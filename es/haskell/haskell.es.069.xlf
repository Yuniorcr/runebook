<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="es" datatype="htmlbody" original="haskell">
    <body>
      <group id="haskell">
        <trans-unit id="2a4e313748880e797d1bcb646d76cb8547d19d57" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-either#t:Either&quot;&gt;Either&lt;/a&gt;&lt;/code&gt; type is sometimes used to represent a value which is either correct or an error; by convention, the &lt;code&gt;&lt;a href=&quot;data-either#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; constructor is used to hold an error value and the &lt;code&gt;&lt;a href=&quot;data-either#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt; constructor is used to hold a correct value (mnemonic: &quot;right&quot; also means &quot;correct&quot;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0e4baff05206c672300bb2b38395a9530159b34" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-either#t:Either&quot;&gt;Either&lt;/a&gt;&lt;/code&gt; type represents values with two possibilities: a value of type &lt;code&gt;&lt;a href=&quot;data-either#t:Either&quot;&gt;Either&lt;/a&gt; a b&lt;/code&gt; is either &lt;code&gt;&lt;a href=&quot;data-either#v:Left&quot;&gt;Left&lt;/a&gt; a&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-either#v:Right&quot;&gt;Right&lt;/a&gt; b&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c8bc066a25dbdc9345dc643976410a0121b2ada" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; class defines equality (&lt;code&gt;&lt;a href=&quot;data-eq#v:-61--61-&quot;&gt;==&lt;/a&gt;&lt;/code&gt;) and inequality (&lt;code&gt;&lt;a href=&quot;data-eq#v:-47--61-&quot;&gt;/=&lt;/a&gt;&lt;/code&gt;). All the basic datatypes exported by the &lt;a href=&quot;prelude&quot;&gt;Prelude&lt;/a&gt; are instances of &lt;code&gt;&lt;a href=&quot;data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; may be derived for any datatype whose constituents are also instances of &lt;code&gt;&lt;a href=&quot;data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69af3900bc4a32d170db2d927f8de7596335e0e4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-foldable#t:Foldable&quot;&gt;Foldable&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-traversable#t:Traversable&quot;&gt;Traversable&lt;/a&gt;&lt;/code&gt; instances traverse the real part first.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5eff372cb874b6edeef6ee4a0a04355990bb5ac2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-foldable#v:find&quot;&gt;find&lt;/a&gt;&lt;/code&gt; function takes a predicate and a structure and returns the leftmost element of the structure matching the predicate, or &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if there is no such element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="168798718c8d67f564d095b7f2c27b1f23db19a7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-foldable#v:product&quot;&gt;product&lt;/a&gt;&lt;/code&gt; function computes the product of the numbers of a structure.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7cca4119f8a53ddfe67d87125c91cc29b78f8689" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-foldable#v:sum&quot;&gt;sum&lt;/a&gt;&lt;/code&gt; function computes the sum of the numbers of a structure.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9699a12c867a28d982d3293073c01ca1c9af29d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-functor#v:fmap&quot;&gt;fmap&lt;/a&gt;&lt;/code&gt; from our &lt;code&gt;&lt;a href=&quot;data-functor#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; instance will ignore &lt;code&gt;&lt;a href=&quot;data-either#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; values, but will apply the supplied function to values contained in a &lt;code&gt;&lt;a href=&quot;data-either#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b77100b25e8a5a0820122925237280bb25f1620c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-functor#v:fmap&quot;&gt;fmap&lt;/a&gt;&lt;/code&gt; function is also available as the infix operator &lt;code&gt;&lt;a href=&quot;data-functor#v:-60--36--62-&quot;&gt;&amp;lt;$&amp;gt;&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75d054c2f2cab23d848c32214fa7c03446c931b9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-functor-const#t:Const&quot;&gt;Const&lt;/a&gt;&lt;/code&gt; functor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91affd44c758dc656c5a465b34202e2474e6eec1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-graph#t:Graph&quot;&gt;Graph&lt;/a&gt;&lt;/code&gt; type is an adjacency list representation of a finite, directed graph with vertices of type &lt;code&gt;Int&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da965f8602a83550c13d9322bdab8f201adad863" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-graph#t:SCC&quot;&gt;SCC&lt;/a&gt;&lt;/code&gt; type represents a &lt;a href=&quot;https://en.wikipedia.org/wiki/Strongly_connected_component&quot;&gt;strongly-connected component&lt;/a&gt; of a graph.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b13b673bb0340c3f60ad133cedd86aba2eebb7ec" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; argument specifies a &lt;em&gt;capability number&lt;/em&gt; (see &lt;code&gt;&lt;a href=&quot;control-concurrent#v:getNumCapabilities&quot;&gt;getNumCapabilities&lt;/a&gt;&lt;/code&gt;). Typically capabilities correspond to physical processors, but the exact behaviour is implementation-dependent. The value passed to &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkOn&quot;&gt;forkOn&lt;/a&gt;&lt;/code&gt; is interpreted modulo the total number of capabilities as returned by &lt;code&gt;&lt;a href=&quot;control-concurrent#v:getNumCapabilities&quot;&gt;getNumCapabilities&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f78d4fb8fef90bc420e0f272097151354016eb5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; argument specifies a &lt;em&gt;capability number&lt;/em&gt; (see &lt;code&gt;&lt;a href=&quot;ghc-conc#v:getNumCapabilities&quot;&gt;getNumCapabilities&lt;/a&gt;&lt;/code&gt;). Typically capabilities correspond to physical processors, but the exact behaviour is implementation-dependent. The value passed to &lt;code&gt;&lt;a href=&quot;ghc-conc#v:forkOn&quot;&gt;forkOn&lt;/a&gt;&lt;/code&gt; is interpreted modulo the total number of capabilities as returned by &lt;code&gt;&lt;a href=&quot;ghc-conc#v:getNumCapabilities&quot;&gt;getNumCapabilities&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="990e9e27ae850a84a5975a64be27bfdd1b9f5808" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; argument specifies a &lt;em&gt;capability number&lt;/em&gt; (see &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:getNumCapabilities&quot;&gt;getNumCapabilities&lt;/a&gt;&lt;/code&gt;). Typically capabilities correspond to physical processors, but the exact behaviour is implementation-dependent. The value passed to &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:forkOn&quot;&gt;forkOn&lt;/a&gt;&lt;/code&gt; is interpreted modulo the total number of capabilities as returned by &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:getNumCapabilities&quot;&gt;getNumCapabilities&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26c55fb3d34eb375b02ebba32fb7b2dd27c91fb0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#t:IntMap&quot;&gt;IntMap&lt;/a&gt; v&lt;/code&gt; type represents a finite map (sometimes called a dictionary) from keys of type &lt;code&gt;Int&lt;/code&gt; to values of type &lt;code&gt;v&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9babf39e61d88f08afacef329c45b58b748886e9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; functions are shared by the lazy and strict modules. Only the choice of merge tactics determines strictness. If you use &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:mapMissing&quot;&gt;mapMissing&lt;/a&gt;&lt;/code&gt; from &lt;a href=&quot;data-map-merge-strict&quot;&gt;Data.Map.Merge.Strict&lt;/a&gt; then the results will be forced before they are inserted. If you use &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:mapMissing&quot;&gt;mapMissing&lt;/a&gt;&lt;/code&gt; from this module then they will not.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="918fcfe1bbabd9b098a3357af6b4c10845874e4e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; functions are shared by the lazy and strict modules. Only the choice of merge tactics determines strictness. If you use &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:mapMissing&quot;&gt;mapMissing&lt;/a&gt;&lt;/code&gt; from this module then the results will be forced before they are inserted. If you use &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:mapMissing&quot;&gt;mapMissing&lt;/a&gt;&lt;/code&gt; from &lt;a href=&quot;data-map-merge-lazy&quot;&gt;Data.Map.Merge.Lazy&lt;/a&gt; then they will not.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e82dc1c0b8d264abe9b7b565b8cd539e1dbf5c5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-intmap-strict#t:IntMap&quot;&gt;IntMap&lt;/a&gt; v&lt;/code&gt; type represents a finite map (sometimes called a dictionary) from key of type &lt;code&gt;Int&lt;/code&gt; to values of type &lt;code&gt;v&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1641ed0171bfd491e6f0e6638191a7945a81dba8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-intmap-strict#t:IntMap&quot;&gt;IntMap&lt;/a&gt;&lt;/code&gt; type is shared between the lazy and strict modules, meaning that the same &lt;code&gt;&lt;a href=&quot;data-intmap-strict#t:IntMap&quot;&gt;IntMap&lt;/a&gt;&lt;/code&gt; value can be passed to functions in both modules. This means that the &lt;code&gt;Functor&lt;/code&gt;, &lt;code&gt;Traversable&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-data#v:Data&quot;&gt;Data&lt;/a&gt;&lt;/code&gt; instances are the same as for the &lt;a href=&quot;data-intmap-lazy&quot;&gt;Data.IntMap.Lazy&lt;/a&gt; module, so if they are used the resulting map may contain suspended values (thunks).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca6e272f4b13fc32e4e87c18c5a09335a1d8e5ca" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#t:IntMap&quot;&gt;IntMap&lt;/a&gt; v&lt;/code&gt; type represents a finite map (sometimes called a dictionary) from key of type &lt;code&gt;Int&lt;/code&gt; to values of type &lt;code&gt;v&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="318814e0b6ddaa927c58b1267d22b77390f5ece2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#t:IntMap&quot;&gt;IntMap&lt;/a&gt;&lt;/code&gt; type is shared between the lazy and strict modules, meaning that the same &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#t:IntMap&quot;&gt;IntMap&lt;/a&gt;&lt;/code&gt; value can be passed to functions in both modules. This means that the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-functor#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-traversable#t:Traversable&quot;&gt;Traversable&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-data#v:Data&quot;&gt;Data&lt;/a&gt;&lt;/code&gt; instances are the same as for the &lt;a href=&quot;data-intmap-lazy&quot;&gt;Data.IntMap.Lazy&lt;/a&gt; module, so if they are used the resulting map may contain suspended values (thunks).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89f7bb2231b7f0bb854265a80968d382d2ee4a72" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-intset#t:IntSet&quot;&gt;IntSet&lt;/a&gt;&lt;/code&gt; type represents a set of elements of type &lt;code&gt;Int&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="235975fc327cbd37e2885a32990dd1d50e6ef2a9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-ix#t:Ix&quot;&gt;Ix&lt;/a&gt;&lt;/code&gt; class is used to map a contiguous subrange of values in a type onto integers. It is used primarily for array indexing (see the array package).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="213033fe7d1bfa8957877f18a3b95df927b829f3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-ix#t:Ix&quot;&gt;Ix&lt;/a&gt;&lt;/code&gt; class is used to map a contiguous subrange of values in type onto integers. It is used primarily for array indexing (see the array package). &lt;code&gt;&lt;a href=&quot;data-ix#t:Ix&quot;&gt;Ix&lt;/a&gt;&lt;/code&gt; uses row-major order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c9726b499ba205a67e8661afa56b3f5e6610bf8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:-92--92-&quot;&gt;\\&lt;/a&gt;&lt;/code&gt; function is list difference (non-associative). In the result of &lt;code&gt;xs&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;data-list#v:-92--92-&quot;&gt;\\&lt;/a&gt;&lt;/code&gt;&lt;code&gt;ys&lt;/code&gt;, the first occurrence of each element of &lt;code&gt;ys&lt;/code&gt; in turn (if any) has been removed from &lt;code&gt;xs&lt;/code&gt;. Thus</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d02a0fb924a1fb516ed51240226d0d6e5d964fd6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:deleteFirstsBy&quot;&gt;deleteFirstsBy&lt;/a&gt;&lt;/code&gt; function takes a predicate and two lists and returns the first list with the first occurrence of each element of the second list removed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d81ce03e6c4879c98e79164e27980ccd4245607" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:dropWhileEnd&quot;&gt;dropWhileEnd&lt;/a&gt;&lt;/code&gt; function drops the largest suffix of a list in which the given predicate holds for all elements. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e6ebb6facf4e5e8507546d0730cd3d8aaa7cdbb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:elemIndex&quot;&gt;elemIndex&lt;/a&gt;&lt;/code&gt; function returns the index of the first element in the given list which is equal (by &lt;code&gt;&lt;a href=&quot;data-eq#v:-61--61-&quot;&gt;==&lt;/a&gt;&lt;/code&gt;) to the query element, or &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if there is no such element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="35376b9066c242bc547e361977a97acd67654b38" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:elemIndices&quot;&gt;elemIndices&lt;/a&gt;&lt;/code&gt; function extends &lt;code&gt;&lt;a href=&quot;data-list#v:elemIndex&quot;&gt;elemIndex&lt;/a&gt;&lt;/code&gt;, by returning the indices of all elements equal to the query element, in ascending order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="777c2200547e9739ba52a7633b954736b9823c38" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:filter&quot;&gt;filter&lt;/a&gt;&lt;/code&gt; function is just &lt;code&gt;&lt;a href=&quot;control-monad#v:mfilter&quot;&gt;mfilter&lt;/a&gt;&lt;/code&gt; specialized to the list monad:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5d8b6f3eaba5030a68bf5d06e480657d33033a0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:find&quot;&gt;find&lt;/a&gt;&lt;/code&gt; function takes a predicate and a structure and returns the leftmost element of the structure matching the predicate, or &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if there is no such element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75b2422f251ce2039aaef3829d2dd5ca0ff38fd1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:findIndex&quot;&gt;findIndex&lt;/a&gt;&lt;/code&gt; function takes a predicate and a list and returns the index of the first element in the list satisfying the predicate, or &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if there is no such element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ea9c7c9c9ab7b6e747e9ebc107dbbfddd67c972" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:findIndices&quot;&gt;findIndices&lt;/a&gt;&lt;/code&gt; function extends &lt;code&gt;&lt;a href=&quot;data-list#v:findIndex&quot;&gt;findIndex&lt;/a&gt;&lt;/code&gt;, by returning the indices of all elements satisfying the predicate, in ascending order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be32822442735a04d54fa68d012d24ba5b89a668" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:genericDrop&quot;&gt;genericDrop&lt;/a&gt;&lt;/code&gt; function is an overloaded version of &lt;code&gt;&lt;a href=&quot;data-list#v:drop&quot;&gt;drop&lt;/a&gt;&lt;/code&gt;, which accepts any &lt;code&gt;&lt;a href=&quot;prelude#t:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt; value as the number of elements to drop.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2812d742b2328d1abd314aebeef9aa75d01e9698" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:genericIndex&quot;&gt;genericIndex&lt;/a&gt;&lt;/code&gt; function is an overloaded version of &lt;code&gt;&lt;a href=&quot;data-list#v:-33--33-&quot;&gt;!!&lt;/a&gt;&lt;/code&gt;, which accepts any &lt;code&gt;&lt;a href=&quot;prelude#t:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt; value as the index.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="737fc86009d880ef7008902e996d5561992367bb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:genericReplicate&quot;&gt;genericReplicate&lt;/a&gt;&lt;/code&gt; function is an overloaded version of &lt;code&gt;&lt;a href=&quot;data-list#v:replicate&quot;&gt;replicate&lt;/a&gt;&lt;/code&gt;, which accepts any &lt;code&gt;&lt;a href=&quot;prelude#t:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt; value as the number of repetitions to make.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3402cafa3322e6ce9bc65e493a0acf1f2884672d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:genericSplitAt&quot;&gt;genericSplitAt&lt;/a&gt;&lt;/code&gt; function is an overloaded version of &lt;code&gt;&lt;a href=&quot;data-list#v:splitAt&quot;&gt;splitAt&lt;/a&gt;&lt;/code&gt;, which accepts any &lt;code&gt;&lt;a href=&quot;prelude#t:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt; value as the position at which to split.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f78c90a57d5cce824e07db93d2197f95aa21a155" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:genericTake&quot;&gt;genericTake&lt;/a&gt;&lt;/code&gt; function is an overloaded version of &lt;code&gt;&lt;a href=&quot;data-list#v:take&quot;&gt;take&lt;/a&gt;&lt;/code&gt;, which accepts any &lt;code&gt;&lt;a href=&quot;prelude#t:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt; value as the number of elements to take.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca4d378c787c5b9b2a06ae77c402a921da5aae20" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:group&quot;&gt;group&lt;/a&gt;&lt;/code&gt; function takes a list and returns a list of lists such that the concatenation of the result is equal to the argument. Moreover, each sublist in the result contains only equal elements. For example,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b33d3992fa75b8c5a7295f072191cef6471b5d58" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:groupBy&quot;&gt;groupBy&lt;/a&gt;&lt;/code&gt; function is the non-overloaded version of &lt;code&gt;&lt;a href=&quot;data-list#v:group&quot;&gt;group&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a2aa0c2fff9d0cd85f48ee4e5c547b1e24beae0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:inits&quot;&gt;inits&lt;/a&gt;&lt;/code&gt; function returns all initial segments of the argument, shortest first. For example,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e70f04ea60546783e780339c103b21d6a6b67467" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:intersect&quot;&gt;intersect&lt;/a&gt;&lt;/code&gt; function takes the list intersection of two lists. For example,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6dc46001b61fa48ad57e1c564b945db378bd949" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:intersectBy&quot;&gt;intersectBy&lt;/a&gt;&lt;/code&gt; function is the non-overloaded version of &lt;code&gt;&lt;a href=&quot;data-list#v:intersect&quot;&gt;intersect&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1446aaefcfea8557eabaae6ea889f9011ff1bbe3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:isInfixOf&quot;&gt;isInfixOf&lt;/a&gt;&lt;/code&gt; function takes two lists and returns &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; iff the first list is contained, wholly and intact, anywhere within the second.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8577e2ac2954a5de0cd6238c09ea92a58c9fb7f8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:isSubsequenceOf&quot;&gt;isSubsequenceOf&lt;/a&gt;&lt;/code&gt; function takes two lists and returns &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; if all the elements of the first list occur, in order, in the second. The elements do not have to occur consecutively.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a40ec49296ced12343a8fd18ca5c49b63aabe04" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:isSuffixOf&quot;&gt;isSuffixOf&lt;/a&gt;&lt;/code&gt; function takes two lists and returns &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; iff the first list is a suffix of the second. The second list must be finite.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b34469353a0b037b47cce6d230cb4cb71110874" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:mapAccumL&quot;&gt;mapAccumL&lt;/a&gt;&lt;/code&gt; function behaves like a combination of &lt;code&gt;&lt;a href=&quot;data-functor#v:fmap&quot;&gt;fmap&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt;; it applies a function to each element of a structure, passing an accumulating parameter from left to right, and returning a final value of this accumulator together with the new structure.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6ebf56806d59584f196cd5d11b8904d0639b1d2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:mapAccumR&quot;&gt;mapAccumR&lt;/a&gt;&lt;/code&gt; function behaves like a combination of &lt;code&gt;&lt;a href=&quot;data-functor#v:fmap&quot;&gt;fmap&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt;; it applies a function to each element of a structure, passing an accumulating parameter from right to left, and returning a final value of this accumulator together with the new structure.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7eb6f6e78bb431c6ad213eb9d21c75fa95dc7ddf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:nubBy&quot;&gt;nubBy&lt;/a&gt;&lt;/code&gt; function behaves just like &lt;code&gt;&lt;a href=&quot;data-list#v:nub&quot;&gt;nub&lt;/a&gt;&lt;/code&gt;, except it uses a user-supplied equality predicate instead of the overloaded &lt;code&gt;&lt;a href=&quot;data-eq#v:-61--61-&quot;&gt;==&lt;/a&gt;&lt;/code&gt; function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc7232b1ebffbebb739ba096d41e32596b9eedb1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:partition&quot;&gt;partition&lt;/a&gt;&lt;/code&gt; function takes a predicate a list and returns the pair of lists of elements which do and do not satisfy the predicate, respectively; i.e.,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b6ed649212daaa5b7d86c6ccef6bf66b085c1db" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:permutations&quot;&gt;permutations&lt;/a&gt;&lt;/code&gt; function returns the list of all permutations of the argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f287658e3d55e31f32fe140091016332ce08537" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:product&quot;&gt;product&lt;/a&gt;&lt;/code&gt; function computes the product of the numbers of a structure.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a463a93b298d3088c6a486752b752d20e4b0de19" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt; function implements a stable sorting algorithm. It is a special case of &lt;code&gt;&lt;a href=&quot;data-list#v:sortBy&quot;&gt;sortBy&lt;/a&gt;&lt;/code&gt;, which allows the programmer to supply their own comparison function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="095b73e07b36153b051dcf74ac3cefd56274581f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:sortBy&quot;&gt;sortBy&lt;/a&gt;&lt;/code&gt; function is the non-overloaded version of &lt;code&gt;&lt;a href=&quot;data-list#v:sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b88e9d47462c1b9615bcd7d7acc05eba51c65b0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:subsequences&quot;&gt;subsequences&lt;/a&gt;&lt;/code&gt; function returns the list of all subsequences of the argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eff98324d1a84c781b046e919d0b375a374d6a43" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:sum&quot;&gt;sum&lt;/a&gt;&lt;/code&gt; function computes the sum of the numbers of a structure.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac33ccd64dfa538162e29b5368275ac3dcab2e9c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:transpose&quot;&gt;transpose&lt;/a&gt;&lt;/code&gt; function transposes the rows and columns of its argument. For example,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21074974ba0da203fdbe3139596e6c3eb82eacd7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; function is a `dual' to &lt;code&gt;&lt;a href=&quot;ghc-list#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt;: while &lt;code&gt;&lt;a href=&quot;ghc-list#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; reduces a list to a summary value, &lt;code&gt;&lt;a href=&quot;data-list#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; builds a list from a seed value. The function takes the element and returns &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if it is done producing the list or returns &lt;code&gt;&lt;a href=&quot;data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt;&lt;code&gt;(a,b)&lt;/code&gt;, in which case, &lt;code&gt;a&lt;/code&gt; is a prepended to the list and &lt;code&gt;b&lt;/code&gt; is used as the next element in a recursive call. For example,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f5fe84f2f6e359d0b958ffdfd50c5ad6c942d08" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:union&quot;&gt;union&lt;/a&gt;&lt;/code&gt; function returns the list union of the two lists. For example,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26aa6f38df9eac11f0ca7ea5149a65e6f035439a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:unionBy&quot;&gt;unionBy&lt;/a&gt;&lt;/code&gt; function is the non-overloaded version of &lt;code&gt;&lt;a href=&quot;data-list#v:union&quot;&gt;union&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3512932a90bda2966b9c4bde2bc99fdaee65977a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:unzip3&quot;&gt;unzip3&lt;/a&gt;&lt;/code&gt; function takes a list of triples and returns three lists, analogous to &lt;code&gt;&lt;a href=&quot;data-list#v:unzip&quot;&gt;unzip&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="465b134f0e0674fc306964e8911a4c8f5a23b544" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:unzip4&quot;&gt;unzip4&lt;/a&gt;&lt;/code&gt; function takes a list of quadruples and returns four lists, analogous to &lt;code&gt;&lt;a href=&quot;data-list#v:unzip&quot;&gt;unzip&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eab7f028c5e43e9c371d7627b6af73045109e75d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:unzip5&quot;&gt;unzip5&lt;/a&gt;&lt;/code&gt; function takes a list of five-tuples and returns five lists, analogous to &lt;code&gt;&lt;a href=&quot;data-list#v:unzip&quot;&gt;unzip&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6934051d9d7b99ca14d42b993760a93edf9a7566" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:unzip6&quot;&gt;unzip6&lt;/a&gt;&lt;/code&gt; function takes a list of six-tuples and returns six lists, analogous to &lt;code&gt;&lt;a href=&quot;data-list#v:unzip&quot;&gt;unzip&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="782bb3363a3945b001878329fde4ebb88dcb6fb0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:unzip7&quot;&gt;unzip7&lt;/a&gt;&lt;/code&gt; function takes a list of seven-tuples and returns seven lists, analogous to &lt;code&gt;&lt;a href=&quot;data-list#v:unzip&quot;&gt;unzip&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17802af283250b2eaa32a2ecb8cb86776774ec7f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:zip4&quot;&gt;zip4&lt;/a&gt;&lt;/code&gt; function takes four lists and returns a list of quadruples, analogous to &lt;code&gt;&lt;a href=&quot;data-list#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt;. It is capable of list fusion, but it is restricted to its first list argument and its resulting list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6bce1a1341ac4dd8d73f1e68a1710aec2a623827" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:zip5&quot;&gt;zip5&lt;/a&gt;&lt;/code&gt; function takes five lists and returns a list of five-tuples, analogous to &lt;code&gt;&lt;a href=&quot;data-list#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt;. It is capable of list fusion, but it is restricted to its first list argument and its resulting list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="451d4d26a4f677865f2a3a707b38064fca9f4083" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:zip6&quot;&gt;zip6&lt;/a&gt;&lt;/code&gt; function takes six lists and returns a list of six-tuples, analogous to &lt;code&gt;&lt;a href=&quot;data-list#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt;. It is capable of list fusion, but it is restricted to its first list argument and its resulting list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c305b363ee1ef77beb2a8edb13e3c0d40953e5c3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:zip7&quot;&gt;zip7&lt;/a&gt;&lt;/code&gt; function takes seven lists and returns a list of seven-tuples, analogous to &lt;code&gt;&lt;a href=&quot;data-list#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt;. It is capable of list fusion, but it is restricted to its first list argument and its resulting list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88779bb5c5d951c52ff0e703df09adaeddb2bdff" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:zipWith3&quot;&gt;zipWith3&lt;/a&gt;&lt;/code&gt; function takes a function which combines three elements, as well as three lists and returns a list of their point-wise combination, analogous to &lt;code&gt;&lt;a href=&quot;data-list#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt;. It is capable of list fusion, but it is restricted to its first list argument and its resulting list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60ff42280ef2fd04c5a52b0fb6c4ced9f80d259b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:zipWith4&quot;&gt;zipWith4&lt;/a&gt;&lt;/code&gt; function takes a function which combines four elements, as well as four lists and returns a list of their point-wise combination, analogous to &lt;code&gt;&lt;a href=&quot;data-list#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt;. It is capable of list fusion, but it is restricted to its first list argument and its resulting list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9fb3b6d637e7bdf78afcd7364064abe2b747412a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:zipWith5&quot;&gt;zipWith5&lt;/a&gt;&lt;/code&gt; function takes a function which combines five elements, as well as five lists and returns a list of their point-wise combination, analogous to &lt;code&gt;&lt;a href=&quot;data-list#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt;. It is capable of list fusion, but it is restricted to its first list argument and its resulting list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76824cb1a5c46cd7971e7c2fd78abbe2f0690804" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:zipWith6&quot;&gt;zipWith6&lt;/a&gt;&lt;/code&gt; function takes a function which combines six elements, as well as six lists and returns a list of their point-wise combination, analogous to &lt;code&gt;&lt;a href=&quot;data-list#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt;. It is capable of list fusion, but it is restricted to its first list argument and its resulting list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2eb2006a61b2e5916c9fa720bb30884f6a6a25d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:zipWith7&quot;&gt;zipWith7&lt;/a&gt;&lt;/code&gt; function takes a function which combines seven elements, as well as seven lists and returns a list of their point-wise combination, analogous to &lt;code&gt;&lt;a href=&quot;data-list#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt;. It is capable of list fusion, but it is restricted to its first list argument and its resulting list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="657b1604cfab08f6d70ddcd61991924e84fa776b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list-nonempty#v:break&quot;&gt;break&lt;/a&gt; p&lt;/code&gt; function is equivalent to &lt;code&gt;&lt;a href=&quot;data-list-nonempty#v:span&quot;&gt;span&lt;/a&gt; (not . p)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee5bf1dc8f489bf35d33f57749203f70974c1fd9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list-nonempty#v:group&quot;&gt;group&lt;/a&gt;&lt;/code&gt; function takes a stream and returns a list of streams such that flattening the resulting list is equal to the argument. Moreover, each stream in the resulting list contains only equal elements. For example, in list notation:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4768abc565ec9f4747dd76eb1df6c5aed894777" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list-nonempty#v:inits&quot;&gt;inits&lt;/a&gt;&lt;/code&gt; function takes a stream &lt;code&gt;xs&lt;/code&gt; and returns all the finite prefixes of &lt;code&gt;xs&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37ce52036d19badb8eb3e19e52707cf238bc5e53" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list-nonempty#v:isPrefixOf&quot;&gt;isPrefixOf&lt;/a&gt;&lt;/code&gt; function returns &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; if the first argument is a prefix of the second.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd9fc5f9beeabe2f81cfc9e7c5d9e742fa36f643" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list-nonempty#v:nub&quot;&gt;nub&lt;/a&gt;&lt;/code&gt; function removes duplicate elements from a list. In particular, it keeps only the first occurrence of each element. (The name &lt;code&gt;&lt;a href=&quot;data-list-nonempty#v:nub&quot;&gt;nub&lt;/a&gt;&lt;/code&gt; means 'essence'.) It is a special case of &lt;code&gt;&lt;a href=&quot;data-list-nonempty#v:nubBy&quot;&gt;nubBy&lt;/a&gt;&lt;/code&gt;, which allows the programmer to supply their own inequality test.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1fd2343fdb59771c84cb4f982c7246f3073f744d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list-nonempty#v:nubBy&quot;&gt;nubBy&lt;/a&gt;&lt;/code&gt; function behaves just like &lt;code&gt;&lt;a href=&quot;data-list-nonempty#v:nub&quot;&gt;nub&lt;/a&gt;&lt;/code&gt;, except it uses a user-supplied equality predicate instead of the overloaded &lt;code&gt;&lt;a href=&quot;data-eq#v:-61--61-&quot;&gt;==&lt;/a&gt;&lt;/code&gt; function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ca6a46f6f161da72b75fa2b96c21284bff63000" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list-nonempty#v:partition&quot;&gt;partition&lt;/a&gt;&lt;/code&gt; function takes a predicate &lt;code&gt;p&lt;/code&gt; and a stream &lt;code&gt;xs&lt;/code&gt;, and returns a pair of lists. The first list corresponds to the elements of &lt;code&gt;xs&lt;/code&gt; for which &lt;code&gt;p&lt;/code&gt; holds; the second corresponds to the elements of &lt;code&gt;xs&lt;/code&gt; for which &lt;code&gt;p&lt;/code&gt; does not hold.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97f203f3e97c286860c77a16076e2c5ba5e804b4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list-nonempty#v:tails&quot;&gt;tails&lt;/a&gt;&lt;/code&gt; function takes a stream &lt;code&gt;xs&lt;/code&gt; and returns all the suffixes of &lt;code&gt;xs&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4b73a8b2bef137b1be451c67193ea1b9dd5278a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list-nonempty#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; function is analogous to &lt;a href=&quot;data-list&quot;&gt;Data.List&lt;/a&gt;'s &lt;code&gt;&lt;a href=&quot;data-list#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; operation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2413c236691707253e811091fb05fcbb1bf0b562" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list-nonempty#v:unzip&quot;&gt;unzip&lt;/a&gt;&lt;/code&gt; function is the inverse of the &lt;code&gt;&lt;a href=&quot;data-list-nonempty#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt; function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce09038022ed3cd501096c0d8a1d4d43ab363fc8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list-nonempty#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt; function takes two streams and returns a stream of corresponding pairs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f10666c8af44a76f18b1cbb206ccc5dbbcf92fdb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list-nonempty#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt; function generalizes &lt;code&gt;&lt;a href=&quot;data-list-nonempty#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt;. Rather than tupling the elements, the elements are combined using the function passed as the first argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16a4e90fc05f7eb7703f8d38de0941aad54680ef" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-map-lazy#t:Map&quot;&gt;Map&lt;/a&gt; k v&lt;/code&gt; type represents a finite map (sometimes called a dictionary) from keys of type &lt;code&gt;k&lt;/code&gt; to values of type &lt;code&gt;v&lt;/code&gt;. A &lt;code&gt;&lt;a href=&quot;data-map-lazy#t:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt; is strict in its keys but lazy in its values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4715b3b3e03f7ebfbfad3ed60bdf0126093bd7fc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; functions are shared by the lazy and strict modules. Only the choice of merge tactics determines strictness. If you use &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:mapMissing&quot;&gt;mapMissing&lt;/a&gt;&lt;/code&gt; from &lt;a href=&quot;data-map-merge-strict&quot;&gt;Data.Map.Merge.Strict&lt;/a&gt; then the results will be forced before they are inserted. If you use &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:mapMissing&quot;&gt;mapMissing&lt;/a&gt;&lt;/code&gt; from this module then they will not.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b155238023fcafca6284b024ed0af65f6650208" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; functions are shared by the lazy and strict modules. Only the choice of merge tactics determines strictness. If you use &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:mapMissing&quot;&gt;mapMissing&lt;/a&gt;&lt;/code&gt; from this module then the results will be forced before they are inserted. If you use &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:mapMissing&quot;&gt;mapMissing&lt;/a&gt;&lt;/code&gt; from &lt;a href=&quot;data-map-merge-lazy&quot;&gt;Data.Map.Merge.Lazy&lt;/a&gt; then they will not.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="662c04a7a17ee001eac580254bab8523defdb93a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-map-strict#t:Map&quot;&gt;Map&lt;/a&gt; k v&lt;/code&gt; type represents a finite map (sometimes called a dictionary) from keys of type &lt;code&gt;k&lt;/code&gt; to values of type &lt;code&gt;v&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12662a5070f04b0d43497ea05090a5128c804911" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-map-strict#t:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt; type is shared between the lazy and strict modules, meaning that the same &lt;code&gt;&lt;a href=&quot;data-map-strict#t:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt; value can be passed to functions in both modules. This means that the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-functor#v:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-traversable#v:Traversable&quot;&gt;Traversable&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-data#v:Data&quot;&gt;Data&lt;/a&gt;&lt;/code&gt; instances are the same as for the &lt;a href=&quot;data-map-lazy&quot;&gt;Data.Map.Lazy&lt;/a&gt; module, so if they are used the resulting maps may contain suspended values (thunks).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f52f3aa69ba900643917df0d514ebfe7065396f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; type encapsulates an optional value. A value of type &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt; a&lt;/code&gt; either contains a value of type &lt;code&gt;a&lt;/code&gt; (represented as &lt;code&gt;&lt;a href=&quot;data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; a&lt;/code&gt;), or it is empty (represented as &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;). Using &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; is a good way to deal with errors or exceptional cases without resorting to drastic measures such as &lt;code&gt;&lt;a href=&quot;prelude#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f185e83cdbbc510aa029904011adfe83bd8b1220" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; type is also a monad. It is a simple kind of error monad, where all errors are represented by &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;. A richer error monad can be built using the &lt;code&gt;&lt;a href=&quot;data-either#v:Either&quot;&gt;Either&lt;/a&gt;&lt;/code&gt; type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8aa4a4fc49f7638e33b52125beaf5389284d595" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-maybe#v:catMaybes&quot;&gt;catMaybes&lt;/a&gt;&lt;/code&gt; function takes a list of &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt;s and returns a list of all the &lt;code&gt;&lt;a href=&quot;data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e3cc1728b8d32e7bd6e33d7191898329f389751" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-maybe#v:fromJust&quot;&gt;fromJust&lt;/a&gt;&lt;/code&gt; function extracts the element out of a &lt;code&gt;&lt;a href=&quot;data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; and throws an error if its argument is &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de4cf2aa7df453c08de73e06681e00b3a9d47c30" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-maybe#v:fromMaybe&quot;&gt;fromMaybe&lt;/a&gt;&lt;/code&gt; function takes a default value and and &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; value. If the &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;, it returns the default values; otherwise, it returns the value contained in the &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a5a7a323996766db88ca0c88884029bb8a6704d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-maybe#v:isJust&quot;&gt;isJust&lt;/a&gt;&lt;/code&gt; function returns &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; iff its argument is of the form &lt;code&gt;Just _&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52483bf501d37712c976868bb9284af355744fac" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-maybe#v:isNothing&quot;&gt;isNothing&lt;/a&gt;&lt;/code&gt; function returns &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; iff its argument is &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eee25b35452f5d1cfc414313539edda0a7120764" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-maybe#v:listToMaybe&quot;&gt;listToMaybe&lt;/a&gt;&lt;/code&gt; function returns &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; on an empty list or &lt;code&gt;&lt;a href=&quot;data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; a&lt;/code&gt; where &lt;code&gt;a&lt;/code&gt; is the first element of the list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9226f117113df71e3656c9e6013ce6d6bf13f04" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-maybe#v:mapMaybe&quot;&gt;mapMaybe&lt;/a&gt;&lt;/code&gt; function is a version of &lt;code&gt;&lt;a href=&quot;ghc-list#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; which can throw out elements. In particular, the functional argument returns something of type &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt; b&lt;/code&gt;. If this is &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;, no element is added on to the result list. If it is &lt;code&gt;&lt;a href=&quot;data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; b&lt;/code&gt;, then &lt;code&gt;b&lt;/code&gt; is included in the result list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85d0ce65a11dff7a785fa5be5465e4febfc6e9a5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-maybe#v:maybe&quot;&gt;maybe&lt;/a&gt;&lt;/code&gt; function takes a default value, a function, and a &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; value. If the &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; value is &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;, the function returns the default value. Otherwise, it applies the function to the value inside the &lt;code&gt;&lt;a href=&quot;data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; and returns the result.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c611fd7648ec2451334092c9df4afb5e19ad5d6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-maybe#v:maybeToList&quot;&gt;maybeToList&lt;/a&gt;&lt;/code&gt; function returns an empty list when given &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; or a singleton list when given &lt;code&gt;&lt;a href=&quot;data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="795a9f9783333374a76593a231e073666138ebda" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-monoid#t:Sum&quot;&gt;Sum&lt;/a&gt;&lt;/code&gt; monoid is defined by the numerical addition operator and `0` as neutral element:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9acde1593d8ad750d5ecbfa06d97960b56f05f43" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-ord#t:Down&quot;&gt;Down&lt;/a&gt;&lt;/code&gt; type allows you to reverse sort order conveniently. A value of type &lt;code&gt;&lt;a href=&quot;data-ord#t:Down&quot;&gt;Down&lt;/a&gt; a&lt;/code&gt; contains a value of type &lt;code&gt;a&lt;/code&gt; (represented as &lt;code&gt;&lt;a href=&quot;data-ord#t:Down&quot;&gt;Down&lt;/a&gt; a&lt;/code&gt;). If &lt;code&gt;a&lt;/code&gt; has an &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; instance associated with it then comparing two values thus wrapped will give you the opposite of their normal sort order. This is particularly useful when sorting in generalised list comprehensions, as in: &lt;code&gt;then sortWith by &lt;a href=&quot;data-ord#t:Down&quot;&gt;Down&lt;/a&gt; x&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d480aba9ca8f558b9bab4a7470c617258413273" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; class is used for totally ordered datatypes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9743e6ce1ccca02d84b310e0c03e3b64b006ece2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-semigroup#t:Min&quot;&gt;Min&lt;/a&gt;&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;data-semigroup#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt; instance for &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; is defined to always pick the smaller number: &amp;gt;&amp;gt;&amp;gt; Min 1 &amp;lt;&amp;gt; Min 2 &amp;lt;&amp;gt; Min 3 &amp;lt;&amp;gt; Min 4 :: Min Int Min {getMin = 1}</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d415a40b49223b304b71b398a708eb25f07e68ae" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt; a&lt;/code&gt; type represents a finite sequence of values of type &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13ce1c3f2600f3e2f50834c056ec8fa70e4eab37" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-set#t:Set&quot;&gt;Set&lt;/a&gt; e&lt;/code&gt; type represents a set of elements of type &lt;code&gt;e&lt;/code&gt;. Most operations require that &lt;code&gt;e&lt;/code&gt; be an instance of the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; class. A &lt;code&gt;&lt;a href=&quot;data-set#t:Set&quot;&gt;Set&lt;/a&gt;&lt;/code&gt; is strict in its elements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8881e3fb681798d7bf981e8e9d449509800437b9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; type is implemented using arrays that are not guaranteed to have a fixed address in the Haskell heap. All communication with native code must thus occur by copying data back and forth.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d9c2733ed15ccf0d235e8a6b100f93fe8426bb4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; type's internal representation is UTF-16, using the platform's native endianness. This makes copied data suitable for use with native libraries that use a similar representation, such as ICU. To interoperate with native libraries that use different internal representations, such as UTF-8 or UTF-32, consider using the functions in the &lt;code&gt;&lt;a href=&quot;data-text#v:Encoding&quot;&gt;Encoding&lt;/a&gt;&lt;/code&gt; module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="161f7f591d2f56a095b5a6738fe11dc948f83c20" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-text#v:mapAccumR&quot;&gt;mapAccumR&lt;/a&gt;&lt;/code&gt; function behaves like a combination of &lt;code&gt;&lt;a href=&quot;data-text#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; and a strict &lt;code&gt;&lt;a href=&quot;data-text#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt;; it applies a function to each element of a &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;, passing an accumulating parameter from right to left, and returning a final value of this accumulator together with the new &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;. Performs replacement on invalid scalar values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5823a0c22eaaaf0e0d80ffbc2bbde448d239204" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-text-array#t:Array&quot;&gt;Array&lt;/a&gt;&lt;/code&gt; constructor is exposed since &lt;code&gt;text-1.1.1.3&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d764c078d54b6747b82b1fb65bc90cbfdc33a9d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-text-array#t:MArray&quot;&gt;MArray&lt;/a&gt;&lt;/code&gt; constructor is exposed since &lt;code&gt;text-1.1.1.3&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e4b96f6778d5f3fbaa9eb0f8c186a8f261148c7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-text-encoding#v:streamDecodeUtf8&quot;&gt;streamDecodeUtf8&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-text-encoding#v:streamDecodeUtf8With&quot;&gt;streamDecodeUtf8With&lt;/a&gt;&lt;/code&gt; functions accept a &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; that represents a possibly incomplete input (e.g. a packet from a network stream) that may not end on a UTF-8 boundary.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8de0eaf04140ba7158dddc8d0be85ce0ccccc4a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-text-internal-fusion#v:findIndex&quot;&gt;findIndex&lt;/a&gt;&lt;/code&gt; function takes a predicate and a stream and returns the index of the first element in the stream satisfying the predicate.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf384e38dd6fd9c82df77df8975246cdedc34701" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-text-internal-fusion-common#v:findIndexI&quot;&gt;findIndexI&lt;/a&gt;&lt;/code&gt; function takes a predicate and a stream and returns the index of the first element in the stream satisfying the predicate.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee94ea37dfd7850ffc9a486e3dd92c091c5cbec7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-text-internal-fusion-size#t:Size&quot;&gt;Size&lt;/a&gt;&lt;/code&gt; of &lt;code&gt;n&lt;/code&gt; code points.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66da5760dab680492ae3a48dc3a35550be6dc4df" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-text-internal-fusion-size#t:Size&quot;&gt;Size&lt;/a&gt;&lt;/code&gt; of the given code point.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a75e1f66c9b008e7ba6ff420a20501b8af837a38" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-text-io#v:interact&quot;&gt;interact&lt;/a&gt;&lt;/code&gt; function takes a function of type &lt;code&gt;Text -&amp;gt; Text&lt;/code&gt; as its argument. The entire input from the standard input device is passed to this function as its argument, and the resulting string is output on the standard output device.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b417d4f678288b71d35accb0f99175761f3e1e07" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-text-io#v:readFile&quot;&gt;readFile&lt;/a&gt;&lt;/code&gt; function reads a file and returns the contents of the file as a string. The entire file is read strictly, as with &lt;code&gt;&lt;a href=&quot;data-text-io#v:getContents&quot;&gt;getContents&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68615baf25b8a5dabb727f9a05e4f69c95e23d72" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:group&quot;&gt;group&lt;/a&gt;&lt;/code&gt; function takes a &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; and returns a list of &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;s such that the concatenation of the result is equal to the argument. Moreover, each sublist in the result contains only equal elements. For example,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="448dca813f1fb16bef7c7de2c7c5fae5b0a093ca" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:groupBy&quot;&gt;groupBy&lt;/a&gt;&lt;/code&gt; function is the non-overloaded version of &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:group&quot;&gt;group&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bea18231a8f3d26a5fe0119fe32dfbafea55d681" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:mapAccumR&quot;&gt;mapAccumR&lt;/a&gt;&lt;/code&gt; function behaves like a combination of &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; and a strict &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt;; it applies a function to each element of a &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;, passing an accumulating parameter from right to left, and returning a final value of this accumulator together with the new &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;. Performs replacement on invalid scalar values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a76ea813e8c21de4f80acb76647bc2ec24349f1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-text-lazy-io#v:interact&quot;&gt;interact&lt;/a&gt;&lt;/code&gt; function takes a function of type &lt;code&gt;Text -&amp;gt; Text&lt;/code&gt; as its argument. The entire input from the standard input device is passed (lazily) to this function as its argument, and the resulting string is output on the standard output device.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f4eb06ba150dfea2048571ec4f24a657175124e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-traversable#v:mapAccumL&quot;&gt;mapAccumL&lt;/a&gt;&lt;/code&gt; function behaves like a combination of &lt;code&gt;&lt;a href=&quot;data-functor#v:fmap&quot;&gt;fmap&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt;; it applies a function to each element of a structure, passing an accumulating parameter from left to right, and returning a final value of this accumulator together with the new structure.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d943aed90068948d72a0d5858ba1b7944e9decb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-traversable#v:mapAccumR&quot;&gt;mapAccumR&lt;/a&gt;&lt;/code&gt; function behaves like a combination of &lt;code&gt;&lt;a href=&quot;data-functor#v:fmap&quot;&gt;fmap&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt;; it applies a function to each element of a structure, passing an accumulating parameter from right to left, and returning a final value of this accumulator together with the new structure.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a5f7c77832ccee5dc8f444bf10cb820686c5a90" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-tree#t:Forest&quot;&gt;Forest&lt;/a&gt; a&lt;/code&gt; type represents a forest of &lt;code&gt;&lt;a href=&quot;data-tree#t:Tree&quot;&gt;Tree&lt;/a&gt; a&lt;/code&gt;s.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4dde0b10b0f433f8901cc6d31ae5f25b888075e7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-tree#t:Tree&quot;&gt;Tree&lt;/a&gt; a&lt;/code&gt; type represents a lazy, possibly infinite, multi-way tree (also known as a &lt;em&gt;rose tree&lt;/em&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8007180e7dc5a974039c84bcb837081428c5c9da" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-typeable#t:Typeable&quot;&gt;Typeable&lt;/a&gt;&lt;/code&gt; class reifies types to some extent by associating type representations to types. These type representations can be compared, and one can in turn define a type-safe cast operation. To this end, an unsafe cast is guarded by a test for type (representation) equivalence. The module &lt;a href=&quot;data-dynamic&quot;&gt;Data.Dynamic&lt;/a&gt; uses Typeable for an implementation of dynamics. The module &lt;a href=&quot;data-data&quot;&gt;Data.Data&lt;/a&gt; uses Typeable and type-safe cast (but not dynamics) to support the &quot;Scrap your boilerplate&quot; style of generic programming.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d043229d0aba230c46b619f1751b3e8e83785014" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;debug-trace#v:trace&quot;&gt;trace&lt;/a&gt;&lt;/code&gt; function outputs the trace message given as its first argument, before returning the second argument as its result.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="140721e416adc2345c2c2facce319e06db5e38ae" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;debug-trace#v:trace&quot;&gt;trace&lt;/a&gt;&lt;/code&gt; function should &lt;em&gt;only&lt;/em&gt; be used for debugging, or for monitoring execution. The function is not referentially transparent: its type indicates that it is a pure function but it has the side effect of outputting the trace message.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="605bec91baff60047b066d4e1ac30c1faa493023" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;debug-trace#v:trace&quot;&gt;trace&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;debug-trace#v:traceShow&quot;&gt;traceShow&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;debug-trace#v:traceIO&quot;&gt;traceIO&lt;/a&gt;&lt;/code&gt; functions print messages to an output stream. They are intended for &quot;printf debugging&quot;, that is: tracing the flow of execution and printing interesting values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a88df11e31fce4c7204e009946e93a681d719b46" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;debug-trace#v:traceEvent&quot;&gt;traceEvent&lt;/a&gt;&lt;/code&gt; function behaves like &lt;code&gt;&lt;a href=&quot;debug-trace#v:trace&quot;&gt;trace&lt;/a&gt;&lt;/code&gt; with the difference that the message is emitted to the eventlog, if eventlog profiling is available and enabled at runtime.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49d4ea0d4504acbc4d1aca32b1293ddbe4063444" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;debug-trace#v:traceEventIO&quot;&gt;traceEventIO&lt;/a&gt;&lt;/code&gt; function emits a message to the eventlog, if eventlog profiling is available and enabled at runtime.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3a4eae130c3225cefb9efb90d8be9b83b521fab" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;debug-trace#v:traceIO&quot;&gt;traceIO&lt;/a&gt;&lt;/code&gt; function outputs the trace message from the IO monad. This sequences the output with respect to other IO actions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d97ccf67a57dfd415eb74011cb7d1b6a77ff69bc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;debug-trace#v:traceMarker&quot;&gt;traceMarker&lt;/a&gt;&lt;/code&gt; function emits a marker to the eventlog, if eventlog profiling is available and enabled at runtime. The &lt;code&gt;String&lt;/code&gt; is the name of the marker. The name is just used in the profiling tools to help you keep clear which marker is which.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa771e47c5e0835b60259fdc80c34fd55cfa3c38" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;debug-trace#v:traceMarkerIO&quot;&gt;traceMarkerIO&lt;/a&gt;&lt;/code&gt; function emits a marker to the eventlog, if eventlog profiling is available and enabled at runtime.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65a90e57ddce6b3095e1eb053172e0add59b8b87" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; is parameterised in the same way as &lt;code&gt;&lt;a href=&quot;foreign-ptr#t:Ptr&quot;&gt;Ptr&lt;/a&gt;&lt;/code&gt;. The type argument of &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; should normally be an instance of class &lt;code&gt;&lt;a href=&quot;foreign-storable#t:Storable&quot;&gt;Storable&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47f829e4b12e19d9b1b9c867b798c3d41bfa7cc6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; type and operations. This module is part of the Foreign Function Interface (FFI) and will usually be imported via the &lt;a href=&quot;foreign&quot;&gt;Foreign&lt;/a&gt; module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4fea14f33688c221cc4b82a2e64457f2c1daf4c4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; is parameterised in the same way as &lt;code&gt;&lt;a href=&quot;foreign-ptr#t:Ptr&quot;&gt;Ptr&lt;/a&gt;&lt;/code&gt;. The type argument of &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; should normally be an instance of class &lt;code&gt;&lt;a href=&quot;foreign-storable#t:Storable&quot;&gt;Storable&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46ba37e75544b376d91afd7d94cc178e3d4edd60" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; type and operations. This module is part of the Foreign Function Interface (FFI) and will usually be imported via the &lt;a href=&quot;foreign&quot;&gt;Foreign&lt;/a&gt; module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05673b670d8de49659d7ca54ef48d3649d1c6cc9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;foreign-ptr#v:castPtr&quot;&gt;castPtr&lt;/a&gt;&lt;/code&gt; function casts a pointer from one type to another.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4a69e977af812c4c1901ff0ace0b2bb4a9d9dd0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-arr#t:Ix&quot;&gt;Ix&lt;/a&gt;&lt;/code&gt; class is used to map a contiguous subrange of values in a type onto integers. It is used primarily for array indexing (see the array package).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e348453b816674bfaf92baa8a27076b87c3aa9bb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-arr#v:accumArray&quot;&gt;accumArray&lt;/a&gt;&lt;/code&gt; function deals with repeated indices in the association list using an &lt;em&gt;accumulating function&lt;/em&gt; which combines the values of associations with the same index.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7873c676664db92e7ab0f598d2d48e71762b5260" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-base#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; class defines the basic operations over a &lt;em&gt;monad&lt;/em&gt;, a concept from a branch of mathematics known as &lt;em&gt;category theory&lt;/em&gt;. From the perspective of a Haskell programmer, however, it is best to think of a monad as an &lt;em&gt;abstract datatype&lt;/em&gt; of actions. Haskell's &lt;code&gt;do&lt;/code&gt; expressions provide a convenient syntax for writing monadic expressions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee50bbd3c67bae7f49e378336e2e433f6106ccf0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-base#v:join&quot;&gt;join&lt;/a&gt;&lt;/code&gt; function is the conventional monad join operator. It is used to remove one level of monadic structure, projecting its bound argument into the outer level.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27aabb232ca4b09ca8d220a432dd7f16df59a935" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-conc#v:yield&quot;&gt;yield&lt;/a&gt;&lt;/code&gt; action allows (forces, in a co-operative multitasking implementation) a context-switch to any other currently runnable threads (if any), and is occasionally useful when implementing concurrency abstractions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a132846a2c0d7c2c3007c1d18b85a3d84e2a398" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:yield&quot;&gt;yield&lt;/a&gt;&lt;/code&gt; action allows (forces, in a co-operative multitasking implementation) a context-switch to any other currently runnable threads (if any), and is occasionally useful when implementing concurrency abstractions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9dd95524ffc61573839150d5ca8d3bbeafd0b7a6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-enum#t:Bounded&quot;&gt;Bounded&lt;/a&gt;&lt;/code&gt; class is used to name the upper and lower limits of a type. &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; is not a superclass of &lt;code&gt;&lt;a href=&quot;ghc-enum#t:Bounded&quot;&gt;Bounded&lt;/a&gt;&lt;/code&gt; since types that are not totally ordered may also have upper and lower bounds.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e4a35f48d43f24d53c5bb16b69fba56be493a94" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-enum#t:Bounded&quot;&gt;Bounded&lt;/a&gt;&lt;/code&gt; class may be derived for any enumeration type; &lt;code&gt;&lt;a href=&quot;ghc-enum#v:minBound&quot;&gt;minBound&lt;/a&gt;&lt;/code&gt; is the first constructor listed in the &lt;code&gt;data&lt;/code&gt; declaration and &lt;code&gt;&lt;a href=&quot;ghc-enum#v:maxBound&quot;&gt;maxBound&lt;/a&gt;&lt;/code&gt; is the last. &lt;code&gt;&lt;a href=&quot;ghc-enum#t:Bounded&quot;&gt;Bounded&lt;/a&gt;&lt;/code&gt; may also be derived for single-constructor datatypes whose constituent types are in &lt;code&gt;&lt;a href=&quot;ghc-enum#t:Bounded&quot;&gt;Bounded&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="674d2d4d75029f825bd270a8d08697ebd9b70ba6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-enum#t:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ghc-enum#t:Bounded&quot;&gt;Bounded&lt;/a&gt;&lt;/code&gt; classes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5cd6d00d90b1e061059918ba18205b11c14c002" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Down&quot;&gt;Down&lt;/a&gt;&lt;/code&gt; type allows you to reverse sort order conveniently. A value of type &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Down&quot;&gt;Down&lt;/a&gt; a&lt;/code&gt; contains a value of type &lt;code&gt;a&lt;/code&gt; (represented as &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Down&quot;&gt;Down&lt;/a&gt; a&lt;/code&gt;). If &lt;code&gt;a&lt;/code&gt; has an &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; instance associated with it then comparing two values thus wrapped will give you the opposite of their normal sort order. This is particularly useful when sorting in generalised list comprehensions, as in: &lt;code&gt;then sortWith by &lt;a href=&quot;ghc-exts#t:Down&quot;&gt;Down&lt;/a&gt; x&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf4c3fac24e8ca008ba612ac6b40c0fcd012f0f0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-exts#t:IsList&quot;&gt;IsList&lt;/a&gt;&lt;/code&gt; class and its methods are intended to be used in conjunction with the OverloadedLists extension.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7ba5830092cef4d84647e79c69131dbc7adc059" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Item&quot;&gt;Item&lt;/a&gt;&lt;/code&gt; type function returns the type of items of the structure &lt;code&gt;l&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f84b47ee1d124d1ca79a226e83d25027b22134b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-exts#v:fromList&quot;&gt;fromList&lt;/a&gt;&lt;/code&gt; function constructs the structure &lt;code&gt;l&lt;/code&gt; from the given list of &lt;code&gt;Item l&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ceee73322b5e0bdd5f3091f55d6384a70d17944b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-exts#v:fromListN&quot;&gt;fromListN&lt;/a&gt;&lt;/code&gt; function takes the input list's length as a hint. Its behaviour should be equivalent to &lt;code&gt;&lt;a href=&quot;ghc-exts#v:fromList&quot;&gt;fromList&lt;/a&gt;&lt;/code&gt;. The hint can be used to construct the structure &lt;code&gt;l&lt;/code&gt; more efficiently compared to &lt;code&gt;&lt;a href=&quot;ghc-exts#v:fromList&quot;&gt;fromList&lt;/a&gt;&lt;/code&gt;. If the given hint does not equal to the input list's length the behaviour of &lt;code&gt;&lt;a href=&quot;ghc-exts#v:fromListN&quot;&gt;fromListN&lt;/a&gt;&lt;/code&gt; is not specified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5c04c12c048d0307d00092d987715f0d989db28" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-exts#v:groupWith&quot;&gt;groupWith&lt;/a&gt;&lt;/code&gt; function uses the user supplied function which projects an element out of every list element in order to first sort the input list and then to form groups by equality on these projected elements</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="695facc226b98a2fdc94f961971c4ce121f69e9b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-exts#v:lazy&quot;&gt;lazy&lt;/a&gt;&lt;/code&gt; function restrains strictness analysis a little. The call &lt;code&gt;lazy e&lt;/code&gt; means the same as &lt;code&gt;e&lt;/code&gt;, but &lt;code&gt;&lt;a href=&quot;ghc-exts#v:lazy&quot;&gt;lazy&lt;/a&gt;&lt;/code&gt; has a magical property so far as strictness analysis is concerned: it is lazy in its first argument, even though its semantics is strict. After strictness analysis has run, calls to &lt;code&gt;&lt;a href=&quot;ghc-exts#v:lazy&quot;&gt;lazy&lt;/a&gt;&lt;/code&gt; are inlined to be the identity function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c62e040021cb66d2ce6289579ad247f811fcaf97" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-exts#v:oneShot&quot;&gt;oneShot&lt;/a&gt;&lt;/code&gt; function can be used to give a hint to the compiler that its argument will be called at most once, which may (or may not) enable certain optimizations. It can be useful to improve the performance of code in continuation passing style.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="738f70f90664f23041407e78e7481ca578a61fb7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-exts#v:sortWith&quot;&gt;sortWith&lt;/a&gt;&lt;/code&gt; function sorts a list of elements using the user supplied function to project something out of each element</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8c0871b5b6f8b978adbdfa4a64b81796ab60e0f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-exts#v:toList&quot;&gt;toList&lt;/a&gt;&lt;/code&gt; function extracts a list of &lt;code&gt;Item l&lt;/code&gt; from the structure &lt;code&gt;l&lt;/code&gt;. It should satisfy fromList . toList = id.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b18ac779aba3ac796c0284e4d2cc3bb7c69a9f44" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; is parameterised in the same way as &lt;code&gt;&lt;a href=&quot;foreign-ptr#t:Ptr&quot;&gt;Ptr&lt;/a&gt;&lt;/code&gt;. The type argument of &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; should normally be an instance of class &lt;code&gt;&lt;a href=&quot;foreign-storable#t:Storable&quot;&gt;Storable&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5c813e0c538449c8b967f68e862c925ce84f9ce" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-generics#t:C1&quot;&gt;C1&lt;/a&gt; ('MetaCons &quot;Leaf&quot; 'PrefixI 'False)&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ghc-generics#t:C1&quot;&gt;C1&lt;/a&gt; ('MetaCons &quot;Node&quot; 'PrefixI 'False)&lt;/code&gt; invocations indicate that the enclosed part is the representation of the first and second constructor of datatype &lt;code&gt;Tree&lt;/code&gt;, respectively. Here, the meta-information regarding constructor names, fixity and whether it has named fields or not is encoded at the type level. The &lt;code&gt;'MetaCons&lt;/code&gt; type is also an instance of the type class &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Constructor&quot;&gt;Constructor&lt;/a&gt;&lt;/code&gt;. This type class can be used to obtain information about the constructor at the value level.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b3758b0106cdc9eb50e8251878d12e347f33b9e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-generics#t:D1&quot;&gt;D1&lt;/a&gt; ('MetaData &quot;Tree&quot; &quot;Main&quot; &quot;package-name&quot; 'False)&lt;/code&gt; tag indicates that the enclosed part is the representation of the datatype &lt;code&gt;Tree&lt;/code&gt;. Again, the meta-information is encoded at the type level. The &lt;code&gt;'MetaData&lt;/code&gt; type is an instance of class &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Datatype&quot;&gt;Datatype&lt;/a&gt;&lt;/code&gt;, which can be used to obtain the name of a datatype, the module it has been defined in, the package it is located under, and whether it has been defined using &lt;code&gt;data&lt;/code&gt; or &lt;code&gt;newtype&lt;/code&gt; at the value level.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="490133c0313c9ba8b7db7fbe7e0fe5b2bf18b53d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Generic1&quot;&gt;Generic1&lt;/a&gt;&lt;/code&gt; class can be generalized to range over types of kind &lt;code&gt;k -&amp;gt; *&lt;/code&gt;, for any kind &lt;code&gt;k&lt;/code&gt;. To do so, derive a &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Generic1&quot;&gt;Generic1&lt;/a&gt;&lt;/code&gt; instance with the &lt;code&gt;PolyKinds&lt;/code&gt; extension enabled. For example, the declaration</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b51e7af78f64d86aed93f2c4d635092dabfbb762" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-generics#t:S1&quot;&gt;S1&lt;/a&gt; ('MetaSel 'Nothing 'NoSourceUnpackedness 'NoSourceStrictness
      'DecidedLazy)&lt;/code&gt; tag indicates several things. The &lt;code&gt;'Nothing&lt;/code&gt; indicates that there is no record field selector associated with this field of the constructor (if there were, it would have been marked &lt;code&gt;'Just
      &quot;recordName&quot;&lt;/code&gt; instead). The other types contain meta-information on the field's strictness:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0cdba7fd39b9182aef4d3fd8dd460a16d152145" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-integer#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ccb84e64bf7ed15245460804350d5f1cb2e76cd3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-io-encoding-failure#t:CodingFailureMode&quot;&gt;CodingFailureMode&lt;/a&gt;&lt;/code&gt; is used to construct &lt;code&gt;&lt;a href=&quot;system-io#v:TextEncoding&quot;&gt;TextEncoding&lt;/a&gt;&lt;/code&gt;s, and specifies how they handle illegal sequences.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="727269e258ca0cc1f5b84b187e061106f48b55ba" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-list#v:product&quot;&gt;product&lt;/a&gt;&lt;/code&gt; function computes the product of a finite list of numbers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29f4142ef18f41223155d901b10e8d9efcecd6fc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-list#v:sum&quot;&gt;sum&lt;/a&gt;&lt;/code&gt; function computes the sum of a finite list of numbers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="791089d56d61f4d3b56178eb7352f6df80bab567" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-list#v:unzip3&quot;&gt;unzip3&lt;/a&gt;&lt;/code&gt; function takes a list of triples and returns three lists, analogous to &lt;code&gt;&lt;a href=&quot;ghc-list#v:unzip&quot;&gt;unzip&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7bb018b60fccf9ba007b71e9eb3d8a718941c0f4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-list#v:zipWith3&quot;&gt;zipWith3&lt;/a&gt;&lt;/code&gt; function takes a function which combines three elements, as well as three lists and returns a list of their point-wise combination, analogous to &lt;code&gt;&lt;a href=&quot;ghc-list#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt;. It is capable of list fusion, but it is restricted to its first list argument and its resulting list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24f96e687e4620b9109ecaf114edba80a1baa66c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; type encapsulates an optional value. A value of type &lt;code&gt;&lt;a href=&quot;ghc-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt; a&lt;/code&gt; either contains a value of type &lt;code&gt;a&lt;/code&gt; (represented as &lt;code&gt;&lt;a href=&quot;ghc-maybe#v:Just&quot;&gt;Just&lt;/a&gt; a&lt;/code&gt;), or it is empty (represented as &lt;code&gt;&lt;a href=&quot;ghc-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;). Using &lt;code&gt;&lt;a href=&quot;ghc-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; is a good way to deal with errors or exceptional cases without resorting to drastic measures such as &lt;code&gt;&lt;a href=&quot;prelude#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="266e593abd43191340f9b33fd8e15a10e0dc922a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; type is also a monad. It is a simple kind of error monad, where all errors are represented by &lt;code&gt;&lt;a href=&quot;ghc-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;. A richer error monad can be built using the &lt;code&gt;&lt;a href=&quot;data-either#v:Either&quot;&gt;Either&lt;/a&gt;&lt;/code&gt; type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b66270e05d2350973bd17982c61ae01a11e0a3f8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-num#t:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt; class and the &lt;code&gt;&lt;a href=&quot;prelude#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d90a8339ada736c69e4569a04518d30718bf0396" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:-92--92-&quot;&gt;\\&lt;/a&gt;&lt;/code&gt; function is list difference (non-associative). In the result of &lt;code&gt;xs&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:-92--92-&quot;&gt;\\&lt;/a&gt;&lt;/code&gt;&lt;code&gt;ys&lt;/code&gt;, the first occurrence of each element of &lt;code&gt;ys&lt;/code&gt; in turn (if any) has been removed from &lt;code&gt;xs&lt;/code&gt;. Thus</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f790bce52b575010739edf6cb02aa96c2885cb9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:deleteFirstsBy&quot;&gt;deleteFirstsBy&lt;/a&gt;&lt;/code&gt; function takes a predicate and two lists and returns the first list with the first occurrence of each element of the second list removed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a978c3a6eaa51a8f531e3682bd2d367abf6607ec" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:dropWhileEnd&quot;&gt;dropWhileEnd&lt;/a&gt;&lt;/code&gt; function drops the largest suffix of a list in which the given predicate holds for all elements. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="109bdc9435b830725cf189c556de56387a5634f5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:elemIndex&quot;&gt;elemIndex&lt;/a&gt;&lt;/code&gt; function returns the index of the first element in the given list which is equal (by &lt;code&gt;&lt;a href=&quot;data-eq#v:-61--61-&quot;&gt;==&lt;/a&gt;&lt;/code&gt;) to the query element, or &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if there is no such element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fadb3e5498f5526f3f541154cc26a34805337369" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:elemIndices&quot;&gt;elemIndices&lt;/a&gt;&lt;/code&gt; function extends &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:elemIndex&quot;&gt;elemIndex&lt;/a&gt;&lt;/code&gt;, by returning the indices of all elements equal to the query element, in ascending order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6568db6f34d6f7a7bf8a446041bb3489740f3067" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:find&quot;&gt;find&lt;/a&gt;&lt;/code&gt; function takes a predicate and a list and returns the first element in the list matching the predicate, or &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if there is no such element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4275cc9b36aa0e4769199e754686defa1594e4b4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:findIndex&quot;&gt;findIndex&lt;/a&gt;&lt;/code&gt; function takes a predicate and a list and returns the index of the first element in the list satisfying the predicate, or &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if there is no such element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f76c76695266af5e321e89b84f46bb9a822c35f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:findIndices&quot;&gt;findIndices&lt;/a&gt;&lt;/code&gt; function extends &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:findIndex&quot;&gt;findIndex&lt;/a&gt;&lt;/code&gt;, by returning the indices of all elements satisfying the predicate, in ascending order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="305fac941a1cc5c29fd70cdde5362cbcac036635" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:genericDrop&quot;&gt;genericDrop&lt;/a&gt;&lt;/code&gt; function is an overloaded version of &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:drop&quot;&gt;drop&lt;/a&gt;&lt;/code&gt;, which accepts any &lt;code&gt;&lt;a href=&quot;prelude#t:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt; value as the number of elements to drop.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="acf544a13e18ba4358a78c184967bf2f876a1aec" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:genericIndex&quot;&gt;genericIndex&lt;/a&gt;&lt;/code&gt; function is an overloaded version of &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:-33--33-&quot;&gt;!!&lt;/a&gt;&lt;/code&gt;, which accepts any &lt;code&gt;&lt;a href=&quot;prelude#t:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt; value as the index.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="813efa98177dcd58489481e0cb89e0133d9e87e0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:genericReplicate&quot;&gt;genericReplicate&lt;/a&gt;&lt;/code&gt; function is an overloaded version of &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:replicate&quot;&gt;replicate&lt;/a&gt;&lt;/code&gt;, which accepts any &lt;code&gt;&lt;a href=&quot;prelude#t:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt; value as the number of repetitions to make.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7d4ee3930a7434ca7c403b4565de9be9be21b9a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:genericSplitAt&quot;&gt;genericSplitAt&lt;/a&gt;&lt;/code&gt; function is an overloaded version of &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:splitAt&quot;&gt;splitAt&lt;/a&gt;&lt;/code&gt;, which accepts any &lt;code&gt;&lt;a href=&quot;prelude#t:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt; value as the position at which to split.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4afafa2336fcae4601a2eaca8e96fec05a60b92" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:genericTake&quot;&gt;genericTake&lt;/a&gt;&lt;/code&gt; function is an overloaded version of &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:take&quot;&gt;take&lt;/a&gt;&lt;/code&gt;, which accepts any &lt;code&gt;&lt;a href=&quot;prelude#t:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt; value as the number of elements to take.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4f6a5e91131c42f6af8de505ab848b2b5f93891" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:group&quot;&gt;group&lt;/a&gt;&lt;/code&gt; function takes a list and returns a list of lists such that the concatenation of the result is equal to the argument. Moreover, each sublist in the result contains only equal elements. For example,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d100c0bef6b2c8b32f44a08a7e7eacb8db8f8cbc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:groupBy&quot;&gt;groupBy&lt;/a&gt;&lt;/code&gt; function is the non-overloaded version of &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:group&quot;&gt;group&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34b65659a51ccdb8baad87c00cd32d74ef9d403b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:inits&quot;&gt;inits&lt;/a&gt;&lt;/code&gt; function returns all initial segments of the argument, shortest first. For example,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="144853d03169fd7769ada44b12eba567928f0591" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:intersect&quot;&gt;intersect&lt;/a&gt;&lt;/code&gt; function takes the list intersection of two lists. For example,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="605c4315b576beab0a53cad6a48c3adba1b2f451" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:intersectBy&quot;&gt;intersectBy&lt;/a&gt;&lt;/code&gt; function is the non-overloaded version of &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:intersect&quot;&gt;intersect&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="abf262d8a1cc937359d5c3c8f6075d27f69eb8ea" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:isInfixOf&quot;&gt;isInfixOf&lt;/a&gt;&lt;/code&gt; function takes two lists and returns &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; iff the first list is contained, wholly and intact, anywhere within the second.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88d273a08a3e06000e98c2629e1e60ff60ea1336" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:isSuffixOf&quot;&gt;isSuffixOf&lt;/a&gt;&lt;/code&gt; function takes two lists and returns &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; iff the first list is a suffix of the second. The second list must be finite.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="551caf48474039991548fe9ddb64d72b72493414" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:mapAccumL&quot;&gt;mapAccumL&lt;/a&gt;&lt;/code&gt; function behaves like a combination of &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt;; it applies a function to each element of a list, passing an accumulating parameter from left to right, and returning a final value of this accumulator together with the new list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8de586ae79a455858fed3746ae4e38cd05c48c19" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:mapAccumR&quot;&gt;mapAccumR&lt;/a&gt;&lt;/code&gt; function behaves like a combination of &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt;; it applies a function to each element of a list, passing an accumulating parameter from right to left, and returning a final value of this accumulator together with the new list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2391074ba068c80233175c59983a54b8066a4878" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:maximumBy&quot;&gt;maximumBy&lt;/a&gt;&lt;/code&gt; function takes a comparison function and a list and returns the greatest element of the list by the comparison function. The list must be finite and non-empty.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cef47277c570e470c285b99dbd14acd85cf932dd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:minimumBy&quot;&gt;minimumBy&lt;/a&gt;&lt;/code&gt; function takes a comparison function and a list and returns the least element of the list by the comparison function. The list must be finite and non-empty.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="057b661eee28e56248a47e5a122b7f8d64ae8148" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:nubBy&quot;&gt;nubBy&lt;/a&gt;&lt;/code&gt; function behaves just like &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:nub&quot;&gt;nub&lt;/a&gt;&lt;/code&gt;, except it uses a user-supplied equality predicate instead of the overloaded &lt;code&gt;&lt;a href=&quot;data-eq#v:-61--61-&quot;&gt;==&lt;/a&gt;&lt;/code&gt; function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19f8893f6a607220120cf57b88c38b3c50e89e8f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:partition&quot;&gt;partition&lt;/a&gt;&lt;/code&gt; function takes a predicate a list and returns the pair of lists of elements which do and do not satisfy the predicate, respectively; i.e.,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d853a061eb012af5ee71d94b4188db9e7e27bb4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:permutations&quot;&gt;permutations&lt;/a&gt;&lt;/code&gt; function returns the list of all permutations of the argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d369bcd6ff7a16017fc81230836cb1e2c9c3d1a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:product&quot;&gt;product&lt;/a&gt;&lt;/code&gt; function computes the product of a finite list of numbers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7601896a58f38cef45cf3ec9dd3675ffa2b1f23a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt; function implements a stable sorting algorithm. It is a special case of &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:sortBy&quot;&gt;sortBy&lt;/a&gt;&lt;/code&gt;, which allows the programmer to supply their own comparison function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7da3570e28419be0578ffd1de4f0b1fde8e86aa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:sortBy&quot;&gt;sortBy&lt;/a&gt;&lt;/code&gt; function is the non-overloaded version of &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f1f49bd6e008dde965696cc4f68b37f4c1c2ff6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:subsequences&quot;&gt;subsequences&lt;/a&gt;&lt;/code&gt; function returns the list of all subsequences of the argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6406e7e60d1afb305384d5af825ad223afd4d34" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:sum&quot;&gt;sum&lt;/a&gt;&lt;/code&gt; function computes the sum of a finite list of numbers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26c98a67aa07a5febf23006c6463cf654a93d6a8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:transpose&quot;&gt;transpose&lt;/a&gt;&lt;/code&gt; function transposes the rows and columns of its argument. For example,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c88aa8ebb4d5e9ab3079fc636599897089099a45" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; function is a `dual' to &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt;: while &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; reduces a list to a summary value, &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; builds a list from a seed value. The function takes the element and returns &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if it is done producing the list or returns &lt;code&gt;&lt;a href=&quot;data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt;&lt;code&gt;(a,b)&lt;/code&gt;, in which case, &lt;code&gt;a&lt;/code&gt; is a prepended to the list and &lt;code&gt;b&lt;/code&gt; is used as the next element in a recursive call. For example,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27a85700d4b6c91457baf0366be6c72427d177b0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:union&quot;&gt;union&lt;/a&gt;&lt;/code&gt; function returns the list union of the two lists. For example,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="897e5cd71a34240e2a452fc04aada2f8a3873766" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:unionBy&quot;&gt;unionBy&lt;/a&gt;&lt;/code&gt; function is the non-overloaded version of &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:union&quot;&gt;union&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a213a220259b72a83d767902fd9b906a21d8991" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:unzip3&quot;&gt;unzip3&lt;/a&gt;&lt;/code&gt; function takes a list of triples and returns three lists, analogous to &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:unzip&quot;&gt;unzip&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9f131d892100da4fd025f7a8ecff18fd3436b21" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:unzip4&quot;&gt;unzip4&lt;/a&gt;&lt;/code&gt; function takes a list of quadruples and returns four lists, analogous to &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:unzip&quot;&gt;unzip&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f19f192bc7bca3bb3b366a104a1495f29a2a94b7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:unzip5&quot;&gt;unzip5&lt;/a&gt;&lt;/code&gt; function takes a list of five-tuples and returns five lists, analogous to &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:unzip&quot;&gt;unzip&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12f0884943983f42126b4d7235d7fee19d6961ab" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:unzip6&quot;&gt;unzip6&lt;/a&gt;&lt;/code&gt; function takes a list of six-tuples and returns six lists, analogous to &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:unzip&quot;&gt;unzip&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd0ada4ba254397c7f2074cd7fe54881a14745ac" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:unzip7&quot;&gt;unzip7&lt;/a&gt;&lt;/code&gt; function takes a list of seven-tuples and returns seven lists, analogous to &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:unzip&quot;&gt;unzip&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0a0bedc800fc663f9a45123739d0871e9842832" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zip4&quot;&gt;zip4&lt;/a&gt;&lt;/code&gt; function takes four lists and returns a list of quadruples, analogous to &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt;. It is capable of list fusion, but it is restricted to its first list argument and its resulting list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b833eb65f6d996a715798ed453669aa9621f8431" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zip5&quot;&gt;zip5&lt;/a&gt;&lt;/code&gt; function takes five lists and returns a list of five-tuples, analogous to &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt;. It is capable of list fusion, but it is restricted to its first list argument and its resulting list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59728e29b809276b20b7cc9ae48caadda444d7f1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zip6&quot;&gt;zip6&lt;/a&gt;&lt;/code&gt; function takes six lists and returns a list of six-tuples, analogous to &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt;. It is capable of list fusion, but it is restricted to its first list argument and its resulting list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df3589322d209e15f6610db4bb0c1c54692646e7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zip7&quot;&gt;zip7&lt;/a&gt;&lt;/code&gt; function takes seven lists and returns a list of seven-tuples, analogous to &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt;. It is capable of list fusion, but it is restricted to its first list argument and its resulting list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7fb675c3384f90b4e5fdef7383e6b1b6d07309c9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zipWith3&quot;&gt;zipWith3&lt;/a&gt;&lt;/code&gt; function takes a function which combines three elements, as well as three lists and returns a list of their point-wise combination, analogous to &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt;. It is capable of list fusion, but it is restricted to its first list argument and its resulting list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d9d273ee2479cdb2c6b8ef0f65b15d495db5a7b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zipWith4&quot;&gt;zipWith4&lt;/a&gt;&lt;/code&gt; function takes a function which combines four elements, as well as four lists and returns a list of their point-wise combination, analogous to &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt;. It is capable of list fusion, but it is restricted to its first list argument and its resulting list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6aa1fdb5c348373284d6b8cfbe31c2976333f351" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zipWith5&quot;&gt;zipWith5&lt;/a&gt;&lt;/code&gt; function takes a function which combines five elements, as well as five lists and returns a list of their point-wise combination, analogous to &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt;. It is capable of list fusion, but it is restricted to its first list argument and its resulting list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5fd0df64a913d6523d2c136a1cb0ba65ca9434f4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zipWith6&quot;&gt;zipWith6&lt;/a&gt;&lt;/code&gt; function takes a function which combines six elements, as well as six lists and returns a list of their point-wise combination, analogous to &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt;. It is capable of list fusion, but it is restricted to its first list argument and its resulting list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57fc99e0dcfb0d585978688443e7472a5b1473e1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zipWith7&quot;&gt;zipWith7&lt;/a&gt;&lt;/code&gt; function takes a function which combines seven elements, as well as seven lists and returns a list of their point-wise combination, analogous to &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt;. It is capable of list fusion, but it is restricted to its first list argument and its resulting list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1325d57361ccc732ebb070de994b0a2421219c2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-ptr#t:Ptr&quot;&gt;Ptr&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ghc-ptr#t:FunPtr&quot;&gt;FunPtr&lt;/a&gt;&lt;/code&gt; types and operations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5763505508dac7b11615ee08a7acaba3fb632110" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-ptr#v:castPtr&quot;&gt;castPtr&lt;/a&gt;&lt;/code&gt; function casts a pointer from one type to another.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a500ee9d80b7f54eb7f8c916b79c09da04687f2a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; class and instances for basic data types.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5c958fd454a64dcb4c746fc275eb37dbbac1200" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-read#v:lex&quot;&gt;lex&lt;/a&gt;&lt;/code&gt; function reads a single lexeme from the input, discarding initial white space, and returning the characters that constitute the lexeme. If the input string contains only white space, &lt;code&gt;&lt;a href=&quot;ghc-read#v:lex&quot;&gt;lex&lt;/a&gt;&lt;/code&gt; returns a single successful `lexeme' consisting of the empty string. (Thus &lt;code&gt;&lt;a href=&quot;ghc-read#v:lex&quot;&gt;lex&lt;/a&gt; &quot;&quot; = [(&quot;&quot;,&quot;&quot;)]&lt;/code&gt;.) If there is no legal lexeme at the beginning of the input string, &lt;code&gt;&lt;a href=&quot;ghc-read#v:lex&quot;&gt;lex&lt;/a&gt;&lt;/code&gt; fails (i.e. returns &lt;code&gt;[]&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86c3288ccf7776810d20b3731af2e3b40bfcb247" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; class, and related operations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d5187961ae2687bea868b7eebea12a2b0fc9457" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-st#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; Monad.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a6e8251d60596b015e69b7b30aa3903c1d58def" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-staticptr#t:StaticKey&quot;&gt;StaticKey&lt;/a&gt;&lt;/code&gt; that can be used to look up the given &lt;code&gt;&lt;a href=&quot;ghc-staticptr#t:StaticPtr&quot;&gt;StaticPtr&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed23a830eec8e95fb04719f3ba021e908eb49a47" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:runIO&quot;&gt;runIO&lt;/a&gt;&lt;/code&gt; function lets you run an I/O computation in the &lt;code&gt;&lt;a href=&quot;language-haskell-th#t:Q&quot;&gt;Q&lt;/a&gt;&lt;/code&gt; monad. Take care: you are guaranteed the ordering of calls to &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:runIO&quot;&gt;runIO&lt;/a&gt;&lt;/code&gt; within a single &lt;code&gt;&lt;a href=&quot;language-haskell-th#t:Q&quot;&gt;Q&lt;/a&gt;&lt;/code&gt; computation, but not about the order in which splices are run.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa005a185e418ee86a0f14b966d5bed4334ff0bd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;language-haskell-th-quote#t:QuasiQuoter&quot;&gt;QuasiQuoter&lt;/a&gt;&lt;/code&gt; type, a value &lt;code&gt;q&lt;/code&gt; of this type can be used in the syntax &lt;code&gt;[q| ... string to parse ...|]&lt;/code&gt;. In fact, for convenience, a &lt;code&gt;&lt;a href=&quot;language-haskell-th-quote#t:QuasiQuoter&quot;&gt;QuasiQuoter&lt;/a&gt;&lt;/code&gt; actually defines multiple quasiquoters to be used in different splice contexts; if you are only interested in defining a quasiquoter to be used for expressions, you would define a &lt;code&gt;&lt;a href=&quot;language-haskell-th-quote#t:QuasiQuoter&quot;&gt;QuasiQuoter&lt;/a&gt;&lt;/code&gt; with only &lt;code&gt;&lt;a href=&quot;language-haskell-th-quote#v:quoteExp&quot;&gt;quoteExp&lt;/a&gt;&lt;/code&gt;, and leave the other fields stubbed out with errors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="822f6a374e5da6792e8281daef5bc8cbc52436fe" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:runIO&quot;&gt;runIO&lt;/a&gt;&lt;/code&gt; function lets you run an I/O computation in the &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:Q&quot;&gt;Q&lt;/a&gt;&lt;/code&gt; monad. Take care: you are guaranteed the ordering of calls to &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:runIO&quot;&gt;runIO&lt;/a&gt;&lt;/code&gt; within a single &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:Q&quot;&gt;Q&lt;/a&gt;&lt;/code&gt; computation, but not about the order in which splices are run.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a0d53f38c6a950df5eadf21a9f9db4dfc69bf0c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;prelude#t:Bounded&quot;&gt;Bounded&lt;/a&gt;&lt;/code&gt; class is used to name the upper and lower limits of a type. &lt;code&gt;&lt;a href=&quot;prelude#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; is not a superclass of &lt;code&gt;&lt;a href=&quot;prelude#t:Bounded&quot;&gt;Bounded&lt;/a&gt;&lt;/code&gt; since types that are not totally ordered may also have upper and lower bounds.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf58cbc6033627535675be41f7c5c26c9a969514" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;prelude#t:Bounded&quot;&gt;Bounded&lt;/a&gt;&lt;/code&gt; class may be derived for any enumeration type; &lt;code&gt;&lt;a href=&quot;prelude#v:minBound&quot;&gt;minBound&lt;/a&gt;&lt;/code&gt; is the first constructor listed in the &lt;code&gt;data&lt;/code&gt; declaration and &lt;code&gt;&lt;a href=&quot;prelude#v:maxBound&quot;&gt;maxBound&lt;/a&gt;&lt;/code&gt; is the last. &lt;code&gt;&lt;a href=&quot;prelude#t:Bounded&quot;&gt;Bounded&lt;/a&gt;&lt;/code&gt; may also be derived for single-constructor datatypes whose constituent types are in &lt;code&gt;&lt;a href=&quot;prelude#t:Bounded&quot;&gt;Bounded&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f24f4c3acddeb2d8485bbd7d048662ea4520e018" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;prelude#t:Either&quot;&gt;Either&lt;/a&gt;&lt;/code&gt; type is sometimes used to represent a value which is either correct or an error; by convention, the &lt;code&gt;&lt;a href=&quot;prelude#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; constructor is used to hold an error value and the &lt;code&gt;&lt;a href=&quot;prelude#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt; constructor is used to hold a correct value (mnemonic: &quot;right&quot; also means &quot;correct&quot;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d02c060c8f45391329e1f6687a2f0b6730500f6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;prelude#t:Either&quot;&gt;Either&lt;/a&gt;&lt;/code&gt; type represents values with two possibilities: a value of type &lt;code&gt;&lt;a href=&quot;prelude#t:Either&quot;&gt;Either&lt;/a&gt; a b&lt;/code&gt; is either &lt;code&gt;&lt;a href=&quot;prelude#v:Left&quot;&gt;Left&lt;/a&gt; a&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;prelude#v:Right&quot;&gt;Right&lt;/a&gt; b&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e44fd4d00d0795dea5f783f70db56faa6bffc024" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;prelude#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; class defines equality (&lt;code&gt;&lt;a href=&quot;prelude#v:-61--61-&quot;&gt;==&lt;/a&gt;&lt;/code&gt;) and inequality (&lt;code&gt;&lt;a href=&quot;prelude#v:-47--61-&quot;&gt;/=&lt;/a&gt;&lt;/code&gt;). All the basic datatypes exported by the &lt;a href=&quot;prelude&quot;&gt;Prelude&lt;/a&gt; are instances of &lt;code&gt;&lt;a href=&quot;prelude#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;prelude#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; may be derived for any datatype whose constituents are also instances of &lt;code&gt;&lt;a href=&quot;prelude#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75fb7e193c14639f9f2c840b46b6b678ecc93443" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;prelude#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; type encapsulates an optional value. A value of type &lt;code&gt;&lt;a href=&quot;prelude#t:Maybe&quot;&gt;Maybe&lt;/a&gt; a&lt;/code&gt; either contains a value of type &lt;code&gt;a&lt;/code&gt; (represented as &lt;code&gt;&lt;a href=&quot;prelude#v:Just&quot;&gt;Just&lt;/a&gt; a&lt;/code&gt;), or it is empty (represented as &lt;code&gt;&lt;a href=&quot;prelude#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;). Using &lt;code&gt;&lt;a href=&quot;prelude#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; is a good way to deal with errors or exceptional cases without resorting to drastic measures such as &lt;code&gt;&lt;a href=&quot;prelude#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d4644834b747ca6136ef2aaff7f66c325592783" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;prelude#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; type is also a monad. It is a simple kind of error monad, where all errors are represented by &lt;code&gt;&lt;a href=&quot;prelude#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;. A richer error monad can be built using the &lt;code&gt;&lt;a href=&quot;data-either#v:Either&quot;&gt;Either&lt;/a&gt;&lt;/code&gt; type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2bc4ca3d8934e365fb80ceb2378eb5082b3a17f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;prelude#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; class defines the basic operations over a &lt;em&gt;monad&lt;/em&gt;, a concept from a branch of mathematics known as &lt;em&gt;category theory&lt;/em&gt;. From the perspective of a Haskell programmer, however, it is best to think of a monad as an &lt;em&gt;abstract datatype&lt;/em&gt; of actions. Haskell's &lt;code&gt;do&lt;/code&gt; expressions provide a convenient syntax for writing monadic expressions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7aaef56b80f737eb27df9b1e3d02aefbb49c126c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;prelude#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; instance for &lt;code&gt;&lt;a href=&quot;prelude#t:Either&quot;&gt;Either&lt;/a&gt;&lt;/code&gt; allows us to chain together multiple actions which may fail, and fail overall if any of the individual steps failed. First we'll write a function that can either parse an &lt;code&gt;&lt;a href=&quot;prelude#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; from a &lt;code&gt;&lt;a href=&quot;prelude#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt;, or fail.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b3a6ba7d1631eb7dffbc7a80d33a50655ec5cdd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;prelude#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; class is used for totally ordered datatypes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7fb9b92b465e420832be5f52da24e03070664a5c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;prelude#v:fmap&quot;&gt;fmap&lt;/a&gt;&lt;/code&gt; from our &lt;code&gt;&lt;a href=&quot;prelude#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; instance will ignore &lt;code&gt;&lt;a href=&quot;prelude#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; values, but will apply the supplied function to values contained in a &lt;code&gt;&lt;a href=&quot;prelude#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb778616987d1ec9e7af8ce5c3a0fe1ad6f720c7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;prelude#v:fromEnum&quot;&gt;fromEnum&lt;/a&gt;&lt;/code&gt; method restricted to the type &lt;code&gt;&lt;a href=&quot;data-char#v:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fdbf4d018722d263569f1a254868963b4ff029df" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;prelude#v:getContents&quot;&gt;getContents&lt;/a&gt;&lt;/code&gt; operation returns all user input as a single string, which is read lazily as it is needed (same as &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hGetContents&quot;&gt;hGetContents&lt;/a&gt;&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;ghc-io-handle-fd#v:stdin&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa6a84a7de6790cd0de53c018c33b1487b75f830" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;prelude#v:interact&quot;&gt;interact&lt;/a&gt;&lt;/code&gt; function takes a function of type &lt;code&gt;String-&amp;gt;String&lt;/code&gt; as its argument. The entire input from the standard input device is passed to this function as its argument, and the resulting string is output on the standard output device.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79b16f25ddf4b36594ea2e938465c9296ed38dc7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;prelude#v:lex&quot;&gt;lex&lt;/a&gt;&lt;/code&gt; function reads a single lexeme from the input, discarding initial white space, and returning the characters that constitute the lexeme. If the input string contains only white space, &lt;code&gt;&lt;a href=&quot;prelude#v:lex&quot;&gt;lex&lt;/a&gt;&lt;/code&gt; returns a single successful `lexeme' consisting of the empty string. (Thus &lt;code&gt;&lt;a href=&quot;prelude#v:lex&quot;&gt;lex&lt;/a&gt; &quot;&quot; = [(&quot;&quot;,&quot;&quot;)]&lt;/code&gt;.) If there is no legal lexeme at the beginning of the input string, &lt;code&gt;&lt;a href=&quot;prelude#v:lex&quot;&gt;lex&lt;/a&gt;&lt;/code&gt; fails (i.e. returns &lt;code&gt;[]&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e4582487867df9d645782b484418688a1f3f58c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;prelude#v:maybe&quot;&gt;maybe&lt;/a&gt;&lt;/code&gt; function takes a default value, a function, and a &lt;code&gt;&lt;a href=&quot;prelude#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; value. If the &lt;code&gt;&lt;a href=&quot;prelude#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; value is &lt;code&gt;&lt;a href=&quot;prelude#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;, the function returns the default value. Otherwise, it applies the function to the value inside the &lt;code&gt;&lt;a href=&quot;prelude#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; and returns the result.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c131692c2bade036458b0d1127914f219c7dd175" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;prelude#v:print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; function outputs a value of any printable type to the standard output device. Printable types are those that are instances of class &lt;code&gt;&lt;a href=&quot;prelude#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt;; &lt;code&gt;&lt;a href=&quot;prelude#v:print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; converts values to strings for output using the &lt;code&gt;&lt;a href=&quot;prelude#v:show&quot;&gt;show&lt;/a&gt;&lt;/code&gt; operation and adds a newline.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c7fc1c52a42ce0024aec6c65a38a9e6dc8fb7ae" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;prelude#v:product&quot;&gt;product&lt;/a&gt;&lt;/code&gt; function computes the product of the numbers of a structure.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f99911d99a3ef08fe8f375dba1db41c4eecf08d7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;prelude#v:read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; function reads input from a string, which must be completely consumed by the input process. &lt;code&gt;&lt;a href=&quot;prelude#v:read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; fails with an &lt;code&gt;&lt;a href=&quot;prelude#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt; if the parse is unsuccessful, and it is therefore discouraged from being used in real applications. Use &lt;code&gt;&lt;a href=&quot;text-read#v:readMaybe&quot;&gt;readMaybe&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;text-read#v:readEither&quot;&gt;readEither&lt;/a&gt;&lt;/code&gt; for safe alternatives.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ffdc3ac1e36da7a1438f94612f331c6323f073b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;prelude#v:readFile&quot;&gt;readFile&lt;/a&gt;&lt;/code&gt; function reads a file and returns the contents of the file as a string. The file is read lazily, on demand, as with &lt;code&gt;&lt;a href=&quot;prelude#v:getContents&quot;&gt;getContents&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1edaaff10f2fbe79640944d7ec56cb49a4bed802" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;prelude#v:readIO&quot;&gt;readIO&lt;/a&gt;&lt;/code&gt; function is similar to &lt;code&gt;&lt;a href=&quot;prelude#v:read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; except that it signals parse failure to the &lt;code&gt;&lt;a href=&quot;prelude#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad instead of terminating the program.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e25de194b180f1f5888a1fb8e989cb909435014" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;prelude#v:readLn&quot;&gt;readLn&lt;/a&gt;&lt;/code&gt; function combines &lt;code&gt;&lt;a href=&quot;prelude#v:getLine&quot;&gt;getLine&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;prelude#v:readIO&quot;&gt;readIO&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bfe43d67eb01eceb873ed3fd660e71f0f5174638" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;prelude#v:sum&quot;&gt;sum&lt;/a&gt;&lt;/code&gt; function computes the sum of the numbers of a structure.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bbb5313ec9e6c9e5650625c5d2da153e452b2504" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;prelude#v:toEnum&quot;&gt;toEnum&lt;/a&gt;&lt;/code&gt; method restricted to the type &lt;code&gt;&lt;a href=&quot;data-char#v:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a04819fa78c89f5452b8780304a58025b2a647c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;prelude#v:unzip3&quot;&gt;unzip3&lt;/a&gt;&lt;/code&gt; function takes a list of triples and returns three lists, analogous to &lt;code&gt;&lt;a href=&quot;prelude#v:unzip&quot;&gt;unzip&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="052c2b73f585f4387bcfea6e35542d389d49e8f6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;prelude#v:zipWith3&quot;&gt;zipWith3&lt;/a&gt;&lt;/code&gt; function takes a function which combines three elements, as well as three lists and returns a list of their point-wise combination, analogous to &lt;code&gt;&lt;a href=&quot;prelude#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt;. It is capable of list fusion, but it is restricted to its first list argument and its resulting list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="645f48f9edaa9bdfcdbd50f2978b6ca7c976e666" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;system#v:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; input functions (e.g. &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#v:getLine&quot;&gt;getLine&lt;/a&gt;&lt;/code&gt;) don't automatically convert to Unicode, so this function is provided to make the conversion from a multibyte string in the given code page to a proper Unicode string. To get the code page for the console, use &lt;code&gt;getConsoleCP&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9915513312e5b9714f0fe4288381e0da0f72704" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;system-console-haskeline#t:InputT&quot;&gt;InputT&lt;/a&gt;&lt;/code&gt; monad transformer provides direct, low-level access to the user's line history state.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77b115021e101641ef1f81dd36bd9d5f8a21f7b9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;system-console-haskeline-monadexception#v:controlIO&quot;&gt;controlIO&lt;/a&gt;&lt;/code&gt; method enables us to &quot;lift&quot; a function that manages IO actions (such as &lt;code&gt;&lt;a href=&quot;system-console-haskeline-monadexception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;system-console-haskeline-monadexception#v:catch&quot;&gt;catch&lt;/a&gt;&lt;/code&gt;) into a function that wraps arbitrary monadic actions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d97760ad46f0a47182108cce3dd3552c71ffced8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;system-console-terminfo-base#t:TermOutput&quot;&gt;TermOutput&lt;/a&gt;&lt;/code&gt; monoid abstracts away all padding and control sequence output. Unfortunately, that datatype is difficult to integrate into existing &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;-based APIs such as pretty-printers. Thus, as a workaround, &lt;code&gt;&lt;a href=&quot;system-console-terminfo-base#v:tiGetOutput1&quot;&gt;tiGetOutput1&lt;/a&gt;&lt;/code&gt; also lets us access the control sequences as &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;s. The one caveat is that it will not allow you to access padded control sequences as Strings. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ff1172a4964334b38f0ed53fd5acdd80ad6655a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;system-cputime#v:cpuTimePrecision&quot;&gt;cpuTimePrecision&lt;/a&gt;&lt;/code&gt; constant is the smallest measurable difference in CPU time that the implementation can record, and is given as an integral number of picoseconds.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d42c1bb360791782c56c45d321fb837bc1ed609e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;system-directory#t:Permissions&quot;&gt;Permissions&lt;/a&gt;&lt;/code&gt; type is used to record whether certain operations are permissible on a file/directory. &lt;code&gt;&lt;a href=&quot;system-directory#v:getPermissions&quot;&gt;getPermissions&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;system-directory#v:setPermissions&quot;&gt;setPermissions&lt;/a&gt;&lt;/code&gt; get and set these permissions, respectively. Permissions apply both to files and directories. For directories, the executable field will be &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt;, and for files the searchable field will be &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt;. Note that directories may be searchable without being readable, if permission has been given to use them as part of a path, but not to examine the directory contents.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7fb38ca78261525df1464df4fb698278b8051df" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:catMaybes&quot;&gt;catMaybes&lt;/a&gt;&lt;/code&gt; function takes a list of &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt;s and returns a list of all the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9dec7d9cce3f521b0de7412db5964162658ad1e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:catchIOError&quot;&gt;catchIOError&lt;/a&gt;&lt;/code&gt; function establishes a handler that receives any &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; raised in the action protected by &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:catchIOError&quot;&gt;catchIOError&lt;/a&gt;&lt;/code&gt;. An &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; is caught by the most recent handler established by one of the exception handling functions. These handlers are not selective: all &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt;s are caught. Exception propagation must be explicitly provided in a handler by re-raising any unwanted exceptions. For example, in</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff85ed75d901b4d2c7aa0d2761fd28a6697d0178" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:fromMaybe&quot;&gt;fromMaybe&lt;/a&gt;&lt;/code&gt; function takes a default value and and &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; value. If the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;, it returns the default values; otherwise, it returns the value contained in the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c7eae4b2c5061e05af7d962b180cd3821808d93" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:maybeToList&quot;&gt;maybeToList&lt;/a&gt;&lt;/code&gt; function returns an empty list when given &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; or a singleton list when given &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0aa3120b7fd0765f6ac196cefe19e035c54f08e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;system-io#v:getContents&quot;&gt;getContents&lt;/a&gt;&lt;/code&gt; operation returns all user input as a single string, which is read lazily as it is needed (same as &lt;code&gt;&lt;a href=&quot;system-io#v:hGetContents&quot;&gt;hGetContents&lt;/a&gt;&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;system-io#v:stdin&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49101be718bf6fa482ea1ac280c8c3978edbdc76" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;system-io#v:interact&quot;&gt;interact&lt;/a&gt;&lt;/code&gt; function takes a function of type &lt;code&gt;String-&amp;gt;String&lt;/code&gt; as its argument. The entire input from the standard input device is passed to this function as its argument, and the resulting string is output on the standard output device.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c28c31ff8d6196f0cd154601474e1e3b9b58f9bd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;system-io#v:print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; function outputs a value of any printable type to the standard output device. Printable types are those that are instances of class &lt;code&gt;&lt;a href=&quot;text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt;; &lt;code&gt;&lt;a href=&quot;system-io#v:print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; converts values to strings for output using the &lt;code&gt;&lt;a href=&quot;text-show#v:show&quot;&gt;show&lt;/a&gt;&lt;/code&gt; operation and adds a newline.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="825ef90fdaca88a42de4c139d5e6c64085f34a5d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;system-io#v:readFile&quot;&gt;readFile&lt;/a&gt;&lt;/code&gt; function reads a file and returns the contents of the file as a string. The file is read lazily, on demand, as with &lt;code&gt;&lt;a href=&quot;system-io#v:getContents&quot;&gt;getContents&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c55ec6a3320441e71baa3c7cddc99bb5586ab05b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;system-io#v:readIO&quot;&gt;readIO&lt;/a&gt;&lt;/code&gt; function is similar to &lt;code&gt;&lt;a href=&quot;text-read#v:read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; except that it signals parse failure to the &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad instead of terminating the program.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="892d5a8616ddf159523b449a487e6243305ef9c8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;system-io#v:readLn&quot;&gt;readLn&lt;/a&gt;&lt;/code&gt; function combines &lt;code&gt;&lt;a href=&quot;system-io#v:getLine&quot;&gt;getLine&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;system-io#v:readIO&quot;&gt;readIO&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f01cd96e2bf006a175917ef728b5ef21ad4ad33" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;system-io-error#v:catchIOError&quot;&gt;catchIOError&lt;/a&gt;&lt;/code&gt; function establishes a handler that receives any &lt;code&gt;&lt;a href=&quot;system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; raised in the action protected by &lt;code&gt;&lt;a href=&quot;system-io-error#v:catchIOError&quot;&gt;catchIOError&lt;/a&gt;&lt;/code&gt;. An &lt;code&gt;&lt;a href=&quot;system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; is caught by the most recent handler established by one of the exception handling functions. These handlers are not selective: all &lt;code&gt;&lt;a href=&quot;system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt;s are caught. Exception propagation must be explicitly provided in a handler by re-raising any unwanted exceptions. For example, in</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e2935b648dbc65061463e0e0bc3ae9bc38731b6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;system-posix-env#v:clearEnv&quot;&gt;clearEnv&lt;/a&gt;&lt;/code&gt; function clears the environment of all name-value pairs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="369194824dad3c17becd69feafce80094511a779" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;system-posix-env#v:setEnv&quot;&gt;setEnv&lt;/a&gt;&lt;/code&gt; function inserts or resets the environment variable name in the current environment list. If the variable &lt;code&gt;name&lt;/code&gt; does not exist in the list, it is inserted with the given value. If the variable does exist, the argument &lt;code&gt;overwrite&lt;/code&gt; is tested; if &lt;code&gt;overwrite&lt;/code&gt; is &lt;code&gt;False&lt;/code&gt;, the variable is not reset, otherwise it is reset to the given value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e16fdd3c2060c8b0e7dcb0de6c67a978ff67d1fd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;system-posix-env#v:unsetEnv&quot;&gt;unsetEnv&lt;/a&gt;&lt;/code&gt; function deletes all instances of the variable name from the environment.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6390faf5740aef6b3fe69f665e1639661b490c68" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;system-posix-env-bytestring#v:setEnv&quot;&gt;setEnv&lt;/a&gt;&lt;/code&gt; function inserts or resets the environment variable name in the current environment list. If the variable &lt;code&gt;name&lt;/code&gt; does not exist in the list, it is inserted with the given value. If the variable does exist, the argument &lt;code&gt;overwrite&lt;/code&gt; is tested; if &lt;code&gt;overwrite&lt;/code&gt; is &lt;code&gt;False&lt;/code&gt;, the variable is not reset, otherwise it is reset to the given value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="908e9623e5b8e5381ae3293c89d2d6a40a5a4714" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;system-posix-env-bytestring#v:unsetEnv&quot;&gt;unsetEnv&lt;/a&gt;&lt;/code&gt; function deletes all instances of the variable name from the environment.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="236f78121c4a2f2bf7b4a76db19e5a7170bc2449" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;system-posix-io#v:createPipe&quot;&gt;createPipe&lt;/a&gt;&lt;/code&gt; function creates a pair of connected file descriptors. The first component is the fd to read from, the second is the write end. Although pipes may be bidirectional, this behaviour is not portable and programmers should use two separate pipes for this purpose. May throw an exception if this is an invalid descriptor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4b473f0667d5a6b55f733ab3a3194586555807c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;system-posix-io-bytestring#v:createPipe&quot;&gt;createPipe&lt;/a&gt;&lt;/code&gt; function creates a pair of connected file descriptors. The first component is the fd to read from, the second is the write end. Although pipes may be bidirectional, this behaviour is not portable and programmers should use two separate pipes for this purpose. May throw an exception if this is an invalid descriptor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50694ec6aab0913f0db1bc83f6e0ed0aed5dd7e6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;text-printf#t:HPrintfType&quot;&gt;HPrintfType&lt;/a&gt;&lt;/code&gt; class provides the variable argument magic for &lt;code&gt;&lt;a href=&quot;text-printf#v:hPrintf&quot;&gt;hPrintf&lt;/a&gt;&lt;/code&gt;. Its implementation is intentionally not visible from this module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="290847fe4ef7b4c780f17cc14317e4a804018f65" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;text-printf#t:PrintfType&quot;&gt;PrintfType&lt;/a&gt;&lt;/code&gt; class provides the variable argument magic for &lt;code&gt;&lt;a href=&quot;text-printf#v:printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt;. Its implementation is intentionally not visible from this module. If you attempt to pass an argument of a type which is not an instance of this class to &lt;code&gt;&lt;a href=&quot;text-printf#v:printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;text-printf#v:hPrintf&quot;&gt;hPrintf&lt;/a&gt;&lt;/code&gt;, then the compiler will report it as a missing instance of &lt;code&gt;&lt;a href=&quot;text-printf#t:PrintfArg&quot;&gt;PrintfArg&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6bde3b6deb5751130f8fa9aed7708139a05904e8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;text-read#v:lex&quot;&gt;lex&lt;/a&gt;&lt;/code&gt; function reads a single lexeme from the input, discarding initial white space, and returning the characters that constitute the lexeme. If the input string contains only white space, &lt;code&gt;&lt;a href=&quot;text-read#v:lex&quot;&gt;lex&lt;/a&gt;&lt;/code&gt; returns a single successful `lexeme' consisting of the empty string. (Thus &lt;code&gt;&lt;a href=&quot;text-read#v:lex&quot;&gt;lex&lt;/a&gt; &quot;&quot; = [(&quot;&quot;,&quot;&quot;)]&lt;/code&gt;.) If there is no legal lexeme at the beginning of the input string, &lt;code&gt;&lt;a href=&quot;text-read#v:lex&quot;&gt;lex&lt;/a&gt;&lt;/code&gt; fails (i.e. returns &lt;code&gt;[]&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a9d5cf956b4aeb4977bd49b0f7c6321ffb9b927" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;text-read#v:read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; function reads input from a string, which must be completely consumed by the input process. &lt;code&gt;&lt;a href=&quot;text-read#v:read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; fails with an &lt;code&gt;&lt;a href=&quot;prelude#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt; if the parse is unsuccessful, and it is therefore discouraged from being used in real applications. Use &lt;code&gt;&lt;a href=&quot;text-read#v:readMaybe&quot;&gt;readMaybe&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;text-read#v:readEither&quot;&gt;readEither&lt;/a&gt;&lt;/code&gt; for safe alternatives.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c81f5117934d868bf2254238529c0a48b7fea08" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;em&gt;k&lt;/em&gt;&lt;/code&gt; argument controls how many test rounds are performed for determining a &lt;em&gt;probable prime&lt;/em&gt;. For more details, see &lt;a href=&quot;http://gmplib.org/manual/Number-Theoretic-Functions.html#index-mpz_005fprobab_005fprime_005fp-360&quot;&gt;GMP documentation for `mpz_probab_prime_p()`&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bad337d10fc64d5b2ff3dbc6f2bf484df6cb613c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;BigNat&lt;/code&gt; type</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b24b400b6bb089abd37b81edfb22c9c44a5b28fe" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Bits&lt;/code&gt; class does not have a &lt;code&gt;Num&lt;/code&gt; superclass. It therefore does not have default methods for the &lt;code&gt;bit&lt;/code&gt;, &lt;code&gt;testBit&lt;/code&gt; and &lt;code&gt;popCount&lt;/code&gt; methods.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7585bf1c302df16ed91051c8a55f49dac7f27c55" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ByteString&lt;/code&gt; type</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4cb78819e2dcf3b038b0fa6fa29d124f961d0aa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ByteString&lt;/code&gt; type and representation</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="005e2bda030ee8e32664f998432e3befbee14062" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;CApiFFI&lt;/code&gt; extension allows a calling convention of &lt;code&gt;capi&lt;/code&gt; to be used in foreign declarations, e.g.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13b7284405381c1e383cd0d0249cafb8eb623b0b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;COMPLETE&lt;/code&gt; pragma is used to inform the pattern match checker that a certain set of patterns is complete and that any function which matches on all the specified patterns is total.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97ba5a1df665f08e5746afd5258e9f9bc0483c65" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;CallStack&lt;/code&gt; will only extend as far as the types allow it, for example</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b22faafc676f89394f33e91663ca60cabb6bc4b8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Chan&lt;/code&gt; type</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56868895505567b8dd6fa6c19b6bf5118c82d7d2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;DOCTYPE&lt;/code&gt; for XHTML 1.0 Strict.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ffc2f173105c8fb1fcbdf98a1d298ce5e8bba858" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Dynamic&lt;/code&gt; type</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f473b66e396d89af61f465962bc064a789e33d0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ErrorT&lt;/code&gt; Monad structure is parameterized over two things:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f105cba62162d63271c49af7cd9cd8361ee2895b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;FOO.hp&lt;/code&gt; file produced when you ask for the heap profile of a program &lt;code&gt;FOO&lt;/code&gt; is a text file with a particularly simple structure. Here&amp;rsquo;s a representative example, with much of the actual data omitted:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48feef81fcfb630b464ad6ce416e6ee040c4f208" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Foo @k a = a&lt;/code&gt; equation would be represented as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c992f175532ed7a0887c33f484f4c4856a6f5c50" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Foo_stub.h&lt;/code&gt; file can be redirected using the &lt;code&gt;-stubdir&lt;/code&gt; option; see &lt;a href=&quot;separate_compilation#options-output&quot;&gt;Redirecting the compilation output(s)&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc9f316a3a267a4b9984d1222e0ad9feb74bf869" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;GHC_PACKAGE_PATH&lt;/code&gt; environment variable may be set to a &lt;code&gt;:&lt;/code&gt;-separated (&lt;code&gt;;&lt;/code&gt;-separated on Windows) list of files containing package databases. This list of package databases, used by GHC and ghc-pkg, specifies a stack of package databases from top to bottom. This order was chosen to match the behaviour of the &lt;code id=&quot;index-5&quot;&gt;PATH&lt;/code&gt; environment variable where entries earlier in the PATH override ones that come later. See &lt;a href=&quot;#package-databases&quot;&gt;Package Databases&lt;/a&gt; for details on how the package database stack is used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f21fc75056d50350516dd52ff5912c872b8b9460" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;GenLanguageDef&lt;/code&gt; type is a record that contains all parameterizable features of the &lt;a href=&quot;text-parsec-token&quot;&gt;Text.Parsec.Token&lt;/a&gt; module. The module &lt;a href=&quot;text-parsec-language&quot;&gt;Text.Parsec.Language&lt;/a&gt; contains some default definitions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4e050756130eeb11c58b31896ace2ae245341ca" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Generic1&lt;/code&gt; class</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b121f20d20404180364bfd43491c63f4245f97f2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Generic&lt;/code&gt; and &lt;code&gt;Generic1&lt;/code&gt; classes mediate between user-defined datatypes and their internal representation as a sum-of-products:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c04d22bf6198b566fefab29ee20c196be128ca5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;HSfoo.o&lt;/code&gt; file is built by Cabal automatically; use &lt;code&gt;--disable-library-for-ghci&lt;/code&gt; to disable it. To build one manually, the following GNU &lt;code&gt;ld&lt;/code&gt; command can be used:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4504a638df2b2b4639ba03e3b6d8a72cdcb6adda" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;INCLUDE&lt;/code&gt; used to be necessary for specifying header files to be included when using the FFI and compiling via C. It is no longer required for GHC, but is accepted (and ignored) for compatibility with other compilers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e15878bd48bab3818efd590996e87053049c312" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;INLINABLE&lt;/code&gt; pragma also works with &lt;code&gt;SPECIALISE&lt;/code&gt;: if you mark function &lt;code&gt;f&lt;/code&gt; as &lt;code&gt;INLINABLE&lt;/code&gt;, then you can subsequently &lt;code&gt;SPECIALISE&lt;/code&gt; in another module (see &lt;a href=&quot;#specialize-pragma&quot;&gt;SPECIALIZE pragma&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="011dae688b0bf1afe030126194f5bf145fe1f133" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Int&lt;/code&gt; may well fix &lt;code&gt;b&lt;/code&gt; at the call site, so that signature should not be rejected. Moreover, the dependencies might be hidden. Consider</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be48930496202a998883fb4cafb1527204c88628" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Integer&lt;/code&gt; type</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd53ccf97b4fdfd6c001e2465d556a7f859dcf35" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;IsList&lt;/code&gt; class and its methods are intended to be used in conjunction with the &lt;code&gt;OverloadedLists&lt;/code&gt; extension.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8673f7079a0b5c433c928ec58cc5f380461b598a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Ix&lt;/code&gt; class</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef3790360f91e6f1db9d6be90c644fd246da75d8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Ix&lt;/code&gt; class and operations</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10c3ff8e25753aa68617bfab48822621de668249" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Just Refl&lt;/code&gt; case in &lt;code&gt;step2&lt;/code&gt; is inaccessible, because in order for &lt;code&gt;checkTEQ&lt;/code&gt; to be able to produce a &lt;code&gt;Just&lt;/code&gt;, &lt;code&gt;t ~ u&lt;/code&gt; must hold, but since we&amp;rsquo;re passing &lt;code&gt;Foo1&lt;/code&gt; and &lt;code&gt;Foo2&lt;/code&gt; here, it follows that &lt;code&gt;t ~
Char&lt;/code&gt;, and &lt;code&gt;u ~ Int&lt;/code&gt;, and thus &lt;code&gt;t ~ u&lt;/code&gt; cannot hold.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50553a5059a245db41faab2319d240eba523fc59" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;LANGUAGE&lt;/code&gt; pragma allows language extensions to be enabled in a portable way. It is the intention that all Haskell compilers support the &lt;code&gt;LANGUAGE&lt;/code&gt; pragma with the same syntax, although not all extensions are supported by all compilers, of course. The &lt;code&gt;LANGUAGE&lt;/code&gt; pragma should be used instead of &lt;code&gt;OPTIONS_GHC&lt;/code&gt;, if possible.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9db793d0713d9096493ec702152818be66ee6bd8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;MArray&lt;/code&gt; class is parameterised over both &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;e&lt;/code&gt; (so that instances specialised to certain element types can be defined, in the same way as for &lt;code&gt;&lt;a href=&quot;data-array-iarray#t:IArray&quot;&gt;IArray&lt;/a&gt;&lt;/code&gt;), and also over the type of the monad, &lt;code&gt;m&lt;/code&gt;, in which the mutable array will be manipulated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9cb8377e96ef4f0bbbfa46420220ebcc273c902" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;MINIMAL&lt;/code&gt; pragma can be used to change which combination of methods will be required for instances of a particular class. See &lt;a href=&quot;glasgow_exts#minimal-pragma&quot;&gt;MINIMAL pragma&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b804211dca7a6234cc53da8eb6f7ab49bdfebd1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;MINIMAL&lt;/code&gt; pragma is used to specify the minimal complete definition of a class, i.e. specify which methods must be implemented by all instances. If an instance does not satisfy the minimal complete definition, then a warning is generated. This can be useful when a class has methods with circular defaults. For example</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="179c9366f2492e385b72cb143e85887902e0ab4c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Maybe Dec&lt;/code&gt; field contains &lt;code&gt;Just&lt;/code&gt; the declaration which defined the variable - including the RHS of the declaration - or else &lt;code&gt;Nothing&lt;/code&gt;, in the case where the RHS is unavailable to the compiler. At present, this value is &lt;em&gt;always&lt;/em&gt;&lt;code&gt;Nothing&lt;/code&gt;: returning the RHS has not yet been implemented because of lack of interest.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="833a3a82dcaf236e1a22c42275a11a48d6dd026d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Maybe String&lt;/code&gt; argument allows to supply an optional time specification. E.g.:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4cf4ef2ad7be84020f5ab8d962e61d9c5230f48" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ModSummary&lt;/code&gt; contains useful meta-information about the compiled module. The &lt;code&gt;HsParsedModule&lt;/code&gt; contains the lexical and syntactical information we mentioned before. The result that you return will change the result of the parsing. If you don&amp;rsquo;t want to change the result, just return the &lt;code&gt;HsParsedModule&lt;/code&gt; that you received as the argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2f1b3a94e8148014127a4f07b1372b7725a7bda" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Monad&lt;/code&gt; class has an &lt;code&gt;Applicative&lt;/code&gt; superclass. You cannot write &lt;code&gt;Monad&lt;/code&gt; instances that work for GHC and also for a Haskell 2010 implementation that does not define &lt;code&gt;Applicative&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9a442b1b9dc364891e0d9b2233f04de798d1ec7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;NOCLDSTOP&lt;/code&gt; flag</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4dd6a67adca1f0f6b2e2bb5d6f4f6be090147329" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;NOINLINE&lt;/code&gt; pragma tells GHC not to inline &lt;code&gt;foo&lt;/code&gt; until Phase 0; and this property is inherited by the specialisation RULE, which will therefore only fire in Phase 0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41cd577171aa93daf4a59092425aec6f8da57085" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;NOUNPACK&lt;/code&gt; pragma indicates to the compiler that it should not unpack the contents of a constructor field. Example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02f6d5f3a66723750914b07b17b4152b831881eb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Natural&lt;/code&gt; number type</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e90151e467bb879239604777d1625aec0d519783" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Num&lt;/code&gt; class does not have &lt;code&gt;Show&lt;/code&gt; or &lt;code&gt;Eq&lt;/code&gt; superclasses.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="126dfab84b0966c6acff2a80c6f25e8566d4c2cb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;OPTIONS_GHC&lt;/code&gt; pragma is used to specify additional options that are given to the compiler when compiling this source file. See &lt;a href=&quot;using#source-file-options&quot;&gt;Command line options in source files&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88a0fae3e171286c99c8569a8b07482329213991" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Plugin&lt;/code&gt; type has a field &lt;code&gt;tcPlugin&lt;/code&gt; of type &lt;code&gt;[CommandLineOption] -&amp;gt; Maybe TcPlugin&lt;/code&gt;, where the &lt;code&gt;TcPlugin&lt;/code&gt; type is defined thus:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fffe76b7bf3798c24838442d37709754d1c21fba" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;PluginRecompile&lt;/code&gt; data type is an enumeration determining how the plugin should affect recompilation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e585b3f2d187dee43075f1c6379003eb2f833f55" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Pointer&lt;/code&gt; field is not used when tag says that it&amp;rsquo;s &lt;code&gt;Nothing&lt;/code&gt;. Otherwise &lt;code&gt;Pointer&lt;/code&gt; points to the value in &lt;code&gt;Just&lt;/code&gt;. As mentioned above, this type is lazy in its lifted field. Therefore, the type</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb221db19183a2bbc482de37382d307415cceaa0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Read&lt;/code&gt; class</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c684523d6c7922654f7664f2f15207a387ba8fbb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Read&lt;/code&gt; class has two extra methods, &lt;code&gt;readPrec&lt;/code&gt; and &lt;code&gt;readListPrec&lt;/code&gt;, that are not found in the Haskell 2010 since they rely on the &lt;code&gt;ReadPrec&lt;/code&gt; data type, which requires the &lt;a href=&quot;glasgow_exts#extension-RankNTypes&quot;&gt;&lt;code&gt;-XRankNTypes&lt;/code&gt;&lt;/a&gt; extension. GHC also derives &lt;code&gt;Read&lt;/code&gt; instances by implementing &lt;code&gt;readPrec&lt;/code&gt; instead of &lt;code&gt;readsPrec&lt;/code&gt;, and relies on a default implementation of &lt;code&gt;readsPrec&lt;/code&gt; that is defined in terms of &lt;code&gt;readPrec&lt;/code&gt;. GHC adds these two extra methods simply because &lt;code&gt;ReadPrec&lt;/code&gt; is more efficient than &lt;code&gt;ReadS&lt;/code&gt; (the type on which &lt;code&gt;readsPrec&lt;/code&gt; is based).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5a639306682ee2392defbfaca8a0612ce62725a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ReadP&lt;/code&gt; type</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55f87a9866a170596d8c12e14883de0375635cbd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Reader&lt;/code&gt; monad (also called the Environment monad). Represents a computation, which can read values from a shared environment, pass values from function to function, and execute sub-computations in a modified environment. Using &lt;code&gt;Reader&lt;/code&gt; monad for such computations is often clearer and easier than using the &lt;code&gt;&lt;a href=&quot;control-monad-state#v:State&quot;&gt;State&lt;/a&gt;&lt;/code&gt; monad.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="138e28c8c2a47ed6154d76f22441ec8c21841137" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;R{..}&lt;/code&gt; expands to &lt;code&gt;R{a=a}&lt;/code&gt;, omitting &lt;code&gt;b&lt;/code&gt; since the record field is not in scope, and omitting &lt;code&gt;c&lt;/code&gt; since the variable &lt;code&gt;c&lt;/code&gt; is not in scope (apart from the binding of the record selector &lt;code&gt;c&lt;/code&gt;, of course).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6082bbc59601d9a449fcc7ad9a4d5ed12a91d6c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SPARKS&lt;/code&gt; statistic refers to the use of &lt;code&gt;Control.Parallel.par&lt;/code&gt; and related functionality in the program. Each spark represents a call to &lt;code&gt;par&lt;/code&gt;; a spark is &amp;ldquo;converted&amp;rdquo; when it is executed in parallel; and a spark is &amp;ldquo;pruned&amp;rdquo; when it is found to be already evaluated and is discarded from the pool by the garbage collector. Any remaining sparks are discarded at the end of execution, so &amp;ldquo;converted&amp;rdquo; plus &amp;ldquo;pruned&amp;rdquo; does not necessarily add up to the total.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0739f5ccb2bb880c7aac97c76af83b628f8a3a90" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ST&lt;/code&gt; Monad</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f614e141f7715f6c62aa646fdfcc09ca9d7280e9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ST&lt;/code&gt; monad</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95776d621e6e94b966ba5059c98ab385d9187b77" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Semigroup&lt;/code&gt; operator &lt;code&gt;(&amp;lt;&amp;gt;)&lt;/code&gt; will be in &lt;code&gt;Prelude&lt;/code&gt;, which clashes with custom local definitions of such an operator</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8bd15c25ef057d5bb7b4b11090add4deb0ab7363" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ShortByteString&lt;/code&gt; type</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42f56d1b1cf13cb62004be77c95ea28a2e463b26" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ShortByteString&lt;/code&gt; type and representation</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c01c63bcea3f47012ef7cb8b53521ef2f599690" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SomeException&lt;/code&gt; type is the root of the exception type hierarchy. When an exception of type &lt;code&gt;e&lt;/code&gt; is thrown, behind the scenes it is encapsulated in a &lt;code&gt;SomeException&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="075869aa5abeccc3e82651f71cd0b49cf876a1ed" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;StablePtr&lt;/code&gt; is freed by &lt;code&gt;hs_try_putmvar()&lt;/code&gt;. This is because it would otherwise be difficult to arrange to free the &lt;code&gt;StablePtr&lt;/code&gt; reliably: we can&amp;rsquo;t free it in Haskell, because if the &lt;code&gt;takeMVar&lt;/code&gt; is interrupted by an asynchronous exception, then the callback will fire at a later time. We can&amp;rsquo;t free it in C, because we don&amp;rsquo;t know when to free it (not when &lt;code&gt;hs_try_putmvar()&lt;/code&gt; returns, because that is an async call that uses the &lt;code&gt;StablePtr&lt;/code&gt; at some time in the future).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22a2fd434898f0f6555b4c40eb04ba5061f4dac5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;String&lt;/code&gt; type and associated operations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="063a241ae6b100332789afebed90ca2f9db07517" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Traversable&lt;/code&gt; class</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3eb004bc8ea181740ab9d964eca4039846cba0d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Tree&lt;/code&gt; datatype has two constructors. The representation of individual constructors is combined using the binary type constructor &lt;code&gt;&lt;a href=&quot;ghc-generics#t::-43-:&quot;&gt;:+:&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea0e01ff4b10acd1f300e041e7c7d24452a6bcef" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Type&lt;/code&gt; field contains the type which underlies the variable. At present, this is always &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:VarT&quot;&gt;VarT&lt;/a&gt; theName&lt;/code&gt;, but future changes may permit refinement of this.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1c62302915451aa80bfd9fc2cff479b2cf284ab" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Type&lt;/code&gt; field contains the type which underlies the variable. At present, this is always &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:VarT&quot;&gt;VarT&lt;/a&gt; theName&lt;/code&gt;, but future changes may permit refinement of this.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="027d2a06d103d553d051280a74cf3845d60d411a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;UNPACK&lt;/code&gt; indicates to the compiler that it should unpack the contents of a constructor field into the constructor itself, removing a level of indirection. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33782bed5c646b932004c73abe54633b85489d8a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Version&lt;/code&gt; type</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c935ef40843fda690b92bec23a2da13f0596d70" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;WARNING&lt;/code&gt; pragma allows you to attach an arbitrary warning to a particular function, class, or type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b5cfd9e9013fd4cb9b04f939f4f7787609c1e73" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Weak&lt;/code&gt; type</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5d131550d29246afe295414037eda39ef3a4a79" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;[2]&lt;/code&gt; means that the rule is active in Phase 2 and subsequent phases. The inverse notation &lt;code&gt;[~2]&lt;/code&gt; is also accepted, meaning that the rule is active up to, but not including, Phase 2.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e762931e5ccd90930535b3ca5e55c6d8c0924233" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;binary&lt;/code&gt; package is notable in that it provides both pure, and high performance serialisation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4bd1285d74cbd2d2cbc3ca0932f6094c43b630ed" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;buildExpressionParser&lt;/code&gt; takes care of all the complexity involved in building expression parser. Here is an example of an expression parser that handles prefix signs, postfix increment and basic arithmetic.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9dc6c10898dec30b4e5dd6a9520ac4b310a891ba" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;catch&lt;/code&gt; functions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce3c62da909521366f0612be95d0d5abc18fd5df" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cr&lt;/code&gt; capability, which moves the cursor to the first column of the current line.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41cac9a191aeb661ca1ba5373f54957c5ae0927f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;deriving( Sizable )&lt;/code&gt; is equivalent to saying</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aecea50617c919f429665961c30499dbecafe248" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;encode&lt;/code&gt; function translates elements of the buffer &lt;code&gt;from&lt;/code&gt; to the buffer &lt;code&gt;to&lt;/code&gt;. It should translate as many elements as possible given the sizes of the buffers, including translating zero elements if there is either not enough room in &lt;code&gt;to&lt;/code&gt;, or &lt;code&gt;from&lt;/code&gt; does not contain a complete multibyte sequence.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a5aa4a69bcc42b7c89b78bde09cb33ccb0cfca5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;enumFrom&lt;/code&gt;... methods are used in Haskell's translation of arithmetic sequences.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ade300f4a813bcee47f07faaadabe78ba37c7979" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;error&lt;/code&gt; function from the Prelude supports printing the call stack that led to the error in addition to the usual error message:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="511af374fd1b5b479579f0c30542d54251504918" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;evaluate&lt;/code&gt; function</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="597cda7e7f16a0e50cd5f0c4f0416902f5c0363f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;fromInteger&lt;/code&gt; (and hence also &lt;code&gt;fromIntegral&lt;/code&gt;) is a special case when converting to &lt;code&gt;Int&lt;/code&gt;. The value of &lt;code&gt;fromIntegral x :: Int&lt;/code&gt; is given by taking the lower ⟨n⟩ bits of &lt;code&gt;(abs x)&lt;/code&gt;, multiplied by the sign of &lt;code&gt;x&lt;/code&gt; (in 2&amp;rsquo;s complement ⟨n⟩-bit arithmetic). This behaviour was chosen so that for example writing &lt;code&gt;0xffffffff :: Int&lt;/code&gt; preserves the bit-pattern in the resulting &lt;code&gt;Int&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef0f4a35a1f6d1c258b22e6d87df758fac232791" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;fromIntegral&lt;/code&gt; function also preserves bit-patterns when converting between the sized integral types (&lt;code&gt;Int8&lt;/code&gt;, &lt;code&gt;Int16&lt;/code&gt;, &lt;code&gt;Int32&lt;/code&gt;, &lt;code&gt;Int64&lt;/code&gt; and the unsigned &lt;code&gt;Word&lt;/code&gt; variants), see the modules &lt;code&gt;Data.Int&lt;/code&gt; and &lt;code&gt;Data.Word&lt;/code&gt; in the library documentation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="762b16a36e554904d87f2db331ab1542095ebd78" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ghc-pkg&lt;/code&gt; program may be run in the ways listed below. Where a package name is required, the package can be named in full including the version number (e.g. &lt;code&gt;network-1.0&lt;/code&gt;), or without the version number. Naming a package without the version number matches all versions of the package; the specified action will be applied to all the matching packages. A package specifier that matches all version of the package can also be written &lt;code&gt;⟨pkg⟩ -*&lt;/code&gt;, to make it clearer that multiple packages are being matched. To match against the installed package ID instead of just package name and version, pass the &lt;code&gt;--ipid&lt;/code&gt; flag.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70e170de84746b93a247accd0e8bc402d6a2ea08" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ghc&lt;/code&gt; package exposes most of GHC&amp;rsquo;s frontend to users, and thus allows you to write programs that leverage it. This library is actually the same library used by GHC&amp;rsquo;s internal, frontend compilation driver, and thus allows you to write tools that programmatically compile source code and inspect it. Such functionality is useful in order to write things like IDE or refactoring tools. As a simple example, here&amp;rsquo;s a program which compiles a module, much like ghc itself does by default when invoked:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e102bed194230593a0e69925d95b61dfc6e1bb63" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ghci.conf&lt;/code&gt; file is most useful for turning on favourite options (e.g. &lt;code&gt;:set +s&lt;/code&gt;), and defining useful macros.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d742d7f4cd29eb0f301c0d47b2cc254469da39b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;handle&lt;/code&gt; functions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34d765516635c10fcdf110fa543c8ace7e8ff1fc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;hi-boot&lt;/code&gt; generated by compiling a &lt;code&gt;hs-boot&lt;/code&gt; file is in the same machine-generated binary format as any other GHC-generated interface file (e.g. &lt;code&gt;B.hi&lt;/code&gt;). You can display its contents with &lt;code&gt;ghc --show-iface&lt;/code&gt;. If you specify a directory for interface files, the &lt;code&gt;-ohidir&lt;/code&gt; flag, then that affects &lt;code&gt;hi-boot&lt;/code&gt; files too.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="355d829a4b676f5ca653b94b80c9807cda2a9d2f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;hsc2hs&lt;/code&gt; command can be used to automate some parts of the process of writing Haskell bindings to C code. It reads an almost-Haskell source with embedded special constructs, and outputs a real Haskell file with these constructs processed, based on information taken from some C headers. The extra constructs deal with accessing C data from Haskell.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2823e69f2a65d7ce80b8fd7a101d62eed4e1c66" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;i2d&lt;/code&gt; function is virtually one machine instruction; the default conversion&amp;mdash;via an intermediate &lt;code&gt;Rational&lt;/code&gt;-is obscenely expensive by comparison.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c8dc7d7a696a83968e6e8dd5a58a6b1ef2a23b8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;id&lt;/code&gt; of a cost-centre listed in the &lt;code&gt;cost_centres&lt;/code&gt; list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f33c5545ef78687d7ec80abf9761102bfc37c4e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;import A hiding( g )&lt;/code&gt; in module &lt;code&gt;B&lt;/code&gt; is technically an error (&lt;a href=&quot;http://www.haskell.org/onlinereport/haskell2010/haskellch5.html#x11-1020005.3.1&quot;&gt;Haskell Report, 5.3.1&lt;/a&gt;) because &lt;code&gt;A&lt;/code&gt; does not export &lt;code&gt;g&lt;/code&gt;. However GHC allows it, in the interests of supporting backward compatibility; for example, a newer version of &lt;code&gt;A&lt;/code&gt; might export &lt;code&gt;g&lt;/code&gt;, and you want &lt;code&gt;B&lt;/code&gt; to work in either case.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f41076a0857a53fdc32d3736b60eb827f4f251e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;import&lt;/code&gt; declaration (&lt;a href=&quot;#ghci-import-decl&quot;&gt;Controlling what is in scope with import&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ad2ceafe50f168640b42ddfd5b779521b31a687" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;instance&lt;/code&gt; keyword is optional.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6290f04db0b506c583506333aeba21e56f7af2ab" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;lazyIOExample&lt;/code&gt; uses lazy I/O to read the file from the disk, which is not suitable in all applications, and certainly not if you need to read from a socket which has higher likelihood to fail. To address these needs, use the incremental input method like in &lt;code&gt;incrementalExample&lt;/code&gt;. For an example of how to read incrementally from a Handle, see the implementation of &lt;code&gt;&lt;a href=&quot;data-binary#v:decodeFileOrFail&quot;&gt;decodeFileOrFail&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2176a754f25110a9917a6219e63404e3208eea44" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;mapException&lt;/code&gt; function</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c837f409d9c890ff0cf84a0f23501c248975f873" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;mask_&lt;/code&gt; is to avoid asynchronous exceptions before the &lt;code&gt;scheduleCallback&lt;/code&gt; call, which would leak the &lt;code&gt;StablePtr&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88156e7be9a84c3b32b21ca9033fb9b40a86fc7d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;mdo&lt;/code&gt; notation removes the burden of placing explicit &lt;code&gt;rec&lt;/code&gt; blocks in the code. Unlike an ordinary &lt;code&gt;do&lt;/code&gt; expression, in which variables bound by statements are only in scope for later statements, variables bound in an &lt;code&gt;mdo&lt;/code&gt; expression are in scope for all statements of the expression. The compiler then automatically identifies minimal mutually recursively dependent segments of statements, treating them as if the user had wrapped a &lt;code&gt;rec&lt;/code&gt; qualifier around them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6a07857e87c25a69a2a85f3c6940b5d3da66364" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;needle&lt;/code&gt; parameter may not be empty.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03da503ca798d541eacd37351134d51c710473a9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;nel&lt;/code&gt; capability, which moves the cursor to the first column of the next line. It behaves like a carriage return followed by a line feed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41854e5bb2dcfb535a78b10a713fbfca69450478" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;nubIntOn&lt;/code&gt; function behaves just like &lt;code&gt;&lt;a href=&quot;data-containers-listutils#v:nubInt&quot;&gt;nubInt&lt;/a&gt;&lt;/code&gt; except it performs comparisons not on the original datatype, but a user-specified projection from that datatype. For example, &lt;code&gt;nubIntOn &lt;a href=&quot;../base-4.13.0.0/prelude#v:fromEnum&quot;&gt;fromEnum&lt;/a&gt;&lt;/code&gt; can be used to nub characters and typical fixed-with numerical types efficiently.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d601cddbbd9d7126bc0e97c81bf6fdd7871c9080" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;nubOrdOn&lt;/code&gt; function behaves just like &lt;code&gt;&lt;a href=&quot;data-containers-listutils#v:nubOrd&quot;&gt;nubOrd&lt;/a&gt;&lt;/code&gt; except it performs comparisons not on the original datatype, but a user-specified projection from that datatype.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d367aba8a4bc7af80523df0833dbadc25b08592e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;only1&lt;/code&gt; and &lt;code&gt;only2&lt;/code&gt; methods &lt;em&gt;must return a map with a subset (possibly empty) of the keys of the given map&lt;/em&gt;. The values can be modified arbitrarily. Most common variants of &lt;code&gt;only1&lt;/code&gt; and &lt;code&gt;only2&lt;/code&gt; are &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-function#v:id&quot;&gt;id&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-function#v:const&quot;&gt;const&lt;/a&gt; &lt;a href=&quot;data-intmap-lazy#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt;, but for example &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:map&quot;&gt;map&lt;/a&gt; f&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:filterWithKey&quot;&gt;filterWithKey&lt;/a&gt; f&lt;/code&gt; could be used for any &lt;code&gt;f&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87db766c3fcfe957880bc536c8055be89a67ca05" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;only1&lt;/code&gt; and &lt;code&gt;only2&lt;/code&gt; methods &lt;em&gt;must return a map with a subset (possibly empty) of the keys of the given map&lt;/em&gt;. The values can be modified arbitrarily. Most common variants of &lt;code&gt;only1&lt;/code&gt; and &lt;code&gt;only2&lt;/code&gt; are &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-function#v:id&quot;&gt;id&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-function#v:const&quot;&gt;const&lt;/a&gt; &lt;a href=&quot;data-intmap-strict#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt;, but for example &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:map&quot;&gt;map&lt;/a&gt; f&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:filterWithKey&quot;&gt;filterWithKey&lt;/a&gt; f&lt;/code&gt; could be used for any &lt;code&gt;f&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b3d76aa425b2c86fc5220b26c112435a53e249f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;only1&lt;/code&gt; and &lt;code&gt;only2&lt;/code&gt; methods &lt;em&gt;must return a map with a subset (possibly empty) of the keys of the given map&lt;/em&gt;. The values can be modified arbitrarily. Most common variants of &lt;code&gt;only1&lt;/code&gt; and &lt;code&gt;only2&lt;/code&gt; are &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-function#v:id&quot;&gt;id&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-function#v:const&quot;&gt;const&lt;/a&gt; &lt;a href=&quot;data-intmap-strict-internal#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt;, but for example &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:map&quot;&gt;map&lt;/a&gt; f&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:filterWithKey&quot;&gt;filterWithKey&lt;/a&gt; f&lt;/code&gt; could be used for any &lt;code&gt;f&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe60eae85d88c9490c48aade82bc12d2974b6022" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;only1&lt;/code&gt; and &lt;code&gt;only2&lt;/code&gt; methods &lt;em&gt;must return a map with a subset (possibly empty) of the keys of the given map&lt;/em&gt;. The values can be modified arbitrarily. Most common variants of &lt;code&gt;only1&lt;/code&gt; and &lt;code&gt;only2&lt;/code&gt; are &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-function#v:id&quot;&gt;id&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-function#v:const&quot;&gt;const&lt;/a&gt; &lt;a href=&quot;data-map-lazy#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt;, but for example &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:map&quot;&gt;map&lt;/a&gt; f&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:filterWithKey&quot;&gt;filterWithKey&lt;/a&gt; f&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:mapMaybeWithKey&quot;&gt;mapMaybeWithKey&lt;/a&gt; f&lt;/code&gt; could be used for any &lt;code&gt;f&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48239e0c803c6ef0e5cd08862ca58810b64b5781" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;only1&lt;/code&gt; and &lt;code&gt;only2&lt;/code&gt; methods &lt;em&gt;must return a map with a subset (possibly empty) of the keys of the given map&lt;/em&gt;. The values can be modified arbitrarily. Most common variants of &lt;code&gt;only1&lt;/code&gt; and &lt;code&gt;only2&lt;/code&gt; are &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-function#v:id&quot;&gt;id&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-function#v:const&quot;&gt;const&lt;/a&gt; &lt;a href=&quot;data-map-strict#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt;, but for example &lt;code&gt;&lt;a href=&quot;data-map-strict#v:map&quot;&gt;map&lt;/a&gt; f&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-map-strict#v:filterWithKey&quot;&gt;filterWithKey&lt;/a&gt; f&lt;/code&gt; could be used for any &lt;code&gt;f&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46099596c66e9f01cbd3f7bcc5b5f08680659ccd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pat_lhs&lt;/code&gt; for explicitly bidirectional construction cannot use Record syntax. (Because the rhs &lt;em&gt;expr&lt;/em&gt; might be constructing different data constructors.) It can use guards with multiple equations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c77daba6d5e5a119d170e42d9dd4a10538222183" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;qq&lt;/code&gt; quasiquoter would be able to see the definition of &lt;code&gt;f&lt;/code&gt; from the preceding declaration group, but not the definitions of &lt;code&gt;h&lt;/code&gt; or &lt;code&gt;k&lt;/code&gt;, or any definitions from subsequent declaration groups.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c466f28061a085d0fe280fa263ce6f774fe3c68f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;recover&lt;/code&gt; function is used to continue decoding in the presence of invalid or unrepresentable sequences. This includes both those detected by &lt;code&gt;encode&lt;/code&gt; returning &lt;code&gt;InvalidSequence&lt;/code&gt; and those that occur because the input byte sequence appears to be truncated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a473a7ced8aa63a52d8a8ae70bef9c494ad7a2e1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;return&lt;/code&gt; function simply creates a continuation which passes the value on.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81379fa1503519747e0a096e84f164e14f442525" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;runghc&lt;/code&gt; command-line looks like:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa8f29d0aba7b46039df62fe50f4c7d9ad9965c3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;shows&lt;/code&gt; functions return a function that prepends the output &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; to an existing &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;. This allows constant-time concatenation of results using function composition.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2bfd895a0337bb9829478985b48c54b24e2e9ad9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;shows&lt;/code&gt; functions return a function that prepends the output &lt;code&gt;&lt;a href=&quot;prelude#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; to an existing &lt;code&gt;&lt;a href=&quot;prelude#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;. This allows constant-time concatenation of results using function composition.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8762c6cbedea04c42d6cbeebccb6250ad93ea53a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;sprint&lt;/code&gt; function adds an exclamation mark at the end of any printed value. Running GHCi with the command:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8ab09f95cb11cc6d3321f577cbb4de51fef8004" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;state hack&lt;/code&gt; optimization can result in non-obvious changes in evaluation ordering which may hide exceptions, even with &lt;a href=&quot;using-optimisation#ghc-flag--fpedantic-bottoms&quot;&gt;&lt;code&gt;-fpedantic-bottoms&lt;/code&gt;&lt;/a&gt; (see, e.g., &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/7411&quot;&gt;Issue #7411&lt;/a&gt;). For instance,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3fc26580a12c7237de8bc3feeef150e25e82b7eb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;template-haskell&lt;/code&gt; library provides &lt;code&gt;Lift&lt;/code&gt; instances for many common data types. Furthermore, it is possible to derive &lt;code&gt;Lift&lt;/code&gt; instances automatically by using the &lt;a href=&quot;#extension-DeriveLift&quot;&gt;&lt;code&gt;DeriveLift&lt;/code&gt;&lt;/a&gt; language extension. See &lt;a href=&quot;#deriving-lift&quot;&gt;Deriving Lift instances&lt;/a&gt; for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="adbf9d076f18bc800a1c0458fc70e137b98ee09f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;try&lt;/code&gt; combinator can for example be used to distinguish identifiers and reserved words. Both reserved words and identifiers are a sequence of letters. Whenever we expect a certain reserved word where we can also expect an identifier we have to use the &lt;code&gt;try&lt;/code&gt; combinator. Suppose we write:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d03c88b23debcedbc11667e18141e6115f243880" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;try&lt;/code&gt; functions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9192255b8c683615d80a4ee64628e5e043860b7b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;type role&lt;/code&gt; (enabled with &lt;a href=&quot;#extension-RoleAnnotations&quot;&gt;&lt;code&gt;RoleAnnotations&lt;/code&gt;&lt;/a&gt;) declaration forces the parameter &lt;code&gt;a&lt;/code&gt; to be at role representational, not role phantom. GHC then checks the user-supplied roles to make sure they don&amp;rsquo;t break any promises. It would be bad, for example, if the user could make &lt;code&gt;BadIdea&lt;/code&gt;&amp;lsquo;s role be representational.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b020a7d468bfda2ff2309461d916b84feeabc338" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;{-# SOURCE #-}&lt;/code&gt; pragma is used only in &lt;code&gt;import&lt;/code&gt; declarations, to break a module loop. It is described in detail in &lt;a href=&quot;separate_compilation#mutual-recursion&quot;&gt;How to compile mutually recursive modules&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ee4634b8912c617cc4c956549ecbf5f2fbc8ae6" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;global package database&lt;/em&gt;, which comes with your GHC installation, e.g. &lt;code&gt;/usr/lib/ghc-6.12.1/package.conf.d&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a81be10d439420dbf2ec989064392ad08ec7838" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;interactive options&lt;/em&gt; apply when evaluating expressions and commands typed at the GHCi prompt.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7491cf46ec5e1fbb15f8b7eb9e41d24a24f00f6a" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;k&lt;/em&gt;th match, followed by the remainder of the string</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc4c2343b61995f2f1a5ec7cbe01528dd89e1ed3" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;loading options&lt;/em&gt; apply when loading modules</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80049228c8301318bfcd4d99de0d8c4f642d80d1" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;user package database&lt;/em&gt; private to each user. On Unix systems this will be &lt;code&gt;$HOME/.ghc/arch-os-version/package.conf.d&lt;/code&gt;, and on Windows it will be something like &lt;code&gt;C:\Documents&amp;nbsp;And&amp;nbsp;Settings\user\ghc\package.conf.d&lt;/code&gt;. The &lt;code&gt;ghc-pkg&lt;/code&gt; tool knows where this file should be located, and will create it if it doesn&amp;rsquo;t exist (see &lt;a href=&quot;#package-management&quot;&gt;Package management (the ghc-pkg command)&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06291563b1a287d734cf4e445906b8935befc784" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;ghc-pkg&lt;/strong&gt; tool is for querying and modifying package databases. To see what package databases are in use, use &lt;code&gt;ghc-pkg list&lt;/code&gt;. The stack of databases that &lt;strong&gt;ghc-pkg&lt;/strong&gt; knows about can be modified using the &lt;a href=&quot;#envvar-GHC_PACKAGE_PATH&quot; id=&quot;index-10&quot;&gt;&lt;code&gt;GHC_PACKAGE_PATH&lt;/code&gt;&lt;/a&gt; environment variable (see &lt;a href=&quot;#ghc-package-path&quot;&gt;The GHC_PACKAGE_PATH environment variable&lt;/a&gt;, and using &lt;a href=&quot;#ghc-flag--package-db%20%E2%9F%A8file%E2%9F%A9&quot;&gt;&lt;code&gt;-package-db ⟨file⟩&lt;/code&gt;&lt;/a&gt; options on the &lt;strong&gt;ghc-pkg&lt;/strong&gt; command line.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21c02a6f4db72c82bb4b16489a1dc3d9f3dcd251" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;gv&lt;/strong&gt; and &lt;strong&gt;ghostview&lt;/strong&gt; programs have a &amp;ldquo;watch file&amp;rdquo; option can be used to view an up-to-date heap profile of your program as it runs. Simply generate an incremental heap profile as described in the previous section. Run &lt;strong&gt;gv&lt;/strong&gt; on your profile:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2745da38f58a1f51bf9ab0d3486cc161c559b3b" translate="yes" xml:space="preserve">
          <source>The ASCII encoding is a 7-bit encoding. The &lt;em&gt;Char7&lt;/em&gt; encoding implemented here works by truncating the Unicode codepoint to 7-bits, prefixing it with a leading 0, and encoding the resulting 8-bits as a single byte. For the codepoints 0-127 this corresponds the ASCII encoding.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3335871b5b9fc97a659ecaa26da1b75a25e4dbb8" translate="yes" xml:space="preserve">
          <source>The Accum monad</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54a2a116adb6e3d511623890991b066600f4a837" translate="yes" xml:space="preserve">
          <source>The AccumT monad transformer</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e322260aafb4a2f2a2ca6cdac3c65b6a2316bc3a" translate="yes" xml:space="preserve">
          <source>The Any type</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77184a896c809c5987a275354391bcb9afa84715" translate="yes" xml:space="preserve">
          <source>The Binary class</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f21b224c49e198997a984cc9f95eb312adc1246f" translate="yes" xml:space="preserve">
          <source>The Binary instance for ResolvedBCOs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1340d1532cd96c08b9077a17a6e5cf354440ec03" translate="yes" xml:space="preserve">
          <source>The Builder monoid</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66e06b4ddeb35c347cf81033820bf5237468d89f" translate="yes" xml:space="preserve">
          <source>The Builder type</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f59e6c207b1a2a380dd7912a6b135a7a6ef6d7e" translate="yes" xml:space="preserve">
          <source>The C call &lt;code&gt;hs_try_putmvar(cap, mvar)&lt;/code&gt; is equivalent to the Haskell call &lt;code&gt;tryPutMVar mvar ()&lt;/code&gt;, except that it is</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="930ac2c5a6231d7b293cf2f4934390d97c5dceec" translate="yes" xml:space="preserve">
          <source>The C code generator is only supported when GHC is built in unregisterised mode, a mode where GHC produces &amp;ldquo;portable&amp;rdquo; C code as output to facilitate porting GHC itself to a new platform. This mode produces much slower code though so it&amp;rsquo;s unlikely your version of GHC was built this way. If it has then the native code generator probably won&amp;rsquo;t be available. You can check this information by calling &lt;code&gt;ghc --info&lt;/code&gt; (see &lt;a href=&quot;using#ghc-flag---info&quot;&gt;&lt;code&gt;--info&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4478e58f6a72e43562ea06bc573417edc1f53b0" translate="yes" xml:space="preserve">
          <source>The C compiler to use (default: &lt;code&gt;gcc&lt;/code&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01130faef1141c2e4c47f77d4532a52f8115186a" translate="yes" xml:space="preserve">
          <source>The C pre-processor &lt;strong&gt;cpp&lt;/strong&gt; is run over your Haskell code only if the &lt;code&gt;-cpp&lt;/code&gt; option -cpp option is given. Unless you are building a large system with significant doses of conditional compilation, you really shouldn&amp;rsquo;t need it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be8a30e9f725c587f4c42c5c2ac8a566321ce4b5" translate="yes" xml:space="preserve">
          <source>The C program is compiled using the Haskell compiler. This provides the include path to &lt;code&gt;HsFFI.h&lt;/code&gt; which is automatically included into the C program.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e91fc210907e94074bed36ea19e87412c05ed8a0" translate="yes" xml:space="preserve">
          <source>The C-side interface</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ff7e343e1c6696d97347c4a9cd5a3b43c6bba9e" translate="yes" xml:space="preserve">
          <source>The CPU time used during GC itself</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b0e04ec6361f33e0d68f7f33f77c1ab233452ad" translate="yes" xml:space="preserve">
          <source>The Chapter does &lt;em&gt;not&lt;/em&gt; require implementations to refrain from doing the same for &lt;code&gt;unsafe&lt;/code&gt; calls, so strictly Haskell 2010-conforming programs cannot pass heap-allocated references to &lt;code&gt;unsafe&lt;/code&gt; FFI calls either.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a6d8be9dffe246766e3012760ad26dc58ac76a9" translate="yes" xml:space="preserve">
          <source>The Char type and associated operations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34ab3cac27f3b7905cb71f872510098e1f28d42c" translate="yes" xml:space="preserve">
          <source>The Char8 interface to bytestrings provides an instance of IsString for the ByteString type, enabling you to use string literals, and have them implicitly packed to ByteStrings. Use &lt;code&gt;{-# LANGUAGE OverloadedStrings #-}&lt;/code&gt; to enable this.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87a20786956ef56773cf03030aa4cf8ea1fe3cb5" translate="yes" xml:space="preserve">
          <source>The Constraint kind</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09ab3e32936ccf9f3bb679b6e68a3e00b45ed452" translate="yes" xml:space="preserve">
          <source>The Cont monad</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12f452e71f00e2687665dadf2d17184d0289a2e5" translate="yes" xml:space="preserve">
          <source>The ContT monad transformer</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca90c83f50ba973fabb4434d084cfad4acdcfc2a" translate="yes" xml:space="preserve">
          <source>The Continuation monad represents computations in continuation-passing style (CPS). In continuation-passing style function result is not returned, but instead is passed to another function, received as a parameter (continuation). Computations are built up from sequences of nested continuations, terminated by a final continuation (often &lt;code&gt;id&lt;/code&gt;) which produces the final result. Since continuations are functions which represent the future of a computation, manipulation of the continuation functions can achieve complex manipulations of the future of the computation, such as interrupting a computation in the middle, aborting a portion of a computation, restarting a computation, and interleaving execution of computations. The Continuation monad adapts CPS to the structure of a monad.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6f5f2130ef6b7cf3dfc8eaaad4cc1b44fc47954" translate="yes" xml:space="preserve">
          <source>The Coverage Condition. For each functional dependency, ⟨tvs⟩&lt;sub&gt;left&lt;/sub&gt;&lt;code&gt;-&amp;gt;&lt;/code&gt; ⟨tvs⟩&lt;sub&gt;right&lt;/sub&gt;, of the class, every type variable in S(⟨tvs⟩&lt;sub&gt;right&lt;/sub&gt;) must appear in S(⟨tvs⟩&lt;sub&gt;left&lt;/sub&gt;), where S is the substitution mapping each type variable in the class declaration to the corresponding type in the instance head.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="312777d9f2d66605158d20bff22160d55dc26cef" translate="yes" xml:space="preserve">
          <source>The Cygwin tools aim to provide a Unix-style API on top of the windows libraries, to facilitate ports of Unix software to windows. To this end, they introduce a Unix-style directory hierarchy under some root directory (typically &lt;code&gt;/&lt;/code&gt; is &lt;code&gt;C:\cygwin\&lt;/code&gt;). Moreover, everything built against the Cygwin API (including the Cygwin tools and programs compiled with Cygwin&amp;rsquo;s GHC) will see &lt;code&gt;/&lt;/code&gt; as the root of their file system, happily pretending to work in a typical unix environment, and finding things like &lt;code&gt;/bin&lt;/code&gt; and &lt;code&gt;/usr/include&lt;/code&gt; without ever explicitly bothering with their actual location on the windows system (probably &lt;code&gt;C:\cygwin\bin&lt;/code&gt; and &lt;code&gt;C:\cygwin\usr\include&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86692a9d897be5d534ba24465eb9de8f931f4ef3" translate="yes" xml:space="preserve">
          <source>The Data class for processing constructor applications</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1bf8237029872b5da672f6b7246e84175ba43046" translate="yes" xml:space="preserve">
          <source>The Dynamic interface provides basic support for dynamic types.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42156dbee11df6db43f4c8b1cc0a248822a7d3cd" translate="yes" xml:space="preserve">
          <source>The Either type, and associated operations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="807130fbb4274539dfd3c0eea747aff0499d3550" translate="yes" xml:space="preserve">
          <source>The Error monad (also called the Exception monad).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a5dc0df0c5ba4b15156469d46e722f494c0f012" translate="yes" xml:space="preserve">
          <source>The ErrorT monad transformer</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e8b0fd8b8d2403326182f44dc58f86de4db1bbe" translate="yes" xml:space="preserve">
          <source>The Except monad</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0636fa085801d03d78d892f99e7194b6c4c5113a" translate="yes" xml:space="preserve">
          <source>The ExceptT monad transformer</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28a34cf6c1c117fe3edc278dd4ce45f5bbb4e2ab" translate="yes" xml:space="preserve">
          <source>The Exception type</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fbddbb39610322fadeb3679edecc1231a3f3fbc0" translate="yes" xml:space="preserve">
          <source>The FFI features that are described in this section are specific to GHC. Your code will not be portable to other compilers if you use them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3efa5246016932362650667f0b2760b9317d9ba9" translate="yes" xml:space="preserve">
          <source>The FFI libraries are documented in the accompanying library documentation; see for example the &lt;a href=&quot;../libraries/base-4.13.0.0/foreign&quot;&gt;Foreign&lt;/a&gt; module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="761c07d2fa3147d943f9914eb230698128638338" translate="yes" xml:space="preserve">
          <source>The FFI libraries provide several ways to allocate memory for use with the FFI, and it isn&amp;rsquo;t always clear which way is the best. This decision may be affected by how efficient a particular kind of allocation is on a given compiler/platform, so this section aims to shed some light on how the different kinds of allocation perform with GHC.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6c805c7ce1959f9f4d5c3417b157ba30228b2de" translate="yes" xml:space="preserve">
          <source>The FFI spec requires the IO monad to appear in various places, but it can sometimes be convenient to wrap the IO monad in a &lt;code&gt;newtype&lt;/code&gt;, thus:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f20794bdc28c9aee5608b0c0fc201d96d6b3994" translate="yes" xml:space="preserve">
          <source>The FFI spec requires the implementation to support re-initialising itself after being shut down with &lt;code&gt;hs_exit()&lt;/code&gt;, but GHC does not currently support that. See &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/13693&quot;&gt;Issue #13693&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d26ec709c2e5283538c1c653d1aa70ca0b33423" translate="yes" xml:space="preserve">
          <source>The GC sync time, along with other GC stats, are available by calling the &lt;code&gt;getRTSStats()&lt;/code&gt; function from C, or &lt;code&gt;GHC.Stats.getRTSStats&lt;/code&gt; from Haskell.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5021fe9fe3de702f6e9a5d53a92dd7d5114b557" translate="yes" xml:space="preserve">
          <source>The GHC API exposes functions for reading and writing these files.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44e336f3335d4bce26ff1489887e65f02d167072" translate="yes" xml:space="preserve">
          <source>The GHC RTS currently can only recover from heap overflow if it detects that an explicit memory limit (set via RTS flags). has been exceeded. Currently, failure to allocate memory from the operating system results in immediate termination of the program.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="092d6db4a6acf8e0f020ffc8e891aef1e6ec0134" translate="yes" xml:space="preserve">
          <source>The GHC command line options that control packages are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61df44498694cfca7ad6514a046e11ddd08beac9" translate="yes" xml:space="preserve">
          <source>The GHC developers hang out here. If you are working with the GHC API or have a question about GHC&amp;rsquo;s implementation, feel free to chime in.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99d5e93b8c29504ff8cde4bfb2796cf7747d055b" translate="yes" xml:space="preserve">
          <source>The GHC driver pre-defines several macros when processing Haskell source code (&lt;code&gt;.hs&lt;/code&gt; or &lt;code&gt;.lhs&lt;/code&gt; files).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87a5e3c32c7140b14331679393031a63e7e433b2" translate="yes" xml:space="preserve">
          <source>The GHC runtime treats program exit as a special case, to avoid the need to wait for blocked threads when a standalone executable exits. Since the program and all its threads are about to terminate at the same time that the code is removed from memory, it isn&amp;rsquo;t necessary to ensure that the threads have exited first. If you want this fast and loose version of &lt;code&gt;hs_exit()&lt;/code&gt;, you can call:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="657d0403b8cb260dd76b91b660bfb82ac7e59695" translate="yes" xml:space="preserve">
          <source>The GHCi &lt;a href=&quot;ghci#ghci-cmd-:info&quot;&gt;&lt;code&gt;:info&lt;/code&gt;&lt;/a&gt; command shows pattern types in this format.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b98fc3571126a85946312283e8cabf74b5c92953" translate="yes" xml:space="preserve">
          <source>The GHCi Monad lifting interface.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ebe9d3dd8c4ab5bd81e3a57040f569e196489a32" translate="yes" xml:space="preserve">
          <source>The GHCi debugger offers a way to hopefully shed some light on these errors quickly and without modifying or recompiling the source code. One way would be to set a breakpoint on the location in the source code that throws the exception, and then use &lt;a href=&quot;#ghci-cmd-:trace&quot;&gt;&lt;code&gt;:trace&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#ghci-cmd-:history&quot;&gt;&lt;code&gt;:history&lt;/code&gt;&lt;/a&gt; to establish the context. However, &lt;code&gt;head&lt;/code&gt; is in a library and we can&amp;rsquo;t set a breakpoint on it directly. For this reason, GHCi provides the flags &lt;a href=&quot;#ghc-flag--fbreak-on-exception&quot;&gt;&lt;code&gt;-fbreak-on-exception&lt;/code&gt;&lt;/a&gt; which causes the evaluator to stop when an exception is thrown, and &lt;a href=&quot;#ghc-flag--fbreak-on-error&quot;&gt;&lt;code&gt;-fbreak-on-error&lt;/code&gt;&lt;/a&gt;, which works similarly but stops only on uncaught exceptions. When stopping at an exception, GHCi will act just as it does when a breakpoint is hit, with the deviation that it will not show you any source code location. Due to this, these commands are only really useful in conjunction with &lt;a href=&quot;#ghci-cmd-:trace&quot;&gt;&lt;code&gt;:trace&lt;/code&gt;&lt;/a&gt;, in order to log the steps leading up to the exception. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b891d2a1ce80a9fee00fa3b6d6737a43b10a747" translate="yes" xml:space="preserve">
          <source>The Get and Put monads</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b776a2d45a7f2c193506de5827ffca159fdaaa31" translate="yes" xml:space="preserve">
          <source>The Get monad</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="881d557edd11af5e9c88e4e2caa565a9b7f16b2b" translate="yes" xml:space="preserve">
          <source>The Handle is closed once the contents have been read, or if an exception is thrown.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9fc6da9c66a23f0d4306adb850fbe34a26d020b4" translate="yes" xml:space="preserve">
          <source>The Haskell 2010 Report specifies that &lt;code&gt;safe&lt;/code&gt; FFI calls must allow foreign calls to safely call into Haskell code. In practice, this means that the garbage collector must be able to run while these calls are in progress, moving heap-allocated Haskell values around arbitrarily.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4f4e3694b9cec057dc91d201d6594fcb8794184" translate="yes" xml:space="preserve">
          <source>The Haskell 2010 definition of &lt;code&gt;Show&lt;/code&gt; stipulates that the rendered string should only include parentheses which are necessary to unambiguously parse the result. For historical reasons, &lt;code&gt;Show&lt;/code&gt; instances derived by GHC include parentheses around records despite the fact that record syntax binds more tightly than function application; e.g.,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75b51a038a288722ea47d665ae6b1906f2f2ca30" translate="yes" xml:space="preserve">
          <source>The Haskell 2010 type for exceptions in the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad. Any I/O operation may raise an &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; instead of returning a result. For a more general type of exception, including also those that arise in pure code, see &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-exception#v:Exception&quot;&gt;Exception&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb081bfa52eb8a4cbf05cd929cfffa397e641c26" translate="yes" xml:space="preserve">
          <source>The Haskell 2010 type for exceptions in the &lt;code&gt;&lt;a href=&quot;prelude#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad. Any I/O operation may raise an &lt;code&gt;&lt;a href=&quot;prelude#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; instead of returning a result. For a more general type of exception, including also those that arise in pure code, see &lt;code&gt;&lt;a href=&quot;control-exception#v:Exception&quot;&gt;Exception&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a99410a64c91a4399b3bdd6ca6ecba63bbee421d" translate="yes" xml:space="preserve">
          <source>The Haskell 2010 type for exceptions in the &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad. Any I/O operation may raise an &lt;code&gt;&lt;a href=&quot;ghc-io-exception#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; instead of returning a result. For a more general type of exception, including also those that arise in pure code, see &lt;code&gt;&lt;a href=&quot;control-exception#v:Exception&quot;&gt;Exception&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="608a1f6c6546f6329017b0ba471b028aef303e51" translate="yes" xml:space="preserve">
          <source>The Haskell 2010 type for exceptions in the &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad. Any I/O operation may raise an &lt;code&gt;&lt;a href=&quot;system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; instead of returning a result. For a more general type of exception, including also those that arise in pure code, see &lt;code&gt;&lt;a href=&quot;control-exception#v:Exception&quot;&gt;Exception&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cbd1a39cbde2acf402014630435be0c05fcd70ac" translate="yes" xml:space="preserve">
          <source>The Haskell 98 definition of &lt;code&gt;isAlpha&lt;/code&gt; is:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bcc5878839ee58bc74d82cc3033b4e47a4421ec2" translate="yes" xml:space="preserve">
          <source>The Haskell FFI already specifies that arguments and results of foreign imports and exports will be automatically unwrapped if they are newtypes (Section 3.2 of the FFI addendum). GHC extends the FFI by automatically unwrapping any newtypes that wrap the IO monad itself. More precisely, wherever the FFI specification requires an &lt;code&gt;IO&lt;/code&gt; type, GHC will accept any newtype-wrapping of an &lt;code&gt;IO&lt;/code&gt; type. For example, these declarations are OK:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4680c4ac34e14b7370d55faae60bc019d40c3efc" translate="yes" xml:space="preserve">
          <source>The Haskell Report defines no laws for &lt;code&gt;&lt;a href=&quot;data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt;. However, &lt;code&gt;&lt;a href=&quot;data-eq#v:-61--61-&quot;&gt;==&lt;/a&gt;&lt;/code&gt; is customarily expected to implement an equivalence relationship where two values comparing equal are indistinguishable by &quot;public&quot; functions, with a &quot;public&quot; function being one not allowing to see implementation details. For example, for a type representing non-normalised natural numbers modulo 100, a &quot;public&quot; function doesn't make the difference between 1 and 201. It is expected to have the following properties:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b435dd60d544eb355fdb3b5a53612290c22abfda" translate="yes" xml:space="preserve">
          <source>The Haskell Report defines no laws for &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt;. However, &lt;code&gt;&lt;a href=&quot;data-ord#v:-60--61-&quot;&gt;&amp;lt;=&lt;/a&gt;&lt;/code&gt; is customarily expected to implement a non-strict partial order and have the following properties:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88538894fe954a03ab344dde58ca70fb4af218ac" translate="yes" xml:space="preserve">
          <source>The Haskell Report defines no laws for &lt;code&gt;&lt;a href=&quot;ghc-float#t:Floating&quot;&gt;Floating&lt;/a&gt;&lt;/code&gt;. However, &lt;code&gt;(&lt;a href=&quot;prelude#v:-43-&quot;&gt;+&lt;/a&gt;)&lt;/code&gt;, &lt;code&gt;(&lt;a href=&quot;prelude#v:-42-&quot;&gt;*&lt;/a&gt;)&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ghc-float#v:exp&quot;&gt;exp&lt;/a&gt;&lt;/code&gt; are customarily expected to define an exponential field and have the following properties:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3149c28629f6ab1e2da394471685318956b0ba8a" translate="yes" xml:space="preserve">
          <source>The Haskell Report defines no laws for &lt;code&gt;&lt;a href=&quot;ghc-num#t:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt;. However, &lt;code&gt;(&lt;a href=&quot;ghc-num#v:-43-&quot;&gt;+&lt;/a&gt;)&lt;/code&gt; and &lt;code&gt;(&lt;a href=&quot;ghc-num#v:-42-&quot;&gt;*&lt;/a&gt;)&lt;/code&gt; are customarily expected to define a ring and have the following properties:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d88eda2762d9273ae973553c58bcc0bd71af620" translate="yes" xml:space="preserve">
          <source>The Haskell Report defines no laws for &lt;code&gt;&lt;a href=&quot;ghc-real#t:Fractional&quot;&gt;Fractional&lt;/a&gt;&lt;/code&gt;. However, &lt;code&gt;(&lt;a href=&quot;prelude#v:-43-&quot;&gt;+&lt;/a&gt;)&lt;/code&gt; and &lt;code&gt;(&lt;a href=&quot;prelude#v:-42-&quot;&gt;*&lt;/a&gt;)&lt;/code&gt; are customarily expected to define a division ring and have the following properties:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e76164abdc0256cd6250a3085c5fb79d40aac6bd" translate="yes" xml:space="preserve">
          <source>The Haskell Report defines no laws for &lt;code&gt;&lt;a href=&quot;ghc-real#t:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt;. However, &lt;code&gt;&lt;a href=&quot;ghc-real#t:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt; instances are customarily expected to define a Euclidean domain and have the following properties for the &lt;code&gt;&lt;a href=&quot;ghc-real#v:div&quot;&gt;div&lt;/a&gt;&lt;/code&gt;/&lt;code&gt;&lt;a href=&quot;ghc-real#v:mod&quot;&gt;mod&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ghc-real#v:quot&quot;&gt;quot&lt;/a&gt;&lt;/code&gt;/&lt;code&gt;&lt;a href=&quot;ghc-real#v:rem&quot;&gt;rem&lt;/a&gt;&lt;/code&gt; pairs, given suitable Euclidean functions &lt;code&gt;f&lt;/code&gt; and &lt;code&gt;g&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ce7650ff72472c9e39924a0365fbdbae6a3a423" translate="yes" xml:space="preserve">
          <source>The Haskell Report defines no laws for &lt;code&gt;&lt;a href=&quot;numeric#t:Floating&quot;&gt;Floating&lt;/a&gt;&lt;/code&gt;. However, &lt;code&gt;(&lt;a href=&quot;prelude#v:-43-&quot;&gt;+&lt;/a&gt;)&lt;/code&gt;, &lt;code&gt;(&lt;a href=&quot;prelude#v:-42-&quot;&gt;*&lt;/a&gt;)&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;numeric#v:exp&quot;&gt;exp&lt;/a&gt;&lt;/code&gt; are customarily expected to define an exponential field and have the following properties:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8323805ef3fcd8127cc342507191554f2e774a6e" translate="yes" xml:space="preserve">
          <source>The Haskell Report defines no laws for &lt;code&gt;&lt;a href=&quot;prelude#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt;. However, &lt;code&gt;&lt;a href=&quot;prelude#v:-61--61-&quot;&gt;==&lt;/a&gt;&lt;/code&gt; is customarily expected to implement an equivalence relationship where two values comparing equal are indistinguishable by &quot;public&quot; functions, with a &quot;public&quot; function being one not allowing to see implementation details. For example, for a type representing non-normalised natural numbers modulo 100, a &quot;public&quot; function doesn't make the difference between 1 and 201. It is expected to have the following properties:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b48c329c20a3981396eab2a99555375b78674fa9" translate="yes" xml:space="preserve">
          <source>The Haskell Report defines no laws for &lt;code&gt;&lt;a href=&quot;prelude#t:Floating&quot;&gt;Floating&lt;/a&gt;&lt;/code&gt;. However, &lt;code&gt;(&lt;a href=&quot;prelude#v:-43-&quot;&gt;+&lt;/a&gt;)&lt;/code&gt;, &lt;code&gt;(&lt;a href=&quot;prelude#v:-42-&quot;&gt;*&lt;/a&gt;)&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;prelude#v:exp&quot;&gt;exp&lt;/a&gt;&lt;/code&gt; are customarily expected to define an exponential field and have the following properties:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c7fa25d86a0693f27eca0a0ad84f5518dec11cf" translate="yes" xml:space="preserve">
          <source>The Haskell Report defines no laws for &lt;code&gt;&lt;a href=&quot;prelude#t:Fractional&quot;&gt;Fractional&lt;/a&gt;&lt;/code&gt;. However, &lt;code&gt;(&lt;a href=&quot;prelude#v:-43-&quot;&gt;+&lt;/a&gt;)&lt;/code&gt; and &lt;code&gt;(&lt;a href=&quot;prelude#v:-42-&quot;&gt;*&lt;/a&gt;)&lt;/code&gt; are customarily expected to define a division ring and have the following properties:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="813c73ced84a637d883552041de27732ad7f49d9" translate="yes" xml:space="preserve">
          <source>The Haskell Report defines no laws for &lt;code&gt;&lt;a href=&quot;prelude#t:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt;. However, &lt;code&gt;&lt;a href=&quot;prelude#t:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt; instances are customarily expected to define a Euclidean domain and have the following properties for the &lt;code&gt;&lt;a href=&quot;prelude#v:div&quot;&gt;div&lt;/a&gt;&lt;/code&gt;/&lt;code&gt;&lt;a href=&quot;prelude#v:mod&quot;&gt;mod&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;prelude#v:quot&quot;&gt;quot&lt;/a&gt;&lt;/code&gt;/&lt;code&gt;&lt;a href=&quot;prelude#v:rem&quot;&gt;rem&lt;/a&gt;&lt;/code&gt; pairs, given suitable Euclidean functions &lt;code&gt;f&lt;/code&gt; and &lt;code&gt;g&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04a2d6720afe45625eeed33bd966e63b2869f306" translate="yes" xml:space="preserve">
          <source>The Haskell Report defines no laws for &lt;code&gt;&lt;a href=&quot;prelude#t:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt;. However, &lt;code&gt;(&lt;a href=&quot;prelude#v:-43-&quot;&gt;+&lt;/a&gt;)&lt;/code&gt; and &lt;code&gt;(&lt;a href=&quot;prelude#v:-42-&quot;&gt;*&lt;/a&gt;)&lt;/code&gt; are customarily expected to define a ring and have the following properties:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79c8c45566ea3ef649482a06f412a05df4a6acfa" translate="yes" xml:space="preserve">
          <source>The Haskell Report defines no laws for &lt;code&gt;&lt;a href=&quot;prelude#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt;. However, &lt;code&gt;&lt;a href=&quot;prelude#v:-60--61-&quot;&gt;&amp;lt;=&lt;/a&gt;&lt;/code&gt; is customarily expected to implement a non-strict partial order and have the following properties:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6f54f30ee874469ea4834b2c92a3bff6d9a4e7e" translate="yes" xml:space="preserve">
          <source>The Haskell Report demands that, for infix operators &lt;code&gt;%&lt;/code&gt;, the following identities hold:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fda99c30e66a8cf02c9c342a9bf010a7836b92f1" translate="yes" xml:space="preserve">
          <source>The Haskell Report describes that &lt;code&gt;*&lt;/code&gt; (spelled &lt;code&gt;Type&lt;/code&gt; and imported from &lt;code&gt;Data.Kind&lt;/code&gt; in the GHC dialect of Haskell) is the kind of ordinary datatypes, such as &lt;code&gt;Int&lt;/code&gt;. Furthermore, type constructors can have kinds with arrows; for example, &lt;code&gt;Maybe&lt;/code&gt; has kind &lt;code&gt;Type -&amp;gt; Type&lt;/code&gt;. Unboxed types have a kind that specifies their runtime representation. For example, the type &lt;code&gt;Int#&lt;/code&gt; has kind &lt;code&gt;TYPE 'IntRep&lt;/code&gt; and &lt;code&gt;Double#&lt;/code&gt; has kind &lt;code&gt;TYPE 'DoubleRep&lt;/code&gt;. These kinds say that the runtime representation of an &lt;code&gt;Int#&lt;/code&gt; is a machine integer, and the runtime representation of a &lt;code&gt;Double#&lt;/code&gt; is a machine double-precision floating point. In contrast, the kind &lt;code&gt;Type&lt;/code&gt; is actually just a synonym for &lt;code&gt;TYPE
'LiftedRep&lt;/code&gt;. More details of the &lt;code&gt;TYPE&lt;/code&gt; mechanisms appear in the &lt;a href=&quot;#runtime-rep&quot;&gt;section on runtime representation polymorphism&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ffc08730dc1e1e7dc18e8e0b58ddcb43b8e6870" translate="yes" xml:space="preserve">
          <source>The Haskell Report is vague about exactly when a &lt;code&gt;deriving&lt;/code&gt; clause is legal. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5dd54d84f1861492e330313f2bf345ca47769e1b" translate="yes" xml:space="preserve">
          <source>The Haskell Report specifies that a group of bindings (at top level, or in a &lt;code&gt;let&lt;/code&gt; or &lt;code&gt;where&lt;/code&gt;) should be sorted into strongly-connected components, and then type-checked in dependency order (&lt;a href=&quot;http://www.haskell.org/onlinereport/decls.html#sect4.5.1&quot;&gt;Haskell Report, Section 4.5.1&lt;/a&gt;). As each group is type-checked, any binders of the group that have an explicit type signature are put in the type environment with the specified polymorphic type, and all others are monomorphic until the group is generalised (&lt;a href=&quot;http://www.haskell.org/onlinereport/decls.html#sect4.5.2&quot;&gt;Haskell Report, Section 4.5.2&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f79c4bbad9a41e128d187b8c2ef86a8f611b12b5" translate="yes" xml:space="preserve">
          <source>The Haskell code in a package may be built into one or more archive libraries (e.g. &lt;code&gt;libHSfoo.a&lt;/code&gt;), or a single shared object (e.g. &lt;code&gt;libHSfoo.dll/.so/.dylib&lt;/code&gt;). The restriction to a single shared object is because the package system is used to tell the compiler when it should make an inter-shared-object call rather than an intra-shared-object-call call (inter-shared-object calls require an extra indirection).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c75300a05da2e87e80a93270dd95d3e5ff6d9a5" translate="yes" xml:space="preserve">
          <source>The Haskell implementation with which the program was compiled or is being interpreted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29f87244b686c50c8127fd2dc9c33f53eb1c0ecb" translate="yes" xml:space="preserve">
          <source>The Haskell report &lt;a href=&quot;https://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-220003&quot;&gt;defines&lt;/a&gt; the &lt;code&gt;lexp&lt;/code&gt; nonterminal thus (&lt;code&gt;*&lt;/code&gt; indicates a rule of interest):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75d99185af7621d262f47061ebc9fcce26c3d99a" translate="yes" xml:space="preserve">
          <source>The Haskell2010 Report specifies in &amp;lt;&lt;a href=&quot;https://www.haskell.org/onlinereport/haskell2010/haskellch5.html#x11-990005.1&quot;&gt;https://www.haskell.org/onlinereport/haskell2010/haskellch5.html#x11-990005.1&lt;/a&gt;&amp;gt; that</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18dcf9c1fa4567e3d746274c7c15cc6b75881bbb" translate="yes" xml:space="preserve">
          <source>The IO monad</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc0f546679107f369d6f8715d864a3e34b5c091c" translate="yes" xml:space="preserve">
          <source>The IOArray type</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="737d5b10a286b500beaf74123af646266a400fbd" translate="yes" xml:space="preserve">
          <source>The IOMode type</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65b73403a619cdf0ecd51edadceb4eff94590c0c" translate="yes" xml:space="preserve">
          <source>The IORef type</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="558e32d8065fb827c731043184d460a503306a06" translate="yes" xml:space="preserve">
          <source>The ISO/IEC 8859-1 encoding is an 8-bit encoding often known as Latin-1. The &lt;em&gt;Char8&lt;/em&gt; encoding implemented here works by truncating the Unicode codepoint to 8-bits and encoding them as a single byte. For the codepoints 0-255 this corresponds to the ISO/IEC 8859-1 encoding.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54ad98c5ffd0b94e42a9d57326f087c3d7345412" translate="yes" xml:space="preserve">
          <source>The ISO/IEC 8859-1 encoding is an 8-bit encoding often known as Latin-1. The &lt;em&gt;Char8&lt;/em&gt; encoding implemented here works by truncating the Unicode codepoint to 8-bits and encoding them as a single byte. For the codepoints 0-255 this corresponds to the ISO/IEC 8859-1 encoding. Note that the Char8 encoding is equivalent to the ASCII encoding on the Unicode codepoints 0-127. Hence, functions such as &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#v:intDec&quot;&gt;intDec&lt;/a&gt;&lt;/code&gt; can also be used for encoding &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;s as a decimal number with Char8 encoded characters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c479ee79f8f50aa3dcf64e97781e845a99daa98d" translate="yes" xml:space="preserve">
          <source>The InputT monad transformer</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f02dbfae6923c5fae8b765773db367457b1cef47" translate="yes" xml:space="preserve">
          <source>The Latin1 (ISO8859-1) encoding. This encoding maps bytes directly to the first 256 Unicode code points, and is thus not a complete Unicode encoding. An attempt to write a character greater than &lt;code&gt;'\255'&lt;/code&gt; to a &lt;code&gt;&lt;a href=&quot;system-io#v:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; using the &lt;code&gt;&lt;a href=&quot;ghc-io-encoding#v:latin1&quot;&gt;latin1&lt;/a&gt;&lt;/code&gt; encoding will result in an error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ddf2c2b44bf1b6f9d563c7f3800d62394c65a764" translate="yes" xml:space="preserve">
          <source>The Latin1 (ISO8859-1) encoding. This encoding maps bytes directly to the first 256 Unicode code points, and is thus not a complete Unicode encoding. An attempt to write a character greater than &lt;code&gt;'\255'&lt;/code&gt; to a &lt;code&gt;&lt;a href=&quot;system-io#v:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; using the &lt;code&gt;&lt;a href=&quot;system-io#v:latin1&quot;&gt;latin1&lt;/a&gt;&lt;/code&gt; encoding will result in an error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="680f8c637bf3c21d4334aa840c68f7b1c0426e80" translate="yes" xml:space="preserve">
          <source>The List data type and its operations</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="527e8dadea35f6a4f5c4a4c4be123089c5e69c00" translate="yes" xml:space="preserve">
          <source>The List monad.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8aba302b7e58fc590a9afdc1a01080baae6e6ec1" translate="yes" xml:space="preserve">
          <source>The ListT monad transformer</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba07cd406a34170d4f0ecfa83e506b98d6f30534" translate="yes" xml:space="preserve">
          <source>The ListT monad transformer, adding backtracking to a given monad, which must be commutative.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0495cc6e831dd99a09b6b22275801501a83fb2b" translate="yes" xml:space="preserve">
          <source>The MVar type</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46396b237f9d18bcd799cea896a2640dfd6df348" translate="yes" xml:space="preserve">
          <source>The Maybe type, and associated operations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e744e9e0cfe46515ef9f5bb52e48c6c750bbb1e5" translate="yes" xml:space="preserve">
          <source>The MaybeT monad transformer</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4126903c0c38cb737f94266782af2c525510b404" translate="yes" xml:space="preserve">
          <source>The Modified Julian Date is the day with the fraction of the day, measured from UT midnight. It's used to represent UT1, which is time as measured by the earth's rotation, adjusted for various wobbles.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4fd231b0228fbbb56527d9186f84060d50a59d7" translate="yes" xml:space="preserve">
          <source>The Modified Julian Day is a standard count of days, with zero being the day 1858-11-17.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c771c28ba6943eb0fbd701bba8effdfe529aa2b4" translate="yes" xml:space="preserve">
          <source>The MonadException class</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad32074e930158647c5d3c0d66a82e352b9530f7" translate="yes" xml:space="preserve">
          <source>The MonadWriter class.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b01bbf48e477c92aa3644550cb6f1cc37d1a0b1f" translate="yes" xml:space="preserve">
          <source>The Monomorphism Restriction is disabled (see &lt;a href=&quot;glasgow_exts#monomorphism&quot;&gt;Switching off the dreaded Monomorphism Restriction&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bfaad71abe81d69b989cc169fbd7881a4139c40a" translate="yes" xml:space="preserve">
          <source>The NT kernel however allows you ways to opt out of this path preprocessing by the Win32 APIs. This is done by explicitly using the desired namespace in the path.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3d1ffc3dd3f40f1c222c841f95386202d3f7d9c" translate="yes" xml:space="preserve">
          <source>The Package Versioning Policy &lt;strong&gt;does not apply&lt;/strong&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7577997f2b7e95327e240c7fc768c6dc92772fe1" translate="yes" xml:space="preserve">
          <source>The Paterson Conditions: for each class constraint &lt;code&gt;(C t1 ... tn)&lt;/code&gt; in the context</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7329aa4547685d3c70bea0407e898afb0b679e44" translate="yes" xml:space="preserve">
          <source>The Prelude: a standard module. The Prelude is imported by default into all Haskell modules unless either there is an explicit import statement for it, or the NoImplicitPrelude extension is enabled.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0aa2000b932cfb04e1a3bcd9c14b88cf13e1335d" translate="yes" xml:space="preserve">
          <source>The Put monad</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6d4dd4f8b3be3cd5b857fe2de8ff602061f0af6" translate="yes" xml:space="preserve">
          <source>The Put monad. A monad for efficiently constructing lazy bytestrings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="859037e4eda9b5b2f4fe55e78c68c20d023080cf" translate="yes" xml:space="preserve">
          <source>The Put type</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab5819377a02005c251c02732e301195c27a0049" translate="yes" xml:space="preserve">
          <source>The PutM type. A Writer monad over the efficient Builder monoid.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2354aa5ff6e1c2d9885153e78ccf38e4f0365e83" translate="yes" xml:space="preserve">
          <source>The RTS has a lot of options to control its behaviour. For example, you can change the context-switch interval, the default size of the heap, and enable heap profiling. These options can be passed to the runtime system in a variety of different ways; the next section (&lt;a href=&quot;#setting-rts-options&quot;&gt;Setting RTS options&lt;/a&gt;) describes the various methods, and the following sections describe the RTS options themselves.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80255d167f12c27a3ea54ce8b0bd00039dbf82da" translate="yes" xml:space="preserve">
          <source>The RTS options related to concurrency are described in &lt;a href=&quot;using-concurrent#using-concurrent&quot;&gt;Using Concurrent Haskell&lt;/a&gt;, and those for parallelism in &lt;a href=&quot;using-concurrent#parallel-options&quot;&gt;RTS options for SMP parallelism&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5bb8ad1fb09a839ecffde8ca34b94bdfdcd8b691" translate="yes" xml:space="preserve">
          <source>The RTS will snaffle &lt;code&gt;-H32m -S&lt;/code&gt; for itself, and the remaining arguments &lt;code&gt;-f -h foo bar&lt;/code&gt; will be available to your program if/when it calls &lt;code&gt;System.Environment.getArgs&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e88b8846d8fe73958229f97485a69a53155ce170" translate="yes" xml:space="preserve">
          <source>The RULES mechanism is used to implement fusion (deforestation) of common list functions. If a &amp;ldquo;good consumer&amp;rdquo; consumes an intermediate list constructed by a &amp;ldquo;good producer&amp;rdquo;, the intermediate list should be eliminated entirely.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91cc01216a24ea0cf70d53ce6831cdfd22c4c1ae" translate="yes" xml:space="preserve">
          <source>The RWS monad</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3030e059d51b47652080afc1bf3e87a96b72964b" translate="yes" xml:space="preserve">
          <source>The RWST monad transformer</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17d69ac471ca747fe3aa42940b683d831a9ef452" translate="yes" xml:space="preserve">
          <source>The Reader monad</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3aea66391daa03b9cc14c2b409c118ef8792ac2b" translate="yes" xml:space="preserve">
          <source>The ReaderT monad transformer</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b28758084e7661741da61d05acfec540a63dcd6" translate="yes" xml:space="preserve">
          <source>The STM implementation will abort transactions that are known to be invalid and need to be restarted. This may happen in the middle of &lt;code&gt;&lt;a href=&quot;ghc-conc#v:unsafeIOToSTM&quot;&gt;unsafeIOToSTM&lt;/a&gt;&lt;/code&gt;, so make sure you don't acquire any resources that need releasing (exception handlers are ignored when aborting the transaction). That includes doing any IO using Handles, for example. Getting this wrong will probably lead to random deadlocks.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a93c60619a7c26a3aaea050cc64323b106e6a10f" translate="yes" xml:space="preserve">
          <source>The STM implementation will abort transactions that are known to be invalid and need to be restarted. This may happen in the middle of &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:unsafeIOToSTM&quot;&gt;unsafeIOToSTM&lt;/a&gt;&lt;/code&gt;, so make sure you don't acquire any resources that need releasing (exception handlers are ignored when aborting the transaction). That includes doing any IO using Handles, for example. Getting this wrong will probably lead to random deadlocks.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a466c95f7705b8667d496c8cad7e2978bbeba71b" translate="yes" xml:space="preserve">
          <source>The STM implementation will often run transactions multiple times, so you need to be prepared for this if your IO has any side effects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2c9be55e3be898cad081ed8cc787cc2dc0d8adc" translate="yes" xml:space="preserve">
          <source>The Safe Haskell &lt;em&gt;safe language&lt;/em&gt; (enabled by &lt;code&gt;-XSafe&lt;/code&gt;) guarantees the following properties:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7726729f19e0da000e83c79bcb8c28c6f385ffcb" translate="yes" xml:space="preserve">
          <source>The Safe Haskell checks can be disabled for a module by passing the &lt;a href=&quot;#ghc-flag--fno-safe-haskell&quot;&gt;&lt;code&gt;-fno-safe-haskell&lt;/code&gt;&lt;/a&gt; flag. This is useful in particular when compiling with source plugins as running a plugin marks the module as unsafe and can then cause downstream modules to fail the safety checks.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6da0062c345ab61160d26f605d07d936e53000f2" translate="yes" xml:space="preserve">
          <source>The Select monad</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14b5bf3a399f4cac6f75470d51a3a0bae35be0f1" translate="yes" xml:space="preserve">
          <source>The SelectT monad transformer</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="afb2b6e8a6ae40d8e5e247b3b17b072cba473176" translate="yes" xml:space="preserve">
          <source>The Signal type</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34ca6ab89d0a5929502c3b8fda82f9d7a6d4db86" translate="yes" xml:space="preserve">
          <source>The State monad</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1d93ac3a4f1be7a558b299c04132f8bd844f80f" translate="yes" xml:space="preserve">
          <source>The StateT monad transformer</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38fd4995bb0200714fd098c99380c5ce19be4b0a" translate="yes" xml:space="preserve">
          <source>The TH state, created by &lt;code&gt;&lt;a href=&quot;ghci-th#v:startTH&quot;&gt;startTH&lt;/a&gt;&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2544b8736e584c3e40b611d6a80bea3cc2e2d77" translate="yes" xml:space="preserve">
          <source>The Typeable class</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="406c428a778ef7125e193987bbac0237ab0511cd" translate="yes" xml:space="preserve">
          <source>The UTC time zone.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38141e622e2458972c46a5896fe7f4e01687679d" translate="yes" xml:space="preserve">
          <source>The UTF-16 Unicode encoding (a byte-order-mark should be used to indicate endianness).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0cf0e68f8c740d3f43a6e8c8dbc14773e82bf3fb" translate="yes" xml:space="preserve">
          <source>The UTF-16 Unicode encoding (big-endian)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e56b9ac4542ba5321237f8287ad2bf793fc3af5" translate="yes" xml:space="preserve">
          <source>The UTF-16 Unicode encoding (litte-endian)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d34bf7d79b70b504d63dce6b7b58a8119636ec3c" translate="yes" xml:space="preserve">
          <source>The UTF-32 Unicode encoding (a byte-order-mark should be used to indicate endianness).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67dffc3f81adbd2d24a0516022167baf8bc86322" translate="yes" xml:space="preserve">
          <source>The UTF-32 Unicode encoding (big-endian)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1d43f77fb169e84f01193e920df4b983c3368e9" translate="yes" xml:space="preserve">
          <source>The UTF-32 Unicode encoding (litte-endian)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52589abf36edd4349a64f7d5395f328f8a947920" translate="yes" xml:space="preserve">
          <source>The UTF-8 Unicode encoding</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a005af9557a056326c8b8d7c97a47bc28391bd3b" translate="yes" xml:space="preserve">
          <source>The UTF-8 Unicode encoding, with a byte-order-mark (BOM; the byte sequence 0xEF 0xBB 0xBF). This encoding behaves like &lt;code&gt;&lt;a href=&quot;ghc-io-encoding#v:utf8&quot;&gt;utf8&lt;/a&gt;&lt;/code&gt;, except that on input, the BOM sequence is ignored at the beginning of the stream, and on output, the BOM sequence is prepended.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eaf74031b27da65f642c604ade4f47115637843c" translate="yes" xml:space="preserve">
          <source>The UTF-8 Unicode encoding, with a byte-order-mark (BOM; the byte sequence 0xEF 0xBB 0xBF). This encoding behaves like &lt;code&gt;&lt;a href=&quot;system-io#v:utf8&quot;&gt;utf8&lt;/a&gt;&lt;/code&gt;, except that on input, the BOM sequence is ignored at the beginning of the stream, and on output, the BOM sequence is prepended.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48a72567fd36d1b77865bf4ea3a5534e90bd33c8" translate="yes" xml:space="preserve">
          <source>The UTF-8 encoding can encode &lt;em&gt;all&lt;/em&gt; Unicode codepoints. We recommend using it always for encoding &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt;s and &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;s unless an application really requires another encoding.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d524833742212d693f8a7a1356f8aab1e3718c22" translate="yes" xml:space="preserve">
          <source>The UTF-8 encoding can encode all Unicode codepoints. It is equivalent to the ASCII encoding on the Unicode codepoints 0-127. Hence, functions such as &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#v:intDec&quot;&gt;intDec&lt;/a&gt;&lt;/code&gt; can also be used for encoding &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;s as a decimal number with UTF-8 encoded characters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09093313f0f91c4b5737ad4a0fbe7d06eea9ee26" translate="yes" xml:space="preserve">
          <source>The Unicode encoding of the current locale</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f137dd2773a7b21ca2a1977bcffe06a49397773" translate="yes" xml:space="preserve">
          <source>The Unicode encoding of the current locale, but allowing arbitrary undecodable bytes to be round-tripped through it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="939eaac913afcf37c06343e0dee5a39351f12362" translate="yes" xml:space="preserve">
          <source>The Unicode encoding of the current locale, but where undecodable bytes are replaced with their closest visual match. Used for the &lt;code&gt;&lt;a href=&quot;foreign-c-string#v:CString&quot;&gt;CString&lt;/a&gt;&lt;/code&gt; marshalling functions in &lt;a href=&quot;foreign-c-string&quot;&gt;Foreign.C.String&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94c16bb05159c06fe3dc812d48c81e471e6e3efb" translate="yes" xml:space="preserve">
          <source>The Unicode general category of the character. This relies on the &lt;code&gt;&lt;a href=&quot;prelude#t:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt; instance of &lt;code&gt;&lt;a href=&quot;data-char#t:GeneralCategory&quot;&gt;GeneralCategory&lt;/a&gt;&lt;/code&gt;, which must remain in the same order as the categories are presented in the Unicode standard.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68e199523a1fa0fa41372e425d662a0ca937ad92" translate="yes" xml:space="preserve">
          <source>The Unicode general category of the character. This relies on the &lt;code&gt;&lt;a href=&quot;prelude#t:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt; instance of &lt;code&gt;&lt;a href=&quot;ghc-unicode#t:GeneralCategory&quot;&gt;GeneralCategory&lt;/a&gt;&lt;/code&gt;, which must remain in the same order as the categories are presented in the Unicode standard.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="461ca2fc00cd995c7e6980fa43df6ef7503d97ca" translate="yes" xml:space="preserve">
          <source>The Windows directory</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a88998b1d185995bfddbae32ddd00452270da2ae" translate="yes" xml:space="preserve">
          <source>The Writer monad</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f31095d17e6be1b28728b97a802ce50d67ad701" translate="yes" xml:space="preserve">
          <source>The WriterT monad transformer</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e564641fef849b7748c52b9e3bbf79b098ce5698" translate="yes" xml:space="preserve">
          <source>The ability to &lt;em&gt;inherit&lt;/em&gt; required signatures from packages we depend upon, combining the signatures into a single merged signature which reflects the requirements of any locally defined signature, as well as the requirements of our dependencies.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7dbeb7f19d92db3db611e99643a65e9afeeb3443" translate="yes" xml:space="preserve">
          <source>The ability to define an &lt;code&gt;hsig&lt;/code&gt; file, containing type definitions and type signature for values which can be used by modules that import the signature, and must be provided by the eventual implementing module, and</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e18a26f623d4b3d5b0afaeca9ff88864b2448314" translate="yes" xml:space="preserve">
          <source>The ability to set a breakpoint on a function definition or expression in the program. When the function is called, or the expression evaluated, GHCi suspends execution and returns to the prompt, where you can inspect the values of local variables before continuing with the execution.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="310f755673bc29e8cd19bd1e50c2672bd0ba64a5" translate="yes" xml:space="preserve">
          <source>The above code is equivalent to:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ceb853b961139ea8a430dce957f73b5c77a03245" translate="yes" xml:space="preserve">
          <source>The above declaration (which requires the language pragma &lt;code&gt;DeriveGeneric&lt;/code&gt;) causes the following representation to be generated:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="124bdbaef2420b9e89592fec3e57e81f0de35ec8" translate="yes" xml:space="preserve">
          <source>The above declaration causes the following representation to be generated:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f76366168215856429247956c4826993833306ed" translate="yes" xml:space="preserve">
          <source>The above definition of trust has an issue. Any module can be compiled with &lt;a href=&quot;#extension-Trustworthy&quot;&gt;&lt;code&gt;Trustworthy&lt;/code&gt;&lt;/a&gt; and it will be trusted. To control this, there is an additional definition of package trust (enabled with the &lt;a href=&quot;#ghc-flag--fpackage-trust&quot;&gt;&lt;code&gt;-fpackage-trust&lt;/code&gt;&lt;/a&gt; flag). The point of package trust is to require that the client C explicitly say which packages are allowed to contain trustworthy modules. Trustworthy packages are only trusted if they reside in a package trusted by C.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2df7fb2c193365ff646472a721e6b7dbe5bf63ae" translate="yes" xml:space="preserve">
          <source>The above function takes a strict &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; supposed to represent Base64 encoded data and the current decoding state. It writes the decoded bytes as the side-effect of the &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Put&quot;&gt;Put&lt;/a&gt;&lt;/code&gt; and returns the new decoding state, if the decoding of all data in the &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; was successful. The checking if the strict &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; represents Base64 encoded data and the actual decoding are fused. This makes the common case, where all data represents Base64 encoded data, more efficient. It also implies that all data must be decoded before the final decoding state can be returned. &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Put&quot;&gt;Put&lt;/a&gt;&lt;/code&gt;s are intended for implementing such fused checking and decoding/encoding, which is reflected in their strictness properties.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0308489ed1646a7d427f7b348942d76c9c0d5d69" translate="yes" xml:space="preserve">
          <source>The above informal specification is fine for simple situations, but matters can get complicated. In particular, it needs to be clear exactly when a key dies, so that any weak pointers that refer to it can be finalized. Suppose, for example, the value of one weak pointer refers to the key of another...does that keep the key alive?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2361448fcf86f9607ed9aa3c2d047337ebd0125c" translate="yes" xml:space="preserve">
          <source>The above laws imply:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6121e60b6f07d4583d6a2f3988fc1fab1e503635" translate="yes" xml:space="preserve">
          <source>The above will parse a string like &lt;code&gt;&quot;aabbb&quot;&lt;/code&gt; and return a successful parse result &lt;code&gt;&quot;aabbb&quot;&lt;/code&gt;. Compare against the below which will produce a result of &lt;code&gt;&quot;bbb&quot;&lt;/code&gt; for the same input:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20d7c122429fa587037c0b158d78237d0e61f8fb" translate="yes" xml:space="preserve">
          <source>The abstract data type &lt;code&gt;ParseError&lt;/code&gt; represents parse errors. It provides the source position (&lt;code&gt;&lt;a href=&quot;text-parsec#t:SourcePos&quot;&gt;SourcePos&lt;/a&gt;&lt;/code&gt;) of the error and a list of error messages (&lt;code&gt;&lt;a href=&quot;text-parsec-error#t:Message&quot;&gt;Message&lt;/a&gt;&lt;/code&gt;). A &lt;code&gt;ParseError&lt;/code&gt; can be returned by the function &lt;code&gt;&lt;a href=&quot;text-parsec-prim#v:parse&quot;&gt;parse&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;ParseError&lt;/code&gt; is an instance of the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; classes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2860dda2765620cbf0f468a55ba7b993da164fe3" translate="yes" xml:space="preserve">
          <source>The abstract data type &lt;code&gt;ParseError&lt;/code&gt; represents parse errors. It provides the source position (&lt;code&gt;&lt;a href=&quot;text-parsec-pos#t:SourcePos&quot;&gt;SourcePos&lt;/a&gt;&lt;/code&gt;) of the error and a list of error messages (&lt;code&gt;&lt;a href=&quot;text-parsec-error#t:Message&quot;&gt;Message&lt;/a&gt;&lt;/code&gt;). A &lt;code&gt;ParseError&lt;/code&gt; can be returned by the function &lt;code&gt;&lt;a href=&quot;text-parsec-prim#v:parse&quot;&gt;parse&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;ParseError&lt;/code&gt; is an instance of the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; classes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aab9864f2e792b8ac699847b4dbdbb4a77ea80ac" translate="yes" xml:space="preserve">
          <source>The abstract data type &lt;code&gt;ParseError&lt;/code&gt; represents parse errors. It provides the source position (&lt;code&gt;&lt;a href=&quot;text-parsec-pos#t:SourcePos&quot;&gt;SourcePos&lt;/a&gt;&lt;/code&gt;) of the error and a list of error messages (&lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-error#t:Message&quot;&gt;Message&lt;/a&gt;&lt;/code&gt;). A &lt;code&gt;ParseError&lt;/code&gt; can be returned by the function &lt;code&gt;&lt;a href=&quot;text-parsec-prim#v:parse&quot;&gt;parse&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;ParseError&lt;/code&gt; is an instance of the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; classes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="510da1eb070dd00ee03ec16a47305698f8cacdd9" translate="yes" xml:space="preserve">
          <source>The abstract data type &lt;code&gt;ParseError&lt;/code&gt; represents parse errors. It provides the source position (&lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec#t:SourcePos&quot;&gt;SourcePos&lt;/a&gt;&lt;/code&gt;) of the error and a list of error messages (&lt;code&gt;&lt;a href=&quot;text-parsec-error#t:Message&quot;&gt;Message&lt;/a&gt;&lt;/code&gt;). A &lt;code&gt;ParseError&lt;/code&gt; can be returned by the function &lt;code&gt;&lt;a href=&quot;text-parsec-prim#v:parse&quot;&gt;parse&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;ParseError&lt;/code&gt; is an instance of the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; classes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de0533afad3f79319b3bf4b1fcb91b9bbdbc0565" translate="yes" xml:space="preserve">
          <source>The abstract data type &lt;code&gt;SourcePos&lt;/code&gt; represents source positions. It contains the name of the source (i.e. file name), a line number and a column number. &lt;code&gt;SourcePos&lt;/code&gt; is an instance of the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; class.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4896de6a97029ad3c503ab35de30ebe552f9de1c" translate="yes" xml:space="preserve">
          <source>The abstract type of documents. A Doc represents a &lt;em&gt;set&lt;/em&gt; of layouts. A Doc with no occurrences of Union or NoDoc represents just one layout.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a80b0e5c19c356bd9ef420910831b319cf81af79" translate="yes" xml:space="preserve">
          <source>The action &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hFlush&quot;&gt;hFlush&lt;/a&gt;&lt;/code&gt;&lt;code&gt;hdl&lt;/code&gt; causes any items buffered for output in handle &lt;code&gt;hdl&lt;/code&gt; to be sent immediately to the operating system.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee59ce1aebad5edf7e6e4aaef4677f21c7eefc31" translate="yes" xml:space="preserve">
          <source>The action &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hFlushAll&quot;&gt;hFlushAll&lt;/a&gt;&lt;/code&gt;&lt;code&gt;hdl&lt;/code&gt; flushes all buffered data in &lt;code&gt;hdl&lt;/code&gt;, including any buffered read data. Buffered read data is flushed by seeking the file position back to the point before the bufferred data was read, and hence only works if &lt;code&gt;hdl&lt;/code&gt; is seekable (see &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hIsSeekable&quot;&gt;hIsSeekable&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a371db2521146387741275550e657dffca505303" translate="yes" xml:space="preserve">
          <source>The action &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hSetEncoding&quot;&gt;hSetEncoding&lt;/a&gt;&lt;/code&gt;&lt;code&gt;hdl&lt;/code&gt;&lt;code&gt;encoding&lt;/code&gt; changes the text encoding for the handle &lt;code&gt;hdl&lt;/code&gt; to &lt;code&gt;encoding&lt;/code&gt;. The default encoding when a &lt;code&gt;&lt;a href=&quot;ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; is created is &lt;code&gt;&lt;a href=&quot;system-io#v:localeEncoding&quot;&gt;localeEncoding&lt;/a&gt;&lt;/code&gt;, namely the default encoding for the current locale.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e5909c7d1c1b470eac7ec2d2a3d5f1c7a3e6b23" translate="yes" xml:space="preserve">
          <source>The action &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:hFlush&quot;&gt;hFlush&lt;/a&gt;&lt;/code&gt;&lt;code&gt;hdl&lt;/code&gt; causes any items buffered for output in handle &lt;code&gt;hdl&lt;/code&gt; to be sent immediately to the operating system.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30e8a3b807220ec41770ad1fcda8f8906a927d36" translate="yes" xml:space="preserve">
          <source>The action &lt;code&gt;&lt;a href=&quot;system-io#v:hFlush&quot;&gt;hFlush&lt;/a&gt;&lt;/code&gt;&lt;code&gt;hdl&lt;/code&gt; causes any items buffered for output in handle &lt;code&gt;hdl&lt;/code&gt; to be sent immediately to the operating system.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c8d6d26b1ac4ce2c7a317b47737557b2e637055" translate="yes" xml:space="preserve">
          <source>The action &lt;code&gt;&lt;a href=&quot;system-io#v:hSetEncoding&quot;&gt;hSetEncoding&lt;/a&gt;&lt;/code&gt;&lt;code&gt;hdl&lt;/code&gt;&lt;code&gt;encoding&lt;/code&gt; changes the text encoding for the handle &lt;code&gt;hdl&lt;/code&gt; to &lt;code&gt;encoding&lt;/code&gt;. The default encoding when a &lt;code&gt;&lt;a href=&quot;system-io#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; is created is &lt;code&gt;&lt;a href=&quot;system-io#v:localeEncoding&quot;&gt;localeEncoding&lt;/a&gt;&lt;/code&gt;, namely the default encoding for the current locale.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88ecb8776a874cfae1e583d670074ac14b0b3b9f" translate="yes" xml:space="preserve">
          <source>The action can handle the interrupt itself; a new &lt;code&gt;&lt;a href=&quot;system-console-haskeline#t:Interrupt&quot;&gt;Interrupt&lt;/a&gt;&lt;/code&gt; exception will be thrown every time Ctrl-C is pressed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c560f66ad19d0c44deb93f325922bbfa7a14cb7" translate="yes" xml:space="preserve">
          <source>The actions to perform when a signal is received.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17c5e604d289acc48a4aeb8ca32b75ead60baded" translate="yes" xml:space="preserve">
          <source>The actual command line arguments (presumably got from &lt;code&gt;&lt;a href=&quot;system-environment#v:getArgs&quot;&gt;getArgs&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51507a88f0049d4973537c6abea3ce2abf60b884" translate="yes" xml:space="preserve">
          <source>The actual meaning of the various columns in the output is:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d600203b76ff6ccdd7956053fbe52659d549a35" translate="yes" xml:space="preserve">
          <source>The advantage of smaller stack chunks is that the garbage collector can avoid traversing stack chunks if they are known to be unmodified since the last collection, so reducing the chunk size means that the garbage collector can identify more stack as unmodified, and the GC overhead might be reduced. On the other hand, making stack chunks too small adds some overhead as there will be more overflow/underflow between chunks. The default setting of 32k appears to be a reasonable compromise in most cases.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="351839425c4046d1ef3e16ab0a651854e611c6da" translate="yes" xml:space="preserve">
          <source>The advantage of this is that the key can be retrieved by &lt;code&gt;&lt;a href=&quot;system-mem-weak#v:deRefWeak&quot;&gt;deRefWeak&lt;/a&gt;&lt;/code&gt; in addition to the value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51801fd153e97264561ce8060f8815074cf0359c" translate="yes" xml:space="preserve">
          <source>The alarm timer</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9de65a28b0e1c87c6c42bf35a90ef7382160962" translate="yes" xml:space="preserve">
          <source>The algebraic data types</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af0e67390188169e10bce1a919bdd538300c70aa" translate="yes" xml:space="preserve">
          <source>The algorithm for &lt;a href=&quot;#extension-DeriveFoldable&quot;&gt;&lt;code&gt;DeriveFoldable&lt;/code&gt;&lt;/a&gt; is adapted from the &lt;a href=&quot;#extension-DeriveFunctor&quot;&gt;&lt;code&gt;DeriveFunctor&lt;/code&gt;&lt;/a&gt; algorithm, but it generates definitions for &lt;code&gt;foldMap&lt;/code&gt;, &lt;code&gt;foldr&lt;/code&gt;, and &lt;code&gt;null&lt;/code&gt; instead of &lt;code&gt;fmap&lt;/code&gt;. In addition, &lt;a href=&quot;#extension-DeriveFoldable&quot;&gt;&lt;code&gt;DeriveFoldable&lt;/code&gt;&lt;/a&gt; filters out all constructor arguments on the RHS expression whose types do not mention the last type parameter, since those arguments do not need to be folded over.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="606c23fd4a39d6f5da98fdda576dd31c1413daef" translate="yes" xml:space="preserve">
          <source>The algorithm for &lt;a href=&quot;#extension-DeriveTraversable&quot;&gt;&lt;code&gt;DeriveTraversable&lt;/code&gt;&lt;/a&gt; is adapted from the &lt;a href=&quot;#extension-DeriveFunctor&quot;&gt;&lt;code&gt;DeriveFunctor&lt;/code&gt;&lt;/a&gt; algorithm, but it generates a definition for &lt;code&gt;traverse&lt;/code&gt; instead of &lt;code&gt;fmap&lt;/code&gt;. In addition, &lt;a href=&quot;#extension-DeriveTraversable&quot;&gt;&lt;code&gt;DeriveTraversable&lt;/code&gt;&lt;/a&gt; filters out all constructor arguments on the RHS expression whose types do not mention the last type parameter, since those arguments do not produce any effects in a traversal.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76b01a57a6338aab828a7c6e4ed1bf39e383096b" translate="yes" xml:space="preserve">
          <source>The allowed fields, with their types, are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="007ff1d2ad1a216037acaa14b7a1f3887c82c2b0" translate="yes" xml:space="preserve">
          <source>The alternative spelling &lt;code&gt;INLINEABLE&lt;/code&gt; is also accepted by GHC.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="305a13d8f5f537b644a0383d8511ddbfd1c351ee" translate="yes" xml:space="preserve">
          <source>The amortized running time is given for each operation, with &lt;em&gt;n&lt;/em&gt; referring to the number of entries in the map and &lt;em&gt;W&lt;/em&gt; referring to the number of bits in an &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; (32 or 64).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43383f5e57411cb28bfae33d1e0cb0912284dd35" translate="yes" xml:space="preserve">
          <source>The amortized running time is given for each operation, with &lt;em&gt;n&lt;/em&gt; referring to the number of entries in the map and &lt;em&gt;W&lt;/em&gt; referring to the number of bits in an &lt;code&gt;Int&lt;/code&gt; (32 or 64).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a366c01859c8d621928b2208d0c7ed30604c01f" translate="yes" xml:space="preserve">
          <source>The amortized running time is given for each operation, with &lt;em&gt;n&lt;/em&gt; referring to the number of entries in the map.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8bc34451c62ea9fef00489d326317052195ef0d" translate="yes" xml:space="preserve">
          <source>The amount of CPU time and elapsed wall clock time while initialising the runtime system (INIT), running the program itself (MUT, the mutator), and garbage collecting (GC).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="324b96835c11121147eb9632d3d28270b6cd3cf5" translate="yes" xml:space="preserve">
          <source>The answer is &quot;it might throw either&quot;; the choice is non-deterministic. If you are catching any type of exception then you might catch either. If you are calling &lt;code&gt;catch&lt;/code&gt; with type &lt;code&gt;IO Int -&amp;gt; (ArithException -&amp;gt; IO Int) -&amp;gt; IO Int&lt;/code&gt; then the handler may get run with &lt;code&gt;DivideByZero&lt;/code&gt; as an argument, or an &lt;code&gt;ErrorCall &quot;urk&quot;&lt;/code&gt; exception may be propogated further up. If you call it again, you might get a the opposite behaviour. This is ok, because &lt;code&gt;&lt;a href=&quot;control-exception#v:catch&quot;&gt;catch&lt;/a&gt;&lt;/code&gt; is an &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; computation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc2d971716bd2fe11fe8e65858d3f263f32451c4" translate="yes" xml:space="preserve">
          <source>The answer is &quot;it might throw either&quot;; the choice is non-deterministic. If you are catching any type of exception then you might catch either. If you are calling &lt;code&gt;catch&lt;/code&gt; with type &lt;code&gt;IO Int -&amp;gt; (ArithException -&amp;gt; IO Int) -&amp;gt; IO Int&lt;/code&gt; then the handler may get run with &lt;code&gt;DivideByZero&lt;/code&gt; as an argument, or an &lt;code&gt;ErrorCall &quot;urk&quot;&lt;/code&gt; exception may be propogated further up. If you call it again, you might get a the opposite behaviour. This is ok, because &lt;code&gt;&lt;a href=&quot;ghc-io#v:catch&quot;&gt;catch&lt;/a&gt;&lt;/code&gt; is an &lt;code&gt;&lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; computation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6636ed331b405e67e4aa7a8f8c1f88ee4738daae" translate="yes" xml:space="preserve">
          <source>The answer is &quot;it might throw either&quot;; the choice is non-deterministic. If you are catching any type of exception then you might catch either. If you are calling &lt;code&gt;catch&lt;/code&gt; with type &lt;code&gt;IO Int -&amp;gt; (ArithException -&amp;gt; IO Int) -&amp;gt; IO Int&lt;/code&gt; then the handler may get run with &lt;code&gt;DivideByZero&lt;/code&gt; as an argument, or an &lt;code&gt;ErrorCall &quot;urk&quot;&lt;/code&gt; exception may be propogated further up. If you call it again, you might get a the opposite behaviour. This is ok, because &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:catch&quot;&gt;catch&lt;/a&gt;&lt;/code&gt; is an &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; computation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="215e7b52176702d87e95e2ce03acf7002f6125af" translate="yes" xml:space="preserve">
          <source>The approximate time when the program finished execution as a UNIX epoch timestamp.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bba06a7c745bfe3d2d4d032c0a5307f863b5c408" translate="yes" xml:space="preserve">
          <source>The arbitrary-precision &lt;code&gt;&lt;a href=&quot;ghc-natural#t:Natural&quot;&gt;Natural&lt;/a&gt;&lt;/code&gt; number type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77f549adbb8c3243a4f421f1caa3469b06d519cd" translate="yes" xml:space="preserve">
          <source>The arbitrary-precision &lt;code&gt;&lt;a href=&quot;numeric-natural#t:Natural&quot;&gt;Natural&lt;/a&gt;&lt;/code&gt; number type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e4663001ff64b0062c525758c18f678a0b593f7" translate="yes" xml:space="preserve">
          <source>The argument is usually the name of the application. Since it will be integrated into the path, it must consist of valid path characters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7c4f0dc994aa251501707da51ab6248d1b7b620" translate="yes" xml:space="preserve">
          <source>The argument must be strictly positive, that condition is &lt;em&gt;not&lt;/em&gt; checked.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bfd85e788b1a4102dc5506f2821063aaee1859f8" translate="yes" xml:space="preserve">
          <source>The argument passed to &lt;code&gt;&lt;a href=&quot;control-exception#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; is a function that takes as its argument another function, which can be used to restore the prevailing masking state within the context of the masked computation. For example, a common way to use &lt;code&gt;&lt;a href=&quot;control-exception#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; is to protect the acquisition of a resource:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec41714558fc08d08da55c62fab2fe097c6c6a18" translate="yes" xml:space="preserve">
          <source>The argument passed to &lt;code&gt;&lt;a href=&quot;ghc-io#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; is a function that takes as its argument another function, which can be used to restore the prevailing masking state within the context of the masked computation. For example, a common way to use &lt;code&gt;&lt;a href=&quot;ghc-io#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; is to protect the acquisition of a resource:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8b310556e765050dba6b8aa3221dbec61d539ee" translate="yes" xml:space="preserve">
          <source>The argument passed to &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; is a function that takes as its argument another function, which can be used to restore the prevailing masking state within the context of the masked computation. For example, a common way to use &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; is to protect the acquisition of a resource:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c1e08fffd8f2b265d44f0c771329303cef101fc" translate="yes" xml:space="preserve">
          <source>The argument to &lt;code&gt;runGhc&lt;/code&gt; is a bit tricky. GHC needs this to find its libraries, so the argument must refer to the directory that is printed by &lt;code&gt;ghc --print-libdir&lt;/code&gt; for the same version of GHC that the program is being compiled with. Above we therefore use the &lt;code&gt;ghc-paths&lt;/code&gt; package which provides this for us.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="629bfd4051da2fa1a32d9993713c3423b906b41a" translate="yes" xml:space="preserve">
          <source>The arguments are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af48f7ebb72df2bb8fd591d8c3756cf037769ab7" translate="yes" xml:space="preserve">
          <source>The arguments to &lt;code&gt;&lt;a href=&quot;control-exception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; are in this order so that we can partially apply it, e.g.:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ab336f12a087d2ee8f1cb00edb943f2a0db5354" translate="yes" xml:space="preserve">
          <source>The arguments to &lt;code&gt;&lt;a href=&quot;system-console-getopt#v:Option&quot;&gt;Option&lt;/a&gt;&lt;/code&gt; are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6d74e6182495971a70d15c2958c5a641ef0bc47" translate="yes" xml:space="preserve">
          <source>The arguments to &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; are in this order so that we can partially apply it, e.g.:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ecd5594ea721a5c5b4964510fa025a0ba7161ee7" translate="yes" xml:space="preserve">
          <source>The array is undefined (i.e. bottom) if any index in the list is out of bounds. The Haskell 2010 Report further specifies that if any two associations in the list have the same index, the value at that index is undefined (i.e. bottom). However in GHC's implementation, the value at such an index is the value part of the last association with that index in the list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44d43a4b5ab2e55067cf3b1a8adecaad475ca23d" translate="yes" xml:space="preserve">
          <source>The array type</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f14b40d222c3b195d28ca364c99460ad8aae96cd" translate="yes" xml:space="preserve">
          <source>The arrows web page at &lt;code&gt;http://www.haskell.org/arrows/&lt;/code&gt; &amp;lt;&lt;a href=&quot;http://www.haskell.org/arrows/&quot;&gt;http://www.haskell.org/arrows/&lt;/a&gt;&amp;gt;`__.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5375e79ae4b0bd456d40500fcf8a53d9559263ad" translate="yes" xml:space="preserve">
          <source>The automatic loading of object files can sometimes lead to confusion, because non-exported top-level definitions of a module are only available for use in expressions at the prompt when the module is interpreted (see &lt;a href=&quot;#ghci-scope&quot;&gt;What&amp;rsquo;s really in scope at the prompt?&lt;/a&gt;). For this reason, you might sometimes want to force GHCi to load a module using the interpreter. This can be done by prefixing a &lt;code&gt;*&lt;/code&gt; to the module name or filename when using &lt;a href=&quot;#ghci-cmd-:load&quot;&gt;&lt;code&gt;:load&lt;/code&gt;&lt;/a&gt;, for example</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8d9c5b3787a7ee0e2557b6cd2dbfe90790c68e2" translate="yes" xml:space="preserve">
          <source>The automatic specialisation of overloaded functions (with &lt;code&gt;-O&lt;/code&gt;) should take care of overloaded local and/or unexported functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b4889f9c5c10822085aef8616f19dbeeab3bf53" translate="yes" xml:space="preserve">
          <source>The available GHCi options are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="320cabfd45dc56924b1a16a731023c186da51000" translate="yes" xml:space="preserve">
          <source>The available mode flags are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d80beedcca979af44b30619e5e06f25ee652ee4" translate="yes" xml:space="preserve">
          <source>The average and maximum &amp;ldquo;residency&amp;rdquo;, which is the amount of live data in bytes. The runtime can only determine the amount of live data during a major GC, which is why the number of samples corresponds to the number of major GCs (and is usually relatively small). To get a better picture of the heap profile of your program, use the &lt;a href=&quot;#rts-flag--hT&quot;&gt;&lt;code&gt;-hT&lt;/code&gt;&lt;/a&gt; RTS option (&lt;a href=&quot;#rts-profiling&quot;&gt;RTS options for profiling&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a46eb9d9f0c06124eb5d61df6a1e2c54302d74ae" translate="yes" xml:space="preserve">
          <source>The avoided &amp;ldquo;dangerous&amp;rdquo; optimisations are those that can make runtime or space &lt;em&gt;worse&lt;/em&gt; if you&amp;rsquo;re unlucky. They are normally turned on or off individually.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eecb19b8afe1b4ff965ad37ca33e048b7e8a4fe6" translate="yes" xml:space="preserve">
          <source>The base must be greater than &lt;code&gt;1&lt;/code&gt;, the second argument, the number whose logarithm is sought, shall be positive, otherwise the result is meaningless.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5bc476ce11547136a2a5b9c892017204522ab1a2" translate="yes" xml:space="preserve">
          <source>The basic algorithm for &lt;a href=&quot;#extension-DeriveFunctor&quot;&gt;&lt;code&gt;DeriveFunctor&lt;/code&gt;&lt;/a&gt; walks the arguments of each constructor of a data type, applying a mapping function depending on the type of each argument. If a plain type variable is found that is syntactically equivalent to the last type parameter of the data type (&lt;code&gt;a&lt;/code&gt; in the above example), then we apply the function &lt;code&gt;f&lt;/code&gt; directly to it. If a type is encountered that is not syntactically equivalent to the last type parameter &lt;em&gt;but does mention&lt;/em&gt; the last type parameter somewhere in it, then a recursive call to &lt;code&gt;fmap&lt;/code&gt; is made. If a type is found which doesn&amp;rsquo;t mention the last type parameter at all, then it is left alone.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3880ac769d164951235b5160f553818be744abe1" translate="yes" xml:space="preserve">
          <source>The basic arrow class.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8e6230ac47ed9f2f8c9e5c744ea8b38e5723913" translate="yes" xml:space="preserve">
          <source>The basic idea is as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba3b2fdca46ebd4f364c251ed8663faaa8ea67c0" translate="yes" xml:space="preserve">
          <source>The basic idea is you render your structure in the form of this tree, and then use treeHtml to turn it into a Html object with the structure explicit.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca1a1e0f9e4dd44a7cc3e7b636c0566990b56840" translate="yes" xml:space="preserve">
          <source>The basic syntax is that instead of specifying a package name P to the package flag &lt;code&gt;-package&lt;/code&gt;, instead we specify both a package name and a parenthesized, comma-separated list of module names to import. For example, &lt;code&gt;-package &quot;base (Data.List, Data.Bool)&quot;&lt;/code&gt; makes only &lt;code&gt;Data.List&lt;/code&gt; and &lt;code&gt;Data.Bool&lt;/code&gt; visible from package &lt;code&gt;base&lt;/code&gt;. We also support renaming of modules, in case you need to refer to both modules simultaneously; this is supporting by writing &lt;code&gt;OldModName as NewModName&lt;/code&gt;, e.g. &lt;code&gt;-package &quot;base (Data.Bool as Bool)&lt;/code&gt;. You can also write &lt;code&gt;-package &quot;base with (Data.Bool as Bool)&lt;/code&gt; to include all of the original bindings (e.g. the renaming is strictly additive). It&amp;rsquo;s important to specify quotes so that your shell passes the package name and thinning/renaming list as a single argument to GHC.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4d64a56087518fa3e2214a7adad0a68d002b762" translate="yes" xml:space="preserve">
          <source>The batch compiler can be used alongside GHCi: compiled modules can be loaded into an interactive session and used in the same way as interpreted code, and in fact when using GHCi most of the library code will be pre-compiled. This means you get the best of both worlds: fast pre-compiled library code, and fast compile turnaround for the parts of your program being actively developed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ef12a287f244edad57a058eca9787cf5ada079d" translate="yes" xml:space="preserve">
          <source>The behavior is equivalent to &lt;code&gt;&lt;a href=&quot;system-directory#v:findFileWith&quot;&gt;findFileWith&lt;/a&gt;&lt;/code&gt; using the given search directories and testing each file for executable permissions. Details can be found in the documentation of &lt;code&gt;&lt;a href=&quot;system-directory#v:findFileWith&quot;&gt;findFileWith&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a37ab05f29aa8d1d66f30bee4471417ca0bbd0f1" translate="yes" xml:space="preserve">
          <source>The behavior is equivalent to &lt;code&gt;&lt;a href=&quot;system-directory#v:findFileWith&quot;&gt;findFileWith&lt;/a&gt;&lt;/code&gt;, returning only the first occurrence. Details can be found in the documentation of &lt;code&gt;&lt;a href=&quot;system-directory#v:findFileWith&quot;&gt;findFileWith&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c8e66257c1f95cca3356ee64f960b20dcb60818" translate="yes" xml:space="preserve">
          <source>The behavior is equivalent to &lt;code&gt;&lt;a href=&quot;system-directory#v:findFilesWith&quot;&gt;findFilesWith&lt;/a&gt;&lt;/code&gt;. Details can be found in the documentation of &lt;code&gt;&lt;a href=&quot;system-directory#v:findFilesWith&quot;&gt;findFilesWith&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb1e1a3692688caa279ab0329a4e161ca0e7b861" translate="yes" xml:space="preserve">
          <source>The behaviour is simply this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25a0b28ac23419d2d5d4b31eb8e82eaa74968d1a" translate="yes" xml:space="preserve">
          <source>The behaviour of parallel list comprehensions follows that of zip, in that the resulting list will have the same length as the shortest branch.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c2566b6e8b4d963d45c5f213c50828df28117fe" translate="yes" xml:space="preserve">
          <source>The benefit of including dependency information is that it allows us to define more general multiple parameter classes, without ambiguity problems, and with the benefit of more accurate types. To illustrate this, we return to the collection class example, and annotate the original definition of &lt;code&gt;Collects&lt;/code&gt; with a simple dependency:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="947bc2cb4d922e45d67175db691e9955f759c4f5" translate="yes" xml:space="preserve">
          <source>The biconnected components of a graph. An undirected graph is biconnected if the deletion of any vertex leaves it connected.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fbd73ac6d922a5bdced0fb605663eb345d894008" translate="yes" xml:space="preserve">
          <source>The binder being annotated must be at the top level (i.e. no nested binders)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63969d96d060c4b503447fa167a99cc5d9a634d8" translate="yes" xml:space="preserve">
          <source>The binder being annotated must be declared in the current module</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e1a540e18890acf0212904549c9082483047e09" translate="yes" xml:space="preserve">
          <source>The binding is lazy, but when either &lt;code&gt;x&lt;/code&gt; or &lt;code&gt;y&lt;/code&gt; is evaluated by &lt;code&gt;b&lt;/code&gt; the entire pattern is matched, including forcing the evaluation of &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5313486dfdead25fb97fb53d215625b3a8e92cb9" translate="yes" xml:space="preserve">
          <source>The body &lt;code&gt;e&lt;/code&gt; of a &lt;code&gt;static e&lt;/code&gt; expression must be a closed expression. Where we say an expression is &lt;em&gt;closed&lt;/em&gt; when all of its free (type) variables are closed. And a variable is &lt;em&gt;closed&lt;/em&gt; if it is let-bound to a &lt;em&gt;closed&lt;/em&gt; expression and its type is &lt;em&gt;closed&lt;/em&gt; as well. And a type is &lt;em&gt;closed&lt;/em&gt; if it has no free variables.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="592ada029a062869cce6e9bab58606be6defb777" translate="yes" xml:space="preserve">
          <source>The body of &lt;code&gt;f&lt;/code&gt; requires a &lt;code&gt;Num Int&lt;/code&gt; instance. We could solve this constraint from the context because we have &lt;code&gt;C Int b&lt;/code&gt; and that provides us a solution for &lt;code&gt;Num Int&lt;/code&gt;. However, we can often produce much better code by directly solving for an available &lt;code&gt;Num Int&lt;/code&gt; dictionary we might have at hand. This removes potentially many layers of indirection and crucially allows other optimisations to fire as the dictionary will be statically known and selector functions can be inlined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d145adb9d3d5724f47490428e23e3c43d0c8235" translate="yes" xml:space="preserve">
          <source>The body of &lt;code&gt;h&lt;/code&gt;&lt;em&gt;can&lt;/em&gt; refer to the function &lt;code&gt;k&lt;/code&gt; appearing on the other side of the declaration quasiquoter, as quasiquoters do not cause a declaration group to be broken up.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c2a782fcf9cc8cd32d7c6db0f011051b79d7285" translate="yes" xml:space="preserve">
          <source>The bound on the size of sequences of bytes generated by this &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim-internal#t:BoundedPrim&quot;&gt;BoundedPrim&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="efcab014d352f2160b0e056ce4481103488be8c8" translate="yes" xml:space="preserve">
          <source>The bounds are specified as a pair of the lowest and highest bounds in the array respectively. For example, a one-origin vector of length 10 has bounds (1,10), and a one-origin 10 by 10 matrix has bounds ((1,1),(10,10)).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba1cb6f6655a10a0c6294b458c9d83470571695d" translate="yes" xml:space="preserve">
          <source>The bounds of an &lt;code&gt;Array&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55a1eeab90b32df97217b33a312a220ee3d8254d" translate="yes" xml:space="preserve">
          <source>The bounds of the array</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e0f777f52cc6d21bfe3b719f3991ded42b0a70a" translate="yes" xml:space="preserve">
          <source>The bounds with which an array was constructed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="606c7ca088c78a3f35afe2ec49468115c18dfed0" translate="yes" xml:space="preserve">
          <source>The buffer is represented by a record, where the record contains the raw buffer and the start/end points of the filled portion. The buffer contents itself is mutable, but the rest of the record is immutable. This is a slightly odd mix, but it turns out to be quite practical: by making all the buffer metadata immutable, we can have operations on buffer metadata outside of the IO monad.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e80cbba3a922b5261d972496342488e7c081b28" translate="yes" xml:space="preserve">
          <source>The bug tracker lists bugs that have been reported in GHC but not yet fixed: see the &lt;a href=&quot;http://ghc.haskell.org/trac/ghc/&quot;&gt;GHC Trac&lt;/a&gt;. In addition to those, GHC also has the following known bugs or infelicities. These bugs are more permanent; it is unlikely that any of them will be fixed in the short term.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c15ff27610c2478bb9e4d3ab87096d2c276c0af" translate="yes" xml:space="preserve">
          <source>The byte ordering of the target machine.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d60877c7df977c480a2e8c741eba795e8186655" translate="yes" xml:space="preserve">
          <source>The byte-order-mark is strictly unnecessary in UTF-8, but is sometimes used to identify the encoding of a file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e514a824a293915d542219870ba513432dcaf11" translate="yes" xml:space="preserve">
          <source>The bytes read, how many bytes were read.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6a0060fcedfd8a68377b3d1eb2b5aba06d7d975" translate="yes" xml:space="preserve">
          <source>The call</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39398c8eae38902a5e0ff83f99f6b2f202aad4e7" translate="yes" xml:space="preserve">
          <source>The call &lt;code&gt;inline f&lt;/code&gt; arranges that &lt;code&gt;f&lt;/code&gt; is inlined, regardless of its size. More precisely, the call &lt;code&gt;inline f&lt;/code&gt; rewrites to the right-hand side of &lt;code&gt;f&lt;/code&gt;'s definition. This allows the programmer to control inlining from a particular call site rather than the definition site of the function (c.f. &lt;code&gt;INLINE&lt;/code&gt; pragmas).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b04d6b098bff47077a3361dce7c4b2060070b35" translate="yes" xml:space="preserve">
          <source>The call may block for a long time if a GC is in progress. We can&amp;rsquo;t use this method if the C API we&amp;rsquo;re calling doesn&amp;rsquo;t allow blocking in the callback.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f662e8be9b1e8327dfadad6256f93b3102227e4" translate="yes" xml:space="preserve">
          <source>The call stack</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b95e6d04b2d9db9df511faee23c172fb043db56" translate="yes" xml:space="preserve">
          <source>The call stack here consists of a single entry, pinpointing the source of the call to &lt;code&gt;error&lt;/code&gt;. However, by annotating several computations with &lt;code&gt;HasCallStack&lt;/code&gt;, figuring out the exact circumstances and sequences of calls that lead to a call to &lt;code&gt;error&lt;/code&gt; becomes a lot easier, as demonstrated with the simple example below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e65b75e639ba49f45b306162220bcb4b4e376b49" translate="yes" xml:space="preserve">
          <source>The call to &lt;code&gt;hs_init()&lt;/code&gt; initializes GHC&amp;rsquo;s runtime system. Do NOT try to invoke any Haskell functions before calling &lt;code&gt;hs_init()&lt;/code&gt;: bad things will undoubtedly happen.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0d2f80290077bea927d89a134d957a184f32cc5" translate="yes" xml:space="preserve">
          <source>The calls &lt;code&gt;&lt;a href=&quot;ghc-enum#v:succ&quot;&gt;succ&lt;/a&gt; &lt;a href=&quot;ghc-enum#v:maxBound&quot;&gt;maxBound&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ghc-enum#v:pred&quot;&gt;pred&lt;/a&gt; &lt;a href=&quot;ghc-enum#v:minBound&quot;&gt;minBound&lt;/a&gt;&lt;/code&gt; should result in a runtime error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="319dd86afb1a88f29e7d25a55be6766bfa4bbc86" translate="yes" xml:space="preserve">
          <source>The calls &lt;code&gt;&lt;a href=&quot;prelude#v:succ&quot;&gt;succ&lt;/a&gt; &lt;a href=&quot;prelude#v:maxBound&quot;&gt;maxBound&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;prelude#v:pred&quot;&gt;pred&lt;/a&gt; &lt;a href=&quot;prelude#v:minBound&quot;&gt;minBound&lt;/a&gt;&lt;/code&gt; should result in a runtime error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82bb223904345033a341142d4c4dc792513b34b0" translate="yes" xml:space="preserve">
          <source>The case for &lt;code&gt;&lt;a href=&quot;ghc-generics#t:K1&quot;&gt;K1&lt;/a&gt;&lt;/code&gt; is rather interesting. Here, we call the final function &lt;code&gt;encode&lt;/code&gt; that we yet have to define, recursively. We will use another type class &lt;code&gt;Encode&lt;/code&gt; for that function:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dbeba971901c44630a87f3ab4af1926015f93dc7" translate="yes" xml:space="preserve">
          <source>The channels are implemented with &lt;code&gt;MVar&lt;/code&gt;s and therefore inherit all the caveats that apply to &lt;code&gt;MVar&lt;/code&gt;s (possibility of races, deadlocks etc). The stm (software transactional memory) library has a more robust implementation of channels called &lt;code&gt;TChan&lt;/code&gt;s.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4069bea430852a057890df955f47a154334cab42" translate="yes" xml:space="preserve">
          <source>The character that is used to separate the entries in the $PATH environment variable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba11d47bc9956242fbb3ca66e5d4200f63de5f8d" translate="yes" xml:space="preserve">
          <source>The character that separates directories. In the case where more than one character is possible, &lt;code&gt;&lt;a href=&quot;system-filepath-posix#v:pathSeparator&quot;&gt;pathSeparator&lt;/a&gt;&lt;/code&gt; is the 'ideal' one.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0adbd55b5e31c8dee6ffdd25e981917f83978616" translate="yes" xml:space="preserve">
          <source>The character that separates directories. In the case where more than one character is possible, &lt;code&gt;&lt;a href=&quot;system-filepath-windows#v:pathSeparator&quot;&gt;pathSeparator&lt;/a&gt;&lt;/code&gt; is the 'ideal' one.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3300c6070d1ff47cc64a9cd4f2a57598bed4fe49" translate="yes" xml:space="preserve">
          <source>The character type &lt;code&gt;&lt;a href=&quot;data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; is an enumeration whose values represent Unicode (or equivalently ISO/IEC 10646) code points (i.e. characters, see &lt;a href=&quot;http://www.unicode.org/&quot;&gt;http://www.unicode.org/&lt;/a&gt; for details). This set extends the ISO 8859-1 (Latin-1) character set (the first 256 characters), which is itself an extension of the ASCII character set (the first 128 characters). A character literal in Haskell has type &lt;code&gt;&lt;a href=&quot;data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a83bfe2a3131f5d1fa9053b377b2dd8ef00abbee" translate="yes" xml:space="preserve">
          <source>The character type &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; is an enumeration whose values represent Unicode (or equivalently ISO/IEC 10646) code points (i.e. characters, see &lt;a href=&quot;http://www.unicode.org/&quot;&gt;http://www.unicode.org/&lt;/a&gt; for details). This set extends the ISO 8859-1 (Latin-1) character set (the first 256 characters), which is itself an extension of the ASCII character set (the first 128 characters). A character literal in Haskell has type &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e57b1fe87f343495401c4e61909f138148056d67" translate="yes" xml:space="preserve">
          <source>The character type &lt;code&gt;&lt;a href=&quot;prelude#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; is an enumeration whose values represent Unicode (or equivalently ISO/IEC 10646) code points (i.e. characters, see &lt;a href=&quot;http://www.unicode.org/&quot;&gt;http://www.unicode.org/&lt;/a&gt; for details). This set extends the ISO 8859-1 (Latin-1) character set (the first 256 characters), which is itself an extension of the ASCII character set (the first 128 characters). A character literal in Haskell has type &lt;code&gt;&lt;a href=&quot;prelude#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47f8f2f2dc9e65ebc1b9adf566bdf62f3dc06201" translate="yes" xml:space="preserve">
          <source>The chunk size used for I/O. Currently set to 32k, less the memory management overhead</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4ebe1e22516dcf7d377102ba02d7a72071fb54c" translate="yes" xml:space="preserve">
          <source>The class &lt;code&gt;&lt;a href=&quot;data-dynamic#t:Typeable&quot;&gt;Typeable&lt;/a&gt;&lt;/code&gt; allows a concrete representation of a type to be calculated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26ec99c0bc5533ce5fa506bf5dd334d666afbabf" translate="yes" xml:space="preserve">
          <source>The class &lt;code&gt;&lt;a href=&quot;data-typeable#t:Typeable&quot;&gt;Typeable&lt;/a&gt;&lt;/code&gt; allows a concrete representation of a type to be calculated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95e5985c3bffdb6706bd6da87ba82bb2b1f9502b" translate="yes" xml:space="preserve">
          <source>The class &lt;code&gt;&lt;a href=&quot;type-reflection#t:Typeable&quot;&gt;Typeable&lt;/a&gt;&lt;/code&gt; allows a concrete representation of a type to be calculated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0793307c198436ef6cbb2b38d12d842f11f5daa" translate="yes" xml:space="preserve">
          <source>The class &lt;code&gt;IsLabel&lt;/code&gt; is defined as:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da702fa4f893f1ff84ab94ead774536cedcefc5d" translate="yes" xml:space="preserve">
          <source>The class &lt;code&gt;IsString&lt;/code&gt; is defined as:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="314c44e92114b49583eff2b98f5eb8171a7374ef" translate="yes" xml:space="preserve">
          <source>The class &lt;code&gt;IsString&lt;/code&gt; is not in scope by default. If you want to mention it explicitly (for example, to give an instance declaration for it), you can import it from module &lt;code&gt;Data.String&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46c25aa9d510e6dfd769a86618af627836e67d95" translate="yes" xml:space="preserve">
          <source>The class &lt;code&gt;Lift&lt;/code&gt;, unlike other derivable classes, lives in &lt;code&gt;template-haskell&lt;/code&gt; instead of &lt;code&gt;base&lt;/code&gt;. Having a data type be an instance of &lt;code&gt;Lift&lt;/code&gt; permits its values to be promoted to Template Haskell expressions (of type &lt;code&gt;ExpQ&lt;/code&gt;), which can then be spliced into Haskell source code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cfedc7f27395d9e14f3b5dcae9116c684144dba3" translate="yes" xml:space="preserve">
          <source>The class &lt;code&gt;Typeable&lt;/code&gt; is very special:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a352e3bea5c92259e258192deb3bd391cda34543" translate="yes" xml:space="preserve">
          <source>The class instances for sequences are all based very closely on those for lists.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f29fdb13c7afe65c971d977ce119c943fb00e75f" translate="yes" xml:space="preserve">
          <source>The class of contravariant functors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15b84a81fb0f85cb419535a3a61b9ad1d3da02f7" translate="yes" xml:space="preserve">
          <source>The class of monad transformers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1aba4d36676a8723cc042f0ef18005b4207f229e" translate="yes" xml:space="preserve">
          <source>The class of monad transformers. Instances should satisfy the following laws, which state that &lt;code&gt;&lt;a href=&quot;control-monad-trans-class#v:lift&quot;&gt;lift&lt;/a&gt;&lt;/code&gt; is a monad transformation:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="968994db3d9c45181b57f61fe4736e2627f5c6a6" translate="yes" xml:space="preserve">
          <source>The class of monoids (types with an associative binary operation that has an identity). Instances should satisfy the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80aae29c2b395ab518f6cbf2867e04f61aabbf53" translate="yes" xml:space="preserve">
          <source>The class of semigroups (types with an associative binary operation).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef50832e806510cb4bbe9f9aafa22744526d2ab1" translate="yes" xml:space="preserve">
          <source>The class of the instance declaration is not declared in &lt;code&gt;M&lt;/code&gt;, and</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc31daa90372a8a474d012704a661ac277d958aa" translate="yes" xml:space="preserve">
          <source>The class of types which can be parsed given a UNIX-style time format string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="380a9b6da5c050f1cf3fa8febdb6d2797a540fc9" translate="yes" xml:space="preserve">
          <source>The closure of the superclass relation over these local axioms : &lt;code&gt;A a =&amp;gt; C a&lt;/code&gt; and &lt;code&gt;B a =&amp;gt; C a&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0848f15a7a4cc86662e9097e3f0cf4b1532d9192" translate="yes" xml:space="preserve">
          <source>The code for the method in the instance declaration is typechecked against the type signature supplied in the instance declaration, as you would expect. So if the instance signature is more polymorphic than required, the code must be too.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5001edd8f78114b36e24d8f0a44754ee90b2f4d" translate="yes" xml:space="preserve">
          <source>The code generator tries to generate as compact layout as possible for each unboxed sum. In the best case, size of an unboxed sum is size of its biggest alternative plus one word (for a tag). The algorithm for generating the memory layout for a sum type works like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3837898dd791b811ea7932889c5130e161088d94" translate="yes" xml:space="preserve">
          <source>The code of the &quot;dominant&quot; language of the webpage.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a45302a43608cfe9a77b37998c0a415b8fef0ffc" translate="yes" xml:space="preserve">
          <source>The code should be mostly self-explanatory. The slightly awkward syntax is because the combinators are written such that the size-bound of the resulting &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#t:BoundedPrim&quot;&gt;BoundedPrim&lt;/a&gt;&lt;/code&gt; can be computed at compile time. We also explicitly inline the &lt;code&gt;fixed2&lt;/code&gt; primitive, which encodes a fixed tuple of characters, to ensure that the bound computation happens at compile time. When encoding the following list of &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;s, the optimized implementation of &lt;code&gt;renderString&lt;/code&gt; is two times faster.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4421b2e89d7c073b3eeabb7b626aa07e05c2b134" translate="yes" xml:space="preserve">
          <source>The combinators &lt;code&gt;&lt;a href=&quot;data-data#v:gmapT&quot;&gt;gmapT&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-data#v:gmapQ&quot;&gt;gmapQ&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-data#v:gmapM&quot;&gt;gmapM&lt;/a&gt;&lt;/code&gt;, etc are all provided with default definitions in terms of &lt;code&gt;&lt;a href=&quot;data-data#v:gfoldl&quot;&gt;gfoldl&lt;/a&gt;&lt;/code&gt;, leaving open the opportunity to provide datatype-specific definitions. (The inclusion of the &lt;code&gt;gmap&lt;/code&gt; combinators as members of class &lt;code&gt;&lt;a href=&quot;data-data#t:Data&quot;&gt;Data&lt;/a&gt;&lt;/code&gt; allows the programmer or the compiler to derive specialised, and maybe more efficient code per datatype. &lt;em&gt;Note&lt;/em&gt;: &lt;code&gt;&lt;a href=&quot;data-data#v:gfoldl&quot;&gt;gfoldl&lt;/a&gt;&lt;/code&gt; is more higher-order than the &lt;code&gt;gmap&lt;/code&gt; combinators. This is subject to ongoing benchmarking experiments. It might turn out that the &lt;code&gt;gmap&lt;/code&gt; combinators will be moved out of the class &lt;code&gt;&lt;a href=&quot;data-data#t:Data&quot;&gt;Data&lt;/a&gt;&lt;/code&gt;.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d6f1f7c8a32c8db29cc4151cc5a6c27c5f31776" translate="yes" xml:space="preserve">
          <source>The combinators for &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#t:BoundedPrim&quot;&gt;BoundedPrim&lt;/a&gt;&lt;/code&gt;s are implemented such that the size of the resulting &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#t:BoundedPrim&quot;&gt;BoundedPrim&lt;/a&gt;&lt;/code&gt; can be computed at compile time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b36fb23ba2c0fd5cf9cc5fbcaa48f3fa3936ed5b" translate="yes" xml:space="preserve">
          <source>The combinators for &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#t:FixedPrim&quot;&gt;FixedPrim&lt;/a&gt;&lt;/code&gt;s are implemented such that the &lt;code&gt;size&lt;/code&gt; of the resulting &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#t:FixedPrim&quot;&gt;FixedPrim&lt;/a&gt;&lt;/code&gt; is computed at compile time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2acc0788b34136669ccf2620396da51b7563e2c2" translate="yes" xml:space="preserve">
          <source>The command &lt;a href=&quot;#ghci-cmd-:show%20imports&quot;&gt;&lt;code&gt;:show imports&lt;/code&gt;&lt;/a&gt; will show a summary of which modules contribute to the top-level scope.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5fdeb122c09642094fcfc48bef6bdcdff89e8605" translate="yes" xml:space="preserve">
          <source>The command &lt;a href=&quot;#ghci-cmd-:step&quot;&gt;&lt;code&gt;:step expr&lt;/code&gt;&lt;/a&gt; begins the evaluation of ⟨expr⟩ in single-stepping mode. If ⟨expr⟩ is omitted, then it single-steps from the current breakpoint. &lt;a href=&quot;#ghci-cmd-:steplocal&quot;&gt;&lt;code&gt;:steplocal&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#ghci-cmd-:stepmodule&quot;&gt;&lt;code&gt;:stepmodule&lt;/code&gt;&lt;/a&gt; commands work similarly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a632ebd88f50b8ac78cacda34b5408a0be9ab51c" translate="yes" xml:space="preserve">
          <source>The command &lt;code&gt;:break 2&lt;/code&gt; sets a breakpoint on line 2 of the most recently-loaded module, in this case &lt;code&gt;qsort.hs&lt;/code&gt;. Specifically, it picks the leftmost complete subexpression on that line on which to set the breakpoint, which in this case is the expression &lt;code&gt;(qsort left ++ [a] ++ qsort right)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e40dd230e05a9e07fe62ec45624d094d383aa421" translate="yes" xml:space="preserve">
          <source>The command &lt;code&gt;:info!&lt;/code&gt; works in a similar fashion but it removes restriction (b), showing all instances that are in scope and mention ⟨name⟩ in their head.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db3abb134ad672048db99caf88a85888bde3b864" translate="yes" xml:space="preserve">
          <source>The command &lt;code&gt;fgrep -n END_SAMPLE FOO.hp&lt;/code&gt; finds the end of every complete sample in &lt;code&gt;FOO.hp&lt;/code&gt;, and labels each sample with its ending line number. We then select the line number of the last complete sample using &lt;strong&gt;tail&lt;/strong&gt; and &lt;strong&gt;cut&lt;/strong&gt;. This is used as a parameter to &lt;strong&gt;head&lt;/strong&gt;; the result is as if we deleted the final incomplete sample from &lt;code&gt;FOO.hp&lt;/code&gt;. This results in a properly-formatted .hp file which we feed directly to &lt;strong&gt;hp2ps&lt;/strong&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="270408c21f336615635c1e2a2c6f2941c9ac84d6" translate="yes" xml:space="preserve">
          <source>The command line arguments passed to the program</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7e794e0f93c2fa925b60afdb7fbdedb64d80c09" translate="yes" xml:space="preserve">
          <source>The command line arguments passed to the runtime system</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77b364d49a3dfa5e15b2ed62d447248ab845ef6f" translate="yes" xml:space="preserve">
          <source>The command to run, which must be in the $PATH, or an absolute or relative path</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9eb0075b8efba5d950b353dc2ba8dd18856c0b6" translate="yes" xml:space="preserve">
          <source>The command versions of lambda abstraction and application are analogous to the expression versions. In particular, the beta and eta rules describe equivalences of commands. These three features (operators, lambda abstraction and application) are the core of the notation; everything else can be built using them, though the results would be somewhat clumsy. For example, we could simulate &lt;code&gt;do&lt;/code&gt;-notation by defining</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a1e2c9e679e0ed25e609bb32dccdb1dffa31a77" translate="yes" xml:space="preserve">
          <source>The comparable symbols for other systems are: &lt;code&gt;__HUGS__&lt;/code&gt; for Hugs, &lt;code&gt;__NHC__&lt;/code&gt; for nhc98, and &lt;code&gt;__HBC__&lt;/code&gt; for hbc).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b172d1caf74bb5840fcb833db8910b15eee4ccf4" translate="yes" xml:space="preserve">
          <source>The compiler does not overwrite an existing &lt;code&gt;.hi&lt;/code&gt; interface file if the new one is the same as the old one; this is friendly to &lt;strong&gt;make&lt;/strong&gt;. When an interface does change, it is often enlightening to be informed. The &lt;a href=&quot;#ghc-flag--ddump-hi-diffs&quot;&gt;&lt;code&gt;-ddump-hi-diffs&lt;/code&gt;&lt;/a&gt; option will make GHC report the differences between the old and new &lt;code&gt;.hi&lt;/code&gt; files.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b50c4e0495b638bc78f832720f50e287f9de7a05" translate="yes" xml:space="preserve">
          <source>The compiler infers that the field is lazy, so it is tagged with &lt;code&gt;'DecidedLazy&lt;/code&gt;. Bear in mind that what the compiler decides may be quite different from what is written in the source. See &lt;code&gt;&lt;a href=&quot;ghc-generics#t:DecidedStrictness&quot;&gt;DecidedStrictness&lt;/a&gt;&lt;/code&gt; for a more detailed explanation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9774a668aa7877058c555311f9fc25aa40959a13" translate="yes" xml:space="preserve">
          <source>The compiler version can be tested within compiled code with the &lt;code&gt;MIN_VERSION_GLASGOW_HASKELL&lt;/code&gt; CPP macro (defined only when &lt;a href=&quot;phases#extension-CPP&quot;&gt;&lt;code&gt;-XCPP&lt;/code&gt;&lt;/a&gt; is used). See &lt;a href=&quot;phases#standard-cpp-macros&quot;&gt;Standard CPP macros&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d31425166e0b9b41d209465f54952b68c26f02ba" translate="yes" xml:space="preserve">
          <source>The compiler will avoid reboxing &lt;code&gt;f1&lt;/code&gt; and &lt;code&gt;f2&lt;/code&gt; by inlining &lt;code&gt;+&lt;/code&gt; on floats, but only when &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt;&lt;code&gt;-O&lt;/code&gt;&lt;/a&gt; is on.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a57eab48089d44200f2aa63903639e1a99c72105" translate="yes" xml:space="preserve">
          <source>The compiler will warn here that the deriving clause doesn&amp;rsquo;t specify a strategy. If the warning is enabled, but &lt;a href=&quot;glasgow_exts#extension-DerivingStrategies&quot;&gt;&lt;code&gt;DerivingStrategies&lt;/code&gt;&lt;/a&gt; is not enabled, the compiler will suggest turning on the &lt;a href=&quot;glasgow_exts#extension-DerivingStrategies&quot;&gt;&lt;code&gt;DerivingStrategies&lt;/code&gt;&lt;/a&gt; extension. This option is not on by default, having to be turned on manually or with &lt;a href=&quot;#ghc-flag--Weverything&quot;&gt;&lt;code&gt;-Weverything&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="281ed5525515ea0993e70db30ed197e71b26abff" translate="yes" xml:space="preserve">
          <source>The complete user-supplied kind signature specifies the polymorphic kind for &lt;code&gt;T&lt;/code&gt;, and this signature is used for all the calls to &lt;code&gt;T&lt;/code&gt; including the recursive ones. In particular, the recursive use of &lt;code&gt;T&lt;/code&gt; is at kind &lt;code&gt;Type&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2bfd3d94f53069effc94df0d648f9c72f750ccc" translate="yes" xml:space="preserve">
          <source>The comprehension should typecheck when its desugaring would typecheck, except that (as discussed in &lt;a href=&quot;#generalised-list-comprehensions&quot;&gt;Generalised (SQL-like) List Comprehensions&lt;/a&gt;) in the &amp;ldquo;then &lt;code&gt;f&lt;/code&gt;&amp;rdquo; and &amp;ldquo;then group using &lt;code&gt;f&lt;/code&gt;&amp;rdquo; clauses, when the &amp;ldquo;by &lt;code&gt;b&lt;/code&gt;&amp;rdquo; qualifier is omitted, argument &lt;code&gt;f&lt;/code&gt; should have a polymorphic type. In particular, &amp;ldquo;then &lt;code&gt;Data.List.sort&lt;/code&gt;&amp;rdquo; and &amp;ldquo;then group using &lt;code&gt;Data.List.group&lt;/code&gt;&amp;rdquo; are insufficiently polymorphic.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e59db8b8873fb6251bff5cd6dfad77bf9b5938cd" translate="yes" xml:space="preserve">
          <source>The computation &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:isEOF&quot;&gt;isEOF&lt;/a&gt;&lt;/code&gt; is identical to &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hIsEOF&quot;&gt;hIsEOF&lt;/a&gt;&lt;/code&gt;, except that it works only on &lt;code&gt;&lt;a href=&quot;ghc-io-handle-fd#v:stdin&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cebda4e55c3afba7a9d7719124e3ada63e52bb27" translate="yes" xml:space="preserve">
          <source>The computation &lt;code&gt;&lt;a href=&quot;prelude#v:appendFile&quot;&gt;appendFile&lt;/a&gt;&lt;/code&gt;&lt;code&gt;file str&lt;/code&gt; function appends the string &lt;code&gt;str&lt;/code&gt;, to the file &lt;code&gt;file&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46965f614145fd2e0bb961350e8543a37e0dd3ca" translate="yes" xml:space="preserve">
          <source>The computation &lt;code&gt;&lt;a href=&quot;prelude#v:writeFile&quot;&gt;writeFile&lt;/a&gt;&lt;/code&gt;&lt;code&gt;file str&lt;/code&gt; function writes the string &lt;code&gt;str&lt;/code&gt;, to the file &lt;code&gt;file&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a4547aaf52f671ee4d0ac2c8d5630bfc87a6e62" translate="yes" xml:space="preserve">
          <source>The computation &lt;code&gt;&lt;a href=&quot;system-cmd#v:rawSystem&quot;&gt;rawSystem&lt;/a&gt; &lt;em&gt;cmd&lt;/em&gt; &lt;em&gt;args&lt;/em&gt;&lt;/code&gt; runs the operating system command &lt;code&gt;&lt;em&gt;cmd&lt;/em&gt;&lt;/code&gt; in such a way that it receives as arguments the &lt;code&gt;&lt;em&gt;args&lt;/em&gt;&lt;/code&gt; strings exactly as given, with no funny escaping or shell meta-syntax expansion. It will therefore behave more portably between operating systems than &lt;code&gt;&lt;a href=&quot;system-cmd#v:system&quot;&gt;system&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9a90ff37849eb4211f81461b5303f42712fea0c" translate="yes" xml:space="preserve">
          <source>The computation &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:exitFailure&quot;&gt;exitFailure&lt;/a&gt;&lt;/code&gt; is equivalent to &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-exit#v:exitWith&quot;&gt;exitWith&lt;/a&gt;&lt;/code&gt;&lt;code&gt;(&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-exit#v:ExitFailure&quot;&gt;ExitFailure&lt;/a&gt;&lt;/code&gt;&lt;em&gt;exitfail&lt;/em&gt;&lt;code&gt;)&lt;/code&gt;, where &lt;em&gt;exitfail&lt;/em&gt; is implementation-dependent.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc29dbc900c1c24c106776b04df9bca05e5cfe6e" translate="yes" xml:space="preserve">
          <source>The computation &lt;code&gt;&lt;a href=&quot;system-exit#v:exitFailure&quot;&gt;exitFailure&lt;/a&gt;&lt;/code&gt; is equivalent to &lt;code&gt;&lt;a href=&quot;system-exit#v:exitWith&quot;&gt;exitWith&lt;/a&gt;&lt;/code&gt;&lt;code&gt;(&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;system-exit#v:ExitFailure&quot;&gt;ExitFailure&lt;/a&gt;&lt;/code&gt;&lt;em&gt;exitfail&lt;/em&gt;&lt;code&gt;)&lt;/code&gt;, where &lt;em&gt;exitfail&lt;/em&gt; is implementation-dependent.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb6d36ed658ece003695ded60aa84d344703fa74" translate="yes" xml:space="preserve">
          <source>The computation &lt;code&gt;&lt;a href=&quot;system-exit#v:exitSuccess&quot;&gt;exitSuccess&lt;/a&gt;&lt;/code&gt; is equivalent to &lt;code&gt;&lt;a href=&quot;system-exit#v:exitWith&quot;&gt;exitWith&lt;/a&gt;&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;system-exit#v:ExitSuccess&quot;&gt;ExitSuccess&lt;/a&gt;&lt;/code&gt;, It terminates the program successfully.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4d04e67ce9ab76c0bbbdea2ad0f01cd7fcbeeb5" translate="yes" xml:space="preserve">
          <source>The computation &lt;code&gt;&lt;a href=&quot;system-io#v:appendFile&quot;&gt;appendFile&lt;/a&gt;&lt;/code&gt;&lt;code&gt;file str&lt;/code&gt; function appends the string &lt;code&gt;str&lt;/code&gt;, to the file &lt;code&gt;file&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18d116851ac5689419eab11fff58738d4aba225b" translate="yes" xml:space="preserve">
          <source>The computation &lt;code&gt;&lt;a href=&quot;system-io#v:isEOF&quot;&gt;isEOF&lt;/a&gt;&lt;/code&gt; is identical to &lt;code&gt;&lt;a href=&quot;system-io#v:hIsEOF&quot;&gt;hIsEOF&lt;/a&gt;&lt;/code&gt;, except that it works only on &lt;code&gt;&lt;a href=&quot;system-io#v:stdin&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46ebfbedadd3b348e49908c00c7a136ae0a3b598" translate="yes" xml:space="preserve">
          <source>The computation &lt;code&gt;&lt;a href=&quot;system-io#v:writeFile&quot;&gt;writeFile&lt;/a&gt;&lt;/code&gt;&lt;code&gt;file str&lt;/code&gt; function writes the string &lt;code&gt;str&lt;/code&gt;, to the file &lt;code&gt;file&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="beccc8e7666a74c9241e66c916390d713f7e9a28" translate="yes" xml:space="preserve">
          <source>The computation &lt;code&gt;&lt;a href=&quot;system-process#v:rawSystem&quot;&gt;rawSystem&lt;/a&gt; &lt;em&gt;cmd&lt;/em&gt; &lt;em&gt;args&lt;/em&gt;&lt;/code&gt; runs the operating system command &lt;code&gt;&lt;em&gt;cmd&lt;/em&gt;&lt;/code&gt; in such a way that it receives as arguments the &lt;code&gt;&lt;em&gt;args&lt;/em&gt;&lt;/code&gt; strings exactly as given, with no funny escaping or shell meta-syntax expansion. It will therefore behave more portably between operating systems than &lt;code&gt;&lt;a href=&quot;system-process#v:system&quot;&gt;system&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f1a05335883c13dae3be1b4a36833b306a5efd1" translate="yes" xml:space="preserve">
          <source>The computation may be performed multiple times by different threads, possibly at the same time. To ensure that the computation is performed only once, use &lt;code&gt;&lt;a href=&quot;ghc-io#v:unsafeInterleaveIO&quot;&gt;unsafeInterleaveIO&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44b39b2d94fcf4d161bbbadc2ba27b97f45eae93" translate="yes" xml:space="preserve">
          <source>The computation may be performed multiple times by different threads, possibly at the same time. To ensure that the computation is performed only once, use &lt;code&gt;&lt;a href=&quot;ghc-io-unsafe#v:unsafeInterleaveIO&quot;&gt;unsafeInterleaveIO&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="add1c55634d2623f9699ebad8b5515dd2d17e5c6" translate="yes" xml:space="preserve">
          <source>The computation may be performed multiple times by different threads, possibly at the same time. To prevent this, use &lt;code&gt;&lt;a href=&quot;control-monad-st-unsafe#v:unsafeInterleaveST&quot;&gt;unsafeInterleaveST&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07d17cfabe3f3fcfca85238e3259375c3de9c784" translate="yes" xml:space="preserve">
          <source>The computation may be performed multiple times by different threads, possibly at the same time. To prevent this, use &lt;code&gt;&lt;a href=&quot;ghc-st#v:unsafeInterleaveST&quot;&gt;unsafeInterleaveST&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52f9695a125810fcb1729c58e4b509090979268c" translate="yes" xml:space="preserve">
          <source>The computation to run</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7849b8b63ccfaa0ec4dad86a18080d47939b33fc" translate="yes" xml:space="preserve">
          <source>The concatenation of all the elements of a container of lists.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="511dfe8f476504df65281a958ed6b2922f8e44b9" translate="yes" xml:space="preserve">
          <source>The concurrency extension for Haskell is described in the paper &lt;em&gt;Concurrent Haskell&lt;/em&gt;&lt;a href=&quot;http://www.haskell.org/ghc/docs/papers/concurrent-haskell.ps.gz&quot;&gt;http://www.haskell.org/ghc/docs/papers/concurrent-haskell.ps.gz&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00393330d59cb21f77b62b7a951195b4749b08f5" translate="yes" xml:space="preserve">
          <source>The conjugate of a complex number.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e61d83010032d16fcd6d96bc1ee67e74abc2ee7" translate="yes" xml:space="preserve">
          <source>The connected components of a graph. Two vertices are connected if there is a path between them, traversing edges in either direction.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5b6ceffe39d0d5eedc736955541b7ffa6430ede" translate="yes" xml:space="preserve">
          <source>The cons constructor (e.g &lt;code&gt;3:4:[]&lt;/code&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ba3b2a290b55dc2fc0d0d6af5a22e45514ed39e" translate="yes" xml:space="preserve">
          <source>The constant &lt;code&gt;&lt;a href=&quot;foreign-ptr#v:nullFunPtr&quot;&gt;nullFunPtr&lt;/a&gt;&lt;/code&gt; contains a distinguished value of &lt;code&gt;&lt;a href=&quot;foreign-ptr#t:FunPtr&quot;&gt;FunPtr&lt;/a&gt;&lt;/code&gt; that is not associated with a valid memory location.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28d23ff9245e92f331af466af03ff314f5479be2" translate="yes" xml:space="preserve">
          <source>The constant &lt;code&gt;&lt;a href=&quot;foreign-ptr#v:nullPtr&quot;&gt;nullPtr&lt;/a&gt;&lt;/code&gt; contains a distinguished value of &lt;code&gt;&lt;a href=&quot;foreign-ptr#t:Ptr&quot;&gt;Ptr&lt;/a&gt;&lt;/code&gt; that is not associated with a valid memory location.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9836a72bb97f8856c19c64a657d43deda4d232f2" translate="yes" xml:space="preserve">
          <source>The constant &lt;code&gt;&lt;a href=&quot;ghc-ptr#v:nullFunPtr&quot;&gt;nullFunPtr&lt;/a&gt;&lt;/code&gt; contains a distinguished value of &lt;code&gt;&lt;a href=&quot;ghc-ptr#t:FunPtr&quot;&gt;FunPtr&lt;/a&gt;&lt;/code&gt; that is not associated with a valid memory location.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f76a0e137f54f18c3f7ac1708ea489f83a12cf45" translate="yes" xml:space="preserve">
          <source>The constant &lt;code&gt;&lt;a href=&quot;ghc-ptr#v:nullPtr&quot;&gt;nullPtr&lt;/a&gt;&lt;/code&gt; contains a distinguished value of &lt;code&gt;&lt;a href=&quot;ghc-ptr#t:Ptr&quot;&gt;Ptr&lt;/a&gt;&lt;/code&gt; that is not associated with a valid memory location.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86d0acfb8c600d07e3b3575390f9c70049148847" translate="yes" xml:space="preserve">
          <source>The constant &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:nullPtr&quot;&gt;nullPtr&lt;/a&gt;&lt;/code&gt; contains a distinguished value of &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#t:Ptr&quot;&gt;Ptr&lt;/a&gt;&lt;/code&gt; that is not associated with a valid memory location.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aee9b6f259cc959b36e11590eea5cb4db85f0c33" translate="yes" xml:space="preserve">
          <source>The constant &lt;code&gt;&lt;a href=&quot;system-win32-types#v:nullPtr&quot;&gt;nullPtr&lt;/a&gt;&lt;/code&gt; contains a distinguished value of &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-ptr#t:Ptr&quot;&gt;Ptr&lt;/a&gt;&lt;/code&gt; that is not associated with a valid memory location.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="799dc66320c38ca69a9441401db6bffcbf9eb360" translate="yes" xml:space="preserve">
          <source>The constant functor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15ca88cd220e51ba407b106275a1029cb4b766e9" translate="yes" xml:space="preserve">
          <source>The constraint &lt;code&gt;Coercible t1 t2&lt;/code&gt; is similar to &lt;code&gt;t1 ~ t2&lt;/code&gt;, but denotes representational equality between &lt;code&gt;t1&lt;/code&gt; and &lt;code&gt;t2&lt;/code&gt; in the sense of Roles (&lt;a href=&quot;#roles&quot;&gt;Roles&lt;/a&gt;). It is exported by &lt;a href=&quot;../libraries/base-4.13.0.0/data-coerce&quot;&gt;Data.Coerce&lt;/a&gt;, which also contains the documentation. More details and discussion can be found in the paper &lt;a href=&quot;https://www.microsoft.com/en-us/research/uploads/prod/2018/05/coercible-JFP.pdf&quot;&gt;&amp;ldquo;Safe Coercions&amp;rdquo;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b45d0e4831d974f0b76095cef9bc4b87f2ec6bb" translate="yes" xml:space="preserve">
          <source>The constraint has fewer constructors and variables (taken together and counting repetitions) than the head</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a50d755f429fad42bcff479620bc13360a0c4b46" translate="yes" xml:space="preserve">
          <source>The constraint mentions at least one type variable. So this is allowed:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce649c6fe844bb02501d53bdc8fcdcf10a388961" translate="yes" xml:space="preserve">
          <source>The constraint mentions no type functions. A type function application can in principle expand to a type of arbitrary size, and so are rejected out of hand</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1443e2e18615f60be07422db9598a6ab2679217" translate="yes" xml:space="preserve">
          <source>The constraints: &lt;code&gt;(C1, C2, ..)&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="112775bf1168cc3582de7a46d153e201b0ce10f8" translate="yes" xml:space="preserve">
          <source>The construct &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:tryIOError&quot;&gt;tryIOError&lt;/a&gt;&lt;/code&gt;&lt;code&gt;comp&lt;/code&gt; exposes IO errors which occur within a computation, and which are not fully handled.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2cbf6e1527ac15029debb90371be54661016768" translate="yes" xml:space="preserve">
          <source>The construct &lt;code&gt;&lt;a href=&quot;system-io-error#v:tryIOError&quot;&gt;tryIOError&lt;/a&gt;&lt;/code&gt;&lt;code&gt;comp&lt;/code&gt; exposes IO errors which occur within a computation, and which are not fully handled.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9cb341bdfdb67d6c8abafd06a4a86c8917f60b5" translate="yes" xml:space="preserve">
          <source>The constructors for &lt;code&gt;&lt;a href=&quot;language-haskell-th#t:Con&quot;&gt;Con&lt;/a&gt;&lt;/code&gt; can roughly be divided up into two categories: those for constructors with &quot;vanilla&quot; syntax (&lt;code&gt;&lt;a href=&quot;language-haskell-th#v:NormalC&quot;&gt;NormalC&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:RecC&quot;&gt;RecC&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:InfixC&quot;&gt;InfixC&lt;/a&gt;&lt;/code&gt;), and those for constructors with GADT syntax (&lt;code&gt;&lt;a href=&quot;language-haskell-th#v:GadtC&quot;&gt;GadtC&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:RecGadtC&quot;&gt;RecGadtC&lt;/a&gt;&lt;/code&gt;). The &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:ForallC&quot;&gt;ForallC&lt;/a&gt;&lt;/code&gt; constructor, which quantifies additional type variables and class contexts, can surround either variety of constructor. However, the type variables that it quantifies are different depending on what constructor syntax is used:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96dfdfe1a048f1f49896be9e99d5931a975888f5" translate="yes" xml:space="preserve">
          <source>The constructors for &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:Con&quot;&gt;Con&lt;/a&gt;&lt;/code&gt; can roughly be divided up into two categories: those for constructors with &quot;vanilla&quot; syntax (&lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:NormalC&quot;&gt;NormalC&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:RecC&quot;&gt;RecC&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:InfixC&quot;&gt;InfixC&lt;/a&gt;&lt;/code&gt;), and those for constructors with GADT syntax (&lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:GadtC&quot;&gt;GadtC&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:RecGadtC&quot;&gt;RecGadtC&lt;/a&gt;&lt;/code&gt;). The &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:ForallC&quot;&gt;ForallC&lt;/a&gt;&lt;/code&gt; constructor, which quantifies additional type variables and class contexts, can surround either variety of constructor. However, the type variables that it quantifies are different depending on what constructor syntax is used:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2ef5f16504fcf65ef460021616315706e1e4d2a" translate="yes" xml:space="preserve">
          <source>The constructors have rank-2 types:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9e51adba83704f5afe34590e66e2249e5965154" translate="yes" xml:space="preserve">
          <source>The contents of &lt;code&gt;OPTIONS_GHC&lt;/code&gt; are appended to the command-line options, so options given in the source file override those given on the command-line.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dff9227ff63668c69518bca492a298e49c135a62" translate="yes" xml:space="preserve">
          <source>The contents of this module is liable to change, or disappear entirely. Please &lt;a href=&quot;https://github.com/haskell/time/issues/new&quot;&gt;let me know&lt;/a&gt; if you depend on anything here.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a40246a3e18d1d7e41c15d6857dbf0b4d63fa72" translate="yes" xml:space="preserve">
          <source>The contents of this module may change &lt;strong&gt;in any way whatsoever&lt;/strong&gt; and &lt;strong&gt;without any warning&lt;/strong&gt; between minor versions of this package.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf37f21b6a3daad2c6c95d66502066032ad944e9" translate="yes" xml:space="preserve">
          <source>The continuation monad transformer. Can be used to add continuation handling to any type constructor: the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; instance and most of the operations do not require &lt;code&gt;m&lt;/code&gt; to be a monad.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f75193e312873c254935fbb8e4b2cdc1397df81b" translate="yes" xml:space="preserve">
          <source>The corresponding &lt;code&gt;makeAbsolute&lt;/code&gt; function can be found in &lt;code&gt;System.Directory&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fbffcb96186edf6acc0b855b93198f4a5cdf1151" translate="yes" xml:space="preserve">
          <source>The corresponding translation for an IO-typed &lt;code&gt;e&lt;/code&gt; is</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86d8b09707b93cf768c10a7d141f2453f73455d0" translate="yes" xml:space="preserve">
          <source>The costs of all CAFs in a module are usually attributed to one &amp;ldquo;big&amp;rdquo; CAF cost-centre. With this option, all CAFs get their own cost-centre. An &amp;ldquo;if all else fails&amp;rdquo; option&amp;hellip;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7cf65e46a7de9baa89f7b3eb6db073c4649dd328" translate="yes" xml:space="preserve">
          <source>The cumulative allocations of the program in bytes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a3b930a34c98c0e41a7bef5730a3bbf42841f7f" translate="yes" xml:space="preserve">
          <source>The current implementation of the &lt;code&gt;OverloadedLists&lt;/code&gt; extension can be improved by handling the lists that are only populated with literals in a special way. More specifically, the compiler could allocate such lists statically using a compact representation and allow &lt;code&gt;IsList&lt;/code&gt; instances to take advantage of the compact representation. Equipped with this capability the &lt;code&gt;OverloadedLists&lt;/code&gt; extension will be in a good position to subsume the &lt;code&gt;OverloadedStrings&lt;/code&gt; extension (currently, as a special case, string literals benefit from statically allocated compact representation).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ad91c37c3debcd3611b7e9c0f27ffd87d2d02eb" translate="yes" xml:space="preserve">
          <source>The current notion of when two view pattern expressions are &amp;ldquo;the same&amp;rdquo; is very restricted: it is not even full syntactic equality. However, it does include variables, literals, applications, and tuples; e.g., two instances of &lt;code&gt;view (&quot;hi&quot;, &quot;there&quot;)&lt;/code&gt; will be collected. However, the current implementation does not compare up to alpha-equivalence, so two instances of &lt;code&gt;(x, view x -&amp;gt; y)&lt;/code&gt; will not be coalesced.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a1a29ae3433386a16c919320319cfdd85da4c46" translate="yes" xml:space="preserve">
          <source>The current status of a thread</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82c826fe4c2ec0dd5e2b6732f42c3a1009fa7e05" translate="yes" xml:space="preserve">
          <source>The current thread's stack exceeded its limit. Since an exception has been raised, the thread's stack will certainly be below its limit again, but the programmer should take remedial action immediately.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed3b026bad78c443d4533994012a8c4a2846cb3c" translate="yes" xml:space="preserve">
          <source>The current value of the &lt;code&gt;-N&lt;/code&gt; option is available to the Haskell program via &lt;code&gt;Control.Concurrent.getNumCapabilities&lt;/code&gt;, and it may be changed while the program is running by calling &lt;code&gt;Control.Concurrent.setNumCapabilities&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ec8f77a94455e151e4c1a9e7ec7c517542a0b66" translate="yes" xml:space="preserve">
          <source>The cut-down Haskell lexer, used by Text.Read</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00bd3d9662d83ac9ec53f0ae935356d4eabc4566" translate="yes" xml:space="preserve">
          <source>The data family &lt;code&gt;URec&lt;/code&gt; is provided to enable generic programming over datatypes with certain unlifted arguments. There are six instances corresponding to common unlifted types:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7cc312cbbdd186a59028317a6d6a5545651161f0" translate="yes" xml:space="preserve">
          <source>The data or type family instance for an associated type must follow the rule that the type indexes corresponding to class parameters must have precisely the same as type given in the instance head. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c9753438fba7e9bfbfa96374f6632d59b89893a" translate="yes" xml:space="preserve">
          <source>The data type &lt;code&gt;Foo&lt;/code&gt; has two constructors with types:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e622f9e9a73471a6364b9efb8251bd756d0f5650" translate="yes" xml:space="preserve">
          <source>The data type invariant for lazy &lt;code&gt;&lt;a href=&quot;data-text-internal-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;: Every &lt;code&gt;&lt;a href=&quot;data-text-internal-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; is either &lt;code&gt;&lt;a href=&quot;data-text-internal-lazy#v:Empty&quot;&gt;Empty&lt;/a&gt;&lt;/code&gt; or consists of non-null &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;s. All functions must preserve this, and the QC properties must check this.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d0441bbee470c2143c8f36a2d1679d26b7e70ba" translate="yes" xml:space="preserve">
          <source>The data type invariant: Every ByteString is either &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-internal#v:Empty&quot;&gt;Empty&lt;/a&gt;&lt;/code&gt; or consists of non-null &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;s. All functions must preserve this, and the QC properties must check this.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d85f04588f07b22aadb87552b730e4cf6174d81" translate="yes" xml:space="preserve">
          <source>The data types and monadic constructor functions for Template Haskell are in the library &lt;code&gt;Language.Haskell.TH.Syntax&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65cb9fa712c4ef1743587a031048fc3377115bf6" translate="yes" xml:space="preserve">
          <source>The datatype below derives the &lt;code&gt;Eq&lt;/code&gt; typeclass, but doesn&amp;rsquo;t specify a strategy. When &lt;a href=&quot;#ghc-flag--Wmissing-deriving-strategies&quot;&gt;&lt;code&gt;-Wmissing-deriving-strategies&lt;/code&gt;&lt;/a&gt; is enabled, the compiler will emit a warning about this.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09ea5a667a11159497b7db70c8ac2393a6a6a569" translate="yes" xml:space="preserve">
          <source>The day of the epoch of &lt;code&gt;&lt;a href=&quot;data-time-clock-system#t:SystemTime&quot;&gt;SystemTime&lt;/a&gt;&lt;/code&gt;, 1970-01-01</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="425505b50ca94bcb223c9489d59b624f0fd02138" translate="yes" xml:space="preserve">
          <source>The debugger provides the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d008597f45a1f7e417f2daa3afa26ed473de0e47" translate="yes" xml:space="preserve">
          <source>The debugging options &lt;code&gt;-Dx&lt;/code&gt; also generate events which are logged using the tracing framework. By default those events are dumped as text to stdout (&lt;code&gt;-Dx&lt;/code&gt; implies &lt;code&gt;-v&lt;/code&gt;), but they may instead be stored in the binary eventlog file by using the &lt;code&gt;-l&lt;/code&gt; option.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8dbf33fb940a3d9f2a5b57f121f6732a25396c40" translate="yes" xml:space="preserve">
          <source>The declaration</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61598f72e2c92204906e453b4899d9c4f265e7a4" translate="yes" xml:space="preserve">
          <source>The declaration for &lt;code&gt;HCons&lt;/code&gt; also requires &lt;a href=&quot;#extension-TypeOperators&quot;&gt;&lt;code&gt;TypeOperators&lt;/code&gt;&lt;/a&gt; because of infix type operator &lt;code&gt;(':)&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4404a7232bfc86c4b3054c2503dd6ddca4de51d" translate="yes" xml:space="preserve">
          <source>The declaration group containing &lt;code&gt;D&lt;/code&gt; is terminated by the empty top-level declaration splice &lt;code&gt;$(return [])&lt;/code&gt; (recall, &lt;code&gt;Q&lt;/code&gt; is a Monad, so we may simply &lt;code&gt;return&lt;/code&gt; the empty list of declarations).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f3eb1e20a19137970a20b350de0e993090c5f42" translate="yes" xml:space="preserve">
          <source>The declarations and types from signatures of dependencies that will be merged in are not in scope when type checking an &lt;code&gt;hsig&lt;/code&gt; file. To refer to any such type, you must declare it yourself:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28bc248b719a26880d510c50487bc9904247476f" translate="yes" xml:space="preserve">
          <source>The decoder has consumed the available input and needs more to continue. Provide &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; if more input is available and &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; otherwise, and you will get a new &lt;code&gt;&lt;a href=&quot;data-binary-get#t:Decoder&quot;&gt;Decoder&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7be60721ea4767c773d4ff5809e621bbad6d744b" translate="yes" xml:space="preserve">
          <source>The decoder has successfully finished. Except for the output value you also get any unused input as well as the number of bytes consumed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c50453020b64e1b5897a128e6a4b8f6fd0ce71b8" translate="yes" xml:space="preserve">
          <source>The decoder ran into an error. The decoder either used &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad-fail#v:fail&quot;&gt;fail&lt;/a&gt;&lt;/code&gt; or was not provided enough input. Contains any unconsumed input and the number of bytes consumed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1106af4463a8221ffa09eb5ef1181409ca7b66ab" translate="yes" xml:space="preserve">
          <source>The decoder to isolate</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9109ffd32c6c50a2b3bbde42b4613b2367726367" translate="yes" xml:space="preserve">
          <source>The default &lt;code&gt;&lt;a href=&quot;system-io#t:NewlineMode&quot;&gt;NewlineMode&lt;/a&gt;&lt;/code&gt; for a &lt;code&gt;&lt;a href=&quot;system-io#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;system-io#v:nativeNewlineMode&quot;&gt;nativeNewlineMode&lt;/a&gt;&lt;/code&gt;, which does no translation on Unix systems, but translates &lt;code&gt;'\r\n'&lt;/code&gt; to &lt;code&gt;'\n'&lt;/code&gt; and back on Windows.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1abf9eda04f648cec0d055b085fe295d921786f" translate="yes" xml:space="preserve">
          <source>The default &lt;code&gt;&lt;a href=&quot;system-io#t:TextEncoding&quot;&gt;TextEncoding&lt;/a&gt;&lt;/code&gt; is the same as the default encoding on your system, which is also available as &lt;code&gt;&lt;a href=&quot;system-io#v:localeEncoding&quot;&gt;localeEncoding&lt;/a&gt;&lt;/code&gt;. (GHC note: on Windows, we currently do not support double-byte encodings; if the console's code page is unsupported, then &lt;code&gt;&lt;a href=&quot;system-io#v:localeEncoding&quot;&gt;localeEncoding&lt;/a&gt;&lt;/code&gt; will be &lt;code&gt;&lt;a href=&quot;system-io#v:latin1&quot;&gt;latin1&lt;/a&gt;&lt;/code&gt;.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f7510baab521b5948629307f9f6f4dc19cd4a03" translate="yes" xml:space="preserve">
          <source>The default backend for GHC. It is a native code generator, compiling Cmm all the way to assembly code. It is the fastest backend and generally produces good performance code. It has the best support for compiling shared libraries. Select it with the &lt;code&gt;-fasm&lt;/code&gt; flag.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="372a76ca948e47b638039a6cfbc912e969dc50c4" translate="yes" xml:space="preserve">
          <source>The default buffering mode is different in GHCi to GHC.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="612f5aad425db1f69a9dbdbaaa3947648f24e8cc" translate="yes" xml:space="preserve">
          <source>The default buffering mode when a handle is opened is implementation-dependent and may depend on the file system object which is attached to that handle. For most implementations, physical files will normally be block-buffered and terminals will normally be line-buffered.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0961e4a3376f291925aa422749fabd42ce25f975" translate="yes" xml:space="preserve">
          <source>The default declaration must mention only type &lt;em&gt;variables&lt;/em&gt; on the left hand side, and the right hand side must mention only type variables that are explicitly bound on the left hand side. This restriction is relaxed for &lt;em&gt;kind&lt;/em&gt; variables, however, as the right hand side is allowed to mention kind variables that are implicitly bound on the left hand side.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e629035dab4042ca2e3774c6dd02fa07a19ca5ba" translate="yes" xml:space="preserve">
          <source>The default definition for &lt;code&gt;&lt;a href=&quot;data-data#v:gfoldl&quot;&gt;gfoldl&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;data-function#v:const&quot;&gt;const&lt;/a&gt; &lt;a href=&quot;data-function#v:id&quot;&gt;id&lt;/a&gt;&lt;/code&gt;, which is suitable for abstract datatypes with no substructures.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b37307a1a8b5c8a76936f7e75a2ac6d6c53b888a" translate="yes" xml:space="preserve">
          <source>The default definition instantiates the type constructor &lt;code&gt;c&lt;/code&gt; in the type of &lt;code&gt;&lt;a href=&quot;data-data#v:gfoldl&quot;&gt;gfoldl&lt;/a&gt;&lt;/code&gt; to an identity datatype constructor, using the isomorphism pair as injection and projection.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ebc5859a93e62be528328f3201553481af2edf0" translate="yes" xml:space="preserve">
          <source>The default definition instantiates the type constructor &lt;code&gt;c&lt;/code&gt; in the type of &lt;code&gt;&lt;a href=&quot;data-data#v:gfoldl&quot;&gt;gfoldl&lt;/a&gt;&lt;/code&gt; to the monad datatype constructor, defining injection and projection using &lt;code&gt;&lt;a href=&quot;control-monad#v:return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;control-monad#v:-62--62--61-&quot;&gt;&amp;gt;&amp;gt;=&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4bd4056577869d6ffa3c25c8d2085ea54f8f3b3d" translate="yes" xml:space="preserve">
          <source>The default definition is</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c68a975cf82f38a807abb27f8056b694f43e039" translate="yes" xml:space="preserve">
          <source>The default definition is &lt;code&gt;&lt;a href=&quot;data-function#v:const&quot;&gt;const&lt;/a&gt; &lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;, which is appropriate for instances of other forms.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa9945acbeccb98293938a8f8c707927dd353e5f" translate="yes" xml:space="preserve">
          <source>The default definition may be overridden with a more efficient version if desired.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71589b344fdce3f6d3065162df2b93817e514841" translate="yes" xml:space="preserve">
          <source>The default definition should be sufficient, but this can be overridden for efficiency.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b230bf83d4661530a10d60a3a4832bae81967728" translate="yes" xml:space="preserve">
          <source>The default definition uses &lt;code&gt;&lt;a href=&quot;data-functor-classes#v:liftReadList&quot;&gt;liftReadList&lt;/a&gt;&lt;/code&gt;. Instances that define &lt;code&gt;&lt;a href=&quot;data-functor-classes#v:liftReadPrec&quot;&gt;liftReadPrec&lt;/a&gt;&lt;/code&gt; should also define &lt;code&gt;&lt;a href=&quot;data-functor-classes#v:liftReadListPrec&quot;&gt;liftReadListPrec&lt;/a&gt;&lt;/code&gt; as &lt;code&gt;&lt;a href=&quot;data-functor-classes#v:liftReadListPrecDefault&quot;&gt;liftReadListPrecDefault&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b8f0470f58f998c4d12f0e8356a21d2ca7b5de3" translate="yes" xml:space="preserve">
          <source>The default definition uses &lt;code&gt;&lt;a href=&quot;data-functor-classes#v:liftReadList2&quot;&gt;liftReadList2&lt;/a&gt;&lt;/code&gt;. Instances that define &lt;code&gt;&lt;a href=&quot;data-functor-classes#v:liftReadPrec2&quot;&gt;liftReadPrec2&lt;/a&gt;&lt;/code&gt; should also define &lt;code&gt;&lt;a href=&quot;data-functor-classes#v:liftReadListPrec2&quot;&gt;liftReadListPrec2&lt;/a&gt;&lt;/code&gt; as &lt;code&gt;&lt;a href=&quot;data-functor-classes#v:liftReadListPrec2Default&quot;&gt;liftReadListPrec2Default&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c58343eea6290f399d2ab6ad1cadcd380e922e3" translate="yes" xml:space="preserve">
          <source>The default definitions of the &lt;code&gt;&lt;a href=&quot;ghc-real#v:ceiling&quot;&gt;ceiling&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;ghc-real#v:floor&quot;&gt;floor&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;ghc-real#v:truncate&quot;&gt;truncate&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ghc-real#v:round&quot;&gt;round&lt;/a&gt;&lt;/code&gt; functions are in terms of &lt;code&gt;&lt;a href=&quot;ghc-real#v:properFraction&quot;&gt;properFraction&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec66529839a9863362b72c24581910fe9d869109" translate="yes" xml:space="preserve">
          <source>The default definitions of the &lt;code&gt;&lt;a href=&quot;prelude#v:ceiling&quot;&gt;ceiling&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:floor&quot;&gt;floor&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:truncate&quot;&gt;truncate&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;prelude#v:round&quot;&gt;round&lt;/a&gt;&lt;/code&gt; functions are in terms of &lt;code&gt;&lt;a href=&quot;prelude#v:properFraction&quot;&gt;properFraction&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="491d8a12b5fa1e7b0bec380645e2c6e813fe0eda" translate="yes" xml:space="preserve">
          <source>The default method definitions in the &lt;code&gt;Exception&lt;/code&gt; class do what we need in this case. You can now throw and catch &lt;code&gt;ThisException&lt;/code&gt; and &lt;code&gt;ThatException&lt;/code&gt; as exceptions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06f71be64b1eace75a4676b9f81b6631fa302e4c" translate="yes" xml:space="preserve">
          <source>The default method for &lt;code&gt;put&lt;/code&gt; is then used, corresponding to the generic implementation of serialization. If you are using &lt;a href=&quot;#extension-DeriveAnyClass&quot;&gt;&lt;code&gt;DeriveAnyClass&lt;/code&gt;&lt;/a&gt;, the same instance is generated by simply attaching a &lt;code&gt;deriving Serialize&lt;/code&gt; clause to the &lt;code&gt;UserTree&lt;/code&gt; datatype declaration. For more examples of generic functions please refer to the &lt;a href=&quot;http://hackage.haskell.org/package/generic-deriving&quot;&gt;generic-deriving&lt;/a&gt; package on Hackage.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84a8076800f1a94cd466a3ca2cb82ca67bed6590" translate="yes" xml:space="preserve">
          <source>The default parallel GC settings are usually suitable for parallel programs (i.e. those using &lt;a href=&quot;../libraries/base-4.13.0.0/ghc-conc#v:par&quot;&gt;GHC.Conc.par&lt;/a&gt;, Strategies, or with multiple threads). However, it is sometimes beneficial to enable the parallel GC for a single-threaded sequential program too, especially if the program has a large amount of heap data and GC is a significant fraction of runtime. To use the parallel GC in a sequential program, enable the parallel runtime with a suitable &lt;code&gt;-N ⟨x⟩&lt;/code&gt; option, and additionally it might be beneficial to restrict parallel GC to the old generation with &lt;code&gt;-qg1&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c469f1e0fe0a399e3c8b4ab9c90096159140285" translate="yes" xml:space="preserve">
          <source>The default preferences which may be overwritten in the &lt;code&gt;.haskeline&lt;/code&gt; file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2646b613e6eb1c1c85aa64b66ff2f7d3602d210c" translate="yes" xml:space="preserve">
          <source>The default role for abstract datatype parameters is now representational. (An abstract datatype is one with no constructors listed.) To get another role, use a role annotation. (See &lt;a href=&quot;glasgow_exts#roles&quot;&gt;Roles&lt;/a&gt;.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60620248a38bdba79e7fcf67abe638e2752d6a16" translate="yes" xml:space="preserve">
          <source>The default seems to work well here. If you have plenty of memory, it is usually better to use &lt;code&gt;-H ⟨size⟩&lt;/code&gt; (see &lt;a href=&quot;#rts-flag--H%20%5B%E2%9F%A8size%E2%9F%A9%5D&quot;&gt;&lt;code&gt;-H [⟨size⟩]&lt;/code&gt;&lt;/a&gt;) than to increase &lt;a href=&quot;#rts-flag--F%20%E2%9F%A8factor%E2%9F%A9&quot;&gt;&lt;code&gt;-F ⟨factor⟩&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3395f0bc00fd88ab55e5b4f27b7ed6fe2e944e0a" translate="yes" xml:space="preserve">
          <source>The default style (&lt;code&gt;mode=PageMode, lineLength=100, ribbonsPerLine=1.5&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af2102e497ed3634f45c2fd75b234c6748ca55b8" translate="yes" xml:space="preserve">
          <source>The definition (of a function, variable, struct or typedef) is written to the C file, and its prototype or extern declaration to the C header. Inline functions are handled correctly. struct definitions and typedefs are written to the C program too. The &lt;code&gt;inline&lt;/code&gt;, &lt;code&gt;struct&lt;/code&gt; or &lt;code&gt;typedef&lt;/code&gt; keyword must come just after &lt;code&gt;def&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c8661345439bef92de6f21733c68492b49b19b5" translate="yes" xml:space="preserve">
          <source>The definition for &amp;ldquo;compatible&amp;rdquo; uses a notion of &amp;ldquo;apart&amp;rdquo;, whose definition in turn relies on type family reduction. This condition of &amp;ldquo;apartness&amp;rdquo;, as stated, is impossible to check, so we use this conservative approximation: two types are considered to be apart when the two types cannot be unified, even by a potentially infinite unifier. Allowing the unifier to be infinite disallows the following pair of instances:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70f33fa7b9f96d835ab103c50be5ec10b816d10e" translate="yes" xml:space="preserve">
          <source>The definition is syntactic:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df390321900febf5a604611d2971ac50e861f17b" translate="yes" xml:space="preserve">
          <source>The definition of &quot;math symbol&quot; may be a little counter-intuitive depending on one's background:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9142eae3b3df142878b925196063f3a19a7bf511" translate="yes" xml:space="preserve">
          <source>The definition of (say) &lt;code&gt;build&lt;/code&gt; in &lt;code&gt;GHC/Base.hs&lt;/code&gt; looks like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2ee65e9c75aa9258dca0f16a6b10f4fd9a759a9" translate="yes" xml:space="preserve">
          <source>The definition of &lt;code&gt;foo&lt;/code&gt; is rejected because one would have to instantiate &lt;code&gt;id&lt;/code&gt;&amp;lsquo;s type with &lt;code&gt;b := (forall s. ST s a) -&amp;gt; a&lt;/code&gt;, and that is not allowed. Instantiating polymorphic type variables with polymorphic types is called &lt;em&gt;impredicative polymorphism&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed024c34bd63c1441cb3695b992556af082202b2" translate="yes" xml:space="preserve">
          <source>The definition of &lt;code&gt;inst&lt;/code&gt; is unchanged from the Haskell Report (roughly, just a type). The &lt;code&gt;context =&amp;gt;&lt;/code&gt; part is optional. That is the only syntactic change to the language.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0bfdf9f8e4b0cf4d6ac3380a527908a80562e1fe" translate="yes" xml:space="preserve">
          <source>The definition of retainers is designed to reflect a common cause of space leaks: a large structure is retained by an unevaluated computation, and will be released once the computation is forced. A good example is looking up a value in a finite map, where unless the lookup is forced in a timely manner the unevaluated lookup will cause the whole mapping to be retained. These kind of space leaks can often be eliminated by forcing the relevant computations to be performed eagerly, using &lt;code&gt;seq&lt;/code&gt; or strictness annotations on data constructor fields.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9455c27066e060f9c4ed319a5e6f962fe125ba2" translate="yes" xml:space="preserve">
          <source>The dependency &lt;code&gt;ce -&amp;gt; e&lt;/code&gt; here specifies that the type &lt;code&gt;e&lt;/code&gt; of elements is uniquely determined by the type of the collection &lt;code&gt;ce&lt;/code&gt;. Note that both parameters of Collects are of kind &lt;code&gt;Type&lt;/code&gt;; there are no constructor classes here. Note too that all of the instances of &lt;code&gt;Collects&lt;/code&gt; that we gave earlier can be used together with this new definition.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ed435c3cbe535cb6b31533a151482c8d2a49765" translate="yes" xml:space="preserve">
          <source>The dependency generation phase of GHC can take some additional options, which you may find useful. The options which affect dependency generation are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b14601aa73f99ec94b5c907467d51ea631241fb4" translate="yes" xml:space="preserve">
          <source>The dependency is based on file content, not a modification time</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="adeb50d906769008b71fc1da461a1b88d5c5394a" translate="yes" xml:space="preserve">
          <source>The derivation mechanism can be used separtely from the data type declaration, using the &lt;a href=&quot;#stand-alone-deriving&quot;&gt;standalone deriving mechanism&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7b9b515a6b382dc8b30446310290e049039607a" translate="yes" xml:space="preserve">
          <source>The derived &lt;code&gt;&lt;a href=&quot;ghc-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; instance allows arbitrary Haskell whitespace between tokens of the input string. Extra parentheses are also allowed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0df45d847dca83db9351f4d864dd9921bcab85be" translate="yes" xml:space="preserve">
          <source>The derived &lt;code&gt;&lt;a href=&quot;prelude#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; instance allows arbitrary Haskell whitespace between tokens of the input string. Extra parentheses are also allowed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="827987dc4d21c55f29757d61b2ead342246251b4" translate="yes" xml:space="preserve">
          <source>The derived &lt;code&gt;&lt;a href=&quot;text-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; instance allows arbitrary Haskell whitespace between tokens of the input string. Extra parentheses are also allowed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="181a26c0ac10388c1c28e3a4a0bb2c744983c69d" translate="yes" xml:space="preserve">
          <source>The derived &lt;code&gt;HasRing&lt;/code&gt; instance would look like</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4744374c6426f29a0ece90c5038f8bb5efa3725d" translate="yes" xml:space="preserve">
          <source>The derived instance in GHC is equivalent to</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2aa9649e650abb1ccfd00ab90d331d7948d62cc4" translate="yes" xml:space="preserve">
          <source>The derived instance is obtained by completing the application of the class to the new type:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75901f130a621087c5df4e3c7ff2bcd908627e72" translate="yes" xml:space="preserve">
          <source>The design also relies on &lt;code&gt;Danger&lt;/code&gt; not being able to access the &lt;code&gt;UnsafeRIO&lt;/code&gt; constructor. Unfortunately Template Haskell can be used to subvert module boundaries and so could be used to gain access to this constructor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49cc72101ca9237972311dd03a0fd606151e4195" translate="yes" xml:space="preserve">
          <source>The design attempts to restrict the operations that &lt;code&gt;Danger&lt;/code&gt; can perform by using types, specifically the &lt;code&gt;RIO&lt;/code&gt; type wrapper around &lt;code&gt;IO&lt;/code&gt; . The author of &lt;code&gt;Danger&lt;/code&gt; can subvert this though by simply writing arbitrary &lt;code&gt;IO&lt;/code&gt; actions and using &lt;code&gt;unsafePerformIO :: IO a -&amp;gt; a&lt;/code&gt; to execute them as pure functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd2da32dc935177290030f66437b8442e648de85" translate="yes" xml:space="preserve">
          <source>The design follows the following principles</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8290c7ce1697900c8e40df8ad0fc8ee4040a8ead" translate="yes" xml:space="preserve">
          <source>The design of Safe Haskell covers the following aspects:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db9668c7f3a96172360c5f50287354a3f36ed64a" translate="yes" xml:space="preserve">
          <source>The design of the &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; monoid is optimized such that</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d69ade52bf3d6bc1c9e9d54294cef3da66243040" translate="yes" xml:space="preserve">
          <source>The design of this combinator was guided by the objective that &lt;code&gt;timeout n f&lt;/code&gt; should behave exactly the same as &lt;code&gt;f&lt;/code&gt; as long as &lt;code&gt;f&lt;/code&gt; doesn't time out. This means that &lt;code&gt;f&lt;/code&gt; has the same &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-concurrent#v:myThreadId&quot;&gt;myThreadId&lt;/a&gt;&lt;/code&gt; it would have without the timeout wrapper. Any exceptions &lt;code&gt;f&lt;/code&gt; might throw cancel the timeout and propagate further up. It also possible for &lt;code&gt;f&lt;/code&gt; to receive exceptions thrown to it by another thread.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ddf2c08a7e7a13b99ab3673124ddb5f1ed0a8e6e" translate="yes" xml:space="preserve">
          <source>The design of this combinator was guided by the objective that &lt;code&gt;timeout n f&lt;/code&gt; should behave exactly the same as &lt;code&gt;f&lt;/code&gt; as long as &lt;code&gt;f&lt;/code&gt; doesn't time out. This means that &lt;code&gt;f&lt;/code&gt; has the same &lt;code&gt;&lt;a href=&quot;control-concurrent#v:myThreadId&quot;&gt;myThreadId&lt;/a&gt;&lt;/code&gt; it would have without the timeout wrapper. Any exceptions &lt;code&gt;f&lt;/code&gt; might throw cancel the timeout and propagate further up. It also possible for &lt;code&gt;f&lt;/code&gt; to receive exceptions thrown to it by another thread.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="069d6b594d5ec9b69dd4d93d8ec6094f3feb0544" translate="yes" xml:space="preserve">
          <source>The details of how to create the process are passed in the &lt;code&gt;&lt;a href=&quot;system-process#t:CreateProcess&quot;&gt;CreateProcess&lt;/a&gt;&lt;/code&gt; record. To make it easier to construct a &lt;code&gt;&lt;a href=&quot;system-process#t:CreateProcess&quot;&gt;CreateProcess&lt;/a&gt;&lt;/code&gt;, the functions &lt;code&gt;&lt;a href=&quot;system-process#v:proc&quot;&gt;proc&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;system-process#v:shell&quot;&gt;shell&lt;/a&gt;&lt;/code&gt; are supplied that fill in the fields with default values which can be overriden as needed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed02330a1fbdda98a3ba7bccd58b777f6e21c2c1" translate="yes" xml:space="preserve">
          <source>The developer knows that a monad transformer takes a monad &lt;code&gt;m&lt;/code&gt; into a new monad &lt;code&gt;t m&lt;/code&gt;. But this property is not formally specified in the above declaration. This omission becomes an issue when defining monad transformer composition:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="baaf6bdd8fde5eba43c6847cbbb88e9af95ebd7b" translate="yes" xml:space="preserve">
          <source>The difference between this and &lt;a href=&quot;#ghc-flag--funfolding-creation-threshold=%E2%9F%A8n%E2%9F%A9&quot;&gt;&lt;code&gt;-funfolding-creation-threshold=⟨n⟩&lt;/code&gt;&lt;/a&gt; is that this one determines if a function definition will be inlined &lt;em&gt;at a call site&lt;/em&gt;. The other option determines if a function definition will be kept around at all for potential inlining.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ce598ae08dc7d0d31f3dc6c209cf1408d599371" translate="yes" xml:space="preserve">
          <source>The difference between using &lt;code&gt;&lt;a href=&quot;control-exception#v:try&quot;&gt;try&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;control-exception#v:catch&quot;&gt;catch&lt;/a&gt;&lt;/code&gt; for recovery is that in &lt;code&gt;&lt;a href=&quot;control-exception#v:catch&quot;&gt;catch&lt;/a&gt;&lt;/code&gt; the handler is inside an implicit &lt;code&gt;&lt;a href=&quot;control-exception#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; (see &quot;Asynchronous Exceptions&quot;) which is important when catching asynchronous exceptions, but when catching other kinds of exception it is unnecessary. Furthermore it is possible to accidentally stay inside the implicit &lt;code&gt;&lt;a href=&quot;control-exception#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; by tail-calling rather than returning from the handler, which is why we recommend using &lt;code&gt;&lt;a href=&quot;control-exception#v:try&quot;&gt;try&lt;/a&gt;&lt;/code&gt; rather than &lt;code&gt;&lt;a href=&quot;control-exception#v:catch&quot;&gt;catch&lt;/a&gt;&lt;/code&gt; for ordinary exception recovery.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7baf36ea1c4b3f790ba00b9fa8c653d9d8edc0dc" translate="yes" xml:space="preserve">
          <source>The difference involves the placement of the last type parameter, &lt;code&gt;a&lt;/code&gt;. In the &lt;code&gt;Right&lt;/code&gt; case, &lt;code&gt;a&lt;/code&gt; occurs within the type &lt;code&gt;Either Int a&lt;/code&gt;, and moreover, it appears as the last type argument of &lt;code&gt;Either&lt;/code&gt;. In the &lt;code&gt;Wrong&lt;/code&gt; case, however, &lt;code&gt;a&lt;/code&gt; is not the last type argument to &lt;code&gt;Either&lt;/code&gt;; rather, &lt;code&gt;Int&lt;/code&gt; is.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b237dd43561a7048051c81d4534c2c8653cc063" translate="yes" xml:space="preserve">
          <source>The directory returned is expected to be writable by the current user, but note that it isn't generally considered good practice to store application-specific data here; use &lt;code&gt;&lt;a href=&quot;system-directory#v:getXdgDirectory&quot;&gt;getXdgDirectory&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;system-directory#v:getAppUserDataDirectory&quot;&gt;getAppUserDataDirectory&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d678522b8fbe1bfba9bfaea6f20349fc6c790192" translate="yes" xml:space="preserve">
          <source>The do-notation of Haskell 98 does not allow &lt;em&gt;recursive bindings&lt;/em&gt;, that is, the variables bound in a do-expression are visible only in the textually following code block. Compare this to a let-expression, where bound variables are visible in the entire binding group.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed0761a6931cceb4a4d7abb1349cfebd091b9cae" translate="yes" xml:space="preserve">
          <source>The document type</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b44ad1035675a222470b757eea4beb20cf50c47b" translate="yes" xml:space="preserve">
          <source>The document.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1cdc66d16588511d035499d8789d0de0a61455f" translate="yes" xml:space="preserve">
          <source>The documentation here describes the realisation of Template Haskell in GHC. It is not detailed enough to understand Template Haskell; see the &lt;a href=&quot;http://haskell.org/haskellwiki/Template_Haskell&quot;&gt;Wiki page&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d161d8e5801d84e4bc6cb6d1ba3399418931f1f" translate="yes" xml:space="preserve">
          <source>The down-side is that, if the boilerplate code fails to typecheck, you will get an error message about that code, which you did not write. Whereas, with a &lt;code&gt;deriving&lt;/code&gt; clause the side-conditions are necessarily more conservative, but any error message may be more comprehensible.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d40a85296a889e2235c05d3e594413e6271c9b0" translate="yes" xml:space="preserve">
          <source>The downside of having lightweight threads is that only one can run at a time, so if one thread blocks in a foreign call, for example, the other threads cannot continue. The GHC runtime works around this by making use of full OS threads where necessary. When the program is built with the &lt;code&gt;-threaded&lt;/code&gt; option (to link against the multithreaded version of the runtime), a thread making a &lt;code&gt;safe&lt;/code&gt; foreign call will not block the other threads in the system; another OS thread will take over running Haskell threads until the original call returns. The runtime maintains a pool of these &lt;em&gt;worker&lt;/em&gt; threads so that multiple Haskell threads can be involved in external calls simultaneously.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e1ca2d2eeb59a37201caba0870b3b617ae2b6e7" translate="yes" xml:space="preserve">
          <source>The drag stage, which lasts from the final use until the last reference to the object is dropped.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5112337835e0aaa1f4501d77e936abde1e9f5833" translate="yes" xml:space="preserve">
          <source>The dual of a &lt;code&gt;&lt;a href=&quot;data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt;, obtained by swapping the arguments of &lt;code&gt;&lt;a href=&quot;data-monoid#v:mappend&quot;&gt;mappend&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7fab6e06621905edcea476fea0795c21d73fe816" translate="yes" xml:space="preserve">
          <source>The dynamic binding constraints are just a new form of predicate in the type class system.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9658faad340c4e37684884e4b4de1d55529e10f" translate="yes" xml:space="preserve">
          <source>The easiest way to see what &lt;code&gt;-O&lt;/code&gt; (etc.) &amp;ldquo;really mean&amp;rdquo; is to run with &lt;a href=&quot;using#ghc-flag--v&quot;&gt;&lt;code&gt;-v&lt;/code&gt;&lt;/a&gt;, then stand back in amazement.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d5eb6a79829c0b2ad6433410a38b38fee844c58" translate="yes" xml:space="preserve">
          <source>The empty &lt;code&gt;&lt;a href=&quot;ghc-stack#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ac8593ee22b444a0803d2615c08c3ad783eddab" translate="yes" xml:space="preserve">
          <source>The empty &lt;code&gt;&lt;a href=&quot;ghc-stack-types#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ffb10a0d9ca8c58bdee511053f10bf4fc11e9fd3" translate="yes" xml:space="preserve">
          <source>The empty document, with no height and no width. &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; is the identity for &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:-60--62-&quot;&gt;&amp;lt;&amp;gt;&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:-60--43--62-&quot;&gt;&amp;lt;+&amp;gt;&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:-36--36-&quot;&gt;$$&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:-36--43--36-&quot;&gt;$+$&lt;/a&gt;&lt;/code&gt;, and anywhere in the argument list for &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:sep&quot;&gt;sep&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:hcat&quot;&gt;hcat&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:hsep&quot;&gt;hsep&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:vcat&quot;&gt;vcat&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:fcat&quot;&gt;fcat&lt;/a&gt;&lt;/code&gt; etc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c38333a804d1c05d76e22c031e0de30532f2b0b2" translate="yes" xml:space="preserve">
          <source>The empty document, with no height and no width. &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; is the identity for &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:-60--62-&quot;&gt;&amp;lt;&amp;gt;&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:-60--43--62-&quot;&gt;&amp;lt;+&amp;gt;&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:-36--36-&quot;&gt;$$&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:-36--43--36-&quot;&gt;$+$&lt;/a&gt;&lt;/code&gt;, and anywhere in the argument list for &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:sep&quot;&gt;sep&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:hcat&quot;&gt;hcat&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:hsep&quot;&gt;hsep&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:vcat&quot;&gt;vcat&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:fcat&quot;&gt;fcat&lt;/a&gt;&lt;/code&gt; etc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57055327e0a4ff0414ff005dc9f2d958097b63a1" translate="yes" xml:space="preserve">
          <source>The empty document, with no height and no width. &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; is the identity for &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:-60--62-&quot;&gt;&amp;lt;&amp;gt;&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:-60--43--62-&quot;&gt;&amp;lt;+&amp;gt;&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:-36--36-&quot;&gt;$$&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:-36--43--36-&quot;&gt;$+$&lt;/a&gt;&lt;/code&gt;, and anywhere in the argument list for &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:sep&quot;&gt;sep&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:hcat&quot;&gt;hcat&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:hsep&quot;&gt;hsep&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:vcat&quot;&gt;vcat&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:fcat&quot;&gt;fcat&lt;/a&gt;&lt;/code&gt; etc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="322d102fb89074ac997d55fe8155256f83635242" translate="yes" xml:space="preserve">
          <source>The empty stream.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aaade1a4c344a06009213d97ea6d90338497c9b0" translate="yes" xml:space="preserve">
          <source>The entire string prior to the &lt;em&gt;k&lt;/em&gt;th match (i.e. the prefix)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e6880e4680eabaf9b865ccc3e11f4776c77ad73" translate="yes" xml:space="preserve">
          <source>The environment variable can also be set to the magical values &lt;code&gt;never&lt;/code&gt; or &lt;code&gt;always&lt;/code&gt;, which is equivalent to setting the corresponding &lt;code&gt;-fdiagnostics-color&lt;/code&gt; flag but with lower precedence.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a78af08f35ea577d78dded305fcc5c4e9509b316" translate="yes" xml:space="preserve">
          <source>The epoch of TAI, which is 1858-11-17 00:00:00 TAI.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81943c20c210a66a07a8f11e6429a84649f3e7b2" translate="yes" xml:space="preserve">
          <source>The equality test in an overloaded numeric pattern uses whatever &lt;code&gt;(==)&lt;/code&gt; is in scope.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="afd1105a178de8acf9d4f7264289cbff2eca2561" translate="yes" xml:space="preserve">
          <source>The equality types</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1199dfc965e5955380e63499fadc65f9cbd20ac3" translate="yes" xml:space="preserve">
          <source>The equivalent REPL example is:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d39f7dfb145cb81010fc146adcc072a6753c454" translate="yes" xml:space="preserve">
          <source>The error message contains some clues as to the transformation happening internally.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59e467fc1987c039f09f1829c27318997a022a9d" translate="yes" xml:space="preserve">
          <source>The error monad transformer. It can be used to add error handling to other monads.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="584676bca032e15cb39d4d01b07dc527b1765a4e" translate="yes" xml:space="preserve">
          <source>The errors that can be deferred are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53caa6a4eadedbc6b469bff64565461d1ccdfebf" translate="yes" xml:space="preserve">
          <source>The event manager state.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f9ab52fbe55b01321892b7fd29ab1a98bb7681d" translate="yes" xml:space="preserve">
          <source>The example below shows quasi-quotation in action. The quoter &lt;code&gt;expr&lt;/code&gt; is bound to a value of type &lt;code&gt;QuasiQuoter&lt;/code&gt; defined in module &lt;code&gt;Expr&lt;/code&gt;. The example makes use of an antiquoted variable &lt;code&gt;n&lt;/code&gt;, indicated by the syntax &lt;code&gt;'int:n&lt;/code&gt; (this syntax for anti-quotation was defined by the parser&amp;rsquo;s author, &lt;em&gt;not&lt;/em&gt; by GHC). This binds &lt;code&gt;n&lt;/code&gt; to the integer value argument of the constructor &lt;code&gt;IntExpr&lt;/code&gt; when pattern matching. Please see the referenced paper for further details regarding anti-quotation as well as the description of a technique that uses SYB to leverage a single parser of type &lt;code&gt;String -&amp;gt; a&lt;/code&gt; to generate both an expression parser that returns a value of type &lt;code&gt;Q Exp&lt;/code&gt; and a pattern parser that returns a value of type &lt;code&gt;Q Pat&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e130d4a858cd5958b963d63c7fe21940f766b4ef" translate="yes" xml:space="preserve">
          <source>The exception itself is bound to a new variable, &lt;code&gt;_exception&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="988d36edf500c18480e248b3ba03ea83da4d2cbf" translate="yes" xml:space="preserve">
          <source>The exception masking state of the executed action is inherited (c.f. &lt;code&gt;forkIO&lt;/code&gt;), see also &lt;code&gt;&lt;a href=&quot;system-posix-process#v:forkProcessWithUnmask&quot;&gt;forkProcessWithUnmask&lt;/a&gt;&lt;/code&gt; (&lt;em&gt;since: 2.7.0.0&lt;/em&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc8f732aa9ca323261d4591444f25b148d16268f" translate="yes" xml:space="preserve">
          <source>The exception masking state of the executed action is inherited (c.f. &lt;code&gt;forkIO&lt;/code&gt;), see also &lt;code&gt;&lt;a href=&quot;system-posix-process-bytestring#v:forkProcessWithUnmask&quot;&gt;forkProcessWithUnmask&lt;/a&gt;&lt;/code&gt; (&lt;em&gt;since: 2.7.0.0&lt;/em&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ebf03146e8f23e21eb8275358c982d6013264e4c" translate="yes" xml:space="preserve">
          <source>The exception thrown by &quot;fail&quot; in the GHCiQ monad</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ceefa01748ad0dcbb4f9adc6b0c343de52816f7c" translate="yes" xml:space="preserve">
          <source>The exception thrown when an infinite cycle is detected in &lt;code&gt;&lt;a href=&quot;system-io#v:fixIO&quot;&gt;fixIO&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e73e797f0aaf19c29e3a38b80b61adffd05c8530" translate="yes" xml:space="preserve">
          <source>The exception to this rule is that the context of a standalone deriving declaration can infer its context when a single, extra-wildcards constraint is used as the context, such as in:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a9b0765cdd57857b495fa1668f0cbcf42055c10" translate="yes" xml:space="preserve">
          <source>The execution continued at the point it previously stopped, and has now stopped at the breakpoint for a second time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11953fb00b8ad70bb93132200530ed5421e8c22b" translate="yes" xml:space="preserve">
          <source>The exit status of a process</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="927dcdbea9e7b5ba6ac39897b83ff1c61f46b2d3" translate="yes" xml:space="preserve">
          <source>The expansion is purely syntactic, so the expanded right-hand side expression refers to the nearest enclosing variable that is spelled the same as the field name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0bb43782d3d91d6c0cfe9ab486e0facf443af806" translate="yes" xml:space="preserve">
          <source>The expansion is purely syntactic, so the record wildcard expression refers to the nearest enclosing variables that are spelled the same as the omitted field names.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6fa2123bab4a96fc3dff4e1405c75b76df70f413" translate="yes" xml:space="preserve">
          <source>The expression &lt;code&gt;(x `par` y)&lt;/code&gt;&lt;em&gt;sparks&lt;/em&gt; the evaluation of &lt;code&gt;x&lt;/code&gt; (to weak head normal form) and returns &lt;code&gt;y&lt;/code&gt;. Sparks are queued for execution in FIFO order, but are not executed immediately. If the runtime detects that there is an idle CPU, then it may convert a spark into a real thread, and run the new thread on the idle CPU. In this way the available parallelism is spread amongst the real CPUs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60035052d2f9f9dbcb2234d0c35b5862aef3671d" translate="yes" xml:space="preserve">
          <source>The expression &lt;code&gt;encodeUtf8CSV table&lt;/code&gt; results in the following lazy &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ec7656c8e0e128b3c718fea844b6924e7c9db92" translate="yes" xml:space="preserve">
          <source>The expression &lt;code&gt;f &amp;lt;$$&amp;gt; p&lt;/code&gt; creates a fresh permutation parser consisting of parser &lt;code&gt;p&lt;/code&gt;. The the final result of the permutation parser is the function &lt;code&gt;f&lt;/code&gt; applied to the return value of &lt;code&gt;p&lt;/code&gt;. The parser &lt;code&gt;p&lt;/code&gt; is not allowed to accept empty input - use the optional combinator (&lt;code&gt;&lt;a href=&quot;text-parsec-perm#v:-60--36--63--62-&quot;&gt;&amp;lt;$?&amp;gt;&lt;/a&gt;&lt;/code&gt;) instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="688562a46f3c26c92c14ba3e2ae41abc13cf015e" translate="yes" xml:space="preserve">
          <source>The expression &lt;code&gt;f &amp;lt;$$&amp;gt; p&lt;/code&gt; creates a fresh permutation parser consisting of parser &lt;code&gt;p&lt;/code&gt;. The the final result of the permutation parser is the function &lt;code&gt;f&lt;/code&gt; applied to the return value of &lt;code&gt;p&lt;/code&gt;. The parser &lt;code&gt;p&lt;/code&gt; is not allowed to accept empty input - use the optional combinator (&lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-perm#v:-60--36--63--62-&quot;&gt;&amp;lt;$?&amp;gt;&lt;/a&gt;&lt;/code&gt;) instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="133ce73b1396f38f1c484e835e97b17e44814c41" translate="yes" xml:space="preserve">
          <source>The expression &lt;code&gt;f &amp;lt;$?&amp;gt; (x,p)&lt;/code&gt; creates a fresh permutation parser consisting of parser &lt;code&gt;p&lt;/code&gt;. The the final result of the permutation parser is the function &lt;code&gt;f&lt;/code&gt; applied to the return value of &lt;code&gt;p&lt;/code&gt;. The parser &lt;code&gt;p&lt;/code&gt; is optional - if it can not be applied, the default value &lt;code&gt;x&lt;/code&gt; will be used instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8fb79b3e4e6a014a406705b86fa9c5b9e188c8b4" translate="yes" xml:space="preserve">
          <source>The expression &lt;code&gt;makeTokenParser language&lt;/code&gt; creates a &lt;code&gt;&lt;a href=&quot;text-parsec-token#t:GenTokenParser&quot;&gt;GenTokenParser&lt;/a&gt;&lt;/code&gt; record that contains lexical parsers that are defined using the definitions in the &lt;code&gt;language&lt;/code&gt; record.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2c369052f3c05736ed3d0aa835e5b9167fa8ef9" translate="yes" xml:space="preserve">
          <source>The expression &lt;code&gt;makeTokenParser language&lt;/code&gt; creates a &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-token#t:GenTokenParser&quot;&gt;GenTokenParser&lt;/a&gt;&lt;/code&gt; record that contains lexical parsers that are defined using the definitions in the &lt;code&gt;language&lt;/code&gt; record.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b086207ac432a47ad80161d4b4db423c87b1bcf" translate="yes" xml:space="preserve">
          <source>The expression &lt;code&gt;parseTest p input&lt;/code&gt; applies a parser &lt;code&gt;p&lt;/code&gt; against input &lt;code&gt;input&lt;/code&gt; and prints the result to stdout. Used for testing parsers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d09630aef55bc10a1cc5f993e20aa9d2c8fa633" translate="yes" xml:space="preserve">
          <source>The expression &lt;code&gt;perm &amp;lt;||&amp;gt; (x,p)&lt;/code&gt; adds parser &lt;code&gt;p&lt;/code&gt; to the permutation parser &lt;code&gt;perm&lt;/code&gt;. The parser &lt;code&gt;p&lt;/code&gt; is optional - if it can not be applied, the default value &lt;code&gt;x&lt;/code&gt; will be used instead. Returns a new permutation parser that includes the optional parser &lt;code&gt;p&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9774c66620e8ebb6dc4947bd7a30ad32d4083961" translate="yes" xml:space="preserve">
          <source>The expression &lt;code&gt;perm &amp;lt;||&amp;gt; p&lt;/code&gt; adds parser &lt;code&gt;p&lt;/code&gt; to the permutation parser &lt;code&gt;perm&lt;/code&gt;. The parser &lt;code&gt;p&lt;/code&gt; is not allowed to accept empty input - use the optional combinator (&lt;code&gt;&lt;a href=&quot;text-parsec-perm#v:-60--124--63--62-&quot;&gt;&amp;lt;|?&amp;gt;&lt;/a&gt;&lt;/code&gt;) instead. Returns a new permutation parser that includes &lt;code&gt;p&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1eff7acfdc904aa55b95ecd8fd5d523b792b889" translate="yes" xml:space="preserve">
          <source>The expression &lt;code&gt;perm &amp;lt;||&amp;gt; p&lt;/code&gt; adds parser &lt;code&gt;p&lt;/code&gt; to the permutation parser &lt;code&gt;perm&lt;/code&gt;. The parser &lt;code&gt;p&lt;/code&gt; is not allowed to accept empty input - use the optional combinator (&lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-perm#v:-60--124--63--62-&quot;&gt;&amp;lt;|?&amp;gt;&lt;/a&gt;&lt;/code&gt;) instead. Returns a new permutation parser that includes &lt;code&gt;p&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b91ada54b3ba346f8466cd7a2f1f8bea7674bcd" translate="yes" xml:space="preserve">
          <source>The expression &lt;code&gt;s (t xs)&lt;/code&gt; does not match the rule &lt;code&gt;&quot;map/map&quot;&lt;/code&gt;, but GHC will substitute for &lt;code&gt;s&lt;/code&gt; and &lt;code&gt;t&lt;/code&gt;, giving an expression which does match. If &lt;code&gt;s&lt;/code&gt; or &lt;code&gt;t&lt;/code&gt; was (a) used more than once, and (b) large or a redex, then it would not be substituted, and the rule would not fire.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="efeb52340545b81120b442152fbbc21924dfa6d1" translate="yes" xml:space="preserve">
          <source>The expression &lt;code&gt;updatePosString pos s&lt;/code&gt; updates the source position &lt;code&gt;pos&lt;/code&gt; by calling &lt;code&gt;&lt;a href=&quot;text-parsec-pos#v:updatePosChar&quot;&gt;updatePosChar&lt;/a&gt;&lt;/code&gt; on every character in &lt;code&gt;s&lt;/code&gt;, ie. &lt;code&gt;foldl updatePosChar pos string&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a46b242264f8f265b934b320d1ad118b5d5d70f9" translate="yes" xml:space="preserve">
          <source>The expression &lt;code&gt;updatePosString pos s&lt;/code&gt; updates the source position &lt;code&gt;pos&lt;/code&gt; by calling &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-pos#v:updatePosChar&quot;&gt;updatePosChar&lt;/a&gt;&lt;/code&gt; on every character in &lt;code&gt;s&lt;/code&gt;, ie. &lt;code&gt;foldl updatePosChar pos string&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5483b1f876b299153ecdf0ce5e6d8239b22dcf61" translate="yes" xml:space="preserve">
          <source>The expression must be convertible to &lt;code&gt;long&lt;/code&gt; or &lt;code&gt;unsigned long&lt;/code&gt;. Its value (literal or negated literal) will be output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="820e3f9e6884aadccb720549e1d4a6de8381de85" translate="yes" xml:space="preserve">
          <source>The expression must be convertible to const char pointer. Its value (string literal) will be output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a5b6e32463e5a84d94f6198a0b148bf41758e64" translate="yes" xml:space="preserve">
          <source>The expression you are annotating with must have a type with &lt;code&gt;Typeable&lt;/code&gt; and &lt;code&gt;Data&lt;/code&gt; instances</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a2b1973077b8ad117174952fdf79b72f3549905" translate="yes" xml:space="preserve">
          <source>The extension &lt;a href=&quot;#extension-ExplicitNamespaces&quot;&gt;&lt;code&gt;ExplicitNamespaces&lt;/code&gt;&lt;/a&gt; is implied by &lt;a href=&quot;#extension-TypeOperators&quot;&gt;&lt;code&gt;TypeOperators&lt;/code&gt;&lt;/a&gt; and (for some reason) by &lt;a href=&quot;#extension-TypeFamilies&quot;&gt;&lt;code&gt;TypeFamilies&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56045ff1bf81ad580973e6c5e5797cb6699258d1" translate="yes" xml:space="preserve">
          <source>The extension &lt;a href=&quot;#extension-MonoLocalBinds&quot;&gt;&lt;code&gt;MonoLocalBinds&lt;/code&gt;&lt;/a&gt; is implied by &lt;a href=&quot;#extension-TypeFamilies&quot;&gt;&lt;code&gt;TypeFamilies&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#extension-GADTs&quot;&gt;&lt;code&gt;GADTs&lt;/code&gt;&lt;/a&gt;. You can switch it off again with &lt;code&gt;NoMonoLocalBinds&lt;/code&gt; but type inference becomes less predictable if you do so. (Read the papers!)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6edfbf43884f0659ca2c3eed2dacc284530ca4be" translate="yes" xml:space="preserve">
          <source>The extension &lt;a href=&quot;#extension-QuantifiedConstraints&quot;&gt;&lt;code&gt;QuantifiedConstraints&lt;/code&gt;&lt;/a&gt; introduces &lt;strong&gt;quantified constraints&lt;/strong&gt;, which give a new level of expressiveness in constraints. For example, consider</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a1fbd6833d7bf7f6b464ba5557bf0f418ef8516" translate="yes" xml:space="preserve">
          <source>The extension &lt;a href=&quot;#extension-RecursiveDo&quot;&gt;&lt;code&gt;RecursiveDo&lt;/code&gt;&lt;/a&gt; also introduces a new keyword &lt;code&gt;rec&lt;/code&gt;, which wraps a mutually-recursive group of monadic statements inside a &lt;code&gt;do&lt;/code&gt; expression, producing a single statement. Similar to a &lt;code&gt;let&lt;/code&gt; statement inside a &lt;code&gt;do&lt;/code&gt;, variables bound in the &lt;code&gt;rec&lt;/code&gt; are visible throughout the &lt;code&gt;rec&lt;/code&gt; group, and below it. For example, compare</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2340bd5004afb06c66885f9f37fdc1ab908eab6d" translate="yes" xml:space="preserve">
          <source>The extension &lt;a href=&quot;#extension-TypeInType&quot;&gt;&lt;code&gt;TypeInType&lt;/code&gt;&lt;/a&gt; is now deprecated: its sole effect is to switch on &lt;a href=&quot;#extension-PolyKinds&quot;&gt;&lt;code&gt;PolyKinds&lt;/code&gt;&lt;/a&gt; (and hence &lt;a href=&quot;#extension-KindSignatures&quot;&gt;&lt;code&gt;KindSignatures&lt;/code&gt;&lt;/a&gt;) and &lt;a href=&quot;#extension-DataKinds&quot;&gt;&lt;code&gt;DataKinds&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d7aee131ad6d19c93d8e0e5cef004d81b83103a" translate="yes" xml:space="preserve">
          <source>The extension adds a new kind of expression for defining arrows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68fc04e40e72e9a26d6e832da587e68cf89dce71" translate="yes" xml:space="preserve">
          <source>The extension does not extend to the left-hand side of function definitions; you must define such a function in prefix form.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad6ad2707106caf932a9bcc6bc55d2c587ffc598" translate="yes" xml:space="preserve">
          <source>The extension is enabled with the extension &lt;a href=&quot;#extension-TransformListComp&quot;&gt;&lt;code&gt;TransformListComp&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="592f0075b3be7dea40fca2f7b78b5f78b8bee1db" translate="yes" xml:space="preserve">
          <source>The extension only affects definitions in this module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dbed722a20b0c81708629361d2e36ddb255e740e" translate="yes" xml:space="preserve">
          <source>The fact that as many elements as possible are translated is used by the IO library in order to report translation errors at the point they actually occur, rather than when the buffer is translated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9688a61970d69ede4ef28783b4cdd7a6fa982ec" translate="yes" xml:space="preserve">
          <source>The field width is a minimum, not a maximum: it will be expanded as needed to avoid mutilating a value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="766dc6dc2e472365cee52e53c97df5ee0cb680d9" translate="yes" xml:space="preserve">
          <source>The fields in &lt;code&gt;Trade&lt;/code&gt; are marked as strict (using &lt;code&gt;!&lt;/code&gt;) since we don't need laziness here. In practise, you would probably consider using the UNPACK pragma as well. &lt;a href=&quot;https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#unpack-pragma&quot;&gt;https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#unpack-pragma&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5972e4dbbb1da0195c707d37fda525d476ee44e9" translate="yes" xml:space="preserve">
          <source>The fields of &lt;code&gt;ExampleConstructor&lt;/code&gt; have &lt;code&gt;&lt;a href=&quot;ghc-generics#v:NoSourceStrictness&quot;&gt;NoSourceStrictness&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;ghc-generics#v:SourceLazy&quot;&gt;SourceLazy&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;ghc-generics#v:SourceStrict&quot;&gt;SourceStrict&lt;/a&gt;&lt;/code&gt;, respectively.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90aff6649fd9e503bb0cd5dab7faab1470bbcfc9" translate="yes" xml:space="preserve">
          <source>The fields of &lt;code&gt;ExampleConstructor&lt;/code&gt; have &lt;code&gt;&lt;a href=&quot;ghc-generics#v:NoSourceUnpackedness&quot;&gt;NoSourceUnpackedness&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;ghc-generics#v:SourceNoUnpack&quot;&gt;SourceNoUnpack&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;ghc-generics#v:SourceUnpack&quot;&gt;SourceUnpack&lt;/a&gt;&lt;/code&gt;, respectively.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="867052d71989ead15b5268bf62e49c7c19eae92d" translate="yes" xml:space="preserve">
          <source>The file &lt;code&gt;A.hs-boot&lt;/code&gt; is a programmer-written source file. It must live in the same directory as its parent source file &lt;code&gt;A.hs&lt;/code&gt;. Currently, if you use a literate source file &lt;code&gt;A.lhs&lt;/code&gt; you must also use a literate boot file, &lt;code&gt;A.lhs-boot&lt;/code&gt;; and vice versa.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a674c835d28bfb6d72a5275286859913c1e00bf" translate="yes" xml:space="preserve">
          <source>The file contains package IDs and optionally package databases, one directive per line:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3dad592ba2c56d2ff45ef3e10379f2cd7056cb1" translate="yes" xml:space="preserve">
          <source>The file descriptor is ready to accept a write.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a87aafdf7c80c25cee8605761116960c822dc15" translate="yes" xml:space="preserve">
          <source>The file is created with permissions such that only the current user can read/write it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cfb39651c9d8c9724affb75edf0166a16b2ab2da" translate="yes" xml:space="preserve">
          <source>The file-header pragmas are: &lt;code&gt;{-# LANGUAGE #-}&lt;/code&gt;, &lt;code&gt;{-# OPTIONS_GHC #-}&lt;/code&gt;, and &lt;code&gt;{-# INCLUDE #-}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ce398b5e4e0b12caa271926c6711a527e411174" translate="yes" xml:space="preserve">
          <source>The final build step that returns the &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#v:done&quot;&gt;done&lt;/a&gt;&lt;/code&gt; signal.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87005632e427f20e49e6f8bedc0a39a36ece9f40" translate="yes" xml:space="preserve">
          <source>The final bullet (about unifiying instances) makes GHC conservative about committing to an overlapping instance. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1913f6cc3ff526a515670ed4f1b49aa9b4f8a2bf" translate="yes" xml:space="preserve">
          <source>The final form is just what we want: a simple case expression.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7d925c1be71fce63599be5c5644561348c21d6e" translate="yes" xml:space="preserve">
          <source>The final layout will be something like</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="509bc33604e7ee8a244ab55cc215005d17244214" translate="yes" xml:space="preserve">
          <source>The finalizer is given the local type environment at the splice point. Thus &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:reify&quot;&gt;reify&lt;/a&gt;&lt;/code&gt; is able to find the local definitions when executed inside the finalizer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="147a1899cc99c9241165663b9d1797441102fedd" translate="yes" xml:space="preserve">
          <source>The finalizer, and the relationship between the key and the value, exist regardless of whether the program keeps a reference to the &lt;code&gt;&lt;a href=&quot;ghc-weak#t:Weak&quot;&gt;Weak&lt;/a&gt;&lt;/code&gt; object or not.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9f13e14cac52cb8d1ac6c69d4a111452644d3b2" translate="yes" xml:space="preserve">
          <source>The finalizer, and the relationship between the key and the value, exist regardless of whether the program keeps a reference to the &lt;code&gt;&lt;a href=&quot;system-mem-weak#t:Weak&quot;&gt;Weak&lt;/a&gt;&lt;/code&gt; object or not.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="deaaee000865e026093bdaeb2c9fc2020dfc3055" translate="yes" xml:space="preserve">
          <source>The fine distinction between different kinds of parse errors allows the system to generate quite good error messages for the user. It also allows error messages that are formatted in different languages. Each kind of message is generated by different combinators:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c672354048c81f22453abece53dcb4410b87ec06" translate="yes" xml:space="preserve">
          <source>The first &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; argument is the contents of the line to the left of the cursor, reversed. The second &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; argument is the contents of the line to the right of the cursor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e20d358fcdcc868c8bd11a6755028db0bb2e37f3" translate="yes" xml:space="preserve">
          <source>The first &lt;code&gt;Int32&lt;/code&gt; is for the tag. There are two &lt;code&gt;Float32&lt;/code&gt; fields because floating point types can&amp;rsquo;t overlap with other types, because of limitations of the code generator that we&amp;rsquo;re hoping to overcome in the future. The second alternative needs two &lt;code&gt;Float32&lt;/code&gt; fields: The &lt;code&gt;Word32&lt;/code&gt; field is for the &lt;code&gt;Word32#&lt;/code&gt; in the first alternative. The &lt;code&gt;Pointer&lt;/code&gt; field is shared between &lt;code&gt;String&lt;/code&gt; and &lt;code&gt;Maybe Int&lt;/code&gt; values of the alternatives.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="349930f2f6ac001a1f1d9bc41ac40db08cbf14ec" translate="yes" xml:space="preserve">
          <source>The first argument &lt;code&gt;(l,u)&lt;/code&gt; of each of these operations is a pair specifying the lower and upper bounds of a contiguous subrange of values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da354ca0b85aa26c68bc2b60c29e2527cd434859" translate="yes" xml:space="preserve">
          <source>The first bullet simply means that the dependency must be well-scoped. The second bullet concerns GHC&amp;rsquo;s ability to infer dependency. Inferring this dependency is difficult, and GHC currently requires the dependency to be made explicit, meaning that &lt;code&gt;k&lt;/code&gt; must appear in the kind of a type variable, making it obvious to GHC that dependency is intended. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5990c2111448ff95032208b84313c09eb4e8e7c7" translate="yes" xml:space="preserve">
          <source>The first clause of &amp;ldquo;compatible&amp;rdquo; is the more straightforward one. It says that the patterns of two distinct type family instances cannot overlap. For example, the following is disallowed:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d05ff555d4b0984db447de192b3bf9a34809e33" translate="yes" xml:space="preserve">
          <source>The first component of &lt;code&gt;&lt;a href=&quot;ghc-float#v:decodeFloat&quot;&gt;decodeFloat&lt;/a&gt;&lt;/code&gt;, scaled to lie in the open interval (&lt;code&gt;-1&lt;/code&gt;,&lt;code&gt;1&lt;/code&gt;), either &lt;code&gt;0.0&lt;/code&gt; or of absolute value &lt;code&gt;&amp;gt;= 1/b&lt;/code&gt;, where &lt;code&gt;b&lt;/code&gt; is the floating-point radix. The behaviour is unspecified on infinite or &lt;code&gt;NaN&lt;/code&gt; values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4f7b2948c8c1ae005bcea73d45f0bbfbc9162d6" translate="yes" xml:space="preserve">
          <source>The first component of &lt;code&gt;&lt;a href=&quot;prelude#v:decodeFloat&quot;&gt;decodeFloat&lt;/a&gt;&lt;/code&gt;, scaled to lie in the open interval (&lt;code&gt;-1&lt;/code&gt;,&lt;code&gt;1&lt;/code&gt;), either &lt;code&gt;0.0&lt;/code&gt; or of absolute value &lt;code&gt;&amp;gt;= 1/b&lt;/code&gt;, where &lt;code&gt;b&lt;/code&gt; is the floating-point radix. The behaviour is unspecified on infinite or &lt;code&gt;NaN&lt;/code&gt; values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a78b840c5ec7a8bd0522ac73f6d9db7e7f7c6e2" translate="yes" xml:space="preserve">
          <source>The first constructor consists of a single field, which is the parameter &lt;code&gt;a&lt;/code&gt;. This is represented as &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Rec0&quot;&gt;Rec0&lt;/a&gt; a&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a491a7e0c75f57c1c82c6779842a217b78376985" translate="yes" xml:space="preserve">
          <source>The first element of the returned tuple is the prefix of &lt;code&gt;haystack&lt;/code&gt; up to and including the last match of &lt;code&gt;needle&lt;/code&gt;. The second is the remainder of &lt;code&gt;haystack&lt;/code&gt;, following the match.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d48cef11152d7e2e71a8b3fb779c57c59642ed57" translate="yes" xml:space="preserve">
          <source>The first example from that paper is set out below (&lt;a href=&quot;#th-example&quot;&gt;A Template Haskell Worked Example&lt;/a&gt;) as a worked example to help get you started.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f5e8571c06e192e03c26745db1bf9e5167e5bff" translate="yes" xml:space="preserve">
          <source>The first example is a parser monad in the style of</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0db21633e5e7584a4e85ed5e4b67955d4a3ea721" translate="yes" xml:space="preserve">
          <source>The first example will cause the exception &lt;code&gt;e&lt;/code&gt; to be raised, whereas the second one won't. In fact, &lt;code&gt;&lt;a href=&quot;control-exception#v:throwIO&quot;&gt;throwIO&lt;/a&gt;&lt;/code&gt; will only cause an exception to be raised when it is used within the &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad. The &lt;code&gt;&lt;a href=&quot;control-exception#v:throwIO&quot;&gt;throwIO&lt;/a&gt;&lt;/code&gt; variant should be used in preference to &lt;code&gt;&lt;a href=&quot;control-exception#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; to raise an exception within the &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad because it guarantees ordering with respect to other &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; operations, whereas &lt;code&gt;&lt;a href=&quot;control-exception#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; does not.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a9264a11b232afb865bd5a70544aaa9c229ee38" translate="yes" xml:space="preserve">
          <source>The first example will cause the exception &lt;code&gt;e&lt;/code&gt; to be raised, whereas the second one won't. In fact, &lt;code&gt;&lt;a href=&quot;control-monad-stm#v:throwSTM&quot;&gt;throwSTM&lt;/a&gt;&lt;/code&gt; will only cause an exception to be raised when it is used within the &lt;code&gt;&lt;a href=&quot;control-monad-stm#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; monad. The &lt;code&gt;&lt;a href=&quot;control-monad-stm#v:throwSTM&quot;&gt;throwSTM&lt;/a&gt;&lt;/code&gt; variant should be used in preference to &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; to raise an exception within the &lt;code&gt;&lt;a href=&quot;control-monad-stm#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; monad because it guarantees ordering with respect to other &lt;code&gt;&lt;a href=&quot;control-monad-stm#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; operations, whereas &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; does not.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00088afbc5cbb44faba064e52d1c85ccc7ca138f" translate="yes" xml:space="preserve">
          <source>The first example will cause the exception &lt;code&gt;e&lt;/code&gt; to be raised, whereas the second one won't. In fact, &lt;code&gt;&lt;a href=&quot;ghc-conc#v:throwSTM&quot;&gt;throwSTM&lt;/a&gt;&lt;/code&gt; will only cause an exception to be raised when it is used within the &lt;code&gt;&lt;a href=&quot;ghc-conc#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; monad. The &lt;code&gt;&lt;a href=&quot;ghc-conc#v:throwSTM&quot;&gt;throwSTM&lt;/a&gt;&lt;/code&gt; variant should be used in preference to &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; to raise an exception within the &lt;code&gt;&lt;a href=&quot;ghc-conc#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; monad because it guarantees ordering with respect to other &lt;code&gt;&lt;a href=&quot;ghc-conc#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; operations, whereas &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; does not.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d99c86cee59c7b0e9addd7c9710d9c1d2d607961" translate="yes" xml:space="preserve">
          <source>The first example will cause the exception &lt;code&gt;e&lt;/code&gt; to be raised, whereas the second one won't. In fact, &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:throwSTM&quot;&gt;throwSTM&lt;/a&gt;&lt;/code&gt; will only cause an exception to be raised when it is used within the &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; monad. The &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:throwSTM&quot;&gt;throwSTM&lt;/a&gt;&lt;/code&gt; variant should be used in preference to &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; to raise an exception within the &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; monad because it guarantees ordering with respect to other &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; operations, whereas &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; does not.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b34efd21f2daa7d49fe1224a63934d829e838b06" translate="yes" xml:space="preserve">
          <source>The first example will cause the exception &lt;code&gt;e&lt;/code&gt; to be raised, whereas the second one won't. In fact, &lt;code&gt;&lt;a href=&quot;ghc-io#v:throwIO&quot;&gt;throwIO&lt;/a&gt;&lt;/code&gt; will only cause an exception to be raised when it is used within the &lt;code&gt;&lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad. The &lt;code&gt;&lt;a href=&quot;ghc-io#v:throwIO&quot;&gt;throwIO&lt;/a&gt;&lt;/code&gt; variant should be used in preference to &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; to raise an exception within the &lt;code&gt;&lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad because it guarantees ordering with respect to other &lt;code&gt;&lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; operations, whereas &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; does not.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c46e0719305fcb7afbedd529b28ef7ed1317a3e9" translate="yes" xml:space="preserve">
          <source>The first example will cause the exception &lt;code&gt;e&lt;/code&gt; to be raised, whereas the second one won't. In fact, &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:throwIO&quot;&gt;throwIO&lt;/a&gt;&lt;/code&gt; will only cause an exception to be raised when it is used within the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad. The &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:throwIO&quot;&gt;throwIO&lt;/a&gt;&lt;/code&gt; variant should be used in preference to &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; to raise an exception within the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad because it guarantees ordering with respect to other &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; operations, whereas &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; does not.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8377e7f947ca82c2d03b9e96804a9cc74da945a8" translate="yes" xml:space="preserve">
          <source>The first form declares that &lt;code&gt;f&lt;/code&gt; is a (pure) C function that takes no arguments and returns a pointer to a C function with type &lt;code&gt;t&lt;/code&gt;, whereas the second form declares that &lt;code&gt;f&lt;/code&gt; itself is a C function with type &lt;code&gt;t&lt;/code&gt;. The first declaration is usually a mistake, and one that is hard to debug because it results in a crash, hence this warning.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b437c04b578dcbe34c5b61a20dafa47889b4aaf9" translate="yes" xml:space="preserve">
          <source>The first four lines (&lt;code&gt;JOB&lt;/code&gt;, &lt;code&gt;DATE&lt;/code&gt;, &lt;code&gt;SAMPLE_UNIT&lt;/code&gt;, &lt;code&gt;VALUE_UNIT&lt;/code&gt;) form a header. Each block of lines starting with &lt;code&gt;BEGIN_SAMPLE&lt;/code&gt; and ending with &lt;code&gt;END_SAMPLE&lt;/code&gt; forms a single sample (you can think of this as a vertical slice of your heap profile). The hp2ps utility should accept any input with a properly-formatted header followed by a series of &lt;em&gt;complete&lt;/em&gt; samples.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2b82a03029ef67f0b50718409c503eea389a692" translate="yes" xml:space="preserve">
          <source>The first letter of the input is converted to title case, as is every subsequent letter that immediately follows a non-letter. Every letter that immediately follows another letter is converted to lower case.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63efb85344c0aa9c20ebac363da48aba559537ad" translate="yes" xml:space="preserve">
          <source>The first matching axiom we encounter while entailing &lt;code&gt;C a&lt;/code&gt;, is &lt;code&gt;B a =&amp;gt; C a&lt;/code&gt;. We have a local axiom &lt;code&gt;B a&lt;/code&gt; available, so now the program is suddenly accepted. This behaviour, where the ordering of an instance context determines whether or not the program is accepted, seems rather confusing for the developer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0123b61d2574afe7df7113981a9973c5d86d2592" translate="yes" xml:space="preserve">
          <source>The first most common step is the concatenation of two &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;s. Internally, concatenation corresponds to function composition. (Note that &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;s can be seen as difference-lists of buffer-filling functions; cf. &lt;a href=&quot;http://hackage.haskell.org/cgi-bin/hackage-scripts/package/dlist&quot;&gt;http://hackage.haskell.org/cgi-bin/hackage-scripts/package/dlist&lt;/a&gt;. ) Function composition is a fast O(1) operation. However, we can use bounded primitives to remove some of these function compositions altogether, which is more efficient.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b6aa4f035d3b73aa4ab4041c788e09ed98100cf" translate="yes" xml:space="preserve">
          <source>The first of the &lt;code&gt;&lt;a href=&quot;control-monad-trans-reader#v:ReaderT&quot;&gt;ReaderT&lt;/a&gt;&lt;/code&gt; operations, &lt;code&gt;&lt;a href=&quot;control-monad-trans-reader#v:ask&quot;&gt;ask&lt;/a&gt;&lt;/code&gt;, is a simple action, so we can lift it through &lt;code&gt;&lt;a href=&quot;control-monad-trans-state-lazy#v:StateT&quot;&gt;StateT&lt;/a&gt;&lt;/code&gt; to &lt;code&gt;InterpM&lt;/code&gt; using &lt;code&gt;&lt;a href=&quot;control-monad-trans-class#v:lift&quot;&gt;lift&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2faac1fc5843e8344edfa39159393215c540048a" translate="yes" xml:space="preserve">
          <source>The first of these is obviously fine. The second is still fine, although less obviously. The third is not Haskell 98, and risks losing termination of instances.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a23c2d18f54a6700ee1bddf4a4ced9e452ae0f90" translate="yes" xml:space="preserve">
          <source>The first option is to compile the program twice:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7637c081a47d73b9bc11cd583b13a110b93646f" translate="yes" xml:space="preserve">
          <source>The first part of the file gives the program name and options, and the total time and total memory allocation measured during the run of the program (note that the total memory allocation figure isn&amp;rsquo;t the same as the amount of &lt;em&gt;live&lt;/em&gt; memory needed by the program at any one time; the latter can be determined using heap profiling, which we will describe later in &lt;a href=&quot;#prof-heap&quot;&gt;Profiling memory usage&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fef3e13957b592e13b7450a30e6df7cd6f143a71" translate="yes" xml:space="preserve">
          <source>The first phase to run is determined by each input-file suffix, and the last phase is determined by a flag. If no relevant flag is present, then go all the way through to linking. This table summarises:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="145ee321d09d8f6c8d70bccf9d36b9f9aa7af807" translate="yes" xml:space="preserve">
          <source>The first thing we need is generic representations. The &lt;code&gt;GHC.Generics&lt;/code&gt; module defines a couple of primitive types that are used to represent Haskell datatypes:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a1ecb3ae40da3aae2e8c25cd4cee41373d627e8" translate="yes" xml:space="preserve">
          <source>The fixed point of a monadic computation. &lt;code&gt;&lt;a href=&quot;control-monad-fix#v:mfix&quot;&gt;mfix&lt;/a&gt; f&lt;/code&gt; executes the action &lt;code&gt;f&lt;/code&gt; only once, with the eventual output fed back as the input. Hence &lt;code&gt;f&lt;/code&gt; should not be strict, for then &lt;code&gt;&lt;a href=&quot;control-monad-fix#v:mfix&quot;&gt;mfix&lt;/a&gt; f&lt;/code&gt; would diverge.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b861bc9465ad5c567e33d3c5ea5e7f4fe10fe04" translate="yes" xml:space="preserve">
          <source>The fixity of a type operator may be set using the usual fixity declarations but, as in &lt;a href=&quot;#infix-tycons&quot;&gt;Infix type constructors, classes, and type variables&lt;/a&gt;, the function and type constructor share a single fixity.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="397ad5d952fd5d1bd350537f1bb34e2a9d3464c7" translate="yes" xml:space="preserve">
          <source>The fixity of the constructor</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0127191c720e27284ab5a66b202e3464fd573afd" translate="yes" xml:space="preserve">
          <source>The flag &lt;a href=&quot;#extension-FlexibleContexts&quot;&gt;&lt;code&gt;FlexibleContexts&lt;/code&gt;&lt;/a&gt; also lifts the corresponding restriction on class declarations (&lt;a href=&quot;#superclass-rules&quot;&gt;The superclasses of a class declaration&lt;/a&gt;) and instance declarations (&lt;a href=&quot;#instance-rules&quot;&gt;Relaxed rules for instance contexts&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="680d808c4989476cdf108f73531ac73891762a24" translate="yes" xml:space="preserve">
          <source>The flag &lt;a href=&quot;#ghc-flag--Wincomplete-uni-patterns&quot;&gt;&lt;code&gt;-Wincomplete-uni-patterns&lt;/code&gt;&lt;/a&gt; is similar to &lt;a href=&quot;#ghc-flag--Wincomplete-patterns&quot;&gt;&lt;code&gt;-Wincomplete-patterns&lt;/code&gt;&lt;/a&gt;, except that it applies only to lambda-expressions and pattern bindings, constructs that only allow a single pattern:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b79e0ee85c7165a369baa04cb9639b641623921" translate="yes" xml:space="preserve">
          <source>The flag &lt;a href=&quot;#ghc-flag--Worphans&quot;&gt;&lt;code&gt;-Worphans&lt;/code&gt;&lt;/a&gt; warns about user-written orphan rules or instances.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47cb0b5fb9b4f5cbc05ae1ed28f5f328bb28aed6" translate="yes" xml:space="preserve">
          <source>The flag &lt;a href=&quot;debugging#ghc-flag--ddump-splices&quot;&gt;&lt;code&gt;-ddump-splices&lt;/code&gt;&lt;/a&gt; shows the expansion of all top-level declaration splices, both typed and untyped, as they happen. As with all dump flags, the default is for this output to be sent to stdout. For a non-trivial program, you may be interested in combining this with the &lt;a href=&quot;debugging#ghc-flag--ddump-to-file&quot;&gt;&lt;code&gt;-ddump-to-file&lt;/code&gt;&lt;/a&gt; flag (see &lt;a href=&quot;debugging#dumping-output&quot;&gt;Dumping out compiler intermediate structures&lt;/a&gt;. For each file using Template Haskell, this will show the output in a &lt;code&gt;.dump-splices&lt;/code&gt; file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4495b2a19abefc172f62863056de3aa383544711" translate="yes" xml:space="preserve">
          <source>The flag &lt;a href=&quot;debugging#ghc-flag--dth-dec-file&quot;&gt;&lt;code&gt;-dth-dec-file&lt;/code&gt;&lt;/a&gt; dumps the expansions of all top-level TH declaration splices, both typed and untyped, in the file &lt;code&gt;M.th.hs&lt;/code&gt; for each module &lt;code&gt;M&lt;/code&gt; being compiled. Note that other types of splices (expressions, types, and patterns) are not shown. Application developers can check this into their repository so that they can grep for identifiers that were defined in Template Haskell. This is similar to using &lt;a href=&quot;debugging#ghc-flag--ddump-to-file&quot;&gt;&lt;code&gt;-ddump-to-file&lt;/code&gt;&lt;/a&gt; with &lt;a href=&quot;debugging#ghc-flag--ddump-splices&quot;&gt;&lt;code&gt;-ddump-splices&lt;/code&gt;&lt;/a&gt; but it always generates a file instead of being coupled to &lt;a href=&quot;debugging#ghc-flag--ddump-to-file&quot;&gt;&lt;code&gt;-ddump-to-file&lt;/code&gt;&lt;/a&gt;. The format is also different: it does not show code from the original file, instead it only shows generated code and has a comment for the splice location of the original file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b93b2c7d1b9eda88e393a8f5e74873331f11d482" translate="yes" xml:space="preserve">
          <source>The flag &lt;a href=&quot;using-warnings#ghc-flag--fdefer-type-errors&quot;&gt;&lt;code&gt;-fdefer-type-errors&lt;/code&gt;&lt;/a&gt; controls whether type errors are deferred to runtime. Type errors will still be emitted as warnings, but will not prevent compilation. You can use &lt;code&gt;-Wno-type-errors&lt;/code&gt; to suppress these warnings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b3baa03b1de2ae2d10fcb9504c97b6f24d46a7f" translate="yes" xml:space="preserve">
          <source>The flag &lt;a href=&quot;using-warnings#ghc-flag--fdefer-type-errors&quot;&gt;&lt;code&gt;-fdefer-type-errors&lt;/code&gt;&lt;/a&gt; works in GHCi as well, with one exception: for &amp;ldquo;naked&amp;rdquo; expressions typed at the prompt, type errors don&amp;rsquo;t get delayed, so for example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7bc71daa56ee822998e1d64f92a7832d0f7badec" translate="yes" xml:space="preserve">
          <source>The flag &lt;code&gt;-fglasgow-exts&lt;/code&gt; is equivalent to enabling the following extensions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bfe7b59eddf66920c11dffff433c9395a1cc1d4e" translate="yes" xml:space="preserve">
          <source>The flag &lt;code&gt;-fprint-evld-with-show&lt;/code&gt; instructs &lt;a href=&quot;#ghci-cmd-:print&quot;&gt;&lt;code&gt;:print&lt;/code&gt;&lt;/a&gt; to reuse available &lt;code&gt;Show&lt;/code&gt; instances when possible. This happens only when the contents of the variable being inspected are completely evaluated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d43a045f4632b27bf091372de67333d21d36a1ae" translate="yes" xml:space="preserve">
          <source>The flag reference tables (&lt;a href=&quot;flags#flag-reference&quot;&gt;Flag reference&lt;/a&gt;) lists the status of each flag.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="960b0cead1ab39ce475efd50a401951d0d90317c" translate="yes" xml:space="preserve">
          <source>The flags &lt;a href=&quot;#ghc-flag--dynamic&quot;&gt;&lt;code&gt;-dynamic&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#ghc-flag--static&quot;&gt;&lt;code&gt;-static&lt;/code&gt;&lt;/a&gt; control whether the resulting shared object links statically or dynamically to Haskell package libraries given as &lt;code&gt;-package ⟨pkg⟩&lt;/code&gt; option. Non-Haskell libraries are linked as gcc would regularly link it on your system, e.g. on most ELF system the linker uses the dynamic libraries when found.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7668d5e6fe85390adb7a3ecf19db212413e1eebc" translate="yes" xml:space="preserve">
          <source>The flags &lt;a href=&quot;#ghc-flag--rtsopts%5B=%E2%9F%A8none%7Csome%7Call%7Cignore%7CignoreAll%E2%9F%A9%5D&quot;&gt;&lt;code&gt;-rtsopts[=⟨none|some|all|ignore|ignoreAll⟩]&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#ghc-flag--with-rtsopts=%E2%9F%A8opts%E2%9F%A9&quot;&gt;&lt;code&gt;-with-rtsopts=⟨opts⟩&lt;/code&gt;&lt;/a&gt; have no effect when used with &lt;a href=&quot;#ghc-flag--no-hs-main&quot;&gt;&lt;code&gt;-no-hs-main&lt;/code&gt;&lt;/a&gt;, because they are implemented by changing the definition of &lt;code&gt;main&lt;/code&gt; that GHC generates. See &lt;a href=&quot;ffi-chap#using-own-main&quot;&gt;Using your own main()&lt;/a&gt; for how to get the effect of &lt;a href=&quot;#ghc-flag--rtsopts%5B=%E2%9F%A8none%7Csome%7Call%7Cignore%7CignoreAll%E2%9F%A9%5D&quot;&gt;&lt;code&gt;-rtsopts[=⟨none|some|all|ignore|ignoreAll⟩]&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#ghc-flag--with-rtsopts=%E2%9F%A8opts%E2%9F%A9&quot;&gt;&lt;code&gt;-with-rtsopts=⟨opts⟩&lt;/code&gt;&lt;/a&gt; when using your own &lt;code&gt;main&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe514827a2bc8cfeb3427c13cc2ba47f6aba7300" translate="yes" xml:space="preserve">
          <source>The flags are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bcad0a34c93b0b86bbc687fc84b1ffd20b52d6a1" translate="yes" xml:space="preserve">
          <source>The floating-point environment is not saved over a normal thread context-switch. So if you modify the floating-point state in one thread, those changes may be visible in other threads. Furthermore, testing the exception state is not reliable, because a context switch may change it. If you need to modify or test the floating point state and use threads, then you must use bound threads (&lt;code&gt;Control.Concurrent.forkOS&lt;/code&gt;), because a bound thread has its own OS thread, and OS threads do save and restore the floating-point state.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d84e5b1b19c72a9f2f8e38f56f6835541ed5d999" translate="yes" xml:space="preserve">
          <source>The following RTS option(s) affect the behaviour of Concurrent Haskell programs:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52952117f68d88486d7181f97f7977ad0131a484" translate="yes" xml:space="preserve">
          <source>The following are QuickCheck specifications of what the combinators do. These can be seen as formal specifications of the behavior of the combinators.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="880afa09746074737763ff34c90d8a824dfb1e1a" translate="yes" xml:space="preserve">
          <source>The following are definitions for &quot;merge&quot; for each of the heaps above. Each takes a comparison function which is used to order the elements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9031e690866836bd079eb18cd7f2cf6f4a7c0278" translate="yes" xml:space="preserve">
          <source>The following are definitions for &lt;code&gt;popMin&lt;/code&gt;, a function which constructs a stateful action which pops the smallest element from the queue, where &quot;smallest&quot; is according to the supplied comparison function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="853c1b2416dd00409c8f94cbaaab4d500ad921b0" translate="yes" xml:space="preserve">
          <source>The following are definitions for functions to build queues, given a comparison function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00e5f1459a91351f85b76ba47f587250af056d92" translate="yes" xml:space="preserve">
          <source>The following are definitions for various specialized pairing heaps.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bcfac859b1b4efae75f25f72bc0530006c88e6e1" translate="yes" xml:space="preserve">
          <source>The following are good consumers:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="415fb3cf16155d23aebc101af30f40f1175a4761" translate="yes" xml:space="preserve">
          <source>The following are good producers:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc2c73f87b7ae21e5d1bff7544c615fae9cb5d03" translate="yes" xml:space="preserve">
          <source>The following behaves as expected:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f147698ae3534209b092f6955e20175ff56a36f" translate="yes" xml:space="preserve">
          <source>The following command works to load new packages into a running GHCi:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7ad1243df876884047bbd1cfa2abad6fc2f257e" translate="yes" xml:space="preserve">
          <source>The following commands turn the keypad on/off (&lt;code&gt;smkx&lt;/code&gt; and &lt;code&gt;rmkx&lt;/code&gt;). They have no effect if those capabilities are not defined. For portability between terminals, the keypad should be explicitly turned on before accepting user key input.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25f14bebf678b2e0c7df12fa6531f8bc946288ab" translate="yes" xml:space="preserve">
          <source>The following definition is available to C programs inter-operating with Haskell code when including the header &lt;code&gt;HsFFI.h&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6d695a5cf6d19ccd0a26b89aff9c95dd12f497b" translate="yes" xml:space="preserve">
          <source>The following description of the motivation and use of functional dependencies is taken from the Hugs user manual, reproduced here (with minor changes) by kind permission of Mark Jones.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="255eb2a60233998edc485b972b2b920903f06efc" translate="yes" xml:space="preserve">
          <source>The following equation relates &lt;code&gt;&lt;a href=&quot;data-bytestring#v:unfoldrN&quot;&gt;unfoldrN&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-bytestring#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="713d7c0768135036f33a7e1109e709b8e968874e" translate="yes" xml:space="preserve">
          <source>The following equation relates &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:unfoldrN&quot;&gt;unfoldrN&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dbc7d38cb4fbd659d01d9a4ef580cbd8a454bdc2" translate="yes" xml:space="preserve">
          <source>The following extra instances are defined:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="219485ecc6b675dce37eba80ce2494e945235236" translate="yes" xml:space="preserve">
          <source>The following flags are simple ways to select standard &amp;ldquo;packages&amp;rdquo; of warnings:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e8f2bd1d4e584f03bc71486665d6449cff997d8" translate="yes" xml:space="preserve">
          <source>The following flags control the way in which GHC displays types in error messages and in GHCi:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="369fd24532366a269db0dd996324b5e45dfd6c9e" translate="yes" xml:space="preserve">
          <source>The following functions allow a thread to control delivery of asynchronous exceptions during a critical region.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf919ec9ecd009bd434b357d75af7e1bf8279715" translate="yes" xml:space="preserve">
          <source>The following functions enable cross-platform output of text that may contain Unicode characters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38af53e84d563801f65a6120a4900e75bb8e39ff" translate="yes" xml:space="preserve">
          <source>The following functions for cursor movement will combine the more primitive capabilities. For example, &lt;code&gt;&lt;a href=&quot;system-console-terminfo-cursor#v:moveDown&quot;&gt;moveDown&lt;/a&gt;&lt;/code&gt; may use either &lt;code&gt;&lt;a href=&quot;system-console-terminfo-cursor#v:cursorDown&quot;&gt;cursorDown&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;system-console-terminfo-cursor#v:cursorDown1&quot;&gt;cursorDown1&lt;/a&gt;&lt;/code&gt; depending on the parameter and which of &lt;code&gt;cud&lt;/code&gt; and &lt;code&gt;cud1&lt;/code&gt; are defined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b7bd1ee8d2490e346b323a061ee5d6bf4bd98aa" translate="yes" xml:space="preserve">
          <source>The following functions read one line or character of input from the user.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="defeb72fa9fc8defce3095a722d77cd56b0b0897" translate="yes" xml:space="preserve">
          <source>The following holds:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e843336042b652d443e731d806dae137491a142" translate="yes" xml:space="preserve">
          <source>The following instances of &lt;code&gt;MonadFix&lt;/code&gt; are automatically provided: List, Maybe, IO. Furthermore, the &lt;code&gt;Control.Monad.ST&lt;/code&gt; and &lt;code&gt;Control.Monad.ST.Lazy&lt;/code&gt; modules provide the instances of the &lt;code&gt;MonadFix&lt;/code&gt; class for Haskell&amp;rsquo;s internal state monad (strict and lazy, respectively).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="974f2bea79592d4497c7bb6f1878062d29b69e35" translate="yes" xml:space="preserve">
          <source>The following laws ought to hold (for all valid bit indices &lt;code&gt;&lt;em&gt;n&lt;/em&gt;&lt;/code&gt;):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3bc96821c04daf88673e5973fb7e13baaeb66bc4" translate="yes" xml:space="preserve">
          <source>The following operations are guaranteed not to be interruptible:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="740d5fed1fd466547dd8bedbd7c0b84313346d32" translate="yes" xml:space="preserve">
          <source>The following options affect the way the runtime schedules threads on CPUs:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b8d3fdea7e46b30a4c9898c10dbf48da92a4aa0" translate="yes" xml:space="preserve">
          <source>The following options are useful for keeping (or not keeping) certain intermediate files around, when normally GHC would throw these away after compilation:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38c3f1cd516a144b167f804cbad9091a110d7738" translate="yes" xml:space="preserve">
          <source>The following property holds</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4d20004308e57029d6af08f5d4d162927106726" translate="yes" xml:space="preserve">
          <source>The following relationships hold:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78400d597f1cd2c8bbeafc9eb8299b783cc0473e" translate="yes" xml:space="preserve">
          <source>The following sections also give some hints and tips on the use of the foreign function interface in GHC.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f17c609e8f1c6b37d3130d2dff0e1652b3175021" translate="yes" xml:space="preserve">
          <source>The following should work, since both &lt;code&gt;'1'&lt;/code&gt; and &lt;code&gt;'2'&lt;/code&gt; can be parsed as &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;s.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f604ae57c21e961a4347d16a255de560a7918fb" translate="yes" xml:space="preserve">
          <source>The following should work, since both &lt;code&gt;'1'&lt;/code&gt; and &lt;code&gt;'2'&lt;/code&gt; can be parsed as &lt;code&gt;&lt;a href=&quot;prelude#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;s.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f68ed3cdb6c1e1e040a389af1a8ea7b8ca3ea19d" translate="yes" xml:space="preserve">
          <source>The following syntax is stolen:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f24a325a1df690e88417cf55ef160f4f9b155bda" translate="yes" xml:space="preserve">
          <source>The following unboxed types may be used as basic foreign types (see FFI Chapter, Section 8.6): &lt;code&gt;Int#&lt;/code&gt;, &lt;code&gt;Word#&lt;/code&gt;, &lt;code&gt;Char#&lt;/code&gt;, &lt;code&gt;Float#&lt;/code&gt;, &lt;code&gt;Double#&lt;/code&gt;, &lt;code&gt;Addr#&lt;/code&gt;, &lt;code&gt;StablePtr# a&lt;/code&gt;, &lt;code&gt;MutableByteArray#&lt;/code&gt;, &lt;code&gt;ForeignObj#&lt;/code&gt;, and &lt;code&gt;ByteArray#&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
