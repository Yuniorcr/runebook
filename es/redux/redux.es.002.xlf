<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="es" datatype="htmlbody" original="redux">
    <body>
      <group id="redux">
        <trans-unit id="40839b1c8a38e69ec4218f19c9a385d95915a832" translate="yes" xml:space="preserve">
          <source>It is up to you to try a few options, choose a convention you like, and follow it, whether with, or without the middleware.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b392f0ed8ea05e547e964224687831827c136e29" translate="yes" xml:space="preserve">
          <source>It is vital that these Prerequisite Concepts are &lt;strong&gt;thoroughly understood&lt;/strong&gt; before moving on to more advanced and Redux-specific techniques. A recommended reading list is available at:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5fa6252549b34d2727aeeb1fe8e3c816a3d8827" translate="yes" xml:space="preserve">
          <source>It may be helpful to see examples of what the different types of sub-reducer functions look like and how they fit together. Let's look at a demonstration of how a large single reducer function can be refactored into a composition of several smaller functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e02627810b718b477472f1f76a7b34ecc56b8eb7" translate="yes" xml:space="preserve">
          <source>It must never return &lt;code&gt;undefined&lt;/code&gt;. It is too easy to do this by mistake via an early &lt;code&gt;return&lt;/code&gt; statement, so &lt;code&gt;combineReducers&lt;/code&gt; throws if you do that instead of letting the error manifest itself somewhere else.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1440628c9081aad68267a2e66c7ba0b0ef6cf7d" translate="yes" xml:space="preserve">
          <source>It needs to be rewritten like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2003fb7b90831988d1d806aec866ee85ca010393" translate="yes" xml:space="preserve">
          <source>It needs to look at the previous state and the dispatched action, and determine what kind of work needs to be done</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5761524a50c8fdeeafeab8c5ae63d8a8423998ef" translate="yes" xml:space="preserve">
          <source>It only exposes a subset of the &lt;a href=&quot;../api/store&quot;&gt;store API&lt;/a&gt; to the middleware: &lt;a href=&quot;../api/store#dispatch&quot;&gt;&lt;code&gt;dispatch(action)&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../api/store#getState&quot;&gt;&lt;code&gt;getState()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c914355546b42c63de745bfcca2aaeb3e2313f74" translate="yes" xml:space="preserve">
          <source>It seems that reducer isn't the right abstraction, but we're very close.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="beb2e2454ed95b3107fe31d45f50cecc81a6856f" translate="yes" xml:space="preserve">
          <source>It then runs a shallow equality check on its reference to the root state object and the state object passed to it, and a separate series of shallow checks on each reference to the props object&amp;rsquo;s values and those that are returned from running the &lt;code&gt;mapStateToProps&lt;/code&gt; function again.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7396f0cc913742a2329483587f6bde1029a53425" translate="yes" xml:space="preserve">
          <source>It will then combine both sets of results into a single state tree:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe6fecbba3b0b6d0528af6e5ce21a171dd9d1cfb" translate="yes" xml:space="preserve">
          <source>It's a &lt;a href=&quot;http://knowyourmeme.com/memes/we-need-to-go-deeper&quot;&gt;&amp;ldquo;we need to go deeper&amp;rdquo;&lt;/a&gt; kind of moment, so it might take a while for this to make sense. The function cascade feels intimidating. ES6 arrow functions make this &lt;a href=&quot;https://en.wikipedia.org/wiki/Currying&quot;&gt;currying&lt;/a&gt; easier on eyes:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53bb5e1d4ed878477f0cfe96c4cca984251e5713" translate="yes" xml:space="preserve">
          <source>It's a good idea to pass as little data in each action as possible. For example, it's better to pass &lt;code&gt;index&lt;/code&gt; than the whole todo object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66564241e2f2072f8ffd6342ef4d5f057cfbf2e9" translate="yes" xml:space="preserve">
          <source>It's also important to note that some of these suggestions may or may not be directly applicable based on architectural decisions in a specific application. For example, an application using Immutable.js Maps to store data would likely have its reducer logic structured at least somewhat differently than an application using plain Javascript objects. This documentation primarily assumes use of plain Javascript objects, but many of the principles would still apply if using other tools.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d8a4e5e3006a924b03ad0f0eb598b2f0f5eaed6" translate="yes" xml:space="preserve">
          <source>It's best not to mix this approach with standard Redux reducer composition. For typical web apps, stick with reducer composition. For &amp;ldquo;product hubs&amp;rdquo;, &amp;ldquo;dashboards&amp;rdquo;, or enterprise software that groups disparate tools into a unified package, give the sub-app approach a try.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="252a3efbc077a7d5a93fd6d1dbfedaa2d2669df6" translate="yes" xml:space="preserve">
          <source>It's called a reducer because it's the type of function you would pass to &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce&quot;&gt;&lt;code&gt;Array.prototype.reduce(reducer, ?initialValue)&lt;/code&gt;&lt;/a&gt;. It's very important that the reducer stays pure. Things you should &lt;strong&gt;never&lt;/strong&gt; do inside a reducer:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a58a3a8e0f482a446b06f379efada2fd4c57438" translate="yes" xml:space="preserve">
          <source>It's easy to create a store if you have a reducer. In the &lt;a href=&quot;reducers&quot;&gt;previous section&lt;/a&gt;, we used &lt;a href=&quot;../api/combinereducers&quot;&gt;&lt;code&gt;combineReducers()&lt;/code&gt;&lt;/a&gt; to combine several reducers into one. We will now import it, and pass it to &lt;a href=&quot;../api/createstore&quot;&gt;&lt;code&gt;createStore()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb4ae669548f27a4108b547b46fa2c12ac612f32" translate="yes" xml:space="preserve">
          <source>It's for this improvement in performance that Redux uses shallow equality checking.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98dcf0d417fbe43fd9477364b70c4f9d857c65e0" translate="yes" xml:space="preserve">
          <source>It's generally suggested that selectors are defined alongside reducers and exported, and then reused elsewhere (such as in &lt;code&gt;mapStateToProps&lt;/code&gt; functions, in async action creators, or sagas) to colocate all the code that knows about the actual shape of the state tree in the reducer files.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a8921bdd4ecd237805498907dc4327f0981b88e" translate="yes" xml:space="preserve">
          <source>It's important to note that a Redux store really only has a single reducer function. The store passes the current state and dispatched action to that one reducer function, and lets the reducer handle things appropriately.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c36768ba51d801006d900629e7ac3f3a13e90bcd" translate="yes" xml:space="preserve">
          <source>It's important to note that you'll only have a single store in a Redux application. When you want to split your data handling logic, you'll use &lt;a href=&quot;reducers#splitting-reducers&quot;&gt;reducer composition&lt;/a&gt; instead of many stores.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61d4dad8daf83a3b27a53b849070082ed3ffa990" translate="yes" xml:space="preserve">
          <source>It's important to remember that whenever you update a nested value, you must also return new copies of anything above it in your state tree. If you have &lt;code&gt;state.a.b.c.d&lt;/code&gt;, and you want to make an update to &lt;code&gt;d&lt;/code&gt;, you would also need to return new copies of &lt;code&gt;c&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt;, &lt;code&gt;a&lt;/code&gt;, and &lt;code&gt;state&lt;/code&gt;. This &lt;a href=&quot;http://arqex.com/wp-content/uploads/2015/02/trees.png&quot;&gt;state tree mutation diagram&lt;/a&gt; demonstrates how a change deep in a tree requires changes all the way up.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c339b6732e0d2b2a42a0ddd93251b26fe3ad96b4" translate="yes" xml:space="preserve">
          <source>It's more code, but it's exactly what makes Redux predictable and efficient. If you want to have less code, you can use a helper like &lt;a href=&quot;https://facebook.github.io/react/docs/update.html&quot;&gt;&lt;code&gt;React.addons.update&lt;/code&gt;&lt;/a&gt; to write immutable transformations with a terse syntax:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f3ca2b8ee117276e54d75838be64e770429f6ba" translate="yes" xml:space="preserve">
          <source>It's not always immediately clear how these two approaches interact. Fortunately, the process does follow some predictable rules. Here's how the pieces fit together.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0ab78e0353e7cd035a999d2fa8e5af4c2f963ef" translate="yes" xml:space="preserve">
          <source>It's possible you're correctly dispatching an action and applying your reducer but the corresponding state is not being correctly translated into props.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4543176cfbe02cd87a4507bdb08d9c22f1859120" translate="yes" xml:space="preserve">
          <source>It's unfortunate that many still choose Flux framework based on whether it uses &lt;code&gt;switch&lt;/code&gt; statements in the documentation. If you don't like &lt;code&gt;switch&lt;/code&gt;, you can solve this with a single function, as we show below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e539fa93863f712b20c2f16d75b4287d6434876" translate="yes" xml:space="preserve">
          <source>It's unfortunate that many still choose a framework based on whether it uses &lt;code&gt;switch&lt;/code&gt; statements in the documentation. If you don't like &lt;code&gt;switch&lt;/code&gt;, you can use a custom &lt;code&gt;createReducer&lt;/code&gt; function that accepts a handler map, as shown in &lt;a href=&quot;../recipes/reducingboilerplate#reducers&quot;&gt;&amp;ldquo;reducing boilerplate&amp;rdquo;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2bb2765277319f208309e2db82a727dcbfdec808" translate="yes" xml:space="preserve">
          <source>JavaScript Application Architecture On The Road To 2015</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5663d16ece82a891feaade5f2800177cdbd06bf0" translate="yes" xml:space="preserve">
          <source>JavaScript Immutability presentation (PDF - see slide 12 for benefits)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5686c8f6acca3473e05ae8e791a2b0127eaac9e5" translate="yes" xml:space="preserve">
          <source>JavaScript and Immutability</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48e85cf4e700b35b1170cf47611de9569a23efdc" translate="yes" xml:space="preserve">
          <source>JavaScript does not provide immutable data structures. As such, for Immutable.JS to provide its immutable guarantees, your data must be encapsulated within an Immutable.JS object (such as a &lt;code&gt;Map&lt;/code&gt; or a &lt;code&gt;List&lt;/code&gt;, etc.). Once it&amp;rsquo;s contained in this way, it&amp;rsquo;s hard for that data to then interoperate with other, plain JavaScript objects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db1e7af6d4d988f37e8c96dfd9be6dd7f8c52667" translate="yes" xml:space="preserve">
          <source>JavaScript was never designed to provide guaranteed immutable operations. Accordingly, there are several issues you need to be aware of if you choose to use it for your immutable operations in your Redux app.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4f9a7a1a37cb18678bb27808982a0fab518f2bf" translate="yes" xml:space="preserve">
          <source>Javascript and Immutability</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8190845a1ebdd8d76968f6c6f761a6be3b93edae" translate="yes" xml:space="preserve">
          <source>Jing Chen, creator of Flux</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="951a42e3bc90a6103cf2aad8fcbde2477e07ad4f" translate="yes" xml:space="preserve">
          <source>Join the &lt;a href=&quot;https://discord.gg/0ZcbPKXt5bZ6au5t&quot;&gt;#redux&lt;/a&gt; channel of the &lt;a href=&quot;http://www.reactiflux.com&quot;&gt;Reactiflux&lt;/a&gt; Discord community.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e399f1c349f8769ebbb0daf23b23eccbf46daf27" translate="yes" xml:space="preserve">
          <source>Just like before, we never write directly to &lt;code&gt;state&lt;/code&gt; or its fields, and instead we return new objects. The new &lt;code&gt;todos&lt;/code&gt; is equal to the old &lt;code&gt;todos&lt;/code&gt; concatenated with a single new item at the end. The fresh todo was constructed using the data from the action.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4775133d954dab5abc63710e9c6e38a2239ee177" translate="yes" xml:space="preserve">
          <source>Just like in the basic tutorial, you'll need to &lt;a href=&quot;../basics/reducers#designing-the-state-shape&quot;&gt;design the shape of your application's state&lt;/a&gt; before rushing into the implementation. With asynchronous code, there is more state to take care of, so we need to think it through.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6df178ca4d41674a93e54d6ff850afe3eceb958" translate="yes" xml:space="preserve">
          <source>Laurence Roberts</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8e78fb63e60ac2949bd5cbbb13dfecd20351939" translate="yes" xml:space="preserve">
          <source>Learn Redux from Its Creator</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="815813ef04db0611309243e056689002bfca2f51" translate="yes" xml:space="preserve">
          <source>Learning Functional Programming in Javascript</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="204c47c7f7b6077c5cc66fb4275cccc654adf5ff" translate="yes" xml:space="preserve">
          <source>Learning Redux</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f18ace0f4dc5ebb1cb3f958d948cec6b1bfd54fc" translate="yes" xml:space="preserve">
          <source>Lee Byron on Twitter: &amp;ldquo;Perf tip for #immutablejs&amp;hellip;&amp;rdquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d516f563abbe7f29a4e3ee915a4a5746abb4a29" translate="yes" xml:space="preserve">
          <source>Let's consider a different scenario:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30e9663293d38e3d33c344fc2983eb83f3e158b6" translate="yes" xml:space="preserve">
          <source>Let's create a function named &lt;code&gt;makeGetVisibleTodos&lt;/code&gt; that returns a new copy of the &lt;code&gt;getVisibleTodos&lt;/code&gt; selector each time it is called:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd130845bbec5d16d12cb399e0c3cbfeb2c430a7" translate="yes" xml:space="preserve">
          <source>Let's define a memoized selector named &lt;code&gt;getVisibleTodos&lt;/code&gt; to replace the non-memoized version above:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3a4dc14b145305dfe293196d07e8aa73560d7a5" translate="yes" xml:space="preserve">
          <source>Let's explore reducer composition more. Can we also extract a reducer managing just &lt;code&gt;visibilityFilter&lt;/code&gt;? We can.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d63428074244e2479b8e425262f560268ac5f43" translate="yes" xml:space="preserve">
          <source>Let's recall what the combined reducer does:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="384774d8dbe43962eb49ce001e2d96e26d96ea07" translate="yes" xml:space="preserve">
          <source>Let's revisit the &lt;a href=&quot;../basics/usagewithreact&quot;&gt;Todos List example&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed19a0e0fde116aef33b7018b7a9bbcce6346bdc" translate="yes" xml:space="preserve">
          <source>Let's say a designer comes back to us after reviewing our prototype, and tells us that we need to allow three todos maximum. We can enforce this by rewriting our action creator to a callback form with &lt;a href=&quot;https://github.com/gaearon/redux-thunk&quot;&gt;redux-thunk&lt;/a&gt; middleware and adding an early exit:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d23a5d0451ec5d5abafa771961468240b19ed964" translate="yes" xml:space="preserve">
          <source>Let's say that our initial reducer looks like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a42244fb104feca9e7eb72186a85fa8a258a8b6f" translate="yes" xml:space="preserve">
          <source>Let's start by defining the several synchronous action types and action creators we need in our example app. Here, the user can select a subreddit to display:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6be34e2837216ea61f99fc5d5668808369bc5adc" translate="yes" xml:space="preserve">
          <source>Let's take a look at our new client file:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b409b71e81ab2b58978b981a343bc5bce51dcd92" translate="yes" xml:space="preserve">
          <source>Let's talk through the algorithm to manipulate the state shape described above. We can define two actions to operate on this state: &lt;code&gt;UNDO&lt;/code&gt; and &lt;code&gt;REDO&lt;/code&gt;. In our reducer, we will do the following steps to handle these actions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd3902ab0d1d59de82883d31a36cdd78b461122c" translate="yes" xml:space="preserve">
          <source>Let's write a function that lets us express reducers as an object mapping from action types to handlers. For example, if we want our &lt;code&gt;todos&lt;/code&gt; reducers to be defined like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e72eaffd3ac1dcb5208c2d6ea7b42f2173627e6a" translate="yes" xml:space="preserve">
          <source>Let's write the components! We begin with the presentational components so we don't need to think about binding to Redux yet.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4642d8e2bbb9a67ffddd44f6258e15948144b9a5" translate="yes" xml:space="preserve">
          <source>Leveling Up with React: Redux</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3229609e15436ec51bcf00818a69a84dbc58a0c2" translate="yes" xml:space="preserve">
          <source>License</source>
          <target state="translated">License</target>
        </trans-unit>
        <trans-unit id="58fd3b1b83cc7fc933d72fe934bdb6e534441281" translate="yes" xml:space="preserve">
          <source>Licensed under the MIT License.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef7dd92b3bad02dfcc7661e876c8b68c18ebfc35" translate="yes" xml:space="preserve">
          <source>Limit your use of &lt;code&gt;toJS()&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83fce8327410848c9eb609acb21732c7c0fec96a" translate="yes" xml:space="preserve">
          <source>Logo</source>
          <target state="translated">Logo</target>
        </trans-unit>
        <trans-unit id="89690ac571dcf4c9c40c842efed3f11171d07b29" translate="yes" xml:space="preserve">
          <source>MIT</source>
          <target state="translated">MIT</target>
        </trans-unit>
        <trans-unit id="17367293ad2021231bf611dd0dd27a355d38e2d6" translate="yes" xml:space="preserve">
          <source>Make sure mapStateToProps is correct</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f370227bbf65772938b3d8e358e2ce2218a1a54" translate="yes" xml:space="preserve">
          <source>Make sure that you use &lt;code&gt;Object.assign&lt;/code&gt; correctly. For example, instead of returning something like &lt;code&gt;Object.assign(state, newData)&lt;/code&gt; from your reducers, return &lt;code&gt;Object.assign({}, state, newData)&lt;/code&gt;. This way you don't override the previous &lt;code&gt;state&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d8418eedd0d6a2db483537e4446820ce1952555" translate="yes" xml:space="preserve">
          <source>Make your entire Redux state tree an Immutable.JS object</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91529d50836c68b2f85612f8480c39828f101131" translate="yes" xml:space="preserve">
          <source>Managing Normalized Data</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8cfd188b6fb6ef58e95265e7bee55786bad588a" translate="yes" xml:space="preserve">
          <source>Managing this ever-changing state is hard. If a model can update another model, then a view can update a model, which updates another model, and this, in turn, might cause another view to update. At some point, you no longer understand what happens in your app as you have &lt;strong&gt;lost control over the when, why, and how of its state.&lt;/strong&gt; When a system is opaque and non-deterministic, it's hard to reproduce bugs or add new features.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="770e69d1c946703f5c3589b40d2b5d1f60424fb5" translate="yes" xml:space="preserve">
          <source>Many applications deal with data that is nested or relational in nature. For example, a blog editor could have many Posts, each Post could have many Comments, and both Posts and Comments would be written by a User. Data for this kind of application might look like:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d062b20c46aa58461072521c5ff06fd5c22eadb2" translate="yes" xml:space="preserve">
          <source>Many users later want to try to share data between two reducers, but find that &lt;code&gt;combineReducers&lt;/code&gt; does not allow them to do so. There are several approaches that can be used:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f7bcd6c888e6b88d0545bc697de285055397b49" translate="yes" xml:space="preserve">
          <source>Maybe we want to be able to run multiple instances of it in the same &amp;ldquo;bigger&amp;rdquo; app and keep it as a complete black box, with Redux being an implementation detail.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99890f553cee2767e33647e04645b77191093369" translate="yes" xml:space="preserve">
          <source>Meet Reducer Enhancers</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1335c9d05ff6249a581b2af47d8ca262af71f878" translate="yes" xml:space="preserve">
          <source>Meet some of the outstanding companies that made it possible:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb8978ed84b5906ad4191a0b252828be64701bfa" translate="yes" xml:space="preserve">
          <source>Middleware</source>
          <target state="translated">Middleware</target>
        </trans-unit>
        <trans-unit id="4de8569a40d6be412d5f73fc6d679fbd847a1bc7" translate="yes" xml:space="preserve">
          <source>Middleware functions wrap behavior of &lt;code&gt;dispatch&lt;/code&gt; calls in Redux, so to test this modified behavior we need to mock the behavior of the &lt;code&gt;dispatch&lt;/code&gt; call.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4cfdea7cdd9cbecf25a5a88942621957d5c3dd05" translate="yes" xml:space="preserve">
          <source>Middleware is composable using function composition. It is useful for logging actions, performing side effects like routing, or turning an asynchronous API call into a series of synchronous actions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3958295af5cb6ac63c96e1bbd5629db43b83e95" translate="yes" xml:space="preserve">
          <source>Middleware is created by the community and does not ship with Redux by default. You need to explicitly install packages like &lt;a href=&quot;https://github.com/gaearon/redux-thunk&quot;&gt;redux-thunk&lt;/a&gt; or &lt;a href=&quot;https://github.com/acdlite/redux-promise&quot;&gt;redux-promise&lt;/a&gt; to use it. You may also create your own middleware.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="709ac9c564fa8004f1018815a013faace4ceaf9b" translate="yes" xml:space="preserve">
          <source>Middleware is not baked into &lt;a href=&quot;createstore&quot;&gt;&lt;code&gt;createStore&lt;/code&gt;&lt;/a&gt; and is not a fundamental part of the Redux architecture, but we consider it useful enough to be supported right in the core. This way, there is a single standard way to extend &lt;a href=&quot;store#dispatch&quot;&gt;&lt;code&gt;dispatch&lt;/code&gt;&lt;/a&gt; in the ecosystem, and different middleware may compete in expressiveness and utility.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00c8a7e2c0f9e6b20fe14442f77d182a03eebb64" translate="yes" xml:space="preserve">
          <source>Middleware is the suggested way to extend Redux with custom functionality. Middleware lets you wrap the store's &lt;a href=&quot;store#dispatch&quot;&gt;&lt;code&gt;dispatch&lt;/code&gt;&lt;/a&gt; method for fun and profit. The key feature of middleware is that it is composable. Multiple middleware can be combined together, where each middleware requires no knowledge of what comes before or after it in the chain.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9772321b9da9e355cae92c8995bc9b6d9b873c30" translate="yes" xml:space="preserve">
          <source>Middleware only wraps the store's &lt;a href=&quot;store#dispatch&quot;&gt;&lt;code&gt;dispatch&lt;/code&gt;&lt;/a&gt; function. Technically, anything a middleware can do, you can do manually by wrapping every &lt;code&gt;dispatch&lt;/code&gt; call, but it's easier to manage this in a single place and define action transformations on the scale of the whole project.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="904b42b851f9aa103d834460d3e42948c262c785" translate="yes" xml:space="preserve">
          <source>Middleware sounds much more complicated than it really is. The only way to really understand middleware is to see how the existing middleware works, and try to write your own. The function nesting can be intimidating, but most of the middleware you'll find are, in fact, 10-liners, and the nesting and composability is what makes the middleware system powerful.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9302feee19404010fcac9af350604fe588e01046" translate="yes" xml:space="preserve">
          <source>Migrating to Redux</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f2cbd107037ed23248e5058a7a64cd6bae05468" translate="yes" xml:space="preserve">
          <source>Miscellaneous</source>
          <target state="translated">Miscellaneous</target>
        </trans-unit>
        <trans-unit id="7cc7d31118fe440474864da8b1d74f693cb0f866" translate="yes" xml:space="preserve">
          <source>Modular Reducers and Selectors</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e7b0b1e9c0a61f16b9a2611a1aa537d440279de" translate="yes" xml:space="preserve">
          <source>Monkeypatching is a hack. &amp;ldquo;Replace any method you like&amp;rdquo;, what kind of API is that? Let's figure out the essence of it instead. Previously, our functions replaced &lt;code&gt;store.dispatch&lt;/code&gt;. What if they &lt;em&gt;returned&lt;/em&gt; the new &lt;code&gt;dispatch&lt;/code&gt; function instead?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4bab2d8fe13fa6ab57f80098b414f0f734c5dd25" translate="yes" xml:space="preserve">
          <source>More</source>
          <target state="translated">More</target>
        </trans-unit>
        <trans-unit id="65607507695dbb68853f7200e33956e39fd6a15d" translate="yes" xml:space="preserve">
          <source>More Examples</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fbb1457de42e260b67aaf3c234080db729e6567f" translate="yes" xml:space="preserve">
          <source>Most applications deal with multiple types of data, which can be broadly divided into three categories:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89d03ee4b54b44641100dd50cccd338fa1f41b27" translate="yes" xml:space="preserve">
          <source>Most commonly people consume Redux as a collection of &lt;a href=&quot;http://webpack.github.io/docs/commonjs.html&quot;&gt;CommonJS&lt;/a&gt; modules. These modules are what you get when you import &lt;code&gt;redux&lt;/code&gt; in a &lt;a href=&quot;https://webpack.js.org/&quot;&gt;Webpack&lt;/a&gt;, &lt;a href=&quot;http://browserify.org/&quot;&gt;Browserify&lt;/a&gt;, or a Node environment. If you like to live on the edge and use &lt;a href=&quot;http://rollupjs.org&quot;&gt;Rollup&lt;/a&gt;, we support that as well.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09f0cc4aec4d47d93c4e8a96edd682217c9476ac" translate="yes" xml:space="preserve">
          <source>Most likely you'll never write a store enhancer, but you may use the one provided by the &lt;a href=&quot;https://github.com/gaearon/redux-devtools&quot;&gt;developer tools&lt;/a&gt;. It is what makes time travel possible without the app being aware it is happening. Amusingly, the &lt;a href=&quot;api/applymiddleware&quot;&gt;Redux middleware implementation&lt;/a&gt; is itself a store enhancer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="390f7c239e26365aa378c0e0495e19cfea627097" translate="yes" xml:space="preserve">
          <source>Most likely, you'll also need &lt;a href=&quot;https://github.com/reactjs/react-redux&quot;&gt;the React bindings&lt;/a&gt; and &lt;a href=&quot;https://github.com/gaearon/redux-devtools&quot;&gt;the developer tools&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e3a3d184b0b6d4dfa96e5964033c932e00274c5" translate="yes" xml:space="preserve">
          <source>Most of the components we'll write will be presentational, but we'll need to generate a few container components to connect them to the Redux store. This and the design brief below do not imply container components must be near the top of the component tree. If a container component becomes too complex (i.e. it has heavily nested presentional components with countless callbacks being passed down), introduce another container within the component tree as noted in the &lt;a href=&quot;../faq/reactredux#react-multiple-components&quot;&gt;FAQ&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4fd704d00a4e5a0c3b40b38e9218c4cbbf210bcc" translate="yes" xml:space="preserve">
          <source>Most of the functionality Baobab provides is related to updating the data with cursors, but Redux enforces that the only way to update the data is to dispatch an action. Therefore they solve the same problem differently, and don't complement each other.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6a06199cc127e571d3588aef63c79108675eabc" translate="yes" xml:space="preserve">
          <source>Motivation</source>
          <target state="translated">Motivation</target>
        </trans-unit>
        <trans-unit id="723bf632acd68a56f2a8abd2cb40c71cceac0c0d" translate="yes" xml:space="preserve">
          <source>Motivation for Memoized Selectors</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="552b006eca5b663e553068321aa1dddaf3b1befb" translate="yes" xml:space="preserve">
          <source>Mozilla's experimental browser testbed</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d88a4a071f039297bbb69db92ff026e19cea735d" translate="yes" xml:space="preserve">
          <source>Mutability vs immutability</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="efd8a68660022a43293fd5a672afacaf4b2ee1a5" translate="yes" xml:space="preserve">
          <source>Mutate its arguments;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="654f242c8a1a04fd78d46a2eed456576101047e8" translate="yes" xml:space="preserve">
          <source>Mutation is discouraged because it generally breaks time-travel debugging, and React Redux's &lt;code&gt;connect&lt;/code&gt; function:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14131d656db4b7bdd8f8e3f363d86fcd460046b5" translate="yes" xml:space="preserve">
          <source>My journey towards a maintainable project structure for React/Redux</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b24ea7fdf4c6ff696c569545bd59b1ddc1a2075" translate="yes" xml:space="preserve">
          <source>Navigating with React Router</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ffb832014d4614f14ecdf3023143c63e959c339a" translate="yes" xml:space="preserve">
          <source>Nested data means that the corresponding reducer logic has to be more nested or more complex. In particular, trying to update a deeply nested field can become very ugly very fast.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80a420ddf85790605c162653ce53a583b0952bbf" translate="yes" xml:space="preserve">
          <source>Never let a plain JavaScript object contain Immutable.JS properties. Equally, never let an Immutable.JS object contain a plain JavaScript object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a430ed54fb612f337f2ab8273ec4cbf9b6644bd7" translate="yes" xml:space="preserve">
          <source>Never mix plain JavaScript objects with Immutable.JS</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a34cbfaae2d3943f4277799da4593a9d4e8866b" translate="yes" xml:space="preserve">
          <source>Never mutate reducer arguments</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5c80dd926f59c776bb8a92ea2761368f2163c20" translate="yes" xml:space="preserve">
          <source>Never use &lt;code&gt;toJS()&lt;/code&gt; in &lt;code&gt;mapStateToProps&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="880eef8459e455b9917669c0f642e566841426d2" translate="yes" xml:space="preserve">
          <source>Never use Immutable.JS in your Dumb Components</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f170caead65df254d786032a409a6f6d204bca6" translate="yes" xml:space="preserve">
          <source>Next Steps</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0264cc83b356bb6ea59a462a975e062d839151d9" translate="yes" xml:space="preserve">
          <source>Next, we can split each specific case into its own function:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="841e4eea113da2949d5aa791e51d64a552200a40" translate="yes" xml:space="preserve">
          <source>Next, we'll explore how to &lt;a href=&quot;store&quot;&gt;create a Redux store&lt;/a&gt; that holds the state and takes care of calling your reducer when you dispatch an action.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="816c52fd2bdd94a63cd0944823a6c0aa9384c103" translate="yes" xml:space="preserve">
          <source>No</source>
          <target state="translated">No</target>
        </trans-unit>
        <trans-unit id="00e1f82b828451acc6eb547238db43005cf32c21" translate="yes" xml:space="preserve">
          <source>No Destructuring or Spread Operators</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45a97bbdd6d1c0b59be783757a1880b3f98ba017" translate="yes" xml:space="preserve">
          <source>No. We suggest you write independent small reducer functions that are each responsible for updates to a specific slice of state. We call this pattern &amp;ldquo;reducer composition&amp;rdquo;. A given action could be handled by all, some, or none of them. This keeps components decoupled from the actual data changes, as one action may affect different parts of the state tree, and there is no need for the component to be aware of this. Some users do choose to bind them more tightly together, such as the &amp;ldquo;ducks&amp;rdquo; file structure, but there is definitely no one-to-one mapping by default, and you should break out of such a paradigm any time you feel you want to handle an action in many reducers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d55eda060d4abd9e941e61eac1c5a4760b4b7fb" translate="yes" xml:space="preserve">
          <source>No. You are welcome to use any approach you'd like to respond to an action in a reducer. The &lt;code&gt;switch&lt;/code&gt; statement is the most common approach, but it's fine to use &lt;code&gt;if&lt;/code&gt; statements, a lookup table of functions, or to create a function that abstracts this away. In fact, while Redux does require that action objects contain a &lt;code&gt;type&lt;/code&gt; field, your reducer logic doesn't even have to rely on that to handle the action. That said, the standard approach is definitely using a switch statement or a lookup table based on &lt;code&gt;type&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e0d7b6b9e9168e473b1803957df55eb87b2031d" translate="yes" xml:space="preserve">
          <source>Nope, it's just HTML, some artisanal &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; tags, and plain old DOM manipulation. Enjoy!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="327c34539b30a346bec5ad81c0c1b3f68e1bdeed" translate="yes" xml:space="preserve">
          <source>Normalizing Data</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24e6df000cfc0eae18573e3ca083b23c0599cf6a" translate="yes" xml:space="preserve">
          <source>Normalizing Nested Data</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dcd338fb8e5bd8068c0c2b43bfce9d5de3e8a57c" translate="yes" xml:space="preserve">
          <source>Normalizing State Shape</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb23cc3f5afc902e5be043420e1d724b51659962" translate="yes" xml:space="preserve">
          <source>Normalizr Documentation</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="335b95f34a7df1f471d9e66d848a822638f18b4c" translate="yes" xml:space="preserve">
          <source>Normally you should just call &lt;a href=&quot;store#dispatch&quot;&gt;&lt;code&gt;dispatch&lt;/code&gt;&lt;/a&gt; directly on your &lt;a href=&quot;store&quot;&gt;&lt;code&gt;Store&lt;/code&gt;&lt;/a&gt; instance. If you use Redux with React, &lt;a href=&quot;https://github.com/gaearon/react-redux&quot;&gt;react-redux&lt;/a&gt; will provide you with the &lt;a href=&quot;store#dispatch&quot;&gt;&lt;code&gt;dispatch&lt;/code&gt;&lt;/a&gt; function so you can call it directly, too.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c4e5332959aece0b47c0b738573f9bd470cb893" translate="yes" xml:space="preserve">
          <source>Normally, a Javascript array's contents are modified using mutative functions like &lt;code&gt;push&lt;/code&gt;, &lt;code&gt;unshift&lt;/code&gt;, and &lt;code&gt;splice&lt;/code&gt;. Since we don't want to mutate state directly in reducers, those should normally be avoided. Because of that, you might see &quot;insert&quot; or &quot;remove&quot; behavior written like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5bf716978826f82f5c2d71096281b5d3d023f9c8" translate="yes" xml:space="preserve">
          <source>Not suitable for small values that change often</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c924e3088204ee77ba681f72be3444357932fca" translate="yes" xml:space="preserve">
          <source>Note</source>
          <target state="translated">Note</target>
        </trans-unit>
        <trans-unit id="eb86ccd5312e5081a352de1334537a0b4650d54d" translate="yes" xml:space="preserve">
          <source>Note About Other Routing Libraries</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6bbf18fa1a59b4aceea2d7935084a5984b1e6199" translate="yes" xml:space="preserve">
          <source>Note about Server Rendering</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c76dccbb579daeff6d19eccfc8338e7cf2dfdca" translate="yes" xml:space="preserve">
          <source>Note for Advanced Users</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e1755ef6326ca3fc737a66979bb10b7fe7587af" translate="yes" xml:space="preserve">
          <source>Note for ES6 Savvy Users</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4bfd422b1acf7ab6bcc2d683c3dcc9593e8dfe47" translate="yes" xml:space="preserve">
          <source>Note on &lt;code&gt;Object.assign&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="759269df6e82649e8ad3a46ac965bc2b1dbc225c" translate="yes" xml:space="preserve">
          <source>Note on &lt;code&gt;fetch&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4191e14191dc73a177c536b0008fd934e599f6c0" translate="yes" xml:space="preserve">
          <source>Note on &lt;code&gt;switch&lt;/code&gt; and Boilerplate</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae1778afee8eaabfaf5e882ffee86fd7dfad1748" translate="yes" xml:space="preserve">
          <source>Note on Boilerplate</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f520e769580a42a8ec1ab5c7de5b32126ab034fd" translate="yes" xml:space="preserve">
          <source>Note on Create React App</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0dba1d6300344edb76956054e6c0d4c05d8a5923" translate="yes" xml:space="preserve">
          <source>Note on Error Handling</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="226b6e169b44973eab9a3a7d4ce9abe63d0c7f07" translate="yes" xml:space="preserve">
          <source>Note on Nested Entities</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f85a104fce56d4fdf589c3dd1d9c7b40327d3c8b" translate="yes" xml:space="preserve">
          <source>Note on Reducer Composition</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d5561853fa6b8c8692a5c30631ba7770fde7366" translate="yes" xml:space="preserve">
          <source>Note on Relationships</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b2ca83fd75e901aec616d782b23314502061cce" translate="yes" xml:space="preserve">
          <source>Note on immutability, side effects, and mutation</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="068f9eefaa044d6807c7bf4c8c0f32ef9489c02e" translate="yes" xml:space="preserve">
          <source>Note that &amp;ldquo;updating data immutably&amp;rdquo; does &lt;em&gt;not&lt;/em&gt; mean that you must use &lt;a href=&quot;https://facebook.github.io/immutable-js/&quot;&gt;Immutable.js&lt;/a&gt;, although that is certainly an option. You can do immutable updates to plain JS objects and arrays using several different approaches:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03a447c3fbe3d52e5d3b4ec4eb5f4cbd98b4d07a" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;combineReducers&lt;/code&gt; doesn't know or care that there's anything special about the reducer function that's responsible for managing &lt;code&gt;a&lt;/code&gt;. We didn't need to modify &lt;code&gt;combineReducers&lt;/code&gt; to specifically know how to undo things - we just built up the pieces we needed into a new composed function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8cedc1c11fc5e0b2729544aacc4a299dcef1a86" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;todos&lt;/code&gt; also accepts &lt;code&gt;state&lt;/code&gt;&amp;mdash;but it's an array! Now &lt;code&gt;todoApp&lt;/code&gt; just gives it the slice of the state to manage, and &lt;code&gt;todos&lt;/code&gt; knows how to update just that slice. &lt;strong&gt;This is called &lt;em&gt;reducer composition&lt;/em&gt;, and it's the fundamental pattern of building Redux apps.&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f8b0362b0a282b6bc627b26a9692c8cb48f4d7f" translate="yes" xml:space="preserve">
          <source>Note that Immutable.JS objects do have a &lt;code&gt;toJS()&lt;/code&gt; method, which returns the data as a plain JavaScript data structure, but this method is extremely slow, and using it extensively will negate the performance benefits that Immutable.JS provides</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="453c35dfa0c302d121b3eadd02c225634676ef9a" translate="yes" xml:space="preserve">
          <source>Note that a normalized state structure generally implies that more components are connected and each component is responsible for looking up its own data, as opposed to a few connected components looking up large amounts of data and passing all that data downwards. As it turns out, having connected parent components simply pass item IDs to connected children is a good pattern for optimizing UI performance in a React Redux application, so keeping state normalized plays a key role in improving performance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd5f79bd2131ac43e4417a0d7a6aaff0b70dafa1" translate="yes" xml:space="preserve">
          <source>Note that a reducer is a pure function. It only &lt;em&gt;computes&lt;/em&gt; the next state. It should be completely predictable: calling it with the same inputs many times should produce the same outputs. It shouldn't perform any side effects like API calls or router transitions. These should happen before an action is dispatched.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dce445ddd99a63b5841226d22eed33b3bf5571f8" translate="yes" xml:space="preserve">
          <source>Note that experimental language features are subject to change.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b9f2be80295a73b990bda31c5fcc186d2c3fd08" translate="yes" xml:space="preserve">
          <source>Note that if you use &lt;code&gt;reduceReducers&lt;/code&gt;, you should make sure that the first reducer in the list is able to define the initial state, since the later reducers will generally assume that the entire state already exists and not try to provide defaults.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3299e9657e0599957e5ab9cd478270d217e7c17c" translate="yes" xml:space="preserve">
          <source>Note that this is equivalent to:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e53104dd9201201207a0d3f3e75f9194a7e7bc6e" translate="yes" xml:space="preserve">
          <source>Note that this is still an experimental language feature proposal so it may change in the future. Nevertheless some large projects such as &lt;a href=&quot;https://github.com/facebook/react-native&quot;&gt;React Native&lt;/a&gt; already use it extensively so it is safe to say that there will be a good automated migration path if it changes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83b83325ce50b1549fdb9a559ec6487d2af3c6cb" translate="yes" xml:space="preserve">
          <source>Note that unlike Redux itself, many packages in the Redux ecosystem don't provide UMD builds, so we recommend using CommonJS module bundlers like &lt;a href=&quot;https://webpack.js.org/&quot;&gt;Webpack&lt;/a&gt; and &lt;a href=&quot;http://browserify.org/&quot;&gt;Browserify&lt;/a&gt; for the most comfortable development experience.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62f695305f86349d2a0577aa88e353229236d1f1" translate="yes" xml:space="preserve">
          <source>Note that we are using &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment&quot;&gt;ES6 destructuring&lt;/a&gt; on the properties to pass in &lt;code&gt;params&lt;/code&gt; to &lt;code&gt;&amp;lt;VisibleTodoList /&amp;gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1618ff7b8e1c0dbfdbf2def8e4b7d2220f232032" translate="yes" xml:space="preserve">
          <source>Note that your &lt;code&gt;combineReducers()&lt;/code&gt; call will stay exactly as it was, but the &lt;code&gt;todos&lt;/code&gt; reducer will now refer to the reducer enhanced with Redux Undo:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="727f3c121140693e9689630208289bf9c864cbb3" translate="yes" xml:space="preserve">
          <source>Note that, conversely, if an &lt;em&gt;immutable&lt;/em&gt; object is used, the &lt;a href=&quot;#immutability-issues-with-react-redux&quot;&gt;component may re-render when it should not&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b863cfb1b4dca7e52579f1008befc33963aff3ba" translate="yes" xml:space="preserve">
          <source>Note that, conversely, if the values in your props object refer to mutable objects, &lt;a href=&quot;#shallow-checking-stops-component-re-rendering&quot;&gt;your component may not render when it should&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e99340e9e77003c33d3f85a388e8f45942421146" translate="yes" xml:space="preserve">
          <source>Note that, even if your immutable library supports cursors, you shouldn't use them in a Redux app. The whole state tree should be considered read-only, and you should use Redux for updating the state, and subscribing to the updates. Therefore writing via cursor doesn't make sense for Redux. &lt;strong&gt;If your only use case for cursors is decoupling the state tree from the UI tree and gradually refining the cursors, you should look at selectors instead.&lt;/strong&gt; Selectors are composable getter functions. See &lt;a href=&quot;http://github.com/faassen/reselect&quot;&gt;reselect&lt;/a&gt; for a really great and concise implementation of composable selectors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="285f98e8d01e4962eff6724b78a3c6724d0931e6" translate="yes" xml:space="preserve">
          <source>Note that:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b3033c3ffc250f6cdbccd213236b9854f6e17c7" translate="yes" xml:space="preserve">
          <source>Note, however, that this does not apply to the Redux state tree, which is (usually) represented as a large collection of data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70440046a3dc2e079f23ee1c57dfa76669b732aa" translate="yes" xml:space="preserve">
          <source>Notes</source>
          <target state="translated">Notes</target>
        </trans-unit>
        <trans-unit id="401d2785d679a18987a35eba32cda5b4c90664ab" translate="yes" xml:space="preserve">
          <source>Nothing happens when I dispatch an action</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2f081e8fb2d918d664c68f1b3afaafa905dc9ec" translate="yes" xml:space="preserve">
          <source>Notice that because the two &quot;slice of state&quot; reducers are now getting only their own part of the whole state as arguments, they no longer need to return complex nested state objects, and are now simpler as a result.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="259bf730b245ab69768be3ff064b89e550ad7e24" translate="yes" xml:space="preserve">
          <source>Notice that because we used the ES6 shorthand for defining an object literal, the key names in the resulting state are the same as the variable names from the imports. This may not always be the desired behavior, and is often a cause of confusion for those who aren't as familiar with ES6 syntax.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c55d1d53bcc6077be7393d548df6e69409007456" translate="yes" xml:space="preserve">
          <source>Notice that the structure of the data is a bit complex, and some of the data is repeated. This is a concern for several reasons:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31c43966210d015eb458a0c29218a03e52a64682" translate="yes" xml:space="preserve">
          <source>Notice that this simple function fulfills all the basic requirements. It returns a default value if none exists, initializing the store; it determines what sort of update needs to be done based on the type of the action, and returns new values; and it returns the previous state if no work needs to be done.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f594ca01c521a947b3e348a3910ebef9ac4949d" translate="yes" xml:space="preserve">
          <source>Now I specified the &lt;code&gt;preloadedState&lt;/code&gt; as the argument to &lt;code&gt;createStore()&lt;/code&gt;. The state returned from the combined reducer &lt;em&gt;combines&lt;/em&gt; the initial state I specified for the &lt;code&gt;a&lt;/code&gt; reducer with the &lt;code&gt;'wat'&lt;/code&gt; default argument specified that &lt;code&gt;b&lt;/code&gt; reducer chose itself.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b89cc88436f6b137ad4a9f780f72e731b9b03e7" translate="yes" xml:space="preserve">
          <source>Now all that's left to do is to port the UI to &lt;a href=&quot;../basics/usagewithreact&quot;&gt;use react-redux&lt;/a&gt; or equivalent.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb64c52d4e3660f6e76a49dcb8eecf7480f674ab" translate="yes" xml:space="preserve">
          <source>Now all you need to do is add the buttons for the Undo and Redo actions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a13470744cb184c27b6870ae352da0030e60cab7" translate="yes" xml:space="preserve">
          <source>Now if you click on &lt;code&gt;&amp;lt;FilterLink /&amp;gt;&lt;/code&gt; you will see that your URL will change between &lt;code&gt;'/SHOW_COMPLETED'&lt;/code&gt;, &lt;code&gt;'/SHOW_ACTIVE'&lt;/code&gt;, and &lt;code&gt;'/'&lt;/code&gt;. Even if you are going back with your browser, it will use your browser's history and effectively go to your previous URL.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5c5b26561c588a93e62173562a3ad6868edb589" translate="yes" xml:space="preserve">
          <source>Now it's &lt;em&gt;very&lt;/em&gt; clear what's happening in each case. We can also start to see some patterns emerging.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="039958ecab3a233f66de07e31ed5de4247ff1cc6" translate="yes" xml:space="preserve">
          <source>Now it's time to hook up those presentational components to Redux by creating some containers. Technically, a container component is just a React component that uses &lt;a href=&quot;../api/store#subscribe&quot;&gt;&lt;code&gt;store.subscribe()&lt;/code&gt;&lt;/a&gt; to read a part of the Redux state tree and supply props to a presentational component it renders. You could write a container component by hand, but we suggest instead generating container components with the React Redux library's &lt;a href=&quot;https://github.com/reactjs/react-redux/blob/master/docs/api.md#connectmapstatetoprops-mapdispatchtoprops-mergeprops-options&quot;&gt;&lt;code&gt;connect()&lt;/code&gt;&lt;/a&gt; function, which provides many useful optimizations to prevent unnecessary re-renders. (One result of this is that you shouldn't have to worry about the &lt;a href=&quot;https://facebook.github.io/react/docs/advanced-performance.html&quot;&gt;React performance suggestion&lt;/a&gt; of implementing &lt;code&gt;shouldComponentUpdate&lt;/code&gt; yourself.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e400bbf3cbd513fc16c8f3c4354394f2d6dfefd" translate="yes" xml:space="preserve">
          <source>Now let's &lt;a href=&quot;reducers&quot;&gt;define some reducers&lt;/a&gt; to specify how the state updates when you dispatch these actions!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a861289e4760b669f41d014c314ded1b05995e5c" translate="yes" xml:space="preserve">
          <source>Now let's consider a case where you use &lt;code&gt;combineReducers()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25793e0576f1da9e1c2bfbfd26f6e9946bceb3cb" translate="yes" xml:space="preserve">
          <source>Now let's handle &lt;code&gt;SET_VISIBILITY_FILTER&lt;/code&gt;. All it needs to do is to change &lt;code&gt;visibilityFilter&lt;/code&gt; on the state. Easy:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7f2dcd080c7438e503e2c14d7c5e936c3fb8edb" translate="yes" xml:space="preserve">
          <source>Now let's say you create a store with it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29c32e5fc4131c9dccec8ae29eeeaccbf917ea78" translate="yes" xml:space="preserve">
          <source>Now middleware takes the &lt;code&gt;next()&lt;/code&gt; dispatch function, and returns a dispatch function, which in turn serves as &lt;code&gt;next()&lt;/code&gt; to the middleware to the left, and so on. It's still useful to have access to some store methods like &lt;code&gt;getState()&lt;/code&gt;, so &lt;code&gt;store&lt;/code&gt; stays available as the top-level argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="382b9eb84610aaa6ea11db467333f8d6953604ec" translate="yes" xml:space="preserve">
          <source>Now that we have a better understanding of reducer enhancers, we can see that this is exactly what &lt;code&gt;undoable&lt;/code&gt; should have been:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5a09e1de7d9c9396b8d34429449e39f8bd9943d" translate="yes" xml:space="preserve">
          <source>Now that we have created a store, let's verify our program works! Even without any UI, we can already test the update logic.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b286277222e0bb8486e6265c655c4d0a7094d7a9" translate="yes" xml:space="preserve">
          <source>Now that we've decided what our state object looks like, we're ready to write a reducer for it. The reducer is a pure function that takes the previous state and an action, and returns the next state.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c21e7038b2cfa1d79db9097dffc1cae32ab8eff6" translate="yes" xml:space="preserve">
          <source>Now that you know how Redux works, let's &lt;a href=&quot;usagewithreact&quot;&gt;connect it to a React app&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04bd1420551bdec742d2330183e8fe0464300fae" translate="yes" xml:space="preserve">
          <source>Now that you know how to do basic routing, you can learn more about &lt;a href=&quot;https://github.com/reactjs/react-router/tree/v3/docs/&quot;&gt;React Router API&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df198929b555d3f025b9f4c6dce1d531c1c5ab85" translate="yes" xml:space="preserve">
          <source>Now the &lt;code&gt;&amp;lt;App /&amp;gt;&lt;/code&gt; component will be rendered if the URL matches '/'. Additionally, we will add the optional &lt;code&gt;(:filter)&lt;/code&gt; parameter to &lt;code&gt;/&lt;/code&gt;, because we will need it further on when we try to read the parameter &lt;code&gt;(:filter)&lt;/code&gt; from the URL.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d916cc36e1dd4f19a7f89bff47aaabeb96451f9" translate="yes" xml:space="preserve">
          <source>Now the &lt;code&gt;todos&lt;/code&gt; part of the state looks like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d942270816eb39d5e0deb26630ac877f7158718d" translate="yes" xml:space="preserve">
          <source>Now we can rewrite the main reducer as a function that calls the reducers managing parts of the state, and combines them into a single object. It also doesn't need to know the complete initial state anymore. It's enough that the child reducers return their initial state when given &lt;code&gt;undefined&lt;/code&gt; at first.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a667ae6de0b7dc9eab910e5e9d0c63d6e4240965" translate="yes" xml:space="preserve">
          <source>Now you can add &lt;code&gt;UndoRedo&lt;/code&gt; component to the &lt;code&gt;App&lt;/code&gt; component:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2b05aac713becd3e746ad95aee7b78fc6182e91" translate="yes" xml:space="preserve">
          <source>Now you saw an example of what middleware can do in Redux, it's time to learn how it actually works, and how you can create your own. Go on to the next detailed section about &lt;a href=&quot;middleware&quot;&gt;Middleware&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65dfb2a3456a6347a253e5df887084ce9d5bc969" translate="yes" xml:space="preserve">
          <source>Now you'll be able to call them directly:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7d7d4bdf1f24961ac2cd4648199d9fca2b39f7d" translate="yes" xml:space="preserve">
          <source>Now, if user presses &amp;ldquo;Undo&amp;rdquo;, we want it to change to move into the past:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f0f0f51df5136b797764eade8b49d76aa9d3def" translate="yes" xml:space="preserve">
          <source>Now, the UI can be updated to reflect the new state. If you use bindings like &lt;a href=&quot;https://github.com/gaearon/react-redux&quot;&gt;React Redux&lt;/a&gt;, this is the point at which &lt;code&gt;component.setState(newState)&lt;/code&gt; is called.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="238539b34511566c52f015ab4f02c6eba84442e7" translate="yes" xml:space="preserve">
          <source>Now, the problem is what to put in the action creator and what in the reducer, the choice between fat and thin action objects. If you put all the logic in the action creator, you end up with fat action objects that basically declare the updates to the state. Reducers become pure, dumb, add-this, remove that, update these functions. They will be easy to compose. But not much of your business logic will be there. If you put more logic in the reducer, you end up with nice, thin action objects, most of your data logic in one place, but your reducers are harder to compose since you might need info from other branches. You end up with large reducers or reducers that take additional arguments from higher up in the state.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd811c18dfe3457c25b793431983374970c1dbff" translate="yes" xml:space="preserve">
          <source>Object spread lets us simplify the above &lt;code&gt;map&lt;/code&gt; call to:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2d82a77c6f21355d9167707cd08b4acf80faac7" translate="yes" xml:space="preserve">
          <source>Obviously, each layer of nesting makes this harder to read, and gives more chances to make mistakes. This is one of several reasons why you are encouraged to keep your state flattened, and compose reducers as much as possible.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99059fe3a8c10ea3a773517b2809c9d604ee1753" translate="yes" xml:space="preserve">
          <source>Obviously, trying to handle every possible action in a single function does not scale well, simply in terms of function size and readability, so it makes sense to split the actual work into separate functions that can be called by the top-level reducer. In particular, the common suggested pattern is to have a separate sub-reducer function that is responsible for managing updates to a particular slice of state at a specific key. The &lt;code&gt;combineReducers()&lt;/code&gt; that comes with Redux is one of the many possible ways to achieve this. It's also highly suggested to keep your store state as flat and as normalized as possible. Ultimately, though, you are in charge of organizing your reducer logic any way you want.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0cc135e616ba1be37c0cfabb241f9c97c73b5f08" translate="yes" xml:space="preserve">
          <source>On the client side, a new Redux store will be created and initialized with the state provided from the server.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6f42b17ddf866ba0ef881ccab2d5ac7ea6bba3a" translate="yes" xml:space="preserve">
          <source>On the server side, we simply wrap our existing code in the &lt;code&gt;fetchCounter&lt;/code&gt; and receive the result in the callback:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="abb297d24ed9dbaa92d7ae801845e13d9a8c7d96" translate="yes" xml:space="preserve">
          <source>On this page we will only feature a few of them that the Redux maintainers have vetted personally. Don't let this discourage you from trying the rest of them! The ecosystem is growing too fast, and we have a limited time to look at everything. Consider these the &amp;ldquo;staff picks&amp;rdquo;, and don't hesitate to submit a PR if you've built something wonderful with Redux.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00a57ab237ca0a42b345eb1574324e493eaac905" translate="yes" xml:space="preserve">
          <source>Once used, Immutable.JS will spread throughout your codebase</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e388b344448bc1c302e673361dcd29e30a20c835" translate="yes" xml:space="preserve">
          <source>Once you encapsulate your data with Immutable.JS, you have to use Immutable.JS&amp;rsquo;s &lt;code&gt;get()&lt;/code&gt; or &lt;code&gt;getIn()&lt;/code&gt; property accessors to access it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99e18cc195c97bd7e16b2c5c00f317c2ee608dad" translate="yes" xml:space="preserve">
          <source>One approach is to merge the contents of the action in to the existing state. In this case, we need to do a deep recursive merge, not just a shallow copy. The Lodash &lt;code&gt;merge&lt;/code&gt; function can handle this for us:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0a9b8df0f4b63915decda672bef5db25fe34cfb" translate="yes" xml:space="preserve">
          <source>One frequently asked question is whether Redux &quot;calls all reducers&quot; when dispatching an action. Since there really is only one root reducer function, the default answer is &quot;no, it does not&quot;. However, &lt;code&gt;combineReducers&lt;/code&gt; has specific behavior that &lt;em&gt;does&lt;/em&gt; work that way. In order to assemble the new state tree, &lt;code&gt;combineReducers&lt;/code&gt; will call each slice reducer with its current slice of state and the current action, giving the slice reducer a chance to respond and update its slice of state if needed. So, in that sense, using &lt;code&gt;combineReducers&lt;/code&gt;&lt;em&gt;does&lt;/em&gt; &quot;call all reducers&quot;, or at least all of the slice reducers it is wrapping.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4284542792cb9fd32437214931abfe8482da4b0" translate="yes" xml:space="preserve">
          <source>One neat trick is to use the &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Functions/default_parameters&quot;&gt;ES6 default arguments syntax&lt;/a&gt; to write this in a more compact way:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da5b8fcb37f2ad97d55411d18f4f50a8acf81489" translate="yes" xml:space="preserve">
          <source>One of the benefits of Redux is that it makes state changes predictable and transparent. Every time an action is dispatched, the new state is computed and saved. The state cannot change by itself, it can only change as a consequence of a specific action.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b05c40a81c382d7e1e4c5eb83c383c8c7dded6ae" translate="yes" xml:space="preserve">
          <source>One of the key advantages of immutability is that it enables shallow equality checking, which dramatically improves performance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="850c598dddd960ff8dafd82d078c789192dada81" translate="yes" xml:space="preserve">
          <source>Operating on JavaScript objects and arrays in an immutable way can be slow, particularly as your state tree grows larger.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af6c37b39bb6ed10d58088845d5a93da150bef3c" translate="yes" xml:space="preserve">
          <source>Operations like &quot;Look up all books by this author&quot; can then accomplished with a single loop over the join table. Given the typical amounts of data in a client application and the speed of Javascript engines, this kind of operation is likely to have sufficiently fast performance for most use cases.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d7d7275da2d9aaca178d7f0589e207de7175f18" translate="yes" xml:space="preserve">
          <source>Or check out the &lt;a href=&quot;https://codesandbox.io/s/github/reactjs/redux/tree/master/examples/async&quot;&gt;sandbox&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a59e4840cfb59b6c79325bf664a6e38968716f6" translate="yes" xml:space="preserve">
          <source>Or check out the &lt;a href=&quot;https://codesandbox.io/s/github/reactjs/redux/tree/master/examples/counter&quot;&gt;sandbox&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b1b65f5915920208d15bbc3e393183be7f4d31d" translate="yes" xml:space="preserve">
          <source>Or check out the &lt;a href=&quot;https://codesandbox.io/s/github/reactjs/redux/tree/master/examples/real-world&quot;&gt;sandbox&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e36463d35299a6a01ac3b467e7d9564b1281179e" translate="yes" xml:space="preserve">
          <source>Or check out the &lt;a href=&quot;https://codesandbox.io/s/github/reactjs/redux/tree/master/examples/shopping-cart&quot;&gt;sandbox&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b45aa8dcd97522495289719a1a18c6bc3300442" translate="yes" xml:space="preserve">
          <source>Or check out the &lt;a href=&quot;https://codesandbox.io/s/github/reactjs/redux/tree/master/examples/todomvc&quot;&gt;sandbox&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0e47b777f4c49cec0992d3e10c918d3a72df107" translate="yes" xml:space="preserve">
          <source>Or check out the &lt;a href=&quot;https://codesandbox.io/s/github/reactjs/redux/tree/master/examples/todos&quot;&gt;sandbox&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="238eb2632136a6f032d42bfad2c07321a67db57b" translate="yes" xml:space="preserve">
          <source>Or check out the &lt;a href=&quot;https://codesandbox.io/s/github/reactjs/redux/tree/master/examples/todos-with-undo&quot;&gt;sandbox&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6685195fe8e2bc04892759da1650e9052a5de4a3" translate="yes" xml:space="preserve">
          <source>Or check out the &lt;a href=&quot;https://codesandbox.io/s/github/reactjs/redux/tree/master/examples/tree-view&quot;&gt;sandbox&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8370968834196c749ed73b6cfe92801e8117ab54" translate="yes" xml:space="preserve">
          <source>Or many granular histories so user can undo and redo actions in them independently:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b392c8838a1573058a955eb668416b3dbbd0f9f" translate="yes" xml:space="preserve">
          <source>Or you can define separate types for them:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0da4144d426fe2efff7bea61cbf27a014d43a17" translate="yes" xml:space="preserve">
          <source>Organizing Large React Applications</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ca854d46781915131c4b8db35d1de91075f652b" translate="yes" xml:space="preserve">
          <source>Organizing Normalized Data in State</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34d16c8765f577c8baee06d396d90415855ba54d" translate="yes" xml:space="preserve">
          <source>Organizing State</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="077be78f1b3e88543b41122cb8c6c6f77f12b367" translate="yes" xml:space="preserve">
          <source>Other Approaches</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eebb2f9cdc2951c739e98100dec8f3363c3a726b" translate="yes" xml:space="preserve">
          <source>Other Components</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b72b54d734e499b1f158ae8c13378ee3157b18a" translate="yes" xml:space="preserve">
          <source>Other side effects like generating unique IDs or timestamps in a reducer also make the code unpredictable and harder to debug and test.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb937a0b9fb7519cc10c3b20032625261018ed28" translate="yes" xml:space="preserve">
          <source>Other than &lt;code&gt;type&lt;/code&gt;, the structure of an action object is really up to you. If you're interested, check out &lt;a href=&quot;https://github.com/acdlite/flux-standard-action&quot;&gt;Flux Standard Action&lt;/a&gt; for recommendations on how actions could be constructed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6536268ad716d89a65f56ced3b4cc69350c48fb9" translate="yes" xml:space="preserve">
          <source>Other than &lt;code&gt;type&lt;/code&gt;, the structure of an action object is really up to you. If you're interested, check out &lt;a href=&quot;https://github.com/acdlite/flux-standard-action&quot;&gt;Flux Standard Action&lt;/a&gt; for recommendations on how actions should be constructed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d77d9e8f5844c5c74da60395774b58f7d3f5387d" translate="yes" xml:space="preserve">
          <source>Others, like &lt;a href=&quot;https://github.com/kolodny/immutability-helper&quot;&gt;immutability-helper&lt;/a&gt; (a fork of the now-deprecated React Immutability Helpers addon), use nested values and helper functions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dda0bb30409a978c6095e977bd09a407e7ec0ccd" translate="yes" xml:space="preserve">
          <source>Our app reducer is still aware of all the different cases for our application. Let's try splitting things up so that the filter logic and the todo logic are separated:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57d76ff70a2b8d5f74ef5118abd52ad01b3bb657" translate="yes" xml:space="preserve">
          <source>Our design brief is simple. We want to show a list of todo items. On click, a todo item is crossed out as completed. We want to show a field where the user may add a new todo. In the footer, we want to show a toggle to show all, only completed, or only active todos.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53d2ee76615e0933562a889f329ff05a0a727e4c" translate="yes" xml:space="preserve">
          <source>Overall, Redux-ORM provides a very useful set of abstractions for defining relations between data types, creating the &quot;tables&quot; in our state, retrieving and denormalizing relational data, and applying immutable updates to relational data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31d482d1d287457cca90cae82978407bee745dc3" translate="yes" xml:space="preserve">
          <source>PDF: JavaScript Immutability - Don&amp;rsquo;t go changing</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a975eea30db9fa05003e3b5097688bd49ec7e01b" translate="yes" xml:space="preserve">
          <source>Parameters</source>
          <target state="translated">Parameters</target>
        </trans-unit>
        <trans-unit id="430ea9730cf326c3cf262aa3e00acbc94a6af33d" translate="yes" xml:space="preserve">
          <source>Passing the Store</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="acae9ab8b8cf95f09e38c1fb61c7e7375972f22f" translate="yes" xml:space="preserve">
          <source>Patrons</source>
          <target state="translated">Patrons</target>
        </trans-unit>
        <trans-unit id="d9b870a4eca18252d7bd7d9da857129a2bd3ed18" translate="yes" xml:space="preserve">
          <source>Perform side effects like API calls and routing transitions;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63c904559993935c470f516c8b549ca7f3640dbb" translate="yes" xml:space="preserve">
          <source>Performance</source>
          <target state="translated">Performance</target>
        </trans-unit>
        <trans-unit id="09c0613fe519089a7fc506820537146b438f0dc9" translate="yes" xml:space="preserve">
          <source>Pete Hunt, one of the early contributors to React, says:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="518776dd7f483eb0d4df7b1bd43c6cdb73104192" translate="yes" xml:space="preserve">
          <source>Poor Performance</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9993816052f22041086b70cb5e1a32b14dfbb33d" translate="yes" xml:space="preserve">
          <source>Practical Redux, Part 6: Connected Lists, Forms, and Performance</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="738c6f9450a7465416076aa7cb2f7dbc8ca7bcb4" translate="yes" xml:space="preserve">
          <source>Preparing the Initial State</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02510af1c9e56dc9bd70dc87dc84e81b435ad642" translate="yes" xml:space="preserve">
          <source>Prerequisite Concepts</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69ac187c979012e887601c19566c66ee6ab15258" translate="yes" xml:space="preserve">
          <source>Prerequisite Concepts for Writing Reducers</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c55cdda21f1ad5ea1b98437db0236145dd69099" translate="yes" xml:space="preserve">
          <source>Prerequisite Reducer Concepts</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3ed0c728475ae7dfeea9ed4c1bc0af7c27941d6" translate="yes" xml:space="preserve">
          <source>Presentational Components</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69e7885b45c24e48f26b3abc065d13744594de0a" translate="yes" xml:space="preserve">
          <source>Presentational and Container Components</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f184d44b598b788adde29d493e92a5c25b0ed0b5" translate="yes" xml:space="preserve">
          <source>Prior Art</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9cb3636454de25708139a72d5a8daebcbab292a1" translate="yes" xml:space="preserve">
          <source>Problem: Crash Reporting</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4367434447e2cee1f6e98eeb1e8d7bc393e9ff67" translate="yes" xml:space="preserve">
          <source>Problem: Logging</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55ebe517b50c8c6c3d52435b9681b506cd9eed36" translate="yes" xml:space="preserve">
          <source>Processing Request Parameters</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71d526269be49e8a2200a08466e2a7f151fbcce6" translate="yes" xml:space="preserve">
          <source>Pros and Cons of Using Immutability With React</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4be452a463fb3cf62c5a4a03fdd906246f9e80cd" translate="yes" xml:space="preserve">
          <source>Pros and Cons of Using Immutability with React</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc98b8947b98b64aa54d5357f558ae0935c47d87" translate="yes" xml:space="preserve">
          <source>Pros and Cons of using immutability with React.js</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6e73fb000c8b75a17c1069b0079cbf4bdde15b6" translate="yes" xml:space="preserve">
          <source>Pros and Cons of using immutability with React.js - React Kung Fu</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21cf88ab38b25368d2f9cb3c579e6a17bc644483" translate="yes" xml:space="preserve">
          <source>Pure Functions and Side Effects</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86a07cd587b106a4018fbf8dbee2dbdcf791f1eb" translate="yes" xml:space="preserve">
          <source>Pure functionality and side effects in Redux</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82a325d136b15dd1db828b5e748b6d37453db386" translate="yes" xml:space="preserve">
          <source>Pure functions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0fb821bdaf93ed9a1f1e920acfb2840eff5b153" translate="yes" xml:space="preserve">
          <source>Purpose</source>
          <target state="translated">Purpose</target>
        </trans-unit>
        <trans-unit id="ea644ff66049122da6969531a96ca0fe72184b08" translate="yes" xml:space="preserve">
          <source>Querying a Redux Store</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55075a14cfbfc51a035aba7e61a80df40309acdd" translate="yes" xml:space="preserve">
          <source>Rails-style: separate folders for &amp;ldquo;actions&amp;rdquo;, &amp;ldquo;constants&amp;rdquo;, &amp;ldquo;reducers&amp;rdquo;, &amp;ldquo;containers&amp;rdquo;, and &amp;ldquo;components&amp;rdquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45a38418ad120f3d535295f729a198b3b7c6c8d7" translate="yes" xml:space="preserve">
          <source>React Boilerplate #27: Application Structure</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="efc78471488cf3d2e323b930c4ab2275310bd60b" translate="yes" xml:space="preserve">
          <source>React Forums: Redux and global state vs local state</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="214641af7b84dcf096934eb2a695cb6d024aae3a" translate="yes" xml:space="preserve">
          <source>React Higher Order Components in depth</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01d8e1cb3dcc43b6aac331fa4ddc4ac02aff9465" translate="yes" xml:space="preserve">
          <source>React How-To</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c00f59a0285f84558e8d0d48133c22e6b6f706e6" translate="yes" xml:space="preserve">
          <source>React Redux</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9ec3cce75743443bbba2142d270fc34d79b7599" translate="yes" xml:space="preserve">
          <source>React Redux #145: consider always passing down dispatch regardless of what mapDispatchToProps does</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="732e7a5dfabaa54435e980f9e805a54c93e2dd29" translate="yes" xml:space="preserve">
          <source>React Redux #235: Predicate function for updating component</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01a98dba508a8efb62a16078cc6efb83597ba734" translate="yes" xml:space="preserve">
          <source>React Redux #255: this.props.dispatch is undefined if using mapDispatchToProps</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="287e83661d0b0ace70aa4b2e7cbc6e6a0b50d186" translate="yes" xml:space="preserve">
          <source>React Redux #263: Huge performance issue when dispatching hundreds of actions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2aea4e5f490054875b5d85d349369a3658b249ef" translate="yes" xml:space="preserve">
          <source>React Redux #269: Connect could be used with a custom subscribe method</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bbdb52200c9c3640fa284dd7801b308c292acc73" translate="yes" xml:space="preserve">
          <source>React Redux #291: Should mapStateToProps be called every time an action is dispatched?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca17da9174a409f3ef37d08c9748a93925d108fc" translate="yes" xml:space="preserve">
          <source>React Redux #407: Rewrite connect to offer an advanced API</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e611799527e4e43143ed34634f793cd5a162cf1" translate="yes" xml:space="preserve">
          <source>React Redux #416: Rewrite connect for better performance and extensibility</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f31b465a1a05e3ab0e22b96c59d09ee25c33ef2" translate="yes" xml:space="preserve">
          <source>React Redux #89: can i wrap multi actionCreators into one props with name?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa04ceff7eca5e570aecaefd3ee71f236ce6eb9f" translate="yes" xml:space="preserve">
          <source>React Redux API: connect()</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5fffe16c96023bbe3dd9abec1447678a45a147c0" translate="yes" xml:space="preserve">
          <source>React Redux implements several optimizations to ensure your actual component only re-renders when actually necessary. One of those is a shallow equality check on the combined props object generated by the &lt;code&gt;mapStateToProps&lt;/code&gt; and &lt;code&gt;mapDispatchToProps&lt;/code&gt; arguments passed to &lt;code&gt;connect&lt;/code&gt;. Unfortunately, shallow equality does not help in cases where new array or object instances are created each time &lt;code&gt;mapStateToProps&lt;/code&gt; is called. A typical example might be mapping over an array of IDs and returning the matching object references, such as:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b3923afd4f9b76fbadb161e5309fe47c5935c89" translate="yes" xml:space="preserve">
          <source>React Redux: Troubleshooting</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7cf84f305d9b4ae3d2e5899504cef59f17174eb6" translate="yes" xml:space="preserve">
          <source>React Router comes with a &lt;a href=&quot;https://github.com/ReactTraining/react-router/blob/v3/docs/API.md#link&quot;&gt;&lt;code&gt;&amp;lt;Link /&amp;gt;&lt;/code&gt;&lt;/a&gt; component that lets you navigate around your application. In our example, we can wrap &lt;code&gt;&amp;lt;Link /&amp;gt;&lt;/code&gt; with a new container component &lt;code&gt;&amp;lt;FilterLink /&amp;gt;&lt;/code&gt; so as to dynamically change the URL. The &lt;code&gt;activeStyle={}&lt;/code&gt; property lets us apply a style on the active state.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="679ef62ec4985a413831aad6d5f132c1e1b0074f" translate="yes" xml:space="preserve">
          <source>React bindings for Redux embrace the idea of &lt;strong&gt;separating presentational and container components&lt;/strong&gt;. If you're not familiar with these terms, &lt;a href=&quot;https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0&quot;&gt;read about them first&lt;/a&gt;, and then come back. They are important, so we'll wait!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd703ea889752160be52204476a7e5217587c640" translate="yes" xml:space="preserve">
          <source>React-Redux Bindings</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="720534ae4ea5a2a18f4bb7bfe9ed16ef3bef02de" translate="yes" xml:space="preserve">
          <source>React-Redux performs a shallow equality check on on each &lt;em&gt;value&lt;/em&gt; within the props object, not on the props object itself.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a3b307a7afe13dcc2d2b56d385f6e7fcdd89e12" translate="yes" xml:space="preserve">
          <source>React-Redux therefore maintains separate references to each &lt;em&gt;value&lt;/em&gt; in the returned props object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a84961e51f0e9045534f55ef19c9b890ec0454dc" translate="yes" xml:space="preserve">
          <source>React-Redux uses shallow equality checking to determine whether the component it&amp;rsquo;s wrapping needs to be re-rendered.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25f69fafc4d53ef37a01d27855717f1b910c32ee" translate="yes" xml:space="preserve">
          <source>React-Redux's &lt;code&gt;connect&lt;/code&gt; method generates components that &lt;a href=&quot;#how-react-redux-uses-shallow-checking&quot;&gt;shallowly check reference changes to the root state&lt;/a&gt;, and the return values from the &lt;code&gt;mapStateToProps&lt;/code&gt; function to see if the wrapped components actually need to re-render. Such &lt;a href=&quot;#redux-shallow-checking-requires-immutability&quot;&gt;shallow checking requires immutability&lt;/a&gt; to function correctly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f4f4a56fd030dcfc889dad10f3ba7abdeb9bf09" translate="yes" xml:space="preserve">
          <source>React.js Pure Render Performance Anti-Pattern</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="efcf558b2b7ed1ce931d4bbaf10d10e4a81b9190" translate="yes" xml:space="preserve">
          <source>React.js pure render performance anti-pattern</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6c84930df2d0caae45068e630cc45ccf1245b86" translate="yes" xml:space="preserve">
          <source>React/Redux Links: &quot;Redux Side Effects&quot; category</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7b97ce28bebc20ce4023d4d1544d8ca708ac055" translate="yes" xml:space="preserve">
          <source>React/Redux Links: Architecture - Project File Structure</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="799adc6d5d994e504c2c138e4ff53248644d5147" translate="yes" xml:space="preserve">
          <source>React/Redux Links: Architecture - Redux Architecture</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f700891537e9332e39007ef543a0c7005ac696ee" translate="yes" xml:space="preserve">
          <source>React/Redux Links: Immutable Data</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fce00908db372392230a5dc59966f0556c9a96b3" translate="yes" xml:space="preserve">
          <source>React/Redux Links: Performance - Redux</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea6624400dd0619a4028a0782161b341f95b9bf3" translate="yes" xml:space="preserve">
          <source>React/Redux Links: Performance - Redux Performance</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11abaa387b4e1d4c6df486f331bca1593b96648d" translate="yes" xml:space="preserve">
          <source>React/Redux Links: React/Redux Performance</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86308254ca58c32a4b48e2e7a927c0057319908d" translate="yes" xml:space="preserve">
          <source>React: Higher-Order Components</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d90bde2bec2c8fa094a1d2200ae82033494cad5" translate="yes" xml:space="preserve">
          <source>React: Optimizing Performance</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d9c1b09aeb1d155202a538eba6d9a3492931ad1" translate="yes" xml:space="preserve">
          <source>Read &lt;a href=&quot;asyncflow&quot;&gt;Async Flow&lt;/a&gt; to recap how async actions fit into the Redux flow.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b607ca1ed943113b8bd40acd28ee479c753558db" translate="yes" xml:space="preserve">
          <source>Read data from props</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99172ffcab6825648dfba7e3fc262a9a5fbe7648" translate="yes" xml:space="preserve">
          <source>Read the &lt;a href=&quot;exampletodolist&quot;&gt;complete source code for this tutorial&lt;/a&gt; to better internalize the knowledge you have gained. Then, head straight to the &lt;a href=&quot;../advanced/index&quot;&gt;advanced tutorial&lt;/a&gt; to learn how to handle network requests and routing!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b21e1ed4d5217309315f564ff74b9eea1936e93c" translate="yes" xml:space="preserve">
          <source>Reading From the URL</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="095c451a2e9ce2021d38bf795774b05403fc75f1" translate="yes" xml:space="preserve">
          <source>Real World</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a49698c20a1d19a475a3edf8be8f8f8b30ec65ca" translate="yes" xml:space="preserve">
          <source>Recap</source>
          <target state="translated">Recap</target>
        </trans-unit>
        <trans-unit id="9fb1092f32d4fcbf9e061ffd718d4ec689c6c95e" translate="yes" xml:space="preserve">
          <source>Recipes</source>
          <target state="translated">Recipes</target>
        </trans-unit>
        <trans-unit id="42624a20e6e4c1562537410bf82ff591ce07f160" translate="yes" xml:space="preserve">
          <source>Recipes: Computed Derived Data</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6d39d52a5e86324ade1d44e7e08ce0b5387e017" translate="yes" xml:space="preserve">
          <source>Recipes: Computing Derived Data</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5effb0f63ab3eb21c89f18e6368e7c1d5f17c3ac" translate="yes" xml:space="preserve">
          <source>Recipes: Immutable Update Patterns</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cbeb9b0f5422b15a6d088c47aaf6e528d0350c4c" translate="yes" xml:space="preserve">
          <source>Recipes: Prerequisite Reducer Concepts</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49a1f34779a5afe85e05cff662577501366300bb" translate="yes" xml:space="preserve">
          <source>Recipes: Reducing Boilerplate</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c1f469e59e4322a9cb07ef58ade84919608d01c" translate="yes" xml:space="preserve">
          <source>Recipes: Structuring Reducers</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29196f40d836acaf77c762f6f7580bf65b85cab3" translate="yes" xml:space="preserve">
          <source>Recipes: Structuring Reducers - Immutable Update Patterns</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb76eaeb79f5b86547d0360e4948f5f88d59b72d" translate="yes" xml:space="preserve">
          <source>Recipes: Structuring Reducers - Normalizing State Shape</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9e51b9812b2e58af4823344e551de6481db8b1b" translate="yes" xml:space="preserve">
          <source>Recipes: Structuring Reducers - Prerequisite Concepts</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8db7ccea3429c3219a46b29a7fb105658ffffce" translate="yes" xml:space="preserve">
          <source>Recipes: Structuring Reducers - Splitting Reducer Logic</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e29b3bc65e2933e5a918d6357b2967374e89998f" translate="yes" xml:space="preserve">
          <source>Recipes: Using the Object Spread Operator</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b66d7a1f117e84d49ce190a144bfa4013537819" translate="yes" xml:space="preserve">
          <source>Recipes: immutability, side effects and mutation</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0284a396b98e7ed88f256c52e6515c77bb1b45d" translate="yes" xml:space="preserve">
          <source>Reddit: &quot;When should I put something into my Redux store?&quot;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="daca44adc4ef60f42583641246276d004e688c4b" translate="yes" xml:space="preserve">
          <source>Reddit: Help designing Redux state for a single page app</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="afe887e317c898f703e24f7d827235e7f21d4918" translate="yes" xml:space="preserve">
          <source>Reddit: Help performing Async API calls with Redux-Promise Middleware.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15ccb05f9d496bf9727d87cee8b1f71f8bdbfba0" translate="yes" xml:space="preserve">
          <source>Reddit: Large open source react/redux projects?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31b5fcaedfa00391f0da82305fa9d9c465e145ba" translate="yes" xml:space="preserve">
          <source>Reddit: React/Redux for Ultra Large Scale apps</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc41eb745ff0afdeef230ca621cfd49d330d77d6" translate="yes" xml:space="preserve">
          <source>Reddit: Redux performance issues with a large state object?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad1dcdbc206f62d81049e1fbbc24d1b99f39b065" translate="yes" xml:space="preserve">
          <source>Reddit: What's the best place to keep initial state?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="216d6244581ce722d2b213f82dbff87a6148139c" translate="yes" xml:space="preserve">
          <source>Reddit: What's the best place to keep the initial state?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6473c3e5bd0f3e386d368c764bc6cec02354577e" translate="yes" xml:space="preserve">
          <source>Reddit: Why Redux Needs Reducers To Be Pure Functions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05ce1169a192ae766ca0f1d7c50a759c7c51974e" translate="yes" xml:space="preserve">
          <source>Reddit: You don't need Redux if your app just fetches something on a single page</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cffbc53fcadf1ea0dddef2d232230038efb6dd3c" translate="yes" xml:space="preserve">
          <source>Reddit: acemarke and cpsubrian comments on Dan Abramov: Redux is not an architecture or design pattern, it is just a library.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59ce6f6beebd57025f07ecd7d9c06fc4781ffca1" translate="yes" xml:space="preserve">
          <source>Reducer</source>
          <target state="translated">Reducer</target>
        </trans-unit>
        <trans-unit id="1b526057cc1ef5812f4ada08c7de94063561f436" translate="yes" xml:space="preserve">
          <source>Reducer Concepts and Techniques</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dda31a027bfa36f4ca8585837d08aaa1912d41bf" translate="yes" xml:space="preserve">
          <source>Reducers</source>
          <target state="translated">Reducers</target>
        </trans-unit>
        <trans-unit id="840f7767cb01214ba0a12025998a85422ab6e283" translate="yes" xml:space="preserve">
          <source>Reducers are just pure functions that take the previous state and an action, and return the next state. Remember to return new state objects, instead of mutating the previous state. You can start with a single reducer, and as your app grows, split it off into smaller reducers that manage specific parts of the state tree. Because reducers are just functions, you can control the order in which they are called, pass additional data, or even make reusable reducers for common tasks such as pagination.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96a29cc7551675123cb7f5294dd805e57df90ca1" translate="yes" xml:space="preserve">
          <source>Reducers are not unique to Redux&amp;mdash;they are a fundamental concept in functional programming. Even most non-functional languages, like JavaScript, have a built-in API for reducing. In JavaScript, it's &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce&quot;&gt;&lt;code&gt;Array.prototype.reduce()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="693d4ec3dd35d12c94a5cb25d408b2e71be3d5b1" translate="yes" xml:space="preserve">
          <source>Reducers are the most important concept in Redux.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="493c42af719ab1cd4cc31be798bcf7e6648293eb" translate="yes" xml:space="preserve">
          <source>Reducing Boilerplate</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a5dd83d686967dbee491e598c66e203e42c8bea" translate="yes" xml:space="preserve">
          <source>Redux</source>
          <target state="translated">Redux</target>
        </trans-unit>
        <trans-unit id="ec290bd2917cc3416af368d34f3c085a675f09e6" translate="yes" xml:space="preserve">
          <source>Redux Addons Catalog: Component State</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8290cc030aab4b8babf95fab40608d602458690f" translate="yes" xml:space="preserve">
          <source>Redux Addons Catalog: DevTools - Component Update Monitoring</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f07485fcebaac4a393292df3922516fc30d4bbca" translate="yes" xml:space="preserve">
          <source>Redux Addons Catalog: Store - Change Subscriptions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a577b901e78ea650452597a6b1059b8084d2ebcb" translate="yes" xml:space="preserve">
          <source>Redux Addons Catalog: Store Change Subscriptions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6d683688573717dedb09bb8c524dd092308d6bd" translate="yes" xml:space="preserve">
          <source>Redux Addons Catalog: Use Cases - Authentication</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9344d1305fa4b38f64ad8cebd9635fa2921b0e1a" translate="yes" xml:space="preserve">
          <source>Redux Best Practices</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bfac34990e02b9e66cd0d6829d754be59da6a26f" translate="yes" xml:space="preserve">
          <source>Redux Docs: &lt;code&gt;combineReducers&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="114c170f090803b3e9b2bcc5c3a6e50beaeed134" translate="yes" xml:space="preserve">
          <source>Redux Docs: Implementing Undo History</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e6cb1adf2efb90cb6a27ea6a72f98f7ab473f85" translate="yes" xml:space="preserve">
          <source>Redux Docs: Reducers</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d40a9cd844cea91b94b47ac94fa5330e9011c46" translate="yes" xml:space="preserve">
          <source>Redux Docs: Reducing Boilerplate</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="726708480591ce54144dc3645deedfceb6e02a27" translate="yes" xml:space="preserve">
          <source>Redux Docs: Using the Object Spread Operator</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43b86674da50a6ae9dfb143b4ed6cba4221221fc" translate="yes" xml:space="preserve">
          <source>Redux Egghead Course Notes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4428f96db39ca62c1587ebeaa693e35a74b127e5" translate="yes" xml:space="preserve">
          <source>Redux FAQ</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d41715c0d155a118b9497d660d8d8ce21d26b4a2" translate="yes" xml:space="preserve">
          <source>Redux FAQ - How do I share state between two reducers? do I have to use &lt;code&gt;combineReducers&lt;/code&gt;?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c491bee4fced1d7081108b5ad804a138bbbbd52e" translate="yes" xml:space="preserve">
          <source>Redux FAQ: Actions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4e401fc452061ae23c6d3ded639c0139571e70a" translate="yes" xml:space="preserve">
          <source>Redux FAQ: Code Structure</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9dd7213b027596f3629ad531290ad9920e77526" translate="yes" xml:space="preserve">
          <source>Redux FAQ: General</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d53c1155526d25e48dcd19338cae9548715d564" translate="yes" xml:space="preserve">
          <source>Redux FAQ: Immutable Data</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af79a6a6e3a5246c79d316570a87b7cf700c435e" translate="yes" xml:space="preserve">
          <source>Redux FAQ: Miscellaneous</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac2ba19db266451829b5648e7675c23413cb2290" translate="yes" xml:space="preserve">
          <source>Redux FAQ: Organizing State</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b775beb138a1c3fb7195b5b0df10ccb6b82fa87d" translate="yes" xml:space="preserve">
          <source>Redux FAQ: Performance</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5b614caad88c44f368607bba25481b521bd85c6" translate="yes" xml:space="preserve">
          <source>Redux FAQ: React Redux</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef49df474a3cc851a7439d8e67a8e396e5ccf5d5" translate="yes" xml:space="preserve">
          <source>Redux FAQ: Reducers</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24a41d53bd26e4da6f09186f3361b234ecd45560" translate="yes" xml:space="preserve">
          <source>Redux FAQ: Store Setup</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0102181826c0cb7d859681534988eee33484e834" translate="yes" xml:space="preserve">
          <source>Redux Patterns and Anti-Patterns</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e73b59699c981c999e9ca3504f30fe27527addd7" translate="yes" xml:space="preserve">
          <source>Redux Reducer Basics</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56891cb67a23a2b058baaee611e9e76e2ced8ffb" translate="yes" xml:space="preserve">
          <source>Redux Reducer/Selector Asymmetry</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7f6bdcedeb4f02ba8baec4a6f623462b01e41d1" translate="yes" xml:space="preserve">
          <source>Redux Side-Effects and You</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec9ae2589e9681b8d5b9a2330255a41898aa3398" translate="yes" xml:space="preserve">
          <source>Redux Tutorial</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6c0eff7c8b338ccc1a25decaa770c2ce1222c1c" translate="yes" xml:space="preserve">
          <source>Redux Without Profanity: Normalizr</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37f4f3e1befc5ff99eacec66375e5105a07bde1d" translate="yes" xml:space="preserve">
          <source>Redux architecture revolves around a &lt;strong&gt;strict unidirectional data flow&lt;/strong&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca8fd39e0f583c4771e3b7ab47147f9b7250d1ac" translate="yes" xml:space="preserve">
          <source>Redux assumes that you never mutate the objects it gives to you in the reducer. &lt;strong&gt;Every single time, you must return the new state object.&lt;/strong&gt; Even if you don't use a library like &lt;a href=&quot;https://facebook.github.io/immutable-js/&quot;&gt;Immutable&lt;/a&gt;, you need to completely avoid mutation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9b13f4fc65014317fe6e4b9892befedf11af3bc" translate="yes" xml:space="preserve">
          <source>Redux can be described in three fundamental principles:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="325d0a3329fe90a45278bb0a0417bd084002d235" translate="yes" xml:space="preserve">
          <source>Redux can be used as a data store for any UI layer. The most common usage is with React and React Native, but there are bindings available for Angular, Angular 2, Vue, Mithril, and more. Redux simply provides a subscription mechanism which can be used by any other code. That said, it is most useful when combined with a declarative view implementation that can infer the UI updates from the state changes, such as React or one of the similar libraries available.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b52d3f31e7f26a9796dbdf1e3a68c3e4fb5e3992" translate="yes" xml:space="preserve">
          <source>Redux does not store a history of actions itself. However, the Redux DevTools do store actions so they can be replayed, but those are generally only enabled during development, and not used in production.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5dbbf7352cc48a4f94b3a8d8faa33290b580cd67" translate="yes" xml:space="preserve">
          <source>Redux encourages you to think about your application in terms of the data you need to manage. The data at any given point in time is the &quot;&lt;em&gt;state&lt;/em&gt;&quot; of your application, and the structure and organization of that state is typically referred to as its &quot;&lt;em&gt;shape&lt;/em&gt;&quot;. The shape of your state plays a major role in how you structure your reducer logic.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0516f1b49c0332831cef6d046aead301f5a49142" translate="yes" xml:space="preserve">
          <source>Redux evolves the ideas of &lt;a href=&quot;http://facebook.github.io/flux/&quot;&gt;Flux&lt;/a&gt;, but avoids its complexity by taking cues from &lt;a href=&quot;https://github.com/evancz/elm-architecture-tutorial/&quot;&gt;Elm&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3d9d039526eff2bcbbc1e2bb2c6ef489f1116bd" translate="yes" xml:space="preserve">
          <source>Redux has a mixed heritage. It is similar to some patterns and technologies, but is also different from them in important ways. We'll explore some of the similarities and the differences below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08c2c8d16a217b7f149595bcdd911d990cf837d5" translate="yes" xml:space="preserve">
          <source>Redux is a predictable state container for JavaScript apps.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1658730b992fc25b0e570963398f980bbbac8597" translate="yes" xml:space="preserve">
          <source>Redux is a tiny library, but its contracts and APIs are carefully chosen to spawn an ecosystem of tools and extensions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0def49afc1d69e709f05c3918091a08540604e3" translate="yes" xml:space="preserve">
          <source>Redux is distributed with a few examples in its &lt;a href=&quot;https://github.com/reactjs/redux/tree/master/examples&quot;&gt;source code&lt;/a&gt;. Most of these examples are also on &lt;a href=&quot;https://codesandbox.io&quot;&gt;CodeSandbox&lt;/a&gt;, this is an online editor that lets you play with the examples online.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2bc1ca81429d291e4da182d33067adbc2146a5ff" translate="yes" xml:space="preserve">
          <source>Redux is in part &lt;a href=&quot;../introduction/priorart&quot;&gt;inspired by Flux&lt;/a&gt;, and the most common complaint about Flux is how it makes you write a lot of boilerplate. In this recipe, we will consider how Redux lets us choose how verbose we'd like our code to be, depending on personal style, team preferences, longer term maintainability, and so on.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ca9a51778106939cd3dfebf9551abdc4b16988e" translate="yes" xml:space="preserve">
          <source>Redux is inspired by functional programming, and out of the box, has no place for side effects to be executed. In particular, reducer functions &lt;em&gt;must&lt;/em&gt; always be pure functions of &lt;code&gt;(state, action) =&amp;gt; newState&lt;/code&gt;. However, Redux's middleware makes it possible to intercept dispatched actions and add additional complex behavior around them, including side effects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e51cf296aaae20f776d432b753a50cb2d012fba" translate="yes" xml:space="preserve">
          <source>Redux is not a monolithic framework, but a set of contracts and a &lt;a href=&quot;../api/index&quot;&gt;few functions that make them work together&lt;/a&gt;. The majority of your &amp;ldquo;Redux code&amp;rdquo; will not even use Redux APIs, as most of the time you'll be writing functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5fa50b0cdd3b8374bae86ce4f34e3e66331618ca" translate="yes" xml:space="preserve">
          <source>Redux is originally written in ES6 and transpiled for production into ES5 with Webpack and Babel. You should be able to use it regardless of your JavaScript build process. Redux also offers a UMD build that can be used directly without any build process at all. The &lt;a href=&quot;https://github.com/reactjs/redux/tree/master/examples/counter-vanilla&quot;&gt;counter-vanilla&lt;/a&gt; example demonstrates basic ES5 usage with Redux included as a &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; tag. As the relevant pull request says:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34fee0109b88a277c57526193a6d212f3a10d90d" translate="yes" xml:space="preserve">
          <source>Redux itself is very simple.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42dce762d39e68e2336c77e1bc865792d15451f7" translate="yes" xml:space="preserve">
          <source>Redux may not be as efficient out of the box when compared to other libraries. For maximum rendering performance in a React application, state should be stored in a normalized shape, many individual components should be connected to the store instead of just a few, and connected list components should pass item IDs to their connected child list items (allowing the list items to look up their own data by ID). This minimizes the overall amount of rendering to be done. Use of memoized selector functions is also an important performance consideration.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d50c81abd53c840945ee2fdbaa44b7467c60100" translate="yes" xml:space="preserve">
          <source>Redux middleware act like a linked list. Each middleware function can either call &lt;code&gt;next(action)&lt;/code&gt; to pass an action along to the next middleware in line, call &lt;code&gt;dispatch(action)&lt;/code&gt; to restart the processing at the beginning of the list, or do nothing at all to stop the action from being processed further.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66a12ac42dd9b817c0a1c7e67e3311842a1c46e9" translate="yes" xml:space="preserve">
          <source>Redux middleware solves different problems than Express or Koa middleware, but in a conceptually similar way. &lt;strong&gt;It provides a third-party extension point between dispatching an action, and the moment it reaches the reducer.&lt;/strong&gt; People use Redux middleware for logging, crash reporting, talking to an asynchronous API, routing, and more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63d4a8adb65aae837c51967b76d09fff2ff98328" translate="yes" xml:space="preserve">
          <source>Redux notifies subscribers after each successfully dispatched action (i.e. an action reached the store and was handled by reducers). In some cases, it may be useful to cut down on the number of times subscribers are called, particularly if an action creator dispatches multiple distinct actions in a row.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e36bd6fb2ddfb9b618b443d363e9df585734103" translate="yes" xml:space="preserve">
          <source>Redux on the Server</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="321a21760687e7864fd03dec217ad326b52df5ef" translate="yes" xml:space="preserve">
          <source>Redux provides a single &lt;code&gt;store.subscribe&lt;/code&gt; method for notifying listeners that the store has updated. Listener callbacks do not receive the current state as an argument&amp;mdash;it is simply an indication that &lt;em&gt;something&lt;/em&gt; has changed. The subscriber logic can then call &lt;code&gt;getState()&lt;/code&gt; to get the current state value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4319c52fd7a20695a4bdd02b2e2cc58d73b86bdf" translate="yes" xml:space="preserve">
          <source>Redux puts some basic constraints on how that write logic function should work. As described in &lt;a href=&quot;../basics/reducers&quot;&gt;Reducers&lt;/a&gt;, it has to have a signature of &lt;code&gt;(previousState, action) =&amp;gt; newState&lt;/code&gt;, is known as a &lt;strong&gt;&lt;em&gt;reducer function&lt;/em&gt;&lt;/strong&gt;, and must be &lt;em&gt;pure&lt;/em&gt; and predictable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59977664d77ebcee933d545dac412554294aeaf2" translate="yes" xml:space="preserve">
          <source>Redux reduces the boilerplate of Flux stores considerably by describing the update logic as a function. A function is simpler than an object, and much simpler than a class.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="402da21959ad1b00c3d1ab6f8adf5613dbe09688" translate="yes" xml:space="preserve">
          <source>Redux uses shallow equality checking in its &lt;code&gt;combineReducers&lt;/code&gt; function to return either a new mutated copy of the root state object, or, if no mutations have been made, the current root state object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc4318e83cc01aa898dd245b381a161bc5966ecd" translate="yes" xml:space="preserve">
          <source>Redux vs MobX TodoMVC Benchmark: #1</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ad6e121085cd64eb499597e7144d3ad136b11ac" translate="yes" xml:space="preserve">
          <source>Redux was inspired by several important qualities of Flux. Like Flux, Redux prescribes that you concentrate your model update logic in a certain layer of your application (&amp;ldquo;stores&amp;rdquo; in Flux, &amp;ldquo;reducers&amp;rdquo; in Redux). Instead of letting the application code directly mutate the data, both tell you to describe every mutation as a plain object called an &amp;ldquo;action&amp;rdquo;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fdbb1f1c5606597f48f095414e66742812988218" translate="yes" xml:space="preserve">
          <source>Redux's &lt;code&gt;combineReducers&lt;/code&gt; utility &lt;a href=&quot;#how-redux-uses-shallow-checking&quot;&gt;shallowly checks for reference changes&lt;/a&gt; caused by the reducers that it calls.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88595cd44ffbc83a4871c93314b71b115c573390" translate="yes" xml:space="preserve">
          <source>Redux's &lt;strong&gt;&lt;em&gt;only&lt;/em&gt;&lt;/strong&gt; job on the server side is to provide the &lt;strong&gt;initial state&lt;/strong&gt; of our app.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7eb32f60e5c70f3bc2c26ceb6005796e8b88abe" translate="yes" xml:space="preserve">
          <source>Redux's use of shallow equality checking requires immutability if any connected components are to be updated correctly. To see why, we need to understand the difference between shallow and deep equality checking in JavaScript.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="143302841cb0d7dca0440bc31869328f76d81e32" translate="yes" xml:space="preserve">
          <source>Redux-ORM</source>
          <target state="translated">Redux-ORM</target>
        </trans-unit>
        <trans-unit id="7367376eab7e449568c0adff1f6f05f157d89179" translate="yes" xml:space="preserve">
          <source>Reduxible #8: Reducers and action creators aren't a one-to-one mapping</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ccd2c30250c1777fda07e84c391cdb978d5d1e8" translate="yes" xml:space="preserve">
          <source>Refactoring Reducer Logic Using Functional Decomposition and Reducer Composition</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b4c884acfadf4ccd7e8f7f80505e0cb44517215" translate="yes" xml:space="preserve">
          <source>Refactoring Reducers Example</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0710cd8e6f7d93aaa10c5bd0b7c50d5a6a0ac74" translate="yes" xml:space="preserve">
          <source>Referring to items by IDs</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="35a045863630981b0a8f647ab7457dcd879ee624" translate="yes" xml:space="preserve">
          <source>Regardless of the specific data type, the shape of the undo history state is the same:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c899eec73f6b556d4b90d92d6ad1d39154a4b74c" translate="yes" xml:space="preserve">
          <source>Registers listeners via &lt;a href=&quot;../api/store#subscribe&quot;&gt;&lt;code&gt;subscribe(listener)&lt;/code&gt;&lt;/a&gt;;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07072abd45ba7236bb3989cbd897b07eeac1c93b" translate="yes" xml:space="preserve">
          <source>Relationships and Tables</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9da905dbbbb2d63041deb7197b587a590301a7b" translate="yes" xml:space="preserve">
          <source>Remember how we &lt;a href=&quot;reducers&quot;&gt;designed the shape of the root state object&lt;/a&gt;? It's time we design the UI hierarchy to match it. This is not a Redux-specific task. &lt;a href=&quot;https://facebook.github.io/react/docs/thinking-in-react.html&quot;&gt;Thinking in React&lt;/a&gt; is a great tutorial that explains the process.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="956f2f6dcc69fefbba147a07801daf0bec3cb1a6" translate="yes" xml:space="preserve">
          <source>Remember that reducers are just functions, so you can use functional composition and higher-order functions as much as you feel comfortable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="186767200c580a2653e26a568dd78d79172ed4ba" translate="yes" xml:space="preserve">
          <source>Remember, to change an immutable object, you must mutate a &lt;em&gt;copy&lt;/em&gt; of it, and copying large objects can be slow as every property must be copied.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d14133871ccbb6d27982d438fb7486a531414b6e" translate="yes" xml:space="preserve">
          <source>Remove the &lt;em&gt;first&lt;/em&gt; element from the &lt;code&gt;future&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8db23b2ef380238e2a9332bbe7bb7805acafcd6f" translate="yes" xml:space="preserve">
          <source>Remove the &lt;em&gt;last&lt;/em&gt; element from the &lt;code&gt;past&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6bae9950e29a13f58e366e00739630628accfbd" translate="yes" xml:space="preserve">
          <source>Replaces the reducer currently used by the store to calculate the state.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e267d53c29587c8cde50b829af85bdaecdc01bb5" translate="yes" xml:space="preserve">
          <source>Reselect #47: Memoizing Hierarchical Selectors</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0e0bcc2864b7d77b721a68ce1600fd8bd2214df" translate="yes" xml:space="preserve">
          <source>Reselect Documentation: How do I use Reselect with Immutable.js?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c338cf732b237c24b1f0506400e28357d0f15bd3" translate="yes" xml:space="preserve">
          <source>Reselect provides a function &lt;code&gt;createSelector&lt;/code&gt; for creating memoized selectors. &lt;code&gt;createSelector&lt;/code&gt; takes an array of input-selectors and a transform function as its arguments. If the Redux state tree is mutated in a way that causes the value of an input-selector to change, the selector will call its transform function with the values of the input-selectors as arguments and return the result. If the values of the input-selectors are the same as the previous call to the selector, it will return the previously computed value instead of calling the transform function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c51b3f2e5f8258e6431cab2fcee20d079a2248f" translate="yes" xml:space="preserve">
          <source>Reselect: Selector library for Redux</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9582a02f141fc4b345b2936eba691cd0654efebc" translate="yes" xml:space="preserve">
          <source>Returns</source>
          <target state="translated">Returns</target>
        </trans-unit>
        <trans-unit id="9845b29c661b5f09755c1a2c1a4a6d8ac8f795eb" translate="yes" xml:space="preserve">
          <source>Returns the current state tree of your application.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b78505f9e7ca9beb942dcc8131c9189c9eeb998a" translate="yes" xml:space="preserve">
          <source>Reusing Reducer Logic</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0966cd2fd5d2cb35f03ce6b1bce5d1e7251e6744" translate="yes" xml:space="preserve">
          <source>Rich API</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a245bc64c38d63184404dacd3bd9f275e513df5f" translate="yes" xml:space="preserve">
          <source>Right now we are not passing anything to &lt;code&gt;&amp;lt;App /&amp;gt;&lt;/code&gt; so &lt;code&gt;ownProps&lt;/code&gt; is an empty object. To filter our todos according to the URL, we want to pass the URL params to &lt;code&gt;&amp;lt;VisibleTodoList /&amp;gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d15dd1bec2e055c5b177c9f869305ae6c54c9bb" translate="yes" xml:space="preserve">
          <source>Routing</source>
          <target state="translated">Routing</target>
        </trans-unit>
        <trans-unit id="c9f8b56b323ff1d67c59f2e6a12b4f9fd24bb536" translate="yes" xml:space="preserve">
          <source>Rules For Structuring (Redux) Applications</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="432cd1e0e18bce42cdef21bc0e2bf47d9952aaae" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/reactjs/redux/tree/master/examples/async&quot;&gt;Async&lt;/a&gt; example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8f9990ca1ff84f660e4614ac28b5a1202d83be9" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/reactjs/redux/tree/master/examples/counter&quot;&gt;Counter&lt;/a&gt; example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02bc6e8d90233a64557847335ed8fd0a2138380c" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/reactjs/redux/tree/master/examples/counter-vanilla&quot;&gt;Counter Vanilla&lt;/a&gt; example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff2baf0af3858008f9b05583c2312fb090bd1e5d" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/reactjs/redux/tree/master/examples/real-world&quot;&gt;Real World&lt;/a&gt; example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0e8812bdf4fabf867445d42be0aa6d8b7c05486" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/reactjs/redux/tree/master/examples/shopping-cart&quot;&gt;Shopping Cart&lt;/a&gt; example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d299f4e9292980bd1533a8b98ddf4a548b317e3d" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/reactjs/redux/tree/master/examples/todomvc&quot;&gt;TodoMVC&lt;/a&gt; example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a20317121271e18a234a5efdad9fa25e4ae9ccb" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/reactjs/redux/tree/master/examples/todos&quot;&gt;Todos&lt;/a&gt; example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="abfea29e9c7baf9015d33caddf86571e5480eee7" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/reactjs/redux/tree/master/examples/todos-with-undo&quot;&gt;Todos with Undo&lt;/a&gt; example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3419ab9b88258855aae8167ab6392ff99bc35318" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/reactjs/redux/tree/master/examples/tree-view&quot;&gt;Tree View&lt;/a&gt; example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eaf774d91e164852adb76afadeea254ddd1b6e1d" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/reactjs/redux/tree/master/examples/universal&quot;&gt;Universal&lt;/a&gt; example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="297ff09ad1fee6372badff1acb02a01184e1b455" translate="yes" xml:space="preserve">
          <source>RxJS</source>
          <target state="translated">RxJS</target>
        </trans-unit>
        <trans-unit id="f5c8e7496f807cd64744816fba01dc672fea8b3c" translate="yes" xml:space="preserve">
          <source>Sandrino Di Mattia</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06c1e2b042f09a95936f43d636e7a9cfe06fa2c4" translate="yes" xml:space="preserve">
          <source>Say, you call this when creating a todo:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e86aae6b5aebceaa76af1cce53d3199d645e9dcb" translate="yes" xml:space="preserve">
          <source>Screencasts</source>
          <target state="translated">Screencasts</target>
        </trans-unit>
        <trans-unit id="abf418e07a2bb8523e609c6622f0ee30e20593e9" translate="yes" xml:space="preserve">
          <source>Second Attempt: Writing a Reducer Enhancer</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="325c723ca2b67b9b7f5ba09ec5687e02ae1b0279" translate="yes" xml:space="preserve">
          <source>Secure Your React and Redux App with JWT Authentication</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="402cc3b6686cd294cb10dd3f5bccbebd0edd8a9b" translate="yes" xml:space="preserve">
          <source>Security Considerations</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="919870200d649a13066b3447ce0f0c25022cc8f6" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;api/applymiddleware&quot;&gt;&lt;code&gt;applyMiddleware(...middlewares)&lt;/code&gt;&lt;/a&gt; for a detailed look at middleware.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94f2d6b880adb72fb73adf9d3a1c8276271ee55a" translate="yes" xml:space="preserve">
          <source>See also &lt;a href=&quot;#async-action&quot;&gt;async action&lt;/a&gt; below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22ce2ecd3395a41aaf7f8cf591c10dd2e971bbd0" translate="yes" xml:space="preserve">
          <source>See the complete &lt;a href=&quot;api/store#dispatch&quot;&gt;store API reference&lt;/a&gt; for more details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1664d8a03fa57f4c8be0067b9d13327134f1e58a" translate="yes" xml:space="preserve">
          <source>Separating Data Handling by Domain</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ff6540c25bde7085cf0d2d1e9575cb74d3e0915" translate="yes" xml:space="preserve">
          <source>Server Rendering</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25c47193088be9016d58e256803985285406a208" translate="yes" xml:space="preserve">
          <source>Set the &lt;code&gt;present&lt;/code&gt; to the element we removed in the previous step.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0b36286cd9781f93bd06e4cc2ba9bd4a1ae46eb" translate="yes" xml:space="preserve">
          <source>Set the &lt;code&gt;present&lt;/code&gt; to the new state after handling the action.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d60b0890a431be3750d67b0f7fe70b5f3af16d7e" translate="yes" xml:space="preserve">
          <source>Setting Up</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ef3f0bd0914407afe72f32d7220011189833964" translate="yes" xml:space="preserve">
          <source>Seven Examples</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bceef6abe99285193523d99d3503c8cbe59abd17" translate="yes" xml:space="preserve">
          <source>Shallow equality checking (or &lt;em&gt;reference equality&lt;/em&gt;) simply checks that two different &lt;em&gt;variables&lt;/em&gt; reference the same object; in contrast, deep equality checking (or &lt;em&gt;value equality&lt;/em&gt;) must check every &lt;em&gt;value&lt;/em&gt; of two objects' properties.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1af20867da7a30bee30fa39bc87d4d6bf5086c5" translate="yes" xml:space="preserve">
          <source>Shallow equality checking cannot be used to detect if a function mutates an object passed into it if that object is mutable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a3368201d828a558753e74bfb641b78ef4ebe17" translate="yes" xml:space="preserve">
          <source>Shallow equality checking with a mutable object will not cause problems with Redux, but &lt;a href=&quot;#shallow-checking-problems-with-react-redux&quot;&gt;it will cause problems with libraries that depend on the store, such as React-Redux&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54774f0c2c7e8f191039f8359b7b19ab53fad9f2" translate="yes" xml:space="preserve">
          <source>Sharing Selectors Across Multiple Components</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="192f8cbb6f5871d94ba5fb03d97db29c7de825cd" translate="yes" xml:space="preserve">
          <source>Sharing State Between Redux Reducers</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b89a118c798fa4a35e3c16cccb58dae4801140ac" translate="yes" xml:space="preserve">
          <source>Sharing data between slice reducers</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90d67309aeeeaf7718677d90e2400596d8e164bd" translate="yes" xml:space="preserve">
          <source>Shopping Cart</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36fe368c9da0c4844911eb85a837f68dcae6c653" translate="yes" xml:space="preserve">
          <source>Should I dispatch multiple actions in a row from one action creator?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5b09d329a9d354e9f3fa021df3644b2917c4096" translate="yes" xml:space="preserve">
          <source>Should I only connect my top component, or can I connect multiple components in my tree?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1737c8bf68fcf64ccfaf2774ab797e55426baaa7" translate="yes" xml:space="preserve">
          <source>Should be &quot;pure&quot;, which means the reducer:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9fdc92b96e07741038b0992e2225ba1bf7f6560" translate="yes" xml:space="preserve">
          <source>Should have a signature of &lt;code&gt;(previousState, action) =&amp;gt; newState&lt;/code&gt;, similar to the type of function you would pass to &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce&quot;&gt;&lt;code&gt;Array.prototype.reduce(reducer, ?initialValue)&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9b9f5929894997ad56cc3c83383ff218a8e4e68" translate="yes" xml:space="preserve">
          <source>Side effects</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2bdc602c5e4f77691c4cf05236ccbfb9a3a7d6cd" translate="yes" xml:space="preserve">
          <source>Similarly, Dan Abramov, one of the creators of Redux, says:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8d94bc8e96596ebe8e2c196ec3465a016861842" translate="yes" xml:space="preserve">
          <source>Similarly, if &lt;code&gt;sliceReducerA&lt;/code&gt; happens to need some data from &lt;code&gt;sliceReducerB&lt;/code&gt;'s slice of state in order to handle a particular action, or &lt;code&gt;sliceReducerB&lt;/code&gt; happens to need the entire state as an argument, &lt;code&gt;combineReducers&lt;/code&gt; does not handle that itself. This could be resolved by writing a custom function that knows to pass the needed data as an additional argument in those specific cases, such as:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="442aad2b9dae61af274e1b5ffcce14c8db98f18c" translate="yes" xml:space="preserve">
          <source>Similarly, while you &lt;em&gt;can&lt;/em&gt; reference your store instance by importing it directly, this is not a recommended pattern in Redux. If you create a store instance and export it from a module, it will become a singleton. This means it will be harder to isolate a Redux app as a component of a larger app, if this is ever necessary, or to enable server rendering, because on the server you want to create separate store instances for every request.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f6c75f4d537fefd2d55e1099d473ae02742b468" translate="yes" xml:space="preserve">
          <source>Similarly, you can compose different asynchronous streams to turn them into actions before feeding them to &lt;code&gt;store.dispatch()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b1172b53a0feb7a9bb295b5a660a2ffbcb58fc3" translate="yes" xml:space="preserve">
          <source>Simple Merging</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2070eaef74ea9323409e358647e9ae6ca53c37cd" translate="yes" xml:space="preserve">
          <source>Since &lt;code&gt;combineReducers&lt;/code&gt; currently only works with plain Javascript objects, an application that uses an Immutable.js Map object for the top of its state tree could not use &lt;code&gt;combineReducers&lt;/code&gt; to manage that Map. Since many developers do use Immutable.js, there are a number of published utilities that provide equivalent functionality, such as &lt;a href=&quot;https://github.com/gajus/redux-immutable&quot;&gt;redux-immutable&lt;/a&gt;. This package provides its own implementation of &lt;code&gt;combineReducers&lt;/code&gt; that knows how to iterate over an Immutable Map instead of a plain Javascript object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81feae1ade917069a12cf9aa7539b91da9719215" translate="yes" xml:space="preserve">
          <source>Since Redux is just a data store library, it has no direct opinion on how your project should be structured. However, there are a few common patterns that most Redux developers tend to use:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec6d8987b40f3810e89420d79f0a03ad196ea3a0" translate="yes" xml:space="preserve">
          <source>Since a Redux reducer is &lt;em&gt;just&lt;/em&gt; a function, the same concept applies. You can split some of your reducer logic out into another function, and call that new function from the parent function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7004cb2a5422c7e3364434a15f16aaad43e92c0" translate="yes" xml:space="preserve">
          <source>Since each data type is separated, an update like changing the text of a comment would only require new copies of the &quot;comments &amp;gt; byId &amp;gt; comment&quot; portion of the tree. This will generally mean fewer portions of the UI that need to update because their data has changed. In contrast, updating a comment in the original nested shape would have required updating the comment object, the parent post object, the array of all post objects, and likely have caused &lt;em&gt;all&lt;/em&gt; of the Post components and Comment components in the UI to re-render themselves.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3378207602b38cf49f27093860fe75762bdd12fe" translate="yes" xml:space="preserve">
          <source>Since immutable data updates require all ancestors in the state tree to be copied and updated as well, and new object references will cause connected UI components to re-render, an update to a deeply nested data object could force totally unrelated UI components to re-render even if the data they're displaying hasn't actually changed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc174df1294758024d3aa9d37156a3b1ea508c4a" translate="yes" xml:space="preserve">
          <source>Since one of the core tenets of Redux is to never mutate state, you'll often find yourself using &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/assign&quot;&gt;&lt;code&gt;Object.assign()&lt;/code&gt;&lt;/a&gt; to create copies of objects with new or updated values. For example, in the &lt;code&gt;todoApp&lt;/code&gt; below &lt;code&gt;Object.assign()&lt;/code&gt; is used to return a new &lt;code&gt;state&lt;/code&gt; object with an updated &lt;code&gt;visibilityFilter&lt;/code&gt; property:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="751750d4cb79c6a8466b2981d8a7c11a9b335b87" translate="yes" xml:space="preserve">
          <source>Since reducers are just functions, there's an infinite number of ways to split up this logic. While using slice reducers is obviously the most common, it's also possible to organize behavior in a more task-oriented structure. Because this will often involve more nested updates, you may want to use an immutable update utility library like &lt;a href=&quot;https://github.com/debitoor/dot-prop-immutable&quot;&gt;dot-prop-immutable&lt;/a&gt; or &lt;a href=&quot;https://github.com/mariocasciaro/object-path-immutable&quot;&gt;object-path-immutable&lt;/a&gt; to simplify the update statements. Here's an example of what that might look like:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9524f9ed1b2581f0acc17e64cde44a8908d2e14e" translate="yes" xml:space="preserve">
          <source>Since the default export is still the decorated component, the import statement pictured above will work as before so you won't have to change your application code. However, you can now import the undecorated &lt;code&gt;App&lt;/code&gt; components in your test file like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1fb6dcac04c2641afe5f5ceba2752f16941c0489" translate="yes" xml:space="preserve">
          <source>Since the object spread syntax is still a &lt;a href=&quot;https://github.com/sebmarkbage/ecmascript-rest-spread#status-of-this-proposal&quot;&gt;Stage 3&lt;/a&gt; proposal for ECMAScript you'll need to use a transpiler such as &lt;a href=&quot;http://babeljs.io/&quot;&gt;Babel&lt;/a&gt; to use it in production. You can use your existing &lt;code&gt;es2015&lt;/code&gt; preset, install &lt;a href=&quot;http://babeljs.io/docs/plugins/transform-object-rest-spread/&quot;&gt;&lt;code&gt;babel-plugin-transform-object-rest-spread&lt;/code&gt;&lt;/a&gt; and add it individually to the &lt;code&gt;plugins&lt;/code&gt; array in your &lt;code&gt;.babelrc&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ca51516913ff8c686b4181a9850b407d585f33e" translate="yes" xml:space="preserve">
          <source>Single Simple Reducer</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3607f5a3395346db279c8631885ad76c32cdec0" translate="yes" xml:space="preserve">
          <source>Single source of truth</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d0ddd2467b9b23c1a85abd5a68ac4b84b509998" translate="yes" xml:space="preserve">
          <source>Slice Reducer Composition</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f8966ee06a6a598a66e68a6f2128780e130ca9a" translate="yes" xml:space="preserve">
          <source>Small utility functions containing some reusable chunk of logic that is needed in multiple places (which may or may not be actually related to the specific business logic)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="712ac3fdb33cc95ff1f79708b05bdbf85fc873a3" translate="yes" xml:space="preserve">
          <source>Smart and Dumb Components in React</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd67eec5e031f2788f993ce1a20a1c919e9f1589" translate="yes" xml:space="preserve">
          <source>Smart components that access the store via React Redux&amp;rsquo;s &lt;code&gt;connect&lt;/code&gt; function must use the Immutable.JS values returned by your selectors. Make sure you avoid the potential issues this can cause with unnecessary component re-rendering. Memoize your selectors using a library such as reselect if necessary.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0fa28ccaea98dae4e7adc0d2f21a6688416f5c11" translate="yes" xml:space="preserve">
          <source>So far we have only seen selectors receive the Redux store state as an argument, but a selector can receive props too.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c7e37241e1ba9e69dbbe9b4a4d92f9d4db7b97e" translate="yes" xml:space="preserve">
          <source>So now &lt;code&gt;getVisibleTodos&lt;/code&gt; has access to &lt;code&gt;props&lt;/code&gt;, and everything seems to be working fine.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7a8e420420cf895d7c454a61b1d5cb20007fa2a" translate="yes" xml:space="preserve">
          <source>So you want to do routing with your Redux app. You can use it with &lt;a href=&quot;https://github.com/reactjs/react-router&quot;&gt;React Router&lt;/a&gt;. Redux will be the source of truth for your data and React Router will be the source of truth for your URL. In most of the cases, &lt;strong&gt;it is fine&lt;/strong&gt; to have them separate unless you need to time travel and rewind actions that triggers the change URL.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2fc8fe9a73edd4d111843f389431f4101d5d9c17" translate="yes" xml:space="preserve">
          <source>So, for example, if your state shape is &lt;code&gt;{ todos, counter }&lt;/code&gt;, the call to &lt;code&gt;combineReducers&lt;/code&gt; would be:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ccb9fbf6736643b0e42418e768268b9cd0d29f5f" translate="yes" xml:space="preserve">
          <source>So, what are you waiting for?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aaba548cf058bc58a2b9e6247d0f30696c87f137" translate="yes" xml:space="preserve">
          <source>Solving a performance issue caused by too frequent updates of some part of the state, when confirmed by profiling the app.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d49f0c1ce0f85599fd62bed378620cb762c1e648" translate="yes" xml:space="preserve">
          <source>Some Reasons Why Redux is Useful in a React App</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67effe7198ec1da2c9351c8b657b35336537bffb" translate="yes" xml:space="preserve">
          <source>Some common rules of thumb for determining what kind of data should be put into Redux:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fce335731003088c209cd9b37e95f6128c05deb1" translate="yes" xml:space="preserve">
          <source>Some frameworks like &lt;a href=&quot;https://github.com/acdlite/flummox&quot;&gt;Flummox&lt;/a&gt; generate action type constants automatically from the action creator function definitions. The idea is that you don't need to both define &lt;code&gt;ADD_TODO&lt;/code&gt; constant and &lt;code&gt;addTodo()&lt;/code&gt; action creator. Under the hood, such solutions still generate action type constants, but they're created implicitly so it's a level of indirection and can cause confusion. We recommend creating your action type constants explicitly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11a2735a6d7891b97c7769374cd7a4c5a0bb87e0" translate="yes" xml:space="preserve">
          <source>Some of these concepts are already described elsewhere in the Redux documentation. Others are generic and applicable outside of Redux itself, and there are numerous existing articles that cover these concepts in detail. These concepts and techniques form the foundation of writing solid Redux reducer logic.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f81aa5aa34cf8b3e24fa1aaf08e9c45c13b0947d" translate="yes" xml:space="preserve">
          <source>Some valid reasons for using multiple stores in Redux might include:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0393764cde3422b70bb25ef444a0fd2f0c54e31" translate="yes" xml:space="preserve">
          <source>Something else doesn't work</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb49415fd84ba99d743a94724fc704b532a5abb2" translate="yes" xml:space="preserve">
          <source>Something needs to map the Immutable.JS props in your Smart Component to the pure JavaScript props used in your Dumb Component. That something is a Higher Order Component (HOC) that simply takes the Immutable.JS props from your Smart Component, and converts them using &lt;code&gt;toJS()&lt;/code&gt; to plain JavaScript props, which are then passed to your Dumb Component.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82c027e36202d6dbe2e05d86322f925c7f839e11" translate="yes" xml:space="preserve">
          <source>Sometimes it's hard to tell if some component should be a presentational component or a container. For example, sometimes form and function are really coupled together, such as in case of this tiny component:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d627c00cc83e8506e9cca85f44caed1d800c8c74" translate="yes" xml:space="preserve">
          <source>Sometimes you want to see all existing actions before working on a new feature. It may be that the action you need was already added by somebody on the team, but you didn't know.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="268852f5aa4bf3dafae464e32161ca334e3c609b" translate="yes" xml:space="preserve">
          <source>Sometimes, you are trying to dispatch an action, but your view does not update. Why does this happen? There may be several reasons for this.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b37110e5b01350732eac4676af2611966b9ccef" translate="yes" xml:space="preserve">
          <source>Source Code</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7919286c635d777ca9b544031e60fec3b718ae8" translate="yes" xml:space="preserve">
          <source>Special thanks to &lt;a href=&quot;http://jdpaton.github.io&quot;&gt;Jamie Paton&lt;/a&gt; for handing over the &lt;code&gt;redux&lt;/code&gt; NPM package name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56c91bc14a02e8f889305106eb782729b8dd411c" translate="yes" xml:space="preserve">
          <source>Specifically, at each stage of the iteration, &lt;code&gt;combineReducers&lt;/code&gt; performs a shallow equality check on the current state slice and the state slice returned from the reducer. If the reducer returns a new object, the shallow equality check will fail, and &lt;code&gt;combineReducers&lt;/code&gt; will set a &lt;code&gt;hasChanged&lt;/code&gt; flag to true.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00a3d8825c5eff03d86ea087a0b53050c94c3f8c" translate="yes" xml:space="preserve">
          <source>Specifically, if the state slice passed to a reducer by &lt;code&gt;combineReducers&lt;/code&gt; is a mutable object, the reducer can modify it directly and return it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="479e7df6db27bd135fe0142b00903715ac33068a" translate="yes" xml:space="preserve">
          <source>Splitting Reducer Logic</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b815e2bedf75de31f11e6b703026f6acada0f6e" translate="yes" xml:space="preserve">
          <source>Splitting Reducers</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63a2a0cb21e82fc3b8d2808aae5b0cbb52a99600" translate="yes" xml:space="preserve">
          <source>Splitting Up Reducer Logic</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d329a5765000192b22c2d117af29d9bee7c6537b" translate="yes" xml:space="preserve">
          <source>Splitting relational/nested data up into separate tables</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1230663d5b652e72592a5cdc4822bd583ada50c6" translate="yes" xml:space="preserve">
          <source>Stack Overflow: Accessing Redux state in an action creator</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af2ce625671f1ad526f0f824992d40592fc65945" translate="yes" xml:space="preserve">
          <source>Stack Overflow: Accessing Redux state in an action creator?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc4a21e47f70cd2f23b0f2c342d8b431463d5d43" translate="yes" xml:space="preserve">
          <source>Stack Overflow: Accessing other parts of the state when using combined reducers?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b04783e3f6d9939621df25d5e278f88f85d40f4e" translate="yes" xml:space="preserve">
          <source>Stack Overflow: Can I dispatch multiple actions without Redux Thunk middleware?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48da126c64af14eeff2ddf00eef38c1862600c5d" translate="yes" xml:space="preserve">
          <source>Stack Overflow: Can a React Redux app scale as well as Backbone?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4dfaf2359aff2ab31c33a3dbf21369953e0929ed" translate="yes" xml:space="preserve">
          <source>Stack Overflow: Can a Redux store lead to a memory leak?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="988abe0fa36c2ebb4e0cbf914b4d5fe269cc989b" translate="yes" xml:space="preserve">
          <source>Stack Overflow: Cleaner/shorter way to update nested state in Redux?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b1e48bcacf1979014102c6547e344589cfc1043" translate="yes" xml:space="preserve">
          <source>Stack Overflow: Do events and actions have a 1:1 relationship in Redux?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ebddfda346f9cc1931bdaef9cad513e27fe3e4da" translate="yes" xml:space="preserve">
          <source>Stack Overflow: How does Redux deal with deeply nested models?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94b70dfefdce48458a92962024bd2e39922329c0" translate="yes" xml:space="preserve">
          <source>Stack Overflow: How to dispatch a Redux action with a timeout?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b44a8af5f0a70fd30e935dc3f76e87f077627bbd" translate="yes" xml:space="preserve">
          <source>Stack Overflow: How to fire AJAX calls in response to the state changes with Redux?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e47386ec6016dd7f3fc367e6cffa3cf96cda35c" translate="yes" xml:space="preserve">
          <source>Stack Overflow: How to get simple dispatch from this.props using connect w/ Redux?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2165fe78c71949f8e9b453c57e11f6841bdc5b4c" translate="yes" xml:space="preserve">
          <source>Stack Overflow: How to handle complex side-effects in Redux?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28f22a2146692414a69f910d533939bac7f855eb" translate="yes" xml:space="preserve">
          <source>Stack Overflow: How to handle tree-shaped entities in Redux reducers?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d4b50a3426c2e7c8b83c7f6061b71189fc4ad4d" translate="yes" xml:space="preserve">
          <source>Stack Overflow: How to optimize small updates to props of nested components in React + Redux?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d918cb89f55a87fe62b679dfe98194482be59ff" translate="yes" xml:space="preserve">
          <source>Stack Overflow: How to optimize small updates to props of nested components?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="acba72b3df5c830d1b5aba0a48d173bc22d8fc32" translate="yes" xml:space="preserve">
          <source>Stack Overflow: How to structure Redux components/containers</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3eccf206103856b93ecbd37ce4f41620479a06a" translate="yes" xml:space="preserve">
          <source>Stack Overflow: How to unit test async Redux actions to mock ajax response</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4927a93f0a45155d14400120ebde30fcac96c00b" translate="yes" xml:space="preserve">
          <source>Stack Overflow: Is there any way to &quot;commit&quot; the state in Redux to free memory?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a704c1a402b4c7a231139affcc8b80dae9a39bc" translate="yes" xml:space="preserve">
          <source>Stack Overflow: Memory Usage Concern with Controlled Components</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dee2e567cd35803ebf7a0cd85960b6e1c5f84ae0" translate="yes" xml:space="preserve">
          <source>Stack Overflow: Reducing an entire subtree with redux combineReducers</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5c28dc373c45c187ad94b9e7c8d28a1a1e19e92" translate="yes" xml:space="preserve">
          <source>Stack Overflow: Redux and ALL the application state</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c804eaac1de7836c4167b4c7ce22081a3aecc375" translate="yes" xml:space="preserve">
          <source>Stack Overflow: Redux multiple stores, why not?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7e9dc84c7d9700ead6d04e9e5ccc4ca7533584c" translate="yes" xml:space="preserve">
          <source>Stack Overflow: Redux vs plain React?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="105923b79101b77a45fa4c3b2354a35798f4c76b" translate="yes" xml:space="preserve">
          <source>Stack Overflow: Should I use one or several action types to represent this async action?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31fdb0827c84ebe2269807c61132bfaba82d6831" translate="yes" xml:space="preserve">
          <source>Stack Overflow: Should actions be handled by reducers to related actions or generated by action creators themselves?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65014c400549c8612072befc0adf72ed3b081d64" translate="yes" xml:space="preserve">
          <source>Stack Overflow: Should all component state be kept in Redux store?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b98acfbe9a6b5556936b1fc7e937ef42e8da0b73" translate="yes" xml:space="preserve">
          <source>Stack Overflow: State in Redux app has the name of the reducer</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9bb052748fb6d9f95b232931f6b7ce0b330d741" translate="yes" xml:space="preserve">
          <source>Stack Overflow: State key names and &lt;code&gt;combineReducers&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70cc3d889ceeb8e34d6f3922754c47f23bd9be8d" translate="yes" xml:space="preserve">
          <source>Stack Overflow: Store initial state and &lt;code&gt;combineReducers&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c38c53a8386528fdbcdcab4494d509416d698fc" translate="yes" xml:space="preserve">
          <source>Stack Overflow: What could be the downsides of using Redux instead of Flux?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="895ded7294588881bb7fc95054edf3c3db5d4e96" translate="yes" xml:space="preserve">
          <source>Stack Overflow: What is the point of the constants in Redux?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="658846fec2f949984f29281c5ad5f8e0b3afe04d" translate="yes" xml:space="preserve">
          <source>Stack Overflow: When should I add Redux to a React app?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49f9fa997616236334bab1f021f4d95a98961d28" translate="yes" xml:space="preserve">
          <source>Stack Overflow: Where should I put synchronous side effects linked to actions in redux?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="936266740da7540850a532833e6a2df525b2a8b5" translate="yes" xml:space="preserve">
          <source>Stack Overflow: Why do we need middleware for async flow in Redux?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9bba3ac3bd12027bb6ac452b12ce38c7e56b122a" translate="yes" xml:space="preserve">
          <source>Stack Overflow: Why do you need 'Actions' as data in Redux?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18756cef85dbd29ab28641afa6772d3fefa20cc2" translate="yes" xml:space="preserve">
          <source>Stack Overflow: Why is state all in one place, even state that isn't global?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d2d7c0b7e20393e0c17c7eab1c82b6b5fc50426" translate="yes" xml:space="preserve">
          <source>Stack Overflow: Why should I use Redux in this example?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0364f6c9c8a113f92fdf913bbb551039a9724ed" translate="yes" xml:space="preserve">
          <source>Stack Overflow: Why use Redux over Facebook Flux?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10aa1b0c136f369eeefa163ced6c37c7c591e72e" translate="yes" xml:space="preserve">
          <source>Stack Overflow: can a dumb component use a Redux container?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b161211956de081a873933a4c8a044abab7e0fb" translate="yes" xml:space="preserve">
          <source>Standard Approaches</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a72502067518684f9deeec70cf119fd26326cd33" translate="yes" xml:space="preserve">
          <source>State</source>
          <target state="translated">State</target>
        </trans-unit>
        <trans-unit id="d587c099b9773435ddc0261ea9851ea406674dcf" translate="yes" xml:space="preserve">
          <source>State is read-only</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88bdda40b1f54211bc74c1e437fac5cd7bd92718" translate="yes" xml:space="preserve">
          <source>Still, this isn't nice.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d8a7046c8d39d9cbd86abcdfb704b161a601f9e" translate="yes" xml:space="preserve">
          <source>Store</source>
          <target state="translated">Store</target>
        </trans-unit>
        <trans-unit id="6bd6be2595d77f48a33fbcd6f117fa074b3dc576" translate="yes" xml:space="preserve">
          <source>Store API</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ae5ce622a7b9cf0a55280ae39f15ebca3636999" translate="yes" xml:space="preserve">
          <source>Store Methods</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="755c0688d517f4d1f3befaef9cbffed1a12611b7" translate="yes" xml:space="preserve">
          <source>Store Setup</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46284619675b8370e43c07e07ae7f90f0dc58a68" translate="yes" xml:space="preserve">
          <source>Store creator</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ce0b798e0d4896a15608877012298d37342e347" translate="yes" xml:space="preserve">
          <source>Store enhancer</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e142a8c534381fae47d56a5e16a0f2235b158282" translate="yes" xml:space="preserve">
          <source>Store enhancers are much the same concept as higher-order components in React, which are also occasionally called &amp;ldquo;component enhancers&amp;rdquo;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9416c1d5086bab5c721ad43af63fa3ab63c0a122" translate="yes" xml:space="preserve">
          <source>Store#dispatch()</source>
          <target state="translated">Store#dispatch()</target>
        </trans-unit>
        <trans-unit id="114eacc705a7df0e8c46ba7b192ea5316ba2c4ac" translate="yes" xml:space="preserve">
          <source>Store#getState()</source>
          <target state="translated">Store#getState()</target>
        </trans-unit>
        <trans-unit id="df99ee9fbf8a2efc5c7ed00b4492bf6b553163b9" translate="yes" xml:space="preserve">
          <source>Store#replaceReducer()</source>
          <target state="translated">Store#replaceReducer()</target>
        </trans-unit>
        <trans-unit id="013d0660eaa2690e6a9f899d36b23e021b36d850" translate="yes" xml:space="preserve">
          <source>Store#subscribe()</source>
          <target state="translated">Store#subscribe()</target>
        </trans-unit>
        <trans-unit id="71b541e49eef296d8df0cc8c719be0338a66cc03" translate="yes" xml:space="preserve">
          <source>Storing a single definition for a given item</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92eb6223892f134972ff80efa523a2000d6d1189" translate="yes" xml:space="preserve">
          <source>Structuring Reducers</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ff01fd753f588ce2cd880cdb10c47db54dde5a5" translate="yes" xml:space="preserve">
          <source>Subscribe to Redux state</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a54bde2350739858cdd0b5bc888eeb8620d23e6e" translate="yes" xml:space="preserve">
          <source>Such a dependency renders the component impure, makes testing the component more difficult, and makes reusing and refactoring the component unnecessarily difficult.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12b71c3e0fe5f7c0b8d17cc03186e281412da4a8" translate="yes" xml:space="preserve">
          <source>Summary</source>
          <target state="translated">Summary</target>
        </trans-unit>
        <trans-unit id="0fe97fb0406402fb59fa412b3bbeb9b60ac9262c" translate="yes" xml:space="preserve">
          <source>Synchronous Action Creators</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9730d4326a7b8a0d13c2be3b7fe29b80ad152bf6" translate="yes" xml:space="preserve">
          <source>Table of Contents</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15c674d7738210d0c5965059a30efc2059314bf7" translate="yes" xml:space="preserve">
          <source>Talks</source>
          <target state="translated">Talks</target>
        </trans-unit>
        <trans-unit id="2b65f913df556f349b0a7873cfdb7a6a8dd462a1" translate="yes" xml:space="preserve">
          <source>Task-Based Updates</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d95c7170ec15da472e1fc16a1b3628b7692d766d" translate="yes" xml:space="preserve">
          <source>Technically we could split it into two components but it might be too early at this stage. It's fine to mix presentation and logic in a component that is very small. As it grows, it will be more obvious how to split it, so we'll leave it mixed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97405b706d923beb562a978445f95da1784f550e" translate="yes" xml:space="preserve">
          <source>Technically you could write the container components by hand using &lt;a href=&quot;../api/store#subscribe&quot;&gt;&lt;code&gt;store.subscribe()&lt;/code&gt;&lt;/a&gt;. We don't advise you to do this because React Redux makes many performance optimizations that are hard to do by hand. For this reason, rather than write container components, we will generate them using the &lt;a href=&quot;https://github.com/reactjs/react-redux/blob/master/docs/api.md#connectmapstatetoprops-mapdispatchtoprops-mergeprops-options&quot;&gt;&lt;code&gt;connect()&lt;/code&gt;&lt;/a&gt; function provided by React Redux, as you will see below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c2cd2ae8ff170115855201664f8bc10a106aa1d" translate="yes" xml:space="preserve">
          <source>Testimonials</source>
          <target state="translated">Testimonials</target>
        </trans-unit>
        <trans-unit id="97cba4858411c435e526dd651157aac20178222c" translate="yes" xml:space="preserve">
          <source>Thanks</source>
          <target state="translated">Thanks</target>
        </trans-unit>
        <trans-unit id="09191f5d1ae35f788275b3791134e5c6cc9695f6" translate="yes" xml:space="preserve">
          <source>That function is fairly short, but already becoming overly complex. We're dealing with two different areas of concern (filtering vs managing our list of todos), the nesting is making the update logic harder to read, and it's not exactly clear what's going on everywhere.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="532f0a532fc0a678855d599bf7ec4ac18d1963d4" translate="yes" xml:space="preserve">
          <source>That reduced the duplication and made things a bit easier to read.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d029300dc585308627967e2bccdc91655721462" translate="yes" xml:space="preserve">
          <source>That said, Redux works especially well with libraries like &lt;a href=&quot;http://facebook.github.io/react/&quot;&gt;React&lt;/a&gt; and &lt;a href=&quot;https://github.com/dekujs/deku&quot;&gt;Deku&lt;/a&gt; because they let you describe UI as a function of state, and Redux emits state updates in response to actions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba443c628e5456614af4a08cbb732b49948515da" translate="yes" xml:space="preserve">
          <source>That&amp;rsquo;s perfectly OK when you mutate the copy, but in the context of a reducer, if you return a copy that &lt;em&gt;hasn&amp;rsquo;t&lt;/em&gt; been mutated, Redux&amp;rsquo;s &lt;code&gt;combineReducers&lt;/code&gt; function will still think that the state needs to be updated, as you're returning an entirely different object from the state slice object that was passed in.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e93f4cf2c16977aa0828b84202ee64df60519c65" translate="yes" xml:space="preserve">
          <source>That's it!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="695a585b3252ff564ab700e0286c7c4e8dfbd47b" translate="yes" xml:space="preserve">
          <source>That's it! Now any actions dispatched to the store instance will flow through &lt;code&gt;logger&lt;/code&gt; and &lt;code&gt;crashReporter&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62c0daeb24847642ed1a353245f2da0b5ca7faa7" translate="yes" xml:space="preserve">
          <source>That's it! Now you know what Redux is all about.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c632b918c1b5cb3e6e028274046e1a0dbd5fac5" translate="yes" xml:space="preserve">
          <source>The 5 Types of React Application State</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8082f45d35153e13c48e541bd18a7f65d42e1b2f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://github.com/tommikaikkonen/redux-orm&quot;&gt;Redux-ORM&lt;/a&gt; library provides a very useful abstraction layer for managing normalized data in a Redux store. It allows you to declare Model classes and define relations between them. It can then generate the empty &quot;tables&quot; for your data types, act as a specialized selector tool for looking up the data, and perform immutable updates on that data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1c005dfb17d1e5ad9227170c4331db15898fd97" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;reducers#reducers-share-state&quot;&gt;suggested structure&lt;/a&gt; for a Redux store is to split the state object into multiple &quot;slices&quot; or &quot;domains&quot; by key, and provide a separate reducer function to manage each individual data slice.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9a0e951a049ef97cd89a4e10f26e1e463b189ef" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;store&quot;&gt;store&lt;/a&gt; will pass two arguments to the &lt;a href=&quot;reducers&quot;&gt;reducer&lt;/a&gt;: the current state tree and the action. For example, in the todo app, the root reducer might receive something like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="738fb16f4a3da86b179b5fd2928c5cc0c8706445" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;combineReducers&lt;/code&gt; helper function turns an object whose values are different reducing functions into a single reducing function you can pass to &lt;a href=&quot;createstore&quot;&gt;&lt;code&gt;createStore&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a78fbb758be2a28c07a8ce0abb4a2f572f7c0bf8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;combineReducers&lt;/code&gt; utility included with Redux is very useful, but is deliberately limited to handle a single common use case: updating a state tree that is a plain Javascript object, by delegating the work of updating each slice of state to a specific slice reducer. It does &lt;em&gt;not&lt;/em&gt; handle other use cases, such as a state tree made up of Immutable.js Maps, trying to pass other portions of the state tree as an additional argument to a slice reducer, or performing &quot;ordering&quot; of slice reducer calls. It also does not care how a given slice reducer does its work.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48d1690c6f2d0e9c8b98b4f655fb56dfcdddc0d3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;connect()&lt;/code&gt; function takes two primary arguments, both optional. The first, &lt;code&gt;mapStateToProps&lt;/code&gt;, is a function you provide to pull data from the store when it changes, and pass those values as props to your component. The second, &lt;code&gt;mapDispatchToProps&lt;/code&gt;, is a function you provide to make use of the store's &lt;code&gt;dispatch&lt;/code&gt; function, usually by creating pre-bound versions of action creators that will automatically dispatch their actions as soon as they are called.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1f724426f5bed59b6fcff9c426308b18d862500" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;dispatch()&lt;/code&gt; function can be accessed directly from the store as &lt;a href=&quot;../api/store#dispatch&quot;&gt;&lt;code&gt;store.dispatch()&lt;/code&gt;&lt;/a&gt;, but more likely you'll access it using a helper like &lt;a href=&quot;http://github.com/gaearon/react-redux&quot;&gt;react-redux&lt;/a&gt;'s &lt;code&gt;connect()&lt;/code&gt;. You can use &lt;a href=&quot;../api/bindactioncreators&quot;&gt;&lt;code&gt;bindActionCreators()&lt;/code&gt;&lt;/a&gt; to automatically bind many action creators to a &lt;code&gt;dispatch()&lt;/code&gt; function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0cc5ef634bd494a2bcb0eba3ea9aacd39c49c13b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;distinctState()&lt;/code&gt; filter serves to ignore the actions that didn't result in a state change. There are &lt;a href=&quot;https://github.com/omnidan/redux-undo#configuration&quot;&gt;many other options&lt;/a&gt; to configure your undoable reducer, like setting the action type for Undo and Redo actions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7e69fb3a56cc38e559d99f56a4e63839a609eb9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;preloadedState&lt;/code&gt; will then be available on the client side by accessing &lt;code&gt;window.__PRELOADED_STATE__&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="454736cedd126ee22b50a1ed19c0f4bfc6ed98d8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;switch&lt;/code&gt; statement is &lt;em&gt;not&lt;/em&gt; the real boilerplate. The real boilerplate of Flux is conceptual: the need to emit an update, the need to register the Store with a Dispatcher, the need for the Store to be an object (and the complications that arise when you want a universal app).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5dfd028dd21b9e32d0060e5d401ade9a104ea3fe" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;switch&lt;/code&gt; statement is &lt;em&gt;not&lt;/em&gt; the real boilerplate. The real boilerplate of Flux is conceptual: the need to emit an update, the need to register the Store with a Dispatcher, the need for the Store to be an object (and the complications that arise when you want a universal app). Redux solves these problems by using pure reducers instead of event emitters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e916ef3dceacc26ab023c93511c4a41b777908e" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;Store&lt;/strong&gt; is the object that brings them together. The store has the following responsibilities:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0dfb0a89f92611bca64f034a94a2f962e4ebd962" translate="yes" xml:space="preserve">
          <source>The Case for Flux</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2be97967a036b4704b556ca385f3d427bc4090d4" translate="yes" xml:space="preserve">
          <source>The Client Side</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d8895e86bbb9fcbb32585f22afa4849467be15b" translate="yes" xml:space="preserve">
          <source>The Final Approach</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ec2a8c85e269f721fc1b0c962b89cc607899b26" translate="yes" xml:space="preserve">
          <source>The Gist</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de9191847383c1842749d836c1147436f76724d9" translate="yes" xml:space="preserve">
          <source>The HyperTerm terminal application</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d571c123a7cfe23b3bbf561d3957e3c00ed11319" translate="yes" xml:space="preserve">
          <source>The Little Idea of Functional Programming</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dfb1aa70710a03922941317888e0b7cc0c028c48" translate="yes" xml:space="preserve">
          <source>The Power of Higher-Order Reducers</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79913e28740ae0370c83c1b4c15cfb9703563d49" translate="yes" xml:space="preserve">
          <source>The Redux API surface is tiny. Redux defines a set of contracts for you to implement (such as &lt;a href=&quot;../glossary#reducer&quot;&gt;reducers&lt;/a&gt;) and provides a few helper functions to tie these contracts together.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5c1e3f8c2dd5838d397dba36b04c9a62e93369f" translate="yes" xml:space="preserve">
          <source>The Redux reducer API is &lt;code&gt;(state, action) =&amp;gt; state&lt;/code&gt;, but how you create those reducers is up to you.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4558623f708d5c23e2aa2461d3125df5fcd82d4a" translate="yes" xml:space="preserve">
          <source>The Redux source code is written in ES2015 but we precompile both CommonJS and UMD builds to ES5 so they work in &lt;a href=&quot;http://caniuse.com/#feat=es5&quot;&gt;any modern browser&lt;/a&gt;. You don't need to use Babel or a module bundler to &lt;a href=&quot;https://github.com/reactjs/redux/blob/master/examples/counter-vanilla/index.html&quot;&gt;get started with Redux&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ecc1a1a17b3429a96287b0bd69b636f5a14dc84c" translate="yes" xml:space="preserve">
          <source>The Redux-ORM library maintains an internal queue of updates to be applied. Those updates are then applied immutably, simplifying the update process.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="478f0f344043467133811ff0c84e58dc576376c2" translate="yes" xml:space="preserve">
          <source>The Server Side</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a5fcafa1bd7939d8a0603992e21bd96c7692240" translate="yes" xml:space="preserve">
          <source>The Tao of Redux, Part 2 - Practice and Philosophy. Thick and thin reducers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b46572db1b8dfcd7649cde9229d79fb8affd4f2" translate="yes" xml:space="preserve">
          <source>The actual list of todos.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5aef95989e50df9f820f46a8576b4cdb580a5dd4" translate="yes" xml:space="preserve">
          <source>The advantage of using the object spread syntax becomes more apparent when you're composing complex objects. Below &lt;code&gt;getAddedIds&lt;/code&gt; maps an array of &lt;code&gt;id&lt;/code&gt; values to an array of objects with values returned from &lt;code&gt;getProduct&lt;/code&gt; and &lt;code&gt;getQuantity&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e2c53398d8416bc804266234b36f940f2c701d5" translate="yes" xml:space="preserve">
          <source>The array spread operator in ES6, and the similar object spread operator that is proposed for a future version of JavaScript</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3bc116f9668143f3ac5c44b58f1126b54a0f5a3" translate="yes" xml:space="preserve">
          <source>The articles listed in &lt;a href=&quot;prerequisiteconcepts#immutable-data-management&quot;&gt;Prerequisite Concepts#Immutable Data Management&lt;/a&gt; give a number of good examples for how to perform basic update operations immutably, such as updating a field in an object or adding an item to the end of an array. However, reducers will often need to use those basic operations in combination to perform more complicated tasks. Here are some examples for some of the more common tasks you might have to implement.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c3850419731a888edfb498c6aaa6ebf75a3a7c1" translate="yes" xml:space="preserve">
          <source>The base dispatch function &lt;em&gt;always&lt;/em&gt; synchronously sends an action to the store's reducer, along with the previous state returned by the store, to calculate a new state. It expects actions to be plain objects ready to be consumed by the reducer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b132326ede652b0ef3bcc14eb28b705253858136" translate="yes" xml:space="preserve">
          <source>The basic concepts of normalizing data are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e52a5e9fc4db9bd1340d6ab9bc0823d57fe77ab" translate="yes" xml:space="preserve">
          <source>The client side is very straightforward. All we need to do is grab the initial state from &lt;code&gt;window.__PRELOADED_STATE__&lt;/code&gt;, and pass it to our &lt;a href=&quot;../api/createstore&quot;&gt;&lt;code&gt;createStore()&lt;/code&gt;&lt;/a&gt; function as the initial state.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf2d52f1f096bfa92fc770873878e027f7266621" translate="yes" xml:space="preserve">
          <source>The code reads from the Express &lt;code&gt;Request&lt;/code&gt; object passed into our server middleware. The parameter is parsed into a number and then set in the initial state. If you visit &lt;a href=&quot;http://localhost:3000/?counter=100&quot;&gt;http://localhost:3000/?counter=100&lt;/a&gt; in your browser, you'll see the counter starts at 100. In the rendered HTML, you'll see the counter output as 100 and the &lt;code&gt;__PRELOADED_STATE__&lt;/code&gt; variable has the counter set in it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4826495f8f747fbdf0f71e9d47d5be2bf0b9040a" translate="yes" xml:space="preserve">
          <source>The common question, then, is &quot;How can I use &lt;code&gt;combineReducers&lt;/code&gt; to handle these other use cases?&quot;. The answer to that is simply: &quot;you don't - you probably need to use something else&quot;. &lt;strong&gt;Once you go past the core use case for &lt;code&gt;combineReducers&lt;/code&gt;, it's time to use more &quot;custom&quot; reducer logic&lt;/strong&gt;, whether it be specific logic for a one-off use case, or a reusable function that could be widely shared. Here's some suggestions for dealing with a couple of these typical use cases, but feel free to come up with your own approaches.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c5f1c9e6c8f5bdeafe0125ff96ed215a380912f" translate="yes" xml:space="preserve">
          <source>The current suggested best practice is to categorize your components as &amp;ldquo;presentational&amp;rdquo; or &amp;ldquo;container&amp;rdquo; components, and extract a connected container component wherever it makes sense:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89bd096d9d762c82ef72e28c42515ef633264780" translate="yes" xml:space="preserve">
          <source>The currently selected visibility filter;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="edf1af83e4170e21d0f26a22f25cf9daa7c8184e" translate="yes" xml:space="preserve">
          <source>The data lifecycle in any Redux app follows these 4 steps:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62b467d39a23989592c09583e8808c4f173188dd" translate="yes" xml:space="preserve">
          <source>The easiest way to do this is to pass through some callback back to your synchronous code. In this case, that will be a function that will reference the response object and send back our rendered HTML to the client. Don't worry, it's not as hard as it may sound.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4ce871b16323b1c0bb886336edf356b3878eb0d" translate="yes" xml:space="preserve">
          <source>The example is a bit long, because it's showing how all the different slice reducers and case reducers fit together. Note the delegation involved here. The &lt;code&gt;postsById&lt;/code&gt; slice reducer delegates the work for this case to &lt;code&gt;addComment&lt;/code&gt;, which inserts the new Comment's ID into the correct Post item. Meanwhile, both the &lt;code&gt;commentsById&lt;/code&gt; and &lt;code&gt;allComments&lt;/code&gt; slice reducers have their own case reducers, which update the Comments lookup table and list of all Comment IDs appropriately.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="779dfe0ad26c982a1de5c2e0e8649831bf366e55" translate="yes" xml:space="preserve">
          <source>The examples in this section require React Redux v4.3.0 or greater</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e75214fea4fb1a9ffce832f2c35732c7381684ab" translate="yes" xml:space="preserve">
          <source>The examples use React, but you should still find them useful if you use something else.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ea635408bd084da5b7ab91bad09e779b2cf750c" translate="yes" xml:space="preserve">
          <source>The extra re-renders could be resolved by saving the array of objects into the state using a reducer, caching the mapped array using &lt;a href=&quot;https://github.com/reactjs/reselect&quot;&gt;Reselect&lt;/a&gt;, or implementing &lt;code&gt;shouldComponentUpdate&lt;/code&gt; in the component by hand and doing a more in-depth props comparison using a function such as &lt;code&gt;_.isEqual&lt;/code&gt;. Be careful to not make your custom &lt;code&gt;shouldComponentUpdate()&lt;/code&gt; more expensive than the rendering itself! Always use a profiler to check your assumptions about performance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0da3ed8f89bdb310cc912494206553bc1426d386" translate="yes" xml:space="preserve">
          <source>The fact that we hide it inside the library doesn't alter this fact.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1de0392a7f8331d8c01e93cc6658a1acbeb1d36b" translate="yes" xml:space="preserve">
          <source>The final step on the server side is to inject our initial component HTML and initial state into a template to be rendered on the client side. To pass along the state, we add a &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; tag that will attach &lt;code&gt;preloadedState&lt;/code&gt; to &lt;code&gt;window.__PRELOADED_STATE__&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dba272babae41e9f815da394011efbc9abd976d3" translate="yes" xml:space="preserve">
          <source>The first thing that we need to do on every request is create a new Redux store instance. The only purpose of this store instance is to provide the initial state of our application.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="437ff180e90b483ac82f3a0b997133834d4da2f7" translate="yes" xml:space="preserve">
          <source>The first time the reducer is called, the &lt;code&gt;state&lt;/code&gt; value will be &lt;code&gt;undefined&lt;/code&gt;. The reducer needs to handle this case by supplying a default state value before handling the incoming action.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a95e0198d37edafccaeec5cfcad513398e60156" translate="yes" xml:space="preserve">
          <source>The fix is to call &lt;a href=&quot;api/store#dispatch&quot;&gt;&lt;code&gt;dispatch()&lt;/code&gt;&lt;/a&gt; method on the &lt;a href=&quot;api/store&quot;&gt;store&lt;/a&gt; instance:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9cbc5ae45e711e0e52c905a6773d8d1b1935dc93" translate="yes" xml:space="preserve">
          <source>The fixed code looks like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="023789ed8635b6b65d05d6a4ac33fe464c661c24" translate="yes" xml:space="preserve">
          <source>The following is the outline for what our server side is going to look like. We are going to set up an &lt;a href=&quot;http://expressjs.com/guide/using-middleware.html&quot;&gt;Express middleware&lt;/a&gt; using &lt;a href=&quot;http://expressjs.com/api.html#app.use&quot;&gt;app.use&lt;/a&gt; to handle all requests that come in to our server. If you're unfamiliar with Express or middleware, just know that our handleRender function will be called every time the server receives a request.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4316b779bf18bece5b0ccea09756426fce5c6d7c" translate="yes" xml:space="preserve">
          <source>The implementation of &lt;a href=&quot;../api/applymiddleware&quot;&gt;&lt;code&gt;applyMiddleware()&lt;/code&gt;&lt;/a&gt; that ships with Redux is similar, but &lt;strong&gt;different in three important aspects&lt;/strong&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9eb650209f72859301cebd361ec76ff3db6f6bc" translate="yes" xml:space="preserve">
          <source>The initial state is zero. Why? Because the second argument to &lt;code&gt;createStore&lt;/code&gt; was &lt;code&gt;undefined&lt;/code&gt;. This is the &lt;code&gt;state&lt;/code&gt; passed to your reducer the first time. When Redux initializes it dispatches a &quot;dummy&quot; action to fill the state. So your &lt;code&gt;counter&lt;/code&gt; reducer was called with &lt;code&gt;state&lt;/code&gt; equal to &lt;code&gt;undefined&lt;/code&gt;. &lt;strong&gt;This is exactly the case that &quot;activates&quot; the default argument.&lt;/strong&gt; Therefore, &lt;code&gt;state&lt;/code&gt; is now &lt;code&gt;0&lt;/code&gt; as per the default &lt;code&gt;state&lt;/code&gt; value (&lt;code&gt;state = 0&lt;/code&gt;). This state (&lt;code&gt;0&lt;/code&gt;) will be returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1870e4c91c65906a132e8ab3a09c561bb5d7c0e" translate="yes" xml:space="preserve">
          <source>The interesting part here is that it does not matter whether we want to keep an undo stack of numbers, strings, arrays, or objects. The structure will always be the same:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aced1e5fb79ae68b6eba1085040abdf61e8e93fd" translate="yes" xml:space="preserve">
          <source>The invoke function runs our middleware in the same way Redux does.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2e2db63b16b97293e72fee9e740a81bd129896c" translate="yes" xml:space="preserve">
          <source>The key step in server side rendering is to render the initial HTML of our component &lt;em&gt;&lt;strong&gt;before&lt;/strong&gt;&lt;/em&gt; we send it to the client side. To do this, we use &lt;a href=&quot;https://facebook.github.io/react/docs/react-dom-server.html#rendertostring&quot;&gt;ReactDOMServer.renderToString()&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ebf3991556cfed7c3eed26e9a4ebee92564c0c2e" translate="yes" xml:space="preserve">
          <source>The key to updating nested data is &lt;strong&gt;that &lt;em&gt;every&lt;/em&gt; level of nesting must be copied and updated appropriately&lt;/strong&gt;. This is often a difficult concept for those learning Redux, and there are some specific problems that frequently occur when trying to update nested objects. These lead to accidental direct mutation, and should be avoided.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1f13b41716a56d3a6b663d8adeef0fbfebcd6da" translate="yes" xml:space="preserve">
          <source>The list of action types that were added, removed, and changed in a Pull Request helps everyone on the team keep track of scope and implementation of new features.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a909efdb80760679c43fc5e7380d281a27aa83b" translate="yes" xml:space="preserve">
          <source>The listener should not expect to see all state changes, as the state might have been updated multiple times during a nested &lt;a href=&quot;#dispatch&quot;&gt;&lt;code&gt;dispatch()&lt;/code&gt;&lt;/a&gt; before the listener is called. It is, however, guaranteed that all subscribers registered before the &lt;a href=&quot;#dispatch&quot;&gt;&lt;code&gt;dispatch()&lt;/code&gt;&lt;/a&gt; started will be called with the latest state by the time it exits.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dfc2ce49bb9fba9f11cb4c299cb527330ef38e0b" translate="yes" xml:space="preserve">
          <source>The listener should only call &lt;a href=&quot;#dispatch&quot;&gt;&lt;code&gt;dispatch()&lt;/code&gt;&lt;/a&gt; either in response to user actions or under specific conditions (e. g. dispatching an action when the store has a specific field). Calling &lt;a href=&quot;#dispatch&quot;&gt;&lt;code&gt;dispatch()&lt;/code&gt;&lt;/a&gt; without any conditions is technically possible, however it leads to an infinite loop as every &lt;a href=&quot;#dispatch&quot;&gt;&lt;code&gt;dispatch()&lt;/code&gt;&lt;/a&gt; call usually triggers the listener again.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1a0911c22c72f7c2742cacaf4dc763e35a23b3f" translate="yes" xml:space="preserve">
          <source>The logic for retrieving or updating a given item is now fairly simple and consistent. Given an item's type and its ID, we can directly look it up in a couple simple steps, without having to dig through other objects to find it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea3c8144b116952a7e48b511c8b6726d8e7f3ef8" translate="yes" xml:space="preserve">
          <source>The middleware that interprets such actions could look like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d682e36630596f87baf92e1be74cab220ee7bbc6" translate="yes" xml:space="preserve">
          <source>The most common issue with server side rendering is dealing with state that comes in asynchronously. Rendering on the server is synchronous by nature, so it's necessary to map any asynchronous fetches into a synchronous operation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8bd487c6f173028a7534d7c66f721bcbc1a7152f" translate="yes" xml:space="preserve">
          <source>The most common state shape for a Redux app is a plain Javascript object containing &quot;slices&quot; of domain-specific data at each top-level key. Similarly, the most common approach to writing reducer logic for that state shape is to have &quot;slice reducer&quot; functions, each with the same &lt;code&gt;(state, action)&lt;/code&gt; signature, and each responsible for managing all updates to that specific slice of state. Multiple slice reducers can respond to the same action, independently update their own slice as needed, and the updated slices are combined into the new state object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93bd18e049d16d78b6a4f2d8ab6b83aaccc924a2" translate="yes" xml:space="preserve">
          <source>The most common use case for middleware is to support asynchronous actions without much boilerplate code or a dependency on a library like &lt;a href=&quot;https://github.com/Reactive-Extensions/RxJS&quot;&gt;Rx&lt;/a&gt;. It does so by letting you dispatch &lt;a href=&quot;../glossary#async-action&quot;&gt;async actions&lt;/a&gt; in addition to normal actions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ca5c9f8c9076592f848e34b0f4212ad6547c204" translate="yes" xml:space="preserve">
          <source>The most common use case for server-side rendering is to handle the &lt;em&gt;initial render&lt;/em&gt; when a user (or search engine crawler) first requests our app. When the server receives the request, it renders the required component(s) into an HTML string, and then sends it as a response to the client. From that point on, the client takes over rendering duties.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24ae76922e0a16060847d467d7cc8498c8e8fd41" translate="yes" xml:space="preserve">
          <source>The most na&amp;iuml;ve solution is just to log the action and the next state yourself every time you call &lt;a href=&quot;../api/store#dispatch&quot;&gt;&lt;code&gt;store.dispatch(action)&lt;/code&gt;&lt;/a&gt;. It's not really a solution, but just a first step towards understanding the problem.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c28210a81ca17cd5297b553285382ceab58a3637" translate="yes" xml:space="preserve">
          <source>The new Counter Vanilla example is aimed to dispel the myth that Redux requires Webpack, React, hot reloading, sagas, action creators, constants, Babel, npm, CSS modules, decorators, fluent Latin, an Egghead subscription, a PhD, or an Exceeds Expectations O.W.L. level.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93fb65536a0476327978e11533ea1a5d24a10c81" translate="yes" xml:space="preserve">
          <source>The new state is not passed to the listeners in order to simplify implementing store enhancers such as the Redux DevTools. In addition, subscribers are intended to react to the state value itself, not the action. Middleware can be used if the action is important and needs to be handled specifically.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e78ce3d1d64476af75b7e5f41d5be781a323a4c" translate="yes" xml:space="preserve">
          <source>The nice thing about thunks is that they can dispatch results of each other:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d99c20eac2d1658b7df0891305cdca243a9af62" translate="yes" xml:space="preserve">
          <source>The only input for server side code is the request made when loading up a page in your app in your browser. You may choose to configure the server during its boot (such as when you are running in a development vs. production environment), but that configuration is static.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f86933dcbbe66c8f04e7c9fc359e8fa49b3f7f3" translate="yes" xml:space="preserve">
          <source>The only use case for &lt;code&gt;bindActionCreators&lt;/code&gt; is when you want to pass some action creators down to a component that isn't aware of Redux, and you don't want to pass &lt;a href=&quot;store#dispatch&quot;&gt;&lt;code&gt;dispatch&lt;/code&gt;&lt;/a&gt; or the Redux store to it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66b4d49e553bb0efa470bbe85e68619297117596" translate="yes" xml:space="preserve">
          <source>The only way to change the state inside it is to dispatch an &lt;a href=&quot;../glossary#action&quot;&gt;action&lt;/a&gt; on it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d51f5c9be0da0a1475d839514b718722284186c" translate="yes" xml:space="preserve">
          <source>The only way to change the state tree is to emit an &lt;em&gt;action&lt;/em&gt;, an object describing what happened.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c24d16d7147d4d6eb8c10527b6a9d45b0beb9c87" translate="yes" xml:space="preserve">
          <source>The option we recommend is to use a special React Redux component called &lt;a href=&quot;https://github.com/reactjs/react-redux/blob/master/docs/api.md#provider-store&quot;&gt;&lt;code&gt;&amp;lt;Provider&amp;gt;&lt;/code&gt;&lt;/a&gt; to &lt;a href=&quot;https://facebook.github.io/react/docs/context.html&quot;&gt;magically&lt;/a&gt; make the store available to all container components in the application without passing it explicitly. You only need to use it once when you render the root component:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="648fab04f4ba80945b0b8fe210f400cb5cd99721" translate="yes" xml:space="preserve">
          <source>The original Flux pattern describes having multiple &amp;ldquo;stores&amp;rdquo; in an app, each one holding a different area of domain data. This can introduce issues such as needing to have one store &amp;ldquo;&lt;code&gt;waitFor&lt;/code&gt;&amp;rdquo; another store to update. This is not necessary in Redux because the separation between data domains is already achieved by splitting a single reducer into smaller reducers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62ee23332a72fc3750f78243b123043b65f95888" translate="yes" xml:space="preserve">
          <source>The question is: do you really need Redux if you already use Rx? Maybe not. It's not hard to &lt;a href=&quot;https://github.com/jas-chen/rx-redux&quot;&gt;re-implement Redux in Rx&lt;/a&gt;. Some say it's a two-liner using Rx &lt;code&gt;.scan()&lt;/code&gt; method. It may very well be!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b112f1eaa085df10f0fb3a949e7c7d0512123ef7" translate="yes" xml:space="preserve">
          <source>The reducer &lt;code&gt;(state, action) =&amp;gt; state&lt;/code&gt; signature makes it natural to implement generic &amp;ldquo;reducer enhancers&amp;rdquo; or &amp;ldquo;higher order reducers&amp;rdquo;. They are functions that take your reducer and enhance it with some additional functionality while preserving its signature. Undo history is exactly such a case.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="831cdccd0fe29b2292b102e71a67a95df749f9a5" translate="yes" xml:space="preserve">
          <source>The reducer generated by &lt;code&gt;combineReducers({ a, b })&lt;/code&gt; looks like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="579bccc1a8ba0deb299c67fd02b66c1a0bde82b3" translate="yes" xml:space="preserve">
          <source>The reducer logic doesn't have to deal with deep levels of nesting, so it will probably be much simpler.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b251f78a3911e16c890bcff055432910c7e244e" translate="yes" xml:space="preserve">
          <source>The reducers may handle this action by merging the new data into the state they manage and resetting &lt;code&gt;isFetching&lt;/code&gt;. The UI would hide the spinner, and display the fetched data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef702e159de1a7ac56e685ea8e6312a6d8a5ae0e" translate="yes" xml:space="preserve">
          <source>The reducers may handle this action by resetting &lt;code&gt;isFetching&lt;/code&gt;. Additionally, some reducers may want to store the error message so the UI can display it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3589533d63065a42192671f978f7884a00c50eb" translate="yes" xml:space="preserve">
          <source>The reducers may handle this action by toggling an &lt;code&gt;isFetching&lt;/code&gt; flag in the state. This way the UI knows it's time to show a spinner.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb415aec3abf5f69e7a7dbc95599da2a8b59bb09" translate="yes" xml:space="preserve">
          <source>The remove function could also be implemented as:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34eee3e75bb47e88848e238f22d63bbf7668e6ee" translate="yes" xml:space="preserve">
          <source>The request contains information about the URL requested, including any query parameters, which will be useful when using something like &lt;a href=&quot;https://github.com/reactjs/react-router&quot;&gt;React Router&lt;/a&gt;. It can also contain headers with inputs like cookies or authorization, or POST body data. Let's see how we can set the initial counter state based on a query parameter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb8346bc09abdc2bdbbd4e730bada908b5a84b2e" translate="yes" xml:space="preserve">
          <source>The resulting reducer calls every child reducer, and gathers their results into a single state object. &lt;strong&gt;The shape of the state object matches the keys of the passed &lt;code&gt;reducers&lt;/code&gt;&lt;/strong&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="191b4037dec326d03a76e5e3d99a324826c75a29" translate="yes" xml:space="preserve">
          <source>The shallow check of &lt;code&gt;param&lt;/code&gt; and &lt;code&gt;returnValue&lt;/code&gt; simply checks whether both variables reference the same object, which they do.&lt;code&gt;mutateObj()&lt;/code&gt; may return a mutated version of &lt;code&gt;obj&lt;/code&gt;, but it's still the same object as that passed in. The fact that its values have been changed within &lt;code&gt;mutateObj&lt;/code&gt; matters not at all to a shallow check.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc6715934729123df24e127a2b31fa31c6f3d1d9" translate="yes" xml:space="preserve">
          <source>The simplest and most common way to do this is to add the &lt;a href=&quot;https://github.com/gaearon/redux-thunk&quot;&gt;Redux Thunk&lt;/a&gt; middleware that lets you write action creators with more complex and asynchronous logic. Another widely-used method is &lt;a href=&quot;https://github.com/yelouafi/redux-saga&quot;&gt;Redux Saga&lt;/a&gt; which lets you write more synchronous-looking code using generators, and can act like &amp;ldquo;background threads&amp;rdquo; or &amp;ldquo;daemons&amp;rdquo; in a Redux app. Yet another approach is &lt;a href=&quot;https://github.com/raisemarketplace/redux-loop&quot;&gt;Redux Loop&lt;/a&gt;, which inverts the process by allowing your reducers to declare side effects in response to state changes and have them executed separately. Beyond that, there are &lt;em&gt;many&lt;/em&gt; other community-developed libraries and ideas, each with their own take on how side effects should be managed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1ef44d7beed8bc507d7e3d3fa102d8a5af7a998" translate="yes" xml:space="preserve">
          <source>The simplest example of middleware is &lt;a href=&quot;https://github.com/gaearon/redux-thunk&quot;&gt;redux-thunk&lt;/a&gt;. &lt;strong&gt;&amp;ldquo;Thunk&amp;rdquo; middleware lets you write action creators as &amp;ldquo;thunks&amp;rdquo;, that is, functions returning functions.&lt;/strong&gt; This inverts the control: you will get &lt;code&gt;dispatch&lt;/code&gt; as an argument, so you can write an action creator that dispatches many times.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a224c5bb5c7b0257b4abc9573a41ae755e11d225" translate="yes" xml:space="preserve">
          <source>The simplest possible approach to writing reducer logic is to put everything into a single function declaration, like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df00019572e1d526628ee1357601871796c2e3aa" translate="yes" xml:space="preserve">
          <source>The state is already immutable, and mutations are already described as discrete actions, which is close to the undo stack mental model.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e2a0df854ac3a6ba67f8bf8af131bbbadf64b8c" translate="yes" xml:space="preserve">
          <source>The store will still be updated with the new values for the root state, but because the root state object itself is still the same object, libraries that bind to Redux, such as React-Redux, will not be aware of the state&amp;rsquo;s mutation, and so will not trigger a wrapped component&amp;rsquo;s re-rendering.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f3016ca7583094ba4738ed1d27a81993f9cabc7" translate="yes" xml:space="preserve">
          <source>The store's reducing function will be called with the current &lt;a href=&quot;#getState&quot;&gt;&lt;code&gt;getState()&lt;/code&gt;&lt;/a&gt; result and the given &lt;code&gt;action&lt;/code&gt; synchronously. Its return value will be considered the next state. It will be returned from &lt;a href=&quot;#getState&quot;&gt;&lt;code&gt;getState()&lt;/code&gt;&lt;/a&gt; from now on, and the change listeners will immediately be notified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cea20ac25d592424eac6b0baa84b4cb2827c5999" translate="yes" xml:space="preserve">
          <source>The sub-app approach is also useful for large teams that are divided by product or feature verticals. These teams can ship sub-apps independently or in combination with an enclosing &amp;ldquo;app shell&amp;rdquo;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="375db8357be87b44ec99ec266964bcb0566ca944" translate="yes" xml:space="preserve">
          <source>The subscriptions are snapshotted just before every &lt;a href=&quot;#dispatch&quot;&gt;&lt;code&gt;dispatch()&lt;/code&gt;&lt;/a&gt; call. If you subscribe or unsubscribe while the listeners are being invoked, this will not have any effect on the &lt;a href=&quot;#dispatch&quot;&gt;&lt;code&gt;dispatch()&lt;/code&gt;&lt;/a&gt; that is currently in progress. However, the next &lt;a href=&quot;#dispatch&quot;&gt;&lt;code&gt;dispatch()&lt;/code&gt;&lt;/a&gt; call, whether nested or not, will use a more recent snapshot of the subscription list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3fcb31aa94b0e76b32e4908a5de1c115f3b15a7" translate="yes" xml:space="preserve">
          <source>The suggested structure for a Redux store is to split the state object into multiple &amp;ldquo;slices&amp;rdquo; or &amp;ldquo;domains&amp;rdquo; by key, and provide a separate reducer function to manage each individual data slice. This is similar to how the standard Flux pattern has multiple independent stores, and Redux provides the &lt;a href=&quot;../api/combinereducers&quot;&gt;&lt;code&gt;combineReducers&lt;/code&gt;&lt;/a&gt; utility function to make this pattern easier. However, it's important to note that &lt;code&gt;combineReducers&lt;/code&gt; is &lt;em&gt;not&lt;/em&gt; required&amp;mdash;it is simply a utility function for the common use case of having a single reducer function per state slice, with plain JavaScript objects for the data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19890ee5401ad9b13da13113d9a0a8f02936561b" translate="yes" xml:space="preserve">
          <source>The term &quot;&lt;em&gt;sub-reducer&lt;/em&gt;&quot; has also been used in various discussions to mean any function that is not the root reducer, although the term is not very precise. Some people may also refer to some functions as &quot;&lt;em&gt;business logic&lt;/em&gt;&quot; (functions that relate to application-specific behavior) or &quot;&lt;em&gt;utility functions&lt;/em&gt;&quot; (generic functions that are not application-specific).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4efb799026840b45f617b41420282694075bcbb5" translate="yes" xml:space="preserve">
          <source>The two most common ways to specialize a reducer are to generate new action constants with a given prefix or suffix, or to attach additional info inside the action object. Here's what those might look like:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8244d8d3077f561bcd0f5377b25ede16bd17a723" translate="yes" xml:space="preserve">
          <source>The whole state of your app is stored in an object tree inside a single &lt;em&gt;store&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b55a43c532a7c8e9947bf52f67dd941ff93ac2e5" translate="yes" xml:space="preserve">
          <source>The work done by Redux generally falls into a few areas: processing actions in middleware and reducers (including object duplication for immutable updates), notifying subscribers after actions are dispatched, and updating UI components based on the state changes. While it's certainly &lt;em&gt;possible&lt;/em&gt; for each of these to become a performance concern in sufficiently complex situations, there's nothing inherently slow or inefficient about how Redux is implemented. In fact, React Redux in particular is heavily optimized to cut down on unnecessary re-renders, and React-Redux v5 shows noticeable improvements over earlier versions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e621bbd33e777ec7ef3871509510242d1781c64a" translate="yes" xml:space="preserve">
          <source>The work on Redux was &lt;a href=&quot;https://www.patreon.com/reactdx&quot;&gt;funded by the community&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e58a6fbd2c7776a43fa3f20f5482c786c5abf51" translate="yes" xml:space="preserve">
          <source>Then your reducer might look like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0b64fceb751659a715e3ef58186964669c75267" translate="yes" xml:space="preserve">
          <source>Then, add this to &lt;code&gt;scripts&lt;/code&gt; in your &lt;code&gt;package.json&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2304d640a16ae9bfebc931161006126d186e787e" translate="yes" xml:space="preserve">
          <source>Then:</source>
          <target state="translated">Then:</target>
        </trans-unit>
        <trans-unit id="e96f86541d1773854c7bcc0e179868209a9a8589" translate="yes" xml:space="preserve">
          <source>There are a few important bits here:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d06a233fcb86cede2504f1d8109e3efa70aa46c" translate="yes" xml:space="preserve">
          <source>There are a number of community packages that implement various approaches for storing per-component state in a Redux store instead, such as &lt;a href=&quot;https://github.com/tonyhb/redux-ui&quot;&gt;redux-ui&lt;/a&gt;, &lt;a href=&quot;https://github.com/tomchentw/redux-component&quot;&gt;redux-component&lt;/a&gt;, &lt;a href=&quot;https://github.com/threepointone/redux-react-local&quot;&gt;redux-react-local&lt;/a&gt;, and more. It's also possible to apply Redux's principles and concept of reducers to the task of updating local component state as well, along the lines of &lt;code&gt;this.setState( (previousState) =&amp;gt; reducer(previousState, someAction))&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0014d11cb95b6c4884244108322b1ff44ccf44a1" translate="yes" xml:space="preserve">
          <source>There are also utility libraries to aid in generating action creators, such as &lt;a href=&quot;https://github.com/pauldijou/redux-act&quot;&gt;redux-act&lt;/a&gt; and &lt;a href=&quot;https://github.com/acdlite/redux-actions&quot;&gt;redux-actions&lt;/a&gt;. These can help reduce boilerplate code and enforce adherence to standards such as &lt;a href=&quot;https://github.com/acdlite/flux-standard-action&quot;&gt;Flux Standard Action (FSA)&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d7c3fb839d1de9f174190d1095682848236da15" translate="yes" xml:space="preserve">
          <source>There are frameworks claiming to be similar to Flux, but without a concept of action objects. In terms of being predictable, this is a step backwards from Flux or Redux. If there are no serializable plain object actions, it is impossible to record and replay user sessions, or to implement &lt;a href=&quot;https://www.youtube.com/watch?v=xsSnOQynTHs&quot;&gt;hot reloading with time travel&lt;/a&gt;. If you'd rather modify data directly, you don't need Redux.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cfa801b0cb8664a9ae599fb04c53df6ce12bf658" translate="yes" xml:space="preserve">
          <source>There are no multiple models&amp;mdash;just a state subtree that you want to keep track of.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="420577e78b88dd5a407cd7bcfca83fee052024be" translate="yes" xml:space="preserve">
          <source>There are several important ideas to be aware of when using &lt;code&gt;combineReducers&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31dadb8b332eafb541ac48d1ad1b0591872b1ba8" translate="yes" xml:space="preserve">
          <source>There are some simple tweaks that can be made to this reducer. First, repeated &lt;code&gt;if&lt;/code&gt;/&lt;code&gt;else&lt;/code&gt; statements quickly grow tiresome, so it's very common to use &lt;code&gt;switch&lt;/code&gt; statements instead. Second, we can use ES6's default parameter values to handle the initial &quot;no existing data&quot; case. With those changes, the reducer would look like:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0306be0f55c35417f1fb94a7a6a33b60158cc20" translate="yes" xml:space="preserve">
          <source>There are two main ways to initialize state for your application. The &lt;code&gt;createStore&lt;/code&gt; method can accept an optional &lt;code&gt;preloadedState&lt;/code&gt; value as its second argument. Reducers can also specify an initial value by looking for an incoming state argument that is &lt;code&gt;undefined&lt;/code&gt;, and returning the value they'd like to use as a default. This can either be done with an explicit check inside the reducer, or by using the ES6 default argument value syntax: &lt;code&gt;function myReducer(state = someDefaultValue, action)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="597620fe64267cbabf96711d555ec9adca761b24" translate="yes" xml:space="preserve">
          <source>There are two ways to define the initial shape and contents of your store's state. First, the &lt;code&gt;createStore&lt;/code&gt; function can take &lt;code&gt;preloadedState&lt;/code&gt; as its second argument. This is primarily intended for initializing the store with state that was previously persisted elsewhere, such as the browser's localStorage. The other way is for the root reducer to return the initial state value when the state argument is &lt;code&gt;undefined&lt;/code&gt;. These two approaches are described in more detail in &lt;a href=&quot;initializingstate&quot;&gt;Initializing State&lt;/a&gt;, but there are some additional concerns to be aware of when using &lt;code&gt;combineReducers&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56409b9a5183b19808817fe73374f07883b83a73" translate="yes" xml:space="preserve">
          <source>There is an important gotcha: you need to remember to append &lt;code&gt;.present&lt;/code&gt; to the current state when you retrieve it. You may also check &lt;code&gt;.past.length&lt;/code&gt; and &lt;code&gt;.future.length&lt;/code&gt; to determine whether to enable or to disable the Undo and Redo buttons, respectively.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5f4b92d40c5193a89ef2d973b4dea0cf41db580" translate="yes" xml:space="preserve">
          <source>There is no &amp;ldquo;right&amp;rdquo; answer for this. Some users prefer to keep every single piece of data in Redux, to maintain a fully serializable and controlled version of their application at all times. Others prefer to keep non-critical or UI state, such as &amp;ldquo;is this dropdown currently open&amp;rdquo;, inside a component's internal state.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90170588b4fa6d7f622136b2c7f8e6e07e225db6" translate="yes" xml:space="preserve">
          <source>There should only be a single store in a Redux app, as the composition happens on the reducer level.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="992aa1eaaf62b5438b3953fb40feec345ca3edf1" translate="yes" xml:space="preserve">
          <source>There should only be a single store in your app.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="168b0114042369684de79c5fdf6b3e093b40d171" translate="yes" xml:space="preserve">
          <source>There will &lt;em&gt;rarely&lt;/em&gt; be a 1-to-1 correspondence between your UI tree and your state shape. The exception to that might be if you are explicitly tracking various aspects of UI data in your Redux store as well, but even then the shape of the UI data and the shape of the domain data would likely be different.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1d2ef296166ce0ecc73c05efc95f385ad2e7495" translate="yes" xml:space="preserve">
          <source>There's a couple ways Redux-ORM can be used to perform updates. First, the Redux-ORM docs suggest defining reducer functions on each Model subclass, then including the auto-generated combined reducer function into your store:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51018a56e34b691dd014441eabce29bdbcbc8652" translate="yes" xml:space="preserve">
          <source>There's no single clear answer to exactly what pieces of logic should go in a reducer or an action creator. Some developers prefer to have &amp;ldquo;fat&amp;rdquo; action creators, with &amp;ldquo;thin&amp;rdquo; reducers that simply take the data in an action and blindly merge it into the corresponding state. Others try to emphasize keeping actions as small as possible, and minimize the usage of &lt;code&gt;getState()&lt;/code&gt; in an action creator. (For purposes of this question, other async approaches such as sagas and observables fall in the &quot;action creator&quot; category.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28edc5708a2301951ec09979956f382164d459ec" translate="yes" xml:space="preserve">
          <source>There's no specific rule for how you should structure your actions. Using an async middleware like Redux Thunk certainly enables scenarios such as dispatching multiple distinct but related actions in a row, dispatching actions to represent progression of an AJAX request, dispatching actions conditionally based on state, or even dispatching an action and checking the updated state immediately afterwards.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3919f394ea7f45a742af3ee7c733b38c93a6700c" translate="yes" xml:space="preserve">
          <source>These &lt;code&gt;&amp;lt;SubApp&amp;gt;&lt;/code&gt;s will be completely independent. They won't share data or actions, and won't see or communicate with each other.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7403f67d70c46d230048ba2241787084beea6a95" translate="yes" xml:space="preserve">
          <source>These are all normal React components, so we won't examine them in detail. We write functional stateless components unless we need to use local state or the lifecycle methods. This doesn't mean that presentational components &lt;em&gt;have to&lt;/em&gt; be functions&amp;mdash;it's just easier to define them this way. If and when you need to add local state, lifecycle methods, or performance optimizations, you can convert them to classes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad42b9f4f6a7ded866b5edd040dee5736736ad79" translate="yes" xml:space="preserve">
          <source>These are some use cases and code snippets to get you started with Redux in a real app. They assume you understand the topics in &lt;a href=&quot;../basics/index&quot;&gt;basic&lt;/a&gt; and &lt;a href=&quot;../advanced/index&quot;&gt;advanced&lt;/a&gt; tutorials.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d704feeae1991cd907524cb1c0f7f6fcf0575629" translate="yes" xml:space="preserve">
          <source>These are the basics of the React Redux API, but there are a few shortcuts and power options so we encourage you to check out &lt;a href=&quot;https://github.com/reactjs/react-redux&quot;&gt;its documentation&lt;/a&gt; in detail. In case you are worried about &lt;code&gt;mapStateToProps&lt;/code&gt; creating new objects too often, you might want to learn about &lt;a href=&quot;../recipes/computingderiveddata&quot;&gt;computing derived data&lt;/a&gt; with &lt;a href=&quot;https://github.com/reactjs/reselect&quot;&gt;reselect&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c26d64685238ce4dbcec18d03116138fa0bb9a0" translate="yes" xml:space="preserve">
          <source>These basic patterns allow you to do things like having multiple instances of a smart connected component within the UI, or reuse common logic for generic capabilities such as pagination or sorting.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c558d4ebff40066937cf4fb4becc7cf460cf85d8" translate="yes" xml:space="preserve">
          <source>These new functions would typically fall into one of three categories:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84e2759c050a4d6ddff70ba97270b913483ea299" translate="yes" xml:space="preserve">
          <source>These were the actions governed by the user interaction. We will also have another kind of action, governed by the network requests. We will see how to dispatch them later, but for now, we just want to define them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="734284615f4837016bf49d7e82571425d6842e5d" translate="yes" xml:space="preserve">
          <source>They can also press a &amp;ldquo;refresh&amp;rdquo; button to update it:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d52a5e55f55bac64300f695ab9f42bb206bbca5" translate="yes" xml:space="preserve">
          <source>They can provide a useful alternative to writing manual immutable update logic.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19c5827cb1612ac05aed827f421dec6e57380bb2" translate="yes" xml:space="preserve">
          <source>They describe the &lt;em&gt;look&lt;/em&gt; but don't know &lt;em&gt;where&lt;/em&gt; the data comes from, or &lt;em&gt;how&lt;/em&gt; to change it. They only render what's given to them. If you migrate from Redux to something else, you'll be able to keep all these components exactly the same. They have no dependency on Redux.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1159323b5c6aa9389a4540485a8db710c7036ca" translate="yes" xml:space="preserve">
          <source>Think of an action as a very brief snippet of news. &amp;ldquo;Mary liked article 42.&amp;rdquo; or &amp;ldquo;&amp;lsquo;Read the Redux docs.' was added to the list of todos.&amp;rdquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4665b478e044391de06bdde9d3e79d16edd37cb" translate="yes" xml:space="preserve">
          <source>Thinking in terms of state and state shape</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91e52043da589de141b602e3e454bd09930f4ace" translate="yes" xml:space="preserve">
          <source>This API is intended as a low-level primitive with no dependencies or complications, and can be used to build higher-level subscription logic. UI bindings such as React Redux can create a subscription for each connected component. It is also possible to write functions that can intelligently compare the old state vs the new state, and execute additional logic if certain pieces have changed. Examples include &lt;a href=&quot;https://github.com/jprichardson/redux-watch&quot;&gt;redux-watch&lt;/a&gt;, &lt;a href=&quot;https://github.com/ashaffer/redux-subscribe&quot;&gt;redux-subscribe&lt;/a&gt; and &lt;a href=&quot;https://github.com/ivantsov/redux-subscriber&quot;&gt;redux-subscriber&lt;/a&gt; which offer different approaches to specifying subscriptions and handling changes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5bc9835804c7bf5d69285a0788d4ec1618aaf13" translate="yes" xml:space="preserve">
          <source>This allows you to gradually rewrite every Flux Store in your app as a reducer, but still export &lt;code&gt;createFluxStore(reducer)&lt;/code&gt; so the rest of your app is not aware that this is happening and sees the Flux stores.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a519a41d84a5c9b747a85285b24fa851ba29b4a3" translate="yes" xml:space="preserve">
          <source>This approach makes it very clear what's happening for the &lt;code&gt;&quot;ADD_COMMENTS&quot;&lt;/code&gt; case, but it does require nested updating logic, and some specific knowledge of the state tree shape. Depending on how you want to compose your reducer logic, this may or may not be desired.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5b98104ccad15391aa66227a6551d8fc9f45bc0" translate="yes" xml:space="preserve">
          <source>This architecture might seem like an overkill for a counter app, but the beauty of this pattern is how well it scales to large and complex apps. It also enables very powerful developer tools, because it is possible to trace every mutation to the action that caused it. You can record user sessions and reproduce them just by replaying every action.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af9a7125c23f1d9f99cfc569936c1de486169781" translate="yes" xml:space="preserve">
          <source>This article is divided into an in-depth intro to help you grok the concept, and &lt;a href=&quot;#seven-examples&quot;&gt;a few practical examples&lt;/a&gt; to show the power of middleware at the very end. You may find it helpful to switch back and forth between them, as you flip between feeling bored and inspired.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8cbc20dacc9ba008323bf48c00c65d6371405cdd" translate="yes" xml:space="preserve">
          <source>This assumes you are using &lt;a href=&quot;https://www.npmjs.com/&quot;&gt;npm&lt;/a&gt; as your package manager.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36abb8e476a11a68638ccf33afca7adf0759ffbc" translate="yes" xml:space="preserve">
          <source>This can be prevented by using &lt;code&gt;toJS()&lt;/code&gt; in a Higher Order Component, as discussed in the &lt;a href=&quot;#immutable-js-best-practices&quot;&gt;Best Practices section&lt;/a&gt; below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80afa0a6f3a3ec186233802f8708789e06fce0fb" translate="yes" xml:space="preserve">
          <source>This chain of middleware is defined by the arguments passed to the &lt;code&gt;applyMiddleware&lt;/code&gt; function used when creating a store. Defining multiple chains will not work correctly, as they would have distinctly different &lt;code&gt;dispatch&lt;/code&gt; references and the different chains would effectively be disconnected.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1fe353295b682382d86ef4ed3fc4f643382d4c5" translate="yes" xml:space="preserve">
          <source>This comment sums up the dichotomy nicely:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="324ca41cb1e96cbdc6d22ac4f0dc0ea7baff76ab" translate="yes" xml:space="preserve">
          <source>This complexity is difficult to handle as &lt;strong&gt;we're mixing two concepts&lt;/strong&gt; that are very hard for the human mind to reason about: &lt;strong&gt;mutation and asynchronicity.&lt;/strong&gt; I call them &lt;a href=&quot;https://en.wikipedia.org/wiki/Diet_Coke_and_Mentos_eruption&quot;&gt;Mentos and Coke&lt;/a&gt;. Both can be great in separation, but together they create a mess. Libraries like &lt;a href=&quot;http://facebook.github.io/react&quot;&gt;React&lt;/a&gt; attempt to solve this problem in the view layer by removing both asynchrony and direct DOM manipulation. However, managing the state of your data is left up to you. This is where Redux enters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bed55034327edcc9ff177976049dde9f1a8518bf" translate="yes" xml:space="preserve">
          <source>This could be expanded in a number of ways. For example, an application that does a lot of editing of entities might want to keep two sets of &quot;tables&quot; in the state, one for the &quot;current&quot; item values and one for the &quot;work-in-progress&quot; item values. When an item is edited, its values could be copied into the &quot;work-in-progress&quot; section, and any actions that update it would be applied to the &quot;work-in-progress&quot; copy, allowing the editing form to be controlled by that set of data while another part of the UI still refers to the original version. &quot;Resetting&quot; the edit form would simply require removing the item from the &quot;work-in-progress&quot; section and re-copying the original data from &quot;current&quot; to &quot;work-in-progress&quot;, while &quot;applying&quot; the edits would involve copying the values from the &quot;work-in-progress&quot; section to the &quot;current&quot; section.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="707c74a21f1746d2a960832a6b8a8cb90405d2f5" translate="yes" xml:space="preserve">
          <source>This ensures that neither the views nor the network callbacks will ever write directly to the state. Instead, they express an intent to transform the state. Because all changes are centralized and happen one by one in a strict order, there are no subtle race conditions to watch out for. As actions are just plain objects, they can be logged, serialized, stored, and later replayed for debugging or testing purposes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9210dbb4de5b40a1c13ddea412dbce790a6977d8" translate="yes" xml:space="preserve">
          <source>This example demonstrates how to use &lt;code&gt;compose&lt;/code&gt; to enhance a &lt;a href=&quot;store&quot;&gt;store&lt;/a&gt; with &lt;a href=&quot;applymiddleware&quot;&gt;&lt;code&gt;applyMiddleware&lt;/code&gt;&lt;/a&gt; and a few developer tools from the &lt;a href=&quot;https://github.com/gaearon/redux-devtools&quot;&gt;redux-devtools&lt;/a&gt; package.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6a4f9f87221d4ef2187fb40a3e81e24b1380c59" translate="yes" xml:space="preserve">
          <source>This example demonstrates rendering a deeply nested tree view and representing its state in a normalized form so it is easy to update from reducers. Good rendering performance is achieved by the container components granularly subscribing only to the tree nodes that they render.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23160794e888b31513354f69f0e10e67f1dfbb27" translate="yes" xml:space="preserve">
          <source>This example includes reading from an asynchronous API, fetching data in response to user input, showing loading indicators, caching the response, and invalidating the cache. It uses &lt;a href=&quot;https://github.com/gaearon/redux-thunk&quot;&gt;Redux Thunk&lt;/a&gt; middleware to encapsulate asynchronous side effects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6057ac5d12f923863450854603485d162d2c570a" translate="yes" xml:space="preserve">
          <source>This example includes tests.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41942bb35c722938329a0363bb8f7775d2d0a267" translate="yes" xml:space="preserve">
          <source>This example shows important idiomatic Redux patterns that become important as your app grows. In particular, it shows how to store entities in a normalized way by their IDs, how to compose reducers on several levels, and how to define selectors alongside the reducers so the knowledge about the state shape is encapsulated. It also demonstrates logging with &lt;a href=&quot;https://github.com/fcomb/redux-logger&quot;&gt;Redux Logger&lt;/a&gt; and conditional dispatching of actions with &lt;a href=&quot;https://github.com/gaearon/redux-thunk&quot;&gt;Redux Thunk&lt;/a&gt; middleware.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a2efc02036a88d2c881bcfa8505561b220da980" translate="yes" xml:space="preserve">
          <source>This function does correctly return a shallow copy of the top-level state object, but because the &lt;code&gt;nestedState&lt;/code&gt; variable was still pointing at the existing object, the state was directly mutated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25186369f150cbdf9cc822a9194a9d16061eb99f" translate="yes" xml:space="preserve">
          <source>This function helps you organize your reducers to manage their own slices of state, similar to how you would have different Flux Stores to manage different state. With Redux, there is just one store, but &lt;code&gt;combineReducers&lt;/code&gt; helps you keep the same logical division between reducers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b6fed5d5eb1e62767d1062998c1daeac688f17a" translate="yes" xml:space="preserve">
          <source>This function is mildly opinionated and is skewed towards helping beginners avoid common pitfalls. This is why it attempts to enforce some rules that you don't have to follow if you write the root reducer manually.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd18efd9ce822617a56ac05dccc19791483c2b46" translate="yes" xml:space="preserve">
          <source>This has the effect of spreading Immutable.JS across your entire codebase, including potentially your components, where you may prefer not to have such external dependencies. Your entire codebase must know what is, and what is not, an Immutable.JS object. It also makes removing Immutable.JS from your app difficult in the future, should you ever need to.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="452cdbd1b5122ca3249e3d165f402ca90ca1b7d3" translate="yes" xml:space="preserve">
          <source>This helper is just a convenience! You can write your own &lt;code&gt;combineReducers&lt;/code&gt; that &lt;a href=&quot;https://github.com/acdlite/reduce-reducers&quot;&gt;works differently&lt;/a&gt;, or even assemble the state object from the child reducers manually and write a root reducing function explicitly, like you would write any other function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ebc9476c901cfaf7607621afa617534b0f6a0851" translate="yes" xml:space="preserve">
          <source>This implementation isn't usable because it leaves out three important questions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5af3f9d227b391b86b28a8a3163dbc7f9de3e1f6" translate="yes" xml:space="preserve">
          <source>This installs the package that provides the &lt;code&gt;undoable&lt;/code&gt; reducer enhancer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="930f0e45185d6f76c2ee37901cdc264e626e46fc" translate="yes" xml:space="preserve">
          <source>This is a basic demonstration of &lt;a href=&quot;../recipes/serverrendering&quot;&gt;server rendering&lt;/a&gt; with Redux and React. It shows how to prepare the initial store state on the server, and pass it down to the client so the client store can boot up from an existing state.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b54fe358811791887040e3628c693b0d5817b4bb" translate="yes" xml:space="preserve">
          <source>This is a functional programming utility, and is included in Redux as a convenience.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="902e57be6eebfba5d7e76929983c6c6258e9c271" translate="yes" xml:space="preserve">
          <source>This is a glossary of the core terms in Redux, along with their type signatures. The types are documented using &lt;a href=&quot;http://flowtype.org/docs/quick-reference.html&quot;&gt;Flow notation&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6257b5ee434e5a7cbdec29bbbff466cb0f6850ea" translate="yes" xml:space="preserve">
          <source>This is a long and complex topic, with a wide variety of opinions on how code should be organized and what approaches should be used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6d24f497bb054862fa8e8a2557607b7b064ec7c" translate="yes" xml:space="preserve">
          <source>This is a particular issue if you use &lt;code&gt;toJS()&lt;/code&gt; in a wrapped component&amp;rsquo;s &lt;code&gt;mapStateToProps&lt;/code&gt; function, as React-Redux shallowly compares each value in the returned props object. For example, the value referenced by the &lt;code&gt;todos&lt;/code&gt; prop returned from &lt;code&gt;mapStateToProps&lt;/code&gt; below will always be a different object, and so will fail a shallow equality check.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf9d83f291ff6e78c4b43b491bded250a9eb9edd" translate="yes" xml:space="preserve">
          <source>This is a place to share common problems and solutions to them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a195446956524ddebe615c6b4dea2d58bc44adbd" translate="yes" xml:space="preserve">
          <source>This is a variation on the previous example. It is almost identical, but additionally shows how wrapping your reducer with &lt;a href=&quot;https://github.com/omnidan/redux-undo&quot;&gt;Redux Undo&lt;/a&gt; lets you add a Undo/Redo functionality to your app with a few lines of code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b62f6d500da56c6baedf79190677dba7f4254d1" translate="yes" xml:space="preserve">
          <source>This is all we need to know for now. The particular mechanism to dispatch these actions together with network requests will be discussed later.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb3caec81383b1f746ae38119a27f33a05999d77" translate="yes" xml:space="preserve">
          <source>This is already closer to what we want! No matter where we dispatch an action, it is guaranteed to be logged. Monkeypatching never feels right, but we can live with this for now.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9084a2b0e6567c9efcaf4f6cafe694a18afbf28" translate="yes" xml:space="preserve">
          <source>This is already looking good! When the app is larger, we can split the reducers into separate files and keep them completely independent and managing different data domains.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e84b6d20c865b455ea1e36d59bd6ef0bdf66609" translate="yes" xml:space="preserve">
          <source>This is basically the whole idea of Redux. Note that we haven&amp;rsquo;t used any Redux APIs. It comes with a few utilities to facilitate this pattern, but the main idea is that you describe how your state is updated over time in response to action objects, and 90% of the code you write is just plain JavaScript, with no use of Redux itself, its APIs, or any magic.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d949a0761f2189999f3ad52f3288abf9de3a495" translate="yes" xml:space="preserve">
          <source>This is because two variables that reference the same object will &lt;em&gt;always&lt;/em&gt; be equal, regardless of whether the object&amp;rsquo;s values changes or not, as they're both referencing the same object. Thus, the following will always return true:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc3fc2dfb4922ecd32a6e14514c4b08ea0d0030f" translate="yes" xml:space="preserve">
          <source>This is it! Run &lt;code&gt;npm install&lt;/code&gt; and &lt;code&gt;npm start&lt;/code&gt; in the &lt;a href=&quot;https://github.com/reactjs/redux/tree/master/examples/todos-with-undo&quot;&gt;example folder&lt;/a&gt; and try it out!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e796128df0ba3814b3885d8d0519693c9b9ad24" translate="yes" xml:space="preserve">
          <source>This is much less typing! If you'd like, you can still have &amp;ldquo;vanilla&amp;rdquo; action creators like &lt;code&gt;loadPostsSuccess&lt;/code&gt; which you'd use from a container &lt;code&gt;loadPosts&lt;/code&gt; action creator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb9aca90fe801173ceb6b822d63183ddbc28a375" translate="yes" xml:space="preserve">
          <source>This is the basic structure that a typical Redux reducer function uses.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="368280f7bdb144d919f7347598b1d6a5599ac6c1" translate="yes" xml:space="preserve">
          <source>This is the best example to get a deeper understanding of how the state updates work together with components in Redux. It shows how reducers can delegate handling actions to other reducers, and how you can use &lt;a href=&quot;https://github.com/reactjs/react-redux&quot;&gt;React Redux&lt;/a&gt; to generate container components from your presentational components.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c0930eaef048e02ff0d006be39c4d3167f83671" translate="yes" xml:space="preserve">
          <source>This is the classical &lt;a href=&quot;http://todomvc.com/&quot;&gt;TodoMVC&lt;/a&gt; example. It's here for the sake of comparison, but it covers the same points as the Todos example.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="881a664225fae7f2e081dcac2b6413fc1deac116" translate="yes" xml:space="preserve">
          <source>This is the complete source code of the Reddit headline fetching example we built during the &lt;a href=&quot;index&quot;&gt;advanced tutorial&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b128d306a5e5a953daf8f443d8e01801093f1c92" translate="yes" xml:space="preserve">
          <source>This is the complete source code of the tiny todo app we built during the &lt;a href=&quot;index&quot;&gt;basics tutorial&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc3837809c1d7850b463c21cec48fd076bd0bf1f" translate="yes" xml:space="preserve">
          <source>This is the most advanced example. It is dense by design. It covers keeping fetched entities in a normalized cache, implementing a custom middleware for API calls, rendering partially loaded data, pagination, caching responses, displaying error messages, and routing. Additionally, it includes Redux DevTools.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c30e411c7f43679e4c0b5f0869178bc002c0cf5" translate="yes" xml:space="preserve">
          <source>This is the most basic example of using Redux together with React. For simplicity, it re-renders the React component manually when the store changes. In real projects, you will likely want to use the highly performant &lt;a href=&quot;https://github.com/reactjs/react-redux&quot;&gt;React Redux&lt;/a&gt; bindings instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45b51f5c0e7ff3cf14ba10063daa88c68ff8ff42" translate="yes" xml:space="preserve">
          <source>This is worth emphasising: &lt;em&gt;If the reducers all return the same &lt;code&gt;state&lt;/code&gt; object passed to them, then &lt;code&gt;combineReducers&lt;/code&gt; will return the &lt;em&gt;current&lt;/em&gt; root state object, not the newly updated one.&lt;/em&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="903f50f13ad03393a3f2547dd8b1848ec4cbcd1e" translate="yes" xml:space="preserve">
          <source>This issue can be avoided by &lt;a href=&quot;https://medium.com/@dtinth/immutable-js-persistent-data-structures-and-structural-sharing-6d163fbd73d2#.z1g1ofrsi&quot;&gt;uncoupling your application logic from your data structures&lt;/a&gt;, as outlined in the &lt;a href=&quot;#immutable-js-best-practices&quot;&gt;best practices section&lt;/a&gt; below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="584dbd560993face7c721c8a75c7abf6bb57ad23" translate="yes" xml:space="preserve">
          <source>This lets us write more sophisticated async control flow gradually, while the consuming code can stay pretty much the same:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2f3d7f982ac8af695c62a8985d12ce4b3081ba8" translate="yes" xml:space="preserve">
          <source>This makes it awkward to interoperate not just with your own code, but also with other libraries, such as lodash or ramda, that expect plain JavaScript objects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8150ebb2edf39875f24f4fc61c627e5d2769703b" translate="yes" xml:space="preserve">
          <source>This makes it easier for bundling tools to cut out unneeded modules and reduces the size of your builds.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf383b9f03a180ee3b947f3cafa81eed01efef2e" translate="yes" xml:space="preserve">
          <source>This makes it easy to create universal apps, as the state from your server can be serialized and hydrated into the client with no extra coding effort. A single state tree also makes it easier to debug or inspect an application; it also enables you to persist your app's state in development, for a faster development cycle. Some functionality which has been traditionally difficult to implement - Undo/Redo, for example - can suddenly become trivial to implement, if all of your state is stored in a single tree.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7a113870425edd65d4dff2ca88a4e416744f63a" translate="yes" xml:space="preserve">
          <source>This makes it easy to migrate both to and from Redux.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6870275e1cdc117fad62310af9bce1130ddad1e5" translate="yes" xml:space="preserve">
          <source>This makes them portable and easy to test.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0117d509de0b7ec1b99dd909691fb32267c2c284" translate="yes" xml:space="preserve">
          <source>This means that all data in an application follows the same lifecycle pattern, making the logic of your app more predictable and easier to understand. It also encourages data normalization, so that you don't end up with multiple, independent copies of the same data that are unaware of one another.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f34593a4e623dbcb3f458552c5cd1622e7dfef63" translate="yes" xml:space="preserve">
          <source>This means that implementing Undo and Redo in an MVC application usually forces you to rewrite parts of your application to use a specific data mutation pattern like &lt;a href=&quot;https://en.wikipedia.org/wiki/Command_pattern&quot;&gt;Command&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc5b85dff1510174b626939c1704dc6629908600" translate="yes" xml:space="preserve">
          <source>This means that we could also write the insert and remove functions like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cbde7ae30a809fab338b95f7689a7203a8a17b4d" translate="yes" xml:space="preserve">
          <source>This means you need to access your state with &lt;code&gt;state.todos.present&lt;/code&gt; instead of just &lt;code&gt;state.todos&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="386fbee61a70c4b922b5caaee2907587414b6c05" translate="yes" xml:space="preserve">
          <source>This mutated copy is a &lt;em&gt;separate&lt;/em&gt; object from that passed into the function, and so when it is returned, a shallow check will identify it as being a different object from that passed in, and so will fail.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca74d22b1244f1a72be0424378b1b4d590fc1e51" translate="yes" xml:space="preserve">
          <source>This new tree is now the next state of your app! Every listener registered with &lt;a href=&quot;../api/store#subscribe&quot;&gt;&lt;code&gt;store.subscribe(listener)&lt;/code&gt;&lt;/a&gt; will now be invoked; listeners may call &lt;a href=&quot;../api/store#getState&quot;&gt;&lt;code&gt;store.getState()&lt;/code&gt;&lt;/a&gt; to get the current state.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="375420430845c3b31d4e0a7e67b9eb12e1e064ee" translate="yes" xml:space="preserve">
          <source>This object is like a &amp;ldquo;model&amp;rdquo; except that there are no setters. This is so that different parts of the code can&amp;rsquo;t change the state arbitrarily, causing hard-to-reproduce bugs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10b96d7bed30bd18afc4040b966809bdd54e8f1c" translate="yes" xml:space="preserve">
          <source>This part is often confusing to beginners, because it is not immediately clear what information describes the state of an asynchronous application, and how to organize it in a single tree.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="726e2aa43c64e8c49eac59a956f48c4350c3da4d" translate="yes" xml:space="preserve">
          <source>This pattern is &lt;em&gt;not&lt;/em&gt; recommended for parts of the same app that share data. However, it can be useful when the bigger app has zero access to the smaller apps' internals, and we'd like to keep the fact that they are implemented with Redux as an implementation detail. Each component instance will have its own store, so they won't &amp;ldquo;know&amp;rdquo; about each other.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4797209ab61d0cba555b0ba999e5df76ff770f2a" translate="yes" xml:space="preserve">
          <source>This problem is caused predominantly by returning a mutated state object from a Redux reducer. With Immutable.JS, this problem simply does not exist, thereby removing a whole class of bugs from your app.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="faee56a051b54fbdf7c577f45ce201c8fd514250" translate="yes" xml:space="preserve">
          <source>This produces the desired effect, but you wouldn't want to do it every time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="112bf8b2448707863e70924e561703fd39856861" translate="yes" xml:space="preserve">
          <source>This project adheres to &lt;a href=&quot;http://semver.org/&quot;&gt;Semantic Versioning&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ca436d5a0e732efb5749020024d046800e0f232" translate="yes" xml:space="preserve">
          <source>This requires the least amount of work on the reducer side, but does require that the action creator potentially do a fair amount of work to organize the data into the correct shape before the action is dispatched. It also doesn't handle trying to delete an item.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e32344333ff16130ad1fc8d8911f91949fab05e" translate="yes" xml:space="preserve">
          <source>This section documents the complete Redux API. Keep in mind that Redux is only concerned with managing the state. In a real app, you'll also want to use UI bindings like &lt;a href=&quot;https://github.com/gaearon/react-redux&quot;&gt;react-redux&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e4e2606978c9371c54128bb24c749164cec9f04" translate="yes" xml:space="preserve">
          <source>This section introduces a hypothetical extension to our app that allows it to support multiple Todo Lists. Please note that a full implementation of this extension requires changes to the reducers, components, actions etc. that aren't directly relevant to the topics discussed and have been omitted for brevity.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d91b745838a2d3e64174d93a13b4a7f1adc65cd3" translate="yes" xml:space="preserve">
          <source>This state shape better reflects the data involved, because we took care to set up the keys we passed to &lt;code&gt;combineReducers&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="125428949dd664c2936fb5646d4a4a0944ef542f" translate="yes" xml:space="preserve">
          <source>This state structure is much flatter overall. Compared to the original nested format, this is an improvement in several ways:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94ba4d7a3e72dccff4a9100d843bda3c33581bff" translate="yes" xml:space="preserve">
          <source>This was all very informative, but can't we just drop a library and use it instead of implementing &lt;code&gt;undoable&lt;/code&gt; ourselves? Sure, we can! Meet &lt;a href=&quot;https://github.com/omnidan/redux-undo&quot;&gt;Redux Undo&lt;/a&gt;, a library that provides simple Undo and Redo functionality for any part of your Redux tree.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96ab6b14f2ef0811b01a8fd50008edc6febd0745" translate="yes" xml:space="preserve">
          <source>This wasn't difficult, was it? Redux doesn't provide such a helper function by default because there are many ways to write it. Maybe you want it to automatically convert plain JS objects to Immutable objects to hydrate the server state. Maybe you want to merge the returned state with the current state. There may be different approaches to a &amp;ldquo;catch all&amp;rdquo; handler. All of this depends on the conventions you choose for your team on a specific project.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="445c1e6f198a1adb4c272f78fb177f8661af0686" translate="yes" xml:space="preserve">
          <source>This way every instance will be independent.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92e38ef43aaabbe31217e626c55343afb37a1c0f" translate="yes" xml:space="preserve">
          <source>This, together with its performance and rich API for data manipulation, is why Immutable.JS is worth the effort.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a60662bb0cf6dca00077914648ad22d8b2ebadfe" translate="yes" xml:space="preserve">
          <source>Three Principles</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45a585aa3738a0a8dc2ee89ca5d822a00a010018" translate="yes" xml:space="preserve">
          <source>Thunk middleware is just one example of middleware. Middleware is not about &amp;ldquo;letting you dispatch functions&amp;rdquo;. It's about letting you dispatch anything that the particular middleware you use knows how to handle. Thunk middleware adds a specific behavior when you dispatch functions, but it really depends on the middleware you use.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="031dd77e620cd8fc8065335ff0e03be8cb20884f" translate="yes" xml:space="preserve">
          <source>Time-travel debugging requires that reducers be pure functions with no side effects, so that you can correctly jump between different states.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4cf1b54b003a59c279d1ba0b615a8a5f3459ca8c" translate="yes" xml:space="preserve">
          <source>Tips</source>
          <target state="translated">Tips</target>
        </trans-unit>
        <trans-unit id="ee1f5ebc6cc52d4f51b113f5097b8455a407c4ed" translate="yes" xml:space="preserve">
          <source>Tips For a Better Redux Architecture: Lessons for Enterprise Scale</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="901c769f8e578666848aa3aae81fe0b1028b6236" translate="yes" xml:space="preserve">
          <source>Tips to Handle Authentication in Redux</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e74f240f49222ea150d6391c54e16b213cd2b1cd" translate="yes" xml:space="preserve">
          <source>To apply multiple store enhancers, you may use &lt;a href=&quot;compose&quot;&gt;&lt;code&gt;compose()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e0f538cbe1b062d76f03414cbe7f487e9b2e5a6" translate="yes" xml:space="preserve">
          <source>To avoid these issues, ensure you follow the recommended &lt;a href=&quot;../recipes/reducers/immutableupdatepatterns&quot;&gt;immutable update patterns for ES6&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f92fd6720446a22647fac455b49ebc045cfee8c" translate="yes" xml:space="preserve">
          <source>To change data</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6565dc46b441e1305f44f9389c074e1086ac2ba7" translate="yes" xml:space="preserve">
          <source>To change something in the state, you need to dispatch an action. An action is a plain JavaScript object (notice how we don&amp;rsquo;t introduce any magic?) that describes what happened. Here are a few example actions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eda24989c78e46dab8c06cd8412d3b18d2d68eab" translate="yes" xml:space="preserve">
          <source>To create it, pass your root &lt;a href=&quot;../glossary#reducer&quot;&gt;reducing function&lt;/a&gt; to &lt;a href=&quot;createstore&quot;&gt;&lt;code&gt;createStore&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac7a33667ce69790c31c3c6959a00eb15d3762e3" translate="yes" xml:space="preserve">
          <source>To do this, it assumes that the wrapped component is pure; that is, that the component will produce the &lt;a href=&quot;https://github.com/reactjs/react-redux/blob/f4d55840a14601c3a5bdc0c3d741fc5753e87f66/docs/troubleshooting.md#my-views-arent-updating-when-something-changes-outside-of-redux&quot;&gt;same results given the same props and state&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29e591a3897c0d0b177067748378b071109328ac" translate="yes" xml:space="preserve">
          <source>To ensure that you may only apply middleware once, it operates on &lt;code&gt;createStore()&lt;/code&gt; rather than on &lt;code&gt;store&lt;/code&gt; itself. Instead of &lt;code&gt;(store, middlewares) =&amp;gt; store&lt;/code&gt;, its signature is &lt;code&gt;(...middlewares) =&amp;gt; (createStore) =&amp;gt; createStore&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b6f0480002ee862ea4e286d796db8dca014c865" translate="yes" xml:space="preserve">
          <source>To hide Redux behind a React API, we can wrap it in a special component that initializes the store in the constructor:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a523db44ce0192bb638d90e57a1f49df365f204" translate="yes" xml:space="preserve">
          <source>To install the stable version:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="598097c2e73e4e488253e6050c3375112c094ef7" translate="yes" xml:space="preserve">
          <source>To learn how to describe asynchronous API calls, read the current state inside action creators, perform side effects, or chain them to execute in a sequence, see the examples for &lt;a href=&quot;applymiddleware&quot;&gt;&lt;code&gt;applyMiddleware&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ed8cb192b488a31ce6935bdfe7a74665d721d67" translate="yes" xml:space="preserve">
          <source>To log the action and state, you can change it to something like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5f1cce2ba9b1ff85191ae7e2687f49081a21c5b" translate="yes" xml:space="preserve">
          <source>To prevent this from happening, you must &lt;em&gt;always return the state slice object that&amp;rsquo;s passed into a reducer if the reducer does not mutate the state.&lt;/em&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89ea208e2cc969561f1309636abe373b57da32a9" translate="yes" xml:space="preserve">
          <source>To read data</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eed3ad29a679d760cf82b7215bd55f2febaeba23" translate="yes" xml:space="preserve">
          <source>To resolve this issue, use a browser extension such as the &lt;a href=&quot;https://chrome.google.com/webstore/detail/immutablejs-object-format/hgldghadipiblonfkkicmgcbbijnpeog&quot;&gt;Immutable.js Object Formatter&lt;/a&gt;, which surfaces your data in Chrome Dev Tools, and hides Immutable.JS&amp;rsquo;s properties when inspecting your data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2401479a503b53af9fbceea514e83457e1c292ef" translate="yes" xml:space="preserve">
          <source>To send the data down to the client, we need to:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ab24a1445cfb045dd93cf66376dc281c3f5f6bd" translate="yes" xml:space="preserve">
          <source>To specify how the actions transform the state tree, you write pure &lt;em&gt;reducers&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50ef1b259d84757adca29f3df1d2d641b6eec11c" translate="yes" xml:space="preserve">
          <source>To sum this up, if you stick to Redux conventions and return the initial state from reducers when they're called with &lt;code&gt;undefined&lt;/code&gt; as the &lt;code&gt;state&lt;/code&gt; argument (the easiest way to implement this is to specify the &lt;code&gt;state&lt;/code&gt; ES6 default argument value), you're going to have a nice useful behavior for combined reducers. &lt;strong&gt;They will prefer the corresponding value in the &lt;code&gt;preloadedState&lt;/code&gt; object you pass to the &lt;code&gt;createStore()&lt;/code&gt; function, but if you didn't pass any, or if the corresponding field is not set, the default &lt;code&gt;state&lt;/code&gt; argument specified by the reducer is chosen instead.&lt;/strong&gt; This approach works well because it provides both initialization and hydration of existing data, but lets individual reducers reset their state if their data was not preserved. Of course you can apply this pattern recursively, as you can use &lt;code&gt;combineReducers()&lt;/code&gt; on many levels, or even compose reducers manually by calling reducers and giving them the relevant part of the state tree.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8cdb0c4afd8333274d4833966816662659fdba2" translate="yes" xml:space="preserve">
          <source>To test the components we make a &lt;code&gt;setup()&lt;/code&gt; helper that passes the stubbed callbacks as props and renders the component with &lt;a href=&quot;http://airbnb.io/enzyme/docs/api/shallow.html&quot;&gt;shallow rendering&lt;/a&gt;. This lets individual tests assert on whether the callbacks were called when expected.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="511c9087c67a4a067c397c7eec06e3c3e446f664" translate="yes" xml:space="preserve">
          <source>To unsubscribe the change listener, invoke the function returned by &lt;code&gt;subscribe&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="898034cb5cc5c4fc7410f57fc7be8100ebeae451" translate="yes" xml:space="preserve">
          <source>To use &lt;code&gt;connect()&lt;/code&gt;, you need to define a special function called &lt;code&gt;mapStateToProps&lt;/code&gt; that tells how to transform the current Redux store state into the props you want to pass to a presentational component you are wrapping. For example, &lt;code&gt;VisibleTodoList&lt;/code&gt; needs to calculate &lt;code&gt;todos&lt;/code&gt; to pass to the &lt;code&gt;TodoList&lt;/code&gt;, so we define a function that filters the &lt;code&gt;state.todos&lt;/code&gt; according to the &lt;code&gt;state.visibilityFilter&lt;/code&gt;, and use it in its &lt;code&gt;mapStateToProps&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b84ac1ca067a403df64cc26ea17e56c8180c71f" translate="yes" xml:space="preserve">
          <source>To use it together with &lt;a href=&quot;http://babeljs.io&quot;&gt;Babel&lt;/a&gt;, you will need to install &lt;code&gt;babel-jest&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="717cd30aec4dd5a323fdb13aff5182c806d12d1b" translate="yes" xml:space="preserve">
          <source>TodoMVC</source>
          <target state="translated">TodoMVC</target>
        </trans-unit>
        <trans-unit id="a4114a83f4c6b03e326fda4a57471ca7c2d9fa96" translate="yes" xml:space="preserve">
          <source>Todos</source>
          <target state="translated">Todos</target>
        </trans-unit>
        <trans-unit id="6426098ad9410ea40ed780712b90e9b1ee4b090c" translate="yes" xml:space="preserve">
          <source>Todos with Undo</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11dbf4818429dd1d9ae43c9b6f0078f50d78eca5" translate="yes" xml:space="preserve">
          <source>Top-Level Exports</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ad8302d110b05d7e02330dac58628134fdcff02" translate="yes" xml:space="preserve">
          <source>Translations</source>
          <target state="translated">Translations</target>
        </trans-unit>
        <trans-unit id="c579263052bf20f3a459fb334a149d298234c3f6" translate="yes" xml:space="preserve">
          <source>Tree View</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="285ec850c11d78bac10f6bfa31b69a37f1b257c9" translate="yes" xml:space="preserve">
          <source>Troubleshooting</source>
          <target state="translated">Troubleshooting</target>
        </trans-unit>
        <trans-unit id="63ae2d8b43c9bd5c5d9a4a0152b1f52dd71f01f5" translate="yes" xml:space="preserve">
          <source>Troubleshooting: My views aren&amp;rsquo;t updating when something changes outside of Redux</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5984c35d0b5720f5ededf659b1e4bb94f25efcc" translate="yes" xml:space="preserve">
          <source>Troubleshooting: Never mutate reducer arguments</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2569e4c2636e5cc4f4bc61ec91ab96c592717fa" translate="yes" xml:space="preserve">
          <source>Troubleshooting: Nothing happens when I dispatch an action</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c79bb1da81bc4cdf1612625ab31bb11eaf51494" translate="yes" xml:space="preserve">
          <source>Try to avoid dispatching several times synchronously in a row in the places where you're concerned about performance. There are a number of addons and approaches that can batch up dispatches as well.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72970471e5d1f5bed9e5c8dccde351d73710853a" translate="yes" xml:space="preserve">
          <source>Turns an object whose values are &lt;a href=&quot;../glossary#action-creator&quot;&gt;action creators&lt;/a&gt;, into an object with the same keys, but with every action creator wrapped into a &lt;a href=&quot;store#dispatch&quot;&gt;&lt;code&gt;dispatch&lt;/code&gt;&lt;/a&gt; call so they may be invoked directly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1733ad2a0216b6de85e1fcd35dfdee394e2afa0" translate="yes" xml:space="preserve">
          <source>Tutorials and Articles</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="606fbca55ef1c11f19a4f936a99beb986380cf17" translate="yes" xml:space="preserve">
          <source>Twitter's mobile site</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9404d68c02ebdd30a4a808a24f9060471b759192" translate="yes" xml:space="preserve">
          <source>Twitter: Don't use Redux unless you're unhappy with local component state</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2affd0dcee2425ca66385d0faf980e7f7ecdf02" translate="yes" xml:space="preserve">
          <source>Twitter: Don't use Redux until...</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7fb782e77a8b9b4edadf5251f4fd4a2b65f0b1b" translate="yes" xml:space="preserve">
          <source>Twitter: If your reducer looks boring, don't use redux</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee9af1a3c185fc74743f29130b1e126141719508" translate="yes" xml:space="preserve">
          <source>Twitter: Redux is a platform for developers to build customized state management with reusable things</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1674978f90c098b4d6e689712105d7a768088c7" translate="yes" xml:space="preserve">
          <source>Twitter: Redux is designed to be predictable, not concise</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6df45452576b437fd3a9fe2fc716cd66dddc4433" translate="yes" xml:space="preserve">
          <source>Twitter: Redux is useful to eliminate deep prop passing</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66661fb38bd97dedfe9248a69ac48fe3658b604e" translate="yes" xml:space="preserve">
          <source>Twitter: Redux scaling</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ecc8be1c9df1cfaf1fb1dfafd8fc3b52bba36bca" translate="yes" xml:space="preserve">
          <source>Twitter: Redux vs MobX benchmark graph - Redux state shape matters</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="129f727416c8f720bb392b36e9ceac07d9339857" translate="yes" xml:space="preserve">
          <source>Twitter: Should I keep something in React component state?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1951b46de5200e3cec6a0f10d24bc32b95efcec1" translate="yes" xml:space="preserve">
          <source>Twitter: There is no ultimate file structure for Redux</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5ab467d2f0669472526a676c4046e4696c17a6a" translate="yes" xml:space="preserve">
          <source>Twitter: Using a reducer to update a component</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd42d6934051561b9a42541c428d37e9a49eefd7" translate="yes" xml:space="preserve">
          <source>Twitter: You don't need Redux if your data never changes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65143436c2a655126e87e9283def5be8f1f1d3d7" translate="yes" xml:space="preserve">
          <source>Twitter: common misconception - deep cloning</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7449ca3dc33732cd2745f1868991eecc95eeb34" translate="yes" xml:space="preserve">
          <source>Twitter: emphasizing &amp;ldquo;one container&amp;rdquo; was a mistake</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94f434b5b79b7481ac06603cc2fe9a2a75efff91" translate="yes" xml:space="preserve">
          <source>Twitter: most common Redux misconception</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dec8b9c8b688102b7c98c2e00ef8f8e810be3a8d" translate="yes" xml:space="preserve">
          <source>Twitter: possible comparison between sagas, loops, and other approaches</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb2d03183352dc0e1406c06a363bec69ab899d18" translate="yes" xml:space="preserve">
          <source>Twitter: state shape should be normalized</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0fc31910b305d54661578ccc6703279eccabacfc" translate="yes" xml:space="preserve">
          <source>Understanding Middleware</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa44a604eeec984741a16fa1f77345805911c705" translate="yes" xml:space="preserve">
          <source>Understanding Programmatic Side-Effects</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f8aabc2d6ab53ecb7bf65fd5b21232c2d632dbb" translate="yes" xml:space="preserve">
          <source>Understanding Redux</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da9a514a65a385fa6f49e9ff3ac2134dd5049f72" translate="yes" xml:space="preserve">
          <source>Understanding Redux Middleware</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1126940f0f175f3010de4d728fe1b602fc4c7c2e" translate="yes" xml:space="preserve">
          <source>Understanding Undo History</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29149689e59122b80c1e38105a1193a813f6026c" translate="yes" xml:space="preserve">
          <source>Undo history is also part of your app's state, and there is no reason why we should approach it differently. Regardless of the type of the state changing over time, when you implement Undo and Redo, you want to keep track of the &lt;em&gt;history&lt;/em&gt; of this state at different points in time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64a01a0c422c934a7950b6881de9ff78984dfa04" translate="yes" xml:space="preserve">
          <source>Unfortunately, the process of correctly applying immutable updates to deeply nested state can easily become verbose and hard to read. Here's what an example of updating &lt;code&gt;state.first.second[someId].fourth&lt;/code&gt; might look like:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9541a9acaaaf0a817940ec4f10e5183c2dd8e50" translate="yes" xml:space="preserve">
          <source>Unfortunately, this setup has a problem. Because &lt;code&gt;combineReducers&lt;/code&gt; will call each slice reducer with the same action, dispatching &lt;code&gt;{type : 'INCREMENT'}&lt;/code&gt; will actually cause &lt;em&gt;all three&lt;/em&gt; counter values to be incremented, not just one of them. We need some way to wrap the &lt;code&gt;counter&lt;/code&gt; logic so that we can ensure that only the counter we care about is updated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d02603176f8822a40aaa5b4270e49934a7f83824" translate="yes" xml:space="preserve">
          <source>Universal</source>
          <target state="translated">Universal</target>
        </trans-unit>
        <trans-unit id="994fe41b283ff02621f9c7dc77840d41dc98c31d" translate="yes" xml:space="preserve">
          <source>Unless you are targeting old browsers like IE9, you can always use &lt;code&gt;browserHistory&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b1ae928f14271308acdf16284c1c3318ffccaac" translate="yes" xml:space="preserve">
          <source>Unlike Flux, &lt;strong&gt;Redux does not have the concept of a Dispatcher&lt;/strong&gt;. This is because it relies on pure functions instead of event emitters, and pure functions are easy to compose and don't need an additional entity managing them. Depending on how you view Flux, you may see this as either a deviation or an implementation detail. Flux has often been &lt;a href=&quot;https://speakerdeck.com/jmorrell/jsconf-uy-flux-those-who-forget-the-past-dot-dot-dot-1&quot;&gt;described as &lt;code&gt;(state, action) =&amp;gt; state&lt;/code&gt;&lt;/a&gt;. In this sense, Redux is true to the Flux architecture, but makes it simpler thanks to pure functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="369afc8b01a8d03d314e492b4f13b9436b7f3540" translate="yes" xml:space="preserve">
          <source>Unlike Immutable, Baobab doesn't yet implement any special efficient data structures under the hood, so you don't really win anything from using it together with Redux. It's easier to just use plain objects in this case.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dafc7d2108e005fe79487a219c36098fea188c9e" translate="yes" xml:space="preserve">
          <source>Unlike Redux, Elm is a language, so it is able to benefit from many things like enforced purity, static typing, out of the box immutability, and pattern matching (using the &lt;code&gt;case&lt;/code&gt; expression). Even if you don't plan to use Elm, you should read about the Elm architecture, and play with it. There is an interesting &lt;a href=&quot;https://github.com/paldepind/noname-functional-frontend-framework&quot;&gt;JavaScript library playground implementing similar ideas&lt;/a&gt;. We should look there for inspiration on Redux! One way that we can get closer to the static typing of Elm is by &lt;a href=&quot;https://github.com/reactjs/redux/issues/290&quot;&gt;using a gradual typing solution like Flow&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb573dae642cd298a26b5ad3f7d8a6aa2a22ab64" translate="yes" xml:space="preserve">
          <source>Updating Nested Objects</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba005750a992aac6711d42039081d7dea24565c8" translate="yes" xml:space="preserve">
          <source>Updating Normalized Data</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34a615077aef7febb310a581aba6ddb1f4573a22" translate="yes" xml:space="preserve">
          <source>Updating an Item in an Array</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38f356713eaa6d37ea438e2f8aa17840c5f0c625" translate="yes" xml:space="preserve">
          <source>Updating complex nested state trees can lead to verbose code that is tedious to write and difficult to debug.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="692659407b3b434cf95e2a7e004744aa8b983be9" translate="yes" xml:space="preserve">
          <source>Updating one item in an array can be accomplished by using &lt;code&gt;Array.map&lt;/code&gt;, returning a new value for the item we want to update, and returning the existing values for all other items:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46dd59ad0b98ced1d4302c19c79265603a50b5a9" translate="yes" xml:space="preserve">
          <source>Updating the Selectors</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59dca19d5e82666b029e887367ee83ee76a6cde5" translate="yes" xml:space="preserve">
          <source>Usage with React</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4bd635c7ecaee77c3a25d970afecbab5846b8de6" translate="yes" xml:space="preserve">
          <source>Usage with React Router</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f27c1c781c4770c2582ae4093ae556d8904e293c" translate="yes" xml:space="preserve">
          <source>Use Immutable.JS everywhere except your dumb components</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9cd0943012b7d196bcc304b78eaf4d76beb5b078" translate="yes" xml:space="preserve">
          <source>Use Immutable.JS objects in your Smart Components</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14a99c911eb8f6fe086d95ec62a6192b50d4564c" translate="yes" xml:space="preserve">
          <source>Use a Higher Order Component to convert your Smart Component&amp;rsquo;s Immutable.JS props to your Dumb Component&amp;rsquo;s JavaScript props</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f88c0684b6236b23ff1f689452822f930944d64" translate="yes" xml:space="preserve">
          <source>Use an Immutable.JS-aware version of the &lt;code&gt;combineReducers&lt;/code&gt; function, such as the one in &lt;a href=&quot;https://www.npmjs.com/package/redux-immutable&quot;&gt;redux-immutable&lt;/a&gt;, as Redux itself expects the state tree to be a plain JavaScript object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e7660e3d84caaf8d0d389dd1aa86ddb2e25f9d1" translate="yes" xml:space="preserve">
          <source>Use the Immutable Object Formatter Chrome Extension to Aid Debugging</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f02307698aa7f146036376ea5c566843affb0cce" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;combineReducers&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f08b702827057616968fd391c82f707b1a5a2d8f" translate="yes" xml:space="preserve">
          <source>Using Immutable.JS everywhere keeps your code performant. Use it in your smart components, your selectors, your sagas or thunks, action creators, and especially your reducers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7293e4f3b5e035630a5bc60b64f59c693251afd" translate="yes" xml:space="preserve">
          <source>Using Immutable.JS with Redux</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67ca03c7a7625d155b3a537ee064c3e9d484c709" translate="yes" xml:space="preserve">
          <source>Using Object Spread Operator</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac6f51d94e4af12a8acd288d8eb407840de3df95" translate="yes" xml:space="preserve">
          <source>Using Redux</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe5bda3640263724e1162e68bdb4f3f60a23f165" translate="yes" xml:space="preserve">
          <source>Using Redux Undo</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4350d0f8a60fb29773b2696fff9bb5c97e53d8b5" translate="yes" xml:space="preserve">
          <source>Using combineReducers</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d518ee67915b609a1dd9ff6c8af1cfadb6c6da1" translate="yes" xml:space="preserve">
          <source>Using objects keyed by item IDs as lookup tables, and arrays of IDs to track ordering</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ed1d4412e834bf938d3923e0b8f3cc5b2463506" translate="yes" xml:space="preserve">
          <source>Using redux-saga To Simplify Your Growing React Native Codebase</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="021b423143ef7a73f92d60003574a87608876b96" translate="yes" xml:space="preserve">
          <source>Using slice reducers with Immutable.js objects</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b97756d7719f737231f86a444a2d68e775b67e86" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;getVisibleTodos&lt;/code&gt; selector with multiple instances of the &lt;code&gt;visibleTodoList&lt;/code&gt; container will not correctly memoize:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4df7fb586380ea5e7c187fb0014d6c3d49e85d05" translate="yes" xml:space="preserve">
          <source>Usually generated by React Redux</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18fdc5ee8b1f8fba8dabaa933373c0483ab7fad7" translate="yes" xml:space="preserve">
          <source>Utilities</source>
          <target state="translated">Utilities</target>
        </trans-unit>
        <trans-unit id="3b6bce0bc82ec87711aba57c2f985407b17ac4e1" translate="yes" xml:space="preserve">
          <source>Utility libraries that wrap immutable update logic into simpler functions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a83ddc10110955dee4bc01b56024b22edcbf4ac4" translate="yes" xml:space="preserve">
          <source>Verbose Code</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="306838c8867984c3b915bde4dd3f78004f4ca086" translate="yes" xml:space="preserve">
          <source>Watch the 30 Free Videos!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0483b60e25b0c25edcc348bff84793a3d91be49a" translate="yes" xml:space="preserve">
          <source>We also include our bundle file for the client-side application via a script tag. This is whatever output your bundling tool provides for your client entry point. It may be a static file or a URL to a hot reloading development server.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10bbc3b0c569fe69fdd473c376b8f564d7a80d0e" translate="yes" xml:space="preserve">
          <source>We also need a way to give each instance of a container access to its own private selector. The &lt;code&gt;mapStateToProps&lt;/code&gt; argument of &lt;code&gt;connect&lt;/code&gt; can help with this.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fdaefd698de230a2f7c12c50f1c7217019df8d31" translate="yes" xml:space="preserve">
          <source>We can now wrap any reducer into &lt;code&gt;undoable&lt;/code&gt; reducer enhancer to teach it to react to &lt;code&gt;UNDO&lt;/code&gt; and &lt;code&gt;REDO&lt;/code&gt; actions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c827f05d5a3cbe83f760b9cd2939ca0c33269a0" translate="yes" xml:space="preserve">
          <source>We can still define these special thunk action creators inside our &lt;code&gt;actions.js&lt;/code&gt; file:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="938b765a6a181b2876b551536787a61427ae0513" translate="yes" xml:space="preserve">
          <source>We can write the following helper to accomplish this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8360b823356a1165aff2dcb5acddb15d0faf8a6" translate="yes" xml:space="preserve">
          <source>We can't reliably enforce serializable actions for performance reasons, so Redux only checks that every action is a plain object, and that the &lt;code&gt;type&lt;/code&gt; is defined. The rest is up to you, but you might find that keeping everything serializable helps debug and reproduce issues.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00855934fc4901f8d981dcebd3bffdd698a1fcbf" translate="yes" xml:space="preserve">
          <source>We could also vary the approach somewhat, and create a more generic higher-order reducer that accepts both a given reducer function and a name or identifier:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f190e4360534b4c5d20b45090414be9e9e50cea0" translate="yes" xml:space="preserve">
          <source>We could end this here, but it's not very convenient to import a special function every time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05ab24ad4034d462a58f7bf871314f5e1296bcbc" translate="yes" xml:space="preserve">
          <source>We could provide a helper inside Redux that would apply the actual monkeypatching as an implementation detail:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9014512e14daf5d56a7fc1c2a33ed8ae10444137" translate="yes" xml:space="preserve">
          <source>We could use it to apply multiple middleware like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62783244d2f4a7054a2bb285d688f4cb5a60d38f" translate="yes" xml:space="preserve">
          <source>We don't want to lock you in!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a9e7b213f0799be76b21fa0d3f91f45192784f7" translate="yes" xml:space="preserve">
          <source>We extracted &lt;code&gt;posts(state, action)&lt;/code&gt; that manages the state of a specific post list. This is just &lt;a href=&quot;../basics/reducers#splitting-reducers&quot;&gt;reducer composition&lt;/a&gt;! It is our choice how to split the reducer into smaller reducers, and in this case, we're delegating updating items inside an object to a &lt;code&gt;posts&lt;/code&gt; reducer. The &lt;a href=&quot;../introduction/examples#real-world&quot;&gt;real world example&lt;/a&gt; goes even further, showing how to create a reducer factory for parameterized pagination reducers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2ba230f751c2afe5d48e98a148b40dba74b740d" translate="yes" xml:space="preserve">
          <source>We have two more actions to handle! Just like we did with &lt;code&gt;SET_VISIBILITY_FILTER&lt;/code&gt;, we'll import the &lt;code&gt;ADD_TODO&lt;/code&gt; and &lt;code&gt;TOGGLE_TODO&lt;/code&gt; actions and then extend our reducer to handle &lt;code&gt;ADD_TODO&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="937d04010c34a1830de25cf054cedd314fd77775" translate="yes" xml:space="preserve">
          <source>We just modified how the &lt;code&gt;addTodo&lt;/code&gt; action creator behaves, completely invisible to the calling code. &lt;strong&gt;We don't have to worry about looking at each place where todos are being added, to make sure they have this check.&lt;/strong&gt; Action creators let you decouple additional logic around dispatching an action, from the actual components emitting those actions. It's very handy when the application is under heavy development, and the requirements change often.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="727029cc06658123c8225de825d04ad8f8957f5b" translate="yes" xml:space="preserve">
          <source>We must distinguish between dispatching functions in general and the base &lt;a href=&quot;api/store#dispatch&quot;&gt;&lt;code&gt;dispatch&lt;/code&gt;&lt;/a&gt; function provided by the store instance without any middleware.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44bbe40c8a0e33b691c1b061d98660259d085213" translate="yes" xml:space="preserve">
          <source>We need to create a fake &lt;code&gt;getState&lt;/code&gt;, &lt;code&gt;dispatch&lt;/code&gt;, and &lt;code&gt;next&lt;/code&gt; functions. We use &lt;code&gt;jest.fn()&lt;/code&gt; to create stubs, but with other test frameworks you would likely use sinon.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="299e4ddfafdfef1e85fc435e6d7114d6525ef4bd" translate="yes" xml:space="preserve">
          <source>We now have examples of several kinds of split-up reducer functions: helper utilities like &lt;code&gt;updateObject&lt;/code&gt; and &lt;code&gt;createReducer&lt;/code&gt;, handlers for specific cases like &lt;code&gt;setVisibilityFilter&lt;/code&gt; and &lt;code&gt;addTodo&lt;/code&gt;, and slice-of-state handlers like &lt;code&gt;visibilityReducer&lt;/code&gt; and &lt;code&gt;todosReducer&lt;/code&gt;. We also can see that &lt;code&gt;appReducer&lt;/code&gt; is an example of a &quot;root reducer&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f931773a23d44ef9110cfd8557dfc7aa1e3202fa" translate="yes" xml:space="preserve">
          <source>We recommend &lt;a href=&quot;http://facebook.github.io/jest/&quot;&gt;Jest&lt;/a&gt; as the testing engine. Note that it runs in a Node environment, so you won't have access to the DOM.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c48c28638a818ee714914dc38026f386ac75db5b" translate="yes" xml:space="preserve">
          <source>We should now be able to use either of these to generate our specialized counter reducers, and then dispatch actions that will affect the portion of the state that we care about:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c89ee6942601c0a301153e30e9c58b2f5d8ec40b" translate="yes" xml:space="preserve">
          <source>We specified the behavior of our app before we even started writing the UI. We won't do this in this tutorial, but at this point you can write tests for your reducers and action creators. You won't need to mock anything because they are just &lt;a href=&quot;../introduction/threeprinciples#changes-are-made-with-pure-functions&quot;&gt;pure&lt;/a&gt; functions. Call them, and make assertions on what they return.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4470bb993a07bc6bfa269c5fb94507004598031" translate="yes" xml:space="preserve">
          <source>We store each subreddit's information separately so we can cache every subreddit. When the user switches between them the second time, the update will be instant, and we won't need to refetch unless we want to. Don't worry about all these items being in memory: unless you're dealing with tens of thousands of items, and your user rarely closes the tab, you won't need any sort of cleanup.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e50f981325b4d6e7b5e1ac94e3d14479ea909a5" translate="yes" xml:space="preserve">
          <source>We test that our middleware is calling the &lt;code&gt;getState&lt;/code&gt;, &lt;code&gt;dispatch&lt;/code&gt;, and &lt;code&gt;next&lt;/code&gt; functions at the right time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75cf0f6e6b134023b61b31d405a78b8ef43ce618" translate="yes" xml:space="preserve">
          <source>We then get the initial state from our Redux store using &lt;a href=&quot;../api/store#getState&quot;&gt;&lt;code&gt;store.getState()&lt;/code&gt;&lt;/a&gt;. We will see how this is passed along in our &lt;code&gt;renderFullPage&lt;/code&gt; function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="319de368fdc28c8b195a6d2c03281f6821c69298" translate="yes" xml:space="preserve">
          <source>We use &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/API/Fetch_API&quot;&gt;&lt;code&gt;fetch&lt;/code&gt; API&lt;/a&gt; in the examples. It is a new API for making network requests that replaces &lt;code&gt;XMLHttpRequest&lt;/code&gt; for most common needs. Because most browsers don't yet support it natively, we suggest that you use &lt;a href=&quot;https://github.com/matthew-andrews/isomorphic-fetch&quot;&gt;&lt;code&gt;isomorphic-fetch&lt;/code&gt;&lt;/a&gt; library:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7b84a5beb3839d0cf7131fb4a2fbbb7aa5d2618" translate="yes" xml:space="preserve">
          <source>We use ES6 computed property syntax so we can update &lt;code&gt;state[action.subreddit]&lt;/code&gt; with &lt;code&gt;Object.assign()&lt;/code&gt; in a concise way. This:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38db718a04799e7dc7479e35fa4bd78f62cd7909" translate="yes" xml:space="preserve">
          <source>We will also need some container components to connect the presentational components to Redux. For example, the presentational &lt;code&gt;TodoList&lt;/code&gt; component needs a container like &lt;code&gt;VisibleTodoList&lt;/code&gt; that subscribes to the Redux store and knows how to apply the current visibility filter. To change the visibility filter, we will provide a &lt;code&gt;FilterLink&lt;/code&gt; container component that renders a &lt;code&gt;Link&lt;/code&gt; that dispatches an appropriate action on click:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cbe16722b5d079bcbcd195adcf84c0f8b9537578" translate="yes" xml:space="preserve">
          <source>We will also need to refactor &lt;code&gt;index.js&lt;/code&gt; to render the &lt;code&gt;&amp;lt;Root /&amp;gt;&lt;/code&gt; component to the DOM.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eed46c74461e18da655f49826f9bb4cec981c01c" translate="yes" xml:space="preserve">
          <source>We will see later how the approach we take lets us choose how granular Undo and Redo need to be.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e48b8e0b74723fbbce7a038049b47d5983a8ab63" translate="yes" xml:space="preserve">
          <source>We will then import the &lt;code&gt;&amp;lt;Provider /&amp;gt;&lt;/code&gt; from React Redux:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3dfe117d376bf6280908c658894a43c98efefd9b" translate="yes" xml:space="preserve">
          <source>We will use React in the examples below, but the same techniques can be used with other view frameworks that can render on the server.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1cfc720c34e5f99bae08591a1d21b8028d872f1f" translate="yes" xml:space="preserve">
          <source>We will use React to build our simple todo app.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77e9494b8c84b985dfa4f4d49ca2fb485e0d6cbd" translate="yes" xml:space="preserve">
          <source>We will wrap &lt;code&gt;&amp;lt;Router /&amp;gt;&lt;/code&gt; in &lt;code&gt;&amp;lt;Provider /&amp;gt;&lt;/code&gt; so that route handlers can get &lt;a href=&quot;../basics/usagewithreact#passing-the-store&quot;&gt;access to the &lt;code&gt;store&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d2a4109058f0af68e149216b99cc33debbea027" translate="yes" xml:space="preserve">
          <source>We would like to replace &lt;code&gt;getVisibleTodos&lt;/code&gt; with a memoized selector that recalculates &lt;code&gt;todos&lt;/code&gt; when the value of &lt;code&gt;state.todos&lt;/code&gt; or &lt;code&gt;state.visibilityFilter&lt;/code&gt; changes, but not when changes occur in other (unrelated) parts of the state tree.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c0e7d729963aa201c31d1a06cb609fdf81434f4" translate="yes" xml:space="preserve">
          <source>We'll add one more action type to describe a user ticking off a todo as completed. We refer to a particular todo by &lt;code&gt;index&lt;/code&gt; because we store them in an array. In a real app, it is wiser to generate a unique ID every time something new is created.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="070f3dc99d82df0afd700715eae9b841ac7a6b07" translate="yes" xml:space="preserve">
          <source>We'll explore how to perform side effects in the &lt;a href=&quot;../advanced/index&quot;&gt;advanced walkthrough&lt;/a&gt;. For now, just remember that the reducer must be pure. &lt;strong&gt;Given the same arguments, it should calculate the next state and return it. No surprises. No side effects. No API calls. No mutations. Just a calculation.&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eaa545b7295152e58ab853f3d912b19f7b907eb9" translate="yes" xml:space="preserve">
          <source>We'll start by specifying the initial state. Redux will call our reducer with an &lt;code&gt;undefined&lt;/code&gt; state for the first time. This is our chance to return the initial state of our app:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a566f04c7bb96e3dad921f4e977a52579a6948e3" translate="yes" xml:space="preserve">
          <source>We'll start with the most common use case: lists. Web applications often show lists of things. For example, a list of posts, or a list of friends. You'll need to figure out what sorts of lists your app can show. You want to store them separately in the state, because this way you can cache them and only fetch again if necessary.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf88ce0d8fb03a1213e9e5aff6c740f652fabdf4" translate="yes" xml:space="preserve">
          <source>We'll use separate types in this tutorial.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6deda5b238140890ee6ed5f2e792c4827705c840" translate="yes" xml:space="preserve">
          <source>We're almost done. Since many people don't like switch statements, it's very common to use a function that creates a lookup table of action types to case functions. We'll use the &lt;code&gt;createReducer&lt;/code&gt; function described in &lt;a href=&quot;../reducingboilerplate#generating-reducers&quot;&gt;Reducing Boilerplate&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf8eb046053a065111d778fef4cfcdc223cb9816" translate="yes" xml:space="preserve">
          <source>Webflow</source>
          <target state="translated">Webflow</target>
        </trans-unit>
        <trans-unit id="cb59effde77f318efa4856b404dd72c191879fc1" translate="yes" xml:space="preserve">
          <source>What approaches are there for handling data immutably? Do I have to use Immutable.JS?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ec40d3e3697bdc90d47223d9a786375d4854093" translate="yes" xml:space="preserve">
          <source>What are some opinionated Best Practices for using Immutable.JS with Redux?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4617f0a4931acbdece3479c94cd5d9b8a29ffbc4" translate="yes" xml:space="preserve">
          <source>What are the benefits of Immutability?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60982d038a3233ff8e99646cab1b3f3181f09be8" translate="yes" xml:space="preserve">
          <source>What are the benefits of immutability?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de1352defc592755d5729188ff9c5931f975beca" translate="yes" xml:space="preserve">
          <source>What are the issues with using ES6 for immutable operations?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87f7ec6d6c32ff8a62aada75fa88678bc51d6ac0" translate="yes" xml:space="preserve">
          <source>What are the issues with using Immutable.JS?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7669cca5868cf84a7c911639d6206223bbfb9011" translate="yes" xml:space="preserve">
          <source>What are the issues with using JavaScript for immutable operations?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6f105fcf428cb482f2dba1e64704d18ef939497" translate="yes" xml:space="preserve">
          <source>What are the issues with using plain JavaScript for immutable operations?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="502931ac19eb7ad8e3a6b09a7f30f2039e70b8f9" translate="yes" xml:space="preserve">
          <source>What are the past (and future) states in the undo stack?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7af9c4632a04865406facc7a09e8fff13bee6fa5" translate="yes" xml:space="preserve">
          <source>What if we just replace the &lt;code&gt;dispatch&lt;/code&gt; function on the store instance? The Redux store is just a plain object with &lt;a href=&quot;../api/store&quot;&gt;a few methods&lt;/a&gt;, and we're writing JavaScript, so we can just monkeypatch the &lt;code&gt;dispatch&lt;/code&gt; implementation:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da380f2420edcb4fe953f900cae3cd95adf19059" translate="yes" xml:space="preserve">
          <source>What if we want to apply &lt;strong&gt;more than one&lt;/strong&gt; such transformation to &lt;code&gt;dispatch&lt;/code&gt;?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d5e21ca6d6c7949c97bbb82b6de23a8e86a90ba" translate="yes" xml:space="preserve">
          <source>What is the current state?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ccdd9f0a8546e0e957522917e3028ad2fdff0b9e" translate="yes" xml:space="preserve">
          <source>What should my file structure look like? How should I group my action creators and reducers in my project? Where should my selectors go?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39b7e4ebfa46344ad4758dbb7c54ade6b182a09d" translate="yes" xml:space="preserve">
          <source>What the Flux?! Let's Redux.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7685a22848ac997a066fa32d4715b4fcb5b90efa" translate="yes" xml:space="preserve">
          <source>Whatever convention you choose, stick with it throughout the application.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e44dc3bb557d164a1c8cd909a8179ffc29fe58f" translate="yes" xml:space="preserve">
          <source>When a piece of data is duplicated in several places, it becomes harder to make sure that it is updated appropriately.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0b74de7e07b265987ff3765a92ea469eb3be3c6" translate="yes" xml:space="preserve">
          <source>When a store is created, Redux dispatches a dummy action to your reducer to populate the store with the initial state. You are not meant to handle the dummy action directly. Just remember that your reducer should return some kind of initial state if the state given to it as the first argument is &lt;code&gt;undefined&lt;/code&gt;, and you're all set.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55f47f3d19e55c7f647cc1402dfe664e913c42b7" translate="yes" xml:space="preserve">
          <source>When adding JavaScript objects to an Immutable.JS Map or List using Immutable.JS&amp;rsquo;s &lt;code&gt;update&lt;/code&gt;, &lt;code&gt;merge&lt;/code&gt; or &lt;code&gt;set&lt;/code&gt; methods, ensure that the object being added is first converted to an Immutable object using &lt;code&gt;fromJS()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5532214553b2a415074b0f39f2cead024233404a" translate="yes" xml:space="preserve">
          <source>When an action creator returns a function, that function will get executed by the Redux Thunk middleware. This function doesn't need to be pure; it is thus allowed to have side effects, including executing asynchronous API calls. The function can also dispatch actions&amp;mdash;like those synchronous actions we defined earlier.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2b511652b6790f3eca5e3448a96b4a14c313d91" translate="yes" xml:space="preserve">
          <source>When it's time to fetch the posts for some subreddit, we will dispatch a &lt;code&gt;REQUEST_POSTS&lt;/code&gt; action:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c552f80b72ecd37903e2d6ffce7bb1a0b3ba91ad" translate="yes" xml:space="preserve">
          <source>When previously we wrote: &lt;code&gt;&amp;lt;Route path=&quot;/(:filter)&quot; component={App} /&amp;gt;&lt;/code&gt;, it made available inside &lt;code&gt;App&lt;/code&gt; a &lt;code&gt;params&lt;/code&gt; property.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c55e37eb1a90ec0796f6a4f05992a64917889494" translate="yes" xml:space="preserve">
          <source>When rendering, we will wrap &lt;code&gt;&amp;lt;App /&amp;gt;&lt;/code&gt;, our root component, inside a &lt;code&gt;&amp;lt;Provider&amp;gt;&lt;/code&gt; to make the store available to all components in the component tree, as we saw in &lt;a href=&quot;../basics/usagewithreact&quot;&gt;Usage with React&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8f09b0e83401e68e4c33132aa1b3b73a6d4dcd4" translate="yes" xml:space="preserve">
          <source>When should I use Redux?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d794925cbdb0e31214ecfc88910755d33c4f0b10" translate="yes" xml:space="preserve">
          <source>When the last middleware in the chain dispatches an action, it has to be a plain object. This is when the &lt;a href=&quot;../basics/dataflow&quot;&gt;synchronous Redux data flow&lt;/a&gt; takes place.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d74a3e9748d787071d9c2fe4d73363cc68c2dcd3" translate="yes" xml:space="preserve">
          <source>When the page loads, the bundle file will be started up and &lt;a href=&quot;https://facebook.github.io/react/docs/top-level-api.html#reactdom.render&quot;&gt;&lt;code&gt;ReactDOM.render()&lt;/code&gt;&lt;/a&gt; will hook into the &lt;code&gt;data-react-id&lt;/code&gt; attributes from the server-rendered HTML. This will connect our newly-started React instance to the virtual DOM used on the server. Since we have the same initial state for our Redux store and used the same code for all our view components, the result will be the same real DOM.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fdc93b372187dd00b09c70c8f0349010aacbd69a" translate="yes" xml:space="preserve">
          <source>When the shallow check fails, React-Redux will cause the component to re-render. Using &lt;code&gt;toJS()&lt;/code&gt; in &lt;code&gt;mapStateToProps&lt;/code&gt; in this way, therefore, will always cause the component to re-render, even if the value never changes, impacting heavily on performance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4aa9765bfd105e5641e876f4bda241427a866bc5" translate="yes" xml:space="preserve">
          <source>When the user presses &amp;ldquo;Redo&amp;rdquo;, we want to move one step back into the future:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f1dc68360b35a018ee091fccfa401d6fad91461" translate="yes" xml:space="preserve">
          <source>When using Redux with server rendering, we must also send the state of our app along in our response, so the client can use it as the initial state. This is important because, if we preload any data before generating the HTML, we want the client to also have access to this data. Otherwise, the markup generated on the client won't match the server markup, and the client would have to load the data again.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08905f564cddc435b39d4746befbbfde05d56c89" translate="yes" xml:space="preserve">
          <source>When you call an asynchronous API, there are two crucial moments in time: the moment you start the call, and the moment when you receive an answer (or a timeout).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b17e363eb01279dd12d04917f1f023babea53839" translate="yes" xml:space="preserve">
          <source>When you emit an action, &lt;code&gt;todoApp&lt;/code&gt; returned by &lt;code&gt;combineReducers&lt;/code&gt; will call both reducers:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9320a916b3e55e2e80a21708cceecfcf437cc640" translate="yes" xml:space="preserve">
          <source>When you have ported all of your Flux Stores to be implemented on top of reducers, you can replace the Flux library with a single Redux store, and combine those reducers you already have into one using &lt;a href=&quot;../api/combinereducers&quot;&gt;&lt;code&gt;combineReducers(reducers)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0a2799ac8efd1f6499c6fb41130094d5c12a451" translate="yes" xml:space="preserve">
          <source>Where do I put my business logic in a React/Redux application?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c07523b65b47a0ad36e94ad44e0e56dd3913c89" translate="yes" xml:space="preserve">
          <source>Where do we get the initial &lt;code&gt;present&lt;/code&gt; state from? We don't seem to know it beforehand.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c79f8ed0107a7fe0a477df33c48d8c228e7eee0" translate="yes" xml:space="preserve">
          <source>Where do we react to the external actions to save the &lt;code&gt;present&lt;/code&gt; to the &lt;code&gt;past&lt;/code&gt;?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6559f99fd936b0050a5d2a1fc16d0873490da574" translate="yes" xml:space="preserve">
          <source>Where to Hold React Component Data: state, store, static, and this</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03693bfdc7508d98809d55b857217f95caac409e" translate="yes" xml:space="preserve">
          <source>Whether you choose to use such a library, or stick with plain JavaScript, depends on how comfortable you are with adding another dependency to your app, or how sure you are that you can avoid the pitfalls inherent within JavaScript&amp;rsquo;s approach to immutability.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="067c7d896d6446815e8315d7a4fcfafc8f8da43b" translate="yes" xml:space="preserve">
          <source>Whether you have used them or not, Redux only takes a few minutes to get started with.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cbfecd927f559c2b5baf796e97b2ca728811bf43" translate="yes" xml:space="preserve">
          <source>Whichever option you choose, make sure you&amp;rsquo;re familiar with the concepts of &lt;a href=&quot;reducers/prerequisiteconcepts#note-on-immutability-side-effects-and-mutation&quot;&gt;immutability, side effects and mutation&lt;/a&gt;. In particular, ensure you have a deep understanding of what JavaScript does when updating and copying values in order to guard against accidental mutations that will degrade your app&amp;rsquo;s performance, or break it altogether.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03047acfd57571e8bdbc8135d9d15cea99035eb1" translate="yes" xml:space="preserve">
          <source>While &lt;a href=&quot;../api/combinereducers&quot;&gt;&lt;code&gt;combineReducers()&lt;/code&gt;&lt;/a&gt; is a handy helper utility, you don't have to use it; feel free to write your own root reducer!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4089c3ad2441e642d6adb86e7f9d112ea7103b43" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;combineReducers&lt;/code&gt; attempts to check that your reducers conform to some of these rules, you should remember them, and do your best to follow them. &lt;code&gt;combineReducers&lt;/code&gt; will check your reducers by passing &lt;code&gt;undefined&lt;/code&gt; to them; this is done even if you specify initial state to &lt;code&gt;Redux.createStore(combineReducers(...), initialState)&lt;/code&gt;. Therefore, you &lt;strong&gt;must&lt;/strong&gt; ensure your reducers work properly when receiving &lt;code&gt;undefined&lt;/code&gt; as state, even if you never intend for them to actually receive &lt;code&gt;undefined&lt;/code&gt; in your own code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a1e65f5bf9037c5912b84c5835b30699b791739" translate="yes" xml:space="preserve">
          <source>While React Redux does work to minimize the number of times that your &lt;code&gt;mapStateToProps&lt;/code&gt; function is called, it's still a good idea to ensure that your &lt;code&gt;mapStateToProps&lt;/code&gt; runs quickly and also minimizes the amount of work it does. The common recommended approach is to create memoized &amp;ldquo;selector&amp;rdquo; functions using &lt;a href=&quot;https://github.com/reactjs/reselect&quot;&gt;Reselect&lt;/a&gt;. These selectors can be combined and composed together, and selectors later in a pipeline will only run if their inputs have changed. This means you can create selectors that do things like filtering or sorting, and ensure that the real work only happens if needed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="040c756905d96ee1b18a17c4c17f4f0537e48ce8" translate="yes" xml:space="preserve">
          <source>While Redux itself is not opinionated about how your state is organized, &lt;code&gt;combineReducers&lt;/code&gt; enforces several rules to help users avoid common errors. (See &lt;a href=&quot;../../api/combinereducers&quot;&gt;&lt;code&gt;combineReducers&lt;/code&gt;&lt;/a&gt; for details.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8dfc58574b33f1efddcb65068c1c7a976c89a49a" translate="yes" xml:space="preserve">
          <source>While effective, using &lt;code&gt;Object.assign()&lt;/code&gt; can quickly make simple reducers difficult to read given its rather verbose syntax.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="269ba06048a7e4e70129f1c6f218059f072f2367" translate="yes" xml:space="preserve">
          <source>While it is technically &lt;em&gt;possible&lt;/em&gt; to &lt;a href=&quot;https://github.com/reactjs/redux/issues/328#issuecomment-125035516&quot;&gt;write impure reducers&lt;/a&gt; that mutate the data for performance corner cases, we actively discourage you from doing this. Development features like time travel, record/replay, or hot reloading will break. Moreover it doesn't seem like immutability poses performance problems in most real apps, because, as &lt;a href=&quot;https://github.com/omcljs/om&quot;&gt;Om&lt;/a&gt; demonstrates, even if you lose out on object allocation, you still win by avoiding expensive re-renders and re-calculations, as you know exactly what changed thanks to reducer purity.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="abcdc11df5ffeb4a687df7b1d5bbf50fd78fa63f" translate="yes" xml:space="preserve">
          <source>While it ultimately doesn't matter how you lay out your code on disk, it's important to remember that actions and reducers shouldn't be considered in isolation. It's entirely possible (and encouraged) for a reducer defined in one folder to respond to an action defined in another folder.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d174eaad0823043371c5b288b8705217853f594b" translate="yes" xml:space="preserve">
          <source>While middleware can be used for a variety of things, including asynchronous API calls, it's really important that you understand where it comes from. We'll guide you through the thought process leading to middleware, by using logging and crash reporting as examples.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ad63caddc89503ad9515ff6b17c9b9ddad8c44b" translate="yes" xml:space="preserve">
          <source>While there's no single definitive answer to this, most of the time this should not be a concern in either case.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="baecaba85a30f210b6df40e0df3b4579a527b679" translate="yes" xml:space="preserve">
          <source>Why do we even overwrite &lt;code&gt;dispatch&lt;/code&gt;? Of course, to be able to call it later, but there's also another reason: so that every middleware can access (and call) the previously wrapped &lt;code&gt;store.dispatch&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f16b35538e53672818a41ec6538a37dcb3ab3da" translate="yes" xml:space="preserve">
          <source>Why does React-Redux shallowly check each value within the props object returned from &lt;code&gt;mapStateToProp&lt;/code&gt;?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94db3c68fc052fe95a3526f89400cbf7608c18b8" translate="yes" xml:space="preserve">
          <source>Why does Redux&amp;rsquo;s use of shallow equality checking require immutability?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e3c854da8974033215e1fa6680270278cfeb926" translate="yes" xml:space="preserve">
          <source>Why does a reducer mutating the state prevent React-Redux from re-rendering a wrapped component?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ee3c091a66db76035f8a4ca74463446e1e64e6a" translate="yes" xml:space="preserve">
          <source>Why does a selector mutating and returning a persistent object to &lt;code&gt;mapStateToProps&lt;/code&gt; prevent React-Redux from re-rendering a wrapped component?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="644fb85f7f965c72f4406c2ac164f794580f3172" translate="yes" xml:space="preserve">
          <source>Why don't I have &lt;code&gt;this.props.dispatch&lt;/code&gt; available in my connected component?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9070dbd8c65265905f9ee4a7b2376e7eafe21a53" translate="yes" xml:space="preserve">
          <source>Why don't I have this.props.dispatch available in my connected component?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="187fff4819a25361b7b72220761e6b7a66afabd9" translate="yes" xml:space="preserve">
          <source>Why is immutability required by Redux?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef930e2cf88a5db6b834d3fe1be3317cae525972" translate="yes" xml:space="preserve">
          <source>Why is immutability required in Redux?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8bcdba5809f1620e1841e83e3768ab2d2842bcd2" translate="yes" xml:space="preserve">
          <source>Why is it &lt;code&gt;42&lt;/code&gt;, and not &lt;code&gt;0&lt;/code&gt;, this time? Because &lt;code&gt;createStore&lt;/code&gt; was called with &lt;code&gt;42&lt;/code&gt; as the second argument. This argument becomes the &lt;code&gt;state&lt;/code&gt; passed to your reducer along with the dummy action. &lt;strong&gt;This time, &lt;code&gt;state&lt;/code&gt; is not undefined (it's &lt;code&gt;42&lt;/code&gt;!), so ES6 default argument syntax has no effect.&lt;/strong&gt; The &lt;code&gt;state&lt;/code&gt; is &lt;code&gt;42&lt;/code&gt;, and &lt;code&gt;42&lt;/code&gt; is returned from the reducer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d09f931d0864d72b3013ba7e135c68d6b2c0d13" translate="yes" xml:space="preserve">
          <source>Why is my component re-rendering too often?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77273d55a2a0fbeee2220902bad56163a526b540" translate="yes" xml:space="preserve">
          <source>Why is this beneficial? &lt;strong&gt;It is often claimed that constants are unnecessary, and for small projects, this might be correct.&lt;/strong&gt; For larger projects, there are some benefits to defining action types as constants:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff0296d28f6b024408ea92b7c1ed963cf8a64adf" translate="yes" xml:space="preserve">
          <source>Why isn't my component re-rendering, or my mapStateToProps running?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67ac165008f4be935481141e41f5ad4f0e445971" translate="yes" xml:space="preserve">
          <source>Why should &lt;code&gt;type&lt;/code&gt; be a string, or at least serializable? Why should my action types be constants?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6250d26c1c06d76575d238d1fd90a39d732b6647" translate="yes" xml:space="preserve">
          <source>Why should I choose Immutable.JS as an immutable library?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36a89fdc5d2eadc3e614ad18a6f439b16e06ba2e" translate="yes" xml:space="preserve">
          <source>Why should I use an immutable-focused library such as Immutable.JS?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9c9ff5d2aa97da2f3c187af80701dfecc789475" translate="yes" xml:space="preserve">
          <source>Why should type be a string, or at least serializable? Why should my action types be constants?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dab3df4bfeab70c04e3398ba91567702008bac36" translate="yes" xml:space="preserve">
          <source>Why will shallow equality checking not work with mutable objects?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="478cc11a21f0ce66c20e68a01399e12557bac4a6" translate="yes" xml:space="preserve">
          <source>Wikipedia: Associative Entity</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="923fc7415b6af8016333316d63e41417d9181e99" translate="yes" xml:space="preserve">
          <source>Will having &amp;ldquo;one state tree&amp;rdquo; cause memory problems? Will dispatching many actions take up memory?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ca4941ae83a69d23ea4d39fc06d98dc6f0b9802" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;https://github.com/reactjs/react-redux&quot;&gt;React Redux&lt;/a&gt;, the wrapper classes generated by the &lt;code&gt;connect()&lt;/code&gt; function do actually look for &lt;code&gt;props.store&lt;/code&gt; if it exists, but it's best if you wrap your root component in &lt;code&gt;&amp;lt;Provider store={store}&amp;gt;&lt;/code&gt; and let React Redux worry about passing the store down. This way components don't need to worry about importing a store module, and isolating a Redux app or enabling server rendering is much easier to do later.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb5a653a3a5bc160a77a07e48c7fddec333e9161" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;combineReducers()&lt;/code&gt; the behavior is more nuanced. Those reducers whose state is specified in &lt;code&gt;preloadedState&lt;/code&gt; will receive that state. Other reducers will receive &lt;code&gt;undefined&lt;/code&gt;&lt;em&gt;and because of that&lt;/em&gt; will fall back to the &lt;code&gt;state = ...&lt;/code&gt; default argument they specify.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dcb12ee583209b8bb9b311e92be2aa73c59c20e7" translate="yes" xml:space="preserve">
          <source>With JavaScript, you can accidentally mutate an object (such as the Redux state tree) quite easily without realising it. For example, updating deeply nested properties, creating a new &lt;em&gt;reference&lt;/em&gt; to an object instead of a new object, or performing a shallow copy rather than a deep copy, can all lead to inadvertent object mutations, and can trip up even the most experienced JavaScript coder.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c279bb3233aaa1e17c77c8a143b0f1883f9cd4d7" translate="yes" xml:space="preserve">
          <source>With Redux, however, implementing undo history is a breeze. There are three reasons for this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30a10f999841101d22cd135f2d787dcfd7a220dd" translate="yes" xml:space="preserve">
          <source>With Redux, the same update logic can be described as a reducing function:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c60d5cf0665575903c5afa25eb7d3eed7b4fc200" translate="yes" xml:space="preserve">
          <source>With this out of the way, let's start writing our reducer by gradually teaching it to understand the &lt;a href=&quot;actions&quot;&gt;actions&lt;/a&gt; we defined earlier.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fee9030454f12e22bef2b8be7208f6154da76739" translate="yes" xml:space="preserve">
          <source>Without &lt;a href=&quot;middleware&quot;&gt;middleware&lt;/a&gt;, Redux store only supports &lt;a href=&quot;../basics/dataflow&quot;&gt;synchronous data flow&lt;/a&gt;. This is what you get by default with &lt;a href=&quot;../api/createstore&quot;&gt;&lt;code&gt;createStore()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b879db99111e27d801d9201a249f4ff8dadbc225" translate="yes" xml:space="preserve">
          <source>Without &lt;code&gt;combineReducers()&lt;/code&gt; or similar manual code, &lt;code&gt;preloadedState&lt;/code&gt; always wins over &lt;code&gt;state = ...&lt;/code&gt; in the reducer because the &lt;code&gt;state&lt;/code&gt; passed to the reducer &lt;em&gt;is&lt;/em&gt;&lt;code&gt;preloadedState&lt;/code&gt; and &lt;em&gt;is not&lt;/em&gt;&lt;code&gt;undefined&lt;/code&gt;, so the ES6 argument syntax doesn't apply.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93111501bb024fd914d89cdba95cef4a48a41268" translate="yes" xml:space="preserve">
          <source>Without any middleware, &lt;a href=&quot;../api/store#dispatch&quot;&gt;&lt;code&gt;dispatch&lt;/code&gt;&lt;/a&gt; only accepts a plain object, so we have to perform AJAX calls inside our components:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3eaee8c6d91975cebb24c4050db09591d953bf58" translate="yes" xml:space="preserve">
          <source>Won't calling &amp;ldquo;all my reducers&amp;rdquo; for each action be slow?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6136c4a62a84feac2443e18a9f39e199c0a98340" translate="yes" xml:space="preserve">
          <source>Wordpress's new admin page</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69c79c2885e8ffba979a60fb509366f84a77cc7d" translate="yes" xml:space="preserve">
          <source>Working with VK API (in Russian)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a31d58278381294346a4e44a8fa95eea8b2e991" translate="yes" xml:space="preserve">
          <source>Wouldn't it be nice if we logged every action that happens in the app, together with the state computed after it? When something goes wrong, we can look back at our log, and figure out which action corrupted the state.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="287cf4a678ff4e9d1ea3555ab140fc6d89ea8b80" translate="yes" xml:space="preserve">
          <source>Wouldn't it be useful if, any time an error is thrown as a result of dispatching an action, we would send it to a crash reporting service like &lt;a href=&quot;https://getsentry.com/welcome/&quot;&gt;Sentry&lt;/a&gt; with the stack trace, the action that caused the error, and the current state? This way it's much easier to reproduce the error in development.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="411ddc1bcac2f709ddb631f9805e03c11ac7e355" translate="yes" xml:space="preserve">
          <source>Wrapping the Reducer</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba0e9312c8cb9cd6ef1a61e5d88575514a7ba12b" translate="yes" xml:space="preserve">
          <source>Writing Tests</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e92ef945f3ed541f8b7064bd91824ad741ef1405" translate="yes" xml:space="preserve">
          <source>Writing simple action creators can be tiresome and often ends up generating redundant boilerplate code:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80dc0881b1c90b466a5ebf41c749b8683c142f76" translate="yes" xml:space="preserve">
          <source>Ximedes</source>
          <target state="translated">Ximedes</target>
        </trans-unit>
        <trans-unit id="5397e0583f14f6c88de06b1ef28f460a1fb5b0ae" translate="yes" xml:space="preserve">
          <source>Yes</source>
          <target state="translated">Yes</target>
        </trans-unit>
        <trans-unit id="885f3940d9ce7913d6e6d671fe072b2efd348d82" translate="yes" xml:space="preserve">
          <source>Yes, lots of them! To name just a few:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="677676d61dff082b230a183ba82de368a4fd2ae9" translate="yes" xml:space="preserve">
          <source>You Might Not Need Redux</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5debd85103d524869a8aafb925b357862c1933e" translate="yes" xml:space="preserve">
          <source>You can also enable the &lt;a href=&quot;recipes/usingobjectspreadoperator&quot;&gt;object spread operator proposal&lt;/a&gt; for a more succinct syntax:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea3d01095c6b6725a225b7568204932eba587586" translate="yes" xml:space="preserve">
          <source>You can always write a function that generates an action creator:</source>
          <target state="new"/>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
