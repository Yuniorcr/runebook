<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="es" datatype="htmlbody" original="jest">
    <body>
      <group id="jest">
        <trans-unit id="f2884236a5a7d1409f769ed84cceee98770e2aba" translate="yes" xml:space="preserve">
          <source>Runs tests related to the changes since the provided branch. If the current branch has diverged from the given branch, then only changes made locally will be tested. Behaves similarly to &lt;code&gt;--onlyChanged&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fdee9094809cabf1a25af1ca3211f475ddc04a54" translate="yes" xml:space="preserve">
          <source>Runs tests related to the current changes and the changes made in the last commit. Behaves similarly to &lt;code&gt;--onlyChanged&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea13653cdec671f745362f34fcd64c3406b64c75" translate="yes" xml:space="preserve">
          <source>Scoped modules can be mocked by creating a file in a directory structure that matches the name of the scoped module. For example, to mock a scoped module called &lt;code&gt;@scope/project-name&lt;/code&gt;, create a file at &lt;code&gt;__mocks__/@scope/project-name.js&lt;/code&gt;, creating the &lt;code&gt;@scope/&lt;/code&gt; directory accordingly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cbc636498e1c269635cd060804fe4bc4c5cc9f77" translate="yes" xml:space="preserve">
          <source>Scoping</source>
          <target state="translated">Scoping</target>
        </trans-unit>
        <trans-unit id="211a5b2321ab26457503f06cb4dc7556791fc7d0" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;configuration#snapshotserializers-arraystring&quot;&gt;configuring Jest&lt;/a&gt; for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="efddd22422ff36c5396f782f1486c33090e561a7" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://docs.aws.amazon.com/AWSJavaScriptSDK/latest/AWS/DynamoDB.html#createTable-property&quot;&gt;Create Table API&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f34a9c66618a8a38e77218fa386d8ca82390118e" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://github.com/shelfio/jest-dynamodb&quot;&gt;documentation&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0f8c5b32a609f4f0cc5792e1d82420240d67f10" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://github.com/shelfio/jest-mongodb&quot;&gt;documentation&lt;/a&gt; for details (configuring MongoDB version, etc).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85e1678b6936236b6f910c2ee40e764fd5fd5efb" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://github.com/smooth-code/jest-puppeteer&quot;&gt;documentation&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac033bc12bf7544e09b943fc85a55ee0e0eb5bb2" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://jestjs.io/help.html&quot;&gt;Help&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4bd8f6623cb0bd7f5cbd56dab7f5f02bfe1b459a" translate="yes" xml:space="preserve">
          <source>See &lt;code&gt;automock&lt;/code&gt; section of &lt;a href=&quot;configuration#automock-boolean&quot;&gt;configuration&lt;/a&gt; for more information</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6f206289cb851ace292e1546d209054802eb0c9" translate="yes" xml:space="preserve">
          <source>See also &lt;a href=&quot;#testregex-string--arraystring&quot;&gt;&lt;code&gt;testRegex&lt;/code&gt; [string | array&amp;lt;string&amp;gt;]&lt;/a&gt;, but note that you cannot specify both options.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94efbf6a114ebb2635afd14dc7211a7f961c8a16" translate="yes" xml:space="preserve">
          <source>See the &lt;a href=&quot;https://github.com/jonschlinkert/micromatch&quot;&gt;micromatch&lt;/a&gt; package for details of the patterns you can specify.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="615ea98380b0e9ec8f2989a621cea9a7e764e463" translate="yes" xml:space="preserve">
          <source>Set the default timeout interval for tests and before/after hooks in milliseconds.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c094b57443ef1dac1663cfc0d2869275b9ac2e1" translate="yes" xml:space="preserve">
          <source>Sets the path to the &lt;a href=&quot;https://prettier.io/&quot;&gt;&lt;code&gt;prettier&lt;/code&gt;&lt;/a&gt; node module used to update inline snapshots.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03632ef1c76d8a3790f3ba38329aa3105012b7ef" translate="yes" xml:space="preserve">
          <source>Setting this value to &lt;code&gt;fake&lt;/code&gt; allows the use of fake timers for functions such as &lt;code&gt;setTimeout&lt;/code&gt;. Fake timers are useful when a piece of code sets a long timeout that we don't want to wait for in a test.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cdd7bb2816b7a8f88bce0e47be39943bc369516b" translate="yes" xml:space="preserve">
          <source>Setup</source>
          <target state="translated">Setup</target>
        </trans-unit>
        <trans-unit id="5f07ec3fe4ba8082e43fef02f2b4d5d1a2a1d466" translate="yes" xml:space="preserve">
          <source>Setup and Teardown</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24b1a600607b12b94694aa1cdc63d96c8b7a540d" translate="yes" xml:space="preserve">
          <source>Setup with Create React App</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e9d9e60fd56a1f1ea8ea643530acaeb4d062997" translate="yes" xml:space="preserve">
          <source>Setup without Create React App</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="822b3a2435ec58cb5bc9376be9ad2eeac55edc92" translate="yes" xml:space="preserve">
          <source>Should snapshot files be committed?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="492eafbaea4c259f43100935024f5e3a182f7170" translate="yes" xml:space="preserve">
          <source>Should your plugin attempt to overwrite a reserved key, Jest will error out with a descriptive message, something like:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd51fd0dd8cd830d4a42fc531c55cdfccd2ac812" translate="yes" xml:space="preserve">
          <source>Show the help information, similar to this page.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb22048fa6d1f11cbc46a0377600ca142853ad0a" translate="yes" xml:space="preserve">
          <source>Similarly webpack's &lt;code&gt;resolve.root&lt;/code&gt; option functions like setting the &lt;code&gt;NODE_PATH&lt;/code&gt; env variable, which you can set, or make use of the &lt;code&gt;modulePaths&lt;/code&gt; option.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1b6800d4211e291c95387e4b2e79446e622a4f0" translate="yes" xml:space="preserve">
          <source>Since Jest 22.1.0+, the &lt;code&gt;jest.spyOn&lt;/code&gt; method takes an optional third argument of &lt;code&gt;accessType&lt;/code&gt; that can be either &lt;code&gt;'get'&lt;/code&gt; or &lt;code&gt;'set'&lt;/code&gt;, which proves to be useful when you want to spy on a getter or a setter, respectively.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f8bae34a73e1f4213cb283f5a11b822ba4dc217" translate="yes" xml:space="preserve">
          <source>Since the later describes exactly what's expected in the output, it's more clear to see when it's wrong:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9678530810438e60dd8aa3f6aa12c28ea2f3f1c" translate="yes" xml:space="preserve">
          <source>Since we just updated our component to point to a different address, it's reasonable to expect changes in the snapshot for this component. Our snapshot test case is failing because the snapshot for our updated component no longer matches the snapshot artifact for this test case.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="540cf57482add7abae948ebe3f5722e703011e20" translate="yes" xml:space="preserve">
          <source>Since we'd like our tests to avoid actually hitting the disk (that's pretty slow and fragile), we create a manual mock for the &lt;code&gt;fs&lt;/code&gt; module by extending an automatic mock. Our manual mock will implement custom versions of the &lt;code&gt;fs&lt;/code&gt; APIs that we can build on for our tests:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66842e9da141137fe7352a0a53d93d8d95043a5c" translate="yes" xml:space="preserve">
          <source>Snapshot Test</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cdf5126870db570bc7f1db0845f8a4e0d4d3ae76" translate="yes" xml:space="preserve">
          <source>Snapshot Testing</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89df76fc07cdab1a593d1520d1e485a89eaa0758" translate="yes" xml:space="preserve">
          <source>Snapshot Testing with Jest</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="133546ab2de371a152f49c68a57605cf66823f74" translate="yes" xml:space="preserve">
          <source>Snapshot Testing with Mocks, Enzyme and React 16</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a16d1671f06c1b79f4ca90da446bf86ec30018f" translate="yes" xml:space="preserve">
          <source>Snapshot files must always represent the current state of the modules they are covering. Therefore, if you are merging two branches and encounter a conflict in the snapshot files, you can either resolve the conflict manually or update the snapshot file by running Jest and inspecting the result.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2f67f68de52f1c63bdae4635f588faaa8a269e7" translate="yes" xml:space="preserve">
          <source>Snapshot testing and visual regression testing are two distinct ways of testing UIs, and they serve different purposes. Visual regression testing tools take screenshots of web pages and compare the resulting images pixel by pixel. With Snapshot testing values are serialized, stored within text files, and compared using a diff algorithm. There are different trade-offs to consider and we listed the reasons why snapshot testing was built in the &lt;a href=&quot;https://jestjs.io/blog/2016/07/27/jest-14.html#why-snapshot-testing&quot;&gt;Jest blog&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67c5ace60d5fc8adf8135b3fa0469ad4f55990c3" translate="yes" xml:space="preserve">
          <source>Snapshot testing is only one of more than 20 assertions that ship with Jest. The aim of snapshot testing is not to replace existing unit tests, but to provide additional value and make testing painless. In some scenarios, snapshot testing can potentially remove the need for unit testing for a particular set of functionalities (e.g. React components), but they can work together as well.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d78cced32db30f3bf1c92f37bcc6a46c7cbbb0b3" translate="yes" xml:space="preserve">
          <source>Snapshot tests are a very useful tool whenever you want to make sure your UI does not change unexpectedly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46a65a578f3ba45c38c2f4b67393d191767bfc07" translate="yes" xml:space="preserve">
          <source>Snapshots are a fantastic tool for identifying unexpected interface changes within your application &amp;ndash; whether that interface is an API response, UI, logs, or error messages. As with any testing strategy, there are some best-practices you should be aware of, and guidelines you should follow, in order to use them effectively.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f682ce988a8d01605c894c6eb3963ca0cc76e8b" translate="yes" xml:space="preserve">
          <source>Sometimes it happens (especially in React Native or TypeScript projects) that 3rd party modules are published as untranspiled. Since all files inside &lt;code&gt;node_modules&lt;/code&gt; are not transformed by default, Jest will not understand the code in these modules, resulting in syntax errors. To overcome this, you may use &lt;code&gt;transformIgnorePatterns&lt;/code&gt; to whitelist such modules. You'll find a good example of this use case in &lt;a href=&quot;tutorial-react-native#transformignorepatterns-customization&quot;&gt;React Native Guide&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2b30ccb8fda73d533a0e969bafd118c24c88742" translate="yes" xml:space="preserve">
          <source>Sometimes you need to provide a more complex manual mock. For example if you'd like to forward the prop types or static fields of a native component to a mock, you can return a different React component from a mock through this helper from jest-react-native:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="695c0e7e9d729e27f87cadca0070a18d74fc0abb" translate="yes" xml:space="preserve">
          <source>Sort test path alphabetically.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e68b54695ab9a614c999727da57981ffa8733914" translate="yes" xml:space="preserve">
          <source>Specifies notification mode. Requires &lt;code&gt;notify: true&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3484b5172e046d75121af3f84a8f20757a6f1353" translate="yes" xml:space="preserve">
          <source>Specify preset in your Jest configuration:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="072147ce4032ecb883aadc972685fb5dc5cab93b" translate="yes" xml:space="preserve">
          <source>Spying on methods of our class</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e66bbc94f94d5c9febbf71967e8a53cc9c379f0" translate="yes" xml:space="preserve">
          <source>Spying on the constructor</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="024a38d0b03fcbf63acc93daff4e631c67675d3b" translate="yes" xml:space="preserve">
          <source>Starting from react-native version 0.38, a Jest setup is included by default when running &lt;code&gt;react-native init&lt;/code&gt;. The following configuration should be automatically added to your package.json file:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1991c5175326e4c289d97fffe85eadf0791dd3bd" translate="yes" xml:space="preserve">
          <source>Static ES6 module imports are hoisted to the top of the file, so instead we have to import them dynamically using &lt;code&gt;import()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28f738d61989d25363252d6dd69c2b75719b7de9" translate="yes" xml:space="preserve">
          <source>Still unresolved?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c6f5518d1fa80f650e491adb2e489a09a7f982c" translate="yes" xml:space="preserve">
          <source>Still, there are cases where it's useful to go beyond the ability to specify return values and full-on replace the implementation of a mock function. This can be done with &lt;code&gt;jest.fn&lt;/code&gt; or the &lt;code&gt;mockImplementationOnce&lt;/code&gt; method on mock functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3816c4beac471c733eed1d91c213f8c2b6a29262" translate="yes" xml:space="preserve">
          <source>Strings</source>
          <target state="translated">Strings</target>
        </trans-unit>
        <trans-unit id="bcc358b3aaafb093f4a2baf42f0160bfb2bfd061" translate="yes" xml:space="preserve">
          <source>Suppose we have a class that fetches users from our API. The class uses &lt;a href=&quot;https://github.com/axios/axios&quot;&gt;axios&lt;/a&gt; to call the API then returns the &lt;code&gt;data&lt;/code&gt; attribute which contains all the users:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a4bc60f3a09d9eb5a73886f79212b0e558b15ec" translate="yes" xml:space="preserve">
          <source>Syntactic sugar function for:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae135cb4bf99d2d69cbac3f5fd417c5399be204b" translate="yes" xml:space="preserve">
          <source>Test environment options that will be passed to the &lt;code&gt;testEnvironment&lt;/code&gt;. The relevant options depend on the environment. For example you can override options given to &lt;a href=&quot;https://github.com/tmpvar/jsdom&quot;&gt;jsdom&lt;/a&gt; such as &lt;code&gt;{userAgent: &quot;Agent/007&quot;}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b55666a28ff3618a6bc88a5a3086460692f20399" translate="yes" xml:space="preserve">
          <source>Test files are normally ignored from collecting code coverage. With this option, you can overwrite this behavior and include otherwise ignored files in code coverage.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32a2b6bfc1cb248afcfe7c96a42e9a946326cac4" translate="yes" xml:space="preserve">
          <source>Test files run inside a &lt;a href=&quot;https://nodejs.org/api/vm.html&quot;&gt;vm&lt;/a&gt;, which slows calls to global context properties (e.g. &lt;code&gt;Math&lt;/code&gt;). With this option you can specify extra properties to be defined inside the vm for faster lookups.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da102bd566881f332f6aa321d898e870666704cb" translate="yes" xml:space="preserve">
          <source>Testing Asynchronous Code</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4b91ec445494c8e5c6d2ecedd86aa56ac5179b5" translate="yes" xml:space="preserve">
          <source>Testing React Apps</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5987105ad86879109c74631bcc686434d71992ae" translate="yes" xml:space="preserve">
          <source>Testing React Native Apps</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="225fc2b10e9a9ea9b701c17da2b76bad93c7b747" translate="yes" xml:space="preserve">
          <source>Testing Web Frameworks</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b228c0a462e4fbc62499ce73feb2a8eb75c4bd39" translate="yes" xml:space="preserve">
          <source>Tests are Extremely Slow on Docker and/or Continuous Integration (CI) server.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2d1541959da20e20096a585a0538d9010954c98" translate="yes" xml:space="preserve">
          <source>Tests are Failing and You Don't Know Why</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c8e525d4231c4190be70b1ad66cd616c6e2aa0f" translate="yes" xml:space="preserve">
          <source>Tests must be defined synchronously for Jest to be able to collect your tests.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba7f8377fd3129e903838676530e75e431a41733" translate="yes" xml:space="preserve">
          <source>That module can also contain a &lt;code&gt;getCacheKey&lt;/code&gt; function to generate a cache key to determine if the logic has changed and any cached artifacts relying on it should be discarded.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11a78e492a9e9e7ac361c24117bfb5e811bddb35" translate="yes" xml:space="preserve">
          <source>That's all there is to it! You can even update the snapshots with &lt;code&gt;--updateSnapshot&lt;/code&gt; or using the &lt;code&gt;u&lt;/code&gt; key in &lt;code&gt;--watch&lt;/code&gt; mode.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa64459e4e03b6885bddfefb159ed4eb86b6825b" translate="yes" xml:space="preserve">
          <source>That's it! webpack is a complex and flexible tool, so you may have to make some adjustments to handle your specific application's needs. Luckily for most projects, Jest should be more than flexible enough to handle your webpack config.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c3361ad0e93e6bc1e1c3de2667211b364b378cd" translate="yes" xml:space="preserve">
          <source>The 4 ways to create an ES6 class mock</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95c25a4fa34143b1216d44b01d41f9f29688f727" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;configuration#clearmocks-boolean&quot;&gt;&lt;code&gt;clearMocks&lt;/code&gt;&lt;/a&gt; configuration option is available to clear mocks automatically between tests.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06c017e6536e5d9f6110e8d0080ca094a5e9ea11" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;configuration#modulenamemapper-objectstring-string&quot;&gt;&lt;code&gt;moduleNameMapper&lt;/code&gt;&lt;/a&gt; can be used to map a module path to a different module. By default the preset maps all images to an image stub module but if a module cannot be found this configuration option can help:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4d9df38ccbce3dc2ed35e993bc8900c35030ec6" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;configuration#restoremocks-boolean&quot;&gt;&lt;code&gt;restoreMocks&lt;/code&gt;&lt;/a&gt; configuration option is available to restore mocks automatically between tests.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1fd9f27ef141c8e346e850781739fd26da2e8bd" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;configuration#transformignorepatterns-arraystring&quot;&gt;&lt;code&gt;transformIgnorePatterns&lt;/code&gt;&lt;/a&gt; option can be used to whitelist or blacklist files from being transformed with Babel. Many react-native npm modules unfortunately don't pre-compile their source code before publishing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5fcd870eb6449696a26dbe9a35105b1b3f0eb6a3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;./src/api/very-important-module.js&lt;/code&gt; file has less than 100% coverage.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4b1bdae91ac8b4ba9e5526619539ee09ec8ff0b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;./src/components&lt;/code&gt; directory has less than 40% branch or statement coverage.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="afcc7bfb1a0f92aed03ab154b1ea46d01fb61f0c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;expect.assertions(2)&lt;/code&gt; call ensures that both callbacks actually get called.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8801cb3154dc90b6dabeb0f8d6adc04b7c96a994" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;expect.hasAssertions()&lt;/code&gt; call ensures that the &lt;code&gt;prepareState&lt;/code&gt; callback actually gets called.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c3326411c984dac96e58b8dd16be60c0de3724a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;expect&lt;/code&gt; function is used every time you want to test a value. You will rarely call &lt;code&gt;expect&lt;/code&gt; by itself. Instead, you will use &lt;code&gt;expect&lt;/code&gt; along with a &quot;matcher&quot; function to assert something about a value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6594bb5f273e5a4f7094c361061889db4f707818" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;extract&lt;/code&gt; function should return an iterable (&lt;code&gt;Array&lt;/code&gt;, &lt;code&gt;Set&lt;/code&gt;, etc.) with the dependencies found in the code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5539a986bbbbf8c351471c1981c9549b0ae07121" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;jest&lt;/code&gt; command line runner has a number of useful options. You can run &lt;code&gt;jest --help&lt;/code&gt; to view all available options. Many of the options shown below can also be used together to run tests exactly the way you want. Every one of Jest's &lt;a href=&quot;configuration&quot;&gt;Configuration&lt;/a&gt; options can also be specified through the CLI.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8cb0dc4d98327301d27ed47332b5824609aeec5f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;jest&lt;/code&gt; object is automatically in scope within every test file. The methods in the &lt;code&gt;jest&lt;/code&gt; object help create mocks and let you control Jest's overall behavior.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7b8cc683ede161fc025b891451a1f71de3a0d36" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;mockImplementation&lt;/code&gt; method is useful when you need to define the default implementation of a mock function that is created from another module:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f414ca5debc72d67a32f4e6f4214b85eb7903c2e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;value&lt;/code&gt; property contains the value that was thrown or returned. &lt;code&gt;value&lt;/code&gt; is undefined when &lt;code&gt;type === 'incomplete'&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60ae20badadde4a0ac472d6382213bf5645d769e" translate="yes" xml:space="preserve">
          <source>The Chrome Developer Tools will be displayed, and a breakpoint will be set at the first line of the Jest CLI script (this is done to give you time to open the developer tools and to prevent Jest from executing before you have time to do so). Click the button that looks like a &quot;play&quot; button in the upper right hand side of the screen to continue execution. When Jest executes the test that contains the &lt;code&gt;debugger&lt;/code&gt; statement, execution will pause and you can examine the current scope and call stack.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cdefcc002eddfb7f6c28f9c7a1871357f57fe794" translate="yes" xml:space="preserve">
          <source>The Jest Object</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af5336b9f0d6a51b49389a0b7ed3fd6e4c3872c6" translate="yes" xml:space="preserve">
          <source>The Jest preset built into &lt;code&gt;react-native&lt;/code&gt; comes with a few default mocks that are applied on a react-native repository. However some react-native components or third party components rely on native code to be rendered. In such cases, Jest's manual mocking system can help to mock out the underlying implementation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2453c12b4a4f24fbc05ce1e4c46073678639c15d" translate="yes" xml:space="preserve">
          <source>The Jest watch plugin system provides a way to hook into specific parts of Jest and to define watch mode menu prompts that execute code on key press. Combined, these features allow you to develop interactive experiences custom for your workflow.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9caca20f4fce1e72a9edd33743ac65377cd25c74" translate="yes" xml:space="preserve">
          <source>The argument to &lt;code&gt;expect&lt;/code&gt; should be the value that your code produces, and any argument to the matcher should be the correct value. If you mix them up, your tests will still work, but the error messages on failing tests will look strange.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8cc68f24cef4585983c9f185a90ee734f90aa8ae" translate="yes" xml:space="preserve">
          <source>The class may optionally expose a &lt;code&gt;handleTestEvent&lt;/code&gt; method to bind to events fired by &lt;a href=&quot;https://github.com/facebook/jest/tree/master/packages/jest-circus&quot;&gt;&lt;code&gt;jest-circus&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="505efbd4b63a11e029fe3900fcf34d5ab8217315" translate="yes" xml:space="preserve">
          <source>The code for this example is available at &lt;a href=&quot;https://github.com/facebook/jest/tree/master/examples/async&quot;&gt;examples/async&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61f42c40ba4012116e65e0172c4574798fdcc3a1" translate="yes" xml:space="preserve">
          <source>The code for this example is available at &lt;a href=&quot;https://github.com/facebook/jest/tree/master/examples/enzyme&quot;&gt;examples/enzyme&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e772aeae1e1e3865bc4cf9718bec60261ce607b" translate="yes" xml:space="preserve">
          <source>The code for this example is available at &lt;a href=&quot;https://github.com/facebook/jest/tree/master/examples/jquery&quot;&gt;examples/jquery&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e7eb572425bcca3655b70ad564fc1692cbc457f" translate="yes" xml:space="preserve">
          <source>The code for this example is available at &lt;a href=&quot;https://github.com/facebook/jest/tree/master/examples/manual-mocks&quot;&gt;examples/manual-mocks&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0665793600a54f70d63deadff14baccb32f7bff" translate="yes" xml:space="preserve">
          <source>The code for this example is available at &lt;a href=&quot;https://github.com/facebook/jest/tree/master/examples/react-native&quot;&gt;examples/react-native&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9347a0f5e3be6b1f8c7f0c4795c7b215bb18ebd4" translate="yes" xml:space="preserve">
          <source>The code for this example is available at &lt;a href=&quot;https://github.com/facebook/jest/tree/master/examples/react-testing-library&quot;&gt;examples/react-testing-library&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b032ec230190e1c4fc446fee9c02430a5dbbd77b" translate="yes" xml:space="preserve">
          <source>The code for this example is available at &lt;a href=&quot;https://github.com/facebook/jest/tree/master/examples/snapshot&quot;&gt;examples/snapshot&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc4f949fe92e0d8c8e3b3a03859bac8aa481d502" translate="yes" xml:space="preserve">
          <source>The code for this example is available at &lt;a href=&quot;https://github.com/facebook/jest/tree/master/examples/timer&quot;&gt;examples/timer&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f12a555ea8e1761a86877b27341850cacd56ac73" translate="yes" xml:space="preserve">
          <source>The community around Jest is working hard to make the testing experience even greater.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7585ea7c7f78a15b022764598b8197c90e7876b0" translate="yes" xml:space="preserve">
          <source>The directory where Jest should output its coverage files.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="376f21d7672ef7ba555cd8e4de07656368d480d0" translate="yes" xml:space="preserve">
          <source>The directory where Jest should store its cached dependency information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b455adf26e8057d7ba70aa7e64159f9222cf09e6" translate="yes" xml:space="preserve">
          <source>The easiest way to debug Jest tests in &lt;a href=&quot;https://www.jetbrains.com/webstorm/&quot;&gt;WebStorm&lt;/a&gt; is using &lt;code&gt;Jest run/debug configuration&lt;/code&gt;. It will launch tests and automatically attach debugger.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ecbe9621df2404d5fbb33e2600044e0b27c47481" translate="yes" xml:space="preserve">
          <source>The example mock shown here uses &lt;a href=&quot;jest-object#jestgenmockfrommodulemodulename&quot;&gt;&lt;code&gt;jest.genMockFromModule&lt;/code&gt;&lt;/a&gt; to generate an automatic mock, and overrides its default behavior. This is the recommended approach, but is completely optional. If you do not want to use the automatic mock at all, you can export your own functions from the mock file. One downside to fully manual mocks is that they're manual &amp;ndash; meaning you have to manually update them any time the module they are mocking changes. Because of this, it's best to use or extend the automatic mock when it works for your needs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4a4a43d898d3af6802055c9164972d36548014d" translate="yes" xml:space="preserve">
          <source>The first argument is the test name; the second argument is a function that contains the expectations to test. The third argument (optional) is &lt;code&gt;timeout&lt;/code&gt; (in milliseconds) for specifying how long to wait before aborting. &lt;em&gt;Note: The default timeout is 5 seconds.&lt;/em&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6838de5b16cb59f34f7a719f1e8d3453345e067e" translate="yes" xml:space="preserve">
          <source>The first time this test is run, Jest creates a &lt;a href=&quot;https://github.com/facebook/jest/blob/master/examples/snapshot/__tests__/__snapshots__/link.react.test.js.snap&quot;&gt;snapshot file&lt;/a&gt; that looks like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1492463266cc80f52fcf093c60f36ae239754aca" translate="yes" xml:space="preserve">
          <source>The following example contains a &lt;code&gt;houseForSale&lt;/code&gt; object with nested properties. We are using &lt;code&gt;toHaveProperty&lt;/code&gt; to check for the existence and values of various properties in the object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7f734d3eeaab81fca3e29f3523738b60fc7cd77" translate="yes" xml:space="preserve">
          <source>The following is a visualization of the default regex:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47cef9c94451278775edf865a9789b6d6b64cf3f" translate="yes" xml:space="preserve">
          <source>The following keys for built-in functionality &lt;strong&gt;can be overwritten&lt;/strong&gt; :</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d021e17efe498d997940dd70ef8fa277b5a2e9cd" translate="yes" xml:space="preserve">
          <source>The function being tested adds an event listener on the &lt;code&gt;#button&lt;/code&gt; DOM element, so we need to set up our DOM correctly for the test. Jest ships with &lt;code&gt;jsdom&lt;/code&gt; which simulates a DOM environment as if you were in the browser. This means that every DOM API that we call can be observed in the same way it would be observed in a browser!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6596e95c4d26bf49becdf01cb51e6fc651959a04" translate="yes" xml:space="preserve">
          <source>The function should either return a path to the module that should be resolved or throw an error if the module can't be found.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aab58f520069315bb0a84d63dee876237963ccad" translate="yes" xml:space="preserve">
          <source>The glob patterns Jest uses to detect test files. By default it looks for &lt;code&gt;.js&lt;/code&gt;, &lt;code&gt;.jsx&lt;/code&gt;, &lt;code&gt;.ts&lt;/code&gt; and &lt;code&gt;.tsx&lt;/code&gt; files inside of &lt;code&gt;__tests__&lt;/code&gt; folders, as well as any files with a suffix of &lt;code&gt;.test&lt;/code&gt; or &lt;code&gt;.spec&lt;/code&gt; (e.g. &lt;code&gt;Component.test.js&lt;/code&gt; or &lt;code&gt;Component.spec.js&lt;/code&gt;). It will also find files called &lt;code&gt;test.js&lt;/code&gt; or &lt;code&gt;spec.js&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1723fc61e3e4203902e2769fce84e0f47e6816e8" translate="yes" xml:space="preserve">
          <source>The goal is to make it easy to review snapshots in pull requests, and fight against the habit of regenerating snapshots when test suites fail instead of examining the root causes of their failure.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2689ebeac189b738f558285371fec779e8a24bfd" translate="yes" xml:space="preserve">
          <source>The jest-community org maintains an &lt;a href=&quot;https://github.com/jest-community/awesome-jest&quot;&gt;awesome-jest&lt;/a&gt; list of great projects and resources related to Jest, this includes all projects not just the ones in the jest-community org.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="327140711518544eb69d91ed359d0f86086c942f" translate="yes" xml:space="preserve">
          <source>The manual mock equivalent of this would be:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="968ed8d3094b9f92af942c92765f9081682130bf" translate="yes" xml:space="preserve">
          <source>The module factory function passed to &lt;code&gt;jest.mock(path, moduleFactory)&lt;/code&gt; can be a HOF that returns a function*. This will allow calling &lt;code&gt;new&lt;/code&gt; on the mock. Again, this allows you to inject different behavior for testing, but does not provide a way to spy on calls.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4376614c6f08aa0261023a608b95c6492b8e9525" translate="yes" xml:space="preserve">
          <source>The most common asynchronous pattern is callbacks.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0274127a2409aa50ab0b03082620b24a366d505d" translate="yes" xml:space="preserve">
          <source>The most common use of this API is for specifying the module a given test intends to be testing (and thus doesn't want automatically mocked).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6cba2620d821c40d1a35b89d6a989fe10a704a0f" translate="yes" xml:space="preserve">
          <source>The most useful ones are &lt;code&gt;matcherHint&lt;/code&gt;, &lt;code&gt;printExpected&lt;/code&gt; and &lt;code&gt;printReceived&lt;/code&gt; to format the error messages nicely. For example, take a look at the implementation for the &lt;code&gt;toBe&lt;/code&gt; matcher:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e952463962a1b689236ab9f6e17c97ccd482a4f3" translate="yes" xml:space="preserve">
          <source>The native timer functions (i.e., &lt;code&gt;setTimeout&lt;/code&gt;, &lt;code&gt;setInterval&lt;/code&gt;, &lt;code&gt;clearTimeout&lt;/code&gt;, &lt;code&gt;clearInterval&lt;/code&gt;) are less than ideal for a testing environment since they depend on real time to elapse. Jest can swap out timers with functions that allow you to control the passage of time. &lt;a href=&quot;https://www.youtube.com/watch?v=QZoJ2Pt27BY&quot;&gt;Great Scott!&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c7bd0e4ffc67ba49a20c3a2e181946f66fdd8b6" translate="yes" xml:space="preserve">
          <source>The next time you run Jest, &lt;code&gt;tree&lt;/code&gt; will be evaluated, and a snapshot will be written as an argument to &lt;code&gt;toMatchInlineSnapshot&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b848fe1137b4b9b68da4deb8ef3d11d697c37f6" translate="yes" xml:space="preserve">
          <source>The next time you run the tests, the rendered output will be compared to the previously created snapshot. The snapshot should be committed along code changes. When a snapshot test fails, you need to inspect whether it is an intended or unintended change. If the change is expected you can invoke Jest with &lt;code&gt;jest -u&lt;/code&gt; to overwrite the existing snapshot.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a31eaed7b5b436b050c922084e63b820147d0c79" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;numDigits&lt;/code&gt; argument has default value &lt;code&gt;2&lt;/code&gt; which means the criterion is &lt;code&gt;Math.abs(expected - received) &amp;lt; 0.005&lt;/code&gt; (that is, &lt;code&gt;10 ** -2 / 2&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb0899f14809b1bdd6ebd980d7e7260be1575887" translate="yes" xml:space="preserve">
          <source>The order in which the mappings are defined matters. Patterns are checked one by one until one fits. The most specific rule should be listed first.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c5b04e8fcaf70465aadc92771f5000507ea04a5" translate="yes" xml:space="preserve">
          <source>The path to a module that can resolve test&amp;lt;-&amp;gt;snapshot path. This config option lets you customize where Jest stores snapshot files on disk.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af95718edc02b7821b4e9e81772f5338985c3a20" translate="yes" xml:space="preserve">
          <source>The path to a module that runs some code to configure or set up the testing framework before each test. Beware that files imported by the setup script will not be mocked during testing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4431569135edde52cd7dc8cd910c15a768e3e1b1" translate="yes" xml:space="preserve">
          <source>The pattern or patterns Jest uses to detect test files. By default it looks for &lt;code&gt;.js&lt;/code&gt;, &lt;code&gt;.jsx&lt;/code&gt;, &lt;code&gt;.ts&lt;/code&gt; and &lt;code&gt;.tsx&lt;/code&gt; files inside of &lt;code&gt;__tests__&lt;/code&gt; folders, as well as any files with a suffix of &lt;code&gt;.test&lt;/code&gt; or &lt;code&gt;.spec&lt;/code&gt; (e.g. &lt;code&gt;Component.test.js&lt;/code&gt; or &lt;code&gt;Component.spec.js&lt;/code&gt;). It will also find files called &lt;code&gt;test.js&lt;/code&gt; or &lt;code&gt;spec.js&lt;/code&gt;. See also &lt;a href=&quot;#testmatch-arraystring&quot;&gt;&lt;code&gt;testMatch&lt;/code&gt; [array&amp;lt;string&amp;gt;]&lt;/a&gt;, but note that you cannot specify both options.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac24fd9dddf51302b5efc36ff27838314425a460" translate="yes" xml:space="preserve">
          <source>The preset sets up the environment and is very opinionated and based on what we found to be useful at Facebook. All of the configuration options can be overwritten just as they can be customized when no preset is used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac31d1cab716f57b4c0ab81a14ecb8cc6af7f1f3" translate="yes" xml:space="preserve">
          <source>The problem is that the test will complete as soon as &lt;code&gt;fetchData&lt;/code&gt; completes, before ever calling the callback.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c9c92c829ae1b54b1e9c5e404efb1cc15d27456" translate="yes" xml:space="preserve">
          <source>The projects feature can also be used to run multiple configurations or multiple &lt;a href=&quot;#runner-string&quot;&gt;runners&lt;/a&gt;. For this purpose you can pass an array of configuration objects. For example, to run both tests and ESLint (via &lt;a href=&quot;https://github.com/jest-community/jest-runner-eslint&quot;&gt;jest-runner-eslint&lt;/a&gt;) in the same invocation of Jest:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d777c2e867accda0c769689ff6458c1a1f2898ad" translate="yes" xml:space="preserve">
          <source>The root directory that Jest should scan for tests and modules within. If you put your Jest config inside your &lt;code&gt;package.json&lt;/code&gt; and want the root directory to be the root of your repo, the value for this config param will default to the directory of the &lt;code&gt;package.json&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a722fbdccf79dd6f0ade849e2e9aba5e205e8984" translate="yes" xml:space="preserve">
          <source>The second argument can be used to specify an explicit module factory that is being run instead of using Jest's automocking feature:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea2159726c801a056456ea23b7ba004e04675c0c" translate="yes" xml:space="preserve">
          <source>The simplest way to test a value is with exact equality.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89fdf05ff2117139335a3d62f43a887b7ae92045" translate="yes" xml:space="preserve">
          <source>The snapshot artifact should be committed alongside code changes, and reviewed as part of your code review process. Jest uses &lt;a href=&quot;https://github.com/facebook/jest/tree/master/packages/pretty-format&quot;&gt;pretty-format&lt;/a&gt; to make snapshots human-readable during code review. On subsequent test runs Jest will compare the rendered output with the previous snapshot. If they match, the test will pass. If they don't match, either the test runner found a bug in your code (in this case, it's &lt;code&gt;&amp;lt;Link&amp;gt;&lt;/code&gt; component) that should be fixed, or the implementation has changed and the snapshot needs to be updated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93bd3296b403f0c79b1219e068c720003979038e" translate="yes" xml:space="preserve">
          <source>The test environment that will be used for testing. The default environment in Jest is a browser-like environment through &lt;a href=&quot;https://github.com/tmpvar/jsdom&quot;&gt;jsdom&lt;/a&gt;. If you are building a node service, you can use the &lt;code&gt;node&lt;/code&gt; option to use a node-like environment instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83a5c50498cba1f5866a682bd859dafc3028b89d" translate="yes" xml:space="preserve">
          <source>The test environment used for all tests. This can point to any file or node module. Examples: &lt;code&gt;jsdom&lt;/code&gt;, &lt;code&gt;node&lt;/code&gt; or &lt;code&gt;path/to/my-environment.js&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d4908fe8da50856a80634fb387ecf713015308b" translate="yes" xml:space="preserve">
          <source>The test for this function will look this way:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73d8c22714027dd5317a0ccf3a9114cb6f10cf4c" translate="yes" xml:space="preserve">
          <source>The test runner module must export a function with the following signature:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29baec25ad18f1066c1ae3baa55f05cb1bcb3277" translate="yes" xml:space="preserve">
          <source>The third argument can be used to create virtual mocks &amp;ndash; mocks of modules that don't exist anywhere in the system:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06b3722bc66e669d036905e4f6b2a5bdde949a1d" translate="yes" xml:space="preserve">
          <source>The transform script was changed or Babel was updated and the changes aren't being recognized by Jest?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca9dbda065b378b7864401a6ebb986bd5f6ee7e2" translate="yes" xml:space="preserve">
          <source>The&lt;code&gt;.rejects&lt;/code&gt; helper works like the &lt;code&gt;.resolves&lt;/code&gt; helper. If the promise is fulfilled, the test will automatically fail.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb453830c3d6aec96f0b7405572bb292c7ef9964" translate="yes" xml:space="preserve">
          <source>Then add &lt;code&gt;@babel/preset-typescript&lt;/code&gt; to the list of presets in your &lt;code&gt;babel.config.js&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70a1108a97f09cf114548ba44e232397dc6dda32" translate="yes" xml:space="preserve">
          <source>Then all your className lookups on the styles object will be returned as-is (e.g., &lt;code&gt;styles.foobar === 'foobar'&lt;/code&gt;). This is pretty handy for React &lt;a href=&quot;snapshot-testing&quot;&gt;Snapshot Testing&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7fd2e2b8e86105641b83aa873750ac3f07a7e6d6" translate="yes" xml:space="preserve">
          <source>Then attach VS Code's debugger using the following &lt;code&gt;launch.json&lt;/code&gt; config:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2ebdb0fca325019ed94f96f98ebfc6dc5ffe770" translate="yes" xml:space="preserve">
          <source>Then we need a custom Test Environment for puppeteer</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91f5afaec66d498efbeae8c4a2a41bd0c4feb389" translate="yes" xml:space="preserve">
          <source>Then you will see warnings in the console:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e559c23353ae644c58d965edecd0976830cfc4b2" translate="yes" xml:space="preserve">
          <source>Then, create a file named &lt;code&gt;sum.test.js&lt;/code&gt;. This will contain our actual test:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="490b7879f324bbb8130b919839cb28e4ee52a87d" translate="yes" xml:space="preserve">
          <source>There are a number of helpful tools exposed on &lt;code&gt;this.utils&lt;/code&gt; primarily consisting of the exports from &lt;a href=&quot;https://github.com/facebook/jest/tree/master/packages/jest-matcher-utils&quot;&gt;&lt;code&gt;jest-matcher-utils&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce3ddc7ca2ed0e64f9ff4f568a1875d4a36fac12" translate="yes" xml:space="preserve">
          <source>There are also scenarios where you might have a recursive timer -- that is a timer that sets a new timer in its own callback. For these, running all the timers would be an endless loop&amp;hellip; so something like &lt;code&gt;jest.runAllTimers()&lt;/code&gt; is not desirable. For these cases you might use &lt;code&gt;jest.runOnlyPendingTimers()&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8062c6b456eff0aa9aea644bdb6882897bba1ab7" translate="yes" xml:space="preserve">
          <source>There are multiple ways to debug Jest tests with &lt;a href=&quot;https://code.visualstudio.com&quot;&gt;Visual Studio Code's&lt;/a&gt; built in &lt;a href=&quot;https://code.visualstudio.com/docs/nodejs/nodejs-debugging&quot;&gt;debugger&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f73f9113b29102310bf6ae603463dfb6eed9cda" translate="yes" xml:space="preserve">
          <source>There are times where you only want Jest to search in a single sub-directory (such as cases where you have a &lt;code&gt;src/&lt;/code&gt; directory in your repo), but prevent it from accessing the rest of the repo.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b73bd505ade591eff51524741c24e46983c0ab6" translate="yes" xml:space="preserve">
          <source>There are two ways to mock functions: Either by creating a mock function to use in test code, or writing a &lt;a href=&quot;manual-mocks&quot;&gt;&lt;code&gt;manual mock&lt;/code&gt;&lt;/a&gt; to override a module dependency.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb812ec7da9105ae82712a4e1f280b3919c21f67" translate="yes" xml:space="preserve">
          <source>There is a less verbose way using &lt;code&gt;resolves&lt;/code&gt; to unwrap the value of a fulfilled promise together with any other matcher. If the promise is rejected, the assertion will fail.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3bc98afc16f0c3f67ba16dbd3f93d1dbca283cf" translate="yes" xml:space="preserve">
          <source>There is an alternate form of &lt;code&gt;test&lt;/code&gt; that fixes this. Instead of putting the test in a function with an empty argument, use a single argument called &lt;code&gt;done&lt;/code&gt;. Jest will wait until the &lt;code&gt;done&lt;/code&gt; callback is called before finishing the test.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38513f64442e40688964ff51c98714e3662f0ad9" translate="yes" xml:space="preserve">
          <source>There's a caveat around snapshot testing when using Enzyme and React 16+. If you mock out a module using the following style:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45969bbe3aaa0e36ec651be5c3c1e2bc6f21618e" translate="yes" xml:space="preserve">
          <source>There's no need to load any dependencies.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="feaa8cf5e94e8af347c21dcc253b06efd78e08cf" translate="yes" xml:space="preserve">
          <source>There's no need to load any dependencies. Puppeteer's &lt;code&gt;page&lt;/code&gt; and &lt;code&gt;browser&lt;/code&gt; classes will automatically be exposed</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="205f02d2ffd73f73e820d056d16ae760c3445b0d" translate="yes" xml:space="preserve">
          <source>These helper functions and properties can be found on &lt;code&gt;this&lt;/code&gt; inside a custom matcher:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b60550c5bbaa39ef042c5fe44f0a413fa65b5bf" translate="yes" xml:space="preserve">
          <source>These matchers are sugar for common forms of inspecting the &lt;code&gt;.mock&lt;/code&gt; property. You can always do this manually yourself if that's more to your taste or if you need to do something more specific:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d8fa2963a415398720fb864829eb323209ccbff" translate="yes" xml:space="preserve">
          <source>These mock members are very useful in tests to assert how these functions get called, instantiated, or what they returned:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="421ccddd05618e2071d86e6bbbe14f0b2076576e" translate="yes" xml:space="preserve">
          <source>These options let you control Jest's behavior in your &lt;code&gt;package.json&lt;/code&gt; file. The Jest philosophy is to work great by default, but sometimes you just need more configuration power.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fcaea31195ac296456fff13bc787d5eef5067d3d" translate="yes" xml:space="preserve">
          <source>These pattern strings match against the full path. Use the &lt;code&gt;&amp;lt;rootDir&amp;gt;&lt;/code&gt; string token to include the path to your project's root directory to prevent it from accidentally ignoring all of your files in different environments that may have different root directories.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17b10be41180956fbf5d08f1f6d6c3f7a2db71c5" translate="yes" xml:space="preserve">
          <source>These pattern strings match against the full path. Use the &lt;code&gt;&amp;lt;rootDir&amp;gt;&lt;/code&gt; string token to include the path to your project's root directory to prevent it from accidentally ignoring all of your files in different environments that may have different root directories. Example: &lt;code&gt;[&quot;&amp;lt;rootDir&amp;gt;/build/&quot;, &quot;&amp;lt;rootDir&amp;gt;/node_modules/&quot;]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="005b28d7accf90e223dee1c8e7ebc452b6213877" translate="yes" xml:space="preserve">
          <source>These pattern strings match against the full path. Use the &lt;code&gt;&amp;lt;rootDir&amp;gt;&lt;/code&gt; string token to include the path to your project's root directory to prevent it from accidentally ignoring all of your files in different environments that may have different root directories. Example: &lt;code&gt;[&quot;&amp;lt;rootDir&amp;gt;/build/&quot;]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b61d73386d7f1dedf935b736a15ddf6e38555ac" translate="yes" xml:space="preserve">
          <source>These patterns match against the full path. Use the &lt;code&gt;&amp;lt;rootDir&amp;gt;&lt;/code&gt; string token to include the path to your project's root directory to prevent it from accidentally ignoring all of your files in different environments that may have different root directories. Example: &lt;code&gt;[&quot;&amp;lt;rootDir&amp;gt;/node_modules/&quot;]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c464bdbe395120d407822fbb18f9738c9a02965a" translate="yes" xml:space="preserve">
          <source>Third-party plugins are also forbidden to overwrite a key reserved already by another third-party plugin present earlier in the configured plugins list (&lt;code&gt;watchPlugins&lt;/code&gt; array setting). When this happens, you&amp;rsquo;ll also get an error message that tries to help you fix that:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea26b0157e1130ece50df7d1c6b1515a7cc72eba" translate="yes" xml:space="preserve">
          <source>This allows your test file to import the actual &lt;code&gt;Response&lt;/code&gt; object from &lt;code&gt;node-fetch&lt;/code&gt;, rather than a mocked version. This means the test will now pass correctly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c57d62e399034f0a7b381de3e7d5f645f9ad504" translate="yes" xml:space="preserve">
          <source>This ensures that a value matches the most recent snapshot. Check out &lt;a href=&quot;snapshot-testing&quot;&gt;the Snapshot Testing guide&lt;/a&gt; for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dac9e840fc23ac31d800f8538975040bb9ecac74" translate="yes" xml:space="preserve">
          <source>This example also shows how you can nest multiple asymmetric matchers, with &lt;code&gt;expect.stringMatching&lt;/code&gt; inside the &lt;code&gt;expect.arrayContaining&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b58eb0d982c4ebd2168b0b47532f786470fd666" translate="yes" xml:space="preserve">
          <source>This example configuration will run Jest in the root directory as well as in every folder in the examples directory. You can have an unlimited amount of projects running in the same Jest instance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07d5008923646b5de183b191e7806d1642e368f2" translate="yes" xml:space="preserve">
          <source>This is a deep-equality function that will return &lt;code&gt;true&lt;/code&gt; if two objects have the same values (recursively).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8787606ea91f4fa45b63964dfe671fe216f1f18b" translate="yes" xml:space="preserve">
          <source>This is especially useful for checking arrays or strings size.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df6bb81a22b9aea2dc501ec88e58677f39b608e1" translate="yes" xml:space="preserve">
          <source>This is how &lt;code&gt;genMockFromModule&lt;/code&gt; will mock the following data types:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3773feba2fd857753eb4d289910186bb5075a5d0" translate="yes" xml:space="preserve">
          <source>This is just a taste. For a complete list of matchers, check out the &lt;a href=&quot;expect&quot;&gt;reference docs&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b91b6036665a31c72c932de515d167cc3324bf18" translate="yes" xml:space="preserve">
          <source>This is often useful for synchronously executing setTimeouts during a test in order to synchronously assert about some behavior that would only happen after the &lt;code&gt;setTimeout()&lt;/code&gt; or &lt;code&gt;setInterval()&lt;/code&gt; callbacks executed. See the &lt;a href=&quot;timer-mocks&quot;&gt;Timer mocks&lt;/a&gt; doc for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7d7c1519ae2cf4a773f1afd649832547d401f24" translate="yes" xml:space="preserve">
          <source>This is often useful if you want to clean up some global setup state that is shared across tests.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f38502aacbc947736082f8a6708a41145ca79655" translate="yes" xml:space="preserve">
          <source>This is often useful if you want to clean up some temporary state that is created by each test.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0881bf0bef2a66191cfe13dc0ddb9fc67b1b880" translate="yes" xml:space="preserve">
          <source>This is often useful if you want to reset some global state that will be used by many tests.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9eaf0b51489505b8e52db0ac5e52495ccfe19ba" translate="yes" xml:space="preserve">
          <source>This is often useful if you want to set up some global state that will be used by many tests.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72cca58df7454651ff7a323dceaea7ab640b298b" translate="yes" xml:space="preserve">
          <source>This is useful for scenarios such as one where the module being tested schedules a &lt;code&gt;setTimeout()&lt;/code&gt; whose callback schedules another &lt;code&gt;setTimeout()&lt;/code&gt; recursively (meaning the scheduling never stops). In these scenarios, it's useful to be able to run forward in time by a single step at a time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a5ea63e8ffdad93e9fef81bb115e6f5cff87758" translate="yes" xml:space="preserve">
          <source>This is useful for some commonly used 'utility' modules that are almost always used as implementation details almost all the time (like underscore/lo-dash, etc). It's generally a best practice to keep this list as small as possible and always use explicit &lt;code&gt;jest.mock()&lt;/code&gt;/&lt;code&gt;jest.unmock()&lt;/code&gt; calls in individual tests. Explicit per-test setup is far easier for other readers of the test to reason about the environment the test will run in.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="511f2fbaf8920a0608d26d5165905f63a5d73c88" translate="yes" xml:space="preserve">
          <source>This is useful when you want to completely reset a &lt;em&gt;mock&lt;/em&gt; back to its initial state. (Note that resetting a &lt;em&gt;spy&lt;/em&gt; will result in a function with no return value).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8d37ce85710fb471d0b215386de8769da78ab05" translate="yes" xml:space="preserve">
          <source>This is useful when you want to create a &lt;a href=&quot;manual-mocks&quot;&gt;manual mock&lt;/a&gt; that extends the automatic mock's behavior.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d837db43e33775ed71a2885c71c5a5602ed7202b" translate="yes" xml:space="preserve">
          <source>This is useful when you want to mock functions in certain test cases and restore the original implementation in others.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="990db4730f558f16c2dc74a09c332aa10da16053" translate="yes" xml:space="preserve">
          <source>This is usually useful when you have a scenario where the number of dependencies you want to mock is far less than the number of dependencies that you don't. For example, if you're writing a test for a module that uses a large number of dependencies that can be reasonably classified as &quot;implementation details&quot; of the module, then you likely do not want to mock them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2cd58fa126aba532c56c9309e162bd465bef920f" translate="yes" xml:space="preserve">
          <source>This isn't required - you can write the &lt;code&gt;test&lt;/code&gt; blocks directly at the top level. But this can be handy if you prefer your tests to be organized into groups.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc38e9460c76ac869bfb97b729c4bebd9601d3e9" translate="yes" xml:space="preserve">
          <source>This matcher also accepts a string, which it will try to match:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="35176ec62e10ad24d9e5bf5b4f422f755d6dc150" translate="yes" xml:space="preserve">
          <source>This means, if any timers have been scheduled (but have not yet executed), they will be cleared and will never have the opportunity to execute in the future.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="688cc7c951b98d9e176b0ce89e8ee57961515438" translate="yes" xml:space="preserve">
          <source>This option allow comments in &lt;code&gt;package.json&lt;/code&gt;. Include the comment text as the value of this key anywhere in &lt;code&gt;package.json&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50f12b52eb11d088de9a4fec28160df38ac92acd" translate="yes" xml:space="preserve">
          <source>This option allows the use of a custom dependency extractor. It must be a node module that exports an object with an &lt;code&gt;extract&lt;/code&gt; function. E.g.:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7387fe3f611db301893ec5bf7cc4bbe625475ab6" translate="yes" xml:space="preserve">
          <source>This option allows the use of a custom global setup module which exports an async function that is triggered once before all test suites. This function gets Jest's &lt;code&gt;globalConfig&lt;/code&gt; object as a parameter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f462a8db0f13013cff3f25a99166d1df5cc7a9d9" translate="yes" xml:space="preserve">
          <source>This option allows the use of a custom global teardown module which exports an async function that is triggered once after all test suites. This function gets Jest's &lt;code&gt;globalConfig&lt;/code&gt; object as a parameter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38a9ab5d714461ae4a524d403260c43d23431747" translate="yes" xml:space="preserve">
          <source>This option allows the use of a custom resolver. This resolver must be a node module that exports a function expecting a string as the first argument for the path to resolve and an object with the following structure as the second argument:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="840ac7a9f3696ee6876dcc9f096bc867ff39672e" translate="yes" xml:space="preserve">
          <source>This option allows the use of a custom results processor. This processor must be a node module that exports a function expecting an object with the following structure as the first argument and return it:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="551495954b791bddca5765dca30e41d9a29511c6" translate="yes" xml:space="preserve">
          <source>This option allows use of a custom test runner. The default is jasmine2. A custom test runner can be provided by specifying a path to a test runner implementation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44d88dc72d1af311d80a8540431e21118807550c" translate="yes" xml:space="preserve">
          <source>This option allows you to use a custom runner instead of Jest's default test runner. Examples of runners include:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5d6d08e3a74b9984da0a1564cf8f546a76f4a82" translate="yes" xml:space="preserve">
          <source>This option allows you to use a custom sequencer instead of Jest's default. &lt;code&gt;sort&lt;/code&gt; may optionally return a Promise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c90ce340f3088fe9972394e67acc0935ff513e5d" translate="yes" xml:space="preserve">
          <source>This option allows you to use a custom watch plugins. Read more about watch plugins &lt;a href=&quot;watch-plugins&quot;&gt;here&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a29c38f33c668ab5c982f199af3ff02856c863a" translate="yes" xml:space="preserve">
          <source>This option sets the URL for the jsdom environment. It is reflected in properties such as &lt;code&gt;location.href&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6bd84ad18e9b644594d518b7f4d72e5c10823c4" translate="yes" xml:space="preserve">
          <source>This option tells Jest that all imported modules in your tests should be mocked automatically. All modules used in your tests will have a replacement implementation, keeping the API surface.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98e2dcf1f1c275210f7dbe5eb1535d1ff6f9f4c3" translate="yes" xml:space="preserve">
          <source>This shouldn't normally be your option of choice as useful warnings could be lost. However, in some cases, for example when testing react-native's components we are rendering react-native tags into the DOM and many warnings are irrelevant. Another option is to swizzle the console.warn and suppress specific warnings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="360362a3cbe9313d68d1cf19949c3804d1f4ed87" translate="yes" xml:space="preserve">
          <source>This test used &lt;code&gt;expect&lt;/code&gt; and &lt;code&gt;toBe&lt;/code&gt; to test that two values were exactly identical. To learn about the other things that Jest can test, see &lt;a href=&quot;using-matchers&quot;&gt;Using Matchers&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6e9bf3c4c1c53fe256faefd1ca6b822f3ed81ba" translate="yes" xml:space="preserve">
          <source>This will add a line in the watch mode menu &lt;em&gt;(&lt;code&gt;&amp;rsaquo; Press s to do something.&lt;/code&gt;)&lt;/em&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f973bafbc6c9d08f6e504faea0ed8253ab2995f" translate="yes" xml:space="preserve">
          <source>This will be used to configure minimum threshold enforcement for coverage results. Thresholds can be specified as &lt;code&gt;global&lt;/code&gt;, as a &lt;a href=&quot;https://github.com/isaacs/node-glob#glob-primer&quot;&gt;glob&lt;/a&gt;, and as a directory or file path. If thresholds aren't met, jest will fail. Thresholds specified as a positive number are taken to be the minimum percentage required. Thresholds specified as a negative number represent the maximum number of uncovered entities allowed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b781fa5a1c5086d94b94b3ea9ed32876793c2c2" translate="yes" xml:space="preserve">
          <source>This will collect coverage information for all the files inside the project's &lt;code&gt;rootDir&lt;/code&gt;, except the ones that match &lt;code&gt;**/node_modules/**&lt;/code&gt; or &lt;code&gt;**/vendor/**&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90cf7fb35e518c105a5552c6219ed3a42ba97b15" translate="yes" xml:space="preserve">
          <source>This will let us inspect usage of our mocked class, using &lt;code&gt;SoundPlayer.mock.calls&lt;/code&gt;: &lt;code&gt;expect(SoundPlayer).toHaveBeenCalled();&lt;/code&gt; or near-equivalent: &lt;code&gt;expect(SoundPlayer.mock.calls.length).toEqual(1);&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="209071c8d9163c6dfec4225f989d2e729c2933ea" translate="yes" xml:space="preserve">
          <source>This will override default reporters:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ce9f7467129f03386e85416d9a79207d3f3cd66" translate="yes" xml:space="preserve">
          <source>This will print something like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0128c1ff802183c48e311ffffeefd6c4c9feb5e7" translate="yes" xml:space="preserve">
          <source>This will render the component as &lt;code&gt;&amp;lt;Video {...props} /&amp;gt;&lt;/code&gt; with all of its props in the snapshot output. See also &lt;a href=&quot;tutorial-react#snapshot-testing-with-mocks-enzyme-and-react-16&quot;&gt;caveats around Enzyme and React 16&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="031037a615f9d64385b25800b6c16eb718e695ad" translate="yes" xml:space="preserve">
          <source>This will run Jest in a Node process that an external debugger can connect to. Note that the process will pause until the debugger has connected to it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff1252de72d76270d68e2df9f8a951026c2b21af" translate="yes" xml:space="preserve">
          <source>This will throw &lt;strong&gt;&lt;em&gt;TypeError: _soundPlayer2.default is not a constructor&lt;/em&gt;&lt;/strong&gt;, unless the code is transpiled to ES5, e.g. by &lt;code&gt;@babel/preset-env&lt;/code&gt;. (ES5 doesn't have arrow functions nor classes, so both will be transpiled to plain functions.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a06ab4358a87cc38d323a6fe966b85af4c53ee66" translate="yes" xml:space="preserve">
          <source>This will use custom reporter in addition to default reporters that Jest provides:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c615ded93f646fc52958cfb01c7b4ab285ef4d0" translate="yes" xml:space="preserve">
          <source>This works if &lt;code&gt;window.matchMedia()&lt;/code&gt; is used in a function (or method) which is invoked in the test. If &lt;code&gt;window.matchMedia()&lt;/code&gt; is executed directly in the tested file, Jest reports the same error. In this case, the solution is to move the manual mock into a separate file and include this one in the test &lt;strong&gt;before&lt;/strong&gt; the tested file:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0bce8231bb2ded7244230db592d5f3864c807820" translate="yes" xml:space="preserve">
          <source>Timer Mocks</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4cf1b54b003a59c279d1ba0b615a8a5f3459ca8c" translate="yes" xml:space="preserve">
          <source>Tips</source>
          <target state="translated">Tips</target>
        </trans-unit>
        <trans-unit id="2ae1e08337e0c3fff9724e42846cabe84620ef36" translate="yes" xml:space="preserve">
          <source>To add a key to the watch menu, implement the &lt;code&gt;getUsageInfo&lt;/code&gt; method, returning a key and the prompt:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47b39578e06150847a8bca907a560548f45db25e" translate="yes" xml:space="preserve">
          <source>To attach the built-in debugger, run your tests as aforementioned:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ecb87b5a4ec9578d9ae035bd9525d7f9a0bbc2d6" translate="yes" xml:space="preserve">
          <source>To automatically launch and attach to a process running your tests, use the following configuration:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ef0aac5dc160f7cae3d13500ae91ad9928ac0f1" translate="yes" xml:space="preserve">
          <source>To build your own please visit the &lt;a href=&quot;tutorial-react#custom-transformers&quot;&gt;Custom Transformer&lt;/a&gt; section</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aacf02378e2b38f25b6b3e4a83d574f8e35ceb32" translate="yes" xml:space="preserve">
          <source>To clear the record of calls to the mock constructor function and its methods, we call &lt;a href=&quot;mock-function-api#mockfnmockclear&quot;&gt;&lt;code&gt;mockClear()&lt;/code&gt;&lt;/a&gt; in the &lt;code&gt;beforeEach()&lt;/code&gt; function:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bbcbbcf6e6e23076d275df0fe406a4a0a2189298" translate="yes" xml:space="preserve">
          <source>To compare floating point numbers, you can use &lt;code&gt;toBeGreaterThan&lt;/code&gt;. For example, if you want to test that &lt;code&gt;ouncesPerCan()&lt;/code&gt; returns a value of more than 10 ounces, write:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f788e1ff5eca8835f05697583466e13f0b6a83d4" translate="yes" xml:space="preserve">
          <source>To compare floating point numbers, you can use &lt;code&gt;toBeGreaterThanOrEqual&lt;/code&gt;. For example, if you want to test that &lt;code&gt;ouncesPerCan()&lt;/code&gt; returns a value of at least 12 ounces, write:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3630a179a57250195ccd7b5b31b4f9f6faacbab0" translate="yes" xml:space="preserve">
          <source>To compare floating point numbers, you can use &lt;code&gt;toBeLessThan&lt;/code&gt;. For example, if you want to test that &lt;code&gt;ouncesPerCan()&lt;/code&gt; returns a value of less than 20 ounces, write:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7bc35d8ccb0dac837113cbb13a4a6a626da1b19b" translate="yes" xml:space="preserve">
          <source>To compare floating point numbers, you can use &lt;code&gt;toBeLessThanOrEqual&lt;/code&gt;. For example, if you want to test that &lt;code&gt;ouncesPerCan()&lt;/code&gt; returns a value of at most 12 ounces, write:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8488371ee9451e1b8abe49379e43d2abac066b15" translate="yes" xml:space="preserve">
          <source>To connect your watch plugin to Jest, add its path under &lt;code&gt;watchPlugins&lt;/code&gt; in your Jest configuration:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c020af932b115a7543d8e80249a02617ab77e279" translate="yes" xml:space="preserve">
          <source>To debug in Google Chrome (or any Chromium-based browser), open your browser and go to &lt;code&gt;chrome://inspect&lt;/code&gt; and click on &quot;Open Dedicated DevTools for Node&quot;, which will give you a list of available node instances you can connect to. Click on the address displayed in the terminal (usually something like &lt;code&gt;localhost:9229&lt;/code&gt;) after running the above command, and you will be able to debug Jest using Chrome's DevTools.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b40318402328b187f84e5d748dc7567c2272d612" translate="yes" xml:space="preserve">
          <source>To enable async/await in your project, install &lt;a href=&quot;https://babeljs.io/docs/en/babel-preset-env&quot;&gt;&lt;code&gt;@babel/preset-env&lt;/code&gt;&lt;/a&gt; and enable the feature in your &lt;code&gt;babel.config.js&lt;/code&gt; file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="302ab4340db66b28bf4eeafaae3f85ad66b05f81" translate="yes" xml:space="preserve">
          <source>To ensure that a manual mock and its real implementation stay in sync, it might be useful to require the real module using &lt;a href=&quot;jest-object#jestrequireactualmodulename&quot;&gt;&lt;code&gt;jest.requireActual(moduleName)&lt;/code&gt;&lt;/a&gt; in your manual mock and amending it with mock functions before exporting it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d68306f89da229b2b38be29155f82cf63d2fefff" translate="yes" xml:space="preserve">
          <source>To get around problems like this, Jest provides the &lt;code&gt;jest.requireActual&lt;/code&gt; helper. To make the above test work, make the following change to the imports in the test file:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11fabe8d8570a5bb7d31d77eddfbad12fd7006ea" translate="yes" xml:space="preserve">
          <source>To handle key press events from the key returned by &lt;code&gt;getUsageInfo&lt;/code&gt;, you can implement the &lt;code&gt;run&lt;/code&gt; method. This method returns a &lt;code&gt;Promise&amp;lt;boolean&amp;gt;&lt;/code&gt; that can be resolved when the plugin wants to return control to Jest. The &lt;code&gt;boolean&lt;/code&gt; specifies if Jest should rerun the tests after it gets the control back.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90daa538926bb277438f39b2435beb57540f0d66" translate="yes" xml:space="preserve">
          <source>To inject nested object values use you can supply a keyPath i.e. &lt;code&gt;$variable.path.to.value&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="970630451f28f37da628f2cf8fe84113808b5a54" translate="yes" xml:space="preserve">
          <source>To make a dependency explicit instead of implicit, you can call &lt;a href=&quot;expect#expectaddsnapshotserializerserializer&quot;&gt;&lt;code&gt;expect.addSnapshotSerializer&lt;/code&gt;&lt;/a&gt; to add a module for an individual test file instead of adding its path to &lt;code&gt;snapshotSerializers&lt;/code&gt; in Jest configuration.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7cd5137812be95f283926c769870dc2156199426" translate="yes" xml:space="preserve">
          <source>To make this work with Jest you need to update your Jest configuration with this: &lt;code&gt;&quot;transform&quot;: {&quot;\\.js$&quot;: &quot;path/to/custom-transformer.js&quot;}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="579190d7cd820daa4fd8a13a589227f7e2eaf9e7" translate="yes" xml:space="preserve">
          <source>To resolve this, we will need to update our snapshot artifacts. You can run Jest with a flag that will tell it to re-generate snapshots:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce42fc860995230ab9f043725c3815bd5aecd9d4" translate="yes" xml:space="preserve">
          <source>To test this function, we can use a mock function, and inspect the mock's state to ensure the callback is invoked as expected.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5fe8e22ac596d3e8399b1774c9a6d272aedb50d5" translate="yes" xml:space="preserve">
          <source>To transform your existing tests, navigate to the project containing the tests and run:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa8c2a8d1b80b426924e3a346cf5aa28210292b8" translate="yes" xml:space="preserve">
          <source>To use &lt;a href=&quot;http://babeljs.io/&quot;&gt;Babel&lt;/a&gt;, install required dependencies via &lt;code&gt;yarn&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45ff297d04a3d2c50427a66fd27f8359258dbfcd" translate="yes" xml:space="preserve">
          <source>To use &lt;code&gt;my-serializer-module&lt;/code&gt; as a serializer, configuration would be as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="244873608d8f270057c41ef22dd861ecd2f588e8" translate="yes" xml:space="preserve">
          <source>To use snapshot testing inside of your custom matcher you can import &lt;code&gt;jest-snapshot&lt;/code&gt; and use it from within your matcher.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d8bcde3184680e702bef641e43c9e47fee12e79" translate="yes" xml:space="preserve">
          <source>To write a test-runner, export a class with which accepts &lt;code&gt;globalConfig&lt;/code&gt; in the constructor, and has a &lt;code&gt;runTests&lt;/code&gt; method with the signature:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e7fbc811015943c1c30e7ceeea8b05c76a8ee58" translate="yes" xml:space="preserve">
          <source>To:</source>
          <target state="translated">To:</target>
        </trans-unit>
        <trans-unit id="2aa91be80e98aceeddfc910352453386480fb849" translate="yes" xml:space="preserve">
          <source>Tool for extracting and parsing the comments at the top of a JavaScript file. Exports various functions to manipulate the data inside the comment block.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2489dcd056dffceaf32fcd13112faa56f6733de" translate="yes" xml:space="preserve">
          <source>Tool for identifying modified files in a git/hg repository. Exports two functions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bba6cd68031555a8aa461d4b5c0878aad6420744" translate="yes" xml:space="preserve">
          <source>Tool for validating configurations submitted by users. Exports a function that takes two arguments: the user's configuration and an object containing an example configuration and other options. The return value is an object with two attributes:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49e105a4ea6033c274af2894a4fcb5d0e03e7eb5" translate="yes" xml:space="preserve">
          <source>Tool for visualizing changes in data. Exports a function that compares two values of any type and returns a &quot;pretty-printed&quot; string illustrating the difference between the two arguments.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="285ec850c11d78bac10f6bfa31b69a37f1b257c9" translate="yes" xml:space="preserve">
          <source>Troubleshooting</source>
          <target state="translated">Troubleshooting</target>
        </trans-unit>
        <trans-unit id="9a02428b2ce5edfe4a952ba3e66ede7b538c678d" translate="yes" xml:space="preserve">
          <source>Truthiness</source>
          <target state="translated">Truthiness</target>
        </trans-unit>
        <trans-unit id="6bce18334982e1e09a6fddd7fb83bd243818a5bd" translate="yes" xml:space="preserve">
          <source>Try running Jest with &lt;a href=&quot;cli#--watchman&quot;&gt;&lt;code&gt;--no-watchman&lt;/code&gt;&lt;/a&gt; or set the &lt;code&gt;watchman&lt;/code&gt; configuration option to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5c112e63b4110470aacee270c74bf17085f1c78" translate="yes" xml:space="preserve">
          <source>Try using the debugging support built into Node. Note: This will only work in Node.js 8+.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4a86cb946d4af4766f6a695502b64f3ea0cd58b" translate="yes" xml:space="preserve">
          <source>TypeScript</source>
          <target state="translated">TypeScript</target>
        </trans-unit>
        <trans-unit id="88ebf4f8084b9e64c1280cb83273c9798bb6700b" translate="yes" xml:space="preserve">
          <source>Uh oh, something went wrong? Use this guide to resolve issues with Jest.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aed4821821385ee1bab0a8cb0c2780d5e1b4df72" translate="yes" xml:space="preserve">
          <source>Unresolved Promises</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb0295c9e03b394a6c931085d1d4692dabdf5136" translate="yes" xml:space="preserve">
          <source>Updating Snapshots</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53431747077771927601efb2109e96aa6b694e10" translate="yes" xml:space="preserve">
          <source>Usage is similar to the module factory function, except that you can omit the second argument from &lt;code&gt;jest.mock()&lt;/code&gt;, and you must import the mocked method into your test file, since it is no longer defined there. Use the original module path for this; don't include &lt;code&gt;__mocks__&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b944d8872fd4ee30de2cd74c68ff456d47e22c9" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;&amp;lt;rootDir&amp;gt;&lt;/code&gt; string token to refer to &lt;a href=&quot;#rootdir-string&quot;&gt;&lt;code&gt;rootDir&lt;/code&gt;&lt;/a&gt; value if you want to use file paths.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="271c57d8c405fa9198756ec5064bbb4c3a46ab5a" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;.rejects&lt;/code&gt; to unwrap the reason of a rejected promise so any other matcher can be chained. If the promise is fulfilled the assertion fails.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff4d09b1ab22e18857563408d1fce004b2fe79a8" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;.toBe&lt;/code&gt; to compare primitive values or to check referential identity of object instances. It calls &lt;code&gt;Object.is&lt;/code&gt; to compare values, which is even better for testing than &lt;code&gt;===&lt;/code&gt; strict equality operator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67ef92856838e5751e399698b48aa87c7d8163a4" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;.toBeDefined&lt;/code&gt; to check that a variable is not undefined. For example, if you want to check that a function &lt;code&gt;fetchNewFlavorIdea()&lt;/code&gt; returns &lt;em&gt;something&lt;/em&gt;, you can write:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f81a87ad40dde8019daa6911a9c4296bf8a5d015" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;.toBeFalsy&lt;/code&gt; when you don't care what a value is and you want to ensure a value is false in a boolean context. For example, let's say you have some application code that looks like:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50aa6948737b4375185feeebf13f13dbe3451e19" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;.toBeInstanceOf(Class)&lt;/code&gt; to check that an object is an instance of a class. This matcher uses &lt;code&gt;instanceof&lt;/code&gt; underneath.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93a0ac0f3d847ffa6b85c3555bc23bce0abae9d2" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;.toBeNaN&lt;/code&gt; when checking a value is &lt;code&gt;NaN&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e05d177a2e90b6b046b4b02a5621b8f26893024" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;.toBeTruthy&lt;/code&gt; when you don't care what a value is and you want to ensure a value is true in a boolean context. For example, let's say you have some application code that looks like:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c167d5affa8fa782feb54d90f30b85615f390e75" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;.toBeUndefined&lt;/code&gt; to check that a variable is undefined. For example, if you want to check that a function &lt;code&gt;bestDrinkForFlavor(flavor)&lt;/code&gt; returns &lt;code&gt;undefined&lt;/code&gt; for the &lt;code&gt;'octopus'&lt;/code&gt; flavor, because there is no good octopus-flavored drink:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a934298864a7697607ca428a7e4d71c72de7efbf" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;.toContain&lt;/code&gt; when you want to check that an item is in an array. For testing the items in the array, this uses &lt;code&gt;===&lt;/code&gt;, a strict equality check. &lt;code&gt;.toContain&lt;/code&gt; can also check whether a string is a substring of another string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd36fedc663beba2df99e661929cac1ca55d82a9" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;.toContainEqual&lt;/code&gt; when you want to check that an item with a specific structure and values is contained in an array. For testing the items in the array, this matcher recursively checks the equality of all fields, rather than checking for object identity.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2892f11bab4090104beb941f4d3d44f139cd4a21" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;.toEqual&lt;/code&gt; to compare recursively all properties of object instances (also known as &quot;deep&quot; equality). It calls &lt;code&gt;Object.is&lt;/code&gt; to compare primitive values, which is even better for testing than &lt;code&gt;===&lt;/code&gt; strict equality operator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22f31877b97035b92fb10441a1a3485e65903b49" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;.toHaveBeenCalled&lt;/code&gt; to ensure that a mock function got called.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dfcaf02f56b10c94ecc202b3c8d9087baccb5181" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;.toHaveBeenCalledTimes&lt;/code&gt; to ensure that a mock function got called exact number of times.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c8d2793887755a171ad2f5be4f1a01fc5c6e2d5" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;.toHaveBeenCalledWith&lt;/code&gt; to ensure that a mock function was called with specific arguments.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4be0de20431e47e5724878c19b00a0321ac838e1" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;.toHaveLastReturnedWith&lt;/code&gt; to test the specific value that a mock function last returned. If the last call to the mock function threw an error, then this matcher will fail no matter what value you provided as the expected return value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7001ece11621c6dd7371042298806dcb68ab8bdd" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;.toHaveLength&lt;/code&gt; to check that an object has a &lt;code&gt;.length&lt;/code&gt; property and it is set to a certain numeric value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a20c538c65f701e8900dd32f27f93e926fbf397" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;.toHaveNthReturnedWith&lt;/code&gt; to test the specific value that a mock function returned for the nth call. If the nth call to the mock function threw an error, then this matcher will fail no matter what value you provided as the expected return value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc794bedf39c69791593b20f2971ba46bf591e64" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;.toHaveProperty&lt;/code&gt; to check if property at provided reference &lt;code&gt;keyPath&lt;/code&gt; exists for an object. For checking deeply nested properties in an object you may use &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Property_accessors&quot;&gt;dot notation&lt;/a&gt; or an array containing the keyPath for deep references.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c5db22f649bb5e433fce75313e71f348fcdbe60" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;.toHaveReturnedTimes&lt;/code&gt; to ensure that a mock function returned successfully (i.e., did not throw an error) an exact number of times. Any calls to the mock function that throw an error are not counted toward the number of times the function returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00cc15ef74e3e3bbb9d04e26768f906229227777" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;.toHaveReturnedWith&lt;/code&gt; to ensure that a mock function returned a specific value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3403bfc7d77f929d8284a0b531fb242672320cf2" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;.toMatch&lt;/code&gt; to check that a string matches a regular expression.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6aa577eec7c4f8e335bb974a5ba8a04b9b825d62" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;.toMatchObject&lt;/code&gt; to check that a JavaScript object matches a subset of the properties of an object. It will match received objects with properties that are &lt;strong&gt;not&lt;/strong&gt; in the expected object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43d74a2c2c927835dbc06a10fe0a834ecd3cf583" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;.toStrictEqual&lt;/code&gt; to test that objects have the same types as well as structure.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60e9ea675b7707c4a125a8d5da6124d2b7dfa82a" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;.toThrow&lt;/code&gt; to test that a function throws when it is called. For example, if we want to test that &lt;code&gt;drinkFlavor('octopus')&lt;/code&gt; throws, because octopus flavor is too disgusting to drink, we could write:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8835c8692fc22c521a477117dec692aecc544e4" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;.toThrowErrorMatchingInlineSnapshot&lt;/code&gt; to test that a function throws an error matching the most recent snapshot when it is called.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8656cd1667dc531479d8b4cb204dd90a1579844f" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;.toThrowErrorMatchingSnapshot&lt;/code&gt; to test that a function throws an error matching the most recent snapshot when it is called.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0440b25bd05f6a2e3c56826df198b652d25c12c6" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;describe.each&lt;/code&gt; if you keep duplicating the same test suites with different data. &lt;code&gt;describe.each&lt;/code&gt; allows you to write the test suite once and pass data in.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef60fa41c287f5e40cf5103947099b8fe473bb0e" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;describe.only.each&lt;/code&gt; if you want to only run specific tests suites of data driven tests.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cedc27af374f9505722e2e0748157f331b8c1a04" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;describe.skip.each&lt;/code&gt; if you want to stop running a suite of data driven tests.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d406a9d711b46330782be9bc2cb621080a4ae6f6" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;react-test-renderer&lt;/code&gt;. The test renderer doesn't care about element types and will happily accept e.g. &lt;code&gt;SomeComponent&lt;/code&gt;. You could check snapshots using the test renderer, and check component behavior separately using Enzyme.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e3d957c7581b38a6f6d9efe05f990ae9f8f779c" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;resolves&lt;/code&gt; to unwrap the value of a fulfilled promise so any other matcher can be chained. If the promise is rejected the assertion fails.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3afb7e6906f2b3257d85cde9c36efa5c6e5bcbfc" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;test.each&lt;/code&gt; if you keep duplicating the same test with different data. &lt;code&gt;test.each&lt;/code&gt; allows you to write the test once and pass data in.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ed7e082f3c3b04fc36bc3b9da1fb4c701925c6d" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;test.only.each&lt;/code&gt; if you want to only run specific tests with different test data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a662231e654755bb86491a61d19bfda30bf8dea" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;test.skip.each&lt;/code&gt; if you want to stop running a collection of data driven tests.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04f44ceaa0fcfd12976de28307ac74bab48f40fa" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;test.todo&lt;/code&gt; when you are planning on writing tests. These tests will be highlighted in the summary output at the end so you know how many tests you still need todo.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="759c0eb81e3b691ac63ce62826c9faeffd303147" translate="yes" xml:space="preserve">
          <source>Use jest-dynamodb Preset</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7194dde7b6fdc7725f8efc98a8775cd0fe57fa0a" translate="yes" xml:space="preserve">
          <source>Use jest-mongodb Preset</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6629ac509cad69b4360ba597e78efb90888b162" translate="yes" xml:space="preserve">
          <source>Use jest-puppeteer Preset</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8859f21b394eb7bddbe02c98d39f3c5d61b96c00" translate="yes" xml:space="preserve">
          <source>Use this configuration option to add custom reporters to Jest. A custom reporter is a class that implements &lt;code&gt;onRunStart&lt;/code&gt;, &lt;code&gt;onTestStart&lt;/code&gt;, &lt;code&gt;onTestResult&lt;/code&gt;, &lt;code&gt;onRunComplete&lt;/code&gt; methods that will be called when any of those events occurs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ce722d28dd2ac22869f544554814473ced27729" translate="yes" xml:space="preserve">
          <source>Useful to create async mock functions that will always reject:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82fe22471a3c89a8a884379e2a589a9b9393684f" translate="yes" xml:space="preserve">
          <source>Useful to mock async functions in async tests:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d6f5093469250351be715bab11328d708148671" translate="yes" xml:space="preserve">
          <source>Useful to resolve different values over multiple async calls:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8386651610226fd04ae64f938ef5bbd0efe279f3" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;describe.skip&lt;/code&gt; is often a cleaner alternative to temporarily commenting out a chunk of tests.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8da013e9c1193b5fd4e55adc4f5c72966bc2f345" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;jest.doMock()&lt;/code&gt; with ES6 imports requires additional steps. Follow these if you don't want to use &lt;code&gt;require&lt;/code&gt; in your tests:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b7ceb252455569b8991c8fe4bfba034672b82cf" translate="yes" xml:space="preserve">
          <source>Using Babel</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad353105ab08c29227ad5d0775b29687a1b718c7" translate="yes" xml:space="preserve">
          <source>Using Matchers</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c578fdee5f39cae171b3ae3dc5e52be3eb3db63" translate="yes" xml:space="preserve">
          <source>Using TypeScript</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2b797adce82409b798a1e85b5f20128645a30c7" translate="yes" xml:space="preserve">
          <source>Using a mock function</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fdad49cc59429141e7cc6464244c820172f9da4a" translate="yes" xml:space="preserve">
          <source>Using exact equality with floating point numbers is a bad idea. Rounding means that intuitive things fail. For example, this test fails:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d56e8185a2d6c77ca4726dcd2b55295a60bd2572" translate="yes" xml:space="preserve">
          <source>Using webpack</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5bf7b56e0fe9da5b66e110d7867887929aa794f" translate="yes" xml:space="preserve">
          <source>Using with DynamoDB</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad43d620306250954a4a631c111cb745bc0804de" translate="yes" xml:space="preserve">
          <source>Using with ES module imports</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44be8a58330b5c23182d2274fdfd6efbdf4e83a9" translate="yes" xml:space="preserve">
          <source>Using with MongoDB</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="785e92a5d24055ece246e1162c6d740443f3f058" translate="yes" xml:space="preserve">
          <source>Using with npm scripts</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="094d8ae70af4304a0d4b4a837d18e1de8f8424c0" translate="yes" xml:space="preserve">
          <source>Using with puppeteer</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62915756095c500af390187568578de70abf9244" translate="yes" xml:space="preserve">
          <source>Using with webpack</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f6a259c826a5d9735d5a64063f1b31e207c2685" translate="yes" xml:space="preserve">
          <source>Using with webpack 2</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e92e8a4901b69fac997e23f82569d015987ccae6" translate="yes" xml:space="preserve">
          <source>Using with yarn</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41c1155f49d57702ee239db81113c543bd9591e4" translate="yes" xml:space="preserve">
          <source>Usually you wouldn't check code using &lt;code&gt;test.only&lt;/code&gt; into source control - you would use it for debugging, and remove it once you have fixed the broken tests.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8bd43b7ad188ce8c3bb9691452ec856dcccbc84c" translate="yes" xml:space="preserve">
          <source>Vue.js</source>
          <target state="translated">Vue.js</target>
        </trans-unit>
        <trans-unit id="4af321d3223afd7ac8763fbd38707f1b871aa01e" translate="yes" xml:space="preserve">
          <source>Warning: If we want to mock Node's core modules (e.g.: &lt;code&gt;fs&lt;/code&gt; or &lt;code&gt;path&lt;/code&gt;), then explicitly calling e.g. &lt;code&gt;jest.mock('path')&lt;/code&gt; is &lt;strong&gt;required&lt;/strong&gt;, because core Node modules are not mocked by default.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0993b420d1ece1c116d94df1eb882929103aacb" translate="yes" xml:space="preserve">
          <source>Watch Menu Integration</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77162c2c5b3f4537b5a429cc13193176c9944f13" translate="yes" xml:space="preserve">
          <source>Watch Plugin Interface</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="730cb1589addfecd42b5dc91914d54090940dd7b" translate="yes" xml:space="preserve">
          <source>Watch Plugins</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b41755710b08ba989fe2719763a7cc16cd093cd" translate="yes" xml:space="preserve">
          <source>Watch files for changes and rerun all tests when something changes. If you want to re-run only the tests that depend on the changed files, use the &lt;code&gt;--watch&lt;/code&gt; option.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f500e5f9a091c5d91b9402809c2e1bfb82401f3" translate="yes" xml:space="preserve">
          <source>Watch files for changes and rerun tests related to changed files. If you want to re-run all tests when a file has changed, use the &lt;code&gt;--watchAll&lt;/code&gt; option instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a33b701f8666961875a562f2fa71a7405de7c06" translate="yes" xml:space="preserve">
          <source>Watch mode also enables to specify the name or path to a file to focus on a specific set of tests.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aff9902a15b762dc90c7266ccddd98d2b3f64e24" translate="yes" xml:space="preserve">
          <source>Watch plugin YourFaultyPlugin attempted to register key &lt;q&gt;, that is reserved internally for quitting watch mode. Please change the configuration key for this plugin.&lt;/q&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a673577265e6ead99e3c23f76e5f29409c5b7d10" translate="yes" xml:space="preserve">
          <source>Watch plugins YourFaultyPlugin and TheirFaultyPlugin both attempted to register key</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a8e0b7b820fac76887499e0730014073b6942fc" translate="yes" xml:space="preserve">
          <source>Watchman Issues</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58ed43a0f07990c616800d6e405003e52deb7101" translate="yes" xml:space="preserve">
          <source>We are mocking &lt;code&gt;fetchCurrentUser.js&lt;/code&gt; so that our test doesn't make a real network request but instead resolves to mock data locally. This ensures that our test can complete in milliseconds rather than seconds and guarantees a fast unit test iteration speed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39fcaf5408d64ca526faacb5d58f9141c191b735" translate="yes" xml:space="preserve">
          <source>We call &lt;code&gt;jest.mock('../request')&lt;/code&gt; to tell Jest to use our manual mock. &lt;code&gt;it&lt;/code&gt; expects the return value to be a Promise that is going to be resolved. You can chain as many Promises as you like and call &lt;code&gt;expect&lt;/code&gt; at any time, as long as you return a Promise at the end.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69b678bb69e79c49e5b0a08e85e9a17993259892" translate="yes" xml:space="preserve">
          <source>We could test this error gets thrown in several ways:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0bd52959384de0efc9e324b40ef0a059ef8e64cd" translate="yes" xml:space="preserve">
          <source>We have to specify the &lt;code&gt;__esModule: true&lt;/code&gt; property (see the &lt;a href=&quot;#jestmockmodulename-factory-options&quot;&gt;&lt;code&gt;jest.mock()&lt;/code&gt;&lt;/a&gt; API for more information).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58e30d514b365fc2673e994c86e9d1067f92cb36" translate="yes" xml:space="preserve">
          <source>We recommend placing the extensions most commonly used in your project on the left, so if you are using TypeScript, you may want to consider moving &quot;ts&quot; and/or &quot;tsx&quot; to the beginning of the array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49cfe85b5d9f91e87c2bb6c4919d6422b42d36a2" translate="yes" xml:space="preserve">
          <source>We'll use a contrived example of a class that plays sound files, &lt;code&gt;SoundPlayer&lt;/code&gt;, and a consumer class which uses that class, &lt;code&gt;SoundPlayerConsumer&lt;/code&gt;. We'll mock &lt;code&gt;SoundPlayer&lt;/code&gt; in our tests for &lt;code&gt;SoundPlayerConsumer&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a570bfe57d90629aa64647c14bb9b9299f88f21" translate="yes" xml:space="preserve">
          <source>We've told Jest to ignore files matching a stylesheet or image extension, and instead, require our mock files. You can adjust the regular expression to match the file types your webpack config handles.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e27e07bef6adeae0276f0cd001319eb48d71a2c" translate="yes" xml:space="preserve">
          <source>What is the performance of snapshot testing regarding speed and size of the generated files?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3bc8902ad3e552d6e229d9ad2fb118f5b3735490" translate="yes" xml:space="preserve">
          <source>What's the difference between snapshot testing and visual regression testing?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18c42c157f8a61af5c55926418fd204e7a9c5be1" translate="yes" xml:space="preserve">
          <source>When Jest runs your test to collect the &lt;code&gt;test&lt;/code&gt;s it will not find any because we have set the definition to happen asynchronously on the next tick of the event loop.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66a712f9c4762f8fb45d196c8b569be5ba0595bc" translate="yes" xml:space="preserve">
          <source>When a conflict happens</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ddcfa27c2af8b12d25959aeb81f42c8a1e31340" translate="yes" xml:space="preserve">
          <source>When a manual mock exists for a given module, Jest's module system will use that module when explicitly calling &lt;code&gt;jest.mock('moduleName')&lt;/code&gt;. However, when &lt;code&gt;automock&lt;/code&gt; is set to &lt;code&gt;true&lt;/code&gt;, the manual mock implementation will be used instead of the automatically created mock, even if &lt;code&gt;jest.mock('moduleName')&lt;/code&gt; is not called. To opt out of this behavior you will need to explicitly call &lt;code&gt;jest.unmock('moduleName')&lt;/code&gt; in tests that should use the actual module implementation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f71f327fabbf5c0637780926759d884ef99d4c6f" translate="yes" xml:space="preserve">
          <source>When an assertion fails, the error message should give as much signal as necessary to the user so they can resolve their issue quickly. You should craft a precise failure message to make sure users of your custom assertions have a good developer experience.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d8bace675f1044daa5589643fe0fa171a34a422" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;projects&lt;/code&gt; configuration is provided with an array of paths or glob patterns, Jest will run tests in all of the specified projects at the same time. This is great for monorepos or when working on multiple projects at the same time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="000d78fbd56ae8d851f29ec24ab5707f75357361" translate="yes" xml:space="preserve">
          <source>When the mocked function runs out of implementations defined with &lt;code&gt;mockImplementationOnce&lt;/code&gt;, it will execute the default implementation set with &lt;code&gt;jest.fn&lt;/code&gt; (if it is defined):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af9f009231011568611cfa6e9ad01b0075f8a8f9" translate="yes" xml:space="preserve">
          <source>When the mocked function runs out of implementations defined with mockImplementationOnce, it will execute the default implementation set with &lt;code&gt;jest.fn(() =&amp;gt; defaultValue)&lt;/code&gt; or &lt;code&gt;.mockImplementation(() =&amp;gt; defaultValue)&lt;/code&gt; if they were called:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="efd67d9a5d58ddfafd6576c76e2d2b45c6a9f072" translate="yes" xml:space="preserve">
          <source>When this API is called, all pending macro-tasks and micro-tasks will be executed. If those tasks themselves schedule new tasks, those will be continually exhausted until there are no more tasks remaining in the queue.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a158c79d89cb2f08512d4bfd3dd789cc435d27dc" translate="yes" xml:space="preserve">
          <source>When this API is called, all pending micro-tasks that have been queued via &lt;code&gt;process.nextTick&lt;/code&gt; will be executed. Additionally, if those micro-tasks themselves schedule new micro-tasks, those will be continually exhausted until there are no more micro-tasks remaining in the queue.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de6b8c35376469c436481e4abc3ac0840d106da8" translate="yes" xml:space="preserve">
          <source>When this API is called, all timers are advanced by &lt;code&gt;msToRun&lt;/code&gt; milliseconds. All pending &quot;macro-tasks&quot; that have been queued via &lt;code&gt;setTimeout()&lt;/code&gt; or &lt;code&gt;setInterval()&lt;/code&gt;, and would be executed within this time frame will be executed. Additionally if those macro-tasks schedule new macro-tasks that would be executed within the same time frame, those will be executed until there are no more macro-tasks remaining in the queue, that should be run within &lt;code&gt;msToRun&lt;/code&gt; milliseconds.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9dca7721cf62aeb16db42f482a108cce06f06d2" translate="yes" xml:space="preserve">
          <source>When this option is provided, Jest will assume it is running in a CI environment. This changes the behavior when a new snapshot is encountered. Instead of the regular behavior of storing a new snapshot automatically, it will fail the test and require Jest to be run with &lt;code&gt;--updateSnapshot&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea2ae246f66a28582d68b56f98e9832a105b042f" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;babel-jest&lt;/code&gt;, calls to &lt;code&gt;mock&lt;/code&gt; will automatically be hoisted to the top of the code block. Use this method if you want to explicitly avoid this behavior.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18b0443351a14618ca1bcb5f6aa3542dc98f4cfe" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;babel-jest&lt;/code&gt;, calls to &lt;code&gt;unmock&lt;/code&gt; will automatically be hoisted to the top of the code block. Use this method if you want to explicitly avoid this behavior.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f978d44fe3f641d915d3d23a0599b90ede804e61" translate="yes" xml:space="preserve">
          <source>When using the &lt;code&gt;--config&lt;/code&gt; option, the JSON file must not contain a &quot;jest&quot; key:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04fedd264e30315e94d0bfc357d0d1a8b0ecd6f0" translate="yes" xml:space="preserve">
          <source>When using the &lt;code&gt;factory&lt;/code&gt; parameter for an ES6 module with a default export, the &lt;code&gt;__esModule: true&lt;/code&gt; property needs to be specified. This property is normally generated by Babel / TypeScript, but here it needs to be set manually. When importing a default export, it's an instruction to import the property named &lt;code&gt;default&lt;/code&gt; from the export object:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d001438addabfdc9a62c0bd086018e034d25a28" translate="yes" xml:space="preserve">
          <source>When we require that module in our tests, explicitly calling &lt;code&gt;jest.mock('./moduleName')&lt;/code&gt; is &lt;strong&gt;required&lt;/strong&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="703ab40aa1656fee5bd7fb985cc5ca7e7af24578" translate="yes" xml:space="preserve">
          <source>When you are debugging a large test file, you will often only want to run a subset of tests. You can use &lt;code&gt;.only&lt;/code&gt; to specify which tests are the only ones you want to run in that test file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d76e8040b92fed0c690e41513159f4832164a34" translate="yes" xml:space="preserve">
          <source>When you are maintaining a large codebase, you may sometimes find a test that is temporarily broken for some reason. If you want to skip running this test, but you don't want to delete this code, you can use &lt;code&gt;test.skip&lt;/code&gt; to specify some tests to skip.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d417a3cdc1c802c0f3ae5fcb03331fd9db749a0" translate="yes" xml:space="preserve">
          <source>When you need to recreate a complex behavior of a mock function such that multiple function calls produce different results, use the &lt;code&gt;mockImplementationOnce&lt;/code&gt; method:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0933ea7e8d1f77a530a24c9128f18fb45e5eb8fc" translate="yes" xml:space="preserve">
          <source>When you run &lt;code&gt;jest&lt;/code&gt; with an argument, that argument is treated as a regular expression to match against files in your project. It is possible to run test suites by providing a pattern. Only the files that the pattern matches will be picked up and executed. Depending on your terminal, you may need to quote this argument: &lt;code&gt;jest &quot;my.*(complex)?pattern&quot;&lt;/code&gt;. On Windows, you will need to use &lt;code&gt;/&lt;/code&gt; as a path separator or escape &lt;code&gt;\&lt;/code&gt; as &lt;code&gt;\\&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68715485bd1666aefca572f144099e2aa37bff4b" translate="yes" xml:space="preserve">
          <source>When you run &lt;code&gt;yarn test&lt;/code&gt; or &lt;code&gt;jest&lt;/code&gt;, this will produce an output file like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a48c34ee84029428f3840a2f252c786c6d129c3b" translate="yes" xml:space="preserve">
          <source>When you're writing tests, you often need to check that values meet certain conditions. &lt;code&gt;expect&lt;/code&gt; gives you access to a number of &quot;matchers&quot; that let you validate different things.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="35131e0d0e9059a4bd01bbcebb7af6e82ca76302" translate="yes" xml:space="preserve">
          <source>Whether to use the cache. Defaults to true. Disable the cache using &lt;code&gt;--no-cache&lt;/code&gt;. &lt;em&gt;Note: the cache should only be disabled if you are experiencing caching related problems. On average, disabling the cache makes Jest at least two times slower.&lt;/em&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83164f909bcd8fc7ba78df4e824b24177b294067" translate="yes" xml:space="preserve">
          <source>Whether to use watchman for file crawling. Defaults to true. Disable using &lt;code&gt;--no-watchman&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1d2275b123b75427db7b2987318a2d50b013b7a" translate="yes" xml:space="preserve">
          <source>While Jest is most of the time extremely fast on modern multi-core computers with fast SSDs, it may be slow on certain setups as our users &lt;a href=&quot;https://github.com/facebook/jest/issues/1395&quot;&gt;have&lt;/a&gt;&lt;a href=&quot;https://github.com/facebook/jest/issues/1524#issuecomment-260246008&quot;&gt;discovered&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c1e359c575a75195c82ced579ca21229a1a43b9" translate="yes" xml:space="preserve">
          <source>While we generally recommend using the same version of every Jest package, this workaround will allow you to continue using the latest version of Jest with Babel 6 for now.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ab9c7998614f26e4eb6805b1167e05ce5311b6e" translate="yes" xml:space="preserve">
          <source>Will result in this error:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5924ea10aaabb62ee9bc1364ab2d6c8d39fa4316" translate="yes" xml:space="preserve">
          <source>With all the things set up, we can now write our tests like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f75c7b6834fbac10e18f4c82ab03776229eb74e2" translate="yes" xml:space="preserve">
          <source>With the &lt;a href=&quot;configuration#globalsetup-string&quot;&gt;Global Setup/Teardown&lt;/a&gt; and &lt;a href=&quot;configuration#testenvironment-string&quot;&gt;Async Test Environment&lt;/a&gt; APIs, Jest can work smoothly with &lt;a href=&quot;https://aws.amazon.com/dynamodb/&quot;&gt;DynamoDB&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09d67fc0b64d61790fbe51d618d9c01a71c9767f" translate="yes" xml:space="preserve">
          <source>With the &lt;a href=&quot;configuration#globalsetup-string&quot;&gt;Global Setup/Teardown&lt;/a&gt; and &lt;a href=&quot;configuration#testenvironment-string&quot;&gt;Async Test Environment&lt;/a&gt; APIs, Jest can work smoothly with &lt;a href=&quot;https://github.com/GoogleChrome/puppeteer&quot;&gt;puppeteer&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="efe0a1fdb2d38cad4bc73937febc9018ab5dfa08" translate="yes" xml:space="preserve">
          <source>With the &lt;a href=&quot;configuration#globalsetup-string&quot;&gt;Global Setup/Teardown&lt;/a&gt; and &lt;a href=&quot;configuration#testenvironment-string&quot;&gt;Async Test Environment&lt;/a&gt; APIs, Jest can work smoothly with &lt;a href=&quot;https://www.mongodb.com/&quot;&gt;MongoDB&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7a7d359c8bb23694d685fdf6e2b5cde46a49ff3" translate="yes" xml:space="preserve">
          <source>Write test results to a file when the &lt;code&gt;--json&lt;/code&gt; option is also specified. The returned JSON structure is documented in &lt;a href=&quot;configuration#testresultsprocessor-string&quot;&gt;testResultsProcessor&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="391b1a9608423cb9c4d16a7886b9e07fab1acb00" translate="yes" xml:space="preserve">
          <source>Write tests</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="694bf05e5891dd2e709b08f7b1d50372246946ee" translate="yes" xml:space="preserve">
          <source>Write your test</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94ba98a24cca1fad5979f2e2b8b87aa24d441f8b" translate="yes" xml:space="preserve">
          <source>Writing tests using the &lt;code&gt;async&lt;/code&gt;/&lt;code&gt;await&lt;/code&gt; syntax is also possible. Here is how you'd write the same examples from before:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13442293f45d32c9c4218756254e61b25c456f59" translate="yes" xml:space="preserve">
          <source>Yes, all snapshot files should be committed alongside the modules they are covering and their tests. They should be considered part of a test, similar to the value of any other assertion in Jest. In fact, snapshots represent the state of the source modules at any given point in time. In this way, when the source modules are modified, Jest can tell what changed from the previous version. It can also provide a lot of additional context during code review in which reviewers can study your changes better.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5059d1df734052fa39f05d1a230ebef9c450fdf6" translate="yes" xml:space="preserve">
          <source>Yes, as well as with any other test.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="933a2cbd693a2fc8e1c7cc9d0a79a6433195d072" translate="yes" xml:space="preserve">
          <source>You avoid limits to configuration that might cause you to eject from &lt;a href=&quot;https://github.com/facebookincubator/create-react-app&quot;&gt;create-react-app&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="406cbbf63f4fe22d5b8ccaa5240411c1502ac6c2" translate="yes" xml:space="preserve">
          <source>You can also hook up puppeteer from scratch. The basic idea is to:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="35aff70317c576091536adc5e1a43d87f6a53f1b" translate="yes" xml:space="preserve">
          <source>You can also nest &lt;code&gt;describe&lt;/code&gt; blocks if you have a hierarchy of tests:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ecbf1217eb1b7413e5ac5532b9f18df62cd10cea" translate="yes" xml:space="preserve">
          <source>You can also pass an array of objects, in which case the method will return true only if each object in the received array matches (in the &lt;code&gt;toMatchObject&lt;/code&gt; sense described above) the corresponding object in the expected array. This is useful if you want to check that two arrays match in their number of elements, as opposed to &lt;code&gt;arrayContaining&lt;/code&gt;, which allows for extra elements in the received array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33e631cdb46e5194143ae6343251d5d4abeebe0e" translate="yes" xml:space="preserve">
          <source>You can also test for the opposite of a matcher:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="766ae758010f2b190e41fbbc693bc28b84e8247c" translate="yes" xml:space="preserve">
          <source>You can also use the &lt;code&gt;.resolves&lt;/code&gt; matcher in your expect statement, and Jest will wait for that promise to resolve. If the promise is rejected, the test will automatically fail.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c23acb6b8a75eb059d0bf1a92f11f8a674f5b5ac" translate="yes" xml:space="preserve">
          <source>You can call &lt;code&gt;expect.addSnapshotSerializer&lt;/code&gt; to add a module that formats application-specific data structures.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0148d2ae9957ac3475428862737e46004f4bc04" translate="yes" xml:space="preserve">
          <source>You can check if an array or iterable contains a particular item using &lt;code&gt;toContain&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d51d93712488643fb65c1c14ffe4c74aaa71d14" translate="yes" xml:space="preserve">
          <source>You can check strings against regular expressions with &lt;code&gt;toMatch&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e25edb586f40e9238795e2ba9b6c0d4c65291a8a" translate="yes" xml:space="preserve">
          <source>You can cherry pick specific features of Jest and use them as standalone packages. Here's a list of the available packages:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42fd15afca8b3c0e27f3602b1bb8b499e91c1c6b" translate="yes" xml:space="preserve">
          <source>You can collect coverage from those files with setting &lt;code&gt;forceCoverageMatch&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0087ca484c125dc235349950ec51d13f3336f610" translate="yes" xml:space="preserve">
          <source>You can combine &lt;code&gt;async&lt;/code&gt; and &lt;code&gt;await&lt;/code&gt; with &lt;code&gt;.resolves&lt;/code&gt; or &lt;code&gt;.rejects&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d20f2b42e97c65aaef925a2c6a3961d0c033857b" translate="yes" xml:space="preserve">
          <source>You can create your own module that will be used for setting up the test environment. The module must export a class with &lt;code&gt;setup&lt;/code&gt;, &lt;code&gt;teardown&lt;/code&gt; and &lt;code&gt;runScript&lt;/code&gt; methods. You can also pass variables from this module to your test suites by assigning them to &lt;code&gt;this.global&lt;/code&gt; object &amp;ndash; this will make them available in your test suites as global variables.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ef2f94dd57c5898c7b5cdef5978ab020627b6d9" translate="yes" xml:space="preserve">
          <source>You can match properties against values or against matchers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8d7a47b61e8074001017d01760195a44daa7d92" translate="yes" xml:space="preserve">
          <source>You can optionally provide a name for your mock functions, which will be displayed instead of &quot;jest.fn()&quot; in test error output. Use this if you want to be able to quickly identify the mock function reporting an error in your test output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="141547ac2059520c584383a103038c5f0023150f" translate="yes" xml:space="preserve">
          <source>You can pass configuration to a transformer like &lt;code&gt;{filePattern: ['path-to-transformer', {options}]}&lt;/code&gt; For example, to configure babel-jest for non-default behavior, &lt;code&gt;{&quot;\\.js$&quot;: ['babel-jest', {rootMode: &quot;upward&quot;}]}&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="800cb883045942cfd5bb4081f8af395b4c78910d" translate="yes" xml:space="preserve">
          <source>You can provide an optional &lt;code&gt;hint&lt;/code&gt; string argument that is appended to the test name. Although Jest always appends a number at the end of a snapshot name, short descriptive hints might be more useful than numbers to differentiate &lt;strong&gt;multiple&lt;/strong&gt; snapshots in a &lt;strong&gt;single&lt;/strong&gt;&lt;code&gt;it&lt;/code&gt; or &lt;code&gt;test&lt;/code&gt; block. Jest sorts snapshots by name in the corresponding &lt;code&gt;.snap&lt;/code&gt; file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4cc4d175319a45a401106b9809e576146487b0b9" translate="yes" xml:space="preserve">
          <source>You can provide an optional &lt;code&gt;propertyMatchers&lt;/code&gt; object argument, which has asymmetric matchers as values of a subset of expected properties, &lt;strong&gt;if&lt;/strong&gt; the received value will be an &lt;strong&gt;object&lt;/strong&gt; instance. It is like &lt;code&gt;toMatchObject&lt;/code&gt; with flexible criteria for a subset of properties, followed by a snapshot test as exact criteria for the rest of the properties.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="342a9b14684325992d5ff139401436ae7682dd1a" translate="yes" xml:space="preserve">
          <source>You can provide an optional &lt;code&gt;value&lt;/code&gt; argument to compare the received property value (recursively for all properties of object instances, also known as deep equality, like the &lt;code&gt;toEqual&lt;/code&gt; matcher).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ecc5cea913bac7656555fb5571fc70b6c18f354b" translate="yes" xml:space="preserve">
          <source>You can provide an optional argument to test that a specific error is thrown:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0387678f500b8dabacd6ece5ed81ebc2dad87e6" translate="yes" xml:space="preserve">
          <source>You can read more about &lt;code&gt;jest-changed-files&lt;/code&gt; in the &lt;a href=&quot;https://github.com/facebook/jest/blob/master/packages/jest-changed-files/README.md&quot;&gt;readme file&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a117882f05bee0eb2692567e191ce66d663578e1" translate="yes" xml:space="preserve">
          <source>You can read more about &lt;code&gt;jest-docblock&lt;/code&gt; in the &lt;a href=&quot;https://github.com/facebook/jest/blob/master/packages/jest-docblock/README.md&quot;&gt;readme file&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46c165debafb7322f712fc6e454196637356e378" translate="yes" xml:space="preserve">
          <source>You can read more about &lt;code&gt;jest-validate&lt;/code&gt; in the &lt;a href=&quot;https://github.com/facebook/jest/blob/master/packages/jest-validate/README.md&quot;&gt;readme file&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2867c6d937c4005f8963139f59e55ad836a6852b" translate="yes" xml:space="preserve">
          <source>You can read more about &lt;code&gt;jest-worker&lt;/code&gt; in the &lt;a href=&quot;https://github.com/facebook/jest/blob/master/packages/jest-worker/README.md&quot;&gt;readme file&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d429e36c0ed20b800a39f032d046273b4cea53be" translate="yes" xml:space="preserve">
          <source>You can read more about &lt;code&gt;pretty-format&lt;/code&gt; in the &lt;a href=&quot;https://github.com/facebook/jest/blob/master/packages/pretty-format/README.md&quot;&gt;readme file&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f91698c99b451b48fdef94d8133ba660ee4beb14" translate="yes" xml:space="preserve">
          <source>You can replace all of the above mocks in order to change the implementation, for a single test or all tests, by calling &lt;code&gt;mockImplementation()&lt;/code&gt; on the existing mock.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="563bf00a2d98bb36c45fffa7a2f6aab090a1748e" translate="yes" xml:space="preserve">
          <source>You can retrieve Jest's default options to expand them if needed:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31bd27fefd08851ca3968f0ceda8045022a66264" translate="yes" xml:space="preserve">
          <source>You can run Jest directly from the CLI (if it's globally available in your &lt;code&gt;PATH&lt;/code&gt;, e.g. by &lt;code&gt;yarn global add jest&lt;/code&gt; or &lt;code&gt;npm install jest --global&lt;/code&gt;) with a variety of useful options.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f225c905306c2c0014f6ff2fdd68b6007152b521" translate="yes" xml:space="preserve">
          <source>You can try out this functionality by cloning the &lt;a href=&quot;https://github.com/facebook/jest/tree/master/examples/snapshot&quot;&gt;snapshot example&lt;/a&gt;, modifying the &lt;code&gt;Link&lt;/code&gt; component, and running Jest.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5ed2e627ad2f097c8fe5c0666910c34f57925f1" translate="yes" xml:space="preserve">
          <source>You can use &lt;code&gt;describe.only&lt;/code&gt; if you want to run only one describe block:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="221b7b5d130528a59256d65bc2c5c5ab8c11adbb" translate="yes" xml:space="preserve">
          <source>You can use &lt;code&gt;describe.skip&lt;/code&gt; if you do not want to run a particular describe block:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29de8e17dc9a604ab72ee70bda29920afbd2d460" translate="yes" xml:space="preserve">
          <source>You can use &lt;code&gt;expect.extend&lt;/code&gt; to add your own matchers to Jest. For example, let's say that you're testing a number utility library and you're frequently asserting that numbers appear within particular ranges of other numbers. You could abstract that into a &lt;code&gt;toBeWithinRange&lt;/code&gt; matcher:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="414d019cf0872729a505b6b1f50111cb1ce5b29d" translate="yes" xml:space="preserve">
          <source>You can use an &lt;a href=&quot;https://github.com/keyanzhang/identity-obj-proxy&quot;&gt;ES6 Proxy&lt;/a&gt; to mock &lt;a href=&quot;https://github.com/css-modules/css-modules&quot;&gt;CSS Modules&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0ca37e74baa1f002bba25e20997f296e5781557" translate="yes" xml:space="preserve">
          <source>You can use it instead of a literal value:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c085c131693a018bbc7ee86b6ff86c3192e859b0" translate="yes" xml:space="preserve">
          <source>You could comment the test out, but it's often a bit nicer to use &lt;code&gt;test.skip&lt;/code&gt; because it will maintain indentation and syntax highlighting.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5359ed25529846e45ba23e420d5b9e5c6713de18" translate="yes" xml:space="preserve">
          <source>You could write &lt;code&gt;expect(bestDrinkForFlavor('octopus')).toBe(undefined)&lt;/code&gt;, but it's better practice to avoid referring to &lt;code&gt;undefined&lt;/code&gt; directly in your code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ba59aa451c75435f919998f9ebfc1c5a8dd95b2" translate="yes" xml:space="preserve">
          <source>You could write &lt;code&gt;expect(fetchNewFlavorIdea()).not.toBe(undefined)&lt;/code&gt;, but it's better practice to avoid referring to &lt;code&gt;undefined&lt;/code&gt; directly in your code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88ed689c2ae9512a449e124212b726dc5d4e0c96" translate="yes" xml:space="preserve">
          <source>You have to run &lt;code&gt;yarn add --dev @testing-library/react&lt;/code&gt; to use react-testing-library.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2580df5ede4388981be8693d0eb04cda44e78ad" translate="yes" xml:space="preserve">
          <source>You have to run &lt;code&gt;yarn add --dev enzyme&lt;/code&gt; to use Enzyme. If you are using a React version below 15.5.0, you will also need to install &lt;code&gt;react-addons-test-utils&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ab8163799282eb2cd2bcd483eb50ba23a2e1feb" translate="yes" xml:space="preserve">
          <source>You make the dependency explicit instead of implicit.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c38db17ba138256cbd5a96be8f1e6dc538f5fa8" translate="yes" xml:space="preserve">
          <source>You may not care what &lt;code&gt;getErrors&lt;/code&gt; returns, specifically - it might return &lt;code&gt;false&lt;/code&gt;, &lt;code&gt;null&lt;/code&gt;, or &lt;code&gt;0&lt;/code&gt;, and your code would still work. So if you want to test there are no errors after drinking some La Croix, you could write:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c89edf49de3c63952efdcc592f2e40d0e91b763b" translate="yes" xml:space="preserve">
          <source>You may not care what &lt;code&gt;thirstInfo&lt;/code&gt; returns, specifically - it might return &lt;code&gt;true&lt;/code&gt; or a complex object, and your code would still work. So if you want to test that &lt;code&gt;thirstInfo&lt;/code&gt; will be truthy after drinking some La Croix, you could write:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17b4764286d414a473eaaf4d566a76ce25182294" translate="yes" xml:space="preserve">
          <source>You should use the matcher that most precisely corresponds to what you want your code to be doing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f37219870fbd51ab28f12639a113236e2ba5334" translate="yes" xml:space="preserve">
          <source>You will find a number of example test cases in the &lt;a href=&quot;https://github.com/facebook/jest/tree/master/examples&quot;&gt;&lt;code&gt;examples&lt;/code&gt;&lt;/a&gt; folder on GitHub. You can also learn from the excellent tests used by the &lt;a href=&quot;https://github.com/facebook/react/tree/master/packages/react/src/__tests__&quot;&gt;React&lt;/a&gt;, &lt;a href=&quot;https://github.com/facebook/relay/tree/master/packages/react-relay/__tests__&quot;&gt;Relay&lt;/a&gt;, and &lt;a href=&quot;https://github.com/facebook/react-native/tree/master/Libraries/Animated/src/__tests__&quot;&gt;React Native&lt;/a&gt; projects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7eb67e376c7a0795313a9464135b5632741a836" translate="yes" xml:space="preserve">
          <source>Your &lt;code&gt;package.json&lt;/code&gt; should look something like this (where &lt;code&gt;&amp;lt;current-version&amp;gt;&lt;/code&gt; is the actual latest version number for the package). Please add the scripts and jest configuration entries:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec89bd1c5f68c024aeca6e9e14636486318a74fe" translate="yes" xml:space="preserve">
          <source>Your test will want to mock the &lt;code&gt;fetch&lt;/code&gt; function so that we can be sure that it gets called without actually making the network request. However, you'll also need to mock the return value of &lt;code&gt;fetch&lt;/code&gt; with a &lt;code&gt;Response&lt;/code&gt; (wrapped in a &lt;code&gt;Promise&lt;/code&gt;), as our function uses it to grab the created user's ID. So you might initially try writing a test like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1175cedc7032117d3657edf28dbe7bb9385d7c5c" translate="yes" xml:space="preserve">
          <source>Your tests should be deterministic. Running the same tests multiple times on a component that has not changed should produce the same results every time. You're responsible for making sure your generated snapshots do not include platform specific or other non-deterministic data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f17fc980285f8ffe0be9e33ef7152af13254fe8" translate="yes" xml:space="preserve">
          <source>afterAll()</source>
          <target state="translated">afterAll()</target>
        </trans-unit>
        <trans-unit id="fb268a1811f730c2067165b083e360322d72f477" translate="yes" xml:space="preserve">
          <source>afterEach()</source>
          <target state="translated">afterEach()</target>
        </trans-unit>
        <trans-unit id="9ad6d2fa2c7de85e6b6dd37cd6a886c8f07ad319" translate="yes" xml:space="preserve">
          <source>async-to-gen</source>
          <target state="translated">async-to-gen</target>
        </trans-unit>
        <trans-unit id="bd90b357192cd27b16a70b7698bb14ee20cba402" translate="yes" xml:space="preserve">
          <source>awesome-jest</source>
          <target state="translated">awesome-jest</target>
        </trans-unit>
        <trans-unit id="d09b0fbfb51ee1470bcc585dd8ce8dfa55e488df" translate="yes" xml:space="preserve">
          <source>beforeAll()</source>
          <target state="translated">beforeAll()</target>
        </trans-unit>
        <trans-unit id="c70978f19975e8b38cf044b33e31fad2d272183a" translate="yes" xml:space="preserve">
          <source>beforeEach()</source>
          <target state="translated">beforeEach()</target>
        </trans-unit>
        <trans-unit id="740e438d6d95b968c3b9aaa798d54c124e64790b" translate="yes" xml:space="preserve">
          <source>close puppeteer with Global Teardown</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53cdcf56a867665dc933b593cb499286aadcbc80" translate="yes" xml:space="preserve">
          <source>connect to puppeteer from each Test Environment</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25509aa65c3b573b5425ab6624df82134524f006" translate="yes" xml:space="preserve">
          <source>default: &lt;code&gt;undefined&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8244e80092f3c12d77f6dd509da0f653409320b" translate="yes" xml:space="preserve">
          <source>describe()</source>
          <target state="translated">describe()</target>
        </trans-unit>
        <trans-unit id="398a5e26f7d6ff23078ffbb871957ca77291b3e7" translate="yes" xml:space="preserve">
          <source>describe.each()</source>
          <target state="translated">describe.each()</target>
        </trans-unit>
        <trans-unit id="4f24a48da5c59a6bd3845bdb54350e1d1d0ee38d" translate="yes" xml:space="preserve">
          <source>describe.only()</source>
          <target state="translated">describe.only()</target>
        </trans-unit>
        <trans-unit id="f11fce8c9ed55e7be7b2cbcc6e46f524b949f14e" translate="yes" xml:space="preserve">
          <source>describe.only.each()</source>
          <target state="translated">describe.only.each()</target>
        </trans-unit>
        <trans-unit id="c3382b09895d6af2c9e821d96ad003e58d4b96de" translate="yes" xml:space="preserve">
          <source>describe.skip()</source>
          <target state="translated">describe.skip()</target>
        </trans-unit>
        <trans-unit id="2c446c6cd1bf47770ef8c7d1bd166c465eedf771" translate="yes" xml:space="preserve">
          <source>describe.skip.each()</source>
          <target state="translated">describe.skip.each()</target>
        </trans-unit>
        <trans-unit id="fcf239e7993ef571d39b364c0de3fda8a3ae0c81" translate="yes" xml:space="preserve">
          <source>error class: error object is &lt;strong&gt;instance of&lt;/strong&gt; class</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7851c6709a8adac9e962eee4f13a4ff8d35c84c6" translate="yes" xml:space="preserve">
          <source>error object: error message is &lt;strong&gt;equal to&lt;/strong&gt; the message property of the object</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a00f641af4b4bd382b037a5599ec8c6bd2a58a7a" translate="yes" xml:space="preserve">
          <source>eslint-plugin-jest</source>
          <target state="translated">eslint-plugin-jest</target>
        </trans-unit>
        <trans-unit id="3aede15b1d5d318f2bf628e79d06cd5ec821f235" translate="yes" xml:space="preserve">
          <source>expect()</source>
          <target state="translated">expect()</target>
        </trans-unit>
        <trans-unit id="c531f8f49210f5c5cc7e56c0bcf8809390d60182" translate="yes" xml:space="preserve">
          <source>expect.addSnapshotSerializer()</source>
          <target state="translated">expect.addSnapshotSerializer()</target>
        </trans-unit>
        <trans-unit id="73052babf147d5ab7087790cf489001a5fe6adef" translate="yes" xml:space="preserve">
          <source>expect.any()</source>
          <target state="translated">expect.any()</target>
        </trans-unit>
        <trans-unit id="041f3593b4cfc38ec52995cb888e8d017339e912" translate="yes" xml:space="preserve">
          <source>expect.anything()</source>
          <target state="translated">expect.anything()</target>
        </trans-unit>
        <trans-unit id="b1648f49219a878c2221460718595da8c398b8b3" translate="yes" xml:space="preserve">
          <source>expect.arrayContaining()</source>
          <target state="translated">expect.arrayContaining()</target>
        </trans-unit>
        <trans-unit id="07105ad3d99570c6ffdfd4ccea4770093ccd6589" translate="yes" xml:space="preserve">
          <source>expect.assertions()</source>
          <target state="translated">expect.assertions()</target>
        </trans-unit>
        <trans-unit id="cf206af29db6d448d19d0b2896ed0f7be77ca4b2" translate="yes" xml:space="preserve">
          <source>expect.extend()</source>
          <target state="translated">expect.extend()</target>
        </trans-unit>
        <trans-unit id="bef0c4a5294c45e4f23630650c298423d2b0033a" translate="yes" xml:space="preserve">
          <source>expect.hasAssertions()</source>
          <target state="translated">expect.hasAssertions()</target>
        </trans-unit>
        <trans-unit id="a4b4f299cc5121ba5bb42d780d793dd0d208d5d1" translate="yes" xml:space="preserve">
          <source>expect.not.arrayContaining()</source>
          <target state="translated">expect.not.arrayContaining()</target>
        </trans-unit>
        <trans-unit id="cd369cc867e384fabaa81e31b91e2ec5e06cb648" translate="yes" xml:space="preserve">
          <source>expect.not.objectContaining()</source>
          <target state="translated">expect.not.objectContaining()</target>
        </trans-unit>
        <trans-unit id="c3e51c2efa41f651e0f4da6911e099a7e6ae1ca4" translate="yes" xml:space="preserve">
          <source>expect.not.stringContaining()</source>
          <target state="translated">expect.not.stringContaining()</target>
        </trans-unit>
        <trans-unit id="1146b5bca92b76c491171096be15657da9f28d46" translate="yes" xml:space="preserve">
          <source>expect.not.stringMatching()</source>
          <target state="translated">expect.not.stringMatching()</target>
        </trans-unit>
        <trans-unit id="a323da51fabb3d791f0b36ac04909baab7f19868" translate="yes" xml:space="preserve">
          <source>expect.objectContaining()</source>
          <target state="translated">expect.objectContaining()</target>
        </trans-unit>
        <trans-unit id="05a9b81e11194231b386c00515a14089ffa1ab48" translate="yes" xml:space="preserve">
          <source>expect.stringContaining()</source>
          <target state="translated">expect.stringContaining()</target>
        </trans-unit>
        <trans-unit id="64a818d5f4128d542c68ad3e5b52cf9cb07239c5" translate="yes" xml:space="preserve">
          <source>expect.stringMatching()</source>
          <target state="translated">expect.stringMatching()</target>
        </trans-unit>
        <trans-unit id="5b53271817c17d31475c2601f79c760d8c18c932" translate="yes" xml:space="preserve">
          <source>in &lt;code&gt;toEqual&lt;/code&gt; or &lt;code&gt;toBeCalledWith&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14fdeea7a02add9f25f4b254a8109cebfb41a968" translate="yes" xml:space="preserve">
          <source>jest</source>
          <target state="translated">jest</target>
        </trans-unit>
        <trans-unit id="399f3e6c7d355276f40f586cacf83580961e34e9" translate="yes" xml:space="preserve">
          <source>jest --bail</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7728f73469dcbf23ae8e337f07d557f5387051c2" translate="yes" xml:space="preserve">
          <source>jest --cache</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4aa246751c414496487d54530974546f8e2e1a7" translate="yes" xml:space="preserve">
          <source>jest --changedFilesWithAncestor</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4435b17b912dad78333d9c715e558d3c202ab34" translate="yes" xml:space="preserve">
          <source>jest --changedSince</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5261799c92dd14f3365e36279542409dc1f4470" translate="yes" xml:space="preserve">
          <source>jest --ci</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18b3b63f5ed9f4cb059fbdfa287a7092d2bd46c8" translate="yes" xml:space="preserve">
          <source>jest --clearCache</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b45786c23204e16069d34c716fc3df38b6aa6b3" translate="yes" xml:space="preserve">
          <source>jest --collectCoverageFrom</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16739578c7f61b7a8f8542434d00d6ab09963e57" translate="yes" xml:space="preserve">
          <source>jest --colors</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16996765a63984335bd12471e86885562b954705" translate="yes" xml:space="preserve">
          <source>jest --config</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ecd47d28d6d16f7e198f7bb676071b8de7aa625f" translate="yes" xml:space="preserve">
          <source>jest --coverage</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="200e04fecf37753c77869affc65b05074a843073" translate="yes" xml:space="preserve">
          <source>jest --debug</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0896a807b1438960db7baa7a96cc00d29eb6fbf" translate="yes" xml:space="preserve">
          <source>jest --detectOpenHandles</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1edb0e7b6eaef88efb6ed9a604136e0b2dc3df91" translate="yes" xml:space="preserve">
          <source>jest --env</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a0f943b937dcd72c06bfe59afe73fb4a1f31d48" translate="yes" xml:space="preserve">
          <source>jest --errorOnDeprecated</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="451e3f27037c6eaedc5c0ee1528d6ecd3860ad73" translate="yes" xml:space="preserve">
          <source>jest --expand</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75a8e4a783be5089515d60538e7e8125cdd33fe3" translate="yes" xml:space="preserve">
          <source>jest --findRelatedTests</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4959c728768cddd33ed24149b8756c30f1461b6c" translate="yes" xml:space="preserve">
          <source>jest --forceExit</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7042ae5c15d17e9dfb626d3b992b070a2b33ac3" translate="yes" xml:space="preserve">
          <source>jest --help</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b44f9af93a63dbc353bdbb59b8977473460ea15" translate="yes" xml:space="preserve">
          <source>jest --init</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b472735c07ba84430b5dcc73a9578211df4a2c7a" translate="yes" xml:space="preserve">
          <source>jest --json</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67842930eb4c451f524a5334d5d9987f944c0b62" translate="yes" xml:space="preserve">
          <source>jest --lastCommit</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ef4898fedf76393b34edae0c0c9eb5f9becbdb5" translate="yes" xml:space="preserve">
          <source>jest --listTests</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68a8e8c37228016d5b69d8f98bc9033444f6dcfc" translate="yes" xml:space="preserve">
          <source>jest --logHeapUsage</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34e1461f0465c9780fed87f508481d93f147883c" translate="yes" xml:space="preserve">
          <source>jest --maxConcurrency</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff2ced6c82113057178b44c26a4df8d1cfcde5ad" translate="yes" xml:space="preserve">
          <source>jest --maxWorkers</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c8c93cffedf5f51fbf6769d1b9f4b08296e0a72" translate="yes" xml:space="preserve">
          <source>jest --noStackTrace</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07fe4de480c74eb982dfd2fc1ffabbc5e8000f9a" translate="yes" xml:space="preserve">
          <source>jest --notify</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="777939208a77b6ed85265bb3541e0aaf5212fbb3" translate="yes" xml:space="preserve">
          <source>jest --onlyChanged</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39d9ffe9fc23f87610839ef7d3409e4bdcaeb08c" translate="yes" xml:space="preserve">
          <source>jest --outputFile</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="709a7d88446a6c333c370abdc7cbc81e5007aeb4" translate="yes" xml:space="preserve">
          <source>jest --passWithNoTests</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c01b9e323723244523c23d1edd20bbd8fa1fad8b" translate="yes" xml:space="preserve">
          <source>jest --projects</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28ccc63c68da10265b442f6ddb719c32cb336d21" translate="yes" xml:space="preserve">
          <source>jest --reporters</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64629dd6eadf22a13bedf72b140ffb326b3adf10" translate="yes" xml:space="preserve">
          <source>jest --runInBand</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d7004d9e45fbe7afc81b68d019a0999a9bc0c7c" translate="yes" xml:space="preserve">
          <source>jest --runTestsByPath</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="096d835c379fd03e494f9bdb3bd4cbf0d83b2f71" translate="yes" xml:space="preserve">
          <source>jest --setupTestFrameworkScriptFile</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="940e5b5b259afe41c7f972448e3b14ae829486ab" translate="yes" xml:space="preserve">
          <source>jest --showConfig</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a19e9fb882999e3c40b7635bba97bd9c793f3561" translate="yes" xml:space="preserve">
          <source>jest --silent</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3116d8e92505df6e40aa26ca10c8d3a5aefaf6af" translate="yes" xml:space="preserve">
          <source>jest --testLocationInResults</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a07b564f31bb6e6c96720d77231a8a1e45f39e3" translate="yes" xml:space="preserve">
          <source>jest --testNamePattern</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4de2b306577ed62d6f8717e3427fffb985e1b43b" translate="yes" xml:space="preserve">
          <source>jest --testPathIgnorePatterns</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6d599e9db1d5b8b8b9b1e34af131cc7a609574c" translate="yes" xml:space="preserve">
          <source>jest --testPathPattern</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1e05395a90bfd20cc69363133868bb63d439c51" translate="yes" xml:space="preserve">
          <source>jest --testRunner</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a107d7a62c0faae9d219c603e662cbdfb1168139" translate="yes" xml:space="preserve">
          <source>jest --testSequencer</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7ef133f2b7dc919c3ad71da9cce4c6ffd6cd868" translate="yes" xml:space="preserve">
          <source>jest --testTimeout</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="855f8a66c2044d0c0aa8ce263401b44fa1019b06" translate="yes" xml:space="preserve">
          <source>jest --updateSnapshot</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ea12447858a50cdd5c983e5da4ab87dbdf7bf88" translate="yes" xml:space="preserve">
          <source>jest --useStderr</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f073ca0513417405f3d24492d3c2e48be87f71de" translate="yes" xml:space="preserve">
          <source>jest --verbose</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8144cdc86e9d7837063cedb0371d26f3eec4e393" translate="yes" xml:space="preserve">
          <source>jest --version</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24a92c60d5aa0d0bc0a04e89176cbe3de81ca593" translate="yes" xml:space="preserve">
          <source>jest --watch</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a0c8c57a84aa98a2040ae7e753c42a9d15607d0" translate="yes" xml:space="preserve">
          <source>jest --watchAll</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8357ee4077e5c430d196688e7e00e4f2b5298f39" translate="yes" xml:space="preserve">
          <source>jest --watchman</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8dac8b8cbde7c22969d69a11d630521076ff0471" translate="yes" xml:space="preserve">
          <source>jest-changed-files</source>
          <target state="translated">jest-changed-files</target>
        </trans-unit>
        <trans-unit id="b54512fd3b9795a4772b2657ce0156724195ce07" translate="yes" xml:space="preserve">
          <source>jest-codemods</source>
          <target state="translated">jest-codemods</target>
        </trans-unit>
        <trans-unit id="4d0ba9791c912565a89e87ec93cd71cdc4b75579" translate="yes" xml:space="preserve">
          <source>jest-diff</source>
          <target state="translated">jest-diff</target>
        </trans-unit>
        <trans-unit id="fae57be3b9d4c6db0129364d146af1ae34bc4571" translate="yes" xml:space="preserve">
          <source>jest-docblock</source>
          <target state="translated">jest-docblock</target>
        </trans-unit>
        <trans-unit id="33815f7eafadf66bdf82b692a5d7500e04bdcf17" translate="yes" xml:space="preserve">
          <source>jest-extended</source>
          <target state="translated">jest-extended</target>
        </trans-unit>
        <trans-unit id="7a5cb26800c7666578e96bedb106ca6c76db8288" translate="yes" xml:space="preserve">
          <source>jest-get-type</source>
          <target state="translated">jest-get-type</target>
        </trans-unit>
        <trans-unit id="9930457414d8318490b519406b0d01e0c0af9388" translate="yes" xml:space="preserve">
          <source>jest-validate</source>
          <target state="translated">jest-validate</target>
        </trans-unit>
        <trans-unit id="74459ea621c5c89c1a6a8777f420f08a699ce618" translate="yes" xml:space="preserve">
          <source>jest-worker</source>
          <target state="translated">jest-worker</target>
        </trans-unit>
        <trans-unit id="b5268823984999cb437a77b35d87876782899202" translate="yes" xml:space="preserve">
          <source>jest.advanceTimersByTime()</source>
          <target state="translated">jest.advanceTimersByTime()</target>
        </trans-unit>
        <trans-unit id="4f84712675c1d51a3df5e0c8bc41ac8a5291b5b5" translate="yes" xml:space="preserve">
          <source>jest.advanceTimersToNextTimer()</source>
          <target state="translated">jest.advanceTimersToNextTimer()</target>
        </trans-unit>
        <trans-unit id="926befda6fecbd4a52674619f3af9b0e7f68fc1e" translate="yes" xml:space="preserve">
          <source>jest.clearAllMocks()</source>
          <target state="translated">jest.clearAllMocks()</target>
        </trans-unit>
        <trans-unit id="4222fbb57b1accc14807b98d10122439d4ff5022" translate="yes" xml:space="preserve">
          <source>jest.clearAllTimers()</source>
          <target state="translated">jest.clearAllTimers()</target>
        </trans-unit>
        <trans-unit id="c805b56432a104b93bac2f37dc3d95d0ee13d1ef" translate="yes" xml:space="preserve">
          <source>jest.disableAutomock()</source>
          <target state="translated">jest.disableAutomock()</target>
        </trans-unit>
        <trans-unit id="37431f3778ecbfb714d3adbd0be802b5c721c30f" translate="yes" xml:space="preserve">
          <source>jest.doMock()</source>
          <target state="translated">jest.doMock()</target>
        </trans-unit>
        <trans-unit id="e1eb654d0e6f9a86254eb54aacafc37839145bc6" translate="yes" xml:space="preserve">
          <source>jest.dontMock()</source>
          <target state="translated">jest.dontMock()</target>
        </trans-unit>
        <trans-unit id="96a8a03defe83d958b13a8db1048b48645fd3459" translate="yes" xml:space="preserve">
          <source>jest.enableAutomock()</source>
          <target state="translated">jest.enableAutomock()</target>
        </trans-unit>
        <trans-unit id="63706588ece2fbb5ee1cbc26ed3cd9b3394a2aa3" translate="yes" xml:space="preserve">
          <source>jest.fn()</source>
          <target state="translated">jest.fn()</target>
        </trans-unit>
        <trans-unit id="5219ae476b088f3b68bcaf6bf0a3ebfe1cd29904" translate="yes" xml:space="preserve">
          <source>jest.genMockFromModule()</source>
          <target state="translated">jest.genMockFromModule()</target>
        </trans-unit>
        <trans-unit id="def17227de8f296f563b72986222dc177bb11d6d" translate="yes" xml:space="preserve">
          <source>jest.getTimerCount()</source>
          <target state="translated">jest.getTimerCount()</target>
        </trans-unit>
        <trans-unit id="124a77d3e596a96e5e22131aaf874ab0b85168bc" translate="yes" xml:space="preserve">
          <source>jest.isMockFunction()</source>
          <target state="translated">jest.isMockFunction()</target>
        </trans-unit>
        <trans-unit id="f59381d1be107811c5f127861c8b25779aac8d08" translate="yes" xml:space="preserve">
          <source>jest.isolateModules()</source>
          <target state="translated">jest.isolateModules()</target>
        </trans-unit>
        <trans-unit id="7fa6adb6c9fe552d5205372a422e3d7869a09385" translate="yes" xml:space="preserve">
          <source>jest.mock()</source>
          <target state="translated">jest.mock()</target>
        </trans-unit>
        <trans-unit id="ea788268b388e4e34786b83b59c434649a2880ba" translate="yes" xml:space="preserve">
          <source>jest.requireActual()</source>
          <target state="translated">jest.requireActual()</target>
        </trans-unit>
        <trans-unit id="eb1640f83eb73de04420583fd51286a6f8f26358" translate="yes" xml:space="preserve">
          <source>jest.requireMock()</source>
          <target state="translated">jest.requireMock()</target>
        </trans-unit>
        <trans-unit id="d6eb5ae9749a1f0bfe615e87dae5660439f11371" translate="yes" xml:space="preserve">
          <source>jest.resetAllMocks()</source>
          <target state="translated">jest.resetAllMocks()</target>
        </trans-unit>
        <trans-unit id="f5adc7f97ed3055597a83e098ddd8044c1732177" translate="yes" xml:space="preserve">
          <source>jest.resetModules()</source>
          <target state="translated">jest.resetModules()</target>
        </trans-unit>
        <trans-unit id="3fafd64547192fe4a73efe5ad2a0deadac3f3422" translate="yes" xml:space="preserve">
          <source>jest.restoreAllMocks()</source>
          <target state="translated">jest.restoreAllMocks()</target>
        </trans-unit>
        <trans-unit id="a948703e7207e3be8661bf6365a632c32226671e" translate="yes" xml:space="preserve">
          <source>jest.retryTimes()</source>
          <target state="translated">jest.retryTimes()</target>
        </trans-unit>
        <trans-unit id="b8ce73ec4b14b469bb28764f3a8c3d19e82ac7b6" translate="yes" xml:space="preserve">
          <source>jest.runAllImmediates()</source>
          <target state="translated">jest.runAllImmediates()</target>
        </trans-unit>
        <trans-unit id="53af7c8ab5fc7e913ecfb6a326b3610f64160176" translate="yes" xml:space="preserve">
          <source>jest.runAllTicks()</source>
          <target state="translated">jest.runAllTicks()</target>
        </trans-unit>
        <trans-unit id="bdd7917ff7ed9b0c8f251b4ed7bfa4aaf2b6152b" translate="yes" xml:space="preserve">
          <source>jest.runAllTimers()</source>
          <target state="translated">jest.runAllTimers()</target>
        </trans-unit>
        <trans-unit id="5f8881d3c2fa2e3c3978c63711cfc41587308941" translate="yes" xml:space="preserve">
          <source>jest.runOnlyPendingTimers()</source>
          <target state="translated">jest.runOnlyPendingTimers()</target>
        </trans-unit>
        <trans-unit id="115ea6be6949d8073195cf40a89a2c53d963f31a" translate="yes" xml:space="preserve">
          <source>jest.setMock()</source>
          <target state="translated">jest.setMock()</target>
        </trans-unit>
        <trans-unit id="e38a82fd2d18d144fa8049c3a4042f3947d71db8" translate="yes" xml:space="preserve">
          <source>jest.setTimeout()</source>
          <target state="translated">jest.setTimeout()</target>
        </trans-unit>
        <trans-unit id="4a21c582c06cb9f55c32d6a0da8083dbef2d04a4" translate="yes" xml:space="preserve">
          <source>jest.spyOn()</source>
          <target state="translated">jest.spyOn()</target>
        </trans-unit>
        <trans-unit id="e51942569d340db8459bde0b3a57da7a3ae5bd19" translate="yes" xml:space="preserve">
          <source>jest.unmock()</source>
          <target state="translated">jest.unmock()</target>
        </trans-unit>
        <trans-unit id="7bdcc5f2e0051948cd9175cbfd47b9f3a5c8a112" translate="yes" xml:space="preserve">
          <source>jest.useFakeTimers()</source>
          <target state="translated">jest.useFakeTimers()</target>
        </trans-unit>
        <trans-unit id="567a022c7ff0ed1eeecf66243bfb760f39f98839" translate="yes" xml:space="preserve">
          <source>jest.useRealTimers()</source>
          <target state="translated">jest.useRealTimers()</target>
        </trans-unit>
        <trans-unit id="d6c73ed242e8279bf8b5008c49164ea76ecca716" translate="yes" xml:space="preserve">
          <source>launch &amp;amp; file the websocket endpoint of puppeteer with Global Setup</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5534dc1bf91cfa3f571372cc1df1fde4778c65c" translate="yes" xml:space="preserve">
          <source>matching the files that coverage info needs to be collected from.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bdaf39bbe2e8ce24d626e5d939f2687b7925a111" translate="yes" xml:space="preserve">
          <source>mockFn.getMockName()</source>
          <target state="translated">mockFn.getMockName()</target>
        </trans-unit>
        <trans-unit id="76ba86f80a3975694b82876ec035c67727b880ce" translate="yes" xml:space="preserve">
          <source>mockFn.mock.calls</source>
          <target state="translated">mockFn.mock.calls</target>
        </trans-unit>
        <trans-unit id="b8f5e098751b2e1a0b0c994fa0e253d7b6667585" translate="yes" xml:space="preserve">
          <source>mockFn.mock.instances</source>
          <target state="translated">mockFn.mock.instances</target>
        </trans-unit>
        <trans-unit id="37a607803e67bc8f0e277c4bad07d899cb8e68ee" translate="yes" xml:space="preserve">
          <source>mockFn.mock.results</source>
          <target state="translated">mockFn.mock.results</target>
        </trans-unit>
        <trans-unit id="d7884cf2e18f52e2befafea1329cc93891d01d0e" translate="yes" xml:space="preserve">
          <source>mockFn.mockClear()</source>
          <target state="translated">mockFn.mockClear()</target>
        </trans-unit>
        <trans-unit id="b1a1dc73ee86a9db45f473726c03a5d44e7d6e00" translate="yes" xml:space="preserve">
          <source>mockFn.mockImplementation()</source>
          <target state="translated">mockFn.mockImplementation()</target>
        </trans-unit>
        <trans-unit id="705599d736e3f800c387b8732532a981208d86f3" translate="yes" xml:space="preserve">
          <source>mockFn.mockImplementationOnce()</source>
          <target state="translated">mockFn.mockImplementationOnce()</target>
        </trans-unit>
        <trans-unit id="b15f7560dc442cfe559991bd028b3593dbedcfa3" translate="yes" xml:space="preserve">
          <source>mockFn.mockName()</source>
          <target state="translated">mockFn.mockName()</target>
        </trans-unit>
        <trans-unit id="cbee5a4253c363dd81a99f99a7171fe30ca56500" translate="yes" xml:space="preserve">
          <source>mockFn.mockRejectedValue()</source>
          <target state="translated">mockFn.mockRejectedValue()</target>
        </trans-unit>
        <trans-unit id="f0f879d05ce665721a5b420f915a6b799a9261b3" translate="yes" xml:space="preserve">
          <source>mockFn.mockRejectedValueOnce()</source>
          <target state="translated">mockFn.mockRejectedValueOnce()</target>
        </trans-unit>
        <trans-unit id="6379aa11d6a3d7b94b0cabd0ea38f28a5ac0a66b" translate="yes" xml:space="preserve">
          <source>mockFn.mockReset()</source>
          <target state="translated">mockFn.mockReset()</target>
        </trans-unit>
        <trans-unit id="e5f5a2cc9780e616fb57bcbabbb5e1b492e59a7c" translate="yes" xml:space="preserve">
          <source>mockFn.mockResolvedValue()</source>
          <target state="translated">mockFn.mockResolvedValue()</target>
        </trans-unit>
        <trans-unit id="a610c3278d44712a00c28aba1ba0a5f4c56f4602" translate="yes" xml:space="preserve">
          <source>mockFn.mockResolvedValueOnce()</source>
          <target state="translated">mockFn.mockResolvedValueOnce()</target>
        </trans-unit>
        <trans-unit id="93b4b4162d3f8f9f6743942f1582c22d36cf0434" translate="yes" xml:space="preserve">
          <source>mockFn.mockRestore()</source>
          <target state="translated">mockFn.mockRestore()</target>
        </trans-unit>
        <trans-unit id="b89668bf6eee3709904c8e914501f15481a0ec32" translate="yes" xml:space="preserve">
          <source>mockFn.mockReturnThis()</source>
          <target state="translated">mockFn.mockReturnThis()</target>
        </trans-unit>
        <trans-unit id="8406d4374df6cedb0774c198a5e18305079be058" translate="yes" xml:space="preserve">
          <source>mockFn.mockReturnValue()</source>
          <target state="translated">mockFn.mockReturnValue()</target>
        </trans-unit>
        <trans-unit id="91d18268f60b6021a577b531532180c54eed125c" translate="yes" xml:space="preserve">
          <source>mockFn.mockReturnValueOnce()</source>
          <target state="translated">mockFn.mockReturnValueOnce()</target>
        </trans-unit>
        <trans-unit id="110fd2eef67d470b905e3f770bc78bf0e48c4532" translate="yes" xml:space="preserve">
          <source>moduleNameMapper</source>
          <target state="translated">moduleNameMapper</target>
        </trans-unit>
        <trans-unit id="1758356db21759f7c5a0da9b4dd1db8fd6feab3f" translate="yes" xml:space="preserve">
          <source>or</source>
          <target state="translated">or</target>
        </trans-unit>
        <trans-unit id="f398e82965b003d86545395906bc58c426a160f4" translate="yes" xml:space="preserve">
          <source>or the following for Windows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e4e9d9ce9649c8da277337be899d54f4b10f016" translate="yes" xml:space="preserve">
          <source>pretty-format</source>
          <target state="translated">pretty-format</target>
        </trans-unit>
        <trans-unit id="b41c94dc77a8359c700e959dbc3271747436b9b8" translate="yes" xml:space="preserve">
          <source>react-testing-library</source>
          <target state="translated">react-testing-library</target>
        </trans-unit>
        <trans-unit id="6096aad9326ad51aa7277852583cdbbd0063c505" translate="yes" xml:space="preserve">
          <source>regular expression: error message &lt;strong&gt;matches&lt;/strong&gt; the pattern</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="564cb4d408b58135c97baa36f450885bf9df5afd" translate="yes" xml:space="preserve">
          <source>renamed from &lt;code&gt;runTimersToTime&lt;/code&gt; to &lt;code&gt;advanceTimersByTime&lt;/code&gt; in Jest &lt;strong&gt;22.0.0&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b081d67ddd0df4286abac590611b195d5398dfcd" translate="yes" xml:space="preserve">
          <source>renamed in Jest &lt;strong&gt;22.0.0+&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa765d3c5cf61960d9c86c450acc1e2d6113a622" translate="yes" xml:space="preserve">
          <source>rewrite &lt;code&gt;expect(received).not.toBe(expected)&lt;/code&gt; as &lt;code&gt;expect(Object.is(received, expected)).toBe(false)&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12ee99b45418f1c182987feaff420ab1c0a53144" translate="yes" xml:space="preserve">
          <source>rewrite &lt;code&gt;expect(received).not.toEqual(expected)&lt;/code&gt; as &lt;code&gt;expect(received.equals(expected)).toBe(false)&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="648a633ae93664b145f1de2382bce78296d0d025" translate="yes" xml:space="preserve">
          <source>rewrite &lt;code&gt;expect(received).toBe(expected)&lt;/code&gt; as &lt;code&gt;expect(Object.is(received, expected)).toBe(true)&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4f197332e08a233e78868954dc8a7424597d992" translate="yes" xml:space="preserve">
          <source>rewrite &lt;code&gt;expect(received).toEqual(expected)&lt;/code&gt; as &lt;code&gt;expect(received.equals(expected)).toBe(true)&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98551bd9aa53f809816b1e04556754e5dbd233c3" translate="yes" xml:space="preserve">
          <source>setupFiles</source>
          <target state="translated">setupFiles</target>
        </trans-unit>
        <trans-unit id="cab3c689753017d9ed1c9833b41212afcceb0268" translate="yes" xml:space="preserve">
          <source>string: error message &lt;strong&gt;includes&lt;/strong&gt; the substring</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a13bd67d53c6ca5d0ba854cc1c6d8e1dc4db3cb" translate="yes" xml:space="preserve">
          <source>test()</source>
          <target state="translated">test()</target>
        </trans-unit>
        <trans-unit id="96bc193802c9de785826750faae2c6bc85cbfbb8" translate="yes" xml:space="preserve">
          <source>test.each()</source>
          <target state="translated">test.each()</target>
        </trans-unit>
        <trans-unit id="5d3becd10c06347f68018bdfb99aca7f0ac8047e" translate="yes" xml:space="preserve">
          <source>test.only()</source>
          <target state="translated">test.only()</target>
        </trans-unit>
        <trans-unit id="ab30dfd5db9a31603c2e47fbd6881ec8dab86d26" translate="yes" xml:space="preserve">
          <source>test.only.each()</source>
          <target state="translated">test.only.each()</target>
        </trans-unit>
        <trans-unit id="1176e40f403020d9366a6b52b73ff551f31b1814" translate="yes" xml:space="preserve">
          <source>test.skip()</source>
          <target state="translated">test.skip()</target>
        </trans-unit>
        <trans-unit id="f1d908eaf6e6e7fa35622b4b43d6a8af1a3c660e" translate="yes" xml:space="preserve">
          <source>test.skip.each()</source>
          <target state="translated">test.skip.each()</target>
        </trans-unit>
        <trans-unit id="74875a7933e712e5381bd416043bfb0b6616a91e" translate="yes" xml:space="preserve">
          <source>test.todo()</source>
          <target state="translated">test.todo()</target>
        </trans-unit>
        <trans-unit id="f4cea10a1c0dc3c50965ee387dece60500be5cff" translate="yes" xml:space="preserve">
          <source>to match a property in &lt;code&gt;objectContaining&lt;/code&gt; or &lt;code&gt;toMatchObject&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1d3d79ec58192bdcdaff5e0ab0b7fbca133543f" translate="yes" xml:space="preserve">
          <source>to match an element in &lt;code&gt;arrayContaining&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3556cfc1ba0721081f3f93c076211e40ef1a22b9" translate="yes" xml:space="preserve">
          <source>transformIgnorePatterns customization</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc220be1ad7bd8b6a9feda6f6ba1285b333e98e2" translate="yes" xml:space="preserve">
          <source>vscode-jest</source>
          <target state="translated">vscode-jest</target>
        </trans-unit>
        <trans-unit id="5218cb6aea807d0d643ecaa0be3719b154b08685" translate="yes" xml:space="preserve">
          <source>webpack 2 offers native support for ES modules. However, Jest runs in Node, and thus requires ES modules to be transpiled to CommonJS modules. As such, if you are using webpack 2, you most likely will want to configure Babel to transpile ES modules to CommonJS modules only in the &lt;code&gt;test&lt;/code&gt; environment.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ebedacdf66fa11ed6c1f1cd9d9b0e19efbf3b58" translate="yes" xml:space="preserve">
          <source>you can use:</source>
          <target state="translated">que puedes usar:</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
