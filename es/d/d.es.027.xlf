<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="es" datatype="htmlbody" original="d">
    <body>
      <group id="d">
        <trans-unit id="0758911fe007939762ea0a98ab73ee500552cb01" translate="yes" xml:space="preserve">
          <source>The parameter may be a number (as shown in the example above) dictating the size of each chunk. Alternatively, &lt;code&gt;byChunk&lt;/code&gt; accepts a user-provided buffer that it uses directly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c903948dffd2abfd68770b5195aac5d542b83003" translate="yes" xml:space="preserve">
          <source>The parameters of this distribution. The random number is x = (x * multipler + increment) % modulus.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c7bb35e4246e498ccd1516d5c0a045c041414c6" translate="yes" xml:space="preserve">
          <source>The parameters to the non-variadic function:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c00f330278c8a3688d755f58c6ef387d6c281e7" translate="yes" xml:space="preserve">
          <source>The parameters to the variadic function:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ebad486f6049114c19bd433cacf524aaf10fabc" translate="yes" xml:space="preserve">
          <source>The parameters with which to instantiate the template.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4fbe12ec5cf422714865a37fd1864dec27719969" translate="yes" xml:space="preserve">
          <source>The parent allocator is publicly accessible either as a direct member if it holds state, or as an alias to &lt;code&gt;Allocator.instance&lt;/code&gt; otherwise. One may use it for making calls that won't count toward statistics collection.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7916e9fe1cbcecc9e5b2265b50cee59f409bc09" translate="yes" xml:space="preserve">
          <source>The parent allocator. Depending on whether &lt;code&gt;ParentAllocator&lt;/code&gt; holds state or not, this is a member variable or an alias for &lt;code&gt;ParentAllocator.instance&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a766f10bdfc11306f72dafd5b728bd7317c675f" translate="yes" xml:space="preserve">
          <source>The parser initially sets it to TOK.concatenateAssign, and semantic() later decides which of the three it will be set to.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ca59cb5bd26311e5307aeb5f44c313335ea3580" translate="yes" xml:space="preserve">
          <source>The passed in input was correct, but more input was expected.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04a94fe6ab7793bd68edc946edd3c4d4f906c623" translate="yes" xml:space="preserve">
          <source>The passed text will be printed first, followed by a newline, then the short and long version of every option will be printed. The short and long version will be aligned to the longest option of every &lt;code&gt;Option&lt;/code&gt; passed. If the option is required, then &quot;Required:&quot; will be printed after the long version of the &lt;code&gt;Option&lt;/code&gt;. If a help message is present it will be printed next. The format is illustrated by this code:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae0176808c4338a2b32bdc055054955a47109b3c" translate="yes" xml:space="preserve">
          <source>The path given by &lt;code&gt;path&lt;/code&gt;, with the extension given by &lt;code&gt;ext&lt;/code&gt; appended if the path doesn't already have one.  Including the dot in the extension is optional.  This function always allocates a new string, except in the case when path is immutable and already has an extension.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9978fd2b7b1c58a32b59d2d933a84ff2eeb9cad1" translate="yes" xml:space="preserve">
          <source>The path name to expand.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dba74006c9911dd825361c79175c3816c02f4fd6" translate="yes" xml:space="preserve">
          <source>The path of the executable as a &lt;code&gt;string&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c35dcd32a0cd2b956596caddc202c46a4ae3354" translate="yes" xml:space="preserve">
          <source>The path to be matched against</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5d7f6c37fe93af27b88af304f713208b3e7e43a" translate="yes" xml:space="preserve">
          <source>The path to the file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9caa4476a8447e566c7b52e6155891828512bf8" translate="yes" xml:space="preserve">
          <source>The path to the shell to use to run the specified program. By default this is &lt;a href=&quot;#nativeShell&quot;&gt;&lt;code&gt;nativeShell&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a791a6dee2401c3ac563dc595efe14cc5ee858e9" translate="yes" xml:space="preserve">
          <source>The permutation to permutate &lt;code&gt;range&lt;/code&gt; to.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3bf6df59e4efc6178ad86ce4d172dd74e35f57bc" translate="yes" xml:space="preserve">
          <source>The permuted range.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b51b8abc388ed1faa0574f36244673bca9d03127" translate="yes" xml:space="preserve">
          <source>The pivot element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2141dbd9249b3127ee2311abb3285ea6f62646d8" translate="yes" xml:space="preserve">
          <source>The plan is to support all of the above except throwing D exceptions directly in C++ code (but they will be throwable indirectly by calling into a D function with C++ linkage).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e9fcc91fd47a551fe2c3ec3018788e0626a6afc" translate="yes" xml:space="preserve">
          <source>The platform-specific native shell path.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c744ae6de5a0c2342c1ec26c71bf9d84af5482c5" translate="yes" xml:space="preserve">
          <source>The point is to allow AliasDeclarationY to use &lt;code&gt;__traits()&lt;/code&gt;, see issue 7804.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b4bb95d6a8d2b3e99a53954eaab5d58c7eb10b4" translate="yes" xml:space="preserve">
          <source>The pointer</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd5b5206507758892b71f3f58e5e23e1c1f7f65c" translate="yes" xml:space="preserve">
          <source>The pointer, dynamic array, or reference is set to &lt;code&gt;null&lt;/code&gt; after the delete is performed. Any attempt to reference the data after the deletion via another reference to it will result in undefined behavior.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="594f71d424c88492080e5062a3ecf8853308a43e" translate="yes" xml:space="preserve">
          <source>The pointer-based version returns a &lt;code&gt;SortedRange&lt;/code&gt; wrapper over index, of type &lt;code&gt;SortedRange!(RangeIndex, (a, b) =&amp;gt; binaryFun!less(*a, *b))&lt;/code&gt; thus reflecting the ordering of the index. The index-based version returns &lt;code&gt;void&lt;/code&gt; because the ordering relation involves not only &lt;code&gt;index&lt;/code&gt; but also &lt;code&gt;r&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c0b6520bd81ff00673e639fb3748bb290589c44" translate="yes" xml:space="preserve">
          <source>The policy to use.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5bfa0d8b059a39ab26c6f284f964719eecf94f69" translate="yes" xml:space="preserve">
          <source>The policy used by this mutex.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8629893a44c9c276074edd00bae067e6b519cbda" translate="yes" xml:space="preserve">
          <source>The position in &lt;code&gt;array&lt;/code&gt; to insert the &lt;code&gt;stuff&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9eb86610993ddd6856217e1e6d70c91e6f75dbc" translate="yes" xml:space="preserve">
          <source>The position in the input string where the error occurred.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f421096d1588c50f7ea09d98220627162688c28b" translate="yes" xml:space="preserve">
          <source>The position of the minimum (respectively maximum) element of forward range &lt;code&gt;range&lt;/code&gt;, i.e. a subrange of &lt;code&gt;range&lt;/code&gt; starting at the position of its smallest (respectively largest) element and with the same ending as &lt;code&gt;range&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51fc654e8d5c11108a73d4836e9e77c133dfb257" translate="yes" xml:space="preserve">
          <source>The possible states of the &lt;code&gt;Ternary&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76c6cabbb86643a051bf73c292aa98533c672138" translate="yes" xml:space="preserve">
          <source>The possible targets are computed more conservatively than the language allows, eliminating all dangerous conversions. For example, &lt;code&gt;ImplicitConversionTargets!double&lt;/code&gt; does not include &lt;code&gt;float&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11d29604df18454624b74cfa89078e0417260306" translate="yes" xml:space="preserve">
          <source>The possible values for units are &lt;code&gt;&quot;weeks&quot;&lt;/code&gt;, &lt;code&gt;&quot;days&quot;&lt;/code&gt;, &lt;code&gt;&quot;hours&quot;&lt;/code&gt;, &lt;code&gt;&quot;minutes&quot;&lt;/code&gt;, &lt;code&gt;&quot;seconds&quot;&lt;/code&gt;, &lt;code&gt;&quot;msecs&quot;&lt;/code&gt; (milliseconds), &lt;code&gt;&quot;usecs&quot;&lt;/code&gt;, (microseconds), &lt;code&gt;&quot;hnsecs&quot;&lt;/code&gt; (hecto-nanoseconds, i.e. 100 ns), and &lt;code&gt;&quot;nsecs&quot;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c4f82ffde3ae1f423f2307932836a1e645ef668" translate="yes" xml:space="preserve">
          <source>The postblits &lt;code&gt;__fieldPostblit&lt;/code&gt; and &lt;code&gt;__aggrPostblit&lt;/code&gt; are generated without any implicit qualifiers and are not considered struct members. This leads to the situation where qualifying an entire struct declaration with &lt;code&gt;const&lt;/code&gt; or &lt;code&gt;immutable&lt;/code&gt; does not have any impact on the above-mentioned postblits. However, since &lt;code&gt;__xpostblit&lt;/code&gt; is a member of the struct and an alias of one of the other postblits, the qualifiers applied to the struct will affect the aliased postblit.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d47161252adc52b1f430344a53bb4997710446f2" translate="yes" xml:space="preserve">
          <source>The power modulus value of (base ^ exponent) % modulus.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="309c3d73f76b800f2ba5fd6059ce5bcf824a5c98" translate="yes" xml:space="preserve">
          <source>The pre contracts specify the preconditions before a statement is executed. The most typical use of this would be in validating the parameters to a function. The post contracts validate the result of the statement. The most typical use of this would be in validating the return value of a function and of any side effects it has. In D, pre contracts begin with &lt;code&gt;in&lt;/code&gt;, and post contracts begin with &lt;code&gt;out&lt;/code&gt;. They come at the end of the function signature and before the opening brace of the function body.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bad3757e2d3ea8e03615372cc42932fa498e0342" translate="yes" xml:space="preserve">
          <source>The predicate &lt;code&gt;less&lt;/code&gt; defines the lexicographical ordering to be used on the range.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75eafad6126e4b32c7a8770becfcb1f1b009b4fa" translate="yes" xml:space="preserve">
          <source>The predicate &lt;code&gt;pred&lt;/code&gt; needs to accept an element of &lt;code&gt;r&lt;/code&gt; and the separator &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73639f6f297aaeaa7398fc5473b39c5c235bf984" translate="yes" xml:space="preserve">
          <source>The predicate for comparing each element with the needle, defaulting to equality &lt;code&gt;&quot;a == b&quot;&lt;/code&gt;. The negated predicate &lt;code&gt;&quot;a != b&quot;&lt;/code&gt; can be used to search instead for the first element</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad19c283f2ff0ef86cf40f35fd842064c7bd010d" translate="yes" xml:space="preserve">
          <source>The predicate for comparing each element with the separator, defaulting to &lt;code&gt;&quot;a == b&quot;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5a87643179e233709de5c2f1a144d80a09a77b5" translate="yes" xml:space="preserve">
          <source>The predicate for deciding where to split the range when no separator is passed</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e35b33251882d624f933a2c1b64ccb5eb65ade7b" translate="yes" xml:space="preserve">
          <source>The predicate for determining when to stop counting.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c33296dd22cd76b6c27b1beb8636640e4665dda" translate="yes" xml:space="preserve">
          <source>The predicate is expected to satisfy certain rules in order for &lt;code&gt;sort&lt;/code&gt; to behave as expected - otherwise, the program may fail on certain inputs (but not others) when not compiled in release mode, due to the cursory &lt;code&gt;assumeSorted&lt;/code&gt; check. Specifically, &lt;code&gt;sort&lt;/code&gt; expects &lt;code&gt;less(a,b) &amp;amp;&amp;amp; less(b,c)&lt;/code&gt; to imply &lt;code&gt;less(a,c)&lt;/code&gt; (transitivity), and, conversely, &lt;code&gt;!less(a,b) &amp;amp;&amp;amp; !less(b,c)&lt;/code&gt; to imply &lt;code&gt;!less(a,c)&lt;/code&gt;. Note that the default predicate (&lt;code&gt;&quot;a &amp;lt; b&quot;&lt;/code&gt;) does not always satisfy these conditions for floating point types, because the expression will always be &lt;code&gt;false&lt;/code&gt; when either &lt;code&gt;a&lt;/code&gt; or &lt;code&gt;b&lt;/code&gt; is NaN. Use &lt;a href=&quot;std_math#cmp&quot;&gt;&lt;code&gt;std.math.cmp&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27f1015c9d3c968b66e69f35344a3e7b0807ccce" translate="yes" xml:space="preserve">
          <source>The predicate is passed to &lt;a href=&quot;std_functional#binaryFun&quot;&gt;&lt;code&gt;std.functional.binaryFun&lt;/code&gt;&lt;/a&gt; and accepts any callable function that can be executed via &lt;code&gt;pred(element, s)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2040ad77d27bfa42d579b0732a628553443b56b4" translate="yes" xml:space="preserve">
          <source>The predicate is passed to &lt;a href=&quot;std_functional#binaryFun&quot;&gt;&lt;code&gt;std.functional.binaryFun&lt;/code&gt;&lt;/a&gt;, and can either accept a string, or any callable that can be executed via &lt;code&gt;pred(element, element)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1cc6d6782bb5ddbb272e878b0a97cd35ebd9643" translate="yes" xml:space="preserve">
          <source>The predicate is passed to &lt;a href=&quot;std_functional#unaryFun&quot;&gt;&lt;code&gt;std.functional.unaryFun&lt;/code&gt;&lt;/a&gt;, and can either accept a string, or any callable that can be executed via &lt;code&gt;pred(element)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30b49793439ff4c8d008cc1bf8471d003e4d8abc" translate="yes" xml:space="preserve">
          <source>The predicate that determines whether elements from each respective range match. Defaults to equality &lt;code&gt;&quot;a == b&quot;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11c0e0e174294f0d039166c9a6e153edb402dcf7" translate="yes" xml:space="preserve">
          <source>The predicate that the range should be partitioned by.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="efb36bba668de1092c1769f6aab990aa0cb00922" translate="yes" xml:space="preserve">
          <source>The predicate the ranges are sorted by.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87bdd1f3ad180a36d78f0b0a9fe20115fabf7d4e" translate="yes" xml:space="preserve">
          <source>The predicate to evaluate.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="793b27dece0d99ba7788014f7bf7dd0fb1085592" translate="yes" xml:space="preserve">
          <source>The predicate to partition by.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5491576ad03ca04a8526c028f920296327ac77a" translate="yes" xml:space="preserve">
          <source>The predicate to satisfy.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c929e818343f11140b434407d7b74c242dda71fa" translate="yes" xml:space="preserve">
          <source>The predicate to sort by.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04024868be7f287d2663bbef1dbf103a8da3cc6b" translate="yes" xml:space="preserve">
          <source>The predicate to use for comparing elements between the range and the needle(s).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28f32071ce8ed6579de4bc0673c1fb09d434c803" translate="yes" xml:space="preserve">
          <source>The predicate to use for comparing elements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e5598b5509b9c6eafc0eab8a5a91702947d0e63" translate="yes" xml:space="preserve">
          <source>The predicate to use for determining a match.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89fd4b4f61967cf71a560e54be19f8d76cbb1cde" translate="yes" xml:space="preserve">
          <source>The predicate to use for the rearrangement.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aafedf7f211b6bcd89cdb1a78ec67451cd224b87" translate="yes" xml:space="preserve">
          <source>The predicate to use in comparing elements for commonality. Defaults to equality &lt;code&gt;&quot;a == b&quot;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d6ef6e2289f7e8b2fa887a80d23adf75d1641e1" translate="yes" xml:space="preserve">
          <source>The predicate used for comparison, modeled as a &lt;a href=&quot;https://en.wikipedia.org/wiki/Weak_ordering#Strict_weak_orderings&quot;&gt; strict weak ordering&lt;/a&gt; (irreflexive, antisymmetric, transitive, and implying a transitive equivalence)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f8c0f3692256237f756958104cf2f7dfb39d06e" translate="yes" xml:space="preserve">
          <source>The predicate used to compare the values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97370c26d71acf94352a17fb62d152e3830e5289" translate="yes" xml:space="preserve">
          <source>The predicates are evaluated from left to right, aborting evaluation in a short-cut manner if a false result is encountered, in which case the latter instantiations do not need to compile.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d7464c6a5c260ac34ab99c016228d6b560c3e52" translate="yes" xml:space="preserve">
          <source>The predicates are evaluated from left to right, aborting evaluation in a short-cut manner if a true result is encountered, in which case the latter instantiations do not need to compile.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c330fdecec36e8afd7824dda6b681cda50cda735" translate="yes" xml:space="preserve">
          <source>The preferred way to do memory management in Objective-C is to use Automatic Reference Counting, &lt;a href=&quot;https://developer.apple.com/library/mac/releasenotes/ObjectiveC/RN-TransitioningToARC/Introduction/Introduction.html&quot;&gt;ARC&lt;/a&gt;. This is not supported in D, therefore manual memory management is required to be used instead. This is achieved by calling &lt;a href=&quot;https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Protocols/NSObject_Protocol/index.html#//apple_ref/occ/intfm/NSObject/release&quot;&gt;&lt;code&gt;release&lt;/code&gt;&lt;/a&gt; on an Objective-C instance, like in the old days of Objective-C.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c5a92eca5579a36fc2d0481a3b2f7e8a916467c" translate="yes" xml:space="preserve">
          <source>The presentation of unit test results to the user.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8662f0b9530b0402d97b53b894f53167be45df40" translate="yes" xml:space="preserve">
          <source>The previous exception in the chain of exceptions, if any.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="279b676cef017bbf61d78e4700dc992f1809ccb0" translate="yes" xml:space="preserve">
          <source>The previous exception in the chain of exceptions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3fc0517fe6d8889b123aa839a1f6e19c03962c2" translate="yes" xml:space="preserve">
          <source>The primary allocator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f0154c15aa8860cab6cca5d166473b2dfba4c14" translate="yes" xml:space="preserve">
          <source>The primary range of a container</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab5e84bf7b0a53be5c65c8499a656cc503de367a" translate="yes" xml:space="preserve">
          <source>The primary range type associated with the container.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33a169f7cc45c68212a77c63178f168570e503e4" translate="yes" xml:space="preserve">
          <source>The primary usefulness of</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d1a3cd0b06a0c49d350401e273d786a65d53304" translate="yes" xml:space="preserve">
          <source>The primary way that programs should time how long something takes is to do</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c12de0da440bbe44b6cbc2ce06649502cfbb1a15" translate="yes" xml:space="preserve">
          <source>The process ID number.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57ea5f74d898ca9f45c60b0cceb17881be0464f6" translate="yes" xml:space="preserve">
          <source>The process of compiling is divided into multiple phases. Each phase has no dependence on subsequent phases. For example, the scanner is not perturbed by the semantic analyzer. This separation of the passes makes language tools like syntax directed editors relatively easy to produce. It also is possible to compress D source by storing it in &amp;lsquo;tokenized&amp;rsquo; form.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28114859ca08917818ce7134f60ebbc9ff108b7d" translate="yes" xml:space="preserve">
          <source>The process of constructing a trie is more involved and is hidden from the user in a form of the convenience functions &lt;a href=&quot;#codepointTrie&quot;&gt;&lt;code&gt;codepointTrie&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#codepointSetTrie&quot;&gt;&lt;code&gt;codepointSetTrie&lt;/code&gt;&lt;/a&gt; and the even more convenient &lt;a href=&quot;#toTrie&quot;&gt;&lt;code&gt;toTrie&lt;/code&gt;&lt;/a&gt;. In general a set or built-in AA with &lt;code&gt;dchar&lt;/code&gt; type can be turned into a trie. The trie object in this module is read-only (immutable); it's effectively frozen after construction.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2a069ebee0eb3fc705692f747a2a23547f8a461" translate="yes" xml:space="preserve">
          <source>The process of deducing template type parameters from function arguments is called Implicit Function Template Instantiation (IFTI).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a65917e549f3ee7bf2fcc111ebfc87ae282e8929" translate="yes" xml:space="preserve">
          <source>The process will be &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/windows/desktop/ms686714%28v=vs.100%29.aspx&quot;&gt;forcefully and abruptly terminated&lt;/a&gt;. If &lt;code&gt;codeOrSignal&lt;/code&gt; is specified, it must be a nonnegative number which will be used as the exit code of the process. If not, the process wil exit with code 1. Do not use &lt;code&gt;codeOrSignal = 259&lt;/code&gt;, as this is a special value (aka. &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/windows/desktop/ms683189.aspx&quot;&gt;STILL_ACTIVE&lt;/a&gt;) used by Windows to signal that a process has in fact</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a52379dcfb4fdf54c286085a8d7b935d4c3bf51f" translate="yes" xml:space="preserve">
          <source>The program can explicitly inform the garbage collector that an object is no longer referred to with &lt;a href=&quot;https://dlang.org/phobos/object.html#destroy&quot;&gt;&lt;code&gt;destroy&lt;/code&gt;&lt;/a&gt;, and then the garbage collector calls the destructor immediately. The destructor is guaranteed to never be called twice.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da8f18e43875ff3b21ffb3a65f1d74da9627baee" translate="yes" xml:space="preserve">
          <source>The program name,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="212a3b865b9d39089a835e861cd51456362e9629" translate="yes" xml:space="preserve">
          <source>The proper way to instantiate this object is to call &lt;code&gt;WorkerLocalStorage.toRange&lt;/code&gt;. Once instantiated, this object behaves as a finite random-access range with assignable, lvalue elements and a length equal to the number of worker threads in the &lt;code&gt;TaskPool&lt;/code&gt; that created it plus 1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06cb3e37f16148a51f8965d4f1cdc4ea883f0365" translate="yes" xml:space="preserve">
          <source>The properties &lt;code&gt;.__vptr&lt;/code&gt; and &lt;code&gt;.__monitor&lt;/code&gt; give access to the class object's vtbl[] and monitor, respectively, but should not be used in user code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="465978af9e7d0929cd7aec7d44ae79ba13368247" translate="yes" xml:space="preserve">
          <source>The property &lt;code&gt;.outer&lt;/code&gt; used in a nested class gives the &lt;code&gt;this&lt;/code&gt; pointer to its enclosing class. If there is no enclosing class context, &lt;code&gt;.outer&lt;/code&gt; would return a pointer to enclosing function frame with &lt;code&gt;void*&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18230b4e21a7c31cb0b0a527787c1242f4f98838" translate="yes" xml:space="preserve">
          <source>The proxied value must be an &lt;b&gt;lvalue&lt;/b&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2aa3e8b16a5d628661af4b4300a9494770cb4fda" translate="yes" xml:space="preserve">
          <source>The ptr aliases are integral types guaranteed to be large enough to hold a pointer without losing bits:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5110028f04b358ea03cfe31d14fda076a20fecde" translate="yes" xml:space="preserve">
          <source>The purpose is to bypass the special case decoding that &lt;a href=&quot;std_range_primitives#front&quot;&gt;&lt;code&gt;std.range.primitives.front&lt;/code&gt;&lt;/a&gt; does to character arrays. As a result, using ranges with &lt;code&gt;byCodeUnit&lt;/code&gt; can be &lt;code&gt;nothrow&lt;/code&gt; while &lt;a href=&quot;std_range_primitives#front&quot;&gt;&lt;code&gt;std.range.primitives.front&lt;/code&gt;&lt;/a&gt; throws when it encounters invalid Unicode sequences.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c265a2d12f1e7e5cd63d17026023fdb0d5f3f129" translate="yes" xml:space="preserve">
          <source>The purpose of this is so that continue will go to the next of the statements, and break will go to the end of the statements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1651c6e27b3326d67f792a155dd955abdff9b39f" translate="yes" xml:space="preserve">
          <source>The qualifier template from the given type &lt;code&gt;T&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e09036cabacde1d4e95f44667e0017f4b4c08158" translate="yes" xml:space="preserve">
          <source>The qualifiers of the affix are not always the same as the qualifiers of the argument. This is because the affixes are not part of the data itself, but instead are just</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c6a006eb9560342bd14cc8557e22fb25a226fd2" translate="yes" xml:space="preserve">
          <source>The random-access range to partition.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97092cfd186fb5b900f835cf73b9eb2468215664" translate="yes" xml:space="preserve">
          <source>The random-access range to rearrange.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4ce54dd9a7b88e5f2bf201fe3fb2e94f16d9fa9" translate="yes" xml:space="preserve">
          <source>The random-access range to reorder.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9759b91222e0376d244c7fe53ea2166dd785b989" translate="yes" xml:space="preserve">
          <source>The range API is supported for both encoding and decoding:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f827934761dc7cbd89045f8928d650c1c6adfe0d" translate="yes" xml:space="preserve">
          <source>The range being partitioned</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff34249e986a29860f6c5d437ad8145efcb4a0b9" translate="yes" xml:space="preserve">
          <source>The range primitives that the resulting range provides depends whether or not &lt;code&gt;r&lt;/code&gt; provides them. Except the functions &lt;code&gt;back&lt;/code&gt; and &lt;code&gt;popBack&lt;/code&gt;, which also require the range to have a length as well as &lt;code&gt;back&lt;/code&gt; and &lt;code&gt;popBack&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e867771f52adb05da2dc3c29c4eccce7ead17be" translate="yes" xml:space="preserve">
          <source>The range to append to.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8f92036ba2322967a7c304f2680091886c10a9f" translate="yes" xml:space="preserve">
          <source>The range to check.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92faab42363803d3ec822fdd1af0c67c9ba8588a" translate="yes" xml:space="preserve">
          <source>The range to count.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a5042de5707ed27e3cd38336bffdd36cd0572c7" translate="yes" xml:space="preserve">
          <source>The range to handle.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e058b4d6c31bc35cf580da1ebefcc71d18f5d1ca" translate="yes" xml:space="preserve">
          <source>The range to index.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80d973acf722de6a5268aeaa4c8fc9646330d9bc" translate="yes" xml:space="preserve">
          <source>The range to permute.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="804c985240d645660c7de05e2788995416dc345a" translate="yes" xml:space="preserve">
          <source>The range to read from.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b4ec9a859bd18ea04f9de73b722dd789467f7e7" translate="yes" xml:space="preserve">
          <source>The range to search.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="121036e1b0b497292221a25f49b6dd27cc53e9e1" translate="yes" xml:space="preserve">
          <source>The range to sort.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc147be5451f6cfb0b41f5b2277bb929ce23d7db" translate="yes" xml:space="preserve">
          <source>The range to subtract from &lt;code&gt;r1&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49d274ac9ff8b631f4dc3f4b09f1138c62b7ffc0" translate="yes" xml:space="preserve">
          <source>The range to write to.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49360fcd22b248a482a8ca2592193dd9241be2ca" translate="yes" xml:space="preserve">
          <source>The range type</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="802ba550fbcee32bf81ae1613d2bfa286e1456a5" translate="yes" xml:space="preserve">
          <source>The range types for &lt;code&gt;RedBlackTree&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a11d808dfbdf148bbb169a6a95255aca3179a47b" translate="yes" xml:space="preserve">
          <source>The range's &lt;code&gt;front&lt;/code&gt; is the interval's &lt;code&gt;begin&lt;/code&gt;. func is used to generate the next &lt;code&gt;front&lt;/code&gt; when &lt;code&gt;popFront&lt;/code&gt; is called. If popFirst is &lt;code&gt;PopFirst.yes&lt;/code&gt;, then &lt;code&gt;popFront&lt;/code&gt; is called before the range is returned (so that &lt;code&gt;front&lt;/code&gt; is a time point which func would generate).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2230a6c9d63e9a6e8252220108f18931ca810d49" translate="yes" xml:space="preserve">
          <source>The range's &lt;code&gt;front&lt;/code&gt; is the interval's &lt;code&gt;end&lt;/code&gt;. func is used to generate the next &lt;code&gt;front&lt;/code&gt; when &lt;code&gt;popFront&lt;/code&gt; is called. If popFirst is &lt;code&gt;PopFirst.yes&lt;/code&gt;, then &lt;code&gt;popFront&lt;/code&gt; is called before the range is returned (so that &lt;code&gt;front&lt;/code&gt; is a time point which func would generate).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc87d893530544a1088c66c1a3ebadf8aa8d14c3" translate="yes" xml:space="preserve">
          <source>The ranges may be different, but they must have compatible element types (i.e. &lt;code&gt;CommonType&lt;/code&gt; must exist for the two element types). The result is a range that offers the weakest capabilities of the two (e.g. &lt;code&gt;ForwardRange&lt;/code&gt; if &lt;code&gt;R1&lt;/code&gt; is a random-access range and &lt;code&gt;R2&lt;/code&gt; is a forward range).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f573b0cbf92f973f94497f03f6ff76a63fec72f" translate="yes" xml:space="preserve">
          <source>The ranges may be different, but they must have compatible element types. The result is a range that offers the weakest capabilities of all &lt;code&gt;Ranges&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b730db3bfe83c0cd05e43737d06094aae7960b40" translate="yes" xml:space="preserve">
          <source>The ranges to compute the intersection for.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46baca537890237a1942208ed4eade3a2e0fe13d" translate="yes" xml:space="preserve">
          <source>The ranges to compute the union for.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5497d81d16c2927140f25a4c1006f37fea2563ca" translate="yes" xml:space="preserve">
          <source>The raw data is statically initialized using the values provided in the class definition. The pointer to the vtbl[] (the array of pointers to virtual functions) is assigned. Constructors are passed fully formed objects for which virtual functions can be called. This operation is equivalent to doing a memory copy of a static version of the object onto the newly allocated one.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fcae8af2965ab59e0bb8589c5d279780cbfa5e92" translate="yes" xml:space="preserve">
          <source>The raw data is statically initialized using the values provided in the struct definition. This operation is equivalent to doing a memory copy of a static version of the object onto the newly allocated one.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b86128a6bd2767acc00fa6def304105cbf1e478d" translate="yes" xml:space="preserve">
          <source>The read end of the pipe.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13a2374af67fe26dbb9c14a59fb5ce5f9e9d781a" translate="yes" xml:space="preserve">
          <source>The read/write mutex module provides a primitive for maintaining shared read access and mutually exclusive write access.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ea37ce134dc82d56b80e1186c5f0aadafbf2545" translate="yes" xml:space="preserve">
          <source>The real part of the number.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d84af79636d58f1538ce03a4ef706cc4269fc0ca" translate="yes" xml:space="preserve">
          <source>The reason why local symbols are not considered by UFCS, is to avoid unexpected name conflicts. See below problematic examples.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e1a9e9d57c1e11e3c0d69a36fca45727647f054" translate="yes" xml:space="preserve">
          <source>The reason why parsing the UUID string failed (if known)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="444ce1c54b9e6e4aeb187c02bb491ead21cc3157" translate="yes" xml:space="preserve">
          <source>The received message. If &lt;code&gt;T.length&lt;/code&gt; is greater than one, the message will be packed into a &lt;a href=&quot;std_typecons#Tuple&quot;&gt;&lt;code&gt;std.typecons.Tuple&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="629439e6d0394e525c1da0e460386c227bde37f1" translate="yes" xml:space="preserve">
          <source>The recommended default type for set of &lt;a href=&quot;#Code%20point&quot;&gt;code points&lt;/a&gt;. For details, see the current implementation: &lt;a href=&quot;#InversionList&quot;&gt;&lt;code&gt;InversionList&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1dc42bd6a98f128cb04e650caf0c66b2c441a15" translate="yes" xml:space="preserve">
          <source>The recommended solution (see Unicode Implementation Guidelines) is using multi-stage tables that are an implementation of the &lt;a href=&quot;http://en.wikipedia.org/wiki/Trie&quot;&gt;Trie&lt;/a&gt; data structure with integer keys and a fixed number of stages. For the remainder of the section this will be called a fixed trie. The following describes a particular implementation that is aimed for the speed of access at the expense of ideal size savings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64d2cded1f6173c486fb7ad21ff19a0763451581" translate="yes" xml:space="preserve">
          <source>The recommended type of &lt;a href=&quot;std_typecons#Tuple&quot;&gt;&lt;code&gt;std.typecons.Tuple&lt;/code&gt;&lt;/a&gt; to represent [a, b) intervals of &lt;a href=&quot;#Code%20point&quot;&gt;code points&lt;/a&gt;. As used in &lt;a href=&quot;#InversionList&quot;&gt;&lt;code&gt;InversionList&lt;/code&gt;&lt;/a&gt;. Any interval type should pass &lt;a href=&quot;#isIntegralPair&quot;&gt;&lt;code&gt;isIntegralPair&lt;/code&gt;&lt;/a&gt; trait.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="859ae610f623e658d3afadb3f75618929c558560" translate="yes" xml:space="preserve">
          <source>The recommended use of &lt;code&gt;KRRegion&lt;/code&gt; is as a</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="388d2ad6c415253a61a360bde9d489b23f6dc8d0" translate="yes" xml:space="preserve">
          <source>The ref-ness of a function is determined from all &lt;a href=&quot;statement#ReturnStatement&quot;&gt;&lt;i&gt;ReturnStatement&lt;/i&gt;&lt;/a&gt;s in the function body:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b502b2fed948d53834e6a08aa36762dc04287b2" translate="yes" xml:space="preserve">
          <source>The reference label must match a reference defined elsewhere. This may be a D symbol in scope of the source code being documented, like &lt;code&gt;[Object]&lt;/code&gt; in the example above, or it may be an explicit reference that is defined in the same documentation comment, like &lt;code&gt;[ref]&lt;/code&gt; in the example above. In the example both instances of &lt;code&gt;[ref]&lt;/code&gt; in item &lt;code&gt;1.&lt;/code&gt; will be replaced with the URL and title text from the matching definition at the bottom of the example. The first link will read &lt;code&gt;reference link&lt;/code&gt; and the second will read &lt;code&gt;ref&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7f3a52223d62265f3e1ec0b1d084d2cc36a6550" translate="yes" xml:space="preserve">
          <source>The region only stores three pointers, corresponding to the current position in the store and the limits. One allocation entails rounding up the allocation size for alignment purposes, bumping the current pointer, and comparing it against the limit.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8dfea884780d568afe3690e3e3875bf9d38d17dd" translate="yes" xml:space="preserve">
          <source>The registry does not perform synchronization, as registration is assumed to be executed serially, as is the case for C constructors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="323d86762a22443df4223066c5d79a8182348cc7" translate="yes" xml:space="preserve">
          <source>The rehashed associative array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2287a637460b49ec8f0775da73953a50ae5c2dbd" translate="yes" xml:space="preserve">
          <source>The relative path.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6288b454d7838d0a858531ccb0a8c1a5187d7261" translate="yes" xml:space="preserve">
          <source>The removed &lt;code&gt;Logger&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c0fe435252d4242a9ba6f628f9c2050e5381799" translate="yes" xml:space="preserve">
          <source>The replacement text is recursively scanned for more macros. If a macro is recursively encountered, with no argument or with the same argument text as the enclosing macro, it is replaced with no text. Macro invocations that cut across replacement text boundaries are not expanded. If the macro name is undefined, the replacement text has no characters in it. If a &amp;amp;dollar;(NAME) is desired to exist in the output without being macro expanded, the &amp;amp;dollar; should be &lt;a href=&quot;#punctuation_escapes&quot;&gt; backslash-escaped&lt;/a&gt;: &lt;code&gt;\$&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00c0559f793b29523699536174f193f79d1404f9" translate="yes" xml:space="preserve">
          <source>The representation of the passed string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="541a2ee308f80899ed39d343b6df8bc566dc23af" translate="yes" xml:space="preserve">
          <source>The requested type. The currently stored value must implicitly convert to the requested type, in fact &lt;code&gt;DecayStaticToDynamicArray!T&lt;/code&gt;. If an implicit conversion is not possible, throws a &lt;code&gt;VariantException&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5eb7b072c5ec5c51e2bc9f0c47309355a93d189e" translate="yes" xml:space="preserve">
          <source>The required value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b92c124327023d2112fc02de9225ba21a0e356f" translate="yes" xml:space="preserve">
          <source>The rest of the EH data can be placed anywhere, it is immutable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc76ec74ecd985115be5a95df44e330a29c95a31" translate="yes" xml:space="preserve">
          <source>The result cannot be represented exactly, so rounding occurred.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab324d21f7bc55d7dd8b6c95008f59bdf991ab91" translate="yes" xml:space="preserve">
          <source>The result is &lt;code&gt;&quot;true&quot;&lt;/code&gt; or &lt;code&gt;&quot;false&quot;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4130bb4d8bac0fbef0c07bb06c97970f537d8b6" translate="yes" xml:space="preserve">
          <source>The result is [s&lt;sub&gt;0&lt;/sub&gt;, s&lt;sub&gt;1&lt;/sub&gt;, ...] where s&lt;sub&gt;n&lt;/sub&gt; is the nth element formatted with the default format.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b142e927d8266a5d73b4c96f242e530946b4181" translate="yes" xml:space="preserve">
          <source>The result is reasonable even if the programmer fails to check for errors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6fee708ae88c1f8ca73e67b83e15b2edc455c01" translate="yes" xml:space="preserve">
          <source>The result is reasonable result even if the programmer fails to check for errors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5df04c97a049ab6feec7de9282693846423b4f8b" translate="yes" xml:space="preserve">
          <source>The result is the equivalent of what the initializer would look like for the contents of the associative array, e.g.: [&quot;red&quot; : 10, &quot;blue&quot; : 20].</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08ac164a7aed36036f9bcf755150a74df3d7b24f" translate="yes" xml:space="preserve">
          <source>The result is the string converted to UTF-8. A</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1509a90746b95e562f0978b9e4493748f60d91cb" translate="yes" xml:space="preserve">
          <source>The result is the string returned from the class instance's &lt;b&gt;.toString()&lt;/b&gt; method. A</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="778aba0a364d09c18b371bc8036e82626d093a0a" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;takeExactly&lt;/code&gt; is identical to that of &lt;a href=&quot;#take&quot;&gt;&lt;code&gt;take&lt;/code&gt;&lt;/a&gt; in cases where the original range defines &lt;code&gt;length&lt;/code&gt; or is infinite.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07564cb52ad1e727fc81a3311ff06a2d773285ae" translate="yes" xml:space="preserve">
          <source>The result of a call to getAttr after the specified bits have been cleared.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f30cfdc760b36139b0f53b5d0be507ea3d824ed7" translate="yes" xml:space="preserve">
          <source>The result of a call to getAttr after the specified bits have been set.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="445b97c22b054bdd6ff54c4dae46c9df7f4357c6" translate="yes" xml:space="preserve">
          <source>The result of the &lt;code&gt;getopt&lt;/code&gt; function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4e35be57e8c5a96f93fd5bad1cb28bc557187a1" translate="yes" xml:space="preserve">
          <source>The result of the cast operation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83715d44bc2b7900f8b6419b6c4fbc003acad08e" translate="yes" xml:space="preserve">
          <source>The result of the comparison (negative if &lt;code&gt;lhs &amp;lt; rhs&lt;/code&gt;, positive if &lt;code&gt; lhs &amp;gt; rhs&lt;/code&gt;, &lt;code&gt;0&lt;/code&gt; if the values are equal)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2ab3e5031cd5a46b28a9645ebcd2ff7f110159a" translate="yes" xml:space="preserve">
          <source>The result of the comparison, &lt;code&gt;true&lt;/code&gt; if the values are equal</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c6e42e7ac37e1c83ed4b193d1c4849e41daad91" translate="yes" xml:space="preserve">
          <source>The result of the comparison.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c6d52fd3aff83619b0b5496c6e3c7be89c2a3aa" translate="yes" xml:space="preserve">
          <source>The result of the expression if no exception is thrown.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c56ce95759c8e42c05e176cc9b231a6a3180930" translate="yes" xml:space="preserve">
          <source>The result of the operation, which is the same as the built-in operator</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b1c264300cd8b658cc8b4e315b7758a06a23af7" translate="yes" xml:space="preserve">
          <source>The result of the operation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d8e130938ba904bc8f047659f58c659ed670a0b" translate="yes" xml:space="preserve">
          <source>The result of this expression will be discarded. Print error messages if the operation has no side effects (and hence is meaningless).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a7cfc7639682da470adfb6b183264f1a3b8552c" translate="yes" xml:space="preserve">
          <source>The result type of an</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4056040f4fa407b267fad8cbca77b5fc61b11543" translate="yes" xml:space="preserve">
          <source>The resulting addresses will be used in a call to &lt;code&gt;Socket.bind&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b20f209f4a7f010b51d8af08450b0f594e3ca06" translate="yes" xml:space="preserve">
          <source>The resulting center-justified string. The returned string is GC-allocated. To avoid GC allocation, use &lt;a href=&quot;#centerJustifier&quot;&gt;&lt;code&gt;centerJustifier&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6de191dd7ab6e3535ad839e47c65dfd4fc76b1d8" translate="yes" xml:space="preserve">
          <source>The resulting index.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3934e1c05473de8755d2bda617c6973f102e169c" translate="yes" xml:space="preserve">
          <source>The return code of the operation. The value stored in val should be used only if the return value is &lt;code&gt;etc.c.curl.CurlInfo.ok&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1da37adfbfe4961b78a217ba2c3b5022d249608b" translate="yes" xml:space="preserve">
          <source>The return expression associated with the first test expression that made the predicate yield true, or the default return expression if no test expression matched.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96d68b6363dece3bf1b664aecfe8cf00504e56f0" translate="yes" xml:space="preserve">
          <source>The return type (int or long). It defaults to time_t, which is normally 32 bits on a 32-bit system and 64 bits on a 64-bit system.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="205ac1a8649e05600dd566c06cc715bf690a04c6" translate="yes" xml:space="preserve">
          <source>The return type must not have unshared aliasing unless &lt;code&gt;fun&lt;/code&gt; is &lt;code&gt;pure&lt;/code&gt; or the &lt;code&gt;Task&lt;/code&gt; is executed via &lt;code&gt;executeInNewThread&lt;/code&gt; instead of using a &lt;code&gt;TaskPool&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e9168599ed0b4047c1160546ea0dbeb54368257" translate="yes" xml:space="preserve">
          <source>The return type of the error handler.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97a463467304a89d6cd8cb9cc6d419fcfa020151" translate="yes" xml:space="preserve">
          <source>The return type of the function called by this &lt;code&gt;Task&lt;/code&gt;. This can be &lt;code&gt;void&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5cb9f689236bc6a0892c16310f01988eb2264f8" translate="yes" xml:space="preserve">
          <source>The return type of tryVisit is deduced from the visiting functions and must be the same across all overloads.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1337a5d1a9830872413420563b85bf03297ab386" translate="yes" xml:space="preserve">
          <source>The return type of visit is deduced from the visiting functions and must be the same across all overloads.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ae63b720e25e931777a9598eac602b1cc909af8" translate="yes" xml:space="preserve">
          <source>The return value of &lt;code&gt;T&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="463c16879da8ce6d09697a58e7475146e16150d1" translate="yes" xml:space="preserve">
          <source>The return value of &lt;code&gt;__traits(getParameterStorageClasses)&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c060f61f5611e03952bbbab3e92b4fea17da134a" translate="yes" xml:space="preserve">
          <source>The return value of the function is cached, so the procedures described below will only be performed the first time the function is called. All subsequent runs will return the same string, regardless of whether environment variables and directory structures have changed in the meantime.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="818fa28d06533d229f1e780afce11dd92bba71cd" translate="yes" xml:space="preserve">
          <source>The returned &lt;a href=&quot;#File&quot;&gt;&lt;code&gt;File&lt;/code&gt;&lt;/a&gt; wraps &lt;a href=&quot;core_stdio#stderr&quot;&gt;&lt;code&gt;core.stdio.stderr&lt;/code&gt;&lt;/a&gt;, and is therefore thread global. Reassigning &lt;code&gt;stderr&lt;/code&gt; to a different &lt;code&gt;File&lt;/code&gt; must be done in a single-threaded or locked context in order to avoid race conditions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5c6e553a95738c70b1b18bed8de44ea5bcf8eb1" translate="yes" xml:space="preserve">
          <source>The returned &lt;a href=&quot;#File&quot;&gt;&lt;code&gt;File&lt;/code&gt;&lt;/a&gt; wraps &lt;a href=&quot;core_stdio#stdin&quot;&gt;&lt;code&gt;core.stdio.stdin&lt;/code&gt;&lt;/a&gt;, and is therefore thread global. Reassigning &lt;code&gt;stdin&lt;/code&gt; to a different &lt;code&gt;File&lt;/code&gt; must be done in a single-threaded or locked context in order to avoid race conditions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58bd0e7417109f330774ab518ccd7daa1f03d122" translate="yes" xml:space="preserve">
          <source>The returned &lt;a href=&quot;#File&quot;&gt;&lt;code&gt;File&lt;/code&gt;&lt;/a&gt; wraps &lt;a href=&quot;core_stdio#stdout&quot;&gt;&lt;code&gt;core.stdio.stdout&lt;/code&gt;&lt;/a&gt;, and is therefore thread global. Reassigning &lt;code&gt;stdout&lt;/code&gt; to a different &lt;code&gt;File&lt;/code&gt; must be done in a single-threaded or locked context in order to avoid race conditions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac381e0220e927fc50320b0674e141c6fbd265c5" translate="yes" xml:space="preserve">
          <source>The returned object additionally supports &lt;a href=&quot;#unwrap&quot;&gt;&lt;code&gt;unwrap&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6492e8cd4172777485864f95c54fa9ab563046c6" translate="yes" xml:space="preserve">
          <source>The returned path is relative to &lt;code&gt;base&lt;/code&gt;, which is by default taken to be the current working directory. If specified, &lt;code&gt;base&lt;/code&gt; must be an absolute path, and it is always assumed to refer to a directory. If &lt;code&gt;path&lt;/code&gt; and &lt;code&gt;base&lt;/code&gt; refer to the same directory, the function returns &lt;code&gt;.&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27a61535d29f02d1215deba5ffbffddc1e97e7db" translate="yes" xml:space="preserve">
          <source>The returned path is relative to &lt;code&gt;base&lt;/code&gt;, which is usually the current working directory. &lt;code&gt;base&lt;/code&gt; must be an absolute path, and it is always assumed to refer to a directory. If &lt;code&gt;path&lt;/code&gt; and &lt;code&gt;base&lt;/code&gt; refer to the same directory, the function returns &lt;code&gt;'.'&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e221dcc2a55e6ae3990cde11462a83ddb8c59e57" translate="yes" xml:space="preserve">
          <source>The reverse of &lt;a href=&quot;#ticksToNSecs&quot;&gt;&lt;code&gt;ticksToNSecs&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6ea2f4408254d943e5179ee3bbfade7f366fbe9" translate="yes" xml:space="preserve">
          <source>The right part of &lt;code&gt;r&lt;/code&gt; after partitioning.  If &lt;code&gt;ss == SwapStrategy.stable&lt;/code&gt;, &lt;code&gt;partition&lt;/code&gt; preserves the relative ordering of all elements &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt; in &lt;code&gt;r&lt;/code&gt; for which &lt;code&gt;predicate(a) == predicate(b)&lt;/code&gt;. If &lt;code&gt;ss == SwapStrategy.semistable&lt;/code&gt;, &lt;code&gt;partition&lt;/code&gt; preserves the relative ordering of all elements &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt; in the left part of &lt;code&gt;r&lt;/code&gt; for which &lt;code&gt;predicate(a) == predicate(b)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74483ebbb544d307348c8757c03b1bb648258bec" translate="yes" xml:space="preserve">
          <source>The right-hand side of the comparison</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e9a080e28a8d91db65b56c19e48812d639eb325" translate="yes" xml:space="preserve">
          <source>The right-hand side of the comparison for equality</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82b77c8515d584392179571806e80acab0df8e0e" translate="yes" xml:space="preserve">
          <source>The right-hand side of the comparison for ordering</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce77342cf014dfbdd37bba884529bb7b1ea8eb76" translate="yes" xml:space="preserve">
          <source>The right-hand side of the operator</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e41eb8c1a87bc5b03b6c14f9d03728097407757" translate="yes" xml:space="preserve">
          <source>The right-hand side of the operator (left-hand side is &lt;code&gt;this&lt;/code&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44c8baae8e4b1cafc92c8edb1f1a4bc6398dfd3a" translate="yes" xml:space="preserve">
          <source>The right-hand side operand</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac11224128b70935424423a8a77fd6fd68210ba1" translate="yes" xml:space="preserve">
          <source>The right-hand side operand (&lt;code&gt;Rhs&lt;/code&gt; is the first argument to &lt;code&gt;Checked&lt;/code&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0295cf674c21bae7e541254ba48b44bd641bdb8f" translate="yes" xml:space="preserve">
          <source>The right-hand side type in the assignment, after the operation has been computed</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="718e1f58f1f55d464000d479f6fd938c33906894" translate="yes" xml:space="preserve">
          <source>The right-hand side type in the operator</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a73d548c23060689342ba25b61016e797895c8bb" translate="yes" xml:space="preserve">
          <source>The right-hand side type involved in the operator</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3fed9dabe35a6b8579a8bd12124493c72510d8b" translate="yes" xml:space="preserve">
          <source>The right-hand side value in the assignment, after the operator has been evaluated</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd88512e1e583ed536b72443b9651f20abee0041" translate="yes" xml:space="preserve">
          <source>The routine called when a message is sent to a full mailbox.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b66d87a6c0e08abdd807f5a483f6da0a435298a3" translate="yes" xml:space="preserve">
          <source>The routines and algorithms are derived from the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89f0c0488274c89f59fab106ec127c844449805c" translate="yes" xml:space="preserve">
          <source>The rules for strings are the usual for literals: If it can fit in an &lt;code&gt;int&lt;/code&gt;, it is an &lt;code&gt;int&lt;/code&gt;. Otherwise, it is a &lt;code&gt;long&lt;/code&gt;. But, if the user specifically asks for a &lt;code&gt;long&lt;/code&gt; with the &lt;code&gt;L&lt;/code&gt; suffix, always give the &lt;code&gt;long&lt;/code&gt;. Give an unsigned iff it is asked for with the &lt;code&gt;U&lt;/code&gt; or &lt;code&gt;u&lt;/code&gt; suffix. Octals created from integers preserve the type of the passed-in integral.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0dffdc084b14542b868ac2c2fcdcfbf771ea55f" translate="yes" xml:space="preserve">
          <source>The runtime module exposes information specific to the D runtime code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e0c7d670da430e1c2fcc83076d681bba14efcaf" translate="yes" xml:space="preserve">
          <source>The safety level of this function is faked. It shows itself as &lt;code&gt;@trusted pure nothrow&lt;/code&gt; to not break existing code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="269ccafe0cbb6bd48c0c364d60e7c6c6e04d5947" translate="yes" xml:space="preserve">
          <source>The same applies to other &lt;code&gt;Object&lt;/code&gt; methods such as &lt;code&gt;opCmp&lt;/code&gt;, &lt;code&gt;toHash&lt;/code&gt;, etc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9e9404807d647f780072b029fb88dbb6d89a0b9" translate="yes" xml:space="preserve">
          <source>The same as &lt;a href=&quot;#getVirtualMethods&quot;&gt;&lt;i&gt;getVirtualMethods&lt;/i&gt;&lt;/a&gt;, except that final functions that do not override anything are included.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93baf85b2a1ff9ebbdedf5ac60d17440ac90bad4" translate="yes" xml:space="preserve">
          <source>The same as &lt;a href=&quot;#isVirtualMethod&quot;&gt;&lt;i&gt;isVirtualMethod&lt;/i&gt;&lt;/a&gt;, except that final functions that don't override anything return true.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="484feea935bb2f51a17677737f5a18c29ab34260" translate="yes" xml:space="preserve">
          <source>The same is true for structs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="daa76d61107754eb643bbf2894986cd43d9f6292" translate="yes" xml:space="preserve">
          <source>The same lookup across blocks, scripts, or binary properties, but performed at run-time. This version is provided for cases where &lt;code&gt;name&lt;/code&gt; is not known beforehand; otherwise compile-time checked &lt;a href=&quot;#opDispatch&quot;&gt;&lt;code&gt;opDispatch&lt;/code&gt;&lt;/a&gt; is typically a better choice.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bed255bb45839fece8e5cb2e49994a8474ab1390" translate="yes" xml:space="preserve">
          <source>The saturated result of the operator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44ebf5442f3ff515c11231f709e48f19fb0fd8ce" translate="yes" xml:space="preserve">
          <source>The scanner function. It should scan from p1 through p2 - 1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b5611ba00d0c5303ec080902ad8f7d6474ce6c0" translate="yes" xml:space="preserve">
          <source>The scanning function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c94bc26dd8e2388a5758b02c027326a48e92c3c" translate="yes" xml:space="preserve">
          <source>The scheduling priority of this thread.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bce914b8aac817557e08a2a5b7b1a5b382065247" translate="yes" xml:space="preserve">
          <source>The scope characteristic is inherited, so any classes derived from a scope class are also scope.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bece65d16e0da3cd8d963615575ef27d8569dde0" translate="yes" xml:space="preserve">
          <source>The second</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0aa270a7ba151a0f73151e3a972f6dc7bf0ee07" translate="yes" xml:space="preserve">
          <source>The second array to compare</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="970cba63abb463ea9e374f88bdbe56bd7fb71605" translate="yes" xml:space="preserve">
          <source>The second form attaches the &lt;code&gt;return&lt;/code&gt; to the &lt;code&gt;ref&lt;/code&gt;, and has &lt;a href=&quot;#return-ref-parameters&quot;&gt;return ref parameter&lt;/a&gt; semantics with additional &lt;a href=&quot;memory-safe-d#scope-return-params&quot;&gt;scope parameter&lt;/a&gt; semantics.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="061d4f927a4a2679d380b604c58cb6c22d22e3d1" translate="yes" xml:space="preserve">
          <source>The second form of this function is usually not called directly; instead, it is used via &lt;a href=&quot;std_string#format&quot;&gt;&lt;code&gt;std.string.format&lt;/code&gt;&lt;/a&gt;, as shown in the examples below. Supported format characters are 'e', 'f', 'g', 'a', and 's'.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6175891dc518c6e785380cc43703fbdbef055ecb" translate="yes" xml:space="preserve">
          <source>The second form, &lt;code&gt;goto default;&lt;/code&gt;, transfers to the innermost &lt;a href=&quot;#DefaultStatement&quot;&gt;&lt;i&gt;DefaultStatement&lt;/i&gt;&lt;/a&gt; of an enclosing &lt;a href=&quot;#SwitchStatement&quot;&gt;&lt;i&gt;SwitchStatement&lt;/i&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b51588d42d45bcafc26dcdf68b259620359d8f6" translate="yes" xml:space="preserve">
          <source>The second function</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a381cf5b12ec2751302d71f1f36bb254a3a2a6d" translate="yes" xml:space="preserve">
          <source>The second makes use of template mixins:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6d7d023028752f2dd5e8e8741a79baee2991163" translate="yes" xml:space="preserve">
          <source>The second portion of the time;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d17baa58ea7c9cb2b5fdeeba1668762e0d314080" translate="yes" xml:space="preserve">
          <source>The second range</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03495ddd562bb985866c15203033cded1697fdb5" translate="yes" xml:space="preserve">
          <source>The second range to be compared.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17805909c78bc23c485d6d0eee55678a2626d3ec" translate="yes" xml:space="preserve">
          <source>The second range.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5c0d389b19e84b52a4b93582ba1ef6275bab88b" translate="yes" xml:space="preserve">
          <source>The second to set this &lt;a href=&quot;#DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt;'s second to.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca5f5f8367bfce8ad586cc8594d3c281eb469bd2" translate="yes" xml:space="preserve">
          <source>The second to set this &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt;'s second to.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="996418c92be5b452f3de4ff986e1cee8b8da9918" translate="yes" xml:space="preserve">
          <source>The second to set this &lt;a href=&quot;#TimeOfDay&quot;&gt;&lt;code&gt;TimeOfDay&lt;/code&gt;&lt;/a&gt;'s second to.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb3c67e4431bd2d01f2e0a28a1a5ab4c776bb0a0" translate="yes" xml:space="preserve">
          <source>The second type to receive the type name for</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="572604b99f4f13c97178a7bb83d0a01c9c1fdbf8" translate="yes" xml:space="preserve">
          <source>The second version of &lt;code&gt;AutoImplement&lt;/code&gt; automatically implements &lt;code&gt;Interface&lt;/code&gt;, while deriving from &lt;code&gt;BaseClass&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9922ebb56662094439fd0982652299a78a77cb79" translate="yes" xml:space="preserve">
          <source>The second version of the function logs data to the &lt;code&gt;sharedLog&lt;/code&gt; in a &lt;code&gt;printf&lt;/code&gt;-style manner.  In order for the resulting log message to be logged the &lt;code&gt;LogLevel&lt;/code&gt; must be greater or equal than the &lt;code&gt;LogLevel&lt;/code&gt; of the &lt;code&gt;sharedLog&lt;/code&gt; and must be greater or equal than the global &lt;code&gt;LogLevel&lt;/code&gt;. Additionally the &lt;code&gt;LogLevel&lt;/code&gt; must be greater or equal than the &lt;code&gt;LogLevel&lt;/code&gt; of the &lt;code&gt;stdSharedLogger&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fca00f96f63ee8d1d8ffcc6e490cc9b3f2af7ff1" translate="yes" xml:space="preserve">
          <source>The second version returns the number of times &lt;code&gt;needle&lt;/code&gt; occurs in &lt;code&gt;haystack&lt;/code&gt;. Throws an exception if &lt;code&gt;needle.empty&lt;/code&gt;, as the count of the empty range in any range would be infinite. Overlapped counts are not considered, for example &lt;code&gt;count(&quot;aaa&quot;, &quot;aa&quot;)&lt;/code&gt; is &lt;code&gt;1&lt;/code&gt;, not &lt;code&gt;2&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0ad6e5d9828f85ec68413d4266b0a775c993286" translate="yes" xml:space="preserve">
          <source>The second way is to cast data to immutable. When doing so, it is up to the programmer to ensure that any mutable references to the same data are not used to modify the data after the cast.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98a2a2f9f0974d5cf21ef2c42fb8d7b511ec7622" translate="yes" xml:space="preserve">
          <source>The second way is to use the precision specifier. The length comes first, followed by the pointer:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6258e42911fadc579ef629cac8b879505c815405" translate="yes" xml:space="preserve">
          <source>The second will queue readers if there are any writers queued. Writers are passed through one at a time, and once there are no writers present, all queued readers will be alerted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="222f9be8417077b869fc4ec2ffe85613dca810b0" translate="yes" xml:space="preserve">
          <source>The selector parameter for Objective-C methods.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7b62a580f33ebf95a2e808ad6d0fddcde51f3ed" translate="yes" xml:space="preserve">
          <source>The semantics of a bidirectional range (not checkable during compilation) are assumed to be the following (&lt;code&gt;r&lt;/code&gt; is an object of type &lt;code&gt;R&lt;/code&gt;):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17817f0aec7117e53dffc5a42bb0ce81b624678f" translate="yes" xml:space="preserve">
          <source>The semantics of a forward range (not checkable during compilation) are the same as for an input range, with the additional requirement that backtracking must be possible by saving a copy of the range object with &lt;code&gt;save&lt;/code&gt; and using it later.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ad7ef472479146863a20e103ea6caeaec90cbb2" translate="yes" xml:space="preserve">
          <source>The semantics of a module are not affected by what imports it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1896dacb2ba5ac95d6272bdae742dc30f30d5318" translate="yes" xml:space="preserve">
          <source>The semantics of a random-access range (not checkable during compilation) are assumed to be the following (&lt;code&gt;r&lt;/code&gt; is an object of type &lt;code&gt;R&lt;/code&gt;):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a29d19e0a1c63b8d3f0187e1b535c432966dec4b" translate="yes" xml:space="preserve">
          <source>The semaphore module provides a general use semaphore for synchronization.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0cb8e57171fd0fa8e03b5c22f3ff466ddf864a6e" translate="yes" xml:space="preserve">
          <source>The sequence of tokens is parsed to form syntax trees.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="438ac8d829e20acc25c07ebf7273d7538987132c" translate="yes" xml:space="preserve">
          <source>The sequence to check for the &lt;code&gt;BOM&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aec41afa837cbb030bd78ed48712b8225ab720a9" translate="yes" xml:space="preserve">
          <source>The short symbol for this option</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14ab0adc14c1851e03d1a893322666eb1605f066" translate="yes" xml:space="preserve">
          <source>The shuffled random-access range.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b938bafa6a37b04fed1bbf8b758bf0a54b828b83" translate="yes" xml:space="preserve">
          <source>The sign of &amp;Gamma;(x).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="691fa1f516ff445955097300abb84801c17ce9af" translate="yes" xml:space="preserve">
          <source>The signature of this function should be:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c551bae643970a0fd547169fd9a9d141dddbbc8" translate="yes" xml:space="preserve">
          <source>The signed type is converted to the unsigned type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee800310ad7741a1c2a988b7683af21966b44816" translate="yes" xml:space="preserve">
          <source>The similarity per &lt;code&gt;gapWeightedSimilarity&lt;/code&gt; has an issue in that it grows with the lengths of the two strings, even though the strings are not actually very similar. For example, the range &lt;code&gt;[&quot;Hello&quot;, &quot;world&quot;]&lt;/code&gt; is increasingly similar with the range &lt;code&gt;[&quot;Hello&quot;, &quot;world&quot;, &quot;world&quot;, &quot;world&quot;,...]&lt;/code&gt; as more instances of &lt;code&gt;&quot;world&quot;&lt;/code&gt; are appended. To prevent that, &lt;code&gt;gapWeightedSimilarityNormalized&lt;/code&gt; computes a normalized version of the similarity that is computed as &lt;code&gt;gapWeightedSimilarity(s, t, lambda) / sqrt(gapWeightedSimilarity(s, t, lambda) * gapWeightedSimilarity(s, t, lambda))&lt;/code&gt;. The function &lt;code&gt;gapWeightedSimilarityNormalized&lt;/code&gt; (a so-called normalized kernel) is bounded in &lt;code&gt;[0, 1]&lt;/code&gt;, reaches &lt;code&gt;0&lt;/code&gt; only for ranges that don't match in any position, and &lt;code&gt;1&lt;/code&gt; only for identical ranges.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88799e576696dc3374489d7e5f75d72056dc1dfa" translate="yes" xml:space="preserve">
          <source>The simplest form of importing is to just list the modules being imported:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2009ad4b4c0d89d88051ad98575cc82bbbcf921" translate="yes" xml:space="preserve">
          <source>The simplest immutable declarations use it as a storage class. It can be used to declare manifest constants.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b20f562102f67ba45af181d477da8263c4656fad" translate="yes" xml:space="preserve">
          <source>The simplest use of &lt;code&gt;bringToFront&lt;/code&gt; is for rotating elements in a buffer. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87bc4b882bb607c1c565d6a1ffe9da4b18a9935d" translate="yes" xml:space="preserve">
          <source>The sine and cosine of &lt;code&gt;z&lt;/code&gt;, respectively.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4beb2d03043706421491257b91174cce75401dc3" translate="yes" xml:space="preserve">
          <source>The single element to check.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e20b632a66e4a0973d296fc8dc97c6e7878340fa" translate="yes" xml:space="preserve">
          <source>The single needle to check, which may be either a single element or an input range of elements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="936e0c490ea32a66488b88e6407723c37e53055d" translate="yes" xml:space="preserve">
          <source>The size in bytes of the block to add. If sz is zero then the no operation will occur. If p is null then sz must be zero.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5f548166d575892e245b5d531ead88e195d968a" translate="yes" xml:space="preserve">
          <source>The size in bytes of the extended memory block referenced by p or zero if no extension occurred.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5a5bf7ffaae9ea0e47a648c75ab38577c22cdee" translate="yes" xml:space="preserve">
          <source>The size in bytes of the memory block referenced by p or zero on error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47c428b4443aaffa87ab01d194f64c1d9938dadd" translate="yes" xml:space="preserve">
          <source>The size of each block can be selected either during compilation or at run time. Statically-known block sizes are frequent in practice and yield slightly better performance. To choose a block size statically, pass it as the &lt;code&gt;blockSize&lt;/code&gt; parameter as in &lt;code&gt;BitmappedBlock!(4096)&lt;/code&gt;. To choose a block size parameter, use &lt;code&gt;BitmappedBlock!(chooseAtRuntime)&lt;/code&gt; and pass the block size to the constructor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8db79a8cc24d1fb50ebc2a5392b4de19bea96fb" translate="yes" xml:space="preserve">
          <source>The size of each chunk</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="812d083ae4b6202df6ef9285312c396838fbce8c" translate="yes" xml:space="preserve">
          <source>The size of file in bytes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5299bf2c3bb77629866128b69aa3cd98cc936e97" translate="yes" xml:space="preserve">
          <source>The size of the allocated length at the end depends on the block size:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a507a2fd30a698197eb87aec60496407de2cc9b4" translate="yes" xml:space="preserve">
          <source>The size of the buffer to store the evaluated elements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f51f328cc82fa5e1146c1bcd8d39f77ba7f1a772" translate="yes" xml:space="preserve">
          <source>The size of the chunks</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f95ddc1cb4621988d676a326385232a6d69ff6df" translate="yes" xml:space="preserve">
          <source>The slice of &lt;code&gt;buf&lt;/code&gt; containing the formatted string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c76fb8fffafacca9cf978997fee5c7ec6adb0669" translate="yes" xml:space="preserve">
          <source>The slice of &lt;code&gt;buffer&lt;/code&gt; containing the data that was actually read. This will be shorter than &lt;code&gt;buffer&lt;/code&gt; if EOF was reached before the buffer could be filled.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25175c4c04d78f4f21e72598ea69bd88d569188a" translate="yes" xml:space="preserve">
          <source>The slice of &lt;code&gt;target&lt;/code&gt; containing the copied elements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad4934ab24ff890e3942dd0930dacb128284b747" translate="yes" xml:space="preserve">
          <source>The slice of buffer containing the decoded result.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2493c4fc7b08258cd8cb15270e3f883e67df77ba" translate="yes" xml:space="preserve">
          <source>The slice of buffer that contains the encoded string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad35a55effab17cdb298d4bb62b7946a0a05ee95" translate="yes" xml:space="preserve">
          <source>The slice on the left and any slices on the right must not overlap. All operands are evaluated exactly once, even if the array slice has zero elements in it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d8c2f61d4c506e7a291057e4bc000a710aed4c4" translate="yes" xml:space="preserve">
          <source>The slice's usable size will not match the block size. Use &lt;a href=&quot;#capacity&quot;&gt;&lt;code&gt;capacity&lt;/code&gt;&lt;/a&gt; to retrieve actual usable capacity.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bba8f7aecbe8029037e1ea79aca03fd651b20234" translate="yes" xml:space="preserve">
          <source>The smallest size that can be allocated is two words (16 bytes on 64-bit systems, 8 bytes on 32-bit systems). This is because the free list management needs two words (one for the length, the other for the next pointer in the singly-linked list).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8f2935f9d51846f40ce3a8ff14ea8411e17c417" translate="yes" xml:space="preserve">
          <source>The so-called &quot;all-lengths gap-weighted string kernel&quot; computes a similarity measure between &lt;code&gt;s&lt;/code&gt; and &lt;code&gt;t&lt;/code&gt; based on all of their common subsequences of all lengths. Gapped subsequences are also included.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b69c2f4a1b196deb3a8f2c9757a25cc977da4151" translate="yes" xml:space="preserve">
          <source>The solution is to use exception handling to report errors. All errors are objects derived from abstract class &lt;code&gt;Error&lt;/code&gt;. &lt;code&gt;Error&lt;/code&gt; has a pure virtual function called toString() which produces a &lt;code&gt;string&lt;/code&gt; with a human readable description of the error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="869eb1c2ddd5095ece630ff3cd9aa908770a28d3" translate="yes" xml:space="preserve">
          <source>The sorted alias sequence</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5890e22a27a487c3d84b74c6aadd83e7f574f4f1" translate="yes" xml:space="preserve">
          <source>The sorted, left-hand side of the random access range to be sorted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="327825eee250d31d85788280f6649c7f91900518" translate="yes" xml:space="preserve">
          <source>The source &lt;code&gt;Tuple&lt;/code&gt; to assign from. Each element of the source &lt;code&gt;Tuple&lt;/code&gt; must be implicitly assignable to each respective element of the target &lt;code&gt;Tuple&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5030b9b136204dc20df5dd72c92bea98a422bbd5" translate="yes" xml:space="preserve">
          <source>The source file is checked to see what character set it is, and the appropriate scanner is loaded. ASCII and UTF formats are accepted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dfdc9b54ae3eba8ba8704bc6e8f6a3bd3398e870" translate="yes" xml:space="preserve">
          <source>The source file is divided up into a sequence of tokens. &lt;a href=&quot;lex#specialtokens&quot;&gt;Special tokens&lt;/a&gt; are replaced with other tokens. &lt;a href=&quot;lex#SpecialTokenSequence&quot;&gt;&lt;i&gt;SpecialTokenSequence&lt;/i&gt;&lt;/a&gt;s are processed and removed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81874a58d9273e37ffa0ff4c91450536e1226f36" translate="yes" xml:space="preserve">
          <source>The source file name of the caller.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63c931360a6dacfd65be2e57e259c4c016ac5c72" translate="yes" xml:space="preserve">
          <source>The source file of the caller.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e1d1c43260b49fce3e8356d81c8f39a6eaf6f86" translate="yes" xml:space="preserve">
          <source>The source location.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57597d8f1413ea294f9a97a53e7900b691ef6e36" translate="yes" xml:space="preserve">
          <source>The source object</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8df6910eb6a7836cdf1dd95711fe44c7f692e87" translate="yes" xml:space="preserve">
          <source>The source of the cast</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79f7b5f01174bbbd5d3e9abcd1ae8cab2d28d824" translate="yes" xml:space="preserve">
          <source>The source range.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="139f7114b9b6fbeefdd429dfd8ce09ec26e9b7ae" translate="yes" xml:space="preserve">
          <source>The source text is decoded from its source representation into Unicode &lt;a href=&quot;#Character&quot;&gt;&lt;i&gt;Character&lt;/i&gt;&lt;/a&gt;s. The &lt;a href=&quot;#Character&quot;&gt;&lt;i&gt;Character&lt;/i&gt;&lt;/a&gt;s are further divided into: &lt;a href=&quot;#WhiteSpace&quot;&gt;&lt;i&gt;WhiteSpace&lt;/i&gt;&lt;/a&gt;, &lt;a href=&quot;#EndOfLine&quot;&gt;&lt;i&gt;EndOfLine&lt;/i&gt;&lt;/a&gt;, &lt;a href=&quot;#Comment&quot;&gt;&lt;i&gt;Comment&lt;/i&gt;&lt;/a&gt;s, &lt;a href=&quot;#SpecialTokenSequence&quot;&gt;&lt;i&gt;SpecialTokenSequence&lt;/i&gt;&lt;/a&gt;s, &lt;a href=&quot;#Token&quot;&gt;&lt;i&gt;Token&lt;/i&gt;&lt;/a&gt;s, all followed by &lt;a href=&quot;#EndOfFile&quot;&gt;&lt;i&gt;EndOfFile&lt;/i&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21e734d8ecbd4a33f2c2bfd5df8fb1b69390624d" translate="yes" xml:space="preserve">
          <source>The source text is split into tokens using the maximal munch technique, i.e., the lexical analyzer makes the longest token it can. For example &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; is a right shift token, not two greater than tokens. There are two exceptions to this rule:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="262fd934f3ad11cda48e320770c23b6cbce4d978" translate="yes" xml:space="preserve">
          <source>The source text is terminated by whichever comes first.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81738bf1b1d3def6ac2869102bc650c16fdd9cf9" translate="yes" xml:space="preserve">
          <source>The source type in the conversion or comparison</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7363cb9e0bea89a84f2ef7322159cb48984847e8" translate="yes" xml:space="preserve">
          <source>The specific &lt;code&gt;LogLevel&lt;/code&gt; used for logging the log message.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02d763555333f9cf77c0541a37bf5b34481db397" translate="yes" xml:space="preserve">
          <source>The specification for the form of embedded documentation comments only specifies how information is to be presented to the compiler. It is implementation-defined how that information is used and the form of the final presentation. Whether the final presentation form is an HTML web page, a man page, a PDF file, etc. is not specified as part of the D Programming Language.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c631213db2c74550b3a422d0caf42968e12b014d" translate="yes" xml:space="preserve">
          <source>The square root of &lt;code&gt;z&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b54a2e145a2a6ad88bd2025575b8d9841ee25294" translate="yes" xml:space="preserve">
          <source>The squared modulus of &lt;code&gt;z&lt;/code&gt;. For genericity, if called on a real number, returns its square.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d04cf6152ee5948faeb5107c99bbd4c4ee9e3f00" translate="yes" xml:space="preserve">
          <source>The stack and/or registers are being scanned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f3ea7f5b668b927908903c59ab3b69fcb5af861" translate="yes" xml:space="preserve">
          <source>The stack size for this fiber.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d77b689dcb1ab13845e33f5ac0d239d2be984a77" translate="yes" xml:space="preserve">
          <source>The stack size for this thread.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1902c662d9b13b82fe81369d128dde4e10ffcdaa" translate="yes" xml:space="preserve">
          <source>The stack trace of where the error happened. This is an opaque object that can either be converted to &lt;code&gt;string&lt;/code&gt;, or iterated over with &lt;code&gt; foreach&lt;/code&gt; to extract the items in the stack trace (as strings).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f20dc3ac3213d71596e365d3a32376deda65355" translate="yes" xml:space="preserve">
          <source>The stack variables referenced by a nested function are still valid even after the function exits (this is different from D 1.0). This is called a</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="813353f101357b03d0b61c073a4c5ccf1975eaf3" translate="yes" xml:space="preserve">
          <source>The standard HTTP methods : &lt;a href=&quot;http://www.w3.org/Protocols/rfc2616/rfc2616-sec5.html#sec5.1.1&quot;&gt;RFC2616 Section 5.1.1&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5be2cd87a2b0f4860fcc1853c1fefdfb3d5a3f6e" translate="yes" xml:space="preserve">
          <source>The standard error stream of the child process. This can be any &lt;a href=&quot;std_stdio#File&quot;&gt;&lt;code&gt;std.stdio.File&lt;/code&gt;&lt;/a&gt; that is opened for writing. By default the child process inherits the parent's error stream.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c14ddf17075fee8f053a24cb7922aea2d8242099" translate="yes" xml:space="preserve">
          <source>The standard error stream.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28e8c3771deea57b1287ddecdda74142b64d7ee8" translate="yes" xml:space="preserve">
          <source>The standard input stream of the child process. This can be any &lt;a href=&quot;std_stdio#File&quot;&gt;&lt;code&gt;std.stdio.File&lt;/code&gt;&lt;/a&gt; that is opened for reading. By default the child process inherits the parent's input stream.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25a87846c6350f9b0dad73c8670fb5c7a560abfc" translate="yes" xml:space="preserve">
          <source>The standard input stream.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f5d48c8b0f2de69f4c747237a77a2d1bfba7b08" translate="yes" xml:space="preserve">
          <source>The standard library lends a hand for comparing strings with mixed encodings (by transparently decoding, see &lt;a href=&quot;https://dlang.org/phobos/std_algorithm.html#cmp&quot;&gt;&lt;code&gt;std.algorithm.cmp&lt;/code&gt;&lt;/a&gt;), &lt;a href=&quot;https://dlang.org/phobos/std_uni.html#icmp&quot;&gt;case-insensitive comparison&lt;/a&gt; and &lt;a href=&quot;https://dlang.org/phobos/std_uni.html#normalize&quot;&gt;normalization&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d461322cb73ba656cc10ee6e78ac236193d95ae6" translate="yes" xml:space="preserve">
          <source>The standard output stream of the child process. This can be any &lt;a href=&quot;std_stdio#File&quot;&gt;&lt;code&gt;std.stdio.File&lt;/code&gt;&lt;/a&gt; that is opened for writing. By default the child process inherits the parent's output stream.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a9e602747062d7eede03400aa4e39b2ccb593c6" translate="yes" xml:space="preserve">
          <source>The standard output stream.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21e7fda428c2c6b1ed80304e44601e7fae93a662" translate="yes" xml:space="preserve">
          <source>The start tag of the element</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e872d9d6a6689ad057f6c088df86c8dbaa1e7c70" translate="yes" xml:space="preserve">
          <source>The starting point of the interval. It is included in the interval.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3554fc05aa3ab3a9ddf7ec9973a0bf7f4072e5a0" translate="yes" xml:space="preserve">
          <source>The starting value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a84bd1411e0ff3c732833affc83038a36b88c2e4" translate="yes" xml:space="preserve">
          <source>The state of the sequence is stored as a &lt;code&gt;Tuple&lt;/code&gt; so it can be heterogeneous.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8013cbe10851e46bc860bd1d31ef9871f35e223" translate="yes" xml:space="preserve">
          <source>The state of this fiber as an enumerated value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="debdb4248e291669b86fe314e231ec5f465f64cb" translate="yes" xml:space="preserve">
          <source>The std time to convert.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0b383e1171d8d015f97f2490da3a859a852e7d9" translate="yes" xml:space="preserve">
          <source>The stored &lt;code&gt;Logger&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d23198b78726b12c064950153015ab0cde6faecb" translate="yes" xml:space="preserve">
          <source>The strategy for finding the next available block is first fit.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2420fb1448496dbbd08ceea8e09dc60562adfb8" translate="yes" xml:space="preserve">
          <source>The stream to pass to INTERLEAVEFUNCTION.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18822dcb8b0bc3c64136bcaebcbf45df0cd6a713" translate="yes" xml:space="preserve">
          <source>The string</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e64ff94f3ecfd8fab9d37892f66980e617d6433b" translate="yes" xml:space="preserve">
          <source>The string &lt;code&gt;command&lt;/code&gt; is passed verbatim to the shell, and is therefore subject to its rules about command structure, argument/filename quoting and escaping of special characters. The path to the shell executable defaults to &lt;a href=&quot;#nativeShell&quot;&gt;&lt;code&gt;nativeShell&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2bf86f45ac17363df2917e94c577fdefa4162b88" translate="yes" xml:space="preserve">
          <source>The string indicating which characters to replace and what to replace them with. It is generated by &lt;a href=&quot;#makeTransTable&quot;&gt;&lt;code&gt;makeTransTable&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0533873999a54cfe4dbbd386fac2585e64d8e51" translate="yes" xml:space="preserve">
          <source>The string is meant to be human readable, not machine parseable (e.g. whether there is an &lt;code&gt;'s'&lt;/code&gt; on the end of the unit name usually depends on whether it's plural or not, and empty units are not included unless the Duration is &lt;code&gt;zero&lt;/code&gt;). Any code needing a specific string format should use &lt;code&gt;total&lt;/code&gt; or &lt;code&gt;split&lt;/code&gt; to get the units needed to create the desired string format and create the string itself.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2bd07e9629d13f3f409b884d3ffac3a7eb0da845" translate="yes" xml:space="preserve">
          <source>The string literal specifies a linker directive to be embedded in the generated object file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32d9e6c3c8e59228cc1e78ece5ad6aef58df9887" translate="yes" xml:space="preserve">
          <source>The string literals are assembled as UTF-8 char arrays, and the postfix is applied to convert to wchar or dchar as necessary as a final step.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1f9801101f016db2a559c014cb349546f881701" translate="yes" xml:space="preserve">
          <source>The string representation of this &lt;code&gt;Tuple&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95ecc1c83a5bc8c9a30b488436872240eb5cf883" translate="yes" xml:space="preserve">
          <source>The string that conventionally marks the end of all options (default '--').</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a364f528b991ce1bd157c8e5da1cb5665c7d72c5" translate="yes" xml:space="preserve">
          <source>The string to be decoded</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6de95ac63fa71760fd1a5b11770046f783a2524" translate="yes" xml:space="preserve">
          <source>The string to be encoded</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2b9d608f0fe83dbf1e7d9c07afcec863203911e" translate="yes" xml:space="preserve">
          <source>The string to capitalize.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf1478823e2820a59dba10485e438b40c5348725" translate="yes" xml:space="preserve">
          <source>The string to center</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e9ccd0a631efea8fdc72a8c62875a331c029bd3" translate="yes" xml:space="preserve">
          <source>The string to demangle.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b67968a1752f9ee5eb2c12fda8191f64a6136ec4" translate="yes" xml:space="preserve">
          <source>The string to parse</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5681bac273a271a57db9a94a9ee8c1380568e850" translate="yes" xml:space="preserve">
          <source>The string to return the representation of.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f72b4c4ff92e79f46043b6ac90fd712bc168dfd" translate="yes" xml:space="preserve">
          <source>The string used to separate the elements of an array or associative array (default is &quot;&quot; which means the elements are separated by whitespace).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="555d16dee4415f5ab0acc21725fda20143e994af" translate="yes" xml:space="preserve">
          <source>The strip group of functions allow stripping of either leading, trailing, or both leading and trailing elements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58b660c2a16b28679d8eef710bda4717a0e26225" translate="yes" xml:space="preserve">
          <source>The structs &lt;code&gt;Yes&lt;/code&gt; and &lt;code&gt;No&lt;/code&gt; are provided as shorthand for &lt;code&gt;Flag!&quot;Name&quot;.yes&lt;/code&gt; and &lt;code&gt;Flag!&quot;Name&quot;.no&lt;/code&gt; and are preferred for brevity and readability. These convenience structs mean it is usually unnecessary and counterproductive to create an alias of a &lt;code&gt;Flag&lt;/code&gt; as a way of avoiding typing out the full type while specifying the affirmative or negative options.  Passing categorical data by means of unstructured &lt;code&gt;bool&lt;/code&gt; parameters is classified under &quot;simple-data coupling&quot; by Steve McConnell in the &lt;a href=&quot;https://google.com/search?btnI=I%27m+Feeling+Lucky&amp;amp;ie=UTF-8&amp;amp;oe=UTF-8&amp;amp;q=Code%20Complete&quot;&gt;Code Complete&lt;/a&gt; book, along with three other kinds of coupling. The author argues citing several studies that coupling has a negative effect on code quality. &lt;code&gt;Flag&lt;/code&gt; offers a simple structuring method for passing yes/no flags to APIs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="076392e866b208f90ee610d973e43efceb10e97e" translate="yes" xml:space="preserve">
          <source>The subclass of EncodingScheme to register.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1ed1f004de54db1586dcfe56503caa35fb79f44" translate="yes" xml:space="preserve">
          <source>The sum of &lt;code&gt;sizes&lt;/code&gt; must be equal 21.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="789facc231279c33347577b57e2a474fbfbd6abb" translate="yes" xml:space="preserve">
          <source>The sum of all bit lengths in one bitfield instantiation must be exactly 8, 16, 32, or 64. If padding is needed, just allocate one bitfield with an empty name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2cfe229a83e79df357cdfd328b79e038bc593b6f" translate="yes" xml:space="preserve">
          <source>The sum of all the elements in the range r.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9be88f8537261298343db1ff319dde4340861d75" translate="yes" xml:space="preserve">
          <source>The supplied code as a delegate.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63d3a3cda8996c92ecd751aecdc230c95f7170d2" translate="yes" xml:space="preserve">
          <source>The swapping strategy parameter is not implemented yet; currently it is ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80b980e073fe362e9683180ed237939256d93352" translate="yes" xml:space="preserve">
          <source>The swapping strategy to employ.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="170969e1d0fabb640f8089b36d7401a205bca51c" translate="yes" xml:space="preserve">
          <source>The swapping strategy to use.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98e99ba24a8243b8fd6b17bc749b4554c5b7f75e" translate="yes" xml:space="preserve">
          <source>The swapping strategy.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48042820d83937bec0797943750b58634bf67f60" translate="yes" xml:space="preserve">
          <source>The symbol containing the &lt;code&gt;static foreach&lt;/code&gt; variables.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56e1148f66671625bb0c6990da38dc2d64edea1a" translate="yes" xml:space="preserve">
          <source>The symbol this &lt;code&gt;alias this&lt;/code&gt; resolves to</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dac6f5e28e8cd7e2f90032028de6bb0f0117f4f9" translate="yes" xml:space="preserve">
          <source>The symlink to create. A relative path is relative to the current working directory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83a33998cfc84a9e39e9f0423cfd7357619092df" translate="yes" xml:space="preserve">
          <source>The synchronization gets released even if</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f52720ebc8b4fb3263a1e381206af9d0efeeb0c2" translate="yes" xml:space="preserve">
          <source>The synchronized statement wraps a statement with a mutex to synchronize access among multiple threads.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54b1dbc833575883512c8f1664c887a121ae9fd3" translate="yes" xml:space="preserve">
          <source>The syntax is &lt;b&gt;/c/string/&lt;/b&gt;, where &lt;b&gt;c&lt;/b&gt; is either a single character, or multiple characters separated by whitespace or commas, and &lt;b&gt;string&lt;/b&gt; is the replacement text.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9da9fc28de038f5884f945667be4b8054f95702" translate="yes" xml:space="preserve">
          <source>The syntax trees are traversed to declare variables, load symbol tables, assign types, and in general determine the meaning of the program.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa94a6e6326b720f3ede8ff8d6c4dce16a4fa303" translate="yes" xml:space="preserve">
          <source>The system clock ticks are the ticks of the system clock at the highest precision that the system provides.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5387aa28c9051257b0dae7b093c61c8a7eb3427d" translate="yes" xml:space="preserve">
          <source>The system-provided garbage-collector allocator. This should be the default fallback allocator tapping into system memory. It offers manual &lt;code&gt;free&lt;/code&gt; and dutifully collects litter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec81049f6e21b9ea49ff325809160b315623cf2d" translate="yes" xml:space="preserve">
          <source>The table below gives a synopsis of predefined allocator building blocks, with their respective modules. Either &lt;code&gt;import&lt;/code&gt; the needed modules individually, or &lt;code&gt;import&lt;/code&gt;&lt;code&gt;std.experimental.building_blocks&lt;/code&gt;, which imports them all &lt;code&gt;public&lt;/code&gt;ly. The building blocks can be assembled in unbounded ways and also combined with your own. For a collection of typical and useful preassembled allocators and for inspiration in defining more such assemblies, refer to &lt;a href=&quot;std_experimental_allocator_showcase&quot;&gt;&lt;code&gt;std.experimental.allocator.showcase&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d173662a2aa058963145fe71e5e20907062a55be" translate="yes" xml:space="preserve">
          <source>The target hardware does not have a floating point unit</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5cdb1793dc5882606089de2cbe88b09e1226416" translate="yes" xml:space="preserve">
          <source>The target hardware has a floating point unit</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0979a69d6f3a7dae7324755cd1aa56f216e319b" translate="yes" xml:space="preserve">
          <source>The target object</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b824dcd9bca9b5db9480c831c6a63d26770ea48" translate="yes" xml:space="preserve">
          <source>The target of the search. Must be an input range. If any of &lt;code&gt;needles&lt;/code&gt; is a range with elements comparable to elements in &lt;code&gt;haystack&lt;/code&gt;, then &lt;code&gt;haystack&lt;/code&gt; must be a &lt;a href=&quot;std_range_primitives#isForwardRange&quot;&gt;forward range&lt;/a&gt; such that the search can backtrack.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1bfc030365108c10d6974605e9bd398b8361c092" translate="yes" xml:space="preserve">
          <source>The target range to copy common elements to.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="829e896e39b70090cbc3b2de79f25fe9335f1b77" translate="yes" xml:space="preserve">
          <source>The target range.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23350db16fa1f3e6288ccb87e5a181ba79379e10" translate="yes" xml:space="preserve">
          <source>The target supports interfacing with Objective-C</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eac1bff04784409ef03a30482f19ef41091d6414" translate="yes" xml:space="preserve">
          <source>The target type in the conversion or comparison</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="390654f1dbf50ff204a2f1fd9ed2609258c428a9" translate="yes" xml:space="preserve">
          <source>The target type of the cast</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5431c3bccb7e8fdc6dc54d831207394bad385ccd" translate="yes" xml:space="preserve">
          <source>The target variable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b71a4a76d74bf9f8e3d2c97011ae3038c9fc6fff" translate="yes" xml:space="preserve">
          <source>The technical term 'Special Functions' includes several families of transcendental functions, which have important applications in particular branches of mathematics and physics.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b45d76d889fde617363950e6293b054095035b5" translate="yes" xml:space="preserve">
          <source>The template API is slightly more efficient. It does not have to allocate memory dynamically, all memory is allocated on the stack. The OOP API has to allocate in the finish method if no buffer was provided. If you provide a buffer to the OOP APIs finish function, it doesn't allocate, but the &lt;a href=&quot;#Digest&quot;&gt;&lt;code&gt;Digest&lt;/code&gt;&lt;/a&gt; classes still have to be created using &lt;code&gt;new&lt;/code&gt; which allocates them using the GC.  The OOP API is useful to change the digest function and/or digest backend at 'runtime'. The benefit here is that switching e.g. Phobos MD5Digest and an OpenSSLMD5Digest implementation is ABI compatible.  If just one specific digest type and backend is needed, the template API is usually a good fit. In this simplest case, the template API can even be used without templates: Just use the &quot;&lt;b&gt;x&lt;/b&gt;&quot; structs directly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="408001ca506523fa6af663497d5def923a607239" translate="yes" xml:space="preserve">
          <source>The template parameter &lt;code&gt;T&lt;/code&gt; specifies the type to return. Possible values are &lt;code&gt;char&lt;/code&gt; and &lt;code&gt;ubyte&lt;/code&gt; to return &lt;code&gt;char[]&lt;/code&gt; or &lt;code&gt;ubyte[]&lt;/code&gt;. If asking for &lt;code&gt;char&lt;/code&gt;, content will be converted from the connection character set (specified in HTTP response headers or FTP connection properties, both ISO-8859-1 by default) to UTF-8.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d301625295a49a8e01e8072c1823836d6260302" translate="yes" xml:space="preserve">
          <source>The template picked to instantiate is the one that is most specialized that fits the types of the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02b51510e4339a80ea7cc2a65d41d079d75e78b8" translate="yes" xml:space="preserve">
          <source>The template to instantiate.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e41f924354ea35f5712eb828813900cd1d5f4161" translate="yes" xml:space="preserve">
          <source>The term and concept of a 'critical region' comes from &lt;a href=&quot;https://github.com/mono/mono/blob/521f4a198e442573c400835ef19bbb36b60b0ebb/mono/metadata/sgen-gc.h#L925&quot;&gt;Mono's SGen garbage collector&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="efe68f5f28809042f03e04ab3e7e40904902798b" translate="yes" xml:space="preserve">
          <source>The tested value</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="836717195b2e4f6e650af52f82b03152a0dc0a7a" translate="yes" xml:space="preserve">
          <source>The text from &lt;a href=&quot;http://unicode.org/cldr/data/common/supplemental/windowsZones.xml&quot;&gt;windowsZones.xml&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="459f3d558c2480422a70a7a05484244d80510d43" translate="yes" xml:space="preserve">
          <source>The text to print at the beginning of the help output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b43a60a00dd34982ab5b9431db8979ee331c8fcd" translate="yes" xml:space="preserve">
          <source>The text to printed at the beginning of the help output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f99eb9686d85d18418cbec2f3108af60157b8372" translate="yes" xml:space="preserve">
          <source>The third form, &lt;code&gt;goto case;&lt;/code&gt;, transfers to the next &lt;a href=&quot;#CaseStatement&quot;&gt;&lt;i&gt;CaseStatement&lt;/i&gt;&lt;/a&gt; of the innermost enclosing &lt;a href=&quot;#SwitchStatement&quot;&gt;&lt;i&gt;SwitchStatement&lt;/i&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d93a13c865f0a3f12bf9f0bb2248b62195335a7" translate="yes" xml:space="preserve">
          <source>The third version counts the elements for which &lt;code&gt;pred(x)&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;. Performs &amp;Omicron;(&lt;code&gt;haystack.length&lt;/code&gt;) evaluations of &lt;code&gt;pred&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7f1a71c5e73a907487dd15adada9e34f7e659b3" translate="yes" xml:space="preserve">
          <source>The thread function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3959bc13b481b7efab32161f7b4d802658e73e9a" translate="yes" xml:space="preserve">
          <source>The thread identifier to search for.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a0f4bf2e74aee3208cf1615166945a5d795e350" translate="yes" xml:space="preserve">
          <source>The thread module provides support for thread creation and management.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7abe70146b93589cb3df68907f1263f3d11f70c" translate="yes" xml:space="preserve">
          <source>The thread object associated with the thread identifier, null if not found.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab55fec985d480d7e55fafd41bc48fa26e59c5c7" translate="yes" xml:space="preserve">
          <source>The thread object representing the calling thread. The result of deleting this object is undefined. If the current thread is not attached to the runtime, a null reference is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5711fdf4eb878a460acdc3e1a74ec3adfd4c562" translate="yes" xml:space="preserve">
          <source>The thread to add.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d29c86c6e1877f0c1dbf42c7ab48cb432ebae10" translate="yes" xml:space="preserve">
          <source>The thread to remove.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0b4719e19dcec3e27e7ac05162455919bfcbe02" translate="yes" xml:space="preserve">
          <source>The threadsafe version of the &lt;a href=&quot;#BitmappedBlock&quot;&gt;&lt;code&gt;BitmappedBlock&lt;/code&gt;&lt;/a&gt;. The semantics of the &lt;code&gt;SharedBitmappedBlock&lt;/code&gt; are identical to the regular &lt;a href=&quot;#BitmappedBlock&quot;&gt;&lt;code&gt;BitmappedBlock&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59a01b618381df97fff6e53a1c501e32c03fcf01" translate="yes" xml:space="preserve">
          <source>The threadsafe version of the &lt;code&gt;Region&lt;/code&gt; allocator. Allocations and deallocations are lock-free based using &lt;a href=&quot;core_atomic#cas&quot;&gt;&lt;code&gt;core.atomic.cas&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1aa46d46c716c543c618abaaa5d085bc00056cfe" translate="yes" xml:space="preserve">
          <source>The tick of the system clock (as a &lt;code&gt;TickDuration&lt;/code&gt;) when the application started.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9d9d06b3436a3b01b898cdc70083c5a552bbada" translate="yes" xml:space="preserve">
          <source>The tid register by name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c95778519910f76a9057566bdc33da531d73931d" translate="yes" xml:space="preserve">
          <source>The time complexity of &lt;code&gt;resolveInternalPointer&lt;/code&gt; is &amp;Omicron;(&lt;code&gt;k&lt;/code&gt;), where &lt;code&gt;k&lt;/code&gt; is the size of the object within which the internal pointer is looked up.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6f885eba6e13ebbe7785527359e11e5b18d7b86" translate="yes" xml:space="preserve">
          <source>The time in this time zone that needs to be adjusted to UTC time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36444ba6ba0b4c42e3d384843ef7cb9d529fafd9" translate="yes" xml:space="preserve">
          <source>The time it takes for a collection to complete is not bounded. While in practice it is very quick, this cannot normally be guaranteed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de1882702ad690d9d775a9f36384bf0f0cf2e003" translate="yes" xml:space="preserve">
          <source>The time point to check for inclusion in this interval.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e148efcac14a5504ed5ebc4915f1425f4ffaad7" translate="yes" xml:space="preserve">
          <source>The time point to check whether this interval is after it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0af6ef24e2680b0852356a3c276c84d96252cda5" translate="yes" xml:space="preserve">
          <source>The time point to check whether this interval is before it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a3820a8c6e406527bb35a80565a009d598d8a36" translate="yes" xml:space="preserve">
          <source>The time point to set &lt;code&gt;begin&lt;/code&gt; to.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cbec4c576826e4c65a07a27c4030261f911b3fc7" translate="yes" xml:space="preserve">
          <source>The time point to set end to.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e8c71e16602a3ead734892883c0297513fcb288" translate="yes" xml:space="preserve">
          <source>The time point which begins the interval.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2fbbe21f1348e2b8375bc085e626db9a6aa48c4" translate="yes" xml:space="preserve">
          <source>The time point which ends (but is not included in) the interval.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78c4a788ebf74ce66cd510d9291804e7429c59df" translate="yes" xml:space="preserve">
          <source>The time point which ends the interval.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a07ced07ea48cf9efd3c59008997a5861e92661c" translate="yes" xml:space="preserve">
          <source>The time portion of &lt;a href=&quot;#DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eaefa3fbda7de51442bf3c3c08acb463add5f535" translate="yes" xml:space="preserve">
          <source>The time required of the base function</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5dfcadc4d17bd6640e6259395ec434dc6bc95330" translate="yes" xml:space="preserve">
          <source>The time required of the target function</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48cf786f30ef005c486cb7a01e2f10f8f8403d94" translate="yes" xml:space="preserve">
          <source>The time to return if the given file does not exist.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4267537c103e163837339d1b65e1d8cf5f9910a8" translate="yes" xml:space="preserve">
          <source>The time to wait.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa99618f433466483613abfd766711a1f7a82462" translate="yes" xml:space="preserve">
          <source>The time units of the &lt;code&gt;Duration&lt;/code&gt; (e.g. &lt;code&gt;&quot;days&quot;&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6cd7e80f003f95225b75b6571da8250b5085bd4" translate="yes" xml:space="preserve">
          <source>The time units of the &lt;code&gt;TickDuration&lt;/code&gt; (e.g. &lt;code&gt;&quot;msecs&quot;&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da60824664e52c129d1706b86eb17c66b6fccefc" translate="yes" xml:space="preserve">
          <source>The time zone for the SysTime that's returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c438d5ef1eeaa45747297e85768ff04bc9674297" translate="yes" xml:space="preserve">
          <source>The time zone that the &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt; will be in (&lt;code&gt;FILETIME&lt;/code&gt;s are in UTC).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ed6f652fe44fd70fdb71a9b99c39e57d001f270" translate="yes" xml:space="preserve">
          <source>The time zone that the time in the &lt;code&gt;SYSTEMTIME&lt;/code&gt; struct is assumed to be (if the &lt;code&gt;SYSTEMTIME&lt;/code&gt; was supplied by a Windows system call, the &lt;code&gt;SYSTEMTIME&lt;/code&gt; will either be in local time or UTC, depending on the call).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2b1325df63f2bced3800f46b247c623c3e4272e" translate="yes" xml:space="preserve">
          <source>The time zone to convert the given time to (no conversion occurs if null).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07061a5295594952467858d09a80f0ac4c6b93c5" translate="yes" xml:space="preserve">
          <source>The time zone which the DOS file time is assumed to be in.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea5d10f63e5499e351af6e045b5284865995d1c6" translate="yes" xml:space="preserve">
          <source>The time-domain signal.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77a3aa828967d445cff64c8dd096774ce4063dcd" translate="yes" xml:space="preserve">
          <source>The timeout duration to set. Must not be negative.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d16c09d69ed3827cc0d9a393d7d97a0e7218d947" translate="yes" xml:space="preserve">
          <source>The times when endianness matters are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3fa37b42db66accd6b9bcd0e0be5ca501e23ea7" translate="yes" xml:space="preserve">
          <source>The total hnsecs from midnight, January 1st, 1 A.D. UTC. This is the internal representation of &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c5851853cba4938d9ece2d746e33f63f5ccc8b6" translate="yes" xml:space="preserve">
          <source>The total number of CPU cores available on the current machine, as reported by the operating system.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79b5fcc0a58019c01762b4288a59bbc0fed9cdab" translate="yes" xml:space="preserve">
          <source>The total number of fields minus the number of hidden fields.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc0f294e7939a4a8cc8e219285559a0f838c9d26" translate="yes" xml:space="preserve">
          <source>The total number of valid bits in the given bit array</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df0ace455640aad44a2f2df358df6cfc839cb3dc" translate="yes" xml:space="preserve">
          <source>The total size of a static array cannot exceed 16Mb.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="976a549fe53e07ee95927e3a3f5dc68542025ca7" translate="yes" xml:space="preserve">
          <source>The traditional C way of detecting and reporting errors is not traditional, it is ad-hoc and varies from function to function, including:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67c33a524b8d09894199c567d354a8e0cb98ab34" translate="yes" xml:space="preserve">
          <source>The trailing end of the sub-format string following the specifier for each item is interpreted as the array delimiter, and is therefore omitted following the last array item. The &lt;b&gt;%|&lt;/b&gt; delimiter specifier may be used to indicate where the delimiter begins, so that the portion of the format string prior to it will be retained in the last array element:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba1799b6274ed3732b914694e0713f19f1425685" translate="yes" xml:space="preserve">
          <source>The transformation target</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc8b213c861da206308d6e24e6eb30fbdfae1604" translate="yes" xml:space="preserve">
          <source>The transformation to apply.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1e46c489c0f174beeea6508fe063266ccec2c4d" translate="yes" xml:space="preserve">
          <source>The transversal assumes, without verifying, that the elements of a range of ranges have all the same length. This option is useful if checking was already done from the outside of the range.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c892e981eb5136632b424a66b388d449fc7ea3de" translate="yes" xml:space="preserve">
          <source>The transversal enforces that the elements of a range of ranges have all the same length (e.g. an array of arrays, all having the same length). Checking is done once upon construction of the transversal range.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39be873b141578a1b5b94098b6cdd594b486bf6c" translate="yes" xml:space="preserve">
          <source>The try/catch/finally statements look a lot nicer than endless if (error) goto errorhandler; statements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2180bb589eb009453566d9091bc41a602b56f38e" translate="yes" xml:space="preserve">
          <source>The tuple passes in a range closed to the left and open to the right (consistent with built-in slices), e.g. &lt;code&gt;tuple(1, 3)&lt;/code&gt; means indices &lt;code&gt;1&lt;/code&gt; and &lt;code&gt;2&lt;/code&gt; but not &lt;code&gt;3&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07a7ad5d5f1c875f8f019e5586ed049f63bb8fa1" translate="yes" xml:space="preserve">
          <source>The two functions are almost identical semantically. The expressions in the first are lowered to contract blocks that look almost exactly like the second, except that a separate block is created for each expression in the first, thus avoiding shadowing variable names.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28b3f8f71ef0f4ce43325479aa6cdea23771283e" translate="yes" xml:space="preserve">
          <source>The two sockets are indistinguishable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61509f7d94291812c28aff0f194b21e094315464" translate="yes" xml:space="preserve">
          <source>The type being allocated embeds no pointers. Examples: &lt;code&gt;int&lt;/code&gt;, &lt;code&gt;int[]&lt;/code&gt;, &lt;code&gt; Tuple!(int, float)&lt;/code&gt;. The implicit conservative assumption is that the type has members with indirections so it needs to be scanned if garbage collected. Example of types with pointers: &lt;code&gt;int*[]&lt;/code&gt;, &lt;code&gt;Tuple!(int, string)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c92e87e9681d72db37be621f13a19e6f9ccab9d8" translate="yes" xml:space="preserve">
          <source>The type being allocated is &lt;code&gt;immutable&lt;/code&gt; and has no pointers. The thread that allocated it must also deallocate it. Example: &lt;code&gt;immutable(int)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e05464f951110a64f08a5f46efef5075a235c4f" translate="yes" xml:space="preserve">
          <source>The type being allocated may be shared across threads, embeds no indirections, and has fixed size.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31e0418a4ffc820d767ece7d24f4809101c1c145" translate="yes" xml:space="preserve">
          <source>The type being allocated may be shared across threads, may embed indirections, and has fixed size.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6fe4cebdd8e8add445c91158cc91cb4158edec6a" translate="yes" xml:space="preserve">
          <source>The type being allocated may be shared across threads, may embed indirections, and has variable size.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ddfa6b8808ffdca7214f401f8531dd3f2c5d3a94" translate="yes" xml:space="preserve">
          <source>The type can be inferred from the initializer:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2bca00fd97360bf19d51b245e76c8ddf38d445e" translate="yes" xml:space="preserve">
          <source>The type for a callback function. This is legacy and deprecated. It is included for historical compatibility and is not documented.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="121e0a2d6317bfb42929d38aae907c92fbe1c037" translate="yes" xml:space="preserve">
          <source>The type for a unary expression is incompatible. Print error message.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c3d19b0730f008ab63e19c7a8d36ffbf8fb1da1" translate="yes" xml:space="preserve">
          <source>The type of &lt;code&gt;Throwable&lt;/code&gt; to handle.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c9c6ef66ad21283731c4e03058407f8e8389f4f" translate="yes" xml:space="preserve">
          <source>The type of &lt;code&gt;Throwable&lt;/code&gt;s to catch. Defaults to &lt;code&gt;Exception&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="334019df59cb8690811d0f69b9dd1719fafb9c56" translate="yes" xml:space="preserve">
          <source>The type of a bit field can be any integral type or enumerated type. The most efficient type to store in bitfields is bool, followed by unsigned types, followed by signed types.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94b6a8f2e23e23e45fa071980296e38bdaa78842" translate="yes" xml:space="preserve">
          <source>The type of a const declaration is itself const.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f092f06205403400bf68aeecbf79e12113097113" translate="yes" xml:space="preserve">
          <source>The type of a string is determined by the semantic phase of compilation. The type is one of: char[], wchar[], dchar[], and is determined by implicit conversion rules. If there are two equally applicable implicit conversions, the result is an error. To disambiguate these cases, a cast or a postfix of &lt;code&gt;c&lt;/code&gt;, &lt;code&gt;w&lt;/code&gt; or &lt;code&gt;d&lt;/code&gt; can be used:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca53c8f136489f724620c0090bfc2e63be277e6a" translate="yes" xml:space="preserve">
          <source>The type of an</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31de113d851dba3763860dc7a09ef0a95ac4302d" translate="yes" xml:space="preserve">
          <source>The type of concurrency used when logical threads are created is determined by the Scheduler selected at initialization time. The default behavior is currently to create a new kernel thread per call to spawn, but other schedulers are available that multiplex fibers across the main thread or use some combination of the two approaches.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98b545b7a4a8236494e660dadf828715e09984c5" translate="yes" xml:space="preserve">
          <source>The type of encoding cannot be deduced. Therefore, it is necessary to explicitly specify the encoding type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28559fdc7fafacf56a4b4aa4caf411513cf1a53a" translate="yes" xml:space="preserve">
          <source>The type of exception to catch.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16e7bff806ed1fa4ab8073e5ade6ccec0c8f929f" translate="yes" xml:space="preserve">
          <source>The type of the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2db65940bfb878a54cfaaae819d3064fa148502" translate="yes" xml:space="preserve">
          <source>The type of the &lt;code&gt;TypeInfo&lt;/code&gt; object associated with &lt;code&gt;t&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3fe50288d353a1cb4576b8e3e05c3c630fa3b33c" translate="yes" xml:space="preserve">
          <source>The type of the array elements</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d37e2aaad386c1ac5e9f0016c42e7b609226d289" translate="yes" xml:space="preserve">
          <source>The type of the expression.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="028c1d38d3da5ded0145ae38e0f7c2dbd53920e7" translate="yes" xml:space="preserve">
          <source>The type of the integer is resolved as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="212a76fc03c17bbe0ddb79883b2541fa9887cff9" translate="yes" xml:space="preserve">
          <source>The type of the integral subject to checking.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c013517e503aa577ef8db2efdfe587a3e89caa97" translate="yes" xml:space="preserve">
          <source>The type of the output cannot be deduced. Therefore, it is necessary to explicitly specify the encoding as a template parameter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03cbac5dfebfa2a554890fbfd9c43c204a18bfcf" translate="yes" xml:space="preserve">
          <source>The type of the output cannot be deduced. Therefore, it is necessary to explicitly specify the encoding type in the template parameter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d39ec39bd451294d5515fb3a127cb955f855d7d6" translate="yes" xml:space="preserve">
          <source>The type of the previous</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="033a19799f0fa5ac9cef064ceb5d1268d8f17524" translate="yes" xml:space="preserve">
          <source>The type of the resulting array elements</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81040b338b2e6abd79e9a3fdf3377720163baee6" translate="yes" xml:space="preserve">
          <source>The type of the return value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd58ac5452c68f3b56c536830be3fca377a108cc" translate="yes" xml:space="preserve">
          <source>The type of the slice is a dynamic array of the element type of the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd785b1199a8635d3d151523c5ad55526bbbd6f9" translate="yes" xml:space="preserve">
          <source>The type of the symbol.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="452196a4318917b63a4cfe89691bc99e9fba3c75" translate="yes" xml:space="preserve">
          <source>The type of units to add (&quot;years&quot; or &quot;months&quot;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9dccb4c7e9a59ec9ebfcaaaf2ab57b17a652de7" translate="yes" xml:space="preserve">
          <source>The type returned by &lt;code&gt;takeOne&lt;/code&gt; is a random-access range with length regardless of &lt;code&gt;R&lt;/code&gt;'s capabilities, as long as it is a forward range. (another feature that distinguishes &lt;code&gt;takeOne&lt;/code&gt; from &lt;code&gt;take&lt;/code&gt;). If (D R) is an input range but not a forward range, return type is an input range with all random-access capabilities except save.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df7e4abf69509dd860941f1b197de09e0d181452" translate="yes" xml:space="preserve">
          <source>The type stored inside &lt;code&gt;bomTable&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6da0e0e3a59ae4f419059fd79e6a5b2efe510dd1" translate="yes" xml:space="preserve">
          <source>The type to cast from. The programmer must ensure it is legal to make this cast.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6fc6b3afd9d09c214bbb47deabcb3d5029a321f8" translate="yes" xml:space="preserve">
          <source>The type to cast to.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a12dddb89baf93f3c8ff660933719a4552a94a9" translate="yes" xml:space="preserve">
          <source>The type to check</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20caa9de7c60aa932980e2103bddf1b7c37802ff" translate="yes" xml:space="preserve">
          <source>The type to check Returns A &lt;code&gt;bool&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="129cd5fe4646df1f906533b11f848d4c99ca621d" translate="yes" xml:space="preserve">
          <source>The type to check.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0884902d15a178811c08946d7f41f322c3b3c6e" translate="yes" xml:space="preserve">
          <source>The type to convert to (either an integral type or a floating point type).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="731464fe86427c8aef65d3aa38988badaf10df11" translate="yes" xml:space="preserve">
          <source>The type to qualify</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4255aeb11f7f1166da5fe91079652809cb8c332" translate="yes" xml:space="preserve">
          <source>The type to transform</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a182178d558aaac6dc8d492d1e7dc9ff9e25bdd0" translate="yes" xml:space="preserve">
          <source>The types bool, byte, ubyte, short, ushort, int, uint, pointer, Object, and interfaces are returned in EAX.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0110212887a1a5d92fbf43e56315c07c9570e0ab" translate="yes" xml:space="preserve">
          <source>The types defined will all follow the naming convention:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04692c0de4f65115c6356357897fe3c8458aeb37" translate="yes" xml:space="preserve">
          <source>The types for a binary expression are incompatible. Print error message.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5522b90b8401affc194c75d94ed28b129ed2edae" translate="yes" xml:space="preserve">
          <source>The types of template parameters are deduced for a particular template instantiation by comparing the template argument with the corresponding template parameter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="066569f5b571624866c51a31fa6ddcb337821083" translate="yes" xml:space="preserve">
          <source>The types of the &lt;code&gt;Tuple&lt;/code&gt;'s components.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c8b9bedfec2099e1aa223db3144a32e496f4931" translate="yes" xml:space="preserve">
          <source>The underlying &lt;code&gt;FILE*&lt;/code&gt; handle is maintained in a reference-counted manner, such that as soon as the last &lt;code&gt;File&lt;/code&gt; variable bound to a given &lt;code&gt;FILE*&lt;/code&gt; goes out of scope, the underlying &lt;code&gt;FILE*&lt;/code&gt; is automatically closed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="afc75b662708321c7f89938e96034aeb600136f1" translate="yes" xml:space="preserve">
          <source>The unfilled part of target</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="634a8a351a2208e39d6a5ada2c8d683b264478f7" translate="yes" xml:space="preserve">
          <source>The units of time to convert from.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca496597d1b0052334d45f82b4d1ebb346322b8a" translate="yes" xml:space="preserve">
          <source>The units of time to convert to.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0be285da06571b223018436a72e418b7f4b54a74" translate="yes" xml:space="preserve">
          <source>The units of time to validate.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="421844a18abe81313eecb91da7e35563552d941b" translate="yes" xml:space="preserve">
          <source>The units to add.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4529f66e815e24cb45e91c0feb5284c7f7ff115" translate="yes" xml:space="preserve">
          <source>The units to add. Must be &lt;code&gt;&quot;days&quot;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a30f00fc7d9dabd0ab88732559ada44060afc844" translate="yes" xml:space="preserve">
          <source>The units to convert to. Accepts &lt;code&gt;&quot;seconds&quot;&lt;/code&gt; and smaller only.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77097e55fb24c41c45ac8fd555bdb9f92cb58569" translate="yes" xml:space="preserve">
          <source>The unix time to convert.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20dd814c3aa8014ba5957f08ad17be1db064e4d2" translate="yes" xml:space="preserve">
          <source>The unsorted, right-hand side of the random access range to be sorted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1d3c14f93e1c2e8f53e8dab18a0c8184c6c7a98" translate="yes" xml:space="preserve">
          <source>The upper bound of the clamp.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0983ef86eb34d76a2780b35b3edfbd68c63c7dea" translate="yes" xml:space="preserve">
          <source>The url to receive content from</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="446e2b0a1f994283348417fe7415a244c477d8c8" translate="yes" xml:space="preserve">
          <source>The use in the example above is correct because &lt;code&gt;result&lt;/code&gt; was private to &lt;code&gt;letters&lt;/code&gt; and is inaccessible in writing after the function returns. The following example shows an incorrect use of &lt;code&gt;assumeUnique&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f765f067fdbcdb23f122179aadad4e3aab7633fe" translate="yes" xml:space="preserve">
          <source>The use of this function is discouraged - use either of &lt;a href=&quot;#matchAll&quot;&gt;&lt;code&gt;matchAll&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#matchFirst&quot;&gt;&lt;code&gt;matchFirst&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12cefe2def110643149592a34e2703038ffe95e9" translate="yes" xml:space="preserve">
          <source>The use of this function is discouraged, please use &lt;a href=&quot;#replaceAll&quot;&gt;&lt;code&gt;replaceAll&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#replaceFirst&quot;&gt;&lt;code&gt;replaceFirst&lt;/code&gt;&lt;/a&gt; explicitly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="258077ec71c841ca26961567df7573b36d2e9600" translate="yes" xml:space="preserve">
          <source>The user-defined attribute to search for</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aef8bf31a8de472e5ee4f185e2b79cc50024f24a" translate="yes" xml:space="preserve">
          <source>The usual arithmetic conversions convert operands of binary operators to a common type. The operands must already be of arithmetic types. The following rules are applied in order, looking at the base type:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed8ed81507c265fdc6ddf599aacfb34e442e2017" translate="yes" xml:space="preserve">
          <source>The value held internally by this &lt;code&gt;Nullable&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18c2cd4ec56e16370bc6d10103dd74ac049c5530" translate="yes" xml:space="preserve">
          <source>The value held previously by &lt;code&gt;here&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="758230c61eadaee99aa3c3ef284aa623718c1933" translate="yes" xml:space="preserve">
          <source>The value of 'val'.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b06c415192563751b142dd5d437c6004b2e9459e" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;expr&lt;/code&gt;, if any.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="efa4633a9b927147870c40861701a3a66f460ac4" translate="yes" xml:space="preserve">
          <source>The value of an</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e705d7da4d67602f093ecd07ec55976add979079" translate="yes" xml:space="preserve">
          <source>The value of an &lt;a href=&quot;#EnumMember&quot;&gt;&lt;i&gt;EnumMember&lt;/i&gt;&lt;/a&gt; is given by its &lt;a href=&quot;expression#AssignExpression&quot;&gt;&lt;i&gt;AssignExpression&lt;/i&gt;&lt;/a&gt;. If there is no &lt;a href=&quot;expression#AssignExpression&quot;&gt;&lt;i&gt;AssignExpression&lt;/i&gt;&lt;/a&gt; and it is the first</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cfdd678ef3efc50d4d19e113e22570e812ee97e8" translate="yes" xml:space="preserve">
          <source>The value of cos(y) + i sin(y).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce228048bba4c787805c0ea9367075ff06ba1fcc" translate="yes" xml:space="preserve">
          <source>The value of cosh(y) + i sinh(y)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dffcef37a6c60e8c1178ac476b670c4fbdc86276" translate="yes" xml:space="preserve">
          <source>The value of the bound being violated</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="911671dbc78d40ead01af236d912c34ae5fc15c4" translate="yes" xml:space="preserve">
          <source>The value of the selected choice.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2079c7788ad766ba6207e480774a32436765df0d" translate="yes" xml:space="preserve">
          <source>The value of this &lt;code&gt;BigInt&lt;/code&gt; as a &lt;code&gt;long&lt;/code&gt;, or &lt;code&gt;long.max&lt;/code&gt;/&lt;code&gt;long.min&lt;/code&gt; if outside the representable range.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bfb5bbd989c9054cc2b242d5eea3691758f09eed" translate="yes" xml:space="preserve">
          <source>The value of this &lt;code&gt;BigInt&lt;/code&gt; as an &lt;code&gt;int&lt;/code&gt;, or &lt;code&gt;int.max&lt;/code&gt;/&lt;code&gt;int.min&lt;/code&gt; if outside the representable range.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44a86e613513bb5b90f75505c846e4f1a8d5e443" translate="yes" xml:space="preserve">
          <source>The value of x - i * y, where i is the number of times that y can be completely subtracted from x. The result has the same sign as x.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fbda37a05f283a201fa47e61f1a28829aac6ca57" translate="yes" xml:space="preserve">
          <source>The value that serves as the stopping criterion. This value is not included in the range.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06ef9451ca2a6ddc30c31abb46ec77c558d2c434" translate="yes" xml:space="preserve">
          <source>The value to act as a proxy for all operations. It must be an lvalue.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4437657364f8d6c0ea26bb67bc977fd2c3d6762" translate="yes" xml:space="preserve">
          <source>The value to add to the current value at each iteration.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ea1a4ae4b9c004c5d2afcb14b6504f978c0f7ea" translate="yes" xml:space="preserve">
          <source>The value to append.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e27e971fbf5a179f864e36ffcc71eeed5543b79" translate="yes" xml:space="preserve">
          <source>The value to be reference counted</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48cc3d885cf27d16c55ff2638b8883795263bff6" translate="yes" xml:space="preserve">
          <source>The value to bind to.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a802e0b8a3a2b83e804f3a0f0ce8a9cba9671bc8" translate="yes" xml:space="preserve">
          <source>The value to cast. It must be of type &lt;code&gt;From&lt;/code&gt;, otherwise a compile-time error is emitted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62da9509e3333e477d714ba7dbd138814897fd19" translate="yes" xml:space="preserve">
          <source>The value to clamp.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ad7684bb8903fcc2f377acbdab0d055ec3933a5" translate="yes" xml:space="preserve">
          <source>The value to convert.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50f2da1a55629d14637add94e8f4d0df9b3b3315" translate="yes" xml:space="preserve">
          <source>The value to divide from this &lt;code&gt;TickDuration&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a1bf08b423c514be4510f8c180b0baca8c3ce06" translate="yes" xml:space="preserve">
          <source>The value to divide from this duration.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1354007d97f6ba4733c332273819ddc621808569" translate="yes" xml:space="preserve">
          <source>The value to exchange.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1212730d5cf61a8236b91aa2562728d9cffb815c" translate="yes" xml:space="preserve">
          <source>The value to initialize this &lt;code&gt;Nullable&lt;/code&gt; with.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9870b988dc93826e41d9e14caae258236099356" translate="yes" xml:space="preserve">
          <source>The value to multiply this &lt;code&gt;Duration&lt;/code&gt; by.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b63d59c749f4e3c4e27b5c62bc54fa60f14460d7" translate="yes" xml:space="preserve">
          <source>The value to multiply/divide this &lt;code&gt;Duration&lt;/code&gt; by.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f9706fe37a21ebb4f5356314e9dbb0f193612de" translate="yes" xml:space="preserve">
          <source>The value to search for.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26611747ab051faf83da9bb9d7c2556f3251cdff" translate="yes" xml:space="preserve">
          <source>The value to store.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="572affcd555e45a118ca8c255703b01188667dc6" translate="yes" xml:space="preserve">
          <source>The value to test.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19051782b6b3c278237f01645d39c916e236a933" translate="yes" xml:space="preserve">
          <source>The value to write.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed8375fc18b2f2889a5d8178e1f4e71c024e1115" translate="yes" xml:space="preserve">
          <source>The value to yield.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36090b23e6b19abea403f7cf11708f739d6ebe0a" translate="yes" xml:space="preserve">
          <source>The value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9c7ac0f2459cf0fcaba3e1a3c53a1114b6dd604" translate="yes" xml:space="preserve">
          <source>The values of the statistics. Has the same length as &lt;code&gt;opts&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73dba46e865b8a15dc63f7dc2a467e9bb9da631f" translate="yes" xml:space="preserve">
          <source>The values to compare the value to.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c472612eda8a57b671db853841e452b39218b0df" translate="yes" xml:space="preserve">
          <source>The values to select the maximum from. At least two arguments must be passed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a965cfb58b4af69ed40e336a152e8e938e3ae5e" translate="yes" xml:space="preserve">
          <source>The values to select the minimum from. At least two arguments must be passed, and they must be comparable with &lt;code&gt;&amp;lt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c4b476e00d554e5b462693564ced434266700cc" translate="yes" xml:space="preserve">
          <source>The vararg module is intended to facilitate vararg manipulation in D. It should be interface compatible with the C module &quot;stdarg,&quot; and the two modules may share a common implementation if possible (as is done here).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e58c51068f71cad0c83773e1d40394fdd897c493" translate="yes" xml:space="preserve">
          <source>The variable to initialize</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da94a792f23c83ccf884c163bc10a13c232be367" translate="yes" xml:space="preserve">
          <source>The variadic arguments are normally consumed in order. POSIX-style &lt;a href=&quot;http://opengroup.org/onlinepubs/009695399/functions/printf.html&quot;&gt; positional parameter syntax&lt;/a&gt; is also supported. Each argument is formatted into a sequence of chars according to the format specification, and the characters are passed to &lt;code&gt;w&lt;/code&gt;. As many arguments as specified in the format string are consumed and formatted. If there are fewer arguments than format specifiers, a &lt;code&gt;FormatException&lt;/code&gt; is thrown. If there are more remaining arguments than needed by the format specification, they are ignored but only if at least one argument was formatted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa8f9f636d8a6045425f97a32a164b87a688ed99" translate="yes" xml:space="preserve">
          <source>The variadic part is converted to a dynamic array and the rest is the same as for non-variadic functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4280e8c5fae666595a22ad15b85940850cfe38e7" translate="yes" xml:space="preserve">
          <source>The vector extensions are currently implemented for the OS X 32 bit target, and all 64 bit targets.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a3f2a8776586397a6e7f50b19626acf584f35ca" translate="yes" xml:space="preserve">
          <source>The vendor specific version number, as in version_major.version_minor</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00e7fe40797e665c537b4d388116b4be59e896ff" translate="yes" xml:space="preserve">
          <source>The version of the D Programming Language Specification supported by the compiler.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="349a4c5870066cd09694037d969de8543ecfc287" translate="yes" xml:space="preserve">
          <source>The version specification makes it straightforward to group a set of features under one major version, for example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8bd1d61a79fbe94ca1f6332082364d1be24742ef" translate="yes" xml:space="preserve">
          <source>The vtable consists of:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3b5820f28d3bae10a6ec27f163ae2a69ac3fe29" translate="yes" xml:space="preserve">
          <source>The way the type of</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0fcc6679e5070c2e4f446305491364698920c76a" translate="yes" xml:space="preserve">
          <source>The way to read this is: start with negative meaning that all numbers smaller then the next one are not present in this set (and positive - the contrary). Then switch positive/negative after each number passed from left to right.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee95d5338e2cc507c044af212b980a2ccdb0be06" translate="yes" xml:space="preserve">
          <source>The week that each time point in the range will be.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ccaf69d731f86b374a2484d6db7113668b98a057" translate="yes" xml:space="preserve">
          <source>The worker treads in the &lt;code&gt;TaskPool&lt;/code&gt; instance returned by the &lt;code&gt;taskPool&lt;/code&gt; property are daemon by default. The worker threads of manually instantiated task pools are non-daemon by default.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="032848bfda222930e013953265615c3e0ccbd961" translate="yes" xml:space="preserve">
          <source>The working directory for the new process. By default the child process inherits the parent's working directory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b0246698510343503660da61604a3af0a5e9947" translate="yes" xml:space="preserve">
          <source>The wrapped statement.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83d3fe39ddb643ccc2434ee8c1b4b3abc6a78d80" translate="yes" xml:space="preserve">
          <source>The wrapped type for which Nullable provides a null value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52054c2c6d64acc406d7bd018817d7a8a1e5c5bf" translate="yes" xml:space="preserve">
          <source>The write end of the pipe.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d72f5499f6b8ab39b36f3e5d6ad25d6e2121747c" translate="yes" xml:space="preserve">
          <source>The year B.C. to set this &lt;a href=&quot;#Date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt;'s year to.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70438f0b3fdbdd369345e88c2fd45090d92cb7e3" translate="yes" xml:space="preserve">
          <source>The year B.C. to set this &lt;a href=&quot;#DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt;'s year to.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="744d36d482072547f2d6e876741e0a75ffde2547" translate="yes" xml:space="preserve">
          <source>The year B.C. to set this &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt;'s year to.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90ffac4afd7dedd0db0cf62512494ecd5d03ce9b" translate="yes" xml:space="preserve">
          <source>The year of the day to validate.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a632533914c1a4222f015d798cec051375cb6c9" translate="yes" xml:space="preserve">
          <source>The year portion of the date.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="674f0ed2625d2fbf8d46e126ee7509b07e39337e" translate="yes" xml:space="preserve">
          <source>The year to set this &lt;a href=&quot;#DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt;'s year to.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78b3d4944643d10e9690ce8b16f07cee0b861543" translate="yes" xml:space="preserve">
          <source>The year to set this &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt;'s year to.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="938c9fb56ce9737aba86f7a255d511c39f3f1219" translate="yes" xml:space="preserve">
          <source>The year to set this Date's year to.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25dac3542e9629d3c6f770b554d3c9420550d89e" translate="yes" xml:space="preserve">
          <source>The year to to be tested.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b05a3a1416ac42134535e13e8cceef19ad3efbf2" translate="yes" xml:space="preserve">
          <source>The ~= operator. It can have one of the following operators:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="483dc9258037e4ea0f71ce99febdf439cc645ac7" translate="yes" xml:space="preserve">
          <source>Then each of the arguments whose type does not match that of the delegate is converted to a delegate.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ef903eb9cd7218e2998c6f06dec42c64cb3057d" translate="yes" xml:space="preserve">
          <source>ThenStatement</source>
          <target state="translated">ThenStatement</target>
        </trans-unit>
        <trans-unit id="cffa55acb530a469e1c0e72f460da047941e3e1e" translate="yes" xml:space="preserve">
          <source>There are advantages to storing bookkeeping data separated from the payload (as opposed to e.g. using &lt;code&gt;AffixAllocator&lt;/code&gt; to store metadata together with each allocation). The layout is more compact (overhead is one bit per block), searching for a free block during allocation enjoys better cache locality, and deallocation does not touch memory around the payload being deallocated (which is often cold).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71da829c4cc0769086794220605ec04ef8da0ce9" translate="yes" xml:space="preserve">
          <source>There are eight usable logging level. These level are</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88bbdd16439c34d51b5285ff9a938ae545ede756" translate="yes" xml:space="preserve">
          <source>There are four kinds of arrays:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e137971ce6d07a865f890bb2bb72e21617522984" translate="yes" xml:space="preserve">
          <source>There are four overloads of this function. The first two take an array of strings, &lt;code&gt;args&lt;/code&gt;, which should contain the program name as the zeroth element and any command-line arguments in subsequent elements. The third and fourth versions are included for convenience, and may be used when there are no command-line arguments. They take a single string, &lt;code&gt;program&lt;/code&gt;, which specifies the program name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72dc9dd21f6b2060d2cd40a0fb38433822ac81cb" translate="yes" xml:space="preserve">
          <source>There are helper functions in this module which generate common delegates to pass to &lt;code&gt;bwdRange&lt;/code&gt;. Their documentation starts with &quot;Range-generating function,&quot; making them easily searchable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5dd0af54e988a94be1d9ad088b9582f13489afd" translate="yes" xml:space="preserve">
          <source>There are helper functions in this module which generate common delegates to pass to &lt;code&gt;bwdRange&lt;/code&gt;. Their documentation starts with &quot;Range-generating function,&quot; to make them easily searchable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d94c1629b0bd4094ede841815962ed80d0586ef" translate="yes" xml:space="preserve">
          <source>There are helper functions in this module which generate common delegates to pass to &lt;code&gt;fwdRange&lt;/code&gt;. Their documentation starts with &quot;Range-generating function,&quot; making them easily searchable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b9f6a69e089c92a07a88022f54475869259bbc2" translate="yes" xml:space="preserve">
          <source>There are helper functions in this module which generate common delegates to pass to &lt;code&gt;fwdRange&lt;/code&gt;. Their documentation starts with &quot;Range-generating function,&quot; to make them easily searchable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd1414ed61178080af45a1f5ca51914c6e9d26e1" translate="yes" xml:space="preserve">
          <source>There are many articles available that can bolster understanding ranges:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2d037a1149b17d68159307022f28fe56d8f92d3" translate="yes" xml:space="preserve">
          <source>There are no &lt;code&gt;__cdecl&lt;/code&gt;, &lt;code&gt;__far&lt;/code&gt;, &lt;code&gt;__stdcall&lt;/code&gt;, &lt;a href=&quot;http://www.digitalmars.com/ctg/ctgLanguageImplementation.html#declspec&quot;&gt; &lt;code&gt;__declspec&lt;/code&gt;&lt;/a&gt;, or other such C &lt;a href=&quot;http://www.digitalmars.com/ctg/ctgLanguageImplementation.html#extended&quot;&gt;extended type modifiers&lt;/a&gt; in D. These are handled by &lt;a href=&quot;attribute#linkage&quot;&gt;linkage attributes&lt;/a&gt;, such as &lt;code&gt;extern (C)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b9f66c209295069e84d0b1adcf2cd5cdb6933de" translate="yes" xml:space="preserve">
          <source>There are no &lt;code&gt;__cdecl&lt;/code&gt;, &lt;code&gt;__far&lt;/code&gt;, &lt;code&gt;__stdcall&lt;/code&gt;, &lt;code&gt;__declspec&lt;/code&gt;, or other such nonstandard C++ extensions in D.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1bbd1ded800fb7f0f4f094477d38ab432c667c3" translate="yes" xml:space="preserve">
          <source>There are no volatile type modifiers in D.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf7de3e93eae097ffa9c0cf65d8e97655fc5a893" translate="yes" xml:space="preserve">
          <source>There are other web resources on regular expressions to help newcomers, and a good &lt;a href=&quot;http://www.regular-expressions.info&quot;&gt;reference with tutorial&lt;/a&gt; can easily be found.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c5539350a7f6635346ecf0167abeb30fa2fea73" translate="yes" xml:space="preserve">
          <source>There are several forms of the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6bdc06ec8e2f529ede508fc3fd01087470669fa0" translate="yes" xml:space="preserve">
          <source>There are several things going on here:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06fc1953f9bbd669c6940d581b7a118ebf65b6cd" translate="yes" xml:space="preserve">
          <source>There are several workarounds for this limitation:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83683e99bdd11374a698bc33993ac450a4156b31" translate="yes" xml:space="preserve">
          <source>There are three categories of functions from the perspective of memory safety:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eebb936bce7d3ae26cde36cf7bb35604dacc5791" translate="yes" xml:space="preserve">
          <source>There are three kinds of comments:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ec3b7350c3966a7a5f315773f8a0d6461bc2b7c" translate="yes" xml:space="preserve">
          <source>There are two APIs for digests: The template API and the OOP API. The template API uses structs and template helpers like &lt;a href=&quot;#isDigest&quot;&gt;&lt;code&gt;isDigest&lt;/code&gt;&lt;/a&gt;. The OOP API implements digests as classes inheriting the &lt;a href=&quot;#Digest&quot;&gt;&lt;code&gt;Digest&lt;/code&gt;&lt;/a&gt; interface. All digests are named so that the template API struct is called &quot;&lt;b&gt;x&lt;/b&gt;&quot; and the OOP API class is called &quot;&lt;b&gt;x&lt;/b&gt;Digest&quot;. For example we have &lt;code&gt;MD5&lt;/code&gt; &amp;lt;--&amp;gt; &lt;code&gt;MD5Digest&lt;/code&gt;, &lt;code&gt;CRC32&lt;/code&gt; &amp;lt;--&amp;gt; &lt;code&gt;CRC32Digest&lt;/code&gt;, etc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f36743287cbe9730e4d00f520be725403f6d9245" translate="yes" xml:space="preserve">
          <source>There are two broad kinds of operations to do on an array - affecting the handle to the array, and affecting the contents of the array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f32e0774371c9709a85def64d98a62e794b8e4d" translate="yes" xml:space="preserve">
          <source>There are two options for handlers. The &lt;code&gt;bool&lt;/code&gt; version is deprecated but will be kept for legacy support. Returning &lt;code&gt;true&lt;/code&gt; from the handler is equivalent to returning &lt;code&gt;UnitTestResult.pass&lt;/code&gt; from the extended version. Returning &lt;code&gt;false&lt;/code&gt; from the handler is equivalent to returning &lt;code&gt;UnitTestResult.fail&lt;/code&gt; from the extended version.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ba98a9e569b41d605493fc4327d51d93311f773" translate="yes" xml:space="preserve">
          <source>There are two ways of using tilde expansion in a path. One involves using the tilde alone or followed by a path separator. In this case, the tilde will be expanded with the value of the environment variable &lt;code&gt;HOME&lt;/code&gt;. The second way is putting a username after the tilde (i.e. &lt;code&gt;~john/Mail&lt;/code&gt;). Here, the username will be searched for in the user database (i.e. &lt;code&gt;/etc/passwd&lt;/code&gt; on Unix systems) and will expand to whatever path is stored there. The username is considered the string after the tilde ending at the first instance of a path separator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4751b63f33932c16045492e8c9d0524f058f4c0a" translate="yes" xml:space="preserve">
          <source>There are two ways to declarate a symbol as member of a namespace: &lt;code&gt;Nspace&lt;/code&gt; and &lt;code&gt;CPPNamespaceDeclaration&lt;/code&gt;. The former creates a scope for the symbol, and inject them in the parent scope at the same time. The later, this class, has no semantic implications and is only used for mangling. Additionally, this class allows one to use reserved identifiers (D keywords) in the namespace.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87bb5bc4a10799fcef3cdb638af33c37c5ac5274" translate="yes" xml:space="preserve">
          <source>There can be any number of unit test functions in a module, including within struct, union and class declarations. They are executed in lexical order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed108d2e4ffaebbc3cca03de1cfa2dee10188c4a" translate="yes" xml:space="preserve">
          <source>There can be more than one invariant declared per class or struct.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07b99c3830a2a4bb0228e8b9b17dd7669ccd56c2" translate="yes" xml:space="preserve">
          <source>There can be multiple documented unittests and they can appear in any order. They will be attached to the last non-unittest declaration:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a95e25d0165fbf5408fd68a513879e3e08629026" translate="yes" xml:space="preserve">
          <source>There can be multiple static constructors and static destructors within one module. The static constructors are run in lexical order, the static destructors are run in reverse lexical order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="079786d2cc065de51998cade65524ac448945bab" translate="yes" xml:space="preserve">
          <source>There can be only one destructor per class, the destructor does not have any parameters, and has no attributes. It is always virtual.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a32fb137b8708f3a1060842effbe53862ee224b5" translate="yes" xml:space="preserve">
          <source>There can be only zero or one</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e54e87553bcbc89bb92a0dbc881f7633b6a68acf" translate="yes" xml:space="preserve">
          <source>There has been a great deal of discussion in the D newsgroups over this, and several implementations:  &lt;a href=&quot;http://www.digitalmars.com/d/archives/digitalmars/D/announce/signal_slots_library_4825.html&quot;&gt;signal slots library&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb4241af492e556aa6aed9941d820f825c722aec" translate="yes" xml:space="preserve">
          <source>There have been several D implementations of Signals and Slots. This version makes use of several new features in D, which make using it simpler and less error prone. In particular, it is no longer necessary to instrument the slots.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="137e54850bfef26233dbe4876142a62cdeee9d88" translate="yes" xml:space="preserve">
          <source>There is a hierarchy of allocation kinds. When an allocator is implemented for a given combination of flags, it is used. Otherwise, the next down the list is chosen.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb4bb1493d0166938db3cf214276bbc597f0dc3b" translate="yes" xml:space="preserve">
          <source>There is a rich set of functions for string handling defined in other modules. Functions related to Unicode and ASCII are found in &lt;a href=&quot;std_uni&quot;&gt;&lt;code&gt;std.uni&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;std_ascii&quot;&gt;&lt;code&gt;std.ascii&lt;/code&gt;&lt;/a&gt;, respectively. Other functions that have a wider generality than just strings can be found in &lt;a href=&quot;std_algorithm&quot;&gt;&lt;code&gt;std.algorithm&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;std_range&quot;&gt;&lt;code&gt;std.range&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="567058ffed748f85071d989bbf1a314374e793b2" translate="yes" xml:space="preserve">
          <source>There is a special type of array which acts as a wildcard that can hold arrays of any kind, declared as &lt;code&gt;void[]&lt;/code&gt;. Void arrays are used for low-level operations where some kind of array data is being handled, but the exact type of the array elements are unimportant. The &lt;code&gt;.length&lt;/code&gt; of a void array is the length of the data in bytes, rather than the number of elements in its original type. Array indices in indexing and slicing operations are interpreted as byte indices.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33cea21ca6b34b343eb25bbde6ebec03ec759bdc" translate="yes" xml:space="preserve">
          <source>There is currently only one special token sequence, &lt;code&gt;#line&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef49fac97d8d2e188e2b78d1a813470cc50ed39b" translate="yes" xml:space="preserve">
          <source>There is currently work in progress to make the runtime library free of GC heap allocations, to allow its use in scenarios where the use of GC infrastructure is not possible.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d933b4164fe170e150ab2367873a597423583d2" translate="yes" xml:space="preserve">
          <source>There is no more need to translate error codes into human readable strings, the correct string is generated by the error detection code, not the error recovery code. This also leads to consistent error messages for the same error between applications.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f17b623fe683ff68f6ed189b8d0d74d5452c95d7" translate="yes" xml:space="preserve">
          <source>There is no overload for &lt;code&gt;merge&lt;/code&gt; which takes a &lt;code&gt;NegInfInterval&lt;/code&gt;, because an interval going from negative infinity to positive infinity is not possible.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e26153f4d19858ed80c05ff7d79d4191b5074d49" translate="yes" xml:space="preserve">
          <source>There is no overload for &lt;code&gt;merge&lt;/code&gt; which takes a &lt;code&gt;PosInfInterval&lt;/code&gt;, because an interval going from negative infinity to positive infinity is not possible.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f100a7a77aee94633ec1e2fffc1096ce477240e" translate="yes" xml:space="preserve">
          <source>There is no overload for &lt;code&gt;span&lt;/code&gt; which takes a &lt;code&gt;NegInfInterval&lt;/code&gt;, because an interval going from negative infinity to positive infinity is not possible.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ac7b0e8d9f0ebf981b0a2590d75065c28e84b23" translate="yes" xml:space="preserve">
          <source>There is no overload for &lt;code&gt;span&lt;/code&gt; which takes a &lt;code&gt;PosInfInterval&lt;/code&gt;, because an interval going from negative infinity to positive infinity is not possible.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2973bc2fd6add6e6231856c6dedc987f0924540" translate="yes" xml:space="preserve">
          <source>There is no remove command functionality. Do a &lt;a href=&quot;#clearCommands&quot;&gt;&lt;code&gt;clearCommands&lt;/code&gt;&lt;/a&gt; and set the needed commands instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5030f2329ed730fd9eebd4cf5437fa2be5db1b38" translate="yes" xml:space="preserve">
          <source>There is no remove header functionality. Do a &lt;a href=&quot;#clearRequestHeaders&quot;&gt;&lt;code&gt;clearRequestHeaders&lt;/code&gt;&lt;/a&gt; and set the needed headers instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97b11eff895aae8a00d7fa461823417d322a76c8" translate="yes" xml:space="preserve">
          <source>There is no virtual table.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5dac0a061658caed895ea08b3637f43c40d7da9d" translate="yes" xml:space="preserve">
          <source>There is no volatile type modifier in D. To declare a C function that uses volatile, just drop the keyword from the declaration.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2434d329704768f135cc60da2cb84c7ba22ac13f" translate="yes" xml:space="preserve">
          <source>There is one exception to the fact that the new type is not related to the old type. &lt;a href=&quot;https://dlang.org/spec/function.html#pseudo-member&quot;&gt;Pseudo-member&lt;/a&gt; functions are usable with the new type; they will be forwarded on to the proxied value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba21f8033d033a747c90b386e1729af20f18ceb8" translate="yes" xml:space="preserve">
          <source>There may be multiple invariants in a class. They are applied in lexical order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a039cc903df4604c54902450e403871fe046481" translate="yes" xml:space="preserve">
          <source>There may be multiple invariants in a struct. They are applied in lexical order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d77d0c2b7a22ee08dcc65faf1983734627d5bea1" translate="yes" xml:space="preserve">
          <source>There may be one or more callable entities (&lt;code&gt;functions&lt;/code&gt; argument) to apply.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32ca8690590fc77f40e2a27fd064159d0d52468b" translate="yes" xml:space="preserve">
          <source>There must be at least one non-variadic parameter declared.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60b895f637fb0461c08aa3c29c276b9513bb30e3" translate="yes" xml:space="preserve">
          <source>There must be one &lt;a href=&quot;expression#AssignExpression&quot;&gt;&lt;i&gt;AssignExpression&lt;/i&gt;&lt;/a&gt; and it must evaluate at compile time to a function symbol.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed59ba7f34618cfcf4f2f62b488d49f3556f524b" translate="yes" xml:space="preserve">
          <source>There must be one &lt;a href=&quot;expression#AssignExpression&quot;&gt;&lt;i&gt;AssignExpression&lt;/i&gt;&lt;/a&gt; and it must evaluate at compile time to a string literal.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9800621b870999653a584633cd52d141e5fbaea7" translate="yes" xml:space="preserve">
          <source>There's only one instance of each module, and it is statically allocated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2acf8c215fcf96c4f44ab4510da81603fd6cc2b3" translate="yes" xml:space="preserve">
          <source>Therefore, it is the programmer's responsibility to ensure that &lt;code&gt;opCmp&lt;/code&gt; and &lt;code&gt;opEquals&lt;/code&gt; are consistent with each other. If &lt;code&gt;opEquals&lt;/code&gt; is not specified, the compiler provides a default version that does member-wise comparison. If this suffices, one may define only &lt;code&gt;opCmp&lt;/code&gt; to customize the behaviour of the inequality operators. But if not, then a custom version of &lt;code&gt;opEquals&lt;/code&gt; should be defined as well, in order to preserve consistent semantics between the two kinds of comparison operators.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6272f7f8273a14bd5544dddbcb1b98032093e68" translate="yes" xml:space="preserve">
          <source>These allow you to construct a &lt;code&gt;Duration&lt;/code&gt; from the given time units with the given length.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da7cf3cb33f506c60b3bae2d7621731fe8a25b5a" translate="yes" xml:space="preserve">
          <source>These are a temporary means of providing a GC hook for DLL use. They may be replaced with some other similar functionality later.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b408f5f827798e4336b44c606a3a8049fa5f385" translate="yes" xml:space="preserve">
          <source>These are convenience aliases for &lt;a href=&quot;std_digest#digest&quot;&gt;&lt;code&gt;std.digest.digest&lt;/code&gt;&lt;/a&gt; using the SHA implementation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc11c250252b92e0b68a712fc50db2f954bbf31e" translate="yes" xml:space="preserve">
          <source>These are found in Druntime's &lt;a href=&quot;https://github.com/dlang/druntime/blob/master/src/rt/&quot;&gt;rt/&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d82964c86f7448130324ef200af867ae90f45f65" translate="yes" xml:space="preserve">
          <source>These are mostly undocumented, as documentation for the functions these declarations provide bindings to can be found on external resources.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0b799b4059387b1ffa81eb5e832597a15aaf9ea" translate="yes" xml:space="preserve">
          <source>These are not directly overloadable, but instead are rewritten in terms of the ++</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="684251477ee92646066796884e053236894cc9d8" translate="yes" xml:space="preserve">
          <source>These are not to be conflated with atomic operations. They do not guarantee any atomicity. This may be provided by coincidence as a result of the instructions used on the target, but this should not be relied on for portable programs. Further, no memory fences are implied by these functions. They should not be used for communication between threads. They may be used to guarantee a write or read cycle occurs at a specified address.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ebd50df5a290d3b9f19a683a307dc1ce5e6fed02" translate="yes" xml:space="preserve">
          <source>These are of type &lt;code&gt;bool&lt;/code&gt; and when cast to another integral type become the values 1 and 0, respectively.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="812c2acf872ebe10657aaa2bbdf1807e2d587d11" translate="yes" xml:space="preserve">
          <source>These are presumably set by the command line as &lt;code&gt;-debug=&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47c1d2e1e32630d5e744bf290c6e49eb16fa04f9" translate="yes" xml:space="preserve">
          <source>These are presumably set by the command line as &lt;code&gt;-version=n&lt;/code&gt; and &lt;code&gt;-version=identifier&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2ddfd41f42add825e0e95354286885963260165" translate="yes" xml:space="preserve">
          <source>These are the return codes for the seek callbacks</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="402db899657981891e40b75b734371cded453058" translate="yes" xml:space="preserve">
          <source>These are the same kinds of scenarios where different optimization settings affect the results.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b6a4816df5dd7b7abf0b558eca9229ade75c78d" translate="yes" xml:space="preserve">
          <source>These arrays are statically allocated when they appear in global scope. Otherwise, they need to be marked with &lt;code&gt;const&lt;/code&gt; or &lt;code&gt;static&lt;/code&gt; storage classes to make them statically allocated arrays.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89a145122969b840110b2fc3e84b6ee09c611afa" translate="yes" xml:space="preserve">
          <source>These attributes may appear after the formal parameter list, in which case they apply either to a method's &lt;code&gt;this&lt;/code&gt; parameter, or to a free function's first parameter</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7f7fc51e48ac814a4df7b5cf79166bee33de381" translate="yes" xml:space="preserve">
          <source>These attributes may be inferred when the compiler has the function body available, such as with templates.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c92e5f8eec2fac65821b6ee901edef5b0d32346" translate="yes" xml:space="preserve">
          <source>These behaviors may be specified when a mailbox is full.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36131b1e9db1f47f4a6ae00babc38af51f8234a5" translate="yes" xml:space="preserve">
          <source>These characters are not normally used in isolation unless they are being described. They include such characters as accents, diacritics, Hebrew points, Arabic vowel signs, and Indic matras.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5af07f8dc23a2ff314c5b53d75ac93fc8390edf4" translate="yes" xml:space="preserve">
          <source>These compound format specifiers may be nested in the case of a nested array argument:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="636ef2d434aea6975bee7e2e69eaea244d21ce1f" translate="yes" xml:space="preserve">
          <source>These constraints are addressed by techniques outlined in &lt;a href=&quot;https://wiki.dlang.org/Memory_Management&quot;&gt;Memory Management&lt;/a&gt;, including the mechanisms provided by D to control allocations outside the GC heap.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce5525a7da98014873ce5f20228128913e88d54f" translate="yes" xml:space="preserve">
          <source>These declarations are transformed into templates:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd87aa675633720f30baafcf6365c73aa7dc6850" translate="yes" xml:space="preserve">
          <source>These directories are recognized by some tools, like the Objective-C compiler and linker, to be frameworks. To link with a framework from DMD, use the following flags:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2db5010283f3eff8277b4bb683d65dd36da0605f" translate="yes" xml:space="preserve">
          <source>These enums are for use with the CURLOPT_HTTP_VERSION option.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66b51419f8ca45e5302436f93fca4afec04366fd" translate="yes" xml:space="preserve">
          <source>These enums are for use with the CURLOPT_NETRC option.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="792d4e3a997f4a55954321b6a67c17e920eebf88" translate="yes" xml:space="preserve">
          <source>These equivalents hold for most C compilers. The C standard does not pin down the sizes of the types, so some care is needed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd5b42710c6e5261013fdb1ae53fc4cbc41fd9bf" translate="yes" xml:space="preserve">
          <source>These equivalents hold when the D and C++ compilers used are companions on the host platform.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90ade43ed5cb1a3092e67126f0f81a88dfd49b38" translate="yes" xml:space="preserve">
          <source>These extensions can be pretty-printed by &lt;a href=&quot;http://www.digitalmars.com/ctg/obj2asm.html&quot;&gt;obj2asm&lt;/a&gt;. The &lt;a href=&quot;http://ddbg.mainia.de/releases.html&quot;&gt;Ddbg&lt;/a&gt; debugger supports them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad13d21d22689769fb2cd4c608e9e8fc232324fc" translate="yes" xml:space="preserve">
          <source>These field were added in CURLVERSION_FOURTH. Same as 'libiconv_version' if built with HAVE_ICONV</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="507497a0514f5bd17890a554cbbbf16c831493b7" translate="yes" xml:space="preserve">
          <source>These flags can be bitwise OR-ed together to represent a complex attribute.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0046ed397526fe785a54f9113f894289f9d20106" translate="yes" xml:space="preserve">
          <source>These flags can be bitwise OR-ed together to represent complex storage class.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91bde2af8a3dc4b91f2f8c73ebb091513ee7a69a" translate="yes" xml:space="preserve">
          <source>These flags can be set/reset via the functions in &lt;code&gt;core.stdc.fenv&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10b77f7a0eebb3e7a656fbdfd23d4cee9e1bc0e6" translate="yes" xml:space="preserve">
          <source>These flags indicate that an exceptional floating-point condition has occurred. They indicate that a NaN or an infinity has been generated, that a result is inexact, or that a signalling NaN has been encountered. If floating-point exceptions are enabled (unmasked), a hardware exception will be generated instead of setting these flags.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e250dcdba1c724b4c5950d43225e8f190c1411c5" translate="yes" xml:space="preserve">
          <source>These functions allow getting and setting the OS scheduling priority of the worker threads in this &lt;code&gt;TaskPool&lt;/code&gt;. They forward to &lt;code&gt;core.thread.Thread.priority&lt;/code&gt;, so a given priority value here means the same thing as an identical priority value in &lt;code&gt;core.thread&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="563010f17028868ed8865c10ee72ad70b45bdc1f" translate="yes" xml:space="preserve">
          <source>These functions allow the creation of &lt;code&gt;Task&lt;/code&gt; objects on the stack rather than the GC heap. The lifetime of a &lt;code&gt;Task&lt;/code&gt; created by &lt;code&gt;scopedTask&lt;/code&gt; cannot exceed the lifetime of the scope it was created in.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c3aa616b64e71a662b37e0ffc58b47e53c7d7a0" translate="yes" xml:space="preserve">
          <source>These functions are defined by</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64a3eca56341ef165f9199f2a7eb38f22c9f31d6" translate="yes" xml:space="preserve">
          <source>These functions are only available if &lt;code&gt;hasPeek!T&lt;/code&gt; is true.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca1095cd637088fb9ac4b341f976f96ce873e4a7" translate="yes" xml:space="preserve">
          <source>These functions are only supported on POSIX platforms, as the Windows operating systems do not provide the ability to overwrite the current process image with another. In single-threaded programs it is possible to approximate the effect of &lt;code&gt;execv*&lt;/code&gt; by using &lt;a href=&quot;#spawnProcess&quot;&gt;&lt;code&gt;spawnProcess&lt;/code&gt;&lt;/a&gt; and terminating the current process once the child process has returned. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="536f51437dc16a03b75f3b412228393928fdac5c" translate="yes" xml:space="preserve">
          <source>These functions are recognized by the compiler, and calls to them are guaranteed to not be removed (as dead assignment elimination or presumed to have no effect) or reordered in the same thread.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1689bc1bc5afab34bd94fef9d049d296d24218eb" translate="yes" xml:space="preserve">
          <source>These functions find the first occurrence of &lt;code&gt;needle&lt;/code&gt; in &lt;code&gt;haystack&lt;/code&gt; and then split &lt;code&gt;haystack&lt;/code&gt; as follows.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b1cfbf3893f882218472af28278eb2e9814bf0e" translate="yes" xml:space="preserve">
          <source>These functions may be used for computing arbitrary extrema by choosing &lt;code&gt;pred&lt;/code&gt; appropriately. For corrrect functioning, &lt;code&gt;pred&lt;/code&gt; must be a strict partial order, i.e. transitive (if &lt;code&gt;pred(a, b) &amp;amp;&amp;amp; pred(b, c)&lt;/code&gt; then &lt;code&gt;pred(a, c)&lt;/code&gt;) and irreflexive (&lt;code&gt;pred(a, a)&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e60755fe688a68024196bc269a7db2354557a4c9" translate="yes" xml:space="preserve">
          <source>These functions may be used for computing arbitrary extrema by choosing &lt;code&gt;pred&lt;/code&gt; appropriately. For corrrect functioning, &lt;code&gt;pred&lt;/code&gt; must be a strict partial order, i.e. transitive (if &lt;code&gt;pred(a, b) &amp;amp;&amp;amp; pred(b, c)&lt;/code&gt; then &lt;code&gt;pred(a, c)&lt;/code&gt;) and irreflexive (&lt;code&gt;pred(a, a)&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;). The trichotomy property of inequality is not required: these algoritms consider elements &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; equal (for the purpose of counting) if &lt;code&gt;pred&lt;/code&gt; puts them in the same equivalence class, i.e. &lt;code&gt;!pred(a, b) &amp;amp;&amp;amp; !pred(b, a)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4885c55c8f009fc55e3ded5c636baed4e8b1027a" translate="yes" xml:space="preserve">
          <source>These functions must be defined for any D program linked against this library.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="863522dc2f55e2bd3557bec461908ee54bfe9148" translate="yes" xml:space="preserve">
          <source>These functions substitute for dynamic_cast. dynamic_cast does not work on earlier versions of gcc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6f52bdfe03bd9c3b6aa669ea2216cab6aa5652c" translate="yes" xml:space="preserve">
          <source>These functions will, when possible, do the load/store as a single operation. In general, this is possible when the size of the operation is less than or equal to &lt;code&gt;(void*).sizeof&lt;/code&gt;, although some targets may support larger operations. If the load/store cannot be done as a single operation, multiple smaller operations will be used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa2712a3447962365aa53a08ef19b228a050bafc" translate="yes" xml:space="preserve">
          <source>These interfaces are intended to provide virtual function-based wrappers around input ranges with element type E. This is useful where a well-defined binary interface is required, such as when a DLL function or virtual function needs to accept a generic range as a parameter. Note that &lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;isInputRange&lt;/a&gt; and friends check for conformance to structural interfaces not for implementation of these &lt;code&gt;interface&lt;/code&gt; types.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7b0ea076cc1a10005c1bfd351e1967a3ff3876c" translate="yes" xml:space="preserve">
          <source>These interfaces are not capable of forwarding &lt;code&gt;ref&lt;/code&gt; access to elements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8fa26313291d5018e0a3e59f0f8f336286abcb0a" translate="yes" xml:space="preserve">
          <source>These issues also apply to appending arrays with the ~= operator. Concatenation using the ~ operator is not affected since it always reallocates.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9ff0eb99086639c464f06ffda166431e591559b" translate="yes" xml:space="preserve">
          <source>These members are populated when one of the following functions are called successfully:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e69f6a6ea64238818e57857e50d3b4e6fac28582" translate="yes" xml:space="preserve">
          <source>These methods return &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2f532d1b48edcd9143f50919e4b67ad8068e5c5" translate="yes" xml:space="preserve">
          <source>These policies may be used alone, e.g. &lt;code&gt;Checked!(uint, WithNaN)&lt;/code&gt; defines a &lt;code&gt;uint&lt;/code&gt;-like type that reaches a stable NaN state for all erroneous operations. They may also be &quot;stacked&quot; on top of each other, owing to the property that a checked integral emulates an actual integral, which means another checked integral can be built on top of it. Some combinations of interest include:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7368ecff3f3d439be72be4fcfde0947c1e9f8e58" translate="yes" xml:space="preserve">
          <source>These prefix instructions do not appear in the same statement as the instructions they prefix; they appear in their own statement. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9636b646d702390220bc4fa38bc7bba209069d1d" translate="yes" xml:space="preserve">
          <source>These properties can be used to set and get this &lt;code&gt;Logger&lt;/code&gt;. Every modification to this &lt;code&gt;Logger&lt;/code&gt; will only be visible in the thread the modification has been done from.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0c185c1fb708b1056aa4da779b1949039005b7f" translate="yes" xml:space="preserve">
          <source>These properties control whether the worker threads are daemon threads. A daemon thread is automatically terminated when all non-daemon threads have terminated. A non-daemon thread will prevent a program from terminating as long as it has not terminated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15376758dabe755dcb87d082399d9c18e9269e9e" translate="yes" xml:space="preserve">
          <source>These properties get and set the number of worker threads in the &lt;code&gt;TaskPool&lt;/code&gt; instance returned by &lt;code&gt;taskPool&lt;/code&gt;. The default value is &lt;code&gt;totalCPUs&lt;/code&gt; - 1. Calling the setter after the first call to &lt;code&gt;taskPool&lt;/code&gt; does not changes number of worker threads in the instance returned by &lt;code&gt;taskPool&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="980ecd42d3382da4165c5745d3e514950a686c39" translate="yes" xml:space="preserve">
          <source>These pseudo ops are for inserting raw data directly into the code. &lt;code&gt;db&lt;/code&gt; is for bytes, &lt;code&gt;ds&lt;/code&gt; is for 16 bit words, &lt;code&gt;di&lt;/code&gt; is for 32 bit words, &lt;code&gt;dl&lt;/code&gt; is for 64 bit words, &lt;code&gt;df&lt;/code&gt; is for 32 bit floats, &lt;code&gt;dd&lt;/code&gt; is for 64 bit doubles, and &lt;code&gt;de&lt;/code&gt; is for 80 bit extended reals. Each can have multiple operands. If an operand is a string literal, it is as if there were</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc738e7762e036039780916cbdd5404d3269d8a0" translate="yes" xml:space="preserve">
          <source>These reordering guarantees are only made with regards to other operations done through these functions; the compiler is free to reorder regular loads/stores with regards to loads/stores done through these functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59c337390b522d2f745f8ff19e4af335466b8d80" translate="yes" xml:space="preserve">
          <source>These rules exist to ensure that D source code can be tokenized independently of syntactic or semantic analysis.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c76e41e867d53b374fa782852a104df9aca82b4" translate="yes" xml:space="preserve">
          <source>These tokens are replaced with other tokens according to the following table:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0bdde0a231ee1346d31198eca44ed30c45d180a" translate="yes" xml:space="preserve">
          <source>These two functions are publicly imported by &lt;a href=&quot;std_string&quot;&gt;&lt;code&gt;std.string&lt;/code&gt;&lt;/a&gt; to be easily available.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d116b35a1d1eb38f8d6deaebff517f7281edce29" translate="yes" xml:space="preserve">
          <source>These two methods set and get the &lt;code&gt;LogLevel&lt;/code&gt; of the used &lt;code&gt;Logger&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c31bee48bf9882a765ab31f12d60d8852693f17b" translate="yes" xml:space="preserve">
          <source>These two were added to Bionic in Lollipop.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51b1a7127ec2cda2b11c1f4d950a66756e0a424a" translate="yes" xml:space="preserve">
          <source>These types and operations will be the ones defined for the architecture the compiler is targeting. If a particular CPU family has varying support for vector types, an additional runtime check may be necessary. The compiler does not emit runtime checks; those must be done by the programmer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f060e83954cb7bb657a24fc206a36f49a7d93ba" translate="yes" xml:space="preserve">
          <source>These variadic functions have a special local variable declared for them, &lt;code&gt;_argptr&lt;/code&gt;, which is a &lt;code&gt;core.vararg&lt;/code&gt; reference to the first of the variadic arguments. To access the arguments, &lt;code&gt;_argptr&lt;/code&gt; must be used in conjuction with &lt;code&gt;va_arg&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="234027e68858253217a4940ca8276de49e1921e6" translate="yes" xml:space="preserve">
          <source>They cannot be accessed directly, but can be when converted to an array type:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="221e10b06207df21853c30ac081dc011d76ee4a6" translate="yes" xml:space="preserve">
          <source>Things that are reliable and can be done:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c0e4517dcdbca852a34fee2578fdfec0c6193f9" translate="yes" xml:space="preserve">
          <source>This 6-digit (24 bits) hexadecimal number does not show pre-release number, and it is always a greater number in a more recent release. It makes comparisons with greater than and less than work.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="229cd848f340b1059ab841306649066eb2235f02" translate="yes" xml:space="preserve">
          <source>This &lt;a href=&quot;https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Miscellaneous/Foundation_Functions/index.html#//apple_ref/c/func/NSLog&quot;&gt;&lt;code&gt;NSLog&lt;/code&gt;&lt;/a&gt; function prints a message to the System Log facility, i.e. to stderr and Console.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3784623518bf5135672133e5b2128ce4da1e03a" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;Logger&lt;/code&gt; implementation writes log messages to the associated file. The name of the file has to be passed on construction time. If the file is already present new log messages will be append at its end.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="713e6c7267281da115b32a479fb632b10a4676bf" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;Logger&lt;/code&gt; is called by the free standing log functions. This allows to create thread local redirections and still use the free standing log functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1905487aa2f3222c1f92ca85d42ee6ef82cec0b" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;delegate&lt;/code&gt; is called in case a log message with &lt;code&gt;LogLevel.fatal&lt;/code&gt; gets logged.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="742a25561151a973ba133d1f0c2d43dea4909a81" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;enum&lt;/code&gt; is used as a template argument to functions which compare file names, and determines whether the comparison is case sensitive or not.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b6a1b7ec8e15b4671a0723320a6b157081a9b40" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;enum&lt;/code&gt; is used to select the primitives of the range to handle by the &lt;a href=&quot;#handle&quot;&gt;&lt;code&gt;handle&lt;/code&gt;&lt;/a&gt; range wrapper. The values of the &lt;code&gt;enum&lt;/code&gt; can be &lt;code&gt;OR&lt;/code&gt;'d to select multiple primitives to be handled.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60302f8f7437eabfe1118a9f0d4373fe741b982e" translate="yes" xml:space="preserve">
          <source>This &lt;strong id=&quot;opBinary&quot;&gt;opBinary&lt;/strong&gt;(string op, U)(U rhs)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0844f4e216523548601b41cd5d7151c085ad2d4f" translate="yes" xml:space="preserve">
          <source>This Element is stored inside the &lt;code&gt;MultiLogger&lt;/code&gt; and associates a &lt;code&gt;Logger&lt;/code&gt; to a &lt;code&gt;string&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f3ba7f1176ff2dafbb0e0f64e80accd29320699" translate="yes" xml:space="preserve">
          <source>This Exception is thrown if something goes wrong when encoding or decoding a URI.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f52bee84df158d351adbe607d7ed92c29a830ca" translate="yes" xml:space="preserve">
          <source>This access can span multiple nesting levels:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b73948545ca0a17466100c56872304c05fd8262" translate="yes" xml:space="preserve">
          <source>This advice applies only to static references or references embedded inside other objects. There is not much point for such stored on the stack to be nulled because new stack frames are initialized anyway.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b180cae02977110add927a1c4e0c64f40292d64f" translate="yes" xml:space="preserve">
          <source>This algorithm is lazy, doing work progressively as elements are pulled off the result.  Time complexity is proportional to the sum of element counts over all inputs.  If all inputs have the same element type and offer it by &lt;code&gt;ref&lt;/code&gt;, output becomes a range with mutable &lt;code&gt;front&lt;/code&gt; (and &lt;code&gt;back&lt;/code&gt; where appropriate) that reflects in the original inputs.  If any of the inputs &lt;code&gt;rs&lt;/code&gt; is infinite so is the result (&lt;code&gt;empty&lt;/code&gt; being always &lt;code&gt;false&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17ac7dad87e44aee326cfad5b437dc8fb209353e" translate="yes" xml:space="preserve">
          <source>This allocator sits on top of &lt;code&gt;ParentAllocator&lt;/code&gt; and quantizes allocation sizes, usually from arbitrary positive numbers to a small set of round numbers (e.g. powers of two, page sizes etc). This technique is commonly used to:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c92308ef13d80d3dc1f8f963c2ddd3981e8c6bde" translate="yes" xml:space="preserve">
          <source>This allows you to construct a &lt;code&gt;TickDuration&lt;/code&gt; from the given time units with the given length.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75add17a5265c1c86eea3c10773eb85a2a082611" translate="yes" xml:space="preserve">
          <source>This also checks if T passes &lt;a href=&quot;#isDigest&quot;&gt;&lt;code&gt;isDigest&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21d1b39871e7f1893df45ac1736d0defe8bdb68b" translate="yes" xml:space="preserve">
          <source>This approach to sorting is akin to the &lt;a href=&quot;http://wikipedia.org/wiki/Schwartzian_transform&quot;&gt;Schwartzian transform&lt;/a&gt;, also known as the decorate-sort-undecorate pattern in Python and Lisp. The complexity is the same as that of the corresponding &lt;code&gt;sort&lt;/code&gt;, but &lt;code&gt;schwartzSort&lt;/code&gt; evaluates &lt;code&gt;transform&lt;/code&gt; only &lt;code&gt;r.length&lt;/code&gt; times (less than half when compared to regular sorting). The usage can be best illustrated with an example.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d88f963aa92f920cdc8aeb7a00bc154db20bbb5" translate="yes" xml:space="preserve">
          <source>This array can be used by a precise GC to avoid false pointers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c35154b2193fa21859ceac41f1d4b9a67330be66" translate="yes" xml:space="preserve">
          <source>This attack can also be mitigated via rate limiting and banning IPs which have too many rejected requests. However, this does not completely solve the problem, as the attacker could be in control of a bot net. To fully defend against the timing attack, rate limiting, banning IPs, and using this function should be used together.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a9127e0dd3d0b5214532b99c1123e71d947a773" translate="yes" xml:space="preserve">
          <source>This binary operator returns a narrower, built-in integer type where applicable, according to the following table.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37d90ec49bcad1514fffff07ef5725f0a4ce3b52" translate="yes" xml:space="preserve">
          <source>This block contains the info to allow appending.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf616d2c8bb18a1f79e9b94bb01fac01a9f85e97" translate="yes" xml:space="preserve">
          <source>This block is guaranteed to have a pointer to its base while it is alive. Interior pointers can be safely ignored. This attribute is useful for eliminating false pointers in very large data structures and is only implemented for data structures at least a page in size.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf3bcec7830ceded3b9368b09e74254cb38823f2" translate="yes" xml:space="preserve">
          <source>This breaks a type down into 'simpler' types that can be passed to a function in registers, and returned in registers. It's highly platform dependent.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8f37b58b4d0486e147bae447382fe4c40e89ace" translate="yes" xml:space="preserve">
          <source>This breaks a type down into 'simpler' types that can be passed to a function in registers, and returned in registers. This is the implementation for the x86_64 System V ABI (not used for Win64), based on &lt;a href=&quot;https://www.uclibc.org/docs/psABI-x86_64.pdf.&quot;&gt;https://www.uclibc.org/docs/psABI-x86_64.pdf.&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0bd70fd848ca13dea85fa0c9ed45a1bd7458ccab" translate="yes" xml:space="preserve">
          <source>This can be a useful function to place in a chain, after functions that have expensive evaluation, as a lazy alternative to &lt;a href=&quot;std_array#array&quot;&gt;&lt;code&gt;std.array.array&lt;/code&gt;&lt;/a&gt;. In particular, it can be placed after a call to &lt;a href=&quot;#map&quot;&gt;&lt;code&gt;map&lt;/code&gt;&lt;/a&gt;, or before a call &lt;a href=&quot;std_range#filter&quot;&gt;&lt;code&gt;std.range.filter&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;std_range#tee&quot;&gt;&lt;code&gt;std.range.tee&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b2e989aa67544fd1198815cd532b63a0f766b8f" translate="yes" xml:space="preserve">
          <source>This can be faster than &lt;code&gt;line = File.readln()&lt;/code&gt; because you can reuse the buffer for each call. Note that reusing the buffer means that you must copy the previous contents if you wish to retain them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9135461de3ded4b1c69a8c8663d6dc1b7b1298f3" translate="yes" xml:space="preserve">
          <source>This can be faster than &lt;code&gt;line = readln()&lt;/code&gt; because you can reuse the buffer for each call. Note that reusing the buffer means that you must copy the previous contents if you wish to retain them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a112b2327f090d0fc1bf3af12645c6807ea32f38" translate="yes" xml:space="preserve">
          <source>This can be used to manually allocate arrays. Initial slice size is 0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77b164cf465602d02b3ffc40b53faf3928b97c45" translate="yes" xml:space="preserve">
          <source>This can be used to restore the state set by &lt;code&gt;_init&lt;/code&gt; to its original state.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd9b6c28efb844ef78e5e1874ec7103f9aedb900" translate="yes" xml:space="preserve">
          <source>This can be used to restore the state set by &lt;code&gt;builtin_init&lt;/code&gt; to its original state.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf855a97cfb23a3029962fde96c07063d751f784" translate="yes" xml:space="preserve">
          <source>This can be used to restore the state set by &lt;code&gt;initDMD&lt;/code&gt; to its original state. Useful if there's a need for multiple sessions of the DMD compiler in the same application.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b9d5f27029fa9824ee5b1d78b90c2ec7ef5fd1e" translate="yes" xml:space="preserve">
          <source>This can be used to restore the state set by &lt;code&gt;initialize&lt;/code&gt; to its original state.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab6e2c03932762345b65936a6392947f9f7fc40e" translate="yes" xml:space="preserve">
          <source>This causes the array to be reallocated in place, and the existing contents copied over to the new array. If the new array length is shorter, the array is not reallocated, and no data is copied. It is equivalent to slicing the array:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2dc8c51a26f6ef694173726a55aa90d7d6530cc8" translate="yes" xml:space="preserve">
          <source>This class can be considered a mutex in its own right, and is used to negotiate a read lock for the enclosing mutex.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c087ce5411ffc17188818ec319892aeaf2de87df" translate="yes" xml:space="preserve">
          <source>This class can be considered a mutex in its own right, and is used to negotiate a write lock for the enclosing mutex.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6fa3f3a70f061e4c741e7043e9f128e38434b5c" translate="yes" xml:space="preserve">
          <source>This class contains only static methods, and cannot be instantiated. See below for examples of use.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e74dd67572321fcf836dd082da1156043102db48" translate="yes" xml:space="preserve">
          <source>This class encapsulates a task queue and a set of worker threads. Its purpose is to efficiently map a large number of &lt;code&gt;Task&lt;/code&gt;s onto a smaller number of threads. A task queue is a FIFO queue of &lt;code&gt;Task&lt;/code&gt; objects that have been submitted to the &lt;code&gt;TaskPool&lt;/code&gt; and are awaiting execution. A worker thread is a thread that executes the &lt;code&gt;Task&lt;/code&gt; at the front of the queue when one is available and sleeps when the queue is empty.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb7ed7def5fa337d461b92cc10d68f83905440de" translate="yes" xml:space="preserve">
          <source>This class encapsulates all threading functionality for the D programming language. As thread manipulation is a required facility for garbage collection, all user threads should derive from this class, and instances of this class should never be explicitly deleted. A new thread may be created using either derivation or composition, as in the following example.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="060824159317cc2ae0b94150653daf83c3c520fb" translate="yes" xml:space="preserve">
          <source>This class is Windows-Only.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74950bb501f7c21fc01a4eeb41b151e182fd4b25" translate="yes" xml:space="preserve">
          <source>This class is intended to simplify certain common programming techniques.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23197b76b4ee940fb447d39ecd365edbbb4617e7" translate="yes" xml:space="preserve">
          <source>This class is the base of every logger. In order to create a new kind of logger a deriving class needs to implement the &lt;code&gt;writeLogMsg&lt;/code&gt; method. By default this is not thread-safe.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5087e482a877ae3c12085be27794a8883c7a901f" translate="yes" xml:space="preserve">
          <source>This class provides a cooperative concurrency mechanism integrated with the threading and garbage collection functionality. Calling a fiber may be considered a blocking operation that returns when the fiber yields (via Fiber.yield()). Execution occurs within the context of the calling thread so synchronization is not necessary to guarantee memory visibility so long as the same thread calls the fiber each time. Please note that there is no requirement that a fiber be bound to one specific thread. Rather, fibers may be freely passed between threads so long as they are not currently executing. Like threads, a new fiber thread may be created using either derivation or composition, as in the following example.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82a75ec7718c8b6f47e4366c93dbe98cf77e29de" translate="yes" xml:space="preserve">
          <source>This class represents a barrier across which threads may only travel in groups of a specific size.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="766ad20f64361ee3b240dfaf608ee851aeb433ae" translate="yes" xml:space="preserve">
          <source>This class represents a condition variable as conceived by C.A.R. Hoare. As per Mesa type monitors however, &quot;signal&quot; has been replaced with &quot;notify&quot; to indicate that control is not transferred to the waiter when a notification is sent.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ebd970226df03dbe75e13571a9e96c6ff81d3f8" translate="yes" xml:space="preserve">
          <source>This class represents a general counting semaphore as concieved by Edsger Dijkstra. As per Mesa type monitors however, &quot;signal&quot; has been replaced with &quot;notify&quot; to indicate that control is not transferred to the waiter when a notification is sent.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8cd845734952865e5a8f06563815740028af34a" translate="yes" xml:space="preserve">
          <source>This class represents a general purpose, recursive mutex.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59a28f2816234c02947ecfa7c34d28fcd7aff787" translate="yes" xml:space="preserve">
          <source>This class represents a mutex that allows any number of readers to enter, but when a writer enters, all other readers and writers are blocked.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="869079d3acf8bad41ab545f5cd5b6ff38c3d966c" translate="yes" xml:space="preserve">
          <source>This class should usually be used via the global instantiation available via the &lt;a href=&quot;std_parallelism#taskPool&quot;&gt;&lt;code&gt;std.parallelism.taskPool&lt;/code&gt;&lt;/a&gt; property. Occasionally it is useful to explicitly instantiate a &lt;code&gt;TaskPool&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67a778401b8293f4ab050d1d10ec2027dc2c3143" translate="yes" xml:space="preserve">
          <source>This class uses a high-performance counter. On Windows systems, it uses &lt;code&gt;QueryPerformanceCounter&lt;/code&gt;, and on Posix systems, it uses &lt;code&gt;clock_gettime&lt;/code&gt; if available, and &lt;code&gt;gettimeofday&lt;/code&gt; otherwise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aaa98a68eef2ad7cd1dc56f0e12cad2e4ff0ed1d" translate="yes" xml:space="preserve">
          <source>This code handles backtrace generation using DWARF debug_line section in ELF and Mach-O files for Posix.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6140309682aaa69b6ff498f8a25796d0edfd215e" translate="yes" xml:space="preserve">
          <source>This code handles decoding UTF strings for foreach loops. There are 6 combinations of conversions between char, wchar, and dchar, and 2 of each of those.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="982470496432064145436b3b7c81c481f591fd15" translate="yes" xml:space="preserve">
          <source>This code handles decoding UTF strings for foreach_reverse loops. There are 6 combinations of conversions between char, wchar, and dchar, and 2 of each of those.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e76eacdedc4fa73ee336ac22c18ef834f35805af" translate="yes" xml:space="preserve">
          <source>This code reads ELF files and sections using memory mapped IO.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db89b4b4bb5b2f93ea6d6ff02b4131b5059932ab" translate="yes" xml:space="preserve">
          <source>This combining of the environment and the function is called a</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f04a03c616b5e70e398965fd9e6bb2d3b0919b13" translate="yes" xml:space="preserve">
          <source>This command-line parameter does not affect custom unit test handlers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="230aa360bfc55c5cf21e968f489f8b1241790aa2" translate="yes" xml:space="preserve">
          <source>This compile-time flag is &lt;code&gt;true&lt;/code&gt; if logging is not statically disabled.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d82eb07cfddf77181a4fa8aca621ce6591fd7ca9" translate="yes" xml:space="preserve">
          <source>This constructor is only called when we figured out which function template to instantiate.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa95214feed626f5e6eebb5c6959ff1d8bcafc67" translate="yes" xml:space="preserve">
          <source>This constructor is the inverse of &lt;a href=&quot;#opCast&quot;&gt;&lt;code&gt;opCast&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8fcfb06ab6c25d2bbe46e5cfe782e5b576ac2d4" translate="yes" xml:space="preserve">
          <source>This contains the copyright notice. The macro COPYRIGHT is set to the contents of the section when it documents the module declaration. The copyright section only gets this special treatment when it is for the module declaration.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="822ca8d08b221bc29495c95da9984e8cee76c282" translate="yes" xml:space="preserve">
          <source>This convenience method alleviates the need to manually manage decoding buffers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf045283f89baa3e44e42e507f01aa06b96bde31" translate="yes" xml:space="preserve">
          <source>This convenience method alleviates the need to manually manage output buffers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16b88e43157a2f6f2c5142b90b7d5fe45695bbef" translate="yes" xml:space="preserve">
          <source>This created a new Fiber for the supplied op and adds it to the dispatch list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fdc94e4392e59112302f3c3212c7174cb2489e38" translate="yes" xml:space="preserve">
          <source>This creates a new Fiber for the supplied op and then starts the dispatcher.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af45f3f128eb584feb53ad796c2bd75a57d5180c" translate="yes" xml:space="preserve">
          <source>This defines a new type &lt;code&gt;X&lt;/code&gt; which has values &lt;code&gt;X.A=0&lt;/code&gt;, &lt;code&gt;X.B=1&lt;/code&gt;, &lt;code&gt;X.C=2&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d27799b2bf9fed9292a027676e909387c978ddb" translate="yes" xml:space="preserve">
          <source>This definition of mutable functions is more general than the one traditionally employed by pure functional languages because it allows a D pure function to use state mutation, as long as all state is created internally or reachable through its arguments. In particular, a pure function may allocate memory by means of e.g. &lt;code&gt;new&lt;/code&gt; or &lt;code&gt;malloc&lt;/code&gt; without these being special cases. A pure function is allowed to loop indefinitely or terminate the program.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="524100fdceb69609090212fc4caf6a68ca169c00" translate="yes" xml:space="preserve">
          <source>This deletes the key e1 from the associative array e2</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e594f9c668086e01075383fb67708b16f0e2344d" translate="yes" xml:space="preserve">
          <source>This describes the OOP API. To understand when to use the template API and when to use the OOP API, see the module documentation at the top of this page.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3007dc64e992f88997b93bf75939ee91b3bf45cf" translate="yes" xml:space="preserve">
          <source>This document describes the &lt;code&gt;x86&lt;/code&gt; and &lt;code&gt;x86_64&lt;/code&gt; implementations of the inline assembler. The inline assembler platform support that a compiler provides is indicated by the &lt;code&gt;D_InlineAsm_X86&lt;/code&gt; and &lt;code&gt;D_InlineAsm_X86_64&lt;/code&gt; version identifiers, respectively.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="569cf1450215141639c3396e75fe3e0e30e8cd78" translate="yes" xml:space="preserve">
          <source>This document is the reference manual for the D Programming Language. For more information and other documents, see &lt;a href=&quot;https://dlang.org/&quot;&gt;The D Language Website&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b76c1da48d91edda64500d21af760a6ce3c2286" translate="yes" xml:space="preserve">
          <source>This document specifies how to interface with C++ directly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4eaa9b84c7822b2e3e77fa7e5df36263689f6cc9" translate="yes" xml:space="preserve">
          <source>This documents the general structure of a Digest in the template API. All digest implementations should implement the following members and therefore pass the &lt;a href=&quot;#isDigest&quot;&gt;&lt;code&gt;isDigest&lt;/code&gt;&lt;/a&gt; test.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac0dd62d84db23b0de6fee189b1020c75493d355" translate="yes" xml:space="preserve">
          <source>This does not assign the pointer of &lt;code&gt;rhs&lt;/code&gt; to this &lt;code&gt;RefRange&lt;/code&gt;. Rather it assigns the range pointed to by &lt;code&gt;rhs&lt;/code&gt; to the range pointed to by this &lt;code&gt;RefRange&lt;/code&gt;. This is because</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e81812302527d63ee87960159e6a1b9dd25fb020" translate="yes" xml:space="preserve">
          <source>This does not include any time during which the StopWatch was stopped but does include</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c432390e6bbf7d9fb981f314323bac09cd4ec391" translate="yes" xml:space="preserve">
          <source>This does not mean, however, that one can change the data:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d63844eee394540a61e05092a78018f8dcdacad" translate="yes" xml:space="preserve">
          <source>This doesn't include '\n', '\r', \t' and other non-space &lt;a href=&quot;#Character&quot;&gt;character&lt;/a&gt;. For commonly used less strict semantics see &lt;a href=&quot;#isWhite&quot;&gt;&lt;code&gt;isWhite&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b899c5918773ae82ab7898c96cd3e0a68f5b5e5e" translate="yes" xml:space="preserve">
          <source>This doesn't work for TLS memory, though.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="add950f77c9072c48dcd0ff96facedd547735caa" translate="yes" xml:space="preserve">
          <source>This easy handle has completed. 'result' contains the CURLcode of the transfer</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef5d8951fd69c70c7d61e2bd1231248df49b6d3e" translate="yes" xml:space="preserve">
          <source>This example creates a DOM (Document Object Model) tree from an XML file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74ec60c9c14341e9d9e5373aa773d98804f76f30" translate="yes" xml:space="preserve">
          <source>This example does much the same thing, except that the file is deconstructed and reconstructed by hand. This is more work, but the techniques involved offer vastly more power.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a4cbb05cb72419e58f855fffb51071ca39f119b" translate="yes" xml:space="preserve">
          <source>This example encodes the input data one byte at a time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="efc529b5b8a635fe0248f0e1b5570f3e5c62ec50" translate="yes" xml:space="preserve">
          <source>This example encodes the input one line at a time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="709f6883e08535336d0975187381366956732f0d" translate="yes" xml:space="preserve">
          <source>This example of template foo has a value parameter that is specialized for 10:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c7fc0bf8d7d58bae3c653e435da196f5834dccc" translate="yes" xml:space="preserve">
          <source>This example shows decoding one byte at a time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca9412e6a6a265cc25cdadaa2feca886b99350b4" translate="yes" xml:space="preserve">
          <source>This example shows decoding over a range of input data lines.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ca157dc5296c9dbda3b67885000d1a3d169c64b" translate="yes" xml:space="preserve">
          <source>This example uses a mixin to implement a generic Duff's device for an arbitrary statement (in this case, the arbitrary statement is in bold). A nested function is generated as well as a delegate literal, these can be inlined by the compiler:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9fd04b9d165e95a5b5d46f431bdbd8794b151b29" translate="yes" xml:space="preserve">
          <source>This example will create an Objective-C string, &lt;code&gt;NSString&lt;/code&gt;, and log the message using &lt;code&gt;NSLog&lt;/code&gt; to stderr.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b44fd2927053fecf7f02a805bef21a73969e7c8" translate="yes" xml:space="preserve">
          <source>This exception is thrown if an error occurs when parsing a UUID from a string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83cf2ca3dac976d4903c104f6cecb54eca32e9c0" translate="yes" xml:space="preserve">
          <source>This exists in order to find where &lt;code&gt;STC.maybescope&lt;/code&gt; is getting turned off.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec12e985e5f97029a4fdcc178a312496ababfe99" translate="yes" xml:space="preserve">
          <source>This fiber must be in state HOLD.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="050dfac3109c2719a43b56525c7b1b2f0f5442dd" translate="yes" xml:space="preserve">
          <source>This fiber must be in state TERM or HOLD.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8069d75e504b5df60eaae8b05121a6dfce90e592" translate="yes" xml:space="preserve">
          <source>This field has been deprecated. Please use &lt;code&gt;cacheLevels&lt;/code&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a88f12f8698a93effebf4b21ac2fcaaf1ed6557e" translate="yes" xml:space="preserve">
          <source>This field is populated when using &lt;a href=&quot;#csvReader&quot;&gt;&lt;code&gt;csvReader&lt;/code&gt;&lt;/a&gt; but not by &lt;a href=&quot;#csvNextToken&quot;&gt;&lt;code&gt;csvNextToken&lt;/code&gt;&lt;/a&gt; as this data will have already been fed to the output range.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00b3ae505bfa7b5877d4290b9bf62b73f3526eab" translate="yes" xml:space="preserve">
          <source>This field was added in CURLVERSION_THIRD</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ded4afb1457e0f04e1bc6ce625b9a154f7bfa729" translate="yes" xml:space="preserve">
          <source>This flag has no effect on &lt;a href=&quot;#spawnProcess&quot;&gt;&lt;code&gt;spawnProcess&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#spawnShell&quot;&gt;&lt;code&gt;spawnShell&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c7a11a8d6d19389f0abbac4fa34ba46bd07ad35" translate="yes" xml:space="preserve">
          <source>This function</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63a837cbc01e12716c2a63542540dfd3d20ec868" translate="yes" xml:space="preserve">
          <source>This function allocates memory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92814a3bf729ba0c96c36e96433e5f0d828849bd" translate="yes" xml:space="preserve">
          <source>This function allows user-defined subclasses of EncodingScheme to be declared in other modules.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="471f7413c5ebea16f57422410a8bf930e30c75d3" translate="yes" xml:space="preserve">
          <source>This function also decomposes hangul syllables as prescribed by the standard.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="534457dcd59761dcb843df10d6fcec190ed3b4c4" translate="yes" xml:space="preserve">
          <source>This function always allocates memory to hold the resulting path. The variadic overload is guaranteed to only perform a single allocation, as is the range version if &lt;code&gt;paths&lt;/code&gt; is a forward range.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd9256b25c3dea2b100b91fc151d4d49aa057003" translate="yes" xml:space="preserve">
          <source>This function always allocates memory to hold the resulting path. Use &lt;a href=&quot;#asNormalizedPath&quot;&gt;&lt;code&gt;asNormalizedPath&lt;/code&gt;&lt;/a&gt; to not allocate memory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="187779b43f44c34c6b32550dd282a3cd2f13a1e6" translate="yes" xml:space="preserve">
          <source>This function always allocates memory to hold the resulting path. Use &lt;a href=&quot;#buildNormalizedPath&quot;&gt;&lt;code&gt;buildNormalizedPath&lt;/code&gt;&lt;/a&gt; to allocate memory and return a string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="565ae089ae893ce04d0723fbc06da8efba3b5449" translate="yes" xml:space="preserve">
          <source>This function calls &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/windows/desktop/aa364439%28v=vs.85%29.aspx&quot;&gt;&lt;code&gt;FlushFileBuffers&lt;/code&gt;&lt;/a&gt; on Windows and &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/7908799/xsh/fsync.html&quot;&gt;&lt;code&gt;fsync&lt;/code&gt;&lt;/a&gt; on POSIX for the file handle.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8c2e50367d22c68b1ef6bf70b530cf16359f88a" translate="yes" xml:space="preserve">
          <source>This function can allocate if the &lt;code&gt;Yes.allocateGC&lt;/code&gt; flag is passed. This has the benefit of have better complexity than the &lt;code&gt;Yes.allocateGC&lt;/code&gt; option. However, this option is only available for ranges whose equality can be determined via each element's &lt;code&gt;toHash&lt;/code&gt; method. If customized equality is needed, then the &lt;code&gt;pred&lt;/code&gt; template parameter can be passed, and the function will automatically switch to the non-allocating algorithm. See &lt;a href=&quot;std_functional#binaryFun&quot;&gt;&lt;code&gt;std.functional.binaryFun&lt;/code&gt;&lt;/a&gt; for more details on how to define &lt;code&gt;pred&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b1f8d9be7c40727aeac47ccfd7444f517f04172" translate="yes" xml:space="preserve">
          <source>This function can be &lt;code&gt;@trusted&lt;/code&gt; if the corresponding constructor of &lt;code&gt;T&lt;/code&gt; is &lt;code&gt;@safe&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="287c25734ab50e3ae9a7c39776861bb5646f4c1c" translate="yes" xml:space="preserve">
          <source>This function can perform a case-sensitive or a case-insensitive comparison. This is controlled through the &lt;code&gt;cs&lt;/code&gt; template parameter which, if not specified, is given by &lt;a href=&quot;#CaseSensitive&quot;&gt;&lt;code&gt;CaseSensitive&lt;/code&gt;&lt;/a&gt;&lt;code&gt;.osDefault&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e873b6c5b5805640016d4214ee3463e370b995d" translate="yes" xml:space="preserve">
          <source>This function complies with &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/utilities/basename.html&quot;&gt; the POSIX requirements for the 'basename' shell utility&lt;/a&gt; (with suitable adaptations for Windows paths).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="271fe9a4358104e29e9baaf0f70ca7697a626f35" translate="yes" xml:space="preserve">
          <source>This function complies with &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/utilities/dirname.html&quot;&gt; the POSIX requirements for the 'dirname' shell utility&lt;/a&gt; (with suitable adaptations for Windows paths).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f911814cd134bf58a8ba7e68aae37ec618511b50" translate="yes" xml:space="preserve">
          <source>This function consumes the input. After each call the input will start with either a delimiter or record break (\n, \r\n, \r) which must be removed for subsequent calls.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82adca51d2d89c2e52168f23c5014dcf4b09b7e3" translate="yes" xml:space="preserve">
          <source>This function creates a complete DOM (Document Object Model) tree.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34f7e14685f9dc1d8824f48b2307f8cd989b3e43" translate="yes" xml:space="preserve">
          <source>This function decodes the entities &amp;amp;amp;, &amp;amp;quot;, &amp;amp;apos;, &amp;amp;lt; and &amp;amp;gt, as well as decimal and hexadecimal entities such as &amp;amp;#x20AC;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37bc9985a8792341b2d7a8d50dc7ab55bd1e93ad" translate="yes" xml:space="preserve">
          <source>This function defends against this attack by always comparing every single item in the array if the two arrays are the same length. Therefore, this function is always &amp;Omicron;(&lt;code&gt;n&lt;/code&gt;) for ranges of the same length.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07fbd70f1f7940fca06c0a8a3c74b8aabe9ac979" translate="yes" xml:space="preserve">
          <source>This function does not provide overloads for wstring and dstring, as there's no clear answer on how that should be implemented. It could be argued, that string, wstring and dstring input should have the same output, but that wouldn't be compatible with Boost, which generates different output for strings and wstrings. It's always possible to pass wstrings and dstrings by using the ubyte[] function overload (but be aware of endianness issues!).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7eab1a520623d1ac5e68ed2c102542d0c568c2a" translate="yes" xml:space="preserve">
          <source>This function encodes a single code point into one or more code units The code units are stored in a user-supplied fixed-size array, which must be passed by reference.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4dfecb064dc08682e5d5f6ff6e2a923d6c06c55" translate="yes" xml:space="preserve">
          <source>This function encodes a single code point into one or more code units. It returns a string containing those code units.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d23af3939d6f49cb27a211fdfb01f49551cd4f68" translate="yes" xml:space="preserve">
          <source>This function encodes a single code point into one or more code units. The code units are passed one at a time to the supplied delegate.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd5007482279246870e612a2f7b9d7848a9ec8a9" translate="yes" xml:space="preserve">
          <source>This function encodes a single code point into one or more ubytes. The supplied buffer must be code unit aligned. (For example, UTF-16LE or UTF-16BE must be wchar-aligned, UTF-32LE or UTF-32BE must be dchar-aligned, etc.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a399e2ee90c7d22546000e946a9cf8427b4a082" translate="yes" xml:space="preserve">
          <source>This function exists to make it easy to convert a &lt;a href=&quot;#Date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; to a string for code that does not care what the exact format is - just that it presents the information in a clear manner. It also makes it easy to simply convert a &lt;a href=&quot;#Date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; to a string when using functions such as &lt;code&gt;to!string&lt;/code&gt;, &lt;code&gt;format&lt;/code&gt;, or &lt;code&gt;writeln&lt;/code&gt; which use toString to convert user-defined types. So, it is unlikely that much code will call toString directly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c7ed4f81f0a82e13d48bb2e31cd6ec82cd2b86c" translate="yes" xml:space="preserve">
          <source>This function exists to make it easy to convert a &lt;a href=&quot;#DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt; to a string for code that does not care what the exact format is - just that it presents the information in a clear manner. It also makes it easy to simply convert a &lt;a href=&quot;#DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt; to a string when using functions such as &lt;code&gt;to!string&lt;/code&gt;, &lt;code&gt;format&lt;/code&gt;, or &lt;code&gt;writeln&lt;/code&gt; which use toString to convert user-defined types. So, it is unlikely that much code will call toString directly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a64dc24e50c98de86395100f53371f383577cde" translate="yes" xml:space="preserve">
          <source>This function exists to make it easy to convert a &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt; to a string for code that does not care what the exact format is - just that it presents the information in a clear manner. It also makes it easy to simply convert a &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt; to a string when using functions such as &lt;code&gt;to!string&lt;/code&gt;, &lt;code&gt;format&lt;/code&gt;, or &lt;code&gt;writeln&lt;/code&gt; which use toString to convert user-defined types. So, it is unlikely that much code will call toString directly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14f41e253b823f745b15c2cc550803f474f520f9" translate="yes" xml:space="preserve">
          <source>This function exists to make it easy to convert a &lt;a href=&quot;#TimeOfDay&quot;&gt;&lt;code&gt;TimeOfDay&lt;/code&gt;&lt;/a&gt; to a string for code that does not care what the exact format is - just that it presents the information in a clear manner. It also makes it easy to simply convert a &lt;a href=&quot;#TimeOfDay&quot;&gt;&lt;code&gt;TimeOfDay&lt;/code&gt;&lt;/a&gt; to a string when using functions such as &lt;code&gt;to!string&lt;/code&gt;, &lt;code&gt;format&lt;/code&gt;, or &lt;code&gt;writeln&lt;/code&gt; which use toString to convert user-defined types. So, it is unlikely that much code will call toString directly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1148e69f156783aee95aaac3af378446a842c947" translate="yes" xml:space="preserve">
          <source>This function generates a name based (Version 3) UUID from a namespace UUID and a name. If no namespace UUID was passed, the empty UUID &lt;code&gt;UUID.init&lt;/code&gt; is used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66eef894e5457f79fe590d4b75d5bdb426faba8d" translate="yes" xml:space="preserve">
          <source>This function generates a name based (Version 5) UUID from a namespace UUID and a name. If no namespace UUID was passed, the empty UUID &lt;code&gt;UUID.init&lt;/code&gt; is used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ebad38cdc822b58300e9d455ffae98ef3b8355b1" translate="yes" xml:space="preserve">
          <source>This function generates a random number based UUID from a random number generator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6f7c9706e6dcaec3dbc1161d8b30b320ab44ea3" translate="yes" xml:space="preserve">
          <source>This function has high relative accuracy for values of x far from zero. (For values near zero, use erf(x)).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e015cb774f65ac50bf4cc869720d1f86b5a714ec" translate="yes" xml:space="preserve">
          <source>This function is #1 on the list of functions that eat cpu time. Be very, very careful about slowing it down.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d30b43ff787a8dfba63ef7540785dda2309b0ec" translate="yes" xml:space="preserve">
          <source>This function is &amp;Omicron;(&lt;code&gt;r.length&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60a203a8ffe09817c002b043b4f7c89faa37bc5d" translate="yes" xml:space="preserve">
          <source>This function is &lt;code&gt;@safe&lt;/code&gt; if the corresponding constructor of &lt;code&gt;T&lt;/code&gt; is &lt;code&gt;@safe&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f04b8551bbda2b81d8696beac9a1b771dca8c71" translate="yes" xml:space="preserve">
          <source>This function is Posix-Only.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fbf60467a7efe2e24827c64edfe554cec3d53403" translate="yes" xml:space="preserve">
          <source>This function is Windows-Only.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="103c72135b781967b4b7d6c0026bb26f7259605d" translate="yes" xml:space="preserve">
          <source>This function is also useful in checking for the existence of an environment variable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff6b0b14fd4304f9c34b27c03cced94d986e4033" translate="yes" xml:space="preserve">
          <source>This function is character-range specific and, contrary to &lt;code&gt;splitter!(std.uni.isWhite)&lt;/code&gt;, runs of whitespace will be merged together (no empty tokens will be produced).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65b5ee7f9fec25cbb593bdce1cbdc98ea5f973e1" translate="yes" xml:space="preserve">
          <source>This function is defined only if both allocators define it, and calls &lt;code&gt;deallocateAll&lt;/code&gt; for them in turn.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e12c13033743e308c93ef7b1af47f1c5b48d3a7" translate="yes" xml:space="preserve">
          <source>This function is defined only if both allocators define it, and forwards appropriately depending on &lt;code&gt;b.length&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ebd4634555bf7b1d8d38cdad8559fbd72f2f0cbb" translate="yes" xml:space="preserve">
          <source>This function is defined only if both allocators define it, and returns the conjunction of &lt;code&gt;empty&lt;/code&gt; calls for the two.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72987efb86a1c65d967d861a8683d92ed7f13b9d" translate="yes" xml:space="preserve">
          <source>This function is not generally very useful; it's almost always better to use the faster functions nextUp() or nextDown() instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7e3e7b8bfa4b21481d77f68ea65de0d9b8237c1" translate="yes" xml:space="preserve">
          <source>This function is not supported at compile time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1569b54f86e9b2550627b7e8e8f05e326ad676e8" translate="yes" xml:space="preserve">
          <source>This function is not thread-safe!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41af9d14cc682c76550081ea13492c59097f2bca" translate="yes" xml:space="preserve">
          <source>This function is only aware of EncodingSchemes which have been registered with the register() function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="290ee1b0991973abcaa58bca7c5f6871e5deb008" translate="yes" xml:space="preserve">
          <source>This function is only implemented to 80 bit precision.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee429d1ffe9a170a1a75d5b4a2ff165cd4f65550" translate="yes" xml:space="preserve">
          <source>This function is reentrant against error occurrence. If returns false, all elements of tiargs won't be modified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a118a63c84fce3cf7c06f5f8756bac60c7cca3ac" translate="yes" xml:space="preserve">
          <source>This function is reentrant against error occurrence. If returns false, any members of this object won't be modified, and repetition call will reproduce same error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45e502c95c63dd3997ac1ae57545286a53eaf26c" translate="yes" xml:space="preserve">
          <source>This function is supported in CTFE code. Note that error messages caused by a malformed UUID parsed at compile time can be cryptic, but errors are detected and reported at compile time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5bb3aca496547a19019cbfbd46c1d03c7dd418c6" translate="yes" xml:space="preserve">
          <source>This function is tentatively defined as &lt;code&gt;nothrow&lt;/code&gt; to prevent &lt;code&gt;opPostMove&lt;/code&gt; from being defined without &lt;code&gt;nothrow&lt;/code&gt;, which would allow for possibly confusing changes in program flow.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="185d734d5fc912e0041185bf79a2b6f944b2db35" translate="yes" xml:space="preserve">
          <source>This function is used to (re)initialize the digest. It must be called before using the digest and it also works as a 'reset' function if the digest has already processed data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99071cc1c1c24be1d51b7e6eda1e08791479ed2b" translate="yes" xml:space="preserve">
          <source>This function is used to read the content of DFLAGS. Flags are separated based on spaces and tabs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d39d375bb67b5bea56b7ea75d0a2e4ee34a5fe2" translate="yes" xml:space="preserve">
          <source>This function is useful for maintaining worker-local resources.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c37fe60667a42f9d7da86b803e8b5052d66d498d" translate="yes" xml:space="preserve">
          <source>This function is, in particular, meant to help maintain garbage collector invariants when a lock is not used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa18c6da596117f8b9e11fbedcdfb9a943118fde" translate="yes" xml:space="preserve">
          <source>This function logs data in a &lt;code&gt;printf&lt;/code&gt;-style manner.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77ac69a4b95956005ebe3b90c8e1ca91567efe01" translate="yes" xml:space="preserve">
          <source>This function logs data to the &lt;code&gt;sharedLog&lt;/code&gt; in a &lt;code&gt;printf&lt;/code&gt;-style manner.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98febaf749a97b9336fc523ba35aa7fdcff34cf1" translate="yes" xml:space="preserve">
          <source>This function logs data to the &lt;code&gt;stdThreadLocalLog&lt;/code&gt;, optionally depending on a condition.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eda414e04cca7c9801e1364601be4f243d02a0be" translate="yes" xml:space="preserve">
          <source>This function logs data to the used &lt;code&gt;Logger&lt;/code&gt; depending on a condition with the &lt;code&gt;LogLevel&lt;/code&gt; of the used &lt;code&gt;Logger&lt;/code&gt; in a &lt;code&gt;printf&lt;/code&gt;-style manner.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66789021f1f75fa2b910c0e9aaed002765517585" translate="yes" xml:space="preserve">
          <source>This function logs data to the used &lt;code&gt;Logger&lt;/code&gt; depending on a condition.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea29ac02cb23a3225768859acfa66ad70cf0ae39" translate="yes" xml:space="preserve">
          <source>This function logs data to the used &lt;code&gt;Logger&lt;/code&gt; depending on a explicitly passed condition with the &lt;code&gt;LogLevel&lt;/code&gt; of the used &lt;code&gt;Logger&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7a8c9b909022c7e8d9e73cb0c216e864ba19a51" translate="yes" xml:space="preserve">
          <source>This function logs data to the used &lt;code&gt;Logger&lt;/code&gt; in a &lt;code&gt;printf&lt;/code&gt;-style manner.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="628f5766ea3ce125dda3efbe604aac9ecda078eb" translate="yes" xml:space="preserve">
          <source>This function logs data to the used &lt;code&gt;Logger&lt;/code&gt; with a specific &lt;code&gt;LogLevel&lt;/code&gt; and depending on a condition in a &lt;code&gt;printf&lt;/code&gt;-style manner.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f75a8e8d5f3578debc1682e9b8a4e7729b3c532e" translate="yes" xml:space="preserve">
          <source>This function logs data to the used &lt;code&gt;Logger&lt;/code&gt; with a specific &lt;code&gt;LogLevel&lt;/code&gt; in a &lt;code&gt;printf&lt;/code&gt;-style manner.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca804d9917691f26fc7fe486237e02550749abb2" translate="yes" xml:space="preserve">
          <source>This function logs data to the used &lt;code&gt;Logger&lt;/code&gt; with a specific &lt;code&gt;LogLevel&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ca01c9755ef83db66052e862db8bfa8416b4a46" translate="yes" xml:space="preserve">
          <source>This function logs data to the used &lt;code&gt;Logger&lt;/code&gt; with the &lt;code&gt;LogLevel&lt;/code&gt; of the used &lt;code&gt;Logger&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32b20bbe0e9053ff439b8531776b44b5d48b2b21" translate="yes" xml:space="preserve">
          <source>This function logs data to the used &lt;code&gt;Logger&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de4891742f4a098eab831566cf8b20847dcaef47" translate="yes" xml:space="preserve">
          <source>This function logs data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6a6f2512cc3b6d3cec5f7eabcb2475f26f787b9" translate="yes" xml:space="preserve">
          <source>This function modifies &lt;code&gt;inp&lt;/code&gt; and thus &lt;code&gt;inp&lt;/code&gt; must be an L-value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7aa3a07169729c5a673fe4e99d00fd959fedfe3" translate="yes" xml:space="preserve">
          <source>This function normally allocates a new string (the possible exception being the case when path is immutable and doesn't already have an extension).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c7d082480a49d72cdaa9587898253b55870d5fe" translate="yes" xml:space="preserve">
          <source>This function only handles 1:1 &lt;a href=&quot;#Code%20point&quot;&gt;code point&lt;/a&gt; mapping and thus is not sufficient for certain alphabets like German, Greek and few others.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d4c84cebd7adfe7f4082a2a17dcc09bc723efd3" translate="yes" xml:space="preserve">
          <source>This function performs several memory allocations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36f6f15315bfa28fc8956871508424ecedf0dc3c" translate="yes" xml:space="preserve">
          <source>This function picks the most suitable regular expression engine depending on the pattern properties.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34bd902809c0b5255b567c50dd18197e0b398a33" translate="yes" xml:space="preserve">
          <source>This function prints the passed &lt;code&gt;Option&lt;/code&gt;s and text in an aligned manner on &lt;code&gt;stdout&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="770ded5804f61f67694592c9314c6c39ad348096" translate="yes" xml:space="preserve">
          <source>This function removes one or more code units from the end of a string, and returns the decoded code point which those code units represent.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63d27ce6c5e48781869a5f906f514c111b2ab498" translate="yes" xml:space="preserve">
          <source>This function removes one or more code units from the start of a string, and returns the decoded code point which those code units represent.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="991bbd196cea9f8531404b722484d52c7268693c" translate="yes" xml:space="preserve">
          <source>This function removes one or more ubytes from the start of an array, and returns the decoded code point which those ubytes represent.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd8d3ae1218b20b89d6f5e7ab875d1f322ea2c00" translate="yes" xml:space="preserve">
          <source>This function returns &lt;code&gt;&quot;cmd.exe&quot;&lt;/code&gt; on Windows, &lt;code&gt;&quot;/bin/sh&quot;&lt;/code&gt; on POSIX, and &lt;code&gt;&quot;/system/bin/sh&quot;&lt;/code&gt; on Android.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cfc5056dabba79a946af25fc1dd8feac3fe04895" translate="yes" xml:space="preserve">
          <source>This function returns a pointer to a static copy of the version info struct. See above.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb8f6db61ab479424f86bd4d40e2eb70c3733a62" translate="yes" xml:space="preserve">
          <source>This function returns a thread unique &lt;code&gt;Logger&lt;/code&gt;, that by default propergates all data logged to it to the &lt;code&gt;sharedLog&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85a54448d469e795c947752c78a6d4cb2de70c6f" translate="yes" xml:space="preserve">
          <source>This function searches with policy &lt;code&gt;sp&lt;/code&gt; to find the largest right subrange on which &lt;code&gt;pred(value, x)&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; for all &lt;code&gt;x&lt;/code&gt; (e.g., if &lt;code&gt;pred&lt;/code&gt; is &quot;less than&quot;, returns the portion of the range with elements strictly greater than &lt;code&gt;value&lt;/code&gt;). The search schedule and its complexity are documented in &lt;a href=&quot;#SearchPolicy&quot;&gt;&lt;code&gt;SearchPolicy&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86863ccd0cc5913a3769149726c682b13dc136f9" translate="yes" xml:space="preserve">
          <source>This function sets an association in the multi handle between the given socket and a private pointer of the application. This is (only) useful for curl_multi_socket uses.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45ebc1498e7faf85df00e384f08e7ba59324aaf5" translate="yes" xml:space="preserve">
          <source>This function should be used for expensive functions, as waiting on a condition variable introduces latency, but avoids wasted CPU cycles.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e6634f9a998d963ab6d1c10d0d15ad19ccda248" translate="yes" xml:space="preserve">
          <source>This function should be used when you expect the result of the &lt;code&gt;Task&lt;/code&gt; to be available on a timescale shorter than that of an OS context switch.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84d0dda7f69c92e937d2c85cb930b35b5906bc64" translate="yes" xml:space="preserve">
          <source>This function simply returns the &lt;code&gt;Rebindable&lt;/code&gt; object passed in. It's useful in generic programming cases when a given object may be either a regular &lt;code&gt;class&lt;/code&gt; or a &lt;code&gt;Rebindable&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75bbfb153afd3973808d9088100797f6903e565d" translate="yes" xml:space="preserve">
          <source>This function supercedes &lt;a href=&quot;#toUCSindex&quot;&gt;&lt;code&gt;toUCSindex&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82566e279c83708bdcc5beef2341e2cb52b9d496" translate="yes" xml:space="preserve">
          <source>This function supersedes &lt;code&gt;std.utf.startsValidDchar()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8a982375de1de2eaf1b0bfc6ef749e37da8e235" translate="yes" xml:space="preserve">
          <source>This function supersedes std.utf.decode(), however, note that the function codePoints() supersedes it more conveniently.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3610464c0d3095b814b50eec2269b0b83ec7dc6a" translate="yes" xml:space="preserve">
          <source>This function supersedes std.utf.decode().</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ed87f3ac177989d1d591be6e146c6a7ad9b003c" translate="yes" xml:space="preserve">
          <source>This function supersedes std.utf.encode(), however, note that the function codeUnits() supersedes it more conveniently.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98db0a10ff6e0809060d25a9c9ccbac61cd894c8" translate="yes" xml:space="preserve">
          <source>This function supersedes std.utf.encode().</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6581afa2c255deba8c9a51b34c12340690fe56e5" translate="yes" xml:space="preserve">
          <source>This function supersedes std.utf.toUTF8(), std.utf.toUTF16() and std.utf.toUTF32() (but note that to!() supersedes it more conveniently).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b48f04fdfd63524d418640a2544c0d752dc1f11b" translate="yes" xml:space="preserve">
          <source>This function supersedes std.utf.toUTFindex().</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="463c192ee5d4e01c6f9684913be662a0a7946d01" translate="yes" xml:space="preserve">
          <source>This function supersedes std.utf.validate(), however note that this function returns a bool indicating whether the input was valid or not, whereas the older function would throw an exception.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b42d760296ed5ca95af88ffb26c20168d2a48b77" translate="yes" xml:space="preserve">
          <source>This function takes a non-scope delegate, meaning it can be used with closures. If you can't allocate a closure due to objects on the stack that have scoped destruction, see &lt;code&gt;scopedTask&lt;/code&gt;, which takes a scope delegate.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df71b7c251663548a0f5121464d05a78978a7d9e" translate="yes" xml:space="preserve">
          <source>This function takes a set of path segments, given as an input range of string elements or as a set of string arguments, and concatenates them with each other. Directory separators are inserted between segments if necessary. If any of the path segments are absolute (as defined by &lt;a href=&quot;#isAbsolute&quot;&gt;&lt;code&gt;isAbsolute&lt;/code&gt;&lt;/a&gt;), the preceding segments will be dropped.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3df6f1df50a9028bb24157314b57114720f745cc" translate="yes" xml:space="preserve">
          <source>This function template needs be between the compiler and a much older runtime hook that bypassed safety, purity, and throwabilty checks. To prevent breaking existing code, this function template is temporarily declared &lt;code&gt;@trusted pure&lt;/code&gt; until the implementation can be brought up to modern D expectations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c911ca2b3e26ac7f7502675d63ee542618ab2fa0" translate="yes" xml:space="preserve">
          <source>This function template was ported from a much older runtime hook that bypassed safety, purity, and throwabilty checks. To prevent breaking existing code, this function template is temporarily declared &lt;code&gt;@trusted pure nothrow&lt;/code&gt; until the implementation can be brought up to modern D expectations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9fd88572c57bc63342adb7e4bba717ecc664649b" translate="yes" xml:space="preserve">
          <source>This function template was ported from a much older runtime hook that bypassed safety, purity, and throwabilty checks. To prevent breaking existing code, this function template is temporarily declared &lt;code&gt;@trusted pure&lt;/code&gt; until the implementation can be brought up to modern D expectations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54aa9e4c989c8754e09bfc948cb90d22fd4c28bf" translate="yes" xml:space="preserve">
          <source>This function template was ported from a much older runtime hook that bypassed safety, purity, and throwabilty checks. To prevent breaking existing code, this function template is temporarily declared &lt;code&gt;@trusted&lt;/code&gt; until the implementation can be brought up to modern D expectations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6faa363e2dc5b5097ffda67002301974586de4b" translate="yes" xml:space="preserve">
          <source>This function transforms &lt;code&gt;decimal&lt;/code&gt; value into a value in the factorial number system stored in &lt;code&gt;fac&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8756d8490c0c80f8a3d6e17d81badb070e1ac3c5" translate="yes" xml:space="preserve">
          <source>This function uses a search with policy &lt;code&gt;sp&lt;/code&gt; to find the largest left subrange on which &lt;code&gt;pred(x, value)&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; for all &lt;code&gt;x&lt;/code&gt; (e.g., if &lt;code&gt;pred&lt;/code&gt; is &quot;less than&quot;, returns the portion of the range with elements strictly smaller than &lt;code&gt;value&lt;/code&gt;). The search schedule and its complexity are documented in &lt;a href=&quot;#SearchPolicy&quot;&gt;&lt;code&gt;SearchPolicy&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4d6e17a7f140767c7776fa94ca98edbcfe8ab26" translate="yes" xml:space="preserve">
          <source>This function will accept an invalidly encoded array as input. If an invalid sequence is found at the start of the string, this function will remove it, and return the value INVALID_SEQUENCE.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3cc6b0a88ba3b96758bad3549ef80853faeb94e" translate="yes" xml:space="preserve">
          <source>This function will accept an invalidly encoded string as input. If an invalid sequence is found at the start of the string, this function will remove it, and return the value INVALID_SEQUENCE.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4c790e3c00edf06c3c523e9a96acaa7028222ba" translate="yes" xml:space="preserve">
          <source>This function will also strip &lt;code&gt;\n\r&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2b84c3cd64925b3bc63cc6da8970f088bb9f6ed" translate="yes" xml:space="preserve">
          <source>This function will be called when an exception is constructed. The user-supplied trace handler will be called if one has been supplied, otherwise no trace will be generated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d78c169d84f9e0fc354575058eb3e604cfbfdad" translate="yes" xml:space="preserve">
          <source>This function will be called with elements of &lt;code&gt;inputRange&lt;/code&gt; progressively as iteration proceeds.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68ba6b0b259ab19a35f9197082fe2ab6d70f5d70" translate="yes" xml:space="preserve">
          <source>This function will generate a module called &lt;code&gt;__entrypoint&lt;/code&gt;, and set the globals &lt;code&gt;entrypoint&lt;/code&gt; and &lt;code&gt;rootHasMain&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc2b9580fcf2b39177541158722d4ae408a87a59" translate="yes" xml:space="preserve">
          <source>This function works by splitting the range to be reduced into work units, which are slices to be reduced in parallel. Once the results from all work units are computed, a final serial reduction is performed on these results to compute the final answer. Therefore, care must be taken to choose the seed value appropriately.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3aad905401dc04f581b2c6077d97923bbd2a8dd" translate="yes" xml:space="preserve">
          <source>This function writes the passed text and &lt;code&gt;Option&lt;/code&gt; into an output range in the manner described in the documentation of function &lt;code&gt;defaultGetoptPrinter&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="055b5453fa39d56b283008b9edaf05dd119fac56" translate="yes" xml:space="preserve">
          <source>This functions is equivalent to &lt;code&gt;max(lower, min(upper,val))&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3de8acad7b682bb3660ea91b4edba8b390f1f531" translate="yes" xml:space="preserve">
          <source>This functions is used at runtime to determine if a &lt;code&gt;LogLevel&lt;/code&gt; is active. The same previously defined version statements are used to disable certain levels. Again the version statements are associated with a compile unit and can therefore not disable logging in other compile units. pure bool isLoggingEnabled()(LogLevel ll) @safe nothrow @nogc</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f907426d2ef951648d87f5cd993e54c9a2f733d" translate="yes" xml:space="preserve">
          <source>This functions returns a trace handler, allowing to inspect the current stack trace.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84eb391f18a28223816cf561bff30465c4000886" translate="yes" xml:space="preserve">
          <source>This gets replaced by the number of local bytes in the local stack frame. It is most handy when the &lt;code&gt;naked&lt;/code&gt; is invoked and a custom stack frame is programmed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8e4bebddf13552333bc85ebe7b11a4e7247c831" translate="yes" xml:space="preserve">
          <source>This handle is used to specify the process in OS-specific APIs. On POSIX, this function returns a &lt;code&gt;core.sys.posix.sys.types.pid_t&lt;/code&gt; with the same value as &lt;a href=&quot;#Pid.processID&quot;&gt;&lt;code&gt;Pid.processID&lt;/code&gt;&lt;/a&gt;, while on Windows it returns a &lt;code&gt;core.sys.windows.windows.HANDLE&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33c852a0522cad2c2b4928299e850452d227ef5f" translate="yes" xml:space="preserve">
          <source>This handler overrides any legacy module unit tester set by the moduleUnitTester property.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c35e1bd5e0e6a04521fa5520ade57041fbf6240b" translate="yes" xml:space="preserve">
          <source>This hasher is compatible with the &lt;code&gt;Digest&lt;/code&gt; API:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3993e1a9197061dc1bf704959d048cb51b8578f3" translate="yes" xml:space="preserve">
          <source>This implements a standard critical section.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2f62226ce4de7b0f3cba225bd19bb063907d826" translate="yes" xml:space="preserve">
          <source>This initialization is done before any constructors are called.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e9f56ef2bea3abd9b78b212cb634ac700d5b66a" translate="yes" xml:space="preserve">
          <source>This instance needs an identifier for name mangling purposes. Create one by taking the template declaration name and adding the type signature for it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="912f09d79c05dc09ba32bc17497f7cccd43f92de" translate="yes" xml:space="preserve">
          <source>This is a D version 2 compiler</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5c32108063ea48a95f2ccade44899e02af1ccaa" translate="yes" xml:space="preserve">
          <source>This is a best-effort implementation of &lt;code&gt;length&lt;/code&gt; for any kind of range.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05c823d62e8c286f879871b1e12c6f9007211866" translate="yes" xml:space="preserve">
          <source>This is a compiler magic function - it doesn't behave like regular D functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b09964b15b26c39a9ce61274e2f775777d6323e9" translate="yes" xml:space="preserve">
          <source>This is a convenience alias for &lt;a href=&quot;std_digest#digest&quot;&gt;&lt;code&gt;std.digest.digest&lt;/code&gt;&lt;/a&gt; using the CRC32 implementation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="512068cf15e63810e132140770d7648100089a8e" translate="yes" xml:space="preserve">
          <source>This is a convenience alias for &lt;a href=&quot;std_digest#digest&quot;&gt;&lt;code&gt;std.digest.digest&lt;/code&gt;&lt;/a&gt; using the CRC64-ECMA implementation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3d4ec4ec88de63e322958e6b0d979a689b11d53" translate="yes" xml:space="preserve">
          <source>This is a convenience alias for &lt;a href=&quot;std_digest#digest&quot;&gt;&lt;code&gt;std.digest.digest&lt;/code&gt;&lt;/a&gt; using the MD5 implementation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd636dcefd273f520355be9a0afa2783ad66dbef" translate="yes" xml:space="preserve">
          <source>This is a convenience alias for &lt;a href=&quot;std_digest#digest&quot;&gt;&lt;code&gt;std.digest.digest&lt;/code&gt;&lt;/a&gt; using the RIPEMD160 implementation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29b73ef07a42490f2884582abd8be259990a85c2" translate="yes" xml:space="preserve">
          <source>This is a convenience alias for &lt;a href=&quot;std_digest_digest#digest&quot;&gt;&lt;code&gt;std.digest.digest.digest&lt;/code&gt;&lt;/a&gt; using the CRC64-ISO implementation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69463742eb10b8885c85b63b60e71b70ccfdbb6a" translate="yes" xml:space="preserve">
          <source>This is a convenience function similar to &lt;a href=&quot;#digest&quot;&gt;&lt;code&gt;digest&lt;/code&gt;&lt;/a&gt;, but it returns the string representation of the hash. Every digest passing the &lt;a href=&quot;#isDigest&quot;&gt;&lt;code&gt;isDigest&lt;/code&gt;&lt;/a&gt; test can be used with this function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d797c320e5f08f4ede0b091329f09c40bcd4c23b" translate="yes" xml:space="preserve">
          <source>This is a convenience function to calculate a hash using the template API. Every digest passing the &lt;a href=&quot;#isDigest&quot;&gt;&lt;code&gt;isDigest&lt;/code&gt;&lt;/a&gt; test can be used with this function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5b7feb30ef91eb966259d553831f946792e76d5" translate="yes" xml:space="preserve">
          <source>This is a convenience function to calculate the hash of a value using the OOP API.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3fbe8b98c7fb42d7985a89e6cebbca4b22e50702" translate="yes" xml:space="preserve">
          <source>This is a convenience function which returns an initialized digest, so it's not necessary to call start manually.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b07fdbfd8e90c114315c0c22212b8f6590899cf6" translate="yes" xml:space="preserve">
          <source>This is a dmd specific setting.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87a04bae60dfddd5f321bbf38e370a4d6f98d8c6" translate="yes" xml:space="preserve">
          <source>This is a full list of Unicode properties accessible through &lt;a href=&quot;#unicode&quot;&gt;&lt;code&gt;unicode&lt;/code&gt;&lt;/a&gt; with specific helpers per category nested within. Consult the &lt;a href=&quot;http://www.unicode.org/cldr/utility/properties.jsp&quot;&gt;CLDR utility&lt;/a&gt; when in doubt about the contents of a particular set.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c8f19a42bba7727a8ce8284636a08320c4e65f1" translate="yes" xml:space="preserve">
          <source>This is a general replacement tool that construct a new string by replacing matches of pattern &lt;code&gt;re&lt;/code&gt; in the &lt;code&gt;input&lt;/code&gt;. Unlike the other overload there is no format string instead captures are passed to to a user-defined functor &lt;code&gt;fun&lt;/code&gt; that returns a new string to use as replacement.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48a52f467fdd89c347f6d4a8f50f81ff656d5562" translate="yes" xml:space="preserve">
          <source>This is a great way to implement simple circular buffers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02adbf08da9a4c46841118c88fd0ba75eb2c489f" translate="yes" xml:space="preserve">
          <source>This is a less strict parser compared to the parser used in the UUID constructor. It enforces the following rules:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ecac55bd6998bb669ca8527fad92e747f31aecf4" translate="yes" xml:space="preserve">
          <source>This is a low-level messaging API upon which more structured or restrictive APIs may be built. The general idea is that every messageable entity is represented by a common handle type called a Tid, which allows messages to be sent to logical threads that are executing in both the current process and in external processes using the same interface. This is an important aspect of scalability because it allows the components of a program to be spread across available resources with few to no changes to the actual implementation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c99b5a617247c271e1cb66e28acf2ff8127a04e2" translate="yes" xml:space="preserve">
          <source>This is a magic return code for the write callback that, when returned, will signal libcurl to pause receiving on the current transfer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a547f3bc057670af878d63b618663f30d9c888a" translate="yes" xml:space="preserve">
          <source>This is a number that uniquely identifies the process on the operating system, for at least as long as the process is running. Once &lt;a href=&quot;#wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt; has been called on the &lt;a href=&quot;#Pid&quot;&gt;&lt;code&gt;Pid&lt;/code&gt;&lt;/a&gt;, this method will return an invalid (negative) process ID.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ba143cb17d230b35dd3e77b4d46b42bf59cd667" translate="yes" xml:space="preserve">
          <source>This is a port of &lt;a href=&quot;http://www.boost.org/doc/libs/1_42_0/libs/uuid/uuid.html&quot;&gt; boost.uuid&lt;/a&gt; from the Boost project with some minor additions and API changes for a more D-like API.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3639c2b895158186c93cfc3d4a942fd3a8a4bcfc" translate="yes" xml:space="preserve">
          <source>This is a public domain version of qsort.d. All it does is call C's qsort().</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2506c523fc3fb4d236735f105644ec414dfd3b6c" translate="yes" xml:space="preserve">
          <source>This is a return code for the read callback that, when returned, will const signal libcurl to pause sending data on the current transfer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5f3cb2b8bae68d0d790adf6bf0c62982e12ad3f" translate="yes" xml:space="preserve">
          <source>This is a return code for the read callback that, when returned, will signal libcurl to immediately abort the current transfer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0df6a7dff27cb6ce3775bea09f58211a06e0fa4d" translate="yes" xml:space="preserve">
          <source>This is a shell around a back end symbol</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc048af9db69350bf7d515c9bc813c09c6660d30" translate="yes" xml:space="preserve">
          <source>This is a shell containing a TraitsExp that can be either resolved to a type or to a symbol.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ad2832faed57297a9408dcd8abe79e66f2c28ae" translate="yes" xml:space="preserve">
          <source>This is a simplified declaration of the &lt;a href=&quot;https://developer.apple.com/documentation/foundation/nsstring?language=objc&quot;&gt;&lt;code&gt;NSString&lt;/code&gt;&lt;/a&gt; class. The &lt;a href=&quot;https://developer.apple.com/documentation/objectivec/nsobject/1571958-alloc?language=objc&quot;&gt;&lt;code&gt;alloc&lt;/code&gt;&lt;/a&gt; method allocates an instance of the class. The &lt;a href=&quot;https://developer.apple.com/documentation/foundation/nsstring/1412128-initwithutf8string?language=objc&quot;&gt;&lt;code&gt;initWithUTF8String:&lt;/code&gt;&lt;/a&gt; method will be used to convert a C string in UTF-8 to an Objective-C string, &lt;code&gt;NSString&lt;/code&gt;. The &lt;a href=&quot;https://developer.apple.com/documentation/objectivec/1418956-nsobject/1571957-release?language=objc&quot;&gt;&lt;code&gt;release&lt;/code&gt;&lt;/a&gt; method is used to release an deallocate the string. Since D doesn't support &lt;a href=&quot;https://developer.apple.com/library/mac/releasenotes/ObjectiveC/RN-TransitioningToARC/Introduction/Introduction.html&quot;&gt;ARC&lt;/a&gt; it's needed to manually release Objective-C instances.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b885a66018a314237093b8fb5cb095cdbb3b8c2" translate="yes" xml:space="preserve">
          <source>This is a special compiler recognized attribute, it has several requirements, which all will be enforced by the compiler:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae39fd6f553ae7cbf7dc06cf4c01bdb3470af4ef" translate="yes" xml:space="preserve">
          <source>This is a speed optimization, a good guess at the maximum size of the resulting buffer will improve performance by eliminating reallocations and copying.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="35d1d3de86a677e769796c4bc667e5033e36cade" translate="yes" xml:space="preserve">
          <source>This is a strict parser. It only accepts the pattern above. It doesn't support any leading or trailing characters. It only accepts characters used for hex numbers and the string must have hyphens exactly like above.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ae5fdcefc9284313dd41ba3b8a3e36e9a73a45c" translate="yes" xml:space="preserve">
          <source>This is a subclass of ElementParser. Most of the useful functions are documented there.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2e662785d1d5993dfe200ed0cd32d243953366c" translate="yes" xml:space="preserve">
          <source>This is a submodule of &lt;a href=&quot;std_algorithm&quot;&gt;&lt;code&gt;std.algorithm&lt;/code&gt;&lt;/a&gt;. It contains generic algorithms that implement set operations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1b41f495bf4c79d2ddcbf0100179c8d893eed73" translate="yes" xml:space="preserve">
          <source>This is a submodule of &lt;a href=&quot;std_algorithm&quot;&gt;&lt;code&gt;std.algorithm&lt;/code&gt;&lt;/a&gt;. It contains generic comparison algorithms.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b5ed9bdf36ce4d3eb2f4fa31e710341bfe1a347" translate="yes" xml:space="preserve">
          <source>This is a submodule of &lt;a href=&quot;std_algorithm&quot;&gt;&lt;code&gt;std.algorithm&lt;/code&gt;&lt;/a&gt;. It contains generic iteration algorithms.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1ca49a48babc2bf7a88dc2f9edada29da0b74aa" translate="yes" xml:space="preserve">
          <source>This is a submodule of &lt;a href=&quot;std_algorithm&quot;&gt;&lt;code&gt;std.algorithm&lt;/code&gt;&lt;/a&gt;. It contains generic mutation algorithms.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9256c3179b28cb98f2ccafcbf01fa1114c7ffabd" translate="yes" xml:space="preserve">
          <source>This is a submodule of &lt;a href=&quot;std_algorithm&quot;&gt;&lt;code&gt;std.algorithm&lt;/code&gt;&lt;/a&gt;. It contains generic searching algorithms.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d621cd2fb3907321fd3307426e0197b19ae1cd6c" translate="yes" xml:space="preserve">
          <source>This is a submodule of &lt;a href=&quot;std_algorithm&quot;&gt;&lt;code&gt;std.algorithm&lt;/code&gt;&lt;/a&gt;. It contains generic sorting algorithms.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a6a835a510bef24f9a4d09ad766e6b4789c5a10" translate="yes" xml:space="preserve">
          <source>This is accessible via the ClassData, but since it is frequently needed directly (like for rtti comparisons), make it directly accessible.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c814acc56ca032045c3a40a509dc625dc91c4d4" translate="yes" xml:space="preserve">
          <source>This is actually what &lt;a href=&quot;#byLine&quot;&gt;&lt;code&gt;byLine&lt;/code&gt;&lt;/a&gt; does internally, so its usage is recommended if you want to process a complete file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43e213b7894a106692ed41475e921810e2f2ef96" translate="yes" xml:space="preserve">
          <source>This is an</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d562af56401d0e00dc584df85564d362806b263a" translate="yes" xml:space="preserve">
          <source>This is an advanced type manipulation necessary e.g. for replacing the placeholder type &lt;code&gt;This&lt;/code&gt; in &lt;a href=&quot;std_variant#Algebraic&quot;&gt;&lt;code&gt;std.variant.Algebraic&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3325f1bf2305c77a1849c9f8a9c2843663095726" translate="yes" xml:space="preserve">
          <source>This is an alias for &lt;code&gt;&lt;a href=&quot;std_digest#WrapperDigest&quot;&gt;std.digest.WrapperDigest&lt;/a&gt;!CRC32&lt;/code&gt;, see there for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="991e65c6e6968487ccb7bb69ca7320b94e4ca93f" translate="yes" xml:space="preserve">
          <source>This is an alias for &lt;code&gt;&lt;a href=&quot;std_digest#WrapperDigest&quot;&gt;std.digest.WrapperDigest&lt;/a&gt;!MD5&lt;/code&gt;, see there for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4ce5ff6ecd05c751170313d80d40096c853a878" translate="yes" xml:space="preserve">
          <source>This is an alias for &lt;code&gt;&lt;a href=&quot;std_digest#WrapperDigest&quot;&gt;std.digest.WrapperDigest&lt;/a&gt;!RIPEMD160&lt;/code&gt;, see there for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9558990a88eaad4533f53210d24e334b473686d" translate="yes" xml:space="preserve">
          <source>This is an alias for &lt;code&gt;&lt;a href=&quot;std_digest#WrapperDigest&quot;&gt;std.digest.WrapperDigest&lt;/a&gt;!SHA1&lt;/code&gt;, see there for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57c783fecd68424a831ee827a2afa820a6eb2e72" translate="yes" xml:space="preserve">
          <source>This is an alias for &lt;code&gt;&lt;a href=&quot;std_digest_digest#WrapperDigest&quot;&gt;std.digest.digest.WrapperDigest&lt;/a&gt;!CRC64ECMA&lt;/code&gt;, see there for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0181596da443b5ba169ba47d5e2dd20f026611e" translate="yes" xml:space="preserve">
          <source>This is an alias for &lt;code&gt;&lt;a href=&quot;std_digest_digest#WrapperDigest&quot;&gt;std.digest.digest.WrapperDigest&lt;/a&gt;!CRC64ISO&lt;/code&gt;, see there for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d3c5e22d15f79f627e001b482acc6838518ff93" translate="yes" xml:space="preserve">
          <source>This is an example Scheduler that mirrors the default scheduling behavior of creating one kernel thread per call to spawn. It is fully functional and may be instantiated and used, but is not a necessary part of the default functioning of this module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ff549d63c3ff212a46a7da946a73dffb4f080d9" translate="yes" xml:space="preserve">
          <source>This is an example scheduler that creates a new Fiber per call to spawn and multiplexes the execution of all fibers within the main thread.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b07c47f7921db818ae08b3487fd61d30861252d" translate="yes" xml:space="preserve">
          <source>This is an infinite range, so it is never empty.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12f3a1e35d9244804e6a51ca5a2db8f208c379f7" translate="yes" xml:space="preserve">
          <source>This is an interface to the libcurl library.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ecf41c17b4ddd40e8365245329f080912127dd4" translate="yes" xml:space="preserve">
          <source>This is an overload of &lt;code&gt;translate&lt;/code&gt; which takes an existing buffer to write the contents to.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ecb65db27289cae51fc17448747e90751d9751d" translate="yes" xml:space="preserve">
          <source>This is by design. During construction the &lt;code&gt;Variant&lt;/code&gt; needs static type information about the type being held, so as to store a pointer to function for fast retrieval.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60ab54d413619310ad332327e4504502f2306f23" translate="yes" xml:space="preserve">
          <source>This is called by TypeInfo.compare(p1, p2). If the struct does not support const objects comparison, it will throw &quot;not implemented&quot; Error in runtime.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c89ac618e64974e5137c2fd8360adb505768057f" translate="yes" xml:space="preserve">
          <source>This is called by TypeInfo.equals(p1, p2). If the struct does not support const objects comparison, it will throw &quot;not implemented&quot; Error in runtime.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="165808d159b6f286bb50d6195dc7d22725a89812" translate="yes" xml:space="preserve">
          <source>This is called for a delete statement where the value being deleted is a pointer to a struct with a destructor but doesn't have an overloaded delete operator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="252a57647acdf0a645523b6daf74e75444387572" translate="yes" xml:space="preserve">
          <source>This is designed for efficient memory reuse with some value-semantics structs, eg. &lt;a href=&quot;https://dlang.org/phobos/std_bigint.html#BigInt&quot;&gt;&lt;code&gt;std.bigint.BigInt&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06ae0b36fee3b8fd0ea0e39cba211a57066e0aad" translate="yes" xml:space="preserve">
          <source>This is done by matching the C compiler's data types, layouts, and function call/return sequences.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11029a896ea23a30143fb56e21fe3c178f1a4a41" translate="yes" xml:space="preserve">
          <source>This is especially useful for adding/removing attributes to/from types in generic code, where the actual type name cannot be spelt out.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b13063fd35605a68f66f22b807caf15b21927ce2" translate="yes" xml:space="preserve">
          <source>This is especially useful when used with inheritance. For example, you might want to implement a final base method which returns a derived class type. Typically you would return a base type, but this won't allow you to call or access derived properties of the type:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33a5219de6733b72248cb459ae3c108de0b27b6d" translate="yes" xml:space="preserve">
          <source>This is for cases where you need a value representing the OS at runtime. If you're doing something which should compile differently on different OSes, then please use &lt;code&gt;version (Windows)&lt;/code&gt;, &lt;code&gt;version (linux)&lt;/code&gt;, etc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9085623d5748a41a60ced02ac9ea7374a5eb5654" translate="yes" xml:space="preserve">
          <source>This is generally fine, and by its very nature, converting from system ticks to any type of seconds (hnsecs, nsecs, etc.) will introduce rounding errors, but if code needs to avoid any of the small rounding errors introduced by conversion, then it needs to use MonoTime's &lt;code&gt;ticks&lt;/code&gt; property and keep all calculations in ticks rather than using &lt;a href=&quot;#Duration&quot;&gt;&lt;code&gt;Duration&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88fe60e9205a837e1c893e74b0d472fd048224ed" translate="yes" xml:space="preserve">
          <source>This is generally the fastest method to convert a floating-point number to an integer. Note that the results from this function depend on the rounding mode, if the fractional part of x is exactly 0.5. If using the default rounding mode (ties round to even integers) lrint(4.5) == 4, lrint(5.5)==6.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f53ca66b2923ca36935e7ce2bb35685de87690d9" translate="yes" xml:space="preserve">
          <source>This is intended for cases where you need to deal with endianness at runtime. If you're doing something which should compile differently depending on whether you're compiling on a big endian or little endian machine, then please use &lt;code&gt;version (BigEndian)&lt;/code&gt; and &lt;code&gt;version (LittleEndian)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b3b92fb9499542d848207397387795d022c0de6" translate="yes" xml:space="preserve">
          <source>This is intended to be called at the start of the program to yield all scheduling to the active Scheduler instance. This is necessary for schedulers that explicitly dispatch threads rather than simply relying on the operating system to do so, and so start should always be called within main() to begin normal program execution.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="168edfe34c09b55f1deed4c37990e3c71a1ca3c1" translate="yes" xml:space="preserve">
          <source>This is more efficient than testing each bit in a sparsely populated bit set. Note that the first bit in the bit set would be bit 0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8fcde002524d5c331c8548b6dca27a95656e7bce" translate="yes" xml:space="preserve">
          <source>This is most handy when the array indices are given by enums:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c31ac80c96aa26f46ec6ee9192e9e74924da45e0" translate="yes" xml:space="preserve">
          <source>This is needed because AssignExp rewrites CommaExp, hence it needs to trigger the deprecation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7738cc186f07169467da57ea636fc910ff8ff41" translate="yes" xml:space="preserve">
          <source>This is not recursive; it will not search for symbols within symbols such as nested structs or unions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79018f9004b6204ff482d1449a187f60021b161a" translate="yes" xml:space="preserve">
          <source>This is similar to &lt;code&gt;takeWhile&lt;/code&gt; in other languages.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da1506be46b53535dcad92fb4d88063b66606cfa" translate="yes" xml:space="preserve">
          <source>This is so we can slice a TypeTuple</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ea183190e1a8d4a5c65894e3d7aa69b999c8015" translate="yes" xml:space="preserve">
          <source>This is the D way, and is used consistently in the D runtime library and examples.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b87f9cb349c407cc69c74e007c81d9397e42baeb" translate="yes" xml:space="preserve">
          <source>This is the FILE * or void * the regular output should be written to.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e03f57cd49f977fe295ada31586860acb7b55e0d" translate="yes" xml:space="preserve">
          <source>This is the argument passed to the socket callback</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be469fab3c85ca74b768977fadfadf33a82814bf" translate="yes" xml:space="preserve">
          <source>This is the argument passed to the timer callback</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47d1ba0ce023e632a01bb533e80836298674478a" translate="yes" xml:space="preserve">
          <source>This is the date and time when the full source package was created. The timestamp is not stored in git, as the timestamp is properly set in the tarballs by the maketgz script.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bcb4b4d07cd24ad03f4d73cf2a834d60bf057434" translate="yes" xml:space="preserve">
          <source>This is the global package copyright</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00bd1884cd8f1f3700cdc8b2d576c08ba85d63de" translate="yes" xml:space="preserve">
          <source>This is the length in bytes of the hash value which is returned by &lt;a href=&quot;#finish&quot;&gt;&lt;code&gt;finish&lt;/code&gt;&lt;/a&gt;. It's also the required size of a buffer passed to &lt;a href=&quot;#finish&quot;&gt;&lt;code&gt;finish&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="629c1787bf8dac085ebe6f000afbc79766608202" translate="yes" xml:space="preserve">
          <source>This is the most specific allocation policy: the memory being allocated is thread local, has no indirections at all, and will not be reallocated. Examples of types fitting this description: &lt;code&gt;int&lt;/code&gt;, &lt;code&gt;double&lt;/code&gt;, &lt;code&gt;Tuple!(int, long)&lt;/code&gt;, but not &lt;code&gt;Tuple!(int, string)&lt;/code&gt;, which contains an indirection.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d53bdfa25144b5efcd12699a648c0b943568037" translate="yes" xml:space="preserve">
          <source>This is the numeric version of the libcurl version number, meant for easier parsing and comparions by programs. The LIBCURL_VERSION_NUM define will always follow this syntax:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f516424ebe0c21d1c77be3938d4dc4c573211582" translate="yes" xml:space="preserve">
          <source>This is the old ctor sorting algorithm that does not find all cycles.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e92c9060948634b2691b12a3f666bd6c1016991" translate="yes" xml:space="preserve">
          <source>This is the same as &lt;code&gt;getTimes&lt;/code&gt; except that it also gives you the file creation time - which isn't possible on Posix systems.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8bc2540cd8cdfdea3a8a5b982374faccf0dd6c1" translate="yes" xml:space="preserve">
          <source>This is the socket callback function pointer</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61598e1f6a7ec5d30e11d3aead7284998d0c4762" translate="yes" xml:space="preserve">
          <source>This is the timer callback function pointer</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c718912a86bcbf8011f76f57098fa90f1498a69a" translate="yes" xml:space="preserve">
          <source>This is the version number of the libcurl package from which this header file origins:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a98c5dbd73e5200bae0821dc0199531a02a94575" translate="yes" xml:space="preserve">
          <source>This is to support compiling expressions within the context of a function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f258032a2e34908ad83c367bba4f67f9bf0d8fc" translate="yes" xml:space="preserve">
          <source>This is true even if the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="915f3d07336b61352341e4f59f1cdec1c322cabb" translate="yes" xml:space="preserve">
          <source>This is useful for:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fcc8360025ee8f837157968edcf3a60c6d678ceb" translate="yes" xml:space="preserve">
          <source>This is useful in cases where the user is expected to type in one of a known set of strings, and the program will helpfully auto-complete the string once sufficient characters have been entered that uniquely identify it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4e34d37acfaa90ff5c5cdca9c0444e2392c7b7c" translate="yes" xml:space="preserve">
          <source>This is useful when dealing with memory-mapped I/O (MMIO) where a store can have an effect other than just writing a value, or where sequential loads with no intervening stores can retrieve different values from the same location due to external stores to the location.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="130a13f443489357f62d68edb3556823f7774c09" translate="yes" xml:space="preserve">
          <source>This is usually the default diagnostic reporter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b8bd52c73d65472e04e60bf842e33bc426a473d" translate="yes" xml:space="preserve">
          <source>This is very useful as a template constraint (see examples)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9c38689ba29d74fc53f435aaf473866b312b836" translate="yes" xml:space="preserve">
          <source>This is, however, NOT equivalent to POSIX' &lt;code&gt;execv*&lt;/code&gt;. For one thing, the executed program is started as a separate process, with all this entails. Secondly, in a multithreaded program, other threads will continue to do work while the current thread is waiting for the child process to complete.  A better option may sometimes be to terminate the current program immediately after spawning the child process. This is the behaviour exhibited by the &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/431x4c1w.aspx&quot;&gt;&lt;code&gt;__exec&lt;/code&gt;&lt;/a&gt; functions in Microsoft's C runtime library, and it is how D's now-deprecated Windows &lt;code&gt;execv*&lt;/code&gt; functions work. Example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86cd963d96c400e127b41fb5e1c683fd1645332a" translate="yes" xml:space="preserve">
          <source>This level is used to display information about the program.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7bd1213d23d1dea834726c3d604226e3f0bd7985" translate="yes" xml:space="preserve">
          <source>This library provides a mechanism whereby other modules may add &lt;a href=&quot;#EncodingScheme&quot;&gt;&lt;code&gt;EncodingScheme&lt;/code&gt;&lt;/a&gt; subclasses for any other encoding.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3c0ccf8cf8329e21b5b2e67a76439bedab69306" translate="yes" xml:space="preserve">
          <source>This library provides full Level 1 support* according to &lt;a href=&quot;http://unicode.org/reports/tr18/&quot;&gt;UTS 18&lt;/a&gt;. Specifically:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4904626a5781bdaca7da93c6ed4103629917781b" translate="yes" xml:space="preserve">
          <source>This library supplies &lt;a href=&quot;#EncodingScheme&quot;&gt;&lt;code&gt;EncodingScheme&lt;/code&gt;&lt;/a&gt; subclasses for ASCII, ISO-8859-1 (also known as LATIN-1), ISO-8859-2 (LATIN-2), WINDOWS-1250, WINDOWS-1251, WINDOWS-1252, UTF-8, and (on little-endian architectures) UTF-16LE and UTF-32LE; or (on big-endian architectures) UTF-16BE and UTF-32BE.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ab23006d99b3e64b2eb41b8a2440b3e86ff5b16" translate="yes" xml:space="preserve">
          <source>This library uses a remarkably common ECMAScript syntax flavor with the following extensions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d7d527b40f488b0b076be50f2a630625a4b71d6" translate="yes" xml:space="preserve">
          <source>This library will supply your function with a new instance of ElementHandler, which may be used to parse inside the element whose start tag was just found, or to identify the tag attributes of the element, etc.  Note that your function will be called for both start tags and empty tags. That is, we make no distinction between &amp;lt;br&amp;gt;&amp;lt;/br&amp;gt; and &amp;lt;br/&amp;gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5bcb738af6294ebb159f7ef50c2f4ed098badaa1" translate="yes" xml:space="preserve">
          <source>This macro below was added in 7.16.3 to push users who recompile to use the new curl_multi_socket_action() instead of the old curl_multi_socket()</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05317d0fb9b73229e7a4b236f6860aa4bc992df1" translate="yes" xml:space="preserve">
          <source>This makes the intent clearer, because the first statement can easily be misread as the following code:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d0a27a35faef1bf1f6ffad88638e7121e05700e" translate="yes" xml:space="preserve">
          <source>This means that pointers to elements of an &lt;code&gt;Array&lt;/code&gt; will become dangling as soon as the element is removed from the &lt;code&gt;Array&lt;/code&gt;. On the other hand the memory allocated by an &lt;code&gt;Array&lt;/code&gt; will be scanned by the GC and GC managed objects referenced from an &lt;code&gt;Array&lt;/code&gt; will be kept alive.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="604c9cc6344fc7f1b954e8b21d2a6ca0c3ac4133" translate="yes" xml:space="preserve">
          <source>This member holds all &lt;code&gt;Logger&lt;/code&gt;s stored in the &lt;code&gt;MultiLogger&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2222d90d3dcd66aaa74b009940ed8d8638bced76" translate="yes" xml:space="preserve">
          <source>This memoizes all values of &lt;code&gt;fact&lt;/code&gt; up to the largest argument. To only cache the final result, move &lt;code&gt;memoize&lt;/code&gt; outside the function as shown below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a167a300836fdd4ab2e0e008d931c833538789e" translate="yes" xml:space="preserve">
          <source>This method allows expansion within the respective bucket range. It succeeds if both &lt;code&gt;b.length&lt;/code&gt; and &lt;code&gt;b.length + delta&lt;/code&gt; fall in a range of the form &lt;code&gt;[min + k * step, min + (k + 1) * step - 1]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4461edb18d36faaf19bc846025f3b95c67801b6c" translate="yes" xml:space="preserve">
          <source>This method allows forwarding log entries from one logger to another.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3816a6346828017f335a6081c798a8a0dd6de4dd" translate="yes" xml:space="preserve">
          <source>This method allows reallocation within the respective bucket range. If both &lt;code&gt;b.length&lt;/code&gt; and &lt;code&gt;size&lt;/code&gt; fall in a range of the form &lt;code&gt;[min + k * step, min + (k + 1) * step - 1]&lt;/code&gt;, then reallocation is in place. Otherwise, reallocation with moving is attempted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9a458cd0b30230c45418803529ca936bac85057" translate="yes" xml:space="preserve">
          <source>This method can be more efficient than the one in the previous example because &lt;code&gt;stdin.readln(buf)&lt;/code&gt; reuses (if possible) memory allocated for &lt;code&gt;buf&lt;/code&gt;, whereas &lt;code&gt;line = stdin.readln()&lt;/code&gt; makes a new memory allocation for every line.  For even better performance you can help &lt;code&gt;readln&lt;/code&gt; by passing in a large buffer to avoid memory reallocations. This can be done by reusing the largest buffer returned by &lt;code&gt;readln&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f7c9ac03db99dc39088ab7814b92a020b0c3ad1" translate="yes" xml:space="preserve">
          <source>This method inserts a new Logger into the &lt;code&gt;MultiLogger&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e456631bd1026dc4c8384262111ee00c2ae6280" translate="yes" xml:space="preserve">
          <source>This method is defined if both allocators define it, and forwards to &lt;code&gt;SmallAllocator&lt;/code&gt; or &lt;code&gt;LargeAllocator&lt;/code&gt; appropriately.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29c6c590b7cd5abdf60b16e55a89efa8f2694069" translate="yes" xml:space="preserve">
          <source>This method is defined only if at least one of the allocators defines it, and work similarly to &lt;code&gt;reallocate&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c403891dca13c06af654365809bbef8d64860536" translate="yes" xml:space="preserve">
          <source>This method is defined only if at least one of the allocators defines it. If &lt;code&gt;SmallAllocator&lt;/code&gt; defines &lt;code&gt;expand&lt;/code&gt; and &lt;code&gt;b.length + delta &amp;lt;= threshold&lt;/code&gt;, the call is forwarded to &lt;code&gt;SmallAllocator&lt;/code&gt;. If &lt;code&gt; LargeAllocator&lt;/code&gt; defines &lt;code&gt;expand&lt;/code&gt; and &lt;code&gt;b.length &amp;gt; threshold&lt;/code&gt;, the call is forwarded to &lt;code&gt;LargeAllocator&lt;/code&gt;. Otherwise, the call returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc308051788a72be786da5419b09693d8595fa4d" translate="yes" xml:space="preserve">
          <source>This method is defined only if at least one of the allocators defines it. If &lt;code&gt;SmallAllocator&lt;/code&gt; defines &lt;code&gt;reallocate&lt;/code&gt; and &lt;code&gt;b.length &amp;lt;= threshold &amp;amp;&amp;amp; s &amp;lt;= threshold&lt;/code&gt;, the call is forwarded to &lt;code&gt; SmallAllocator&lt;/code&gt;. If &lt;code&gt;LargeAllocator&lt;/code&gt; defines &lt;code&gt;expand&lt;/code&gt; and &lt;code&gt; b.length &amp;gt; threshold &amp;amp;&amp;amp; s &amp;gt; threshold&lt;/code&gt;, the call is forwarded to &lt;code&gt; LargeAllocator&lt;/code&gt;. Otherwise, the call returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="620e46438ddff127931a59ae1ef3a8f250fd07f0" translate="yes" xml:space="preserve">
          <source>This method is defined only if at least one of the allocators defines it. The good allocation size is obtained from &lt;code&gt;SmallAllocator&lt;/code&gt; if &lt;code&gt; s &amp;lt;= threshold&lt;/code&gt;, or &lt;code&gt;LargeAllocator&lt;/code&gt; otherwise. (If one of the allocators does not define &lt;code&gt;goodAllocSize&lt;/code&gt;, the default implementation in this module applies.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d239e7b226a63994c92bb5f28f2af2cc148e0855" translate="yes" xml:space="preserve">
          <source>This method is defined only if both allocators define it. The call is forwarded to &lt;code&gt;SmallAllocator&lt;/code&gt; if &lt;code&gt;b.length &amp;lt;= threshold&lt;/code&gt;, or &lt;code&gt; LargeAllocator&lt;/code&gt; otherwise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5f2a8f9e894a52f7a4a03fd41c115c5a28e5d48" translate="yes" xml:space="preserve">
          <source>This method is only available if the underlying range is a &lt;a href=&quot;std_range_primitives#isForwardRange&quot;&gt;forward range&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8fd044a02e3e694fc797ffa7b6155202b89056a3" translate="yes" xml:space="preserve">
          <source>This method is only available if the underlying range is a &lt;a href=&quot;std_range_primitives#isForwardRange&quot;&gt;forward range&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="832bf9b6aa94575865959f7e42866388acb50190" translate="yes" xml:space="preserve">
          <source>This method is only defined if &lt;code&gt;Allocator&lt;/code&gt; defines &lt;code&gt;deallocate&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d110cb43a292fbf904825bc3d4bb27446be41655" translate="yes" xml:space="preserve">
          <source>This method is only defined if all allocators involved define &lt;code&gt; deallocateAll&lt;/code&gt;, and calls it for each bucket in turn. Returns &lt;code&gt;true&lt;/code&gt; if all allocators could deallocate all.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39358dd310cc162f2c05e4b4ad0f8504cf1a91af" translate="yes" xml:space="preserve">
          <source>This method is only defined if all allocators involved define &lt;code&gt; resolveInternalPointer&lt;/code&gt;, and tries it for each bucket in turn.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9dbdb0a556e3c7305bbb92177faa9a39d0b98a27" translate="yes" xml:space="preserve">
          <source>This method logs data to the used &lt;code&gt;Logger&lt;/code&gt; with the &lt;code&gt;LogLevel&lt;/code&gt; of the this &lt;code&gt;Logger&lt;/code&gt; in a &lt;code&gt;printf&lt;/code&gt;-style manner.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6f8a28a408a1ebec1b43e9856020fe703ce80ce" translate="yes" xml:space="preserve">
          <source>This method logs data with the &lt;code&gt;LogLevel&lt;/code&gt; of the used &lt;code&gt;Logger&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c1dde3d6319c6f9ff98c98c06a035679376bc16" translate="yes" xml:space="preserve">
          <source>This method removes a Logger from the &lt;code&gt;MultiLogger&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
