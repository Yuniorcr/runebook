<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="es" datatype="htmlbody" original="d">
    <body>
      <group id="d">
        <trans-unit id="d13659d418fd5667a2a45e0c6e1f23ef28169af7" translate="yes" xml:space="preserve">
          <source>A range type dependent on &lt;code&gt;R1&lt;/code&gt; and &lt;code&gt;R2&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aca5fa10af5948aacb0618dcc7659c011b96c280" translate="yes" xml:space="preserve">
          <source>A range with each fun applied to all the elements. If there is more than one fun, the element type will be &lt;code&gt;Tuple&lt;/code&gt; containing one element for each fun.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a647974a789216b78223c54f30ddb7dbc6f42bec" translate="yes" xml:space="preserve">
          <source>A reader sub-mutex.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78aacc289e57898ba520714d51228a88f7785c8a" translate="yes" xml:space="preserve">
          <source>A real number.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5279da871ece6d65446e8b83a539f4a46cf9e5b" translate="yes" xml:space="preserve">
          <source>A record has fields separated by a comma (customizable)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d0f9f69bb9f8022d38780e473a8ed97e90abb3f" translate="yes" xml:space="preserve">
          <source>A record is separated by a new line (CRLF,LF,CR)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5838b1b8195e7908693ea69a0ccd678dde645bf2" translate="yes" xml:space="preserve">
          <source>A reference counted struct that wraps the dynamic allocator interface. This should be used wherever a uniform type is required for encapsulating various allocator implementations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="073ff9e700584023c7f918b3c35ddc44ddc93350" translate="yes" xml:space="preserve">
          <source>A reference counted struct that wraps the dynamic shared allocator interface. This should be used wherever a uniform type is required for encapsulating various allocator implementations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42e7f065a5d8231c47d820792cd468e9083d8ea9" translate="yes" xml:space="preserve">
          <source>A reference to &lt;code&gt;this&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5eeb6dd68fac30b5064fbb6c8083f183c09787e7" translate="yes" xml:space="preserve">
          <source>A reference to a class, or an interface. We need this when we point to a base class (we must record what the type is).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30938b6d6a99ea62f4185cf08673d2059303fed2" translate="yes" xml:space="preserve">
          <source>A reference to a declaration marked with the &lt;code&gt;@disable&lt;/code&gt; attribute causes a compile time error. This can be used to explicitly disallow certain operations or overloads at compile time rather than relying on generating a runtime error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68e9ca0fa77d6187ddb37422879e54ea57fecf2e" translate="yes" xml:space="preserve">
          <source>A reference to an object, interface, associative array, or an array slice to initialize the &lt;code&gt;Rebindable&lt;/code&gt; with.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c12cdfe35d9669562e6c6517387b415345dc5100" translate="yes" xml:space="preserve">
          <source>A reference to the &lt;code&gt;Date&lt;/code&gt; (&lt;code&gt;this&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e807fe0dbc26276ecc9263d30854a040d1f0bceb" translate="yes" xml:space="preserve">
          <source>A reference to the &lt;code&gt;DateTime&lt;/code&gt; (&lt;code&gt;this&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ecb5758110283986b0f628f0dee35b28e439047" translate="yes" xml:space="preserve">
          <source>A reference to the &lt;code&gt;TimeOfDay&lt;/code&gt; (&lt;code&gt;this&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3643ec80e8e77b31f829b56e6385e6b5fae1a8bb" translate="yes" xml:space="preserve">
          <source>A reference to the allocated memory on success or &lt;code&gt;null&lt;/code&gt; if &lt;code&gt;sz&lt;/code&gt; is zero or the pointer does not point to the base of an GC allocated memory block.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d5352d81e29a32196c5f56f2bb9ed97b987c1d7" translate="yes" xml:space="preserve">
          <source>A reference to the allocated memory or null if insufficient memory is available.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e37e582469e7c67872dafc3589a5e25b3c66b5ab" translate="yes" xml:space="preserve">
          <source>A reference to the current thread. May be null.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a61f330905217e37d6323303c34b226425d66b17" translate="yes" xml:space="preserve">
          <source>A reference to the digest for convenient chaining.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20e52674df62aed2822a9ce68fb98c50fe7dd734" translate="yes" xml:space="preserve">
          <source>A reference to the initialized variable</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a73c900947644b46c70f39971b466339325ec9c" translate="yes" xml:space="preserve">
          <source>A reference to the library or null on error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75039d96df258122331865dd56bd4d83100ff798" translate="yes" xml:space="preserve">
          <source>A reference to the library to unload.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d686f93504e54ee14861d429718fa839597a8cdf" translate="yes" xml:space="preserve">
          <source>A reference to the newly created thread.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9756cbec24ff837e6d02b449d53fc6cb5a1e5f3" translate="yes" xml:space="preserve">
          <source>A reference to the next error in the list. This is used when a new &lt;code&gt;Throwable&lt;/code&gt; is thrown from inside a &lt;code&gt;catch&lt;/code&gt; block. The originally caught &lt;code&gt;Exception&lt;/code&gt; will be chained to the new &lt;code&gt;Throwable&lt;/code&gt; via this field.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff58948889bb0a36a8abceb97a8a3c148dcf9671" translate="yes" xml:space="preserve">
          <source>A refernce to the &lt;code&gt;Logger&lt;/code&gt; used to create this &lt;code&gt;LogEntry&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91e4b10e829acb93ce7cd86702882a460a9c1e50" translate="yes" xml:space="preserve">
          <source>A regex engine state, as returned by &lt;code&gt;match&lt;/code&gt; family of functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2539e853fd15604cb6a934d48bc2528e82ab9538" translate="yes" xml:space="preserve">
          <source>A reimplemented interface must implement all the interface functions, it does not inherit them from a super class:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="306cb18355cd21a0060bd8023086f1a746ecc542" translate="yes" xml:space="preserve">
          <source>A relational operator can have &lt;code&gt;NaN&lt;/code&gt; operands. If either or both operands is &lt;code&gt;NaN&lt;/code&gt;, the floating point comparison operation returns as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2fbb01cbf6b15e85576d1bc8dafb5f686611418c" translate="yes" xml:space="preserve">
          <source>A root module is one that will be compiled all the way to object code. This field holds the root module that caused this module to be loaded. If this module is a root module, then it will be set to &lt;code&gt;this&lt;/code&gt;. This is used to determine ownership of template instantiation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bfb6ac8ef8ee222f7c87138ddd6e6d11dddde966" translate="yes" xml:space="preserve">
          <source>A scope block statement introduces a new scope for the &lt;a href=&quot;#BlockStatement&quot;&gt;&lt;i&gt;BlockStatement&lt;/i&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4eca2516e751338cb4cea2d3632121becc1dcc07" translate="yes" xml:space="preserve">
          <source>A scope class is a class with the &lt;code&gt;scope&lt;/code&gt; attribute, as in:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1726fb56d87e8ffffee60a1adced14592e54f844" translate="yes" xml:space="preserve">
          <source>A scope class reference can only appear as a function local variable. It must be declared as being &lt;code&gt;scope&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0af4522df69cbecf3e1a90ca6686769a3cc8194" translate="yes" xml:space="preserve">
          <source>A seed may be passed to &lt;code&gt;sum&lt;/code&gt;. Not only will this seed be used as an initial value, but its type will override all the above, and determine the algorithm and precision used for summation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8ed8bfa97374dda35f3e6d60a27183df8e3dd7b" translate="yes" xml:space="preserve">
          <source>A seedable random-number generator has the following additional features:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62eef04deeedb61ec809031e320e402553bde037" translate="yes" xml:space="preserve">
          <source>A semi-lazy parallel map that can be used for pipelining. The map functions are evaluated for the first &lt;code&gt;bufSize&lt;/code&gt; elements and stored in a buffer and made available to &lt;code&gt;popFront&lt;/code&gt;. Meanwhile, in the background a second buffer of the same size is filled. When the first buffer is exhausted, it is swapped with the second buffer and filled while the values from what was originally the second buffer are read. This implementation allows for elements to be written to the buffer without the need for atomic operations or synchronization for each write, and enables the mapping function to be evaluated efficiently in parallel.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a25d6360214ab107cc5a2690ac6934209de0713e" translate="yes" xml:space="preserve">
          <source>A set of arguments to a function with inout parameters is considered a match if any inout argument types match exactly, or:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51c642f510697a8d846cbe239c05d6e7f4bd433c" translate="yes" xml:space="preserve">
          <source>A set of functions in this module that do the substitution rely on a simple format to guide the process. In particular the table below applies to the &lt;code&gt;format&lt;/code&gt; argument of &lt;a href=&quot;#replaceFirst&quot;&gt;&lt;code&gt;replaceFirst&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#replaceAll&quot;&gt;&lt;code&gt;replaceAll&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8a9cfe24fb306eb618c433658da1dfff7fbe905" translate="yes" xml:space="preserve">
          <source>A shell command which is passed verbatim to the command interpreter. (See &lt;a href=&quot;#spawnShell&quot;&gt;&lt;code&gt;spawnShell&lt;/code&gt;&lt;/a&gt; for details.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6e6e41467f1af8066889b7eb3e8cd2ba5db578e" translate="yes" xml:space="preserve">
          <source>A shorthand for creating a custom multi-level fixed Trie from a &lt;code&gt;CodepointSet&lt;/code&gt;. &lt;code&gt;sizes&lt;/code&gt; are numbers of bits per level, with the most significant bits used first.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="872a8839a08b7a547700d02979804255ca5dda79" translate="yes" xml:space="preserve">
          <source>A signed integer representing the unix time which is equivalent to the given std time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f860d4a0b4e17f8f9f5a52ee6fbbcb2156c9580b" translate="yes" xml:space="preserve">
          <source>A signed integer representing the unix time which is equivalent to this SysTime.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3616b970c3c6ad571e4bcd0ec81882f1b115ec64" translate="yes" xml:space="preserve">
          <source>A simple file cache that can be used to avoid reading the same file multiple times. It stores its cached files as &lt;a href=&quot;#FileAndLines&quot;&gt;&lt;code&gt;FileAndLines&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="baa475621014a28514997e0b8ab31fb33db431d4" translate="yes" xml:space="preserve">
          <source>A simple generic copy template would be:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20b05a6cb1c672b9ef624b2ff448b0500b9047e8" translate="yes" xml:space="preserve">
          <source>A simple property would be:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba136270dcb78a01ac01f425897459708ac2204d" translate="yes" xml:space="preserve">
          <source>A simple wrapper around core.demangle.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be6731f2a1c9e7c94bf4c940a35e7396dbfee3d9" translate="yes" xml:space="preserve">
          <source>A single entry point to lookup Unicode &lt;a href=&quot;#Code%20point&quot;&gt;code point&lt;/a&gt; sets by name or alias of a block, script or general category.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79c7939d70d47eaa74b95a0d35217792acd405a3" translate="yes" xml:space="preserve">
          <source>A single random element drawn from the &lt;code&gt;range&lt;/code&gt;. If it can, it will return a &lt;code&gt;ref&lt;/code&gt; to the &lt;code&gt;range element&lt;/code&gt;, otherwise it will return a copy.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="660d1f6310c0c87621e9a54e4b08dfcdf5729188" translate="yes" xml:space="preserve">
          <source>A single random variate drawn from the uniform distribution between &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;, whose type is the common type of these parameters</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0634725ae5a0e7183bfefc294b400ab01233d7f2" translate="yes" xml:space="preserve">
          <source>A single regular expression to match.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec5a41e95c545f5b9ca17c3cce34db77407a6c8d" translate="yes" xml:space="preserve">
          <source>A single unsigned integer seed value, different on each successive call</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae4b3bcc6e1cb3e9d2d9a6f88f30cf7fd585afe6" translate="yes" xml:space="preserve">
          <source>A singleton instance of the default random number generator</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ef9bc9017937bc2cb5ef8d012679f4242838bf7" translate="yes" xml:space="preserve">
          <source>A slice of &lt;code&gt;path&lt;/code&gt; or &quot;.&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="211be94b802431a091e4438f74d6d8da155125ad" translate="yes" xml:space="preserve">
          <source>A slice of &lt;code&gt;path&lt;/code&gt; that is the drive, or an empty range if the drive is not specified. In the case of UNC paths, the network share is returned.  Always returns an empty range on POSIX.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="beac62a1b583a4886c9c1be497e5c0b0348e7cd1" translate="yes" xml:space="preserve">
          <source>A slice of &lt;code&gt;path&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a44a0058f9c93fc07954a765d5c3b256792c20e" translate="yes" xml:space="preserve">
          <source>A slice of &lt;code&gt;r1&lt;/code&gt; which contains the characters that both ranges start with, if the first argument is a string; otherwise, the same as the result of &lt;code&gt;takeExactly(r1, n)&lt;/code&gt;, where &lt;code&gt;n&lt;/code&gt; is the number of elements in the common prefix of both ranges.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ffe788b4fb95a6848324f21f66531a09b889ad4" translate="yes" xml:space="preserve">
          <source>A slice of path without the drive component.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="581b3b4f0e3112a50b079afa9d9199402f78b5ce" translate="yes" xml:space="preserve">
          <source>A slightly more general tool for building fixed &lt;code&gt;Trie&lt;/code&gt; for the Unicode data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4cd1ce7d77a0e891a7fba5fd7dfff37943999a7f" translate="yes" xml:space="preserve">
          <source>A slot is implemented as a delegate. The slot_t is the type of the delegate. The delegate must be to an instance of a class or an interface to a class instance. Delegates to struct instances or nested functions must not be used as slots.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d89edff631bacdade5c431ac87b9ac60108881dd" translate="yes" xml:space="preserve">
          <source>A sockaddr_in as obtained from lower-level API calls such as getifaddrs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d42edca23e3ad2a39e5d64109da0bfd2ccec746" translate="yes" xml:space="preserve">
          <source>A sockaddr_in6 as obtained from lower-level API calls such as getifaddrs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ea4d279c0d7e6e01846c33d4b612f74d42c15cf" translate="yes" xml:space="preserve">
          <source>A sockaddr_un as obtained from lower-level API calls.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ebed80eb86233fab6e2b5379562de9775ffe2e21" translate="yes" xml:space="preserve">
          <source>A span of text wrapped in asterisks (&lt;code&gt;*&lt;/code&gt;) is emphasized, and text wrapped in two asterisks (&lt;code&gt;**&lt;/code&gt;) is strongly emphasized:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4762ac489724656b1a0c7c273b89622b35dd42e5" translate="yes" xml:space="preserve">
          <source>A static array &lt;code&gt;T[dim]&lt;/code&gt; can be implicitly converted to one of the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="503b1cd5041c9f832a5dfa476e07423ac07fe21d" translate="yes" xml:space="preserve">
          <source>A static array constructed from &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a546994264658c0bb6793fa47d07dceb84796aa" translate="yes" xml:space="preserve">
          <source>A static array with a dimension of 0 is allowed, but no space is allocated for it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ba99ac5c994db50a264f1a8103a1072e41e4bd6" translate="yes" xml:space="preserve">
          <source>A static constructor is a function that performs initializations of thread local data before the &lt;code&gt;main()&lt;/code&gt; function gets control for the main thread, and upon thread startup.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55ddf0925f26b59946dae28233d6fdfaaa7329f1" translate="yes" xml:space="preserve">
          <source>A static destructor gets called on thread termination, but only if the static constructor completed successfully. Static destructors have empty parameter lists. Static destructors get called in the reverse order that the static constructors were called in.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff247e4fd411c5dd8e2c32f15b27c31dc37dd89a" translate="yes" xml:space="preserve">
          <source>A static destructor is defined as a special static function with the syntax &lt;code&gt;static ~this()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33e2d43ef4615d3925e034bec4d4921e1e6d6425" translate="yes" xml:space="preserve">
          <source>A static instance of the expression, typed as &lt;code&gt;Tint32&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b826ff3a676670f0d088e1cd9b512a0238306126" translate="yes" xml:space="preserve">
          <source>A string containing the path given by &lt;code&gt;path&lt;/code&gt;, but where the extension has been set to &lt;code&gt;ext&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69c56f08ab57e676746d4e01be6a9cc3952f4ae4" translate="yes" xml:space="preserve">
          <source>A string formatted in the ISO Extended format for dates and times.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef701934bf57ae45596601643b85ee15d3f2485e" translate="yes" xml:space="preserve">
          <source>A string formatted in the ISO Extended format for dates.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2da20ec434f95bb8d5443fe8e314ce1623955145" translate="yes" xml:space="preserve">
          <source>A string formatted in the ISO Extended format for times.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a00e008e78aea96cbfa32fcdb23e6a8b450b797c" translate="yes" xml:space="preserve">
          <source>A string formatted in the ISO format for dates and times.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a3df60399b45643cd31eb34963073f7812833b6" translate="yes" xml:space="preserve">
          <source>A string formatted in the ISO format for dates.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04939a3353d03734d347b05e3ca2729bd9a9341a" translate="yes" xml:space="preserve">
          <source>A string formatted in the ISO format for times.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0643f1e9bd52d0a8a25555e18edbd5da7b51bdf5" translate="yes" xml:space="preserve">
          <source>A string formatted in the way that &lt;code&gt;toSimpleString&lt;/code&gt; formats dates and times.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f962ea73f49b39339b4922f88a0c238e4ba1325d" translate="yes" xml:space="preserve">
          <source>A string formatted in the way that toSimpleString formats dates and times.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="632ab3df5f88419d1e31f1d1cee5760bbb59e7a9" translate="yes" xml:space="preserve">
          <source>A string formatted in the way that toSimpleString formats dates.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd3280dc41aa99bf0618b972c678e1b7727cbc29" translate="yes" xml:space="preserve">
          <source>A string is an array of characters. String literals are just an easy way to write character arrays. String literals are immutable (read only).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4693492ea4f8cc4f79d65fb1c5fff8fc71f5424c" translate="yes" xml:space="preserve">
          <source>A string listing the name of each JSON field. Useful for errors messages.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2dfa7f97ca7b310eefa5e44ed45cbd5a9d6fba44" translate="yes" xml:space="preserve">
          <source>A string literal is either a double quoted string, a wysiwyg quoted string, a delimited string, a token string, or a hex string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91c359df16c8f1e8cc04e86239901e547e4069a7" translate="yes" xml:space="preserve">
          <source>A string of the same type as &lt;code&gt;input&lt;/code&gt; with the all of the matches (if any) replaced. If no match is found returns the input string itself.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2e9744762303d84756cc38d0bb797a1dfb35ea5" translate="yes" xml:space="preserve">
          <source>A string of the same type with the first match (if any) replaced. If no match is found returns the input string itself.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3572bd9c75fcb62fc2a06156321d1044ce974ae" translate="yes" xml:space="preserve">
          <source>A string or a callable</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ade01e08f23d876345b07c46538697febd10cde1" translate="yes" xml:space="preserve">
          <source>A string to be mixed in to an aggregate, such as a &lt;code&gt;struct&lt;/code&gt; or &lt;code&gt;class&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d73e7649de9a0fce40f5dced1b091b66c878d3f" translate="yes" xml:space="preserve">
          <source>A struct can be prevented from being nested by using the static attribute, but then of course it will not be able to access variables from its enclosing scope.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f09ef100c2ee69f17128a0533548f020c5d9e4c" translate="yes" xml:space="preserve">
          <source>A struct constructor is called by the name of the struct followed by &lt;a href=&quot;class#Parameters&quot;&gt;&lt;i&gt;Parameters&lt;/i&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00e185de50d62e9d91d5d52f4d70129a74a374a6" translate="yes" xml:space="preserve">
          <source>A struct declaration can have a storage class of &lt;code&gt;const&lt;/code&gt;, &lt;code&gt;immutable&lt;/code&gt; or &lt;code&gt;shared&lt;/code&gt;. It has an equivalent effect as declaring each member of the struct as &lt;code&gt;const&lt;/code&gt;, &lt;code&gt;immutable&lt;/code&gt; or &lt;code&gt;shared&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e4f169c05b38809d1d31f76423e59d52a2b4315" translate="yes" xml:space="preserve">
          <source>A struct is defined to not have an identity; that is, the implementation is free to make bit copies of the struct as convenient.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9bc9847f25ea362b6740a9b93ab804ef00434940" translate="yes" xml:space="preserve">
          <source>A struct literal. &lt;a href=&quot;#Value&quot;&gt;&lt;i&gt;Value&lt;/i&gt;&lt;/a&gt; is repeated &lt;a href=&quot;#Number&quot;&gt;&lt;i&gt;Number&lt;/i&gt;&lt;/a&gt; times.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="286be268efaafbe7332e602d9baab19f8148f3ca" translate="yes" xml:space="preserve">
          <source>A struct or union is</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="306c597a82d5ab4af2135e10c7b985f1b617d325" translate="yes" xml:space="preserve">
          <source>A struct representing an arbitrary precision integer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="526765a5620c1404cef412a5aba1cb550dfea2fe" translate="yes" xml:space="preserve">
          <source>A struct with a disabled default constructor, and no other constructors, cannot be instantiated other than via a &lt;a href=&quot;declaration#VoidInitializer&quot;&gt;&lt;i&gt;VoidInitializer&lt;/i&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44cac3ef6b0f178c3af52d9fad3a48b33c922f31" translate="yes" xml:space="preserve">
          <source>A structure designed to effectively pack &lt;a href=&quot;#Character&quot;&gt;characters&lt;/a&gt; of a &lt;a href=&quot;#Grapheme%20cluster&quot;&gt;grapheme cluster&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1dee43ab463ff81471969585aaeb25d27e17a8d5" translate="yes" xml:space="preserve">
          <source>A sub-type of &lt;code&gt;Tuple!()&lt;/code&gt; of the split portions of &lt;code&gt;haystack&lt;/code&gt; (see above for details). This sub-type of &lt;code&gt;Tuple!()&lt;/code&gt; has &lt;code&gt;opCast&lt;/code&gt; defined for &lt;code&gt;bool&lt;/code&gt;. This &lt;code&gt;opCast&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt; when the separating &lt;code&gt;needle&lt;/code&gt; was found and &lt;code&gt;false&lt;/code&gt; otherwise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ceb760806d127d92222223abf19d6e9a9a642d1" translate="yes" xml:space="preserve">
          <source>A subset of flags supported on all platforms with getaddrinfo. Specifies option flags for &lt;code&gt;getAddressInfo&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5fdcf48534cbb5ac5ca95f825a7e9b13b6291b8b" translate="yes" xml:space="preserve">
          <source>A switch statement goes to one of a collection of case statements depending on the value of the switch expression.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d52ce29a153bfcaed221e76bcfa3b8652e6334d" translate="yes" xml:space="preserve">
          <source>A switch statement must have a default statement.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="243f938b3c97b4e1d8eadd9d338c92b666235144" translate="yes" xml:space="preserve">
          <source>A symbol can be declared as an</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84b715dd42cb515250f3406c66517dd9d7115450" translate="yes" xml:space="preserve">
          <source>A table in the database is locked</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34955ed2643e3acedc24870a54a36ec54c1a46f3" translate="yes" xml:space="preserve">
          <source>A tagged class reference uses the bits known to be zero in a normal class reference to store extra information. For example, a pointer to an integer must be 4-byte aligned, so there are 2 bits that are always known to be zero. One can store a 2-bit integer there.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bec6ca0b9e854ba9b4dc6eeb575b3e2cf1fbdc8a" translate="yes" xml:space="preserve">
          <source>A tagged pointer uses the bits known to be zero in a normal pointer or class reference to store extra information. For example, a pointer to an integer must be 4-byte aligned, so there are 2 bits that are always known to be zero. One can store a 2-bit integer there.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71dbdba1f186a3e3df4f62b2ce30433dcfeb9ff8" translate="yes" xml:space="preserve">
          <source>A template instance that requires IFTI: foo!tiargs(fargs) // foo!tiargs is left until CallExp::semantic() or resolveProperties()</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c487a2a162f74902ff60920af22e2df0fcc4fd2b" translate="yes" xml:space="preserve">
          <source>A template instantiation can be aliased:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ec9a1a961c15a72835c9d805bb9f5cb8a6a13d6" translate="yes" xml:space="preserve">
          <source>A templated &lt;code&gt;struct&lt;/code&gt; can become a nested &lt;code&gt;struct&lt;/code&gt; if it is instantiated with a local symbol passed as an aliased argument:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="286beb1ed5435d657d4bd322969e6d1bee678996" translate="yes" xml:space="preserve">
          <source>A text file of macro definitions can be created, and specified in &lt;code&gt;sc.ini&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2c74bdd28417e72ddc700c54f50c8aefa1946fb" translate="yes" xml:space="preserve">
          <source>A textual representation of the email status</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="635a851773d8480d1d8ecc449412eec073d321df" translate="yes" xml:space="preserve">
          <source>A tuple consisting of &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y = f(x)&lt;/code&gt; and &lt;code&gt;error = 3 * (absTolerance * fabs(x) + relTolerance)&lt;/code&gt;.  The method used is a combination of golden section search and successive parabolic interpolation. Convergence is never much slower than that for a Fibonacci search.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ef0df844df69a5568d48b91fa199dcc9de56bc7" translate="yes" xml:space="preserve">
          <source>A tuple consisting of two ranges. The first two elements are the range (in &lt;code&gt;x&lt;/code&gt;) of the root, while the second pair of elements are the corresponding function values at those points. If an exact root was found, both of the first two elements will contain the root, and the second pair of elements will be 0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6012f9e438732b6c8c1f1bc9808a6995a46a0ce0" translate="yes" xml:space="preserve">
          <source>A tuple containing &lt;code&gt;haystack&lt;/code&gt; positioned to match one of the needles and also the 1-based index of the matching element in &lt;code&gt;needles&lt;/code&gt; (0 if none of &lt;code&gt;needles&lt;/code&gt; matched, 1 if &lt;code&gt;needles[0]&lt;/code&gt; matched, 2 if &lt;code&gt;needles[1]&lt;/code&gt; matched...). The first needle to be found will be the one that matches. If multiple needles are found at the same spot in the range, then the shortest one is the one which matches (if multiple needles of the same length are found at the same spot (e.g &lt;code&gt;&quot;a&quot;&lt;/code&gt; and &lt;code&gt;'a'&lt;/code&gt;), then the left-most of them in the argument list matches).  The relationship between &lt;code&gt;haystack&lt;/code&gt; and &lt;code&gt;needles&lt;/code&gt; simply means that one can e.g. search for individual &lt;code&gt;int&lt;/code&gt;s or arrays of &lt;code&gt;int&lt;/code&gt;s in an array of &lt;code&gt;int&lt;/code&gt;s. In addition, if elements are individually comparable, searches of heterogeneous types are allowed as well: a &lt;code&gt;double[]&lt;/code&gt; can be searched for an &lt;code&gt;int&lt;/code&gt; or a &lt;code&gt;short[]&lt;/code&gt;, and conversely a &lt;code&gt;long&lt;/code&gt; can be searched for a &lt;code&gt;float&lt;/code&gt; or a &lt;code&gt;double[]&lt;/code&gt;. This makes for efficient searches without the need to coerce one side of the comparison into the other's side type.  The complexity of the search is &amp;Omicron;(&lt;code&gt;haystack.length * max(needles.length)&lt;/code&gt;). (For needles that are individual items, length is considered to be 1.) The strategy used in searching several subranges at once maximizes cache usage by moving in &lt;code&gt;haystack&lt;/code&gt; as few times as possible.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ded0856f6fc1b75ce8ecf0a9f7b88274ab801b0f" translate="yes" xml:space="preserve">
          <source>A tuple of ParameterStorageClass bits</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd35c428724dd8619e23fbf0f2a7e57058b4f08d" translate="yes" xml:space="preserve">
          <source>A tuple with &lt;code&gt;isMutable&lt;/code&gt; and &lt;code&gt;isNotShared&lt;/code&gt; set if the &lt;code&gt;lhsMod&lt;/code&gt; is missing those modifiers (compared to rhs).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87f68985da3ea589273931016f24036b553a5f0d" translate="yes" xml:space="preserve">
          <source>A type &lt;code&gt;S&lt;/code&gt; gets compiler-generated &lt;code&gt;opAssign&lt;/code&gt; in case it has an elaborate copy constructor or elaborate destructor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2925ba28f3ef4457063b11b5313b546bc942531" translate="yes" xml:space="preserve">
          <source>A type called StaticClassXXXX which defines all the static members.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4bafd715c2d842fc48782a23197830301ac6594f" translate="yes" xml:space="preserve">
          <source>A typesafe structure for storing combinations of enum values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19bbabc23db1d89e38664a27a9f383fa929906e5" translate="yes" xml:space="preserve">
          <source>A typical use-case is to perform lazy but thread-safe initialization.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1108e01a71348662d4697940c03ca612a789d5db" translate="yes" xml:space="preserve">
          <source>A typical workaround would be to use array vector operations instead:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="622333820bdb5ef06fbb318f56dcf3f6445745f2" translate="yes" xml:space="preserve">
          <source>A unique hash of the &lt;code&gt;BigInt&lt;/code&gt;'s value suitable for use in a hash table.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2198d4c146bec18fd1ce6760a109cc4921cdd05d" translate="yes" xml:space="preserve">
          <source>A unit test for a function should appear immediately following it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a517fa6a3c0c868fd6ae7e933059bd47b7df17a" translate="yes" xml:space="preserve">
          <source>A unittest may be attributed with any of the global function attributes. Such unittests are useful in verifying the given attribute(s) on a template function:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ae21aa22fe7948e4c729f1540b79f8cd693afe8" translate="yes" xml:space="preserve">
          <source>A unittest which is not documented, or is marked as private will not be used to generate code samples.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c1c04f676b35796be10ffb3edecc8f6268e7b22" translate="yes" xml:space="preserve">
          <source>A useful and popular use of algebraic data structures is for defining &lt;a href=&quot;https://google.com/search?btnI=I%27m+Feeling+Lucky&amp;amp;ie=UTF-8&amp;amp;oe=UTF-8&amp;amp;q=self-referential%20data%20structures&quot;&gt;self-referential data structures&lt;/a&gt;, i.e. structures that embed references to values of their own type within.  This is achieved with &lt;code&gt;Algebraic&lt;/code&gt; by using &lt;code&gt;This&lt;/code&gt; as a placeholder whenever a reference to the type being defined is needed. The &lt;code&gt;Algebraic&lt;/code&gt; instantiation will perform &lt;a href=&quot;https://en.wikipedia.org/wiki/Name_resolution_(programming_languages)#Alpha_renaming_to_make_name_resolution_trivial&quot;&gt;alpha renaming&lt;/a&gt; on its constituent types, replacing &lt;code&gt;This&lt;/code&gt; with the self-referenced type. The structure of the type involving &lt;code&gt;This&lt;/code&gt; may be arbitrarily complex.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5cd31092f50e6668ec7962d66b14d97f0b254db8" translate="yes" xml:space="preserve">
          <source>A useful technique for Unicode-aware parsers that perform character classification of encoded &lt;a href=&quot;#Code%20point&quot;&gt;code points&lt;/a&gt; is to avoid unnecassary decoding at all costs. &lt;a href=&quot;#utfMatcher&quot;&gt;&lt;code&gt;utfMatcher&lt;/code&gt;&lt;/a&gt; provides an improvement over the usual workflow of decode-classify-process, combining the decoding and classification steps. By extracting necessary bits directly from encoded &lt;a href=&quot;#Code%20unit&quot;&gt;code units&lt;/a&gt; matchers achieve significant performance improvements. See &lt;a href=&quot;#MatcherConcept&quot;&gt;&lt;code&gt;MatcherConcept&lt;/code&gt;&lt;/a&gt; for the common interface of UTF matchers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e9a2a2de1ba1fef47986aeaad29546ee2f0c629" translate="yes" xml:space="preserve">
          <source>A user-defined attribute looks like:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ec4f05c1da31924f6c46c6e8eceeade66257fb8" translate="yes" xml:space="preserve">
          <source>A user-defined one can implement the equivalent semantics, but can be more efficient.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24ccdd70677c403ccb2a313c4c9c32fa6f8c9c76" translate="yes" xml:space="preserve">
          <source>A user:password in the URL will be ignored. Unless one is set programmatically, the .netrc will be queried.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c2902f73aa9094938733525713baf7d27f4d32d" translate="yes" xml:space="preserve">
          <source>A user:password in the URL will be preferred to one in the .netrc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bfd68567162b198b169e63ff6f9ce0abafc592a1" translate="yes" xml:space="preserve">
          <source>A value from &lt;code&gt;input&lt;/code&gt; of type &lt;code&gt;T&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fab34a840eca5f0af3a6adfab162743b8b96ab0f" translate="yes" xml:space="preserve">
          <source>A value of 1 means that no alignment is done; fields are packed together.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f087658ff6dd881c1c276fc1abe86c63c82fce4" translate="yes" xml:space="preserve">
          <source>A value of type &lt;code&gt;T&lt;/code&gt; to assign to this &lt;code&gt;Nullable&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92fc64d8ff9ab394a43cf1989c0c0f6d5f276117" translate="yes" xml:space="preserve">
          <source>A value of type &lt;code&gt;T&lt;/code&gt; to assign to this &lt;code&gt;Nullable&lt;/code&gt;. If it is &lt;code&gt;nullvalue&lt;/code&gt;, then the internal state of this &lt;code&gt;Nullable&lt;/code&gt; will be set to null.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="595ffc8e3de776e07c75f9495e539287bfe40f7d" translate="yes" xml:space="preserve">
          <source>A value of type &lt;code&gt;T&lt;/code&gt; to assign to this &lt;code&gt;NullableRef&lt;/code&gt;. If the internal state of this &lt;code&gt;NullableRef&lt;/code&gt; has not been initialized, an error will be thrown in non-release mode.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0312bacf411c0359c567722d8da661969980e011" translate="yes" xml:space="preserve">
          <source>A variable storing the number of digits of the factorial number stored in &lt;code&gt;fac&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1288e9434e2f0aa83f354b220fc3320a00da2bf3" translate="yes" xml:space="preserve">
          <source>A variadic array of &lt;code&gt;Statement&lt;/code&gt;s, that will copied in this class The entries themselves will not be copied.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f46908d75fb188ea17f0c418cfb5fce0d59b00a5" translate="yes" xml:space="preserve">
          <source>A variant on interfaces is the COM interface. A COM interface is designed to map directly onto a Windows COM object. Any COM object can be represented by a COM interface, and any D object with a COM interface can be used by external COM clients.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74bc7034954daf05645c8bdf69b200a66acd5b8d" translate="yes" xml:space="preserve">
          <source>A variation on &lt;a href=&quot;#replaceAll&quot;&gt;&lt;code&gt;replaceAll&lt;/code&gt;&lt;/a&gt; that instead of allocating a new string on each call outputs the result piece-wise to the &lt;code&gt;sink&lt;/code&gt;. In particular this enables efficient construction of a final output incrementally.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="558bf167836891063033473ff39e29c40f76a6ae" translate="yes" xml:space="preserve">
          <source>A variation on &lt;a href=&quot;#replaceFirst&quot;&gt;&lt;code&gt;replaceFirst&lt;/code&gt;&lt;/a&gt; that instead of allocating a new string on each call outputs the result piece-wise to the &lt;code&gt;sink&lt;/code&gt;. In particular this enables efficient construction of a final output incrementally.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd2627bfee6415d1e46fb27e196853613a72b036" translate="yes" xml:space="preserve">
          <source>A variation on &lt;a href=&quot;#spawnProcess&quot;&gt;&lt;code&gt;spawnProcess&lt;/code&gt;&lt;/a&gt; that runs the given command through the current user's preferred command interpreter (aka. shell).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06c25ac99fc939d88ae07ec02cd1e2eaea8adf25" translate="yes" xml:space="preserve">
          <source>A vector operation is indicated by the slice operator appearing as the left-hand side of an assignment or an op-assignment expression. The right-hand side can be an expression consisting either of an array slice of the same length and type as the left-hand side or a scalar expression of the element type of the left-hand side, in any combination.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0201e0884279f412eec70152c95bca634cabe90f" translate="yes" xml:space="preserve">
          <source>A version condition is of the form:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="036b91c045d7afd669b86e632efdeb65cf70fbe8" translate="yes" xml:space="preserve">
          <source>A version of &lt;a href=&quot;#Appender&quot;&gt;&lt;code&gt;Appender&lt;/code&gt;&lt;/a&gt; that can update an array in-place. It forwards all calls to an underlying appender implementation. Any calls made to the appender also update the pointer to the original array passed in.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f69ae09b687c0f70931e5d637c3720fd96bc47f" translate="yes" xml:space="preserve">
          <source>A very important attribute of the Unicode Normalization Forms is that they must remain stable between versions of the Unicode Standard. A Unicode string normalized to a particular Unicode Normalization Form in one version of the standard is guaranteed to remain in that Normalization Form for implementations of future versions of the standard.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="204a1d9da8aeb4ccbb41074798c36ae598e785cb" translate="yes" xml:space="preserve">
          <source>A visitor to walk entire statements and provides ability to replace any sub-statements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ecda6fbd787080a0c71eaf580a2379d0a84fd558" translate="yes" xml:space="preserve">
          <source>A way to construct optimal packed multi-stage tables also known as a special case of &lt;a href=&quot;https://en.wikipedia.org/wiki/Trie&quot;&gt;Trie&lt;/a&gt;. The functions &lt;a href=&quot;#codepointTrie&quot;&gt;&lt;code&gt;codepointTrie&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#codepointSetTrie&quot;&gt;&lt;code&gt;codepointSetTrie&lt;/code&gt;&lt;/a&gt; construct custom tries that map dchar to value. The end result is a fast and predictable &amp;Omicron;(&lt;code&gt;1&lt;/code&gt;) lookup that powers functions like &lt;a href=&quot;#isAlpha&quot;&gt;&lt;code&gt;isAlpha&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#combiningClass&quot;&gt;&lt;code&gt;combiningClass&lt;/code&gt;&lt;/a&gt;, but for user-defined data sets.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="179d3c78fdb472871d26dca4bbdeaf8b134c8648" translate="yes" xml:space="preserve">
          <source>A word-aligned buffer of &lt;code&gt;n&lt;/code&gt; bytes, or &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5bda91bd2eb64cc9ebd789e00ffee28462db953" translate="yes" xml:space="preserve">
          <source>A wrapper &lt;code&gt;struct&lt;/code&gt; that preserves the range interface of &lt;code&gt;input&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d29ec600e62a50d3d9eec98dae8f8d3e051f7de3" translate="yes" xml:space="preserve">
          <source>A wrapper around a list of allocators which allow for very fast deallocations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15c2c153bb71919b5cdec457823f4fd9f8d71bf9" translate="yes" xml:space="preserve">
          <source>A wrapper for whatever the main thread would have done in the absence of a custom scheduler. It will be automatically executed via a call to spawn by the Scheduler.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66b2f8e9850db5c9a0ef26a091089e2397efa6e8" translate="yes" xml:space="preserve">
          <source>A wrapper on top of the built-in cast operator that allows one to restrict casting of the original type of the value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d26b628f187d45bc4e12de9cc9385d4c6d2e0a9b" translate="yes" xml:space="preserve">
          <source>A writer sub-mutex.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74f058625ae51d7f9a4f0234f03e7d2e3133d478" translate="yes" xml:space="preserve">
          <source>A zero was generated by underflow</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce3098487e1cd9f75cd7cad95483a4b4deb5588e" translate="yes" xml:space="preserve">
          <source>A* &lt;code&gt;arr&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a30240d9b1407524e8eee853f1720d4610565ce4" translate="yes" xml:space="preserve">
          <source>AA &lt;code&gt;aa&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76c631f781a8d0368d8a6ea89a0fbce4e43bfbaa" translate="yes" xml:space="preserve">
          <source>AA version for debuggers, bump whenever changing the layout</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e563eabeb4bf3cec4d1e28f9fcc377ee1ff90bd" translate="yes" xml:space="preserve">
          <source>AA* &lt;code&gt;aa&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0ab529de7da6070afe29cdd8345d68a47ee6fbe" translate="yes" xml:space="preserve">
          <source>AMD Athlon (K7, K8, K10).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="624f7573dca9fe5ebe0a6858283e1c5d9432014a" translate="yes" xml:space="preserve">
          <source>AMD Opcodes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="039721a06435401a74bdd364a8f46ca9309e70c2" translate="yes" xml:space="preserve">
          <source>AMD Opcodes Supported</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ca0a1dafaea5e84f002eb1c3a7a92dd033b7a8c" translate="yes" xml:space="preserve">
          <source>APIs</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b6bf129e90e87f19aebb266c7797207c07f48fe" translate="yes" xml:space="preserve">
          <source>ARM in Thumb mode; use &lt;code&gt;ARM_Thumb&lt;/code&gt; instead</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb1fdcfffd40402c89d0d4bb3b0d681220235dda" translate="yes" xml:space="preserve">
          <source>ARM in any Thumb mode</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94090230b1f8c256f7ac5dc5a70bd3b20ee4ff15" translate="yes" xml:space="preserve">
          <source>ASCII</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89174118a4a495c66300fbe7239a480764509b25" translate="yes" xml:space="preserve">
          <source>ASCII i string to capitalize</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f7fc546df38aeee4d77978d5dcfbe350f0e2747" translate="yes" xml:space="preserve">
          <source>ASCII whitespace</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ef82a5dc44fd8e8e212aabe32c11cac57294938" translate="yes" xml:space="preserve">
          <source>ASCII-only</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6fc55697bc9a0a7e365add2e6ecfcd149e10701c" translate="yes" xml:space="preserve">
          <source>ASCII_Hex_Digit</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a579237e1f01010812c214ab27a5b3beb489ff76" translate="yes" xml:space="preserve">
          <source>AST node for &lt;code&gt;EnumDeclaration&lt;/code&gt;&lt;a href=&quot;https://dlang.org/spec/enum.html#EnumDeclaration&quot;&gt;https://dlang.org/spec/enum.html#EnumDeclaration&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2e1a886f972c32fded02bd26e8e6b865f2eb255" translate="yes" xml:space="preserve">
          <source>AST node representing a member of an enum. &lt;a href=&quot;https://dlang.org/spec/enum.html#EnumMember&quot;&gt;https://dlang.org/spec/enum.html#EnumMember&lt;/a&gt;&lt;a href=&quot;https://dlang.org/spec/enum.html#AnonymousEnumMember&quot;&gt;https://dlang.org/spec/enum.html#AnonymousEnumMember&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4856a925a6f71d775d2a2dd67176ae2d0a9e9f77" translate="yes" xml:space="preserve">
          <source>AST.Expression &lt;strong id=&quot;parsePrimaryExp&quot;&gt;parsePrimaryExp&lt;/strong&gt;();</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3fec866346bd5e2dcb25d972f5a97367df05503" translate="yes" xml:space="preserve">
          <source>AST.Statement &lt;strong id=&quot;parseStatement&quot;&gt;parseStatement&lt;/strong&gt;(int flags, const(char)** endPtr = null, Loc* pEndloc = null);</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="debca9f07fb54076426713e9f9bdcd3e1e056b0e" translate="yes" xml:space="preserve">
          <source>AVX Vector instructions are supported</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44a916ba2993444e910670ef65cccc667bfc068f" translate="yes" xml:space="preserve">
          <source>AVX2 Vector instructions are supported</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc32691eed408bcffd208331061395fcb95f2539" translate="yes" xml:space="preserve">
          <source>Abb.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d87c8562414047004383cefab06dde994ab29260" translate="yes" xml:space="preserve">
          <source>Abort due to constraint violation</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28ef1e43dd92ae02027dd18a6bebb7e635d80224" translate="yes" xml:space="preserve">
          <source>Abort the SQL statement with an error</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14230c93975c238bf7c790d700013262220823e1" translate="yes" xml:space="preserve">
          <source>Abort the send and return.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa41dd8e948e2dab26d97077811c4859daf44a19" translate="yes" xml:space="preserve">
          <source>Above, &lt;code&gt;Foo!().foo&lt;/code&gt; will work just the same as a member function of class &lt;code&gt;C&lt;/code&gt;, and &lt;code&gt;Bar!().bar&lt;/code&gt; will work just the same as a nested function within function &lt;code&gt;main()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72be1abc9c41f18cb036851d094c7e5ee1691674" translate="yes" xml:space="preserve">
          <source>Absolute tolerance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5065cb3ac6b52ca94db622cc45ddec46996ff941" translate="yes" xml:space="preserve">
          <source>Abstract base class for XML items</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa5896f602b41f6e737833e94bdb9dfbf32d9f47" translate="yes" xml:space="preserve">
          <source>Abstract base class of all encoding schemes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd71c6586a6fb20a005525c1ab9479acf96f2316" translate="yes" xml:space="preserve">
          <source>Abstract characters not directly encoded by the Unicode Standard can often be represented by the use of combining character sequences.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9ce51b5c3d269c08cea6f74d4b2f5fd2e587775" translate="yes" xml:space="preserve">
          <source>Accept an incoming connection. If the socket is blocking, &lt;code&gt;accept&lt;/code&gt; waits for a connection request. Throws &lt;code&gt;SocketAcceptException&lt;/code&gt; if unable to accept. See &lt;code&gt;accepting&lt;/code&gt; for use with derived classes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3697222ce3b5ee0c832014446956a71a9e3f9768" translate="yes" xml:space="preserve">
          <source>Accepted units are &lt;code&gt;&quot;days&quot;&lt;/code&gt;, &lt;code&gt;&quot;minutes&quot;&lt;/code&gt;, &lt;code&gt;&quot;hours&quot;&lt;/code&gt;, &lt;code&gt;&quot;minutes&quot;&lt;/code&gt;, &lt;code&gt;&quot;seconds&quot;&lt;/code&gt;, &lt;code&gt;&quot;msecs&quot;&lt;/code&gt;, &lt;code&gt;&quot;usecs&quot;&lt;/code&gt;, and &lt;code&gt;&quot;hnsecs&quot;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4354a6713d7ad0caea954c67b888e32cf0474a8" translate="yes" xml:space="preserve">
          <source>Accepted units are &lt;code&gt;&quot;days&quot;&lt;/code&gt;, &lt;code&gt;&quot;minutes&quot;&lt;/code&gt;, &lt;code&gt;&quot;hours&quot;&lt;/code&gt;, &lt;code&gt;&quot;minutes&quot;&lt;/code&gt;, and &lt;code&gt;&quot;seconds&quot;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5fe93e8eee53666f950c9ca80808bfeb7d041149" translate="yes" xml:space="preserve">
          <source>Accepted units are &lt;code&gt;&quot;hours&quot;&lt;/code&gt;, &lt;code&gt;&quot;minutes&quot;&lt;/code&gt;, and &lt;code&gt;&quot;seconds&quot;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2757cba57a7420e39d1261498e6488dd5ac45155" translate="yes" xml:space="preserve">
          <source>Accepts a path to either a file or a directory. In the former case, the basepath (path to the containing directory) will be checked for existence, and created if it does not exists. In the later case, the directory pointed to will be checked for existence and created if needed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="baa49dd84c2f97d1400c5b886e7457901cafa944" translate="yes" xml:space="preserve">
          <source>Access C++ std::type_info's virtual functions from D, being careful to not require linking with libstd++ or interfere with core.stdcpp.typeinfo. So, give it a different name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8cee105dc9286540eb8273e1a66712fc79c398e3" translate="yes" xml:space="preserve">
          <source>Access Control</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1777ced1e09bfb3a20d75e96ad2f4ce23f4f24f" translate="yes" xml:space="preserve">
          <source>Access labels AA from C++ code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf0ad5ada4db8ecde7f83bac072e7c784cdc3f1f" translate="yes" xml:space="preserve">
          <source>Access permission denied</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bee6f9fa537ba79f8b898add7fb4d8af609c3d99" translate="yes" xml:space="preserve">
          <source>Access the members of the object e. This type is same as e.type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd91024887ec34e3b4d4c550ead58d4e228f98e0" translate="yes" xml:space="preserve">
          <source>Access to a large selection of commonly used sets of &lt;a href=&quot;#Code%20point&quot;&gt;code points&lt;/a&gt;. &lt;a href=&quot;#Unicode%20properties&quot;&gt;Supported sets&lt;/a&gt; include Script, Block and General Category. The exact contents of a set can be observed in the CLDR utility, on the &lt;a href=&quot;http://www.unicode.org/cldr/utility/properties.jsp&quot;&gt;property index&lt;/a&gt; page of the Unicode website. See &lt;a href=&quot;#unicode&quot;&gt;&lt;code&gt;unicode&lt;/code&gt;&lt;/a&gt; for easy and (optionally) compile-time checked set queries.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f2d0eae88d66a5fc766687a84f6f7f91d5ae27d" translate="yes" xml:space="preserve">
          <source>Access to class members is controlled using &lt;a href=&quot;attribute#visibility_attributes&quot;&gt; visibility attributes&lt;/a&gt;. The default visibility attribute is &lt;code&gt;public&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="307fc632b58de82a174b55210d8d42a94693e17a" translate="yes" xml:space="preserve">
          <source>Access to variadic arguments is done using the standard library module &lt;code&gt;core.stdc.stdarg&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6f1467ab57ce45967443e18135c914da7e45a13" translate="yes" xml:space="preserve">
          <source>Accessing C Globals</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="beb23fe078814adbeacefa1f1f2dfb764f4b3413" translate="yes" xml:space="preserve">
          <source>Accessing Individual Vector Elements</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db7fc46962b3e4858cae12b974315033c117901c" translate="yes" xml:space="preserve">
          <source>Accessing variable v. Check for purity and safety violations. Returns true if error occurs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9beb96dac88f56752e0ce800d691ef1a92595d9b" translate="yes" xml:space="preserve">
          <source>Acknowledge</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d47f537dcb350bf669800548ceb300b34426ee2" translate="yes" xml:space="preserve">
          <source>Acquires a read lock on the enclosing mutex.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99ed81fec0ff177b818b848aa967a2dc6a60b509" translate="yes" xml:space="preserve">
          <source>Acquires a write lock on the enclosing mutex.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34be5c3351b113f2cad4cc4a8602e9f1303b4543" translate="yes" xml:space="preserve">
          <source>Adam D. Ruppe</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e9e257be9ac18996821b962c7a49ec73c7aba38" translate="yes" xml:space="preserve">
          <source>Adapted with minimal changes from the work of David L. Davis (refer to the &lt;a href=&quot;http://forum.dlang.org/post/cfk7ql&amp;amp;dollar;1p4n&amp;amp;dollar;1@digitaldaemon.com&quot;&gt;original announcement&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c5a3264f3bad4a3d08e2dbdc79dc6adf56d9043" translate="yes" xml:space="preserve">
          <source>Add Content To A Dynamic String</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="783f29b92ccf3cb30aa2e12d525b1971eef1ba41" translate="yes" xml:space="preserve">
          <source>Add Expressions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a1ad0f8b610189b63e4cb0f7b4aed4a9b1d3a61" translate="yes" xml:space="preserve">
          <source>Add MODxxxx bits to existing type. We're adding, not replacing, so adding const to a shared type =&amp;gt; &quot;shared const&quot;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f6598ae97b68f3c9b2eca03bcb16039c37701f3" translate="yes" xml:space="preserve">
          <source>Add a &lt;code&gt;Socket&lt;/code&gt; to the collection. The socket must not already be in the collection.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf47751bc3702034406ec509e784f3ea1eb6200d" translate="yes" xml:space="preserve">
          <source>Add a command to send to ftp server.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e665ffb3cdd40a1e58b3bf5dfd0804b5aaf86432" translate="yes" xml:space="preserve">
          <source>Add a header e.g. &quot;X-CustomField: Something is fishy&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9b93c9a5ae048bb45d10d62122638eca633993f" translate="yes" xml:space="preserve">
          <source>Add a slot to the list of slots to be called when emit() is called.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58e96b8b192b5161f00d42ec478ec85a678ec3b1" translate="yes" xml:space="preserve">
          <source>Add an IP group membership</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eaee2d4a639caa6d286ce081d0fec7d81fdd68aa" translate="yes" xml:space="preserve">
          <source>Add an interval [a, b) to this set.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d58f391b6636a37e4ed4aadaddc8bc0a051e9638" translate="yes" xml:space="preserve">
          <source>Add an user-supplied global identifier to the list</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68f594a7d8331d79aa134583b826df0691870790" translate="yes" xml:space="preserve">
          <source>Add an user-supplied identifier to the list of global debug identifiers</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff5f9ed6a9198f29682b6e2fdc1784d631624385" translate="yes" xml:space="preserve">
          <source>Add any global identifier to the list, without checking if it's predefined</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="180269a30ba169b4ad5b7a1b7661b30529e56f3a" translate="yes" xml:space="preserve">
          <source>Add de to the archive. The file is compressed on the fly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0795781eaf01631d4376c4aabb0efd2f797184aa" translate="yes" xml:space="preserve">
          <source>Add default &lt;code&gt;version&lt;/code&gt; identifier for dmd, and set the target platform in &lt;code&gt;params&lt;/code&gt;. &lt;a href=&quot;https://dlang.org/spec/version.html#predefined-versions&quot;&gt;https://dlang.org/spec/version.html#predefined-versions&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c84400b54e58a4517104843b16d7336ce756b1a0" translate="yes" xml:space="preserve">
          <source>Add documentation comment to Dsymbol. Ignore NULL comments.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b821ad6b597b9aa864b5401ed9295cf33f19f5bb" translate="yes" xml:space="preserve">
          <source>Add empty fields for padding to have a total bit length of 8, 16, 32, or 64</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27e8affa9a2779909d012a0a9e565d5d9c4930bc" translate="yes" xml:space="preserve">
          <source>Add expressions for floating point operands are not associative.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39654cee35d80be4140c48c2f4acb0a4d3eddad1" translate="yes" xml:space="preserve">
          <source>Add import path to the &lt;code&gt;global.path&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ca0c9e82595b2ff7d12c349025925ae8755eaf0" translate="yes" xml:space="preserve">
          <source>Add import to sd's symbol table.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da23c7c2b4b6933ac5908203dac9c52485b7b4dd" translate="yes" xml:space="preserve">
          <source>Add instance ti to TemplateDeclaration's table of instances. Return a handle we can use to later remove it if it fails instantiation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d414082ffd854e8335dc0549b71c84435addf66" translate="yes" xml:space="preserve">
          <source>Add or get a file from the file cache. If the file isn't part of the cache, it will be read from the filesystem. If the file has been read before, the cached file object will be returned</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a520040bdffe08f3eefdcecf7998ef8840dd4783" translate="yes" xml:space="preserve">
          <source>Add storage class modifiers to type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0dc5179d5d1626885bf2c954280bebcdbc0811f9" translate="yes" xml:space="preserve">
          <source>Add string import path to &lt;code&gt;global.filePath&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37089788442ff881d462af2da489fd68f0412cb3" translate="yes" xml:space="preserve">
          <source>Add t to the list of tracked threads if it is not already being tracked.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a88d5dd379a53bc3a2adc9fd4af43267e851bf42" translate="yes" xml:space="preserve">
          <source>Add the extension &lt;code&gt;ext&lt;/code&gt; to &lt;code&gt;name&lt;/code&gt;, regardless of the content of &lt;code&gt;name&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52a02a5e1fb93d0d15ea7fa0332d56723a1247a4" translate="yes" xml:space="preserve">
          <source>Add to precision as necessary so that the first digit of the octal formatting is a '0', even if both the argument and the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66d00d03ee0d2653e725dd73702a2661d7a02c6b" translate="yes" xml:space="preserve">
          <source>Add two signed integers, checking for overflow.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66fdaf8b303799ed2eb7e0bf44cbe2a7bcbf9b7d" translate="yes" xml:space="preserve">
          <source>Add two unsigned integers, checking for overflow (aka carry).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="edb4a17762e7e7667165a329429cbc010d27e3c1" translate="yes" xml:space="preserve">
          <source>Add variable to maybes[]. When a maybescope variable &lt;code&gt;v&lt;/code&gt; is assigned to a maybescope variable &lt;code&gt;this&lt;/code&gt;, we cannot determine if &lt;code&gt;this&lt;/code&gt; is actually scope until the semantic analysis for the function is completed. Thus, we save the data until then.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3aaf26753f5eadebbc6849954cfee254c2f15e1d" translate="yes" xml:space="preserve">
          <source>Added Since CV4</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4990b86487a33fe06b07471000a0e208027a17e" translate="yes" xml:space="preserve">
          <source>Added to Bionic since Lollipop.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86922b5391f09bc921f8e0e85beb11adcc142c71" translate="yes" xml:space="preserve">
          <source>Adding &lt;code&gt;deallocate&lt;/code&gt; capability to an allocator that lacks it (such as simple regions).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1667d04dd978ce8b93994c5e6826422d13b6b5b0" translate="yes" xml:space="preserve">
          <source>Adding Contracts to Java</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d4e406e41eeda4c6401647b660b3cce1ffbd218" translate="yes" xml:space="preserve">
          <source>Adding or subtracting a &lt;a href=&quot;#Duration&quot;&gt;&lt;code&gt;Duration&lt;/code&gt;&lt;/a&gt; to/from a MonoTime results in a MonoTime which is adjusted by that amount.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b8df2ffa33c3a92e63907cf222e7bd23c2fa650" translate="yes" xml:space="preserve">
          <source>Adding your own Garbage Collector</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d6556acb18b8662a066437c99c4df78f7b12865" translate="yes" xml:space="preserve">
          <source>Additional &lt;code&gt;Logger&lt;/code&gt; can be created by creating a new instance of the required &lt;code&gt;Logger&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d317f4f1de7128a0d4cd8fd921eb8e06ea7ebc6" translate="yes" xml:space="preserve">
          <source>Additional environment variables for the child process.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="168245e7982df504f3251c14992ea04ceb75d2cc" translate="yes" xml:space="preserve">
          <source>Additional environment variables for the child process. (See &lt;a href=&quot;#spawnProcess&quot;&gt;&lt;code&gt;spawnProcess&lt;/code&gt;&lt;/a&gt; for details.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e835350d1c68a871d44080439d13025d3be377ee" translate="yes" xml:space="preserve">
          <source>Additionally the following attributes are only valid for non-static member functions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0f1260010cd19b58b440bfbe6492df580b2aeb8" translate="yes" xml:space="preserve">
          <source>Additionally, this example shows how a new &lt;code&gt;FileLogger&lt;/code&gt; is created. Individual &lt;code&gt;Logger&lt;/code&gt; and the global log functions share commonly named functions to log data.  The names of the functions are as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a136ff61f84c9c4a7228e88b27550819c0abee84" translate="yes" xml:space="preserve">
          <source>Address &lt;strong id=&quot;address&quot;&gt;address&lt;/strong&gt;;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b544b7ba62b9aa270da33d07d9f1852fc51631a7" translate="yes" xml:space="preserve">
          <source>Address containing warnings is considered valid, that is, any status code below 16 is considered valid.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a1be6fc1f7f9662fc7c2b17d5434e70a4a8f2ab" translate="yes" xml:space="preserve">
          <source>Address contains Folding White Space</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="887781f145aaaf658d75f1517b0fb398589f6ee9" translate="yes" xml:space="preserve">
          <source>Address contains a carriage return that is not followed by a line feed</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62b80eb5466f5d5ffa1ab6d5b43626ec70a85c2d" translate="yes" xml:space="preserve">
          <source>Address contains a character that is not allowed</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92528dcc41ae0f2a64e93d533de3ccfed0b942e5" translate="yes" xml:space="preserve">
          <source>Address contains a comment in a position that is deprecated</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c918d7b9e49563c6cbad6a857c4705bf794b76c" translate="yes" xml:space="preserve">
          <source>Address contains a comment or Folding White Space around the @ sign</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65380a42fab34c0f4121362666fdd9910ff2d19a" translate="yes" xml:space="preserve">
          <source>Address contains an obsolete form of Folding White Space</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="381c317957b5ee7582e73884cd558cdbc223631b" translate="yes" xml:space="preserve">
          <source>Address contains comments</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5e2d3cb1fcbce606eb8ccac93ab49310a74b07e" translate="yes" xml:space="preserve">
          <source>Address contains deprecated elements but may still be valid in restricted contexts</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88121f59a17918138d3a99669a4d019180020a55" translate="yes" xml:space="preserve">
          <source>Address contains text after a comment or Folding White Space</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7efe220560e0d5cd3e5e7d43e3e3fd9aca69e6a" translate="yes" xml:space="preserve">
          <source>Address contains text after a quoted string</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee43b6fd8e15e2b41602e256006bcdb0082b3ca4" translate="yes" xml:space="preserve">
          <source>Address family</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8ef22713afbe995add506093e861ef3d18ab313" translate="yes" xml:space="preserve">
          <source>Address has no domain part</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71bff518935e72def54800521f7700ba45be35d6" translate="yes" xml:space="preserve">
          <source>Address has no local part</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0517bb692824017669287d8571ea86907ce7eb9" translate="yes" xml:space="preserve">
          <source>Address is RFC 5322 compliant but contains domain characters that are not allowed by DNS</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d576c3642c5b3b413429d68ea79dca4c6c19abca" translate="yes" xml:space="preserve">
          <source>Address is either considered valid or not, no finer grained error checking is performed. Returned email status code will be either Error or Valid.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fbe50a7d373fa45401392dba0d4f4263b57fb794" translate="yes" xml:space="preserve">
          <source>Address is invalid for any purpose</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f1d8cab19a432244d5e438db730dcd5d7cfc3c1" translate="yes" xml:space="preserve">
          <source>Address is marked.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="056f415145809cf554f197edff3a6210c2a3c84c" translate="yes" xml:space="preserve">
          <source>Address is not managed by the GC.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b276a2a7b3b8082b5205d4f36c48fdb75ab436d5" translate="yes" xml:space="preserve">
          <source>Address is not marked.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00d60928d09249fd5121c82ffadb486ff2af7cda" translate="yes" xml:space="preserve">
          <source>Address is too long</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7114aec6ccd6343782971decf3ba885ed8926cea" translate="yes" xml:space="preserve">
          <source>Address is valid</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8684bf895369a504a173494b46ce79f3bfbff7cd" translate="yes" xml:space="preserve">
          <source>Address is valid but a DNS check was not successful</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="910b30a1f7f08850b97f7aabdcb68e08a1bc037b" translate="yes" xml:space="preserve">
          <source>Address is valid but at a Top Level Domain</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8be421532761d6177a79b25f6bf4e24d2aa48096" translate="yes" xml:space="preserve">
          <source>Address is valid but at a literal address not a domain</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2a0d6b7ee4c32f5a2b735044ea5126f1011eba5" translate="yes" xml:space="preserve">
          <source>Address is valid but contains a :: that only elides one zero group</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="510622562d2c0218e53097ea6e32ac7b80cf235c" translate="yes" xml:space="preserve">
          <source>Address is valid but contains a quoted string</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c451ae2b8582f3467ec31948cc6b1b82ba98f9e" translate="yes" xml:space="preserve">
          <source>Address is valid but the Top Level Domain begins with a number</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ca2422e194aa478738b3920d49b1d72b4a04751" translate="yes" xml:space="preserve">
          <source>Address is valid for SMTP but has unusual elements</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="069a8b8d9763d9ed6d488c79b3db6100b19c762d" translate="yes" xml:space="preserve">
          <source>Address is valid within the message but cannot be used unmodified for the envelope</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="265f5be727c33a8a13245b57c78d571329630167" translate="yes" xml:space="preserve">
          <source>AddressFamily &lt;strong id=&quot;family&quot;&gt;family&lt;/strong&gt;;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9da00639bb3965aa70738e6a575e509275598a8a" translate="yes" xml:space="preserve">
          <source>AddressInfo[] &lt;strong id=&quot;getAddressInfo&quot;&gt;getAddressInfo&lt;/strong&gt;(T...)(scope const(char)[] node, scope T options);</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dffa5b087a5bb8dd265fd7a6cbbd1e0d1d41f678" translate="yes" xml:space="preserve">
          <source>Adds &lt;code&gt;p[0 .. sz]&lt;/code&gt; to the list of memory ranges to be scanned for pointers during a collection. If p is null, no operation is performed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="672314e29bcc5e362e383fbd999c4b5b4410b405" translate="yes" xml:space="preserve">
          <source>Adds a sign bit to allow for signed numbers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee9a206f63997b29125ee641371481b30dee8462" translate="yes" xml:space="preserve">
          <source>Adds a single Element of data without increasing &lt;code&gt;element_count&lt;/code&gt;. Make sure to increase &lt;code&gt;element_count&lt;/code&gt; by &lt;code&gt;Element.sizeof&lt;/code&gt; for each call to &lt;code&gt;putElement&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7bf698b9f6e73db894b28808fd5abdeb21c41a83" translate="yes" xml:space="preserve">
          <source>Adds an internal root pointing to the GC memory block referenced by p. As a result, the block referenced by p itself and any blocks accessible via it will be considered live until the root is removed again.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff12c7ce51172ee3fa78ed53b57f7c8617e36d66" translate="yes" xml:space="preserve">
          <source>Adds assignable elements to BidirectionalRange.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af63794bdee98164b7dedba21a8ddcd815487b81" translate="yes" xml:space="preserve">
          <source>Adds assignable elements to ForwardRange.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d86b2ad49209ff010a91b4e8020be86eef38434b" translate="yes" xml:space="preserve">
          <source>Adds assignable elements to InputRange.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2111dba4f281687d624b61c6aeeecb551c0b910b" translate="yes" xml:space="preserve">
          <source>Adds assignable elements to RandomAccessFinite.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cea0f0bf07e47c7fb0a04a4c50f0f8d4341a2b7e" translate="yes" xml:space="preserve">
          <source>Adds data to the digester. This function can be called many times in a row after start but before finish.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9a3cbb838535843105d2dbd716177d37c6dc90e" translate="yes" xml:space="preserve">
          <source>Adds or subtracts two &lt;code&gt;TickDuration&lt;/code&gt;s as well as assigning the result to this &lt;code&gt;TickDuration&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c16f4ce03396768dfa95982d340781a78324241" translate="yes" xml:space="preserve">
          <source>Adds or subtracts two &lt;code&gt;TickDuration&lt;/code&gt;s.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c737e93d31255b859d9ebe8158a9fb5eee5ea8ae" translate="yes" xml:space="preserve">
          <source>Adds or subtracts two durations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e87760afd0099199ebc5a0eb76c281d30e85cec5" translate="yes" xml:space="preserve">
          <source>Adds the given number of units to this &lt;a href=&quot;#Date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt;, mutating it. A negative number will subtract.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f80ac2d800f8ee490ca058f4b673564daf01236" translate="yes" xml:space="preserve">
          <source>Adds the given number of units to this &lt;a href=&quot;#DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt;, mutating it. A negative number will subtract.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00a26d0cef5a8a591d36a0308e58ee4701a2e0f7" translate="yes" xml:space="preserve">
          <source>Adds the given number of units to this &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt;. A negative number will subtract.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25d7fd9970d15ef947135e621f6d15c4231ff9c0" translate="yes" xml:space="preserve">
          <source>Adds the given number of units to this &lt;a href=&quot;#TimeOfDay&quot;&gt;&lt;code&gt;TimeOfDay&lt;/code&gt;&lt;/a&gt;, mutating it. A negative number will subtract.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="abb4bf42c71674b6c0e872462683cd4dd3560370" translate="yes" xml:space="preserve">
          <source>Adds the given number of years or months to this &lt;a href=&quot;#Date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt;, mutating it. A negative number will subtract.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17c8fc904e2c9da1e769c06f6205227d30331e48" translate="yes" xml:space="preserve">
          <source>Adds the given number of years or months to this &lt;a href=&quot;#DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt;, mutating it. A negative number will subtract.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb5ca95f30def8b12993088b8d76ab1dd37d553c" translate="yes" xml:space="preserve">
          <source>Adds the given number of years or months to this &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt;. A negative number will subtract.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae45ff9fb528c8b811a4a8b39bb46f4d2af30e79" translate="yes" xml:space="preserve">
          <source>Adds, subtracts or calculates the modulo of two durations as well as assigning the result to this &lt;code&gt;Duration&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7217c4f38fb4c88be899accd3f3c8388ee115acb" translate="yes" xml:space="preserve">
          <source>Adds, subtracts or calculates the modulo of two durations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="190513d30ca7a3e2a999758bba5d14849013dae0" translate="yes" xml:space="preserve">
          <source>Adheres to &lt;a href=&quot;http://www.unicode.org/versions/Unicode7.0.0/ch05.pdf&quot;&gt;Unicode 7.0&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e6c5c313ae1124d50c20408776fe80d4c2f9549" translate="yes" xml:space="preserve">
          <source>Adjacent separators.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="722ed5201dde06aad85b7457e551331fed6fc5eb" translate="yes" xml:space="preserve">
          <source>Adjusts &lt;code&gt;n&lt;/code&gt; to a size suitable for allocation (two words or larger, word-aligned).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25ad3e5c0dbbba69ec8c4772c55f2582037c6136" translate="yes" xml:space="preserve">
          <source>Advance the range to the next chunk of encoded data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53489cea9eb74ca25d0c733e6598d5384d852067" translate="yes" xml:space="preserve">
          <source>Advance to the next decoded byte.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a3cd74a73d6f0a26c42392d915705fa7dae1cf8" translate="yes" xml:space="preserve">
          <source>Advance to the next element in the input to be decoded.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d3634150cc1196e50397ef062eee34b37152811" translate="yes" xml:space="preserve">
          <source>Advance to the next encoded character.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1dffc8e495ab0f0b08bad1e3f10f588c91ee072" translate="yes" xml:space="preserve">
          <source>Advanced feature - provide direct access to a subset of matcher based a set of known encoding lengths. Lengths are provided in &lt;a href=&quot;#Code%20unit&quot;&gt;code units&lt;/a&gt;. The sub-matcher then may do less operations per any &lt;code&gt;test&lt;/code&gt;/&lt;code&gt;match&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eeb58f4b086c0412e02e6890890553e6dd38d672" translate="yes" xml:space="preserve">
          <source>Advanced updating</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf881b5c6e7f1c3b9a2c00554a2646c41d876526" translate="yes" xml:space="preserve">
          <source>Advances &lt;code&gt;r&lt;/code&gt; until it finds the first two adjacent elements &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt; that satisfy &lt;code&gt;pred(a, b)&lt;/code&gt;. Performs &amp;Omicron;(&lt;code&gt;r.length&lt;/code&gt;) evaluations of &lt;code&gt;pred&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="facf585ea759be8e47863eaecb960e98185ac802" translate="yes" xml:space="preserve">
          <source>Advances &lt;code&gt;seq&lt;/code&gt; by calling &lt;code&gt;seq.popFront&lt;/code&gt; until either &lt;code&gt;find!(pred)(choices, seq.front)&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, or &lt;code&gt;seq&lt;/code&gt; becomes empty. Performs &amp;Omicron;(&lt;code&gt;seq.length * choices.length&lt;/code&gt;) evaluations of &lt;code&gt;pred&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f69d337edd3755f38c1707e24fc5346d4e2d44c" translate="yes" xml:space="preserve">
          <source>Advances a given bidirectional range from the right by exactly</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19d2eb30ee8dd8c5d7afbff2f9bd7ea8bb2642e3" translate="yes" xml:space="preserve">
          <source>Advances a given bidirectional range from the right by up to</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1e75744b3b444139cd4f0a58b334b9edf66d830" translate="yes" xml:space="preserve">
          <source>Advances a given range by up exactly</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a622ec23b3321ab3e350f048523f7084cf595eb" translate="yes" xml:space="preserve">
          <source>Advances a given range by up to</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78bc54605619ccfaa022076c05ce4d0d5ecf8d2e" translate="yes" xml:space="preserve">
          <source>Advances the generator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7c9ed0ebcf630bc583e7903a2b6d29b7aca3fc7" translate="yes" xml:space="preserve">
          <source>Advances the random sequence.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="841e5d06644019901743e66d69de7d1976b71c5b" translate="yes" xml:space="preserve">
          <source>Advances to the next element in all controlled ranges.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cbe9dcb57596ffec1913e83a16abf147d32611b9" translate="yes" xml:space="preserve">
          <source>Aegean Numbers</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="931eed4d96571bfeae93ef9dcf8c3202ff20b1ad" translate="yes" xml:space="preserve">
          <source>Affects whether functions are inlined or not. If at the declaration level, it affects the functions declared in the block it controls. If inside a function, it affects the function it is enclosed by.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="442683da146742a25947515455e712ba78a50694" translate="yes" xml:space="preserve">
          <source>Affix access functions offering references to the affixes of a block &lt;code&gt;b&lt;/code&gt; previously allocated with this allocator. &lt;code&gt;b&lt;/code&gt; may not be null. They are defined if and only if the corresponding affix is not &lt;code&gt;void&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c23381a58dcf83131fe33f75a01b801175e69bea" translate="yes" xml:space="preserve">
          <source>After &lt;code&gt;typeSemantic&lt;/code&gt; the symbol when &lt;code&gt;exp&lt;/code&gt; doesn't represent a type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f58f4b720491f08a3e184b4d93384253d667e81c" translate="yes" xml:space="preserve">
          <source>After a FTP client has been setup and possibly assigned callbacks the &lt;code&gt; perform()&lt;/code&gt; method will start performing the actual communication with the server.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40877a01f3d2d2683d82a5ea2b798c56a293359c" translate="yes" xml:space="preserve">
          <source>After creation, a &lt;code&gt;Task&lt;/code&gt; may be executed in a new thread, or submitted to a &lt;code&gt;TaskPool&lt;/code&gt; for execution. A &lt;code&gt;TaskPool&lt;/code&gt; encapsulates a task queue and its worker threads. Its purpose is to efficiently map a large number of &lt;code&gt;Task&lt;/code&gt;s onto a smaller number of threads. A task queue is a FIFO queue of &lt;code&gt;Task&lt;/code&gt; objects that have been submitted to the &lt;code&gt;TaskPool&lt;/code&gt; and are awaiting execution. A worker thread is a thread that is associated with exactly one task queue. It executes the &lt;code&gt;Task&lt;/code&gt; at the front of its queue when the queue has work available, or sleeps when no work is available. Each task queue is associated with zero or more worker threads. If the result of a &lt;code&gt;Task&lt;/code&gt; is needed before execution by a worker thread has begun, the &lt;code&gt;Task&lt;/code&gt; can be removed from the task queue and executed immediately in the thread where the result is needed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fac78fef792ce790d176c70684c125385e59b69f" translate="yes" xml:space="preserve">
          <source>After the HTTP client has been setup and possibly assigned callbacks the &lt;code&gt;perform()&lt;/code&gt; method will start performing the request towards the specified server.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3be61943c5e6beb762f765e4ebc8da159c5a9299" translate="yes" xml:space="preserve">
          <source>After this function is finished executing, any exceptions thrown are chained together via &lt;code&gt;Throwable.next&lt;/code&gt; and rethrown. The chaining order is non-deterministic.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2423ca21e96dd2f33c30a0a22ba75c7e9a97460a" translate="yes" xml:space="preserve">
          <source>Aggregate Templates</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="422fc1d404645ddf0fe8822054c49c2df47da791" translate="yes" xml:space="preserve">
          <source>Aggregate Type traits</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a49d2a80d7f18d6b1f678d37a80f429dee0945d" translate="yes" xml:space="preserve">
          <source>Aggregate literals (AA/string/array/struct)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a01f2f266bf28f3c82d33549ab6734f725b8328" translate="yes" xml:space="preserve">
          <source>AggregateDeclaration &lt;code&gt;ad&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65711c59e3f2ecd6ab45c5a271a40aff4bf044a7" translate="yes" xml:space="preserve">
          <source>AggregateDeclaration &lt;strong id=&quot;isAggregate&quot;&gt;isAggregate&lt;/strong&gt;(Type t);</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b026ca73b3ee9e08b16268eb5969c7649a6ada2c" translate="yes" xml:space="preserve">
          <source>AggregateDeclaration &lt;strong id=&quot;isInlinableNestedAggregate&quot;&gt;isInlinableNestedAggregate&lt;/strong&gt;(DeclarationExp e);</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="deb507c2bab5b6df1dfb7a527622531bee5bbcae" translate="yes" xml:space="preserve">
          <source>Aggregates</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="039a4d9ad09b94c49e1256fa36bbd7145bd6a873" translate="yes" xml:space="preserve">
          <source>Aggregates can be string literals, which can be accessed as char, wchar, or dchar arrays:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64215ea928af9a868c37adc98435f865c066cad0" translate="yes" xml:space="preserve">
          <source>Aggregation of GC stats to be exposed via public API</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95739c27a4231a1ab1768db7918200a659985986" translate="yes" xml:space="preserve">
          <source>Aggregation of current profile information</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="960ed8592125f2bc50d2c8d3a223103bb8eab0ce" translate="yes" xml:space="preserve">
          <source>Alchemical Symbols</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5ba6c3d74529cf2db06f24108dd96d14e3a3bf5" translate="yes" xml:space="preserve">
          <source>Algebraic data type restricted to a closed set of possible types. It's an alias for &lt;a href=&quot;#VariantN&quot;&gt;&lt;code&gt;VariantN&lt;/code&gt;&lt;/a&gt; with an appropriately-constructed maximum size. &lt;code&gt;Algebraic&lt;/code&gt; is useful when it is desirable to restrict what a discriminated type could hold to the end of defining simpler and more efficient manipulation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67e15eb99dc0e473c962d6a494d00e048e9f6fc6" translate="yes" xml:space="preserve">
          <source>Algorithms</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6f1119d49c8f3cbd3127d86d596eb5ad76abaa0" translate="yes" xml:space="preserve">
          <source>Algorithms are categorized into the following submodules:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d031d2cc1773d432e8d4e5e3e397ff72d33b73a" translate="yes" xml:space="preserve">
          <source>Algorithms should be written to work based on the minimum precision of the calculation. They should not degrade or fail if the actual precision is greater. Float or double types, as opposed to the real (extended) type, should only be used for:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b7d7cc33ac422a7126bf7ca7d4bc41f992588c9" translate="yes" xml:space="preserve">
          <source>Algorithms that work specifically with strings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88abf47d65eee8406cedefebf1444bde5b352ec5" translate="yes" xml:space="preserve">
          <source>Ali &amp;Ccedil;ehreli's &lt;a href=&quot;http://ddili.org/ders/d.en/ranges.html&quot;&gt;tutorial on ranges&lt;/a&gt; for the basics of working with and creating range-based code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04259816ace1ebe56c853a8763558570c008514a" translate="yes" xml:space="preserve">
          <source>Alias</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b42e13ed23a87356a09e332c7e6e714e6e09e96" translate="yes" xml:space="preserve">
          <source>Alias Declarations</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77ef2f52299fed56a50f678635e931b47d8d55bb" translate="yes" xml:space="preserve">
          <source>Alias Templates</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e3462f022e547a8b9b81a59c7d09995c97a1575" translate="yes" xml:space="preserve">
          <source>Alias This</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6823ce53aa787875a84b73b489aeaa41fb9203a" translate="yes" xml:space="preserve">
          <source>Alias declarations can be used to overload together functions declared in different mixins:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f63972ec70f46c0515cbfc8d099ae2cc95be598" translate="yes" xml:space="preserve">
          <source>Alias for &lt;a href=&quot;#VariantN&quot;&gt;&lt;code&gt;VariantN&lt;/code&gt;&lt;/a&gt; instantiated with the largest size of &lt;code&gt;creal&lt;/code&gt;, &lt;code&gt;char[]&lt;/code&gt;, and &lt;code&gt;void delegate()&lt;/code&gt;. This ensures that &lt;code&gt;Variant&lt;/code&gt; is large enough to hold all of D's predefined types unboxed, including all numeric types, pointers, delegates, and class references. You may want to use &lt;code&gt;VariantN&lt;/code&gt; directly with a different maximum size either for storing larger types unboxed, or for saving memory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63202ec3a67d85508053325231c6e3a50b705940" translate="yes" xml:space="preserve">
          <source>Alias for &lt;code&gt;typeof(Factory()(1))&lt;/code&gt;, i.e. the type of the individual allocators.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="105407ad1c7568b9c649c50759d11c4e192f57b4" translate="yes" xml:space="preserve">
          <source>Alias parameters can accept both literals and user-defined type symbols, but they are less specialized than the matches to type parameters and value parameters:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d22b74da1f9d782bb61c364a8aadbff84bd13777" translate="yes" xml:space="preserve">
          <source>Alias parameters can also be typed. These parameters will accept symbols of that type:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b917c61ec37f1f84ac7cb387db33687a0c61b1b1" translate="yes" xml:space="preserve">
          <source>Alias parameters enable templates to be parameterized with symbol names or values computed at compile-time. Almost any kind of D symbol can be used, including user-defined type names, global names, local names, module names, template names, and template instance names.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8515de354ea5c9130e0c481ca51f1addb44b5d02" translate="yes" xml:space="preserve">
          <source>Alias sequence filtering</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cdba1b60c0b760cd04f385300eb523eb54b00054" translate="yes" xml:space="preserve">
          <source>Alias sequence searching</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1590720ca74c606d4c9f961020006e51239fec30" translate="yes" xml:space="preserve">
          <source>Alias sequence transformation</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c56d0ae76a47ae72fa8c318d1bfb56034cb27c4" translate="yes" xml:space="preserve">
          <source>Alias sequence type hierarchy</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ba4b28154b9d6a34808cdcb201b98d061c254fa" translate="yes" xml:space="preserve">
          <source>Alias your own enforce function</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3677863f140b997e20f4c765fa070bfcd26df047" translate="yes" xml:space="preserve">
          <source>AliasDeclaration</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07e1c1a8b4a8503f8648ab57227770c6e32ac2e8" translate="yes" xml:space="preserve">
          <source>AliasSeq</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a75c4e940b98b3f296d4a0d45ef3c78158d01f9b" translate="yes" xml:space="preserve">
          <source>AliasThis</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f45e3de29f946da184942d83246da3931f3381ce" translate="yes" xml:space="preserve">
          <source>AliasThis &lt;code&gt;at&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a6b07ef377e1a1cca3873fdac3f4b419d63ed5c" translate="yes" xml:space="preserve">
          <source>Aliased symbols are useful as a shorthand for a long qualified symbol name, or as a way to redirect references from one symbol to another:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f8884a25f8de2f7a75d30d9ae86bb0f1f09187b" translate="yes" xml:space="preserve">
          <source>Aliased types are semantically identical to the types they are aliased to. The debugger cannot distinguish between them, and there is no difference as far as function overloading is concerned. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="181e7f0a478bed4e18de65212b24a50ae36262a7" translate="yes" xml:space="preserve">
          <source>Aliases can also &lt;code&gt;import&lt;/code&gt; a set of overloaded functions, that can be overloaded with functions in the current scope:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="daf33e541d4cc1a3ec6daef4974e2cc623107069" translate="yes" xml:space="preserve">
          <source>Aliases cannot be used for expressions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ebc45702486814ba8ea503fc9c806c260e1435cb" translate="yes" xml:space="preserve">
          <source>Aliases itself to &lt;code&gt;T[0]&lt;/code&gt; if the boolean &lt;code&gt;condition&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; and to &lt;code&gt;T[1]&lt;/code&gt; otherwise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3937b5ce30f890ad3772d735fbf89d86613c889" translate="yes" xml:space="preserve">
          <source>Aliases the operating-system-specific semaphore type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca83555e7a077f50fe3fcacdc4d3433397f6d741" translate="yes" xml:space="preserve">
          <source>Aliasing can be used to &lt;code&gt;import&lt;/code&gt; a symbol from an import into the current scope:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3880da17e1bb86f5003addaa85926c1d8378f606" translate="yes" xml:space="preserve">
          <source>AlignAttribute</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c33b72e35015aa610f1d135fb91888616c7312da" translate="yes" xml:space="preserve">
          <source>Aligned allocator using OS-specific primitives, under a uniform API.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33c63fc9fbd39c59d281cefd5cb568321a27de38" translate="yes" xml:space="preserve">
          <source>Aligning the start of a loop body can sometimes have a dramatic effect on the execution speed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f8c5176c3f03b97659161923f2b6492f7de7e73" translate="yes" xml:space="preserve">
          <source>Alignment</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="631fafc1c69d316d9d50c570d786f73ce03ceecb" translate="yes" xml:space="preserve">
          <source>Alignment is identical to that of the parent.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="628683da3626c98088bdb745580ccfdd6195c8e9" translate="yes" xml:space="preserve">
          <source>Alignment is page-size and hardcoded to 4096 (even though on certain systems it could be larger).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee7a5f296fba571ed109f22fb62cee377810a13b" translate="yes" xml:space="preserve">
          <source>Alignment offered</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da6f06da696bc1f912e995a3736dfda61d958504" translate="yes" xml:space="preserve">
          <source>Alignment offered is equal to &lt;code&gt;Allocator.alignment&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9fda3b8d79c5ba0e4cb6a973462e579762d4731" translate="yes" xml:space="preserve">
          <source>Alignment offered.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a72085653e4c5be8c7640c868ef787cbcf063d1" translate="yes" xml:space="preserve">
          <source>All</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="abe24b72722605e6cdd91fc4259456dcc124fc52" translate="yes" xml:space="preserve">
          <source>All &lt;code&gt;struct&lt;/code&gt; declarations are an instance of this.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a15215d4acb70177c3fa907103d5e4082e2c6ca5" translate="yes" xml:space="preserve">
          <source>All D class objects inherit from Object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b8af670ebee67e47b1547dfb583c8778c294941" translate="yes" xml:space="preserve">
          <source>All Linux Systems, except for Android</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80accc5a7a3759a25495613b953505c2d3f752d2" translate="yes" xml:space="preserve">
          <source>All Linux systems</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d974fefbe10142c06ce86c531753f630c736767" translate="yes" xml:space="preserve">
          <source>All Objective-C classes that should be accessible from within D need to be declared with the &lt;a href=&quot;#objc-linkage&quot;&gt;Objective-C linkage&lt;/a&gt;. If the class is declared as &lt;code&gt;extern&lt;/code&gt; (in addition to &lt;code&gt;extern (Objective-C)&lt;/code&gt;) it is expected to be defined externally.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1cad9880f94b0d69e64ab7ba48ed53970ed3c806" translate="yes" xml:space="preserve">
          <source>All POSIX systems (includes Linux, FreeBSD, OS X, Solaris, etc.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="573bedde18f09596640b473ee57afdc92f81ce77" translate="yes" xml:space="preserve">
          <source>All algorithms are generalized to accept as input not only sets but also &lt;a href=&quot;http://https//en.wikipedia.org/wiki/Multiset&quot;&gt;multisets&lt;/a&gt;. Each algorithm documents behaviour in the presence of duplicated inputs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="deb71250ab180a43538a473f83e6182c437126a3" translate="yes" xml:space="preserve">
          <source>All allocators in this module accept and return &lt;code&gt;void[]&lt;/code&gt; (as opposed to &lt;code&gt;shared void[]&lt;/code&gt;). This is because at the time of allocation, deallocation, or reallocation, the memory is effectively not &lt;code&gt;shared&lt;/code&gt; (if it were, it would reveal a bug at the application level).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5de9c469f53cd882bbe9f78f7b9c7bd22b28c0ee" translate="yes" xml:space="preserve">
          <source>All arithmetic operations are supported, except unsigned shift right (&lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt;). Bitwise operations (&lt;code&gt;|&lt;/code&gt;, &lt;code&gt;&amp;amp;&lt;/code&gt;, &lt;code&gt;^&lt;/code&gt;, &lt;code&gt;~&lt;/code&gt;) are supported, and behave as if BigInt was an infinite length 2's complement number.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46dc5bc27e859a39247d5b9a63e991bdb3dcaaa3" translate="yes" xml:space="preserve">
          <source>All arrays that use char, wchar, and their qualified versions are narrow strings. (Those include string and wstring).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8a30ad5dcb475c164f90e540d6c2f68890c9e95" translate="yes" xml:space="preserve">
          <source>All changes are temporary. The previous state is restored at the end of the scope.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21cfae6e750ea0fd4fbc469d1b9c885b7b28182c" translate="yes" xml:space="preserve">
          <source>All character input range conversions using &lt;a href=&quot;#to&quot;&gt;&lt;code&gt;to&lt;/code&gt;&lt;/a&gt; are forwarded to &lt;code&gt;parse&lt;/code&gt; and do not require lvalues.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9cfc0aec4bf30e7871d683d9b8ae2997d4838aa1" translate="yes" xml:space="preserve">
          <source>All characters with non-zero canonical combining class are combining characters, but the reverse is not the case: there are combining characters with a zero combining class.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb44cae4675a0a5faf9a4d0a4f28a2e8d6e40ac0" translate="yes" xml:space="preserve">
          <source>All classes inherit from a super class. If one is not specified, it inherits from Object. Object forms the root of the D class inheritance hierarchy.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9bdea0dd8fa982a6717a9259d201dcc03dde23b0" translate="yes" xml:space="preserve">
          <source>All containers have reference semantics, which means that after assignment both variables refer to the same underlying data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b52c04d3bf060364790c0c3403f5779dc2a33f11" translate="yes" xml:space="preserve">
          <source>All control characters in the ASCII table (&lt;a href=&quot;https://www.asciitable.com&quot;&gt;source&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c22d531bfa3aab4e678dd7f6e2eb1504810b6d16" translate="yes" xml:space="preserve">
          <source>All elements &lt;code&gt;e&lt;/code&gt; in subrange &lt;code&gt;r[0 .. k]&lt;/code&gt; satisfy &lt;code&gt;!less(r[k], e)&lt;/code&gt; (i.e. &lt;code&gt;r[k]&lt;/code&gt; is greater than or equal to each element to its left according to predicate &lt;code&gt;less&lt;/code&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4173fedb2ec95e1c7fab071952ccdfb425731d8e" translate="yes" xml:space="preserve">
          <source>All elements &lt;code&gt;e&lt;/code&gt; in subrange &lt;code&gt;r[k .. $]&lt;/code&gt; satisfy &lt;code&gt;!less(e, r[k])&lt;/code&gt; (i.e. &lt;code&gt;r[k]&lt;/code&gt; is less than or equal to each element to its right according to predicate &lt;code&gt;less&lt;/code&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="478b4e7b48496f9b1b20465b5132e0e5432d493b" translate="yes" xml:space="preserve">
          <source>All empty nodes which cannot return new memory, are removed from the list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05c11955f5c3b9e526943e8928fc83cd41d0f45c" translate="yes" xml:space="preserve">
          <source>All errors must be dealt with in some way, either by code explicitly written to handle them, or by some system default handling.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4680cfd395545685306b1b1ceb36045a37266d2f" translate="yes" xml:space="preserve">
          <source>All finer grained error checking is turned on. Address containing errors or warnings is considered invalid. A specific email status code will be returned indicating the error/warning of the address.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de02c4a63acb3a5d4f7f587b7e81e74ed2b0de72" translate="yes" xml:space="preserve">
          <source>All floating point types to all string types.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79e88b74a9d4c8b35e8dc0b4507253f67ff5fa01" translate="yes" xml:space="preserve">
          <source>All functions, with the exception of &lt;a href=&quot;#expandTilde&quot;&gt;&lt;code&gt;expandTilde&lt;/code&gt;&lt;/a&gt; (and in some cases &lt;a href=&quot;#absolutePath&quot;&gt;&lt;code&gt;absolutePath&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#relativePath&quot;&gt;&lt;code&gt;relativePath&lt;/code&gt;&lt;/a&gt;), are pure string manipulation functions; they don't depend on any state outside the program, nor do they perform any actual file system actions. This has the consequence that the module does not make any distinction between a path that points to a directory and a path that points to a file, and it does not know whether or not the object pointed to by the path actually exists in the file system. To differentiate between these cases, use &lt;a href=&quot;std_file#isDir&quot;&gt;&lt;code&gt;std.file.isDir&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;std_file#exists&quot;&gt;&lt;code&gt;std.file.exists&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="897231d543ddd436ff3d6ba5df7aae31b8e08c87" translate="yes" xml:space="preserve">
          <source>All hidden parameters bundled.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f34602fbc14abc9ba9e2e2916d9e6f9be4a8ff7" translate="yes" xml:space="preserve">
          <source>All implementations must support these, even if by just ignoring them:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8bbea447a7889fa98476703b1f292c42f34bfb25" translate="yes" xml:space="preserve">
          <source>All information associated with call to log function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a29b997591598a8b6cfc336ecadb36fbed66be7" translate="yes" xml:space="preserve">
          <source>All inserts, removes, searches, and any function in general has complexity of &amp;Omicron;(&lt;code&gt;lg(n)&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dcba16c11981f392657558a8d07f357ce4272a30" translate="yes" xml:space="preserve">
          <source>All interface functions must be defined in a class that inherits from that interface:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91e8b4ee2b5a17486728589fc5f6cd3d4c03e0e9" translate="yes" xml:space="preserve">
          <source>All keys can be removed by using the method &lt;code&gt;clear&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cfd5908b4325dd814d160c014614e871bbfd4828" translate="yes" xml:space="preserve">
          <source>All locks are automatically released when the process terminates.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a9b40a952996bdcd13db98ad39be39296434cf8" translate="yes" xml:space="preserve">
          <source>All matches returned by pattern matching functionality in this library are slices of the original input. The notable exception is the &lt;code&gt;replace&lt;/code&gt; family of functions that generate a new string from the input.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8490a5c1885e9991535da5cae9171b20351f0f9" translate="yes" xml:space="preserve">
          <source>All member functions of synchronized classes are synchronized. A static member function is synchronized on the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d2e902a58669b4a70fa2a561fe94c27f74e6b8d" translate="yes" xml:space="preserve">
          <source>All methods inside a class declared as &lt;code&gt;extern (Objective-C)&lt;/code&gt; will get implicit Objective-C linkage.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b366095400babb69322d711aa921d268cfb35ea8" translate="yes" xml:space="preserve">
          <source>All numbers in [-&amp;infin;, +&amp;infin;] are ordered the same way as by built-in comparison, with the exception of -0.0, which is less than +0.0;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf2fb5f601f3c7c74aa1d7bc5d26857dd697e304" translate="yes" xml:space="preserve">
          <source>All of its inputs are assumed to be sorted. This can mean that inputs are instances of &lt;a href=&quot;std_range#SortedRange&quot;&gt;&lt;code&gt;std.range.SortedRange&lt;/code&gt;&lt;/a&gt;. Use the result of &lt;a href=&quot;std_algorithm_sorting#sort&quot;&gt;&lt;code&gt; std.algorithm.sorting.sort&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;std_range#assumeSorted&quot;&gt;&lt;code&gt;std.range.assumeSorted&lt;/code&gt;&lt;/a&gt; to merge ranges known to be sorted (show in the example below). Note that there is currently no way of ensuring that two or more instances of &lt;a href=&quot;std_range#SortedRange&quot;&gt;&lt;code&gt; std.range.SortedRange&lt;/code&gt;&lt;/a&gt; are sorted using a specific comparison function &lt;code&gt;pred&lt;/code&gt;. Therefore no checking is done here to assure that all inputs &lt;code&gt;rs&lt;/code&gt; are instances of &lt;a href=&quot;std_range#SortedRange&quot;&gt;&lt;code&gt;std.range.SortedRange&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7760c023d07d36fdca08004de575b3be6fcb979d" translate="yes" xml:space="preserve">
          <source>All of the functions in std.ascii accept Unicode characters but effectively ignore them if they're not ASCII. All &lt;code&gt;isX&lt;/code&gt; functions return &lt;code&gt;false&lt;/code&gt; for non-ASCII characters, and all &lt;code&gt;toX&lt;/code&gt; functions do nothing to non-ASCII characters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="406700e1b4c5b2a9f03e14707a386766e7ff13f4" translate="yes" xml:space="preserve">
          <source>All of the standard numeric operators are defined for the UUID struct.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3100bf25a966348766069acc9d7aec1ceec953c8" translate="yes" xml:space="preserve">
          <source>All of these UUID versions can be read and processed by &lt;code&gt;std.uuid&lt;/code&gt;, but only version 3, 4 and 5 UUIDs can be generated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="502d87114b09889db456bdf9177fc6f3f3031b7f" translate="yes" xml:space="preserve">
          <source>All of these functions come in two varieties: one takes a target element, where the range will be stripped as long as this element can be found. The other takes a lambda predicate, where the range will be stripped as long as the predicate returns true.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="821e98543b08c50cacab703f8d367d6710ccef75" translate="yes" xml:space="preserve">
          <source>All other BSDs</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd68fd410f45079b0d7aa364b641219999200191" translate="yes" xml:space="preserve">
          <source>All possible error codes from all sorts of curl functions. Future versions may return other values, stay prepared.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="136fb65faf8ab2a2cf368736fd6aeb99f8c344fd" translate="yes" xml:space="preserve">
          <source>All possible options</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b813b3d5035d2aa3a990bcb3215de8f25be6e30e" translate="yes" xml:space="preserve">
          <source>All primitives listed operate on Unicode characters and sets of characters. For functions which operate on ASCII characters and ignore Unicode &lt;a href=&quot;#Character&quot;&gt;characters&lt;/a&gt;, see &lt;a href=&quot;std_ascii&quot;&gt;&lt;code&gt;std.ascii&lt;/code&gt;&lt;/a&gt;. For definitions of Unicode &lt;a href=&quot;#Character&quot;&gt;character&lt;/a&gt;, &lt;a href=&quot;#Code%20point&quot;&gt;code point&lt;/a&gt; and other terms used throughout this module see the &lt;a href=&quot;#Terminology&quot;&gt;terminology&lt;/a&gt; section below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c8a2e2c452533012af5af53a5f2117564ba54d2" translate="yes" xml:space="preserve">
          <source>All programs have to deal with errors. Errors are unexpected conditions that are not part of the normal operation of a program. Examples of common errors are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c20c0313c3654dcf38a230e6a0ac8e51f952d657" translate="yes" xml:space="preserve">
          <source>All reading from &lt;code&gt;stdin&lt;/code&gt; automatically locks the file globally, and will cause all other threads calling &lt;code&gt;read&lt;/code&gt; to wait until the lock is released.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9df267cdc9ad11425ae578a49e8b8411f22249c" translate="yes" xml:space="preserve">
          <source>All sections for the module are combined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4fe809ffea83f91ee87860fb09bce9898a2380b1" translate="yes" xml:space="preserve">
          <source>All static fields in this struct represents a specific predefined symbol.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9dfd9dd3cf17f876b6f44df68cf586485cbe563b" translate="yes" xml:space="preserve">
          <source>All stats of the form &lt;code&gt;numXxx&lt;/code&gt; record counts of events occurring, such as calls to functions and specific results. The stats of the form &lt;code&gt;bytesXxx&lt;/code&gt; collect cumulative sizes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3aeac5247fab94056a2fcd9ae2ebfe7ce2a4741c" translate="yes" xml:space="preserve">
          <source>All steps combined look like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73e1d82508097f721dc5f94481ae54c7c96a5506" translate="yes" xml:space="preserve">
          <source>All symbols from a publicly imported module are also aliased in the importing module. Thus in the above example if C contains the name foo, it will be accessible in A as &lt;code&gt;foo&lt;/code&gt;, &lt;code&gt;B.foo&lt;/code&gt; and &lt;code&gt;C.foo&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a81b5e33e5d9b6fed4225267f1379628464786b1" translate="yes" xml:space="preserve">
          <source>All symbols within &lt;code&gt;symbol&lt;/code&gt; that have the given UDA &lt;code&gt;attribute&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20ecb571750aace44511ab3cf936eb97eef093c5" translate="yes" xml:space="preserve">
          <source>All the binary operators work in their assignment version</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd0de63de936b7274b430f7f3c7c61353d4b4b65" translate="yes" xml:space="preserve">
          <source>All the properties of the &lt;a href=&quot;declaration#VectorBaseType&quot;&gt;&lt;i&gt;VectorBaseType&lt;/i&gt;&lt;/a&gt; work.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97efa5a26947938bb903257f0409a1c26a039cd2" translate="yes" xml:space="preserve">
          <source>All the static constructors for a module are aggregated into a single function, and a pointer to that function is inserted into the ctor member of the ModuleInfo instance for that module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b0681a718887d97ad7ee984aa0510556a949ead" translate="yes" xml:space="preserve">
          <source>All the static denstructors for a module are aggregated into a single function, and a pointer to that function is inserted into the dtor member of the ModuleInfo instance for that module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15236deff34ae39943ca5f31e8d24cf0e03855cc" translate="yes" xml:space="preserve">
          <source>All the unit tests for a module are aggregated into a single function, and a pointer to that function is inserted into the unitTest member of the ModuleInfo instance for that module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f949da684991e66b76cb0131b05508ca1cb634cb" translate="yes" xml:space="preserve">
          <source>All those destructors freeing memory can become significant when objects are allocated on the stack. For each one, some mechanism must be established so that if an exception happens, the destructors all get called in each frame to release any memory they hold. If the destructors become irrelevant, then there's no need to set up special stack frames to handle exceptions, and the code runs faster.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c628520ddca4f269f1a2425393dd896bb6ecd64f" translate="yes" xml:space="preserve">
          <source>All thrown objects must inherit from Throwable. Class &lt;code&gt;Exception&lt;/code&gt;, which derives from this class, represents the category of thrown objects that are safe to catch and handle. In principle, one should not catch Throwable objects that are not derived from &lt;code&gt;Exception&lt;/code&gt;, as they represent unrecoverable runtime errors. Certain runtime guarantees may fail to hold when these errors are thrown, making it unsafe to continue execution after catching them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d57ed726e64ba51ae7c15a7975e045226435204a" translate="yes" xml:space="preserve">
          <source>All writing to &lt;code&gt;stderr&lt;/code&gt; automatically locks the file globally, and will cause all other threads calling &lt;code&gt;write&lt;/code&gt; to wait until the lock is released.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="645f93cabf6576decf07a138ca4abf26edcd1dfb" translate="yes" xml:space="preserve">
          <source>All writing to &lt;code&gt;stdout&lt;/code&gt; automatically locks the file globally, and will cause all other threads calling &lt;code&gt;write&lt;/code&gt; to wait until the lock is released.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b093a504d859edb011aa4c10e43272d307e7616" translate="yes" xml:space="preserve">
          <source>Allocate &lt;code&gt;n&lt;/code&gt; bytes of memory. If &lt;code&gt;n&lt;/code&gt; is eligible for freelist and the freelist is not empty, pops the memory off the free list. In all other cases, uses the parent allocator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb204135b1e21acae9320219240e8e87e6f65b6f" translate="yes" xml:space="preserve">
          <source>Allocate a block of size &lt;code&gt;s&lt;/code&gt; with alignment &lt;code&gt;a&lt;/code&gt;. First tries to allocate from the existing list of already-created allocators. If neither can satisfy the request, creates a new allocator by calling &lt;code&gt;make(s + a - 1)&lt;/code&gt; and delegates the request to it. However, if the allocation fresh off a newly created allocator fails, subsequent calls to &lt;code&gt;alignedAllocate&lt;/code&gt; will not cause more calls to &lt;code&gt;make&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1b869869fcf623a87d8a6cf55943a9b074f4092" translate="yes" xml:space="preserve">
          <source>Allocate a block of size &lt;code&gt;s&lt;/code&gt;. First tries to allocate from the existing list of already-created allocators. If neither can satisfy the request, creates a new allocator by calling &lt;code&gt;make(s)&lt;/code&gt; and delegates the request to it. However, if the allocation fresh off a newly created allocator fails, subsequent calls to &lt;code&gt;allocate&lt;/code&gt; will not cause more calls to &lt;code&gt; make&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e3ac4a0a39edc956251dca78db0c555e763550a" translate="yes" xml:space="preserve">
          <source>Allocate a new array of length elements. ti is the type of the resulting array, or pointer to element. (For when the array is initialized to 0)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04a5579ec9d9ea7bf8fd9194782b75e61153d45c" translate="yes" xml:space="preserve">
          <source>Allocate a new uninitialized array of length elements. ti is the type of the resulting array, or pointer to element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4addc8952362210dbd4d01899c0184f19033db2f" translate="yes" xml:space="preserve">
          <source>Allocate a new variable via xmalloc that can be added to the global environment. The resulting string will be null-terminated immediately after the end of the array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5ae03eb0a1a6cb0d88d14fb5a3b4d6ad0ebf542" translate="yes" xml:space="preserve">
          <source>Allocate an exception of type &lt;code&gt;ci&lt;/code&gt; from the exception pool. It has the same interface as &lt;code&gt;rt.lifetime._d_newclass()&lt;/code&gt;. The class type must be Throwable or derived from it, and cannot be a COM or C++ class. The compiler must enforce this.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b15ff176dde037c8eec0c32aab20116e3b618dd6" translate="yes" xml:space="preserve">
          <source>Allocate an instance of the class, &lt;code&gt;NSString&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74612396c30d0c63cc046cd3b14fa2fd0d0f12bd" translate="yes" xml:space="preserve">
          <source>Allocate an uninitialized non-array item. This is an optimization to avoid things needed for arrays like the _arrayPad(size).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="690211495bdf02fe74267eebc1c68112cdf01cf1" translate="yes" xml:space="preserve">
          <source>Allocate and fill in ctors[] and tlsctors[]. Modules are inserted into the arrays in the order in which the constructors need to be run.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="546305171dde7bde4a1c7bbf4dee4fc391ed9224" translate="yes" xml:space="preserve">
          <source>Allocate and initialize an ExceptionHeader.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="152c2032835fcd0df6e709b46cbe62f6b6cd7102" translate="yes" xml:space="preserve">
          <source>Allocate data from the caller's stack frame. This is a 'magic' function that needs help from the compiler to work right, do not change its name, do not call it from other compilers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7bcab4c37e278570affa71300f593890c5082f0a" translate="yes" xml:space="preserve">
          <source>Allocate the array, rely on the caller to do the initialization of the array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae51d44518dcf6c4431053abbfb74d465f5558a1" translate="yes" xml:space="preserve">
          <source>Allocated blocks do not hold a size prefix. This is because in D the size information is available in client code at deallocation time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb1dd4282b618235f704ba742fef6168e8279026" translate="yes" xml:space="preserve">
          <source>Allocates &lt;code&gt;bytes&lt;/code&gt; and returns them, or &lt;code&gt;null&lt;/code&gt; if the region cannot accommodate the request. For efficiency reasons, if &lt;code&gt;bytes == 0&lt;/code&gt; the function returns an empty non-null slice.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd1ff9ea9b54d782b4a1fa925149d8ee9eefd67e" translate="yes" xml:space="preserve">
          <source>Allocates &lt;code&gt;n&lt;/code&gt; bytes of memory aligned at alignment &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a919f47db37669617faab9ea6d5ad732011e85df" translate="yes" xml:space="preserve">
          <source>Allocates &lt;code&gt;n&lt;/code&gt; bytes of memory with specified alignment &lt;code&gt;a&lt;/code&gt;. Implementations that do not support this primitive should always return &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3556f444ee3e01e4ff6b4c12964c1a5b8dc14fca" translate="yes" xml:space="preserve">
          <source>Allocates &lt;code&gt;n&lt;/code&gt; bytes of memory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="571906ff58f2c345c55fece0c6b4680a0d168821" translate="yes" xml:space="preserve">
          <source>Allocates &lt;code&gt;n&lt;/code&gt; bytes of memory. First consults the free tree, and returns from it if a suitably sized block is found. Otherwise, the parent allocator is tried. If allocation from the parent succeeds, the allocated block is returned. Otherwise, the free tree tries an alternate strategy: If &lt;code&gt; ParentAllocator&lt;/code&gt; defines &lt;code&gt;deallocate&lt;/code&gt;, &lt;code&gt;FreeTree&lt;/code&gt; releases all of its contents and tries again.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2b3a385e46b9ac83e94af9618c4d1619a61f273" translate="yes" xml:space="preserve">
          <source>Allocates &lt;code&gt;n&lt;/code&gt; bytes of memory. The allocation is served by atomically incrementing a pointer which keeps track of the current used space.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="545e4bfeb16f8477990d8181bb9178281843dd98" translate="yes" xml:space="preserve">
          <source>Allocates &lt;code&gt;n&lt;/code&gt; bytes of memory. The shortest path involves an alignment adjustment (if &lt;code&gt;alignment &amp;gt; 1&lt;/code&gt;), an increment, and a comparison.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2936608c36ed9f5713be515def45d248186393f0" translate="yes" xml:space="preserve">
          <source>Allocates &lt;code&gt;n&lt;/code&gt; bytes. Allocation searches the list of available blocks until a free block with &lt;code&gt;n&lt;/code&gt; or more bytes is found (first fit strategy). The block is split (if larger) and returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b627f8a5a1e78d575daa227732620caf9398d99d" translate="yes" xml:space="preserve">
          <source>Allocates &lt;code&gt;s&lt;/code&gt; bytes of memory and returns it, or &lt;code&gt;null&lt;/code&gt; if memory could not be allocated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="955f82f1f9371d9a1a5f44a9d6884b1bf06878cf" translate="yes" xml:space="preserve">
          <source>Allocates a &lt;code&gt;class&lt;/code&gt; object right inside the current scope, therefore avoiding the overhead of &lt;code&gt;new&lt;/code&gt;. This facility is unsafe; it is the responsibility of the user to not escape a reference to the object outside the scope.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d0bc107a98ee07d1d72bbabf6107748dcbf6e02" translate="yes" xml:space="preserve">
          <source>Allocates a block with specified alignment &lt;code&gt;a&lt;/code&gt;. The alignment must be a power of 2. If &lt;code&gt;a &amp;lt;= alignment&lt;/code&gt;, function forwards to &lt;code&gt;allocate&lt;/code&gt;. Otherwise, it attempts to overallocate and then adjust the result for proper alignment. In the worst case the slack memory is around two blocks.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="333f797e4d1750e2dc2dd943bcec484cf81e4464" translate="yes" xml:space="preserve">
          <source>Allocates a multidimensional array of elements of type T.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ef2526b1e1b8c72e2349064073c5f4e36bc9e05" translate="yes" xml:space="preserve">
          <source>Allocates a new array which is identical to &lt;code&gt;s&lt;/code&gt; except that all of its characters are converted to uppercase (by preforming Unicode uppercase mapping). If none of &lt;code&gt;s&lt;/code&gt; characters were affected, then &lt;code&gt;s&lt;/code&gt; itself is returned if &lt;code&gt;s&lt;/code&gt; is a &lt;code&gt;string&lt;/code&gt;-like type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5aaa9a811057230aa95580332ee9fece9148d7e" translate="yes" xml:space="preserve">
          <source>Allocates all memory available to this allocator. If the allocator is empty, returns the entire available block of memory. Otherwise, it still performs a best-effort allocation: if there is no fragmentation (e.g. &lt;code&gt;allocate&lt;/code&gt; has been used but not &lt;code&gt;deallocate&lt;/code&gt;), allocates and returns the only available block of memory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="affe2fcdb8093269677afa8f01518ff0ce594273" translate="yes" xml:space="preserve">
          <source>Allocates all memory available with this allocator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="457c8670d7db9f415c2c631b04bc7df87f7a8ce8" translate="yes" xml:space="preserve">
          <source>Allocates an array and initializes it with copies of the elements of range &lt;code&gt;r&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e31ee88595be1a4376af43d499352d1f95ed61d8" translate="yes" xml:space="preserve">
          <source>Allocates and returns all memory available to this allocator. Implementations that do not support this primitive should always return &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a3681eb538dd63a79378153545a077147ef7123" translate="yes" xml:space="preserve">
          <source>Allocates and returns all memory available to this region.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b750fd7da093b1e747e05812152ef8c3fccbd77" translate="yes" xml:space="preserve">
          <source>Allocates in coarse-grained quantas, thus improving performance of reallocations by often reallocating in place. The drawback is higher memory consumption because of allocated and unused memory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70331dfb1a6e6d60011fcc4d4e71ab51d10775b6" translate="yes" xml:space="preserve">
          <source>Allocates memory either off of the free list or from the parent allocator. If &lt;code&gt;n&lt;/code&gt; is within &lt;code&gt;[min, max]&lt;/code&gt; or if the free list is unchecked (&lt;code&gt;minSize == 0 &amp;amp;&amp;amp; maxSize == size_t.max&lt;/code&gt;), then the free list is consulted first. If not empty (hit), the block at the front of the free list is removed from the list and returned. Otherwise (miss), a new block of &lt;code&gt;max&lt;/code&gt; bytes is allocated, truncated to &lt;code&gt;n&lt;/code&gt; bytes, and returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22f9e74278651d99027c27c713ac855e8ed1e715" translate="yes" xml:space="preserve">
          <source>Allocates memory trying the primary allocator first. If it returns &lt;code&gt; null&lt;/code&gt;, the fallback allocator is tried.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b925b0b6c371d9f54077bbba76c9a1da1602d6a9" translate="yes" xml:space="preserve">
          <source>Allocates memory. For management it actually allocates extra memory from the parent.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="575ca88081327e09f680960a4110bc8ba17a9371" translate="yes" xml:space="preserve">
          <source>Allocates memory; use &lt;a href=&quot;#lineSplitter&quot;&gt;&lt;code&gt;lineSplitter&lt;/code&gt;&lt;/a&gt; for an alternative that does not.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee6c6f7e81d98e5543bf32244a9bf50d0d1defcc" translate="yes" xml:space="preserve">
          <source>Allocates s bytes of memory and returns it, or &lt;code&gt;null&lt;/code&gt; if memory could not be allocated. &lt;code&gt;allocateFresh&lt;/code&gt; behaves just like allocate, the only difference being that this always returns unused(fresh) memory. Although there may still be available space in the &lt;code&gt;BitmappedBlock&lt;/code&gt;, &lt;code&gt;allocateFresh&lt;/code&gt; could still return null, because all the available blocks have been previously deallocated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40d52c59404ae014d74089cf6166317c2d5cca72" translate="yes" xml:space="preserve">
          <source>Allocates s bytes of memory and returns it, or &lt;code&gt;null&lt;/code&gt; if memory could not be allocated. &lt;code&gt;allocateFresh&lt;/code&gt; behaves just like allocate, the only difference being that this always returns unused(fresh) memory. Although there may still be available space in the &lt;code&gt;SharedBitmappedBlock&lt;/code&gt;, &lt;code&gt;allocateFresh&lt;/code&gt; could still return null, because all the available blocks have been previously deallocated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34562b2c1efcd9772eb4d939efa35b8757f6170e" translate="yes" xml:space="preserve">
          <source>Allocates the requested &lt;code&gt;bytes&lt;/code&gt; of memory with specified &lt;code&gt;alignment&lt;/code&gt;. Directs the call to either one of the &lt;code&gt;buckets&lt;/code&gt; allocators. Defined only if &lt;code&gt;Allocator&lt;/code&gt; defines &lt;code&gt;alignedAllocate&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc90ab9b460af01883735fa719d7075b6f64fedd" translate="yes" xml:space="preserve">
          <source>Allocating memory for sharing across threads</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1483392946af2634ec9da37d8a5eacfc7465700" translate="yes" xml:space="preserve">
          <source>Allocation requests are handled on a first-fit basis. Although linear in complexity, allocation is in practice fast because of the compact bookkeeping representation, use of simple and fast bitwise routines, and caching of the first available block position. A known issue with this general approach is fragmentation, partially mitigated by coalescing. Since &lt;code&gt;BitmappedBlock&lt;/code&gt; does not need to maintain the allocated size, freeing memory implicitly coalesces free blocks together. Also, tuning &lt;code&gt;blockSize&lt;/code&gt; has a considerable impact on both internal and external fragmentation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cbc962bc5b83a88a16f2713a98847658123e8258" translate="yes" xml:space="preserve">
          <source>Allocation requests first search the tree for a buffer of suitable size deallocated in the past. If a match is found, the node is removed from the tree and the memory is returned. Otherwise, the allocation is directed to &lt;code&gt;ParentAllocator&lt;/code&gt;. If at this point &lt;code&gt;ParentAllocator&lt;/code&gt; also fails to allocate, &lt;code&gt;FreeTree&lt;/code&gt; frees everything and then tries the parent allocator again.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af0e205e8505bb23310602de5dd4be9af5c6a6d9" translate="yes" xml:space="preserve">
          <source>Allocation-related flags dictated by type characteristics. &lt;code&gt;TypedAllocator&lt;/code&gt; deduces these flags from the type being allocated and uses the appropriate allocator accordingly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fdc44965c2d6c8c8d7c21352e9d968a0c8014291" translate="yes" xml:space="preserve">
          <source>Allocations for sizes smaller than &lt;code&gt;min&lt;/code&gt; or larger than &lt;code&gt;max&lt;/code&gt; are illegal for &lt;code&gt;Bucketizer&lt;/code&gt;. To handle them separately, &lt;code&gt;Segregator&lt;/code&gt; may be of use.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cbf9e75065cafb419b19fb5a13dddefb2735eaa6" translate="yes" xml:space="preserve">
          <source>Allocator</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e08b1899abf4a5d12c1969cc846a1ce148364a1f" translate="yes" xml:space="preserve">
          <source>Allocator (currently defined only for Posix and Windows) using &lt;code&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Mmap&quot;&gt;mmap&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;https://google.com/search?btnI=I%27m+Feeling+Lucky&amp;amp;ie=UTF-8&amp;amp;oe=UTF-8&amp;amp;q=munmap&quot;&gt;munmap&lt;/a&gt;&lt;/code&gt; directly (or their Windows equivalents). There is no additional structure: each call to &lt;code&gt;allocate(s)&lt;/code&gt; issues a call to &lt;code&gt;mmap(null, s, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0)&lt;/code&gt;, and each call to &lt;code&gt;deallocate(b)&lt;/code&gt; issues &lt;code&gt;munmap(b.ptr, b.length)&lt;/code&gt;. So &lt;code&gt;MmapAllocator&lt;/code&gt; is usually intended for allocating large chunks to be managed by fine-granular allocators.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3353234ce0124f8910aaa38caffee20b71a4f80f" translate="yes" xml:space="preserve">
          <source>Allocator &lt;code&gt;alloc&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1e6a4ec6000f9e0b7f661da3b6a91cb8ae29132" translate="yes" xml:space="preserve">
          <source>Allocator &lt;strong id=&quot;_parent&quot;&gt;_parent&lt;/strong&gt;;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d69c3c0130d6d25953b8d2d9b80b986133e83dd0" translate="yes" xml:space="preserve">
          <source>Allocator &lt;strong id=&quot;parent&quot;&gt;parent&lt;/strong&gt;;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cadfd13af30b7dd1dff50bada6dc1d562f201deb" translate="yes" xml:space="preserve">
          <source>Allocator API.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="675049c41d27d311eac5a89bd2e072dfd75d4167" translate="yes" xml:space="preserve">
          <source>Allocator backed by &lt;code&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Sbrk&quot;&gt;sbrk&lt;/a&gt;&lt;/code&gt; for Posix systems. Due to the fact that &lt;code&gt;sbrk&lt;/code&gt; is not thread-safe &lt;a href=&quot;http://lifecs.likai.org/2010/02/sbrk-is-not-thread-safe.html&quot;&gt;by design&lt;/a&gt;, &lt;code&gt;SbrkRegion&lt;/code&gt; uses a mutex internally. This implies that uncontrolled calls to &lt;code&gt;brk&lt;/code&gt; and &lt;code&gt;sbrk&lt;/code&gt; may affect the workings of &lt;code&gt;SbrkRegion&lt;/code&gt; adversely.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="513b82ce13f2dc2be45bd311fabfc658467c99b2" translate="yes" xml:space="preserve">
          <source>Allocator primitives.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68a0d53209b9f9a4b14c3a76e7ad158b2dca28b9" translate="yes" xml:space="preserve">
          <source>Allocator similar to &lt;code&gt;FreeList&lt;/code&gt; that uses a binary search tree to adaptively store not one, but many free lists.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0cc49cc2f10e3277f742185d09b671e886851a2" translate="yes" xml:space="preserve">
          <source>Allocator that adds some extra data before (of type &lt;code&gt;Prefix&lt;/code&gt;) and/or after (of type &lt;code&gt;Suffix&lt;/code&gt;) any allocation made with its parent allocator. This is useful for uses where additional allocation-related information is needed, such as mutexes, reference counts, or walls for debugging memory corruption errors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="506fd6ecc5980e2993d9b94a51762bcf43b76fb6" translate="yes" xml:space="preserve">
          <source>Allocator that allows and manages allocating extra prefix and/or a suffix bytes for each block allocated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bfd65030e4aadae8e36c3b33912522b7bfee3263" translate="yes" xml:space="preserve">
          <source>Allocator that collects extra data about allocations. Since each piece of information adds size and time overhead, statistics can be individually enabled or disabled through compile-time &lt;code&gt;flags&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc0af3b6f564e9ca229952d612a3550f66061e3a" translate="yes" xml:space="preserve">
          <source>Allocator that collects useful statistics about allocations, both global and per calling point. The statistics collected can be configured statically by choosing combinations of &lt;code&gt;Options&lt;/code&gt; appropriately.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14e1947892b24d554e92c80dc9a3054c6f2dbace" translate="yes" xml:space="preserve">
          <source>Allocator that combines two other allocators - primary and fallback. Allocation requests are first tried with primary, and upon failure are passed to the fallback. Useful for small and fast allocators fronting general-purpose ones.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82ae157e1fe07caf7d37c5484581461f1d9f6744" translate="yes" xml:space="preserve">
          <source>Allocator that implements a &lt;a href=&quot;http://wikipedia.org/wiki/Free_list&quot;&gt;free list&lt;/a&gt; on top of any other allocator. The preferred size, tolerance, and maximum elements are configurable at compile- and run time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92d633faca70f593d2eefae1500ce778644a707a" translate="yes" xml:space="preserve">
          <source>Allocator that uses stack allocation for up to &lt;code&gt;stackSize&lt;/code&gt; bytes and then falls back to &lt;code&gt;Allocator&lt;/code&gt;. Defined as:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="277f2e388687399a48875d2b4c26cd068e3208fa" translate="yes" xml:space="preserve">
          <source>Allocator used for storing bookkeeping data. The size of bookkeeping data is proportional to the number of allocators. If &lt;code&gt;BookkeepingAllocator&lt;/code&gt; is &lt;code&gt;NullAllocator&lt;/code&gt;, then &lt;code&gt;AllocatorList&lt;/code&gt; is &quot;ouroboros-style&quot;, i.e. it keeps the bookkeeping data in memory obtained from the allocators themselves. Note that for ouroboros-style management, the size &lt;code&gt;n&lt;/code&gt; passed to &lt;code&gt;make&lt;/code&gt; will be occasionally different from the size requested by client code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08bb4c3deb9ae5f24662a76a349c8811c202d3b8" translate="yes" xml:space="preserve">
          <source>Allocator using &lt;code&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Mmap&quot;&gt;mmap&lt;/a&gt;&lt;/code&gt; directly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8e7b4b37828838d0088cc341f2bd349bdd2e0c6" translate="yes" xml:space="preserve">
          <source>Allocator[(max + 1 - min) / step] &lt;strong id=&quot;buckets&quot;&gt;buckets&lt;/strong&gt;;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="244757ffcceddee2188dcae6f52360122e5f32b2" translate="yes" xml:space="preserve">
          <source>Allocators are classes that define memory models to be used by some parts of the C++ Standard Library, and most specifically, by STL containers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cfd42e2cc807e85fba40b31455784b7f9341316f" translate="yes" xml:space="preserve">
          <source>Allocators assembled from the heap building blocks don't need to go through &lt;code&gt;IAllocator&lt;/code&gt; to be usable. They have the same primitives as &lt;code&gt;IAllocator&lt;/code&gt; and they work with &lt;a href=&quot;#make&quot;&gt;&lt;code&gt;make&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#makeArray&quot;&gt;&lt;code&gt;makeArray&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#dispose&quot;&gt;&lt;code&gt;dispose&lt;/code&gt;&lt;/a&gt; etc. So it suffice to create allocator objects wherever fit and use them appropriately:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1a8b8369433cbedfb9cf80b63c1ab01ecb08d5f" translate="yes" xml:space="preserve">
          <source>Allocators customarily allocate memory in discretely-sized chunks. Therefore, a request for &lt;code&gt;n&lt;/code&gt; bytes may result in a larger allocation. The extra memory allocated goes unused and adds to the so-called &lt;a href=&quot;http://goo.gl/YoKffF&quot;&gt;internal fragmentation&lt;/a&gt;. The function &lt;code&gt;goodAllocSize(n)&lt;/code&gt; returns the actual number of bytes that would be allocated upon a request for &lt;code&gt;n&lt;/code&gt; bytes. This module defines a default implementation that returns &lt;code&gt;n&lt;/code&gt; rounded up to a multiple of the allocator's alignment.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6e1e46c405b75de5b94f462defa6a8af94b5d44" translate="yes" xml:space="preserve">
          <source>Allow Duration to be used as a boolean.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="adac40bfba505bd009304b9376798311375e4e91" translate="yes" xml:space="preserve">
          <source>Allow local reuse of address</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b6333bf17facce373203c2555dce16e5a1895fb" translate="yes" xml:space="preserve">
          <source>Allow the last slide to have fewer elements than windowSize</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ed1bcaf99a3846f70cbca3700192d6c980d8840" translate="yes" xml:space="preserve">
          <source>Allow transmission of broadcast messages</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8fa57446bade27e54bc705df143acdcdd3b1802" translate="yes" xml:space="preserve">
          <source>AllowDayOverflow &lt;code&gt;allowOverflow&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64679db98864f0cda1e9bac90e046d01f23a860d" translate="yes" xml:space="preserve">
          <source>AllowDayOverflow only applies to calculations involving months or years.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25c6d16035cd63a1ba2d0337d85f0862317f57db" translate="yes" xml:space="preserve">
          <source>Allows &lt;code&gt;alias&lt;/code&gt;ing of any single symbol, type or compile-time expression.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f4acd20c1f1294f9371d9a6ba2cfbedb8612aac" translate="yes" xml:space="preserve">
          <source>Allows assignment from a subset algebraic type</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7cde2e0711d3681c464aaffee0a4276b1a5dd9a" translate="yes" xml:space="preserve">
          <source>Allows constructing a &lt;a href=&quot;#Duration&quot;&gt;&lt;code&gt;Duration&lt;/code&gt;&lt;/a&gt; from the given time units with the given length.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee70bbaa43d45797f5f446c5970672b1c530f1ac" translate="yes" xml:space="preserve">
          <source>Allows creating bit fields inside structs and classes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64ee76f10cd6158b74b7abb63361a7dad9dbd646" translate="yes" xml:space="preserve">
          <source>Allows for custom number of worker threads.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="328393fd6489bef674280b2b2127dc7cc02ec9c0" translate="yes" xml:space="preserve">
          <source>Allows freely swapping of elements as long as the output satisfies the algorithm's requirements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a9ded70476d5ecbed5df1b409fabc86f2220dab" translate="yes" xml:space="preserve">
          <source>Allows manipulating the fraction, exponent, and sign parts of a double separately. The definition is:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="334b65d7fe406c8806cd27978db1e757401c70de" translate="yes" xml:space="preserve">
          <source>Allows manipulating the fraction, exponent, and sign parts of a float separately. The definition is:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25a3ad747e7b5e32b1dfdc83fe51e1af4607df0d" translate="yes" xml:space="preserve">
          <source>Allows safe construction of &lt;code&gt;Unique&lt;/code&gt;. It creates the resource and guarantees unique ownership of it (unless &lt;code&gt;T&lt;/code&gt; publishes aliases of &lt;code&gt;this&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b188cff78ffe93b93118a9afb92a5b0ecf425233" translate="yes" xml:space="preserve">
          <source>Allows the storage of &lt;a href=&quot;https://en.wikipedia.org/wiki/IEEE_754-1985#Positive_and_negative_infinity&quot;&gt; IEEE754 infinity&lt;/a&gt; values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3c7e91d01b82633b7ccef70ff930b3cba01954d" translate="yes" xml:space="preserve">
          <source>Allows the storage of &lt;a href=&quot;https://en.wikipedia.org/wiki/NaN&quot;&gt;IEEE754 Not a Number&lt;/a&gt; values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82e4b1439e8421bdc9916fd5cc4940cdec7c35ca" translate="yes" xml:space="preserve">
          <source>Allows user code to define custom floating-point formats. These formats are for storage only; all operations on them are performed by first implicitly extracting them to &lt;code&gt;real&lt;/code&gt; first. After the operation is completed the result can be stored in a custom floating-point value via assignment.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a707a85edc66a653109fa80da8910d24c0d7d6d7" translate="yes" xml:space="preserve">
          <source>Alphabetic</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c31b9723b74539a236469f5380dbe298e0356511" translate="yes" xml:space="preserve">
          <source>Alphabetic Presentation Forms</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4f699c324e0e58a96d3bb16953095da737d92fc" translate="yes" xml:space="preserve">
          <source>Also known as trinary, trivalent, or trilean.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3cb12cab0f941ad8314fbcab6c21fb7b159e66aa" translate="yes" xml:space="preserve">
          <source>Also note that while normally the &lt;code&gt;begin&lt;/code&gt; of an interval is included in it and its &lt;code&gt;end&lt;/code&gt; is excluded from it, if &lt;code&gt;dir == Direction.bwd&lt;/code&gt;, then &lt;code&gt;begin&lt;/code&gt; is treated as excluded and &lt;code&gt;end&lt;/code&gt; is treated as included. This allows for the same behavior in both directions. This works because none of &lt;a href=&quot;#Interval&quot;&gt;&lt;code&gt;Interval&lt;/code&gt;&lt;/a&gt;'s functions which care about whether &lt;code&gt;begin&lt;/code&gt; or &lt;code&gt;end&lt;/code&gt; is included or excluded are ever called by &lt;code&gt;IntervalRange&lt;/code&gt;. &lt;code&gt;interval&lt;/code&gt; returns a normal interval, regardless of whether &lt;code&gt;dir == Direction.fwd&lt;/code&gt; or if &lt;code&gt;dir == Direction.bwd&lt;/code&gt;, so any &lt;a href=&quot;#Interval&quot;&gt;&lt;code&gt;Interval&lt;/code&gt;&lt;/a&gt; functions which are called on it which care about whether &lt;code&gt;begin&lt;/code&gt; or &lt;code&gt;end&lt;/code&gt; are included or excluded will treat &lt;code&gt;begin&lt;/code&gt; as included and &lt;code&gt;end&lt;/code&gt; as excluded.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be0f9f39d5673fb5d350cd6b832b92db8b3eeda0" translate="yes" xml:space="preserve">
          <source>Also note that while normally the &lt;code&gt;end&lt;/code&gt; of an interval is excluded from it, &lt;code&gt;NegInfIntervalRange&lt;/code&gt; treats it as if it were included. This allows for the same behavior as with &lt;code&gt;PosInfIntervalRange&lt;/code&gt;. This works because none of &lt;code&gt;NegInfInterval&lt;/code&gt;'s functions which care about whether &lt;code&gt;end&lt;/code&gt; is included or excluded are ever called by &lt;code&gt;NegInfIntervalRange&lt;/code&gt;. &lt;code&gt;interval&lt;/code&gt; returns a normal interval, so any &lt;code&gt;NegInfInterval&lt;/code&gt; functions which are called on it which care about whether &lt;code&gt;end&lt;/code&gt; is included or excluded will treat &lt;code&gt;end&lt;/code&gt; as excluded.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="238e333d78d3953efe21f4c8dee91a8052bf6044" translate="yes" xml:space="preserve">
          <source>Also please note, that no spaces are allowed within the string anywhere whether it's a leading, trailing, or embedded space(s), thus they too must be stripped from the string before using this function, or any of the conversion functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19b283d04d340872863f50c8bc1177319aa2279b" translate="yes" xml:space="preserve">
          <source>Also see: &lt;code&gt;dmd.attrib.ForwardingAttribDeclaration&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ceee206f7bf1c9c9a3b0facedfafb260135ff34" translate="yes" xml:space="preserve">
          <source>Also, because no decoding occurs, it is possible to use this overload to translate ASCII characters within a proper UTF-8 string without altering the other, non-ASCII characters. It's replacing any code unit greater than &lt;code&gt;127&lt;/code&gt; with another code unit or replacing any code unit with another code unit greater than &lt;code&gt;127&lt;/code&gt; which will cause UTF validation issues.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd0ce1c13fb8625991e7b8d7c7f0d7c753bdcd89" translate="yes" xml:space="preserve">
          <source>Also, note that Phobos code assumes that the primitives &lt;code&gt;r.front&lt;/code&gt; and &lt;code&gt;r.empty&lt;/code&gt; are &amp;Omicron;(&lt;code&gt;1&lt;/code&gt;) time complexity wise or &quot;cheap&quot; in terms of running time. &amp;Omicron;() statements in the documentation of range functions are made with this assumption.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7575757c12c48b07e624443d696165742a7b14f4" translate="yes" xml:space="preserve">
          <source>Also, the IANA time zone database has a lot more time zones than Windows does.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f85c414c696f8d88b637f2931596bd576a74dbf" translate="yes" xml:space="preserve">
          <source>Also, you may wish to utilize the &lt;code&gt;reserve&lt;/code&gt; function to pre-allocate array data to use with the append operator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87ea7db4a430030d90185495584807fc225cd906" translate="yes" xml:space="preserve">
          <source>Also:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3cfd4ccb3c0f4865df49b814eab540d3553f2c1" translate="yes" xml:space="preserve">
          <source>Alternate name for &lt;a href=&quot;#Fields&quot;&gt;&lt;code&gt;Fields&lt;/code&gt;&lt;/a&gt;, kept for legacy compatibility.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d62f98b8f8caf5989633e5408f0d403968f08f9" translate="yes" xml:space="preserve">
          <source>Alternate name for &lt;a href=&quot;#ParameterDefaults&quot;&gt;&lt;code&gt;ParameterDefaults&lt;/code&gt;&lt;/a&gt;, kept for legacy compatibility.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c96b3e17073941a891d0a738663e82616b91e67" translate="yes" xml:space="preserve">
          <source>Alternate name for &lt;a href=&quot;#Parameters&quot;&gt;&lt;code&gt;Parameters&lt;/code&gt;&lt;/a&gt;, kept for legacy compatibility.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d679f53e7924ba2aa8d486d630ba51ae1a168a21" translate="yes" xml:space="preserve">
          <source>Alternate name for &lt;a href=&quot;#isExpressions&quot;&gt;&lt;code&gt;isExpressions&lt;/code&gt;&lt;/a&gt;, kept for legacy compatibility.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88e4f940df16ef30434b16d10b67a7bb93c43df0" translate="yes" xml:space="preserve">
          <source>Alternative sorting method that should be used when comparing keys involves an expensive computation. Instead of using &lt;code&gt;less(a, b)&lt;/code&gt; for comparing elements, &lt;code&gt;schwartzSort&lt;/code&gt; uses &lt;code&gt;less(transform(a), transform(b))&lt;/code&gt;. The values of the &lt;code&gt;transform&lt;/code&gt; function are precomputed in a temporary array, thus saving on repeatedly computing it. Conversely, if the cost of &lt;code&gt;transform&lt;/code&gt; is small compared to the cost of allocating and filling the precomputed array, &lt;code&gt;sort&lt;/code&gt; may be faster and therefore preferable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b074433d0046e94a8541abc9c7fb27718d93f11" translate="yes" xml:space="preserve">
          <source>Alternatively, &lt;code&gt;values&lt;/code&gt; can be passed at compile-time, allowing for a more efficient search, but one that only supports matching on equality:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c34214f7bf412f966f5ee7b7c1e43a0611031a85" translate="yes" xml:space="preserve">
          <source>Alternatively, inside the scope of an aggregate, only the member name is needed:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ab148c62e084629eaeb7919a9c875b4ac608894" translate="yes" xml:space="preserve">
          <source>Alternatively, instead of using a single &lt;code&gt;value&lt;/code&gt; to fill the &lt;code&gt;range&lt;/code&gt;, a &lt;code&gt;filter&lt;/code&gt;&lt;a href=&quot;std_range_primitives#isForwardRange&quot;&gt;forward range&lt;/a&gt; can be provided. The length of &lt;code&gt;filler&lt;/code&gt; and &lt;code&gt;range&lt;/code&gt; do not need to match, but &lt;code&gt;filler&lt;/code&gt; must not be empty.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="188d34f7156185437a8f88ec534863d101dd6cd7" translate="yes" xml:space="preserve">
          <source>Alternatively, you can declare a single templated &lt;code&gt;opEquals&lt;/code&gt; function with an &lt;a href=&quot;template#auto-ref-parameters&quot;&gt;auto ref&lt;/a&gt; parameter:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d49f83ba69fd5e0ed773bc16674431bab9674cc" translate="yes" xml:space="preserve">
          <source>Although &lt;code&gt;char[]&lt;/code&gt; and &lt;code&gt;wchar[]&lt;/code&gt; (as well as their qualified versions including &lt;code&gt;string&lt;/code&gt; and &lt;code&gt;wstring&lt;/code&gt;) are arrays, &lt;code&gt;isRandomAccessRange&lt;/code&gt; yields &lt;code&gt;false&lt;/code&gt; for them because they use variable-length encodings (UTF-8 and UTF-16 respectively). These types are bidirectional ranges only.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce1b50075d06a3525c670dfdee2303781cd59e16" translate="yes" xml:space="preserve">
          <source>Although D does not currently use a moving garbage collector, by following the rules listed above one can be implemented. No special action is required to pin objects. A moving collector will only move objects for which there are no ambiguous references, and for which it can update those references. All other objects will be automatically pinned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1aee14a59e8527fa460ebbbf449880cdcef580e1" translate="yes" xml:space="preserve">
          <source>Although a struct constructor returns a reference to the instance being constructed, it is treated as form (1).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2e0f6070914711324b1b22c0acefe2c4d0046f3" translate="yes" xml:space="preserve">
          <source>Although allocations are in theory served in linear searching time, &lt;code&gt;deallocate&lt;/code&gt; calls take &amp;Omicron;(&lt;code&gt;1&lt;/code&gt;) time, by using aligned allocations. &lt;code&gt;ParentAllocator&lt;/code&gt; must implement &lt;code&gt;alignedAllocate&lt;/code&gt; and it must be able to allocate &lt;code&gt;theAlignment&lt;/code&gt; bytes at the same alignment. Each aligned allocation done by &lt;code&gt;ParentAllocator&lt;/code&gt; will contain metadata for an &lt;code&gt;Allocator&lt;/code&gt;, followed by its payload.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba5576589df037851e2ab68a594e957c64a2217b" translate="yes" xml:space="preserve">
          <source>Although narrow string types (&lt;code&gt;char[]&lt;/code&gt;, &lt;code&gt;wchar[]&lt;/code&gt;, and their qualified derivatives) do define a &lt;code&gt;length&lt;/code&gt; property, &lt;code&gt;hasLength&lt;/code&gt; yields &lt;code&gt;false&lt;/code&gt; for them. This is because a narrow string's length does not reflect the number of characters, but instead the number of encoding units, and as such is not useful with range-oriented algorithms. To use strings as random-access ranges with length, use &lt;a href=&quot;std_string#representation&quot;&gt;&lt;code&gt;std.string.representation&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;std_utf#byCodeUnit&quot;&gt;&lt;code&gt;std.utf.byCodeUnit&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="751a51b5f3815e4913ea4c1e3d08b8c0587fdc03" translate="yes" xml:space="preserve">
          <source>Although some keywords can be used both as a type qualifier and a storage class, there are some storage classes that cannot be used to construct new types, such as &lt;code&gt;ref&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd93adfa24c055484c1d6ac7b1222125e38dd6c6" translate="yes" xml:space="preserve">
          <source>Although static variable name visibility follows the usual scoping rules, the names of them must be unique within a particular function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d68e23bc937fb1a750f414f57afc9ba51e4f8a9" translate="yes" xml:space="preserve">
          <source>Although the contents of the padding are often zero, do not rely on that.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f6d1d3556d0e4071164ab02759b80b8f87727af" translate="yes" xml:space="preserve">
          <source>Although the data is immutable, the allocator &quot;knows&quot; the underlying memory is mutable, so &lt;code&gt;immutable&lt;/code&gt; is elided for the affix which is independent from the data itself. However, the result is &lt;code&gt;shared&lt;/code&gt; because &lt;code&gt;immutable&lt;/code&gt; is implicitly shareable so multiple threads may access and manipulate the affix for the same data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4594a211d07176e71f67f04c76263fc9e17f8056" translate="yes" xml:space="preserve">
          <source>Always &lt;code&gt;false&lt;/code&gt; (random generators are infinite ranges).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2317146c4b78429c9fa4a78c82cf701740b74a6" translate="yes" xml:space="preserve">
          <source>Always &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ed0571bb284ff0022a6b18f52dbb495171fb6f8" translate="yes" xml:space="preserve">
          <source>Always a new scope, to use for this &lt;code&gt;DeprecatedDeclaration&lt;/code&gt;'s members.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ecdf7d32ac0560522ba0c167fff3b2a8084d9926" translate="yes" xml:space="preserve">
          <source>Always add new return codes last. Never &lt;em&gt;EVER&lt;/em&gt; remove any. The return codes must remain the same!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91aa9903448204ed37d902e02a20b0b8d1775687" translate="yes" xml:space="preserve">
          <source>Always call &lt;a href=&quot;#wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt; to wait for a process to complete, even if &lt;code&gt;kill&lt;/code&gt; has been called on it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00efb2c1e297670bc7025d03ccb66d306c20b175" translate="yes" xml:space="preserve">
          <source>Always defined; used as the opposite of &lt;code&gt;none&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c125fb83f824d4bd1d2beebad9485aed6b09839a" translate="yes" xml:space="preserve">
          <source>Always do checking</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e048da15ca2bf279cd35e525737612e720e444c" translate="yes" xml:space="preserve">
          <source>Always inline the functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="756f986f9bcdd129940f4871df381abfdb52d4bb" translate="yes" xml:space="preserve">
          <source>Always insert the decimal point and print trailing zeros.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e89bec8fb850573de2289bb9dc31383490faf82d" translate="yes" xml:space="preserve">
          <source>Always returns &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28625924634a090c91d5b21229f6718ca1949c53" translate="yes" xml:space="preserve">
          <source>Always returns false (unless the given interval is empty) because an interval beginning at negative infinity can never be after any other interval.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bdadc4badca1a50ef408f60afbd76636c86734c4" translate="yes" xml:space="preserve">
          <source>Always returns false (unless the given interval is empty) because an interval going to positive infinity can never be before any other interval.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94fa66f43e494b57c40dedacad5e8fcc5ed7e45e" translate="yes" xml:space="preserve">
          <source>Always returns false (unless this interval is empty) because a finite interval can never be after an interval going to positive infinity.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d882cba308665fda178b09f0755ed0e7ac35509a" translate="yes" xml:space="preserve">
          <source>Always returns false (unless this interval is empty) because a finite interval can never be before an interval beginning at negative infinity.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="839ddfcb8311f35aad2fb0b8e24e88538a023202" translate="yes" xml:space="preserve">
          <source>Always returns false (unless this interval is empty), because an interval beginning at negative infinity can never be contained in a finite interval.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ed45722000fa0537c28f229adeae463146f4016" translate="yes" xml:space="preserve">
          <source>Always returns false (unless this interval is empty), because an interval going to positive infinity can never be contained in a finite interval.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a53924ebd00c5459aa871927c9ec67510a96dd54" translate="yes" xml:space="preserve">
          <source>Always returns false because an interval beginning at negative infinity can never be after any other interval.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9bab92525c979c53e601d84248db55d697093d3" translate="yes" xml:space="preserve">
          <source>Always returns false because an interval beginning at negative infinity can never be after any time point.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="829c04d974963809ceb0735be3d487911f2864cf" translate="yes" xml:space="preserve">
          <source>Always returns false because an interval beginning at negative infinity can never be before another interval beginning at negative infinity.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48190dd4a715744e9634474743dcbc604a9ca68f" translate="yes" xml:space="preserve">
          <source>Always returns false because an interval beginning at negative infinity can never contain an interval going to positive infinity.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87f5c7255865a6aa09545519f01b0f602d71f734" translate="yes" xml:space="preserve">
          <source>Always returns false because an interval going to positive infinity can never be after another interval going to positive infinity.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94b78d489ebc6bd76631339902c007afae618abe" translate="yes" xml:space="preserve">
          <source>Always returns false because an interval going to positive infinity can never be before any other interval.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b622d5187c151cf5715d74c3640dbb076d4394c" translate="yes" xml:space="preserve">
          <source>Always returns false because an interval going to positive infinity can never be before any time point.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46754795cce31e571fe7c4a3849c49251d755cfd" translate="yes" xml:space="preserve">
          <source>Always returns false because an interval going to positive infinity can never contain an interval beginning at negative infinity.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51bcc244bd67d8750a4fdd4fbdf0a387caa703aa" translate="yes" xml:space="preserve">
          <source>Always returns false because two intervals beginning at negative infinity can never be adjacent to one another.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5de1beefc377ac68c64f67a4b951a1494a514eb5" translate="yes" xml:space="preserve">
          <source>Always returns false because two intervals going to positive infinity can never be adjacent to one another.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e5c51adf29d169f29f627d0dc8290c18d19524d" translate="yes" xml:space="preserve">
          <source>Always returns false.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9789c7e0f94b9d97c7bb5b256c563654386851c1" translate="yes" xml:space="preserve">
          <source>Always returns true because two intervals beginning at negative infinity always overlap.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ae3ed1006060103837a55fb96e4df45549bbde7" translate="yes" xml:space="preserve">
          <source>Always returns true because two intervals going to positive infinity always overlap.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99690d58d4abd10cd0938a7adcb56ded08ef66ad" translate="yes" xml:space="preserve">
          <source>An</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dcf1c44121ab11079f75ad4f70a75125be5a6a9a" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;#EmailStatus&quot;&gt;&lt;code&gt;EmailStatus&lt;/code&gt;&lt;/a&gt;, indicating the status of the email address.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ffe9a34aa0d7b745cc8f891bddd4b51b3279fa26" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;#LName&quot;&gt;&lt;i&gt;LName&lt;/i&gt;&lt;/a&gt; is a name preceded by a &lt;a href=&quot;#Number&quot;&gt;&lt;i&gt;Number&lt;/i&gt;&lt;/a&gt; giving the number of characters in the &lt;a href=&quot;#Name&quot;&gt;&lt;i&gt;Name&lt;/i&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9368e81deb8013394f56e991844ff7d8f9e56b8" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;expression#ArrayLiteral&quot;&gt;&lt;i&gt;ArrayLiteral&lt;/i&gt;&lt;/a&gt; is inferred to be a dynamic array type rather than a static array:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89d876389132db631f40f8472f475c33763a7de8" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;expression#AssertExpression&quot;&gt;&lt;i&gt;AssertExpression&lt;/i&gt;&lt;/a&gt; that fails its condition</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6590283f72c8bc68a61e26f8207b2166720f88ee" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;std_meta#AliasSeq&quot;&gt;&lt;code&gt;std.meta.AliasSeq&lt;/code&gt;&lt;/a&gt; with all possible target types of an implicit conversion &lt;code&gt;T&lt;/code&gt;.  If &lt;code&gt;T&lt;/code&gt; is a class derived from &lt;code&gt;Object&lt;/code&gt;, the the result of &lt;a href=&quot;#TransitiveBaseTypeTuple&quot;&gt;&lt;code&gt;TransitiveBaseTypeTuple&lt;/code&gt;&lt;/a&gt; is returned.  If the type is not a built-in value type or a class derived from &lt;code&gt;Object&lt;/code&gt;, the an empty &lt;a href=&quot;std_meta#AliasSeq&quot;&gt;&lt;code&gt;std.meta.AliasSeq&lt;/code&gt;&lt;/a&gt; is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5357eeb67edd28cef849aec387209e4ff6da64a3" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;input range&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5ae81b9680ce568443b4c970f3bc5dc366146d8" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;input range&lt;/a&gt; of &lt;a href=&quot;#DirEntry&quot;&gt;&lt;code&gt;DirEntry&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f659b816c177344a9a4b993dd7f1f23fa0444745" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;input range&lt;/a&gt; of consecutively unique elements in the original range. If &lt;code&gt;r&lt;/code&gt; is also a forward range or bidirectional range, the returned range will be likewise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a3658d6619aac9bf9bbbb396cba995f2c9f0bb3" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;input range&lt;/a&gt; of elements</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aeb6a5dabc8ee71a80f9364ee1475c7fc12f32a2" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;input range&lt;/a&gt; of elements to filter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="707d66d0f4a293729b9673f780ebae8dbcfcc3c1" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;input range&lt;/a&gt; of elements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33c6aa39a8169309ace06cecc9bf8cd227418643" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;input range&lt;/a&gt; of input ranges</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e44b358ef6f4995ad58c7e05ef241784818aecf" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;input range&lt;/a&gt; of input ranges to be joined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db74a7a8ef007cbf994b98f4433445f62a98cc07" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;input range&lt;/a&gt; of keys</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95280f839dfcc7e6fffaf43a757e145f824a67a0" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;input range&lt;/a&gt; of segments to assemble the path from.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b7d7db68f90c0aa95feaeaf3c9f2a490793d047" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;input range&lt;/a&gt; of slices of the original range split by whitespace.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb75e1af2690fdd4800075d57086bf1d4208ae4b" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;input range&lt;/a&gt; of tuples of keys and values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97ff10ecbc90564b57494f893fe51dd077880140" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;input range&lt;/a&gt; of values</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="133de0070e3c643c203f06c3842a5a65269aacef" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;input range&lt;/a&gt; over the data to be decoded.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05ae651266b6aebe6405ca7d3e9d38d6bbda4a2e" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;input range&lt;/a&gt; over the data to be encoded.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53e90b53eb146e6b34d965149154b8c1b40783a3" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;input range&lt;/a&gt; that exposes references to its elements and has assignable elements</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea7d6814c8da44833511f491c47ceb591d626a8d" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;input range&lt;/a&gt; that iterates over the bytes of data decoded from a Base64 encoded string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0e959040d1e17340e8751524e2d4256b8691ac7" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;input range&lt;/a&gt; that iterates over the decoded data of a range of Base64 encodings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43af4719ff15eb275c1c72c27f3b8376924d9bc1" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;input range&lt;/a&gt; that iterates over the encoded bytes of the given source data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49c67170189246c824452f09ce0e9b881029c595" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;input range&lt;/a&gt; that iterates over the original range's elements, but ends when the specified predicate becomes true. If the original range is a &lt;a href=&quot;std_range_primitives#isForwardRange&quot;&gt;forward range&lt;/a&gt; or higher, this range will be a forward range.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1a22b9c6d64de659aa93282f2a2c09eb16b5f23" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;input range&lt;/a&gt; that iterates over the respective Base64 encodings of a range of data items.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7f2d0c17c0405fa6b38c89079adc1903c913cb8" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;input range&lt;/a&gt; to be chunked.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c892ebe289689b74313c775aba7569dc3d96121e" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;input range&lt;/a&gt; with elements that elements from &lt;code&gt;src&lt;/code&gt; can be moved into.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b62730011ee93bfeac5690d8a28be51290200dce" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;input range&lt;/a&gt; with movable elements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="501f3d209c91fc5763279ea66a99a52ae9245f3d" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;input range&lt;/a&gt; with the cached values of range</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="965b67bd175b57783d700b642e30d67633838585" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;input range&lt;/a&gt;, or any number of implicitly convertible items to insert into &lt;code&gt;array&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="568cafc64895197463cb35df36675af55e4422de" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;std_range_primitives#isOutputRange&quot;&gt;output range&lt;/a&gt; which accepts string types, &lt;code&gt;ubyte[]&lt;/code&gt;, individual character types, and individual &lt;code&gt;ubyte&lt;/code&gt;s.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96659bf0ec2c02c0f163ebb47294be48aeeef57c" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;std_stdio#File&quot;&gt;&lt;code&gt;std.stdio.File&lt;/code&gt;&lt;/a&gt; that allows reading from the child process' standard error stream.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20e84e08d65e61dcd687cc1797aa39066181d9c1" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;std_stdio#File&quot;&gt;&lt;code&gt;std.stdio.File&lt;/code&gt;&lt;/a&gt; that allows reading from the child process' standard output stream.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53e5c6c6f6f60588aedc9a37247bd45dc00707bc" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;std_stdio#File&quot;&gt;&lt;code&gt;std.stdio.File&lt;/code&gt;&lt;/a&gt; that allows writing to the child process' standard input stream.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e9533a6a3d9a4d55816c193bc0f53b935c22f6d" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;template#variadic-templates&quot;&gt;expression sequence&lt;/a&gt; of all struct fields - see &lt;a href=&quot;class#class_properties&quot;&gt;Class Properties&lt;/a&gt; for a class-based example.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3a6583818c5f8f234b1ec03cdc9d796a3fa7ebe" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;Address&lt;/code&gt; instance representing specified address.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56e2323d99083365dfdf1e12a30b245e969af361" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;AliasSeq&lt;/code&gt; containing the values produced by iterating over &lt;code&gt;iter&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8cfdc9c8275278162fbcaa5be1463495fde71d3" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;AliasSeq&lt;/code&gt; filtered by the selected stride.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20aff1a9df323b6df7883ad0a1e714a382dae9ef" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;AliasSeq&lt;/code&gt; of &lt;code&gt;args&lt;/code&gt; with &lt;code&gt;out&lt;/code&gt;, &lt;code&gt;ref&lt;/code&gt;, and &lt;code&gt;lazy&lt;/code&gt; saved.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94b6f12ba21ae4feae1b40330f4a8aa9e0a73296" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;Exception&lt;/code&gt; if all of the ranges are not the same length and &lt;code&gt;sp&lt;/code&gt; is set to &lt;code&gt;StoppingPolicy.requireSameLength&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d61cad630058a64dcee11973cf4730e528fa9b3" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;Interval&lt;/code&gt; has a starting point and an end point. The interval of time is therefore the time starting at the starting point up to, but not including, the end point. e.g.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11231347c4e1b61534c1256649e8160ffb845ccb" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;enum&lt;/code&gt; of type &lt;code&gt;Target&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f32443fe48d10edfa532d0732e99edf167154d6" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;extern&lt;/code&gt; declaration can optionally be followed by an &lt;code&gt;extern&lt;/code&gt;&lt;a href=&quot;attribute#linkage&quot;&gt;linkage attribute&lt;/a&gt;. If there is no linkage attribute it defaults to &lt;code&gt;extern(D)&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb13928ebe13144a8f0cde9175549c7ca8ef3240" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;int&lt;/code&gt; that is 0 if the strings match, &amp;lt;0 if &lt;code&gt;r1&lt;/code&gt; is lexicographically &quot;less&quot; than &lt;code&gt;r2&lt;/code&gt;, &amp;gt;0 if &lt;code&gt;r1&lt;/code&gt; is lexicographically &quot;greater&quot; than &lt;code&gt;r2&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="efb2860a0ceaf8160fc6745198e13de4de19934e" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;int&lt;/code&gt; that is 0 if the strings match, &amp;lt;0 if &lt;code&gt;str1&lt;/code&gt; is lexicographically &quot;less&quot; than &lt;code&gt;str2&lt;/code&gt;, &amp;gt;0 if &lt;code&gt;str1&lt;/code&gt; is lexicographically &quot;greater&quot; than &lt;code&gt;str2&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd2a5ae8ac277d08cffcbd8287934b6c72d5390c" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;std.typecons.Tuple!(bool, &quot;terminated&quot;, int, &quot;status&quot;)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b29fdcb57cf0f2aa50c1917aef7ee2d7326de41" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;std.typecons.Tuple!(int, &quot;status&quot;, string, &quot;output&quot;)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44325a188ea9f569f00f25fe1293e0a22a6a319a" translate="yes" xml:space="preserve">
          <source>An Associative Array can be iterated in key/value fashion using a &lt;a href=&quot;statement#ForeachStatement&quot;&gt;foreach statement&lt;/a&gt;. As an example, the number of occurrences of all possible substrings of length 2 (aka 2-mers) in a string will be counted:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a90c85005c067a015cf8ee553e7e07506f3cb661" translate="yes" xml:space="preserve">
          <source>An Associative Array defaults to &lt;code&gt;null&lt;/code&gt;, and is constructed upon assigning the first key/value pair. However, once constructed, an associative array has</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20dacc2ff7dcec50b018c97c25042104ca6d5e2d" translate="yes" xml:space="preserve">
          <source>An N-dimensional array with individual elements of type T.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="374153a385906e41868a8afe177a5c76f263689c" translate="yes" xml:space="preserve">
          <source>An OutputRange that discards the data it receives.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7013471ca7cfba239c38e91976beb8fce0d63dd" translate="yes" xml:space="preserve">
          <source>An abstract character does not necessarily correspond to what a user thinks of as a &amp;ldquo;character&amp;rdquo; and should not be confused with a &lt;a href=&quot;#Grapheme&quot;&gt;&lt;code&gt;Grapheme&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fdba09e2a7de450eb20cc61c51e59eb62e78cd9a" translate="yes" xml:space="preserve">
          <source>An abstract character has no concrete form and should not be confused with a &lt;a href=&quot;#Glyph&quot;&gt;glyph&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5231e46b8fbe9153560533f1e9c30f8aa007e730" translate="yes" xml:space="preserve">
          <source>An abstract member function must be overridden by a derived class. Only virtual member functions may be declared abstract; non-virtual member functions and free-standing functions cannot be declared abstract.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4533566ebe9595ef8c3fb7a85a6b2b8cded96094" translate="yes" xml:space="preserve">
          <source>An additional hidden argument with the name &lt;code&gt;_arguments&lt;/code&gt; and type &lt;code&gt;TypeInfo[]&lt;/code&gt; is passed to the function. &lt;code&gt;_arguments&lt;/code&gt; gives the number of arguments and the type of each, enabling type safety to be checked at run time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b6d0293666de158be3f12d22968c31c56140ac3" translate="yes" xml:space="preserve">
          <source>An adjustor thunk looks like:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0847d49328423d89a734c43cd88e9b79a0544a70" translate="yes" xml:space="preserve">
          <source>An alias for &lt;code&gt;minAlign&lt;/code&gt;, which must be a valid alignment (nonzero power of 2). The start of the region and all allocation requests will be rounded up to a multiple of the alignment.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9993ac9ea2f6651d34b1aa2a448a3c14badfcb90" translate="yes" xml:space="preserve">
          <source>An alternate form of wysiwyg strings are enclosed by backquotes, the ` character.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ffb2ff8aaa0d0c4fff2997632dac364705c0344c" translate="yes" xml:space="preserve">
          <source>An alternative version of curl_multi_perform() that allows the application to pass in one of the file descriptors that have been detected to have &quot;action&quot; on them and let libcurl perform. See man page for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67aef8339b904d4fa6032e3895c0a4baeec8d2c9" translate="yes" xml:space="preserve">
          <source>An anonymous nested class is both defined and instantiated with a</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6df80b73f182ab7ff7950f3a7e97396adcc2088" translate="yes" xml:space="preserve">
          <source>An arbitrary-precision integer type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3c537c68c1280a36448d29d7b84b05b6066936e" translate="yes" xml:space="preserve">
          <source>An argument to a &lt;code&gt;lazy&lt;/code&gt; parameter is not evaluated before the function is called. The argument is only evaluated if/when the parameter is evaluated within the function. Hence, a &lt;code&gt;lazy&lt;/code&gt; argument can be executed 0 or more times.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea18ca730a0aa21281c1af9096a60b9ecf44e189" translate="yes" xml:space="preserve">
          <source>An array containing references to all threads currently being tracked by the system. The result of deleting any contained objects is undefined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77815bde2a83a1011d8ecf1e77f89465ef4b38cb" translate="yes" xml:space="preserve">
          <source>An array containing the divided parts of &lt;code&gt;range&lt;/code&gt; (or the words of &lt;code&gt;s&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="daec8cadf3d6935e405e9c172ddf7e64c36f7c31" translate="yes" xml:space="preserve">
          <source>An array of &lt;code&gt;Statement&lt;/code&gt;s, that will referenced by this class</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29fa536473a8fa6b0ec875c2597efa9dce1d5e34" translate="yes" xml:space="preserve">
          <source>An array of &lt;code&gt;T&lt;/code&gt; with &lt;code&gt;I.length&lt;/code&gt; dimensions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="479c220b9bb5c5c461e1a646be4bf0d486b927a9" translate="yes" xml:space="preserve">
          <source>An array of complex numbers representing the transformed data in the frequency domain.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0621e8fe8af51735a47c76956cd2a28911a1a9f" translate="yes" xml:space="preserve">
          <source>An array of elements</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7326b4532e3c0a6987d70e29c99a0d57edd13a68" translate="yes" xml:space="preserve">
          <source>An array of path to D modules</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fbfc4f55870a8b45855e77b9502741089e3999c7" translate="yes" xml:space="preserve">
          <source>An array of paths to assemble.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6eeb3c945dc78c366a34ecd56e6cc4c9081dc7db" translate="yes" xml:space="preserve">
          <source>An array of regular expression strings. The resulting &lt;code&gt;Regex&lt;/code&gt; object will match any expression; use &lt;a href=&quot;#whichPattern&quot;&gt;&lt;code&gt;whichPattern&lt;/code&gt;&lt;/a&gt; to know which.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="418fbbabc9dc07ec6379ba1dda3419b4c8dd83da" translate="yes" xml:space="preserve">
          <source>An array of type &lt;code&gt;Target&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81574167760f6ba7a1bdd1dc1d384e2cfcd701d9" translate="yes" xml:space="preserve">
          <source>An array or asssociative array literal. &lt;a href=&quot;#Number&quot;&gt;&lt;i&gt;Number&lt;/i&gt;&lt;/a&gt; is the length of the array. &lt;a href=&quot;#Value&quot;&gt;&lt;i&gt;Value&lt;/i&gt;&lt;/a&gt; is repeated &lt;a href=&quot;#Number&quot;&gt;&lt;i&gt;Number&lt;/i&gt;&lt;/a&gt; times for a normal array, and 2 * &lt;a href=&quot;#Number&quot;&gt;&lt;i&gt;Number&lt;/i&gt;&lt;/a&gt; times for an associative array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="039c70efd683d3e9b93b4df14d2d6d5c5145b436" translate="yes" xml:space="preserve">
          <source>An array that consists of &lt;code&gt;s&lt;/code&gt; repeated &lt;code&gt;n&lt;/code&gt; times. This function allocates, fills, and returns a new array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17d3bd6e24229484523be9a3c75e2496e09c2fce" translate="yes" xml:space="preserve">
          <source>An array which contains the program name as the zeroth element and any command-line arguments in the following elements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ab896a4e586f016dcbd9051e137d42864250451" translate="yes" xml:space="preserve">
          <source>An array which contains the program name as the zeroth element and any command-line arguments in the following elements. (See &lt;a href=&quot;#spawnProcess&quot;&gt;&lt;code&gt;spawnProcess&lt;/code&gt;&lt;/a&gt; for details.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b92a8e452fa62db1566192e1dffdc9e80610f68" translate="yes" xml:space="preserve">
          <source>An array with the same element type as &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="598dedc2bf0e9cd988bf5a32f1e674f47e9054d4" translate="yes" xml:space="preserve">
          <source>An asm statement enables the direct use of assembly language instructions. This makes it easy to obtain direct access to special CPU features without resorting to an external assembler. The D compiler will take care of the function calling conventions, stack setup, etc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8302b7bfc189e1b4c0ac50685a98310945e13267" translate="yes" xml:space="preserve">
          <source>An associative array can be tested to see if an element is in the array:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63634bc46188cedd4498192107dab899f5055fcb" translate="yes" xml:space="preserve">
          <source>An associative array mapping elements to weights.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff67502c32274c3ab17b5bd51317488c7f9e8d17" translate="yes" xml:space="preserve">
          <source>An associative array of type &lt;code&gt;Target&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="956aeaeb58bfe5aa034cd122a587434b8ac88521" translate="yes" xml:space="preserve">
          <source>An attacker wants to send harmful data to your server, which requires a integrity HMAC SHA1 token signed with a secret.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be28bdcc45d4da897969c562a4da4fd240bfaeb2" translate="yes" xml:space="preserve">
          <source>An attractive feature of UUIDs when compared to alternatives is their relative small size, of 128 bits, or 16 bytes. Another is that the creation of UUIDs does not require a centralized authority.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7195e6cce01f1fb7dad70c303c1f8649fcd1f03b" translate="yes" xml:space="preserve">
          <source>An auto function is declared without a return type. If it does not already have a storage class, use the auto storage class.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03d538bd3cecd7df878dcb400c90734b77cf2b23" translate="yes" xml:space="preserve">
          <source>An auto ref function template parameter becomes a ref parameter if its corresponding argument is an lvalue, otherwise it becomes a value parameter:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14284ad6c006c28b3ea6130bf5b64152ddb04c86" translate="yes" xml:space="preserve">
          <source>An eager version of &lt;code&gt;splitter&lt;/code&gt; that creates an array with splitted slices of &lt;code&gt;input&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d74290ce6e26cbf9d133491fbe882725c8fd224" translate="yes" xml:space="preserve">
          <source>An earlier version of the documentation incorrectly stated that &lt;code&gt;-1&lt;/code&gt; is the only negative value returned and &lt;code&gt;1&lt;/code&gt; is the only positive value returned. Whether that is true depends on the types being compared.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="564af87619e62a538d43ce07aa464a50505648ac" translate="yes" xml:space="preserve">
          <source>An email status code, indicating if an email address is valid or not. If it is invalid it also indicates why.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57821790126b7d9653db7d5ab96220cb8a8449b5" translate="yes" xml:space="preserve">
          <source>An embedded list builds a most-recently-used strategy: the most recent allocators used in calls to either &lt;code&gt;allocate&lt;/code&gt;, &lt;code&gt;owns&lt;/code&gt; (successful calls only), or &lt;code&gt;deallocate&lt;/code&gt; are tried for new allocations in order of their most recent use. Thus, although core operations take in theory &amp;Omicron;(&lt;code&gt;k&lt;/code&gt;) time for &lt;code&gt;k&lt;/code&gt; allocators in current use, in many workloads the factor is sublinear. Details of the actual strategy may change in future releases.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e2d7c3c03945c2979ade27d1766c3427f23af71" translate="yes" xml:space="preserve">
          <source>An empty enum body (For example &lt;code&gt;enum E;&lt;/code&gt;) signifies an opaque enum - the enum members are unknown.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="182b823f47405fe4bd517067833d2431e24dcb91" translate="yes" xml:space="preserve">
          <source>An empty range.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b60e63467d1ead57d7b824f987eda3203e244a7" translate="yes" xml:space="preserve">
          <source>An entire program can be written in &lt;b&gt;BetterC&lt;/b&gt; by supplying a C &lt;code&gt;main()&lt;/code&gt; function:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42f22d22943ec9876daf38f246747335b3206a97" translate="yes" xml:space="preserve">
          <source>An enum can be implicitly converted to its base type, but going the other way requires an explicit conversion. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20274664503ab2b78599fa35b2c6976d6732af22" translate="yes" xml:space="preserve">
          <source>An enum can have multiple members which have the same value. If you want to use EnumMembers to e.g. generate switch cases at compile-time, you should use the &lt;a href=&quot;std_meta#NoDuplicates&quot;&gt;&lt;code&gt;std.meta.NoDuplicates&lt;/code&gt;&lt;/a&gt; template to avoid generating duplicate switch cases.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ccb5e54934db47a114cb48c08f87f6a9591ebdc" translate="yes" xml:space="preserve">
          <source>An enumerated type. &lt;code&gt;E&lt;/code&gt; may have duplicated values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1735ccd74a7dfbde9ac3516d787c61e34b65fdd9" translate="yes" xml:space="preserve">
          <source>An environment without an operating system (such as Bare-metal targets)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f809d6288855134dff456bf6ac1c95f894cfd5e3" translate="yes" xml:space="preserve">
          <source>An error message supplied by the user.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22b5aeaf7859c416b77cbb971c1f98412c7e91a6" translate="yes" xml:space="preserve">
          <source>An even permutation is one which is produced by swapping an even number of pairs of elements in the original range. The set of</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf3445745f98506a937cbbe828a5f495bdf57758" translate="yes" xml:space="preserve">
          <source>An example Scheduler using Fibers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8895ad0e3d621b831278de48f37930b071bff33" translate="yes" xml:space="preserve">
          <source>An example Scheduler using kernel threads.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26be4513512b7649f788720ecf8495f76d5a5e27" translate="yes" xml:space="preserve">
          <source>An example using this might be:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a9fd3843ecc8c2de2413f35d41e6dffcb1a7e0f" translate="yes" xml:space="preserve">
          <source>An exception that signals a problem with starting or waiting for a process.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da1bd43b320d9d6951e218332ce5fe294afbcb16" translate="yes" xml:space="preserve">
          <source>An explicit &lt;code&gt;break&lt;/code&gt;/&lt;code&gt;continue&lt;/code&gt; label can be used to avoid this limitation. (Note that &lt;code&gt;static foreach&lt;/code&gt; itself cannot be broken nor continued even if it is explicitly labeled.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4c419979ff292482ec7caed76ce12cf20cdff6d" translate="yes" xml:space="preserve">
          <source>An explicit seed may be provided as the first argument. If provided, it is used as the seed for all work units and for the final reduction of results from all work units. Therefore, if it is not the identity value for the operation being performed, results may differ from those generated by &lt;a href=&quot;std_algorithm_iteration#reduce&quot;&gt;&lt;code&gt;std.algorithm.iteration.reduce&lt;/code&gt;&lt;/a&gt; or depending on how many work units are used. The next argument must be the range to be reduced.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="813be4ff1857df0549bcdcfd3e08cf103fc4ef9a" translate="yes" xml:space="preserve">
          <source>An explicit work unit size may be specified as the last argument. Specifying too small a work unit size will effectively serialize the reduction, as the final reduction of the result of each work unit will dominate computation time. If &lt;code&gt;TaskPool.size&lt;/code&gt; for this instance is zero, this parameter is ignored and one work unit is used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0fd613c26e74a1b3f4e55de4f7a9e820062689a" translate="yes" xml:space="preserve">
          <source>An expression is a sequence of operators and operands that specifies an evaluation. The syntax, order of evaluation, and semantics of expressions are as follows.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06fe4315b1fb38b822d67e7c040bc5b1f34c50c5" translate="yes" xml:space="preserve">
          <source>An expression may be converted from immutable to mutable if the expression is unique.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="405b72bbf5cd1ecea0f847f041852bc8f1e21267" translate="yes" xml:space="preserve">
          <source>An expression may be converted from mutable or shared to immutable if the expression is unique and all expressions it transitively refers to are either unique or immutable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="038c4cfe80a0e1283f840551b0b9c6235c040703" translate="yes" xml:space="preserve">
          <source>An expression may be converted from mutable to shared if the expression is unique and all expressions it transitively refers to are either unique, immutable, or shared.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1316dd74d7c8ddd73ce90ec6a71f0202d5cfedc3" translate="yes" xml:space="preserve">
          <source>An expression may be converted from shared to mutable if the expression is unique.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ed051b5f24cb3bdb14e7ca6dadf808a8182256e" translate="yes" xml:space="preserve">
          <source>An expression that contains no side effects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14b91d68f1409c403821f7e2395540ae4efe1e65" translate="yes" xml:space="preserve">
          <source>An expression that discards its result. If the argument is null or not a CommaExp, nothing happens.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2da87c9bf77a96f0a7e8a08472638759b2796da0" translate="yes" xml:space="preserve">
          <source>An identifier that corresponds to each static field in this struct will be placed in the identifier pool.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29be0b87cd939460b9a6e031fd7b9746d13400f2" translate="yes" xml:space="preserve">
          <source>An identity assignment overload is required for a struct if one or more of these conditions hold:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c62cfceef6921debd60c6c989b8a6621704ef9cf" translate="yes" xml:space="preserve">
          <source>An immutable or const type qualifier can be removed with a cast:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1978b5c17c98e8bf28acd8b0134128096257bb6e" translate="yes" xml:space="preserve">
          <source>An implementation is free to perform heap compaction and copying so long as no valid GC pointers are invalidated in the process. However, memory allocated with &lt;code&gt;GC.BlkAttr.&lt;a href=&quot;#NO_MOVE&quot;&gt;NO_MOVE&lt;/a&gt;&lt;/code&gt; must not be moved/copied.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4a12d968ae65e1a6afdfd511c35a5dc8f841297" translate="yes" xml:space="preserve">
          <source>An implementation may assume that a &lt;code&gt;pure&lt;/code&gt; function that (a) accepts only parameters without mutable indirections, and (b) returns a result without mutable indirections, will have the same effect for all invocation with equivalent arguments, and is allowed to memoize the result of the function under the assumption that equivalent parameters always produce equivalent results. Such functions are termed</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ebe5dd05444d0198f9f66e793ceca70c1980b807" translate="yes" xml:space="preserve">
          <source>An implementation may construct the object or array instance on the stack. Therefore, it is an error to refer to that instance after the variadic function has returned:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74288b66176460a92a66dcc8ea28e93696886600" translate="yes" xml:space="preserve">
          <source>An implementation may perform transformations on floating point computations in order to reduce their strength, i.e. their runtime computation time. Because floating point math does not precisely follow mathematical rules, some transformations are not valid, even though some other programming languages still allow them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ce778a63881d05f0438cdea7125a850f6f3ff60" translate="yes" xml:space="preserve">
          <source>An implementation may provide a means of overriding the cycle detection abort. A typical method uses the D Runtime switch &lt;code&gt;--DRT-oncycle=...&lt;/code&gt; where the following behaviors are supported:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29f794447dac8202e31e213bb8c23478c8aa558d" translate="yes" xml:space="preserve">
          <source>An implementation may rearrange the evaluation of expressions according to arithmetic associativity and commutativity rules as long as, within that thread of execution, no observable difference is possible.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f7ecd52c6b042334def208ec0513d80f9a2a5ed" translate="yes" xml:space="preserve">
          <source>An import can be explicitly declared</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38f4d49a07266de3b15530c1f9a75863df6ff329" translate="yes" xml:space="preserve">
          <source>An improved D function for formatted output is &lt;code&gt;std.stdio.writef()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9cb97ce4508c3a47fa6274780fa6593ebb6be60" translate="yes" xml:space="preserve">
          <source>An infinity was generated by division by zero</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6890806a1ad6818323e1006abea77b6b3d37709f" translate="yes" xml:space="preserve">
          <source>An infinity was generated by overflow</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae9c3bc7805fd7227432d2eaa0eab014f342aca5" translate="yes" xml:space="preserve">
          <source>An initialized &lt;code&gt;RefCounted&lt;/code&gt; containing &lt;code&gt;val&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87972790a4f1887f61efbff5428d42aa21b25d17" translate="yes" xml:space="preserve">
          <source>An inline comment that is ignored while matching.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85da1ce1be9cc229a0d38aa534ff7a6f98704992" translate="yes" xml:space="preserve">
          <source>An input range R as defined by &lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;&lt;code&gt;std.range.primitives.isInputRange&lt;/code&gt;&lt;/a&gt;. When &lt;code&gt;Contents&lt;/code&gt; is a struct, class, or an associative array, the element type of R is &lt;code&gt;Contents&lt;/code&gt;, otherwise the element type of R is itself a range with element type &lt;code&gt;Contents&lt;/code&gt;.  If a &lt;code&gt;header&lt;/code&gt; argument is provided, the returned range provides a &lt;code&gt;header&lt;/code&gt; field for accessing the header from the input in array form.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8233ac502082d5effa82f80dbc2e0cac66b1db40" translate="yes" xml:space="preserve">
          <source>An input range at minimum. If all of the ranges in &lt;code&gt;rs&lt;/code&gt; provide a range primitive, the returned range will also provide that range primitive.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7168e31c32e5919f60149f7ae2d8c075d8657c9" translate="yes" xml:space="preserve">
          <source>An input range of random access ranges</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8adc363777a6afb1445324ba10df4840c08d231" translate="yes" xml:space="preserve">
          <source>An input range of the subranges of elements between separators. If &lt;code&gt;r&lt;/code&gt; is a &lt;a href=&quot;std_range_primitives#isForwardRange&quot;&gt;forward range&lt;/a&gt; or &lt;a href=&quot;std_range_primitives#isBidirectionalRange&quot;&gt;bidirectional range&lt;/a&gt;, the returned range will be likewise. When a range is used a separator, bidirectionality isn't possible.  If an empty range is given, the result is an empty range. If a range with one separator is given, the result is a range with two empty elements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77fcb0b8936d71a377fcbb398a2e222509a71db3" translate="yes" xml:space="preserve">
          <source>An input range representing the results of the map. This range has a length iff &lt;code&gt;source&lt;/code&gt; has a length.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3ed7a93b1ad11aa4211044600bdb3f20f6462d6" translate="yes" xml:space="preserve">
          <source>An input range that offers the elements of &lt;code&gt;inputRange&lt;/code&gt;. Regardless of whether &lt;code&gt;inputRange&lt;/code&gt; is a more powerful range (forward, bidirectional etc), the result is always an input range. Reading this causes &lt;code&gt;inputRange&lt;/code&gt; to be iterated and returns its elements in turn. In addition, the same elements will be passed to &lt;code&gt;outputRange&lt;/code&gt; or &lt;code&gt;fun&lt;/code&gt; as well.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8db0e5d660666f379e5bd5033aea5532a4a6d755" translate="yes" xml:space="preserve">
          <source>An input range, or a single element, to join the ranges on</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53e41ba736cd23d712f10ab5d4286f8a49bbcc4b" translate="yes" xml:space="preserve">
          <source>An instance of &lt;code&gt;BoyerMooreFinder&lt;/code&gt; that can be used with &lt;code&gt;find()&lt;/code&gt; to invoke the Boyer-Moore matching algorithm for finding of &lt;code&gt;needle&lt;/code&gt; in a given haystack.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="082c7f6d5b0afa12e8dd042a23683a443fd1ed5f" translate="yes" xml:space="preserve">
          <source>An instance of &lt;code&gt;RefCounted&lt;/code&gt; is a reference to a structure, which is referred to as the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81dfbeaffbeddcdca676ca9f6b1f01a2e767b7b5" translate="yes" xml:space="preserve">
          <source>An instance of Class called ClassXXXX.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df7f1cf5303035f4982248b96ae7f8dcd8dbd36d" translate="yes" xml:space="preserve">
          <source>An instance of ModuleInfo is generated into the object file for each compiled module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0af1d2f763a9f835d30a298bd5512f1a1ecb310d" translate="yes" xml:space="preserve">
          <source>An instance of Rebindable!T.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f20d76f76289925279727351d584459074c5f577" translate="yes" xml:space="preserve">
          <source>An instance of StaticClassXXXX called StaticXXXX for the static members.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7588661ba7457b5448344cfc895cdb3b665fc0e3" translate="yes" xml:space="preserve">
          <source>An instance of an interface cannot be created.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9fe6552b2cda57271319df5e41efc135feb5083" translate="yes" xml:space="preserve">
          <source>An integer literal may not exceed those values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3dd1eb0e6607d6d3937d482192de7ee283f310ab" translate="yes" xml:space="preserve">
          <source>An interface is a pointer to a pointer to a vtbl[]. The vtbl[0] entry is a pointer to the corresponding instance of the object.Interface class. The rest of the &lt;code&gt;vtbl[1..$]&lt;/code&gt; entries are pointers to the virtual functions implemented by that interface, in the order that they were declared.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f535852beda0178c415bc9fa63dbe96b52f5fffb" translate="yes" xml:space="preserve">
          <source>An interface to a pipe created by the &lt;a href=&quot;#pipe&quot;&gt;&lt;code&gt;pipe&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab4113213830fe7d72486bf84fdb4481ba6c3903" translate="yes" xml:space="preserve">
          <source>An interior pointer to the allocated memory block is sufficient to let the GC know the object is in use; i.e. it is not necessary to maintain a pointer to the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e468e9d85b8c7d660b637f4814b9ebc7dd018028" translate="yes" xml:space="preserve">
          <source>An interior pointer to the allocated memory block is sufficient to let the GC know the object is in use; i.e. it is not necessary to maintain a pointer to the beginning of the allocated memory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f380906d548143bc93c92fea41836178dba951d1" translate="yes" xml:space="preserve">
          <source>An invalid IPv4 host address.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c151927ff98085446422d3ef9db66acbb3009ff" translate="yes" xml:space="preserve">
          <source>An invalid memory operation error occurs in circumstances when the garbage collector has detected an operation it cannot reliably handle. The default D GC is not re-entrant, so this can happen due to allocations done from within finalizers called during a garbage collection cycle.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e1ca0b5740cb0c049a4626d36738a30cd09bcf8" translate="yes" xml:space="preserve">
          <source>An new array with the same element type as &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9a13417415c3a89c1b29b77e22f2e53079843b6" translate="yes" xml:space="preserve">
          <source>An object consists of:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4aafa70d4d827025493d92426cb1881df221dd19" translate="yes" xml:space="preserve">
          <source>An object describing the current calling context or null if no handler is supplied.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5be2f170166a5ab81d9f7b1c1bbe46754996b242" translate="yes" xml:space="preserve">
          <source>An object, interface, array slice type, or associative array type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46658cef8915a535dc984d5da9a05cb48f404327" translate="yes" xml:space="preserve">
          <source>An opaque type used to represent a logical thread.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac93278e9eecd73148f8d1da8ce3975a03dbd346" translate="yes" xml:space="preserve">
          <source>An operating system handle to the process.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f1bf7d22dd547a7812632d87cd15c2924db734c" translate="yes" xml:space="preserve">
          <source>An option can be bound to a function or delegate with the signature &lt;code&gt;void function()&lt;/code&gt;, &lt;code&gt;void function(string option)&lt;/code&gt;, &lt;code&gt;void function(string option, string value)&lt;/code&gt;, or their delegate equivalents.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b5227e5d32ce42de170098574202aa25566b464" translate="yes" xml:space="preserve">
          <source>An option can be marked as required. If that option is not present in the arguments an exception will be thrown.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62587f93049001b563bb61577949d667674822d9" translate="yes" xml:space="preserve">
          <source>An option to create &lt;a href=&quot;#FileLogger&quot;&gt;&lt;code&gt;FileLogger&lt;/code&gt;&lt;/a&gt; directory if it is non-existent.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64ee06f639f325adeda208d2447a973be665d9e1" translate="yes" xml:space="preserve">
          <source>An optional &lt;code&gt;header&lt;/code&gt; can be provided. The first record will be read in as the header. If &lt;code&gt;Contents&lt;/code&gt; is a struct then the header provided is expected to correspond to the fields in the struct. When &lt;code&gt;Contents&lt;/code&gt; is not a type which can contain the entire record, the &lt;code&gt;header&lt;/code&gt; must be provided in the same order as the input or an exception is thrown.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c541908f1a9f1491cf9b9d292e345a7480fb7a54" translate="yes" xml:space="preserve">
          <source>An optional destination buffer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8208436747ee5979d41650c17a37d3a20bbfe83b" translate="yes" xml:space="preserve">
          <source>An optional list of strings naming each successive field of the &lt;code&gt;Tuple&lt;/code&gt; or a list of types that the elements are being casted to. For a list of names, each name matches up with the corresponding field given by &lt;code&gt;Args&lt;/code&gt;. A name does not have to be provided for every field, but as the names must proceed in order, it is not possible to skip one field and name the next after it. For a list of types, there must be exactly as many types as parameters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="301d753d609aee359b108ee54a2daf0751f4373a" translate="yes" xml:space="preserve">
          <source>An optional suffix to be removed from the file name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bbb578323324900d1fe9af43a6b6b06a406772b4" translate="yes" xml:space="preserve">
          <source>An output range for returning the results may be provided as the last argument. If one is not provided, an array of the proper type will be allocated on the garbage collected heap. If one is provided, it must be a random access range with assignable elements, must have reference semantics with respect to assignment to its elements, and must have the same length as the input range. Writing to adjacent elements from different threads must be safe.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="481df4f9db6b7c39f75ab8b5d8402946a05557b9" translate="yes" xml:space="preserve">
          <source>An output range that discards the data it receives.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01b526186c983c89501e19ff25742faa0abd686c" translate="yes" xml:space="preserve">
          <source>An output range to write the contents to.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ec96a76a1b7b768707aea157270f72d702aae35" translate="yes" xml:space="preserve">
          <source>An uninitialized &lt;code&gt;Variant&lt;/code&gt; is used in any way except assignment and &lt;code&gt;hasValue&lt;/code&gt;;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="017d1765237968f656e289b4e56677bea3baad1b" translate="yes" xml:space="preserve">
          <source>An uninitialized value, generated from void initializers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d865e1b843ed22f5ad95224465f066dd3bf97cd" translate="yes" xml:space="preserve">
          <source>An unqualified postblit will get called even if the struct is instantiated as &lt;code&gt;immutable&lt;/code&gt; or &lt;code&gt;const&lt;/code&gt;, but the compiler issues an error if the struct is instantiated as &lt;code&gt;shared&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02377b58a34c4a8ec19952d46cd99f893c878ed8" translate="yes" xml:space="preserve">
          <source>An unrecognized command-line argument is passed, and &lt;code&gt;std.getopt.config.passThrough&lt;/code&gt; was not present.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="355743baaf25b39e6a1bf6c9a0897a53f7ca51a0" translate="yes" xml:space="preserve">
          <source>An unrecognized option such as &quot;--baz&quot; will be found untouched in &lt;code&gt;args&lt;/code&gt; after &lt;code&gt;getopt&lt;/code&gt; returns.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b75455d22427a9d7061b91a6aa632f59812aa7cb" translate="yes" xml:space="preserve">
          <source>Analogously to class templates, struct, union and interfaces can be transformed into templates by supplying a template parameter list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="381d6919b76a155cc3d0bed8744ee2e82e29874b" translate="yes" xml:space="preserve">
          <source>Analogously, &lt;code&gt;typeof(super)&lt;/code&gt; will generate the type of what &lt;code&gt;super&lt;/code&gt; would be in a non-static member function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e760dd880de0f515f576dc77edef82d0231e14ae" translate="yes" xml:space="preserve">
          <source>Ancient Greek Musical Notation</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aac24095b26055100b3e137537a2c7e0ad932e04" translate="yes" xml:space="preserve">
          <source>Ancient Greek Numbers</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3550f110a8c69b086b7eac12c46c400773c345dc" translate="yes" xml:space="preserve">
          <source>Ancient Symbols</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29bd442643bea5b50cf62a67104dd1d1aa8f0d1e" translate="yes" xml:space="preserve">
          <source>And Expressions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="955032d49b799cc6cb579cffbe0f243b5d0f3d5f" translate="yes" xml:space="preserve">
          <source>And all the summary sections will now be green.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e67c2d4e000dc2740dc758b29287dd9038d89a6b" translate="yes" xml:space="preserve">
          <source>And an example of D code providing a callback to C code:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="028627a78221787a21142d8d33379cef0d471467" translate="yes" xml:space="preserve">
          <source>AndAnd Expressions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d132739724126beb0a58639e9a6156fdf0949d66" translate="yes" xml:space="preserve">
          <source>AndAndExpression</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b25772e958c7000fd371337d6359418dab3becfa" translate="yes" xml:space="preserve">
          <source>Andrei Alexandrescu</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8086e1eeb4770ea0dab8abf60035423c0a58a5b4" translate="yes" xml:space="preserve">
          <source>Andrei Alexandrescu's article &lt;a href=&quot;http://www.informit.com/articles/printerfriendly.aspx?p=1407357&amp;amp;rll=1&quot;&gt; &lt;i&gt;On Iteration&lt;/i&gt;&lt;/a&gt; for conceptual aspect of ranges and the motivation</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1928f95c598b9e69462fcb512625cf8e28923044" translate="yes" xml:space="preserve">
          <source>Android</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b803b58141bc58845f04cfa8646ac85f1f1a979d" translate="yes" xml:space="preserve">
          <source>Anonymous Enums</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ccd2afbc983959f9583ca7f31cb4e5cf46494d9" translate="yes" xml:space="preserve">
          <source>Anonymous Functions and Anonymous Delegates</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98a2443b6da1909f7a102e64a4964e0f390eb397" translate="yes" xml:space="preserve">
          <source>Anonymous Nested Classes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46249cc944aedcf50eaf15b7e810784027798c68" translate="yes" xml:space="preserve">
          <source>Anonymous delegates can behave like arbitrary statement literals. For example, here an arbitrary statement is executed by a loop:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1acf88a52df3795f2b20ed6511eee7ceb7ec305" translate="yes" xml:space="preserve">
          <source>Another caveat of using sub-matcher is that skip is not available preciesly because sub-matcher doesn't detect all lengths.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a60f4e1a9ef014cfadbb26ea290e8c3eb775ed4" translate="yes" xml:space="preserve">
          <source>Another event handling module</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bae2455d3699406c3641a5d660465c6bf6758fc6" translate="yes" xml:space="preserve">
          <source>Another example of formatting a &lt;code&gt;struct&lt;/code&gt; with a defined &lt;code&gt;toString&lt;/code&gt;, this time using the &lt;code&gt;scope delegate&lt;/code&gt; method.  This method is now discouraged for non-virtual functions. If possible, please use the output range method instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="322444d3bb52c341f429ca0454f292dc242f315b" translate="yes" xml:space="preserve">
          <source>Any</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85e6f644dc8e5726c5821532bf00eff211afd4d4" translate="yes" xml:space="preserve">
          <source>Any &lt;a href=&quot;#LName&quot;&gt;&lt;i&gt;LName&lt;/i&gt;&lt;/a&gt; or non-basic &lt;a href=&quot;#Type&quot;&gt;&lt;i&gt;Type&lt;/i&gt;&lt;/a&gt; (i.e. any type that does not encode as a fixed one or two character sequence) that has been emitted to the mangled symbol before will not be emitted again, but is referenced by a special sequence encoding the relative position of the original occurrence in the mangled symbol name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4ebed2ed3fe69fdf17bf0f9ea8120a1a0f126ed" translate="yes" xml:space="preserve">
          <source>Any &lt;code&gt;pure&lt;/code&gt; function that is not strongly pure cannot be assumed to be memoizable, and calls to it may not be elided even if it returns &lt;code&gt;void&lt;/code&gt; (save for compiler optimizations that prove the function has no effect). Function calls may still be elided, or results be memoized, by means of traditional inlining and optimization techniques available for all functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb9050538a91f8603d45e66e05f6aeeb1d29c1a1" translate="yes" xml:space="preserve">
          <source>Any CSV input</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3dd20dd36e01004b82e2eb3d1b7678c47e9521c9" translate="yes" xml:space="preserve">
          <source>Any IPv4 host address.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8aed77784e6588d748089e680321e31de462e28c" translate="yes" xml:space="preserve">
          <source>Any IPv4 port number.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb484c1e8a46997e29e20927039aa9b377327c02" translate="yes" xml:space="preserve">
          <source>Any IPv6 host address.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94c6cca2615cd31987c71c42944c48bb96956b95" translate="yes" xml:space="preserve">
          <source>Any IPv6 port number.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e80ff69d9bdfebf77e41c7bd69caee37e4adb6e" translate="yes" xml:space="preserve">
          <source>Any Object types will be serialized in a key-sorted order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f7c1cd84505fa215ea84971d24628315cd3387b" translate="yes" xml:space="preserve">
          <source>Any Statement that fails semantic() or has a component that is an ErrorExp or a TypeError should return an ErrorStatement from semantic().</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="baa16ecc9203783f7d302f47d6c7e99ca53b7882" translate="yes" xml:space="preserve">
          <source>Any ambiguities in the grammar between</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77ecebcd0dc38ae59d287e9d6832a173b570a0a2" translate="yes" xml:space="preserve">
          <source>Any atom</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="638621cad02fb4ef96d35005061aa41c6d8d2099" translate="yes" xml:space="preserve">
          <source>Any casting of a class reference to a derived class reference is done with a runtime check to make sure it really is a downcast. &lt;code&gt;null&lt;/code&gt; is the result if it isn't.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7916c4b8de53330f21dcd29a0e59721012e5dd75" translate="yes" xml:space="preserve">
          <source>Any class invariants for base classes are applied before the class invariant for the derived class.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7e950396436ad2a46ce9aad7dec469f189171b3" translate="yes" xml:space="preserve">
          <source>Any data referenced by the const declaration cannot be changed from the const declaration, but it might be changed by other references to the same data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea9ba6b957e1ee541543e4ed84469edf4ec75cad" translate="yes" xml:space="preserve">
          <source>Any exception not handled by the joined thread.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df41046890795b4eaa63b398c58e4d9d99374a20" translate="yes" xml:space="preserve">
          <source>Any exception not handled by the joined threads.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="010d3e9dcdbd22cd7fd006df77170e4cb60a5618" translate="yes" xml:space="preserve">
          <source>Any exception not handled by this fiber if rethrow = false, null otherwise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6ba130c34ce4b05804f636f1f2f916c5937c009" translate="yes" xml:space="preserve">
          <source>Any exception not handled by this thread if rethrow = false, null otherwise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f674a6378976f81a229e3e40bb92d9695e3314fe" translate="yes" xml:space="preserve">
          <source>Any functions that execute in CTFE must also be executable at run time. The compile time evaluation of a function does the equivalent of running the function at run time. This means that the semantics of a function cannot depend on compile time values of the function. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a57e0db645362adce30e4484501c92ffe3bbf8b7" translate="yes" xml:space="preserve">
          <source>Any insertion, removal, or lookups in an associative array</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e84b6b0c57f34d7c618d447a7ab2c9f8792eac9" translate="yes" xml:space="preserve">
          <source>Any interface that derives from a C++ interface is also a C++ interface. A C++ interface differs from a D interface in that:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="440031e52a8a0c7f5013522c41d2f3dc66691e39" translate="yes" xml:space="preserve">
          <source>Any intervening finally clauses are executed, along with releasing any intervening synchronization mutexes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="752a908277ccaeb8ca9908aea34bc98614160ea6" translate="yes" xml:space="preserve">
          <source>Any intervening finally clauses are executed, and any intervening synchronization objects are released.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c58819fbd73a8c9fe0c340f0db018003ce09975" translate="yes" xml:space="preserve">
          <source>Any invariants for fields are applied before the struct invariant.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9fe95fc6eae39aaf25f84d103f3acf7d7a384fd" translate="yes" xml:space="preserve">
          <source>Any license information for copyrighted code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67b9adde439b5f8364926599d4a45d83875f65d8" translate="yes" xml:space="preserve">
          <source>Any numerical type that supports the modulo operator &lt;code&gt;%&lt;/code&gt;. If bit-shifting &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; and &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; are also supported, Stein's algorithm will be used; otherwise, Euclid's algorithm is used as a fallback.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81c3013df61cbea6a4c917b70878d87da30767d9" translate="yes" xml:space="preserve">
          <source>Any pointer may be cast to &lt;code&gt;void*&lt;/code&gt; and from &lt;code&gt;void*&lt;/code&gt; back to its original type. Casting between pointer and non-pointer types is prohibited.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5cc05a90008a92dc38ec7d27e928baccc65c4ac" translate="yes" xml:space="preserve">
          <source>Any ranges which iterate over a &lt;code&gt;NegInfInterval&lt;/code&gt; are infinite. So, the main purpose of using &lt;code&gt;NegInfInterval&lt;/code&gt; is to create an infinite range which starts at negative infinity and goes to a fixed end point. Iterate over it in reverse.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fea46f39188f37b7400472b6a7256e566f0dadfc" translate="yes" xml:space="preserve">
          <source>Any ranges which iterate over a &lt;code&gt;PosInfInterval&lt;/code&gt; are infinite. So, the main purpose of using &lt;code&gt;PosInfInterval&lt;/code&gt; is to create an infinite range which starts at a fixed point in time and goes to positive infinity.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9d9d3b6ac3e9e29441a9345be2bae022fb55442" translate="yes" xml:space="preserve">
          <source>Any sequence of character class elements implicitly forms a union.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f33c41254cc91d5ef5db3832237d967b66a6b7df" translate="yes" xml:space="preserve">
          <source>Any statement can be labeled, including empty statements, and so can serve as the target of a goto statement. Labeled statements can also serve as the target of a break or continue statement.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77bf850fc03647bf14bd010a86cea6f71dcbb566" translate="yes" xml:space="preserve">
          <source>Any type which implicitly converts to &lt;code&gt;dchar&lt;/code&gt;. In the case where it's a built-in type, or an enum of a built-in type, &lt;code&gt;Unqual!(OriginalType!C)&lt;/code&gt; is returned, whereas if it's a user-defined type, &lt;code&gt;dchar&lt;/code&gt; is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83413c5ae04e9398c07c45877def24fe2d3e627f" translate="yes" xml:space="preserve">
          <source>Any usage examples</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b0bf7c14ffa6d93dd97c17d04c8db163f500b7e" translate="yes" xml:space="preserve">
          <source>Append 'this' to the specific module members[]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6389badcbed51133ce737118947b50567eac4a2" translate="yes" xml:space="preserve">
          <source>Append &lt;a href=&quot;#Character&quot;&gt;character&lt;/a&gt;&lt;code&gt;ch&lt;/code&gt; to this grapheme.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9423c656632feb94c95542550bc5776ab847c04f" translate="yes" xml:space="preserve">
          <source>Append &lt;code&gt;e2&lt;/code&gt; to chain of exceptions that starts with &lt;code&gt;e1&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3d06094350a95ba5b433011fb835e7124c4ec5e" translate="yes" xml:space="preserve">
          <source>Append a CData item to the interior of this element</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="984824e040f0720fce2fc4f6a13d57fc728e8caa" translate="yes" xml:space="preserve">
          <source>Append a comment to the interior of this element</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db03388cd72ade8520d2e378966e698614e72a5e" translate="yes" xml:space="preserve">
          <source>Append a complete element to the interior of this element</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef21e116b7bca07b0b591badb0bc081fdcfe67e5" translate="yes" xml:space="preserve">
          <source>Append a processing instruction to the interior of this element</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="496596976c04bde5f7e7a5a8202d7b8abe85e980" translate="yes" xml:space="preserve">
          <source>Append a text item to the interior of this element</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6dd93a31eb85b0a74d513a784054a244ba3c76c" translate="yes" xml:space="preserve">
          <source>Append all &lt;a href=&quot;#Character&quot;&gt;characters&lt;/a&gt; from the input range &lt;code&gt;inp&lt;/code&gt; to this Grapheme.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34b47904d2988c2185d4a53f77f7d8e792a3291d" translate="yes" xml:space="preserve">
          <source>Append array &lt;code&gt;y&lt;/code&gt; to array &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad6cd5314f128c12adc628c28aef59e004d422e0" translate="yes" xml:space="preserve">
          <source>Append data represented by ptr[0..size]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="35f4f092745cbd38143bff7f25d5d2804e9a0623" translate="yes" xml:space="preserve">
          <source>Append data to the internal buffer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6cfc826c67159c690715f887f4b34b4df17e6673" translate="yes" xml:space="preserve">
          <source>Append dchar to char[]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6ff7bb65433411731c9ec32fd03f8c8b7ab8dbf" translate="yes" xml:space="preserve">
          <source>Append dchar to wchar[]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f099c58d9143b4e0a6f01a50957762bf07adaa8f" translate="yes" xml:space="preserve">
          <source>Append dt to data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73602dd98d646af114882b411baed4caf29ed4aa" translate="yes" xml:space="preserve">
          <source>Append dtb to data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05676aa51ec52e96deb89d7ae3b7bad0e2920095" translate="yes" xml:space="preserve">
          <source>Append instead of overwrite on upload!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="725e2673bb64dd768f5e35adc33733f051daff12" translate="yes" xml:space="preserve">
          <source>Append integer item to list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e98d78b75b667bfa9432c073969f89aad62837e" translate="yes" xml:space="preserve">
          <source>Append nbytes of 0 to the internal buffer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6100e49b257665109b21fcb575027c3b1d83fee9" translate="yes" xml:space="preserve">
          <source>Append output of C's printf() to internal buffer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f1cd15bde5d09d444835959bdf7cf1009a819c1" translate="yes" xml:space="preserve">
          <source>Append output of C's vprintf() to internal buffer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26196f1c60516e313842646d760dfe092b0b8783" translate="yes" xml:space="preserve">
          <source>Append ptr to *plist.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="379fc789872b087a61658c08353344a2820471c2" translate="yes" xml:space="preserve">
          <source>Append s to list of object files to generate later.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c74420521a423ce5daf955e234405a229d6cc0f" translate="yes" xml:space="preserve">
          <source>Append the remaining segments of &lt;code&gt;path&lt;/code&gt; to the string and return.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e7e4b12820cee8e262b36441f586183f6d04cab" translate="yes" xml:space="preserve">
          <source>Append y[] to array x[]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ef306358b052f7e64b8bcc3cd14249cef33ca02" translate="yes" xml:space="preserve">
          <source>Appender!(E[]) &lt;strong id=&quot;appender&quot;&gt;appender&lt;/strong&gt;(A : E[], E)(auto ref A array);</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e11e6991b83788f5357a19dc342f52d09507315" translate="yes" xml:space="preserve">
          <source>Appender!A &lt;strong id=&quot;appender&quot;&gt;appender&lt;/strong&gt;(A)()</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b06a35dce8dc5935a09578e40179d4dbbd0cee5e" translate="yes" xml:space="preserve">
          <source>Appending does not always create a copy, see &lt;a href=&quot;#resize&quot;&gt; setting dynamic array length&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d23d95cfc1028cebc43e6d6bc87290142bad8a2a" translate="yes" xml:space="preserve">
          <source>Appending to and direct manipulation of grapheme's &lt;a href=&quot;#Character&quot;&gt;characters&lt;/a&gt; may render it no longer valid. Certain applications may chose to use Grapheme as a &quot;small string&quot; of any &lt;a href=&quot;#Code%20point&quot;&gt;code points&lt;/a&gt; and ignore this property entirely.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27687e63c8f2765f7f45c656d25a88a2f70872d2" translate="yes" xml:space="preserve">
          <source>Appends &lt;code&gt;buffer&lt;/code&gt; to file &lt;code&gt;name&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7f62b12268c12952ecff14c3290b88618812066" translate="yes" xml:space="preserve">
          <source>Appends &lt;code&gt;item&lt;/code&gt; to the managed array. Performs encoding for &lt;code&gt;char&lt;/code&gt; types if &lt;code&gt;A&lt;/code&gt; is a differently typed &lt;code&gt;char&lt;/code&gt; array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3fa391a5e33fe2002fc2b72cecadf723ca6b30fe" translate="yes" xml:space="preserve">
          <source>Appends &lt;code&gt;rhs&lt;/code&gt; to the managed array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7623fabcaede88b964c04becc831d4ac3e3b23ce" translate="yes" xml:space="preserve">
          <source>Appends &lt;code&gt;x&lt;/code&gt; to &lt;code&gt;c&lt;/code&gt;. &lt;code&gt;x&lt;/code&gt; may be a single element or an input range type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18bc8e8710e112a386b8301eb1ea86dca70c5d37" translate="yes" xml:space="preserve">
          <source>Appends a string to a linked list. If no list exists, it will be created first. Returns the new list, after appending.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81cdccb19773651976963e90237f5de77beaf9e6" translate="yes" xml:space="preserve">
          <source>Appends an entire range to the managed array. Performs encoding for &lt;code&gt;char&lt;/code&gt; elements if &lt;code&gt;A&lt;/code&gt; is a differently typed &lt;code&gt;char&lt;/code&gt; array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1a17d68e5eb26669b8a6fd759bf09e863160e46" translate="yes" xml:space="preserve">
          <source>Appends the contents of the argument &lt;code&gt;rhs&lt;/code&gt; into &lt;code&gt;this&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20cd868cd32de230764914be80101e71a8f019d2" translate="yes" xml:space="preserve">
          <source>Appends to the managed array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="762f62942181d4b2666650e69bb8c92655c35501" translate="yes" xml:space="preserve">
          <source>AppleTalk</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82cac29a8ad5cbbc38d1a1fb84f536367b07a15f" translate="yes" xml:space="preserve">
          <source>Application Binary Interface</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c42705eec7c415a6997bd8c9d3dc65da77e4f55" translate="yes" xml:space="preserve">
          <source>Application Defined Page Cache.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1097391b6d8c24e778f4782f5e62fadaf414d9d" translate="yes" xml:space="preserve">
          <source>Applies a delegate or function to the given &lt;a href=&quot;#Algebraic&quot;&gt;&lt;code&gt;Algebraic&lt;/code&gt;&lt;/a&gt; depending on the held type, ensuring that all types are handled by the visiting functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e64c5b4326d836829a0ebf41a9e13a5e62411c7" translate="yes" xml:space="preserve">
          <source>Apply MODxxxx bits to existing type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee985a3510121398e40860de4ace149b4869d63d" translate="yes" xml:space="preserve">
          <source>Apply STCxxxx bits to existing type. Use *before* semantic analysis is run.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a27c3d86d32e5ed828ae9b07fd5ad23ae9593843" translate="yes" xml:space="preserve">
          <source>Apply a function fp to each member of a list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c98d8debd927a2a04375be8cb963231c736c4c5" translate="yes" xml:space="preserve">
          <source>Applying a qualifier to a type that already has that qualifier is legal but has no effect, e.g. given an unqualified type &lt;code&gt;T&lt;/code&gt;, &lt;code&gt;shared(const shared T)&lt;/code&gt; yields the type &lt;code&gt;const shared T&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a15b638351f6a01ae8878d2186ac098d189b867" translate="yes" xml:space="preserve">
          <source>Applying the &lt;code&gt;immutable&lt;/code&gt; qualifier to any type (qualified or not) results in &lt;code&gt;immutable T&lt;/code&gt;. Applying any qualifier to &lt;code&gt;immutable T&lt;/code&gt; results in &lt;code&gt;immutable T&lt;/code&gt;. This makes &lt;code&gt;immutable&lt;/code&gt; a fixed point of qualifier combinations and makes types such as &lt;code&gt;const(immutable(shared T))&lt;/code&gt; impossible to create.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af4f4762f9bd3f0f4a10caf5b6e63dc4ce543724" translate="yes" xml:space="preserve">
          <source>Arabic</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e35d0b2742a654477e1cd63556f021113ce5b4c" translate="yes" xml:space="preserve">
          <source>Arabic Extended-A</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2e75f0c9d3aecdda25899708775d147043e7830" translate="yes" xml:space="preserve">
          <source>Arabic Mathematical Alphabetic Symbols</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1855677dcc7468bb9c8e6a1cd81ba79444a4ff7e" translate="yes" xml:space="preserve">
          <source>Arabic Presentation Forms-A</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81d80ec90565c460cb86314a7772144c7915e63e" translate="yes" xml:space="preserve">
          <source>Arabic Presentation Forms-B</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f967001c1a34ccb5d4db68033cb95ea3afa4f067" translate="yes" xml:space="preserve">
          <source>Arabic Supplement</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f984e10440745697cc3d65ba4c39e78b962f2e10" translate="yes" xml:space="preserve">
          <source>Arbitrary block of memory (&lt;code&gt;null&lt;/code&gt; is allowed; &lt;code&gt;owns(null)&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="35ae340d74ec660428a4617d592eb281817c9ae4" translate="yes" xml:space="preserve">
          <source>Arbitrary length and complexity lookbehind, including lookahead in lookbehind and vise-versa.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b10f364535b59752b7187d9f87de14ac7b52ee5" translate="yes" xml:space="preserve">
          <source>Arbitrary-precision ('bignum') arithmetic.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9fcbd049669bd8c4ed6c2c7a64ef6513f2e0d6d" translate="yes" xml:space="preserve">
          <source>Are AMD extensions to MMX supported?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01e21616c01d0a2fca25a82b396c6f6e959a0c86" translate="yes" xml:space="preserve">
          <source>Are LAHF and SAHF supported in 64-bit mode?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a1445e9d8e93be79bf26c9c6c4caa120500ae1a" translate="yes" xml:space="preserve">
          <source>Are any of the Objects an error?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4bf0024c4bc943f998126635e2b2826496ec8582" translate="yes" xml:space="preserve">
          <source>Args</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4293e4b957c97199f617f8492936758c0b738afa" translate="yes" xml:space="preserve">
          <source>Args &lt;code&gt;args&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f5be29a09e6e60319db52d529ad7515c16471a5" translate="yes" xml:space="preserve">
          <source>Argument Deduction</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54486629b7690ae513c392c789d163e099b5b87d" translate="yes" xml:space="preserve">
          <source>Argument Type</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29654984a9e906a0a06167995d3f42a8d08cf353" translate="yes" xml:space="preserve">
          <source>Argument to xInit() and xShutdown()</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="daf86c8879ed0c69961403ceb76965c2482d6deb" translate="yes" xml:space="preserve">
          <source>ArgumentList</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8946712557cc8b1c3fb3e94fee0d0fce04b3802b" translate="yes" xml:space="preserve">
          <source>Arguments to pass to &lt;code&gt;T&lt;/code&gt;'s constructor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bfbc91d37e47f927568d7a30e3496cf96960cf08" translate="yes" xml:space="preserve">
          <source>Arguments to pass to the method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89180ef2e932b4599c798900639013ef3f341134" translate="yes" xml:space="preserve">
          <source>Arguments to the function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9630a5d15efcdc7541a36a0160b3500004aba0a" translate="yes" xml:space="preserve">
          <source>Arithmetic between &lt;code&gt;VariantN&lt;/code&gt; objects and numeric values. All arithmetic operations return a &lt;code&gt;VariantN&lt;/code&gt; object typed depending on the types of both values involved. The conversion rules mimic D's built-in rules for arithmetic conversions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a0d21145500640fd3f6136eeba595bfe934d364" translate="yes" xml:space="preserve">
          <source>Armenian</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c96bf3a668aac126792eaf02dadd14fa48e70d3" translate="yes" xml:space="preserve">
          <source>Array &lt;strong id=&quot;opBinary&quot;&gt;opBinary&lt;/strong&gt;(string op, Stuff)(Stuff stuff)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3660d1d1308b201f353bc8fa6130b29f9ba2d842" translate="yes" xml:space="preserve">
          <source>Array Bounds Checking</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f1275d2846b1606eecf7847c7e27140c6dc6c89" translate="yes" xml:space="preserve">
          <source>Array Concatenation</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d1d05717fafa53ed33983c8c412c01fb3ca32f6" translate="yes" xml:space="preserve">
          <source>Array Copying</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b0779db36c24b1c78ab44d3d32261e35d9bc05e" translate="yes" xml:space="preserve">
          <source>Array Declarations</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83248d40160f2cce014335fe1581785cb6bcecaf" translate="yes" xml:space="preserve">
          <source>Array Index/Slice scope</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b91e23ca287553cadb09bb925d112bdb13a167e" translate="yes" xml:space="preserve">
          <source>Array Indexing and Slicing Operators Overloading</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3e061b1b0837d1a9960794f282dd75e750eb332" translate="yes" xml:space="preserve">
          <source>Array Initialization</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c847e3a06bdc4135a7a456a0f00a984d2c67477" translate="yes" xml:space="preserve">
          <source>Array Length</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9f04b9d6c3b8a78da5ec9d06e0efef4332889f5" translate="yes" xml:space="preserve">
          <source>Array Literals</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7106a989ccb65a04eb4c26053be05ad2d2e071e2" translate="yes" xml:space="preserve">
          <source>Array Operations</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d517d3c8494600360cbc4c90cee07bed4ba0d68" translate="yes" xml:space="preserve">
          <source>Array Properties</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9703b944aa367c5aa673c3d017ce64794e77b9b2" translate="yes" xml:space="preserve">
          <source>Array Setting</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1aa037357a9b7f1c16ef42cc60976b8847ef657b" translate="yes" xml:space="preserve">
          <source>Array Usage</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c01b400578305839c9f204fb953e859a5125d529" translate="yes" xml:space="preserve">
          <source>Array and associative array operations. If a &lt;code&gt; VariantN&lt;/code&gt; contains an (associative) array, it can be indexed into. Otherwise, an exception is thrown.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b84dfacc31a0969124c8d1abef734c629bb90a1e" translate="yes" xml:space="preserve">
          <source>Array appending</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d76be94dc9a7b58ca84dbb5c3adb93a7d01641c" translate="yes" xml:space="preserve">
          <source>Array bound checks.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85acbf2069ff740d2820da623cb0a7f96c951889" translate="yes" xml:space="preserve">
          <source>Array bounds checks are disabled (command line switch &lt;a href=&quot;https://dlang.org/dmd.html#switch-boundscheck&quot;&gt;&lt;em&gt;-boundscheck=off&lt;/em&gt;&lt;/a&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9495b0030caddeaddd3d77aa9749a4ea64f6f7d" translate="yes" xml:space="preserve">
          <source>Array bounds checks are necessary to enforce memory safety, so these are enabled (by default) for &lt;code&gt;@safe&lt;/code&gt; code even in &lt;b&gt;-release&lt;/b&gt; mode.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cea52181688b642f5fdfd14c038de482c009d5f6" translate="yes" xml:space="preserve">
          <source>Array concatenation</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57ff9464bbbd1fa1767e470a5012532b91719c42" translate="yes" xml:space="preserve">
          <source>Array container for internal usage.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65a0b8da864827cd0478aba1fdf30610a77c4fd1" translate="yes" xml:space="preserve">
          <source>Array containing arrays that will be concatenated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67d3696aeb8ef015e2952b35a392df743f65e443" translate="yes" xml:space="preserve">
          <source>Array literal is going to be allocated on the GC heap. Check its elements to see if any would escape by going on the heap.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="014dbf281d4d372cf828b4f858f7eb383406da80" translate="yes" xml:space="preserve">
          <source>Array literals (except when used to initialize static data)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6a7d7c506c31a93cc6747b37be514d93fad8773" translate="yes" xml:space="preserve">
          <source>Array literals are a comma-separated list of &lt;a href=&quot;#AssignExpression&quot;&gt;&lt;i&gt;AssignExpression&lt;/i&gt;&lt;/a&gt;s between square brackets &lt;code&gt;[&lt;/code&gt; and &lt;code&gt;]&lt;/code&gt;. The</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dae2c2b63d025ee4c0832bb31c33f2a5fbf34690" translate="yes" xml:space="preserve">
          <source>Array literals are allocated on the memory managed heap. Thus, they can be returned safely from functions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e69b9d12c30731402c84433338297ab2257d2102" translate="yes" xml:space="preserve">
          <source>Array of VarDeclaration's for parameters</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d9eb8f765adfc90b02ec28ca02924204c83af1e" translate="yes" xml:space="preserve">
          <source>Array of characters read.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a234f4c4feb75a8aa7b93d09c3a8859c0ea7eb5" translate="yes" xml:space="preserve">
          <source>Array of pairs giving the offset and type information for each member in an aggregate.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3cc66155c78e1b4720002ac02361e391e42c1fdd" translate="yes" xml:space="preserve">
          <source>Array of the strings representing time units, starting with the smallest unit and going to the largest. It does not include &lt;code&gt;&quot;nsecs&quot;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c26e25fdec1370d18f0c93ee54cfd77f08bc7279" translate="yes" xml:space="preserve">
          <source>Array options.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82ee133059983d2093ca847eb799753d9f96eeef" translate="yes" xml:space="preserve">
          <source>Array slicing, and array bounds checking</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f187d73020c36a9ee259d3863cac2e2a8546f9fe" translate="yes" xml:space="preserve">
          <source>Array specialized for &lt;code&gt;bool&lt;/code&gt;. Packs together values efficiently by allocating one bit per element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5058965ad79b9992b8f00aae6b40d9b43a8d0f10" translate="yes" xml:space="preserve">
          <source>Array syntax for json arrays.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5973135baae02b17a741da0daeae795a22336d6f" translate="yes" xml:space="preserve">
          <source>Array to append the flags to, if any.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d290f86768d5ed39f7a46e3545ef125df15763f2" translate="yes" xml:space="preserve">
          <source>Array to which binaries (shared/static libs and object files) will be appended</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c59fb5bcd382383b02c6f2e682a6e49d5169c774" translate="yes" xml:space="preserve">
          <source>Array type with deterministic control of memory. The memory allocated for the array is reclaimed as soon as possible; there is no reliance on the garbage collector. &lt;code&gt;Array&lt;/code&gt; uses &lt;code&gt;malloc&lt;/code&gt;, &lt;code&gt;realloc&lt;/code&gt; and &lt;code&gt;free&lt;/code&gt; for managing its own memory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17f3d834c909f91543323d2da6d7e392df7fc04d" translate="yes" xml:space="preserve">
          <source>Array utilities.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8d1c5f297e5b542d7b3b426ee67519393b84051" translate="yes" xml:space="preserve">
          <source>Array with one &lt;code&gt;Address&lt;/code&gt; instance per socket address.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b02c75e5cfd1dbb8861cc9d33aefc7788debf27" translate="yes" xml:space="preserve">
          <source>Array with one &lt;code&gt;AddressInfo&lt;/code&gt; per socket address.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ccb9694106595867500e36f178956e556d5f06d5" translate="yes" xml:space="preserve">
          <source>Array!T &lt;code&gt;array&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59ed81f06d61cee7ac46ef81d4494047f843a918" translate="yes" xml:space="preserve">
          <source>Array!bool &lt;strong id=&quot;opBinary&quot;&gt;opBinary&lt;/strong&gt;(string op, Stuff)(Stuff rhs)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f58b7e3beff7cb376f330022b72abdbf5e8d71a8" translate="yes" xml:space="preserve">
          <source>Array!bool &lt;strong id=&quot;opOpAssign&quot;&gt;opOpAssign&lt;/strong&gt;(string op, Stuff)(Stuff stuff)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb8a70fa9de0823f16fd95fb5d95b4122c80f726" translate="yes" xml:space="preserve">
          <source>ArrayInitializer &lt;code&gt;ai&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dcde65a6ef36678480c533ad205a2b3653940979" translate="yes" xml:space="preserve">
          <source>ArrayLiteralExp &lt;code&gt;ae&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49604b859f9dbf7987784da7c49e4b4f67d157a7" translate="yes" xml:space="preserve">
          <source>ArrayLiteralExp &lt;strong id=&quot;createBlockDuplicatedArrayLiteral&quot;&gt;createBlockDuplicatedArrayLiteral&lt;/strong&gt;(UnionExp* pue, ref const Loc loc, Type type, Expression elem, size_t dim);</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b90cc9bfd23567a2ff5ba1f00e7c63ca6da8755e" translate="yes" xml:space="preserve">
          <source>Arrays</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ec121f807ed23a3ee478e2902d2a39d93f6938e" translate="yes" xml:space="preserve">
          <source>Arrays (dynamic and static)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dad86d2f90fcf8d8a3cdfa4cf789d731af0dd940" translate="yes" xml:space="preserve">
          <source>Arrays and static arrays</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f1d0899c823da5c8626a1dbb08800ddf6eec849" translate="yes" xml:space="preserve">
          <source>Arrays of any type can be implicitly converted to a void array; the compiler inserts the appropriate calculations so that the &lt;code&gt;.length&lt;/code&gt; of the resulting array's size is in bytes rather than number of elements. Void arrays cannot be converted back to the original type without using a cast, and it is an error to convert to an array type whose element size does not evenly divide the length of the void array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d07335e1b59b41b81acffb9c1b5c94e2033e5ab4" translate="yes" xml:space="preserve">
          <source>Arrays read right to left as well:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0cf604cb001bdc6112fda3affb0c7674d1c4481b" translate="yes" xml:space="preserve">
          <source>Arrows</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ebe044f5962ca7b8d7aab096e7aee2bc2b61b686" translate="yes" xml:space="preserve">
          <source>As &lt;code&gt;static foreach&lt;/code&gt; is a code generation construct and not a loop, &lt;code&gt;break&lt;/code&gt; and &lt;code&gt;continue&lt;/code&gt; cannot be used to change control flow within it. Instead of breaking or continuing a suitable enclosing statement, such an usage yields an error (this is to prevent misunderstandings).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d13756a62d354c00bff64fd46fa593358676140" translate="yes" xml:space="preserve">
          <source>As a concession to practicality, a pure function can also:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8bc155ad0d18590ebe40ebe2b93eb23941ceadd8" translate="yes" xml:space="preserve">
          <source>As a contract, an &lt;code&gt;assert&lt;/code&gt; represents a guarantee that the code</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bccab5f9b93fd641ceebcd69566613681ff777b0" translate="yes" xml:space="preserve">
          <source>As a debugging aid, the compiler may insert a runtime check to verify that the expression is indeed true. If it is false, an &lt;code&gt;AssertError&lt;/code&gt; is thrown. When compiling for release, this check is not generated. The special &lt;code&gt;assert(0)&lt;/code&gt; expression, however, is generated even in release mode. See the &lt;a href=&quot;expression#AssertExpression&quot;&gt;&lt;i&gt;AssertExpression&lt;/i&gt;&lt;/a&gt; documentation for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90a896ea477e7a62fdbd266c90ef3478e166538a" translate="yes" xml:space="preserve">
          <source>As a micro-optimization, to avoid the heap allocation associated with &lt;code&gt;task&lt;/code&gt; or with the creation of a closure.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="842753f613e1812047f79b9da908210026f9a41f" translate="yes" xml:space="preserve">
          <source>As above, but also provides &lt;code&gt;back&lt;/code&gt; and &lt;code&gt;popBack&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a95b268782f9af6c10edd99d4e3bb5baafff0eb" translate="yes" xml:space="preserve">
          <source>As above, but may be reallocated later. Examples of types fitting this description are &lt;code&gt;int[]&lt;/code&gt;, &lt;code&gt;double[]&lt;/code&gt;, &lt;code&gt;Tuple!(int, long)[]&lt;/code&gt;, but not &lt;code&gt;Tuple!(int, string)[]&lt;/code&gt;, which contains an indirection.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ada3120f9cc1043d7b4f9c611d3e84f82bcb254e" translate="yes" xml:space="preserve">
          <source>As above, but may embed indirections. Examples of types fitting this description are &lt;code&gt;int*[]&lt;/code&gt;, &lt;code&gt;Object[]&lt;/code&gt;, &lt;code&gt;Tuple!(int, string)[]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1700838138f9af03c11ccaa20b548dd32d2a5c61" translate="yes" xml:space="preserve">
          <source>As above, but the memory allocated is aligned at &lt;code&gt;a&lt;/code&gt; bytes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a7b2b5d58503b9d84dce03ccae75f857fd6475e" translate="yes" xml:space="preserve">
          <source>As above, but the type may be appended to in the future. Example: &lt;code&gt;string&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67b44aad993023067b75a99b577d6a3bad9df809" translate="yes" xml:space="preserve">
          <source>As above, but the type may embed references. Example: &lt;code&gt;immutable(Object)[]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0ab111de9460a5c459418af453cc0583e8938ad" translate="yes" xml:space="preserve">
          <source>As an exception to the above, curl_off_t shall be typedef'ed to a 32-bit wide signed integral data type if there is no 64-bit type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00c376f2504564e95535f66220527b7aef723e32" translate="yes" xml:space="preserve">
          <source>As copying the range means copying all elements, it can be safely returned from functions. For the same reason, copying the returned range may be expensive for a large number of arguments.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86ffd7c99fd994cc802f084df86d92e7d718ebb0" translate="yes" xml:space="preserve">
          <source>As long as the target range elements support assignment from source range elements, different types of ranges are accepted:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89f24648855e3c77be3def51419022b8377886d0" translate="yes" xml:space="preserve">
          <source>As of this time, &lt;code&gt;std.experimental.allocator&lt;/code&gt; is not integrated with D's built-in operators that allocate memory, such as &lt;code&gt;new&lt;/code&gt;, array literals, or array concatenation operators. That means &lt;code&gt;std.experimental.allocator&lt;/code&gt; is opt-in</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="102c86647896232382d7c6363a032a8965f35f84" translate="yes" xml:space="preserve">
          <source>As the above example shows, a different compile-time argument is passed to &lt;code&gt;opDollar&lt;/code&gt; depending on which argument it appears in. A &lt;code&gt;$&lt;/code&gt; appearing in the first argument gets translated to &lt;code&gt;opDollar!0&lt;/code&gt;, a &lt;code&gt;$&lt;/code&gt; appearing in the second argument gets translated to &lt;code&gt;opDollar!1&lt;/code&gt;, and so on. Thus, the appropriate value for &lt;code&gt;$&lt;/code&gt; can be returned to implement multidimensional arrays.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f1f55e4d756cae86481e151850fb4d8b6d4d597" translate="yes" xml:space="preserve">
          <source>As the interval goes to negative infinity, the range is always iterated over backwards, never forwards. &lt;code&gt;func&lt;/code&gt; must generate a time point going in the proper direction of iteration, or a &lt;a href=&quot;std_datetime_date#DateTimeException&quot;&gt;&lt;code&gt;std.datetime.date.DateTimeException&lt;/code&gt;&lt;/a&gt; will be thrown. So, the time points that &lt;code&gt;func&lt;/code&gt; generates must be earlier in time than the one passed to it. If it's either identical or later in time, then a &lt;a href=&quot;std_datetime_date#DateTimeException&quot;&gt;&lt;code&gt;std.datetime.date.DateTimeException&lt;/code&gt;&lt;/a&gt; will be thrown.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19397d297232fda90f291340ee30b5e3c1ea48c9" translate="yes" xml:space="preserve">
          <source>As the interval goes to positive infinity, the range is always iterated over forwards, never backwards. &lt;code&gt;func&lt;/code&gt; must generate a time point going in the proper direction of iteration, or a &lt;a href=&quot;std_datetime_date#DateTimeException&quot;&gt;&lt;code&gt;std.datetime.date.DateTimeException&lt;/code&gt;&lt;/a&gt; will be thrown. So, the time points that &lt;code&gt;func&lt;/code&gt; generates must be later in time than the one passed to it. If it's either identical or earlier in time, then a &lt;a href=&quot;std_datetime_date#DateTimeException&quot;&gt;&lt;code&gt;std.datetime.date.DateTimeException&lt;/code&gt;&lt;/a&gt; will be thrown.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85319de6635b6d77d85a430a22ed2839720cedf1" translate="yes" xml:space="preserve">
          <source>As we generate code, collect information about what parts of NT exception handling we need.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51268903c8fb9b838b2eb55d7979a33593c37355" translate="yes" xml:space="preserve">
          <source>As with &lt;a href=&quot;#lists&quot;&gt;lists&lt;/a&gt;, note that the initial &lt;code&gt;*&lt;/code&gt; in the example above will be stripped because it is part of a documentation comment that is delimited with asterisks, so you need at least three subsequent asterisks.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac7e95e21d2700c2e5e4f32e9e7f466df23faf33" translate="yes" xml:space="preserve">
          <source>As with &lt;a href=&quot;#replaceAll&quot;&gt;&lt;code&gt;replaceAll&lt;/code&gt;&lt;/a&gt; there are 2 overloads - one with a format string, the other one with a user defined functor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4799d67b11d550709cf6847100b2162c1067dd7e" translate="yes" xml:space="preserve">
          <source>As with any global resource, setting &lt;code&gt;theAllocator&lt;/code&gt; and &lt;code&gt;processAllocator&lt;/code&gt; should not be done often and casually. In particular, allocating memory with one allocator and deallocating with another causes undefined behavior. Typically, these variables are set during application initialization phase and last through the application.  To avoid this, long-lived objects that need to perform allocations, reallocations, and deallocations relatively often may want to store a reference to the allocator object they use throughout their lifetime. Then, instead of using &lt;code&gt;theAllocator&lt;/code&gt; for internal allocation-related tasks, they'd use the internally held reference. For example, consider a user-defined hash table:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a187fce74f3c088795c6e5b47e1056e5126c0fae" translate="yes" xml:space="preserve">
          <source>Ask curl for its fd_set sets. The app can use these to select() or poll() on. We want curl_multi_perform() called as soon as one of them are ready.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="407c3cb45f2c60add113bb40a5a457b3e7b28548" translate="yes" xml:space="preserve">
          <source>Ask the multi handle if there's any messages/informationals from the individual transfers. Messages include informationals such as error code from the transfer or just the fact that a transfer is completed. More details on these should be written down as well.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00a0f49dff6a5c0c910755166ec70967a98d46e8" translate="yes" xml:space="preserve">
          <source>Asm Statement</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1afc7a2cc88dee030813b66323a3af633b890e22" translate="yes" xml:space="preserve">
          <source>Asm instruction</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="790208a1b6c1cdd2c13b57adc90b509e7d203c6c" translate="yes" xml:space="preserve">
          <source>Asm instructions are terminated by a ;, not by an end of line.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a7e3825909e47cd662a1349cd9c1f9bb88f142c" translate="yes" xml:space="preserve">
          <source>Asm statement</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90e6cfa22a58ec4314abe99303529bc30df1cd45" translate="yes" xml:space="preserve">
          <source>AsmStatement</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c9be4e0207ca69f4c35ec2cd41e7f07aef7a2ef" translate="yes" xml:space="preserve">
          <source>Assemble &lt;code&gt;values&lt;/code&gt; into a range that carries all its elements in-situ.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c617a006ef306c30de2e4c3a12d2334fbba7a9af" translate="yes" xml:space="preserve">
          <source>Assembler instructions can be labeled just like other statements. They can be the target of goto statements. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e421bc1f45d2b482fe2ff716000545e5646f7277" translate="yes" xml:space="preserve">
          <source>Assembler instructions must be located inside an &lt;code&gt;asm&lt;/code&gt; block. Like functions, &lt;code&gt;asm&lt;/code&gt; statements must be anotated with adequate function attributes to be compatible with the caller. Asm statements attributes must be explicitly defined, they are not infered.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="714e45eb8c405fbdb34a796120ab67c6ae2d72b9" translate="yes" xml:space="preserve">
          <source>Assembling Your Own Allocator</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b52465945f6ab45ca943fa9fa1e9d738eca2cc3b" translate="yes" xml:space="preserve">
          <source>Assert Contract</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="881c910749065a58abd709f4221af38a82fabadc" translate="yes" xml:space="preserve">
          <source>Assert Expressions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7a5b9464524d049c6fe8ff66c5b2bdc7b543fff" translate="yes" xml:space="preserve">
          <source>Assert Failure</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7d72241e6b5848e305187f74df13930409f541f" translate="yes" xml:space="preserve">
          <source>Assert checks.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="843aa1baaf4b9511699ef763eb98fe79f5099f70" translate="yes" xml:space="preserve">
          <source>Assert failure functions in the GLIBC library.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94e6ce29a6460dbe0c0daaaab648acdb3c2883d7" translate="yes" xml:space="preserve">
          <source>AssertExpression</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a422512dc44cc15063776e77a81a3f8e6eb0d6de" translate="yes" xml:space="preserve">
          <source>AssertExpressions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49bf55dc112eb3597726ba8ecf785a4fae4cbce0" translate="yes" xml:space="preserve">
          <source>Assertions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f19e0385b8f9d7c5a7eb86bb2c7ba5f0e720900" translate="yes" xml:space="preserve">
          <source>Asserts that the given condition is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="120daecc558f73b157187685546d1c314c351c50" translate="yes" xml:space="preserve">
          <source>Asserts that the given expression does</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bba2525f9e139559b132642a96447978bab43209" translate="yes" xml:space="preserve">
          <source>Asserts that the given expression throws the given type of &lt;code&gt;Throwable&lt;/code&gt;. The &lt;code&gt;Throwable&lt;/code&gt; is caught and does not escape assertThrown. However, any other &lt;code&gt;Throwable&lt;/code&gt;s</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17e81c7a1f671e7e24608f38c1a74f6ff4e02c7b" translate="yes" xml:space="preserve">
          <source>Assign Expressions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f86ed464704ba1c6b681ec2726c5fbeefb20008" translate="yes" xml:space="preserve">
          <source>Assign a value to the current thread's instance. This function has the same caveats as its overload.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76d3ba357057c554bcbcf6a7822d736c1e09e3bc" translate="yes" xml:space="preserve">
          <source>AssignExpression</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="365e967e191a82b0dfa667724d9ef332e0565a97" translate="yes" xml:space="preserve">
          <source>Assigned to each element of range</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2490af57d4237289ce473c7f9d5d5a7e29bbba7a" translate="yes" xml:space="preserve">
          <source>Assignment Operator Expressions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eda4293e36885d0479c5dae22502b3085be9643a" translate="yes" xml:space="preserve">
          <source>Assignment Operator Overloading</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3bf524ec3b928fa7a8316d5c4f46f6427bafeb2e" translate="yes" xml:space="preserve">
          <source>Assignment from another &lt;code&gt;Tuple&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad22a9ad0d4f785e89bbd9df67b80efd310fb186" translate="yes" xml:space="preserve">
          <source>Assignment from another BigInt.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c734c417d0433b21b0c33224a47f994821944ee9" translate="yes" xml:space="preserve">
          <source>Assignment from built-in integer types.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2c6b545c0015432c32a5f8afe451255b5b743ef" translate="yes" xml:space="preserve">
          <source>Assignment helper functions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84aa2531d79787134c4a3ba8faa799337584a358" translate="yes" xml:space="preserve">
          <source>Assignment operator. Has the same constraints as the constructor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa098245c1ec6b3b4a9cec4ec49f68bc2b3dc905" translate="yes" xml:space="preserve">
          <source>Assignment operators</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99b05821addb139efb582d5733eb165057e45a88" translate="yes" xml:space="preserve">
          <source>Assignment to &lt;code&gt;super&lt;/code&gt; is not allowed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d46d956c7065444efb33c5f5602fe16eab572e8a" translate="yes" xml:space="preserve">
          <source>Assignment to &lt;code&gt;this&lt;/code&gt; is not allowed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac9f4d1b12010a7c21b70ea99324f1a0dd8bcccd" translate="yes" xml:space="preserve">
          <source>Assigns &lt;code&gt;v&lt;/code&gt; to the first element of the container.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="922d6285649b37db600cf15c96dc723863c5afe5" translate="yes" xml:space="preserve">
          <source>Assigns &lt;code&gt;v&lt;/code&gt; to the last element of the container.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9af0d121c1f00202f8eb1627dd5494f59fbf6800" translate="yes" xml:space="preserve">
          <source>Assigns &lt;code&gt;value&lt;/code&gt; to each element of input range &lt;code&gt;range&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5f7c4ee9f81cf1e0b7f9cbc458913458f588507" translate="yes" xml:space="preserve">
          <source>Assigns &lt;code&gt;value&lt;/code&gt; to the internally-held state.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21c3bd56c75643c04bab89ad011aec98a36c3a16" translate="yes" xml:space="preserve">
          <source>Assigns &lt;code&gt;value&lt;/code&gt; to the internally-held state. If the assignment succeeds, &lt;code&gt;this&lt;/code&gt; becomes non-null.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d0fc7c17a3a2b5f1514756ed138007924a3a66a" translate="yes" xml:space="preserve">
          <source>Assigns &lt;code&gt;value&lt;/code&gt; to the internally-held state. If the assignment succeeds, &lt;code&gt;this&lt;/code&gt; becomes non-null. No null checks are made. Note that the assignment may leave &lt;code&gt;this&lt;/code&gt; in the null state.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b359bc586830b69163a1e75c910372bb60f5dad" translate="yes" xml:space="preserve">
          <source>Assigns a &lt;code&gt;VariantN&lt;/code&gt; from a generic argument. Statically rejects disallowed types.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44eb8314103f2fdd05abf9443854b7e8c14d4780" translate="yes" xml:space="preserve">
          <source>Assigns a file to another. The target of the assignment gets detached from whatever file it was attached to, and attaches itself to the new file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="057b5aa3c0ad5c43ab19d19f8ce9f6db63dca13d" translate="yes" xml:space="preserve">
          <source>Assigns a logical thread to execute the supplied op.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5425da91b2931a4dd8cdec7b13e0afa9866f1762" translate="yes" xml:space="preserve">
          <source>Assigns the given &lt;code&gt;value&lt;/code&gt; to the environment variable with the given &lt;code&gt;name&lt;/code&gt;. If &lt;code&gt;value&lt;/code&gt; is null the variable is removed from environment.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6b3ed4789854a21da3d57b64bb5165df47849f8" translate="yes" xml:space="preserve">
          <source>Assigns to the &lt;code&gt;n&lt;/code&gt;th element in the composite range. Defined if all ranges offer random access.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a41d06f6960668b2b925acd3bf255f8df4491e62" translate="yes" xml:space="preserve">
          <source>AssocArrayLiteral</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a9bcf3e687e72baa7a855ea1562aeb0b0f6c922" translate="yes" xml:space="preserve">
          <source>AssocArrayLiteralExp &lt;code&gt;ae&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47c12f36c1b476d37e1b0680000a7ced07747bab" translate="yes" xml:space="preserve">
          <source>Associate a local address with this socket.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6fdc76eca25e9805145ab4faa10fd711ec8e7f73" translate="yes" xml:space="preserve">
          <source>Associates name with tid in a process-local map. When the thread represented by tid terminates, any names associated with it will be automatically unregistered.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d00bb7dcc304b2d3b149b7f7680cc932d7d86d19" translate="yes" xml:space="preserve">
          <source>Associates name with tid.</source>
          <target state="new"/>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
