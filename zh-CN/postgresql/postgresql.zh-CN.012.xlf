<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="postgresql">
    <body>
      <group id="postgresql">
        <trans-unit id="d39ed9f52193cbb9703d5a56c5956b148e841314" translate="yes" xml:space="preserve">
          <source>On Linux 2.6 and later, it is possible to modify the kernel's behavior so that it will not &amp;ldquo;overcommit&amp;rdquo; memory. Although this setting will not prevent the &lt;a href=&quot;https://lwn.net/Articles/104179/&quot;&gt;OOM killer&lt;/a&gt; from being invoked altogether, it will lower the chances significantly and will therefore lead to more robust system behavior. This is done by selecting strict overcommit mode via &lt;code&gt;sysctl&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="501ddfe2d2530fe9fcac7688b14da5778270cdb1" translate="yes" xml:space="preserve">
          <source>On Linux &lt;code&gt;/proc/sys/fs/file-max&lt;/code&gt; determines the maximum number of open files that the kernel will support. It can be changed by writing a different number into the file or by adding an assignment in &lt;code&gt;/etc/sysctl.conf&lt;/code&gt;. The maximum limit of files per process is fixed at the time the kernel is compiled; see &lt;code&gt;/usr/src/linux/Documentation/proc.txt&lt;/code&gt; for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f009fe3fb04da9e8adcc93565c99cbfd73e2affe" translate="yes" xml:space="preserve">
          <source>On Linux and POSIX platforms &lt;a href=&quot;runtime-config-wal#GUC-CHECKPOINT-FLUSH-AFTER&quot;&gt;checkpoint_flush_after&lt;/a&gt; allows to force the OS that pages written by the checkpoint should be flushed to disk after a configurable number of bytes. Otherwise, these pages may be kept in the OS's page cache, inducing a stall when &lt;code&gt;fsync&lt;/code&gt; is issued at the end of a checkpoint. This setting will often help to reduce transaction latency, but it also can have an adverse effect on performance; particularly for workloads that are bigger than &lt;a href=&quot;runtime-config-resource#GUC-SHARED-BUFFERS&quot;&gt;shared_buffers&lt;/a&gt;, but smaller than the OS's page cache.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c936f58f7f62e48372e8a8076ff322928b68bb04" translate="yes" xml:space="preserve">
          <source>On Linux or Unix systems, you might use:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f7c8c1bd4d71387a1210efd816cb3bef4ae3f74" translate="yes" xml:space="preserve">
          <source>On Linux systems either add</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc805fd8588880f607d3f4520d6ee5e450aee68a" translate="yes" xml:space="preserve">
          <source>On Linux, IDE and SATA drives can be queried using &lt;code&gt;hdparm -I&lt;/code&gt;; write caching is enabled if there is a &lt;code&gt;*&lt;/code&gt; next to &lt;code&gt;Write cache&lt;/code&gt;. &lt;code&gt;hdparm -W 0&lt;/code&gt; can be used to turn off write caching. SCSI drives can be queried using &lt;a href=&quot;http://sg.danny.cz/sg/sdparm.html&quot;&gt;sdparm&lt;/a&gt;. Use &lt;code&gt;sdparm --get=WCE&lt;/code&gt; to check whether the write cache is enabled and &lt;code&gt;sdparm --clear=WCE&lt;/code&gt; to disable it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55da6c1d848d4260b86ebf92495a2847786e7138" translate="yes" xml:space="preserve">
          <source>On Microsoft Windows, also:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3630213a83c6eeeff64f72e78908e323507bf7bd" translate="yes" xml:space="preserve">
          <source>On NetBSD, use either the FreeBSD or Linux start scripts, depending on preference.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba742d094af1abbc78f9a3859fd3be730c7188af" translate="yes" xml:space="preserve">
          <source>On OpenBSD, add the following lines to the file &lt;code&gt;/etc/rc.local&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c2c1726b1c50e52c768b284b11ed29bfb8afb96" translate="yes" xml:space="preserve">
          <source>On Solaris, create a file called &lt;code&gt;/etc/init.d/postgresql&lt;/code&gt; that contains the following line:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2bb8949d83fc7ef1475b557895bfe563a925aea9" translate="yes" xml:space="preserve">
          <source>On Solaris, the disk write cache is controlled by &lt;code&gt;format -e&lt;/code&gt;. (The Solaris ZFS file system is safe with disk write-cache enabled because it issues its own disk cache flush commands.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d85af98780490009a295939145f84e031804f11c" translate="yes" xml:space="preserve">
          <source>On Unix systems this parameter reports the permissions of the data directory defined by (&lt;a href=&quot;runtime-config-file-locations#GUC-DATA-DIRECTORY&quot;&gt;data_directory&lt;/a&gt;) at startup. (On Microsoft Windows this parameter will always display &lt;code&gt;0700&lt;/code&gt;). See &lt;a href=&quot;app-initdb#APP-INITDB-ALLOW-GROUP-ACCESS&quot;&gt;group access&lt;/a&gt; for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d93a70eed193dd90ef032ea7d63d19a6516eb0a" translate="yes" xml:space="preserve">
          <source>On Unix systems this parameter sets the permissions for log files when &lt;code&gt;logging_collector&lt;/code&gt; is enabled. (On Microsoft Windows this parameter is ignored.) The parameter value is expected to be a numeric mode specified in the format accepted by the &lt;code&gt;chmod&lt;/code&gt; and &lt;code&gt;umask&lt;/code&gt; system calls. (To use the customary octal format the number must start with a &lt;code&gt;0&lt;/code&gt; (zero).)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aec768083a143a16efefa19e77bcef93265299f5" translate="yes" xml:space="preserve">
          <source>On Unix systems, the permissions on &lt;code&gt;server.key&lt;/code&gt; must disallow any access to world or group; achieve this by the command &lt;code&gt;chmod 0600 server.key&lt;/code&gt;. Alternatively, the file can be owned by root and have group read access (that is, &lt;code&gt;0640&lt;/code&gt; permissions). That setup is intended for installations where certificate and key files are managed by the operating system. The user under which the PostgreSQL server runs should then be made a member of the group that has access to those certificate and key files.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0de69e7d7ec6add644868e783650d15d55a6f2e" translate="yes" xml:space="preserve">
          <source>On Windows hosts, preloading a library at server start will not reduce the time required to start each new server process; each server process will re-load all preload libraries. However, &lt;code&gt;shared_preload_libraries&lt;/code&gt; is still useful on Windows hosts for libraries that need to perform operations at postmaster start time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08c92789aa023ae69cee69a7db7a2ae77f278c4c" translate="yes" xml:space="preserve">
          <source>On Windows, if &lt;code&gt;wal_sync_method&lt;/code&gt; is &lt;code&gt;open_datasync&lt;/code&gt; (the default), write caching can be disabled by unchecking &lt;code&gt;My Computer\Open\disk drive\Properties\Hardware\Properties\Policies\Enable write caching on the disk&lt;/code&gt;. Alternatively, set &lt;code&gt;wal_sync_method&lt;/code&gt; to &lt;code&gt;fsync&lt;/code&gt; or &lt;code&gt;fsync_writethrough&lt;/code&gt;, which prevent write caching.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81eec3e42d4f18ead15b1e929550fb213358fb1f" translate="yes" xml:space="preserve">
          <source>On Windows, setting a value of 0 will set this parameter to 1 second, since Windows does not provide a way to read the system default value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53478c470af75305cb8745b03e7cb49bde700061" translate="yes" xml:space="preserve">
          <source>On Windows, setting a value of 0 will set this parameter to 2 hours, since Windows does not provide a way to read the system default value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0312ea0b4215b07b7b0ad5539831203f3c1aa4d" translate="yes" xml:space="preserve">
          <source>On Windows, when you use the &lt;code&gt;eventlog&lt;/code&gt; option for &lt;code&gt;log_destination&lt;/code&gt;, you should register an event source and its library with the operating system so that the Windows Event Viewer can display event log messages cleanly. See &lt;a href=&quot;event-log-registration&quot;&gt;Section 18.12&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5ae51b938e943ee6107b7e5c25bdb8c42c5ee40" translate="yes" xml:space="preserve">
          <source>On a hot standby, the status of the WAL receiver process can be retrieved via the &lt;a href=&quot;monitoring-stats#PG-STAT-WAL-RECEIVER-VIEW&quot;&gt;pg_stat_wal_receiver&lt;/a&gt; view. A large difference between &lt;code&gt;pg_last_wal_replay_lsn&lt;/code&gt; and the view's &lt;code&gt;received_lsn&lt;/code&gt; indicates that WAL is being received faster than it can be replayed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a87ef11e5bf076fa4c6ca218448b2458c3ebe4c9" translate="yes" xml:space="preserve">
          <source>On all currently supported platforms, the &lt;code&gt;real&lt;/code&gt; type has a range of around 1E-37 to 1E+37 with a precision of at least 6 decimal digits. The &lt;code&gt;double precision&lt;/code&gt; type has a range of around 1E-307 to 1E+308 with a precision of at least 15 digits. Values that are too large or too small will cause an error. Rounding might take place if the precision of an input number is too high. Numbers too close to zero that are not representable as distinct from zero will cause an underflow error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc9f60ea02e43afcbb3f8733c606556d9627a339" translate="yes" xml:space="preserve">
          <source>On all platforms, the collations named &lt;code&gt;default&lt;/code&gt;, &lt;code&gt;C&lt;/code&gt;, and &lt;code&gt;POSIX&lt;/code&gt; are available. Additional collations may be available depending on operating system support. The &lt;code&gt;default&lt;/code&gt; collation selects the &lt;code&gt;LC_COLLATE&lt;/code&gt; and &lt;code&gt;LC_CTYPE&lt;/code&gt; values specified at database creation time. The &lt;code&gt;C&lt;/code&gt; and &lt;code&gt;POSIX&lt;/code&gt; collations both specify &amp;ldquo;traditional C&amp;rdquo; behavior, in which only the ASCII letters &amp;ldquo;&lt;code&gt;A&lt;/code&gt;&amp;rdquo; through &amp;ldquo;&lt;code&gt;Z&lt;/code&gt;&amp;rdquo; are treated as letters, and sorting is done strictly by character code byte values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c0634f5bf5f884787664141e116cb74ad234b48" translate="yes" xml:space="preserve">
          <source>On error, the server can abort the authentication at any stage, and send an ErrorMessage.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5350086780663aaf1bd7a44ba47818175298a073" translate="yes" xml:space="preserve">
          <source>On macOS, write caching can be prevented by setting &lt;code&gt;wal_sync_method&lt;/code&gt; to &lt;code&gt;fsync_writethrough&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="befd8f0dca607b26fc6d2d970cd74ce25f6b225a" translate="yes" xml:space="preserve">
          <source>On many systems, however, syslog is not very reliable, particularly with large log messages; it might truncate or drop messages just when you need them the most. Also, on Linux, syslog will flush each message to disk, yielding poor performance. (You can use a &amp;ldquo;&lt;code&gt;-&lt;/code&gt;&amp;rdquo; at the start of the file name in the syslog configuration file to disable syncing.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb6093f7e35a1c20e326af32dcefbf608a486601" translate="yes" xml:space="preserve">
          <source>On most Unix platforms, PostgreSQL modifies its command title as reported by &lt;code&gt;ps&lt;/code&gt;, so that individual server processes can readily be identified. A sample display is</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3b91e78aa6712803e0d5864f8e480013e5bf3c9" translate="yes" xml:space="preserve">
          <source>On most Unix systems, you will need to alter the configuration of your system's syslog daemon in order to make use of the syslog option for &lt;code&gt;log_destination&lt;/code&gt;. PostgreSQL can log to syslog facilities &lt;code&gt;LOCAL0&lt;/code&gt; through &lt;code&gt;LOCAL7&lt;/code&gt; (see &lt;a href=&quot;runtime-config-logging#GUC-SYSLOG-FACILITY&quot;&gt;syslog_facility&lt;/a&gt;), but the default syslog configuration on most platforms will discard all such messages. You will need to add something like:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50e3c6b1dcc491688ab2b7696ca3d74d8a9db77d" translate="yes" xml:space="preserve">
          <source>On most modern operating systems, PostgreSQL can determine which character set is implied by the &lt;code&gt;LC_CTYPE&lt;/code&gt; setting, and it will enforce that only the matching database encoding is used. On older systems it is your responsibility to ensure that you use the encoding expected by the locale you have selected. A mistake in this area is likely to lead to strange behavior of locale-dependent operations such as sorting.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2260de2d5df529fa47da0a7e6dd5d8bb23e03ee" translate="yes" xml:space="preserve">
          <source>On most platforms, if PostgreSQL is built with &lt;code&gt;--enable-dtrace&lt;/code&gt;, the arguments to a trace macro will be evaluated whenever control passes through the macro, &lt;em&gt;even if no tracing is being done&lt;/em&gt;. This is usually not worth worrying about if you are just reporting the values of a few local variables. But beware of putting expensive function calls into the arguments. If you need to do that, consider protecting the macro with a check to see if the trace is actually enabled:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1a020e1e97e31739abdd2c2ef2354878b9e297e" translate="yes" xml:space="preserve">
          <source>On one system, an &lt;code&gt;EXPLAIN&lt;/code&gt; showed a query with a cost of 8488 was reduced to a cost of 329. The original query was a join involving the &lt;code&gt;one_to_many&lt;/code&gt; table, which was replaced by:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46913037bc93da8c08a056c91624219985822221" translate="yes" xml:space="preserve">
          <source>On output, double quotes always surround keys and values, even when it's not strictly necessary.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bac2b8b67734755e62d6acef24655269b5ebc6a2" translate="yes" xml:space="preserve">
          <source>On some newer Linux systems, it's possible to change the clock source used to collect timing data at any time. A second example shows the slowdown possible from switching to the slower acpi_pm time source, on the same system used for the fast results above:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ce5931c68b8a455769ec944aab5c902a50f0a9b" translate="yes" xml:space="preserve">
          <source>On some operating systems, the status of data in the kernel's page cache is unknown after a write-back failure. In some cases it might have been entirely forgotten, making it unsafe to retry; the second attempt may be reported as successful, when in fact the data has been lost. In these circumstances, the only way to avoid data loss is to recover from the WAL after any failure is reported, preferably after investigating the root cause of the failure and replacing any faulty hardware.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eee21b404ba214868f7afb4e8cb293a79759405b" translate="yes" xml:space="preserve">
          <source>On some systems, this locale category does not exist. Setting this variable will still work, but there will be no effect. Also, there is a chance that no translated messages for the desired language exist. In that case you will continue to see the English messages.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8426bc3d71cab36b2e69aeb3bfdd7499b750f4a" translate="yes" xml:space="preserve">
          <source>On success, &lt;code&gt;*recheck&lt;/code&gt; should be set to true if the heap tuple needs to be rechecked against the query operator, or false if the index test is exact. That is, a false return value guarantees that the heap tuple does not match the query; a true return value with &lt;code&gt;*recheck&lt;/code&gt; set to false guarantees that the heap tuple does match the query; and a true return value with &lt;code&gt;*recheck&lt;/code&gt; set to true means that the heap tuple might match the query, so it needs to be fetched and rechecked by evaluating the query operator directly against the originally indexed item.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="471ab7df5323b9c1beeab9b6ad11a4a3d81ba199" translate="yes" xml:space="preserve">
          <source>On successful completion, a &lt;code&gt;COPY&lt;/code&gt; command returns a command tag of the form</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a330b5f61b3e5eaefa54001cda5edd47cd225306" translate="yes" xml:space="preserve">
          <source>On successful completion, a &lt;code&gt;DELETE&lt;/code&gt; command returns a command tag of the form</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="606df5c042bda87282091ed6e870632af55a409b" translate="yes" xml:space="preserve">
          <source>On successful completion, a &lt;code&gt;FETCH&lt;/code&gt; command returns a command tag of the form</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="522cefa61331276f75d9354dde07beed068c55b2" translate="yes" xml:space="preserve">
          <source>On successful completion, a &lt;code&gt;MOVE&lt;/code&gt; command returns a command tag of the form</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10a00a825ef1af18a74c6369608739640c2c6694" translate="yes" xml:space="preserve">
          <source>On successful completion, an &lt;code&gt;INSERT&lt;/code&gt; command returns a command tag of the form</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="adea3b7cb9bb8d678c08759a0633a3db722c1eb8" translate="yes" xml:space="preserve">
          <source>On successful completion, an &lt;code&gt;UPDATE&lt;/code&gt; command returns a command tag of the form</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17c3054fe4ff4e4031ec1aca452c9f2fbf414b42" translate="yes" xml:space="preserve">
          <source>On systems that have PostgreSQL started at boot time, there is probably a start-up file that will accomplish the same thing. For example, on a Red Hat Linux system one might find that this works:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c79b94518a5311140dc7e0d3b2812f742d2b393" translate="yes" xml:space="preserve">
          <source>On systems that support the keepalive socket option, setting &lt;a href=&quot;runtime-config-connection#GUC-TCP-KEEPALIVES-IDLE&quot;&gt;tcp_keepalives_idle&lt;/a&gt;, &lt;a href=&quot;runtime-config-connection#GUC-TCP-KEEPALIVES-INTERVAL&quot;&gt;tcp_keepalives_interval&lt;/a&gt; and &lt;a href=&quot;runtime-config-connection#GUC-TCP-KEEPALIVES-COUNT&quot;&gt;tcp_keepalives_count&lt;/a&gt; helps the primary promptly notice a broken connection.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1fa1a4c2c8b8530e986a78ada66b4ce0e77848ad" translate="yes" xml:space="preserve">
          <source>On systems with less than 1GB of RAM, a smaller percentage of RAM is appropriate, so as to leave adequate space for the operating system.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7c83da74a1e6d13c844e01daa0931d96bf79bb8" translate="yes" xml:space="preserve">
          <source>On that date, there were two possible interpretations of 2:30AM; there was 2:30AM EDT, and then an hour later after the reversion to standard time, there was 2:30AM EST. Again, PostgreSQL interprets the given time as if it were standard time (UTC-5). We can force the matter by specifying daylight-savings time:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="108bc1acbd3eb627957c49ac13cf1805b058d6fd" translate="yes" xml:space="preserve">
          <source>On the other hand, the JSON existence operator is not nested: it will only look for the specified key or array element at top level of the JSON value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0944856f78282776625887773317f5e5a29f6901" translate="yes" xml:space="preserve">
          <source>On the other hand, the following query finds all the cities that are not state capitals and are situated at an altitude over 500 feet:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d66d041f4d766c1f0ee27254b9b736aa4e0885c" translate="yes" xml:space="preserve">
          <source>On the other hand, the prefix operator &lt;code&gt;~&lt;/code&gt; (bitwise negation) is defined only for integer data types, not for &lt;code&gt;float8&lt;/code&gt;. So, if we try a similar case with &lt;code&gt;~&lt;/code&gt;, we get:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3fb0b420bf61dd2f01fedc471af93946522a689" translate="yes" xml:space="preserve">
          <source>On the other hand, the structurally similar case</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa512d53935676cc08f57c9480c2f5a40cb3a7f6" translate="yes" xml:space="preserve">
          <source>On the other side of the coin, some systems allow individual processes to open large numbers of files; if more than a few processes do so then the system-wide limit can easily be exceeded. If you find this happening, and you do not want to alter the system-wide limit, you can set PostgreSQL's &lt;a href=&quot;runtime-config-resource#GUC-MAX-FILES-PER-PROCESS&quot;&gt;max_files_per_process&lt;/a&gt; configuration parameter to limit the consumption of open files.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e90706123ac00808e07c484e32d4635f07e67a74" translate="yes" xml:space="preserve">
          <source>On the primary server, these cases simply result in waiting; and the user might choose to cancel either of the conflicting actions. However, on the standby there is no choice: the WAL-logged action already occurred on the primary so the standby must not fail to apply it. Furthermore, allowing WAL application to wait indefinitely may be very undesirable, because the standby's state will become increasingly far behind the primary's. Therefore, a mechanism is provided to forcibly cancel standby queries that conflict with to-be-applied WAL records.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12047b5caa5d65a62660b71617de0d4a759ef067" translate="yes" xml:space="preserve">
          <source>On the primary, parameters &lt;a href=&quot;runtime-config-wal#GUC-WAL-LEVEL&quot;&gt;wal_level&lt;/a&gt; and &lt;a href=&quot;runtime-config-replication#GUC-VACUUM-DEFER-CLEANUP-AGE&quot;&gt;vacuum_defer_cleanup_age&lt;/a&gt; can be used. &lt;a href=&quot;runtime-config-replication#GUC-MAX-STANDBY-ARCHIVE-DELAY&quot;&gt;max_standby_archive_delay&lt;/a&gt; and &lt;a href=&quot;runtime-config-replication#GUC-MAX-STANDBY-STREAMING-DELAY&quot;&gt;max_standby_streaming_delay&lt;/a&gt; have no effect if set on the primary.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4d2789c0f0275ad798be7e6d4e299236ebe91e1" translate="yes" xml:space="preserve">
          <source>On the publisher side, &lt;code&gt;wal_level&lt;/code&gt; must be set to &lt;code&gt;logical&lt;/code&gt;, and &lt;code&gt;max_replication_slots&lt;/code&gt; must be set to at least the number of subscriptions expected to connect, plus some reserve for table synchronization. And &lt;code&gt;max_wal_senders&lt;/code&gt; should be set to at least the same as &lt;code&gt;max_replication_slots&lt;/code&gt; plus the number of physical replicas that are connected at the same time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="35745b04684e80ded8dc5507c072fa2674283617" translate="yes" xml:space="preserve">
          <source>On the standby, parameters &lt;a href=&quot;runtime-config-replication#GUC-HOT-STANDBY&quot;&gt;hot_standby&lt;/a&gt;, &lt;a href=&quot;runtime-config-replication#GUC-MAX-STANDBY-ARCHIVE-DELAY&quot;&gt;max_standby_archive_delay&lt;/a&gt; and &lt;a href=&quot;runtime-config-replication#GUC-MAX-STANDBY-STREAMING-DELAY&quot;&gt;max_standby_streaming_delay&lt;/a&gt; can be used. &lt;a href=&quot;runtime-config-replication#GUC-VACUUM-DEFER-CLEANUP-AGE&quot;&gt;vacuum_defer_cleanup_age&lt;/a&gt; has no effect as long as the server remains in standby mode, though it will become relevant if the standby becomes primary.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70715c6fbe3e407765f6386cd308c88b6865cc56" translate="yes" xml:space="preserve">
          <source>Once &lt;code&gt;UNLISTEN&lt;/code&gt; has been executed, further &lt;code&gt;NOTIFY&lt;/code&gt; messages will be ignored:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec65ec416b46f0c02b02945a4d9803e7d39332ca" translate="yes" xml:space="preserve">
          <source>Once a client is connected to the database, PostgreSQL provides two additional SQL commands (and equivalent functions) to interact with session-local configuration settings:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="356c49cf82618dc4e123a48d759d153fd0e38847" translate="yes" xml:space="preserve">
          <source>Once a connection is established the client process can send a query to the &lt;em&gt;backend&lt;/em&gt; (server). The query is transmitted using plain text, i.e., there is no parsing done in the &lt;em&gt;frontend&lt;/em&gt; (client). The server parses the query, creates an &lt;em&gt;execution plan&lt;/em&gt;, executes the plan and returns the retrieved rows to the client by transmitting them over the established connection.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ad9c4a6213a012c3300efd580e40047d30505b8" translate="yes" xml:space="preserve">
          <source>Once acquired, a lock is normally held till end of transaction. But if a lock is acquired after establishing a savepoint, the lock is released immediately if the savepoint is rolled back to. This is consistent with the principle that &lt;code&gt;ROLLBACK&lt;/code&gt; cancels all effects of the commands since the savepoint. The same holds for locks acquired within a PL/pgSQL exception block: an error escape from the block releases locks acquired within it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41f916b016e9381b5815b3e4089f244578b1cdbc" translate="yes" xml:space="preserve">
          <source>Once an index is created, no further intervention is required: the system will update the index when the table is modified, and it will use the index in queries when it thinks doing so would be more efficient than a sequential table scan. But you might have to run the &lt;code&gt;ANALYZE&lt;/code&gt; command regularly to update statistics to allow the query planner to make educated decisions. See &lt;a href=&quot;https://www.postgresql.org/docs/12/performance-tips.html&quot;&gt;Chapter 14&lt;/a&gt; for information about how to find out whether an index is used and when and why the planner might choose &lt;em&gt;not&lt;/em&gt; to use an index.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e5421d611a483b4f3357d11ff23a5acc44acb58" translate="yes" xml:space="preserve">
          <source>Once any valuable objects have been transferred to new owners, any remaining objects owned by the role-to-be-dropped can be dropped with the &lt;a href=&quot;sql-drop-owned&quot;&gt;DROP OWNED&lt;/a&gt; command. Again, this command cannot access objects in other databases, so it is necessary to run it in each database that contains objects owned by the role. Also, &lt;code&gt;DROP OWNED&lt;/code&gt; will not drop entire databases or tablespaces, so it is necessary to do that manually if the role owns any databases or tablespaces that have not been transferred to new owners.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e81389b8f98e0c4fa0978b0ecbccf3ec2c7326c5" translate="yes" xml:space="preserve">
          <source>Once created, a tablespace can be used from any database, provided the requesting user has sufficient privilege. This means that a tablespace cannot be dropped until all objects in all databases using the tablespace have been removed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73da0c6102d03c025cdbc83b1b38fc971869013e" translate="yes" xml:space="preserve">
          <source>Once created, the enum type can be used in table and function definitions much like any other type:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9f4d5e2b4aa9fc314da7481d260ca60dd53ed46" translate="yes" xml:space="preserve">
          <source>Once failover to the standby occurs, there is only a single server in operation. This is known as a degenerate state. The former standby is now the primary, but the former primary is down and might stay down. To return to normal operation, a standby server must be recreated, either on the former primary system when it comes up, or on a third, possibly new, system. The &lt;a href=&quot;app-pgrewind&quot;&gt;pg_rewind&lt;/a&gt; utility can be used to speed up this process on large clusters. Once complete, the primary and standby can be considered to have switched roles. Some people choose to use a third server to provide backup for the new primary until the new standby server is recreated, though clearly this complicates the system configuration and operational processes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99eb90b007ab371c4c054db1b4a14dc72baaf9ae" translate="yes" xml:space="preserve">
          <source>Once prepared, a transaction can later be committed or rolled back with &lt;a href=&quot;sql-commit-prepared&quot;&gt;COMMIT PREPARED&lt;/a&gt; or &lt;a href=&quot;sql-rollback-prepared&quot;&gt;ROLLBACK PREPARED&lt;/a&gt;, respectively. Those commands can be issued from any session, not only the one that executed the original transaction.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a26efc323b5a3b586fc58ac6b6adb6fb3937603a" translate="yes" xml:space="preserve">
          <source>Once restored, it is wise to run &lt;code&gt;ANALYZE&lt;/code&gt; on each database so the optimizer has useful statistics. You can also run &lt;code&gt;vacuumdb -a -z&lt;/code&gt; to analyze all databases.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1c807b866ed2972017d5380e0a876fec0d03a30" translate="yes" xml:space="preserve">
          <source>Once restored, it is wise to run &lt;code&gt;ANALYZE&lt;/code&gt; on each restored table so the optimizer has useful statistics; see &lt;a href=&quot;routine-vacuuming#VACUUM-FOR-STATISTICS&quot;&gt;Section 24.1.3&lt;/a&gt; and &lt;a href=&quot;routine-vacuuming#AUTOVACUUM&quot;&gt;Section 24.1.6&lt;/a&gt; for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f22ae97ca76db6661c3c1f5a88b003eb151976f" translate="yes" xml:space="preserve">
          <source>Once started, &lt;code&gt;pg_upgrade&lt;/code&gt; will verify the two clusters are compatible and then do the upgrade. You can use &lt;code&gt;pg_upgrade --check&lt;/code&gt; to perform only the checks, even if the old server is still running. &lt;code&gt;pg_upgrade --check&lt;/code&gt; will also outline any manual adjustments you will need to make after the upgrade. If you are going to be using link or clone mode, you should use the option &lt;code&gt;--link&lt;/code&gt; or &lt;code&gt;--clone&lt;/code&gt; with &lt;code&gt;--check&lt;/code&gt; to enable mode-specific checks. &lt;code&gt;pg_upgrade&lt;/code&gt; requires write permission in the current directory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c713ae812f1782bcff8d86ab36ed9c6d151c330d" translate="yes" xml:space="preserve">
          <source>Once streaming replication has been configured, configuring synchronous replication requires only one additional configuration step: &lt;a href=&quot;runtime-config-replication#GUC-SYNCHRONOUS-STANDBY-NAMES&quot;&gt;synchronous_standby_names&lt;/a&gt; must be set to a non-empty value. &lt;code&gt;synchronous_commit&lt;/code&gt; must also be set to &lt;code&gt;on&lt;/code&gt;, but since this is the default value, typically no change is required. (See &lt;a href=&quot;runtime-config-wal#RUNTIME-CONFIG-WAL-SETTINGS&quot;&gt;Section 19.5.1&lt;/a&gt; and &lt;a href=&quot;runtime-config-replication#RUNTIME-CONFIG-REPLICATION-MASTER&quot;&gt;Section 19.6.2&lt;/a&gt;.) This configuration will cause each commit to wait for confirmation that the standby has written the commit record to durable storage. &lt;code&gt;synchronous_commit&lt;/code&gt; can be set by individual users, so it can be configured in the configuration file, for particular users or databases, or dynamically by applications, in order to control the durability guarantee on a per-transaction basis.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9871853da7c650c2f0dd2795f59e948ae7531634" translate="yes" xml:space="preserve">
          <source>Once the WAL segment files active during the backup are archived, you are done. The file identified by &lt;code&gt;pg_stop_backup&lt;/code&gt;'s first return value is the last segment that is required to form a complete set of backup files. On a primary, if &lt;code&gt;archive_mode&lt;/code&gt; is enabled and the &lt;code&gt;wait_for_archive&lt;/code&gt; parameter is &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;pg_stop_backup&lt;/code&gt; does not return until the last segment has been archived. On a standby, &lt;code&gt;archive_mode&lt;/code&gt; must be &lt;code&gt;always&lt;/code&gt; in order for &lt;code&gt;pg_stop_backup&lt;/code&gt; to wait. Archiving of these files happens automatically since you have already configured &lt;code&gt;archive_command&lt;/code&gt;. In most cases this happens quickly, but you are advised to monitor your archive system to ensure there are no delays. If the archive process has fallen behind because of failures of the archive command, it will keep retrying until the archive succeeds and the backup is complete. If you wish to place a time limit on the execution of &lt;code&gt;pg_stop_backup&lt;/code&gt;, set an appropriate &lt;code&gt;statement_timeout&lt;/code&gt; value, but make note that if &lt;code&gt;pg_stop_backup&lt;/code&gt; terminates because of this your backup may not be valid.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32e5f3f159f9a76e583d7e4dd4b47490f3262b2b" translate="yes" xml:space="preserve">
          <source>Once the WAL segment files active during the backup are archived, you are done. The file identified by &lt;code&gt;pg_stop_backup&lt;/code&gt;'s result is the last segment that is required to form a complete set of backup files. If &lt;code&gt;archive_mode&lt;/code&gt; is enabled, &lt;code&gt;pg_stop_backup&lt;/code&gt; does not return until the last segment has been archived. Archiving of these files happens automatically since you have already configured &lt;code&gt;archive_command&lt;/code&gt;. In most cases this happens quickly, but you are advised to monitor your archive system to ensure there are no delays. If the archive process has fallen behind because of failures of the archive command, it will keep retrying until the archive succeeds and the backup is complete.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f47c9896865faba1d610987fd3b05badac486b3" translate="yes" xml:space="preserve">
          <source>Once the delay specified by &lt;code&gt;max_standby_archive_delay&lt;/code&gt; or &lt;code&gt;max_standby_streaming_delay&lt;/code&gt; has been exceeded, conflicting queries will be canceled. This usually results just in a cancellation error, although in the case of replaying a &lt;code&gt;DROP DATABASE&lt;/code&gt; the entire conflicting session will be terminated. Also, if the conflict is over a lock held by an idle transaction, the conflicting session is terminated (this behavior might change in the future).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8e1074216e0451321cd3f251827b2e9872eaede" translate="yes" xml:space="preserve">
          <source>Once the group role exists, you can add and remove members using the &lt;a href=&quot;sql-grant&quot;&gt;GRANT&lt;/a&gt; and &lt;a href=&quot;sql-revoke&quot;&gt;REVOKE&lt;/a&gt; commands:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69a71607e88d378416ed92ac7ffd6286dc445378" translate="yes" xml:space="preserve">
          <source>Once you are satisfied with the upgrade, you can delete the old cluster's data directories by running the script mentioned when &lt;code&gt;pg_upgrade&lt;/code&gt; completes. (Automatic deletion is not possible if you have user-defined tablespaces inside the old data directory.) You can also delete the old installation directories (e.g. &lt;code&gt;bin&lt;/code&gt;, &lt;code&gt;share&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5a7bdde6e82e682c3584d24535e62c92a86edd3" translate="yes" xml:space="preserve">
          <source>Once you have created a database, you can access it by:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a17a3f555279791537a8bafe938cf8c6379fa784" translate="yes" xml:space="preserve">
          <source>Once you have done the necessary setup, you can run your benchmark with a command that doesn't include &lt;code&gt;-i&lt;/code&gt;, that is</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61eda2a3b905b905ee98026b455b6eb92908a307" translate="yes" xml:space="preserve">
          <source>One &lt;code&gt;postgres&lt;/code&gt; instance always manages the data of exactly one database cluster. A database cluster is a collection of databases that is stored at a common file system location (the &amp;ldquo;data area&amp;rdquo;). More than one &lt;code&gt;postgres&lt;/code&gt; instance can run on a system at one time, so long as they use different data areas and different communication ports (see below). When &lt;code&gt;postgres&lt;/code&gt; starts it needs to know the location of the data area. The location must be specified by the &lt;code&gt;-D&lt;/code&gt; option or the &lt;code&gt;PGDATA&lt;/code&gt; environment variable; there is no default. Typically, &lt;code&gt;-D&lt;/code&gt; or &lt;code&gt;PGDATA&lt;/code&gt; points directly to the data area directory created by &lt;a href=&quot;app-initdb&quot;&gt;initdb&lt;/a&gt;. Other possible file layouts are discussed in &lt;a href=&quot;runtime-config-file-locations&quot;&gt;Section 19.2&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d2b8f4e1b139546c73a22f8f91fadc862c3170c" translate="yes" xml:space="preserve">
          <source>One advantage of GIN is that it allows the development of custom data types with the appropriate access methods, by an expert in the domain of the data type, rather than a database expert. This is much the same advantage as using GiST.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e058cfc0d2adb864aa10f7c9c5f44bcfe8be50f0" translate="yes" xml:space="preserve">
          <source>One advantage of GiST is that it allows the development of custom data types with the appropriate access methods, by an expert in the domain of the data type, rather than a database expert.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f48b87ea34b25adefa4f3efa4a97db47fb753d95" translate="yes" xml:space="preserve">
          <source>One advantage of the separate-column approach over an expression index is that it is not necessary to explicitly specify the text search configuration in queries in order to make use of the index. As shown in the example above, the query can depend on &lt;code&gt;default_text_search_config&lt;/code&gt;. Another advantage is that searches will be faster, since it will not be necessary to redo the &lt;code&gt;to_tsvector&lt;/code&gt; calls to verify index matches. (This is more important when using a GiST index than a GIN index; see &lt;a href=&quot;textsearch-indexes&quot;&gt;Section 12.9&lt;/a&gt;.) The expression-index approach is simpler to set up, however, and it requires less disk space since the &lt;code&gt;tsvector&lt;/code&gt; representation is not stored explicitly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c591e2a82e983192d18fdc29edda9221e37c6723" translate="yes" xml:space="preserve">
          <source>One advantage of using concatenation in the vector form, rather than concatenating text before applying &lt;code&gt;to_tsvector&lt;/code&gt;, is that you can use different configurations to parse different sections of the document. Also, because the &lt;code&gt;setweight&lt;/code&gt; function marks all lexemes of the given vector the same way, it is necessary to parse the text and do &lt;code&gt;setweight&lt;/code&gt; before concatenating if you want to label different parts of the document with different weights.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7aa492c47d8ea5d45e5da9a09ed3c6c96f7a96e5" translate="yes" xml:space="preserve">
          <source>One application of the rewrite system is in the realization of &lt;em&gt;views&lt;/em&gt;. Whenever a query against a view (i.e., a &lt;em&gt;virtual table&lt;/em&gt;) is made, the rewrite system rewrites the user's query to a query that accesses the &lt;em&gt;base tables&lt;/em&gt; given in the &lt;em&gt;view definition&lt;/em&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bee7fd28573b33fce2d46ef1ac5fa8251ec94562" translate="yes" xml:space="preserve">
          <source>One component of the statistics is the total number of entries in each table and index, as well as the number of disk blocks occupied by each table and index. This information is kept in the table &lt;a href=&quot;catalog-pg-class&quot;&gt;&lt;code&gt;pg_class&lt;/code&gt;&lt;/a&gt;, in the columns &lt;code&gt;reltuples&lt;/code&gt; and &lt;code&gt;relpages&lt;/code&gt;. We can look at it with queries similar to this one:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4bd99552b099beafc96cbe7829988f7a06eb967b" translate="yes" xml:space="preserve">
          <source>One convenient way to create a compatible table that will later be made a new child is to use the &lt;code&gt;LIKE&lt;/code&gt; clause in &lt;code&gt;CREATE TABLE&lt;/code&gt;. This creates a new table with the same columns as the source table. If there are any &lt;code&gt;CHECK&lt;/code&gt; constraints defined on the source table, the &lt;code&gt;INCLUDING CONSTRAINTS&lt;/code&gt; option to &lt;code&gt;LIKE&lt;/code&gt; should be specified, as the new child must have constraints matching the parent to be considered compatible.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="313d199647b14e908c91b6831b2ac1803fbc36c9" translate="yes" xml:space="preserve">
          <source>One could accomplish the same thing with, say,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7bcb03e673340a4965d50eadd319bf1730dddebc" translate="yes" xml:space="preserve">
          <source>One disadvantage of decreasing &lt;code&gt;vacuum_freeze_min_age&lt;/code&gt; is that it might cause &lt;code&gt;VACUUM&lt;/code&gt; to do useless work: freezing a row version is a waste of time if the row is modified soon thereafter (causing it to acquire a new XID). So the setting should be large enough that rows are not frozen until they are unlikely to change any more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d99c8486b08ccc8839ea87cdfcd9e4516a4d63fc" translate="yes" xml:space="preserve">
          <source>One disadvantage of the longitude/latitude representation is that you need to be careful about the edge conditions near the poles and near +/- 180 degrees of longitude. The &lt;code&gt;cube&lt;/code&gt;-based representation avoids these discontinuities.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17918ae437c6b6c4eb55d620ac26a6167c3d73b5" translate="yes" xml:space="preserve">
          <source>One example use of this mechanism is to copy the contents of a file into a table column. First load the file into a variable and then interpolate the variable's value as a quoted string:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11e396823958b9942ef20dabe2804d32c8c47de7" translate="yes" xml:space="preserve">
          <source>One fairly large constraint of the table access method API is that, currently, if the AM wants to support modifications and/or indexes, it is necessary for each tuple to have a tuple identifier (TID) consisting of a block number and an item number (see also &lt;a href=&quot;storage-page-layout&quot;&gt;Section 68.6&lt;/a&gt;). It is not strictly necessary that the sub-parts of TIDs have the same meaning they e.g. have for &lt;code&gt;heap&lt;/code&gt;, but if bitmap scan support is desired (it is optional), the block number needs to provide locality.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea6157e87abd7338811eb2303b2c46792b171e86" translate="yes" xml:space="preserve">
          <source>One major reason for using a partial index is to avoid indexing common values. Since a query searching for a common value (one that accounts for more than a few percent of all the table rows) will not use the index anyway, there is no point in keeping those rows in the index at all. This reduces the size of the index, which will speed up those queries that do use the index. It will also speed up many table update operations because the index does not need to be updated in all cases. &lt;a href=&quot;indexes-partial#INDEXES-PARTIAL-EX1&quot;&gt;Example 11.1&lt;/a&gt; shows a possible application of this idea.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d407807dcbba44e4e2aa91e451040ac8b91fe898" translate="yes" xml:space="preserve">
          <source>One might need to insert a large amount of data when first populating a database. This section contains some suggestions on how to make this process as efficient as possible.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8bb08b9cf98dd6c73c6dc0c7e52247a78ee67c4" translate="yes" xml:space="preserve">
          <source>One of</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e3d57db8bbc433a035cda8e815f996da30de43e" translate="yes" xml:space="preserve">
          <source>One of &lt;code&gt;INSERT&lt;/code&gt;, &lt;code&gt;UPDATE&lt;/code&gt;, &lt;code&gt;DELETE&lt;/code&gt;, or &lt;code&gt;TRUNCATE&lt;/code&gt;; this specifies the event that will fire the trigger. Multiple events can be specified using &lt;code&gt;OR&lt;/code&gt;, except when transition relations are requested.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d58cd9872ba6b984b5aaf4db1dd4f254a5318e3" translate="yes" xml:space="preserve">
          <source>One of the most critical design decisions will be the column or columns by which you partition your data. Often the best choice will be to partition by the column or set of columns which most commonly appear in &lt;code&gt;WHERE&lt;/code&gt; clauses of queries being executed on the partitioned table. &lt;code&gt;WHERE&lt;/code&gt; clause items that match and are compatible with the partition key can be used to prune unneeded partitions. However, you may be forced into making other decisions by requirements for the &lt;code&gt;PRIMARY KEY&lt;/code&gt; or a &lt;code&gt;UNIQUE&lt;/code&gt; constraint. Removal of unwanted data is also a factor to consider when planning your partitioning strategy. An entire partition can be detached fairly quickly, so it may be beneficial to design the partition strategy in such a way that all data to be removed at once is located in a single partition.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd64b8780a8987f51d6cf827b3649d1c335b7dcc" translate="yes" xml:space="preserve">
          <source>One of the obvious uses for &lt;code&gt;file_fdw&lt;/code&gt; is to make the PostgreSQL activity log available as a table for querying. To do this, first you must be logging to a CSV file, which here we will call &lt;code&gt;pglog.csv&lt;/code&gt;. First, install &lt;code&gt;file_fdw&lt;/code&gt; as an extension:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01a9a0754bb2d47df04d6f754f8a9d26cef931fd" translate="yes" xml:space="preserve">
          <source>One of the problems with the JDBC driver (and this affects the ODBC driver also), is that the specification assumes that references to BLOBs (Binary Large OBjects) are stored within a table, and if that entry is changed, the associated BLOB is deleted from the database.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e5610f45b959ec0066fbadc6e622bf504204314" translate="yes" xml:space="preserve">
          <source>One of the values estimated by &lt;code&gt;ANALYZE&lt;/code&gt; is the number of distinct values that appear in each column. Because only a subset of the rows are examined, this estimate can sometimes be quite inaccurate, even with the largest possible statistics target. If this inaccuracy leads to bad query plans, a more accurate value can be determined manually and then installed with &lt;code&gt;ALTER TABLE ... ALTER COLUMN ... SET (n_distinct = ...)&lt;/code&gt; (see &lt;a href=&quot;sql-altertable&quot;&gt;ALTER TABLE&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="493483fbe186caeb533f2587ea2f5c9911b94b74" translate="yes" xml:space="preserve">
          <source>One or more server-challenge and client-response message will follow. Each server-challenge is sent in an AuthenticationSASLContinue message, followed by a response from client in an SASLResponse message. The particulars of the messages are mechanism specific.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="425be19de627a14da7ab3bb185d550dfbfe3423c" translate="yes" xml:space="preserve">
          <source>One parameter is specified per line. The equal sign between name and value is optional. Whitespace is insignificant (except within a quoted parameter value) and blank lines are ignored. Hash marks (&lt;code&gt;#&lt;/code&gt;) designate the remainder of the line as a comment. Parameter values that are not simple identifiers or numbers must be single-quoted. To embed a single quote in a parameter value, write either two quotes (preferred) or backslash-quote. If the file contains multiple entries for the same parameter, all but the last one are ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80b5eb3c3d07dabe60de983aaa0a3518afd885a7" translate="yes" xml:space="preserve">
          <source>One row for each backend (including autovacuum worker processes) running &lt;code&gt;VACUUM&lt;/code&gt;, showing current progress. See &lt;a href=&quot;progress-reporting#VACUUM-PROGRESS-REPORTING&quot;&gt;Section 27.4.2&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e814a8df1ec5e7ba9113e201d150026719d20049" translate="yes" xml:space="preserve">
          <source>One row for each backend running &lt;code&gt;CLUSTER&lt;/code&gt; or &lt;code&gt;VACUUM FULL&lt;/code&gt;, showing current progress. See &lt;a href=&quot;progress-reporting#CLUSTER-PROGRESS-REPORTING&quot;&gt;Section 27.4.3&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="592609ed9243ae5def10fa9f090855998b555b8d" translate="yes" xml:space="preserve">
          <source>One row for each backend running &lt;code&gt;CREATE INDEX&lt;/code&gt; or &lt;code&gt;REINDEX&lt;/code&gt;, showing current progress. See &lt;a href=&quot;progress-reporting#CREATE-INDEX-PROGRESS-REPORTING&quot;&gt;Section 27.4.1&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="636789b8fa3526dcb7ffa47252873c271555303c" translate="yes" xml:space="preserve">
          <source>One row for each index in the current database, showing statistics about I/O on that specific index. See &lt;a href=&quot;monitoring-stats#PG-STATIO-ALL-INDEXES-VIEW&quot;&gt;pg_statio_all_indexes&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c843f1eedf963b1dea0a4c471c30395c4850fb0a" translate="yes" xml:space="preserve">
          <source>One row for each index in the current database, showing statistics about accesses to that specific index. See &lt;a href=&quot;monitoring-stats#PG-STAT-ALL-INDEXES-VIEW&quot;&gt;pg_stat_all_indexes&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2a19a27308f1c1e0f487d86ec09bd9389b70b95" translate="yes" xml:space="preserve">
          <source>One row for each sequence in the current database, showing statistics about I/O on that specific sequence. See &lt;a href=&quot;monitoring-stats#PG-STATIO-ALL-SEQUENCES-VIEW&quot;&gt;pg_statio_all_sequences&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="876cb7f3198f93830f07de3b355cbda033ba5c5c" translate="yes" xml:space="preserve">
          <source>One row for each table in the current database, showing statistics about I/O on that specific table. See &lt;a href=&quot;monitoring-stats#PG-STATIO-ALL-TABLES-VIEW&quot;&gt;pg_statio_all_tables&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1a2d424d05fad0ce8a503aad44ed8e2890ec86d" translate="yes" xml:space="preserve">
          <source>One row for each table in the current database, showing statistics about accesses to that specific table. See &lt;a href=&quot;monitoring-stats#PG-STAT-ALL-TABLES-VIEW&quot;&gt;pg_stat_all_tables&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e4f1c454b46b07db5b5caff74a33b9a88d14f14" translate="yes" xml:space="preserve">
          <source>One row for each tracked function, showing statistics about executions of that function. See &lt;a href=&quot;monitoring-stats#PG-STAT-USER-FUNCTIONS-VIEW&quot;&gt;pg_stat_user_functions&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a27e9764cf42abc447770a40b26ae4110256df1" translate="yes" xml:space="preserve">
          <source>One row only, showing statistics about the WAL archiver process's activity. See &lt;a href=&quot;monitoring-stats#PG-STAT-ARCHIVER-VIEW&quot;&gt;pg_stat_archiver&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08ff69da529511355514d8fad09917a768f3dfee" translate="yes" xml:space="preserve">
          <source>One row only, showing statistics about the background writer process's activity. See &lt;a href=&quot;monitoring-stats#PG-STAT-BGWRITER-VIEW&quot;&gt;pg_stat_bgwriter&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41761c4e3d769b5a97047d2af3c904ca9b99e019" translate="yes" xml:space="preserve">
          <source>One row per WAL sender process, showing statistics about replication to that sender's connected standby server. See &lt;a href=&quot;monitoring-stats#PG-STAT-REPLICATION-VIEW&quot;&gt;pg_stat_replication&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04eefccf9acdca920d874c55aed10830947f2ad0" translate="yes" xml:space="preserve">
          <source>One row per connection (regular and replication), showing information about GSSAPI authentication and encryption used on this connection. See &lt;a href=&quot;monitoring-stats#PG-STAT-GSSAPI-VIEW&quot;&gt;pg_stat_gssapi&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff2500623059c396127b50986a7192b6dece4045" translate="yes" xml:space="preserve">
          <source>One row per connection (regular and replication), showing information about SSL used on this connection. See &lt;a href=&quot;monitoring-stats#PG-STAT-SSL-VIEW&quot;&gt;pg_stat_ssl&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e2bdd85f6f61ca9f60bf24ae4eb4fe127af69af" translate="yes" xml:space="preserve">
          <source>One row per database, showing database-wide statistics about query cancels due to conflict with recovery on standby servers. See &lt;a href=&quot;monitoring-stats#PG-STAT-DATABASE-CONFLICTS-VIEW&quot;&gt;pg_stat_database_conflicts&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28ca9a3ad9c0527d7bf8067a93b52b4e199755b8" translate="yes" xml:space="preserve">
          <source>One row per database, showing database-wide statistics. See &lt;a href=&quot;monitoring-stats#PG-STAT-DATABASE-VIEW&quot;&gt;pg_stat_database&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02ad092a9644445754a24d9ccf37920da6663d5c" translate="yes" xml:space="preserve">
          <source>One row per server process, showing information related to the current activity of that process, such as state and current query. See &lt;a href=&quot;monitoring-stats#PG-STAT-ACTIVITY-VIEW&quot;&gt;pg_stat_activity&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd0d7184c558c048e1447f27b2e4a45d43e212a8" translate="yes" xml:space="preserve">
          <source>One semantically-insignificant detail worth noting is that in &lt;code&gt;jsonb&lt;/code&gt;, numbers will be printed according to the behavior of the underlying &lt;code&gt;numeric&lt;/code&gt; type. In practice this means that numbers entered with &lt;code&gt;E&lt;/code&gt; notation will be printed without it, for example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eee0b1a9ad748e96945cdf21735c3cba379b36e1" translate="yes" xml:space="preserve">
          <source>One should be wary of statements of the form</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0503270d022d51df4a5d1385ddb363763c100a21" translate="yes" xml:space="preserve">
          <source>One should be wary that the POSIX-style time zone feature can lead to silently accepting bogus input, since there is no check on the reasonableness of the zone abbreviations. For example, &lt;code&gt;SET TIMEZONE TO FOOBAR0&lt;/code&gt; will work, leaving the system effectively using a rather peculiar abbreviation for UTC. Another issue to keep in mind is that in POSIX time zone names, positive offsets are used for locations &lt;em&gt;west&lt;/em&gt; of Greenwich. Everywhere else, PostgreSQL follows the ISO-8601 convention that positive timezone offsets are &lt;em&gt;east&lt;/em&gt; of Greenwich.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07761093680f0435d07de4dfbf3133e5f6e33451" translate="yes" xml:space="preserve">
          <source>One upgrade method is to dump data from one major version of PostgreSQL and reload it in another &amp;mdash; to do this, you must use a &lt;em&gt;logical&lt;/em&gt; backup tool like pg_dumpall; file system level backup methods will not work. (There are checks in place that prevent you from using a data directory with an incompatible version of PostgreSQL, so no great harm can be done by trying to start the wrong server version on a data directory.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c2ef0cb6e16fe638517e00044d9fddafd2f1f0e" translate="yes" xml:space="preserve">
          <source>One way to avoid this problem is to run PostgreSQL on a machine where you can be sure that other processes will not run the machine out of memory. If memory is tight, increasing the swap space of the operating system can help avoid the problem, because the out-of-memory (OOM) killer is invoked only when physical memory and swap space are exhausted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb720ead71b0312fba38d640c63f7a5801cc13dc" translate="yes" xml:space="preserve">
          <source>One way to do this is to shut down the server and start a single-user PostgreSQL server with the &lt;code&gt;-P&lt;/code&gt; option included on its command line. Then, &lt;code&gt;REINDEX DATABASE&lt;/code&gt;, &lt;code&gt;REINDEX SYSTEM&lt;/code&gt;, &lt;code&gt;REINDEX TABLE&lt;/code&gt;, or &lt;code&gt;REINDEX INDEX&lt;/code&gt; can be issued, depending on how much you want to reconstruct. If in doubt, use &lt;code&gt;REINDEX SYSTEM&lt;/code&gt; to select reconstruction of all system indexes in the database. Then quit the single-user server session and restart the regular server. See the &lt;a href=&quot;app-postgres&quot;&gt;postgres&lt;/a&gt; reference page for more information about how to interact with the single-user server interface.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76a318a5204a34131edd8add7164960e6a6851df" translate="yes" xml:space="preserve">
          <source>One way to look at variant plans is to force the planner to disregard whatever strategy it thought was the cheapest, using the enable/disable flags described in &lt;a href=&quot;runtime-config-query#RUNTIME-CONFIG-QUERY-ENABLE&quot;&gt;Section 19.7.1&lt;/a&gt;. (This is a crude tool, but useful. See also &lt;a href=&quot;explicit-joins&quot;&gt;Section 14.3&lt;/a&gt;.) For example, if we're unconvinced that sequential-scan-and-sort is the best way to deal with table &lt;code&gt;onek&lt;/code&gt; in the previous example, we could try</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0391e7fdb45313d9e4e2f5f1634bb9ecb7a05ff9" translate="yes" xml:space="preserve">
          <source>One way to prevent spoofing of &lt;code&gt;local&lt;/code&gt; connections is to use a Unix domain socket directory (&lt;a href=&quot;runtime-config-connection#GUC-UNIX-SOCKET-DIRECTORIES&quot;&gt;unix_socket_directories&lt;/a&gt;) that has write permission only for a trusted local user. This prevents a malicious user from creating their own socket file in that directory. If you are concerned that some applications might still reference &lt;code&gt;/tmp&lt;/code&gt; for the socket file and hence be vulnerable to spoofing, during operating system startup create a symbolic link &lt;code&gt;/tmp/.s.PGSQL.5432&lt;/code&gt; that points to the relocated socket file. You also might need to modify your &lt;code&gt;/tmp&lt;/code&gt; cleanup script to prevent removal of the symbolic link.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="839eb373f7e57c0c527b6ab4498f37574f9b1b5d" translate="yes" xml:space="preserve">
          <source>Online Analytical Processing</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9bc8e24fa431e83abb8ee45cbd92647ad8e714f7" translate="yes" xml:space="preserve">
          <source>Online Transaction Processing</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b59497ee41bee58e3cf2969b674c4903d4bc6b0" translate="yes" xml:space="preserve">
          <source>Online statistics:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95683a3aebf06f5e3b349d234f74e1173b887f29" translate="yes" xml:space="preserve">
          <source>Only an &lt;code&gt;ACCESS EXCLUSIVE&lt;/code&gt; lock blocks a &lt;code&gt;SELECT&lt;/code&gt; (without &lt;code&gt;FOR UPDATE/SHARE&lt;/code&gt;) statement.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6428d0603b66d67294f1af1eb460cffe5ea43327" translate="yes" xml:space="preserve">
          <source>Only calculate statistics for use by the optimizer (no vacuum), like &lt;code&gt;--analyze-only&lt;/code&gt;. Run several (currently three) stages of analyze with different configuration settings, to produce usable statistics faster.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4af2b2a347593a2587cd89d5c7edc042fe1b2ae" translate="yes" xml:space="preserve">
          <source>Only calculate statistics for use by the optimizer (no vacuum).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ff76f6d5463fac41b779622c32a96a9ae59972a" translate="yes" xml:space="preserve">
          <source>Only certain data types support TOAST &amp;mdash; there is no need to impose the overhead on data types that cannot produce large field values. To support TOAST, a data type must have a variable-length (&lt;em&gt;varlena&lt;/em&gt;) representation, in which, ordinarily, the first four-byte word of any stored value contains the total length of the value in bytes (including itself). TOAST does not constrain the rest of the data type's representation. The special representations collectively called &lt;em&gt;TOASTed values&lt;/em&gt; work by modifying or reinterpreting this initial length word. Therefore, the C-level functions supporting a TOAST-able data type must be careful about how they handle potentially TOASTed input values: an input might not actually consist of a four-byte length word and contents until after it's been &lt;em&gt;detoasted&lt;/em&gt;. (This is normally done by invoking &lt;code&gt;PG_DETOAST_DATUM&lt;/code&gt; before doing anything with an input value, but in some cases more efficient approaches are possible. See &lt;a href=&quot;https://www.postgresql.org/docs/12/xtypes.html#XTYPES-TOAST&quot;&gt;Section 37.13.1&lt;/a&gt; for more detail.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27a5875a715917165876854e17c248ccf4f95f13" translate="yes" xml:space="preserve">
          <source>Only display records generated by the specified resource manager. If &lt;code&gt;list&lt;/code&gt; is passed as name, print a list of valid resource manager names, and exit.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1eec6acc7fed503402488b3ba82909c46aae0483" translate="yes" xml:space="preserve">
          <source>Only display records marked with the given transaction ID.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df686aa57f8a0399728798091a1185e8914758e9" translate="yes" xml:space="preserve">
          <source>Only dump the named section. The section name can be &lt;code&gt;pre-data&lt;/code&gt;, &lt;code&gt;data&lt;/code&gt;, or &lt;code&gt;post-data&lt;/code&gt;. This option can be specified more than once to select multiple sections. The default is to dump all sections.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c62a53b547108de76ccc1531107eb8cfedb9cfb" translate="yes" xml:space="preserve">
          <source>Only execute the vacuum or analyze commands on tables with a multixact ID age of at least &lt;code&gt;mxid_age&lt;/code&gt;. This setting is useful for prioritizing tables to process to prevent multixact ID wraparound (see &lt;a href=&quot;routine-vacuuming#VACUUM-FOR-MULTIXACT-WRAPAROUND&quot;&gt;Section 24.1.5.1&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22cc7a345e3b6c6eac0bd069839bf36f1185ab25" translate="yes" xml:space="preserve">
          <source>Only execute the vacuum or analyze commands on tables with a transaction ID age of at least &lt;code&gt;xid_age&lt;/code&gt;. This setting is useful for prioritizing tables to process to prevent transaction ID wraparound (see &lt;a href=&quot;routine-vacuuming#VACUUM-FOR-WRAPAROUND&quot;&gt;Section 24.1.5&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30caad55acba8eaee72cd0eb2b22ca9a6e1cfcaa" translate="yes" xml:space="preserve">
          <source>Only has effect if &lt;a href=&quot;app-initdb#APP-INITDB-DATA-CHECKSUMS&quot;&gt;data checksums&lt;/a&gt; are enabled.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4930a6bbf0f1c4de7f538ff4072a1668f8d281a2" translate="yes" xml:space="preserve">
          <source>Only lowercase &lt;code&gt;true&lt;/code&gt; and &lt;code&gt;false&lt;/code&gt; spellings are accepted</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d755b459eeaa6b733e81509898e0f04066e3489" translate="yes" xml:space="preserve">
          <source>Only one comment string is stored for each object, so to modify a comment, issue a new &lt;code&gt;COMMENT&lt;/code&gt; command for the same object. To remove a comment, write &lt;code&gt;NULL&lt;/code&gt; in place of the text string. Comments are automatically dropped when their object is dropped.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b3d566bcef3dc1ca42fe3bd8ea05bbe930d19d6" translate="yes" xml:space="preserve">
          <source>Only one parameter may be supplied to the function in a &lt;code&gt;CREATE TRIGGER&lt;/code&gt; statement, and that is optional. If supplied it will be used for the channel name for the notifications. If omitted &lt;code&gt;tcn&lt;/code&gt; will be used for the channel name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52d2c18b8c742c722526abc3884826a2891d9cd5" translate="yes" xml:space="preserve">
          <source>Only one row, showing statistics about the WAL receiver from that receiver's connected server. See &lt;a href=&quot;monitoring-stats#PG-STAT-WAL-RECEIVER-VIEW&quot;&gt;pg_stat_wal_receiver&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e141ed896712b895fe333210a9bdff25138d7ab" translate="yes" xml:space="preserve">
          <source>Only operator classes for &lt;code&gt;int4&lt;/code&gt; and &lt;code&gt;text&lt;/code&gt; are included with the module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36554985b3656b4dddfbe30677cd178826516027" translate="yes" xml:space="preserve">
          <source>Only persistent base tables can be part of a publication. Temporary tables, unlogged tables, foreign tables, materialized views, regular views, and partitioned tables cannot be part of a publication. To replicate a partitioned table, add the individual partitions to the publication.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0f9131e0157ccbc9f71702565357129b8273efc" translate="yes" xml:space="preserve">
          <source>Only restore the named section. The section name can be &lt;code&gt;pre-data&lt;/code&gt;, &lt;code&gt;data&lt;/code&gt;, or &lt;code&gt;post-data&lt;/code&gt;. This option can be specified more than once to select multiple sections. The default is to restore all sections.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d94341e83b6e3cc09be7f96d9ae2bbdbd997a3f" translate="yes" xml:space="preserve">
          <source>Only roles that have the &lt;code&gt;LOGIN&lt;/code&gt; attribute can be used as the initial role name for a database connection. A role with the &lt;code&gt;LOGIN&lt;/code&gt; attribute can be considered the same as a &amp;ldquo;database user&amp;rdquo;. To create a role with login privilege, use either:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d85fc142dd33473e697f51542b02c504f67a9b35" translate="yes" xml:space="preserve">
          <source>Only shared libraries specifically intended to be used with PostgreSQL can be loaded this way. Every PostgreSQL-supported library has a &amp;ldquo;magic block&amp;rdquo; that is checked to guarantee compatibility. For this reason, non-PostgreSQL libraries cannot be loaded in this way. You might be able to use operating-system facilities such as &lt;code&gt;LD_PRELOAD&lt;/code&gt; for that.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7bf905053544478968750f95521ca3e30e70375f" translate="yes" xml:space="preserve">
          <source>Only superusers can alter foreign-data wrappers. Additionally, only superusers can own foreign-data wrappers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9d1a65de15d43acfd7df441e250838c198f3037" translate="yes" xml:space="preserve">
          <source>Only superusers can call &lt;code&gt;CHECKPOINT&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b3d5ff53d3f29afdf3319b912d99cf3260a4f77" translate="yes" xml:space="preserve">
          <source>Only superusers can change this setting, because it affects the messages sent to the server log as well as to the client, and an improper value might obscure the readability of the server logs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2be6ed45f348313973635f2ddfd082cf6f9717d" translate="yes" xml:space="preserve">
          <source>Only superusers can create event triggers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ae5bc67902361297a54dbc3f2c9fc4cdf0facde" translate="yes" xml:space="preserve">
          <source>Only superusers can create foreign-data wrappers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0a550e0a836899716e0fe5ebdbfaa0d54059384" translate="yes" xml:space="preserve">
          <source>Only superusers can define new access methods.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d11423b98472dc3dca65de17ed52b8e73990fa3d" translate="yes" xml:space="preserve">
          <source>Only superusers can use &lt;code&gt;ALTER SYSTEM&lt;/code&gt;. Also, since this command acts directly on the file system and cannot be rolled back, it is not allowed inside a transaction block or function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0b0ed2869d7ce3fc0379f4c0080abfebb839775" translate="yes" xml:space="preserve">
          <source>Only superusers may connect to foreign servers without password authentication, so always specify the &lt;code&gt;password&lt;/code&gt; option for user mappings belonging to non-superusers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="add5aed352ded84ef9a29f07c8afce866831ef29" translate="yes" xml:space="preserve">
          <source>Only the &lt;code&gt;=&lt;/code&gt; operator is supported for search. But it is possible to add support for arrays with union and intersection operations in the future.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2c2cf173b45b1ac1a32e3ec0d5fe77ba32623c7" translate="yes" xml:space="preserve">
          <source>Only the &lt;code&gt;ANALYZE&lt;/code&gt; and &lt;code&gt;VERBOSE&lt;/code&gt; options can be specified, and only in that order, without surrounding the option list in parentheses. Prior to PostgreSQL 9.0, the unparenthesized syntax was the only one supported. It is expected that all new options will be supported only in the parenthesized syntax.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5022f8e7bdd77bf8c02d9d1490318561a8027b6a" translate="yes" xml:space="preserve">
          <source>Only the custom and directory archive formats are supported with this option. The input must be a regular file or directory (not, for example, a pipe). This option is ignored when emitting a script rather than connecting directly to a database server. Also, multiple jobs cannot be used together with the option &lt;code&gt;--single-transaction&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e47b4720ff6f0582001899cb68bf4bdb2a0ac11" translate="yes" xml:space="preserve">
          <source>Only the owner of the database, or a superuser, can drop a database. Dropping a database removes all objects that were contained within the database. The destruction of a database cannot be undone.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="992702029b9e3a50c611dc6825669adb061c4f3f" translate="yes" xml:space="preserve">
          <source>Only the specified timeline is displayed (or the default, if none is specified). Records in other timelines are ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e8a66b6f0be3b6d7c6a27438485bc034b86bede" translate="yes" xml:space="preserve">
          <source>Only validate checksums in the relation with filenode &lt;code&gt;filenode&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0b885bbfd4f3bfc263123d67cbabd608309adfe" translate="yes" xml:space="preserve">
          <source>Open Database Connectivity</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="904b1a9c4f30cf27ea883ca5fa7d3ff036c36eb9" translate="yes" xml:space="preserve">
          <source>Open interval with lower bound &lt;code&gt;x&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a8b4a983dd22778ee9f002679eacd86bf69191d" translate="yes" xml:space="preserve">
          <source>Open interval with upper bound &lt;code&gt;x&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45de3417dc1987111074bc170202fbf751c567d8" translate="yes" xml:space="preserve">
          <source>Open path</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db3951317261fd51cb4c1a3e01c4748b4896c421" translate="yes" xml:space="preserve">
          <source>OpenBSD</source>
          <target state="translated">OpenBSD</target>
        </trans-unit>
        <trans-unit id="50ef244d7dd70cb29f22ada32d04825a64fc9036" translate="yes" xml:space="preserve">
          <source>OpenBSD sys/crypto</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e301ca795081a87c0033bddb2e90503f9f7929d2" translate="yes" xml:space="preserve">
          <source>OpenPGP message format.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2188261ca504497d39a1689d5dff920fe8b50f79" translate="yes" xml:space="preserve">
          <source>OpenSSL names for the most common curves are: &lt;code&gt;prime256v1&lt;/code&gt; (NIST P-256), &lt;code&gt;secp384r1&lt;/code&gt; (NIST P-384), &lt;code&gt;secp521r1&lt;/code&gt; (NIST P-521). The full list of available curves can be shown with the command &lt;code&gt;openssl ecparam -list_curves&lt;/code&gt;. Not all of them are usable in TLS though.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c972fdff495c397d3150e0515793a7f4559382c" translate="yes" xml:space="preserve">
          <source>OpenSSL supports a wide range of ciphers and authentication algorithms, of varying strength. While a list of ciphers can be specified in the OpenSSL configuration file, you can specify ciphers specifically for use by the database server by modifying &lt;a href=&quot;runtime-config-connection#GUC-SSL-CIPHERS&quot;&gt;ssl_ciphers&lt;/a&gt; in &lt;code&gt;postgresql.conf&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3b0974ebaa95408edcf74b52711fc4f50a804a3" translate="yes" xml:space="preserve">
          <source>Operations such as TRUNCATE which normally affect a table and all of its inheritance children will cascade to all partitions, but may also be performed on an individual partition. Note that dropping a partition with &lt;code&gt;DROP TABLE&lt;/code&gt; requires taking an &lt;code&gt;ACCESS EXCLUSIVE&lt;/code&gt; lock on the parent table.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0e687b079fb70f2208d1f8d2c75d64d74925496" translate="yes" xml:space="preserve">
          <source>Operator</source>
          <target state="translated">Operator</target>
        </trans-unit>
        <trans-unit id="b07cfafa5cefef04cd848e7642b8acf9013a81e6" translate="yes" xml:space="preserve">
          <source>Operator Classes and Operator Families</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b398f34e06d00a1a82db7c5bd5884749c340c3d5" translate="yes" xml:space="preserve">
          <source>Operator Strategy 1</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="244ef231d648a8011796f75d8ba0c200ff67c490" translate="yes" xml:space="preserve">
          <source>Operator Strategy 10</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa5d9755365c2952ee3e6f612eacdbdd1a1d7624" translate="yes" xml:space="preserve">
          <source>Operator Strategy 11</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4a97822fa5fff84d7420e13e887c2193e9890f0" translate="yes" xml:space="preserve">
          <source>Operator Strategy 12</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84afbc51b4cffb9fe60bc11408d20fc3c75207ff" translate="yes" xml:space="preserve">
          <source>Operator Strategy 2</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32970bd5b0dc670174fa5e603b715a1879812041" translate="yes" xml:space="preserve">
          <source>Operator Strategy 20</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="151eb78f3e104abebf3876024563a961e2605d2c" translate="yes" xml:space="preserve">
          <source>Operator Strategy 21</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8684f3d138a78992a0b771dfbb423682326c65f8" translate="yes" xml:space="preserve">
          <source>Operator Strategy 22</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71205740f8d9e86efeb0bd151835d85c0a6b3446" translate="yes" xml:space="preserve">
          <source>Operator Strategy 23</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0c4fa7b818964dd91a014987dc2cbf9d0f35f95" translate="yes" xml:space="preserve">
          <source>Operator Strategy 3</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0698fd0a94af9d76a35b8038b94b51dc5055fa5" translate="yes" xml:space="preserve">
          <source>Operator Strategy 4</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f6f8898348de22423f28b86e1d340d71a2b39e6" translate="yes" xml:space="preserve">
          <source>Operator Strategy 5</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b8f252bde4d01adf4e5020737ab0f39249112c8" translate="yes" xml:space="preserve">
          <source>Operator Strategy 6, 18</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63882822a5b9fac73c626ceb2fedd6c07953d3d2" translate="yes" xml:space="preserve">
          <source>Operator Strategy 7</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="614f640543a97c56dc41fc006e5e6df302593992" translate="yes" xml:space="preserve">
          <source>Operator Strategy 7, 13, 16, 24, 25</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5666e86d614f20d9c6c6d654b73870444a0a7b8" translate="yes" xml:space="preserve">
          <source>Operator Strategy 8, 14, 26, 27</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6bd466b077248c905be85a30157069ea7d392f05" translate="yes" xml:space="preserve">
          <source>Operator Strategy 9</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23a5e32675db7a6dae8947caf6f8b77d2fb419f2" translate="yes" xml:space="preserve">
          <source>Operator class member</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a154991f482d1ef020b50f829693f6a3e7645883" translate="yes" xml:space="preserve">
          <source>Operator classes are described at length in &lt;a href=&quot;https://www.postgresql.org/docs/12/xindex.html&quot;&gt;Section 37.16&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58080c4fb9795121bf1294991f50a6dd258005c4" translate="yes" xml:space="preserve">
          <source>Operator classes that implement completely different semantics are also possible, provided implementations of the four main support functions described above are written. Note that backwards compatibility across major releases is not guaranteed: for example, additional support functions might be required in later releases.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb753b5f274e2276c93849eb8d4d017ef67b8b0d" translate="yes" xml:space="preserve">
          <source>Operator families are described at length in &lt;a href=&quot;https://www.postgresql.org/docs/12/xindex.html&quot;&gt;Section 37.16&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="089453e64460e24c4860d90b978d73331899e626" translate="yes" xml:space="preserve">
          <source>Operator family containing the operator class</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d001f433bb040727266e2e45232ebf1b96c87507" translate="yes" xml:space="preserve">
          <source>Operator purpose, either &lt;code&gt;s&lt;/code&gt; for search or &lt;code&gt;o&lt;/code&gt; for ordering</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="912efd8e18516ea9637e59e441f7f7a9add7dc7b" translate="yes" xml:space="preserve">
          <source>Operator strategy number</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e8cb1b3b6dd7d5c36991fdde1327aa3fa525b70" translate="yes" xml:space="preserve">
          <source>Operator/Element</source>
          <target state="translated">Operator/Element</target>
        </trans-unit>
        <trans-unit id="2d08499adb61cbc2e5aa0edb02bd1f8b9de48e7f" translate="yes" xml:space="preserve">
          <source>Operator/Method</source>
          <target state="translated">Operator/Method</target>
        </trans-unit>
        <trans-unit id="e90414358dbfff0a68e4eb5d68a16978cf197d5a" translate="yes" xml:space="preserve">
          <source>Operators</source>
          <target state="translated">Operators</target>
        </trans-unit>
        <trans-unit id="245cf7f12c2bf5a2fc5aaf31f347829fe389252a" translate="yes" xml:space="preserve">
          <source>Operators are represented by &lt;code&gt;oprname(lefttype,righttype)&lt;/code&gt;, writing the type names exactly as they appear in the &lt;code&gt;pg_operator.dat&lt;/code&gt; entry's &lt;code&gt;oprleft&lt;/code&gt; and &lt;code&gt;oprright&lt;/code&gt; fields. (Write &lt;code&gt;0&lt;/code&gt; for the omitted operand of a unary operator.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f5c0ba13f00010cbbfefca8a52453ff0cb4b539" translate="yes" xml:space="preserve">
          <source>Optimality of the query plan</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e31d972229de381b461860014dd710856361917a" translate="yes" xml:space="preserve">
          <source>Option</source>
          <target state="translated">Option</target>
        </trans-unit>
        <trans-unit id="30ea09691f79f4f3b53ede4678ab841460419294" translate="yes" xml:space="preserve">
          <source>Optional data-manipulation: compression, conversion to UTF-8, and/or conversion of line-endings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dda0500e72a6b8d9415eee2d2bd9c2b4bddc1e78" translate="yes" xml:space="preserve">
          <source>Optional key words. They have no effect.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be700c602b6a0f91e2d0a7efd9323b26ffbdc0e3" translate="yes" xml:space="preserve">
          <source>Optional parameters can be written in any order, not only the order illustrated above.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1ddbf1be07fc433b776138e1087ccfcfc7bb295" translate="yes" xml:space="preserve">
          <source>Optional planner support function for this function (see &lt;a href=&quot;https://www.postgresql.org/docs/12/xfunc-optimization.html&quot;&gt;Section 37.11&lt;/a&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2fd16c799a777633af7110bcb3365acd2d2f9b6f" translate="yes" xml:space="preserve">
          <source>Optional server type, potentially useful to foreign-data wrappers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23e65fc5f0e4b9be1c8551d9648425aede4fa734" translate="yes" xml:space="preserve">
          <source>Optional server version, potentially useful to foreign-data wrappers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8080182e2b9ea49c9096dd85079cd9c704e16363" translate="yes" xml:space="preserve">
          <source>Optionally one can add the key word &lt;code&gt;ASC&lt;/code&gt; (ascending) or &lt;code&gt;DESC&lt;/code&gt; (descending) after any expression in the &lt;code&gt;ORDER BY&lt;/code&gt; clause. If not specified, &lt;code&gt;ASC&lt;/code&gt; is assumed by default. Alternatively, a specific ordering operator name can be specified in the &lt;code&gt;USING&lt;/code&gt; clause. An ordering operator must be a less-than or greater-than member of some B-tree operator family. &lt;code&gt;ASC&lt;/code&gt; is usually equivalent to &lt;code&gt;USING &amp;lt;&lt;/code&gt; and &lt;code&gt;DESC&lt;/code&gt; is usually equivalent to &lt;code&gt;USING &amp;gt;&lt;/code&gt;. (But the creator of a user-defined data type can define exactly what the default sort ordering is, and it might correspond to operators with other names.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25a8ce77c093de9028c29694dad75d1d0b46f922" translate="yes" xml:space="preserve">
          <source>Optionally specifies an existing replication slot to be used when connecting to the sending server via streaming replication to control resource removal on the upstream node (see &lt;a href=&quot;warm-standby#STREAMING-REPLICATION-SLOTS&quot;&gt;Section 26.2.6&lt;/a&gt;). This parameter can only be set at server start. This setting has no effect if &lt;code&gt;primary_conninfo&lt;/code&gt; is not set.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9e1a54cb19d7f45ef6c62130cbc0ebd54aaaeaa" translate="yes" xml:space="preserve">
          <source>Optionally, &lt;code&gt;CREATE SCHEMA&lt;/code&gt; can include subcommands to create objects within the new schema. The subcommands are treated essentially the same as separate commands issued after creating the schema, except that if the &lt;code&gt;AUTHORIZATION&lt;/code&gt; clause is used, all the created objects will be owned by that user.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb213cf60cad5118b118598f7c3788d5e4cf965c" translate="yes" xml:space="preserve">
          <source>Optionally, &lt;code&gt;GLOBAL&lt;/code&gt; or &lt;code&gt;LOCAL&lt;/code&gt; can be written before &lt;code&gt;TEMPORARY&lt;/code&gt; or &lt;code&gt;TEMP&lt;/code&gt;. This presently makes no difference in PostgreSQL and is deprecated; see &lt;a href=&quot;sql-createtable#SQL-CREATETABLE-COMPATIBILITY&quot;&gt;Compatibility&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38ce22db7991e92cf37c1757c548b3362a7ca1aa" translate="yes" xml:space="preserve">
          <source>Optionally, a btree operator family may provide &lt;em&gt;in_range&lt;/em&gt; support function(s), registered under support function number 3. These are not used during btree index operations; rather, they extend the semantics of the operator family so that it can support window clauses containing the &lt;code&gt;RANGE&lt;/code&gt;&lt;code&gt;offset&lt;/code&gt;&lt;code&gt;PRECEDING&lt;/code&gt; and &lt;code&gt;RANGE&lt;/code&gt;&lt;code&gt;offset&lt;/code&gt;&lt;code&gt;FOLLOWING&lt;/code&gt; frame bound types (see &lt;a href=&quot;sql-expressions#SYNTAX-WINDOW-FUNCTIONS&quot;&gt;Section 4.2.8&lt;/a&gt;). Fundamentally, the extra information provided is how to add or subtract an &lt;code&gt;offset&lt;/code&gt; value in a way that is compatible with the family's data ordering.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="478c790850d122e707e8f7883dedaa4fc2abbd82" translate="yes" xml:space="preserve">
          <source>Optionally, a btree operator family may provide &lt;em&gt;sort support&lt;/em&gt; function(s), registered under support function number 2. These functions allow implementing comparisons for sorting purposes in a more efficient way than naively calling the comparison support function. The APIs involved in this are defined in &lt;code&gt;src/include/utils/sortsupport.h&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d0b1d8f44651eff9c08018d57dc26658e0d79ec" translate="yes" xml:space="preserve">
          <source>Optionally, an operator class for GIN can supply the following method:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="555fcafecaac1b7a79da77571a044c4fcd960ef4" translate="yes" xml:space="preserve">
          <source>Optionally, integer &lt;em&gt;positions&lt;/em&gt; can be attached to lexemes:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba2c90dde0ab03dd101be9fe39552cd35bcc19fc" translate="yes" xml:space="preserve">
          <source>Optionally, lexemes in a &lt;code&gt;tsquery&lt;/code&gt; can be labeled with one or more weight letters, which restricts them to match only &lt;code&gt;tsvector&lt;/code&gt; lexemes with one of those weights:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6bf5da9c080bee3a8142586c412aa39971137eee" translate="yes" xml:space="preserve">
          <source>Options</source>
          <target state="translated">Options</target>
        </trans-unit>
        <trans-unit id="bfb2e74b331377cdefa56e8103510af4757e8e75" translate="yes" xml:space="preserve">
          <source>Options are named to be similar to GnuPG. An option's value should be given after an equal sign; separate options from each other with commas. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01c5d645df020042965df6656c79fbcb52302c6d" translate="yes" xml:space="preserve">
          <source>Options for Single-User Mode</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2cc6e913a91a4d81d0ee2eacb713152c147c5122" translate="yes" xml:space="preserve">
          <source>Options for Windows</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0807432116c5005f30d6e9cc2d8f5760b3400db2" translate="yes" xml:space="preserve">
          <source>Options specified for authentication method, if any</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ba952bec3ffacb85d251e04c62c8891e8cc4022" translate="yes" xml:space="preserve">
          <source>Options to be associated with the new foreign table or one of its columns. The allowed option names and values are specific to each foreign data wrapper and are validated using the foreign-data wrapper's validator function. Duplicate option names are not allowed (although it's OK for a table option and a column option to have the same name).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea0cc8f54bce88ccfd10bba527220a016a032c30" translate="yes" xml:space="preserve">
          <source>Options to be used during the import. The allowed option names and values are specific to each foreign data wrapper.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a0c5ecf28319808109742741597da1a162506e4" translate="yes" xml:space="preserve">
          <source>Or, if no array size is to be specified:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57f20b026b33a5f996b1722a8963058f7f139ed9" translate="yes" xml:space="preserve">
          <source>Order in which the entries are processed (1..&lt;code&gt;n&lt;/code&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b71865e60556421edb3dc5a27a33115f8d23b2c" translate="yes" xml:space="preserve">
          <source>Order in which to consult this entry (lower &lt;code&gt;mapseqno&lt;/code&gt;s first)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9032c5927654c6b139387affcba7ab64e16f3699" translate="yes" xml:space="preserve">
          <source>Ordering Operators</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb496dd08aebe7c50e13b0f636e3490f9e72e352" translate="yes" xml:space="preserve">
          <source>Ordinarily a cast must have different source and target data types. However, it is allowed to declare a cast with identical source and target types if it has a cast implementation function with more than one argument. This is used to represent type-specific length coercion functions in the system catalogs. The named function is used to coerce a value of the type to the type modifier value given by its second argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23ae1f89c4cafddef64330187ff525b64ad51110" translate="yes" xml:space="preserve">
          <source>Ordinarily, PostgreSQL functions are expected to be true functions that do not modify their input values. However, an aggregate transition function, &lt;em&gt;when used in the context of an aggregate&lt;/em&gt;, is allowed to cheat and modify its transition-state argument in place. This can provide substantial performance benefits compared to making a fresh copy of the transition state each time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c0095250f58080cd4f7b0263a9f790d13029e21" translate="yes" xml:space="preserve">
          <source>Ordinarily, if a date/time string is syntactically valid but contains out-of-range field values, an error will be thrown. For example, input specifying the 31st of February will be rejected.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d469c00e9517d285e5591f4a6f0cfdb929fc4475" translate="yes" xml:space="preserve">
          <source>Ordinarily, only the object's owner (or a superuser) can grant or revoke privileges on an object. However, it is possible to grant a privilege &amp;ldquo;with grant option&amp;rdquo;, which gives the recipient the right to grant it in turn to others. If the grant option is subsequently revoked then all who received the privilege from that recipient (directly or through a chain of grants) will lose the privilege. For details see the &lt;a href=&quot;sql-grant&quot;&gt;GRANT&lt;/a&gt; and &lt;a href=&quot;sql-revoke&quot;&gt;REVOKE&lt;/a&gt; reference pages.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1198b431d5751f4a8f2d46d9894c80568e5c546c" translate="yes" xml:space="preserve">
          <source>Ordinarily, the input rows are fed to the aggregate function in an unspecified order. In many cases this does not matter; for example, &lt;code&gt;min&lt;/code&gt; produces the same result no matter what order it receives the inputs in. However, some aggregate functions (such as &lt;code&gt;array_agg&lt;/code&gt; and &lt;code&gt;string_agg&lt;/code&gt;) produce results that depend on the ordering of the input rows. When using such an aggregate, the optional &lt;code&gt;order_by_clause&lt;/code&gt; can be used to specify the desired ordering. The &lt;code&gt;order_by_clause&lt;/code&gt; has the same syntax as for a query-level &lt;code&gt;ORDER BY&lt;/code&gt; clause, as described in &lt;a href=&quot;queries-order&quot;&gt;Section 7.5&lt;/a&gt;, except that its expressions are always just expressions and cannot be output-column names or numbers. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a1751155e24c2b7f81369ad2aa106588546c4f5" translate="yes" xml:space="preserve">
          <source>Ordinarily, the user must have the PostgreSQL superuser privilege to register a new language. However, the owner of a database can register a new language within that database if the language is listed in the &lt;code&gt;pg_pltemplate&lt;/code&gt; catalog and is marked as allowed to be created by database owners (&lt;code&gt;tmpldbacreate&lt;/code&gt; is true). The default is that trusted languages can be created by database owners, but this can be adjusted by superusers by modifying the contents of &lt;code&gt;pg_pltemplate&lt;/code&gt;. The creator of a language becomes its owner and can later drop it, rename it, or assign it to a new owner.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49558321bc55879a8f79a252d13bd83f15cac2ec" translate="yes" xml:space="preserve">
          <source>Ordinary comparison operators yield null (signifying &amp;ldquo;unknown&amp;rdquo;), not true or false, when either input is null. For example, &lt;code&gt;7 = NULL&lt;/code&gt; yields null, as does &lt;code&gt;7 &amp;lt;&amp;gt; NULL&lt;/code&gt;. When this behavior is not suitable, use the &lt;code&gt;IS [ NOT ] DISTINCT FROM&lt;/code&gt; predicates:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f51e9682012527e72ed015353424811e9ad8a4d" translate="yes" xml:space="preserve">
          <source>Ordinary text is allowed in &lt;code&gt;to_char&lt;/code&gt; templates and will be output literally. You can put a substring in double quotes to force it to be interpreted as literal text even if it contains template patterns. For example, in &lt;code&gt;'&quot;Hello Year &quot;YYYY'&lt;/code&gt;, the &lt;code&gt;YYYY&lt;/code&gt; will be replaced by the year data, but the single &lt;code&gt;Y&lt;/code&gt; in &lt;code&gt;Year&lt;/code&gt; will not be. In &lt;code&gt;to_date&lt;/code&gt;, &lt;code&gt;to_number&lt;/code&gt;, and &lt;code&gt;to_timestamp&lt;/code&gt;, literal text and double-quoted strings result in skipping the number of characters contained in the string; for example &lt;code&gt;&quot;XX&quot;&lt;/code&gt; skips two input characters (whether or not they are &lt;code&gt;XX&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47deb2333130b0b71a558b913d84907ec715a39c" translate="yes" xml:space="preserve">
          <source>Original UNIX crypt</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="728421f1a8e764e582012583a50320fee679ab3e" translate="yes" xml:space="preserve">
          <source>Original author: Gene Selkov, Jr. &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:selkovjr@mcs.anl.gov&quot;&gt;selkovjr@mcs.anl.gov&lt;/a&gt;&amp;gt;&lt;/code&gt;, Mathematics and Computer Science Division, Argonne National Laboratory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15c3cbc7d90ec04ca02171128016ae7aa1d06c07" translate="yes" xml:space="preserve">
          <source>Original version by Mark Kirkwood &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:markir@paradise.net.nz&quot;&gt;markir@paradise.net.nz&lt;/a&gt;&amp;gt;&lt;/code&gt;. Rewritten in version 8.4 to suit new FSM implementation by Heikki Linnakangas &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:heikki@enterprisedb.com&quot;&gt;heikki@enterprisedb.com&lt;/a&gt;&amp;gt;&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c3f5ca5b9a803aee38134c4fbdc2dd67fcb8f9e" translate="yes" xml:space="preserve">
          <source>Other clients and libraries might provide their own mechanisms, via the shell or otherwise, that allow the user to alter session settings without direct use of SQL commands.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b025a6555e41ac8947f0005aa2f96a2fbcedc20" translate="yes" xml:space="preserve">
          <source>Other database systems might advance these values more frequently.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16dab4fb6d3b76123e52d90af3ba7c8bf6cdec38" translate="yes" xml:space="preserve">
          <source>Other dependency flavors might be needed in future.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d54e9e4d1cedbb61d73910e1c0331a6b34276e3c" translate="yes" xml:space="preserve">
          <source>Other dependency flavors might be needed in future. Note in particular that the current definition only supports roles as referenced objects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b090b2cc862f6eb58c39020ceea8daeedfe6f7b3" translate="yes" xml:space="preserve">
          <source>Other digest algorithms</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd97a9c89af824879fb23956d987ca3355ff4cc8" translate="yes" xml:space="preserve">
          <source>Other libraries can also be preloaded. By preloading a shared library, the library startup time is avoided when the library is first used. However, the time to start each new server process might increase slightly, even if that process never uses the library. So this parameter is recommended only for libraries that will be used in most sessions. Also, changing this parameter requires a server restart, so this is not the right setting to use for short-term debugging tasks, say. Use &lt;a href=&quot;runtime-config-client#GUC-SESSION-PRELOAD-LIBRARIES&quot;&gt;session_preload_libraries&lt;/a&gt; for that instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b6d149d1176a026cafb96a0f82667c8ba54a10c" translate="yes" xml:space="preserve">
          <source>Other options are also available:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="599ffbd6e95e9102a19874cfc765e0666e6a5f25" translate="yes" xml:space="preserve">
          <source>Other options:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da25b0d9d5dc45c67ed8cb3f27503780b4aa4443" translate="yes" xml:space="preserve">
          <source>Other recommended kernel setting changes for database servers which will have a large number of connections are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3903dba9afe98748981ae8bb62ee1e14b5b5b0bf" translate="yes" xml:space="preserve">
          <source>Other scan types, such as scans of non-btree indexes, may support parallel scans in the future.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c88c65d71407192da2177c969f1b4c3e1b24c5ec" translate="yes" xml:space="preserve">
          <source>Other systems may only allow setting the time source on boot. On older Linux systems the &quot;clock&quot; kernel setting is the only way to make this sort of change. And even on some more recent ones, the only option you'll see for a clock source is &quot;jiffies&quot;. Jiffies are the older Linux software clock implementation, which can have good resolution when it's backed by fast enough timing hardware, as in this example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a2d21cbb1de6f88a1dcf3d541f364a9e95c1127" translate="yes" xml:space="preserve">
          <source>Other than configuration of the negotiation behavior, GSSAPI encryption requires no setup beyond that which is necessary for GSSAPI authentication. (For more information on configuring that, see &lt;a href=&quot;gssapi-auth&quot;&gt;Section 20.6&lt;/a&gt;.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d21779594b1e9934ec89f12215df7e04fc45898b" translate="yes" xml:space="preserve">
          <source>Other ways of looking at the statistics can be set up by writing queries that use the same underlying statistics access functions used by the standard views shown above. For details such as the functions' names, consult the definitions of the standard views. (For example, in psql you could issue &lt;code&gt;\d+ pg_stat_activity&lt;/code&gt;.) The access functions for per-database statistics take a database OID as an argument to identify which database to report on. The per-table and per-index functions take a table or index OID. The functions for per-function statistics take a function OID. Note that only tables, indexes, and functions in the current database can be seen with these functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5209293ce5b675774d27db322f4e25b9f78fde50" translate="yes" xml:space="preserve">
          <source>Other, less commonly used, options are also available:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86f791018da698782167efe67330f3a311425f18" translate="yes" xml:space="preserve">
          <source>Otherwise the date field ordering is assumed to follow the &lt;code&gt;DateStyle&lt;/code&gt; setting: mm-dd-yy, dd-mm-yy, or yy-mm-dd. Throw an error if a month or day field is found to be out of range.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="456174149b4fb59cccb0b858ebfab00191262c8b" translate="yes" xml:space="preserve">
          <source>Otherwise, all input expressions must have the same implicit collation derivation or the default collation. If any non-default collation is present, that is the result of the collation combination. Otherwise, the result is the default collation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7ebacc516a1689e9342c3f059955ce6038791c1" translate="yes" xml:space="preserve">
          <source>Otherwise, choose the last non-unknown input type that allows all the preceding non-unknown inputs to be implicitly converted to it. (There always is such a type, since at least the first type in the list must satisfy this condition.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9c2a604b8999f698fdb4a51e3a4309645319d17" translate="yes" xml:space="preserve">
          <source>Otherwise, if the JSON value is a string literal, the contents of the string are fed to the input conversion function for the column's data type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7bead17837ca29580c9cb15e38f0a813be5d9242" translate="yes" xml:space="preserve">
          <source>Otherwise, the ordinary text representation of the JSON value is fed to the input conversion function for the column's data type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c91502e459c401481e3ca0162bbcb613cfb57d2b" translate="yes" xml:space="preserve">
          <source>Otherwise, try to convert the expression to the target type. This is possible if an &lt;em&gt;assignment cast&lt;/em&gt; between the two types is registered in the &lt;code&gt;pg_cast&lt;/code&gt; catalog (see &lt;a href=&quot;sql-createcast&quot;&gt;CREATE CAST&lt;/a&gt;). Alternatively, if the expression is an unknown-type literal, the contents of the literal string will be fed to the input conversion routine for the target type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43c3af901aa493d7824a6ced3329413231661c11" translate="yes" xml:space="preserve">
          <source>Out-of-line values are divided (after compression if used) into chunks of at most &lt;code&gt;TOAST_MAX_CHUNK_SIZE&lt;/code&gt; bytes (by default this value is chosen so that four chunk rows will fit on a page, making it about 2000 bytes). Each chunk is stored as a separate row in the TOAST table belonging to the owning table. Every TOAST table has the columns &lt;code&gt;chunk_id&lt;/code&gt; (an OID identifying the particular TOASTed value), &lt;code&gt;chunk_seq&lt;/code&gt; (a sequence number for the chunk within its value), and &lt;code&gt;chunk_data&lt;/code&gt; (the actual data of the chunk). A unique index on &lt;code&gt;chunk_id&lt;/code&gt; and &lt;code&gt;chunk_seq&lt;/code&gt; provides fast retrieval of the values. A pointer datum representing an out-of-line on-disk TOASTed value therefore needs to store the OID of the TOAST table in which to look and the OID of the specific value (its &lt;code&gt;chunk_id&lt;/code&gt;). For convenience, pointer datums also store the logical datum size (original uncompressed data length) and physical stored size (different if compression was applied). Allowing for the varlena header bytes, the total size of an on-disk TOAST pointer datum is therefore 18 bytes regardless of the actual size of the represented value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97c53cd2b521753c0d717a86dd39f58035793149" translate="yes" xml:space="preserve">
          <source>Output Length</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="afe32b815eb6ac2d448375f1b337e892bc780a8c" translate="yes" xml:space="preserve">
          <source>Output Result</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a19289a8a65e3eaa1c70019f70d69f0ccdc7e3cc" translate="yes" xml:space="preserve">
          <source>Output SQL-standard &lt;code&gt;SET SESSION AUTHORIZATION&lt;/code&gt; commands instead of &lt;code&gt;ALTER OWNER&lt;/code&gt; commands to determine object ownership. This makes the dump more standards compatible, but depending on the history of the objects in the dump, might not restore properly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d49ccd8d61f0c2e0d773215d12c820e621fe051" translate="yes" xml:space="preserve">
          <source>Output SQL-standard &lt;code&gt;SET SESSION AUTHORIZATION&lt;/code&gt; commands instead of &lt;code&gt;ALTER OWNER&lt;/code&gt; commands to determine object ownership. This makes the dump more standards-compatible, but depending on the history of the objects in the dump, might not restore properly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4625db4629522bcdf0c7c483ff44db087396b6a5" translate="yes" xml:space="preserve">
          <source>Output SQL-standard &lt;code&gt;SET SESSION AUTHORIZATION&lt;/code&gt; commands instead of &lt;code&gt;ALTER OWNER&lt;/code&gt; commands to determine object ownership. This makes the dump more standards-compatible, but depending on the history of the objects in the dump, might not restore properly. Also, a dump using &lt;code&gt;SET SESSION AUTHORIZATION&lt;/code&gt; will certainly require superuser privileges to restore correctly, whereas &lt;code&gt;ALTER OWNER&lt;/code&gt; requires lesser privileges.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2005b7d907d65c19aff7a047dfc1b1dcc52ef1ca" translate="yes" xml:space="preserve">
          <source>Output a &lt;code&gt;tar&lt;/code&gt;-format archive suitable for input into pg_restore. The tar format is compatible with the directory format: extracting a tar-format archive produces a valid directory-format archive. However, the tar format does not support compression. Also, when using tar format the relative order of table data items cannot be changed during restore.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2eb830dc0187c951bb3c38e2fc9ae11b3f83d2a4" translate="yes" xml:space="preserve">
          <source>Output a custom-format archive suitable for input into pg_restore. Together with the directory output format, this is the most flexible output format in that it allows manual selection and reordering of archived items during restore. This format is also compressed by default.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="314bcb0a58dea88f5b77ecfb141e26b87d6cd0bf" translate="yes" xml:space="preserve">
          <source>Output a directory-format archive suitable for input into pg_restore. This will create a directory with one file for each table and blob being dumped, plus a so-called Table of Contents file describing the dumped objects in a machine-readable format that pg_restore can read. A directory format archive can be manipulated with standard Unix tools; for example, files in an uncompressed archive can be compressed with the gzip tool. This format is compressed by default and also supports parallel dumps.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9af173b4747fa54411d828576f57ede6b623e6c6" translate="yes" xml:space="preserve">
          <source>Output a plain-text SQL script file (the default).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8bdf0890d1e63cc1cfc92f91594ac95c633ba722" translate="yes" xml:space="preserve">
          <source>Output commands to clean (drop) database objects prior to outputting the commands for creating them. (Unless &lt;code&gt;--if-exists&lt;/code&gt; is also specified, restore might generate some harmless error messages, if any objects were not present in the destination database.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48cd5d324665dcd708893b4a104e4fb4fecb1e8f" translate="yes" xml:space="preserve">
          <source>Output conversion function (binary format), or 0 if none</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3bc8730df1e12ab656e0ea8398920726728cdbcd" translate="yes" xml:space="preserve">
          <source>Output conversion function (text format)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d850ce6c63d0f20826daa05520cced6f2083334" translate="yes" xml:space="preserve">
          <source>Output detailed information about backup blocks.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="babad7640e9f136cd19423d495f4b1ee0fee89a9" translate="yes" xml:space="preserve">
          <source>Output is always in the standard form.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7835db447bc76230b5b0d736b2d78c671d7100a1" translate="yes" xml:space="preserve">
          <source>Outputs</source>
          <target state="translated">Outputs</target>
        </trans-unit>
        <trans-unit id="cdfe59de620bc8ec7ec39dbaf869451006fe122e" translate="yes" xml:space="preserve">
          <source>Outputs information about the current database connection.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3ae7cd3ba4b5d3440099a3b3e44c0885cc411f2" translate="yes" xml:space="preserve">
          <source>Overlaps or is left of &amp;mdash; This might be better read as &amp;ldquo;does not extend to right of&amp;rdquo;. It is true when b &amp;lt;= d.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3d201e01172e474738c7662f57e70ca764bc088" translate="yes" xml:space="preserve">
          <source>Overlaps or is right of &amp;mdash; This might be better read as &amp;ldquo;does not extend to left of&amp;rdquo;. It is true when a &amp;gt;= c.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7af34d74e482413c9143a47da7e672969aed843a" translate="yes" xml:space="preserve">
          <source>Overlaps? (One point in common makes this true.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb2f163ccc20cb7388203cf1edbc6860b44ea0f0" translate="yes" xml:space="preserve">
          <source>Overloading</source>
          <target state="translated">Overloading</target>
        </trans-unit>
        <trans-unit id="a2fd113f354ec9ec1edb291682b81f94fe430ddc" translate="yes" xml:space="preserve">
          <source>Owner of the collation</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7eb54933c030e119dce1086dc82e09c41077f94" translate="yes" xml:space="preserve">
          <source>Owner of the configuration</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a47511340c90f2c223a36694793ee22b0651e345" translate="yes" xml:space="preserve">
          <source>Owner of the conversion</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9adb637b26bc7a0111112afdc905c0fa9b433b1f" translate="yes" xml:space="preserve">
          <source>Owner of the database, usually the user who created it</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e1395f6076a153ad4fcc55b23348741788d9a0e" translate="yes" xml:space="preserve">
          <source>Owner of the dictionary</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="873852f61944660a0d123bafc40c1182f58cd2a5" translate="yes" xml:space="preserve">
          <source>Owner of the event trigger</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e618675166fd8eccc064277b88953a8fdc0951cf" translate="yes" xml:space="preserve">
          <source>Owner of the extended statistics</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e0062122acfc3428eb36e8494aa91cdda1bb823" translate="yes" xml:space="preserve">
          <source>Owner of the extension</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b3fd58bbcd1cbede99d727eb332a616ef746459" translate="yes" xml:space="preserve">
          <source>Owner of the foreign server</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4abeec384f4e4e4fd2630496e361931c03792e90" translate="yes" xml:space="preserve">
          <source>Owner of the foreign-data wrapper</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="045ebe36026cc33372375251adb04267dd08a6f9" translate="yes" xml:space="preserve">
          <source>Owner of the function</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3de3b296802701c83666e4a9e6c77ad8e092b09c" translate="yes" xml:space="preserve">
          <source>Owner of the language</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f358242f17294414495cbc231ac35ed8a7ef36f" translate="yes" xml:space="preserve">
          <source>Owner of the large object</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08c133834660a3f3265245c9248f60f1979449d5" translate="yes" xml:space="preserve">
          <source>Owner of the namespace</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3d409145414a207ad5ab1a06298cf4de3e3d79d" translate="yes" xml:space="preserve">
          <source>Owner of the operator</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4fe1d02890b80f29d14de9cf7c7d720b98ec4436" translate="yes" xml:space="preserve">
          <source>Owner of the operator class</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34a092b8bf19aa76f83af3f5f7f00fd4abe9f1da" translate="yes" xml:space="preserve">
          <source>Owner of the operator family</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="530840c2bedf8afbc58ec145a817bd5855b5da2c" translate="yes" xml:space="preserve">
          <source>Owner of the publication</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f104f465825a18941861fe36eee16972af35d0fd" translate="yes" xml:space="preserve">
          <source>Owner of the relation</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2d338d2c9f46fc9058acd6bf8b505d62cfd7125" translate="yes" xml:space="preserve">
          <source>Owner of the statistics object</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27aa59e6a53863d7fc75c728e631589d9ef875ce" translate="yes" xml:space="preserve">
          <source>Owner of the subscription</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ca261d2ecfb68a9f64ba043ec469131179f4f2d" translate="yes" xml:space="preserve">
          <source>Owner of the tablespace, usually the user who created it</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="451938c2f2732dd84e3e87dd05cdd4be024d9498" translate="yes" xml:space="preserve">
          <source>Owner of the type</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a88ac00bf4b0ee2c311712a067ae74712fb2321" translate="yes" xml:space="preserve">
          <source>Ownership of objects can be transferred one at a time using &lt;code&gt;ALTER&lt;/code&gt; commands, for example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="880684f9ec2b7a622ac555da2f5f06938c962c51" translate="yes" xml:space="preserve">
          <source>P''(t)</source>
          <target state="translated">P''(t)</target>
        </trans-unit>
        <trans-unit id="6c4b4caa40b248d284230f88cbcd7f13476b2cac" translate="yes" xml:space="preserve">
          <source>P(t)</source>
          <target state="translated">P(t)</target>
        </trans-unit>
        <trans-unit id="f8475eae73fea7de999190d28ead30c11cd46b3b" translate="yes" xml:space="preserve">
          <source>P-1Y-2M3DT-4H-5M-6S</source>
          <target state="translated">P-1Y-2M3DT-4H-5M-6S</target>
        </trans-unit>
        <trans-unit id="c066b74bc2c03f3472bba6e63d39e90c2e2d20c7" translate="yes" xml:space="preserve">
          <source>P0001-02-03T04:05:06</source>
          <target state="translated">P0001-02-03T04:05:06</target>
        </trans-unit>
        <trans-unit id="579e8ed8bf53a5860299c4787471ee73ec431b5e" translate="yes" xml:space="preserve">
          <source>P1Y2M</source>
          <target state="translated">P1Y2M</target>
        </trans-unit>
        <trans-unit id="bd1aaf321a587301c665f6a19e72881af023a930" translate="yes" xml:space="preserve">
          <source>P1Y2M3DT4H5M6S</source>
          <target state="translated">P1Y2M3DT4H5M6S</target>
        </trans-unit>
        <trans-unit id="9ba0b6685e5baca573f3acd95f81a092797985f3" translate="yes" xml:space="preserve">
          <source>P3DT4H5M6S</source>
          <target state="translated">P3DT4H5M6S</target>
        </trans-unit>
        <trans-unit id="1dc752ba52c4ea05107706b7e03df6ab354e39ff" translate="yes" xml:space="preserve">
          <source>PAM</source>
          <target state="translated">PAM</target>
        </trans-unit>
        <trans-unit id="388c2af7f59c6eee722356ebc329cec67a8389d7" translate="yes" xml:space="preserve">
          <source>PAM Authentication</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e8eaf2f87853067037437397fcd30a4aa337b20" translate="yes" xml:space="preserve">
          <source>PAM service name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0bfd8f66160aa4b77dcdec5d43e4805495e07e18" translate="yes" xml:space="preserve">
          <source>PGP Public-Key encryption</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76646f05da6bf5eb4fecf712e1a4c9bffc428604" translate="yes" xml:space="preserve">
          <source>PGP Symmetric encryption</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e09cf6b34360609cb4cdd2c5b437e8b7854a05d" translate="yes" xml:space="preserve">
          <source>PGSQL</source>
          <target state="translated">PGSQL</target>
        </trans-unit>
        <trans-unit id="3ba27c9c3666ed10b53aa3320fe270149336d75a" translate="yes" xml:space="preserve">
          <source>PGXS</source>
          <target state="translated">PGXS</target>
        </trans-unit>
        <trans-unit id="dde57e820d65c87a0777da46aba7cd35a0c8436a" translate="yes" xml:space="preserve">
          <source>PID</source>
          <target state="translated">PID</target>
        </trans-unit>
        <trans-unit id="feee1d9b13144a255359aea6e303897e613b068c" translate="yes" xml:space="preserve">
          <source>PITR</source>
          <target state="translated">PITR</target>
        </trans-unit>
        <trans-unit id="3238a2c23ec52b54d1a9d62034bcdec3628b7db6" translate="yes" xml:space="preserve">
          <source>PL</source>
          <target state="translated">PL</target>
        </trans-unit>
        <trans-unit id="beec5d503ed58c40992ce7fab4af575b48a55538" translate="yes" xml:space="preserve">
          <source>PL/pgSQL handles output parameters in &lt;code&gt;CALL&lt;/code&gt; commands differently; see &lt;a href=&quot;https://www.postgresql.org/docs/12/plpgsql-control-structures.html#PLPGSQL-STATEMENTS-CALLING-PROCEDURE&quot;&gt;Section 42.6.3&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23507e798d66fee0b05313c2a15e15ff93e82f20" translate="yes" xml:space="preserve">
          <source>POSIX</source>
          <target state="translated">POSIX</target>
        </trans-unit>
        <trans-unit id="f586c4a0642bd8530bd206b6d1e6d9b7d935f68f" translate="yes" xml:space="preserve">
          <source>POSIX interprets character classes such as &lt;code&gt;\w&lt;/code&gt; (see &lt;a href=&quot;functions-matching#POSIX-CLASS-SHORTHAND-ESCAPES-TABLE&quot;&gt;Table 9.20&lt;/a&gt;) according to the prevailing locale (which you can control by attaching a &lt;code&gt;COLLATE&lt;/code&gt; clause to the operator or function). XQuery specifies these classes by reference to Unicode character properties, so equivalent behavior is obtained only with a locale that follows the Unicode rules.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e102feaa5742be5a0f3d3fc50f40fceae7d340a6" translate="yes" xml:space="preserve">
          <source>POSIX regular expressions provide a more powerful means for pattern matching than the &lt;code&gt;LIKE&lt;/code&gt; and &lt;code&gt;SIMILAR TO&lt;/code&gt; operators. Many Unix tools such as &lt;code&gt;egrep&lt;/code&gt;, &lt;code&gt;sed&lt;/code&gt;, or &lt;code&gt;awk&lt;/code&gt; use a pattern matching language that is similar to the one described here.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46e0e2f3d2a15c3b14b95e0c1c7504bef70da246" translate="yes" xml:space="preserve">
          <source>POSIX-style time zone specification</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66e2f96d2e144c19219f34885e8aed66af8ec26f" translate="yes" xml:space="preserve">
          <source>PREPARE</source>
          <target state="translated">PREPARE</target>
        </trans-unit>
        <trans-unit id="497f657a7bd6c59491c1afe2f14778a0325e0aeb" translate="yes" xml:space="preserve">
          <source>PREPARE &amp;mdash; prepare a statement for execution</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37fb488fc1130c92529c23ebb00239237637a743" translate="yes" xml:space="preserve">
          <source>PREPARE TRANSACTION</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6c4ba5ff6212b5c43bdc5722e0f091244559eda" translate="yes" xml:space="preserve">
          <source>PREPARE TRANSACTION &amp;mdash; prepare the current transaction for two-phase commit</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ddcb3afaebc491f73714dc172d37266e6be3bda" translate="yes" xml:space="preserve">
          <source>Packaging and deployment scripts should be careful to create the &lt;code&gt;postgres&lt;/code&gt; user as a system user by using &lt;code&gt;useradd -r&lt;/code&gt;, &lt;code&gt;adduser --system&lt;/code&gt;, or equivalent.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a10c2d221e8eba42e9b331576d9daca086bdfe95" translate="yes" xml:space="preserve">
          <source>Packet containing a session key &amp;mdash; either symmetric-key or public-key encrypted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe9ad910809dee7861d17df7e5f096ed938e0ab2" translate="yes" xml:space="preserve">
          <source>Packet containing data encrypted with the session key.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5dd9f751429eb18847bb4ae66caf8a2fda2b0c20" translate="yes" xml:space="preserve">
          <source>Page checksum</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10d741089ed07914a82a77ba0b90a6a76cd492d4" translate="yes" xml:space="preserve">
          <source>Page number of this page within its large object (counting from zero)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc5666da83404ee33adbe94f98f1c6ba4503d3c8" translate="yes" xml:space="preserve">
          <source>Page number targeted by the lock within the relation, or null if the target is not a relation page or tuple</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05fe9679957eb1665689044c2d47f231b7b99aa3" translate="yes" xml:space="preserve">
          <source>Page number within the relation</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b355a7b15353314735e75b8e122c5ae1fcd5a22" translate="yes" xml:space="preserve">
          <source>Page size and layout version number information</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a03c41b78d25bf18f06cd333e2c95e267c66a660" translate="yes" xml:space="preserve">
          <source>PageHeaderData</source>
          <target state="translated">PageHeaderData</target>
        </trans-unit>
        <trans-unit id="2750093ba2a279af4331fd53d0a8cee7be245d4f" translate="yes" xml:space="preserve">
          <source>PageXLogRecPtr</source>
          <target state="translated">PageXLogRecPtr</target>
        </trans-unit>
        <trans-unit id="d90de0896be6c5efa3c782fa286f1c3cdb9a7b50" translate="yes" xml:space="preserve">
          <source>Parallel Plans</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="686414fccc150dceb0e9f56ace196fdc729a14bb" translate="yes" xml:space="preserve">
          <source>Parallel Plans: Parallel Aggregation</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b75e7cdb23627ee4086ddf3246e9c894f0ce11d0" translate="yes" xml:space="preserve">
          <source>Parallel Plans: Parallel Append</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="976b16b543b8304722b64b1a24c59b4c0b79488f" translate="yes" xml:space="preserve">
          <source>Parallel Plans: Parallel Joins</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9010e7d56024ae4a3d31f2d2290191dd0b36e537" translate="yes" xml:space="preserve">
          <source>Parallel Plans: Parallel Plan Tips</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="039109d587d0e62745986a2cf6f26a04992e1351" translate="yes" xml:space="preserve">
          <source>Parallel Plans: Parallel Scans</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cfafb44924e6a5f388ef259a64814a132f966833" translate="yes" xml:space="preserve">
          <source>Parallel Query</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82124baa3b5560bbd5720a4765dc2466961bc53a" translate="yes" xml:space="preserve">
          <source>Parallel Safety</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0fe56d7979154496310d56ea233bf1c11643ddc4" translate="yes" xml:space="preserve">
          <source>Parallel Safety: Parallel Labeling for Functions and Aggregates</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ab3e8fa2d7856e75083b2a36c41793361958622" translate="yes" xml:space="preserve">
          <source>Parallel aggregation is not supported in all situations. Each aggregate must be &lt;a href=&quot;parallel-safety&quot;&gt;safe&lt;/a&gt; for parallelism and must have a combine function. If the aggregate has a transition state of type &lt;code&gt;internal&lt;/code&gt;, it must have serialization and deserialization functions. See &lt;a href=&quot;sql-createaggregate&quot;&gt;CREATE AGGREGATE&lt;/a&gt; for more details. Parallel aggregation is not supported if any aggregate function call contains &lt;code&gt;DISTINCT&lt;/code&gt; or &lt;code&gt;ORDER BY&lt;/code&gt; clause and is also not supported for ordered set aggregates or when the query involves &lt;code&gt;GROUPING SETS&lt;/code&gt;. It can only be used when all joins involved in the query are also part of the parallel portion of the plan.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04d6d9331b5a5aaad9590228fe97b2a4cfe26295" translate="yes" xml:space="preserve">
          <source>Parallel index builds may benefit from increasing &lt;code&gt;maintenance_work_mem&lt;/code&gt; where an equivalent serial index build will see little or no benefit. Note that &lt;code&gt;maintenance_work_mem&lt;/code&gt; may influence the number of worker processes requested, since parallel workers must have at least a &lt;code&gt;32MB&lt;/code&gt; share of the total &lt;code&gt;maintenance_work_mem&lt;/code&gt; budget. There must also be a remaining &lt;code&gt;32MB&lt;/code&gt; share for the leader process. Increasing &lt;a href=&quot;runtime-config-resource#GUC-MAX-PARALLEL-WORKERS-MAINTENANCE&quot;&gt;max_parallel_maintenance_workers&lt;/a&gt; may allow more workers to be used, which will reduce the time needed for index creation, so long as the index build is not already I/O bound. Of course, there should also be sufficient CPU capacity that would otherwise lie idle.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f699f295e5ae4ac633cfa18437fed38d028b3fdb" translate="yes" xml:space="preserve">
          <source>Parameter</source>
          <target state="translated">Parameter</target>
        </trans-unit>
        <trans-unit id="09be2449f5c7874ea156950916c870b9f0c9269d" translate="yes" xml:space="preserve">
          <source>Parameter type (&lt;code&gt;bool&lt;/code&gt;, &lt;code&gt;enum&lt;/code&gt;, &lt;code&gt;integer&lt;/code&gt;, &lt;code&gt;real&lt;/code&gt;, or &lt;code&gt;string&lt;/code&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="044b6f8bb6500f64950a5a00b3fc891db56006e8" translate="yes" xml:space="preserve">
          <source>Parameter value assumed at server startup if the parameter is not otherwise set</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a975eea30db9fa05003e3b5097688bd49ec7e01b" translate="yes" xml:space="preserve">
          <source>Parameters</source>
          <target state="translated">Parameters</target>
        </trans-unit>
        <trans-unit id="2f389ed6f97b68ab045fe7feae01a113660deba4" translate="yes" xml:space="preserve">
          <source>Parameters - &lt;code&gt;SHOW&lt;/code&gt;, &lt;code&gt;SET&lt;/code&gt;, &lt;code&gt;RESET&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d605d3acb20f72158d3fdf0384d4816df27da77" translate="yes" xml:space="preserve">
          <source>Parameters set in this way provide default values for the cluster. The settings seen by active sessions will be these values unless they are overridden. The following sections describe ways in which the administrator or user can override these defaults.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9c46bf34fcbc732066fd8d85a736b2f71975d85" translate="yes" xml:space="preserve">
          <source>Parentheses (&lt;code&gt;()&lt;/code&gt;) have their usual meaning to group expressions and enforce precedence. In some cases parentheses are required as part of the fixed syntax of a particular SQL command.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98e95b8350c1e439f335fb041362e108a0725712" translate="yes" xml:space="preserve">
          <source>Parentheses &lt;code&gt;()&lt;/code&gt; can be used to group items into a single logical item.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6bd6d9306fafc7f371b0f3c8451bd6a999eda172" translate="yes" xml:space="preserve">
          <source>Parentheses are used to resolve ambiguities. In the following example, the first statement assigns the alias &lt;code&gt;b&lt;/code&gt; to the second instance of &lt;code&gt;my_table&lt;/code&gt;, but the second statement assigns the alias to the result of the join:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a18942798320d682a81a99742ced66e1f7dcd4f" translate="yes" xml:space="preserve">
          <source>Parentheses can be used to control nesting of the &lt;code&gt;tsquery&lt;/code&gt; operators. Without parentheses, &lt;code&gt;|&lt;/code&gt; binds least tightly, then &lt;code&gt;&amp;amp;&lt;/code&gt;, then &lt;code&gt;&amp;lt;-&amp;gt;&lt;/code&gt;, and &lt;code&gt;!&lt;/code&gt; most tightly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0de9a8d461cec2b96e138a5742063451fce829dd" translate="yes" xml:space="preserve">
          <source>Parentheses can be used to enforce grouping of these operators. In the absence of parentheses, &lt;code&gt;!&lt;/code&gt; (NOT) binds most tightly, &lt;code&gt;&amp;lt;-&amp;gt;&lt;/code&gt; (FOLLOWED BY) next most tightly, then &lt;code&gt;&amp;amp;&lt;/code&gt; (AND), with &lt;code&gt;|&lt;/code&gt; (OR) binding the least tightly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1050a7f51685a531fe35b29d9845b1171bb5126c" translate="yes" xml:space="preserve">
          <source>Parentheses, which can be used to provide filter expressions or define the order of path evaluation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dde89c96be949ecdb36498952ab75fb083c95513" translate="yes" xml:space="preserve">
          <source>Parse and validate the reloptions array for an index. This is called only when a non-null reloptions array exists for the index. &lt;em&gt;&lt;code&gt;reloptions&lt;/code&gt;&lt;/em&gt; is a &lt;code&gt;text&lt;/code&gt; array containing entries of the form &lt;code&gt;name&lt;/code&gt;&lt;code&gt;=&lt;/code&gt;&lt;code&gt;value&lt;/code&gt;. The function should construct a &lt;code&gt;bytea&lt;/code&gt; value, which will be copied into the &lt;code&gt;rd_options&lt;/code&gt; field of the index's relcache entry. The data contents of the &lt;code&gt;bytea&lt;/code&gt; value are open for the access method to define; most of the standard access methods use struct &lt;code&gt;StdRdOptions&lt;/code&gt;. When &lt;em&gt;&lt;code&gt;validate&lt;/code&gt;&lt;/em&gt; is true, the function should report a suitable error message if any of the options are unrecognized or have invalid values; when &lt;em&gt;&lt;code&gt;validate&lt;/code&gt;&lt;/em&gt; is false, invalid entries should be silently ignored. (&lt;em&gt;&lt;code&gt;validate&lt;/code&gt;&lt;/em&gt; is false when loading options already stored in &lt;code&gt;pg_catalog&lt;/code&gt;; an invalid entry could only be found if the access method has changed its rules for options, and in that case ignoring obsolete entries is appropriate.) It is OK to return NULL if default behavior is wanted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e963287c4fec77476e5d1bf8476b1e7cc102ae88" translate="yes" xml:space="preserve">
          <source>Parse system include files as well.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c8772d05d1a8b9d8d78cf0c1c4a6eb499eca0c8" translate="yes" xml:space="preserve">
          <source>Parser Stage</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="efdb99a054fb37fae9696b10ed15efeeb9f36b28" translate="yes" xml:space="preserve">
          <source>Parsers</source>
          <target state="translated">Parsers</target>
        </trans-unit>
        <trans-unit id="b58d58ace5fa0761b582d29360f9eac7d42ba9f0" translate="yes" xml:space="preserve">
          <source>Parsing for arguments stops at the end of the line, or when another unquoted backslash is found. An unquoted backslash is taken as the beginning of a new meta-command. The special sequence &lt;code&gt;\\&lt;/code&gt; (two backslashes) marks the end of arguments and continues parsing SQL commands, if any. That way SQL and psql commands can be freely mixed on a line. But in any case, the arguments of a meta-command cannot continue beyond the end of the line.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07c159051320590e27d53f2ca68bc5552c059bb0" translate="yes" xml:space="preserve">
          <source>Part II. The SQL Language</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed99b73ba1d17331570cbb8c11cb9612833219a4" translate="yes" xml:space="preserve">
          <source>Part III. Server Administration</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="233b8f2c1ff53528b0a2395bfd96a5533e5bf211" translate="yes" xml:space="preserve">
          <source>Part VII. Internals</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c0b1424932f39a83140c4ab14b4b9ddde6b4f52" translate="yes" xml:space="preserve">
          <source>Part VIII. Appendixes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53657ace24d508d9d61d6689474a05a11f116ca4" translate="yes" xml:space="preserve">
          <source>Partial (including parallel) aggregation is currently not supported for ordered-set aggregates. Also, it will never be used for aggregate calls that include &lt;code&gt;DISTINCT&lt;/code&gt; or &lt;code&gt;ORDER BY&lt;/code&gt; clauses, since those semantics cannot be supported during partial aggregation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6893b79566df0f4ab433d9b0d800d95d1637ec25" translate="yes" xml:space="preserve">
          <source>Partial Indexes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21eb60b5918acacccb4909c31bcd93a4758e3020" translate="yes" xml:space="preserve">
          <source>Partial Mode</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7fabd14af4eb6ccfa3f503f4e268b2ad2693497" translate="yes" xml:space="preserve">
          <source>Partial indexes also have interesting interactions with index-only scans. Consider the partial index shown in &lt;a href=&quot;indexes-partial#INDEXES-PARTIAL-EX3&quot;&gt;Example 11.3&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a5ba09370f100d4b05c522688c9cba42e037f6a" translate="yes" xml:space="preserve">
          <source>Partition pruning can be disabled using the &lt;a href=&quot;runtime-config-query#GUC-ENABLE-PARTITION-PRUNING&quot;&gt;enable_partition_pruning&lt;/a&gt; setting.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2325b1acc0d3782c122e1bc1c9eed9984fc2f19a" translate="yes" xml:space="preserve">
          <source>Partition pruning can be performed not only during the planning of a given query, but also during its execution. This is useful as it can allow more partitions to be pruned when clauses contain expressions whose values are not known at query planning time, for example, parameters defined in a &lt;code&gt;PREPARE&lt;/code&gt; statement, using a value obtained from a subquery, or using a parameterized value on the inner side of a nested loop join. Partition pruning during execution can be performed at any of the following times:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25be32546f15fa3443a67e839c875e6c98ffb53d" translate="yes" xml:space="preserve">
          <source>Partitioned tables do not support &lt;code&gt;EXCLUDE&lt;/code&gt; constraints; however, you can define these constraints on individual partitions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cdd1ab913d96a23c99606f41fe3792bb2b1fe894" translate="yes" xml:space="preserve">
          <source>Partitioning of big collections and the proper use of GIN and GiST indexes allows the implementation of very fast searches with online update. Partitioning can be done at the database level using table inheritance, or by distributing documents over servers and collecting external search results, e.g. via &lt;a href=&quot;ddl-foreign-data&quot;&gt;Foreign Data&lt;/a&gt; access. The latter is possible because ranking functions use only local information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de0bffd921d00f01c704a415da77618af1ad1157" translate="yes" xml:space="preserve">
          <source>Partitioning refers to splitting what is logically one large table into smaller physical pieces. Partitioning can provide several benefits:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c73b5aa4d6c05a53fb97d25c9d92f2517cfd521" translate="yes" xml:space="preserve">
          <source>Partitioning strategy; &lt;code&gt;h&lt;/code&gt; = hash partitioned table, &lt;code&gt;l&lt;/code&gt; = list partitioned table, &lt;code&gt;r&lt;/code&gt; = range partitioned table</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac39e0014a08ee6c92f0e5cdb5959d966b4de171" translate="yes" xml:space="preserve">
          <source>Partitions can also be foreign tables, although they have some limitations that normal tables do not; see &lt;a href=&quot;sql-createforeigntable&quot;&gt;CREATE FOREIGN TABLE&lt;/a&gt; for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="742a14b2e0099a02fc2828373fdc246b43a7d658" translate="yes" xml:space="preserve">
          <source>Partitions cannot have columns that are not present in the parent. It is not possible to specify columns when creating partitions with &lt;code&gt;CREATE TABLE&lt;/code&gt;, nor is it possible to add columns to partitions after-the-fact using &lt;code&gt;ALTER TABLE&lt;/code&gt;. Tables may be added as a partition with &lt;code&gt;ALTER TABLE ... ATTACH PARTITION&lt;/code&gt; only if their columns exactly match the parent.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90542a9f44eb209be50c576524ab51cf75180838" translate="yes" xml:space="preserve">
          <source>Partitions may themselves be defined as partitioned tables, using what is called &lt;em&gt;sub-partitioning&lt;/em&gt;. Partitions may have their own indexes, constraints and default values, distinct from those of other partitions. See &lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE&lt;/a&gt; for more details on creating partitioned tables and partitions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0fe4b4dd2ad3e0c4391acf69fe76d976b85276f5" translate="yes" xml:space="preserve">
          <source>Partitions thus created are in every way normal PostgreSQL tables (or, possibly, foreign tables). It is possible to specify a tablespace and storage parameters for each partition separately.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88b62432a05ee62c1b6215e5aa74e2720815cc44" translate="yes" xml:space="preserve">
          <source>Parts of the GEQO module are adapted from D. Whitley's Genitor algorithm.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1c5d9114d4f8eeeec0857bd19317d948e267875" translate="yes" xml:space="preserve">
          <source>Pass the option &lt;code&gt;name&lt;/code&gt; to the output plugin with, if specified, the option value &lt;code&gt;value&lt;/code&gt;. Which options exist and their effects depends on the used output plugin.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="adee4d3938c90062826aa15c6cd38c8f321a8960" translate="yes" xml:space="preserve">
          <source>Password (possibly encrypted); null if none. See &lt;a href=&quot;catalog-pg-authid&quot;&gt;&lt;code&gt;pg_authid&lt;/code&gt;&lt;/a&gt; for details of how encrypted passwords are stored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99366622edd98624e0f268beb5dfad9b43284c50" translate="yes" xml:space="preserve">
          <source>Password (possibly encrypted); null if none. The format depends on the form of encryption used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6148812de885ba8e1911ccd743a2dc2463667a7" translate="yes" xml:space="preserve">
          <source>Password Authentication</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8e30ae74424dc989ae9149964d67afb93a52bdb" translate="yes" xml:space="preserve">
          <source>Password Encryption</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36eca0e0aafbe2102ac86aee3d25cb85966cbaa6" translate="yes" xml:space="preserve">
          <source>Password expiry time (only used for password authentication)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de5ff361027e5b08609865471d6dc5846a389286" translate="yes" xml:space="preserve">
          <source>Password expiry time (only used for password authentication); null if no expiration</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="238db8fa438548c1928f9502d7d8e1e30eb6d531" translate="yes" xml:space="preserve">
          <source>Password for the user to run the service as.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3fa38ad80d289fe4c73a95809bdea71d6cbf450b" translate="yes" xml:space="preserve">
          <source>Password for user to bind to the directory with to perform the search when doing search+bind authentication.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d33984b00815ba0da90a3eeaeb545efb634cbde4" translate="yes" xml:space="preserve">
          <source>Path construction using functions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="463f854670c23f477bbd78e96423f8e31931e339" translate="yes" xml:space="preserve">
          <source>Path literals of JSON primitive types: Unicode text, numeric, true, false, or null.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b6339b7ad3d2b4abc5be8c19dc30583042c4165" translate="yes" xml:space="preserve">
          <source>Path of a Query</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="266a8e23c8475feda63519f1c3d2f320f2aaac65" translate="yes" xml:space="preserve">
          <source>Path of shared library that implements language</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a3675336ca9e8caece923ce6c69021ab35c9b34" translate="yes" xml:space="preserve">
          <source>Path variables listed in &lt;a href=&quot;datatype-json#TYPE-JSONPATH-VARIABLES&quot;&gt;Table 8.24&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55707d92267c5187de428b55c28d908802787d98" translate="yes" xml:space="preserve">
          <source>Paths are output using the first or second syntax, as appropriate.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d21eb60eb90443c1e0fde7a365afe587f415ae66" translate="yes" xml:space="preserve">
          <source>Paths are represented by lists of connected points. Paths can be &lt;em&gt;open&lt;/em&gt;, where the first and last points in the list are considered not connected, or &lt;em&gt;closed&lt;/em&gt;, where the first and last points are considered connected.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1fff6a31661b491fc40cc9c1ad7fe5e479cb7500" translate="yes" xml:space="preserve">
          <source>Pattern</source>
          <target state="translated">Pattern</target>
        </trans-unit>
        <trans-unit id="535ab3a1c5459ace2d0b0bcb8fc022e58a4100d9" translate="yes" xml:space="preserve">
          <source>Pattern Matching</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a43195d59d6b988e5bc825ea91ee5fa2ee54455" translate="yes" xml:space="preserve">
          <source>Pattern Matching: LIKE</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="577a01dd1c0e8f649068e70f9cf054970915cb36" translate="yes" xml:space="preserve">
          <source>Pattern Matching: POSIX Regular Expressions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1aca0dbf2888e4f1bc7d10adb1a49bb94a808a60" translate="yes" xml:space="preserve">
          <source>Pattern Matching: SIMILAR TO Regular Expressions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2cca6a6a36d34faa5c5f178fbe489846badc8fb5" translate="yes" xml:space="preserve">
          <source>Pattern matching operators (&lt;code&gt;LIKE&lt;/code&gt;, &lt;code&gt;SIMILAR TO&lt;/code&gt;, and POSIX-style regular expressions); locales affect both case insensitive matching and the classification of characters by character-class regular expressions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d34f7a2b0b3b6df62a051917d7e7ac2de8a38df" translate="yes" xml:space="preserve">
          <source>Patterns</source>
          <target state="translated">Patterns</target>
        </trans-unit>
        <trans-unit id="ca382c16294c214dbe3191677fc4669d70c86654" translate="yes" xml:space="preserve">
          <source>Pauses recovery immediately (restricted to superusers by default, but other users can be granted EXECUTE to run the function).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12a0f150ca4476ed5b576c007ac1865d1fb8bb74" translate="yes" xml:space="preserve">
          <source>Peer Authentication</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7140c44c7da9185cfa0b73cd8cc49f9de3bc1489" translate="yes" xml:space="preserve">
          <source>Peer authentication is only available on operating systems providing the &lt;code&gt;getpeereid()&lt;/code&gt; function, the &lt;code&gt;SO_PEERCRED&lt;/code&gt; socket parameter, or similar mechanisms. Currently that includes Linux, most flavors of BSD including macOS, and Solaris.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9cdd79a05b9da966c26a1f6a5e99a7a9fb8d64a3" translate="yes" xml:space="preserve">
          <source>Per-Command Policies</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed1d3a75054b9592b198ba465dda151b09c333ea" translate="yes" xml:space="preserve">
          <source>Per-Statement Latencies</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db0ae07882c18b5649ee33de907e97a3481ed614" translate="yes" xml:space="preserve">
          <source>Per-Transaction Logging</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f973c235a702ba0b4882340692bc401f9c1e7c7c" translate="yes" xml:space="preserve">
          <source>Per-index value for &lt;a href=&quot;runtime-config-client#GUC-VACUUM-CLEANUP-INDEX-SCALE-FACTOR&quot;&gt;vacuum_cleanup_index_scale_factor&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6aee541129a013df791c695dddfe4b66f3b0804a" translate="yes" xml:space="preserve">
          <source>Per-table granularity</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df6300430e05243fb8623c3dacf21a834f4ec9db" translate="yes" xml:space="preserve">
          <source>Per-table value for &lt;a href=&quot;runtime-config-autovacuum#GUC-AUTOVACUUM-ANALYZE-SCALE-FACTOR&quot;&gt;autovacuum_analyze_scale_factor&lt;/a&gt; parameter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13bcc410c7f9ecd5027e7aabb4054809e94a5637" translate="yes" xml:space="preserve">
          <source>Per-table value for &lt;a href=&quot;runtime-config-autovacuum#GUC-AUTOVACUUM-ANALYZE-THRESHOLD&quot;&gt;autovacuum_analyze_threshold&lt;/a&gt; parameter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4cc49570c37ddaf0ad982835227bdfeb5fb34fc" translate="yes" xml:space="preserve">
          <source>Per-table value for &lt;a href=&quot;runtime-config-autovacuum#GUC-AUTOVACUUM-FREEZE-MAX-AGE&quot;&gt;autovacuum_freeze_max_age&lt;/a&gt; parameter. Note that autovacuum will ignore per-table &lt;code&gt;autovacuum_freeze_max_age&lt;/code&gt; parameters that are larger than the system-wide setting (it can only be set smaller).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="adc3bbc6bde46e7a977a3d025522a0b130c2221c" translate="yes" xml:space="preserve">
          <source>Per-table value for &lt;a href=&quot;runtime-config-autovacuum#GUC-AUTOVACUUM-MULTIXACT-FREEZE-MAX-AGE&quot;&gt;autovacuum_multixact_freeze_max_age&lt;/a&gt; parameter. Note that autovacuum will ignore per-table &lt;code&gt;autovacuum_multixact_freeze_max_age&lt;/code&gt; parameters that are larger than the system-wide setting (it can only be set smaller).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52ee90bf83a221126d345af63a697f023bf7aaf2" translate="yes" xml:space="preserve">
          <source>Per-table value for &lt;a href=&quot;runtime-config-autovacuum#GUC-AUTOVACUUM-VACUUM-COST-DELAY&quot;&gt;autovacuum_vacuum_cost_delay&lt;/a&gt; parameter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8f18627239c76784b53c354db6754ba7815a1a8" translate="yes" xml:space="preserve">
          <source>Per-table value for &lt;a href=&quot;runtime-config-autovacuum#GUC-AUTOVACUUM-VACUUM-COST-LIMIT&quot;&gt;autovacuum_vacuum_cost_limit&lt;/a&gt; parameter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3dd4eed61fa80fd43095c3741dd5dd959fac77e2" translate="yes" xml:space="preserve">
          <source>Per-table value for &lt;a href=&quot;runtime-config-autovacuum#GUC-AUTOVACUUM-VACUUM-SCALE-FACTOR&quot;&gt;autovacuum_vacuum_scale_factor&lt;/a&gt; parameter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4413713442ca0dbea5e7f8130793f8e4a24e0cef" translate="yes" xml:space="preserve">
          <source>Per-table value for &lt;a href=&quot;runtime-config-autovacuum#GUC-AUTOVACUUM-VACUUM-THRESHOLD&quot;&gt;autovacuum_vacuum_threshold&lt;/a&gt; parameter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d2800f8c07e42c6c33e28d11f8d0822c4287722" translate="yes" xml:space="preserve">
          <source>Per-table value for &lt;a href=&quot;runtime-config-autovacuum#GUC-LOG-AUTOVACUUM-MIN-DURATION&quot;&gt;log_autovacuum_min_duration&lt;/a&gt; parameter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="223ad5e2d00a73119ddde400e71e2b1ba9280ccb" translate="yes" xml:space="preserve">
          <source>Per-table value for &lt;a href=&quot;runtime-config-client#GUC-VACUUM-FREEZE-MIN-AGE&quot;&gt;vacuum_freeze_min_age&lt;/a&gt; parameter. Note that autovacuum will ignore per-table &lt;code&gt;autovacuum_freeze_min_age&lt;/code&gt; parameters that are larger than half the system-wide &lt;a href=&quot;runtime-config-autovacuum#GUC-AUTOVACUUM-FREEZE-MAX-AGE&quot;&gt;autovacuum_freeze_max_age&lt;/a&gt; setting.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68a4d3118ea45821db0cebd7519f0ea146995887" translate="yes" xml:space="preserve">
          <source>Per-table value for &lt;a href=&quot;runtime-config-client#GUC-VACUUM-FREEZE-TABLE-AGE&quot;&gt;vacuum_freeze_table_age&lt;/a&gt; parameter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aed713d91e51cd08cd23d16d2810e44fceb208ef" translate="yes" xml:space="preserve">
          <source>Per-table value for &lt;a href=&quot;runtime-config-client#GUC-VACUUM-MULTIXACT-FREEZE-MIN-AGE&quot;&gt;vacuum_multixact_freeze_min_age&lt;/a&gt; parameter. Note that autovacuum will ignore per-table &lt;code&gt;autovacuum_multixact_freeze_min_age&lt;/code&gt; parameters that are larger than half the system-wide &lt;a href=&quot;runtime-config-autovacuum#GUC-AUTOVACUUM-MULTIXACT-FREEZE-MAX-AGE&quot;&gt;autovacuum_multixact_freeze_max_age&lt;/a&gt; setting.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d6a639607b9fecb0af2c41612e5b2768fa56a2e" translate="yes" xml:space="preserve">
          <source>Per-table value for &lt;a href=&quot;runtime-config-client#GUC-VACUUM-MULTIXACT-FREEZE-TABLE-AGE&quot;&gt;vacuum_multixact_freeze_table_age&lt;/a&gt; parameter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e975b3d41bbeabc6eb00c97d7e30fbafd1d2457e" translate="yes" xml:space="preserve">
          <source>Percentage of dead tuples</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0cd75c0030dceadd02cefb1f4f8cdfe1c43c19b" translate="yes" xml:space="preserve">
          <source>Percentage of free space</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="026e26a6ed3d13c32e91d16667b4fce6169c8f91" translate="yes" xml:space="preserve">
          <source>Percentage of live tuples</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20574a809cad3d22e4de78bb07a64ea3c84d8769" translate="yes" xml:space="preserve">
          <source>Percentage of table scanned</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cecafd6247612c74017c4324067017c519c963f3" translate="yes" xml:space="preserve">
          <source>Perform &amp;ldquo;full&amp;rdquo; vacuuming.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="feca8a5ed5223a5437966dd095f2b42b084450e7" translate="yes" xml:space="preserve">
          <source>Perform SCRAM-SHA-256 authentication to verify the user's password. See &lt;a href=&quot;auth-password&quot;&gt;Section 20.5&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cee9d96cd6bf238088136c000e640e78e06aa374" translate="yes" xml:space="preserve">
          <source>Perform SCRAM-SHA-256 or MD5 authentication to verify the user's password. See &lt;a href=&quot;auth-password&quot;&gt;Section 20.5&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e17faacf8a7556f475f5c4f9f96ab42fd904d29" translate="yes" xml:space="preserve">
          <source>Perform a variable assignment, like the &lt;code&gt;\set&lt;/code&gt; meta-command. Note that you must separate name and value, if any, by an equal sign on the command line. To unset a variable, leave off the equal sign. To set a variable with an empty value, use the equal sign but leave off the value. These assignments are done during command line processing, so variables that reflect connection state will get overwritten later.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b34d3d05facf882ae3a691abd30e8b6cd4a6e677" translate="yes" xml:space="preserve">
          <source>Perform just a selected set of the normal initialization steps. &lt;code&gt;init_steps&lt;/code&gt; specifies the initialization steps to be performed, using one character per step. Each step is invoked in the specified order. The default is &lt;code&gt;dtgvp&lt;/code&gt;. The available steps are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f6bc160364e3493898bf7d6bb17edbe09454bda" translate="yes" xml:space="preserve">
          <source>Perform no vacuuming before running the test. This option is &lt;em&gt;necessary&lt;/em&gt; if you are running a custom test scenario that does not include the standard tables &lt;code&gt;pgbench_accounts&lt;/code&gt;, &lt;code&gt;pgbench_branches&lt;/code&gt;, &lt;code&gt;pgbench_history&lt;/code&gt;, and &lt;code&gt;pgbench_tellers&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a366494657843694e57b5bad59c50324f01a651" translate="yes" xml:space="preserve">
          <source>Perform no vacuuming during initialization. (This option suppresses the &lt;code&gt;v&lt;/code&gt; initialization step, even if it was specified in &lt;code&gt;-I&lt;/code&gt;.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae7a93c9cfd5aa5e2e72b1ed16236cb5de67de61" translate="yes" xml:space="preserve">
          <source>Perform the backup, using any convenient file-system-backup tool such as tar or cpio (not pg_dump or pg_dumpall). It is neither necessary nor desirable to stop normal operation of the database while you do this. See &lt;a href=&quot;continuous-archiving#BACKUP-LOWLEVEL-BASE-BACKUP-DATA&quot;&gt;Section 25.3.3.3&lt;/a&gt; for things to consider during this backup.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0828d0154023185a4f3f08252e7050a26fc998a" translate="yes" xml:space="preserve">
          <source>Perform the same operation and return the updated entries:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca80079033f0036f2ec138c62dcdab998ede3b1d" translate="yes" xml:space="preserve">
          <source>Perform the same operation, using a sub-select in the &lt;code&gt;WHERE&lt;/code&gt; clause:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d4af32e4acc11996347bfaec82c71604728dd29" translate="yes" xml:space="preserve">
          <source>Performance Tips</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc8d14b954dfe439eb5ef6988b32004ef49622c0" translate="yes" xml:space="preserve">
          <source>Performs a frontend (client) copy. This is an operation that runs an SQL &lt;a href=&quot;sql-copy&quot;&gt;COPY&lt;/a&gt; command, but instead of the server reading or writing the specified file, psql reads or writes the file and routes the data between the server and the local file system. This means that file accessibility and privileges are those of the local user, not the server, and no SQL superuser privileges are required.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c344e1248da1978bc3644d43b9d891fff2e39be" translate="yes" xml:space="preserve">
          <source>Peter Eisentraut &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:peter_e@gmx.net&quot;&gt;peter_e@gmx.net&lt;/a&gt;&amp;gt;&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da078a3d051b083b829b48a189bf09b75dac6cd7" translate="yes" xml:space="preserve">
          <source>Peter Mount &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:peter@retep.org.uk&quot;&gt;peter@retep.org.uk&lt;/a&gt;&amp;gt;&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac972e7b24283f21a917e63d12ab81c028b6b619" translate="yes" xml:space="preserve">
          <source>Phantom Read</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6371a4980dacd0f821ddeb75bac77ae4886ba72" translate="yes" xml:space="preserve">
          <source>Phase</source>
          <target state="translated">Phase</target>
        </trans-unit>
        <trans-unit id="042205072874b99f497a9509acb6db1b05f17fb3" translate="yes" xml:space="preserve">
          <source>Physical Storage: Database File Layout</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3fc82c3858fa9eb0fe848a4e73244b155ecf922b" translate="yes" xml:space="preserve">
          <source>Physical Storage: Database Page Layout</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb5882e77d3988624189c0ed4e594bfe45615e1a" translate="yes" xml:space="preserve">
          <source>Physical Storage: Free Space Map</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1aa3f80bb2e1afaf99e1bd935f3605582854ea4b" translate="yes" xml:space="preserve">
          <source>Physical Storage: Initialization Fork</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="365026e65b63752c65e5cd29c199d84c6b17ab3e" translate="yes" xml:space="preserve">
          <source>Physical Storage: TOAST</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b725586447f2023155afd853eb7071d04362c03" translate="yes" xml:space="preserve">
          <source>Physical Storage: Visibility Map</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27e67533896359d51a605428384ec08a0b4ccbfe" translate="yes" xml:space="preserve">
          <source>Physical relation length in bytes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53d91fab1719e32b08f04ca110073dde614b240a" translate="yes" xml:space="preserve">
          <source>Physical relation length in bytes (exact)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d0ec6f0ef721a8a8cb1c82f207caf7adfca229f" translate="yes" xml:space="preserve">
          <source>Place the database cluster's data directory in a memory-backed file system (i.e. RAM disk). This eliminates all database disk I/O, but limits data storage to the amount of available memory (and perhaps swap).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eeb237570f0f7f892d4ed491876f26dd479a782a" translate="yes" xml:space="preserve">
          <source>Placing &lt;code&gt;ORDER BY&lt;/code&gt; within the aggregate's regular argument list, as described so far, is used when ordering the input rows for general-purpose and statistical aggregates, for which ordering is optional. There is a subclass of aggregate functions called &lt;em&gt;ordered-set aggregates&lt;/em&gt; for which an &lt;code&gt;order_by_clause&lt;/code&gt; is &lt;em&gt;required&lt;/em&gt;, usually because the aggregate's computation is only sensible in terms of a specific ordering of its input rows. Typical examples of ordered-set aggregates include rank and percentile calculations. For an ordered-set aggregate, the &lt;code&gt;order_by_clause&lt;/code&gt; is written inside &lt;code&gt;WITHIN GROUP (...)&lt;/code&gt;, as shown in the final syntax alternative above. The expressions in the &lt;code&gt;order_by_clause&lt;/code&gt; are evaluated once per input row just like regular aggregate arguments, sorted as per the &lt;code&gt;order_by_clause&lt;/code&gt;'s requirements, and fed to the aggregate function as input arguments. (This is unlike the case for a non-&lt;code&gt;WITHIN GROUP&lt;/code&gt;&lt;code&gt;order_by_clause&lt;/code&gt;, which is not treated as argument(s) to the aggregate function.) The argument expressions preceding &lt;code&gt;WITHIN GROUP&lt;/code&gt;, if any, are called &lt;em&gt;direct arguments&lt;/em&gt; to distinguish them from the &lt;em&gt;aggregated arguments&lt;/em&gt; listed in the &lt;code&gt;order_by_clause&lt;/code&gt;. Unlike regular aggregate arguments, direct arguments are evaluated only once per aggregate call, not once per input row. This means that they can contain variables only if those variables are grouped by &lt;code&gt;GROUP BY&lt;/code&gt;; this restriction is the same as if the direct arguments were not inside an aggregate expression at all. Direct arguments are typically used for things like percentile fractions, which only make sense as a single value per aggregation calculation. The direct argument list can be empty; in this case, write just &lt;code&gt;()&lt;/code&gt; not &lt;code&gt;(*)&lt;/code&gt;. (PostgreSQL will actually accept either spelling, but only the first way conforms to the SQL standard.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="050a736fd59911f8226167a2c6f31c24c2830d29" translate="yes" xml:space="preserve">
          <source>Placing the function in a &lt;code&gt;LATERAL&lt;/code&gt;&lt;code&gt;FROM&lt;/code&gt; item keeps it from being invoked more than once per row. &lt;code&gt;m.*&lt;/code&gt; is still expanded into &lt;code&gt;m.a, m.b, m.c&lt;/code&gt;, but now those variables are just references to the output of the &lt;code&gt;FROM&lt;/code&gt; item. (The &lt;code&gt;LATERAL&lt;/code&gt; keyword is optional here, but we show it to clarify that the function is getting &lt;code&gt;x&lt;/code&gt; from &lt;code&gt;some_table&lt;/code&gt;.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4a1219ff91be25a0770f7df590b928d12b8a2c5" translate="yes" xml:space="preserve">
          <source>Plain &lt;code&gt;VACUUM&lt;/code&gt; (without &lt;code&gt;FULL&lt;/code&gt;) simply reclaims space and makes it available for re-use. This form of the command can operate in parallel with normal reading and writing of the table, as an exclusive lock is not obtained. However, extra space is not returned to the operating system (in most cases); it's just kept available for re-use within the same table. &lt;code&gt;VACUUM FULL&lt;/code&gt; rewrites the entire contents of the table into a new disk file with no extra space, allowing unused space to be returned to the operating system. This form is much slower and requires an exclusive lock on each table while it is being processed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8499132893d83a3f2ae11d9668e227a0e6596484" translate="yes" xml:space="preserve">
          <source>Plain &lt;code&gt;VACUUM&lt;/code&gt; may not be satisfactory when a table contains large numbers of dead row versions as a result of massive update or delete activity. If you have such a table and you need to reclaim the excess disk space it occupies, you will need to use &lt;code&gt;VACUUM FULL&lt;/code&gt;, or alternatively &lt;a href=&quot;sql-cluster&quot;&gt;CLUSTER&lt;/a&gt; or one of the table-rewriting variants of &lt;a href=&quot;sql-altertable&quot;&gt;ALTER TABLE&lt;/a&gt;. These commands rewrite an entire new copy of the table and build new indexes for it. All these options require exclusive lock. Note that they also temporarily use extra disk space approximately equal to the size of the table, since the old copies of the table and indexes can't be released until the new ones are complete.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9dba597737e71648392c996cea122250f0bead7" translate="yes" xml:space="preserve">
          <source>Plan nodes to which an &lt;code&gt;InitPlan&lt;/code&gt; is attached.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2bae7f24c9eebd1039795f1be6ffdf3da89d373b" translate="yes" xml:space="preserve">
          <source>Plan nodes which reference a correlated &lt;code&gt;SubPlan&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd8eca8ef866c5503502580ce3a00558f59a9928" translate="yes" xml:space="preserve">
          <source>Plannable queries (that is, &lt;code&gt;SELECT&lt;/code&gt;, &lt;code&gt;INSERT&lt;/code&gt;, &lt;code&gt;UPDATE&lt;/code&gt;, and &lt;code&gt;DELETE&lt;/code&gt;) are combined into a single &lt;code&gt;pg_stat_statements&lt;/code&gt; entry whenever they have identical query structures according to an internal hash calculation. Typically, two queries will be considered the same for this purpose if they are semantically equivalent except for the values of literal constants appearing in the query. Utility commands (that is, all other commands) are compared strictly on the basis of their textual query strings, however.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c065dbb4470e9d21b7a921d317fd42a4a204fc8" translate="yes" xml:space="preserve">
          <source>Planner Statistics and Security</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20ef8925a22326d996284c55f97493dce8cb35b8" translate="yes" xml:space="preserve">
          <source>Planner/Optimizer</source>
          <target state="translated">Planner/Optimizer</target>
        </trans-unit>
        <trans-unit id="88b7699abe5df4b9c91f2b6e5ea1aabcde7ea7fc" translate="yes" xml:space="preserve">
          <source>Plans and resources - &lt;code&gt;PREPARE&lt;/code&gt;, &lt;code&gt;EXECUTE&lt;/code&gt;, &lt;code&gt;DEALLOCATE&lt;/code&gt;, &lt;code&gt;DISCARD&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60e74c5b37f496e9f5820d20828439504e47ddb6" translate="yes" xml:space="preserve">
          <source>Please enter all the commands shown above so you have some data to work with in the following sections.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a932052bd8c1c2c9d99c8557aa55ac6cb1e71319" translate="yes" xml:space="preserve">
          <source>Please note that you may see some or all of the following notifications depending on the particular versions you have of libselinux and selinux-policy:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0db2f66cabcb72c7d5c5552d7794e37b6384e5d6" translate="yes" xml:space="preserve">
          <source>Please note the following points when using the generic WAL record facility:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86f9d988d7b8b2829ff9e18a117a22f3c6c12cda" translate="yes" xml:space="preserve">
          <source>Pluggable Authentication Modules</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3dfb3c336b3693041700e2e10c00427b27b0180f" translate="yes" xml:space="preserve">
          <source>Plugins and extensions - &lt;code&gt;LOAD&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="efefb1be830f67be53a399ad23055160dfbce160" translate="yes" xml:space="preserve">
          <source>Plus operator that iterates over the SQL/JSON sequence</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65afde293357ae741287178244c36bbcce3cc736" translate="yes" xml:space="preserve">
          <source>Point on a plane</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="609adbe0655f07f14c79208d551f8d9718fabd23" translate="yes" xml:space="preserve">
          <source>Point or box of intersection</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09812b4d0aeaa487df4bde731b3996675a249aaa" translate="yes" xml:space="preserve">
          <source>Points are output using the first syntax.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44c9844a5c8235f295a2612b30b79553235db5c0" translate="yes" xml:space="preserve">
          <source>Points are the fundamental two-dimensional building block for geometric types. Values of type &lt;code&gt;point&lt;/code&gt; are specified using either of the following syntaxes:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f6158e808f6832883a61fff6f7473e7ffa8d937" translate="yes" xml:space="preserve">
          <source>Points to note:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da968837807c4a4627a6c38281eebcac2e2aa0b7" translate="yes" xml:space="preserve">
          <source>Policies are created using the &lt;a href=&quot;sql-createpolicy&quot;&gt;CREATE POLICY&lt;/a&gt; command, altered using the &lt;a href=&quot;sql-alterpolicy&quot;&gt;ALTER POLICY&lt;/a&gt; command, and dropped using the &lt;a href=&quot;sql-droppolicy&quot;&gt;DROP POLICY&lt;/a&gt; command. To enable and disable row security for a given table, use the &lt;a href=&quot;sql-altertable&quot;&gt;ALTER TABLE&lt;/a&gt; command.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1624c281a60434d712e179fdb6ff898796130b43" translate="yes" xml:space="preserve">
          <source>Policies can be applied for specific commands or for specific roles. The default for newly created policies is that they apply for all commands and roles, unless otherwise specified. Multiple policies may apply to a single command; see below for more details. &lt;a href=&quot;sql-createpolicy#SQL-CREATEPOLICY-SUMMARY&quot;&gt;Table 256&lt;/a&gt; summarizes how the different types of policy apply to specific commands.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9218496f73981d3e04361890ce5e81c103eeff2b" translate="yes" xml:space="preserve">
          <source>Policies stored in &lt;code&gt;pg_policy&lt;/code&gt; are applied only when &lt;code&gt;pg_class&lt;/code&gt;.&lt;code&gt;relrowsecurity&lt;/code&gt; is set for their table.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64fe90225d9ffc87de024a67667003d6e6192eb8" translate="yes" xml:space="preserve">
          <source>Policy names are per-table. Therefore, one policy name can be used for many different tables and have a definition for each table which is appropriate to that table.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a028a9272b54da3da6db504ed096a2910de4d948" translate="yes" xml:space="preserve">
          <source>Polygon (similar to closed path)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="358c4e4d5755c21f01067425fdfdaf1bfdcb7099" translate="yes" xml:space="preserve">
          <source>Polygons are output using the first syntax.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7fb66bc5a7ec5dcfcc725c19a5a1e5c03cd32e7e" translate="yes" xml:space="preserve">
          <source>Polygons are represented by lists of points (the vertexes of the polygon). Polygons are very similar to closed paths, but are stored differently and have their own set of support routines.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="274e42ad6449f3252ec5038abe402083876dea88" translate="yes" xml:space="preserve">
          <source>Populating a Database</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7fbc9b4eb9f4bb4e95de4acb2d6d7f0b43e20913" translate="yes" xml:space="preserve">
          <source>Population standard deviation of time spent in the statement, in milliseconds</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="384cecb2d7b1b2012eaea272977d2cf0c551884e" translate="yes" xml:space="preserve">
          <source>Port number of the PostgreSQL instance this WAL receiver is connected to.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="008e62801aaa400319958b2b2b06cc2182c60162" translate="yes" xml:space="preserve">
          <source>Port number on LDAP server to connect to. If no port is specified, the LDAP library's default port setting will be used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c75704d05c6e22d0fdf67c00eb401f9b1c6b139b" translate="yes" xml:space="preserve">
          <source>Portable Operating System Interface</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7c56d55f410fd275aaccf8ba063a18761b3e5c0" translate="yes" xml:space="preserve">
          <source>Position values in &lt;code&gt;tsvector&lt;/code&gt; must be greater than 0 and no more than 16,383</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bbb340fe5bf8594afaa03b969bb8e8f82eef71df" translate="yes" xml:space="preserve">
          <source>Positional notation is the traditional mechanism for passing arguments to functions in PostgreSQL. An example is:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd8bd0b5027f70c1cefa9f905da80fd30083ef2a" translate="yes" xml:space="preserve">
          <source>Possible</source>
          <target state="translated">Possible</target>
        </trans-unit>
        <trans-unit id="6db8a7e83593975ece623b8f9b3fe94d53e8a1b1" translate="yes" xml:space="preserve">
          <source>Possible limitations of the &lt;code&gt;query&lt;/code&gt; clause are documented under &lt;a href=&quot;sql-select&quot;&gt;SELECT&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7280aa9b126e519bb5acdcab7417841a30bb930a" translate="yes" xml:space="preserve">
          <source>Possible values are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e46bf54baa1011e163ced28f70574e61876f70d3" translate="yes" xml:space="preserve">
          <source>Possible variants of the above queries are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92818ef9b703eafdfca9b984fb83c6ed173e8358" translate="yes" xml:space="preserve">
          <source>Possibly, your site administrator has already created a database for your use. In that case you can omit this step and skip ahead to the next section.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24fd6c2d1150de6a47543209150ff4c2a2d3104f" translate="yes" xml:space="preserve">
          <source>PostgreSQL</source>
          <target state="translated">PostgreSQL</target>
        </trans-unit>
        <trans-unit id="0c5bb15ce4cd87c929efa330565ff6d28cd04381" translate="yes" xml:space="preserve">
          <source>PostgreSQL Client Applications</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c24f12993bca195ad8365e3a9f46bba7d548c46e" translate="yes" xml:space="preserve">
          <source>PostgreSQL Error Codes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="179caa7e2f2ae5bcccafd6de1029390b28df93ea" translate="yes" xml:space="preserve">
          <source>PostgreSQL Extension System</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bde4caa4f627d1ed1cd6258230a52653ae368364" translate="yes" xml:space="preserve">
          <source>PostgreSQL Limits</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="831c73ba52cb3a865742b364e490e3d33fd67271" translate="yes" xml:space="preserve">
          <source>PostgreSQL Log Sequence Number</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6e7156cbc0b3b93da375064bee0966e60cdb8ac" translate="yes" xml:space="preserve">
          <source>PostgreSQL Rule System</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="452e61af45168fd75ac971dbf646f72b427da732" translate="yes" xml:space="preserve">
          <source>PostgreSQL Server Applications</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67fae22a18c43950aa1922954f1d91e59073538b" translate="yes" xml:space="preserve">
          <source>PostgreSQL User Account</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5ec2d5a5859a9a3bd680edc1c2f24695d8620d3" translate="yes" xml:space="preserve">
          <source>PostgreSQL actually treats every SQL statement as being executed within a transaction. If you do not issue a &lt;code&gt;BEGIN&lt;/code&gt; command, then each individual statement has an implicit &lt;code&gt;BEGIN&lt;/code&gt; and (if successful) &lt;code&gt;COMMIT&lt;/code&gt; wrapped around it. A group of statements surrounded by &lt;code&gt;BEGIN&lt;/code&gt; and &lt;code&gt;COMMIT&lt;/code&gt; is sometimes called a &lt;em&gt;transaction block&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a08fed9d9b5168502be31cd2bf857824ed3fb1b6" translate="yes" xml:space="preserve">
          <source>PostgreSQL allows &lt;code&gt;INSERT&lt;/code&gt;, &lt;code&gt;UPDATE&lt;/code&gt;, and &lt;code&gt;DELETE&lt;/code&gt; to be used as &lt;code&gt;WITH&lt;/code&gt; queries. This is not found in the SQL standard.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ae0ed23837a44ee80fff5d2d48a225d0adbd095" translate="yes" xml:space="preserve">
          <source>PostgreSQL allows a function call to be written directly as a member of the &lt;code&gt;FROM&lt;/code&gt; list. In the SQL standard it would be necessary to wrap such a function call in a sub-&lt;code&gt;SELECT&lt;/code&gt;; that is, the syntax &lt;code&gt;FROM func(...) alias&lt;/code&gt; is approximately equivalent to &lt;code&gt;FROM LATERAL (SELECT func(...)) alias&lt;/code&gt;. Note that &lt;code&gt;LATERAL&lt;/code&gt; is considered to be implicit; this is because the standard requires &lt;code&gt;LATERAL&lt;/code&gt; semantics for an &lt;code&gt;UNNEST()&lt;/code&gt; item in &lt;code&gt;FROM&lt;/code&gt;. PostgreSQL treats &lt;code&gt;UNNEST()&lt;/code&gt; the same as other set-returning functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1fec2c228fe0347b7815e3014f29d97d5a87acca" translate="yes" xml:space="preserve">
          <source>PostgreSQL allows a table of no columns to be created (for example, &lt;code&gt;CREATE TABLE foo();&lt;/code&gt;). This is an extension from the SQL standard, which does not allow zero-column tables. Zero-column tables are not in themselves very useful, but disallowing them creates odd special cases for &lt;code&gt;ALTER TABLE DROP COLUMN&lt;/code&gt;, so it seems cleaner to ignore this spec restriction.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a502e4f8d9c2660f0a8eba2540286883c5cd8c9" translate="yes" xml:space="preserve">
          <source>PostgreSQL allows a table to have more than one identity column. The standard specifies that a table can have at most one identity column. This is relaxed mainly to give more flexibility for doing schema changes or migrations. Note that the &lt;code&gt;INSERT&lt;/code&gt; command supports only one override clause that applies to the entire statement, so having multiple identity columns with different behaviors is not well supported.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3ae4855b2a3e72640693b7d20d3ad5d9fb47042" translate="yes" xml:space="preserve">
          <source>PostgreSQL allows a trailing &lt;code&gt;*&lt;/code&gt; to be written to explicitly specify the non-&lt;code&gt;ONLY&lt;/code&gt; behavior of including child tables. The standard does not allow this.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0222c8fe2334be83692d30a209d5aa08ec24134f" translate="yes" xml:space="preserve">
          <source>PostgreSQL allows an object owner to revoke their own ordinary privileges: for example, a table owner can make the table read-only to themselves by revoking their own &lt;code&gt;INSERT&lt;/code&gt;, &lt;code&gt;UPDATE&lt;/code&gt;, &lt;code&gt;DELETE&lt;/code&gt;, and &lt;code&gt;TRUNCATE&lt;/code&gt; privileges. This is not possible according to the SQL standard. The reason is that PostgreSQL treats the owner's privileges as having been granted by the owner to themselves; therefore they can revoke them too. In the SQL standard, the owner's privileges are granted by an assumed entity &amp;ldquo;_SYSTEM&amp;rdquo;. Not being &amp;ldquo;_SYSTEM&amp;rdquo;, the owner cannot revoke these rights.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d75f3d8cbebcea3de67f82faaf69d14b5b967380" translate="yes" xml:space="preserve">
          <source>PostgreSQL allows columns of a table to be defined as variable-length multidimensional arrays. Arrays of any built-in or user-defined base type, enum type, composite type, range type, or domain can be created.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bbbdf4cafaaa4dcf65d19eea36b6d2663f13d7b7" translate="yes" xml:space="preserve">
          <source>PostgreSQL allows database sessions to synchronize their snapshots. A &lt;em&gt;snapshot&lt;/em&gt; determines which data is visible to the transaction that is using the snapshot. Synchronized snapshots are necessary when two or more sessions need to see identical content in the database. If two sessions just start their transactions independently, there is always a possibility that some third transaction commits between the executions of the two &lt;code&gt;START TRANSACTION&lt;/code&gt; commands, so that one session sees the effects of that transaction and the other does not.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f376988cf3adab23de6270e27f2d8af7b43d3dc" translate="yes" xml:space="preserve">
          <source>PostgreSQL allows expressions with prefix and postfix unary (one-argument) operators, as well as binary (two-argument) operators. Like functions, operators can be overloaded, so the same problem of selecting the right operator exists.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38e06aff61270fa25d3a83fecc14dbc49c17fa73" translate="yes" xml:space="preserve">
          <source>PostgreSQL allows function &lt;em&gt;overloading&lt;/em&gt;; that is, the same name can be used for several different functions so long as they have distinct input argument types. Whether or not you use it, this capability entails security precautions when calling functions in databases where some users mistrust other users; see &lt;a href=&quot;typeconv-func&quot;&gt;Section 10.3&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="885786b4f5cdfbf8b703cb2cdbcec19a632c472d" translate="yes" xml:space="preserve">
          <source>PostgreSQL allows functions that have named parameters to be called using either &lt;em&gt;positional&lt;/em&gt; or &lt;em&gt;named&lt;/em&gt; notation. Named notation is especially useful for functions that have a large number of parameters, since it makes the associations between parameters and actual arguments more explicit and reliable. In positional notation, a function call is written with its argument values in the same order as they are defined in the function declaration. In named notation, the arguments are matched to the function parameters by name and can be written in any order. For each notation, also consider the effect of function argument types, documented in &lt;a href=&quot;typeconv-func&quot;&gt;Section 10.3&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ccedf68ac95013795d6781ac353bb002bbdac9bd" translate="yes" xml:space="preserve">
          <source>PostgreSQL allows identifier syntax (&lt;code&gt;&quot;rolename&quot;&lt;/code&gt;), while the SQL standard requires the role name to be written as a string literal. SQL does not allow this command during a transaction; PostgreSQL does not make this restriction because there is no reason to. The &lt;code&gt;SESSION&lt;/code&gt; and &lt;code&gt;LOCAL&lt;/code&gt; modifiers are a PostgreSQL extension, as is the &lt;code&gt;RESET&lt;/code&gt; syntax.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aee304bddb0add35cce98f16acc2e91d76460499" translate="yes" xml:space="preserve">
          <source>PostgreSQL allows one to omit the &lt;code&gt;FROM&lt;/code&gt; clause. It has a straightforward use to compute the results of simple expressions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0eb6de17c126effc5a1502158efa04db9cdf59d" translate="yes" xml:space="preserve">
          <source>PostgreSQL allows only one character set encoding per database. It is therefore not possible for the JSON types to conform rigidly to the JSON specification unless the database encoding is UTF8. Attempts to directly include characters that cannot be represented in the database encoding will fail; conversely, characters that can be represented in the database encoding but not in UTF8 will be allowed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f4d7c19f392d3d32e2ae22627f8334829c75a1e" translate="yes" xml:space="preserve">
          <source>PostgreSQL allows the application developer to specify the durability level required via replication. This can be specified for the system overall, though it can also be specified for specific users or connections, or even individual transactions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67e964073140451a310c8055af1d484d7e584b05" translate="yes" xml:space="preserve">
          <source>PostgreSQL allows you to specify time zones in three different forms:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2091ac924b203b9490fe163a62e56fac7f983c3f" translate="yes" xml:space="preserve">
          <source>PostgreSQL also accepts &amp;ldquo;escape&amp;rdquo; string constants, which are an extension to the SQL standard. An escape string constant is specified by writing the letter &lt;code&gt;E&lt;/code&gt; (upper or lower case) just before the opening single quote, e.g., &lt;code&gt;E'foo'&lt;/code&gt;. (When continuing an escape string constant across lines, write &lt;code&gt;E&lt;/code&gt; only before the first opening quote.) Within an escape string, a backslash character (&lt;code&gt;\&lt;/code&gt;) begins a C-like &lt;em&gt;backslash escape&lt;/em&gt; sequence, in which the combination of backslash and following character(s) represent a special byte value, as shown in &lt;a href=&quot;sql-syntax-lexical#SQL-BACKSLASH-TABLE&quot;&gt;Table 4.1&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8e26c666446bf180bc1b3bdb6835476bef38f80" translate="yes" xml:space="preserve">
          <source>PostgreSQL also accepts the following alternative forms for input: use of upper-case digits, the standard format surrounded by braces, omitting some or all hyphens, adding a hyphen after any group of four digits. Examples are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d551afc59236ea284f4ca849fa7d2277a7469049" translate="yes" xml:space="preserve">
          <source>PostgreSQL also has native support for using GSSAPI to encrypt client/server communications for increased security. Support requires that a GSSAPI implementation (such as MIT krb5) is installed on both client and server systems, and that support in PostgreSQL is enabled at build time (see &lt;a href=&quot;https://www.postgresql.org/docs/12/installation.html&quot;&gt;Chapter 16&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d7d486aaa9f91eb610db7317aa89991dcace483" translate="yes" xml:space="preserve">
          <source>PostgreSQL also protects against some kinds of data corruption on storage devices that may occur because of hardware errors or media failure over time, such as reading/writing garbage data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc4957185fda95801e3489431ec80f6cc95ed9d3" translate="yes" xml:space="preserve">
          <source>PostgreSQL also provides functions that return the start time of the current statement, as well as the actual current time at the instant the function is called. The complete list of non-SQL-standard time functions is:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73c105cc11eec562c7842e40a45124c8ca33cfca" translate="yes" xml:space="preserve">
          <source>PostgreSQL also supports &lt;em&gt;mixed&lt;/em&gt; notation, which combines positional and named notation. In this case, positional parameters are written first and named parameters appear after them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca59eb947715e169590d0f69e1f5c9da2f5d3e56" translate="yes" xml:space="preserve">
          <source>PostgreSQL also supports a parameter to strip the realm from the principal. This method is supported for backwards compatibility and is strongly discouraged as it is then impossible to distinguish different users with the same user name but coming from different realms. To enable this, set &lt;code&gt;include_realm&lt;/code&gt; to 0. For simple single-realm installations, doing that combined with setting the &lt;code&gt;krb_realm&lt;/code&gt; parameter (which checks that the principal's realm matches exactly what is in the &lt;code&gt;krb_realm&lt;/code&gt; parameter) is still secure; but this is a less capable approach compared to specifying an explicit mapping in &lt;code&gt;pg_ident.conf&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b477944494e7d8e126d3d69b3ea2e26c69eb1df" translate="yes" xml:space="preserve">
          <source>PostgreSQL also supports another type of escape syntax for strings that allows specifying arbitrary Unicode characters by code point. A Unicode escape string constant starts with &lt;code&gt;U&amp;amp;&lt;/code&gt; (upper or lower case letter U followed by ampersand) immediately before the opening quote, without any spaces in between, for example &lt;code&gt;U&amp;amp;'foo'&lt;/code&gt;. (Note that this creates an ambiguity with the operator &lt;code&gt;&amp;amp;&lt;/code&gt;. Use spaces around the operator to avoid this problem.) Inside the quotes, Unicode characters can be specified in escaped form by writing a backslash followed by the four-digit hexadecimal code point number or alternatively a backslash followed by a plus sign followed by a six-digit hexadecimal code point number. For example, the string &lt;code&gt;'data'&lt;/code&gt; could be written as</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b4d1cfe50623e59a66d0a1accf91a989fc0e27f" translate="yes" xml:space="preserve">
          <source>PostgreSQL also supports reporting dynamic information about exactly what is going on in the system right now, such as the exact command currently being executed by other server processes, and which other connections exist in the system. This facility is independent of the collector process.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="478c7623d400e727e3280b1e79d887e002061f8f" translate="yes" xml:space="preserve">
          <source>PostgreSQL also supports the SQL-standard notations &lt;code&gt;float&lt;/code&gt; and &lt;code&gt;float(p)&lt;/code&gt; for specifying inexact numeric types. Here, &lt;code&gt;p&lt;/code&gt; specifies the minimum acceptable precision in &lt;em&gt;binary&lt;/em&gt; digits. PostgreSQL accepts &lt;code&gt;float(1)&lt;/code&gt; to &lt;code&gt;float(24)&lt;/code&gt; as selecting the &lt;code&gt;real&lt;/code&gt; type, while &lt;code&gt;float(25)&lt;/code&gt; to &lt;code&gt;float(53)&lt;/code&gt; select &lt;code&gt;double precision&lt;/code&gt;. Values of &lt;code&gt;p&lt;/code&gt; outside the allowed range draw an error. &lt;code&gt;float&lt;/code&gt; with no precision specified is taken to mean &lt;code&gt;double precision&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de648c643b7990a2f17212f7c4a34e709bba19e4" translate="yes" xml:space="preserve">
          <source>PostgreSQL always initially presumes that a regular expression follows the ARE rules. However, the more limited ERE or BRE rules can be chosen by prepending an &lt;em&gt;embedded option&lt;/em&gt; to the RE pattern, as described in &lt;a href=&quot;functions-matching#POSIX-METASYNTAX&quot;&gt;Section 9.7.3.4&lt;/a&gt;. This can be useful for compatibility with applications that expect exactly the POSIX 1003.2 rules.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54903aca24fd73df3d0ecfd618b2abc92e61f984" translate="yes" xml:space="preserve">
          <source>PostgreSQL assumes that &lt;code&gt;CHECK&lt;/code&gt; constraints' conditions are immutable, that is, they will always give the same result for the same input row. This assumption is what justifies examining &lt;code&gt;CHECK&lt;/code&gt; constraints only when rows are inserted or updated, and not at other times. (The warning above about not referencing other table data is really a special case of this restriction.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff088d9be54485de195a863d4cf5285816323947" translate="yes" xml:space="preserve">
          <source>PostgreSQL assumes that &lt;code&gt;CHECK&lt;/code&gt; constraints' conditions are immutable, that is, they will always give the same result for the same input value. This assumption is what justifies examining &lt;code&gt;CHECK&lt;/code&gt; constraints only when a value is first converted to be of a domain type, and not at other times. (This is essentially the same as the treatment of table &lt;code&gt;CHECK&lt;/code&gt; constraints, as described in &lt;a href=&quot;ddl-constraints#DDL-CONSTRAINTS-CHECK-CONSTRAINTS&quot;&gt;Section 5.4.1&lt;/a&gt;.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2bff8b5a2ca5d91db2860fea9c0dad6138d0027" translate="yes" xml:space="preserve">
          <source>PostgreSQL automatically creates a unique index when a unique constraint or primary key is defined for a table. The index covers the columns that make up the primary key or unique constraint (a multicolumn index, if appropriate), and is the mechanism that enforces the constraint.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f26b59affbadfc237829843f54d3c4584d266882" translate="yes" xml:space="preserve">
          <source>PostgreSQL automatically creates an index for each unique constraint and primary key constraint to enforce uniqueness. Thus, it is not necessary to create an index explicitly for primary key columns. (See &lt;a href=&quot;sql-createindex&quot;&gt;CREATE INDEX&lt;/a&gt; for more information.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71faf5408aef54cef3ab5e08ed45e5e43ecd20a6" translate="yes" xml:space="preserve">
          <source>PostgreSQL can build indexes while leveraging multiple CPUs in order to process the table rows faster. This feature is known as &lt;em&gt;parallel index build&lt;/em&gt;. For index methods that support building indexes in parallel (currently, only B-tree), &lt;code&gt;maintenance_work_mem&lt;/code&gt; specifies the maximum amount of memory that can be used by each index build operation as a whole, regardless of how many worker processes were started. Generally, a cost model automatically determines how many worker processes should be requested, if any.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b61a24efb840bbdfd7121333fc936cd259d1497d" translate="yes" xml:space="preserve">
          <source>PostgreSQL can sometimes exhaust various operating system resource limits, especially when multiple copies of the server are running on the same system, or in very large installations. This section explains the kernel resources used by PostgreSQL and the steps you can take to resolve problems related to kernel resource consumption.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2e725f00d6a809e37502a0cf8c2fc8a68d3f58c" translate="yes" xml:space="preserve">
          <source>PostgreSQL comes with the following built-in range types:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb387a6689d06faa79aaca21b4c8e065a066ab23" translate="yes" xml:space="preserve">
          <source>PostgreSQL considers distinct collation objects to be incompatible even when they have identical properties. Thus for example,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="390d5417e842d1a1814896813c380671ee3b4fd0" translate="yes" xml:space="preserve">
          <source>PostgreSQL creates a temporary variable of data type &lt;code&gt;stype&lt;/code&gt; to hold the current internal state of the aggregate. At each input row, the aggregate argument value(s) are calculated and the state transition function is invoked with the current state value and the new argument value(s) to calculate a new internal state value. After all the rows have been processed, the final function is invoked once to calculate the aggregate's return value. If there is no final function then the ending state value is returned as-is.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14a71a515034c71c679dfb591fbd291cd9591d60" translate="yes" xml:space="preserve">
          <source>PostgreSQL currently does not support multi-character collating elements. This information describes possible future behavior.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e2fde7f5f9c9a2ecbda1c45fded6817737c8d70" translate="yes" xml:space="preserve">
          <source>PostgreSQL database passwords are separate from operating system user passwords. The password for each database user is stored in the &lt;code&gt;pg_authid&lt;/code&gt; system catalog. Passwords can be managed with the SQL commands &lt;a href=&quot;sql-createrole&quot;&gt;CREATE ROLE&lt;/a&gt; and &lt;a href=&quot;sql-alterrole&quot;&gt;ALTER ROLE&lt;/a&gt;, e.g., &lt;strong&gt;&lt;code&gt;CREATE ROLE foo WITH LOGIN PASSWORD 'secret'&lt;/code&gt;&lt;/strong&gt;, or the psql command &lt;code&gt;\password&lt;/code&gt;. If no password has been set up for a user, the stored password is null and password authentication will always fail for that user.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae07be10ad05f8eb77e791ce859f3046663e8d9e" translate="yes" xml:space="preserve">
          <source>PostgreSQL databases require periodic maintenance known as &lt;em&gt;vacuuming&lt;/em&gt;. For many installations, it is sufficient to let vacuuming be performed by the &lt;em&gt;autovacuum daemon&lt;/em&gt;, which is described in &lt;a href=&quot;routine-vacuuming#AUTOVACUUM&quot;&gt;Section 24.1.6&lt;/a&gt;. You might need to adjust the autovacuuming parameters described there to obtain best results for your situation. Some database administrators will want to supplement or replace the daemon's activities with manually-managed &lt;code&gt;VACUUM&lt;/code&gt; commands, which typically are executed according to a schedule by cron or Task Scheduler scripts. To set up manually-managed vacuuming properly, it is essential to understand the issues discussed in the next few subsections. Administrators who rely on autovacuuming may still wish to skim this material to help them understand and adjust autovacuuming.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b15ec468b17952447cfdd51a679958ed70d2e48" translate="yes" xml:space="preserve">
          <source>PostgreSQL devises a &lt;em&gt;query plan&lt;/em&gt; for each query it receives. Choosing the right plan to match the query structure and the properties of the data is absolutely critical for good performance, so the system includes a complex &lt;em&gt;planner&lt;/em&gt; that tries to choose good plans. You can use the &lt;a href=&quot;sql-explain&quot;&gt;EXPLAIN&lt;/a&gt; command to see what query plan the planner creates for any query. Plan-reading is an art that requires some experience to master, but this section attempts to cover the basics.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6bdc7ca1f027f4e423efc6001869a2aac8718c0" translate="yes" xml:space="preserve">
          <source>PostgreSQL does not have an explicit &lt;code&gt;OPEN&lt;/code&gt; cursor statement; a cursor is considered open when it is declared. Use the &lt;a href=&quot;sql-declare&quot;&gt;DECLARE&lt;/a&gt; statement to declare a cursor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0dfef93504eab39387d43751a55a477c2955176f" translate="yes" xml:space="preserve">
          <source>PostgreSQL does not offer this type of replication, though PostgreSQL two-phase commit (&lt;a href=&quot;sql-prepare-transaction&quot;&gt;PREPARE TRANSACTION&lt;/a&gt; and &lt;a href=&quot;sql-commit-prepared&quot;&gt;COMMIT PREPARED&lt;/a&gt;) can be used to implement this in application code or middleware.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bcb2a401b7b0ac69a360f9b7c695ed89ed9ebff0" translate="yes" xml:space="preserve">
          <source>PostgreSQL does not protect against correctable memory errors and it is assumed you will operate using RAM that uses industry standard Error Correcting Codes (ECC) or better protection.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13d3dc2372c98003c5a49c2b15eff6ff46f18e90" translate="yes" xml:space="preserve">
          <source>PostgreSQL does not protect against correctable memory errors and it is assumed you will operate using RAM that uses industry standard Error Correcting Codes (ECC) or better protection. However, ECC memory is typically only immune to single-bit errors, and should not be assumed to provide &lt;em&gt;absolute&lt;/em&gt; protection against failures that result in memory corruption.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1217e1656a3a27412f47a2f27ca6ddad0011cb8d" translate="yes" xml:space="preserve">
          <source>PostgreSQL does not provide the system software required to identify a failure on the primary and notify the standby database server. Many such tools exist and are well integrated with the operating system facilities required for successful failover, such as IP address migration.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d796e67fd8db9494e77a87bae072c969985dce1" translate="yes" xml:space="preserve">
          <source>PostgreSQL does not support &lt;code&gt;CHECK&lt;/code&gt; constraints that reference table data other than the new or updated row being checked. While a &lt;code&gt;CHECK&lt;/code&gt; constraint that violates this rule may appear to work in simple tests, it cannot guarantee that the database will not reach a state in which the constraint condition is false (due to subsequent changes of the other row(s) involved). This would cause a database dump and reload to fail. The reload could fail even when the complete database state is consistent with the constraint, due to rows not being loaded in an order that will satisfy the constraint. If possible, use &lt;code&gt;UNIQUE&lt;/code&gt;, &lt;code&gt;EXCLUDE&lt;/code&gt;, or &lt;code&gt;FOREIGN KEY&lt;/code&gt; constraints to express cross-row and cross-table restrictions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cef8ed11bde695868953cc0c745e366d96215f8a" translate="yes" xml:space="preserve">
          <source>PostgreSQL doesn't remember any information about modified rows in memory, so there is no limit on the number of rows locked at one time. However, locking a row might cause a disk write, e.g., &lt;code&gt;SELECT FOR UPDATE&lt;/code&gt; modifies selected rows to mark them locked, and so will result in disk writes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63ab1d6406e057a762f3f310fecdc3a3bbd6104e" translate="yes" xml:space="preserve">
          <source>PostgreSQL endeavors to be compatible with the SQL standard definitions for typical usage. However, the SQL standard has an odd mix of date and time types and capabilities. Two obvious problems are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66d120b7abdf73ead6dc3fd9f48bfc40f4f89b99" translate="yes" xml:space="preserve">
          <source>PostgreSQL enforces SQL uniqueness constraints using &lt;em&gt;unique indexes&lt;/em&gt;, which are indexes that disallow multiple entries with identical keys. An access method that supports this feature sets &lt;code&gt;amcanunique&lt;/code&gt; true. (At present, only b-tree supports it.) Columns listed in the &lt;code&gt;INCLUDE&lt;/code&gt; clause are not considered when enforcing uniqueness.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46cf5e94b98f5acb847fc69a661150beb395793b" translate="yes" xml:space="preserve">
          <source>PostgreSQL grants privileges on some types of objects to &lt;code&gt;PUBLIC&lt;/code&gt; by default when the objects are created. No privileges are granted to &lt;code&gt;PUBLIC&lt;/code&gt; by default on tables, table columns, sequences, foreign data wrappers, foreign servers, large objects, schemas, or tablespaces. For other types of objects, the default privileges granted to &lt;code&gt;PUBLIC&lt;/code&gt; are as follows: &lt;code&gt;CONNECT&lt;/code&gt; and &lt;code&gt;TEMPORARY&lt;/code&gt; (create temporary tables) privileges for databases; &lt;code&gt;EXECUTE&lt;/code&gt; privilege for functions and procedures; and &lt;code&gt;USAGE&lt;/code&gt; privilege for languages and data types (including domains). The object owner can, of course, &lt;code&gt;REVOKE&lt;/code&gt; both default and expressly granted privileges. (For maximum security, issue the &lt;code&gt;REVOKE&lt;/code&gt; in the same transaction that creates the object; then there is no window in which another user can use the object.) Also, these default privilege settings can be overridden using the &lt;a href=&quot;sql-alterdefaultprivileges&quot;&gt;ALTER DEFAULT PRIVILEGES&lt;/a&gt; command.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a3b4b281714f98b0b025baa01ab2e4079267b58" translate="yes" xml:space="preserve">
          <source>PostgreSQL handles column expansion by actually transforming the first form into the second. So, in this example, &lt;code&gt;myfunc()&lt;/code&gt; would get invoked three times per row with either syntax. If it's an expensive function you may wish to avoid that, which you can do with a query like:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df3dd7b1a171b6d6a80edc47008e7fbb158239c5" translate="yes" xml:space="preserve">
          <source>PostgreSQL handles temporary tables in a way rather different from the standard; see &lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d2f14dc9f7becae572a0674a0a8f299b6b7b7aa" translate="yes" xml:space="preserve">
          <source>PostgreSQL has a rich set of native data types available to users. Users can add new types to PostgreSQL using the &lt;a href=&quot;sql-createtype&quot;&gt;CREATE TYPE&lt;/a&gt; command.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78dda5739ec01795bd873fabe7ba9d163840acc7" translate="yes" xml:space="preserve">
          <source>PostgreSQL has an optional but highly recommended feature called &lt;em&gt;autovacuum&lt;/em&gt;, whose purpose is to automate the execution of &lt;code&gt;VACUUM&lt;/code&gt; and &lt;code&gt;ANALYZE&lt;/code&gt; commands. When enabled, autovacuum checks for tables that have had a large number of inserted, updated or deleted tuples. These checks use the statistics collection facility; therefore, autovacuum cannot be used unless &lt;a href=&quot;runtime-config-statistics#GUC-TRACK-COUNTS&quot;&gt;track_counts&lt;/a&gt; is set to &lt;code&gt;true&lt;/code&gt;. In the default configuration, autovacuuming is enabled and the related configuration parameters are appropriately set.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="745a9a5fff0d46d735897a2bfe230fa0dcd833f5" translate="yes" xml:space="preserve">
          <source>PostgreSQL has builtin support to perform JIT compilation using &lt;a href=&quot;https://llvm.org/&quot;&gt;LLVM&lt;/a&gt; when PostgreSQL is built with &lt;a href=&quot;https://www.postgresql.org/docs/12/install-procedure.html#CONFIGURE-WITH-LLVM&quot;&gt;&lt;code&gt;--with-llvm&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f59e9103489b1a27d73e875b095c1816ff90ee6" translate="yes" xml:space="preserve">
          <source>PostgreSQL has many features not touched upon in this tutorial introduction, which has been oriented toward newer users of SQL. These features are discussed in more detail in the remainder of this book.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34f532154e5db2109f00a916c27e879723393e79" translate="yes" xml:space="preserve">
          <source>PostgreSQL has native support for using SSL connections to encrypt client/server communications for increased security. This requires that OpenSSL is installed on both client and server systems and that support in PostgreSQL is enabled at build time (see &lt;a href=&quot;https://www.postgresql.org/docs/12/installation.html&quot;&gt;Chapter 16&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2cee738042d576fe56c5cf2614b5d2a89ef2ed35" translate="yes" xml:space="preserve">
          <source>PostgreSQL has the ability to report the progress of certain commands during command execution. Currently, the only commands which support progress reporting are &lt;code&gt;CREATE INDEX&lt;/code&gt;, &lt;code&gt;VACUUM&lt;/code&gt; and &lt;code&gt;CLUSTER&lt;/code&gt;. This may be expanded in the future.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a153bd140b6eee429afa97ad0154361013ce149c" translate="yes" xml:space="preserve">
          <source>PostgreSQL implements portions of the SQL/MED specification, allowing you to access data that resides outside PostgreSQL using regular SQL queries. Such data is referred to as &lt;em&gt;foreign data&lt;/em&gt;. (Note that this usage is not to be confused with foreign keys, which are a type of constraint within the database.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45ba54515ef38ae8443e32276665e58fc7c44f3d" translate="yes" xml:space="preserve">
          <source>PostgreSQL implements table inheritance, which can be a useful tool for database designers. (SQL:1999 and later define a type inheritance feature, which differs in many respects from the features described here.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a4293b24f0d18f72db2fd6c1c67a47c9fab41ed" translate="yes" xml:space="preserve">
          <source>PostgreSQL includes a program &lt;a href=&quot;app-createuser&quot;&gt;createuser&lt;/a&gt; that has the same functionality as &lt;code&gt;CREATE ROLE&lt;/code&gt; (in fact, it calls this command) but can be run from the command shell.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84114ad3110b572f55729ff61c07b1a5d40daec3" translate="yes" xml:space="preserve">
          <source>PostgreSQL includes a program &lt;a href=&quot;app-dropuser&quot;&gt;dropuser&lt;/a&gt; that has the same functionality as this command (in fact, it calls this command) but can be run from the command shell.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="682b0969ef85f21e73efd9cc0f1d64eca421eb6a" translate="yes" xml:space="preserve">
          <source>PostgreSQL includes a sizable set of built-in data types that fit many applications. Users can also define their own data types. Most built-in data types have obvious names and semantics, so we defer a detailed explanation to &lt;a href=&quot;datatype&quot;&gt;Chapter 8&lt;/a&gt;. Some of the frequently used data types are &lt;code&gt;integer&lt;/code&gt; for whole numbers, &lt;code&gt;numeric&lt;/code&gt; for possibly fractional numbers, &lt;code&gt;text&lt;/code&gt; for character strings, &lt;code&gt;date&lt;/code&gt; for dates, &lt;code&gt;time&lt;/code&gt; for time-of-day values, and &lt;code&gt;timestamp&lt;/code&gt; for values containing both date and time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="735559b54f06b3f3f206e8111b18e4ea8d9566e4" translate="yes" xml:space="preserve">
          <source>PostgreSQL includes an &amp;ldquo;autovacuum&amp;rdquo; facility which can automate routine vacuum maintenance. For more information about automatic and manual vacuuming, see &lt;a href=&quot;routine-vacuuming&quot;&gt;Section 24.1&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ffa60848047cd6b07df3ba1987237f159ca48b0a" translate="yes" xml:space="preserve">
          <source>PostgreSQL includes an implementation of the standard btree (multi-way balanced tree) index data structure. Any data type that can be sorted into a well-defined linear order can be indexed by a btree index. The only limitation is that an index entry cannot exceed approximately one-third of a page (after TOAST compression, if applicable).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="821fe06f71c1808348a7b91e09179799740b9a95" translate="yes" xml:space="preserve">
          <source>PostgreSQL is a &lt;em&gt;relational database management system&lt;/em&gt; (RDBMS). That means it is a system for managing data stored in &lt;em&gt;relations&lt;/em&gt;. Relation is essentially a mathematical term for &lt;em&gt;table&lt;/em&gt;. The notion of storing data in tables is so commonplace today that it might seem inherently obvious, but there are a number of other ways of organizing databases. Files and directories on Unix-like operating systems form an example of a hierarchical database. A more modern development is the object-oriented database.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9cfd426182152d61be1e2778a072f15bc552fcab" translate="yes" xml:space="preserve">
          <source>PostgreSQL is implemented using a simple &amp;ldquo;process per user&amp;rdquo; client/server model. In this model there is one &lt;em&gt;client process&lt;/em&gt; connected to exactly one &lt;em&gt;server process&lt;/em&gt;. As we do not know ahead of time how many connections will be made, we have to use a &lt;em&gt;master process&lt;/em&gt; that spawns a new server process every time a connection is requested. This master process is called &lt;code&gt;postgres&lt;/code&gt; and listens at a specified TCP/IP port for incoming connections. Whenever a request for a connection is detected the &lt;code&gt;postgres&lt;/code&gt; process spawns a new server process. The server tasks communicate with each other using &lt;em&gt;semaphores&lt;/em&gt; and &lt;em&gt;shared memory&lt;/em&gt; to ensure data integrity throughout concurrent data access.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5b0c6c6215c78ea032d3a013c7f4ae434fd6519" translate="yes" xml:space="preserve">
          <source>PostgreSQL is more flexible in handling date/time input than the SQL standard requires. See &lt;a href=&quot;https://www.postgresql.org/docs/12/datetime-appendix.html&quot;&gt;Appendix B&lt;/a&gt; for the exact parsing rules of date/time input and for the recognized text fields including months, days of the week, and time zones.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c828eb4cf5a62919aaf9e56822812dfeb42eacd5" translate="yes" xml:space="preserve">
          <source>PostgreSQL is very extensible and allows new data types, functions, operators and other database objects to be defined; see &lt;a href=&quot;https://www.postgresql.org/docs/12/extend.html&quot;&gt;Chapter 37&lt;/a&gt;. In fact the built-in objects are implemented using nearly the same mechanisms. This extensibility implies some overhead, for example due to function calls (see &lt;a href=&quot;https://www.postgresql.org/docs/12/xfunc.html&quot;&gt;Section 37.3&lt;/a&gt;). To reduce that overhead, JIT compilation can inline the bodies of small functions into the expressions using them. That allows a significant percentage of the overhead to be optimized away.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66bf58dffda176b2af709bb0e9bb018d0b319b34" translate="yes" xml:space="preserve">
          <source>PostgreSQL lets you reference columns of other tables in the &lt;code&gt;WHERE&lt;/code&gt; condition by specifying the other tables in the &lt;code&gt;USING&lt;/code&gt; clause. For example, to delete all films produced by a given producer, one can do:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="575317fbf767c3750ee89eec8e188302800f4189" translate="yes" xml:space="preserve">
          <source>PostgreSQL makes use of symbolic links to simplify the implementation of tablespaces. This means that tablespaces can be used &lt;em&gt;only&lt;/em&gt; on systems that support symbolic links.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0ca6dd2831d7be94912fd0050870a1cb327936d" translate="yes" xml:space="preserve">
          <source>PostgreSQL offers a way to specify how to divide a table into pieces called partitions. The table that is divided is referred to as a &lt;em&gt;partitioned table&lt;/em&gt;. The specification consists of the &lt;em&gt;partitioning method&lt;/em&gt; and a list of columns or expressions to be used as the &lt;em&gt;partition key&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="891f5d2a022ddd1dd671a070027ea1cff8f75e34" translate="yes" xml:space="preserve">
          <source>PostgreSQL offers built-in support for the following forms of partitioning:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5662adc70468d34652ede9f811304c570cee30e3" translate="yes" xml:space="preserve">
          <source>PostgreSQL offers data types to store IPv4, IPv6, and MAC addresses, as shown in &lt;a href=&quot;datatype-net-types#DATATYPE-NET-TYPES-TABLE&quot;&gt;Table 8.21&lt;/a&gt;. It is better to use these types instead of plain text types to store network addresses, because these types offer input error checking and specialized operators and functions (see &lt;a href=&quot;functions-net&quot;&gt;Section 9.12&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84c215e752220c438a12a8423b6fe5998d9faf4a" translate="yes" xml:space="preserve">
          <source>PostgreSQL offers encryption at several levels, and provides flexibility in protecting data from disclosure due to database server theft, unscrupulous administrators, and insecure networks. Encryption might also be required to secure sensitive data such as medical records or financial transactions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69f5fb450ee35fca9053db0e9cf0fee2e325d788" translate="yes" xml:space="preserve">
          <source>PostgreSQL offers two types for storing JSON data: &lt;code&gt;json&lt;/code&gt; and &lt;code&gt;jsonb&lt;/code&gt;. To implement efficient query mechanisms for these data types, PostgreSQL also provides the &lt;code&gt;jsonpath&lt;/code&gt; data type described in &lt;a href=&quot;datatype-json#DATATYPE-JSONPATH&quot;&gt;Section 8.14.6&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="926dbd334c49f127c9efe79cdb0a9983f9b87b3a" translate="yes" xml:space="preserve">
          <source>PostgreSQL only allows the execution of a user-defined function for the triggered action. The standard allows the execution of a number of other SQL commands, such as &lt;code&gt;CREATE TABLE&lt;/code&gt;, as the triggered action. This limitation is not hard to work around by creating a user-defined function that executes the desired commands.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43083b6336b02575039a2d9d8f76b5988935b20e" translate="yes" xml:space="preserve">
          <source>PostgreSQL procedural language libraries can be preloaded in this way, typically by using the syntax &lt;code&gt;'$libdir/plXXX'&lt;/code&gt; where &lt;code&gt;XXX&lt;/code&gt; is &lt;code&gt;pgsql&lt;/code&gt;, &lt;code&gt;perl&lt;/code&gt;, &lt;code&gt;tcl&lt;/code&gt;, or &lt;code&gt;python&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f59dd80e652539f7d5e5bc6cc2d156491128c008" translate="yes" xml:space="preserve">
          <source>PostgreSQL provides a JIT implementation based on LLVM. The interface to the JIT provider is pluggable and the provider can be changed without recompiling (although currently, the build process only provides inlining support data for LLVM). The active provider is chosen via the setting &lt;a href=&quot;runtime-config-client#GUC-JIT-PROVIDER&quot;&gt;jit_provider&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe91789313046ec6475705a372e78ba71b0024c0" translate="yes" xml:space="preserve">
          <source>PostgreSQL provides a function to inspect complex statistics defined using the &lt;code&gt;CREATE STATISTICS&lt;/code&gt; command.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46fdddf06cc7902f32855be5f7713801b1905af6" translate="yes" xml:space="preserve">
          <source>PostgreSQL provides a means for creating locks that have application-defined meanings. These are called &lt;em&gt;advisory locks&lt;/em&gt;, because the system does not enforce their use &amp;mdash; it is up to the application to use them correctly. Advisory locks can be useful for locking strategies that are an awkward fit for the MVCC model. For example, a common use of advisory locks is to emulate pessimistic locking strategies typical of so-called &amp;ldquo;flat file&amp;rdquo; data management systems. While a flag stored in a table could be used for the same purpose, advisory locks are faster, avoid table bloat, and are automatically cleaned up by the server at the end of the session.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0cfb1fbdc7aff0cefa972216042683bcba69e5d6" translate="yes" xml:space="preserve">
          <source>PostgreSQL provides a number of functions that return values related to the current date and time. These SQL-standard functions all return values based on the start time of the current transaction:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4d4d96a6016bf1a3419a8adde28df6d7f17d284" translate="yes" xml:space="preserve">
          <source>PostgreSQL provides a rich set of tools for developers to manage concurrent access to data. Internally, data consistency is maintained by using a multiversion model (Multiversion Concurrency Control, MVCC). This means that each SQL statement sees a snapshot of data (a &lt;em&gt;database version&lt;/em&gt;) as it was some time ago, regardless of the current state of the underlying data. This prevents statements from viewing inconsistent data produced by concurrent transactions performing updates on the same data rows, providing &lt;em&gt;transaction isolation&lt;/em&gt; for each database session. MVCC, by eschewing the locking methodologies of traditional database systems, minimizes lock contention in order to allow for reasonable performance in multiuser environments.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ecdd68232ab41018a2aebf2b36bf6bfee6f90a3" translate="yes" xml:space="preserve">
          <source>PostgreSQL provides a set of default roles which provide access to certain, commonly needed, privileged capabilities and information. Administrators can GRANT these roles to users and/or other roles in their environment, providing those users with access to the specified capabilities and information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12a7e7c8c66bad39574adedb86e60a5508ed2a12" translate="yes" xml:space="preserve">
          <source>PostgreSQL provides facilities to support dynamic tracing of the database server. This allows an external utility to be called at specific points in the code and thereby trace execution.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93788cdb40903d97aaf58bdd1f296a2d0af57e6d" translate="yes" xml:space="preserve">
          <source>PostgreSQL provides predefined dictionaries for many languages. There are also several predefined templates that can be used to create new dictionaries with custom parameters. Each predefined dictionary template is described below. If no existing template is suitable, it is possible to create new ones; see the &lt;code&gt;contrib/&lt;/code&gt; area of the PostgreSQL distribution for examples.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="abe4b5b2c2d17d1440228c909b7105d20d3d03a0" translate="yes" xml:space="preserve">
          <source>PostgreSQL provides several features for breaking down complex &lt;code&gt;postgresql.conf&lt;/code&gt; files into sub-files. These features are especially useful when managing multiple servers with related, but not identical, configurations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12ddc3899973df221c8322e34a526586b23ebfaa" translate="yes" xml:space="preserve">
          <source>PostgreSQL provides several index types: B-tree, Hash, GiST, SP-GiST, GIN and BRIN. Each index type uses a different algorithm that is best suited to different types of queries. By default, the &lt;code&gt;CREATE INDEX&lt;/code&gt; command creates B-tree indexes, which fit the most common situations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d643a989351582bdcc707ed3905be058a733c4a" translate="yes" xml:space="preserve">
          <source>PostgreSQL provides storage and comparison functions for UUIDs, but the core database does not include any function for generating UUIDs, because no single algorithm is well suited for every application. The &lt;a href=&quot;uuid-ossp&quot;&gt;uuid-ossp&lt;/a&gt; module provides functions that implement several standard algorithms. The &lt;a href=&quot;pgcrypto&quot;&gt;pgcrypto&lt;/a&gt; module also provides a generation function for random UUIDs. Alternatively, UUIDs could be generated by client applications or other libraries invoked through a server-side function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8055d8a3fe512bf9a836cadb5eae9c2e8b86c5c" translate="yes" xml:space="preserve">
          <source>PostgreSQL provides the function &lt;code&gt;to_tsvector&lt;/code&gt; for converting a document to the &lt;code&gt;tsvector&lt;/code&gt; data type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="987c367c1a1efc0cb03cfb3dd34409cf91adaf69" translate="yes" xml:space="preserve">
          <source>PostgreSQL provides the functions &lt;code&gt;to_tsquery&lt;/code&gt;, &lt;code&gt;plainto_tsquery&lt;/code&gt;, &lt;code&gt;phraseto_tsquery&lt;/code&gt; and &lt;code&gt;websearch_to_tsquery&lt;/code&gt; for converting a query to the &lt;code&gt;tsquery&lt;/code&gt; data type. &lt;code&gt;to_tsquery&lt;/code&gt; offers access to more features than either &lt;code&gt;plainto_tsquery&lt;/code&gt; or &lt;code&gt;phraseto_tsquery&lt;/code&gt;, but it is less forgiving about its input. &lt;code&gt;websearch_to_tsquery&lt;/code&gt; is a simplified version of &lt;code&gt;to_tsquery&lt;/code&gt; with an alternative syntax, similar to the one used by web search engines.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d433b9e1cb0cc5f1366352a11ce9410f17e6d0fd" translate="yes" xml:space="preserve">
          <source>PostgreSQL provides the index methods B-tree, hash, GiST, SP-GiST, GIN, and BRIN. Users can also define their own index methods, but that is fairly complicated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bed8f31d13fc879249d79e50cd113d8dd0d3c306" translate="yes" xml:space="preserve">
          <source>PostgreSQL provides the standard SQL type &lt;code&gt;boolean&lt;/code&gt;; see &lt;a href=&quot;datatype-boolean#DATATYPE-BOOLEAN-TABLE&quot;&gt;Table 8.19&lt;/a&gt;. The &lt;code&gt;boolean&lt;/code&gt; type can have several states: &amp;ldquo;true&amp;rdquo;, &amp;ldquo;false&amp;rdquo;, and a third state, &amp;ldquo;unknown&amp;rdquo;, which is represented by the SQL null value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="112d712cbd3f4abfdabfc159cdc6a3584db95c15" translate="yes" xml:space="preserve">
          <source>PostgreSQL provides three SQL commands to establish configuration defaults. The already-mentioned &lt;a href=&quot;sql-altersystem&quot;&gt;ALTER SYSTEM&lt;/a&gt; command provides a SQL-accessible means of changing global defaults; it is functionally equivalent to editing &lt;code&gt;postgresql.conf&lt;/code&gt;. In addition, there are two commands that allow setting of defaults on a per-database or per-role basis:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d071c1667c54c5d765a697ea20deb60db45601b3" translate="yes" xml:space="preserve">
          <source>PostgreSQL provides two data types that are designed to support full text search, which is the activity of searching through a collection of natural-language &lt;em&gt;documents&lt;/em&gt; to locate those that best match a &lt;em&gt;query&lt;/em&gt;. The &lt;code&gt;tsvector&lt;/code&gt; type represents a document in a form optimized for text search; the &lt;code&gt;tsquery&lt;/code&gt; type similarly represents a text query. &lt;a href=&quot;https://www.postgresql.org/docs/12/textsearch.html&quot;&gt;Chapter 12&lt;/a&gt; provides a detailed explanation of this facility, and &lt;a href=&quot;functions-textsearch&quot;&gt;Section 9.13&lt;/a&gt; summarizes the related functions and operators.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d5de0e98d735e8c10c90f072b5e772ac6f8ca44" translate="yes" xml:space="preserve">
          <source>PostgreSQL provides two functions introduced in SQL:2006, but in variants that use the XPath 1.0 language, rather than XML Query as specified for them in the standard.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e29f8f292e01eb034e6335e7938f34ec555db8f" translate="yes" xml:space="preserve">
          <source>PostgreSQL provides various lock modes to control concurrent access to data in tables. These modes can be used for application-controlled locking in situations where MVCC does not give the desired behavior. Also, most PostgreSQL commands automatically acquire locks of appropriate modes to ensure that referenced tables are not dropped or modified in incompatible ways while the command executes. (For example, &lt;code&gt;TRUNCATE&lt;/code&gt; cannot safely be executed concurrently with other operations on the same table, so it obtains an exclusive lock on the table to enforce that.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aca67cd10f6b55fba07fefeab32464592e84bd50" translate="yes" xml:space="preserve">
          <source>PostgreSQL reads the system-wide OpenSSL configuration file. By default, this file is named &lt;code&gt;openssl.cnf&lt;/code&gt; and is located in the directory reported by &lt;code&gt;openssl version -d&lt;/code&gt;. This default can be overridden by setting environment variable &lt;code&gt;OPENSSL_CONF&lt;/code&gt; to the name of the desired configuration file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e141c534293f75601bff1fea667fc64a4f6c7d7" translate="yes" xml:space="preserve">
          <source>PostgreSQL recognizes functional dependency (allowing columns to be omitted from &lt;code&gt;GROUP BY&lt;/code&gt;) only when a table's primary key is included in the &lt;code&gt;GROUP BY&lt;/code&gt; list. The SQL standard specifies additional conditions that should be recognized.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d151da8167491478df86aef81ab6d8ffea35f9fb" translate="yes" xml:space="preserve">
          <source>PostgreSQL releases before 7.4 used a different binary file format.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b128f368f0a60d65746b559a252c4dc977c1b44f" translate="yes" xml:space="preserve">
          <source>PostgreSQL releases prior to 8.1 would accept queries of this form, and add an implicit entry to the query's &lt;code&gt;FROM&lt;/code&gt; clause for each table referenced by the query. This is no longer allowed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63fb6169ba8a1a0f974f4aea96b8b4aa6c3f1759" translate="yes" xml:space="preserve">
          <source>PostgreSQL requires a few bytes of System V shared memory (typically 48 bytes, on 64-bit platforms) for each copy of the server. On most modern operating systems, this amount can easily be allocated. However, if you are running many copies of the server or you explicitly configure the server to use large amounts of System V shared memory (see &lt;a href=&quot;runtime-config-resource#GUC-SHARED-MEMORY-TYPE&quot;&gt;shared_memory_type&lt;/a&gt; and &lt;a href=&quot;runtime-config-resource#GUC-DYNAMIC-SHARED-MEMORY-TYPE&quot;&gt;dynamic_shared_memory_type&lt;/a&gt;), it may be necessary to increase &lt;code&gt;SHMALL&lt;/code&gt;, which is the total amount of System V shared memory system-wide. Note that &lt;code&gt;SHMALL&lt;/code&gt; is measured in pages rather than bytes on many systems.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2c20c79653dcae8f8fc047710211c040521d5bc" translate="yes" xml:space="preserve">
          <source>PostgreSQL requires the operating system to provide inter-process communication (IPC) features, specifically shared memory and semaphores. Unix-derived systems typically provide &amp;ldquo;System V&amp;rdquo; IPC, &amp;ldquo;POSIX&amp;rdquo; IPC, or both. Windows has its own implementation of these features and is not discussed here.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36d337a94d7ba7a46b07377e19460ac78dd155d2" translate="yes" xml:space="preserve">
          <source>PostgreSQL streaming replication is asynchronous by default. If the primary server crashes then some transactions that were committed may not have been replicated to the standby server, causing data loss. The amount of data loss is proportional to the replication delay at the time of failover.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c42d1cce1b2b6028e2490c0570386d5f856bca2" translate="yes" xml:space="preserve">
          <source>PostgreSQL supports a powerful &lt;em&gt;rule system&lt;/em&gt; for the specification of &lt;em&gt;views&lt;/em&gt; and ambiguous &lt;em&gt;view updates&lt;/em&gt;. Originally the PostgreSQL rule system consisted of two implementations:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2241743d9fa8eb9bf19ded10e2bc6c68ceaf9df2" translate="yes" xml:space="preserve">
          <source>PostgreSQL supports automatic character set conversion between server and client for certain character set combinations. The conversion information is stored in the &lt;code&gt;pg_conversion&lt;/code&gt; system catalog. PostgreSQL comes with some predefined conversions, as shown in &lt;a href=&quot;multibyte#MULTIBYTE-TRANSLATION-TABLE&quot;&gt;Table 23.2&lt;/a&gt;. You can create a new conversion using the SQL command &lt;code&gt;CREATE CONVERSION&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7c3b9018391e76aa16042a998f014061b76d5bb" translate="yes" xml:space="preserve">
          <source>PostgreSQL supports basic table partitioning. This section describes why and how to implement partitioning as part of your database design.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e97f638eb1274873aa3e4e622cb72d93b7b7f24" translate="yes" xml:space="preserve">
          <source>PostgreSQL supports building indexes without locking out writes. This method is invoked by specifying the &lt;code&gt;CONCURRENTLY&lt;/code&gt; option of &lt;code&gt;CREATE INDEX&lt;/code&gt;. When this option is used, PostgreSQL must perform two scans of the table, and in addition it must wait for all existing transactions that could potentially modify or use the index to terminate. Thus this method requires more total work than a standard index build and takes significantly longer to complete. However, since it allows normal operations to continue while the index is built, this method is useful for adding new indexes in a production environment. Of course, the extra CPU and I/O load imposed by the index creation might slow other operations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf603007c3689d71b489ed77c1b75a8fa44bed1c" translate="yes" xml:space="preserve">
          <source>PostgreSQL supports parallel aggregation by aggregating in two stages. First, each process participating in the parallel portion of the query performs an aggregation step, producing a partial result for each group of which that process is aware. This is reflected in the plan as a &lt;code&gt;Partial Aggregate&lt;/code&gt; node. Second, the partial results are transferred to the leader via &lt;code&gt;Gather&lt;/code&gt; or &lt;code&gt;Gather Merge&lt;/code&gt;. Finally, the leader re-aggregates the results across all workers in order to produce the final result. This is reflected in the plan as a &lt;code&gt;Finalize Aggregate&lt;/code&gt; node.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98c96f2dead7b89b38c3c2461ff7cd5a4376ae6d" translate="yes" xml:space="preserve">
          <source>PostgreSQL supports rebuilding indexes with minimum locking of writes. This method is invoked by specifying the &lt;code&gt;CONCURRENTLY&lt;/code&gt; option of &lt;code&gt;REINDEX&lt;/code&gt;. When this option is used, PostgreSQL must perform two scans of the table for each index that needs to be rebuilt and wait for termination of all existing transactions that could potentially use the index. This method requires more total work than a standard index rebuild and takes significantly longer to complete as it needs to wait for unfinished transactions that might modify the index. However, since it allows normal operations to continue while the index is being rebuilt, this method is useful for rebuilding indexes in a production environment. Of course, the extra CPU, memory and I/O load imposed by the index rebuild may slow down other operations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b659630282ce6fbd7aba80155fab2795874d42d4" translate="yes" xml:space="preserve">
          <source>PostgreSQL supports row-level access, but &lt;code&gt;sepgsql&lt;/code&gt; does not.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef19df889c26aff47b13a779090fcd37550d60bb" translate="yes" xml:space="preserve">
          <source>PostgreSQL supports several methods for logging server messages, including stderr, csvlog and syslog. On Windows, eventlog is also supported. Set this parameter to a list of desired log destinations separated by commas. The default is to log to stderr only. This parameter can only be set in the &lt;code&gt;postgresql.conf&lt;/code&gt; file or on the server command line.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51899fa8eebb3b3aa74bb4a137479eee2fd66147" translate="yes" xml:space="preserve">
          <source>PostgreSQL supports several special date/time input values for convenience, as shown in &lt;a href=&quot;datatype-datetime#DATATYPE-DATETIME-SPECIAL-TABLE&quot;&gt;Table 8.13&lt;/a&gt;. The values &lt;code&gt;infinity&lt;/code&gt; and &lt;code&gt;-infinity&lt;/code&gt; are specially represented inside the system and will be displayed unchanged; but the others are simply notational shorthands that will be converted to ordinary date/time values when read. (In particular, &lt;code&gt;now&lt;/code&gt; and related strings are converted to a specific time value as soon as they are read.) All of these values need to be enclosed in single quotes when used as constants in SQL commands.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6c41dd3d36631eef9a60ad49bfd703137d3f4d8" translate="yes" xml:space="preserve">
          <source>PostgreSQL supports the full set of SQL date and time types, shown in &lt;a href=&quot;datatype-datetime#DATATYPE-DATETIME-TABLE&quot;&gt;Table 8.9&lt;/a&gt;. The operations available on these data types are described in &lt;a href=&quot;functions-datetime&quot;&gt;Section 9.9&lt;/a&gt;. Dates are counted according to the Gregorian calendar, even in years before that calendar was introduced (see &lt;a href=&quot;datetime-units-history&quot;&gt;Section B.5&lt;/a&gt; for more information).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f14a3d6cb75702f32d5dc071e65c1dc41ad01772" translate="yes" xml:space="preserve">
          <source>PostgreSQL supports the standard SQL types &lt;code&gt;int&lt;/code&gt;, &lt;code&gt;smallint&lt;/code&gt;, &lt;code&gt;real&lt;/code&gt;, &lt;code&gt;double precision&lt;/code&gt;, &lt;code&gt;char(N)&lt;/code&gt;, &lt;code&gt;varchar(N)&lt;/code&gt;, &lt;code&gt;date&lt;/code&gt;, &lt;code&gt;time&lt;/code&gt;, &lt;code&gt;timestamp&lt;/code&gt;, and &lt;code&gt;interval&lt;/code&gt;, as well as other types of general utility and a rich set of geometric types. PostgreSQL can be customized with an arbitrary number of user-defined data types. Consequently, type names are not key words in the syntax, except where required to support special cases in the SQL standard.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d51b565fec4c2b0e44f5a1d45ac9c129a9f5580" translate="yes" xml:space="preserve">
          <source>PostgreSQL treats the settings &lt;code&gt;origin&lt;/code&gt; and &lt;code&gt;local&lt;/code&gt; the same internally. Third-party replication systems may use these two values for their internal purposes, for example using &lt;code&gt;local&lt;/code&gt; to designate a session whose changes should not be replicated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="749a4f6a11ea83f98676b6594e8c9efc963bc390" translate="yes" xml:space="preserve">
          <source>PostgreSQL type</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47a27d79e52ae2c7462f626790ad2829a449a676" translate="yes" xml:space="preserve">
          <source>PostgreSQL uses a fixed page size (commonly 8 kB), and does not allow tuples to span multiple pages. Therefore, it is not possible to store very large field values directly. To overcome this limitation, large field values are compressed and/or broken up into multiple physical rows. This happens transparently to the user, with only small impact on most of the backend code. The technique is affectionately known as TOAST (or &amp;ldquo;the best thing since sliced bread&amp;rdquo;). The TOAST infrastructure is also used to improve handling of large data values in-memory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1529abe3421ea489100f9759672bf8f68aa03a3" translate="yes" xml:space="preserve">
          <source>PostgreSQL version information. See also &lt;a href=&quot;runtime-config-preset#GUC-SERVER-VERSION-NUM&quot;&gt;server_version_num&lt;/a&gt; for a machine-readable version.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79b79e94e250861d3a37b2b81991c08edde567f2" translate="yes" xml:space="preserve">
          <source>PostgreSQL versions before 9.5 used slightly different operator precedence rules. In particular, &lt;code&gt;&amp;lt;=&lt;/code&gt;&lt;code&gt;&amp;gt;=&lt;/code&gt; and &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; used to be treated as generic operators; &lt;code&gt;IS&lt;/code&gt; tests used to have higher priority; and &lt;code&gt;NOT BETWEEN&lt;/code&gt; and related constructs acted inconsistently, being taken in some cases as having the precedence of &lt;code&gt;NOT&lt;/code&gt; rather than &lt;code&gt;BETWEEN&lt;/code&gt;. These rules were changed for better compliance with the SQL standard and to reduce confusion from inconsistent treatment of logically equivalent constructs. In most cases, these changes will result in no behavioral change, or perhaps in &amp;ldquo;no such operator&amp;rdquo; failures which can be resolved by adding parentheses. However there are corner cases in which a query might change behavior without any parsing error being reported. If you are concerned about whether these changes have silently broken something, you can test your application with the configuration parameter &lt;a href=&quot;runtime-config-compatible#GUC-OPERATOR-PRECEDENCE-WARNING&quot;&gt;operator_precedence_warning&lt;/a&gt; turned on to see if any warnings are logged.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b12aba1a6149cc1a1cc6de75b2d9db3d7327f976" translate="yes" xml:space="preserve">
          <source>PostgreSQL versions before 9.6 did not provide any guarantees about the timing of evaluation of output expressions versus sorting and limiting; it depended on the form of the chosen query plan.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a330d6e333f0e705b7dbdae815c080baf029fd11" translate="yes" xml:space="preserve">
          <source>PostgreSQL will accept &lt;code&gt;BY VALUE&lt;/code&gt; or &lt;code&gt;BY REF&lt;/code&gt; in an &lt;code&gt;XMLEXISTS&lt;/code&gt; or &lt;code&gt;XMLTABLE&lt;/code&gt; construct, but it ignores them. The &lt;code&gt;xml&lt;/code&gt; data type holds a character-string serialized representation, so there is no node identity to preserve, and passing is always effectively &lt;code&gt;BY VALUE&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46668d602303093fd5436b07b8510921686fe19b" translate="yes" xml:space="preserve">
          <source>PostgreSQL will allow superusers to create databases with &lt;code&gt;SQL_ASCII&lt;/code&gt; encoding even when &lt;code&gt;LC_CTYPE&lt;/code&gt; is not &lt;code&gt;C&lt;/code&gt; or &lt;code&gt;POSIX&lt;/code&gt;. As noted above, &lt;code&gt;SQL_ASCII&lt;/code&gt; does not enforce that the data stored in the database has any particular encoding, and so this choice poses risks of locale-dependent misbehavior. Using this combination of settings is deprecated and may someday be forbidden altogether.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4c3b94e027418ea1293e7cfc1afc35261ba39ee" translate="yes" xml:space="preserve">
          <source>PostgreSQL will apply this expansion behavior to any composite-valued expression, although as shown &lt;a href=&quot;rowtypes#ROWTYPES-ACCESSING&quot;&gt;above&lt;/a&gt;, you need to write parentheses around the value that &lt;code&gt;.*&lt;/code&gt; is applied to whenever it's not a simple table name. For example, if &lt;code&gt;myfunc()&lt;/code&gt; is a function returning a composite type with columns &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt;, and &lt;code&gt;c&lt;/code&gt;, then these two queries have the same result:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c89f6a3f1560a7bd4653723f3e72dbf1311168a6" translate="yes" xml:space="preserve">
          <source>PostgreSQL will attempt to convert the column's default value (if any) to the new type, as well as any constraints that involve the column. But these conversions might fail, or might produce surprising results. It's often best to drop any constraints on the column before altering its type, and then add back suitably modified constraints afterwards.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23adfa969a97323ee3ec177a7dcb8f6884bb3a0c" translate="yes" xml:space="preserve">
          <source>PostgreSQL's &lt;a href=&quot;mvcc-intro&quot;&gt;MVCC&lt;/a&gt; transaction semantics depend on being able to compare transaction ID (XID) numbers: a row version with an insertion XID greater than the current transaction's XID is &amp;ldquo;in the future&amp;rdquo; and should not be visible to the current transaction. But since transaction IDs have limited size (32 bits) a cluster that runs for a long time (more than 4 billion transactions) would suffer &lt;em&gt;transaction ID wraparound&lt;/em&gt;: the XID counter wraps around to zero, and all of a sudden transactions that were in the past appear to be in the future &amp;mdash; which means their output become invisible. In short, catastrophic data loss. (Actually the data is still there, but that's cold comfort if you cannot get at it.) To avoid this, it is necessary to vacuum every table in every database at least once every two billion transactions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d01ad7a96af1c4c37b0765a65b29de55d59ec177" translate="yes" xml:space="preserve">
          <source>PostgreSQL's &lt;a href=&quot;sql-vacuum&quot;&gt;VACUUM&lt;/a&gt; command has to process each table on a regular basis for several reasons:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d397eedb2e425cb61e6640819576e2ece268547" translate="yes" xml:space="preserve">
          <source>PostgreSQL's &lt;em&gt;statistics collector&lt;/em&gt; is a subsystem that supports collection and reporting of information about server activity. Presently, the collector can count accesses to tables and indexes in both disk-block and individual-row terms. It also tracks the total number of rows in each table, and information about vacuum and analyze actions for each table. It can also count calls to user-defined functions and the total time spent in each one.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa34938a4c0bdb7ddaed6ea9437aad3e7e7c20a7" translate="yes" xml:space="preserve">
          <source>PostgreSQL's JIT implementation can inline the bodies of functions of types &lt;code&gt;C&lt;/code&gt; and &lt;code&gt;internal&lt;/code&gt;, as well as operators based on such functions. To do so for functions in extensions, the definitions of those functions need to be made available. When using &lt;a href=&quot;https://www.postgresql.org/docs/12/extend-pgxs.html&quot;&gt;PGXS&lt;/a&gt; to build an extension against a server that has been compiled with LLVM JIT support, the relevant files will be built and installed automatically.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2ce9be22eb538937b290524f1a893fff9a3a342" translate="yes" xml:space="preserve">
          <source>PostgreSQL's foreign-data functionality is still under active development. Optimization of queries is primitive (and mostly left to the wrapper, too). Thus, there is considerable room for future performance improvements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="045ba636eac8c350bd9d92d07f5b544b6d689ef6" translate="yes" xml:space="preserve">
          <source>PostgreSQL's implementation of SQL/JSON path language has the following deviations from the SQL/JSON standard:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6512655ce0206ad2e55af59128437c19a85eef8" translate="yes" xml:space="preserve">
          <source>PostgreSQL's regular expressions are implemented using a software package written by Henry Spencer. Much of the description of regular expressions below is copied verbatim from his manual.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b89dce84ea21263b16697e60b4c1b4c85d27493" translate="yes" xml:space="preserve">
          <source>PostgreSQL's text search features are described at length in &lt;a href=&quot;https://www.postgresql.org/docs/12/textsearch.html&quot;&gt;Chapter 12&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39f6a42a4fb0039de8b2fce0531aa5cf8bf17009" translate="yes" xml:space="preserve">
          <source>PostgreSQL-style typecast</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19b427c5cf5eb995bfcd7725e3fbf7217d1adcbd" translate="yes" xml:space="preserve">
          <source>Poul-Henning Kamp</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17ae45bd355f880cc7401f24ea563dca0df2e7d4" translate="yes" xml:space="preserve">
          <source>Pre-loaded catalog rows must have preassigned OIDs if there are OID references to them in other pre-loaded rows. A preassigned OID is also needed if the row's OID must be referenced from C code. If neither case applies, the &lt;code&gt;oid&lt;/code&gt; metadata field can be omitted, in which case the bootstrap code assigns an OID automatically. In practice we usually preassign OIDs for all or none of the pre-loaded rows in a given catalog, even if only some of them are actually cross-referenced.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9eee28bfd739e1debf4d3b892d013537ae16da9f" translate="yes" xml:space="preserve">
          <source>Predicate</source>
          <target state="translated">Predicate</target>
        </trans-unit>
        <trans-unit id="24fe09a1cf90d17df4307cd57797792c845342fc" translate="yes" xml:space="preserve">
          <source>Predicate locks in PostgreSQL, like in most other database systems, are based on data actually accessed by a transaction. These will show up in the &lt;a href=&quot;view-pg-locks&quot;&gt;&lt;code&gt;pg_locks&lt;/code&gt;&lt;/a&gt; system view with a &lt;code&gt;mode&lt;/code&gt; of &lt;code&gt;SIReadLock&lt;/code&gt;. The particular locks acquired during execution of a query will depend on the plan used by the query, and multiple finer-grained locks (e.g., tuple locks) may be combined into fewer coarser-grained locks (e.g., page locks) during the course of the transaction to prevent exhaustion of the memory used to track the locks. A &lt;code&gt;READ ONLY&lt;/code&gt; transaction may be able to release its SIRead locks before completion, if it detects that no conflicts can still occur which could lead to a serialization anomaly. In fact, &lt;code&gt;READ ONLY&lt;/code&gt; transactions will often be able to establish that fact at startup and avoid taking any predicate locks. If you explicitly request a &lt;code&gt;SERIALIZABLE READ ONLY DEFERRABLE&lt;/code&gt; transaction, it will block until it can establish this fact. (This is the &lt;em&gt;only&lt;/em&gt; case where Serializable transactions block but Repeatable Read transactions don't.) On the other hand, SIRead locks often need to be kept past transaction commit, until overlapping read write transactions complete.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a2a4f6fed53f092f075c647902092f49dff565c" translate="yes" xml:space="preserve">
          <source>Prepare all statements before using them. Libecpg will keep a cache of prepared statements and reuse a statement if it gets executed again. If the cache runs full, libecpg will free the least used statement.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="805b0426cd8c493c6395add1e59cb6d57cc782f6" translate="yes" xml:space="preserve">
          <source>Prepare for an index scan. The &lt;code&gt;nkeys&lt;/code&gt; and &lt;code&gt;norderbys&lt;/code&gt; parameters indicate the number of quals and ordering operators that will be used in the scan; these may be useful for space allocation purposes. Note that the actual values of the scan keys aren't provided yet. The result must be a palloc'd struct. For implementation reasons the index access method &lt;em&gt;must&lt;/em&gt; create this struct by calling &lt;code&gt;RelationGetIndexScan()&lt;/code&gt;. In most cases &lt;code&gt;ambeginscan&lt;/code&gt; does little beyond making that call and perhaps acquiring locks; the interesting parts of index-scan startup are in &lt;code&gt;amrescan&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1badb6123149d2dd80187b1001e17317e0376a45" translate="yes" xml:space="preserve">
          <source>Prepare for performing on-line backup (restricted to superusers by default, but other users can be granted EXECUTE to run the function)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea6420d9e6ea0b317eaaff702554d4ab07b95961" translate="yes" xml:space="preserve">
          <source>Prepare the current transaction for two-phase commit, using &lt;code&gt;foobar&lt;/code&gt; as the transaction identifier:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5eccdbb667192934bc79ff3dadac066bfd3213f5" translate="yes" xml:space="preserve">
          <source>Prepared statements (either explicitly prepared or implicitly generated, for example by PL/pgSQL) can be executed using custom or generic plans. Custom plans are made afresh for each execution using its specific set of parameter values, while generic plans do not rely on the parameter values and can be re-used across executions. Thus, use of a generic plan saves planning time, but if the ideal plan depends strongly on the parameter values then a generic plan may be inefficient. The choice between these options is normally made automatically, but it can be overridden with &lt;code&gt;plan_cache_mode&lt;/code&gt;. The allowed values are &lt;code&gt;auto&lt;/code&gt; (the default), &lt;code&gt;force_custom_plan&lt;/code&gt; and &lt;code&gt;force_generic_plan&lt;/code&gt;. This setting is considered when a cached plan is to be executed, not when it is prepared. For more information see &lt;a href=&quot;sql-prepare&quot;&gt;PREPARE&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d2d9ca4ec55b877233447dcb48943c2ef02e7aa" translate="yes" xml:space="preserve">
          <source>Prepared statements can take parameters: values that are substituted into the statement when it is executed. When creating the prepared statement, refer to parameters by position, using &lt;code&gt;$1&lt;/code&gt;, &lt;code&gt;$2&lt;/code&gt;, etc. A corresponding list of parameter data types can optionally be specified. When a parameter's data type is not specified or is declared as &lt;code&gt;unknown&lt;/code&gt;, the type is inferred from the context in which the parameter is first referenced (if possible). When executing the statement, specify the actual values for these parameters in the &lt;code&gt;EXECUTE&lt;/code&gt; statement. Refer to &lt;a href=&quot;sql-execute&quot;&gt;EXECUTE&lt;/a&gt; for more information about that.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23037ec79dcb923a75cebd6186549d643c581e91" translate="yes" xml:space="preserve">
          <source>Prepared statements only last for the duration of the current database session. When the session ends, the prepared statement is forgotten, so it must be recreated before being used again. This also means that a single prepared statement cannot be used by multiple simultaneous database clients; however, each client can create their own prepared statement to use. Prepared statements can be manually cleaned up using the &lt;a href=&quot;sql-deallocate&quot;&gt;DEALLOCATE&lt;/a&gt; command.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a483a03c91ae871a21f8ef97015a97d796c2feb5" translate="yes" xml:space="preserve">
          <source>Prepared statements potentially have the largest performance advantage when a single session is being used to execute a large number of similar statements. The performance difference will be particularly significant if the statements are complex to plan or rewrite, e.g. if the query involves a join of many tables or requires the application of several rules. If the statement is relatively simple to plan and rewrite but relatively expensive to execute, the performance advantage of prepared statements will be less noticeable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16e489d5458780c56ecec5255859ffa473005ad5" translate="yes" xml:space="preserve">
          <source>Presently, &lt;code&gt;COPY TO&lt;/code&gt; will never emit an octal or hex-digits backslash sequence, but it does use the other sequences listed above for those control characters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa75b2cb1f42b5b78ef47e3bac6d7cbc20568a8c" translate="yes" xml:space="preserve">
          <source>Presently, &lt;code&gt;ON SELECT&lt;/code&gt; rules must be unconditional &lt;code&gt;INSTEAD&lt;/code&gt; rules and must have actions that consist of a single &lt;code&gt;SELECT&lt;/code&gt; command. Thus, an &lt;code&gt;ON SELECT&lt;/code&gt; rule effectively turns the table into a view, whose visible contents are the rows returned by the rule's &lt;code&gt;SELECT&lt;/code&gt; command rather than whatever had been stored in the table (if anything). It is considered better style to write a &lt;code&gt;CREATE VIEW&lt;/code&gt; command than to create a real table and define an &lt;code&gt;ON SELECT&lt;/code&gt; rule for it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52172a45fa35ea47ee37481a7598605f94332941" translate="yes" xml:space="preserve">
          <source>Presently, all data values in a binary-format file are assumed to be in binary format (format code one). It is anticipated that a future extension might add a header field that allows per-column format codes to be specified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07a55fa2dfc20be04c1afe40194156f4b790bc71" translate="yes" xml:space="preserve">
          <source>Presently, if a rule action contains a &lt;code&gt;NOTIFY&lt;/code&gt; command, the &lt;code&gt;NOTIFY&lt;/code&gt; command will be executed unconditionally, that is, the &lt;code&gt;NOTIFY&lt;/code&gt; will be issued even if there are not any rows that the rule should apply to. For example, in:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70f8a5644dc2d0fd28dd5618b027e4363107a89a" translate="yes" xml:space="preserve">
          <source>Presently, the commands emitted for &lt;code&gt;--disable-triggers&lt;/code&gt; must be done as superuser. So you should also specify a superuser name with &lt;code&gt;-S&lt;/code&gt; or, preferably, run pg_restore as a PostgreSQL superuser.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48866779c6574ae0eb32e070be6be5c56e3ca440" translate="yes" xml:space="preserve">
          <source>Presently, the commands emitted for &lt;code&gt;--disable-triggers&lt;/code&gt; must be done as superuser. So, you should also specify a superuser name with &lt;code&gt;-S&lt;/code&gt;, or preferably be careful to start the resulting script as a superuser.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="334d01d9c8e3bbf43f71d7eda4f0774b3bc44f64" translate="yes" xml:space="preserve">
          <source>Preset Options</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e96fea52df5eb0d7ea088eb0523f5fd6be20645f" translate="yes" xml:space="preserve">
          <source>Prev</source>
          <target state="translated">Prev</target>
        </trans-unit>
        <trans-unit id="ee7bdb0dff39839c1fd827f5826a7bfd60c2d7e2" translate="yes" xml:space="preserve">
          <source>Prevent dumping of access privileges (grant/revoke commands).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0771736ef9369c38d7919dcb8f69f80ef4855cc" translate="yes" xml:space="preserve">
          <source>Prevent restoration of access privileges (grant/revoke commands).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="233b752a1d979d1b03bfc00189d385eb81deac5c" translate="yes" xml:space="preserve">
          <source>Preventing Server Spoofing</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b97befde20e55eaecab9bab9cc63c02e247c4a9f" translate="yes" xml:space="preserve">
          <source>Previous releases failed to preserve a lock which is upgraded by a later savepoint. For example, this code:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e203068f90ee842092a40f00034de5e2bf0c940" translate="yes" xml:space="preserve">
          <source>Primary keys are useful both for documentation purposes and for client applications. For example, a GUI application that allows modifying row values probably needs to know the primary key of a table to be able to identify rows uniquely. There are also various ways in which the database system makes use of a primary key if one has been declared; for example, the primary key defines the default target column(s) for foreign keys referencing its table.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="302096a883e851361a7c65e770ac4a2f93b77640" translate="yes" xml:space="preserve">
          <source>Primary keys can span more than one column; the syntax is similar to unique constraints:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54c622f5b5e8c75c7d4757c68339aa2e8b25f7fc" translate="yes" xml:space="preserve">
          <source>Primary log file name, or log in the requested format, currently in use by the logging collector</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a03aad5c247b986acad6d97b6927c2a6ffb1095" translate="yes" xml:space="preserve">
          <source>Primitive JSON values are compared using the same comparison rules as for the underlying PostgreSQL data type. Strings are compared using the default database collation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f9dd23572b66164559cf3545fb93e79c89e5d8a" translate="yes" xml:space="preserve">
          <source>Principal used to authenticate this connection, or NULL if GSSAPI was not used to authenticate this connection. This field is truncated if the principal is longer than &lt;code&gt;NAMEDATALEN&lt;/code&gt; (64 characters in a standard build).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7e7318f55e0c844d9e1050c000b470ae6a8596e" translate="yes" xml:space="preserve">
          <source>Print additional information including the version and the &quot;include&quot; path.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8de0f5082ac6065288eac684400de412407c144" translate="yes" xml:space="preserve">
          <source>Print all nonempty input lines to standard output as they are read. (This does not apply to lines read interactively.) This is equivalent to setting the variable &lt;code&gt;ECHO&lt;/code&gt; to &lt;code&gt;all&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ebb9a1e5bbdb1243d5e4a31dff31eebe9fc06f03" translate="yes" xml:space="preserve">
          <source>Print debugging output from the bootstrap backend and a few other messages of lesser interest for the general public. The bootstrap backend is the program &lt;code&gt;initdb&lt;/code&gt; uses to create the catalog tables. This option generates a tremendous amount of extremely boring output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7c370355f00f0bd758a9808623b790c218141fd" translate="yes" xml:space="preserve">
          <source>Print debugging output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0d63d35347e807b3cd5630fcccfcb97aefdff03" translate="yes" xml:space="preserve">
          <source>Print detailed information during processing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c073dbd6b543c579fb650eb5ea8d11e57c402573" translate="yes" xml:space="preserve">
          <source>Print failed SQL commands to standard error output. This is equivalent to setting the variable &lt;code&gt;ECHO&lt;/code&gt; to &lt;code&gt;errors&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="597bb464eafa276a5ad0cc91e76eaf6190c85748" translate="yes" xml:space="preserve">
          <source>Print lots of debug logging output on &lt;code&gt;stderr&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a75f64b677ea04810bae39f5467bba0bd440ec28" translate="yes" xml:space="preserve">
          <source>Print only errors, no informational messages.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f01f9df20b27d4321c4eb47d64e1ce581df8c21" translate="yes" xml:space="preserve">
          <source>Print psql's command line history to &lt;code&gt;filename&lt;/code&gt;. If &lt;code&gt;filename&lt;/code&gt; is omitted, the history is written to the standard output (using the pager if appropriate). This command is not available if psql was built without Readline support.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="827ff74717cfd2b965ff32b6c6548085dff68335" translate="yes" xml:space="preserve">
          <source>Print the clusterdb version and exit.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6d64dc0309d9d3b50923addc35c2349b3a13866" translate="yes" xml:space="preserve">
          <source>Print the createdb version and exit.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9c1069309fb6fad15e176f641cc5f92410a215f" translate="yes" xml:space="preserve">
          <source>Print the createuser version and exit.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ca986b09253f90ac05485c4d1b53fd88df68efc" translate="yes" xml:space="preserve">
          <source>Print the current query buffer to the standard output. If the current query buffer is empty, the most recently executed query is printed instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1947bab167f53773caffcdb3abd24d61e23f4340" translate="yes" xml:space="preserve">
          <source>Print the dropdb version and exit.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c27b83ad0e23795e57b1563b077c538c9ab60bb3" translate="yes" xml:space="preserve">
          <source>Print the dropuser version and exit.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9eeca2b3e3f27d8960033787d850e4053105026" translate="yes" xml:space="preserve">
          <source>Print the ecpg version and exit.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="657af6d675a70187bdfd892abd1e767e65979526" translate="yes" xml:space="preserve">
          <source>Print the initdb version and exit.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a31c7045982c28354a2311d649532f2714d0cd52" translate="yes" xml:space="preserve">
          <source>Print the location of C header files for server programming.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7399f9aea54b81806345b5fe9d88c09f2b217c4" translate="yes" xml:space="preserve">
          <source>Print the location of C header files of the client interfaces.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="595d5d7d00e3b9031bcf9b394461136007040d8b" translate="yes" xml:space="preserve">
          <source>Print the location of HTML documentation files.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c45a54aeef843a3b47abadef8be23a9c8c5faa3" translate="yes" xml:space="preserve">
          <source>Print the location of architecture-independent support files.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6938b263f35a6474ff201cc4e757d0f937313671" translate="yes" xml:space="preserve">
          <source>Print the location of documentation files.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38bf4c616b7c56d3f58464d10d1a64af7f6e8779" translate="yes" xml:space="preserve">
          <source>Print the location of dynamically loadable modules, or where the server would search for them. (Other architecture-dependent data files might also be installed in this directory.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53148cc85f0f5372b92b4adab97d78f0cf599385" translate="yes" xml:space="preserve">
          <source>Print the location of extension makefiles.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4dee3cc7ede35752aad16661b510c6ddc2cb5087" translate="yes" xml:space="preserve">
          <source>Print the location of locale support files. (This will be an empty string if locale support was not configured when PostgreSQL was built.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8935ed932264eb12d05dc3d54390bc5894e6a109" translate="yes" xml:space="preserve">
          <source>Print the location of manual pages.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c6b2cdac40039c6a4b46eed898e35031563c475" translate="yes" xml:space="preserve">
          <source>Print the location of object code libraries.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc4be32137a130cb7e8939f72a35980a1297a7e0" translate="yes" xml:space="preserve">
          <source>Print the location of other C header files.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="348ec650580d85aaddcb30661d2eb9345e76019a" translate="yes" xml:space="preserve">
          <source>Print the location of system-wide configuration files.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4773e766d5cc8cfc3ce755cd29aeb486a0dd05ae" translate="yes" xml:space="preserve">
          <source>Print the location of user executables. Use this, for example, to find the &lt;code&gt;psql&lt;/code&gt; program. This is normally also the location where the &lt;code&gt;pg_config&lt;/code&gt; program resides.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53049ab5ef89f22bb5a6370fb0f7681de3a90603" translate="yes" xml:space="preserve">
          <source>Print the names of the files that would have been removed on &lt;code&gt;stdout&lt;/code&gt; (performs a dry run).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c56e3a83e3c5d8c7d0ed82cb15ca361eb64f1dd" translate="yes" xml:space="preserve">
          <source>Print the options that were given to the &lt;code&gt;configure&lt;/code&gt; script when PostgreSQL was configured for building. This can be used to reproduce the identical configuration, or to find out with what options a binary package was built. (Note however that binary packages often contain vendor-specific custom patches.) See also the examples below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b85724f77cfb0e7f274dc964acb424d6648ba3f5" translate="yes" xml:space="preserve">
          <source>Print the pg_archivecleanup version and exit.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74b744744ac1bd9386b12893ce62c91739371ca7" translate="yes" xml:space="preserve">
          <source>Print the pg_basebackup version and exit.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1fca2718d1cfc02986e8abfd6906319ca68c5805" translate="yes" xml:space="preserve">
          <source>Print the pg_checksums version and exit.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bff35bc331305f42d0adc605e5c4b58b8bea0e9f" translate="yes" xml:space="preserve">
          <source>Print the pg_ctl version and exit.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f2c8e42d192d577eaeaaebcc2a4ef29dbe17a60" translate="yes" xml:space="preserve">
          <source>Print the pg_dump version and exit.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="711f70c380c99649a9e35f12c5de7cf7f0629905" translate="yes" xml:space="preserve">
          <source>Print the pg_dumpall version and exit.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8234e166090222ac3be3d5f09ddf8625331bebb7" translate="yes" xml:space="preserve">
          <source>Print the pg_isready version and exit.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="521a97d4453901044173e646cb65a707141a7eb2" translate="yes" xml:space="preserve">
          <source>Print the pg_receivewal version and exit.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8fea9240f920d019a51b3b8ffd1d91229e6f0d5d" translate="yes" xml:space="preserve">
          <source>Print the pg_recvlogical version and exit.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70b6553fafd53c48b770a9da4d3ec37d70a8b1bd" translate="yes" xml:space="preserve">
          <source>Print the pg_restore version and exit.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c61b85690c18a6b2ca1bca9177c45ff31b5bf02" translate="yes" xml:space="preserve">
          <source>Print the pg_test_fsync version and exit.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b30cd37e82aef2f652a2277ade9f7c97f25f875b" translate="yes" xml:space="preserve">
          <source>Print the pg_test_timing version and exit.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a75796fa54df85333380d1e7052d5f64abec4dce" translate="yes" xml:space="preserve">
          <source>Print the pg_waldump version and exit.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="835f88fb67301afbc19bedf23ff78555f1978387" translate="yes" xml:space="preserve">
          <source>Print the pgbench version and exit.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f24e000355bdd04337ccc4fe4d288fbdae421623" translate="yes" xml:space="preserve">
          <source>Print the postgres version and exit.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a240d07648994ecf31009ecc7c34fcbc6cd8c620" translate="yes" xml:space="preserve">
          <source>Print the psql version and exit.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9739b8f99cc181f488382f72fe14dfc0f6cbc479" translate="yes" xml:space="preserve">
          <source>Print the reindexdb version and exit.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ecaad77a21e5cec5eaf16f12e5d3692f68b6cf4f" translate="yes" xml:space="preserve">
          <source>Print the vacuumdb version and exit.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="860a0a17430dffac960ad73d395384c352d45cdd" translate="yes" xml:space="preserve">
          <source>Print the value of the &lt;code&gt;CC&lt;/code&gt; variable that was used for building PostgreSQL. This shows the C compiler used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7872c242661cddddfe9f42b05b47dc0212422396" translate="yes" xml:space="preserve">
          <source>Print the value of the &lt;code&gt;CFLAGS&lt;/code&gt; variable that was used for building PostgreSQL. This shows C compiler switches.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04b3c2f0676508a38269ff7567031f4ef2b568d8" translate="yes" xml:space="preserve">
          <source>Print the value of the &lt;code&gt;CFLAGS_SL&lt;/code&gt; variable that was used for building PostgreSQL. This shows extra C compiler switches used for building shared libraries.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c0bdef9295fb7af405415912b5de766b9d4853d" translate="yes" xml:space="preserve">
          <source>Print the value of the &lt;code&gt;CPPFLAGS&lt;/code&gt; variable that was used for building PostgreSQL. This shows C compiler switches needed at preprocessing time (typically, &lt;code&gt;-I&lt;/code&gt; switches).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0696181ec9c948b2b028ffaf665cb6bea3b893d7" translate="yes" xml:space="preserve">
          <source>Print the value of the &lt;code&gt;LDFLAGS&lt;/code&gt; variable that was used for building PostgreSQL. This shows linker switches.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6bb0fe5ffeea6cad2f014a2a3a3b8da60923296c" translate="yes" xml:space="preserve">
          <source>Print the value of the &lt;code&gt;LDFLAGS_EX&lt;/code&gt; variable that was used for building PostgreSQL. This shows linker switches used for building executables only.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="afbd4079f245521defb38cf6819d6a459fcf80ee" translate="yes" xml:space="preserve">
          <source>Print the value of the &lt;code&gt;LDFLAGS_SL&lt;/code&gt; variable that was used for building PostgreSQL. This shows linker switches used for building shared libraries only.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ca57dae88c29583c5d57897894867bc83f03e6b" translate="yes" xml:space="preserve">
          <source>Print the value of the &lt;code&gt;LIBS&lt;/code&gt; variable that was used for building PostgreSQL. This normally contains &lt;code&gt;-l&lt;/code&gt; switches for external libraries linked into PostgreSQL.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8570b6b8795434406c72b8b33b0f9520fcd7b330" translate="yes" xml:space="preserve">
          <source>Print the version of PostgreSQL.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7df780f62e4b06755a28e7503d78d06b7b6aac8" translate="yes" xml:space="preserve">
          <source>Print time information and other statistics at the end of each command. This is useful for benchmarking or for use in tuning the number of buffers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7df4a5fb243017c5e16941bc4e0dfea430b29b29" translate="yes" xml:space="preserve">
          <source>Print timing statistics for each query relating to each of the major system modules. This option cannot be used together with the &lt;code&gt;-s&lt;/code&gt; option.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85a0746f8a9b8ded581582b11332c0023bccc928" translate="yes" xml:space="preserve">
          <source>Print verbose debugging output that is mostly useful for developers debugging pg_rewind.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97b0c0a03f737e5ff32021d5ed70701853641a62" translate="yes" xml:space="preserve">
          <source>Prints a detailed vacuum activity report for each table.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fdb87a5e1b1bdc10bff754f8e203de6fe5cda103" translate="yes" xml:space="preserve">
          <source>Prints a progress report as each index is reindexed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa656d5b9337debc039cad558013cd97db922af4" translate="yes" xml:space="preserve">
          <source>Prints a progress report as each table is clustered.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8b2b40104cd92cd0c519f2553360402afa05710" translate="yes" xml:space="preserve">
          <source>Prints the arguments to the standard output, separated by one space and followed by a newline. This can be useful to intersperse information in the output of scripts. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f89aa4d95dc992bd35115af766260f55953c5bc3" translate="yes" xml:space="preserve">
          <source>Prints the value of the named run-time parameter, and exits. (See the &lt;code&gt;-c&lt;/code&gt; option above for details.) This can be used on a running server, and returns values from &lt;code&gt;postgresql.conf&lt;/code&gt;, modified by any parameters supplied in this invocation. It does not reflect parameters supplied when the cluster was started.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4dcba485023d207a9206ea5fc3e3c00fb561414e" translate="yes" xml:space="preserve">
          <source>Prior releases of PostgreSQL also had an R-tree index method. This method has been removed because it had no significant advantages over the GiST method. If &lt;code&gt;USING rtree&lt;/code&gt; is specified, &lt;code&gt;CREATE INDEX&lt;/code&gt; will interpret it as &lt;code&gt;USING gist&lt;/code&gt;, to simplify conversion of old databases to GiST.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3bafe92248149caf71bc79d94b8990987f12cfb7" translate="yes" xml:space="preserve">
          <source>Prior to PostgreSQL 10, this rule did not exist, and unspecified-type literals in a &lt;code&gt;SELECT&lt;/code&gt; output list were left as type &lt;code&gt;unknown&lt;/code&gt;. That had assorted bad consequences, so it's been changed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="35b1eb24223c97f90cf161ff4a23f9a4840e576e" translate="yes" xml:space="preserve">
          <source>Prior to PostgreSQL 12, it was possible to skip arbitrary text in the input string using non-letter or non-digit characters. For example, &lt;code&gt;to_timestamp('2000y6m1d', 'yyyy-MM-DD')&lt;/code&gt; used to work. Now you can only use letter characters for this purpose. For example, &lt;code&gt;to_timestamp('2000y6m1d', 'yyyytMMtDDt')&lt;/code&gt; and &lt;code&gt;to_timestamp('2000y6m1d', 'yyyy&quot;y&quot;MM&quot;m&quot;DD&quot;d&quot;')&lt;/code&gt; skip &lt;code&gt;y&lt;/code&gt;, &lt;code&gt;m&lt;/code&gt;, and &lt;code&gt;d&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="857acef4a685e40620b468c416dd0a4e24020172" translate="yes" xml:space="preserve">
          <source>Prior to PostgreSQL 8.2, the &lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;lt;=&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;gt;=&lt;/code&gt; cases were not handled per SQL specification. A comparison like &lt;code&gt;ROW(a,b) &amp;lt; ROW(c,d)&lt;/code&gt; was implemented as &lt;code&gt;a &amp;lt; c AND b &amp;lt; d&lt;/code&gt; whereas the correct behavior is equivalent to &lt;code&gt;a &amp;lt; c OR (a = c AND b &amp;lt; d)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ebe12687d87000c523fc24a0eeeef23def50ea6" translate="yes" xml:space="preserve">
          <source>Prior to PostgreSQL 8.2, the containment operators &lt;code&gt;@&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;@&lt;/code&gt; were called &lt;code&gt;@&lt;/code&gt; and &lt;code&gt;~&lt;/code&gt;, respectively. These names are still available, but are deprecated and will eventually be removed. Notice that the old names are reversed from the convention formerly followed by the core geometric data types!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5348a6ba1728be7d24665ecab38998e34ce72cc3" translate="yes" xml:space="preserve">
          <source>Prior to PostgreSQL 9.0, there was no permission structure associated with large objects. As a result, &lt;code&gt;pg_largeobject&lt;/code&gt; was publicly readable and could be used to obtain the OIDs (and contents) of all large objects in the system. This is no longer the case; use &lt;a href=&quot;catalog-pg-largeobject-metadata&quot;&gt;&lt;code&gt;pg_largeobject_metadata&lt;/code&gt;&lt;/a&gt; to obtain a list of large object OIDs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b601cf233ea62fc96a74bc628fe24fcc3e36d22e" translate="yes" xml:space="preserve">
          <source>Prior to PostgreSQL 9.3, only System V shared memory was used, so the amount of System V shared memory required to start the server was much larger. If you are running an older version of the server, please consult the documentation for your server version.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa951ebcd4fe7e0105a5593fae4e308d45c56780" translate="yes" xml:space="preserve">
          <source>Prior to PostgreSQL version 9.1, a request for the Serializable transaction isolation level provided exactly the same behavior described here. To retain the legacy Serializable behavior, Repeatable Read should now be requested.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="284364f281ed56be49bcacf7f01665e2a0a6fd04" translate="yes" xml:space="preserve">
          <source>Priority of this standby server for being chosen as the synchronous standby in a priority-based synchronous replication. This has no effect in a quorum-based synchronous replication.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="515ede092cef3c82a110d9534d9f8d3d6afc3135" translate="yes" xml:space="preserve">
          <source>Privilege</source>
          <target state="translated">Privilege</target>
        </trans-unit>
        <trans-unit id="f10ec7ea8e1d8b3a37e319a1b22811778ff9078d" translate="yes" xml:space="preserve">
          <source>Privilege and Ownership - &lt;code&gt;GRANT&lt;/code&gt;, &lt;code&gt;REVOKE&lt;/code&gt;, &lt;code&gt;REASSIGN&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de3a5e762db24187db518d22a3b23c1896a649d9" translate="yes" xml:space="preserve">
          <source>Privileges</source>
          <target state="translated">Privileges</target>
        </trans-unit>
        <trans-unit id="2a58093a093ab7a9a99a1645efb525934d0d372c" translate="yes" xml:space="preserve">
          <source>Privileges are only checked once at the start of a replication connection. They are not re-checked as each change record is read from the publisher, nor are they re-checked for each change when applied.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1787c604579783f25be8d303f900f7717e89e48f" translate="yes" xml:space="preserve">
          <source>Privileges on databases, tablespaces, schemas, and languages are PostgreSQL extensions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46289836967711686edf2dff70a298178c49970e" translate="yes" xml:space="preserve">
          <source>Probe that fires after dirty buffers have been written to the kernel, and before starting to issue fsync requests.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53ee2024c54dc2129f5d4dce9249284ce7d962e4" translate="yes" xml:space="preserve">
          <source>Probe that fires after each buffer is written during checkpoint. arg0 is the ID number of the buffer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c4f6900a8f3d94a47b827dad74ca58a7f090a3e" translate="yes" xml:space="preserve">
          <source>Probe that fires anytime the server process updates its &lt;code&gt;pg_stat_activity&lt;/code&gt;.&lt;code&gt;status&lt;/code&gt;. arg0 is the new status string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="453f8db7eb85902c8d7efba2100824b715baeb8d" translate="yes" xml:space="preserve">
          <source>Probe that fires at the start of a new transaction. arg0 is the transaction ID.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a3aefacb2b30c73490e38f66077f014ccc50ebf" translate="yes" xml:space="preserve">
          <source>Probe that fires before issuing any write request for a shared buffer. arg0 and arg1 contain the fork and block numbers of the page. arg2, arg3, and arg4 contain the tablespace, database, and relation OIDs identifying the relation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33d263a06d1f645788a7d9cc687ecf761651c94e" translate="yes" xml:space="preserve">
          <source>Probe that fires when a WAL record is inserted. arg0 is the resource manager (rmid) for the record. arg1 contains the info flags.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f1168c24751c9cc0c2a8a2c6b3927e1a19c2275" translate="yes" xml:space="preserve">
          <source>Probe that fires when a WAL segment switch is requested.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e4d476400e68096572772c60276c43e69c8a62b" translate="yes" xml:space="preserve">
          <source>Probe that fires when a block read is complete. arg0 and arg1 contain the fork and block numbers of the page. arg2, arg3, and arg4 contain the tablespace, database, and relation OIDs identifying the relation. arg5 is the ID of the backend which created the temporary relation for a local buffer, or &lt;code&gt;InvalidBackendId&lt;/code&gt; (-1) for a shared buffer. arg6 is the number of bytes actually read, while arg7 is the number requested (if these are different it indicates trouble).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bec87f01b3c4ae7574229debd84c5fd432c77b1a" translate="yes" xml:space="preserve">
          <source>Probe that fires when a block write is complete. arg0 and arg1 contain the fork and block numbers of the page. arg2, arg3, and arg4 contain the tablespace, database, and relation OIDs identifying the relation. arg5 is the ID of the backend which created the temporary relation for a local buffer, or &lt;code&gt;InvalidBackendId&lt;/code&gt; (-1) for a shared buffer. arg6 is the number of bytes actually written, while arg7 is the number requested (if these are different it indicates trouble).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46f91b3dd629f638c1e5b0918321dc6a1503deb9" translate="yes" xml:space="preserve">
          <source>Probe that fires when a buffer read is complete. arg0 and arg1 contain the fork and block numbers of the page (if this is a relation extension request, arg1 now contains the block number of the newly added block). arg2, arg3, and arg4 contain the tablespace, database, and relation OIDs identifying the relation. arg5 is the ID of the backend which created the temporary relation for a local buffer, or &lt;code&gt;InvalidBackendId&lt;/code&gt; (-1) for a shared buffer. arg6 is true for a relation extension request, false for normal read. arg7 is true if the buffer was found in the pool, false if not.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58ba85ae8dc3ff12abd986e1bbe24ce88cd6ffee" translate="yes" xml:space="preserve">
          <source>Probe that fires when a buffer read is started. arg0 and arg1 contain the fork and block numbers of the page (but arg1 will be -1 if this is a relation extension request). arg2, arg3, and arg4 contain the tablespace, database, and relation OIDs identifying the relation. arg5 is the ID of the backend which created the temporary relation for a local buffer, or &lt;code&gt;InvalidBackendId&lt;/code&gt; (-1) for a shared buffer. arg6 is true for a relation extension request, false for normal read.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0fbe84f59555154d75e50194b6717675ebf83d0f" translate="yes" xml:space="preserve">
          <source>Probe that fires when a checkpoint is complete. (The probes listed next fire in sequence during checkpoint processing.) arg0 is the number of buffers written. arg1 is the total number of buffers. arg2, arg3 and arg4 contain the number of WAL files added, removed and recycled respectively.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23fe54bf3cce9571085cc7cf6504d3feaa949415" translate="yes" xml:space="preserve">
          <source>Probe that fires when a checkpoint is started. arg0 holds the bitwise flags used to distinguish different checkpoint types, such as shutdown, immediate or force.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93bbd1ca880ff804d869958124aceb46cced58c3" translate="yes" xml:space="preserve">
          <source>Probe that fires when a deadlock is found by the deadlock detector.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd2095b8769349eb00b3e4c4c59eb7c9f09aa65d" translate="yes" xml:space="preserve">
          <source>Probe that fires when a dirty WAL buffer write is complete.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e06e64448ac61e5f30e9d0aae09a59b087a40467" translate="yes" xml:space="preserve">
          <source>Probe that fires when a dirty-buffer write is complete. The arguments are the same as for &lt;code&gt;buffer-write-dirty-start&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc7ff5d60d95edecd39d25ce953e04898f2adf03" translate="yes" xml:space="preserve">
          <source>Probe that fires when a request for a heavyweight lock (lmgr lock) has begun to wait because the lock is not available. arg0 through arg3 are the tag fields identifying the object being locked. arg4 indicates the type of object being locked. arg5 indicates the lock type being requested.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4162528ebd10f947261c421936db3a10071c6bda" translate="yes" xml:space="preserve">
          <source>Probe that fires when a request for a heavyweight lock (lmgr lock) has finished waiting (i.e., has acquired the lock). The arguments are the same as for &lt;code&gt;lock-wait-start&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c611257e152cea80f6cfc845709b8d0de904351c" translate="yes" xml:space="preserve">
          <source>Probe that fires when a server process begins to write a dirty WAL buffer because no more WAL buffer space is available. (If this happens often, it implies that &lt;a href=&quot;runtime-config-wal#GUC-WAL-BUFFERS&quot;&gt;wal_buffers&lt;/a&gt; is too small.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f78264e8172fbf9d18964b5de63c4b5c50a37b93" translate="yes" xml:space="preserve">
          <source>Probe that fires when a server process begins to write a dirty buffer. (If this happens often, it implies that &lt;a href=&quot;runtime-config-resource#GUC-SHARED-BUFFERS&quot;&gt;shared_buffers&lt;/a&gt; is too small or the background writer control parameters need adjustment.) arg0 and arg1 contain the fork and block numbers of the page. arg2, arg3, and arg4 contain the tablespace, database, and relation OIDs identifying the relation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab6028b90f757cbb259294d12f57f8c712860524" translate="yes" xml:space="preserve">
          <source>Probe that fires when a server process has been released from its wait for an LWLock (it does not actually have the lock yet). arg0 is the LWLock's tranche. arg1 is the requested lock mode, either exclusive or shared.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="327d56ed2b9d3f4cc36bd9b948fbb4da61129ae8" translate="yes" xml:space="preserve">
          <source>Probe that fires when a sort is complete. arg0 is true for external sort, false for internal sort. arg1 is the number of disk blocks used for an external sort, or kilobytes of memory used for an internal sort.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a9847b929f87d2af0af81f9222c2554ede52eda" translate="yes" xml:space="preserve">
          <source>Probe that fires when a sort operation is started. arg0 indicates heap, index or datum sort. arg1 is true for unique-value enforcement. arg2 is the number of key columns. arg3 is the number of kilobytes of work memory allowed. arg4 is true if random access to the sort result is required. arg5 indicates serial when &lt;code&gt;0&lt;/code&gt;, parallel worker when &lt;code&gt;1&lt;/code&gt;, or parallel leader when &lt;code&gt;2&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a6c578cf9ebf6dafcb797b30e10c8c0ea10449f" translate="yes" xml:space="preserve">
          <source>Probe that fires when a transaction completes successfully. arg0 is the transaction ID.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a8dcaad5632a5c029ca8a4cd70eeafe1ca847b1" translate="yes" xml:space="preserve">
          <source>Probe that fires when a transaction completes unsuccessfully. arg0 is the transaction ID.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17050254a1180d83c2f09021018121a20c9a108c" translate="yes" xml:space="preserve">
          <source>Probe that fires when a write request is complete. (Note that this just reflects the time to pass the data to the kernel; it's typically not actually been written to disk yet.) The arguments are the same as for &lt;code&gt;buffer-flush-start&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e023e6af3bb6f75b33af22efff6aa6afa3fd941" translate="yes" xml:space="preserve">
          <source>Probe that fires when all dirty buffers have been written. arg0 is the total number of buffers. arg1 is the number of buffers actually written by the checkpoint process. arg2 is the number that were expected to be written (arg1 of &lt;code&gt;buffer-sync-start&lt;/code&gt;); any difference reflects other processes flushing buffers during the checkpoint.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="466cfd0176351b56d635f32f0410727040245d40" translate="yes" xml:space="preserve">
          <source>Probe that fires when an LWLock has been acquired. arg0 is the LWLock's tranche. arg1 is the requested lock mode, either exclusive or shared.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6121be81d01b11fd11854f3cc9d63c7a9a5f1cbf" translate="yes" xml:space="preserve">
          <source>Probe that fires when an LWLock has been released (but note that any released waiters have not yet been awakened). arg0 is the LWLock's tranche.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eee4a231a6a278d84a4bf21d96cfbf0b033695e4" translate="yes" xml:space="preserve">
          <source>Probe that fires when an LWLock was not immediately available and a server process has begun to wait for the lock to become available. arg0 is the LWLock's tranche. arg1 is the requested lock mode, either exclusive or shared.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32b5dee951d8d8bbcc4c527b18fd9921e80f05ea" translate="yes" xml:space="preserve">
          <source>Probe that fires when an LWLock was not successfully acquired when the caller specified no waiting. arg0 is the LWLock's tranche. arg1 is the requested lock mode, either exclusive or shared.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29ccd443bca3bd38a197795375408911c2de33c3" translate="yes" xml:space="preserve">
          <source>Probe that fires when an LWLock was successfully acquired when the caller specified no waiting. arg0 is the LWLock's tranche. arg1 is the requested lock mode, either exclusive or shared.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9fe33e9001aca2852cd9dca52b36bdbecb7c1f32" translate="yes" xml:space="preserve">
          <source>Probe that fires when beginning to read a block from a relation. arg0 and arg1 contain the fork and block numbers of the page. arg2, arg3, and arg4 contain the tablespace, database, and relation OIDs identifying the relation. arg5 is the ID of the backend which created the temporary relation for a local buffer, or &lt;code&gt;InvalidBackendId&lt;/code&gt; (-1) for a shared buffer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3f7e8aeab722a5eb71c03e5e72e466f6f7d683f" translate="yes" xml:space="preserve">
          <source>Probe that fires when beginning to write a block to a relation. arg0 and arg1 contain the fork and block numbers of the page. arg2, arg3, and arg4 contain the tablespace, database, and relation OIDs identifying the relation. arg5 is the ID of the backend which created the temporary relation for a local buffer, or &lt;code&gt;InvalidBackendId&lt;/code&gt; (-1) for a shared buffer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9cef86798a06a87b1e53005af8b7cffd9544c2ff" translate="yes" xml:space="preserve">
          <source>Probe that fires when syncing of buffers to disk is complete.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e4496f8bfaa3cf215e7723d1b3f6a6a44062ac3" translate="yes" xml:space="preserve">
          <source>Probe that fires when the CLOG portion of a checkpoint is complete. arg0 has the same meaning as for &lt;code&gt;clog-checkpoint-start&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ce40580bfe3cc60932d40bba9c3a62201a4d419" translate="yes" xml:space="preserve">
          <source>Probe that fires when the CLOG portion of a checkpoint is started. arg0 is true for normal checkpoint, false for shutdown checkpoint.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f127e8e58e69f04b50616b0e221c7c59b7f1f3d1" translate="yes" xml:space="preserve">
          <source>Probe that fires when the MultiXact portion of a checkpoint is complete. arg0 has the same meaning as for &lt;code&gt;multixact-checkpoint-start&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7db7d3684151dd5b3ccf2213972ecca8de60eb5e" translate="yes" xml:space="preserve">
          <source>Probe that fires when the MultiXact portion of a checkpoint is started. arg0 is true for normal checkpoint, false for shutdown checkpoint.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19d184e6d4448ad19f4409d088d396f7df8c32d3" translate="yes" xml:space="preserve">
          <source>Probe that fires when the SUBTRANS portion of a checkpoint is complete. arg0 has the same meaning as for &lt;code&gt;subtrans-checkpoint-start&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="406309c24a9ce7d667e2ff79d8bf7268a9ff9831" translate="yes" xml:space="preserve">
          <source>Probe that fires when the SUBTRANS portion of a checkpoint is started. arg0 is true for normal checkpoint, false for shutdown checkpoint.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d124d93cd049bd0371700c2959bdf0770b013e0" translate="yes" xml:space="preserve">
          <source>Probe that fires when the buffer-writing portion of a checkpoint is started. arg0 holds the bitwise flags used to distinguish different checkpoint types, such as shutdown, immediate or force.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="931b1ed777e93c094dcd52151780b666556374f1" translate="yes" xml:space="preserve">
          <source>Probe that fires when the execution of a query is complete.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6643c1646d73651ecf6358eff359f77c5055c16d" translate="yes" xml:space="preserve">
          <source>Probe that fires when the execution of a query is started.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0944a082320c7bc732281e77e7ca49f36f32c834" translate="yes" xml:space="preserve">
          <source>Probe that fires when the parsing of a query is complete. arg0 is the query string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d96fa9e5daed0c63d0c0481d8ca8ebbe0a261583" translate="yes" xml:space="preserve">
          <source>Probe that fires when the parsing of a query is started. arg0 is the query string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9452ef2f9dd8e46c1c62afe77724fc190b423661" translate="yes" xml:space="preserve">
          <source>Probe that fires when the planning of a query is complete.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1d4370c7121e9a518ec9800f508633ae2640459" translate="yes" xml:space="preserve">
          <source>Probe that fires when the planning of a query is started.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96a4a695589b1af8e96af229876a85b1ac6a6721" translate="yes" xml:space="preserve">
          <source>Probe that fires when the processing of a query is complete. arg0 is the query string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17d08bdfb5f9889597cd8fad97751d8760642495" translate="yes" xml:space="preserve">
          <source>Probe that fires when the processing of a query is started. arg0 is the query string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eab217356aa735f20b49ab127f241495b6ade066" translate="yes" xml:space="preserve">
          <source>Probe that fires when the rewriting of a query is complete. arg0 is the query string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a428364242cf9691158e2fd27eee09f0cdf33ee9" translate="yes" xml:space="preserve">
          <source>Probe that fires when the rewriting of a query is started. arg0 is the query string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21185778a7abdae335897b758940d7f751d2a6f0" translate="yes" xml:space="preserve">
          <source>Probe that fires when the two-phase portion of a checkpoint is complete.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b37c215587e2b196fc6e3605c0952c5abaaeaa4" translate="yes" xml:space="preserve">
          <source>Probe that fires when the two-phase portion of a checkpoint is started.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64dbe1e4375ac3d8c100dcc3b4624e32ba635dcb" translate="yes" xml:space="preserve">
          <source>Probe that fires when we begin to write dirty buffers during checkpoint (after identifying which buffers must be written). arg0 is the total number of buffers. arg1 is the number that are currently dirty and need to be written.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e17699a3879dd39ab092b19091e781ba0c3179a" translate="yes" xml:space="preserve">
          <source>Procedural Languages (server-side)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d23b357b75ad2622370788956db89d9cceb43ba0" translate="yes" xml:space="preserve">
          <source>Procedural languages are local to individual databases. However, a language can be installed into the &lt;code&gt;template1&lt;/code&gt; database, which will cause it to be available automatically in all subsequently-created databases.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c80cc4229f5a9d3da6a7c3b6c8547ced65049640" translate="yes" xml:space="preserve">
          <source>Process ID</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be2c2eb824ea5b51d9b5bce07c9b40cd34577acf" translate="yes" xml:space="preserve">
          <source>Process ID of a WAL sender process</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af10df8d6082fa39f1e4f58ff138720439c3d068" translate="yes" xml:space="preserve">
          <source>Process ID of a backend</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="373864156198cbd9c04a34d7ab3e6735c02719d2" translate="yes" xml:space="preserve">
          <source>Process ID of a backend or WAL sender process</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5da887d9f68351aff22198bf3916a2bd05dd9d7" translate="yes" xml:space="preserve">
          <source>Process ID of backend.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1aca36c0622a2538e27d8bf063d83ca00390c145" translate="yes" xml:space="preserve">
          <source>Process ID of the WAL receiver process</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d7d2e19d28ca6186fcc59c93b80889377f993f2" translate="yes" xml:space="preserve">
          <source>Process ID of the locker currently being waited for.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01681ffc812bd9e058f3a6c5baf1409c4f0ba3bc" translate="yes" xml:space="preserve">
          <source>Process ID of the server process attached to the current session</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af8e0118b6d9e8d86d67cf0400739aba8210dd2b" translate="yes" xml:space="preserve">
          <source>Process ID of the server process handling the current session</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03fbcc6f1367738e610a0cace02a8fd6438fb048" translate="yes" xml:space="preserve">
          <source>Process ID of the server process holding or awaiting this lock, or null if the lock is held by a prepared transaction</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="999d9e41cb5cf7f111cc6e19904f6e291da38b6e" translate="yes" xml:space="preserve">
          <source>Process ID of the subscription worker process</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1f52d5447d8eaecbf7bddfce74b35d1ffb039b9" translate="yes" xml:space="preserve">
          <source>Process ID of this backend</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d15b210cc1e134700f907b8b25d7b1043aa0ca7b" translate="yes" xml:space="preserve">
          <source>Process ID(s) that are blocking specified server process ID from acquiring a lock</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f132a3ada7bb531c167b75bc5eeea4c4aebfc18" translate="yes" xml:space="preserve">
          <source>Process ID(s) that are blocking specified server process ID from acquiring a safe snapshot</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9b1d2668cc983dbc740512036c3c2a0339f13e5" translate="yes" xml:space="preserve">
          <source>Process IDs of locking backends (more than one if multitransaction)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f966bc3f73e4a99fa5d7b7c8751d4573456fa586" translate="yes" xml:space="preserve">
          <source>Process Identifier</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9404f1b149e0fa2944f7fe7f5a9758a8f27d7f2a" translate="yes" xml:space="preserve">
          <source>Process start time stamp</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b87f820c5635b5c920ad2cf5059d2207d8f59e5" translate="yes" xml:space="preserve">
          <source>Produce an error indicating that the deletion or update would create a foreign key constraint violation. If the constraint is deferred, this error will be produced at constraint check time if there still exist any referencing rows. This is the default action.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19db911f45836f08f67324db7d1d1b7713f59b5d" translate="yes" xml:space="preserve">
          <source>Produce an error indicating that the deletion or update would create a foreign key constraint violation. This is the same as &lt;code&gt;NO ACTION&lt;/code&gt; except that the check is not deferrable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="595741604d266c8ba7ee063d34ab349a2aac4f77" translate="yes" xml:space="preserve">
          <source>Produces a &amp;ldquo;pivot table&amp;rdquo; containing row names plus &lt;code&gt;N&lt;/code&gt; value columns, where &lt;code&gt;N&lt;/code&gt; is determined by the row type specified in the calling query</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b7d934bad462d22e3d780a0512ef5f70c8fefe7" translate="yes" xml:space="preserve">
          <source>Produces a &amp;ldquo;pivot table&amp;rdquo; containing row names plus &lt;code&gt;N&lt;/code&gt; value columns. &lt;code&gt;crosstab2&lt;/code&gt;, &lt;code&gt;crosstab3&lt;/code&gt;, and &lt;code&gt;crosstab4&lt;/code&gt; are predefined, but you can create additional &lt;code&gt;crosstabN&lt;/code&gt; functions as described below</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="953361f0fb07cbbdc30a8c3d39ada8d75e41aa1b" translate="yes" xml:space="preserve">
          <source>Produces a &amp;ldquo;pivot table&amp;rdquo; with the value columns specified by a second query</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eeb96fffad25790b78f8b2fd976762cd22e0262e" translate="yes" xml:space="preserve">
          <source>Produces a representation of a hierarchical tree structure</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2cf09a7cb7a5d996def491486e555116c8e56fe" translate="yes" xml:space="preserve">
          <source>Produces a set of normally distributed random values</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b3d37859bb87e00841bf5b68801363110571121" translate="yes" xml:space="preserve">
          <source>Produces no output, but tells non-session processes to stop at this point in the string; ignored by session processes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4cc122a953a1ad9e9d147019c31d589653986fa" translate="yes" xml:space="preserve">
          <source>Produces the intersection of two cubes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc2b03c140585a107e123dbad9c7907236c487ae" translate="yes" xml:space="preserve">
          <source>Produces the union of two cubes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a873ea551f5b656a037c9a2775158084055a3fb" translate="yes" xml:space="preserve">
          <source>Programs using C code with embedded SQL have to be linked against the &lt;code&gt;libecpg&lt;/code&gt; library, for example using the linker options &lt;code&gt;-L/usr/local/pgsql/lib -lecpg&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62babe4510e8d8a8ee8afda900ec73acd0a5dab6" translate="yes" xml:space="preserve">
          <source>Progress Reporting</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d02226c16e2d7d25eeaba8bd347cdb833f33050" translate="yes" xml:space="preserve">
          <source>Promotes a physical standby server. With &lt;em&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/em&gt; set to &lt;code&gt;true&lt;/code&gt; (the default), the function waits until promotion is completed or &lt;em&gt;&lt;code&gt;wait_seconds&lt;/code&gt;&lt;/em&gt; seconds have passed, and returns &lt;code&gt;true&lt;/code&gt; if promotion is successful and &lt;code&gt;false&lt;/code&gt; otherwise. If &lt;em&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/em&gt; is set to &lt;code&gt;false&lt;/code&gt;, the function returns &lt;code&gt;true&lt;/code&gt; immediately after sending &lt;code&gt;SIGUSR1&lt;/code&gt; to the postmaster to trigger the promotion. This function is restricted to superusers by default, but other users can be granted EXECUTE to run the function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="310745705e4b51911f7ad05e685132e85803b43c" translate="yes" xml:space="preserve">
          <source>Prompt for confirmation before actually removing the user, and prompt for the user name if none is specified on the command line.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4139dbdd33b4ca75eb092bf7d5f911f9e520f3e" translate="yes" xml:space="preserve">
          <source>Prompt for the user name if none is specified on the command line, and also prompt for whichever of the options &lt;code&gt;-d&lt;/code&gt;/&lt;code&gt;-D&lt;/code&gt;, &lt;code&gt;-r&lt;/code&gt;/&lt;code&gt;-R&lt;/code&gt;, &lt;code&gt;-s&lt;/code&gt;/&lt;code&gt;-S&lt;/code&gt; is not specified on the command line. (This was the default behavior up to PostgreSQL 9.1.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d970e24b22fc0f6e277e6e1b9c10241b2293ff1" translate="yes" xml:space="preserve">
          <source>Prompting</source>
          <target state="translated">Prompting</target>
        </trans-unit>
        <trans-unit id="7b9401a5b590107a8b6c6f9423644051eff19629" translate="yes" xml:space="preserve">
          <source>Prompts can contain terminal control characters which, for example, change the color, background, or style of the prompt text, or change the title of the terminal window. In order for the line editing features of Readline to work properly, these non-printing control characters must be designated as invisible by surrounding them with &lt;code&gt;%[&lt;/code&gt; and &lt;code&gt;%]&lt;/code&gt;. Multiple pairs of these can occur within the prompt. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="068e4f6fa6576b1f7eb180c4d966c9c332e88e9a" translate="yes" xml:space="preserve">
          <source>Prompts the user to supply text, which is assigned to the variable &lt;code&gt;name&lt;/code&gt;. An optional prompt string, &lt;code&gt;text&lt;/code&gt;, can be specified. (For multiword prompts, surround the text with single quotes.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25a719c409be1921beafe5e788d439d93b07f5ff" translate="yes" xml:space="preserve">
          <source>Protocol head</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a9320a6ee345a64538cc41c73838b336f61862b" translate="yes" xml:space="preserve">
          <source>Protocol to use for submitting queries to the server:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1ac8c14d0bafdecefeefa05418d3e4bf8d46ea4" translate="yes" xml:space="preserve">
          <source>Provide an extension that will be stripped from all file names before deciding if they should be deleted. This is typically useful for cleaning up archives that have been compressed during storage, and therefore have had an extension added by the compression program. For example: &lt;code&gt;-x .gz&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5c7f8ac0c8dc8b2a3526acf0eb6df53ded419c3" translate="yes" xml:space="preserve">
          <source>Provide information about extensions of client certificate: extension name, extension value, and if it is a critical extension.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7bc2350bc3b2039d9e0afed6b3606b6e8d63eb56" translate="yes" xml:space="preserve">
          <source>Provide the correct path to the database directory with &lt;code&gt;-D&lt;/code&gt;, or make sure that the environment variable &lt;code&gt;PGDATA&lt;/code&gt; is set. Also specify the name of the particular database you want to work in.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7fba2085619c6e697d55f8299ef0ca805ea435a8" translate="yes" xml:space="preserve">
          <source>Provider of the collation: &lt;code&gt;d&lt;/code&gt; = database default, &lt;code&gt;c&lt;/code&gt; = libc, &lt;code&gt;i&lt;/code&gt; = icu</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0a624c98e3417bfbf37f095267adcc37f1bdf46" translate="yes" xml:space="preserve">
          <source>Provider-specific version of the collation. This is recorded when the collation is created and then checked when it is used, to detect changes in the collation definition that could lead to data corruption.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="813380993db87b7b78063d3b522dabe042e0e038" translate="yes" xml:space="preserve">
          <source>Provides information implicitly requested by the user, e.g., output from &lt;code&gt;VACUUM VERBOSE&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de28296ee358cb5c7a7c1493346ff358cf83bc56" translate="yes" xml:space="preserve">
          <source>Provides information that might be helpful to users, e.g., notice of truncation of long identifiers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b544ef7e317c450388c8e22bbca337ffb169c783" translate="yes" xml:space="preserve">
          <source>Provides successively-more-detailed information for use by developers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4085a3488b9b927970106c990aa79f6421cbdb9c" translate="yes" xml:space="preserve">
          <source>Provides warnings of likely problems, e.g., &lt;code&gt;COMMIT&lt;/code&gt; outside a transaction block.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff659eeee4de0858f88b33fd3f4e7746d59a5ad2" translate="yes" xml:space="preserve">
          <source>Pseudo-Types</source>
          <target state="translated">Pseudo-Types</target>
        </trans-unit>
        <trans-unit id="4ece916bc1c6f84ddff998832df4ef0ea2024f0a" translate="yes" xml:space="preserve">
          <source>Pseudo-Types: any</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b47d9ee644ffb538aa98ee437eec99c988a8d15d" translate="yes" xml:space="preserve">
          <source>Pseudo-Types: anyarray</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22e5a6f841dae2418964bcaa84aa6a0a7f245549" translate="yes" xml:space="preserve">
          <source>Pseudo-Types: anyelement</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a3f6d920428a6c8e5967a26fb4e46758728f6a5" translate="yes" xml:space="preserve">
          <source>Pseudo-Types: anyenum</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84a873dc734548a1fe95e38fb333bb6d8bee10ef" translate="yes" xml:space="preserve">
          <source>Pseudo-Types: anynonarray</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f53e360e11fbb973d5b222308c28fd5706c50dd" translate="yes" xml:space="preserve">
          <source>Pseudo-Types: anyrange</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df7657db40732623a8894c06b0028cc7640273e5" translate="yes" xml:space="preserve">
          <source>Pseudo-Types: cstring</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="facd216b2d58500521e9c80e073f3f02e67f467b" translate="yes" xml:space="preserve">
          <source>Pseudo-Types: event_trigger</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c5c3ab69652fb55ae765ca8240e7c3bf40db9ce" translate="yes" xml:space="preserve">
          <source>Pseudo-Types: fdw_handler</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d96c1feed021f0bd14872d446a70c55ec2a02e1" translate="yes" xml:space="preserve">
          <source>Pseudo-Types: index_am_handler</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8be67788a823313be97039f4a4b82ee6108f4b0f" translate="yes" xml:space="preserve">
          <source>Pseudo-Types: internal</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c054109c5cb702aee10dbb32b0def25f56488525" translate="yes" xml:space="preserve">
          <source>Pseudo-Types: language_handler</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20a35bc47475d7650010ce766369afc8aabfb683" translate="yes" xml:space="preserve">
          <source>Pseudo-Types: opaque</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3674c8f90a9e09b98f639dae572ceb4253fed389" translate="yes" xml:space="preserve">
          <source>Pseudo-Types: pg_ddl_command</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0325a47d21e05370cdf2a42ac118a73e10a48da" translate="yes" xml:space="preserve">
          <source>Pseudo-Types: record</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d51593e94e15db79bb52c20320be4240d42cc899" translate="yes" xml:space="preserve">
          <source>Pseudo-Types: trigger</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e60d0c02309d5445a01602a98db4ff91365738e" translate="yes" xml:space="preserve">
          <source>Pseudo-Types: tsm_handler</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17a7daa819e8dc7b6c6317f25efa7b50fffc1bab" translate="yes" xml:space="preserve">
          <source>Pseudo-Types: unknown</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad3dfebd9fb48eb5727ce6fe6f50844a86efc6a5" translate="yes" xml:space="preserve">
          <source>Pseudo-Types: void</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c4dc2e4c074e37178229f858d4eb2dfaf30038f" translate="yes" xml:space="preserve">
          <source>Pseudo-types</source>
          <target state="translated">Pseudo-types</target>
        </trans-unit>
        <trans-unit id="cfb71764f58cd5ce25681b038025973a34e3322a" translate="yes" xml:space="preserve">
          <source>Pseudocode for a suitable &lt;code&gt;restore_command&lt;/code&gt; is:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88d402501992d3fecf47cb438f8e35c65835d25d" translate="yes" xml:space="preserve">
          <source>PuTTY</source>
          <target state="translated">PuTTY</target>
        </trans-unit>
        <trans-unit id="e00441c49bf6cb62a4a537860a47c6b85de694f6" translate="yes" xml:space="preserve">
          <source>Publication</source>
          <target state="translated">Publication</target>
        </trans-unit>
        <trans-unit id="1c3179d96f0fdc556230a1396cdf463d5208ef82" translate="yes" xml:space="preserve">
          <source>Publications are different from schemas and do not affect how the table is accessed. Each table can be added to multiple publications if needed. Publications may currently only contain tables. Objects must be added explicitly, except when a publication is created for &lt;code&gt;ALL TABLES&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58589c3756a9812c4f0f3e4873d1e342581ef4c0" translate="yes" xml:space="preserve">
          <source>Publications can choose to limit the changes they produce to any combination of &lt;code&gt;INSERT&lt;/code&gt;, &lt;code&gt;UPDATE&lt;/code&gt;, &lt;code&gt;DELETE&lt;/code&gt;, and &lt;code&gt;TRUNCATE&lt;/code&gt;, similar to how triggers are fired by particular event types. By default, all operation types are replicated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0fb821bdaf93ed9a1f1e920acfb2840eff5b153" translate="yes" xml:space="preserve">
          <source>Purpose</source>
          <target state="translated">Purpose</target>
        </trans-unit>
        <trans-unit id="18900d3584ded79ec60330adb7d33689eb4bab06" translate="yes" xml:space="preserve">
          <source>Put all query output into file &lt;code&gt;filename&lt;/code&gt;. This is equivalent to the command &lt;code&gt;\o&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="877e59f50b56dd32ce7ae2762957d53396b6d9d9" translate="yes" xml:space="preserve">
          <source>Qualified joins</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3eb467853e78723a75783ad177cb3b81ed614c2e" translate="yes" xml:space="preserve">
          <source>Qualified names are tedious to write, and it's often best not to wire a particular schema name into applications anyway. Therefore tables are often referred to by &lt;em&gt;unqualified names&lt;/em&gt;, which consist of just the table name. The system determines which table is meant by following a &lt;em&gt;search path&lt;/em&gt;, which is a list of schemas to look in. The first matching table in the search path is taken to be the one wanted. If there is no match in the search path, an error is reported, even if matching table names exist in other schemas in the database.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29bac22a5e177f5c85c1a4ee3241bc0678be6667" translate="yes" xml:space="preserve">
          <source>Quantifier</source>
          <target state="translated">Quantifier</target>
        </trans-unit>
        <trans-unit id="5370954c958801abba850882cd6534802d171dbc" translate="yes" xml:space="preserve">
          <source>Quantities of days, hours, minutes, and seconds can be specified without explicit unit markings. For example, &lt;code&gt;'1 12:59:10'&lt;/code&gt; is read the same as &lt;code&gt;'1 day 12 hours 59 min 10 sec'&lt;/code&gt;. Also, a combination of years and months can be specified with a dash; for example &lt;code&gt;'200-10'&lt;/code&gt; is read the same as &lt;code&gt;'200 years 10 months'&lt;/code&gt;. (These shorter forms are in fact the only ones allowed by the SQL standard, and are used for output when &lt;code&gt;IntervalStyle&lt;/code&gt; is set to &lt;code&gt;sql_standard&lt;/code&gt;.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2644b7d942f174a4bbf0bc8675c1badf9352393e" translate="yes" xml:space="preserve">
          <source>Queries</source>
          <target state="translated">Queries</target>
        </trans-unit>
        <trans-unit id="efa9d81fc99ae6041fbe49339a919ef99bac7ade" translate="yes" xml:space="preserve">
          <source>Query Planning</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b65f94596db8e112e4f92d4f1acdc4bb922a6268" translate="yes" xml:space="preserve">
          <source>Query access - &lt;code&gt;SELECT&lt;/code&gt;, &lt;code&gt;COPY TO&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb0b645346d8b6276dfe9ec30dfc16f0625329b2" translate="yes" xml:space="preserve">
          <source>Query performance can be improved dramatically in certain situations, particularly when most of the heavily accessed rows of the table are in a single partition or a small number of partitions. The partitioning substitutes for leading columns of indexes, reducing index size and making it more likely that the heavily-used parts of the indexes fit in memory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="198d3f9fde17e740d63372e1985f338979a36a67" translate="yes" xml:space="preserve">
          <source>Query tree (in the form of a &lt;code&gt;nodeToString()&lt;/code&gt; representation) for the rule's action</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6002c5c363574bc4fe16e6079b6e23f671de172" translate="yes" xml:space="preserve">
          <source>Querying this view is similar to using &lt;code&gt;SHOW ALL&lt;/code&gt; but provides more detail. It is also more flexible, since it's possible to specify filter conditions or join against other relations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33208d59d48811565117bf5ce172585c48018ea8" translate="yes" xml:space="preserve">
          <source>Quick Setup</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d17b23cd28367fcd27d5f878512b5e25587ec17b" translate="yes" xml:space="preserve">
          <source>Quits the psql program. In a script file, only execution of that script is terminated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="472cc72a1798e7f5b5bbceeb0bca7885d9d12809" translate="yes" xml:space="preserve">
          <source>Quoted identifiers can contain any character, except the character with code zero. (To include a double quote, write two double quotes.) This allows constructing table or column names that would otherwise not be possible, such as ones containing spaces or ampersands. The length limitation still applies.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a777f2b79b97851a7b855a9429a5ebde18f036d" translate="yes" xml:space="preserve">
          <source>Quoting an identifier also makes it case-sensitive, whereas unquoted names are always folded to lower case. For example, the identifiers &lt;code&gt;FOO&lt;/code&gt;, &lt;code&gt;foo&lt;/code&gt;, and &lt;code&gt;&quot;foo&quot;&lt;/code&gt; are considered the same by PostgreSQL, but &lt;code&gt;&quot;Foo&quot;&lt;/code&gt; and &lt;code&gt;&quot;FOO&quot;&lt;/code&gt; are different from these three and each other. (The folding of unquoted names to lower case in PostgreSQL is incompatible with the SQL standard, which says that unquoted names should be folded to upper case. Thus, &lt;code&gt;foo&lt;/code&gt; should be equivalent to &lt;code&gt;&quot;FOO&quot;&lt;/code&gt; not &lt;code&gt;&quot;foo&quot;&lt;/code&gt; according to the standard. If you want to write portable applications you are advised to always quote a particular name or never quote it.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="115088ecccb3000708edba51535672720b3a9ec6" translate="yes" xml:space="preserve">
          <source>Quoting rules for lexemes are the same as described previously for lexemes in &lt;code&gt;tsvector&lt;/code&gt;; and, as with &lt;code&gt;tsvector&lt;/code&gt;, any required normalization of words must be done before converting to the &lt;code&gt;tsquery&lt;/code&gt; type. The &lt;code&gt;to_tsquery&lt;/code&gt; function is convenient for performing such normalization:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b79583615e1227273c81a5db2662b19ad81511a9" translate="yes" xml:space="preserve">
          <source>RADIUS Authentication</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7edcf4d8bc4d16588d07b8848c85c166b827fdc9" translate="yes" xml:space="preserve">
          <source>RD-Tree for one-dimensional array of int4 values</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff426c74c79867f7bf13e61c4f68d776339590f2" translate="yes" xml:space="preserve">
          <source>RDBMS</source>
          <target state="translated">RDBMS</target>
        </trans-unit>
        <trans-unit id="633fabe87d723214b65f1db2d624431f04c32334" translate="yes" xml:space="preserve">
          <source>REASSIGN OWNED</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b6e0d55ca8c5d1c174cbdd39c8e88014cc1d924" translate="yes" xml:space="preserve">
          <source>REASSIGN OWNED &amp;mdash; change the ownership of database objects owned by a database role</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9cbb3a44e5994b48186107b069ebdee3f1ded8c" translate="yes" xml:space="preserve">
          <source>REFRESH MATERIALIZED VIEW</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="044770dd01baff51d49560ba1c3262f9b7a5e296" translate="yes" xml:space="preserve">
          <source>REFRESH MATERIALIZED VIEW &amp;mdash; replace the contents of a materialized view</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5345e769e7d2d5a04080b106526b4188c28b2947" translate="yes" xml:space="preserve">
          <source>REINDEX</source>
          <target state="translated">REINDEX</target>
        </trans-unit>
        <trans-unit id="d68887fcf8498472cf8183721de3d160d3d8a3bb" translate="yes" xml:space="preserve">
          <source>REINDEX &amp;mdash; rebuild indexes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bec39b2581dc86d96ef7eb4b59715b2db9fb5b98" translate="yes" xml:space="preserve">
          <source>RELEASE SAVEPOINT</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d33a2b2590d58d2a81b75053789ac9fe4aed380a" translate="yes" xml:space="preserve">
          <source>RELEASE SAVEPOINT &amp;mdash; destroy a previously defined savepoint</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="995f2d9ddfbe7ab63a2a7ddd59856b61ae272710" translate="yes" xml:space="preserve">
          <source>RESET</source>
          <target state="translated">RESET</target>
        </trans-unit>
        <trans-unit id="c157890fb1f2fab533caebe2d7bbafd037ee3504" translate="yes" xml:space="preserve">
          <source>RESET &amp;mdash; restore the value of a run-time parameter to the default value</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d173eb30e8b9fe61478a02d722cdc111a632ca90" translate="yes" xml:space="preserve">
          <source>REVOKE</source>
          <target state="translated">REVOKE</target>
        </trans-unit>
        <trans-unit id="6d5e97f2b0b3bc9eba1622d19f4c033f547d2f10" translate="yes" xml:space="preserve">
          <source>REVOKE &amp;mdash; remove access privileges</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="285e88316b0d14455ae0c18a656f7e4c2153f4a5" translate="yes" xml:space="preserve">
          <source>RFC</source>
          <target state="translated">RFC</target>
        </trans-unit>
        <trans-unit id="709f9208ad6c95b7efb1b7aea432fe35dfaffef8" translate="yes" xml:space="preserve">
          <source>RFC 3629</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e9a9191aa9d2f384e00599efbf540e0c6906e72" translate="yes" xml:space="preserve">
          <source>RFC 7159 permits JSON strings to contain Unicode escape sequences denoted by &lt;code&gt;\uXXXX&lt;/code&gt;. In the input function for the &lt;code&gt;json&lt;/code&gt; type, Unicode escapes are allowed regardless of the database encoding, and are checked only for syntactic correctness (that is, that four hex digits follow &lt;code&gt;\u&lt;/code&gt;). However, the input function for &lt;code&gt;jsonb&lt;/code&gt; is stricter: it disallows Unicode escapes for non-ASCII characters (those above &lt;code&gt;U+007F&lt;/code&gt;) unless the database encoding is UTF8. The &lt;code&gt;jsonb&lt;/code&gt; type also rejects &lt;code&gt;\u0000&lt;/code&gt; (because that cannot be represented in PostgreSQL's &lt;code&gt;text&lt;/code&gt; type), and it insists that any use of Unicode surrogate pairs to designate characters outside the Unicode Basic Multilingual Plane be correct. Valid Unicode escapes are converted to the equivalent ASCII or UTF8 character for storage; this includes folding surrogate pairs into a single character.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ce42e824f2163751d62c49d3226c338efa1179d" translate="yes" xml:space="preserve">
          <source>ROLLBACK</source>
          <target state="translated">ROLLBACK</target>
        </trans-unit>
        <trans-unit id="59a24d752da80d40b19238fcc5ec55b82fdc443e" translate="yes" xml:space="preserve">
          <source>ROLLBACK &amp;mdash; abort the current transaction</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e90e1449c7ef5b8820b08718a11f2da71c8d13be" translate="yes" xml:space="preserve">
          <source>ROLLBACK PREPARED</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48a2a83386a59b9b2fdad5e2cd3606242846748b" translate="yes" xml:space="preserve">
          <source>ROLLBACK PREPARED &amp;mdash; cancel a transaction that was earlier prepared for two-phase commit</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61b9b7603e40508bc503ee4691737e409606fd90" translate="yes" xml:space="preserve">
          <source>ROLLBACK TO SAVEPOINT</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d35ebfad8fd6f928fec74d3875a90f0020c24317" translate="yes" xml:space="preserve">
          <source>ROLLBACK TO SAVEPOINT &amp;mdash; roll back to a savepoint</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a8f649047eb74a2e378d2089854762723ab49ef" translate="yes" xml:space="preserve">
          <source>ROW EXCLUSIVE</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14cb7a6b49bc39b1cc0a49d9f930265fc065d308" translate="yes" xml:space="preserve">
          <source>ROW SHARE</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="498fa9be2d32c469ac4cde84af98396f043472d9" translate="yes" xml:space="preserve">
          <source>Random access to mechanical disk storage is normally much more expensive than four times sequential access. However, a lower default is used (4.0) because the majority of random accesses to disk, such as indexed reads, are assumed to be in cache. The default value can be thought of as modeling random access as 40 times slower than sequential, while expecting 90% of random reads to be cached.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a16c5bbe4bf996740f257aa1e81bd57e4c52c8dd" translate="yes" xml:space="preserve">
          <source>Range</source>
          <target state="translated">Range</target>
        </trans-unit>
        <trans-unit id="a12932077f1a02e9d49ac217bf48adda8287e429" translate="yes" xml:space="preserve">
          <source>Range Partitioning</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="150371fe63779db9b501fedeeefe579700f1d7d0" translate="yes" xml:space="preserve">
          <source>Range Types</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53d929e1fb8ce766a0948419773ae86cbb9a3971" translate="yes" xml:space="preserve">
          <source>Range Types: daterange</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3693b9f49e1d1bce857f56deb98c373c7aef619" translate="yes" xml:space="preserve">
          <source>Range Types: int4range</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a82ac3da25ee609b2aeb0f2103e7ae7eeded8ea" translate="yes" xml:space="preserve">
          <source>Range Types: int8range</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="744cc477872918910432194727cf36fb5632f253" translate="yes" xml:space="preserve">
          <source>Range Types: numrange</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f03184b38e676b9e59d518680c29ef81d475b159" translate="yes" xml:space="preserve">
          <source>Range Types: tsrange</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="010e27d6ddc0ef1f60c30945a5ab60be84e20b61" translate="yes" xml:space="preserve">
          <source>Range Types: tstzrange</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19eccf536154da069167603ea475b5f422e59b33" translate="yes" xml:space="preserve">
          <source>Range and list partitioning require a btree operator class, while hash partitioning requires a hash operator class. If no operator class is specified explicitly, the default operator class of the appropriate type will be used; if no default operator class exists, an error will be raised. When hash partitioning is used, the operator class used must implement support function 2 (see &lt;a href=&quot;https://www.postgresql.org/docs/12/xindex.html#XINDEX-SUPPORT&quot;&gt;Section 37.16.3&lt;/a&gt; for details).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48652fff66c0aa4370d5c8fba0d573037de8ea3f" translate="yes" xml:space="preserve">
          <source>Range types</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="152d9f920b5a18dd2e34c468823a545e1a1c8d0c" translate="yes" xml:space="preserve">
          <source>Range types are data types representing a range of values of some element type (called the range's &lt;em&gt;subtype&lt;/em&gt;). For instance, ranges of &lt;code&gt;timestamp&lt;/code&gt; might be used to represent the ranges of time that a meeting room is reserved. In this case the data type is &lt;code&gt;tsrange&lt;/code&gt; (short for &amp;ldquo;timestamp range&amp;rdquo;), and &lt;code&gt;timestamp&lt;/code&gt; is the subtype. The subtype must have a total order so that it is well-defined whether element values are within, before, or after a range of values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10501cb18e09508ff10076b64f0cc428df172882" translate="yes" xml:space="preserve">
          <source>Range types are useful because they represent many element values in a single range value, and because concepts such as overlapping ranges can be expressed clearly. The use of time and date ranges for scheduling purposes is the clearest example; but price ranges, measurement ranges from an instrument, and so forth can also be useful.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9a5ac13ea7278862eadf429fec1a6d53e07ac45" translate="yes" xml:space="preserve">
          <source>Range: &amp;amp;&amp;amp;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5138aeeb99cbf6ebff075b87fadb3ac93d6e5193" translate="yes" xml:space="preserve">
          <source>Range: &amp;amp;&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d72ae278ac597396584e8c02a1741c100edfca80" translate="yes" xml:space="preserve">
          <source>Range: &amp;amp;&amp;lt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3887b799dded8092c6301d5be1aefa3d0dd6d3a" translate="yes" xml:space="preserve">
          <source>Range: &amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="798e0e9e88e4e32e73dc02d11defb73693566666" translate="yes" xml:space="preserve">
          <source>Range: &amp;gt;&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e6946ee5453b7aafe3852ad6a413e04bbe70b3f" translate="yes" xml:space="preserve">
          <source>Range: &amp;gt;=</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50827e59e82c8b9b94902deba9c0cd7d740e2584" translate="yes" xml:space="preserve">
          <source>Range: &amp;lt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6f037363a29496f0699d11afa7d6227f3803584" translate="yes" xml:space="preserve">
          <source>Range: &amp;lt;&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f6f0031a9d4355c819448b50757c3487642b742" translate="yes" xml:space="preserve">
          <source>Range: &amp;lt;&amp;lt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="278020aa13725565b03e23b783ab30ead6a5d971" translate="yes" xml:space="preserve">
          <source>Range: &amp;lt;=</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8fd029989c2ed32bcffaf5576523df4934fcb6aa" translate="yes" xml:space="preserve">
          <source>Range: &amp;lt;@</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="519ae404f51d7cdda5157d728a679f6ac34e633b" translate="yes" xml:space="preserve">
          <source>Range: *</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2eb640bcc9834e28157d86493366688f7c5d38a2" translate="yes" xml:space="preserve">
          <source>Range: +</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8e5cef097bd3910fe5e0190257f34cad206f4c2" translate="yes" xml:space="preserve">
          <source>Range: -</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b30626f6a47ecd0abac84acd28b5ffc7444c5618" translate="yes" xml:space="preserve">
          <source>Range: -|-</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7943ac61251b0e439e59453d3c9bd4d92cbe7db" translate="yes" xml:space="preserve">
          <source>Range: =</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c9fd1a7ffb6cd6aed893574001127ea193ec53e" translate="yes" xml:space="preserve">
          <source>Range: @&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5df42bdba4fe9375d8ecde65d144985e2fa123da" translate="yes" xml:space="preserve">
          <source>Range: isempty</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7cf1b8f7817c42e33a217bf084388d7956ddb800" translate="yes" xml:space="preserve">
          <source>Range: lower</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41561998090e13cce0a01b7784c0b3af97242f0c" translate="yes" xml:space="preserve">
          <source>Range: lower_inc</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2cc53727481a0808617729c756b990601f85da64" translate="yes" xml:space="preserve">
          <source>Range: lower_inf</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ace460c813343c7a659f92c463b48f8e9497c10" translate="yes" xml:space="preserve">
          <source>Range: range_merge</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f28a3c6d0b4768f8b324bd884ab8839d0315ae6" translate="yes" xml:space="preserve">
          <source>Range: upper</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="254cd3d46f3b050314f0a32b8ccaf21bfef8428c" translate="yes" xml:space="preserve">
          <source>Range: upper_inc</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15a1bf88678aec9c8e638569577cf68508681fb4" translate="yes" xml:space="preserve">
          <source>Range: upper_inf</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16773cb5b6a39b09024cc881604849b2ada6e7b5" translate="yes" xml:space="preserve">
          <source>Ranking attempts to measure how relevant documents are to a particular query, so that when there are many matches the most relevant ones can be shown first. PostgreSQL provides two predefined ranking functions, which take into account lexical, proximity, and structural information; that is, they consider how often the query terms appear in the document, how close together the terms are in the document, and how important is the part of the document where they occur. However, the concept of relevancy is vague and very application-specific. Different applications might require additional information for ranking, e.g., document modification time. The built-in ranking functions are only examples. You can write your own ranking functions and/or combine their results with additional factors to fit your specific needs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d643b0d7aa4393d4d9da3687d8322d0a81e0cab" translate="yes" xml:space="preserve">
          <source>Ranking can be expensive since it requires consulting the &lt;code&gt;tsvector&lt;/code&gt; of each matching document, which can be I/O bound and therefore slow. Unfortunately, it is almost impossible to avoid since practical queries often result in large numbers of matches.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19afdfa41a0ed827f969267ae295f3b913f28c70" translate="yes" xml:space="preserve">
          <source>Ranks vectors based on the frequency of their matching lexemes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="236c736d2b53bb667d136c499a0d1ba402fdd25d" translate="yes" xml:space="preserve">
          <source>Rather than look at &lt;code&gt;pg_statistic&lt;/code&gt; directly, it's better to look at its view &lt;a href=&quot;view-pg-stats&quot;&gt;&lt;code&gt;pg_stats&lt;/code&gt;&lt;/a&gt; when examining the statistics manually. &lt;code&gt;pg_stats&lt;/code&gt; is designed to be more easily readable. Furthermore, &lt;code&gt;pg_stats&lt;/code&gt; is readable by all, whereas &lt;code&gt;pg_statistic&lt;/code&gt; is only readable by a superuser. (This prevents unprivileged users from learning something about the contents of other people's tables from the statistics. The &lt;code&gt;pg_stats&lt;/code&gt; view is restricted to show only rows about tables that the current user can read.) For example, we might do:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2bec5c61f15a407e756ab05a685ad23bb7e5511" translate="yes" xml:space="preserve">
          <source>Raw encryption</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3a99e9a4728dc2bda56a78db524b67989b4e597" translate="yes" xml:space="preserve">
          <source>Read all configuration variables, even those normally visible only to superusers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38c5a7218bb22d1b28959f625c6bfbea27ffbf82" translate="yes" xml:space="preserve">
          <source>Read all pg_stat_* views and use various statistics related extensions, even those normally visible only to superusers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f317af3bdf1a98cfc777a36424de3b09eb202cb2" translate="yes" xml:space="preserve">
          <source>Read commands from the file &lt;code&gt;filename&lt;/code&gt;, rather than standard input. This option can be repeated and combined in any order with the &lt;code&gt;-c&lt;/code&gt; option. When either &lt;code&gt;-c&lt;/code&gt; or &lt;code&gt;-f&lt;/code&gt; is specified, psql does not read commands from standard input; instead it terminates after processing all the &lt;code&gt;-c&lt;/code&gt; and &lt;code&gt;-f&lt;/code&gt; options in sequence. Except for that, this option is largely equivalent to the meta-command &lt;code&gt;\i&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9076a937057025c12698c82a06c40b255a1ab2fe" translate="yes" xml:space="preserve">
          <source>Read committed</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a95dbf92f08a3c417ee95bdad4ed061db64fdec6" translate="yes" xml:space="preserve">
          <source>Read only transactions and transaction rollbacks need not wait for replies from standby servers. Subtransaction commits do not wait for responses from standby servers, only top-level commits. Long running actions such as data loading or index building do not wait until the very final commit message. All two-phase commit actions require commit waits, including both prepare and commit.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6be205ecd14d327027894365b4c4da763eabaefb" translate="yes" xml:space="preserve">
          <source>Read uncommitted</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6eb06aa586fee4fadd30e615b431af9599c0f350" translate="yes" xml:space="preserve">
          <source>Read/execute various monitoring views and functions. This role is a member of &lt;code&gt;pg_read_all_settings&lt;/code&gt;, &lt;code&gt;pg_read_all_stats&lt;/code&gt; and &lt;code&gt;pg_stat_scan_tables&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="208855ca97c0a555c27eb1fe53c1f9d25c951c72" translate="yes" xml:space="preserve">
          <source>Reads input from the file &lt;code&gt;filename&lt;/code&gt; and executes it as though it had been typed on the keyboard.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c6e304c0494e1083fecdbe3327bbaf955efd2c7" translate="yes" xml:space="preserve">
          <source>Reads the large object with OID &lt;code&gt;loid&lt;/code&gt; from the database and writes it to &lt;code&gt;filename&lt;/code&gt;. Note that this is subtly different from the server function &lt;code&gt;lo_export&lt;/code&gt;, which acts with the permissions of the user that the database server runs as and on the server's file system.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b773130a64ad2044832f0c09fb6170f96c3c7a41" translate="yes" xml:space="preserve">
          <source>Real-world usage will involve including it in a text search configuration as described in &lt;a href=&quot;https://www.postgresql.org/docs/12/textsearch.html&quot;&gt;Chapter 12&lt;/a&gt;. That might look like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae23f1294951923b0cc23537cc39645d564d2aab" translate="yes" xml:space="preserve">
          <source>Rebuild a single index:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7641f144c3aa51f565ab278ebea2baf02cb12776" translate="yes" xml:space="preserve">
          <source>Rebuild all indexes in a particular database, without trusting the system indexes to be valid already:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4bafd726bbf407899b495d1dbf54642ee4ba4831" translate="yes" xml:space="preserve">
          <source>Rebuild all the indexes on the table &lt;code&gt;my_table&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e240124d901fd858d5ecb298dbf587210bc9d05" translate="yes" xml:space="preserve">
          <source>Rebuild indexes for a table, without blocking read and write operations on involved relations while reindexing is in progress:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a65666fb054ac024fe44494209417a92c10f6a1" translate="yes" xml:space="preserve">
          <source>Rebuilding Indexes Concurrently</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="988c4afb32e29d0f56df1f4ce3ed4b7fe8a47d56" translate="yes" xml:space="preserve">
          <source>Rebuilding an index can interfere with regular operation of a database. Normally PostgreSQL locks the table whose index is rebuilt against writes and performs the entire index build with a single scan of the table. Other transactions can still read the table, but if they try to insert, update, or delete rows in the table they will block until the index rebuild is finished. This could have a severe effect if the system is a live production database. Very large tables can take many hours to be indexed, and even for smaller tables, an index rebuild can lock out writers for periods that are unacceptably long for a production system.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82bd8c2397d7ac2c1c641075498f1fce81c5df27" translate="yes" xml:space="preserve">
          <source>Recall from &lt;a href=&quot;https://www.postgresql.org/docs/12/ddl.html&quot;&gt;Chapter 5&lt;/a&gt; that SQL does not, in general, provide a unique identifier for rows. Therefore it is not always possible to directly specify which row to update. Instead, you specify which conditions a row must meet in order to be updated. Only if you have a primary key in the table (independent of whether you declared it or not) can you reliably address individual rows by choosing a condition that matches the primary key. Graphical database access tools rely on this fact to allow you to update rows individually.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4efef42b9260b682732a87952d0c648c37aa88b4" translate="yes" xml:space="preserve">
          <source>Recall from &lt;a href=&quot;https://www.postgresql.org/docs/12/runtime-config.html&quot;&gt;Chapter 19&lt;/a&gt; that the PostgreSQL server provides a large number of run-time configuration variables. You can set database-specific default values for many of these settings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f93654028aee4dea14c9a1eae10f967b20dc5e9" translate="yes" xml:space="preserve">
          <source>Recall the &lt;code&gt;weather&lt;/code&gt; and &lt;code&gt;cities&lt;/code&gt; tables from &lt;a href=&quot;https://www.postgresql.org/docs/12/tutorial-sql.html&quot;&gt;Chapter 2&lt;/a&gt;. Consider the following problem: You want to make sure that no one can insert rows in the &lt;code&gt;weather&lt;/code&gt; table that do not have a matching entry in the &lt;code&gt;cities&lt;/code&gt; table. This is called maintaining the &lt;em&gt;referential integrity&lt;/em&gt; of your data. In simplistic database systems this would be implemented (if at all) by first looking at the &lt;code&gt;cities&lt;/code&gt; table to check if a matching record exists, and then inserting or rejecting the new &lt;code&gt;weather&lt;/code&gt; records. This approach has a number of problems and is very inconvenient, so PostgreSQL can do this for you.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0eaa953826e935204b6a44cd6a2370cac662b344" translate="yes" xml:space="preserve">
          <source>Receipt time of last message received from origin WAL sender</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3cc37caa6d46528f9045d282984fbf57211a9456" translate="yes" xml:space="preserve">
          <source>Recent SATA drives (those following ATAPI-6 or later) offer a drive cache flush command (&lt;code&gt;FLUSH CACHE EXT&lt;/code&gt;), while SCSI drives have long supported a similar command &lt;code&gt;SYNCHRONIZE CACHE&lt;/code&gt;. These commands are not directly accessible to PostgreSQL, but some file systems (e.g., ZFS, ext4) can use them to flush data to the platters on write-back-enabled drives. Unfortunately, such file systems behave suboptimally when combined with battery-backup unit (BBU) disk controllers. In such setups, the synchronize command forces all data from the controller cache to the disks, eliminating much of the benefit of the BBU. You can run the &lt;a href=&quot;pgtestfsync&quot;&gt;pg_test_fsync&lt;/a&gt; program to see if you are affected. If you are affected, the performance benefits of the BBU can be regained by turning off write barriers in the file system or reconfiguring the disk controller, if that is an option. If write barriers are turned off, make sure the battery remains functional; a faulty battery can potentially lead to data loss. Hopefully file system and disk controller designers will eventually address this suboptimal behavior.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb81291c24a22a0d7ee2d0164ff6f4bb7150f01b" translate="yes" xml:space="preserve">
          <source>Recent XPath versions begin to offer capabilities overlapping with these (such as functional-style &lt;code&gt;for-each&lt;/code&gt; and &lt;code&gt;sort&lt;/code&gt;, anonymous functions, and &lt;code&gt;parse-xml&lt;/code&gt; to create a node from a string), but such features were not available before XPath 3.0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e74ab6cfa0460d1693f4b9e4a5ccdbb1ddbfa73f" translate="yes" xml:space="preserve">
          <source>Recompile and verify that the new probes are available</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c56b9211f3ee693b17cfa7d6c447d7f6c0a97469" translate="yes" xml:space="preserve">
          <source>Record commit time of transactions. This parameter can only be set in &lt;code&gt;postgresql.conf&lt;/code&gt; file or on the server command line. The default value is &lt;code&gt;off&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1e650b68eeccef8d69d91d12499b2ffe7f56b1b" translate="yes" xml:space="preserve">
          <source>Recovery performance is sufficiently good that the standby will typically be only moments away from full availability once it has been activated. As a result, this is called a warm standby configuration which offers high availability. Restoring a server from an archived base backup and rollforward will take considerably longer, so that technique only offers a solution for disaster recovery, not high availability. A standby server can also be used for read-only queries, in which case it is called a Hot Standby server. See &lt;a href=&quot;hot-standby&quot;&gt;Section 26.5&lt;/a&gt; for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc32ecc375b8a61098de0a79de9f7d52b34ebeb9" translate="yes" xml:space="preserve">
          <source>Recovery treats the WAL archive as read-only, so once a WAL file has been copied to the standby system it can be copied to tape at the same time as it is being read by the standby database server. Thus, running a standby server for high availability can be performed at the same time as files are stored for longer term disaster recovery purposes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3bc2f178f62154c386cd90668f7442aeca7ac4b" translate="yes" xml:space="preserve">
          <source>Recreate &lt;code&gt;index&lt;/code&gt; only. Multiple indexes can be recreated by writing multiple &lt;code&gt;-i&lt;/code&gt; switches.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ab8e4cf2bee361b549d0a7652eba7adf3a2e36d" translate="yes" xml:space="preserve">
          <source>Recreate all indexes of the specified schema. If a table of this schema has a secondary &amp;ldquo;TOAST&amp;rdquo; table, that is reindexed as well. Indexes on shared system catalogs are also processed. This form of &lt;code&gt;REINDEX&lt;/code&gt; cannot be executed inside a transaction block.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54a36c0b2b1b570c5b51a6a3b47c25f473f3cfb8" translate="yes" xml:space="preserve">
          <source>Recreate all indexes of the specified table. If the table has a secondary &amp;ldquo;TOAST&amp;rdquo; table, that is reindexed as well.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3546f5e2e55d429c2387304c29dfa4c36ee5973" translate="yes" xml:space="preserve">
          <source>Recreate all indexes on system catalogs within the current database. Indexes on shared system catalogs are included. Indexes on user tables are not processed. This form of &lt;code&gt;REINDEX&lt;/code&gt; cannot be executed inside a transaction block.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8026b4ad3f9457c0e184493f3e0aa052fee5538" translate="yes" xml:space="preserve">
          <source>Recreate all indexes within the current database. Indexes on shared system catalogs are also processed. This form of &lt;code&gt;REINDEX&lt;/code&gt; cannot be executed inside a transaction block.</source>
          <target state="new"/>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
