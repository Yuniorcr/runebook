<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="cpp">
    <body>
      <group id="cpp">
        <trans-unit id="622dca44b962cc1f074838d9efdbe8759696a1de" translate="yes" xml:space="preserve">
          <source>Associative containers implement sorted data structures that can be quickly searched (O(log n) complexity).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c6a25ab3379bdd54a1512bb45e9d133927a1700" translate="yes" xml:space="preserve">
          <source>Associative containers in the standard library</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3b3c941634aac79492f857fc539fd4c9d008a56" translate="yes" xml:space="preserve">
          <source>AssociativeContainer</source>
          <target state="translated">AssociativeContainer</target>
        </trans-unit>
        <trans-unit id="d20b5a26a1cdf631954b50a5206246dff93d9c8a" translate="yes" xml:space="preserve">
          <source>Associativity</source>
          <target state="translated">Associativity</target>
        </trans-unit>
        <trans-unit id="b3392e5205fe590e481f972619ef5508947ebdc5" translate="yes" xml:space="preserve">
          <source>Associativity specification is redundant for unary operators and is only shown for completeness: unary prefix operators always associate right-to-left (&lt;code&gt;delete ++*p&lt;/code&gt; is &lt;code&gt;delete(++(*p))&lt;/code&gt;) and unary postfix operators always associate left-to-right (&lt;code&gt;a[1][2]++&lt;/code&gt; is &lt;code&gt;((a[1])[2])++&lt;/code&gt;). Note that the associativity is meaningful for member access operators, even though they are grouped with unary postfix operators: &lt;code&gt;a.b++&lt;/code&gt; is parsed &lt;code&gt;(a.b)++&lt;/code&gt; and not &lt;code&gt;a.(b++)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6062b342e2d9e9c70ef9a02f2326265c628746c" translate="yes" xml:space="preserve">
          <source>Assuming &lt;code&gt;i&lt;/code&gt; has built-in type or the postincrement operator is not &lt;a href=&quot;operators&quot;&gt;overloaded&lt;/a&gt; to return by lvalue reference.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74f381465fb7e488d40ff21e2669ec9bd0efa9fd" translate="yes" xml:space="preserve">
          <source>Assuming &lt;code&gt;i&lt;/code&gt; has built-in type or the pre-increment operator is &lt;a href=&quot;operators&quot;&gt;overloaded&lt;/a&gt; to return by lvalue reference.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="033599246c3928bd9bbc1f63fef180f75f1d6fa6" translate="yes" xml:space="preserve">
          <source>Assuming that &lt;code&gt;CD&lt;/code&gt; is the function return type and &lt;code&gt;CR&amp;lt;A, B&amp;gt; = &lt;a href=&quot;../../types/common_type&quot;&gt;std::common_type&lt;/a&gt;&amp;lt;A, B&amp;gt;::type&lt;/code&gt;, then:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f51aeb937353e872aa16e888ad3642d2d51989e0" translate="yes" xml:space="preserve">
          <source>Assuming that &lt;code&gt;CT =&lt;br/&gt; &lt;a href=&quot;../../types/common_type&quot;&gt;std::common_type&lt;/a&gt;&amp;lt;&lt;a href=&quot;../duration&quot;&gt;std::chrono::duration&lt;/a&gt;&amp;lt;Rep1, Period1&amp;gt;,&lt;br/&gt; &lt;a href=&quot;../duration&quot;&gt;std::chrono::duration&lt;/a&gt;&amp;lt;Rep2, Period2&amp;gt;&amp;gt;::type&lt;/code&gt;, then:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16dad30e22d9f8f0b187b91674cdf99f5bfa4cfb" translate="yes" xml:space="preserve">
          <source>Assuming that alignment requirements are met, a &lt;code&gt;reinterpret_cast&lt;/code&gt; does not change the &lt;a href=&quot;pointer#Pointers&quot;&gt;value of a pointer&lt;/a&gt; outside of a few limited cases dealing with &lt;a href=&quot;static_cast#pointer-interconvertible&quot;&gt;&lt;i&gt;pointer-interconvertible&lt;/i&gt;&lt;/a&gt; objects:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eaa51d32fe12f955eec03f2bc4bdb2751f3da027" translate="yes" xml:space="preserve">
          <source>At first, a local variable of type &lt;code&gt;BidirIt&lt;/code&gt; is constructed with the value of &lt;code&gt;match[0].second&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9ec839d7fa04addb5ce25ff54e78bc29c079bf1" translate="yes" xml:space="preserve">
          <source>At least one major implementation does not implement these rules and instead optimizes out the store to &lt;code&gt;n&lt;/code&gt;. The lifetime rules are under reconsideration as &lt;a href=&quot;https://wg21.link/CWG2256&quot;&gt;core issue 2256&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5357281e6d1ead597f87156333dc4e4a2d371458" translate="yes" xml:space="preserve">
          <source>At least one of &lt;code&gt;T1&lt;/code&gt; and &lt;code&gt;T2&lt;/code&gt; depends on a user-defined type, and</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7ff6c8662e2b7c4ac75ca0560a6904f05eb0097" translate="yes" xml:space="preserve">
          <source>At most</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a065be791d5f07e9b9b28e1a3ee4de5830efc2d5" translate="yes" xml:space="preserve">
          <source>At most 2&amp;middot;(N&lt;sub&gt;1&lt;/sub&gt;+N&lt;sub&gt;2&lt;/sub&gt;-1) comparisons, where N&lt;sub&gt;1&lt;/sub&gt;&lt;code&gt;= &lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first1, last1)&lt;/code&gt; and N&lt;sub&gt;2&lt;/sub&gt;&lt;code&gt;= &lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first2, last2)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f417027ea40c23a98d041983aee663fe84c4fd8a" translate="yes" xml:space="preserve">
          <source>At most 2&amp;middot;min(N1, N2) applications of the comparison operation, where &lt;code&gt;N1 = &lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first1, last1)&lt;/code&gt; and &lt;code&gt;N2 = &lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first2, last2)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82ec885967ce3dacad15402cd2d8eb2b10af93f5" translate="yes" xml:space="preserve">
          <source>At most &lt;code&gt;(last-first)/2&lt;/code&gt; swaps. Averaged over the entire sequence of permutations, typical implementations use about 3 comparisons and 1.5 swaps per call.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ddecdfce8186bf2f225c5a792633c5ddf7b502c1" translate="yes" xml:space="preserve">
          <source>At most &lt;code&gt;3*&lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first, last)&lt;/code&gt; comparisons.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37142ec0061a83658ba826e1c1afead3f11e0ec2" translate="yes" xml:space="preserve">
          <source>At most &lt;code&gt;d_last - d_first&lt;/code&gt; of the elements are placed sorted to the range &lt;code&gt;[d_first, d_first + n)&lt;/code&gt;. &lt;code&gt;n&lt;/code&gt; is the number of elements to sort (&lt;code&gt;n = min(last - first, d_last - d_first)&lt;/code&gt;). The order of equal elements is not guaranteed to be preserved.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2675fe7d12495f05dcdb52627fa675c17129e6a" translate="yes" xml:space="preserve">
          <source>At most &lt;code&gt;last - first&lt;/code&gt; applications of the predicate and the projection.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29eb338ad07d90987b424a3ee5360988d67741cd" translate="yes" xml:space="preserve">
          <source>At most &lt;code&gt;last - first&lt;/code&gt; applications of the predicate.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c36a9685749cdd93b9b788e8f13203a1e8dd5a28" translate="yes" xml:space="preserve">
          <source>At most &lt;code&gt;last&lt;/code&gt; - &lt;code&gt;first&lt;/code&gt; applications of the predicate.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="835c572fed24e005461e8303ab401feae3c77b72" translate="yes" xml:space="preserve">
          <source>At most &lt;code&gt;std::distance(first, last)&lt;/code&gt; applications of &lt;code&gt;p&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28b847c1c9ad7813c6cd6afbca6893f3a89d3246" translate="yes" xml:space="preserve">
          <source>At most N/2 swaps, where &lt;code&gt;N = &lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first, last)&lt;/code&gt;. Averaged over the entire sequence of permutations, typical implementations use about 3 comparisons and 1.5 swaps per call.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87d08107753bb0853d26d589fe4f49b4791d7a3c" translate="yes" xml:space="preserve">
          <source>At most O(N&lt;sup&gt;2&lt;/sup&gt;) applications of the predicate, or exactly N if the sequences are already equal, where &lt;code&gt;N=&lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first1, last1)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e9957d5de91d4b7c6c68d594aa3aa480005b9e3" translate="yes" xml:space="preserve">
          <source>At most linear in the &lt;code&gt;&lt;a href=&quot;size&quot;&gt;size()&lt;/a&gt;&lt;/code&gt; of the container.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b67cf2f323c75240ad28ea0936fabdb2eb7dfd2" translate="yes" xml:space="preserve">
          <source>At most linear in the &lt;code&gt;&lt;a href=&quot;size&quot;&gt;size()&lt;/a&gt;&lt;/code&gt; of the string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f95351bbc9191f119c0c979d668c0b60be5e7b1" translate="yes" xml:space="preserve">
          <source>At most linear in the size of the container.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a42136bb0320d6ac91f01ed89b5ec95ea11cd801" translate="yes" xml:space="preserve">
          <source>At most max(floor((3/2)*(N&amp;minus;1)), 0) applications of the predicate, where &lt;code&gt;N = &lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first, last)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d7bca3c1a2d078e776e71dcbe99b35a321e5167" translate="yes" xml:space="preserve">
          <source>At most one &lt;a href=&quot;union#Union-like_classes&quot;&gt;variant member&lt;/a&gt; can have a &lt;a href=&quot;data_members#Member_initialization&quot;&gt;default member initializer&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c1f6896df7e191deb062d81024e89c21817f2db" translate="yes" xml:space="preserve">
          <source>At most one copy option in each of the following options groups may be present, otherwise the behavior of the copy functions is undefined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d4b41d6c4f9d31917e8132872ca199c890aa525" translate="yes" xml:space="preserve">
          <source>At most one grammar option must be chosen out of &lt;code&gt;ECMAScript&lt;/code&gt;, &lt;code&gt;basic&lt;/code&gt;, &lt;code&gt;extended&lt;/code&gt;, &lt;code&gt;awk&lt;/code&gt;, &lt;code&gt;grep&lt;/code&gt;, &lt;code&gt;egrep&lt;/code&gt;. If no grammar is chosen, &lt;code&gt;ECMAScript&lt;/code&gt; is assumed to be selected. The other options serve as modifiers, such that &lt;code&gt;&lt;a href=&quot;../basic_regex&quot;&gt;std::regex&lt;/a&gt;(&quot;meow&quot;, std::regex::icase)&lt;/code&gt; is equivalent to &lt;code&gt;&lt;a href=&quot;../basic_regex&quot;&gt;std::regex&lt;/a&gt;(&quot;meow&quot;, std::regex::ECMAScript|std::regex::icase)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4664e42aaeebe95a9d1a078a45a775bf60943bc7" translate="yes" xml:space="preserve">
          <source>At most one grammar option must be chosen out of &lt;code&gt;ECMAScript&lt;/code&gt;, &lt;code&gt;basic&lt;/code&gt;, &lt;code&gt;extended&lt;/code&gt;, &lt;code&gt;awk&lt;/code&gt;, &lt;code&gt;grep&lt;/code&gt;, &lt;code&gt;egrep&lt;/code&gt;. If no grammar is chosen, &lt;code&gt;ECMAScript&lt;/code&gt; is assumed to be selected. The other options serve as modifiers, such that &lt;code&gt;&lt;a href=&quot;basic_regex&quot;&gt;std::regex&lt;/a&gt;(&quot;meow&quot;, std::regex::icase)&lt;/code&gt; is equivalent to &lt;code&gt;&lt;a href=&quot;basic_regex&quot;&gt;std::regex&lt;/a&gt;(&quot;meow&quot;, std::regex::ECMAScript|std::regex::icase)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e31fa82af84a5c287a47f543cebf5aedf134031" translate="yes" xml:space="preserve">
          <source>At most one grammar option must be chosen out of &lt;code&gt;ECMAScript&lt;/code&gt;, &lt;code&gt;basic&lt;/code&gt;, &lt;code&gt;extended&lt;/code&gt;, &lt;code&gt;awk&lt;/code&gt;, &lt;code&gt;grep&lt;/code&gt;, &lt;code&gt;egrep&lt;/code&gt;. If no grammar is chosen, &lt;code&gt;ECMAScript&lt;/code&gt; is assumed to be selected. The other options serve as modifiers, such that &lt;code&gt;std::regex(&quot;meow&quot;, std::regex::icase)&lt;/code&gt; is equivalent to &lt;code&gt;std::regex(&quot;meow&quot;, std::regex::ECMAScript|std::regex::icase)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="311d67e063c452f5ead23f742890b672f660636b" translate="yes" xml:space="preserve">
          <source>At most one of &lt;code&gt;add&lt;/code&gt;, &lt;code&gt;remove&lt;/code&gt;, &lt;code&gt;replace&lt;/code&gt; may be present, otherwise the behavior of the permissions function is undefined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2395ecfd633261d1a9cd5400cd07b765cc2f7a58" translate="yes" xml:space="preserve">
          <source>At most two comparisons.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c3f1418c87059f4cdb7e84bd90cc9bbf999a3c8" translate="yes" xml:space="preserve">
          <source>At or after modified element(s)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b99b53e1b81171c73a473d86eb4eba8e01df0ac3" translate="yes" xml:space="preserve">
          <source>At program startup,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc78dcde97d0faac3fa0ab3c4057950ede8cc9fd" translate="yes" xml:space="preserve">
          <source>At the point in the code the operator() is called, the type must be complete. In some implementations a &lt;code&gt;static_assert&lt;/code&gt; is used to make sure this is the case. The reason for this requirement is that calling &lt;a href=&quot;../language/delete&quot;&gt;delete&lt;/a&gt; on an incomplete type is undefined behavior in C++ if the complete class type has a nontrivial destructor or a deallocation function, as the compiler has no way of knowing whether such functions exist and must be invoked.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e34285cac72686e9e93e2ea071243a4d166878b4" translate="yes" xml:space="preserve">
          <source>Atomic Operations library</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c9d8d00b5cb702da9e8a277758916eb4dd3cc1c" translate="yes" xml:space="preserve">
          <source>Atomic and synchronized blocks</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6816e21f31c82f13f142f06d907125e6d3ac7b98" translate="yes" xml:space="preserve">
          <source>Atomic and synchronized blocks are used to implement &lt;a href=&quot;transactional_memory&quot;&gt;transactional memory&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82b6893aff5aea02a2292327874493a700ee80ae" translate="yes" xml:space="preserve">
          <source>Atomic blocks</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17b2c09204bb130f11f065ef3080da8ab1f767cb" translate="yes" xml:space="preserve">
          <source>Atomic constraints</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="401a31bc657222e6c53d68e589a5e6bc2cfed3b4" translate="yes" xml:space="preserve">
          <source>Atomic constraints are formed during &lt;a href=&quot;constraints#Constraint_normalization&quot;&gt;constraint normalization&lt;/a&gt;. &lt;code&gt;E&lt;/code&gt; is never a logical AND or logical OR expression (those form conjunctions and disjunctions, respectively).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab3668521ac1e65f2c9a3ca3cc545235dc9f88c8" translate="yes" xml:space="preserve">
          <source>Atomic load with &lt;code&gt;memory_order_acquire&lt;/code&gt; or stronger is an acquire operation. The lock() operation on a &lt;a href=&quot;../named_req/mutex&quot;&gt;Mutex&lt;/a&gt; is also an acquire operation. Note that &lt;code&gt;&lt;a href=&quot;atomic_thread_fence&quot;&gt;std::atomic_thread_fence&lt;/a&gt;&lt;/code&gt; imposes stronger synchronization requirements than an acquire operation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="783585c8300c9cdf7a66c42d7b14307cfec6d73d" translate="yes" xml:space="preserve">
          <source>Atomic load with &lt;code&gt;memory_order_consume&lt;/code&gt; or stronger is a consume operation. Note that &lt;code&gt;&lt;a href=&quot;atomic_thread_fence&quot;&gt;std::atomic_thread_fence&lt;/a&gt;&lt;/code&gt; imposes stronger synchronization requirements than a consume operation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb34ad6782840b3609292d56d50524837de11852" translate="yes" xml:space="preserve">
          <source>Atomic operations</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99d4cd5536d79615f44163fe8a9526d16ce5bfca" translate="yes" xml:space="preserve">
          <source>Atomic operations applied to an object through an &lt;code&gt;atomic_ref&lt;/code&gt; are atomic with respect to atomic operations applied through any other &lt;code&gt;atomic_ref&lt;/code&gt; referencing the same object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec45a74e461d6d1f9a6d6860119c9137a6fed5b2" translate="yes" xml:space="preserve">
          <source>Atomic operations library</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac1cfc02a52dba8b178a48b4597760d28fb77ccd" translate="yes" xml:space="preserve">
          <source>Atomic operations tagged &lt;code&gt;memory_order_relaxed&lt;/code&gt; are not synchronization operations; they do not impose an order among concurrent memory accesses. They only guarantee atomicity and modification order consistency.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f6d4f2c68a571824e3f43d98c75cbda9d541c52" translate="yes" xml:space="preserve">
          <source>Atomic operations tagged &lt;code&gt;memory_order_seq_cst&lt;/code&gt; not only order memory the same way as release/acquire ordering (everything that</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72d4efbfff4cc7a737493b1c1c5054ea34242989" translate="yes" xml:space="preserve">
          <source>Atomic store with &lt;code&gt;memory_order_release&lt;/code&gt; or stronger is a release operation. The unlock() operation on a &lt;a href=&quot;../named_req/mutex&quot;&gt;Mutex&lt;/a&gt; is also a release operation. Note that &lt;code&gt;&lt;a href=&quot;atomic_thread_fence&quot;&gt;std::atomic_thread_fence&lt;/a&gt;&lt;/code&gt; imposes stronger synchronization requirements than a release operation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6bd53298c2672a3d3501c1b3d668970f3f55e051" translate="yes" xml:space="preserve">
          <source>Atomic types</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90945bda736ccd52d67480431115772e6ed72f07" translate="yes" xml:space="preserve">
          <source>Atomic-fence synchronization</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d6ac2f41530550ee308dc296f9a8b617587365b" translate="yes" xml:space="preserve">
          <source>Atomically changes the state of a &lt;code&gt;&lt;a href=&quot;../atomic_flag&quot;&gt;std::atomic_flag&lt;/a&gt;&lt;/code&gt; to clear (&lt;code&gt;false&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29366d9f87188ae24c9efa9144aa990ffcfc84da" translate="yes" xml:space="preserve">
          <source>Atomically changes the state of a &lt;code&gt;&lt;a href=&quot;../atomic_flag&quot;&gt;std::atomic_flag&lt;/a&gt;&lt;/code&gt; to set (&lt;code&gt;true&lt;/code&gt;) and returns the value it held before.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ad9c0fc62bc1537d54b4759ea20c55784c16070" translate="yes" xml:space="preserve">
          <source>Atomically changes the state of a &lt;code&gt;&lt;a href=&quot;atomic_flag&quot;&gt;std::atomic_flag&lt;/a&gt;&lt;/code&gt; pointed to by &lt;code&gt;p&lt;/code&gt; to clear (&lt;code&gt;false&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75a7c684721b08be0f1216c929374cec16cea043" translate="yes" xml:space="preserve">
          <source>Atomically changes the state of a &lt;code&gt;&lt;a href=&quot;atomic_flag&quot;&gt;std::atomic_flag&lt;/a&gt;&lt;/code&gt; pointed to by &lt;code&gt;p&lt;/code&gt; to set (&lt;code&gt;true&lt;/code&gt;) and returns the value it held before.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2222bc337f08cf3ae8d66cc236b81d457d5ceac1" translate="yes" xml:space="preserve">
          <source>Atomically compares the &lt;a href=&quot;../../language/objects&quot;&gt;object representation&lt;/a&gt;(until C++20)&lt;a href=&quot;../../language/objects&quot;&gt;value representation&lt;/a&gt;(since C++20) of &lt;code&gt;*this&lt;/code&gt; with that of &lt;code&gt;expected&lt;/code&gt;, and if those are bitwise-equal, replaces the former with &lt;code&gt;desired&lt;/code&gt; (performs read-modify-write operation). Otherwise, loads the actual value stored in &lt;code&gt;*this&lt;/code&gt; into &lt;code&gt;expected&lt;/code&gt; (performs load operation).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b40ae57bd4976e100c4d9ee74cf8c6179fd8839" translate="yes" xml:space="preserve">
          <source>Atomically compares the &lt;a href=&quot;../../language/objects&quot;&gt;value representation&lt;/a&gt; of the referenced object with that of &lt;code&gt;expected&lt;/code&gt;, and if those are bitwise-equal, replaces the former with &lt;code&gt;desired&lt;/code&gt; (performs a read-modify-write operation). Otherwise, loads the actual value stored in the referenced object into &lt;code&gt;expected&lt;/code&gt; (performs a load operation).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aeaea937abc0bf67a8421b823386eae91292163e" translate="yes" xml:space="preserve">
          <source>Atomically compares the &lt;a href=&quot;../language/objects&quot;&gt;object representation&lt;/a&gt;(until C++20)&lt;a href=&quot;../language/objects&quot;&gt;value representation&lt;/a&gt;(since C++20) of the object pointed to by &lt;code&gt;obj&lt;/code&gt; with that of the object pointed to by &lt;code&gt;expected&lt;/code&gt;, and if those are bitwise-equal, replaces the former with &lt;code&gt;desired&lt;/code&gt; (performs read-modify-write operation). Otherwise, loads the actual value pointed to by &lt;code&gt;obj&lt;/code&gt; into &lt;code&gt;*expected&lt;/code&gt; (performs load operation). Copying is performed as if by &lt;code&gt;&lt;a href=&quot;../string/byte/memcpy&quot;&gt;std::memcpy&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="100502f70f849b38ac64477081a65ec2c013fbb9" translate="yes" xml:space="preserve">
          <source>Atomically increments or decrements the current value of the referenced object. These operations are read-modify-write operations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="478a2d2041d2790f2221395bbe5bc4e3d3f3c4ae" translate="yes" xml:space="preserve">
          <source>Atomically increments or decrements the current value. The operation is read-modify-write operation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7bed069080eb00025095bf335aa11983b2283e1" translate="yes" xml:space="preserve">
          <source>Atomically loads and returns the current value of the atomic variable. Equivalent to &lt;code&gt;load()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1952cd629d030a2fa8403e27ef4aeced380b94ae" translate="yes" xml:space="preserve">
          <source>Atomically loads and returns the current value of the atomic variable. Memory is affected according to the value of &lt;code&gt;order&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f83aead02c429c2fa534aa09292be21ef4c6405" translate="yes" xml:space="preserve">
          <source>Atomically loads and returns the current value of the referenced object. Equivalent to &lt;code&gt;load()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e52c7a399bc235c4dbc0b29092d8308432fa02c0" translate="yes" xml:space="preserve">
          <source>Atomically loads and returns the current value of the referenced object. Memory is affected according to the value of &lt;code&gt;order&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f53b29272e48fca5f9671422bca6315e7e6fd8c3" translate="yes" xml:space="preserve">
          <source>Atomically replaces the current value of the referenced object with &lt;code&gt;desired&lt;/code&gt;. Memory is affected according to the value of &lt;code&gt;order&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a19feea96676cb1f3c159f83afde19f4a6539c3e" translate="yes" xml:space="preserve">
          <source>Atomically replaces the current value of the referenced object with the result of arithmetic addition of the value and &lt;code&gt;arg&lt;/code&gt;. This operation is a read-modify-write operation. Memory is affected according to the value of &lt;code&gt;order&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b3d0c0959425f2182650fbfbac226f664e7ddf7" translate="yes" xml:space="preserve">
          <source>Atomically replaces the current value of the referenced object with the result of arithmetic subtraction of the value and &lt;code&gt;arg&lt;/code&gt;. This operation is a read-modify-write operation. Memory is affected according to the value of &lt;code&gt;order&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99dda00379caf075c4d39211472eaedafbd4f762" translate="yes" xml:space="preserve">
          <source>Atomically replaces the current value of the referenced object with the result of bitwise AND of the value and &lt;code&gt;arg&lt;/code&gt;. This operation is a read-modify-write operation. Memory is affected according to the value of &lt;code&gt;order&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="323c91d66c8118d7dbee222ab3de24a8cae5e0b1" translate="yes" xml:space="preserve">
          <source>Atomically replaces the current value of the referenced object with the result of bitwise OR of the value and &lt;code&gt;arg&lt;/code&gt;. This operation is a read-modify-write operation. Memory is affected according to the value of &lt;code&gt;order&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="adf79a00626da82188ce094554607a0fe2a38357" translate="yes" xml:space="preserve">
          <source>Atomically replaces the current value of the referenced object with the result of bitwise XOR of the value and &lt;code&gt;arg&lt;/code&gt;. This operation is a read-modify-write operation. Memory is affected according to the value of &lt;code&gt;order&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed67e3ed1c1744cb0f490f47975b11310f42139e" translate="yes" xml:space="preserve">
          <source>Atomically replaces the current value of the referenced object with the result of computation involving the previous value and &lt;code&gt;arg&lt;/code&gt;. These operations are read-modify-write operations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9b3020972d1b8ef0fae02f3fff0adbd8b1bd992" translate="yes" xml:space="preserve">
          <source>Atomically replaces the current value with &lt;code&gt;desired&lt;/code&gt;. Memory is affected according to the value of &lt;code&gt;order&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c638ee73c1897f53905a40e8ba22b46e8d59e4e1" translate="yes" xml:space="preserve">
          <source>Atomically replaces the current value with the result of arithmetic addition of the value and &lt;code&gt;arg&lt;/code&gt;. The operation is read-modify-write operation. Memory is affected according to the value of &lt;code&gt;order&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b99663e5dfaace40d5f5294851f50381ac55b0bc" translate="yes" xml:space="preserve">
          <source>Atomically replaces the current value with the result of arithmetic subtraction of the value and &lt;code&gt;arg&lt;/code&gt;. The operation is read-modify-write operation. Memory is affected according to the value of &lt;code&gt;order&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79ead769b0375ec14ce72a88030040dd2a0e44be" translate="yes" xml:space="preserve">
          <source>Atomically replaces the current value with the result of bitwise AND of the value and &lt;code&gt;arg&lt;/code&gt;. The operation is read-modify-write operation. Memory is affected according to the value of &lt;code&gt;order&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b7fe2746833cc38f05662da6d971a85fc32df09" translate="yes" xml:space="preserve">
          <source>Atomically replaces the current value with the result of bitwise OR of the value and &lt;code&gt;arg&lt;/code&gt;. The operation is read-modify-write operation. Memory is affected according to the value of &lt;code&gt;order&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ea95b2c69d82181c7d1ab5a7c21e9a5addde310" translate="yes" xml:space="preserve">
          <source>Atomically replaces the current value with the result of bitwise XOR of the value and &lt;code&gt;arg&lt;/code&gt;. The operation is read-modify-write operation. Memory is affected according to the value of &lt;code&gt;order&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10212a346ea05ad906b686a41eca7ff8ef3b510f" translate="yes" xml:space="preserve">
          <source>Atomically replaces the current value with the result of computation involving the previous value and &lt;code&gt;arg&lt;/code&gt;. The operation is read-modify-write operation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3467c0dccb0c6c9b65479a9107e17419103cfb53" translate="yes" xml:space="preserve">
          <source>Atomically replaces the underlying &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; with &lt;code&gt;desired&lt;/code&gt; as if by &lt;code&gt;p.swap(desired)&lt;/code&gt; where &lt;code&gt;p&lt;/code&gt; is the underlying &lt;code&gt;std::shared_ptr&amp;lt;T&amp;gt;&lt;/code&gt; and returns a copy of the value that &lt;code&gt;p&lt;/code&gt; had immediately before the swap. Memory is ordered according to &lt;code&gt;order&lt;/code&gt;. This is an atomic read-modify-write operation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85d280e69a1a33e2d68aa75acba96c49fd3e46b4" translate="yes" xml:space="preserve">
          <source>Atomically replaces the underlying &lt;code&gt;&lt;a href=&quot;../weak_ptr&quot;&gt;std::weak_ptr&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; with &lt;code&gt;desired&lt;/code&gt; as if by &lt;code&gt;p.swap(desired)&lt;/code&gt; where &lt;code&gt;p&lt;/code&gt; is the underlying &lt;code&gt;std::weak_ptr&amp;lt;T&amp;gt;&lt;/code&gt;, and returns a copy of the value that &lt;code&gt;p&lt;/code&gt; had immediately before the swap. Memory is ordered according to &lt;code&gt;order&lt;/code&gt;. This is an atomic read-modify-write operation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a463d97ca8c0c667a93bc169dce0bad4944f951" translate="yes" xml:space="preserve">
          <source>Atomically replaces the underlying value with &lt;code&gt;desired&lt;/code&gt;. The operation is read-modify-write operation. Memory is affected according to the value of &lt;code&gt;order&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="718b9a19aefebfb54908169ba35b035711a206bc" translate="yes" xml:space="preserve">
          <source>Atomically replaces the value of &lt;code&gt;*this&lt;/code&gt; with the value of &lt;code&gt;desired&lt;/code&gt; as if by &lt;code&gt;p.swap(desired)&lt;/code&gt; where &lt;code&gt;p&lt;/code&gt; is the underlying &lt;code&gt;std::shared_ptr&amp;lt;T&amp;gt;&lt;/code&gt;. Memory is ordered according to &lt;code&gt;order&lt;/code&gt;. The behavior is undefined if &lt;code&gt;order&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../../atomic/memory_order&quot;&gt;std::memory_order_consume&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../../atomic/memory_order&quot;&gt;std::memory_order_acquire&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;../../atomic/memory_order&quot;&gt;std::memory_order_acq_rel&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc343521b195a9638c26a309b38189be49c6ff1c" translate="yes" xml:space="preserve">
          <source>Atomically replaces the value of &lt;code&gt;*this&lt;/code&gt; with the value of &lt;code&gt;desired&lt;/code&gt; as if by &lt;code&gt;p.swap(desired)&lt;/code&gt; where &lt;code&gt;p&lt;/code&gt; is the underlying &lt;code&gt;std::weak_ptr&amp;lt;T&amp;gt;&lt;/code&gt;. Memory is ordered according to &lt;code&gt;order&lt;/code&gt;. The behavior is undefined if &lt;code&gt;order&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../../atomic/memory_order&quot;&gt;std::memory_order_consume&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../../atomic/memory_order&quot;&gt;std::memory_order_acquire&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;../../atomic/memory_order&quot;&gt;std::memory_order_acq_rel&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eccb30a10adac1732c948846412c97a22323cf04" translate="yes" xml:space="preserve">
          <source>Atomically replaces the value of the referenced object with &lt;code&gt;desired&lt;/code&gt;. The operation is a read-modify-write operation. Memory is affected according to the value of &lt;code&gt;order&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80dd75e8d600a19f4770f91cf5757274b7f5c6c5" translate="yes" xml:space="preserve">
          <source>Atomically replaces the value pointed by &lt;code&gt;obj&lt;/code&gt; with the result of bitwise AND between the old value of &lt;code&gt;obj&lt;/code&gt; and &lt;code&gt;arg&lt;/code&gt;. Returns the value &lt;code&gt;obj&lt;/code&gt; held previously.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="790044bcc17db31e5c336936470c4daa1b6b3cd4" translate="yes" xml:space="preserve">
          <source>Atomically replaces the value pointed by &lt;code&gt;obj&lt;/code&gt; with the result of bitwise OR between the old value of &lt;code&gt;obj&lt;/code&gt; and &lt;code&gt;arg&lt;/code&gt;. Returns the value &lt;code&gt;obj&lt;/code&gt; held previously.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f251ecee591189cacdcc48a0936a14e913d943df" translate="yes" xml:space="preserve">
          <source>Atomically replaces the value pointed by &lt;code&gt;obj&lt;/code&gt; with the result of bitwise XOR between the old value of &lt;code&gt;obj&lt;/code&gt; and &lt;code&gt;arg&lt;/code&gt;. Returns the value &lt;code&gt;obj&lt;/code&gt; held previously.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d9f4d98a3780918fb788b0a5026571e73af577e" translate="yes" xml:space="preserve">
          <source>Atomically returns a copy of the underlying &lt;code&gt;std::weak_ptr&amp;lt;T&amp;gt;&lt;/code&gt;. Memory is ordered according to &lt;code&gt;order&lt;/code&gt;. The behavior is undefined if &lt;code&gt;order&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../../atomic/memory_order&quot;&gt;std::memory_order_release&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../../atomic/memory_order&quot;&gt;std::memory_order_acq_rel&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33f67f81fe0865ff25fe2875aabcaf4cb3ed91ca" translate="yes" xml:space="preserve">
          <source>Atomically returns a copy of the underlying shared pointer. Memory is ordered according to &lt;code&gt;order&lt;/code&gt;. The behavior is undefined if &lt;code&gt;order&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../../atomic/memory_order&quot;&gt;std::memory_order_release&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../../atomic/memory_order&quot;&gt;std::memory_order_acq_rel&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68c88562518723a64d9fcb4f31aa71ec0eefafe8" translate="yes" xml:space="preserve">
          <source>Atomically stores the exception pointer &lt;code&gt;p&lt;/code&gt; into the shared state and makes the state ready.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5a3aae2b82d6bc278809f7ca79720a49ddb5e50" translate="yes" xml:space="preserve">
          <source>Atomically transmits all pending output to the wrapped stream.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22cd0cbd81dee9dcd227285a4fb456261af24ea4" translate="yes" xml:space="preserve">
          <source>Atomics</source>
          <target state="translated">Atomics</target>
        </trans-unit>
        <trans-unit id="a0416416d30eca6a7701e0924dc48acb5d8ff422" translate="yes" xml:space="preserve">
          <source>Attempting to forward an rvalue as an lvalue, such as by instantiating the form (2) with lvalue reference type T, is a compile-time error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76a4004354e2dd4daf0348cba6cc1fc1999f48f1" translate="yes" xml:space="preserve">
          <source>Attempting to modify a string literal results in</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="abad2c050ad896c23b0ad28b3e223e6dd62344dd" translate="yes" xml:space="preserve">
          <source>Attempting to specialize a template defined in the &lt;code&gt;&amp;lt;type_traits&amp;gt;&lt;/code&gt; header results in undefined behavior, except that &lt;code&gt;&lt;a href=&quot;types/common_type&quot;&gt;std::common_type&lt;/a&gt;&lt;/code&gt; may be specialized &lt;a href=&quot;types/common_type#Specializations&quot;&gt;as described in its description&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78a4a89b2d2486832b4cafece47f12bab7a55776" translate="yes" xml:space="preserve">
          <source>Attempts to acquire the lock for the current execution agent (thread, process, task) without blocking. If an exception is thrown, no lock is obtained.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="baca3810d2cde4b7e1025b84062248c5223beff5" translate="yes" xml:space="preserve">
          <source>Attempts to clear the floating-point exceptions that are listed in the bitmask argument &lt;code&gt;excepts&lt;/code&gt;, which is a bitwise OR of the &lt;a href=&quot;fe_exceptions&quot;&gt;floating point exception macros&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7dbed2ba20cbcb53c66e4a383e6c53bad4b2eb39" translate="yes" xml:space="preserve">
          <source>Attempts to extract (&quot;splice&quot;) each element in &lt;code&gt;source&lt;/code&gt; and insert it into &lt;code&gt;*this&lt;/code&gt; using the comparison object of &lt;code&gt;*this&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69638346260f8c39f54ee09036f959b95caeb136" translate="yes" xml:space="preserve">
          <source>Attempts to extract (&quot;splice&quot;) each element in &lt;code&gt;source&lt;/code&gt; and insert it into &lt;code&gt;*this&lt;/code&gt; using the comparison object of &lt;code&gt;*this&lt;/code&gt;. If there is an element in &lt;code&gt;*this&lt;/code&gt; with key equivalent to the key of an element from &lt;code&gt;source&lt;/code&gt;, then that element is not extracted from &lt;code&gt;source&lt;/code&gt;. No elements are copied or moved, only the internal pointers of the container nodes are repointed. All pointers and references to the transferred elements remain valid, but now refer into &lt;code&gt;*this&lt;/code&gt;, not into &lt;code&gt;source&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95555f012243a16b5fbac5ece1355dd665253556" translate="yes" xml:space="preserve">
          <source>Attempts to extract (&quot;splice&quot;) each element in &lt;code&gt;source&lt;/code&gt; and insert it into &lt;code&gt;*this&lt;/code&gt; using the hash function and key equality predicate of &lt;code&gt;*this&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5462c1b9abbfcaedbee9e1ed5c5c12b594c2335b" translate="yes" xml:space="preserve">
          <source>Attempts to extract (&quot;splice&quot;) each element in &lt;code&gt;source&lt;/code&gt; and insert it into &lt;code&gt;*this&lt;/code&gt; using the hash function and key equality predicate of &lt;code&gt;*this&lt;/code&gt;. If there is an element in &lt;code&gt;*this&lt;/code&gt; with key equivalent to the key of an element from &lt;code&gt;source&lt;/code&gt;, then that element is not extracted from &lt;code&gt;source&lt;/code&gt;. No elements are copied or moved, only the internal pointers of the container nodes are repointed. All pointers and references to the transferred elements remain valid, but now refer into &lt;code&gt;*this&lt;/code&gt;, not into &lt;code&gt;source&lt;/code&gt;. Iterators referring to the transferred elements and all iterators referring to &lt;code&gt;*this&lt;/code&gt; are invalidated. Iterators to elements remaining in &lt;code&gt;source&lt;/code&gt; remain valid.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92bc4254a3b00d301ffc057c9e050501ca173c4b" translate="yes" xml:space="preserve">
          <source>Attempts to obtain exclusive ownership of the mutex for the calling thread without blocking. If ownership is not obtained, returns immediately. The function is allowed to spuriously fail and return even if the mutex is not currently owned by another thread.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d99e4cbad6e4e7caa7d20dc148d4b12dfad9de6" translate="yes" xml:space="preserve">
          <source>Attempts to obtain exclusive ownership of the mutex within the duration specified by &lt;code&gt;duration&lt;/code&gt;. If &lt;code&gt;duration&lt;/code&gt; is less or equal &lt;code&gt;duration.zero()&lt;/code&gt;, attempts to obtain the ownership without locking (as if by &lt;code&gt;try_lock()&lt;/code&gt;). Otherwise, this function blocks until the mutex is acquired or until the time specified by &lt;code&gt;duration&lt;/code&gt; passes. It returns within &lt;code&gt;duration&lt;/code&gt; only if it succeeds, but it allowed to fail to acquire the mutex even if at some point in time during &lt;code&gt;duration&lt;/code&gt; it was not owned by another thread. In any case, it returns &lt;code&gt;true&lt;/code&gt; if the mutex was acquired and &lt;code&gt;false&lt;/code&gt; otherwise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80bd748efa455b573b135d3617ebfa1fd13b34d8" translate="yes" xml:space="preserve">
          <source>Attempts to obtain exclusive ownership of the mutex within the time left until &lt;code&gt;time_point&lt;/code&gt;. If &lt;code&gt;time_point&lt;/code&gt; already passed, attempts to obtain the ownership without locking (as if by &lt;code&gt;try_lock()&lt;/code&gt;). Otherwise, this function blocks until the mutex is acquired or until the time specified by &lt;code&gt;time_point&lt;/code&gt; passes. It returns before &lt;code&gt;time_point&lt;/code&gt; only if it succeeds, but it allowed to fail to acquire the mutex even if at some point in time before &lt;code&gt;time_point&lt;/code&gt; it was not owned by another thread. In any case, it returns &lt;code&gt;true&lt;/code&gt; if the mutex was acquired and &lt;code&gt;false&lt;/code&gt; otherwise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7fb190dc6b50cac16e4189df447478fcf3a9d392" translate="yes" xml:space="preserve">
          <source>Attempts to obtain shared ownership of the mutex for the calling thread without blocking. If ownership is not obtained, returns immediately. The function is allowed to spuriously fail and return even if the mutex is not currently owned by any threads in any mode.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1ab0535323ac87b863427dcfd803c52e2e71c97" translate="yes" xml:space="preserve">
          <source>Attempts to obtain shared ownership of the mutex within the duration specified by &lt;code&gt;duration&lt;/code&gt;. If &lt;code&gt;duration&lt;/code&gt; is less or equal &lt;code&gt;duration.zero()&lt;/code&gt;, attempts to obtain the ownership without waiting (as if by &lt;code&gt;try_lock()&lt;/code&gt;). Otherwise, this function blocks until the mutex is acquired or until the time specified by &lt;code&gt;duration&lt;/code&gt; passes. It returns within &lt;code&gt;duration&lt;/code&gt; only if it succeeds, but it allowed to fail to acquire the mutex even if at some point in time during &lt;code&gt;duration&lt;/code&gt; it was not owned by another thread. In any case, it returns &lt;code&gt;true&lt;/code&gt; if the mutex was acquired and &lt;code&gt;false&lt;/code&gt; otherwise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e1b61606843aa888af598e0c261d938b302f15a" translate="yes" xml:space="preserve">
          <source>Attempts to obtain shared ownership of the mutex within the time left until &lt;code&gt;time_point&lt;/code&gt;. If &lt;code&gt;time_point&lt;/code&gt; already passed, attempts to obtain the ownership without locking (as if by &lt;code&gt;try_lock()&lt;/code&gt;). Otherwise, this function blocks until the mutex is acquired or until the time specified by &lt;code&gt;time_point&lt;/code&gt; passes. It returns before &lt;code&gt;time_point&lt;/code&gt; only if it succeeds, but it allowed to fail to acquire the mutex even if at some point in time before &lt;code&gt;time_point&lt;/code&gt; it was not owned by another thread. In any case, it returns &lt;code&gt;true&lt;/code&gt; if the mutex was acquired and &lt;code&gt;false&lt;/code&gt; otherwise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52d6b2b14e6e6fe30ee7f8d64fe95f33b5f6832a" translate="yes" xml:space="preserve">
          <source>Attempts to parse the input stream &lt;code&gt;is&lt;/code&gt; into the &lt;code&gt;&lt;a href=&quot;../duration&quot;&gt;std::chrono::duration&lt;/a&gt;&lt;/code&gt;&lt;code&gt;d&lt;/code&gt;, interpreted as the time of day since midnight, according to the format string &lt;code&gt;fmt&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="376efd8a04cc4bbd4dec0c37c8f77d83f331d150" translate="yes" xml:space="preserve">
          <source>Attempts to parse the input stream &lt;code&gt;is&lt;/code&gt; into the &lt;code&gt;std::chrono::day&lt;/code&gt;&lt;code&gt;d&lt;/code&gt; according to the format string &lt;code&gt;fmt&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ca1a9386d370561e811dd985b14a1c196b3e9e6" translate="yes" xml:space="preserve">
          <source>Attempts to parse the input stream &lt;code&gt;is&lt;/code&gt; into the &lt;code&gt;std::chrono::month&lt;/code&gt;&lt;code&gt;m&lt;/code&gt; according to the format string &lt;code&gt;fmt&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40506d7d67c8bce66782b683f245a3f3fdf40954" translate="yes" xml:space="preserve">
          <source>Attempts to parse the input stream &lt;code&gt;is&lt;/code&gt; into the &lt;code&gt;std::chrono::month_day&lt;/code&gt;&lt;code&gt;md&lt;/code&gt; according to the format string &lt;code&gt;fmt&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40de5b5311f786d5adb9ba2992f4f537c57266b8" translate="yes" xml:space="preserve">
          <source>Attempts to parse the input stream &lt;code&gt;is&lt;/code&gt; into the &lt;code&gt;std::chrono::weekday&lt;/code&gt;&lt;code&gt;wd&lt;/code&gt; according to the format string &lt;code&gt;fmt&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c5714af52ba60c907aab16771ef9fc12f5e61b9" translate="yes" xml:space="preserve">
          <source>Attempts to parse the input stream &lt;code&gt;is&lt;/code&gt; into the &lt;code&gt;std::chrono::year&lt;/code&gt;&lt;code&gt;y&lt;/code&gt; according to the format string &lt;code&gt;fmt&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40c30b9ec9cc1fd3faebf2fb9fdfd4762f1dbc0a" translate="yes" xml:space="preserve">
          <source>Attempts to parse the input stream &lt;code&gt;is&lt;/code&gt; into the &lt;code&gt;std::chrono::year_month&lt;/code&gt;&lt;code&gt;ym&lt;/code&gt; according to the format string &lt;code&gt;fmt&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca0d091ecc65883512fa43e7446c9c5bb23b7dda" translate="yes" xml:space="preserve">
          <source>Attempts to parse the input stream &lt;code&gt;is&lt;/code&gt; into the &lt;code&gt;std::chrono::year_month_day&lt;/code&gt;&lt;code&gt;ymd&lt;/code&gt; according to the format string &lt;code&gt;fmt&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31bf10609fbb5d90b5c351b1efc2680a881a160b" translate="yes" xml:space="preserve">
          <source>Attempts to parse the input stream &lt;code&gt;is&lt;/code&gt; into the time point &lt;code&gt;tp&lt;/code&gt; according to the format string &lt;code&gt;fmt&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80ba342b8785a08804a333bbfedec341d6d1c9c0" translate="yes" xml:space="preserve">
          <source>Attempts to raise all floating point exceptions listed in &lt;code&gt;excepts&lt;/code&gt; (a bitwise OR of the &lt;a href=&quot;fe_exceptions&quot;&gt;floating point exception macros&lt;/a&gt;). If one of the exceptions is &lt;code&gt;&lt;a href=&quot;fe_exceptions&quot;&gt;FE_OVERFLOW&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;fe_exceptions&quot;&gt;FE_UNDERFLOW&lt;/a&gt;&lt;/code&gt;, this function may additionally raise &lt;code&gt;&lt;a href=&quot;fe_exceptions&quot;&gt;FE_INEXACT&lt;/a&gt;&lt;/code&gt;. The order in which the exceptions are raised is unspecified, except that &lt;code&gt;&lt;a href=&quot;fe_exceptions&quot;&gt;FE_OVERFLOW&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;fe_exceptions&quot;&gt;FE_UNDERFLOW&lt;/a&gt;&lt;/code&gt; are always raised before &lt;code&gt;&lt;a href=&quot;fe_exceptions&quot;&gt;FE_INEXACT&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a086d942884a301b827479029ba19c2746237425" translate="yes" xml:space="preserve">
          <source>Attribute</source>
          <target state="translated">Attribute</target>
        </trans-unit>
        <trans-unit id="a902057674f85199d3ac1499e38efca7a4896e56" translate="yes" xml:space="preserve">
          <source>Attribute declaration (&lt;a href=&quot;attributes&quot;&gt;attr&lt;/a&gt;&lt;code&gt;;&lt;/code&gt;) (since C++11)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73fed77350865417033e78f8ec9ca2448d835567" translate="yes" xml:space="preserve">
          <source>Attribute list</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6652617f2c799eb11ee727b16c5646c48af6905" translate="yes" xml:space="preserve">
          <source>Attributes</source>
          <target state="translated">Attributes</target>
        </trans-unit>
        <trans-unit id="fad8ef5207a6faf8cf0a093eff47035c565b35b8" translate="yes" xml:space="preserve">
          <source>Attributes for &lt;a href=&quot;language/enum&quot;&gt;enumerators&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c24797e2f08fead2ed265ebddf05756fe163fa39" translate="yes" xml:space="preserve">
          <source>Attributes for &lt;a href=&quot;language/namespace&quot;&gt;namespaces&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24a93aad8da8b2ecc0fb62d3635f7bcad0973aee" translate="yes" xml:space="preserve">
          <source>Attributes provide the unified standard syntax for implementation-defined language extensions, such as the GNU and IBM language extensions &lt;code&gt;__attribute__((...))&lt;/code&gt;, Microsoft extension &lt;code&gt;__declspec()&lt;/code&gt;, etc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="35d5b17890aadedb8aadfe40da01d18e88c0f170" translate="yes" xml:space="preserve">
          <source>Average case O(N), worst case O(N*size()+N), where N is &lt;code&gt;source.size()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca02a8758f4a48f9665324811a74024dd77f1084" translate="yes" xml:space="preserve">
          <source>Average case linear in the number of elements with the key &lt;code&gt;key&lt;/code&gt;, worst case linear in the size of the container.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="500ca2374c6717aa20d965b6fb6566e425ffa363" translate="yes" xml:space="preserve">
          <source>Average case linear in the size of the container, worst case quadratic.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0cf15213abbcf806e052466023c496d374b93c5e" translate="yes" xml:space="preserve">
          <source>Average case: constant, worst case: linear in size.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c69ec73023882fcdb14f4029c8b28967cb6b9150" translate="yes" xml:space="preserve">
          <source>Average number of elements per bucket.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5af1300096bdfebd096b49bf84d70a955eb1b7f9" translate="yes" xml:space="preserve">
          <source>Avoiding implicit copy assignment.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c40560d40ca8b01a27ce21af51b6bb3a0aa5d77" translate="yes" xml:space="preserve">
          <source>Avoiding implicit generation of the copy constructor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55a6c927298fd43f61b985a13d7c9627855c38d0" translate="yes" xml:space="preserve">
          <source>Avoiding implicit move assignment.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21e51124dadde6f26a27f5ade3d091ebb552a9a3" translate="yes" xml:space="preserve">
          <source>Avoiding implicit move constructor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae4f281df5a5d0ff3cad6371f76d5c29b6d953ec" translate="yes" xml:space="preserve">
          <source>B</source>
          <target state="translated">B</target>
        </trans-unit>
        <trans-unit id="4c39141080123158d56211e39765a42a9728de5f" translate="yes" xml:space="preserve">
          <source>B 2) A</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62706ba741ba699cbebde8104c0834806fb26022" translate="yes" xml:space="preserve">
          <source>B 3) A</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a1b08f2698d8eaa357ae4e4639ab5964829b92d" translate="yes" xml:space="preserve">
          <source>B 4) A</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc28f53619db61ee68c4c2b6467d93002c47863a" translate="yes" xml:space="preserve">
          <source>B and A appears before Y in the Single Total Order</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="403422f66cba2adadb0da593596292864fb30e29" translate="yes" xml:space="preserve">
          <source>B within thread 1 and C is</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e54499211164f4b65d4e8324b3d4ca2593386d6" translate="yes" xml:space="preserve">
          <source>B, and X appears before Y in the Single Total Order, then B observes either:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45e5662cbbb3c35284b81863cd8050953ac79093" translate="yes" xml:space="preserve">
          <source>B, and X appears before Y in the Single Total Order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4bf1b75c4f0c15c46e32fb9f6447c95ca649c7c" translate="yes" xml:space="preserve">
          <source>B, and both A and B are sequentially consistent atomic operations 3) A is</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4bf2b61e8848faddd0e0998dfeaa5d79d2e597c" translate="yes" xml:space="preserve">
          <source>B, then A appears to be evaluated before B in all contexts.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd0adbaaff060b07baf50fd24c9446ab105890da" translate="yes" xml:space="preserve">
          <source>B, then A precedes B in S 2) for every pair of atomic operations A and B on an object M, where A is</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b23fad0d216b95f70509ee04aeb30c3631070eb7" translate="yes" xml:space="preserve">
          <source>B, then B observes one of the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bfcc02cf7f3d23e187eac12bb5d9ac766d223025" translate="yes" xml:space="preserve">
          <source>B. Stroustrup (2000), &quot;The C++ Programming Language&quot;&lt;a href=&quot;http://stroustrup.com/3rd_safe.pdf&quot;&gt;Appendix E&quot;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1a4c571996703e3e33bba826b70616b63fd77ac" translate="yes" xml:space="preserve">
          <source>B...</source>
          <target state="translated">B...</target>
        </trans-unit>
        <trans-unit id="56809777eee50fda776cf36fcf8f615216fd8cfd" translate="yes" xml:space="preserve">
          <source>B: a) if A and B are both &lt;code&gt;memory_order_seq_cst&lt;/code&gt; operations, then A precedes B in S b) if A is a &lt;code&gt;memory_order_seq_cst&lt;/code&gt; operation, and B</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90973d18393c2644dbda93e71ed88917ecac4b89" translate="yes" xml:space="preserve">
          <source>BLAS-like slice of a valarray: starting index, length, stride</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6909406a48bd13f476c9416147defba89909eee5" translate="yes" xml:space="preserve">
          <source>BUFSIZ</source>
          <target state="translated">BUFSIZ</target>
        </trans-unit>
        <trans-unit id="1afefdad8f394c65ed6d000a865d699a38489c6f" translate="yes" xml:space="preserve">
          <source>Bad address</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="100269e198b12a051ab659ff66bd324a08031278" translate="yes" xml:space="preserve">
          <source>Bad file descriptor</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="551cd91c11cd1216214e9eb9e26d84be076f8948" translate="yes" xml:space="preserve">
          <source>Bad message</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6bda91ea312720b2ec09940e98682034dcace7af" translate="yes" xml:space="preserve">
          <source>Barebones valarray-backed Matrix class with a &lt;a href=&quot;https://en.wikipedia.org/wiki/Trace_(linear_algebra)&quot;&gt;trace&lt;/a&gt; calculating function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="077fe9c54ed5ed26fa547f4ded3ef9a9bb066d65" translate="yes" xml:space="preserve">
          <source>Base</source>
          <target state="translated">Base</target>
        </trans-unit>
        <trans-unit id="3bcdbe728e1760eac3fdacb54d72efd9ba89bbaa" translate="yes" xml:space="preserve">
          <source>Base specifiers and member initializer lists</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1604e75055b78b9111dd5b59253504e535b02f2" translate="yes" xml:space="preserve">
          <source>Base::vf (whether or not the word &lt;code&gt;override&lt;/code&gt; is used in its declaration).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5899059fb2d20a463b2a04266836e60a1b0645c6" translate="yes" xml:space="preserve">
          <source>BaseCharacteristic</source>
          <target state="translated">BaseCharacteristic</target>
        </trans-unit>
        <trans-unit id="aa2c96dacf00c451ef465f6115a45a20bccf1256" translate="yes" xml:space="preserve">
          <source>Basic</source>
          <target state="translated">Basic</target>
        </trans-unit>
        <trans-unit id="e4e7ae591b0abd861a75d3fa39a7cab907d2a5c8" translate="yes" xml:space="preserve">
          <source>Basic concepts</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1dda37dbdb1d5ae832ec94dde2b8248f41206b6f" translate="yes" xml:space="preserve">
          <source>Basic exception guarantee</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="beb8cd5e0f8e7a06f8d36dc83c4364f7f79078fa" translate="yes" xml:space="preserve">
          <source>Basic operations</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3fc431b29bb2c2516db706b2f480a558166eba6d" translate="yes" xml:space="preserve">
          <source>Basic types</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="928b9aad5c0144f195e57231e11400d2c46ac0fb" translate="yes" xml:space="preserve">
          <source>Basic types (e.g. &lt;code&gt;&lt;a href=&quot;types/size_t&quot;&gt;std::size_t&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;types/nullptr_t&quot;&gt;std::nullptr_t&lt;/a&gt;&lt;/code&gt;), RTTI (e.g. &lt;code&gt;&lt;a href=&quot;types/type_info&quot;&gt;std::type_info&lt;/a&gt;&lt;/code&gt;), type traits (e.g. &lt;code&gt;&lt;a href=&quot;types/is_integral&quot;&gt;std::is_integral&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;types/rank&quot;&gt;std::rank&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c2ef712eeb88ff3db947441935726076c82c0bb" translate="yes" xml:space="preserve">
          <source>BasicLockable</source>
          <target state="translated">BasicLockable</target>
        </trans-unit>
        <trans-unit id="90870ca4432acfd7b541273fcb2661e871119daf" translate="yes" xml:space="preserve">
          <source>Because &lt;a href=&quot;../../language/template_argument_deduction&quot;&gt;template argument deduction&lt;/a&gt; does not consider implicit conversions, these operators cannot be used for mixed integer/complex arithmetic. In all cases, the scalar must have the same type as the underlying type of the complex number.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1f6ad19289944156463986759f118c4be88ae5a" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;&lt;a href=&quot;../memory/unique_ptr&quot;&gt;std::unique_ptr&lt;/a&gt;&lt;/code&gt; requires that the pointed-to type is a complete type in any context where the deleter is called, the destructor and the copy/move assignment operators must be user-declared and defined out-of-line, in the implementation file, where the implementation class is complete. This suppresses the move constructor, which has to be defined or defaulted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee2e8f20b5463733118ed9ad438d1e579dcd6096" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;assert&lt;/code&gt; is a &lt;a href=&quot;../preprocessor/replace&quot;&gt;function-like macro&lt;/a&gt;, commas anywhere in condition that are not protected by parentheses are interpreted as macro argument separators. Such commas are often found in template argument lists and list-initialization:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53424f213e903d21acf1145501cd3bd319bc65a2" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;regex_match&lt;/code&gt; only considers full matches, the same regex may give different matches between &lt;code&gt;regex_match&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;regex_search&quot;&gt;std::regex_search&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c2c9164d9adc62f94d817ac748a2112477652ed" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;setlocale&lt;/code&gt; modifies global state which affects execution of locale-dependent functions, it is undefined behavior to call it from one thread, while another thread is executing any of the following functions: &lt;code&gt;&lt;a href=&quot;../io/c/printf&quot;&gt;std::fprintf&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;std::isprint&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/wide/iswdigit&quot;&gt;std::iswdigit&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;localeconv&quot;&gt;std::localeconv&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;std::tolower&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../io/c/scanf&quot;&gt;std::fscanf&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;std::ispunct&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/wide/iswgraph&quot;&gt;std::iswgraph&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/multibyte/mblen&quot;&gt;std::mblen&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;std::toupper&lt;/code&gt;, &lt;code&gt;std::isalnum&lt;/code&gt;, &lt;code&gt;std::isspace&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/wide/iswlower&quot;&gt;std::iswlower&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/multibyte/mbstowcs&quot;&gt;std::mbstowcs&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/wide/towlower&quot;&gt;std::towlower&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;std::isalpha&lt;/code&gt;, &lt;code&gt;std::isupper&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/wide/iswprint&quot;&gt;std::iswprint&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/multibyte/mbtowc&quot;&gt;std::mbtowc&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/wide/towupper&quot;&gt;std::towupper&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;std::isblank&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/wide/iswalnum&quot;&gt;std::iswalnum&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/wide/iswpunct&quot;&gt;std::iswpunct&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;std::setlocale&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/wide/wcscoll&quot;&gt;std::wcscoll&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;std::iscntrl&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/wide/iswalpha&quot;&gt;std::iswalpha&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/wide/iswspace&quot;&gt;std::iswspace&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/byte/strcoll&quot;&gt;std::strcoll&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/wide/wcstof&quot;&gt;std::wcstod&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;std::isdigit&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/wide/iswblank&quot;&gt;std::iswblank&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/wide/iswupper&quot;&gt;std::iswupper&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/byte/strerror&quot;&gt;std::strerror&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/multibyte/wcstombs&quot;&gt;std::wcstombs&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;std::isgraph&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/wide/iswcntrl&quot;&gt;std::iswcntrl&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/wide/iswxdigit&quot;&gt;std::iswxdigit&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/byte/strtof&quot;&gt;std::strtod&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/wide/wcsxfrm&quot;&gt;std::wcsxfrm&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;std::islower&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/wide/iswctype&quot;&gt;std::iswctype&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;std::isxdigit&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89d8571118516caef2a1d25c02e79eb519ae1beb" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;std::remove&lt;/code&gt; takes &lt;code&gt;value&lt;/code&gt; by reference, it can have unexpected behavior if it is a reference to an element of the range &lt;code&gt;[first, last)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20471d58e5d2833a1993c6fb0cc59d825025d821" translate="yes" xml:space="preserve">
          <source>Because C++ copies and copy-assigns objects of user-defined types in various situations (passing/returning by value, manipulating a container, etc), these special member functions will be called, if accessible, and if they are not user-defined, they are implicitly-defined by the compiler.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="517acf744121042d5f84823be03eeb3b29badaed" translate="yes" xml:space="preserve">
          <source>Because C++ interprets a character immediately following a string literal as a &lt;a href=&quot;../language/user_literal&quot;&gt;user-defined string literal&lt;/a&gt;, C code such as &lt;code&gt;printf(&quot;%&quot;PRId64&quot;\n&quot;,n);&lt;/code&gt; is invalid C++ and requires a space before &lt;code&gt;PRId64&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="219e7d89011a786888d2482ec713003b1ecb5238" translate="yes" xml:space="preserve">
          <source>Because POSIX uses &quot;leftmost longest&quot; matching rule (the longest matching subsequence is matched, and if there are several such subsequences, the first one is matched), it is not suitable, for example, for parsing markup languages: a POSIX regex such as &lt;code&gt;&quot;&amp;lt;tag[^&amp;gt;]*&amp;gt;.*&amp;lt;/tag&amp;gt;&quot;&lt;/code&gt; would match everything from the first &lt;code&gt;&quot;&amp;lt;tag&quot;&lt;/code&gt; to the last &lt;code&gt;&quot;&amp;lt;/tag&amp;gt;&quot;&lt;/code&gt;, including every &lt;code&gt;&quot;&amp;lt;/tag&amp;gt;&quot;&lt;/code&gt; and &lt;code&gt;&quot;&amp;lt;tag&amp;gt;&quot;&lt;/code&gt; inbetween. On the other hand, ECMAScript supports non-greedy matches, and the ECMAScript regex &lt;code&gt;&quot;&amp;lt;tag[^&amp;gt;]*&amp;gt;.*?&amp;lt;/tag&amp;gt;&quot;&lt;/code&gt; would match only until the first closing tag.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b08396994d212dfe6289df9ec245e89c348fd76a" translate="yes" xml:space="preserve">
          <source>Because a pair of brackets following the keyword &lt;code&gt;delete&lt;/code&gt; is always interpreted as the array form of delete, a lambda-expression with empty capture list immediately after &lt;code&gt;delete&lt;/code&gt; must be enclosed in parentheses.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="672ca8a2390d44e9109a5b0f60fc6036a7a4d8de" translate="yes" xml:space="preserve">
          <source>Because a temporary copy of the object is constructed during post-increment and post-decrement,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52aa0f31213848ac5fabf7dcecdd2f55a132ed32" translate="yes" xml:space="preserve">
          <source>Because array elements cannot have incomplete type, multidimensional arrays cannot have unknown bound in a dimension other than the first:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ebfd5a82361d89ed63a37a3062866f4e78777689" translate="yes" xml:space="preserve">
          <source>Because bit fields do not necessarily begin at the beginning of a byte, address of a bit field cannot be taken. Pointers and non-const references to bit fields are not possible. When &lt;a href=&quot;reference_initialization&quot;&gt;initializing a const reference&lt;/a&gt; from a bit field, a temporary is created (its type is the type of the bit field), copy initialized with the value of the bit field, and the reference is bound to that temporary.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="165915841c598e436e4f4ef5949ddbdf66094494" translate="yes" xml:space="preserve">
          <source>Because both &lt;code&gt;iterator&lt;/code&gt; and &lt;code&gt;const_iterator&lt;/code&gt; are constant iterators (and may in fact be the same type), it is not possible to mutate the elements of the container through an iterator returned by any of these member functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5ebf1a72c58aab22e302945eaa39d0cb80ef7c4" translate="yes" xml:space="preserve">
          <source>Because comments &lt;a href=&quot;language/translation_phases&quot;&gt;are removed&lt;/a&gt; before the preprocessor stage, a macro cannot be used to form a comment and an unterminated C-style comment doesn't spill over from an #include'd file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8283f8b80380fa4e852889799ea8ad590ba8476b" translate="yes" xml:space="preserve">
          <source>Because condition #2 is tested before condition #3, the input line that exactly fits the buffer does not trigger failbit.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="515369749f5f51688eb83df1f7be779be9524043" translate="yes" xml:space="preserve">
          <source>Because copying &lt;code&gt;std::domain_error&lt;/code&gt; is not permitted to throw exceptions, this message is typically stored internally as a separately-allocated reference-counted string. This is also why there is no constructor taking &lt;code&gt;std::string&amp;amp;&amp;amp;&lt;/code&gt;: it would have to copy the content anyway.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ecb376ab21a6f256feb79f178105c51676d0d60" translate="yes" xml:space="preserve">
          <source>Because copying &lt;code&gt;std::exception&lt;/code&gt; is not permitted to throw exceptions, when derived classes (such as &lt;code&gt;&lt;a href=&quot;../runtime_error/runtime_error&quot;&gt;std::runtime_error&lt;/a&gt;&lt;/code&gt;) have to manage a user-defined diagnostic message, it is typically implemented as a copy-on-write string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3da5bbc4235f4c93a80ce50bc387f0b13711c29a" translate="yes" xml:space="preserve">
          <source>Because copying &lt;code&gt;std::invalid_argument&lt;/code&gt; is not permitted to throw exceptions, this message is typically stored internally as a separately-allocated reference-counted string. This is also why there is no constructor taking &lt;code&gt;std::string&amp;amp;&amp;amp;&lt;/code&gt;: it would have to copy the content anyway.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="976f924388c6dee8de713ae69d4c65520bd93b74" translate="yes" xml:space="preserve">
          <source>Because copying &lt;code&gt;std::length_error&lt;/code&gt; is not permitted to throw exceptions, this message is typically stored internally as a separately-allocated reference-counted string. This is also why there is no constructor taking &lt;code&gt;std::string&amp;amp;&amp;amp;&lt;/code&gt;: it would have to copy the content anyway.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d329778fe1d9574d6ed3f3facfee5d31e87476c0" translate="yes" xml:space="preserve">
          <source>Because copying &lt;code&gt;std::logic_error&lt;/code&gt; is not permitted to throw exceptions, this message is typically stored internally as a separately-allocated reference-counted string. This is also why there is no constructor taking &lt;code&gt;std::string&amp;amp;&amp;amp;&lt;/code&gt;: it would have to copy the content anyway.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="018a393e39e3b182ca10487c347de04d186be7cb" translate="yes" xml:space="preserve">
          <source>Because copying &lt;code&gt;std::out_of_range&lt;/code&gt; is not permitted to throw exceptions, this message is typically stored internally as a separately-allocated reference-counted string. This is also why there is no constructor taking &lt;code&gt;std::string&amp;amp;&amp;amp;&lt;/code&gt;: it would have to copy the content anyway.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f345edfef34a7652c4a3e8c88a8d58867553acd" translate="yes" xml:space="preserve">
          <source>Because copying &lt;code&gt;std::overflow_error&lt;/code&gt; is not permitted to throw exceptions, this message is typically stored internally as a separately-allocated reference-counted string. This is also why there is no constructor taking &lt;code&gt;std::string&amp;amp;&amp;amp;&lt;/code&gt;: it would have to copy the content anyway.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57850b32155ea45ecb9e2f25f07c6b9ec1154de7" translate="yes" xml:space="preserve">
          <source>Because copying &lt;code&gt;std::range_error&lt;/code&gt; is not permitted to throw exceptions, this message is typically stored internally as a separately-allocated reference-counted string. This is also why there is no constructor taking &lt;code&gt;std::string&amp;amp;&amp;amp;&lt;/code&gt;: it would have to copy the content anyway.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="402cb452aa1c6e8357e1ec6173212b86a7d33f65" translate="yes" xml:space="preserve">
          <source>Because copying &lt;code&gt;std::runtime_error&lt;/code&gt; is not permitted to throw exceptions, this message is typically stored internally as a separately-allocated reference-counted string. This is also why there is no constructor taking &lt;code&gt;std::string&amp;amp;&amp;amp;&lt;/code&gt;: it would have to copy the content anyway.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37068db94b3bf966577e4aa45601ece784efa76c" translate="yes" xml:space="preserve">
          <source>Because copying &lt;code&gt;std::underflow_error&lt;/code&gt; is not permitted to throw exceptions, this message is typically stored internally as a separately-allocated reference-counted string. This is also why there is no constructor taking &lt;code&gt;std::string&amp;amp;&amp;amp;&lt;/code&gt;: it would have to copy the content anyway.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9379074a5072b78ee4eeef2326fa80c14b76e9c1" translate="yes" xml:space="preserve">
          <source>Because copying a standard library class derived from &lt;code&gt;std::exception&lt;/code&gt; is not permitted to throw exceptions, this message is typically stored internally as a separately-allocated reference-counted string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ae6e0e63afdccc5b632c5cb746027af8b35d225" translate="yes" xml:space="preserve">
          <source>Because correct C++ programs are free of undefined behavior, compilers may produce unexpected results when a program that actually has UB is compiled with optimization enabled:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4626ae145ee72ecf116829f511a5171a1ace5607" translate="yes" xml:space="preserve">
          <source>Because currency symbol is optional if &lt;code&gt;showbase&lt;/code&gt; is off but the entire multicharacter &lt;code&gt;negative_sign()&lt;/code&gt; is required, given the formatting pattern &lt;code&gt;{sign, value, space, symbol}&lt;/code&gt; with &lt;code&gt;showbase&lt;/code&gt; off and negative_sign of &lt;code&gt;&quot;-&quot;&lt;/code&gt;, the string &lt;code&gt;&quot;-1.23 &amp;euro;&quot;&lt;/code&gt; parses as &lt;code&gt;-123&lt;/code&gt; and leaves &quot;&amp;euro;&quot; unconsumed on the input stream, but if negative_sign is &lt;code&gt;&quot;()&quot;&lt;/code&gt;, the string &lt;code&gt;&quot;(1.23 &amp;euro;)&quot;&lt;/code&gt; is consumed completely.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c7bc26a7deccd5754905307ee4096fdff25e864" translate="yes" xml:space="preserve">
          <source>Because each &lt;code&gt;std::array&amp;lt;T, N&amp;gt;&lt;/code&gt; is a fixed-size container, the value returned by &lt;code&gt;max_size&lt;/code&gt; equals &lt;code&gt;N&lt;/code&gt; (which is also the value returned by &lt;code&gt;&lt;a href=&quot;size&quot;&gt;size&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1d63aeceb4f0e5680d16d7c267971930a3bce18" translate="yes" xml:space="preserve">
          <source>Because locales and facets must be available for the IO stream objects with static storage duration, such as &lt;code&gt;&lt;a href=&quot;../../../io/cout&quot;&gt;std::cout&lt;/a&gt;&lt;/code&gt;, typical implementations let implicit default constructor zero-initialize the contents of &lt;code&gt;&lt;a href=&quot;../id&quot;&gt;std::locale::id&lt;/a&gt;&lt;/code&gt; during static initialization (before constructors run for static objects), and when a facet is added to any locale for the first time, the locale completes initialization of the facet's &lt;code&gt;id&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bad967f19eac295089f2fac67901872b755b210a" translate="yes" xml:space="preserve">
          <source>Because most conversion specifiers first consume all consecutive whitespace, code such as.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="baeb5892e67350663f292930f0546a18e00a4338" translate="yes" xml:space="preserve">
          <source>Because of argument-dependent lookup, non-member functions and non-member operators defined in the same namespace as a class are considered part of the public interface of that class (if they are found through ADL) &lt;sup id=&quot;cite_ref-1&quot;&gt;&lt;a href=&quot;adl#cite_note-1&quot;&gt;[1]&lt;/a&gt;&lt;/sup&gt;.  ADL is the reason behind the established idiom for swapping two objects in generic code:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e744698bc894ffd70f35015c02148587a2699846" translate="yes" xml:space="preserve">
          <source>Because of the &lt;a href=&quot;implicit_cast&quot;&gt;array-to-pointer&lt;/a&gt; implicit conversion, pointer to the first element of an array can be initialized with an expression of array type:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="940a6ecf2484f5047dcbde372b969605698443fc" translate="yes" xml:space="preserve">
          <source>Because of the &lt;a href=&quot;implicit_cast&quot;&gt;derived-to-base&lt;/a&gt; implicit conversion for pointers, pointer to a base class can be initialized with the address of a derived class:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d22544963a037f06cda7296c1659e0c18ea6896" translate="yes" xml:space="preserve">
          <source>Because of the rule above, if initialization of some object &lt;code&gt;o1&lt;/code&gt; refers to an namespace-scope object &lt;code&gt;o2&lt;/code&gt;, which potentially requires dynamic initialization, but is defined later in the same translation unit, it is unspecified whether the value of &lt;code&gt;o2&lt;/code&gt; used will be the value of the fully initialized &lt;code&gt;o2&lt;/code&gt; (because the compiler promoted initialization of &lt;code&gt;o2&lt;/code&gt; to compile time) or will be the value of &lt;code&gt;o2&lt;/code&gt; merely zero-initialized.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9dfa5b6f4b206c84c88479521272aa1a77080bd" translate="yes" xml:space="preserve">
          <source>Because of the side-effects involved, built-in increment and decrement operators must be used with care to avoid undefined behavior due to violations of &lt;a href=&quot;eval_order&quot;&gt;sequencing rules&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e487fcdc25049314ba3c1aa8b2d5bde8e083329" translate="yes" xml:space="preserve">
          <source>Because of these rules, the following function declarations declare exactly the same function:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d688b7551f970383439094dc77352596d64c75aa" translate="yes" xml:space="preserve">
          <source>Because operator&amp;lt; is defined for pairs, containers of pairs can be sorted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d70357852eee5a3977fc8f45f9558148ea3110c" translate="yes" xml:space="preserve">
          <source>Because operator&amp;lt; is defined for tuples, containers of tuples can be sorted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9988c3b00612ee646fb4689ee722feac6456ce93" translate="yes" xml:space="preserve">
          <source>Because private data members of a class participate in its object representation, affecting size and layout, and because private member functions of a class participate in &lt;a href=&quot;overload_resolution&quot;&gt;overload resolution&lt;/a&gt; (which takes place before member access checking), any change to those implementation details requires recompilation of all users of the class.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3b6294e7526f54f684e9230a46827a20327483e" translate="yes" xml:space="preserve">
          <source>Because reallocation may involve bytewise copying (regardless of whether it's to expand or to contract), only the objects of &lt;a href=&quot;../../named_req/triviallycopyable&quot;&gt;TriviallyCopyable&lt;/a&gt; types are safe to access in the preserved part of the memory block after a call to &lt;code&gt;realloc&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7a4b66b6298eef0d24f634e1a2d845ff026b299" translate="yes" xml:space="preserve">
          <source>Because references are not objects, there are no arrays of references, no pointers to references, and no references to references:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2058d826c2c292a12210fe0965fc4ca9d8da0fd" translate="yes" xml:space="preserve">
          <source>Because rvalue references can bind to xvalues, they can refer to non-temporary objects:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04759d29e77b0401f5cb7e54b5a9ccc5b0666e57" translate="yes" xml:space="preserve">
          <source>Because some assignment operator (move or copy) is always declared for any class, the base class assignment operator is always hidden. If a using-declaration is used to bring in the assignment operator from the base class, and its argument type could be the same as the argument type of the implicit assignment operator of the derived class, the using-declaration is also hidden by the implicit declaration.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00f0a274c1ab8c40e7bb092c85aefd4a4d48b525" translate="yes" xml:space="preserve">
          <source>Because stage 2 filters out characters such as 'p', 'N' or 'i', the hexadecimal floating-point numbers such as &quot;0x1.23p-10&quot; and the strings &quot;NaN&quot; or &quot;inf&quot; may be rejected by &lt;code&gt;do_get(double)&lt;/code&gt; even if they are valid input to &lt;code&gt;strtod&lt;/code&gt;: this is &lt;a href=&quot;http://cplusplus.github.io/LWG/lwg-active.html#2381&quot;&gt;LWG #2381&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa02ffb6258aec2d2486ffca8631f59286ef5ce5" translate="yes" xml:space="preserve">
          <source>Because the &lt;a href=&quot;noexcept&quot;&gt;noexcept&lt;/a&gt; operator always returns &lt;code&gt;true&lt;/code&gt; for a constant expression, it can be used to check if a particular invocation of a constexpr function takes the constant expression branch:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13956b893efc09b160ae84ba33c1cbb13cb7bc62" translate="yes" xml:space="preserve">
          <source>Because the C++ program terminates if a destructor throws an exception during stack unwinding (which usually cannot be predicted), all practical destructors are non-throwing even if they are not declared noexcept. All destructors found in the C++ standard library are non-throwing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4b14ea26ead34a1997c4a30b1317b3b91b17acb" translate="yes" xml:space="preserve">
          <source>Because the algorithm takes &lt;code&gt;old_value&lt;/code&gt; and &lt;code&gt;new_value&lt;/code&gt; by reference, it can have unexpected behavior if either is a reference to an element of the range &lt;code&gt;[first, last)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="265f1e5e363f13b331939f8d44a25ab55d331f5b" translate="yes" xml:space="preserve">
          <source>Because the compiler is (usually) unable to analyze the code of an external library to determine whether it does or does not perform I/O or volatile access, third-party library calls also aren't affected by optimization. However, standard library calls may be replaced by other calls, eliminated, or added to the program during optimization. Statically-linked third-party library code may be subject to link-time optimization.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f7a16168cd91eaf4c419d45869f4dbf9eb22f7c" translate="yes" xml:space="preserve">
          <source>Because the copy assignment operator is always declared for any class, the base class assignment operator is always hidden. If a &lt;a href=&quot;using_declaration#In_class_definition&quot;&gt;using-declaration&lt;/a&gt; is used to bring in the assignment operator from the base class, and its argument type could be the same as the argument type of the implicit assignment operator of the derived class, the using-declaration is also hidden by the implicit declaration.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f97ab617bba2611157c1c18672811c19cf4fbf8" translate="yes" xml:space="preserve">
          <source>Because the default constructor is &lt;code&gt;constexpr&lt;/code&gt;, static &lt;code&gt;std::any&lt;/code&gt;s are initialized as part of &lt;a href=&quot;../../language/initialization#Non-local_variables&quot;&gt;static non-local initialization&lt;/a&gt;, before any dynamic non-local initialization begins. This makes it safe to use an object of type &lt;code&gt;std::any&lt;/code&gt; in a constructor of any static object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42b540f8fad9f3f5b7e3465475a9831636bf020b" translate="yes" xml:space="preserve">
          <source>Because the default constructor is &lt;code&gt;constexpr&lt;/code&gt;, static &lt;code&gt;weak_ptr&lt;/code&gt;s are initialized as part of &lt;a href=&quot;../../language/initialization#Non-local_variables&quot;&gt;static non-local initialization&lt;/a&gt;, before any dynamic non-local initialization begins. This makes it safe to use a weak_ptr in a constructor of any static object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe59378ecb23670abf397ca1ed600f6c13757f88" translate="yes" xml:space="preserve">
          <source>Because the default constructor is &lt;code&gt;constexpr&lt;/code&gt;, static mutexes are initialized as part of &lt;a href=&quot;../../language/initialization#Non-local_variables&quot;&gt;static non-local initialization&lt;/a&gt;, before any dynamic non-local initialization begins. This makes it safe to lock a mutex in a constructor of any static object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="920e4279426f6b2bafbfaf754987ba73067a3aed" translate="yes" xml:space="preserve">
          <source>Because the default constructor is &lt;code&gt;constexpr&lt;/code&gt;, static shared_ptrs are initialized as part of &lt;a href=&quot;../../language/initialization#Non-local_variables&quot;&gt;static non-local initialization&lt;/a&gt;, before any dynamic non-local initialization begins. This makes it safe to use a shared_ptr in a constructor of any static object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="534359d78874e4479c30413b7cac076114495993" translate="yes" xml:space="preserve">
          <source>Because the default constructor is &lt;code&gt;constexpr&lt;/code&gt;, static unique_ptrs are initialized as part of &lt;a href=&quot;../../language/initialization#Non-local_variables&quot;&gt;static non-local initialization&lt;/a&gt;, before any dynamic non-local initialization begins. This makes it safe to use a unique_ptr in a constructor of any static object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ebbf73d1f46f71b596f1282630351e427e8477a7" translate="yes" xml:space="preserve">
          <source>Because the meaning of the keyword inline for functions came to mean &quot;multiple definitions are permitted&quot; rather than &quot;inlining is preferred&quot;, that meaning was extended to variables.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="006cf008ab0b4c79aa08791fcfe4af60405cca97" translate="yes" xml:space="preserve">
          <source>Because the presence of a user-defined destructor, copy-constructor, or copy-assignment operator prevents implicit definition of the &lt;a href=&quot;move_constructor&quot;&gt;move constructor&lt;/a&gt; and the &lt;a href=&quot;move_operator&quot;&gt;move assignment operator&lt;/a&gt;, any class for which move semantics are desirable, has to declare all five special member functions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6dd2c080a889192fcdc9756c073e592957f9bd5" translate="yes" xml:space="preserve">
          <source>Because the short-circuiting properties of &lt;code&gt;operator&amp;amp;&amp;amp;&lt;/code&gt; and &lt;code&gt;operator||&lt;/code&gt; do not apply to overloads, and because types with boolean semantics are uncommon, only two standard library classes overload these operators:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da716a2068c8a4a0779a87e17e684144cccab8b0" translate="yes" xml:space="preserve">
          <source>Because the terminating character is counted as an extracted character, an empty input line does not trigger failbit.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d2b809785ffb9b84788684b26543ec41eac3af8" translate="yes" xml:space="preserve">
          <source>Because these operators group left-to-right, the expression &lt;code&gt;a&amp;lt;b&amp;lt;c&lt;/code&gt; is parsed &lt;code&gt;(a&amp;lt;b)&amp;lt;c&lt;/code&gt;, and not &lt;code&gt;a&amp;lt;(b&amp;lt;c)&lt;/code&gt; or &lt;code&gt;(a&amp;lt;b)&amp;amp;&amp;amp;(b&amp;lt;c)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70619bda160666d212cde7b85f1f8b5a55f4c5a2" translate="yes" xml:space="preserve">
          <source>Because this function provides the automatic fall back to direct call to the destructor, the member function &lt;code&gt;destroy()&lt;/code&gt; is an optional &lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator&lt;/a&gt; requirement since C++11.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7687252b20cc0d88dc4dda04b2b393cf7f223dc8" translate="yes" xml:space="preserve">
          <source>Because this function provides the automatic fall back to placement new, the member function &lt;code&gt;construct()&lt;/code&gt; is an optional &lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator&lt;/a&gt; requirement since C++11.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f86afd7df6f8079055e111a54ab1c7b1acee01f" translate="yes" xml:space="preserve">
          <source>Because this function takes an &lt;code&gt;int&lt;/code&gt;, it cannot manipulate buffers larger than &lt;code&gt;std::numeric_limits&amp;lt;int&amp;gt;::max()&lt;/code&gt; characters (&lt;a href=&quot;http://wg21.link/lwg255&quot;&gt;LWG 255&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96b9e8b9f2beaa29d6fe717de5892c225fc24e46" translate="yes" xml:space="preserve">
          <source>Because transfer of control is &lt;a href=&quot;goto&quot;&gt;not permitted to enter the scope&lt;/a&gt; of a variable, if a declaration statement is encountered inside the statement, it has to be scoped in its own compound statement:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8087588a9b0c2147f6476231103eced47874ee97" translate="yes" xml:space="preserve">
          <source>Because trigraphs are processed early, a comment such as &lt;code&gt;// Will the next line be executed?????/&lt;/code&gt; will effectively comment out the following line, and the string literal such as &lt;code&gt;&quot;Enter date ??/??/??&quot;&lt;/code&gt; is parsed as &lt;code&gt;&quot;Enter date \\??&quot;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48a81f0ee3ab4431a19bb6ed8bbbce0c2c607478" translate="yes" xml:space="preserve">
          <source>Because variadic parameters have the lowest rank for the purpose of &lt;a href=&quot;overload_resolution&quot;&gt;overload resolution&lt;/a&gt;, they are commonly used as the catch-all fallbacks in &lt;a href=&quot;sfinae&quot;&gt;SFINAE&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3342f0b566e3613e9188ea93ab88f717f12a0f2c" translate="yes" xml:space="preserve">
          <source>Because when const member function calls a function through a non-const member pointer, the non-const overload of the implementation function is called, the pointer has to be wrapped in &lt;code&gt;&lt;a href=&quot;http://en.cppreference.com/w/cpp/experimental/propagate_const&quot;&gt;std::experimental::propagate_const&lt;/a&gt;&lt;/code&gt; or equivalent.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8374ae1ab38ced7f1c45fb4cad278a13b4530170" translate="yes" xml:space="preserve">
          <source>Before &lt;code&gt;std::bit_cast&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/byte/memcpy&quot;&gt;std::memcpy&lt;/a&gt;&lt;/code&gt; can be used when it is needed to interpret the object representation as one of another type:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fea4659c4c01a5438272693831b7a6cf369a447e" translate="yes" xml:space="preserve">
          <source>Before C++11, floating-point exceptions were not specified, &lt;code&gt;&lt;a href=&quot;../../error/errno_macros&quot;&gt;EDOM&lt;/a&gt;&lt;/code&gt; was required for any domain error, &lt;code&gt;&lt;a href=&quot;../../error/errno_macros&quot;&gt;ERANGE&lt;/a&gt;&lt;/code&gt; was required for overflows and implementation-defined for underflows.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8315db453a2a5506755072ec6a7820d4232e1cea" translate="yes" xml:space="preserve">
          <source>Before a call to &lt;code&gt;str()&lt;/code&gt; that uses the result as a C string, the stream buffer must be null-terminated. Regular output such as with &lt;code&gt;stream &amp;lt;&amp;lt; 1.2&lt;/code&gt; does not store a null terminator, it must be appended explicitly, typically with the manipulator &lt;code&gt;&lt;a href=&quot;../manip/ends&quot;&gt;std::ends&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a94bcd5b8d87a105ad9ebe672411a4e5e7749b2c" translate="yes" xml:space="preserve">
          <source>Before any call to &lt;code&gt;str()&lt;/code&gt; that uses the result as a C string, the buffer must be null-terminated, typically with &lt;code&gt;&lt;a href=&quot;manip/ends&quot;&gt;std::ends&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c35792e95cf3b07cb316904dfad082217f59a440" translate="yes" xml:space="preserve">
          <source>Before any catch clauses of a function-try-block on a constructor are entered, all fully-constructed members and bases have already been destroyed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d25af084b2d0cf872bc310ddc2b32c2b646e23c4" translate="yes" xml:space="preserve">
          <source>Before any catch clauses of a function-try-block on a destructor are entered, all bases and non-variant members have already been destroyed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73e853eca15162afc8c02a1bedca567760609d5c" translate="yes" xml:space="preserve">
          <source>Before any further analysis, constraints are &lt;a href=&quot;constraints#Constraint_normalization&quot;&gt;normalized&lt;/a&gt; by substituting the body of every name concept and every requires expression until what is left is a sequence of conjunctions and disjunctions on atomic constraints.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6aa106196ee396275230e60cf51ed929654bbc97" translate="yes" xml:space="preserve">
          <source>Before any of the member functions would yield undefined results, calls callbacks, registered by &lt;a href=&quot;register_callback&quot;&gt;&lt;code&gt;register_callback()&lt;/code&gt;&lt;/a&gt; passing &lt;a href=&quot;event&quot;&gt;&lt;code&gt;erase_event&lt;/code&gt;&lt;/a&gt; as parameter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32981297d13de998df78a59af43e17581b0c92e7" translate="yes" xml:space="preserve">
          <source>Before class template argument deduction was introduced, a common approach to avoiding explicitly specifying arguments is to use a function template:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="448996df8021b850305d2f1a744547e3fb5a961d" translate="yes" xml:space="preserve">
          <source>Before deduction begins, the following adjustments to &lt;code&gt;P&lt;/code&gt; and &lt;code&gt;A&lt;/code&gt; are made:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec06b6296ed6cd7c8b9af0261c5f6873359d381f" translate="yes" xml:space="preserve">
          <source>Before doing anything else, &lt;code&gt;seekg&lt;/code&gt; clears &lt;code&gt;eofbit&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7de5fab850d46a3b252876719b32d89d2a9ae789" translate="yes" xml:space="preserve">
          <source>Before insertion, first, all characters are widened using &lt;code&gt;os.widen()&lt;/code&gt;, then padding is determined as follows: if the number of characters to insert is less than &lt;code&gt;os.width()&lt;/code&gt;, then enough copies of &lt;code&gt;os.fill()&lt;/code&gt; are added to the character sequence to make its length equal &lt;code&gt;os.width()&lt;/code&gt;. If &lt;code&gt;(out.flags()&amp;amp;&lt;a href=&quot;../ios_base/fmtflags&quot;&gt;std::ios_base::adjustfield&lt;/a&gt;) == &lt;a href=&quot;../ios_base/fmtflags&quot;&gt;std::ios_base::left&lt;/a&gt;&lt;/code&gt;, the fill characters are added at the end of the output sequence, otherwise they are added before the output sequence. After insertion, &lt;code&gt;width(0)&lt;/code&gt; is called to cancel the effects of &lt;code&gt;&lt;a href=&quot;../manip/setw&quot;&gt;std::setw&lt;/a&gt;&lt;/code&gt;, if any.  The behavior is undefined if &lt;code&gt;s&lt;/code&gt; is a null pointer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66a732adfdd2f159eb6ed563c85a4950c2ff838b" translate="yes" xml:space="preserve">
          <source>Before modified element(s)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d97a4012796ad8947371e2ae9f789d3c201395de" translate="yes" xml:space="preserve">
          <source>Before name lookup can be performed for the name on the right hand side of &lt;code&gt;::&lt;/code&gt;, lookup must be completed for the name on its left hand side (unless a &lt;a href=&quot;decltype&quot;&gt;decltype&lt;/a&gt; expression is used, or there is nothing on the left). This lookup, which may be qualified or unqualified, depending on whether there's another &lt;code&gt;::&lt;/code&gt; to the left of that name, considers only namespaces, class types, enumerations, and templates whose specializations are types:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82707517c83290ff1d38dc49904b3bfd7e902adb" translate="yes" xml:space="preserve">
          <source>Before overload resolution begins, the functions selected by name lookup and template argument deduction are combined to form the set of</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff5ff5557a213e5cbabe46f3d7e81258ac04a845" translate="yes" xml:space="preserve">
          <source>Before the compound statement that forms the function body of the constructor begins executing, initialization of all direct bases, virtual bases, and non-static data members is finished. Member initializer list is the place where non-default initialization of these objects can be specified. For members that cannot be default-initialized, such as members of reference and const-qualified types, member initializers must be specified. No initialization is performed for &lt;a href=&quot;union#Anonymous_unions&quot;&gt;anonymous unions&lt;/a&gt; or &lt;a href=&quot;union#Union-like_class&quot;&gt;variant members&lt;/a&gt; that do not have a member initializer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0c425b7763137b46eb294c01dcbca3225e7768a" translate="yes" xml:space="preserve">
          <source>Before the lifetime of an object has started but after the storage which the object will occupy has been allocated or, after the lifetime of an object has ended and before the storage which the object occupied is reused or released, the following uses of the glvalue expression that identifies that object are undefined:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01ee3728daf49b9887894e9051143ca70683a003" translate="yes" xml:space="preserve">
          <source>Behaves as &lt;a href=&quot;../../named_req/unformattedinputfunction&quot;&gt;UnformattedInputFunction&lt;/a&gt;, except that &lt;code&gt;&lt;a href=&quot;gcount&quot;&gt;gcount()&lt;/a&gt;&lt;/code&gt; is not affected. After constructing and checking the sentry object,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="afa456ec56112ff3b6b761bd5b74f63ce75d28ec" translate="yes" xml:space="preserve">
          <source>Behaves as &lt;a href=&quot;../../named_req/unformattedinputfunction&quot;&gt;UnformattedInputFunction&lt;/a&gt;, except that &lt;code&gt;&lt;a href=&quot;gcount&quot;&gt;gcount()&lt;/a&gt;&lt;/code&gt; is not affected. After constructing and checking the sentry object, if &lt;code&gt;fail() == true&lt;/code&gt;, returns &lt;code&gt;pos_type(-1)&lt;/code&gt;. Otherwise, returns &lt;code&gt;rdbuf()-&amp;gt;pubseekoff(0, &lt;a href=&quot;../ios_base/seekdir&quot;&gt;std::ios_base::cur&lt;/a&gt;, &lt;a href=&quot;../ios_base/openmode&quot;&gt;std::ios_base::in&lt;/a&gt;)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a77bac3067d3940c6b684599ba369eb392602c9" translate="yes" xml:space="preserve">
          <source>Behaves as &lt;a href=&quot;../../named_req/unformattedinputfunction&quot;&gt;UnformattedInputFunction&lt;/a&gt;. After constructing and checking the sentry object,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9678066f0a18b755a7a83de41a67b8f539cf21e5" translate="yes" xml:space="preserve">
          <source>Behaves as &lt;a href=&quot;../../named_req/unformattedinputfunction&quot;&gt;UnformattedInputFunction&lt;/a&gt;. After constructing and checking the sentry object, extracts characters and stores them into successive locations of the character array whose first element is pointed to by &lt;code&gt;s&lt;/code&gt;. Characters are extracted and stored until any of the following conditions occurs:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5452e2d70444e38dce8d1658572b189b3491c062" translate="yes" xml:space="preserve">
          <source>Behaves as &lt;a href=&quot;../../named_req/unformattedinputfunction&quot;&gt;UnformattedInputFunction&lt;/a&gt;. After constructing and checking the sentry object, extracts characters from &lt;code&gt;*this&lt;/code&gt; and stores them in successive locations of the array whose first element is pointed to by &lt;code&gt;s&lt;/code&gt;, until any of the following occurs (tested in the order shown):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ce9bf750568029bd6c252857e382b90c6756ee0" translate="yes" xml:space="preserve">
          <source>Behaves as &lt;a href=&quot;../../named_req/unformattedinputfunction&quot;&gt;UnformattedInputFunction&lt;/a&gt;. After constructing and testing the sentry object, reads the next character from the input stream without extracting it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0749de46c88cb22f7c4409a2cfcef6bf1f8046f6" translate="yes" xml:space="preserve">
          <source>Behaves as &lt;a href=&quot;../../named_req/unformattedoutputfunction&quot;&gt;UnformattedOutputFunction&lt;/a&gt; (except without actually performing output). After constructing and checking the sentry object,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4672c00972c0e6a7e7c5cce22e6b19b90240fb04" translate="yes" xml:space="preserve">
          <source>Behaves as a &lt;a href=&quot;../../named_req/formattedoutputfunction&quot;&gt;FormattedOutputFunction&lt;/a&gt;. After constructing and checking the sentry object, determines the output format padding as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd13a34bc371a84520ebfd6305bba27395aa1de8" translate="yes" xml:space="preserve">
          <source>Behaves as an &lt;a href=&quot;../../named_req/unformattedinputfunction&quot;&gt;UnformattedInputFunction&lt;/a&gt;, except that &lt;code&gt;is.gcount()&lt;/code&gt; is not modified. After constructing and checking the sentry object, extracts characters from the stream and discards them until any one of the following conditions occurs:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb87348382a678ef761dc7c93eddfa49c60fd167" translate="yes" xml:space="preserve">
          <source>Behaves as an &lt;a href=&quot;../../named_req/unformattedinputfunction&quot;&gt;UnformattedInputFunction&lt;/a&gt;, except that it has an unspecified effect on &lt;code&gt;is.gcount()&lt;/code&gt;. After constructing and checking the sentry object, attempts to parse the input stream &lt;code&gt;is&lt;/code&gt; into &lt;code&gt;d&lt;/code&gt; according to the format string &lt;code&gt;fmt&lt;/code&gt;. If the parse fails to decode a valid &lt;code&gt;day&lt;/code&gt;, &lt;code&gt;is.setstate(&lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;std::ios_base::failbit&lt;/a&gt;)&lt;/code&gt; is called and &lt;code&gt;d&lt;/code&gt; is not modified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1fa65d008ed7c245aef54a0ea0b67364379c951b" translate="yes" xml:space="preserve">
          <source>Behaves as an &lt;a href=&quot;../../named_req/unformattedinputfunction&quot;&gt;UnformattedInputFunction&lt;/a&gt;, except that it has an unspecified effect on &lt;code&gt;is.gcount()&lt;/code&gt;. After constructing and checking the sentry object, attempts to parse the input stream &lt;code&gt;is&lt;/code&gt; into &lt;code&gt;d&lt;/code&gt; according to the format string &lt;code&gt;fmt&lt;/code&gt;. If the parse fails to decode a valid &lt;code&gt;duration&lt;/code&gt;, &lt;code&gt;is.setstate(&lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;std::ios_base::failbit&lt;/a&gt;)&lt;/code&gt; is called and &lt;code&gt;d&lt;/code&gt; is not modified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2831b6a6c206e8d8a233d91bfdec888a2de732b" translate="yes" xml:space="preserve">
          <source>Behaves as an &lt;a href=&quot;../../named_req/unformattedinputfunction&quot;&gt;UnformattedInputFunction&lt;/a&gt;, except that it has an unspecified effect on &lt;code&gt;is.gcount()&lt;/code&gt;. After constructing and checking the sentry object, attempts to parse the input stream &lt;code&gt;is&lt;/code&gt; into &lt;code&gt;m&lt;/code&gt; according to the format string &lt;code&gt;fmt&lt;/code&gt;. If the parse fails to decode a valid &lt;code&gt;month&lt;/code&gt;, &lt;code&gt;is.setstate(&lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;std::ios_base::failbit&lt;/a&gt;)&lt;/code&gt; is called and &lt;code&gt;m&lt;/code&gt; is not modified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="faffa23b913d2432b4e5d59afb1027604b07f00e" translate="yes" xml:space="preserve">
          <source>Behaves as an &lt;a href=&quot;../../named_req/unformattedinputfunction&quot;&gt;UnformattedInputFunction&lt;/a&gt;, except that it has an unspecified effect on &lt;code&gt;is.gcount()&lt;/code&gt;. After constructing and checking the sentry object, attempts to parse the input stream &lt;code&gt;is&lt;/code&gt; into &lt;code&gt;md&lt;/code&gt; according to the format string &lt;code&gt;fmt&lt;/code&gt;. If the parse fails to decode a valid &lt;code&gt;month_day&lt;/code&gt;, &lt;code&gt;is.setstate(&lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;std::ios_base::failbit&lt;/a&gt;)&lt;/code&gt; is called and &lt;code&gt;md&lt;/code&gt; is not modified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e065fe398d7803bd86c6a7e26d51804b3b96c6b0" translate="yes" xml:space="preserve">
          <source>Behaves as an &lt;a href=&quot;../../named_req/unformattedinputfunction&quot;&gt;UnformattedInputFunction&lt;/a&gt;, except that it has an unspecified effect on &lt;code&gt;is.gcount()&lt;/code&gt;. After constructing and checking the sentry object, attempts to parse the input stream &lt;code&gt;is&lt;/code&gt; into &lt;code&gt;tp&lt;/code&gt; according to the format string &lt;code&gt;fmt&lt;/code&gt;. If the parse fails to decode a valid time point, &lt;code&gt;is.setstate(&lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;std::ios_base::failbit&lt;/a&gt;)&lt;/code&gt; is called and &lt;code&gt;tp&lt;/code&gt; is not modified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e916f1ce3a09969712030a89b921f22ad91cde6" translate="yes" xml:space="preserve">
          <source>Behaves as an &lt;a href=&quot;../../named_req/unformattedinputfunction&quot;&gt;UnformattedInputFunction&lt;/a&gt;, except that it has an unspecified effect on &lt;code&gt;is.gcount()&lt;/code&gt;. After constructing and checking the sentry object, attempts to parse the input stream &lt;code&gt;is&lt;/code&gt; into &lt;code&gt;wd&lt;/code&gt; according to the format string &lt;code&gt;fmt&lt;/code&gt;. If the parse fails to decode a valid &lt;code&gt;weekday&lt;/code&gt;, &lt;code&gt;is.setstate(&lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;std::ios_base::failbit&lt;/a&gt;)&lt;/code&gt; is called and &lt;code&gt;wd&lt;/code&gt; is not modified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="534f077e6bac2d7fcd7ec6bfbd2ce8a229d9e671" translate="yes" xml:space="preserve">
          <source>Behaves as an &lt;a href=&quot;../../named_req/unformattedinputfunction&quot;&gt;UnformattedInputFunction&lt;/a&gt;, except that it has an unspecified effect on &lt;code&gt;is.gcount()&lt;/code&gt;. After constructing and checking the sentry object, attempts to parse the input stream &lt;code&gt;is&lt;/code&gt; into &lt;code&gt;y&lt;/code&gt; according to the format string &lt;code&gt;fmt&lt;/code&gt;. If the parse fails to decode a valid &lt;code&gt;year&lt;/code&gt;, &lt;code&gt;is.setstate(&lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;std::ios_base::failbit&lt;/a&gt;)&lt;/code&gt; is called and &lt;code&gt;y&lt;/code&gt; is not modified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d1a3df7d8a7fca81ecb344ddc22950a523c840e" translate="yes" xml:space="preserve">
          <source>Behaves as an &lt;a href=&quot;../../named_req/unformattedinputfunction&quot;&gt;UnformattedInputFunction&lt;/a&gt;, except that it has an unspecified effect on &lt;code&gt;is.gcount()&lt;/code&gt;. After constructing and checking the sentry object, attempts to parse the input stream &lt;code&gt;is&lt;/code&gt; into &lt;code&gt;ym&lt;/code&gt; according to the format string &lt;code&gt;fmt&lt;/code&gt;. If the parse fails to decode a valid &lt;code&gt;year_month&lt;/code&gt;, &lt;code&gt;is.setstate(&lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;std::ios_base::failbit&lt;/a&gt;)&lt;/code&gt; is called and &lt;code&gt;ym&lt;/code&gt; is not modified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="354ffd6415a45c8148f6d721a7550f4e07921a44" translate="yes" xml:space="preserve">
          <source>Behaves as an &lt;a href=&quot;../../named_req/unformattedinputfunction&quot;&gt;UnformattedInputFunction&lt;/a&gt;, except that it has an unspecified effect on &lt;code&gt;is.gcount()&lt;/code&gt;. After constructing and checking the sentry object, attempts to parse the input stream &lt;code&gt;is&lt;/code&gt; into &lt;code&gt;ymd&lt;/code&gt; according to the format string &lt;code&gt;fmt&lt;/code&gt;. If the parse fails to decode a valid &lt;code&gt;year_month_day&lt;/code&gt;, &lt;code&gt;is.setstate(&lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;std::ios_base::failbit&lt;/a&gt;)&lt;/code&gt; is called and &lt;code&gt;ymd&lt;/code&gt; is not modified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b31240671d71f38c08c6175c2a624c5485aa3e4b" translate="yes" xml:space="preserve">
          <source>Behaves as an &lt;a href=&quot;../../named_req/unformattedoutputfunction&quot;&gt;UnformattedOutputFunction&lt;/a&gt;. After constructing and checking the sentry object, outputs the characters from successive locations in the character array whose first element is pointed to by &lt;code&gt;s&lt;/code&gt;. Characters are inserted into the output sequence until one of the following occurs:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="420d1377b9bbd844155a88eb257414b14d2edd8c" translate="yes" xml:space="preserve">
          <source>Behaves as an &lt;a href=&quot;../../named_req/unformattedoutputfunction&quot;&gt;UnformattedOutputFunction&lt;/a&gt;. After constructing and checking the sentry object, writes the character &lt;code&gt;ch&lt;/code&gt; to the output stream.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82ff397227b9a7ad0f8b7b725088913fce6ee471" translate="yes" xml:space="preserve">
          <source>Behaves as an atomic operation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9dc5d13ce0d39d79ca5f8d6c575a41f58014821" translate="yes" xml:space="preserve">
          <source>Behaves as if applying &lt;code&gt;&lt;a href=&quot;iter_swap&quot;&gt;std::iter_swap&lt;/a&gt;&lt;/code&gt; to every pair of iterators &lt;code&gt;first+i, (last-i) - 1&lt;/code&gt; for each non-negative &lt;code&gt;i &amp;lt; (last-first)/2&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bed410844ec9fd5b13e393d20c755ef0b8dfbf2d" translate="yes" xml:space="preserve">
          <source>Behaves as if by executing the assignment &lt;code&gt;*(d_first + (last - first) - 1 - i) = *(first + i)&lt;/code&gt; once for each non-negative &lt;code&gt;i &amp;lt; (last - first)&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2095bbba3a93f2559c0792b761c684cd2ef1312" translate="yes" xml:space="preserve">
          <source>Behaves as if it forms a &lt;code&gt;&lt;a href=&quot;../../string/basic_string&quot;&gt;std::basic_string&lt;/a&gt;&amp;lt;CharT, Traits&amp;gt;&lt;/code&gt;&lt;code&gt;str&lt;/code&gt; initially consisting of the characters in &lt;code&gt;&lt;a href=&quot;../../string/basic_string/to_string&quot;&gt;std::to_string&lt;/a&gt;(d.count())&lt;/code&gt; (if &lt;code&gt;CharT&lt;/code&gt; is &lt;code&gt;char&lt;/code&gt;) or &lt;code&gt;&lt;a href=&quot;../../string/basic_string/to_wstring&quot;&gt;std::to_wstring&lt;/a&gt;(d.count())&lt;/code&gt; (if &lt;code&gt;CharT&lt;/code&gt; is &lt;code&gt;wchar_t&lt;/code&gt;). Appends to &lt;code&gt;str&lt;/code&gt; a suffix based on &lt;code&gt;Period::type&lt;/code&gt; according to the following table, and inserts &lt;code&gt;str&lt;/code&gt; into the stream with &lt;code&gt;os &amp;lt;&amp;lt; str;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ba1f2a3eb212b1fa99c5e19994960cbf5cc4c56" translate="yes" xml:space="preserve">
          <source>Behaves like the &lt;code&gt;&lt;a href=&quot;../basic_streambuf/underflow&quot;&gt;underflow()&lt;/a&gt;&lt;/code&gt;, except that if &lt;code&gt;&lt;a href=&quot;../basic_streambuf/underflow&quot;&gt;underflow()&lt;/a&gt;&lt;/code&gt; succeeds (does not return &lt;code&gt;Traits::eof()&lt;/code&gt;), then advances the next pointer for the get area. In other words, consumes one of the characters obtained by &lt;code&gt;&lt;a href=&quot;../basic_streambuf/underflow&quot;&gt;underflow()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7424443eb2a5187f8df088d1e24d7b153e76c40" translate="yes" xml:space="preserve">
          <source>Behaves like the base class &lt;code&gt;&lt;a href=&quot;../basic_streambuf/overflow&quot;&gt;std::basic_streambuf::overflow&lt;/a&gt;&lt;/code&gt;, except that to write the data, first uses &lt;code&gt;&lt;a href=&quot;../../locale/codecvt/out&quot;&gt;std::codecvt::out&lt;/a&gt;&lt;/code&gt; of the imbued locale to convert the characters into external (possibly multibyte) representation, stored in a temporary buffer (allocated as large as necessary), then uses file I/O to copy all fully-converted bytes into the file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ead68b316b3a5bb13de60a50d4b049c735bc0457" translate="yes" xml:space="preserve">
          <source>Behaves like the base class &lt;code&gt;std::basic_streambuf::underflow&lt;/code&gt;, except that to read the data from the associated character sequence (the file) into the get area, first reads the bytes from the file into a temporary buffer (allocated as large as necessary), then uses &lt;code&gt;std::codecvt::in&lt;/code&gt; of the imbued locale to convert the external (typically, multibyte) representation to the internal form which is then used to populate the get area. The conversion may be skipped if the locale's &lt;code&gt;std::codecvt::always_noconv&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8144558f99cdff249c2ee868ada81e832e47eeb4" translate="yes" xml:space="preserve">
          <source>Behavior as published</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b4de82624ef063c5570a0aa0bb2fd68f2dc6163" translate="yes" xml:space="preserve">
          <source>Bernoulli distributions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e5ebe6f1289f29133bcd6572d2c2241857b3a1a" translate="yes" xml:space="preserve">
          <source>Besides &lt;a href=&quot;operator_other&quot;&gt;function-call expressions&lt;/a&gt;, where &lt;a href=&quot;overload_resolution&quot;&gt;overload resolution&lt;/a&gt; takes place, the name of an overloaded function may appear in the following 7 contexts:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="35a9468290c3394c97c047fe437a550a62007c54" translate="yes" xml:space="preserve">
          <source>Besides commenting out, other mechanisms used for source code exclusion are.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03958a7c9ad1213ec526869eb4c84b20e58f0961" translate="yes" xml:space="preserve">
          <source>Besides establishing new parse state and position, a call to this function undoes the effects of &lt;code&gt;&lt;a href=&quot;ungetc&quot;&gt;std::ungetc&lt;/a&gt;&lt;/code&gt; and clears the end-of-file state, if it is set.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cde31df5b3a6edf2b668225ad16ccbe6298bf72e" translate="yes" xml:space="preserve">
          <source>Besides function calls and operator expressions, template argument deduction is used in the following situations:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ea3de9ed1aa39d9d12037783bc2af648287a89b" translate="yes" xml:space="preserve">
          <source>Besides function lvalues, the function call expression supports pointers to functions, dereferenced pointers to member functions, &lt;a href=&quot;lambda&quot;&gt;lambda-expressions&lt;/a&gt;, and any variable of class type that overloads the function-call operator. Together, these types are known as &lt;a href=&quot;../named_req/functionobject&quot;&gt;FunctionObjects&lt;/a&gt;, and they are used ubiquitously through the C++ standard library, see for example, usages of &lt;a href=&quot;../named_req/binarypredicate&quot;&gt;BinaryPredicate&lt;/a&gt; and &lt;a href=&quot;../named_req/compare&quot;&gt;Compare&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eadda9e8c93ae861b29d0afee13d836c6af0e0f7" translate="yes" xml:space="preserve">
          <source>Besides introducing the new exception template &lt;a href=&quot;../error/tx_exception&quot;&gt;&lt;code&gt;std::tx_exception&lt;/code&gt;&lt;/a&gt;, the transactional memory technical specification makes the following changes to the standard library:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f85f4cbfeeefb97ce1a4ae209c4036553a0f1353" translate="yes" xml:space="preserve">
          <source>Besides suitably declared identifiers, the following can be used in expressions in the same role:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc609bbb82549ba7934f717ed858b800830e4534" translate="yes" xml:space="preserve">
          <source>Besides the minimal bit counts, the C++ Standard guarantees that  &lt;code&gt;1 == sizeof(char) &amp;lt;= sizeof(short) &amp;lt;= sizeof(int) &amp;lt;= sizeof(long) &amp;lt;= sizeof(long long)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c97ed01493243e69d10ffc8e50648f78cab73dcd" translate="yes" xml:space="preserve">
          <source>Besides the standard attributes listed below, implementations may support arbitrary non-standard attributes with implementation-defined behavior. All attributes unknown to an implementation are ignored without causing an error.(since C++17).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="326ce75ab410687b03d60753ab3b5a7bc3c6aa60" translate="yes" xml:space="preserve">
          <source>Besides the system-specific information necessary to access the device (e.g. a POSIX file descriptor), each C stream object holds the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="987751c78ae2b93d437defad81b5467e3258fa00" translate="yes" xml:space="preserve">
          <source>Best viable function</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5445f48f941a5ad1d1542f8d66aef55a24056167" translate="yes" xml:space="preserve">
          <source>Between threads, evaluation A</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08921ac97281717dcf3cc5edee55ed9ec1246d18" translate="yes" xml:space="preserve">
          <source>Between threads, evaluation A is</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2451baa075c4c2006f43575b68fffc6be3054416" translate="yes" xml:space="preserve">
          <source>BidirIt first</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0770f96a62e4dba7b78dc8ded5a3d2559e0c17b" translate="yes" xml:space="preserve">
          <source>BidirIt second</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ffdf5ba9df9ed49abf7794c76ef97818235d86f9" translate="yes" xml:space="preserve">
          <source>BidirectionalIterator</source>
          <target state="translated">BidirectionalIterator</target>
        </trans-unit>
        <trans-unit id="482ad58667e3f2f9817b420cb310aa97436e0bbd" translate="yes" xml:space="preserve">
          <source>BidirectionalRange</source>
          <target state="translated">BidirectionalRange</target>
        </trans-unit>
        <trans-unit id="c460d3f926dfc813742e2a51770def855d27f159" translate="yes" xml:space="preserve">
          <source>Binary and text modes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91150bd6516ac5f77628d936130ba9cf5ec13ae6" translate="yes" xml:space="preserve">
          <source>Binary arithmetic operators</source>
          <target state="translated">二进制算术运算符</target>
        </trans-unit>
        <trans-unit id="b85455cd395dfbce0c44e85498fb4706eb3346ce" translate="yes" xml:space="preserve">
          <source>Binary literals in the C++ core language</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc724df4c71a335d592593fb78d0f54cdc71de39" translate="yes" xml:space="preserve">
          <source>Binary operators are typically implemented as non-members to maintain symmetry (for example, when adding a complex number and an integer, if &lt;code&gt;operator+&lt;/code&gt; is a member function of the complex type, then only &lt;code&gt;complex+integer&lt;/code&gt; would compile, and not &lt;code&gt;integer+complex&lt;/code&gt;). Since for every binary arithmetic operator there exists a corresponding compound assignment operator, canonical forms of binary operators are implemented in terms of their compound assignments:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b181c7beda214f4532f13b77ba42314ece1f768" translate="yes" xml:space="preserve">
          <source>Binary search operations (on sorted ranges)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b0e681b6c800f7b05bda65505fa83f5f1a1be72" translate="yes" xml:space="preserve">
          <source>BinaryPredicate</source>
          <target state="translated">BinaryPredicate</target>
        </trans-unit>
        <trans-unit id="d7b9396086e5ec8058fd32dd688322acc6d2bf68" translate="yes" xml:space="preserve">
          <source>BinaryTypeTrait</source>
          <target state="translated">BinaryTypeTrait</target>
        </trans-unit>
        <trans-unit id="3dbc95d187c9e90ca622a826dd7edb08cc9cacfa" translate="yes" xml:space="preserve">
          <source>Binders</source>
          <target state="translated">Binders</target>
        </trans-unit>
        <trans-unit id="f4e69ca5e425a4bf55911c4e6db32c6119febe30" translate="yes" xml:space="preserve">
          <source>Binding a reference to a virtual base class subobject.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9f04cf314fb7952075910e2f9ba75070c56f9c6" translate="yes" xml:space="preserve">
          <source>Binding of</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0cece0851be5efd26379576b4bcef2caf1dd812" translate="yes" xml:space="preserve">
          <source>Binding of a reference parameter directly to the argument expression is either Identity or a derived-to-base Conversion:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d829dc6fbeb72ba40b4a6193d7c09ca8de6d9c66" translate="yes" xml:space="preserve">
          <source>Binding rules</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f722c7dc45abe867103665120ef13603cd9867f6" translate="yes" xml:space="preserve">
          <source>Binds a given argument &lt;code&gt;x&lt;/code&gt; to a first or second parameter of the given binary function object &lt;code&gt;f&lt;/code&gt;. That is, stores &lt;code&gt;x&lt;/code&gt; within the resulting wrapper, which, if called, passes &lt;code&gt;x&lt;/code&gt; as the first or the second parameter of &lt;code&gt;f&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2587e5513df92e2184a69043d5b2d8c64896348f" translate="yes" xml:space="preserve">
          <source>Binds a reference to an object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ff0b1c06c14891fb48b824df8e7692aa76016b3" translate="yes" xml:space="preserve">
          <source>Binds the specified names to subobjects or elements of the initializer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48c22d075b084cd5b8d711e4184eb43a90b6c4ef" translate="yes" xml:space="preserve">
          <source>Binomial coefficients can be expressed in terms of the beta function: \(\binom{n}{k} = \frac{1}{(n+1)B(n-k+1,k+1)}\).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8835c712451999e0a892ac12f5715c4350423b1" translate="yes" xml:space="preserve">
          <source>Bit</source>
          <target state="translated">Bit</target>
        </trans-unit>
        <trans-unit id="b5630cfa9108a371c432ca1b8e629cf6bc1b012a" translate="yes" xml:space="preserve">
          <source>Bit field</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b045376f837c7f5b36378c8f4a5c40a869f8ef92" translate="yes" xml:space="preserve">
          <source>Bit fields</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="443a8710a8bef103647191f97f7cd879bcad9c73" translate="yes" xml:space="preserve">
          <source>Bit manipulation</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="491df97cfa5e39f515f28ec7e2a2d72a45a33da8" translate="yes" xml:space="preserve">
          <source>Bit manipulation (since C++20)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6078ce7cb8ef5cea6018354d8a889b9edde5cbc" translate="yes" xml:space="preserve">
          <source>BitmaskType</source>
          <target state="translated">BitmaskType</target>
        </trans-unit>
        <trans-unit id="5ec768dbd17e419b41b32bba46a2d38687d9a71f" translate="yes" xml:space="preserve">
          <source>Bitset</source>
          <target state="translated">Bitset</target>
        </trans-unit>
        <trans-unit id="741c773876c69e2cd07b549c1ea8ece454c609e3" translate="yes" xml:space="preserve">
          <source>Bitwise &lt;a href=&quot;operator_arithmetic#Bitwise_shift_operators&quot;&gt;left shift and right shift&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17e80e5f71e9b85954b350f117d4dfeb3c5cf70a" translate="yes" xml:space="preserve">
          <source>Bitwise AND</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="306fd7520aac5bd6625750560fd55f52696ffa54" translate="yes" xml:space="preserve">
          <source>Bitwise OR of the floating-point exception macros that are both included in &lt;code&gt;excepts&lt;/code&gt; and correspond to floating-point exceptions currently set.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="35355cba328d12df3bd3dca4cc2c3703b1246bb3" translate="yes" xml:space="preserve">
          <source>Bitwise arithmetic operators</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9137bddcb31c15dd59efa0751eb46d78510d3c77" translate="yes" xml:space="preserve">
          <source>Bitwise logic operators</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67445a8812f7cd259e3b6e21272d2fddff30a9e2" translate="yes" xml:space="preserve">
          <source>Bitwise operations</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d49fb1543c1cf037be882f516f8283e8411c03af" translate="yes" xml:space="preserve">
          <source>Bitwise shift operators</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5bf1d047debbacfb72d2c4727d98ae3d266e79f4" translate="yes" xml:space="preserve">
          <source>Block declaration (a declaration that can appear inside a &lt;a href=&quot;statements#Compound_statement&quot;&gt;block&lt;/a&gt;), which, in turn, can be one of the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e681513340338ab189ae37b3a82732813788fc1e" translate="yes" xml:space="preserve">
          <source>Block scope</source>
          <target state="translated">块范围</target>
        </trans-unit>
        <trans-unit id="ab7474d238eb40c9da20e933f1c1d4048b69acd4" translate="yes" xml:space="preserve">
          <source>Blocks for the provided duration or until a lock on &lt;code&gt;m&lt;/code&gt; is acquired.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92391cb25322ebaeda3d45357ca30e226b318b27" translate="yes" xml:space="preserve">
          <source>Blocks the calling thread until exclusive ownership of the mutex can be obtained.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f7f11c61615ab6fa684880437bc9968e692fba9" translate="yes" xml:space="preserve">
          <source>Blocks the calling thread until shared ownership of the mutex can be obtained.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2fd2dcd848502428b39dc60b6225e09d3f0e7e57" translate="yes" xml:space="preserve">
          <source>Blocks the current thread until the thread identified by &lt;code&gt;*this&lt;/code&gt; finishes its execution.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e00d4fd15cea4053d3d66470eca6ff8a4eb81f0" translate="yes" xml:space="preserve">
          <source>Blocks the execution of the current thread for</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74a224c0de9a1fe8a0d5475e7041194e73e5a53a" translate="yes" xml:space="preserve">
          <source>Blocks the execution of the current thread until specified &lt;code&gt;sleep_time&lt;/code&gt; has been reached.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9af45472a96a859ddc1794b6abf6298174b74613" translate="yes" xml:space="preserve">
          <source>Blocks until a lock can be obtained for the current execution agent (thread, process, task). If an exception is thrown, no lock is obtained.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eba863ee2c609bd20888a9ee01d8f0bc03fe3b0b" translate="yes" xml:space="preserve">
          <source>Blocks until the provided time limit point is reached or a lock on &lt;code&gt;m&lt;/code&gt; is acquired.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb596caefce629504fd3a475f3183426b8a356e3" translate="yes" xml:space="preserve">
          <source>Blocks until the result becomes available. &lt;code&gt;valid() == true&lt;/code&gt; after the call.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b76ff4906f33c2dd97ddd929b9662ba8cac6174c" translate="yes" xml:space="preserve">
          <source>Boolean</source>
          <target state="translated">Boolean</target>
        </trans-unit>
        <trans-unit id="7bb852d637486dd2f9b852b32fe5bd9ba4fa4b63" translate="yes" xml:space="preserve">
          <source>Boolean conversions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9a26dc7a812c76d486afec462ae9a205a68b3e6" translate="yes" xml:space="preserve">
          <source>Boolean literals</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74e13cd703ad7a9a0db9e8fcedf7a2cbccdea7d3" translate="yes" xml:space="preserve">
          <source>Boolean negation operator</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49f29c844f200eead7503c6d10737135d242ba2b" translate="yes" xml:space="preserve">
          <source>Boolean type</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a14c6ec0166e69a3cf0be1f4ccc882e1dc773e55" translate="yes" xml:space="preserve">
          <source>Both &lt;a href=&quot;../../language/new&quot;&gt;new-expression&lt;/a&gt; and &lt;a href=&quot;../../language/delete&quot;&gt;delete-expression&lt;/a&gt;, when used with objects whose alignment requirement is greater than &lt;code&gt;__STDCPP_DEFAULT_NEW_ALIGNMENT__&lt;/code&gt;, pass that alignment requirement as an argument of type &lt;code&gt;std::align_val_t&lt;/code&gt; to the selected allocation/deallocation function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="efa828bc8c6e261a85369b79ad278f982b80b478" translate="yes" xml:space="preserve">
          <source>Both &lt;a href=&quot;function_template&quot;&gt;function template&lt;/a&gt; and &lt;a href=&quot;class_template&quot;&gt;class template&lt;/a&gt; declarations may appear with the &lt;code&gt;friend&lt;/code&gt; specifier in any non-local class or class template (although only function templates may be defined within the class or class template that is granting friendship). In this case, every specialization of the template becomes a friend, whether it is implicitly instantiated, partially specialized, or explicitly specialized.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63016d3fee2638a4d3429bfc299eeab7075b466b" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;EXIT_SUCCESS&lt;/code&gt; and the value zero indicate successful program execution status (see &lt;code&gt;&lt;a href=&quot;exit&quot;&gt;std::exit&lt;/a&gt;&lt;/code&gt;), although it is not required that &lt;code&gt;EXIT_SUCCESS&lt;/code&gt; equals zero.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff19dd1cff37c69bcf7f62a061f0632df661ad27" translate="yes" xml:space="preserve">
          <source>Both constructors (other than &lt;a href=&quot;copy_constructor&quot;&gt;copy&lt;/a&gt;/&lt;a href=&quot;move_constructor&quot;&gt;move&lt;/a&gt;) and user-defined conversion functions may be function templates; the meaning of &lt;code&gt;explicit&lt;/code&gt; doesn't change.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b2dfd50c4fa7ea73355cbddda751f4dda04b1d2" translate="yes" xml:space="preserve">
          <source>Both constructors are protected, and are only called by the concrete streambuf classes, such as &lt;code&gt;&lt;a href=&quot;../basic_filebuf&quot;&gt;std::basic_filebuf&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../basic_stringbuf&quot;&gt;std::basic_stringbuf&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;../strstreambuf&quot;&gt;std::strstreambuf&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a919957c7deab2ea5acd8f4154fbcf839bb6dac2" translate="yes" xml:space="preserve">
          <source>Both copy- and move-assignment operators for directory_entry are are defaulted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5bb05230f21307e6f1e1d771c4a72fefe561d481" translate="yes" xml:space="preserve">
          <source>Both scoped enumeration types and unscoped enumeration types whose underlying type is fixed can be initialized from an integer without a cast, using &lt;a href=&quot;list_initialization&quot;&gt;list initialization&lt;/a&gt;, if all of the following is true:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5deba5db9615b12e705c1e44fac1908355100dcb" translate="yes" xml:space="preserve">
          <source>Both single-object and array allocation functions may be defined as public static member functions of a class (versions (15-18)). If defined, these allocation functions are called by &lt;a href=&quot;../../language/new&quot;&gt;new-expressions&lt;/a&gt; to allocate memory for single objects and arrays of this class, unless the new expression used the form &lt;code&gt;::new&lt;/code&gt; which bypasses class-scope lookup. The keyword &lt;code&gt;static&lt;/code&gt; is optional for these functions: whether used or not, the allocation function is a static member function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0028861eddd8245788364237b82fa610aebd0d8e" translate="yes" xml:space="preserve">
          <source>Both this function and the constructor of &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt; may be used to acquire temporary ownership of the managed object referred to by a &lt;code&gt;std::weak_ptr&lt;/code&gt;. The difference is that the constructor of &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt; throws an exception when its &lt;code&gt;std::weak_ptr&lt;/code&gt; argument is empty, while &lt;code&gt;std::weak_ptr&amp;lt;T&amp;gt;::lock()&lt;/code&gt; constructs an empty &lt;code&gt;std::shared_ptr&amp;lt;T&amp;gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c71adfce132d82af6ce298cc94111b2a04e3c1ab" translate="yes" xml:space="preserve">
          <source>Both versions are constant expressions of type &lt;code&gt;&lt;a href=&quot;../types/size_t&quot;&gt;std::size_t&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="943facfd40f56533abfb37b73ee46c45ee23481a" translate="yes" xml:space="preserve">
          <source>Boyer-Moore search algorithm implementation</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="498eeb65762b20bc8f5d61f62b5b2037e626f9c9" translate="yes" xml:space="preserve">
          <source>Boyer-Moore-Horspool search algorithm implementation</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f87d9810eeab220cb3bd2cc07cbf939aafc31cb1" translate="yes" xml:space="preserve">
          <source>Brace-enclosed initializers</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="014d790a3d5a9df8c0ff4408ebe540186f635544" translate="yes" xml:space="preserve">
          <source>Breaks the association of the associated mutex, if any, and &lt;code&gt;*this&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7dfd8323fd5e72ce649953eb9bbb100abdbf328" translate="yes" xml:space="preserve">
          <source>Broken pipe</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5817b915ebc6c65487325f1fad96d1830f9ec3a" translate="yes" xml:space="preserve">
          <source>Bucket index for the key &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1578c16566abfd5ed0ac525177c29f906ca89176" translate="yes" xml:space="preserve">
          <source>Bucket interface</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39da5ebcfeabc5cbfab75222627dd08adc0b92bb" translate="yes" xml:space="preserve">
          <source>Build level and violation handling</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20f409cc87c744070ec80e942947a590f8db80d1" translate="yes" xml:space="preserve">
          <source>Built-in</source>
          <target state="translated">Built-in</target>
        </trans-unit>
        <trans-unit id="5620451e3028694b641893b89d306b16dd893957" translate="yes" xml:space="preserve">
          <source>Built-in &lt;a href=&quot;operator_comparison#Three-way_comparison&quot;&gt;three-way comparison operator&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba57c0678fa197d58d012dcdbd8ff367ded4373c" translate="yes" xml:space="preserve">
          <source>Built-in address-of operator</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89c57ad877bc748c74e85159feaaf08e70f5f5a1" translate="yes" xml:space="preserve">
          <source>Built-in comma operator</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29c41e2e5a519d072283f8900cfb2aecddea654d" translate="yes" xml:space="preserve">
          <source>Built-in function call operator</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a837a52363a7caaa8043442690c260da71652ff" translate="yes" xml:space="preserve">
          <source>Built-in indirection operator</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="667f2d7df45e4a7b467abfa721de0d718054104f" translate="yes" xml:space="preserve">
          <source>Built-in member access operators</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76bd10380a7941d509b7c26c3c0d87d1eddae2bc" translate="yes" xml:space="preserve">
          <source>Built-in pointer-to-member access operators</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74faee7794760c0f5ba932d0cc3927a1f7c63af0" translate="yes" xml:space="preserve">
          <source>Built-in postfix operators</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c49aba310c5c949e131422dc6d86594cd3fd9999" translate="yes" xml:space="preserve">
          <source>Built-in prefix operators</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01e1dbd00564662647a6c23a14ae45eff862413d" translate="yes" xml:space="preserve">
          <source>Built-in subscript operator</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97de26f6f9f063ed744153d8d933e88e0b59a100" translate="yes" xml:space="preserve">
          <source>Builtin compound assignment</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="860269ba76f59f407f62610e614523ed6bb2b17c" translate="yes" xml:space="preserve">
          <source>Builtin direct assignment</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd27a3b8b65f3e0b8397cd40fb51bd882218435c" translate="yes" xml:space="preserve">
          <source>Builtin operators &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; and &lt;code&gt;||&lt;/code&gt; perform short-circuit evaluation (do not evaluate the second operand if the result is known after evaluating the first), but overloaded operators behave like regular function calls and always evaluate both operands</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05d591efb279e3a248c17303baf5ea55526a4063" translate="yes" xml:space="preserve">
          <source>But the same parameter cannot be given default arguments twice in the same scope.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae372236d69794d1162dbcde117c87725ee50599" translate="yes" xml:space="preserve">
          <source>By default (with the default &lt;code&gt;&lt;a href=&quot;../char_traits&quot;&gt;std::char_traits&lt;/a&gt;&lt;/code&gt;), this function is not locale-sensitive. See &lt;code&gt;&lt;a href=&quot;../../locale/collate/compare&quot;&gt;std::collate::compare&lt;/a&gt;&lt;/code&gt; for locale-aware three-way string comparison.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3a260b7cae289fb8e1fb6ad3c38b354a5c26916" translate="yes" xml:space="preserve">
          <source>By default, all eight standard C++ streams are synchronized with their respective C streams.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce023180676c6490743b29e9926007bad4819315" translate="yes" xml:space="preserve">
          <source>By default, symlinks are not followed, but this can be enabled by specifying the directory option &lt;a href=&quot;directory_options&quot;&gt;&lt;code&gt;follow_directory_symlink&lt;/code&gt;&lt;/a&gt; at construction time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0eb851d780be859c6cd08434ab3959f35e91fa13" translate="yes" xml:space="preserve">
          <source>By default, the standard streams &lt;code&gt;cin&lt;/code&gt; and &lt;code&gt;cerr&lt;/code&gt; are tied to &lt;code&gt;cout&lt;/code&gt;. Similarly, their wide counterparts &lt;code&gt;wcin&lt;/code&gt; and &lt;code&gt;wcerr&lt;/code&gt; are tied to &lt;code&gt;wcout&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0541acf21651250dc0b8e2afd7f3da25009343a" translate="yes" xml:space="preserve">
          <source>By default, this will call placement-new, as by &lt;code&gt;::new((void*)p) T()&lt;/code&gt; (that is, &lt;a href=&quot;../language/value_initialization&quot;&gt;value-initialize&lt;/a&gt; the object pointed to by &lt;code&gt;p&lt;/code&gt;). If value-initialization is undesirable, for example, if the object is of non-class type and zeroing out is not needed, it can be avoided by providing a &lt;a href=&quot;http://stackoverflow.com/a/21028912/273767&quot;&gt;custom Allocator::construct&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7803ee252527503b67d1eeb0deb252622746cebd" translate="yes" xml:space="preserve">
          <source>Byte</source>
          <target state="translated">Byte</target>
        </trans-unit>
        <trans-unit id="8e26337cf6bb10967dc0cb055379c6312a7a94ee" translate="yes" xml:space="preserve">
          <source>Byte/multibyte character</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32096c2e0eff33d844ee6d675407ace18289357d" translate="yes" xml:space="preserve">
          <source>C</source>
          <target state="translated">C</target>
        </trans-unit>
        <trans-unit id="15c24806702abe5ea48e31ecde1d9e103ea60746" translate="yes" xml:space="preserve">
          <source>C &lt;a href=&quot;language_linkage&quot;&gt;language linkage&lt;/a&gt; is not allowed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09b5b3333cb4ff4683a9d0855cb7f956ff522e8f" translate="yes" xml:space="preserve">
          <source>C Date and time utilities</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1eca25182c934c202df4d629e6f313747250a6f1" translate="yes" xml:space="preserve">
          <source>C compatibility header.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f27d46df9dc50736ed4e3b3843a69d430fee37b8" translate="yes" xml:space="preserve">
          <source>C compatibility headers</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b75858e6f52757d42995120144302a816dcfb58b" translate="yes" xml:space="preserve">
          <source>C compatibility macro constant, expands to integer constant &lt;code&gt;1&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a96bb87493004f593e10038ce1e6395886cc3ef" translate="yes" xml:space="preserve">
          <source>C library</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="085bb2391a15d3dae8b4fa9f82fd51d51923f45e" translate="yes" xml:space="preserve">
          <source>C library locales</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="401eb191196e5e41faa446684424f56e654762b8" translate="yes" xml:space="preserve">
          <source>C localization utilities</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f247a737aad973565e0ba61f676327ab62c8b7fc" translate="yes" xml:space="preserve">
          <source>C memory management library</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="726cf0d2d039a3d7cb20400e7f928d472fbf197c" translate="yes" xml:space="preserve">
          <source>C numeric limits interface</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b970bd670bcff0b0de508ab26d86ee7e72402f93" translate="yes" xml:space="preserve">
          <source>C random library</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56b2ac8093b8f482b9514d65903de1ddffba1b90" translate="yes" xml:space="preserve">
          <source>C streams are objects of type &lt;code&gt;std::FILE&lt;/code&gt; that can only be accessed and manipulated through pointers of type &lt;code&gt;std::FILE*&lt;/code&gt; (Note: while it may be possible to create a local object of type &lt;code&gt;std::FILE&lt;/code&gt; by dereferencing and copying a valid &lt;code&gt;std::FILE*&lt;/code&gt;, using the address of such copy in the I/O functions is undefined behavior). Each C stream is associated with an external physical device (file, standard input stream, printer, serial port, etc).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6cb82dfe4668eb03399d738975e3f7f2a00e75b" translate="yes" xml:space="preserve">
          <source>C streams can be used for both unformatted and formatted input and output. They are locale-sensitive and may perform wide/multibyte conversions as necessary. Unlike C++ streams, where each stream is associated with its own locale, all C streams access the same locale object: the one most recently installed with &lt;code&gt;&lt;a href=&quot;../locale/setlocale&quot;&gt;std::setlocale&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79c384f1ba053ea6a78d8c958d790e56d9052ca1" translate="yes" xml:space="preserve">
          <source>C string holding the name of the desired category</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="437c617752c611b36293355138fcbc5720307f88" translate="yes" xml:space="preserve">
          <source>C string holding the name of the desired mapping.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="136b0b9b8ee0529927aebb743b29982272ffa9e4" translate="yes" xml:space="preserve">
          <source>C&amp;amp;</source>
          <target state="translated">C&amp;amp;</target>
        </trans-unit>
        <trans-unit id="fc2b4216164cfb01ac45112054b3fedda8b56c86" translate="yes" xml:space="preserve">
          <source>C++</source>
          <target state="translated">C++</target>
        </trans-unit>
        <trans-unit id="2f6d341776b09562a2d3ff15e2b8fa6906d9644e" translate="yes" xml:space="preserve">
          <source>C++ (and C) source code may be written in any non-ASCII 7-bit character set that includes the &lt;a href=&quot;https://en.wikipedia.org/wiki/ISO_646&quot;&gt;ISO 646:1983&lt;/a&gt; invariant character set. However, several C++ operators and punctuators require characters that are outside of the ISO 646 codeset: &lt;code&gt;{, }, [, ], #, \, ^, |, ~&lt;/code&gt;. To be able to use character encodings where some or all of these symbols do not exist (such as the German &lt;a href=&quot;http://de.wikipedia.org/wiki/DIN_66003&quot;&gt;DIN 66003&lt;/a&gt;), C++ defines the following alternatives composed of ISO 646 compatible characters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c7d95b436ecd68b95eaa98a87bac58f93c37e6b" translate="yes" xml:space="preserve">
          <source>C++ Core Guidelines &lt;a href=&quot;https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#e14-use-purpose-designed-user-defined-types-as-exceptions-not-built-in-types&quot;&gt;E.14&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8cd612f2751329bbc16fee8f0091854df9f6031e" translate="yes" xml:space="preserve">
          <source>C++ Core Guidelines &lt;a href=&quot;https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#e15-catch-exceptions-from-a-hierarchy-by-reference&quot;&gt;E.15&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98881b02a247b26f94eb74fc06a45d722e646dd5" translate="yes" xml:space="preserve">
          <source>C++ Core Guidelines &lt;a href=&quot;https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#i10-use-exceptions-to-signal-a-failure-to-perform-a-required-task&quot;&gt;I.10&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8be3e815f49596e499ad72b4130d9ecd2f1b149" translate="yes" xml:space="preserve">
          <source>C++ Core Guidelines E.6 &quot;Use RAII to prevent leaks&quot;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="147230a86e1c7e0bef8e1878444e4fbcc383fa96" translate="yes" xml:space="preserve">
          <source>C++ Operator Precedence</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c31eca9ef3dcd7526b7195249185a9729b743830" translate="yes" xml:space="preserve">
          <source>C++ Programming Language</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7e7bcbec1050d7f0d883fbb8bc2748f84236f39" translate="yes" xml:space="preserve">
          <source>C++ also includes the &lt;a href=&quot;io/c&quot;&gt; input/output functions defined by C&lt;/a&gt;, such as &lt;code&gt;&lt;a href=&quot;io/c/fopen&quot;&gt;std::fopen&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;io/c/fgetc&quot;&gt;std::getc&lt;/a&gt;&lt;/code&gt;, etc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06557fdbe17d2e091891cc63144b53692b2f4c27" translate="yes" xml:space="preserve">
          <source>C++ attribute: carries_dependency (since C++11)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a80c78aa3d0be4365d4a4aace53df1894fafefe" translate="yes" xml:space="preserve">
          <source>C++ attribute: deprecated (since C++14)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad4b4ad5889a95c53ae7ededcaefccd580e10788" translate="yes" xml:space="preserve">
          <source>C++ attribute: expects, ensures, assert (C++20)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f01e78c670736bcfbc7cbb131e20f9036aefa35" translate="yes" xml:space="preserve">
          <source>C++ attribute: fallthrough (since C++17)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a55af33c93fad900d8f3c516df19e406f43533ff" translate="yes" xml:space="preserve">
          <source>C++ attribute: likely, unlikely (since C++20)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69ebed955bad0cdef08a090954f7632df7b64103" translate="yes" xml:space="preserve">
          <source>C++ attribute: maybe_unused (since C++17)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="127add9901453ff701417a6b814f3ecc1b88d1ac" translate="yes" xml:space="preserve">
          <source>C++ attribute: no_unique_address (since C++20)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9e91b3dd1ac40fbbb8928fd5021a1da6124dcb0" translate="yes" xml:space="preserve">
          <source>C++ attribute: nodiscard (since C++17)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f8de489858717f3061b65d4e3dae9adad203d70" translate="yes" xml:space="preserve">
          <source>C++ attribute: noreturn (since C++11)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="387814363c5c1f906d9da1e85cb5bc67e4f38c05" translate="yes" xml:space="preserve">
          <source>C++ attribute: optimize_for_synchronized (TM TS)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4583aeee6b4e07e7a7eb1f6b99f908d66bf96f40" translate="yes" xml:space="preserve">
          <source>C++ defines several function objects that represent common arithmetic and logical operations:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c67f57f6a26a137cf9bc71e8f9c5a5af0559e777" translate="yes" xml:space="preserve">
          <source>C++ includes a variety of utility libraries that provide functionality ranging from &lt;a href=&quot;utility/bitset&quot;&gt;bit-counting&lt;/a&gt; to &lt;a href=&quot;utility/functional/bind&quot;&gt;partial function application&lt;/a&gt;. These libraries can be broadly divided into two groups:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76aad39fcff3282441a6d5280586f60940cc31a5" translate="yes" xml:space="preserve">
          <source>C++ includes built-in support for threads, mutual exclusion, condition variables, and futures.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3934f659aacbf1f001d3645344748b8c444cd791" translate="yes" xml:space="preserve">
          <source>C++ includes support for two types of time manipulation:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92a2c968a34da23e4708e71892c2ffb721fa839a" translate="yes" xml:space="preserve">
          <source>C++ includes the following types of statements:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49dd66f99c3d0ac54dc62b7ee7eb01eca487493b" translate="yes" xml:space="preserve">
          <source>C++ includes two input/output libraries: a modern, stream-based I/O library and the standard set of C-style I/O functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0e04efcb6a316f4e833950df1ac7962ec66959a" translate="yes" xml:space="preserve">
          <source>C++ keywords</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3aee0b831c4708d12c9406617e0cc1e8018f2d74" translate="yes" xml:space="preserve">
          <source>C++ keywords: alignas (since C++11)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29507b9a59ffc6150615d0d338bd1beb939dfad0" translate="yes" xml:space="preserve">
          <source>C++ keywords: alignof (since C++11)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="183b1dcdba07c3b1be4b49fab102e89c9a7de240" translate="yes" xml:space="preserve">
          <source>C++ keywords: and</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a6e38d19cc3dc2909a3faa576f245fdf6217690" translate="yes" xml:space="preserve">
          <source>C++ keywords: and_eq</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="124a64afaa6c8c5bfca6047dd460511a6b97db33" translate="yes" xml:space="preserve">
          <source>C++ keywords: asm</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0612d43a8ba92fee978df18206be3adce6458fa" translate="yes" xml:space="preserve">
          <source>C++ keywords: audit (since C++20)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2ccdccd648a0f0a224169f56af64c5a94ea2b07" translate="yes" xml:space="preserve">
          <source>C++ keywords: auto</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="526ec64f9498eb1229f0b99304e24893a3786743" translate="yes" xml:space="preserve">
          <source>C++ keywords: axiom (since C++20)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="163810b967745c12225f305e7e817d651df13205" translate="yes" xml:space="preserve">
          <source>C++ keywords: bitand</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05bce8999813ae5f7d868f68ce64fcade539f423" translate="yes" xml:space="preserve">
          <source>C++ keywords: bitor</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba78f8f4b5950d9d7ebfc170c7afd751c59bdc1f" translate="yes" xml:space="preserve">
          <source>C++ keywords: bool</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d69d38c5fa6d513f4ee223cae0f80ada3cf1eb0b" translate="yes" xml:space="preserve">
          <source>C++ keywords: break</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b869375d71945d8fecb773bf590ce8095cc4588" translate="yes" xml:space="preserve">
          <source>C++ keywords: case</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7c81faed45b85c8dcd86de0734ee278e34df717" translate="yes" xml:space="preserve">
          <source>C++ keywords: catch</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb289f167e01192a7926393875a6c8672f6c6f9e" translate="yes" xml:space="preserve">
          <source>C++ keywords: char</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eacf79f3f8a785c01bc0ce19bb78a42fbe110d2b" translate="yes" xml:space="preserve">
          <source>C++ keywords: char16_t (since C++11)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d42a327c13fbb384479588185d9a50190dde3cf8" translate="yes" xml:space="preserve">
          <source>C++ keywords: char32_t (since C++11)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2545bdc74a2da147dd1af1123e6aa8edbc09e87" translate="yes" xml:space="preserve">
          <source>C++ keywords: char8_t (since C++20)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2ebb8c0d088a0587ab8ccaeece91bd9e176a491" translate="yes" xml:space="preserve">
          <source>C++ keywords: class</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29b898e1bb17af4eedf763c0844dd1fbb1bdd22d" translate="yes" xml:space="preserve">
          <source>C++ keywords: co_await</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16a636816ed7f754d904e9002adf34e537a3bbfa" translate="yes" xml:space="preserve">
          <source>C++ keywords: co_return</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33bc95e36c6779fdbd2d85867f4c0f747ae853fe" translate="yes" xml:space="preserve">
          <source>C++ keywords: co_yield</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01848e98ae4887d344100accfb0dc0f687fda24d" translate="yes" xml:space="preserve">
          <source>C++ keywords: compl</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f9e6b0ca42a7a44125068643d4aeacd6ed22adc" translate="yes" xml:space="preserve">
          <source>C++ keywords: concept</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26d8438420078942bafe0fcabb0f3a9ff8f21c57" translate="yes" xml:space="preserve">
          <source>C++ keywords: const</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69601052b6f31cbc68f401b4565ce386a65a23c2" translate="yes" xml:space="preserve">
          <source>C++ keywords: const_cast</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf6dfea8cb8956898c49e4b94e6e3b12224c1209" translate="yes" xml:space="preserve">
          <source>C++ keywords: consteval</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="527aef1fbeeb02aed3a5fdbfc85d582ce0f515aa" translate="yes" xml:space="preserve">
          <source>C++ keywords: constexpr (since C++11)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="395fd0f15c5d8fac44a7288a59ea5a86379a156b" translate="yes" xml:space="preserve">
          <source>C++ keywords: continue</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36bf9192492d110977874a62802f3f0cbf1c7005" translate="yes" xml:space="preserve">
          <source>C++ keywords: decltype</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f30dc791d0616219ea0defdde70ed1cfef4ff5c8" translate="yes" xml:space="preserve">
          <source>C++ keywords: default</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94d1f98ddc77ffbdfd69b93ceca8b8d435110d3c" translate="yes" xml:space="preserve">
          <source>C++ keywords: delete</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2fec1767b7b69a4a327e04a5a4c3a4f27379bdd2" translate="yes" xml:space="preserve">
          <source>C++ keywords: do</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7bafac1a9bd6cde00b59ed3cdcbd753151e0a51a" translate="yes" xml:space="preserve">
          <source>C++ keywords: double</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b4a595b8bfbe949f6ca15f733e9e13331a42383" translate="yes" xml:space="preserve">
          <source>C++ keywords: dynamic_cast</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b32114b3f766f8a6739a7358915b26ea1b71457a" translate="yes" xml:space="preserve">
          <source>C++ keywords: else</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9917c70089a8094b6d2fbb8e852e373f906a704b" translate="yes" xml:space="preserve">
          <source>C++ keywords: enum</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d544a09b352faa3a994cc54ccff972a5a3cb000b" translate="yes" xml:space="preserve">
          <source>C++ keywords: explicit</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c3210a8eec85af05733531fd5df52b05cdd6aa9" translate="yes" xml:space="preserve">
          <source>C++ keywords: export</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de55ab46e46dffbf77fad964ecd27e3f0d9ef421" translate="yes" xml:space="preserve">
          <source>C++ keywords: extern</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e57865b70fcda2180074588769785ddc1a36b1c4" translate="yes" xml:space="preserve">
          <source>C++ keywords: false</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a700071e23581008cd76b45c2c69fea512ecb640" translate="yes" xml:space="preserve">
          <source>C++ keywords: final (since C++11)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d02f9afd3fb00647e6a8e3424d891ceecd47fa78" translate="yes" xml:space="preserve">
          <source>C++ keywords: float</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5cd84453036526e60fa4e42dda9e069ff310fd3" translate="yes" xml:space="preserve">
          <source>C++ keywords: for</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48f95d56f056fed8728e03635e48afcd5b420407" translate="yes" xml:space="preserve">
          <source>C++ keywords: friend</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e68fa94e046f072a7ff1b219e912a351a979625" translate="yes" xml:space="preserve">
          <source>C++ keywords: goto</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4725b0f2dcc6d3119ce93a5f3e3d49658b9f6ae7" translate="yes" xml:space="preserve">
          <source>C++ keywords: if</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e499739fb3e6977144ad9e1eeb2e5bc4a8ddc540" translate="yes" xml:space="preserve">
          <source>C++ keywords: inline</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3fd1b872d293865c0aefeed8e6183dd1c548684" translate="yes" xml:space="preserve">
          <source>C++ keywords: int</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c27210515d0813a21164dfce05ea3be2f9ae3b66" translate="yes" xml:space="preserve">
          <source>C++ keywords: long</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d43f4cb276936dd386b3bd9758fc75c328cc95f" translate="yes" xml:space="preserve">
          <source>C++ keywords: mutable</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b02800bd96f0d61d78a098b7b68899cdbbd6afe6" translate="yes" xml:space="preserve">
          <source>C++ keywords: namespace</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f9a52b4836fa43713e1e3fa4d56214068cc8def" translate="yes" xml:space="preserve">
          <source>C++ keywords: new</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c0ca031ba0d25429ecf94970709e58032f30ab8" translate="yes" xml:space="preserve">
          <source>C++ keywords: noexcept (since C++11)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c89b31c825167c40b35e37235a165123fdf5b4e4" translate="yes" xml:space="preserve">
          <source>C++ keywords: not</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3cc0c7490348f3b3ba14089762bd72de7bd639ce" translate="yes" xml:space="preserve">
          <source>C++ keywords: not_eq</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b19ba534185a30e68c38be176f0412bc1f2bc6b5" translate="yes" xml:space="preserve">
          <source>C++ keywords: nullptr (since C++11)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70814bfe02a7af8b95ce36bc95a7da1123095a6a" translate="yes" xml:space="preserve">
          <source>C++ keywords: operator</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c23df376605d78f63a5500160b48ee512157ad7c" translate="yes" xml:space="preserve">
          <source>C++ keywords: or</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d20cac1ee4d77d9ffa9e5793ad0383aa3ad51475" translate="yes" xml:space="preserve">
          <source>C++ keywords: or_eq</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a0293371d55246ce973ae3e75626127f1504b6a" translate="yes" xml:space="preserve">
          <source>C++ keywords: override (since C++11)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03786ae3b9f628796529d09b809dbfc8b46793fe" translate="yes" xml:space="preserve">
          <source>C++ keywords: private</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df7d4ea5bc32cb787a6f750294cd5227c2fcd0d1" translate="yes" xml:space="preserve">
          <source>C++ keywords: protected</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bfab844551173e61ef5a9ab220a29b66c69734b6" translate="yes" xml:space="preserve">
          <source>C++ keywords: public</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f1f72ef9a8c96008d1a90280fd58c243aa19f0b" translate="yes" xml:space="preserve">
          <source>C++ keywords: register</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd98a0128d90a9233e207ec1405b9a7e57585055" translate="yes" xml:space="preserve">
          <source>C++ keywords: reinterpret_cast</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e57ca4acf8809388dce3238247eb7aa0f55ae138" translate="yes" xml:space="preserve">
          <source>C++ keywords: requires</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1abcca2b0e66ee60c977a4e5782dd98d5b4d457d" translate="yes" xml:space="preserve">
          <source>C++ keywords: return</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b1adaad1115bcff0759ad4794ff292ed78b3c23" translate="yes" xml:space="preserve">
          <source>C++ keywords: short</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7bd3bfdfb2f3297c5564232cb8f3314290cdc7cf" translate="yes" xml:space="preserve">
          <source>C++ keywords: signed</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ff280c7a565563348f26be8d65133c336d662d3" translate="yes" xml:space="preserve">
          <source>C++ keywords: sizeof</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a6d44df359c5334d919f430e3f3a4ac0d088d64" translate="yes" xml:space="preserve">
          <source>C++ keywords: static</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94bea4546792cb644fbf90e8a6f9c16d09f62ef3" translate="yes" xml:space="preserve">
          <source>C++ keywords: static_assert (since C++11)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72096556dc877cb5f85ffd02a8ca80027a3dd3aa" translate="yes" xml:space="preserve">
          <source>C++ keywords: static_cast</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2fb75279739ad8e2dec4f932c10feab705444ec" translate="yes" xml:space="preserve">
          <source>C++ keywords: struct</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d55fcffd470c877223faca7c22ebb0001352b9e" translate="yes" xml:space="preserve">
          <source>C++ keywords: switch</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a86cf3a93c4b52678e6d0617edc0697e04f2ca0" translate="yes" xml:space="preserve">
          <source>C++ keywords: template</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="917e6e9b4ef5b0862e8ac7fdc4490ad8424f619e" translate="yes" xml:space="preserve">
          <source>C++ keywords: this</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7be930465dc63b127e9244e46b51e76cf2df9d25" translate="yes" xml:space="preserve">
          <source>C++ keywords: thread_local (since C++11)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6e56566966d5710214d6f3ea6c95ab6c44200df" translate="yes" xml:space="preserve">
          <source>C++ keywords: throw</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0044cc96e436f4b21ecd72cd8dfbd5e16f91d829" translate="yes" xml:space="preserve">
          <source>C++ keywords: true</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98ac0c70a9cb341c8cd03989ea0fb7d75b0bb05a" translate="yes" xml:space="preserve">
          <source>C++ keywords: try</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef86b57182f4ee052964937a9ab5e68c63c4ce5f" translate="yes" xml:space="preserve">
          <source>C++ keywords: typedef</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="454d53b90b0b8d7c3a3e8ad398ac791969143134" translate="yes" xml:space="preserve">
          <source>C++ keywords: typeid</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f09f8d522055844ed39f38a10e8d3068231112c5" translate="yes" xml:space="preserve">
          <source>C++ keywords: typename</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9cfe8a8699032565be2259c78cf9cf21c03061f" translate="yes" xml:space="preserve">
          <source>C++ keywords: union</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a2039a0d25e07bab54ea79e32cbb688dd58e12e" translate="yes" xml:space="preserve">
          <source>C++ keywords: unsigned</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8471d9f4d77d2e5eb14371c1da076716f02eaa32" translate="yes" xml:space="preserve">
          <source>C++ keywords: using</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca2d0f00321b8103f435fd2b14b1924abd2dfb05" translate="yes" xml:space="preserve">
          <source>C++ keywords: virtual</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="624f83b1ecef18ff894e0bb447112f9f3014800a" translate="yes" xml:space="preserve">
          <source>C++ keywords: void</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f78e5cc4134b90e370b281fe8d44693b1ec58e36" translate="yes" xml:space="preserve">
          <source>C++ keywords: volatile</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c61c84d1b44e56098d4c56e5048e58138e3fbc7" translate="yes" xml:space="preserve">
          <source>C++ keywords: wchar_t</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c909f57896904cc34b1cc4e253dd5d79ed3ab7b" translate="yes" xml:space="preserve">
          <source>C++ keywords: while</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b74b5079b0e1bc6b6d3a9df3f3dcaf748b4fdf4" translate="yes" xml:space="preserve">
          <source>C++ keywords: xor</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb3705de2bf421a4730d1843c818dc31e4324286" translate="yes" xml:space="preserve">
          <source>C++ keywords: xor_eq</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00d4296327feae05e7f754006f1f81e7b3df74e7" translate="yes" xml:space="preserve">
          <source>C++ language</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c6e1f137cae8deef2fe086c3a40c23cb3abd95c" translate="yes" xml:space="preserve">
          <source>C++ named requirements: Allocator</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68093762465efd54450ba8bcd9c0a91c4dbf0f1b" translate="yes" xml:space="preserve">
          <source>C++ named requirements: AllocatorAwareContainer</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab7ac32bec349da4c19ab2096d1b1255564f39b0" translate="yes" xml:space="preserve">
          <source>C++ named requirements: AssociativeContainer</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bce38a21c7a5a1ec76fbe77837afdf562ff1649d" translate="yes" xml:space="preserve">
          <source>C++ named requirements: BasicLockable</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1a9abc4c52e314d687b58fdfa28003600137949" translate="yes" xml:space="preserve">
          <source>C++ named requirements: BinaryPredicate</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77f706b668a619259c5204b16d231a4b5f303147" translate="yes" xml:space="preserve">
          <source>C++ named requirements: BinaryTypeTrait</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2dac169f409edf4d6004eeef2aa80e3ce234acba" translate="yes" xml:space="preserve">
          <source>C++ named requirements: BitmaskType</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ac90618765ee9c85f861c53f0604fe5b1bece8f" translate="yes" xml:space="preserve">
          <source>C++ named requirements: Callable</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee45309ee631f97e8c54fdd32dd4c7314a219410" translate="yes" xml:space="preserve">
          <source>C++ named requirements: CharTraits</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e49e0b2de04ceaac02567e3c466ce7f34aa9139b" translate="yes" xml:space="preserve">
          <source>C++ named requirements: Clock</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03d4cd85a40261a51658ef8d686e3877be8fb96e" translate="yes" xml:space="preserve">
          <source>C++ named requirements: Compare</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac0da8de55de872e9c67b652831ec7e483b09c3b" translate="yes" xml:space="preserve">
          <source>C++ named requirements: ConstexprIterator</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0267fe31b3826841ff7251625998f2fcb06717e" translate="yes" xml:space="preserve">
          <source>C++ named requirements: Container</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf843c7d6d3dc3a137cc532583586f04e6c312a3" translate="yes" xml:space="preserve">
          <source>C++ named requirements: ContiguousContainer</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f039fec7eb71a74ef921bce40ef720e3e7301f7" translate="yes" xml:space="preserve">
          <source>C++ named requirements: CopyAssignable</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5a5a4d38564c8be046908e5b71fa8fc1c5617c2" translate="yes" xml:space="preserve">
          <source>C++ named requirements: CopyConstructible</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a6121d6fc5b64e9265c4080e5c5342c8e2ea499" translate="yes" xml:space="preserve">
          <source>C++ named requirements: CopyInsertable</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0410f086a810b23ccfa34f4b0166c8fba23f310" translate="yes" xml:space="preserve">
          <source>C++ named requirements: DefaultConstructible</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0e9c4ff46f14ebb3f87a8006d8b76bdc0d3803b" translate="yes" xml:space="preserve">
          <source>C++ named requirements: DefaultInsertable</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f0c828f8de0769b3ee1f87f72ae6283f03e4208" translate="yes" xml:space="preserve">
          <source>C++ named requirements: Destructible</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3846bfd4ceb5970ead3569546441faa22d6f618" translate="yes" xml:space="preserve">
          <source>C++ named requirements: EmplaceConstructible (since C++11)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f00c016cd8d60c879ed8f11a065a6cdb2245c1a" translate="yes" xml:space="preserve">
          <source>C++ named requirements: EqualityComparable</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4bdf57055cd7c0dae92592574976fad30e86740" translate="yes" xml:space="preserve">
          <source>C++ named requirements: Erasable</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9dce4c90e1ab07bd8e4f26bfd59c7bb93d2c13b" translate="yes" xml:space="preserve">
          <source>C++ named requirements: FormattedInputFunction</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78390db68319248607d73e238aa034d36af5547e" translate="yes" xml:space="preserve">
          <source>C++ named requirements: FormattedOutputFunction</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17341909637487f66a0a51420af28ebc0ff53f17" translate="yes" xml:space="preserve">
          <source>C++ named requirements: FunctionObject</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83eafac0e33fd85d404291ef083b29a6c21e4bd5" translate="yes" xml:space="preserve">
          <source>C++ named requirements: Hash</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7114351c4bbaa9528560ef257598f798ddb3de5" translate="yes" xml:space="preserve">
          <source>C++ named requirements: LegacyBidirectionalIterator</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="333591b546d46f2b2872fef1e1d696156e3d4da4" translate="yes" xml:space="preserve">
          <source>C++ named requirements: LegacyContiguousIterator</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49fdc557343b56a30b7a499efbbea9f6e8d5ea27" translate="yes" xml:space="preserve">
          <source>C++ named requirements: LegacyForwardIterator</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0ca593d796d2c1f1cdfea5aaaa5bcc718fed510" translate="yes" xml:space="preserve">
          <source>C++ named requirements: LegacyInputIterator</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="daac43c9c4fb82513fe27e3efbdb288f38305a58" translate="yes" xml:space="preserve">
          <source>C++ named requirements: LegacyIterator</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="491d2d06bd47da0deeddf998db8a57451119a47e" translate="yes" xml:space="preserve">
          <source>C++ named requirements: LegacyOutputIterator</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2bae53a7d3573b63c5126a51eeda215a90f01f27" translate="yes" xml:space="preserve">
          <source>C++ named requirements: LegacyRandomAccessIterator</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="234fc9eae136300c3a84df869801ddac1bc39e85" translate="yes" xml:space="preserve">
          <source>C++ named requirements: LessThanComparable</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa488eac6c38cb8817603703df4bd4bc17b5bc3c" translate="yes" xml:space="preserve">
          <source>C++ named requirements: LiteralType</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e27d143c2848bfc04da8fa00c12fc56eba98a8f" translate="yes" xml:space="preserve">
          <source>C++ named requirements: Lockable</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ffa229dee12fb9a9290b1083466a57ea9ef88cb2" translate="yes" xml:space="preserve">
          <source>C++ named requirements: MoveAssignable (since C++11)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c7af72e00db75b25a6339c6bc85b14f40833ea5" translate="yes" xml:space="preserve">
          <source>C++ named requirements: MoveConstructible (since C++11)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="596d45856032c8c30536491e6532eb33250543a6" translate="yes" xml:space="preserve">
          <source>C++ named requirements: MoveInsertable (since C++11)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c772f99ba3b1d592fe8bec17544a1e701895811" translate="yes" xml:space="preserve">
          <source>C++ named requirements: Mutex</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e88a54faa0bd94e7b4c8d3cd5b28da3afb45b924" translate="yes" xml:space="preserve">
          <source>C++ named requirements: NullablePointer (since C++11)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc4469e68ff2c5b54f8ee6d9e3f309ac6b21c5bb" translate="yes" xml:space="preserve">
          <source>C++ named requirements: NumericType</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c535b9a77f5571dd0ffba42bac2b8d4ab54373c3" translate="yes" xml:space="preserve">
          <source>C++ named requirements: PODType</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8a0530ac14d26f5e08f4d837ff5542a4988b36d" translate="yes" xml:space="preserve">
          <source>C++ named requirements: Predicate</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84db291a7430e53241b723b9cdb6f5c57cf85f43" translate="yes" xml:space="preserve">
          <source>C++ named requirements: RandomNumberDistribution</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16dd49ad42be796cea9fe6814de48219bd526a22" translate="yes" xml:space="preserve">
          <source>C++ named requirements: RandomNumberEngine</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57db25a8dd2fe59f88627a14f0d9f4454923652f" translate="yes" xml:space="preserve">
          <source>C++ named requirements: RandomNumberEngineAdaptor</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ada05a46bb39c300a568907c930d2a57c5b9005d" translate="yes" xml:space="preserve">
          <source>C++ named requirements: RegexTraits</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="016355c7ec2c0cd838b6de26f8a355d0c2f26913" translate="yes" xml:space="preserve">
          <source>C++ named requirements: ReversibleContainer</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19a660b52b4b8c99460cfc9a560b03a16cf9cb42" translate="yes" xml:space="preserve">
          <source>C++ named requirements: SeedSequence</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="331ae8b25a90d44993d56e79517cc81206e0068d" translate="yes" xml:space="preserve">
          <source>C++ named requirements: SequenceContainer</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f9909d09bcc4eb0bdaada38cd2e514913d23668" translate="yes" xml:space="preserve">
          <source>C++ named requirements: SharedMutex</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f60730295a5aa0cd12e4416e599d5f966530ef4d" translate="yes" xml:space="preserve">
          <source>C++ named requirements: SharedTimedMutex</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d03f73195120ea59f692bd306fc14c4f75ddea6e" translate="yes" xml:space="preserve">
          <source>C++ named requirements: StandardLayoutType</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c2afe9643847a18800f6549859cddf158aebfc0" translate="yes" xml:space="preserve">
          <source>C++ named requirements: Swappable</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2699ee8a713e7d4efdc2e45280ccf4b85602bf33" translate="yes" xml:space="preserve">
          <source>C++ named requirements: TimedLockable</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4b09ebf2a8a166fe825d2ef813341e3cf6c00c4" translate="yes" xml:space="preserve">
          <source>C++ named requirements: TimedMutex</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f87af6136487f4529c077f27de7397f9b71930c" translate="yes" xml:space="preserve">
          <source>C++ named requirements: TransformationTrait</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90ecc6e1cfa9c37cd7a9058209da8423a4e1b338" translate="yes" xml:space="preserve">
          <source>C++ named requirements: TrivialClock</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e4be673e637f57a59a671d691fed257e408bde7" translate="yes" xml:space="preserve">
          <source>C++ named requirements: TrivialType</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="547fb3490fe494ac4547d562d1e3a4efcf9201ea" translate="yes" xml:space="preserve">
          <source>C++ named requirements: TriviallyCopyable</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5dbb493f4749a745c93c18f6210f4d60d51e03a6" translate="yes" xml:space="preserve">
          <source>C++ named requirements: UnaryTypeTrait</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4994b5268d59d59fba759c4ba742ecf79924693a" translate="yes" xml:space="preserve">
          <source>C++ named requirements: UnformattedInputFunction</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5d9e9fb8d202091be5c90998db3426e13ad8496" translate="yes" xml:space="preserve">
          <source>C++ named requirements: UnformattedOutputFunction</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e75c2aeea843d06f31a9ca2caeb62946537533d" translate="yes" xml:space="preserve">
          <source>C++ named requirements: UniformRandomBitGenerator</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87ad5436e94ce7e8b55c4f29d6f5a45aad21cf59" translate="yes" xml:space="preserve">
          <source>C++ named requirements: UnorderedAssociativeContainer</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15fe7066a6555232e049a6b5ae3a3b40fcc5e98b" translate="yes" xml:space="preserve">
          <source>C++ named requirements: ValueSwappable</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb6995247feeb0031e28871e5d52bb0bde2f6ab2" translate="yes" xml:space="preserve">
          <source>C++ pragmas in Visual Studio 2015</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b72da128624ab00dbe11304128e495f5b161352" translate="yes" xml:space="preserve">
          <source>C++ programs create, destroy, refer to, access, and manipulate</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc223fe085208876202452b5634bdb87b28fe03f" translate="yes" xml:space="preserve">
          <source>C++ standard</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a70571302b7aef91f6a1709d3bff98dbbe103cc" translate="yes" xml:space="preserve">
          <source>C++ time utilites</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ae06f5fc59967a95d7d2edd41265fb164cde198" translate="yes" xml:space="preserve">
          <source>C++ type system overview</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59267432adf8c9336c020edab8c6d1687c5a8555" translate="yes" xml:space="preserve">
          <source>C++-style</source>
          <target state="translated">C++-style</target>
        </trans-unit>
        <trans-unit id="741b2c379deb40170659b19eb9ef222dbd5fa167" translate="yes" xml:space="preserve">
          <source>C++-style comments are usually used to comment single lines, however, multiple C++-style comments can be placed together to form multi-line comments. C++-style comments tell the compiler to ignore all content between &lt;code&gt;//&lt;/code&gt; and a new line.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59fa0388313caf4655070a0038f68ffbc408c139" translate="yes" xml:space="preserve">
          <source>C++03</source>
          <target state="translated">C++03</target>
        </trans-unit>
        <trans-unit id="afd7c0601f217ac99e680979ea51cdb99e023353" translate="yes" xml:space="preserve">
          <source>C++03 POD with deleted non-trivial assignment was not trivial</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d030954e126ef3cc7aa28e489ff18c492566d17e" translate="yes" xml:space="preserve">
          <source>C++03 standard (ISO/IEC 14882:2003):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa182f32a2b889bab8bb654d1c6efd34ac494dd1" translate="yes" xml:space="preserve">
          <source>C++11</source>
          <target state="translated">C++11</target>
        </trans-unit>
        <trans-unit id="eb6204614cbf77403cd382a95e0f929788c6393d" translate="yes" xml:space="preserve">
          <source>C++11 (class type)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bca730909e080a8fc13db2273be471dfdb358b21" translate="yes" xml:space="preserve">
          <source>C++11 standard (ISO/IEC 14882:2011):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="526d8c7b1c46f07481431485812086e8bde79cad" translate="yes" xml:space="preserve">
          <source>C++14</source>
          <target state="translated">C++14</target>
        </trans-unit>
        <trans-unit id="3cf652fe8eeb36408d7f957624dd1e5feb276abf" translate="yes" xml:space="preserve">
          <source>C++14 (void)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="451b62af75ef22e7c1ee3794a50c6a6c3fdd7f7e" translate="yes" xml:space="preserve">
          <source>C++14 standard (ISO/IEC 14882:2014):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69ae287a1096db334e322d2404e3cd62fc5f7016" translate="yes" xml:space="preserve">
          <source>C++17</source>
          <target state="translated">C++17</target>
        </trans-unit>
        <trans-unit id="4c20ccb3f39c8ffe021987c4ad44fbb012e0262a" translate="yes" xml:space="preserve">
          <source>C++17 standard (ISO/IEC 14882:2017):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f0db8e1214a8ccf376f0bc5ba61385a18fbb5cc" translate="yes" xml:space="preserve">
          <source>C++20 defines a set of &lt;a href=&quot;../language/constraints&quot;&gt;constrained&lt;/a&gt; comparison function objects. The equality operators (&lt;code&gt;ranges::equal_to&lt;/code&gt; and &lt;code&gt;ranges::not_equal_to&lt;/code&gt;) require the types of the arguments to model &lt;a href=&quot;../concepts/equalitycomparable&quot;&gt;&lt;code&gt;EqualityComparableWith&lt;/code&gt;&lt;/a&gt;. The relational operators (&lt;code&gt;ranges::less&lt;/code&gt;, &lt;code&gt;ranges::greater&lt;/code&gt;, &lt;code&gt;ranges::less_equal&lt;/code&gt;, and &lt;code&gt;ranges::greater_equal&lt;/code&gt;) require the types of the arguments to model &lt;a href=&quot;../concepts/stricttotallyordered&quot;&gt;&lt;code&gt;StrictTotallyOrderedWith&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05eb29d2d943895480cbf23e5a4b02a727a6e2db" translate="yes" xml:space="preserve">
          <source>C++20 introduces a new system of iterators based on &lt;a href=&quot;language/constraints&quot;&gt;concepts&lt;/a&gt; that are different from C++17 iterators. While the basic taxonomy remains similar, the requirements for individual iterator categories are somewhat different.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e528f3cc4d3fc3ca8b281cef54dbb5b071d694e" translate="yes" xml:space="preserve">
          <source>C++20 iterator concepts</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="098b2706a0a08c620a10641456b665a828dbc0fa" translate="yes" xml:space="preserve">
          <source>C++20 provides &lt;a href=&quot;../language/constraints&quot;&gt;constrained&lt;/a&gt; versions of most algorithms in the namespace &lt;code&gt;std::ranges&lt;/code&gt;. In these algorithms, a range can be specified as either a &lt;a href=&quot;https://en.cppreference.com/mwiki/index.php?title=cpp/iterator/Iterator&amp;amp;action=edit&amp;amp;redlink=1&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt;-&lt;a href=&quot;https://en.cppreference.com/mwiki/index.php?title=cpp/iterator/Sentinel&amp;amp;action=edit&amp;amp;redlink=1&quot;&gt;&lt;code&gt;Sentinel&lt;/code&gt;&lt;/a&gt; pair or as a single &lt;a href=&quot;../ranges/range&quot;&gt;&lt;code&gt;Range&lt;/code&gt;&lt;/a&gt; argument, and projections and pointer-to-member callables are supported. Additionally, the return type of most algorithms have been changed to return all potentially useful information computed during the execution of the algorithm.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e947bf13606a87a8b5513ba351822e6dad8eca6" translate="yes" xml:space="preserve">
          <source>C++20 provides &lt;a href=&quot;language/constraints&quot;&gt;constrained&lt;/a&gt; uninitialized memory algorithms that accept range arguments or iterator-sentinel pairs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02dac318248d623e3712f39050dab4b9f4c60683" translate="yes" xml:space="preserve">
          <source>C++20 provides &lt;a href=&quot;language/constraints&quot;&gt;constrained&lt;/a&gt; versions of most algorithms in the namespace &lt;code&gt;std::ranges&lt;/code&gt;. In these algorithms, a range can be specified as either an &lt;a href=&quot;https://en.cppreference.com/mwiki/index.php?title=cpp/iterator/Iterator&amp;amp;action=edit&amp;amp;redlink=1&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt;-&lt;a href=&quot;https://en.cppreference.com/mwiki/index.php?title=cpp/iterator/Sentinel&amp;amp;action=edit&amp;amp;redlink=1&quot;&gt;&lt;code&gt;Sentinel&lt;/code&gt;&lt;/a&gt; pair or as a single &lt;a href=&quot;ranges/range&quot;&gt;&lt;code&gt;Range&lt;/code&gt;&lt;/a&gt; argument, and projections and pointer-to-member callables are supported. Additionally, the return types of most algorithms have been changed to return all potentially useful information computed during the execution of the algorithm.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b22ed7e9c883004117343b0e71726914a2fd2287" translate="yes" xml:space="preserve">
          <source>C++98</source>
          <target state="translated">C++98</target>
        </trans-unit>
        <trans-unit id="ba0489b5be9b76c42ad4405b0950fd7062f9aa6d" translate="yes" xml:space="preserve">
          <source>C++98 standard (ISO/IEC 14882:1998):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f192047d0579fa733e3007a4b4927c4192eec128" translate="yes" xml:space="preserve">
          <source>C, but C precedes A in the single total order C-E-F-A of &lt;code&gt;memory_order_seq_cst&lt;/code&gt; (see &lt;a href=&quot;https://plv.mpi-sws.org/scfix/paper.pdf&quot;&gt;Lahav et al&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f56f539774c9129a13109892792a99de9ce3ec15" translate="yes" xml:space="preserve">
          <source>C-string or char array to use as the contents of the stream</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd39761895022d52ef2184edffb0689497519cb3" translate="yes" xml:space="preserve">
          <source>C-style</source>
          <target state="translated">C-style</target>
        </trans-unit>
        <trans-unit id="7526d60a0c8e276994609ec345feddbe30ee8465" translate="yes" xml:space="preserve">
          <source>C-style &lt;a href=&quot;string/multibyte&quot;&gt; Unicode character conversion functions&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56a020c22140d662b6720ea7925672fd8f454173" translate="yes" xml:space="preserve">
          <source>C-style IO</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44c1448ec5b283e6541ef6028da691d71017b995" translate="yes" xml:space="preserve">
          <source>C-style cast</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2150e9d35b98ece63e7d4b63009872a56f2d872" translate="yes" xml:space="preserve">
          <source>C-style cast expression</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c663a9e8a239cedd93c5da9c15d557da154de974" translate="yes" xml:space="preserve">
          <source>C-style comments are usually used to comment large blocks of text, however, they can be used to comment single lines. To insert a C-style comment, simply surround text with &lt;code&gt;/*&lt;/code&gt; and &lt;code&gt;*/&lt;/code&gt;; this will cause the contents of the comment to be ignored by the compiler. Although it is not part of the C++ standard, &lt;code&gt;/**&lt;/code&gt; and &lt;code&gt;*/&lt;/code&gt; are often used to indicate documentation blocks; this is legal because the second asterisk is simply treated as part of the comment. C-style comments cannot be nested.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48253fbd0ad94c130de734e904780378dbaf86ae" translate="yes" xml:space="preserve">
          <source>C-style date and time library</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f7dc08f72f32281ebb854326effae89b085e12d" translate="yes" xml:space="preserve">
          <source>C-style date and time library (e.g. &lt;code&gt;&lt;a href=&quot;chrono/c/time&quot;&gt;std::time&lt;/a&gt;&lt;/code&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f58953ee114042660a40fb46cdbb6561045fdd9e" translate="yes" xml:space="preserve">
          <source>C-style file input/output</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee69eba17157f0bd643ab8f69127f0bbfedd84dc" translate="yes" xml:space="preserve">
          <source>C-style input-output functions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78e1709449ee6d0679c98c9e988b4d20f58cb3c2" translate="yes" xml:space="preserve">
          <source>C-style memory management</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3df26bb0867d25f5ab994e73d5725e15e0b58b0" translate="yes" xml:space="preserve">
          <source>C-style time/date utilites</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52aea3b6618c4eb66aee74f7ff3b04621de74570" translate="yes" xml:space="preserve">
          <source>C-style variadic functions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24fc58ea2f98cd20a27008421ec7f7e3dfc35435" translate="yes" xml:space="preserve">
          <source>CHAR_BIT</source>
          <target state="translated">CHAR_BIT</target>
        </trans-unit>
        <trans-unit id="725f72738449b33d5ed2db35158ace2f646b043c" translate="yes" xml:space="preserve">
          <source>CHAR_MAX</source>
          <target state="translated">CHAR_MAX</target>
        </trans-unit>
        <trans-unit id="b30c9342a5465cef0a56934460b3bfa4e2e74c49" translate="yes" xml:space="preserve">
          <source>CHAR_MIN</source>
          <target state="translated">CHAR_MIN</target>
        </trans-unit>
        <trans-unit id="c820f67f5827175c8c204a8b983dc8a39b93cac1" translate="yes" xml:space="preserve">
          <source>CIRCLED DIGIT ONE - NEGATIVE CIRCLED DIGIT ZERO</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fff8f67cf9fc327818272d81ae72e6f4b9164d0a" translate="yes" xml:space="preserve">
          <source>CJK COMPATIBILITY IDEOGRAPH-F900 - ARABIC LIGATURE ALEF WITH FATHATAN ISOLATED FORM</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="190e1ea5952f0d388e456800d46304578b3a93e8" translate="yes" xml:space="preserve">
          <source>CJK RADICAL REPEAT - IDEOGRAPHIC DESCRIPTION CHARACTER OVERLAID</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="789b032a45d264e7a02138bff69b47aacb370fca" translate="yes" xml:space="preserve">
          <source>CLOCKS_PER_SEC</source>
          <target state="translated">CLOCKS_PER_SEC</target>
        </trans-unit>
        <trans-unit id="8b6654ec4bc3d0c514cc6e4b4ad72a0db37a1444" translate="yes" xml:space="preserve">
          <source>COMBINING DOTTED GRAVE ACCENT - COMBINING RIGHT ARROWHEAD AND DOWN ARROWHEAD BELOW</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="714ab47a0e6f413b3bf281d1f4cbe410847fe7f1" translate="yes" xml:space="preserve">
          <source>COMBINING GRAVE ACCENT - COMBINING LATIN SMALL LETTER X</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="35575c776ae958fb9883f5bf9ba9b6cfaf676fb9" translate="yes" xml:space="preserve">
          <source>COMBINING LEFT HARPOON ABOVE - COMBINING ASTERISK ABOVE</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7febb4b03096c80654f363847dc95a2cfb84fefe" translate="yes" xml:space="preserve">
          <source>COMBINING LIGATURE LEFT HALF - COMBINING CYRILLIC TITLO RIGHT HALF</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9560447a54fd74d0cf86900665e48394b8c2274d" translate="yes" xml:space="preserve">
          <source>CPL</source>
          <target state="translated">CPL</target>
        </trans-unit>
        <trans-unit id="b24be71613a88ae74ef2222af07f1f8532a2eb06" translate="yes" xml:space="preserve">
          <source>CRTP</source>
          <target state="translated">CRTP</target>
        </trans-unit>
        <trans-unit id="a59d9bcee7f8794c67d0f8eaac8b827616f73808" translate="yes" xml:space="preserve">
          <source>CTAD</source>
          <target state="translated">CTAD</target>
        </trans-unit>
        <trans-unit id="47563e02f34b97527aa11cd2660b1c531f28a7a0" translate="yes" xml:space="preserve">
          <source>CWG 1213</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b2c33f3b2901add653231f28b9837371837d438" translate="yes" xml:space="preserve">
          <source>CWG 1301</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ffd78fdcfc97704227c81ed211b654ae584f03c" translate="yes" xml:space="preserve">
          <source>CWG 1313</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e72262c1f7923c69acd5b6e632a6ea0b0ee13223" translate="yes" xml:space="preserve">
          <source>CWG 1315</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74b12783757c5081b7fb53b3cd6b878928af8eae" translate="yes" xml:space="preserve">
          <source>CWG 1391</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9e49fbd701bbcdc956dcedc347ee4c2dab0f2ed" translate="yes" xml:space="preserve">
          <source>CWG 1394</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4fb7724609c8a8b0dcca0bada49c63e843cf4195" translate="yes" xml:space="preserve">
          <source>CWG 1395</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7154988f61117199c76a049798a28cf90de02420" translate="yes" xml:space="preserve">
          <source>CWG 1397</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b449890ac0834487b5eaf123c275fd35b1137504" translate="yes" xml:space="preserve">
          <source>CWG 1423</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a7b9cc74202f3c29fa36c900f6ba27c585313fc" translate="yes" xml:space="preserve">
          <source>CWG 1458</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40d23e9f1ab69a460e82608189870f9b5cac5e51" translate="yes" xml:space="preserve">
          <source>CWG 1467</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9c41df53bb29177228be09033e92e1deef54502" translate="yes" xml:space="preserve">
          <source>CWG 1550</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2749cb8bd08487f07f57b026d7f0a32906248fc7" translate="yes" xml:space="preserve">
          <source>CWG 1558</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1930e406ede3e006c8d9aac6e7043f5d94676955" translate="yes" xml:space="preserve">
          <source>CWG 1560</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6ba8d164871c6a798203d13dfcb1e6e4da6da78" translate="yes" xml:space="preserve">
          <source>CWG 1579</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73c5f99cc638773086e35615fade4d4947d1d60e" translate="yes" xml:space="preserve">
          <source>CWG 1591</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="735a2e213b861827190fdf465dd014f41f1f5684" translate="yes" xml:space="preserve">
          <source>CWG 1601</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f698a022a799e476a4b5d90908c4f0968039b3a4" translate="yes" xml:space="preserve">
          <source>CWG 1638</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d6075634dd8060a300813233ee99f173cd90be3" translate="yes" xml:space="preserve">
          <source>CWG 1672</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b72ace2ad31c1e2fb91f1346d396608578b35f79" translate="yes" xml:space="preserve">
          <source>CWG 1696</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28347337bf2cc1f1919d510e1adbb168425a77c2" translate="yes" xml:space="preserve">
          <source>CWG 1719</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be03df1470395dcc9eeb7f3194fc4e5a81102ad5" translate="yes" xml:space="preserve">
          <source>CWG 1722</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c7f27ab354ac1a80a384197c76d4e3d24b3a644" translate="yes" xml:space="preserve">
          <source>CWG 1734</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93fb30cfc8e126fb5fe13f8d64ea000c6669b4e0" translate="yes" xml:space="preserve">
          <source>CWG 1781</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75c74907ac6a6383a90bffab070b3ef5f33e6cdb" translate="yes" xml:space="preserve">
          <source>CWG 1813</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2eaa057756492b48b304275aed682a52bf13bef5" translate="yes" xml:space="preserve">
          <source>CWG 1838</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d25ef040ac6f3edbf12f878493bba23ddbf903d" translate="yes" xml:space="preserve">
          <source>CWG 1863</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d31cb5a2e409347064465cd90ecdb5de73cbbcca" translate="yes" xml:space="preserve">
          <source>CWG 1866</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af6cfdd2ae9b748b30376111eb2e1a4d17271d87" translate="yes" xml:space="preserve">
          <source>CWG 1878</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76b6b3653d71fac1420ccfc68013d1df012f6885" translate="yes" xml:space="preserve">
          <source>CWG 1885</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80077256fcd7c8d10a1735e2561b5761dc72781c" translate="yes" xml:space="preserve">
          <source>CWG 1891</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1028a0754e9331957ee9dec60315a06334455543" translate="yes" xml:space="preserve">
          <source>CWG 1895</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="715e6f5a0af4ea83c2adbba2e1c4a84c4cdf4c23" translate="yes" xml:space="preserve">
          <source>CWG 1911</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d59063371cbbf3c50fa4004a2c980a915a5a3712" translate="yes" xml:space="preserve">
          <source>CWG 1932</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fee2040205e11bfb3c90d627d95a3ef1b06bf7c8" translate="yes" xml:space="preserve">
          <source>CWG 1940</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7be04ab603086e1fe7b3d69077927db8d61e60df" translate="yes" xml:space="preserve">
          <source>CWG 195</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="401b02ff04774bdf69dfc351c0fc646e8c52792c" translate="yes" xml:space="preserve">
          <source>CWG 1951</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28c16abcb79a7d2985fffaea2e7091ceaeedcb15" translate="yes" xml:space="preserve">
          <source>CWG 1952</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78e6d54c5d8c416b62b8bc7f6de701b3133dfbaa" translate="yes" xml:space="preserve">
          <source>CWG 1955</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41f749570a89d069549057499232a1cc43471407" translate="yes" xml:space="preserve">
          <source>CWG 1992</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1463942fad687beb04e017d429368db857b7bf10" translate="yes" xml:space="preserve">
          <source>CWG 2004</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24b2f326ff1dbd6e75b7fe0777847a2048e25f64" translate="yes" xml:space="preserve">
          <source>CWG 2012</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a252ff07735443b3b89651fd3662e3f4c3a99e40" translate="yes" xml:space="preserve">
          <source>CWG 2022</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="585fa29096b9165f2e65d4ab7ac3d55d4ccca16d" translate="yes" xml:space="preserve">
          <source>CWG 2026</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8190296876c615aed0b58aa2986f2e3603ff068b" translate="yes" xml:space="preserve">
          <source>CWG 2039</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9fac3c0f458bed3f35cc6e7ea77169bfd642f791" translate="yes" xml:space="preserve">
          <source>CWG 2052</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="905971b8c2ebad4151cef0c505c6db3c3443e509" translate="yes" xml:space="preserve">
          <source>CWG 2082</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a60400639f386cc83b091425fd72478bd78dccb6" translate="yes" xml:space="preserve">
          <source>CWG 2084</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0912de9c62ce2a759dd40ba5c95059625c84704" translate="yes" xml:space="preserve">
          <source>CWG 2091</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97ce1e0c528bfc8a4aee8f304b082d78f3313d15" translate="yes" xml:space="preserve">
          <source>CWG 2094</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb553bbdccad20b58a6287507179e7aaac1138f8" translate="yes" xml:space="preserve">
          <source>CWG 2100</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d55f979aebc02a17a304196dbaedd6e39446715" translate="yes" xml:space="preserve">
          <source>CWG 2120</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57a98d99b6d9403964ab62e7650db4ce2125747b" translate="yes" xml:space="preserve">
          <source>CWG 2137</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e7983e2eff1437835ae2c5af3c0e619bb441ca6" translate="yes" xml:space="preserve">
          <source>CWG 2163</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fab7f39f8b013bbf0a59f2fe8002534da773c8aa" translate="yes" xml:space="preserve">
          <source>CWG 2167</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f873603897faddf9e479a2f3afd854cd91d6381" translate="yes" xml:space="preserve">
          <source>CWG 2171</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe9644b244394c2eabfc31e02ec47a961f67cb01" translate="yes" xml:space="preserve">
          <source>CWG 2176</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="203df293763ce0d669052a6832f14d3fafcf7792" translate="yes" xml:space="preserve">
          <source>CWG 2268</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0654e95544b6a3934ee54bf50137e9773bf4eece" translate="yes" xml:space="preserve">
          <source>CWG 2278</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e706907058df91acb35f56258b08ab09a4a3a70" translate="yes" xml:space="preserve">
          <source>CWG 2387</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82d53da8356c3ca3b92f1c7356ff3db1988d1b75" translate="yes" xml:space="preserve">
          <source>CWG 330</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ccb6c3b42336d94c15bb3870d96c4815af38060e" translate="yes" xml:space="preserve">
          <source>CWG 393</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e15dfefc20dc9707f7b3d7e3bfd742f4ba2fe0e6" translate="yes" xml:space="preserve">
          <source>CWG 45</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a683182b298c47030d15a78fb9455cd68db3f4e1" translate="yes" xml:space="preserve">
          <source>CWG 496</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6a4d2d7852a929bdef3282acacef0950c6827a3" translate="yes" xml:space="preserve">
          <source>CWG 500</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8168079f990033b28ee30baf555b21dac700dbe5" translate="yes" xml:space="preserve">
          <source>CWG 577</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6fc7f7d941214d7e90028d76ec9df5aece8e4b10" translate="yes" xml:space="preserve">
          <source>CWG 613</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65ecce3064605f43be72ea3dd69ca82afaeced68" translate="yes" xml:space="preserve">
          <source>CWG 616</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de85001d3da367b6bc9e3cd052c9bab51ab5abda" translate="yes" xml:space="preserve">
          <source>CWG 727</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1617da0092a5442eeec85cdd1cb1225081fe44bf" translate="yes" xml:space="preserve">
          <source>CWG 903</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af14bcf58f1a68925b0a5504ba2c3fedd31bf275" translate="yes" xml:space="preserve">
          <source>CWG 975</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="883938ab5275fd7f506eef92dcbd07ff4e7d5615" translate="yes" xml:space="preserve">
          <source>Cache size access</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="abd58164af939ff4d9cde0c5a458880ac0375eb1" translate="yes" xml:space="preserve">
          <source>Calculates the length of a null-terminated character sequence, that is, the smallest &lt;code&gt;i&lt;/code&gt; such that &lt;code&gt;p[i]==0&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf186f04df8bd87628a780c3378dd3632fd2a3a3" translate="yes" xml:space="preserve">
          <source>Calculates the phase angle (in radians) of the complex number &lt;code&gt;z&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57f0569da38bf80c03db47109bd43da72eb97f7c" translate="yes" xml:space="preserve">
          <source>Calculates the smallest integral power of two that is not smaller than &lt;code&gt;x&lt;/code&gt;. If that value is not representable in &lt;code&gt;T&lt;/code&gt;, the result is unspecified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="adab5090ac6a1b7b5420faac7be86c41721ba27c" translate="yes" xml:space="preserve">
          <source>Calendar</source>
          <target state="translated">Calendar</target>
        </trans-unit>
        <trans-unit id="77ea7aa743c8ae5ceebe6476bf7df6ad49a72839" translate="yes" xml:space="preserve">
          <source>Call once</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4eba4ac4450eda1340606ecffb5eb5859411715" translate="yes" xml:space="preserve">
          <source>Call signature</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31298f54f958dfd787e62fd18a5dfa0ea246238e" translate="yes" xml:space="preserve">
          <source>Call to a class object</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="788d2b3c20bc6bb4acdf2e12c362e93fcf9f86e9" translate="yes" xml:space="preserve">
          <source>Call to a named function</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25e89ac78843ab3e453d550dab696b1c2685d9c8" translate="yes" xml:space="preserve">
          <source>Call to an overloaded operator</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b55289fd0c473d42c2d6be6391e6a9f53a24056" translate="yes" xml:space="preserve">
          <source>Callable</source>
          <target state="translated">Callable</target>
        </trans-unit>
        <trans-unit id="23d949dfc4bd360aaa190a7d8b95216e5ade27f3" translate="yes" xml:space="preserve">
          <source>Callable concepts</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26f12919d9abcbe806f8a77ed9eb33b55d766a0f" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;back&lt;/code&gt; on an empty container is undefined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff2ffbf673a19e18259ea1cb76992f714681e368" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;back&lt;/code&gt; on an empty span results in undefined behavior.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6717d3aa8431f388fa22c83faef176dba4e916c3" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;front&lt;/code&gt; on an empty container is undefined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b224fd770585fb9a84773057036aa9e7e6d3a7e" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;front&lt;/code&gt; on an empty span results in undefined behavior.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c9aa3a9eae1452c28134c585eb3820a002e81bd" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;pop_back&lt;/code&gt; on an empty container is undefined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3735210d481937108546f459443e5f1fd0f227c2" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;std::snprintf&lt;/code&gt; with zero &lt;code&gt;buf_size&lt;/code&gt; and null pointer for &lt;code&gt;buffer&lt;/code&gt; is useful to determine the necessary buffer size to contain the output:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ca41836763a311e7e3b63538aadbcd41b01f43b" translate="yes" xml:space="preserve">
          <source>Calling a member function of class X on an object of any other type invokes undefined behavior.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b21d6934e73f94ffe04f7672733609014752fd4f" translate="yes" xml:space="preserve">
          <source>Calling any non-const member function of a &lt;code&gt;path&lt;/code&gt; invalidates all iterators referring to elements of that object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6605741078828d4b9eb94a61e28230ca57d44e38" translate="yes" xml:space="preserve">
          <source>Calling non-const member functions on the string, excluding &lt;a href=&quot;operator_at&quot;&gt;&lt;code&gt;operator[]()&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;&lt;a href=&quot;at&quot;&gt;at()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;front&quot;&gt;front()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;back&quot;&gt;back()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;begin&quot;&gt;begin()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;end&quot;&gt;end()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;rbegin&quot;&gt;rbegin()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;rend&quot;&gt;rend()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bfe2bc9fc50f90ff08c540ee75e64a547ec4aa73" translate="yes" xml:space="preserve">
          <source>Calling non-const member functions on the string, excluding &lt;code&gt;&lt;a href=&quot;operator_at&quot;&gt;operator[]&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;at&quot;&gt;at()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;front&quot;&gt;front()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;back&quot;&gt;back()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;begin&quot;&gt;begin()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;rbegin&quot;&gt;rbegin()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;end&quot;&gt;end()&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;rend&quot;&gt;rend()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1590423ec88dccd74976d9c0b4a15cd539e5de0f" translate="yes" xml:space="preserve">
          <source>Calling the function from several threads does not induce a data race. The implementation shall support the registration of at least &lt;code&gt;32&lt;/code&gt; functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae706e35be31c74437d8b879378de31abca1e947" translate="yes" xml:space="preserve">
          <source>Calling this function if &lt;a href=&quot;../unique_lock/mutex&quot;&gt;&lt;code&gt;lock.mutex()&lt;/code&gt;&lt;/a&gt; is not locked by the current thread is undefined behavior.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75bbd4aac5cc1d989e699d782da569785e80372d" translate="yes" xml:space="preserve">
          <source>Calling this function if &lt;a href=&quot;../unique_lock/mutex&quot;&gt;&lt;code&gt;lock.mutex()&lt;/code&gt;&lt;/a&gt; is not the same mutex as the one used by all other threads that are currently waiting on the same condition variable is undefined behavior.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4dc1176c569db8cabf9eb9a19f697b5eace8b739" translate="yes" xml:space="preserve">
          <source>Calling this function if &lt;code&gt;lock.mutex()&lt;/code&gt; is not locked by the current thread is undefined behavior.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59ddebba5c0c5f3cf16d2db3348b2a06ea675f9c" translate="yes" xml:space="preserve">
          <source>Calling this function if &lt;code&gt;lock.mutex()&lt;/code&gt; is not the same mutex as the one used by all other threads that are currently waiting on the same condition variable is undefined behavior.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca1101d4e72ebfdcdf0ad75bb31490874ef21229" translate="yes" xml:space="preserve">
          <source>Calling wait on the same &lt;code&gt;std::shared_future&lt;/code&gt; from multiple threads is not safe; the intended use is for each thread that waits on the same shared state to have a copy of a &lt;code&gt;std::shared_future&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7fe2219fd2346b0443d87479d3d6381482c45d02" translate="yes" xml:space="preserve">
          <source>Calls &lt;a href=&quot;emit&quot;&gt;&lt;code&gt;emit()&lt;/code&gt;&lt;/a&gt; to transmit all pending output (and delayed flush, if any) to the wrapped stream. If an exception is thrown by this call, it is caught and ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7211e6009a18f7a09fbc9ac46b8a624714b4410" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;::&lt;a href=&quot;../new/operator_delete&quot;&gt;operator delete&lt;/a&gt;(void*)&lt;/code&gt;or &lt;code&gt;::&lt;a href=&quot;../new/operator_delete&quot;&gt;operator delete&lt;/a&gt;(void*, &lt;a href=&quot;../new/align_val_t&quot;&gt;std::align_val_t&lt;/a&gt;)&lt;/code&gt;(since C++17), but it is unspecified when and how it is called.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d77a5af1e4348b5987265920ffaec5aa8d151398" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;&lt;a href=&quot;close&quot;&gt;close()&lt;/a&gt;&lt;/code&gt; to close the associated file and destructs all other members of &lt;code&gt;basic_filebuf&lt;/code&gt;. If an exception is thrown by &lt;code&gt;&lt;a href=&quot;close&quot;&gt;close()&lt;/a&gt;&lt;/code&gt;, it is caught and not rethrown.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36548e9702a28bd62ee76fcd892dc9bc23d3cf34" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;&lt;a href=&quot;freeze&quot;&gt;freeze()&lt;/a&gt;&lt;/code&gt;, then returns a copy of start pointer of the get area, &lt;code&gt;&lt;a href=&quot;../basic_streambuf/gptr&quot;&gt;std::streambuf::eback()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5eeb168b574d3d4c252825f4a3753f9379de82e" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;basic_ios::swap(rhs)&lt;/code&gt; to swap all data members of the base class except for &lt;code&gt;rdbuf()&lt;/code&gt;, and swaps the values of the &lt;code&gt;gcount()&lt;/code&gt; counters between &lt;code&gt;*this&lt;/code&gt; and &lt;code&gt;rhs&lt;/code&gt;. This swap function is protected: it is called by the swap functions of the swappable input stream classes &lt;code&gt;&lt;a href=&quot;../basic_ifstream&quot;&gt;std::basic_ifstream&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../basic_istringstream&quot;&gt;std::basic_istringstream&lt;/a&gt;&lt;/code&gt;, which know how to correctly swap the associated streambuffers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ac56e091391242bbdc4ad807edc846cff28d837" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;basic_ios::swap(rhs)&lt;/code&gt; to swap all data members of the base class, except for &lt;code&gt;rdbuf()&lt;/code&gt;, between &lt;code&gt;*this&lt;/code&gt; and &lt;code&gt;rhs&lt;/code&gt;. This swap function is protected: it is called by the swap functions of the swappable output stream classes &lt;code&gt;&lt;a href=&quot;../basic_ofstream&quot;&gt;std::basic_ofstream&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../basic_ostringstream&quot;&gt;std::basic_ostringstream&lt;/a&gt;&lt;/code&gt;, which know how to correctly swap the associated streambuffers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3dc184d2193e1837c7b1ab6ae910b4a5a68b463" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;clear()&lt;/code&gt; on success.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3934f9f9eebfbb559e3c31093566b7ed8b1d4ffc" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;setstate(failbit)&lt;/code&gt; on failure.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2c103774ce296202589b581a39e2733fbd14eeb" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;swap&lt;/code&gt; (which might be &lt;code&gt;&lt;a href=&quot;../../algorithm/swap&quot;&gt;std::swap&lt;/a&gt;&lt;/code&gt;, or might be found via ADL) for each element in &lt;code&gt;*this&lt;/code&gt; and its corresponding element in &lt;code&gt;other&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="481431a2735414dcd8592892b784b43366935f35" translate="yes" xml:space="preserve">
          <source>Calls the &lt;a href=&quot;../../../named_req/callable&quot;&gt;Callable&lt;/a&gt; object, reference to which is stored. This function is available only if the stored reference points to a &lt;a href=&quot;../../../named_req/callable&quot;&gt;Callable&lt;/a&gt; object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0bbf1dcddfa6e1ab86b5f404a8df59c3e805b815" translate="yes" xml:space="preserve">
          <source>Calls the appropriate extraction operator, given an rvalue reference to an input stream object (equivalent to &lt;code&gt;st &amp;gt;&amp;gt; &lt;a href=&quot;../../utility/forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;T&amp;gt;(value)&lt;/code&gt;). This function does not participate in overload resolution unless the expression &lt;code&gt;st &amp;gt;&amp;gt; &lt;a href=&quot;../../utility/forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;T&amp;gt;(value)&lt;/code&gt; is well-formed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c48a860ccae7d78225a13d6988e12c01b392911" translate="yes" xml:space="preserve">
          <source>Calls the appropriate extraction operator, given an rvalue reference to an input stream object (equivalent to &lt;code&gt;st &amp;gt;&amp;gt; value&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b5b7a129b3ced37543947e6912ecc3cecfa84d6" translate="yes" xml:space="preserve">
          <source>Calls the destructor of the object pointed to by &lt;code&gt;p&lt;/code&gt;, as if by &lt;code&gt;p-&amp;gt;~T()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b405a9cd2b966c4bc34d98cc6f9f7cf4e95fe857" translate="yes" xml:space="preserve">
          <source>Calls the destructor of the object pointed to by &lt;code&gt;p&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78b1409922d2e4a9785fcea7996d5ce02b31a4ce" translate="yes" xml:space="preserve">
          <source>Calls the destructor of the object pointed to by &lt;code&gt;p&lt;/code&gt;. If possible, does so by calling &lt;code&gt;a.destroy(p)&lt;/code&gt;. If not possible (e.g. &lt;code&gt;a&lt;/code&gt; does not have the member function &lt;code&gt;destroy()&lt;/code&gt;), then calls the destructor of &lt;code&gt;*p&lt;/code&gt; directly, as &lt;code&gt;p-&amp;gt;~T()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d65d02c76675e1ef2e0ab59d434954fbf4aab1b9" translate="yes" xml:space="preserve">
          <source>Calls the function named &lt;code&gt;swap()&lt;/code&gt; found by overload resolution among all functions with that name that are found by &lt;a href=&quot;../language/adl&quot;&gt;argument-dependent lookup&lt;/a&gt; and the two &lt;code&gt;&lt;a href=&quot;../algorithm/swap&quot;&gt;std::swap&lt;/a&gt;&lt;/code&gt; templates defined in the header &lt;code&gt;&amp;lt;utility&amp;gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb046b6586e057bb9aae9a1e6bfffa31963ec5ed" translate="yes" xml:space="preserve">
          <source>Calls the host environment's command processor (e.g. &lt;code&gt;/bin/sh&lt;/code&gt;, &lt;code&gt;cmd.exe&lt;/code&gt;, &lt;code&gt;command.com&lt;/code&gt;) with the parameter &lt;code&gt;command&lt;/code&gt;. Returns an implementation-defined value (usually the value that the invoked program returns).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b26b8306a6c31504edbc512428e1a837332ab1bd" translate="yes" xml:space="preserve">
          <source>Calls the stored function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="afca4766bb42b40e6c34338087393e97b7c59c19" translate="yes" xml:space="preserve">
          <source>Calls the stored task with &lt;code&gt;args&lt;/code&gt; as the arguments. The return value of the task or any exceptions thrown are stored in the shared state. The shared state is made ready and any threads waiting for this are unblocked.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd90a8cace7a8f14fa555e29a7e7953fe85896a1" translate="yes" xml:space="preserve">
          <source>Calls the stored task with forwarded &lt;code&gt;args&lt;/code&gt; as the arguments. The return value of the task or any exception thrown by it is stored in the shared state of &lt;code&gt;*this&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ee1a97db496e5e5a537daa1da0e2cec32168671" translate="yes" xml:space="preserve">
          <source>Calls to &lt;a href=&quot;synchronized_pool_resource/do_allocate&quot;&gt;&lt;code&gt;do_allocate&lt;/code&gt;&lt;/a&gt; are dispatched to the pool serving the smallest blocks accommodating the requested size.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40a3a9a4b8f56ea0c9cc9b74ebd031cfe3acb404" translate="yes" xml:space="preserve">
          <source>Calls to &lt;a href=&quot;unsynchronized_pool_resource/do_allocate&quot;&gt;&lt;code&gt;do_allocate&lt;/code&gt;&lt;/a&gt; are dispatched to the pool serving the smallest blocks accommodating the requested size.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2bc1581a9b7b77d7540b30aeb4545a58a025742b" translate="yes" xml:space="preserve">
          <source>Calls to &lt;code&gt;Allocator::allocate&lt;/code&gt; may throw.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e921f3a7ab8c6ee7f214b9ae25dfd4e6dac7ed9" translate="yes" xml:space="preserve">
          <source>Calls to &lt;code&gt;c8rtomb&lt;/code&gt; with a null pointer argument for &lt;code&gt;s&lt;/code&gt; may introduce a data race with other calls to &lt;code&gt;c8rtomb&lt;/code&gt; with a null pointer argument for &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="842bfa338f91c208278bfed4b504f42e1234ae0a" translate="yes" xml:space="preserve">
          <source>Calls to const member functions of the distribution and &lt;code&gt;os &amp;lt;&amp;lt; d&lt;/code&gt; do not affect the sequence of numbers produced by repeated &lt;code&gt;d(g)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f6bda6c551be6982977241156d440ef692185ef" translate="yes" xml:space="preserve">
          <source>Calls to these functions that allocate or deallocate a particular unit of storage occur in a single total order, and each such deallocation call &lt;a href=&quot;../../atomic/memory_order&quot;&gt;happens-before&lt;/a&gt; the next allocation (if any) in this order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7f6d16e4b3fb1f8e6d8ebfda2e4deaa82522158" translate="yes" xml:space="preserve">
          <source>Calls to this function do not introduce data races with calls to &lt;code&gt;&lt;a href=&quot;get_future&quot;&gt;get_future&lt;/a&gt;&lt;/code&gt; (but they need not synchronize with each other).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e8b087d01af0042b03fbd3b40cf94cd4b629f74" translate="yes" xml:space="preserve">
          <source>Calls to this function do not introduce data races with calls to &lt;code&gt;&lt;a href=&quot;set_value&quot;&gt;set_value&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;set_exception&quot;&gt;set_exception&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;set_value_at_thread_exit&quot;&gt;set_value_at_thread_exit&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;set_exception_at_thread_exit&quot;&gt;set_exception_at_thread_exit&lt;/a&gt;&lt;/code&gt; (but they need not synchronize with each other).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="978f12bb4868b3da1bd6017109c32a97b6cc062a" translate="yes" xml:space="preserve">
          <source>Can be used to iterate through a single bucket</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0754caffdf7dc1f3c428a31d5458447d8f2078b5" translate="yes" xml:space="preserve">
          <source>Can be variadic as well</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32df764f4a004f4803750cb06a6e1038b85f5ab0" translate="yes" xml:space="preserve">
          <source>Can throw the exceptions thrown from &lt;code&gt;Alloc::allocate()&lt;/code&gt; or from the constructor of &lt;code&gt;T&lt;/code&gt;. If an exception is thrown, (1) has no effect. If an exception is thrown during the construction of the array, already-initialized elements are destroyed in reverse order(since C++20).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4c126ec0c1d28e21fc971d14fbf29c30650c27c" translate="yes" xml:space="preserve">
          <source>Candidate functions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a1ea5de25db4a707e5b97c9c93167ca46913fc0" translate="yes" xml:space="preserve">
          <source>Cannot be called and thus never returns a value. The return type is &lt;code&gt;T&amp;amp;&amp;amp;&lt;/code&gt; unless &lt;code&gt;T&lt;/code&gt; is (possibly cv-qualified) &lt;code&gt;void&lt;/code&gt;, in which case the return type is &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a47709738a13682382a8bb47d1c3c176fb6cf434" translate="yes" xml:space="preserve">
          <source>Canonical implementations</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca09c54bff74a82bae543ebe259f7452ee8c5293" translate="yes" xml:space="preserve">
          <source>Capabilities</source>
          <target state="translated">Capabilities</target>
        </trans-unit>
        <trans-unit id="45bd908df490edd79694ba0daff82fc092970b55" translate="yes" xml:space="preserve">
          <source>Capacity</source>
          <target state="translated">Capacity</target>
        </trans-unit>
        <trans-unit id="8c8a5e126ef7ec6a6ad77d0edf96fa8a146e07ff" translate="yes" xml:space="preserve">
          <source>Capacity of the currently allocated storage.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b17823bc1728ea261d27feb54556ae24540f0e72" translate="yes" xml:space="preserve">
          <source>Capture and storage of exception objects</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc6500dd683ae5c40011f02be84c903248d14d1b" translate="yes" xml:space="preserve">
          <source>Capturing the result of &lt;code&gt;std::clamp&lt;/code&gt; by reference if one of the parameters is rvalue produces a dangling reference if that parameter is returned:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f412180178dea3bf686bb7206b2a1c6f412f169f" translate="yes" xml:space="preserve">
          <source>Capturing the result of &lt;code&gt;std::max&lt;/code&gt; by reference if one of the parameters is rvalue produces a dangling reference if that parameter is returned:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37013b98a907be74378196d00c40398eaed52529" translate="yes" xml:space="preserve">
          <source>Capturing the result of &lt;code&gt;std::min&lt;/code&gt; by reference if one of the parameters is rvalue produces a dangling reference if that parameter is returned:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aeac558c74f367c4d77b33a3b991b9293571a506" translate="yes" xml:space="preserve">
          <source>Care should be taken when using &lt;code&gt;enable_if&lt;/code&gt; in the type of a template non-type parameter of a namespace-scope function template. Some ABI specifications like the Itanium ABI do not include the instantiation-dependent portions of non-type template parameters in the mangling, meaning that specializations of two distinct function templates might end up with the same mangled name and be erroneously linked together. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bbfb9c69143915569ecc52059ab10ea7a1d14360" translate="yes" xml:space="preserve">
          <source>Careful use of &lt;code&gt;emplace&lt;/code&gt; allows the new element to be constructed while avoiding unnecessary copy or move operations. The constructor of the new element (i.e. &lt;code&gt;&lt;a href=&quot;../../utility/pair&quot;&gt;std::pair&lt;/a&gt;&amp;lt;const Key, T&amp;gt;&lt;/code&gt;) is called with exactly the same arguments as supplied to &lt;code&gt;emplace&lt;/code&gt;, forwarded via &lt;code&gt;&lt;a href=&quot;../../utility/forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;Args&amp;gt;(args)...&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52b9bfebd40c006ea3917327fed74d66704c9687" translate="yes" xml:space="preserve">
          <source>Careful use of &lt;code&gt;emplace&lt;/code&gt; allows the new element to be constructed while avoiding unnecessary copy or move operations. The constructor of the new element (i.e. &lt;code&gt;&lt;a href=&quot;../../utility/pair&quot;&gt;std::pair&lt;/a&gt;&amp;lt;const Key, T&amp;gt;&lt;/code&gt;) is called with exactly the same arguments as supplied to &lt;code&gt;emplace&lt;/code&gt;, forwarded via &lt;code&gt;&lt;a href=&quot;../../utility/forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;Args&amp;gt;(args)...&lt;/code&gt;. The element may be constructed even if there already is an element with the key in the container, in which case the newly constructed element will be destroyed immediately.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4714de10bb9278addf37bd8e9cf61fba91ba9335" translate="yes" xml:space="preserve">
          <source>Careful use of &lt;code&gt;emplace&lt;/code&gt; allows the new element to be constructed while avoiding unnecessary copy or move operations. The constructor of the new element is called with exactly the same arguments as supplied to &lt;code&gt;emplace&lt;/code&gt;, forwarded via &lt;code&gt;&lt;a href=&quot;../../utility/forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;Args&amp;gt;(args)...&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d62f1320fbf353fbac4ea498ae530ee45805f5d" translate="yes" xml:space="preserve">
          <source>Careful use of &lt;code&gt;emplace&lt;/code&gt; allows the new element to be constructed while avoiding unnecessary copy or move operations. The constructor of the new element is called with exactly the same arguments as supplied to &lt;code&gt;emplace&lt;/code&gt;, forwarded via &lt;code&gt;&lt;a href=&quot;../../utility/forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;Args&amp;gt;(args)...&lt;/code&gt;. The element may be constructed even if there already is an element with the key in the container, in which case the newly constructed element will be destroyed immediately.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ba8ece0eb57ce634431d006ebb786d69e1c0fb8" translate="yes" xml:space="preserve">
          <source>Carries dependency</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="349f4b2217e91ab2d1ba3827cff21266a8c0e7bc" translate="yes" xml:space="preserve">
          <source>Case 1: binding an array</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56f64fdbefc9674a22cdd908d97b4da3d5e9aac5" translate="yes" xml:space="preserve">
          <source>Case 1: if &lt;code&gt;&lt;i&gt;E&lt;/i&gt;&lt;/code&gt; is an array type, then the names are bound to the array elements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8fc50ba85c9e0bf4533570a0c18a73541e34b19c" translate="yes" xml:space="preserve">
          <source>Case 2: binding a tuple-like type</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a28b6bd53fab5c5518781c66d9367f259e8a1a8b" translate="yes" xml:space="preserve">
          <source>Case 2: if &lt;code&gt;&lt;i&gt;E&lt;/i&gt;&lt;/code&gt; is a non-union class type and &lt;code&gt;&lt;a href=&quot;../utility/tuple/tuple_size&quot;&gt;std::tuple_size&lt;/a&gt;&amp;lt;E&amp;gt;&lt;/code&gt; is a complete type, then the &quot;tuple-like&quot; binding protocol is used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="511322fb92a18ad6c803db32b44850aa3b21431d" translate="yes" xml:space="preserve">
          <source>Case 3: binding to data members</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6570c00b51cbb8acf7b8685b39e65082f79bd7f" translate="yes" xml:space="preserve">
          <source>Case 3: if &lt;code&gt;&lt;i&gt;E&lt;/i&gt;&lt;/code&gt; is a non-union class type but &lt;code&gt;&lt;a href=&quot;../utility/tuple/tuple_size&quot;&gt;std::tuple_size&lt;/a&gt;&amp;lt;E&amp;gt;&lt;/code&gt; is not a complete type, then the names are bound to the accessible data members of &lt;code&gt;&lt;i&gt;E&lt;/i&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74473f63620ac45f2911b86a7f11c6501a7660cd" translate="yes" xml:space="preserve">
          <source>Cast and assignment strip away any extraneous range and precision: this models the action of storing a value from an extended-precision FPU register into a standard-sized memory location.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8107a9770cf1c808e1686a8e8b7cced06eac8bfc" translate="yes" xml:space="preserve">
          <source>Casting between integer durations where the source period is exactly divisible by the target period (e.g. hours to minutes) or between floating-point durations can be performed with ordinary casts or implicitly via &lt;a href=&quot;duration&quot;&gt;std::chrono::duration constructors&lt;/a&gt;, no &lt;code&gt;duration_cast&lt;/code&gt; is needed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f784c0dfdd40d5aecdcc755d6d0d02557b2aa7e" translate="yes" xml:space="preserve">
          <source>Casting from a floating-point duration to an integer duration is &lt;a href=&quot;../../language/implicit_cast#Floating_-_integral_conversions&quot;&gt;subject to undefined behavior&lt;/a&gt; when the floating-point value is NaN, infinity, or too large to be representable by the target's integer type. Otherwise, casting to an integer duration is subject to truncation as with any static_cast to an integer type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1bd210bf015301c8468da6b036f05fe262ff0f0" translate="yes" xml:space="preserve">
          <source>Catch clause of a function-try block</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3c686e711e4720f99b4562bb3dbaae7ab658cf2" translate="yes" xml:space="preserve">
          <source>Category</source>
          <target state="translated">Category</target>
        </trans-unit>
        <trans-unit id="8610c7e6c1a1322fdf2ebc74043f66b624b393a8" translate="yes" xml:space="preserve">
          <source>Causes abnormal program termination unless &lt;code&gt;&lt;a href=&quot;sig_types&quot;&gt;SIGABRT&lt;/a&gt;&lt;/code&gt; is being caught by a signal handler passed to &lt;code&gt;&lt;a href=&quot;signal&quot;&gt;std::signal&lt;/a&gt;&lt;/code&gt; and the handler does not return.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5fc98a179eaefefc7383473561adf59469b047c" translate="yes" xml:space="preserve">
          <source>Causes normal program termination to occur without completely cleaning the resources.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03d84237d77c18a1ea9454f00c0d5a2c4def6e6a" translate="yes" xml:space="preserve">
          <source>Causes normal program termination to occur.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1f612c1cf7abef4418592e6cc6efbf397106128" translate="yes" xml:space="preserve">
          <source>Causes reallocation if the new &lt;code&gt;&lt;a href=&quot;size&quot;&gt;size()&lt;/a&gt;&lt;/code&gt; is greater than the old &lt;code&gt;&lt;a href=&quot;capacity&quot;&gt;capacity()&lt;/a&gt;&lt;/code&gt;. If the new &lt;code&gt;&lt;a href=&quot;size&quot;&gt;size()&lt;/a&gt;&lt;/code&gt; is greater than &lt;code&gt;&lt;a href=&quot;capacity&quot;&gt;capacity()&lt;/a&gt;&lt;/code&gt;, all iterators and references are invalidated. Otherwise, only the iterators and references before the insertion point remain valid. The past-the-end iterator is also invalidated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b3b922a89d7fd2178e02a2f975053d39cd95e01" translate="yes" xml:space="preserve">
          <source>Causes the enclosing &lt;a href=&quot;for&quot;&gt;for&lt;/a&gt;, &lt;a href=&quot;range-for&quot;&gt;range-for&lt;/a&gt;, &lt;a href=&quot;while&quot;&gt;while&lt;/a&gt; or &lt;a href=&quot;do&quot;&gt;do-while&lt;/a&gt; loop or &lt;a href=&quot;switch&quot;&gt; switch statement&lt;/a&gt; to terminate.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c910b43d8c16258ce3d66377f217e9ecf4da3d0f" translate="yes" xml:space="preserve">
          <source>Causes the remaining portion of the enclosing &lt;a href=&quot;for&quot;&gt;for&lt;/a&gt;, &lt;a href=&quot;range-for&quot;&gt;range-for&lt;/a&gt;, &lt;a href=&quot;while&quot;&gt;while&lt;/a&gt; or &lt;a href=&quot;do&quot;&gt; do-while&lt;/a&gt; loop body to be skipped.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2cc09c65ee94e9da20a5da53ff7a1764aa2d212" translate="yes" xml:space="preserve">
          <source>Certain &lt;a href=&quot;operator_arithmetic#Additive_operators&quot;&gt;addition, subtraction&lt;/a&gt;, &lt;a href=&quot;operator_incdec&quot;&gt;increment, and decrement&lt;/a&gt; operators are defined for pointers to elements of arrays: such pointers satisfy the &lt;a href=&quot;../named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIterator&lt;/a&gt; requirements and allow the C++ library &lt;a href=&quot;../algorithm&quot;&gt;algorithms&lt;/a&gt; to work with raw arrays.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16ced4992002374e1ee48c60ab57aa3dd53629bb" translate="yes" xml:space="preserve">
          <source>Certain words in a C++ program have special meaning, and these are known as &lt;a href=&quot;../keywords&quot;&gt;keywords&lt;/a&gt;. Others can be used as &lt;a href=&quot;name&quot;&gt;identifiers&lt;/a&gt;. &lt;a href=&quot;../comments&quot;&gt;Comments&lt;/a&gt; are ignored during translation. Certain characters in the program have to be represented with &lt;a href=&quot;escape&quot;&gt;escape sequences&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="191f1780427cc9f433fedbcd960fd714be286f24" translate="yes" xml:space="preserve">
          <source>Change the return type of the &lt;code&gt;&lt;a href=&quot;container/list/remove&quot;&gt;remove()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;container/list/remove&quot;&gt;remove_if()&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;container/list/unique&quot;&gt;unique()&lt;/a&gt;&lt;/code&gt; members of &lt;code&gt;&lt;a href=&quot;container/forward_list&quot;&gt;std::forward_list&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;container/list&quot;&gt;std::list&lt;/a&gt;&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a51058c46332744397288d2669e24ba920dc2025" translate="yes" xml:space="preserve">
          <source>Changes access permissions of the file to which &lt;code&gt;p&lt;/code&gt; resolves, as if by POSIX &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/fchmodat.html&quot;&gt;fchmodat&lt;/a&gt;. Symlinks are followed unless &lt;code&gt;perm_options::nofollow&lt;/code&gt; is set in &lt;code&gt;opts&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d059f7f607e7b98754449b95b9c9f18d224be17e" translate="yes" xml:space="preserve">
          <source>Changes the associated locale so that all characters inserted or extracted after this call (and until another call to &lt;code&gt;imbue()&lt;/code&gt;) are converted using the &lt;code&gt;&lt;a href=&quot;../../locale/codecvt&quot;&gt;std::codecvt&lt;/a&gt;&lt;/code&gt; facet of &lt;code&gt;loc&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59519c86c11d2513037e609c3becf73e19a3102f" translate="yes" xml:space="preserve">
          <source>Changes the associated locale.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1931e70aa0ae325fe795a9e9d024fe1264be193" translate="yes" xml:space="preserve">
          <source>Changes the contained object to one of type &lt;code&gt;&lt;a href=&quot;../../types/decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;ValueType&amp;gt;&lt;/code&gt; constructed from the arguments.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7260987e96fdc55dd04ca01a135da1cbdd6808b1" translate="yes" xml:space="preserve">
          <source>Changes the current emit-on-sync policy.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="900063105ed808c1839aeda96993e8913c65dcff" translate="yes" xml:space="preserve">
          <source>Changes the current file name and number in the preprocessor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bcd3bc7bc25f117f48576a1067f3eab87dc09962" translate="yes" xml:space="preserve">
          <source>Changes the filename of a file. The file is identified by character string pointed to by &lt;code&gt;old_filename&lt;/code&gt;. The new filename is identified by character string pointed to by &lt;code&gt;new_filename&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a983560b5611c7eaf3bbb1134baa772fadd17a2a" translate="yes" xml:space="preserve">
          <source>Changes the filename of the directory entry.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15ca90f2bd5d157747f2bcfd7fd13098d9365990" translate="yes" xml:space="preserve">
          <source>Changes the output format.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="028cce033fce6f33e2a026dffc3790dff3f7ae1a" translate="yes" xml:space="preserve">
          <source>Changes the size of the regular file named by &lt;code&gt;p&lt;/code&gt; as if by POSIX &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/truncate.html&quot;&gt;truncate&lt;/a&gt;: if the file size was previously larger than &lt;code&gt;new_size&lt;/code&gt;, the remainder of the file is discarded. If the file was previously smaller than &lt;code&gt;new_size&lt;/code&gt;, the file size is increased and the new area appears as if zero-filled.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f1702f311546e930d8f583ff60c5b7dafb56f91" translate="yes" xml:space="preserve">
          <source>Changes the the buffering mode of the given file stream &lt;code&gt;stream&lt;/code&gt; as indicated by the argument &lt;code&gt;mode&lt;/code&gt;. In addition,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db66637e4bd602383b9a36e093d02ad744d50d19" translate="yes" xml:space="preserve">
          <source>CharT</source>
          <target state="translated">CharT</target>
        </trans-unit>
        <trans-unit id="075d1aa22da1d1a791ea28f036dd3029899ef7df" translate="yes" xml:space="preserve">
          <source>CharTarray&lt;code&gt;[&lt;/code&gt;n&lt;code&gt;]&lt;/code&gt;&lt;code&gt;= &quot;&quot;;&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a40d3a3e7cab1d5912b21bb9180e2c135f3d1b0" translate="yes" xml:space="preserve">
          <source>CharTraits</source>
          <target state="translated">CharTraits</target>
        </trans-unit>
        <trans-unit id="ea0427dd5d6f2fd22fb387a84f007ebffee5c102" translate="yes" xml:space="preserve">
          <source>CharTraits is required by the following standard library class templates as a template type parameter:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f52782a792cc00d2892c8162c4d20455ac882bd" translate="yes" xml:space="preserve">
          <source>CharTraits is satisfied by the following standard library classes:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee9946c82d4a077c5be79e3015a3d2479d9fcaf2" translate="yes" xml:space="preserve">
          <source>Character</source>
          <target state="translated">Character</target>
        </trans-unit>
        <trans-unit id="f72882235ad60f37016237d8303fb8c1162e42f0" translate="yes" xml:space="preserve">
          <source>Character and character string arguments (e.g., of type &lt;code&gt;char&lt;/code&gt; or &lt;code&gt;const char*&lt;/code&gt;) are handled by the &lt;a href=&quot;operator_ltlt2&quot;&gt;non-member overloads&lt;/a&gt; of &lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt;. Attempting to output a character using the member function call syntax (e.g., &lt;code&gt;&lt;a href=&quot;../cout&quot;&gt;std::cout&lt;/a&gt;.operator&amp;lt;&amp;lt;('c');&lt;/code&gt;) will call one of overloads (2-4) and output the numerical value. Attempting to output a character string using the member function call syntax will call overload (7) and print the pointer value instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6512adfeb2b6b71a8085a0b4569a9025105f6ea1" translate="yes" xml:space="preserve">
          <source>Character array manipulation</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6c2fd1aae71d170866344f96ee158518de8bbea" translate="yes" xml:space="preserve">
          <source>Character arrays</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11a965778572465b297760373bc0ab9a5fe50dd4" translate="yes" xml:space="preserve">
          <source>Character classification</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e46fee36b88268f4391d4aab452946b36ee208f" translate="yes" xml:space="preserve">
          <source>Character conversions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea3303247b226441481c96408e89f86363fc056f" translate="yes" xml:space="preserve">
          <source>Character converted to &lt;code&gt;char_type&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c75ca2fc8c1a6a863ef50c02a9cfe0d0c2a00888" translate="yes" xml:space="preserve">
          <source>Character converted to its standard equivalent and then to &lt;code&gt;char&lt;/code&gt;. &lt;code&gt;dfault&lt;/code&gt; is returned if the conversion fails.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71abf6f6cdd425368811b306d03c5406b82396a5" translate="yes" xml:space="preserve">
          <source>Character manipulation</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c58f86ca967b4e419cb22f348fc6985fce2677c" translate="yes" xml:space="preserve">
          <source>Character matching should be performed without regard to case.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c0613c06e2948d7013037f534e1060ec71035f9" translate="yes" xml:space="preserve">
          <source>Character ranges of the form</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01b4f31695ebfef5e54e268eeccaa5f720d189d9" translate="yes" xml:space="preserve">
          <source>Character string identifying the value of the environmental variable or null pointer if such variable is not found.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce6ddaa694e2a7b4942fbc87cf18e8f64d26f9b2" translate="yes" xml:space="preserve">
          <source>Character types</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2fa17410341c773958ab0b06148ed01369e49360" translate="yes" xml:space="preserve">
          <source>Characteristics</source>
          <target state="translated">Characteristics</target>
        </trans-unit>
        <trans-unit id="b6f59f08fd6d58c6725e21a9ec24e068148ec586" translate="yes" xml:space="preserve">
          <source>Characters</source>
          <target state="translated">Characters</target>
        </trans-unit>
        <trans-unit id="f75befe1513c72cfd4b48f48e3e273b661b4521f" translate="yes" xml:space="preserve">
          <source>Characters are extracted until either.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d0fadb68912f46be7478bf1dc2a449a1ccab7e3" translate="yes" xml:space="preserve">
          <source>Characters following the null character are not compared.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bbb7ac13141743e85ef9cf35d0729e5e44ee839e" translate="yes" xml:space="preserve">
          <source>Checks for the presence of an &lt;a href=&quot;language/attributes&quot;&gt;attribute&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c239cb24da30a931bb645a231c2c1a422922f55" translate="yes" xml:space="preserve">
          <source>Checks if &lt;code&gt;*this&lt;/code&gt; is the only &lt;code&gt;shared_ptr&lt;/code&gt; instance managing the current object, i.e. whether &lt;code&gt;use_count() == 1&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64fe6c568f795adfd098e0d63f6859cec6831cc6" translate="yes" xml:space="preserve">
          <source>Checks if &lt;code&gt;*this&lt;/code&gt; represents a valid date. Because a &lt;code&gt;year_month_day_last&lt;/code&gt; represents the last day of a particular month, it represents a valid date as long as the year and month are valid.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0373b2fbb18e3c084d0c6cb8a8392f2d23211bd2" translate="yes" xml:space="preserve">
          <source>Checks if &lt;code&gt;*this&lt;/code&gt; stores a non-null pointer, i.e. whether &lt;code&gt;get() != nullptr&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4fb57d3244245c7b2c53e5525199fd6990e81a5" translate="yes" xml:space="preserve">
          <source>Checks if &lt;code&gt;T&lt;/code&gt; is an &lt;a href=&quot;../language/aggregate_initialization&quot;&gt;aggregate type&lt;/a&gt;. The member constant &lt;code&gt;value&lt;/code&gt; is equal to &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;T&lt;/code&gt; is an aggregate type and &lt;code&gt;false&lt;/code&gt; otherwise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46810c15e7731f0bcc598e64e82c003580066f60" translate="yes" xml:space="preserve">
          <source>Checks if &lt;code&gt;ch&lt;/code&gt; is a printable character as classified by the currently installed C locale. In the default, &quot;C&quot; locale, the following characters are printable:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bef2c39f0952ee3e2e6df2eb7c4b6c1cb97c1231" translate="yes" xml:space="preserve">
          <source>Checks if &lt;code&gt;lhs&lt;/code&gt; is</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8742a8ea58f9f8b2f58eab45ce84322d20b1ef7e" translate="yes" xml:space="preserve">
          <source>Checks if &lt;code&gt;x&lt;/code&gt; is an integral power of two.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e01f0ff952438d49e950107b31dc2f6d176fb839" translate="yes" xml:space="preserve">
          <source>Checks if all, any or none of the bits are set to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ebd2ed423ea71f7993be85315a4cf55c91df927f" translate="yes" xml:space="preserve">
          <source>Checks if an element equivalent to &lt;code&gt;value&lt;/code&gt; appears within the range &lt;code&gt;[first, last)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3df65edb22a1ea82942fb937399112c261a1ddf5" translate="yes" xml:space="preserve">
          <source>Checks if the &lt;code&gt;month&lt;/code&gt; object stored in &lt;code&gt;*this&lt;/code&gt; is valid.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf1c1960bf8bd117039d083bce42dfd50d32f263" translate="yes" xml:space="preserve">
          <source>Checks if the contained &lt;a href=&quot;../month&quot;&gt;&lt;code&gt;month&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../weekday_indexed&quot;&gt;&lt;code&gt;weekday_indexed&lt;/code&gt;&lt;/a&gt; objects are valid.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0e9dbc22fbac3c623e99fa4b12c00c784887ebb" translate="yes" xml:space="preserve">
          <source>Checks if the contained &lt;a href=&quot;../month&quot;&gt;&lt;code&gt;month&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../weekday_last&quot;&gt;&lt;code&gt;weekday_last&lt;/code&gt;&lt;/a&gt; objects are valid.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a186fda0be6fbf8b4f0463ca58545aab4b63c811" translate="yes" xml:space="preserve">
          <source>Checks if the container has no elements, i.e. whether &lt;code&gt;begin() == end()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bdababdda3b078e8a754954e78f43fa63c1e9fca" translate="yes" xml:space="preserve">
          <source>Checks if the day value stored in &lt;code&gt;*this&lt;/code&gt; is in the valid range, i.e., [1, 31].</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="883d61f7b86b64216417405d15836a0059e52c16" translate="yes" xml:space="preserve">
          <source>Checks if the elements in range &lt;code&gt;[first, last)&lt;/code&gt; are a</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="edd5932dbd43271b51bea92b6301c914eb0d9627" translate="yes" xml:space="preserve">
          <source>Checks if the elements in range &lt;code&gt;[first, last)&lt;/code&gt; are sorted in non-descending order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7583a23f352a0114e03ecd5b421ac82f127e76d4" translate="yes" xml:space="preserve">
          <source>Checks if the end of the given file stream has been reached.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ea631da0eac64b4493283ac77224a99a20a1afb" translate="yes" xml:space="preserve">
          <source>Checks if the error value is valid, i.e. non-zero.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0a4ec6efbb9408286b1f97366f614bd6aebe167" translate="yes" xml:space="preserve">
          <source>Checks if the file stream has an associated file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9939f20d92c8448e034a9fb2ce041b3a30041e38" translate="yes" xml:space="preserve">
          <source>Checks if the first range &lt;code&gt;[first1, last1)&lt;/code&gt; is lexicographically</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c9cf6d9c81ca1a6f48142b146482b5a7d92c18d" translate="yes" xml:space="preserve">
          <source>Checks if the future refers to a shared state.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f541bb8843b33c6aed03a6b4cf9d5e87a333b18" translate="yes" xml:space="preserve">
          <source>Checks if the given character classified as a graphic character (i.e. printable, excluding space) by the given locale's &lt;code&gt;&lt;a href=&quot;ctype&quot;&gt;std::ctype&lt;/a&gt;&lt;/code&gt; facet.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b8c77159013c45824384fde718470edb60e4d82" translate="yes" xml:space="preserve">
          <source>Checks if the given character classified as a printable character (including space) by the given locale's &lt;code&gt;&lt;a href=&quot;ctype&quot;&gt;std::ctype&lt;/a&gt;&lt;/code&gt; facet.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c2b1f4fcd055b704d957a1b2cdeb2187a3b7dbc" translate="yes" xml:space="preserve">
          <source>Checks if the given character classified as an alphanumeric character by the given locale's &lt;code&gt;&lt;a href=&quot;ctype&quot;&gt;std::ctype&lt;/a&gt;&lt;/code&gt; facet.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f79c82fa33d708a83fc2cde057f0b8a25d9b077" translate="yes" xml:space="preserve">
          <source>Checks if the given character is a blank character as classified by the currently installed C locale. Blank characters are whitespace characters used to separate words within a sentence. In the default C locale, only space (&lt;code&gt;0x20&lt;/code&gt;) and horizontal tab (&lt;code&gt;0x09&lt;/code&gt;) are classified as blank characters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63924bd06b9cfc417682f6f2da0b8cccc1b40b2a" translate="yes" xml:space="preserve">
          <source>Checks if the given character is a control character as classified by the currently installed C locale. In the default, &quot;C&quot; locale, the control characters are the characters with the codes &lt;code&gt;0x00-0x1F&lt;/code&gt; and &lt;code&gt;0x7F&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="620ca22193327aabe490bc69707b719cd34918b4" translate="yes" xml:space="preserve">
          <source>Checks if the given character is a hexadecimal numeric character (&lt;code&gt;0123456789abcdefABCDEF&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b960e379d1de64e4dd59c0a98f8f7ba08f6e01b" translate="yes" xml:space="preserve">
          <source>Checks if the given character is a punctuation character as classified by the current C locale. The default C locale classifies the characters &lt;code&gt;!&quot;#$%&amp;amp;'()*+,-./:;&amp;lt;=&amp;gt;?@[\]^_`{|}~&lt;/code&gt; as punctuation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e36cb86f2350ed7cbcb8c08ff869f068fcb37a55" translate="yes" xml:space="preserve">
          <source>Checks if the given character is an alphabetic character as classified by the currently installed C locale. In the default locale, the following characters are alphabetic:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8460053f4f6257cbef25ff160120cc6c7e959e75" translate="yes" xml:space="preserve">
          <source>Checks if the given character is an alphanumeric character as classified by the current C locale. In the default locale, the following characters are alphanumeric:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7168f1ddb2b4d425325e246ea920d97240da433" translate="yes" xml:space="preserve">
          <source>Checks if the given character is an uppercase character as classified by the currently installed C locale. In the default &quot;C&quot; locale, &lt;code&gt;isupper&lt;/code&gt; returns a nonzero value only for the uppercase letters (&lt;code&gt;ABCDEFGHIJKLMNOPQRSTUVWXYZ&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11145349eb5a7ce12671e4ea9c07676f5f562772" translate="yes" xml:space="preserve">
          <source>Checks if the given character is classified as a blank character by the given locale's ctype facet.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d19f846387e2564dd01a4273fc111bb0f3752b9" translate="yes" xml:space="preserve">
          <source>Checks if the given character is classified as a control character by the given locale's &lt;code&gt;&lt;a href=&quot;ctype&quot;&gt;std::ctype&lt;/a&gt;&lt;/code&gt; facet.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1d14d696222c936849b54795e37e65ab005fff8" translate="yes" xml:space="preserve">
          <source>Checks if the given character is classified as a digit by the given locale's &lt;code&gt;&lt;a href=&quot;ctype&quot;&gt;std::ctype&lt;/a&gt;&lt;/code&gt; facet.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65f5cc11ad968a30d5184556f3ca2929d52f75ca" translate="yes" xml:space="preserve">
          <source>Checks if the given character is classified as a hexadecimal digit by the given locale's &lt;code&gt;&lt;a href=&quot;ctype&quot;&gt;std::ctype&lt;/a&gt;&lt;/code&gt; facet.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a564f70b3df82a305537021cab411cdbd81adce" translate="yes" xml:space="preserve">
          <source>Checks if the given character is classified as a lowercase alphabetic character by the given locale's &lt;code&gt;&lt;a href=&quot;ctype&quot;&gt;std::ctype&lt;/a&gt;&lt;/code&gt; facet.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a2d197badc519c2b6d6b8c1c0f0089443b1e3e0" translate="yes" xml:space="preserve">
          <source>Checks if the given character is classified as a lowercase character according to the current C locale. In the default &quot;C&quot; locale, &lt;code&gt;islower&lt;/code&gt; returns a nonzero value only for the lowercase letters (&lt;code&gt;abcdefghijklmnopqrstuvwxyz&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23434ffbce64a443ceebe9b25bfd4dee6b410a4d" translate="yes" xml:space="preserve">
          <source>Checks if the given character is classified as a whitespace character by the given locale's ctype facet.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29b8c4707acb6f5f5b0af799234d886e0c8bdb59" translate="yes" xml:space="preserve">
          <source>Checks if the given character is classified as an alphabetic character by the given locale's &lt;code&gt;&lt;a href=&quot;ctype&quot;&gt;std::ctype&lt;/a&gt;&lt;/code&gt; facet.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f13395f8feb0b1900f02da016716c265861d48bd" translate="yes" xml:space="preserve">
          <source>Checks if the given character is classified as an punctuation character by the given locale's &lt;code&gt;&lt;a href=&quot;ctype&quot;&gt;std::ctype&lt;/a&gt;&lt;/code&gt; facet.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06bebae7934c976345409e18e4892deb4f07b810" translate="yes" xml:space="preserve">
          <source>Checks if the given character is classified as an uppercase alphabetic character by the given locale's &lt;code&gt;&lt;a href=&quot;ctype&quot;&gt;std::ctype&lt;/a&gt;&lt;/code&gt; facet.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05ecdcea5d58ceaa8ef5f1b140c063bf55d26ae8" translate="yes" xml:space="preserve">
          <source>Checks if the given character is graphic (has a graphical representation) as classified by the currently installed C locale. In the default C locale, the following characters are graphic:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53e2f7b7aaa15bbc121a001ba778520977aa5a41" translate="yes" xml:space="preserve">
          <source>Checks if the given character is one of the 10 decimal digits: &lt;code&gt;0123456789&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8fe8cd0a6bef5c367f22c30f7a34e386596daca0" translate="yes" xml:space="preserve">
          <source>Checks if the given character is whitespace character as classified by the currently installed C locale. In the default locale, the whitespace characters are the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb1f23b247c77dd957a70ee1a23c0abb19665059" translate="yes" xml:space="preserve">
          <source>Checks if the given file status is known, Equivalent to &lt;code&gt;s.type() != file_type::none&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="218bbbf54d03f6b2078dbf8b7f02244dc7b15314" translate="yes" xml:space="preserve">
          <source>Checks if the given file status or path corresponds to a FIFO or pipe file as if determined by POSIX &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/sys_stat.h.html&quot;&gt;S_ISFIFO&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5bbc2239e82c8c44869791aa800f48187a92cdb" translate="yes" xml:space="preserve">
          <source>Checks if the given file status or path corresponds to a block special file, as if determined by the POSIX &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/sys_stat.h.html&quot;&gt;S_ISBLK &lt;/a&gt;. Examples of block special files are block devices such as &lt;code&gt;/dev/sda&lt;/code&gt; or &lt;code&gt;/dev/loop0&lt;/code&gt; on Linux.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd5468dc57f1c432cf3158ebdd4f2506febe1e97" translate="yes" xml:space="preserve">
          <source>Checks if the given file status or path corresponds to a character special file, as if determined by POSIX &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/sys_stat.h.html&quot;&gt;S_ISCHR&lt;/a&gt;. Examples of character special files are character devices such as &lt;code&gt;/dev/null&lt;/code&gt;, &lt;code&gt;/dev/tty&lt;/code&gt;, &lt;code&gt;/dev/audio&lt;/code&gt;, or &lt;code&gt;/dev/nvram&lt;/code&gt; on Linux.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5800e2498685522757fe31c5c55c07d4ca923fef" translate="yes" xml:space="preserve">
          <source>Checks if the given file status or path corresponds to a directory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a93cdcd4a85825d11b2a20b899602004622f63c" translate="yes" xml:space="preserve">
          <source>Checks if the given file status or path corresponds to a file of type</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bac818da5390c8dda2cd14c441525beaeb1ca7ce" translate="yes" xml:space="preserve">
          <source>Checks if the given file status or path corresponds to a named IPC socket, as if determined by the POSIX &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/sys_stat.h.html&quot;&gt;S_IFSOCK&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5cbb58c72659913381cfab0101affa7e32b4218a" translate="yes" xml:space="preserve">
          <source>Checks if the given file status or path corresponds to a regular file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="069358c7a4934c3a0eff64f5a19fd200748050f4" translate="yes" xml:space="preserve">
          <source>Checks if the given file status or path corresponds to a symbolic link, as if determined by the POSIX &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/sys_stat.h.html&quot;&gt;S_IFLNK&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7887d8d69526f9ccd0654883e159eed9a48b721d" translate="yes" xml:space="preserve">
          <source>Checks if the given file status or path corresponds to an existing file or directory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86e15e5f001ace8d5ed732d67f679b17b8027345" translate="yes" xml:space="preserve">
          <source>Checks if the given wide character can be printed, i.e. it is either a number (&lt;code&gt;0123456789&lt;/code&gt;), an uppercase letter (&lt;code&gt;ABCDEFGHIJKLMNOPQRSTUVWXYZ&lt;/code&gt;), a lowercase letter (&lt;code&gt;abcdefghijklmnopqrstuvwxyz&lt;/code&gt;), a punctuation character(&lt;code&gt;!&quot;#$%&amp;amp;'()*+,-./:;&amp;lt;=&amp;gt;?@[\]^_`{|}~&lt;/code&gt;), space or any printable character specific to the current C locale.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ddf1d4606203515c454d3cbf72c353c2b7a5550" translate="yes" xml:space="preserve">
          <source>Checks if the given wide character corresponds (if narrowed) to a hexadecimal numeric character, i.e. one of &lt;code&gt;0123456789abcdefABCDEF&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9737563245a39a0f23f82812e136487feb35b8a3" translate="yes" xml:space="preserve">
          <source>Checks if the given wide character corresponds (if narrowed) to one of the ten decimal digit characters &lt;code&gt;0123456789&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="901c321d30a4b9e0c1bb0f4ce4f0b7f3fc5086ff" translate="yes" xml:space="preserve">
          <source>Checks if the given wide character has a graphical representation, i.e. it is either a number (&lt;code&gt;0123456789&lt;/code&gt;), an uppercase letter (&lt;code&gt;ABCDEFGHIJKLMNOPQRSTUVWXYZ&lt;/code&gt;), a lowercase letter (&lt;code&gt;abcdefghijklmnopqrstuvwxyz&lt;/code&gt;), a punctuation character(&lt;code&gt;!&quot;#$%&amp;amp;'()*+,-./:;&amp;lt;=&amp;gt;?@[\]^_`{|}~&lt;/code&gt;) or any graphical character specific to the current C locale.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69347e858d3166f00f30fe95f9dd5f5ae37bc816" translate="yes" xml:space="preserve">
          <source>Checks if the given wide character is a control character, i.e. codes &lt;code&gt;0x00-0x1F&lt;/code&gt; and &lt;code&gt;0x7F&lt;/code&gt; and any control characters specific to the current locale.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f75e93760224f49060fa9daae484b93562cec26c" translate="yes" xml:space="preserve">
          <source>Checks if the given wide character is a lowercase letter, i.e. one of &lt;code&gt;abcdefghijklmnopqrstuvwxyz&lt;/code&gt; or any lowercase letter specific to the current locale.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3bc1df8c65e55dc36b4066a3cfbf00b5eb6d139" translate="yes" xml:space="preserve">
          <source>Checks if the given wide character is a punctuation character, i.e. it is one of &lt;code&gt;!&quot;#$%&amp;amp;'()*+,-./:;&amp;lt;=&amp;gt;?@[\]^_`{|}~&lt;/code&gt; or any punctuation character specific to the current locale.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7082207d2a2725304cb1acc7985965ef85b95446" translate="yes" xml:space="preserve">
          <source>Checks if the given wide character is a wide whitespace character as classified by the currently installed C locale. In the default locale, the whitespace characters are the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ecee395d873139c5f79bbced8e5ab2094298ef99" translate="yes" xml:space="preserve">
          <source>Checks if the given wide character is an alphabetic character, i.e. either an uppercase letter (&lt;code&gt;ABCDEFGHIJKLMNOPQRSTUVWXYZ&lt;/code&gt;), a lowercase letter (&lt;code&gt;abcdefghijklmnopqrstuvwxyz&lt;/code&gt;) or any alphabetic character specific to the current locale.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5467527cb982943f926960fa171baeacafcc85de" translate="yes" xml:space="preserve">
          <source>Checks if the given wide character is an alphanumeric character, i.e. either a number (&lt;code&gt;0123456789&lt;/code&gt;), an uppercase letter (&lt;code&gt;ABCDEFGHIJKLMNOPQRSTUVWXYZ&lt;/code&gt;), a lowercase letter (&lt;code&gt;abcdefghijklmnopqrstuvwxyz&lt;/code&gt;) or any alphanumeric character specific to the current locale.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43c33322c3d3cfbcbf8bd68f060fd927a3eb782d" translate="yes" xml:space="preserve">
          <source>Checks if the given wide character is an uppercase letter, i.e. one of &lt;code&gt;ABCDEFGHIJKLMNOPQRSTUVWXYZ&lt;/code&gt; or any uppercase letter specific to the current locale.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1541b6076382859c29bdb454303ad0411f5bf188" translate="yes" xml:space="preserve">
          <source>Checks if the given wide character is classified as blank character (that is, a whitespace character used to separate words in a sentence) by the current C locale. In the default C locale, only space (&lt;code&gt;0x20&lt;/code&gt;) and horizontal tab (&lt;code&gt;0x09&lt;/code&gt;) are blank characters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b129df05edbccc2dbdbb661453142c518a02f19" translate="yes" xml:space="preserve">
          <source>Checks if the identifier was &lt;a href=&quot;replace&quot;&gt;defined as a macro name&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64cb0aa280d8c5b49543261dbfb062c65e2ea369" translate="yes" xml:space="preserve">
          <source>Checks if the locale &lt;code&gt;loc&lt;/code&gt; implements the facet &lt;code&gt;Facet&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9985c18b99c624309993b776322be3e5b6066d2" translate="yes" xml:space="preserve">
          <source>Checks if the month value stored in &lt;code&gt;*this&lt;/code&gt; is in the valid range, i.e., [1, 12].</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0dd7dcb8d83418ab5c1982a79ec6863927fac41" translate="yes" xml:space="preserve">
          <source>Checks if the objects refer to the same types.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="afce813d540f870643a2e6dca3dce7be3e73c275" translate="yes" xml:space="preserve">
          <source>Checks if the path in generic format is empty.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="071d812ba3714e0179abe833e7757fda078f2ab3" translate="yes" xml:space="preserve">
          <source>Checks if the span is empty.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d21231b9c8a7c7e4c607dfb289d854bd85592b5" translate="yes" xml:space="preserve">
          <source>Checks if the string begins with the given prefix, where.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71b7c6ae3905a663f394b1116d26498963174727" translate="yes" xml:space="preserve">
          <source>Checks if the string ends with the given suffix, where.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49c8ee0c41c7b9956041b8533f0a3c22e35fb914" translate="yes" xml:space="preserve">
          <source>Checks if the string has no characters, i.e. whether &lt;code&gt;begin() == end()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f75909c8025e14e89620cb4160aa02ff233aed4b" translate="yes" xml:space="preserve">
          <source>Checks if the string view begins with the given prefix, where.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7427d8a4aadff39d88d1b06e6bec36a6333d8cae" translate="yes" xml:space="preserve">
          <source>Checks if the string view ends with the given suffix, where.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c97dbdbc5ab4d6a6b9d169e205e7ed31539d6f2" translate="yes" xml:space="preserve">
          <source>Checks if the thread object identifies an active thread of execution. Specifically, returns &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;get_id() != &lt;a href=&quot;id&quot;&gt;std::thread::id&lt;/a&gt;()&lt;/code&gt;. So a default constructed &lt;code&gt;thread&lt;/code&gt; is not joinable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5f3b8028d75916c6cdb6ba96aa95864bd377eef" translate="yes" xml:space="preserve">
          <source>Checks if the underlying container has no elements, i.e. whether &lt;code&gt;c.empty()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a67620d24bc287120096a35fb784d0aa23f510f3" translate="yes" xml:space="preserve">
          <source>Checks if the variant &lt;code&gt;v&lt;/code&gt; holds the alternative &lt;code&gt;T&lt;/code&gt;. The call is ill-formed if &lt;code&gt;T&lt;/code&gt; does not appear exactly once in &lt;code&gt;Types...&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af699c2fb33c530d4e019c89f05d9a81a1ed9be7" translate="yes" xml:space="preserve">
          <source>Checks if the view has no characters, i.e. whether &lt;code&gt;size() == 0&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1bb1c34feb70b41fb26ff6f15e61488cf7b90f70" translate="yes" xml:space="preserve">
          <source>Checks if the weekday object and the index stored in &lt;code&gt;*this&lt;/code&gt; are both valid.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f994a993b7fef807fb525562e15e1525c1a69a9" translate="yes" xml:space="preserve">
          <source>Checks if the weekday object stored in &lt;code&gt;*this&lt;/code&gt; is valid.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b7ab4115c5420b5077429b962479db9584a2da3" translate="yes" xml:space="preserve">
          <source>Checks if the weekday value stored in &lt;code&gt;*this&lt;/code&gt; is in the valid range, i.e., [0, 6].</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9931d20719fee825f5a129c05c9d24c6dd21e79b" translate="yes" xml:space="preserve">
          <source>Checks if the year and month values stored in this object are valid.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd3b595aeae50a14c0fc3a412a6eb6ed2aaf74d7" translate="yes" xml:space="preserve">
          <source>Checks if the year value stored in &lt;code&gt;*this&lt;/code&gt; is in the valid range, i.e., [-32767, 32767].</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="464075ee2620831863a05ac3a062d2394191d131" translate="yes" xml:space="preserve">
          <source>Checks if this &lt;code&gt;year_month_day&lt;/code&gt; object represents a valid calendar date.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f08fd0aa437da8d48e5c7e55ec6138f44d1d5e3" translate="yes" xml:space="preserve">
          <source>Checks if this &lt;code&gt;year_month_weekday&lt;/code&gt; object represents a valid date.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7012f03f45a478e758270c82fce18acc13dfab8e" translate="yes" xml:space="preserve">
          <source>Checks if this object represents a valid date. Since a &lt;code&gt;year_month_weekday_last&lt;/code&gt; represents the last weekday of a particular month, it is valid as long as the year, month and weekday are valid.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="587976447f530aa6d25584b121ecdd151dbddd88" translate="yes" xml:space="preserve">
          <source>Checks the given stream for errors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e063831806b4abf69aa95a8f1d0b948f8c9a0902" translate="yes" xml:space="preserve">
          <source>Checks the status of the sentry by calling &lt;code&gt;sentry::operator bool()&lt;/code&gt;, which is equivalent to &lt;a href=&quot;../io/basic_ios/good&quot;&gt;&lt;code&gt;basic_ios::good&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="635ea4eba5accbfc249cd25209bcc3997533d8d6" translate="yes" xml:space="preserve">
          <source>Checks whether &lt;code&gt;*this&lt;/code&gt; contains a value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c38bd2aaae4ae9aad431571bc2897944efdb92f3" translate="yes" xml:space="preserve">
          <source>Checks whether &lt;code&gt;*this&lt;/code&gt; has a shared state.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71b816d1cfbb4f8588b6af2666d0efc8ea0c81d9" translate="yes" xml:space="preserve">
          <source>Checks whether &lt;code&gt;*this&lt;/code&gt; owns a locked mutex or not.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed68d48f6a1e0644798c3fa0bfc8f385861ea72e" translate="yes" xml:space="preserve">
          <source>Checks whether &lt;code&gt;*this&lt;/code&gt; owns a locked mutex or not. Effectively calls &lt;code&gt;&lt;a href=&quot;owns_lock&quot;&gt;owns_lock()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f31ae0eaa08456edf17a19eb82949ee2db0b8878" translate="yes" xml:space="preserve">
          <source>Checks whether &lt;code&gt;*this&lt;/code&gt; owns an object, i.e. whether &lt;code&gt;get() != nullptr&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ed8174a7598bc58814343000b3811be1096f8ba" translate="yes" xml:space="preserve">
          <source>Checks whether &lt;code&gt;*this&lt;/code&gt; stores a callable function target, i.e. is not empty.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7022e1e52a32f5446f404931d6fe2823c8c69dd3" translate="yes" xml:space="preserve">
          <source>Checks whether &lt;code&gt;T&lt;/code&gt; is a &lt;a href=&quot;../language/pointer&quot;&gt;pointer to object&lt;/a&gt; or a pointer to function (but not a pointer to member/member function). Provides the member constant &lt;code&gt;value&lt;/code&gt; which is equal to &lt;code&gt;true&lt;/code&gt;, if &lt;code&gt;T&lt;/code&gt; is a object/function pointer type. Otherwise, &lt;code&gt;value&lt;/code&gt; is equal to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8a0aab7ac34afa964604fd6771adf4104c3b8e7" translate="yes" xml:space="preserve">
          <source>Checks whether &lt;code&gt;T&lt;/code&gt; is a floating-point type. Provides the member constant &lt;code&gt;value&lt;/code&gt; which is equal to &lt;code&gt;true&lt;/code&gt;, if &lt;code&gt;T&lt;/code&gt; is the type &lt;code&gt;float&lt;/code&gt;, &lt;code&gt;double&lt;/code&gt;, &lt;code&gt;long double&lt;/code&gt;, including any cv-qualified variants. Otherwise, &lt;code&gt;value&lt;/code&gt; is equal to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e59abc34df71bdf6c32c2c5ea33dd17229fe5b19" translate="yes" xml:space="preserve">
          <source>Checks whether &lt;code&gt;T&lt;/code&gt; is a function type. Types like &lt;code&gt;&lt;a href=&quot;../utility/functional/function&quot;&gt;std::function&lt;/a&gt;&lt;/code&gt;, lambdas, classes with overloaded &lt;code&gt;operator()&lt;/code&gt; and pointers to functions don't count as function types. Provides the member constant &lt;code&gt;value&lt;/code&gt; which is equal to &lt;code&gt;true&lt;/code&gt;, if &lt;code&gt;T&lt;/code&gt; is a function type. Otherwise, &lt;code&gt;value&lt;/code&gt; is equal to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e28cb24a251f49a5aebb9fae5f5a3ec5667c582" translate="yes" xml:space="preserve">
          <source>Checks whether &lt;code&gt;T&lt;/code&gt; is a lvalue reference type. Provides the member constant &lt;code&gt;value&lt;/code&gt; which is equal to &lt;code&gt;true&lt;/code&gt;, if &lt;code&gt;T&lt;/code&gt; is a lvalue reference type. Otherwise, &lt;code&gt;value&lt;/code&gt; is equal to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b883e14dd2e029695b8fd5542cec26d4e9260ac" translate="yes" xml:space="preserve">
          <source>Checks whether &lt;code&gt;T&lt;/code&gt; is a non-static member function pointer. Provides the member constant &lt;code&gt;value&lt;/code&gt; which is equal to &lt;code&gt;true&lt;/code&gt;, if &lt;code&gt;T&lt;/code&gt; is a non-static member function pointer type. Otherwise, &lt;code&gt;value&lt;/code&gt; is equal to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9164f6a53718da4919f5f96385b37cf47562a131" translate="yes" xml:space="preserve">
          <source>Checks whether &lt;code&gt;T&lt;/code&gt; is a non-static member object. Provides the member constant &lt;code&gt;value&lt;/code&gt; which is equal to &lt;code&gt;true&lt;/code&gt;, if &lt;code&gt;T&lt;/code&gt; is a non-static member object type. Otherwise, &lt;code&gt;value&lt;/code&gt; is equal to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ecf7dc059b4ed93776d32d000af1b4107668e74" translate="yes" xml:space="preserve">
          <source>Checks whether &lt;code&gt;T&lt;/code&gt; is a non-union class type. Provides the member constant &lt;code&gt;value&lt;/code&gt; which is equal to &lt;code&gt;true&lt;/code&gt;, if &lt;code&gt;T&lt;/code&gt; is a class type (but not union). Otherwise, &lt;code&gt;value&lt;/code&gt; is equal to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2bedc64ebaaa15f40dee6eca6d599bd4bb747d7b" translate="yes" xml:space="preserve">
          <source>Checks whether &lt;code&gt;T&lt;/code&gt; is a rvalue reference type. Provides the member constant &lt;code&gt;value&lt;/code&gt; which is equal to &lt;code&gt;true&lt;/code&gt;, if &lt;code&gt;T&lt;/code&gt; is a rvalue reference type. Otherwise, &lt;code&gt;value&lt;/code&gt; is equal to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a8715fd468c9164b80d434876b0f9a130176110" translate="yes" xml:space="preserve">
          <source>Checks whether &lt;code&gt;T&lt;/code&gt; is a standard or implementation-defined execution policy type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dfe90d9b7dabaa2818a7d2a0d184dea435b97627" translate="yes" xml:space="preserve">
          <source>Checks whether &lt;code&gt;T&lt;/code&gt; is a union type. Provides the member constant &lt;code&gt;value&lt;/code&gt;, which is equal to &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;T&lt;/code&gt; is a union type . Otherwise, &lt;code&gt;value&lt;/code&gt; is equal to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6df4126bdcc6310ebb0cdad5780493d77d0c187" translate="yes" xml:space="preserve">
          <source>Checks whether &lt;code&gt;T&lt;/code&gt; is a void type. Provides the member constant &lt;code&gt;value&lt;/code&gt; that is equal to &lt;code&gt;true&lt;/code&gt;, if &lt;code&gt;T&lt;/code&gt; is the type &lt;code&gt;void&lt;/code&gt;, &lt;code&gt;const void&lt;/code&gt;, &lt;code&gt;volatile void&lt;/code&gt;, or &lt;code&gt;const volatile void&lt;/code&gt;. Otherwise, &lt;code&gt;value&lt;/code&gt; is equal to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2be34e132a60607ab5dd9c04136e75642192abbf" translate="yes" xml:space="preserve">
          <source>Checks whether &lt;code&gt;T&lt;/code&gt; is an &lt;a href=&quot;../language/array#Arrays_of_unknown_bound&quot;&gt;array type of unknown bound&lt;/a&gt;. Provides the member constant &lt;code&gt;value&lt;/code&gt; which is equal to &lt;code&gt;true&lt;/code&gt;, if &lt;code&gt;T&lt;/code&gt; is an array type of unknown bound. Otherwise, &lt;code&gt;value&lt;/code&gt; is equal to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1833b30272f19f6543d86fb787e9532baf6350d0" translate="yes" xml:space="preserve">
          <source>Checks whether &lt;code&gt;T&lt;/code&gt; is an &lt;a href=&quot;../language/enum&quot;&gt;enumeration type&lt;/a&gt;. Provides the member constant &lt;code&gt;value&lt;/code&gt; which is equal to &lt;code&gt;true&lt;/code&gt;, if &lt;code&gt;T&lt;/code&gt; is an enumeration type . Otherwise, &lt;code&gt;value&lt;/code&gt; is equal to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="130f7441ba35a78873bfe867bf57a2fe54bb8190" translate="yes" xml:space="preserve">
          <source>Checks whether &lt;code&gt;T&lt;/code&gt; is an array type of known bound. Provides the member constant &lt;code&gt;value&lt;/code&gt; which is equal to &lt;code&gt;true&lt;/code&gt;, if &lt;code&gt;T&lt;/code&gt; is an array type of known bound. Otherwise, &lt;code&gt;value&lt;/code&gt; is equal to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f1fcc5981b134a62c10ce0c25e9c946467ed28b" translate="yes" xml:space="preserve">
          <source>Checks whether &lt;code&gt;T&lt;/code&gt; is an array type. Provides the member constant &lt;code&gt;value&lt;/code&gt; which is equal to &lt;code&gt;true&lt;/code&gt;, if &lt;code&gt;T&lt;/code&gt; is an array type. Otherwise, &lt;code&gt;value&lt;/code&gt; is equal to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d91afb5a075ac60e9677a8cc4754febe1adbc79" translate="yes" xml:space="preserve">
          <source>Checks whether &lt;code&gt;T&lt;/code&gt; is an integral type. Provides the member constant &lt;code&gt;value&lt;/code&gt; which is equal to &lt;code&gt;true&lt;/code&gt;, if &lt;code&gt;T&lt;/code&gt; is the type &lt;code&gt;bool&lt;/code&gt;, &lt;code&gt;char&lt;/code&gt;, &lt;code&gt;char8_t&lt;/code&gt;, &lt;code&gt;char16_t&lt;/code&gt;, &lt;code&gt;char32_t&lt;/code&gt;, &lt;code&gt;wchar_t&lt;/code&gt;, &lt;code&gt;short&lt;/code&gt;, &lt;code&gt;int&lt;/code&gt;, &lt;code&gt;long&lt;/code&gt;, &lt;code&gt;long long&lt;/code&gt;, or any implementation-defined extended integer types, including any signed, unsigned, and cv-qualified variants. Otherwise, &lt;code&gt;value&lt;/code&gt; is equal to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bffa9e6d94cce1dcc42a4c7c509890d27926c672" translate="yes" xml:space="preserve">
          <source>Checks whether &lt;code&gt;T&lt;/code&gt; is the type &lt;code&gt;&lt;a href=&quot;nullptr_t&quot;&gt;std::nullptr_t&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f73a2b89f64c132a7a2db95ab8f3890b3255a62a" translate="yes" xml:space="preserve">
          <source>Checks whether &lt;code&gt;e&lt;/code&gt; is not equivalent to</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a77ef24ff3015dfba3640ad0d13f58fcf1e32d5e" translate="yes" xml:space="preserve">
          <source>Checks whether &lt;code&gt;lhs&lt;/code&gt; is</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f66fee9824887853dd82d29f509864b5623f6f69" translate="yes" xml:space="preserve">
          <source>Checks whether both &lt;code&gt;*this&lt;/code&gt; and &lt;code&gt;it&lt;/code&gt; are valid, or both are invalid, regardless of the stream buffer objects they use.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4244940d730169d64aee1da2da131b1ed135f26" translate="yes" xml:space="preserve">
          <source>Checks whether both &lt;code&gt;lhs&lt;/code&gt; and &lt;code&gt;rhs&lt;/code&gt; are equal. Two stream iterators are equal if both of them are end-of-stream iterators or both of them refer to the same stream.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87eaad996e60cbb3cfe0fcdde3be3c14e4f9c4d4" translate="yes" xml:space="preserve">
          <source>Checks whether both &lt;code&gt;lhs&lt;/code&gt; and &lt;code&gt;rhs&lt;/code&gt; are valid, or both are invalid, regardless of the stream buffer objects they use.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="229342a11042ce2ed84a995d5ff77f850ed69020" translate="yes" xml:space="preserve">
          <source>Checks whether error code is equivalent to an error condition for the error category represented by &lt;code&gt;*this&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43194b114099424f38087d59c9ce8423ad80e636" translate="yes" xml:space="preserve">
          <source>Checks whether the atomic operations on all objects of this type are lock-free.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7846cd20df099e25c9a395f85406d0c13c14521b" translate="yes" xml:space="preserve">
          <source>Checks whether the atomic operations on this object are lock-free.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1704ab82dfc96f2bfbaf877fe0ee93b65d75c37" translate="yes" xml:space="preserve">
          <source>Checks whether the given path refers to an empty file or directory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5fe5582e4c95a42678f653d245fc0d8ca7e77c8" translate="yes" xml:space="preserve">
          <source>Checks whether the match was successful.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37b6b4e530b3a44ad4560ab7cb9ddc3bdf92e02b" translate="yes" xml:space="preserve">
          <source>Checks whether the object contains a value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4dea1801ed41e688c9e6537be30704d3706b1021" translate="yes" xml:space="preserve">
          <source>Checks whether the path contains the corresponding path element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5ac19b39ecb671ac7a345baa1d1f56bbccd9a62" translate="yes" xml:space="preserve">
          <source>Checks whether the path is absolute or relative. An absolute path is a path that unambiguously identifies the location of a file without reference to an additional starting location. The first version returns &lt;code&gt;true&lt;/code&gt; if the path, in native format, is absolute, &lt;code&gt;false&lt;/code&gt; otherwise; the second version the other way round.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c6d7504c98282a80ee4254b4ab667a6d5ecaf40" translate="yes" xml:space="preserve">
          <source>Checks whether the paths &lt;code&gt;p1&lt;/code&gt; and &lt;code&gt;p2&lt;/code&gt; resolve to the same file system entity.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d03ecb587e7beec78ef27e7550fba2bb1b68ac55" translate="yes" xml:space="preserve">
          <source>Checks whether the pointed-to object exists. Effectively returns &lt;code&gt;std::filesystem::exists(status())&lt;/code&gt; or &lt;code&gt;std::filesystem::exists(status(ec))&lt;/code&gt;, respectively.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ea5dd068aa953cd3a0e1bd7233cfb66ad43dfac" translate="yes" xml:space="preserve">
          <source>Checks whether the pointed-to object is a FIFO or pipe file. Effectively returns &lt;code&gt;std::filesystem::is_fifo(status())&lt;/code&gt; or &lt;code&gt;std::filesystem::is_fifo(status(ec))&lt;/code&gt;, respectively.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38196c9d5c220a32c0349e4637ac5aa258b11038" translate="yes" xml:space="preserve">
          <source>Checks whether the pointed-to object is a block device. Effectively returns &lt;code&gt;std::filesystem::is_block_file(status())&lt;/code&gt; or &lt;code&gt;std::filesystem::is_block_file(status(ec))&lt;/code&gt;, respectively.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="751e0118d57f62587cc9a3a0af0af434ad3c1600" translate="yes" xml:space="preserve">
          <source>Checks whether the pointed-to object is a character device. Effectively returns &lt;code&gt;std::filesystem::is_character_file(status())&lt;/code&gt; or &lt;code&gt;std::filesystem::is_character_file(status(ec))&lt;/code&gt;, respectively.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0540859f0b874033d66529a5545b918e9abbefb3" translate="yes" xml:space="preserve">
          <source>Checks whether the pointed-to object is a directory. Effectively returns &lt;code&gt;std::filesystem::is_directory(status())&lt;/code&gt; or &lt;code&gt;std::filesystem::is_directory(status(ec))&lt;/code&gt;, respectively.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2308e9815e22ffba2f923b2d946ea52b4cda4576" translate="yes" xml:space="preserve">
          <source>Checks whether the pointed-to object is a named socket. Effectively returns &lt;code&gt;std::filesystem::is_socket(status())&lt;/code&gt; or &lt;code&gt;std::filesystem::is_socket(status(ec))&lt;/code&gt;, respectively.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b951526e00e6f97e074e12e389d2a9920ec6315e" translate="yes" xml:space="preserve">
          <source>Checks whether the pointed-to object is a regular file. Effectively returns &lt;code&gt;std::filesystem::is_regular_file(status())&lt;/code&gt; or &lt;code&gt;std::filesystem::is_regular_file(status(ec))&lt;/code&gt;, respectively.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="acf48ae97d4d120a878b0e576cd023878de18fa6" translate="yes" xml:space="preserve">
          <source>Checks whether the pointed-to object is a symlink. Effectively returns &lt;code&gt;std::filesystem::is_symlink(symlink_status())&lt;/code&gt; or &lt;code&gt;std::filesystem::is_symlink(symlink_status(ec))&lt;/code&gt;, respectively.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="279a1e6eab42861c169fe61939f083dce62d93e0" translate="yes" xml:space="preserve">
          <source>Checks whether the pointed-to object is an</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e8a0961bfa95374e31de6c178abd1091a03292e" translate="yes" xml:space="preserve">
          <source>Checks whether the preparation of the input stream was successful.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6813cbedc840219b2040df151acc0737b0c8c377" translate="yes" xml:space="preserve">
          <source>Checks whether the preparation of the output stream was successful.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34d57af6172a5843af278992c90022d6be885f65" translate="yes" xml:space="preserve">
          <source>Checks whether the stored error code is not zero.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a10aac416e423604412995d69f280cd38d6aa63f" translate="yes" xml:space="preserve">
          <source>Checks whether the stream has no errors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7558d5daa29a73a6092a6bb0ffb197bd0adfe9f6" translate="yes" xml:space="preserve">
          <source>Checks whether this &lt;code&gt;shared_ptr&lt;/code&gt; precedes &lt;code&gt;other&lt;/code&gt; in implementation defined owner-based (as opposed to value-based) order. The order is such that two smart pointers compare equivalent only if they are both empty or if they both own the same object, even if the values of the pointers obtained by get() are different (e.g. because they point at different subobjects within the same object).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c75ecfbdc7f9038d0ac97b90b6953481e5484923" translate="yes" xml:space="preserve">
          <source>Checks whether this &lt;code&gt;weak_ptr&lt;/code&gt; precedes &lt;code&gt;other&lt;/code&gt; in implementation defined owner-based (as opposed to value-based) order. The order is such that two smart pointers compare equivalent only if they are both empty or if they both own the same object, even if the values of the pointers obtained by get() are different (e.g. because they point at different subobjects within the same object).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e99c517d029e72bf940a22ccc78ab9409097406" translate="yes" xml:space="preserve">
          <source>Checks whether two values of type &lt;code&gt;int_type&lt;/code&gt; are equal.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34eb3f9df1785987205174d978835deeb45e94ad" translate="yes" xml:space="preserve">
          <source>Choose clang to observe the output shown.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0dd1c8b596b65fa50cf7f5efdd880ad3089168ac" translate="yes" xml:space="preserve">
          <source>Clang++3.0 libc++</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="128f6dc5d7caa59dda6044d3e8e6c55352499ea0" translate="yes" xml:space="preserve">
          <source>Class &lt;code&gt;&lt;a href=&quot;../atomic/atomic&quot;&gt;std::atomic&lt;/a&gt;&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04c10a537c6bab1bf5c4017ce72824562df9ab4f" translate="yes" xml:space="preserve">
          <source>Class &lt;code&gt;&lt;a href=&quot;../atomic/atomic_flag&quot;&gt;std::atomic_flag&lt;/a&gt;&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d939a5c95da9331b931381710149919c5d9fa22" translate="yes" xml:space="preserve">
          <source>Class &lt;code&gt;&lt;a href=&quot;../chrono/c/timespec&quot;&gt;std::timespec&lt;/a&gt;&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0fa1da504a8e1edfacf0be0377679a386d14664" translate="yes" xml:space="preserve">
          <source>Class &lt;code&gt;&lt;a href=&quot;../chrono/c/tm&quot;&gt;std::tm&lt;/a&gt;&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a55038579f31c03e4e93f4a6273203742021c97" translate="yes" xml:space="preserve">
          <source>Class &lt;code&gt;&lt;a href=&quot;../container/array&quot;&gt;std::array&lt;/a&gt;&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="225da75ec2fdc972d380bbb0e74573b3ffe5aab4" translate="yes" xml:space="preserve">
          <source>Class &lt;code&gt;&lt;a href=&quot;../container/deque&quot;&gt;std::deque&lt;/a&gt;&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
