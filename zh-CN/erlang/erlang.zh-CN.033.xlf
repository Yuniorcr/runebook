<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="erlang">
    <body>
      <group id="erlang">
        <trans-unit id="d32435d41ff7d589ba94cc7995cb7739a9bc6203" translate="yes" xml:space="preserve">
          <source>The info returned by this function is returned together with other info collected by the agent when the &lt;code&gt;&lt;a href=&quot;snmpa#info&quot;&gt;info&lt;/a&gt;&lt;/code&gt; function is called (tagged with with the key &lt;code&gt;net_if&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec9fdae2e67074ae99c5bacfc96a607916bd07f0" translate="yes" xml:space="preserve">
          <source>The info returned by this function is returned together with other info collected by the manager when the &lt;code&gt;&lt;a href=&quot;snmpm#info&quot;&gt;info&lt;/a&gt;&lt;/code&gt; function is called (tagged with the key &lt;code&gt;net_if&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4969c27d9e2b93f6c0c9f0dd0ae52939b796209" translate="yes" xml:space="preserve">
          <source>The info returned is basically up to the implementer to decide. The implementation provided by this application provides info about memory allocation and various socket information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b94457081093b8de25115749fb7f0e65291a036f" translate="yes" xml:space="preserve">
          <source>The info returned is basically up to the implementer to decide. This implementation provided by the application provides info about memory allocation and various socket information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8953da75c34f8aaee4e44739d4a4db94876e2705" translate="yes" xml:space="preserve">
          <source>The information about MIB Views for VACM should be stored in a file called &lt;code&gt;vacm.conf&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a593d35263cd423914377045097ffa123820496" translate="yes" xml:space="preserve">
          <source>The information about Notify Definitions should be stored in a file called &lt;code&gt;notify.conf&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db26f39dea524ffb501a0d56ccb46e2ba20ceda2" translate="yes" xml:space="preserve">
          <source>The information about Security data for USM should be stored in a file called &lt;code&gt;usm.conf&lt;/code&gt;, which must be present if the agent is configured for SNMPv3.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="307e4d8639265e2a32ea9ca56343b6ede5418d77" translate="yes" xml:space="preserve">
          <source>The information about Security data for USM should be stored in a file called &lt;code&gt;usm.conf&lt;/code&gt;, which must be present if the manager wishes to use SNMPv3 when communicating with agents. It is also possible to add usm data in run-time by calling the &lt;code&gt;&lt;a href=&quot;snmpm#register_usm_user&quot;&gt;register_usm_user&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba12704a027dbf1ed0fe4c7e9af52e49cba83222" translate="yes" xml:space="preserve">
          <source>The information about Target Address Definitions should be stored in a file called &lt;code&gt;target_addr.conf&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a40d6040ee67551c129f61fc60a30d2acba9667f" translate="yes" xml:space="preserve">
          <source>The information about Target Parameters Definitions should be stored in a file called &lt;code&gt;target_params.conf&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3aa4d245e100d97d0412e925606bc4810d337eae" translate="yes" xml:space="preserve">
          <source>The information about the new application specifications is fetched from the boot script included in the release package. Thus, it is important that the boot script is generated from the same &lt;code&gt;.rel&lt;/code&gt; file as is used to build the release package itself.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="391611f6929211ce72507251e567123fcf0c63db" translate="yes" xml:space="preserve">
          <source>The information from the analysis is displayed in the &lt;strong&gt;Log&lt;/strong&gt; window and the &lt;strong&gt;Warnings&lt;/strong&gt; window.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14c6d60f6fb1b8c358808ee0563e8e58bb01c1ed" translate="yes" xml:space="preserve">
          <source>The information from the files specified with &lt;code&gt;-c&lt;/code&gt; and &lt;code&gt;-r&lt;/code&gt; is removed from the PLT. Notice that this can cause a reanalysis of the remaining dependent files.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="35a417a84c4c7c4decb79621743a9dd3565ee6be" translate="yes" xml:space="preserve">
          <source>The information function &lt;code&gt;init/end_per_suite()&lt;/code&gt; is called for &lt;code&gt;init/end_per_suite(Config)&lt;/code&gt;, and information function &lt;code&gt;init/end_per_group(GroupName)&lt;/code&gt; is called for &lt;code&gt;init/end_per_group(GroupName,Config)&lt;/code&gt;. However, information functions cannot be used with &lt;code&gt;init/end_per_testcase(TestCase, Config)&lt;/code&gt;, as these configuration functions execute on the test case process and use the same properties as the test case (that is, the properties set by the test case information function, &lt;code&gt;TestCase()&lt;/code&gt;). For a list of valid information properties and more general information, see the &lt;code&gt;&lt;a href=&quot;#info_function&quot;&gt;Test Case Information Function&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="580ee4de3515f41920aad05c4796ca8a83145041" translate="yes" xml:space="preserve">
          <source>The information has the form of an Erlang expression where QLCs most likely occur. Depending on the format functions of mentioned QLC tables, it is not certain that the information is absolutely accurate.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="305d9bd7c8803717b9892f1b41b37ab6f87fe9d8" translate="yes" xml:space="preserve">
          <source>The information needed to handle agents should be stored in a file called &lt;code&gt;agents.conf&lt;/code&gt;. It is also possible to add agents in run-time by calling the &lt;code&gt;&lt;a href=&quot;snmpm#register_agent&quot;&gt;register_agent&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c58f25be105f880c4313e388829ec4c71197bfd3" translate="yes" xml:space="preserve">
          <source>The information presented here is as in the &lt;code&gt;connect&lt;/code&gt; case except that the client connections are grouped under an &lt;code&gt;accept&lt;/code&gt; tuple.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c59dd2aeba1c3a9f59f5d5103b732b653592744" translate="yes" xml:space="preserve">
          <source>The information returned by the current invocation of function &lt;code&gt;info/1&lt;/code&gt; is gathered from the disk log process running on &lt;code&gt;Node&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="384d84cf094e7d37c004a133a85246195c3cf123" translate="yes" xml:space="preserve">
          <source>The information shown in a detail window can contain links to processes or ports. Clicking one of these links opens the detail window for the process or port in question. If the process or port resides on a remote node, no information is available. Clicking the link then displays a dialog where you can choose to open the detail window for the remote node.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49a50cd6647973c69a1bf7b4354e70d711a6ebe4" translate="yes" xml:space="preserve">
          <source>The init process evaluates &lt;code&gt;apply(Mod, Func, Args)&lt;/code&gt;. The system terminates if this results in an error. The boot procedure hangs if this function never returns.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70767c9929b242def2046198ed888e89eaa4092e" translate="yes" xml:space="preserve">
          <source>The initial Erlang shell does not read user input until the system boot procedure has been completed (Erlang/OTP 5.4 and later). This flag disables the start synchronization feature and lets the shell start in parallel with the rest of the system.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="736895f627174e578045de3e4408955d43bc90d8" translate="yes" xml:space="preserve">
          <source>The initial configuration of the Megaco should be defined in the Erlang system configuration file. The following configured parameters are defined for the Megaco application:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4d81e5c16ade0725185a698be4a1277d1047896" translate="yes" xml:space="preserve">
          <source>The initial default values are set when creating an &lt;code&gt;&lt;a href=&quot;#xref_server&quot;&gt;Xref server&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="555d7eb44ef4a30035e00a3ca666e72b873a31f0" translate="yes" xml:space="preserve">
          <source>The initial goal is to trace file I/O operations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f43375679765975926ed43276d2e3e97141d5efc" translate="yes" xml:space="preserve">
          <source>The initial value of this option is set by the Kernel configuration parameter &lt;code&gt;&lt;a href=&quot;#logger_level&quot;&gt;logger_level&lt;/a&gt;&lt;/code&gt;. It is changed during runtime with &lt;code&gt;&lt;a href=&quot;logger#set_primary_config-2&quot;&gt;logger:set_primary_config(level,Level)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be84bb7f590bd193861c25c169900eba0112bb1a" translate="yes" xml:space="preserve">
          <source>The initial value of this option is set by the Kernel configuration parameter &lt;code&gt;&lt;a href=&quot;#logger_parameter&quot;&gt;logger&lt;/a&gt;&lt;/code&gt;. During runtime, primary filters are added and removed with &lt;code&gt;&lt;a href=&quot;logger#add_primary_filter-2&quot;&gt;logger:add_primary_filter/2&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;logger#remove_primary_filter-1&quot;&gt;logger:remove_primary_filter/1&lt;/a&gt;&lt;/code&gt;, respectively.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b46dedd594f319e350068f1193c873d34aee425" translate="yes" xml:space="preserve">
          <source>The initial values for fields are to be compatible with (that is, a member of) the corresponding types. This is checked by the compiler and results in a compilation error if a violation is detected.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8dd5640afe4eb44c50f0dc55a49ff96c25b7ecf" translate="yes" xml:space="preserve">
          <source>The initial values for the managed objects defined in these tables, are read at start-up from a set of configuration files. These are described in &lt;code&gt;&lt;a href=&quot;snmp_config&quot;&gt;Configuration Files&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1bc56027c40e88b952495c29f19f297d464ec0de" translate="yes" xml:space="preserve">
          <source>The initial working directory of the Erlang emulator. Defaults to the system directory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bbe26b329d2acb042c7bfd92ae3556c450f2a952" translate="yes" xml:space="preserve">
          <source>The input &lt;code&gt;State&lt;/code&gt; is the last returned &lt;code&gt;State&lt;/code&gt;, in it the callback can include any data that it needs to keep track of when handling the chunks.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ab1d9b79595ee9a80512a32c4f00246f558b37e" translate="yes" xml:space="preserve">
          <source>The input argument is passed from &lt;code&gt;Common Test&lt;/code&gt;, as defined in the test specification, or specified as an option to &lt;code&gt;ct_run&lt;/code&gt; or &lt;code&gt;ct:run_test&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b8a4a85bbd859e117dae9edd6f4ddaeebc656ee" translate="yes" xml:space="preserve">
          <source>The input characters. If the I/O device supports Unicode, the data can represent codepoints &amp;gt; 255 (the &lt;code&gt;latin1&lt;/code&gt; range). If the I/O server is set to deliver binaries, they are encoded in UTF-8 (regardless of whether the I/O device supports Unicode).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a54dcf56c159353e0ace601f3572dfb662f8a6c" translate="yes" xml:space="preserve">
          <source>The input file is expected to be assembler code (default file suffix &quot;.S&quot;). Notice that the format of assembler files is not documented, and can change between releases.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="401c0d476b7d6af409b8af21342fa3b0e4602412" translate="yes" xml:space="preserve">
          <source>The input file is expected to be core code (default file suffix &quot;.core&quot;). Notice that the format of core files is not documented, and can change between releases.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f68ee0fd471148681af709e832d148fec4d81211" translate="yes" xml:space="preserve">
          <source>The input is changed into a list of integers and sent to the driver.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="895f0498a8445706072f6a486a101f535049625a" translate="yes" xml:space="preserve">
          <source>The input is complete. The result is one of the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ee231fcc37d80538054d899a6aa444060d44d7f" translate="yes" xml:space="preserve">
          <source>The installation directory of Erlang/OTP, &lt;code&gt;$ROOT&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b211abaa6268b0cb1eb68387738a79dd87d7b54d" translate="yes" xml:space="preserve">
          <source>The installation of a new release can restart the system. Which program to use is specified by the SASL configuration parameter &lt;code&gt;start_prg&lt;/code&gt;, which defaults to &lt;code&gt;$ROOT/bin/start&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6426a93a1ac8fd4371599a87da39ac5721577a7" translate="yes" xml:space="preserve">
          <source>The installation procedure is automated. Double-click the &lt;code&gt;.exe&lt;/code&gt; file icon and follow the instructions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8df4540e0f132ae38a44f67dc8db64d1677a955e" translate="yes" xml:space="preserve">
          <source>The installation will be created in a location prefixed by &lt;code&gt;$DESTDIR&lt;/code&gt;. It can, however, not be run from there. It needs to be moved into the correct location before it can be run. If &lt;code&gt;DESTDIR&lt;/code&gt; have not been set but &lt;code&gt;INSTALL_PREFIX&lt;/code&gt; has been set, &lt;code&gt;DESTDIR&lt;/code&gt; will be set to &lt;code&gt;INSTALL_PREFIX&lt;/code&gt;. Note that &lt;code&gt;INSTALL_PREFIX&lt;/code&gt; in pre R13B04 was buggy and behaved as &lt;code&gt;EXTRA_PREFIX&lt;/code&gt; (see below). There are lots of areas of use for an installation procedure using &lt;code&gt;DESTDIR&lt;/code&gt;, e.g. when creating a package, cross compiling, etc. Here is an example where the installation should be located under &lt;code&gt;/opt/local&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc927e07960f46bc214f273ddf993919105c4192" translate="yes" xml:space="preserve">
          <source>The instruction loads the module and is necessary when running Erlang in embedded mode. It is not strictly required when running Erlang in interactive (default) mode, since the code server then automatically searches for and loads unloaded modules.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ad8974dbde3476a5985cc107445f129c6aef0af" translate="yes" xml:space="preserve">
          <source>The instruction must be a valid Erlang term ended by a dot.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d51d691ce36ba72ff972c51e18b40a26c5a340a" translate="yes" xml:space="preserve">
          <source>The instruction, and thus the &lt;code&gt;.appup&lt;/code&gt; file, when changing an existing child specification, is the same as when changing properties as described earlier:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5573a2cd0a733b9336e3b438f659165c812e003" translate="yes" xml:space="preserve">
          <source>The instructions apply to versions of Windows supporting the Cygwin emulated gnuish environment or the MSYS or MSYS2 ditto. We&amp;rsquo;ve built on the following platforms: Windows 2012, Windows 7, Windows 8 and Windows 10. It&amp;rsquo;s probably possible to build on older platforms too, but you might not be able to install the appropriate Microsoft SDK, Visual Studio or OpenSSL, in which case you will need to go back to earlier compilers etc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e507f2e1bdeb41dfac8c8cfdf517a26d52c4a6f" translate="yes" xml:space="preserve">
          <source>The integer of &lt;code&gt;t&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="477d8b618ecfd772da7e539d868fb58baec9416c" translate="yes" xml:space="preserve">
          <source>The integers in all multibyte fields are in big-endian order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e32bedc7955d7223fe090b7e55010b6b9e5ac12" translate="yes" xml:space="preserve">
          <source>The intention of Trace Tool Builder is to serve as a base for tailor-made trace tools, but it can also be used directly from the Erlang shell (it can mimic &lt;code&gt;dbg&lt;/code&gt; behaviour while still providing useful additions, such as match specification shortcuts). Trace Tool Builder only allows the use of file port tracer, so to use other types of trace clients it is better to use &lt;code&gt;dbg&lt;/code&gt; directly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd559a381bf43260a8e8db813fe8999b82c7f1c0" translate="yes" xml:space="preserve">
          <source>The intention of the restart mechanism is to prevent a situation where a process repeatedly dies for the same reason, only to be restarted again.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f04e21c615bcaa3bab7ffca923abd7b20f74b1c4" translate="yes" xml:space="preserve">
          <source>The interaction of option &lt;code&gt;global&lt;/code&gt; with a regular expression that matches an empty string surprises some users. When option &lt;code&gt;global&lt;/code&gt; is specified, &lt;code&gt;run/3&lt;/code&gt; handles empty matches in the same way as Perl: a zero-length match at any point is also retried with options &lt;code&gt;[anchored, notempty_atstart]&lt;/code&gt;. If that search gives a result of length &amp;gt; 0, the result is included. Example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="645847dee511adf6054272dd5554738165580583" translate="yes" xml:space="preserve">
          <source>The interactive Erlang shell, when started to a terminal or started using command &lt;code&gt;werl&lt;/code&gt; on Windows, can support Unicode input and output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85316f7b39c18cba3ed8c41e6e00aa4508657f73" translate="yes" xml:space="preserve">
          <source>The interface between the &lt;code&gt;Collector&lt;/code&gt; and its &lt;code&gt;Viewers&lt;/code&gt; is public in order to enable other types of &lt;code&gt;Viewers&lt;/code&gt;. However in the following text we will focus on usage of the &lt;code&gt;et_viewer&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d929ebaedeeb26c076c849c65d6a880fabbe836" translate="yes" xml:space="preserve">
          <source>The interface function &lt;code&gt;&lt;a href=&quot;ct#run_test-1&quot;&gt;ct:run_test/1&lt;/a&gt;&lt;/code&gt;, corresponding to the &lt;code&gt;ct_run&lt;/code&gt; program, is used for starting &lt;code&gt;Common Test&lt;/code&gt; from the Erlang shell (or an Erlang program). For details, see the &lt;code&gt;&lt;a href=&quot;ct&quot;&gt;ct&lt;/a&gt;&lt;/code&gt; manual page.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8d5bf454a2abaa2d99599aa77da439bfb1b0e39" translate="yes" xml:space="preserve">
          <source>The interface functions (&lt;code&gt;start_link/1&lt;/code&gt; and &lt;code&gt;button/1&lt;/code&gt;) are located in the same module as the callback functions (&lt;code&gt;init/1&lt;/code&gt;, &lt;code&gt;locked/3&lt;/code&gt;, and &lt;code&gt;open/3&lt;/code&gt;). It is normally good programming practice to have the client-side code and the server-side code contained in one module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3ffe36fe5fb02811ee7cbe99d87ab60dfaf7743" translate="yes" xml:space="preserve">
          <source>The interface functions (&lt;code&gt;start_link&lt;/code&gt;, &lt;code&gt;alloc&lt;/code&gt;, and &lt;code&gt;free&lt;/code&gt;) are then located in the same module as the callback functions (&lt;code&gt;init&lt;/code&gt;, &lt;code&gt;handle_call&lt;/code&gt;, and &lt;code&gt;handle_cast&lt;/code&gt;). This is normally good programming practice, to have the code corresponding to one process contained in one module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81df0f8bc6de0b4acea945c7c93ea405daa969a9" translate="yes" xml:space="preserve">
          <source>The interface of the filter function is the same as the the filter functions for the good old &lt;code&gt;lists:filtermap/2&lt;/code&gt;. If the filter returns &lt;code&gt;false&lt;/code&gt; it means that the trace data should silently be dropped. &lt;code&gt;true&lt;/code&gt; means that the trace data data already is an &lt;code&gt;Event Record&lt;/code&gt; and that it should be kept as it is. &lt;code&gt;true&lt;/code&gt; means that the &lt;code&gt;TraceData&lt;/code&gt; already is an &lt;code&gt;Event Record&lt;/code&gt; and that it should be kept as it is. &lt;code&gt;{true, NewEvent}&lt;/code&gt; means that the original trace data should be replaced with &lt;code&gt;Event&lt;/code&gt;. This provides means to get rid of unwanted &lt;code&gt;Events&lt;/code&gt; as well as enabling alternate views of an &lt;code&gt;Event&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="631992b55633d87ae608966e2309f0f4727adc29" translate="yes" xml:space="preserve">
          <source>The interface supports two basic scenarios of loading and unloading. Each scenario can also have the option of either killing ports when the driver is unloading, or waiting for the ports to close themselves. The scenarios are as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6996c2e840da27c2e132b6627f75acd9d9d5a71" translate="yes" xml:space="preserve">
          <source>The intermediate stage for a connected socket. There is to be no processing of input for this socket.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a87821499f533dec180c9e450557e45ce8484c82" translate="yes" xml:space="preserve">
          <source>The internal events are as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c740abc33f39344410422e82491682fb38f4e44d" translate="yes" xml:space="preserve">
          <source>The internal index of the port.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="965c55683139a0161e61ded48632af4d225cdd1d" translate="yes" xml:space="preserve">
          <source>The internal service name can be seen in the Windows service manager if viewing &lt;code&gt;Properties&lt;/code&gt; for an Erlang service.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41156700bf653a3e0e4298bb097606750ea7e9b5" translate="yes" xml:space="preserve">
          <source>The interpretation in some detail for the three operators:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ebf147e57bc82f05aaff52b7bfcaac8dbd9b6556" translate="yes" xml:space="preserve">
          <source>The interpretation is left as an exercise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1933de0224d21786fb43f077472bddf757fd1f65" translate="yes" xml:space="preserve">
          <source>The interpretation of a URI depends only on the characters used and not on how those characters are represented in a network protocol.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26e3837ab6ca4df148db60d98c6975bec751a92b" translate="yes" xml:space="preserve">
          <source>The interpretation of constants and variables are sets, and those sets can be used as the basis for forming new sets by the application of  &lt;strong id=&quot;set_operator&quot;&gt;set operators&lt;/strong&gt;. The syntax:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e923c1f615d5158c088a332c75e5ac9dd307ac63" translate="yes" xml:space="preserve">
          <source>The interpretation of some LineOp operator applied to a set of function calls assigns to each call the set of line numbers where the first function calls the second function. Not all calls are assigned line numbers by all operators:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa994c33b9388f94e332b012c066b84d979eb038" translate="yes" xml:space="preserve">
          <source>The interpretation of the  &lt;strong id=&quot;count&quot;&gt;counting operator&lt;/strong&gt; is the number of elements of a set. The operator is undefined for closures. The &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt; and &lt;code&gt;*&lt;/code&gt; operators are interpreted as the obvious arithmetical operators when applied to numbers. The syntax of the counting operator:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="029af9da1d3b7dfa078a55f2dfafcadb44b815ca" translate="yes" xml:space="preserve">
          <source>The interpretation of the  &lt;strong id=&quot;restriction&quot;&gt;restriction operators&lt;/strong&gt; is a subset of the first operand, a set of calls. The second operand, a set of vertices, is converted to the type of the first operand. The syntax of the restriction operators:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42a357f828f4be5cdec9a066f8f31849364dc8f3" translate="yes" xml:space="preserve">
          <source>The interpretation of the &lt;code&gt;Lin&lt;/code&gt; operator applied to a set of functions assigns to each function the line number where the function is defined. Unknown functions and functions of library modules are assigned the number 0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79e7f897549e217090e266a6ea8b4df3f84a5e55" translate="yes" xml:space="preserve">
          <source>The interpretation of the &lt;code&gt;closure&lt;/code&gt; operator is the transitive closure of the operand.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3da3bce7de2dcd2a2e677818a4ae2d0bdc921895" translate="yes" xml:space="preserve">
          <source>The interpretation of the &lt;code&gt;of&lt;/code&gt; operator is a chain of calls of the second operand (a set of calls) that passes throw all of the vertices of the first operand (a tuple of constants), in the given order. The second operand is converted to the type of the first operand. For instance, the &lt;code&gt;of&lt;/code&gt; operator can be used for finding out whether a function calls another function indirectly, and the chain of calls demonstrates how. The syntax of the graph analyzing operators:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0eda32350bebfe83b0d81b3598e00fc83971c333" translate="yes" xml:space="preserve">
          <source>The interpretation of the cast operator depends on the named type &lt;code&gt;Type&lt;/code&gt;, the type of &lt;code&gt;Expression&lt;/code&gt;, and the structure of the elements of the interpretation of &lt;code&gt;Expression&lt;/code&gt;. If the named type is equal to the expression type, no conversion is done. Otherwise, the conversion is done one step at a time; &lt;code&gt;(Fun)&amp;nbsp;(App)&amp;nbsp;RE&lt;/code&gt;, for instance, is equivalent to &lt;code&gt;(Fun)&amp;nbsp;(Mod)&amp;nbsp;(App)&amp;nbsp;RE&lt;/code&gt;. Now assume that the interpretation of &lt;code&gt;Expression&lt;/code&gt; is a set of constants (functions, modules, applications or releases). If the named type is more general than the expression type, say &lt;code&gt;Mod&lt;/code&gt; and &lt;code&gt;Fun&lt;/code&gt; respectively, then the interpretation of the cast expression is the set of modules that have at least one of their functions mentioned in the interpretation of the expression. If the named type is more special than the expression type, say &lt;code&gt;Fun&lt;/code&gt; and &lt;code&gt;Mod&lt;/code&gt;, then the interpretation is the set of all the functions of the modules (in &lt;code&gt;modules&lt;/code&gt; mode, the conversion is partial since the local functions are not known). The conversions to and from applications and releases work analogously. For instance, &lt;code&gt;(App) &quot;xref_.*&quot; : Mod&lt;/code&gt; returns all applications containing at least one module such that &lt;code&gt;xref_&lt;/code&gt; is a prefix of the module name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6993da444161dc204cc03e12d5fc3810b9cd2d1f" translate="yes" xml:space="preserve">
          <source>The interpretation of this time field depends on the operating system. On Unix, it is the last time the file or the &lt;code&gt;inode&lt;/code&gt; was changed. In Windows, it is the create time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91054e3a873098417a4f5c515e5ee9a48b04d7dd" translate="yes" xml:space="preserve">
          <source>The interpreted function call has returned a value, and the process is no longer executing interpreted code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3cabfaea9757a021ed3e404bb4e938889922f05f" translate="yes" xml:space="preserve">
          <source>The interpreter depends on the Kernel, STDLIB, and GS applications. This means that modules belonging to any of these applications are not allowed to be interpreted, as it could lead to a deadlock or emulator crash. This also applies to modules belonging to the Debugger application.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b74c0c5597c96d6ab8e51a9cb5a0af4d7d7773f" translate="yes" xml:space="preserve">
          <source>The interpreter requires both the source code and the object code. The object code &lt;strong&gt;must&lt;/strong&gt; include debug information, that is, only modules compiled with option &lt;code&gt;debug_info&lt;/code&gt; set can be interpreted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a87e9cf7deb8f947251ab88b658e53f7027d6b5d" translate="yes" xml:space="preserve">
          <source>The introduction of Erlang monotonic time allows us to adjust the two Erlang times (Erlang monotonic time and Erlang system time) separately. By doing this, the accuracy of elapsed time does not have to suffer just because the system time happened to be wrong at some point in time. Separate adjustments of the two times are only performed in the time warp modes, and only fully separated in the &lt;code&gt;&lt;a href=&quot;#Multi_Time_Warp_Mode&quot;&gt;multi-time warp mode&lt;/a&gt;&lt;/code&gt;. All other modes than the multi-time warp mode are for backward compatibility reasons. When using these modes, the accuracy of Erlang monotonic time suffer, as the adjustments of Erlang monotonic time in these modes are more or less tied to Erlang system time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4aa282f4900a445d575232fb66e91f370519721d" translate="yes" xml:space="preserve">
          <source>The inverse case of assertEqual, for convenience.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c146628c3a85cf3e58449747def90c476aa8e70" translate="yes" xml:space="preserve">
          <source>The inverse case of assertMatch, for convenience.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2bf283e78cc5757549c9cd4cea259895effeb450" translate="yes" xml:space="preserve">
          <source>The ip trace driver has a queue of &lt;code&gt;QueSize&lt;/code&gt; messages waiting to be delivered. If the driver cannot deliver messages as fast as they are produced by the runtime system, a special message is sent, which indicates how many messages that are dropped. That message will arrive at the handler function specified in &lt;code&gt;&lt;a href=&quot;#trace_client-3&quot;&gt;trace_client/3&lt;/a&gt;&lt;/code&gt; as the tuple &lt;code&gt;{drop, N}&lt;/code&gt; where &lt;code&gt;N&lt;/code&gt; is the number of consecutive messages dropped. In case of heavy tracing, drop's are likely to occur, and they surely occur if no client is reading the trace messages. The default value of &lt;code&gt;QueSize&lt;/code&gt; is 200.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1cc4bd29058e4c95bb51a0143db9193819039f9d" translate="yes" xml:space="preserve">
          <source>The isolation property ensures that transactions that execute on different nodes in a network, and access and manipulate the same data records, do not interfere with each other. The isolation property makes it possible to execute the function &lt;code&gt;raise/2&lt;/code&gt; concurrently. A classical problem in concurrency control theory is the &quot;lost update problem&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b7ca45a26b149b7bec285f808a539b088d510f6" translate="yes" xml:space="preserve">
          <source>The isolation property is compromised, because other Erlang processes, which use transaction to manipulate the data, do not get the benefit of isolation if dirty operations simultaneously are used to read and write records from the same table.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f15766776f9f8c25cf7a58ac94784f1f3ead7adc" translate="yes" xml:space="preserve">
          <source>The isolation property is in particular useful if the following circumstances occur where an employee (with employee number 123) and two processes (P1 and P2) are concurrently trying to raise the salary for the employee:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="284c773ace5ac2a66861a95faee4480ce7506813" translate="yes" xml:space="preserve">
          <source>The issuer id consists of the serial number and the issuers name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="afc376918231468e613617267d35779bd5d5d659" translate="yes" xml:space="preserve">
          <source>The item was not present in the system at the point of failure.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d57c675d8a8485a1824af8a77e5919d6b9669f2e" translate="yes" xml:space="preserve">
          <source>The items in this menu are used to create and delete breakpoints. For details, see section &lt;code&gt;&lt;a href=&quot;#breakpoints&quot;&gt;Breakpoints&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="481eae0056ff6c417a15e2d26dc9dfb9c5c8016d" translate="yes" xml:space="preserve">
          <source>The join is to be expressed as a guard filter. The filter must be placed immediately after the two joined generators, possibly after guard filters that use variables from no other generators but the two joined generators. The &lt;code&gt;qlc&lt;/code&gt; module inspects the operands of &lt;code&gt;=:=/2&lt;/code&gt;, &lt;code&gt;==/2&lt;/code&gt;, &lt;code&gt;is_record/2&lt;/code&gt;, &lt;code&gt;element/2&lt;/code&gt;, and logical operators (&lt;code&gt;and/2&lt;/code&gt;, &lt;code&gt;or/2&lt;/code&gt;, &lt;code&gt;andalso/2&lt;/code&gt;, &lt;code&gt;orelse/2&lt;/code&gt;, &lt;code&gt;xor/2&lt;/code&gt;) when determining which joins to consider.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90b36f2ace473010b2db9075b6ab6adecda8977a" translate="yes" xml:space="preserve">
          <source>The kernel supervisor has detected a failure, usually that the &lt;code&gt;application_controller&lt;/code&gt; has shut down (&lt;code&gt;Who&lt;/code&gt; = &lt;code&gt;application_controller&lt;/code&gt;, &lt;code&gt;Why&lt;/code&gt; = &lt;code&gt;shutdown&lt;/code&gt;). The application controller can have shut down for many reasons, the most usual is that the node name of the distributed Erlang node is already in use. A complete supervisor tree &quot;crash&quot; (that is, the top supervisors have exited) gives about the same result. This message comes from the Erlang code and not from the virtual machine itself. It is always because of some failure in an application, either within OTP or a &quot;user-written&quot; one. Looking at the error log for your application is probably the first step to take.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87cfd3cdc21e12ece215da1ff3c7bd0778edf3ae" translate="yes" xml:space="preserve">
          <source>The key &lt;code&gt;mod&lt;/code&gt; defines the callback module and start argument of the application, in this case &lt;code&gt;ch_app&lt;/code&gt; and &lt;code&gt;[]&lt;/code&gt;, respectively. This means that the following is called when the application is to be started:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63c37d9d912063a1a57159881898bac71cffe007" translate="yes" xml:space="preserve">
          <source>The key above can be written as &lt;code&gt;&quot;\\hklm\\software\\ericsson\\erlang\\5.0&quot;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4de5a958aeabffb38a49fbf124f00c275f5ea14" translate="yes" xml:space="preserve">
          <source>The key can be provided in the following two ways:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e475f564fef24efe7c2edd2e65ff61b8004f591" translate="yes" xml:space="preserve">
          <source>The key position is obtained by calling &lt;code&gt;InfoFun(keypos)&lt;/code&gt; and the indexed positions by calling &lt;code&gt;InfoFun(indices)&lt;/code&gt;. If the key position can be used for lookup, it is always chosen, otherwise the indexed position requiring the least number of lookups is chosen. If there is a tie between two indexed positions, the one occurring first in the list returned by &lt;code&gt;InfoFun&lt;/code&gt; is chosen. Positions requiring more than &lt;code&gt;&lt;a href=&quot;#max_lookup&quot;&gt;max_lookup&lt;/a&gt;&lt;/code&gt; lookups are ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06c2324ad19db22f732f87371d50b783de7c2324" translate="yes" xml:space="preserve">
          <source>The key position.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8b10ddac8355f7a246ab0ac12d610b134228817" translate="yes" xml:space="preserve">
          <source>The key's password</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f88e9f9a4e85f1b89fcef9e232ae2c64409d89a5" translate="yes" xml:space="preserve">
          <source>The key-value pairs of a map have no defined iteration order. The only guarantee is that the iteration order of a single map instance is preserved during the lifetime of the environment that the map belongs to.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e64b8f95a5f079901b89db2a9fb2daa26e73a227" translate="yes" xml:space="preserve">
          <source>The keys &lt;code&gt;intensity&lt;/code&gt; and &lt;code&gt;period&lt;/code&gt; are optional in the supervisor flags map. If they are not given, they default to &lt;code&gt;1&lt;/code&gt; and &lt;code&gt;5&lt;/code&gt;, respectively.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a715eaeca461686c2d011a0989c495c1be24a00f" translate="yes" xml:space="preserve">
          <source>The keys and some other data are by default stored in files in the directory &lt;code&gt;.ssh&lt;/code&gt; in the user's home directory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e270d4cb9c5a1f53027b9df8a800abde232726f8" translate="yes" xml:space="preserve">
          <source>The keys are by default stored in files:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66af8fb8940dc217a32c86c117d958eb57768c52" translate="yes" xml:space="preserve">
          <source>The keys for the symmetric encryption are generated uniquely for each connection and are based on a secret negotiated in the TLS/DTLS handshake.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aff18d7af60baca2c26521c99fcf528391bc0c76" translate="yes" xml:space="preserve">
          <source>The label is intended to provide a brief summary of the event. It is preferred to use an atom but a string would also do.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="edeb86123112824d83ee0303c271a4cb682dd647" translate="yes" xml:space="preserve">
          <source>The language setting in the operating system mainly affects the shell. The terminal (that is, the group leader) operates with &lt;code&gt;{encoding, unicode}&lt;/code&gt; only if the environment tells it that UTF-8 is allowed. This setting is to correspond to the terminal you are using.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d5867e4e848137cec6dd146c4e2783ad319840b" translate="yes" xml:space="preserve">
          <source>The last &lt;code&gt;&lt;a href=&quot;#monotonic_time-0&quot;&gt;Erlang monotonic time&lt;/a&gt;&lt;/code&gt; in &lt;code&gt;native&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;#type_time_unit&quot;&gt;time unit&lt;/a&gt;&lt;/code&gt; that can be represented internally in the current Erlang runtime system instance. The time between the &lt;code&gt;&lt;a href=&quot;#system_info_start_time&quot;&gt;start time&lt;/a&gt;&lt;/code&gt; and the end time is at least a quarter of a millennium.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cbf7bc8595fbcb78ce027c719bffd4ff1c3073de" translate="yes" xml:space="preserve">
          <source>The last column is the internal column. When performing a &lt;code&gt;set&lt;/code&gt; operation, which creates a row, we must give a value to the internal column. The instrumentation functions will now look as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="184226eab517900aa5e104f77b408fc4703f673c" translate="yes" xml:space="preserve">
          <source>The last group in the specified path is the terminating group in the test, that is, no subgroups following this group are executed. In the previous example, &lt;code&gt;g4&lt;/code&gt; is the terminating group. Hence, &lt;code&gt;Common Test&lt;/code&gt; executes a test that calls all &lt;code&gt;init&lt;/code&gt; configuration functions in the path to &lt;code&gt;g4&lt;/code&gt;, that is, &lt;code&gt;g1..g3..g4&lt;/code&gt;. It then calls test cases &lt;code&gt;tc1&lt;/code&gt; and &lt;code&gt;tc5&lt;/code&gt; in &lt;code&gt;g4&lt;/code&gt;, and finally all &lt;code&gt;end&lt;/code&gt; configuration functions in order &lt;code&gt;g4..g3..g1&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8fa1840cc2c30d96ac21156af3e40270a8d80935" translate="yes" xml:space="preserve">
          <source>The last line is generated due to internal message passing in the Erlang shell. The process id's will vary.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e64b76cd01b4823944e2365efd79f7ca4112521f" translate="yes" xml:space="preserve">
          <source>The last part of the grammar file is an optional section with Erlang code (= function definitions) which is included 'as is' in the resulting parser file. This section must start with the pseudo declaration, or key words</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6f5d3a54465773e89b4c8e688e662aaa9749ae4" translate="yes" xml:space="preserve">
          <source>The last step is to create boot scripts to make the protocol implementation available at boot time. The implementation can be debugged by starting the distribution when all the system is running, but in a real system the distribution is to start very early, why a boot script and some command-line parameters are necessary.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45a35c1b9bd211b68b47957d2e49a6e71571d068" translate="yes" xml:space="preserve">
          <source>The last test to run is for system &lt;code&gt;t3&lt;/code&gt;. Here, all suites are skipped and this is explicitly noted in the log files.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8852e7914b224a1a777608407ab41bad01ca2077" translate="yes" xml:space="preserve">
          <source>The last time the file was read.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="791648c90deaadf98f3326f3b6bcff45e17be84e" translate="yes" xml:space="preserve">
          <source>The last time the file was written.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="072e3449b89f599c8bc8ba1995b3f4a85ad87776" translate="yes" xml:space="preserve">
          <source>The latter example is equivalent to the former, which can be verified using function &lt;code&gt;qlc:info/1&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ba708046f3a5ea5ae482709704f7c918ddacbf9" translate="yes" xml:space="preserve">
          <source>The latter functions are needed only when new config directives are to be introduced. For details, see &lt;code&gt;&lt;a href=&quot;httpd&quot;&gt;httpd(3)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cfe702a557aaf2b0af643fec45c2fbcc306adfbd" translate="yes" xml:space="preserve">
          <source>The latter specification says that the function takes some tuple and returns some tuple. The specification with the &lt;code&gt;X&lt;/code&gt; type variable specifies that the function takes a tuple and returns &lt;strong&gt;the same&lt;/strong&gt; tuple.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e60740c974cd4ca31f6898f4c908ec03d194026" translate="yes" xml:space="preserve">
          <source>The least maximum packet size that the daemon will accept in channel open requests from the client. The default value is 0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0dde3cfeba08df09564d97f09effbfe3c18694c1" translate="yes" xml:space="preserve">
          <source>The least significant bit in that half byte is flag &lt;code&gt;LongAtoms&lt;/code&gt;. If it is set, 2 bytes are used for atom lengths instead of 1 byte in the distribution header.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10c687faf784f36e13b6f57d77f566d81227f644" translate="yes" xml:space="preserve">
          <source>The left associative arithmetic operators are evaluated left to right:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16a5e87b76355a265a2acff30311f789fd728096" translate="yes" xml:space="preserve">
          <source>The left hand side is a non-terminal category. The right hand side is a sequence of one or more non-terminal or terminal symbols with spaces between. The associated code is a sequence of zero or more Erlang expressions (with commas &lt;code&gt;','&lt;/code&gt; as separators). If the associated code is empty, the separating colon &lt;code&gt;':'&lt;/code&gt; is also omitted. A final dot marks the end of the rule.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d15c8b505512cf7ef5ed3725e558edb04ee8e3f" translate="yes" xml:space="preserve">
          <source>The legacy and intermediate variables &lt;code&gt;address&lt;/code&gt; and &lt;code&gt;domain&lt;/code&gt; are still supported so old configurations will work.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d5b31ada6fd921f21fd7ea3a8c8a6e7b646094e" translate="yes" xml:space="preserve">
          <source>The legacy and intermediate variables &lt;code&gt;intAgentIpAddress&lt;/code&gt; and &lt;code&gt;intAgentTransportDomain&lt;/code&gt; are still supported so old &lt;code&gt;agent.conf&lt;/code&gt; files will work.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4544ea5bcba9a54bca20006006b59bdb9618fafb" translate="yes" xml:space="preserve">
          <source>The length (in bytes) of atom &lt;code&gt;t&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7315fe138888586d2580dc24cb36b5eccee73131" translate="yes" xml:space="preserve">
          <source>The length (in bytes) of binary object &lt;code&gt;t&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ddba0164da7862c7ff2f4f524f8c9cbb1852156f" translate="yes" xml:space="preserve">
          <source>The length (in bytes) of field &lt;code&gt;NodeName&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31080ac8eb9821d87bfa8097d8cf1b74183eeb9a" translate="yes" xml:space="preserve">
          <source>The length of a list with the first element &lt;code&gt;First&lt;/code&gt; and the remaining elements &lt;code&gt;Rest&lt;/code&gt; is 1 + the length of &lt;code&gt;Rest&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f96f13301619a2d2b302b2c22fb4b20b1a059059" translate="yes" xml:space="preserve">
          <source>The length of an empty list is obviously 0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1de7130de2bc092009b6447a54b5cc56f2e0ac6" translate="yes" xml:space="preserve">
          <source>The length of field &lt;code&gt;Extra&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6031d07abc01be3ec4d2fad520f49b18ab9f57ce" translate="yes" xml:space="preserve">
          <source>The length of the message queue for the process.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15fbacbdc36d9fa85ce6b119e70f9944e34bbef9" translate="yes" xml:space="preserve">
          <source>The library &lt;code&gt;ei&lt;/code&gt; contains macros and functions to encode and decode the Erlang binary term format.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1a396fcf8bb30c9c4e81871da3298d0c3af7de9" translate="yes" xml:space="preserve">
          <source>The library did not fulfill the requirements as a NIF library of the calling module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4000d6b2656172da8f1ebb8bb8da55bc7e83a2fc" translate="yes" xml:space="preserve">
          <source>The library fails to load if &lt;code&gt;load&lt;/code&gt; returns anything other than &lt;code&gt;0&lt;/code&gt;. &lt;code&gt;load&lt;/code&gt; can be &lt;code&gt;NULL&lt;/code&gt; if initialization is not needed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7c36356b1ef653f4eb93e620c175a01deae68b6" translate="yes" xml:space="preserve">
          <source>The library fails to load if &lt;code&gt;upgrade&lt;/code&gt; returns anything other than &lt;code&gt;0&lt;/code&gt; or if &lt;code&gt;upgrade&lt;/code&gt; is &lt;code&gt;NULL&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d68ce185719476197d42f3853f9b5b1affcf038" translate="yes" xml:space="preserve">
          <source>The library handles byte-oriented data. For bitstrings that are not binaries (does not contain whole octets of bits) a &lt;code&gt;badarg&lt;/code&gt; exception is thrown from any of the functions in this module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58751b20a63ee8ce5dffe3bf1fdb22852c369253" translate="yes" xml:space="preserve">
          <source>The library initialization callbacks &lt;code&gt;load&lt;/code&gt; and &lt;code&gt;upgrade&lt;/code&gt; are thread-safe even for shared state data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="525c752158ef80bf2ab4b174acb04d2294619c57" translate="yes" xml:space="preserve">
          <source>The library path  &lt;code id=&quot;code_path&quot;&gt;code_path&lt;/code&gt; is used by the functions &lt;code&gt;m/1&lt;/code&gt; and &lt;code&gt;d/1&lt;/code&gt;, but can also be set explicitly. Note however that the code path will be traversed once for each used &lt;code&gt;&lt;a href=&quot;#library_module&quot;&gt;library module&lt;/a&gt;&lt;/code&gt; while setting up module data. On the other hand, if there are only a few modules that are used but not analyzed, using &lt;code&gt;code_path&lt;/code&gt; may be faster than setting the library path to &lt;code&gt;code:get_path()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72d5d28aae4fd1fc9e01fcb3c39ddb230755733d" translate="yes" xml:space="preserve">
          <source>The line and column where the token begins, or just the line if the column is unknown.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="360684cf560fc66328b23d2a88ed263288ae0193" translate="yes" xml:space="preserve">
          <source>The line number where the token occurred.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32ef4a94e615116b5f15d93da06b8801c1438276" translate="yes" xml:space="preserve">
          <source>The line where the token begins.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06982a696a56059b28dcc90e39b170a06c23c36e" translate="yes" xml:space="preserve">
          <source>The lines where functions are defined (more precisely: where the first clause begins) and the lines where functions are used are available in &lt;code&gt;functions&lt;/code&gt; mode. The line numbers refer to the files where the functions are defined. This holds also for files included with the &lt;code&gt;-include&lt;/code&gt; and &lt;code&gt;-include_lib&lt;/code&gt; directives, which may result in functions defined apparently in the same line. The &lt;strong&gt;line operators&lt;/strong&gt; are used for assigning line numbers to functions and for assigning sets of line numbers to function calls. The syntax is similar to the one of the cast operator:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d24fd42f9853b856c640811e28979dbf854c2b78" translate="yes" xml:space="preserve">
          <source>The lines where the external calls of the example before last are made.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d24fdb17e4fea5eb7628e12a6c79e2f53029142b" translate="yes" xml:space="preserve">
          <source>The lines where the local calls of the last example are made.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2e317995e860f4cf19c85bed428103e5fa4c987" translate="yes" xml:space="preserve">
          <source>The list &lt;code&gt;&lt;a href=&quot;xref#representation&quot;&gt;representation of graphs&lt;/a&gt;&lt;/code&gt; is used analyzing direct calls, while the &lt;code&gt;digraph&lt;/code&gt; representation is suited for analyzing indirect calls. The restriction operators (&lt;code&gt;|&lt;/code&gt;, &lt;code&gt;||&lt;/code&gt; and &lt;code&gt;|||&lt;/code&gt;) are the only operators that accept both representations. This means that in order to analyze indirect calls using restriction, the &lt;code&gt;closure&lt;/code&gt; operator (which creates the &lt;code&gt;digraph&lt;/code&gt; representation of graphs) has to be applied explicitly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ffd5b9d0b2da7f031376ce2e3f4de1790dbcb873" translate="yes" xml:space="preserve">
          <source>The list &lt;code&gt;Args&lt;/code&gt; no longer contains the arguments, but the same number of atoms as the number of arguments; the first atom is &lt;code&gt;'Argument__1'&lt;/code&gt;, the second &lt;code&gt;'Argument__2'&lt;/code&gt;, and so on. The reason is that the argument list could waste a significant amount of memory, and if the argument list contained funs, it could be impossible to upgrade the code for the module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9fe5976fc2a1ed8cd95c6aebc522dfac26e44839" translate="yes" xml:space="preserve">
          <source>The list can also include any of the flags allowed in &lt;code&gt;erlang:trace/3&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da6db7b25a7a041b2bd8a84f4bc3822e1da0eef8" translate="yes" xml:space="preserve">
          <source>The list can be retrieved with &lt;code&gt;&lt;a href=&quot;#env_compiler_options-0&quot;&gt;env_compiler_options/0&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f867b0a6e2ade5a232d4c40764e78cd0cbf33e8" translate="yes" xml:space="preserve">
          <source>The list concatenation operator &lt;code&gt;++&lt;/code&gt; appends its second argument to its first and returns the resulting list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32f8386d87e909841366c0d0ccad694e85e74074" translate="yes" xml:space="preserve">
          <source>The list contains two-tuples with &lt;code&gt;Key&lt;/code&gt;s as first element, and &lt;code&gt;Value&lt;/code&gt;s as second element. The order if these tuples is undefined. The following tuples can be part of the list, but more tuples can be introduced in the future:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9bdaf0305629367e99487e912564f15660d944d8" translate="yes" xml:space="preserve">
          <source>The list is appended to any options given to &lt;code&gt;&lt;a href=&quot;#file-2&quot;&gt;file/2&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#forms-2&quot;&gt;forms/2&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;#output_generated-1&quot;&gt;output_generated/2&lt;/a&gt;&lt;/code&gt;. Use the alternative functions &lt;code&gt;&lt;a href=&quot;#noenv_file-2&quot;&gt;noenv_file/2&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#noenv_forms-2&quot;&gt;noenv_forms/2&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;#noenv_output_generated-1&quot;&gt;noenv_output_generated/2&lt;/a&gt;&lt;/code&gt; if you do not want the environment variable to be consulted, for example, if you are calling the compiler recursively from inside a parse transform.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3b32daab7fb1e19913c070d23e0ea4b8468b157" translate="yes" xml:space="preserve">
          <source>The list of (visible) nodes currently connected to is returned by &lt;code&gt;nodes()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b60dab1d9d95dba89e1bcb54a37f2a68e4f7112c" translate="yes" xml:space="preserve">
          <source>The list of applications must contain the Kernel and STDLIB applications.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1993372f86c3ca2fcdaa4d4bdbaa44aa452f9b73" translate="yes" xml:space="preserve">
          <source>The list of arguments to the &lt;code&gt;init&lt;/code&gt; function of the callback module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a7dbd6dc14496e939ba002f5d8d58309bf69a66" translate="yes" xml:space="preserve">
          <source>The list of attributes becomes empty if the module is stripped with the &lt;code&gt;beam_lib(3)&lt;/code&gt; module (in STDLIB).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e28c0b378c7e30234825e4c28e09987fea8b7d5" translate="yes" xml:space="preserve">
          <source>The list of attributes is sorted on &lt;code&gt;Attribute&lt;/code&gt; (in &lt;code&gt;attrib_entry()&lt;/code&gt;) and each attribute name occurs once in the list. The attribute values occur in the same order as in the file. The lists of functions are also sorted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ab8914ad054b49e90cc2dd0c7617689deb0ec65" translate="yes" xml:space="preserve">
          <source>The list of binaries used for search alternatives must be flat and proper.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4aa24e9ead310fa857b3ae54bebbc5e4c77a275b" translate="yes" xml:space="preserve">
          <source>The list of column names is ordered in the same way as the list of values of a row, e.g. the first &lt;code&gt;ColName&lt;/code&gt; is associated with the first &lt;code&gt;Value&lt;/code&gt; in a &lt;code&gt;Row&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e441bd917def7eab6debc68f650fc15899ecb1b8" translate="yes" xml:space="preserve">
          <source>The list of examples can be made long. One need a kind of knowledge that was not needed when programs only considered one or two languages. The complexity of human languages and scripts has certainly made this a challenge when constructing a universal standard. Supporting Unicode properly in your program will require effort.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9263bcdcc9a4162758b1c2d0636a8277b41c8e1" translate="yes" xml:space="preserve">
          <source>The list of protocols is in order of preference. The protocol negotiated will be the first in the list that matches one of the protocols advertised by the client. If no protocol matches, the server will fail the connection with a &quot;no_application_protocol&quot; alert.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a34fbb4766ea85a1f9d8f22cb9859cc99bb888c" translate="yes" xml:space="preserve">
          <source>The list of protocols must not contain an empty binary.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9fbf59d4843615920d8035868251705ea8faee6" translate="yes" xml:space="preserve">
          <source>The list of protocols supported by the client to be sent to the server to be used for an Application-Layer Protocol Negotiation (ALPN). If the server supports ALPN then it will choose a protocol from this list; otherwise it will fail the connection with a &quot;no_application_protocol&quot; alert. A server that does not support ALPN will ignore this value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7ac87c7d4335021ee1fa77bdee81b3d2fc28da7" translate="yes" xml:space="preserve">
          <source>The list of scheduler information is unsorted and can appear in different order between calls.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53177127ac53807caaec1a5f4ac0ff7d969ee202" translate="yes" xml:space="preserve">
          <source>The list of thread information is unsorted and can appear in different order between calls.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f6ff9051ce3adf391b324c7141d157fd50f0f8f" translate="yes" xml:space="preserve">
          <source>The list structure is invalid (a number as tail).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90359ff88196faa6388683deff22b771581b0f36" translate="yes" xml:space="preserve">
          <source>The list subtraction operator &lt;code&gt;--&lt;/code&gt; produces a list that is a copy of the first argument. The procedure is a follows: for each element in the second argument, the first occurrence of this element (if any) is removed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="015b99d661bab28e17445e0783bc50c17f9fd517" translate="yes" xml:space="preserve">
          <source>The listed applications are not only original Erlang/OTP applications but possibly also new applications that you have written (here exemplified by the application Pea (&lt;code&gt;pea&lt;/code&gt;)).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1a6d7b7d2505dd4415caa1c747f640e87d05200" translate="yes" xml:space="preserve">
          <source>The listing shows &lt;code&gt;mnesia_locker&lt;/code&gt;, a process, has highly contended locks.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7824d7fdf06f507845f19aac3e93cad24e62691c" translate="yes" xml:space="preserve">
          <source>The lists are (named as in the SSH application's options):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e47f7860f16d8f455b34192361d141ea74928549" translate="yes" xml:space="preserve">
          <source>The literal character &quot;]&quot; cannot be the end character of a range. A pattern such as [W-]46] is interpreted as a class of two characters (&quot;W&quot; and &quot;-&quot;) followed by a literal string &quot;46]&quot;, so it would match &quot;W46]&quot; or &quot;-46]&quot;. However, if &quot;]&quot; is escaped with a backslash, it is interpreted as the end of range, so [W-\]46] is interpreted as a class containing a range followed by two other characters. The octal or hexadecimal representation of &quot;]&quot; can also be used to end a range.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a151d7c8c495b43d8c9ca28cb4fd22e5563c1c3" translate="yes" xml:space="preserve">
          <source>The load request is registered, but the loading is delayed because an earlier instance of the driver is still waiting to get unloaded (open ports use it). Still, unload is expected when you are done with the driver. This return value &lt;strong&gt;mostly&lt;/strong&gt; occurs when options &lt;code&gt;{reload,pending_driver}&lt;/code&gt; or &lt;code&gt;{reload,pending}&lt;/code&gt; are used, but &lt;strong&gt;can&lt;/strong&gt; occur when another &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;user&lt;/a&gt;&lt;/code&gt; is unloading a driver in parallel and driver option &lt;code&gt;kill_ports&lt;/code&gt; is set. In other words, this return value always needs to be handled.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93816305e042fa9b1290121579e7bab7986a2b27" translate="yes" xml:space="preserve">
          <source>The load request is registered, but the loading is delayed because an earlier instance of the driver is still waiting to get unloaded by another &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;user&lt;/a&gt;&lt;/code&gt; (not only by a port, in which case &lt;code&gt;{ok,pending_driver}&lt;/code&gt; would have been returned). Still, unload is expected when you are done with the driver. This return value &lt;strong&gt;only&lt;/strong&gt; occurs when option &lt;code&gt;{reload,pending}&lt;/code&gt; is used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82d30f913008685e194b4636bf5269a0b248f283" translate="yes" xml:space="preserve">
          <source>The load values are proportional to how long time a runnable Unix process has to spend in the run queue before it is scheduled. Accordingly, higher values mean more system load. The returned value divided by 256 produces the figure displayed by &lt;code&gt;rup&lt;/code&gt; and &lt;code&gt;top&lt;/code&gt;. What is displayed as 2.00 in &lt;code&gt;rup&lt;/code&gt;, is displayed as load up to the second mark in &lt;code&gt;xload&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e778b9f1baa2ba78c9a8b99dac7d82d4dd62545a" translate="yes" xml:space="preserve">
          <source>The local address of the socket.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2cbe8d9027d2e67a3221c97411a93a55c403aba2" translate="yes" xml:space="preserve">
          <source>The local hostname.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d70c0c380895bb03a1a2bbd03acd9232797565f" translate="yes" xml:space="preserve">
          <source>The local mid (of the connection, i.e. the own mid). &lt;code&gt;megaco_mid()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ca9eb8c2f734b6ef1d76976ee366124ff598fcc" translate="yes" xml:space="preserve">
          <source>The local node is not alive.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9da45befb57e0a6e8d60cb2a231a07186dafa5dc" translate="yes" xml:space="preserve">
          <source>The local process was monitoring the remote process at the time of the crash.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0faaeec49d245a46502b8c7536db4c7e2f24fafe" translate="yes" xml:space="preserve">
          <source>The location of the Erlang emulator. The default is the &lt;code&gt;erl.exe&lt;/code&gt; located in the same directory as &lt;code&gt;erlsrv.exe&lt;/code&gt;. Do not specify &lt;code&gt;werl.exe&lt;/code&gt; as this emulator, it will not work.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94ca339fcbea0bf957948c562687f39b4e2a7718" translate="yes" xml:space="preserve">
          <source>The location of the file &lt;code&gt;start_erl.data&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67a812bb246705dde14edb442f878d3a06f58d28" translate="yes" xml:space="preserve">
          <source>The lock is acquired on &lt;code&gt;LockItem&lt;/code&gt; on all nodes in the node list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb95c03b38e9e250b3764b1b69a94cf910fd3f1f" translate="yes" xml:space="preserve">
          <source>The log can be either a &lt;code&gt;read&lt;/code&gt;, &lt;code&gt;write&lt;/code&gt; or a &lt;code&gt;read_write&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8084a2197c0ae9cceee71abbb7d30557e1d027d1" translate="yes" xml:space="preserve">
          <source>The log event used in the examples is:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33cf2a0cd54fceab0e5adde86b3ea4f3d0186889" translate="yes" xml:space="preserve">
          <source>The log file grows continuously and must be dumped at regular intervals. &quot;Dumping the log file&quot; means that &lt;code&gt;Mnesia&lt;/code&gt; performs all the operations listed in the log and place the records in the corresponding &lt;code&gt;.DAT&lt;/code&gt;, &lt;code&gt;.DCD&lt;/code&gt;, and &lt;code&gt;.DCL&lt;/code&gt; data files. For example, if the operation &quot;write record &lt;code&gt;{foo, 4, elvis, 6}&lt;/code&gt;&quot; is listed in the log, &lt;code&gt;Mnesia&lt;/code&gt; inserts the operation into the file &lt;code&gt;foo.DCL&lt;/code&gt;. Later, when &lt;code&gt;Mnesia&lt;/code&gt; thinks that the &lt;code&gt;.DCL&lt;/code&gt; file is too large, the data is moved to the &lt;code&gt;.DCD&lt;/code&gt; file. The dumping operation can be time consuming if the log is large. Notice that the &lt;code&gt;Mnesia&lt;/code&gt; system continues to operate during log dumps.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05378e99ad67de335df2edd4587676257847240f" translate="yes" xml:space="preserve">
          <source>The log files are written continuously during a test run and links are always created initially when a test starts. Thevtest progress can therefore be followed simply by refreshing pages in the HTML browser. Statistics totals are not presented until a test is complete however.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09d8292095f3c463951aa3a38fcb81bdb1a77b22" translate="yes" xml:space="preserve">
          <source>The log files, that is:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5dbdf4f4a2f484ace5b99188170053805f051195" translate="yes" xml:space="preserve">
          <source>The log function takes three arguments, &lt;code&gt;fun(Level, FormatString, [FormatArg]) end&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70e83f6de81bba1e8369d3fb4c74e2e701680bf9" translate="yes" xml:space="preserve">
          <source>The log is also dumped at startup and whenever a schema operation is performed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e63f405b602b189c562910f99bbf0f61b97eb9a" translate="yes" xml:space="preserve">
          <source>The log level can be changed to error or info, see &lt;code&gt;&lt;a href=&quot;#warning_map-0&quot;&gt;warning_map/0&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52f3c1c01d0caa39ade0e63e03754a32f5ea8746" translate="yes" xml:space="preserve">
          <source>The log level for a module overrides the primary log level of Logger for log events originating from the module in question. Notice, however, that it does not override the level configuration for any handler.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ef6ed5dbe5f350a3677cd9b499598f99164de3e" translate="yes" xml:space="preserve">
          <source>The log level indicates the severity of a event. In accordance with the Syslog protocol, &lt;code&gt;&lt;a href=&quot;https://www.ietf.org/rfc/rfc5424.txt&quot;&gt;RFC 5424&lt;/a&gt;&lt;/code&gt;, eight log levels can be specified. The following table lists all possible log levels by name (atom), integer value, and description:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1fc6320a2d9c1fb41416707d45873416f2a21be8" translate="yes" xml:space="preserve">
          <source>The log level is specified when adding the handler, or changed during runtime with, for instance, &lt;code&gt;&lt;a href=&quot;logger#set_handler_config-3&quot;&gt;logger:set_handler_config(HandlerId,level,Level)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21c56bbe5854873ac255ff079279c9dff663d1fe" translate="yes" xml:space="preserve">
          <source>The log message can also be provided through a fun for lazy evaluation. The fun is only evaluated if the primary log level check passes, and is therefore recommended if it is expensive to generate the message. The lazy fun must return a string, a report, or a tuple with format string and arguments.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="148877212af3299aabd6e2e80464a605727cd9f4" translate="yes" xml:space="preserve">
          <source>The log message contains the information to be logged. The message can consist of a format string and arguments (given as two separate parameters in the Logger API), a string or a report. The latter, which is either a map or a key-value list, can be accompanied by a &lt;strong&gt;report callback&lt;/strong&gt; specified in the log event's &lt;code&gt;&lt;a href=&quot;#metadata&quot;&gt;metadata&lt;/a&gt;&lt;/code&gt;. The report callback is a convenience function that the &lt;code&gt;&lt;a href=&quot;#formatters&quot;&gt;formatter&lt;/a&gt;&lt;/code&gt; can use to convert the report to a format string and arguments. The formatter can also use its own conversion function, if no callback is provided, or if a customized formatting is desired.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e0c9afffef01563d1e914bbb564b164c5c43598" translate="yes" xml:space="preserve">
          <source>The log type. Defaults to &lt;code&gt;halt&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e28a2d8b5a958d67c48ee8bc4c5069e252d9e6f6" translate="yes" xml:space="preserve">
          <source>The log uses a raw data format (basically the BER encoded message), in order to minimize the CPU load needed for the log mechanism. This means that the log is not human readable, but needs to be formatted off-line before it can be read. Use the function &lt;code&gt;&lt;a href=&quot;snmpa#log_to_txt&quot;&gt;snmpa:log_to_txt&lt;/a&gt;&lt;/code&gt; for this purpose.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="286976b20277382019a10c4770aeb782c67d3c09" translate="yes" xml:space="preserve">
          <source>The log uses a raw data format (basically the BER encoded message), in order to minimize the CPU load needed for the log mechanism. This means that the log is not human readable, but needs to be formatted off-line before it can be read. Use the function &lt;code&gt;&lt;a href=&quot;snmpm#log_to_txt&quot;&gt;snmpm:log_to_txt&lt;/a&gt;&lt;/code&gt; for this purpose.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96b3fd02f414c107ec8f4bbb84dfc360fb88eb27" translate="yes" xml:space="preserve">
          <source>The long synonyms for property names supported by Perl (such as \p{Letter}) are not supported by PCRE. It is not permitted to prefix any of these properties with &quot;Is&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf1f5fae62661eca849a838d180479af9bffc0a1" translate="yes" xml:space="preserve">
          <source>The look and feel on an Erlang shell inside Emacs should be the same as in a normal Erlang shell. There is just one major difference, the cursor keys will actually move the cursor around just like in any normal Emacs buffer. The command line history can be accessed by the following commands:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0df7a98e001c7e4a5d47744bc177ec50ac6e7aac" translate="yes" xml:space="preserve">
          <source>The lookup fun is to defined as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="026bec80693d2fc446353c2345ce4713bd83e4e1" translate="yes" xml:space="preserve">
          <source>The lookup function is optional. It is assumed that the lookup function always finds values much faster than it would take to traverse the table. The first argument is the position of the key. As &lt;code&gt;qlc_next/1&lt;/code&gt; returns the objects as &lt;code&gt;{Key,&amp;nbsp;Value}&lt;/code&gt; pairs, the position is 1. Notice that the lookup function is to return &lt;code&gt;{Key,&amp;nbsp;Value}&lt;/code&gt; pairs, as the traversal function does.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fabd07160cb884d874c4f9a6b01df339b79b9bb2" translate="yes" xml:space="preserve">
          <source>The lookup method &lt;code&gt;string&lt;/code&gt; tries to parse the hostname as an IPv4 or IPv6 string and return the resulting IP address. It is automatically tried first when &lt;code&gt;native&lt;/code&gt; is &lt;strong&gt;not&lt;/strong&gt; in the &lt;code&gt;Methods&lt;/code&gt; list. To skip it in this case, the pseudo lookup method &lt;code&gt;nostring&lt;/code&gt; can be inserted anywhere in the &lt;code&gt;Methods&lt;/code&gt; list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97cdecdfe5db74108a6e54e74406dd0b623db1c5" translate="yes" xml:space="preserve">
          <source>The lowest distribution version that this node can handle. The value in Erlang/OTP R6B and later is 5.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0b970e479bf0315a32496d0381fe4d1214762f9" translate="yes" xml:space="preserve">
          <source>The machine name, &lt;code&gt;'BEAM'&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="afb285d4f389b85ea26f3cda19e5a047be514a48" translate="yes" xml:space="preserve">
          <source>The macro &lt;code&gt;?Q(Text)&lt;/code&gt; expands to &lt;code&gt;merl:quote(?LINE, Text, Env)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="111750be1ff5da23f444d310ece95b7d465283a5" translate="yes" xml:space="preserve">
          <source>The macro &lt;code&gt;?Q(Text, Env)&lt;/code&gt; expands to &lt;code&gt;merl:qquote(?LINE, Text, Env)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab9e862588129d877f212f0bfde0ba3a46758cc8" translate="yes" xml:space="preserve">
          <source>The macro &lt;code&gt;ENSURE&lt;/code&gt; (line 5-10) is used to ensure that the buffer is large enough for the answer. We switch on the command and take actions. We always have read select active on a port in &lt;code&gt;data&lt;/code&gt; mode (achieved by calling &lt;code&gt;do_recv&lt;/code&gt; on line 45), but we turn off read selection in &lt;code&gt;intermediate&lt;/code&gt; and &lt;code&gt;command&lt;/code&gt; modes (line 27 and 36).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dfa60ec98993e6c63f6b1ebab600c7c27efb5263" translate="yes" xml:space="preserve">
          <source>The macro directives cannot be used inside functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5c84a81d3e29ec48f2e8baa4f7a70afaa858f2c" translate="yes" xml:space="preserve">
          <source>The macros &lt;code&gt;ERL_ATOM_PTR&lt;/code&gt; and &lt;code&gt;ERL_INT_VALUE&lt;/code&gt; from &lt;code&gt;erl_eterm&lt;/code&gt; can be used to obtain the actual values of the atom and the integer. The atom value is represented as a string. By comparing this value with the strings &quot;foo&quot; and &quot;bar&quot;, it can be decided which function to call:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e6a4c157f57c6d503002b41adbc5bd71b9008ba" translate="yes" xml:space="preserve">
          <source>The magic cookie of the local node is retrieved by calling &lt;code&gt;erlang:get_cookie()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a05f6bcadc54f796f0b1fd5def2686d750e1700" translate="yes" xml:space="preserve">
          <source>The main (outer) loop for a process &lt;strong&gt;must&lt;/strong&gt; be tail-recursive. Otherwise, the stack grows until the process terminates.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="255b30701b0f9daa4744f53b6adde340892fc688" translate="yes" xml:space="preserve">
          <source>The main advantage of dividing systems into global groups is that the background load decreases while the number of nodes to be updated is reduced when manipulating globally registered names.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8bac27c9210ec680873a11c4354804a354e76059" translate="yes" xml:space="preserve">
          <source>The main advantage of using records rather than tuples is that fields in a record are accessed by name, whereas fields in a tuple are accessed by position. To illustrate these differences, suppose that you want to represent a person with the tuple &lt;code&gt;{Name, Address, Phone}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b014077cb1006ff99f29813775f91d4f9609fb7b" translate="yes" xml:space="preserve">
          <source>The main benefit of constants is that they can be used to reduce the size (and avoid repetition) of long strings, such as file paths.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a935bee785d5a929b8af32300cdaed69bbcdc5fe" translate="yes" xml:space="preserve">
          <source>The main execution threads that do most of the work. See &lt;code&gt;erl +S&lt;/code&gt; for more details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44bd22c67eb6433073dc2e343a3a6d7e1322b4de" translate="yes" xml:space="preserve">
          <source>The main features of SNMPv2 compared to SNMPv1 are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f987baf10d1a6cef3c887c260f84f36bcc967860" translate="yes" xml:space="preserve">
          <source>The main idea in the model is that it is not tied to any specific management protocol. An Application Programming Interface (API) is defined, which can be used to write adaptations for specific management protocols.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79d206b097b388ff06479821f31341df73bd37fd" translate="yes" xml:space="preserve">
          <source>The main idea is that the resource sends the notifications as Erlang terms to a dedicated &lt;code&gt;gen_event&lt;/code&gt; process. Into this process, handlers for the different management protocols are installed. When an event is received by this process, it is forwarded to each installed handler. The handlers are responsible for translating the event into a notification to be sent over the management protocol. For example, a handler for SNMP translates each event into an SNMP trap.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47a8cc665e1c479e686529aed490a0ed53790936" translate="yes" xml:space="preserve">
          <source>The main idea with the &lt;code&gt;erts_alloc&lt;/code&gt; library is to separate memory blocks that are used differently into different memory areas, to achieve less memory fragmentation. By putting less effort in finding a good fit for memory blocks that are frequently allocated than for those less frequently allocated, a performance gain can be achieved.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68792cbe81e714a76ce3bda5abbbd3fd1ba75cb7" translate="yes" xml:space="preserve">
          <source>The main loop receives messages from the client (which can use the the &lt;code&gt;io&lt;/code&gt; module to send requests). For each request, the function &lt;code&gt;request/2&lt;/code&gt; is called and a reply is eventually sent using function &lt;code&gt;reply/3&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a881d2bf8e074a4ba8b926654caec623f66ddd76" translate="yes" xml:space="preserve">
          <source>The main purpose of benchmarking is to find out which implementation of a given algorithm or function is the fastest. Benchmarking is far from an exact science. Today's operating systems generally run background tasks that are difficult to turn off. Caches and multiple CPU cores does not facilitate benchmarking. It would be best to run UNIX computers in single-user mode when benchmarking, but that is inconvenient to say the least for casual testing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d7cf0f3407ae9a11f3bfd8fb13ccb306f69fca2" translate="yes" xml:space="preserve">
          <source>The main purpose of the history buffer is the possibility to create configuration files. Any function stored in the history buffer can be written to a configuration file and used for creating a specific configuration at any time with a single function call.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3a2d3d740cc729d95dfc1aed7685f23aefe5460" translate="yes" xml:space="preserve">
          <source>The main purpose of this verb is to track how a match was arrived at, although it also has a secondary use in with advancing the match starting point (see (*SKIP) below).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="944d5d0eccccb0b12f4b4534569f94fbf95946bc" translate="yes" xml:space="preserve">
          <source>The main reason for using &lt;code&gt;assertMatch&lt;/code&gt; also for simple matches, instead of matching with &lt;code&gt;=&lt;/code&gt;, is that it produces more detailed error messages.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36e19f27d5fcd9a14663b0e9dd365354ee344321" translate="yes" xml:space="preserve">
          <source>The main start function is &lt;code&gt;et_viewer:start/1&lt;/code&gt;. By default it will start both an &lt;code&gt;et_collector&lt;/code&gt; and an &lt;code&gt;et_viewer&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a97901ec3926c3174291fa1e27d3f66bbc8d7ec" translate="yes" xml:space="preserve">
          <source>The main use of the function &lt;code&gt;meta/1&lt;/code&gt; is to transform a data structure &lt;code&gt;Tree&lt;/code&gt;, which represents a piece of program code, into a form that is &lt;strong&gt;representation independent when printed&lt;/strong&gt;. E.g., suppose &lt;code&gt;Tree&lt;/code&gt; represents a variable named &quot;V&quot;. Then (assuming a function &lt;code&gt;print/1&lt;/code&gt; for printing syntax trees), evaluating &lt;code&gt;print(abstract(Tree))&lt;/code&gt; - simply using &lt;code&gt;&lt;a href=&quot;#abstract-1&quot;&gt;abstract/1&lt;/a&gt;&lt;/code&gt; to map the actual data structure onto a syntax tree representation - would output a string that might look something like &quot;&lt;code&gt;{tree, variable, ..., &quot;V&quot;, ...}&lt;/code&gt;&quot;, which is obviously dependent on the implementation of the abstract syntax trees. This could e.g. be useful for caching a syntax tree in a file. However, in some situations like in a program generator generator (with two &quot;generator&quot;), it may be unacceptable. Using &lt;code&gt;print(meta(Tree))&lt;/code&gt; instead would output a &lt;strong&gt;representation independent&lt;/strong&gt; syntax tree generating expression; in the above case, something like &quot;&lt;code&gt;erl_syntax:variable(&quot;V&quot;)&lt;/code&gt;&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5cc7ab3d8930133e6c9f32ae9603597733b45c75" translate="yes" xml:space="preserve">
          <source>The main user interface consists of the functions &lt;code&gt;&lt;a href=&quot;#merge-3&quot;&gt;merge/3&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#rename-3&quot;&gt;rename/3&lt;/a&gt;&lt;/code&gt;. See also the function &lt;code&gt;&lt;a href=&quot;#parse_transform-2&quot;&gt;parse_transform/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf690a3ba48e5ab54f3129fdb73083e8aa1ffc60" translate="yes" xml:space="preserve">
          <source>The major advantage of dirty operations is that they execute much faster than equivalent operations that are processed as functional objects within a transaction.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c3f1a7bfd03b2e26984b55900c5f5a003f06a78" translate="yes" xml:space="preserve">
          <source>The major log file shows a detailed report of the test run. It includes test suite and test case names, execution time, the exact reason for failures, and so on. The information is available in both a file with textual and with HTML representation. The HTML file shows a summary that gives a good overview of the test run. It also has links to each individual test case log file for quick viewing with an HTML browser.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75ff18089a46d332c47b58a78759522e28ba0f11" translate="yes" xml:space="preserve">
          <source>The management information is defined in a &lt;strong&gt;Management Information Base (MIB)&lt;/strong&gt;. It is a formal definition of which information the agent makes available to the manager. The manager accesses the MIB through a management protocol, such as SNMP, CMIP, HTTP, or CORBA. Each protocol has its own MIB definition language. In SNMP, it is a subset of ASN.1, in CMIP it is GDMO, in HTTP it is implicit, and using CORBA, it is IDL.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3ad91073d713476eff5d4cf8dadc04c76b79f8f" translate="yes" xml:space="preserve">
          <source>The management of data in telecommunications system has many aspects, thereof some, but not all, are addressed by traditional commercial Database Management Systems (DBMSs). In particular the high level of fault tolerance that is required in many nonstop systems, combined with requirements on the DBMS to run in the same address space as the application, have led us to implement a new DBMS, called Mnesia.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="febc54d5d2b9c5b21af431123017ea615fe431a5" translate="yes" xml:space="preserve">
          <source>The manager information should be stored in a file called &lt;code&gt;manager.conf&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1781b487b48a4f52fe09daa2b7145718574c6144" translate="yes" xml:space="preserve">
          <source>The manager is often referred to as the &lt;strong&gt;Network Management System (NMS)&lt;/strong&gt;, to emphasize that it usually is realized as a program that presents data to an operator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2e6c9c5cfab679c1965d0d5bc8b363294a83d30" translate="yes" xml:space="preserve">
          <source>The manager issues the following &lt;code&gt;getNext&lt;/code&gt; request:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dca59b908ffe28e5cc68a3e4e9de1faaa52c370b" translate="yes" xml:space="preserve">
          <source>The manager now issues the following &lt;code&gt;getNext&lt;/code&gt; request:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8c05d8e33ba91352ab1e91a3f375a5f712ff8b9" translate="yes" xml:space="preserve">
          <source>The manager provided with the tool is a lightweight manager that basically provides a means to communicate with agents.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c1c074734e843dc6952bf33ee471b27c50c0033" translate="yes" xml:space="preserve">
          <source>The mapping between an instrumentation function and a resource is not necessarily 1-1. It is also possible to write one instrumentation function for each resource, and use that function from different protocols.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="998850a8c8eb8546e7768e95697db1697df937aa" translate="yes" xml:space="preserve">
          <source>The master node failed to get in contact with the slave node. This can occur in a number of circumstances:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e8a3dc76b35e83a289af92700b545a4ad79beb4" translate="yes" xml:space="preserve">
          <source>The master node must be alive.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14b34e7f97d388e649ae66acf54b7298a330905d" translate="yes" xml:space="preserve">
          <source>The master node setting is always local. It can be changed regardless if Mnesia is started or not.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38a3c861dd367c28c4c17a1c39eefe8dd878d733" translate="yes" xml:space="preserve">
          <source>The master nodes &lt;code&gt;Masters&lt;/code&gt; are not alive.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58c3b06d8afda9470de94fad6ad989bbb0cc70c8" translate="yes" xml:space="preserve">
          <source>The match function can also be used to check the equality of different attributes. For example, to find all employees with an employee number equal to their room number:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01db01bdcf4f0ead878b2024575a51c69acd4f98" translate="yes" xml:space="preserve">
          <source>The match of &lt;code&gt;Dgram&lt;/code&gt; fails if one of the following occurs:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c78419f0c88d5eda3fb5ff5b511ec776a98797e" translate="yes" xml:space="preserve">
          <source>The match specification function &lt;code&gt;{return_trace}&lt;/code&gt; works with meta-trace and sends its trace message to the same tracer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5153c93179a582efee4cbb10c8790c7726a7e986" translate="yes" xml:space="preserve">
          <source>The match specification has to return the atom &lt;code&gt;true&lt;/code&gt; if the object is to be deleted. No other return value gets the object deleted. So one cannot use the same match specification for looking up elements as for deleting them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98c4807426673ae3f3cbf5adfe4d22a81aa12f6b" translate="yes" xml:space="preserve">
          <source>The match specifications in the file are &lt;strong&gt;merged&lt;/strong&gt; with the current match specifications, so that no duplicates are generated. Use &lt;code&gt;&lt;a href=&quot;#ltp-0&quot;&gt;ltp/0&lt;/a&gt;&lt;/code&gt; to see what numbers were assigned to the specifications from the file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d55c9805b9483fe33032d7ae9cde54896150634e" translate="yes" xml:space="preserve">
          <source>The match specifiction must be guaranteed to &lt;strong&gt;retain the key&lt;/strong&gt; of any matched object. If not, &lt;code&gt;select_replace&lt;/code&gt; will fail with &lt;code&gt;badarg&lt;/code&gt; without updating any objects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee0a15736607c624569021f76ff9d3298f79570e" translate="yes" xml:space="preserve">
          <source>The match-and-replace operation for each individual object is guaranteed to be &lt;code&gt;&lt;a href=&quot;#concurrency&quot;&gt;atomic and isolated&lt;/a&gt;&lt;/code&gt;. The &lt;code&gt;select_replace&lt;/code&gt; table iteration as a whole, like all other select functions, does not give such guarantees.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ca8026082eee2ad7e64557de104f28a642c57fb" translate="yes" xml:space="preserve">
          <source>The matching algorithms of the library are based on the PCRE library, but not all of the PCRE library is interfaced and some parts of the library go beyond what PCRE offers. Currently PCRE version 8.40 (release date 2017-01-11) is used. The sections of the PCRE documentation that are relevant to this module are included here.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fbd21ba9310055b64610ab1a5c2a142134aa443f" translate="yes" xml:space="preserve">
          <source>The matching is executed on each element in &lt;code&gt;List&lt;/code&gt; and the function returns a list containing all results. If an element in &lt;code&gt;List&lt;/code&gt; does not match, nothing is returned for that element. The length of the result list is therefore equal or less than the length of parameter &lt;code&gt;List&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="198df020548452f3363e4fa559534d8078bfc86b" translate="yes" xml:space="preserve">
          <source>The matching operations in &lt;code&gt;Mnesia&lt;/code&gt; can either lock the entire table or only a single record (when the key is bound in the pattern).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="334b3e2d6b3a53d5d4f23d6292533ac9fed61406" translate="yes" xml:space="preserve">
          <source>The maximum number of allowed characters in an atom is 255. In the UTF-8 case, each character can need 4 bytes to be encoded.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19294f2a8c14a8b4f31f643e9f2b22734d7e410e" translate="yes" xml:space="preserve">
          <source>The maximum number of bytes that has been allocated during the lifetime of the originating node. This is only shown if the Erlang runtime system is run instrumented.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="139d6633f301a60c8cd9a458fcbc51c168888bf8" translate="yes" xml:space="preserve">
          <source>The maximum number of capturing subpatterns is 65535.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1bc4329e4ceb57ba9547a9f48f399278acde7346" translate="yes" xml:space="preserve">
          <source>The maximum number of channels with active remote subsystem that are accepted for each connection to this daemon</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b534caa8ed29360c9c0c9252aae63ac15ba8de99" translate="yes" xml:space="preserve">
          <source>The maximum number of elements in a tuple is 16,777,215 (24-bit unsigned integer).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa82ab7bf0492deb21a60217a14e1da088287537" translate="yes" xml:space="preserve">
          <source>The maximum number of ports that can be open at the same time can be configured by passing command-line flag &lt;code&gt;&lt;a href=&quot;erl#max_ports&quot;&gt;+Q&lt;/a&gt;&lt;/code&gt; to &lt;code&gt;erl(1)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="364851e20b3d3baac09ccbd2901df833d89219b3" translate="yes" xml:space="preserve">
          <source>The maximum number of repetitions of the timer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b52d3e36551290057fbd3fa69d9e51f68308bed8" translate="yes" xml:space="preserve">
          <source>The maximum number of simultaneous sessions that are accepted at any time for this daemon. This includes sessions that are being authorized. Thus, if set to &lt;code&gt;N&lt;/code&gt;, and &lt;code&gt;N&lt;/code&gt; clients have connected but not started the login process, connection attempt &lt;code&gt;N+1&lt;/code&gt; is aborted. If &lt;code&gt;N&lt;/code&gt; connections are authenticated and still logged in, no more logins are accepted until one of the existing ones log out.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33f9e2efd4e8f4d95b154e45a6aa836475444a9a" translate="yes" xml:space="preserve">
          <source>The maximum number of simultaneously alive Erlang processes is by default 262,144. This limit can be configured at startup. For more information, see the &lt;code&gt;+P&lt;/code&gt; command-line flag in the &lt;code&gt;erl(1)&lt;/code&gt; manual page in ERTS.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ea78efb7aa811663d27fe73cd13c0c8fb0d40a3" translate="yes" xml:space="preserve">
          <source>The maximum number of simultaneously connected nodes is limited by either the maximum number of simultaneously known remote nodes, &lt;code&gt;&lt;a href=&quot;#ports&quot;&gt;the maximum number of (Erlang) ports&lt;/a&gt;&lt;/code&gt; available, or &lt;code&gt;&lt;a href=&quot;#files_sockets&quot;&gt;the maximum number of sockets&lt;/a&gt;&lt;/code&gt; available.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d7d8a949becb40e83e6c856df21937f4d5e2fc4" translate="yes" xml:space="preserve">
          <source>The maximum number of simultaneously open Erlang ports is often by default 16,384. This limit can be configured at startup. For more information, see the &lt;code&gt;+Q&lt;/code&gt; command-line flag in the &lt;code&gt;erl(1)&lt;/code&gt; manual page in ERTS.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dce3aefe9378fbdd7c23ba61275213a9e8f16e3c" translate="yes" xml:space="preserve">
          <source>The maximum number of simultaneously open files and sockets depends on &lt;code&gt;&lt;a href=&quot;#ports&quot;&gt;the maximum number of Erlang ports&lt;/a&gt;&lt;/code&gt; available, as well as on operating system-specific settings and limits.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9d46ab9b300e30ac3d0d3879401107e372584e8" translate="yes" xml:space="preserve">
          <source>The maximum size in words of the process. If set to zero, the heap size limit is disabled. &lt;code&gt;badarg&lt;/code&gt; is be thrown if the value is smaller than &lt;code&gt;&lt;a href=&quot;#process_flag_min_heap_size&quot;&gt;min_heap_size&lt;/a&gt;&lt;/code&gt;. The size check is only done when a garbage collection is triggered.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4b6db39ece8aee304cbcf9157b862c4fb5ad3c9" translate="yes" xml:space="preserve">
          <source>The maximum size of the data returned by the &lt;code&gt;os:cmd&lt;/code&gt; call. See the &lt;code&gt;&lt;a href=&quot;#cmd-2&quot;&gt;os:cmd/2&lt;/a&gt;&lt;/code&gt; documentation for more details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ac1dd4626b925c247f9422c7d93ee30b6d58305" translate="yes" xml:space="preserve">
          <source>The maximum size of the data returned by the &lt;code&gt;os:cmd&lt;/code&gt; call. This option is a safety feature that should be used when the command executed can return a very large, possibly infinite, result.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="585b754a1ab975e434f0ece6fc3dc6117a6bfa95" translate="yes" xml:space="preserve">
          <source>The maximum time that &lt;code&gt;Mnesia&lt;/code&gt; waits for other nodes to respond with a transaction recovery decision can be specified. The configuration parameter &lt;code&gt;max_wait_for_decision&lt;/code&gt; defaults to &lt;code&gt;infinity&lt;/code&gt;, which can cause the indefinite hanging as mentioned earlier. However, if the parameter is set to a definite time period (for example, three minutes), &lt;code&gt;Mnesia&lt;/code&gt; then enforces a transaction recovery decision, if needed, to allow &lt;code&gt;Mnesia&lt;/code&gt; to continue with its startup procedure.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c5051bd43e740038041f2bf25ed5638f7d0e3f3" translate="yes" xml:space="preserve">
          <source>The maximum total amount of memory allocated since the emulator was started. This tuple is only present when the emulator is run with instrumentation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28e274b5f8dfecfd5eae3c1b1cfa72d55e0d6e66" translate="yes" xml:space="preserve">
          <source>The meaning of dollar can be changed so that it matches only at the very end of the string, by setting option &lt;code&gt;dollar_endonly&lt;/code&gt; at compile time. This does not affect the \Z assertion.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db8e327530c8b9b6b5b186cd76cf404392297a30" translate="yes" xml:space="preserve">
          <source>The meaning of the various quantifiers is not otherwise changed, only the preferred number of matches. Do not confuse this use of question mark with its use as a quantifier in its own right. As it has two uses, it can sometimes appear doubled, as in</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1fc58f8c2a19d894912d06c0debf88001c2723f" translate="yes" xml:space="preserve">
          <source>The meanings of the circumflex and dollar characters are changed if option &lt;code&gt;multiline&lt;/code&gt; is set. When this is the case, a circumflex matches immediately after internal newlines and at the start of the subject string. It does not match after a newline that ends the string. A dollar matches before any newlines in the string, and at the very end, when &lt;code&gt;multiline&lt;/code&gt; is set. When newline is specified as the two-character sequence CRLF, isolated CR and LF characters do not indicate newlines.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d91b3d8b6609ca598d50d85473759e345b88f58" translate="yes" xml:space="preserve">
          <source>The meanings of the packet types are as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="978fd2c6d0a38bb48b2e443f83d298392afa53c5" translate="yes" xml:space="preserve">
          <source>The measured node.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3fced30f9f09acd4ae489f7a4cde9db12cd9cfb" translate="yes" xml:space="preserve">
          <source>The measurement (meas) module(s)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d1886cf663e0cdc7dac0d21c48bb994286f92d0" translate="yes" xml:space="preserve">
          <source>The measurement is done by iterating over the decode/encode function for approx 2 seconds per message and counting the number of decodes/encodes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aec8fc6af742975da8742323e5863ba3c2976265" translate="yes" xml:space="preserve">
          <source>The measurements has been performed on a HP xw4600 Workstation with a Intel(R) Core(TM)2 Quad CPU Q9550 @ 2.83GHz, with 4 GB memory and running Ubuntu 10.04 x86_64, kernel 2.6.32-22-generic. Software versions was open source OTP R13B04 (megaco-3.14).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3cc922c4e05bd2a334377ee02802a916cd403417" translate="yes" xml:space="preserve">
          <source>The mechanism for &lt;code&gt;&lt;a href=&quot;#multi_file_logging&quot;&gt;multi-file error report logging&lt;/a&gt;&lt;/code&gt; as described in this section is also kept for backwards compatibility. However, the new logging API also introduces &lt;code&gt;logger_disk_log_h(3)&lt;/code&gt;, which is a logger handler that can print to multiple files using &lt;code&gt;disk_log(3)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa0f7032a10e00f5b731f6ddebd729a428e75839" translate="yes" xml:space="preserve">
          <source>The mechanism for passing data is called &lt;code&gt;save_config&lt;/code&gt;. The idea is that one test case (or suite) can save the current value of &lt;code&gt;Config&lt;/code&gt;, or any list of key-value tuples, so that the next executing test case (or test suite) can read it. The configuration data is not saved permanently but can only be passed from one case (or suite) to the next.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4a82246982edacf43dfbd803e39adbeb1684356" translate="yes" xml:space="preserve">
          <source>The mechanism is easiest explained by an example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8fa97754d61962935bb76075b6dc85939e815dbc" translate="yes" xml:space="preserve">
          <source>The memory allocated by the node in kilobytes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="298ac153c29e1852aa628eb9371283caf21dbef1" translate="yes" xml:space="preserve">
          <source>The memory allocated for code storage.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59e5363544c056808c214b7d5c9c6474a917a3b4" translate="yes" xml:space="preserve">
          <source>The memory allocation strategy used for multiblock carriers by an allocator can be configured using parameter &lt;code id=&quot;strategy&quot;&gt;&lt;a href=&quot;#M_as&quot;&gt;as&lt;/a&gt;&lt;/code&gt;. The following strategies are available:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d175bff5507dd3c92a81b43fddcde2ca548264d" translate="yes" xml:space="preserve">
          <source>The memory use is in bytes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3a1ae2cae0473b354552d179be5126c3e3c48c2" translate="yes" xml:space="preserve">
          <source>The menu bar contains a &lt;strong&gt;File&lt;/strong&gt; menu and a &lt;strong&gt;Help&lt;/strong&gt; menu. From the &lt;strong&gt;File&lt;/strong&gt; menu, a new crashdump can be loaded or the tool can be terminated. From the &lt;strong&gt;Help&lt;/strong&gt; menu, this User's Guide and section &quot;How to interpret the Erlang crash dumps&quot; from the ERTS application can be opened. &quot;How to interpret the Erlang crash dumps&quot; describes the raw crashdumps in detail and includes information about each field in the information pages.&quot;How to interpret the Erlang crash dumps&quot; is also available in the OTP online documentation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1da2ec9bc11a5f3d2243b7edb144004648c44860" translate="yes" xml:space="preserve">
          <source>The message &lt;code&gt;Msg&lt;/code&gt; is received.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bef16814b598901c6478a3fbd2f3f7dcb03410e5" translate="yes" xml:space="preserve">
          <source>The message &lt;code&gt;Msg&lt;/code&gt; is sent to process &lt;code&gt;Pid&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2f87f0f2be084c26692c04f5569df347bc82216" translate="yes" xml:space="preserve">
          <source>The message environment &lt;code&gt;msg_env&lt;/code&gt; with all its terms (including &lt;code&gt;msg&lt;/code&gt;) is invalidated by a successful call to &lt;code&gt;enif_send&lt;/code&gt;. The environment is to either be freed with &lt;code&gt;&lt;a href=&quot;#enif_free_env&quot;&gt;enif_free_env&lt;/a&gt;&lt;/code&gt; of cleared for reuse with &lt;code&gt;&lt;a href=&quot;#enif_clear_env&quot;&gt;enif_clear_env&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69095ad9f243cb8ca62108dfb3eb20c26f31c02d" translate="yes" xml:space="preserve">
          <source>The message is delivered as an Erlang binary and is decoded by the encoding module stated in the receive handle together with its encoding config (also in the receive handle). Depending of the outcome of the decoding various callback functions will be invoked. See megaco_user for more info about the callback arguments.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53e2b8f523369c83642e4048ab82a3185ec3b76f" translate="yes" xml:space="preserve">
          <source>The message is to be sent unordered</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0a211d0180d304363ef532b16b38c1c8ed96d5c" translate="yes" xml:space="preserve">
          <source>The message provided by the caller is printed. This function is simply a wrapper for &lt;code&gt;fprintf()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="188062935a333dac8b9cbce97db717469f7ef85a" translate="yes" xml:space="preserve">
          <source>The message queue is on the heap depending on the process flag &lt;code&gt;&lt;a href=&quot;#process_flag_message_queue_data&quot;&gt;message_queue_data&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6d253006487349bbc06f18a3a3218a8846cc6f2" translate="yes" xml:space="preserve">
          <source>The message sent to another node using the '!' (in external format). Notice that &lt;code&gt;Message&lt;/code&gt; is only passed in combination with a &lt;code&gt;ControlMessage&lt;/code&gt; encoding a send ('!').</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2508ed4b299c2e2a914cd2e173689088380e01ae" translate="yes" xml:space="preserve">
          <source>The message size is limited according to the values of configuration parameters &lt;code&gt;&lt;a href=&quot;#chars_limit&quot;&gt;chars_limit&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#depth&quot;&gt;depth&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6aa5e3b5fe2a2c9211425bda03965c4fecd38672" translate="yes" xml:space="preserve">
          <source>The message term to be appended to the trace message</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0a0e8de3b2b246c6805a721cd7aa635b44ea3ae" translate="yes" xml:space="preserve">
          <source>The message term to send.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb35a1112b2aba4bb7f59c7ef2bd29e811541e66" translate="yes" xml:space="preserve">
          <source>The message term to send. The same limitations apply as on the payload to &lt;code&gt;&lt;a href=&quot;erlang#port_command-2&quot;&gt;erlang:port_command/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25ff1263e12ec9b56844ab9f45da012f6df9fa30" translate="yes" xml:space="preserve">
          <source>The message to be sent.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="662e1568be87a93705ec3d52e5be7681c3dcae9b" translate="yes" xml:space="preserve">
          <source>The message transformation is done by the transformation module. It is used to transform a set of messages encoded with one codec into the other base codec's.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f330d0749b4288239218bfd8721d9cc50f2048e" translate="yes" xml:space="preserve">
          <source>The messages used by the different tools are contained in single message package file (see below for more info). The messages in this file is encoded with just one codec. During measurement initiation, the messages are read and then transformed to all codec formats used in the measurement.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92b306bf0e70c78b5d09e95ccf216abcbe6cd2ba" translate="yes" xml:space="preserve">
          <source>The messenger is set up by allowing &quot;clients&quot; to connect to a central server and say who and where they are. That is, a user does not need to know the name of the Erlang node where another user is located to send a message.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b08f3d25f362366adcd8ed69b48375b76af1ceb" translate="yes" xml:space="preserve">
          <source>The messenger server traps exits. If it receives an exit signal, &lt;code&gt;{'EXIT',From,Reason}&lt;/code&gt;, this means that a client process has terminated or is unreachable for one of the following reasons:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d73c2514c79c3ab7ddf5f518405430d4594740a9" translate="yes" xml:space="preserve">
          <source>The method used to implement distributed tables with this SNMP tool is to implement a table coordinator process responsible for coordinating the processes, which hold the table data and they are called table holders. All table holders must in some way be known by the coordinator; the structure of the table data determines how this is achieved. The coordinator may require that the table holders explicitly register themselves and specify their information. In other cases, the table holders can be determined once at compile time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9aeb4d59c4a528fedb146161bc65731c3aab1a8a" translate="yes" xml:space="preserve">
          <source>The method used to present a distributed table is strongly application dependent. The use of different masking techniques is only valid for a small subset of problems and registering every row in a distributed table makes it non-distributed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63514a43185163391d03ee090dbfddf650488f7c" translate="yes" xml:space="preserve">
          <source>The mib storage is used by the agent to store internal mib- related information. The mib storage module is used by several entities, not just the mib-server.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22c3dd445cc6fc863b70e9b3499332bc0735098f" translate="yes" xml:space="preserve">
          <source>The minimal setup is not the most secure setup of SSL/TLS/DTLS.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a717b6f86847b74e42485f2bb9e93125c968160" translate="yes" xml:space="preserve">
          <source>The minimal system based on Erlang/OTP, enabling release handling, thus consists of the Kernel, STDLIB, and SASL applications.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07c2b5af828a95564e2ccf73c84d39aeac748a78" translate="yes" xml:space="preserve">
          <source>The minimum size of the receive buffer to use for the socket. You are encouraged to use &lt;code&gt;&lt;a href=&quot;#getopts-2&quot;&gt;getopts/2&lt;/a&gt;&lt;/code&gt; to retrieve the size set by your operating system.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8abc7d7fd3d2b168dd30ef9b33fd46de95e55a93" translate="yes" xml:space="preserve">
          <source>The minimum size of the send buffer to use for the socket. You are encouraged to use &lt;code&gt;&lt;a href=&quot;#getopts-2&quot;&gt;getopts/2&lt;/a&gt;&lt;/code&gt;, to retrieve the size set by your operating system.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3eddcd151845fa0f558f92cf054830bab732faab" translate="yes" xml:space="preserve">
          <source>The minor log files contain full details of every single test case, each in a separate file. This way, it is straightforward to compare the latest results to that of previous test runs, even if the set of test cases changes. If application SASL is running, its logs are also printed to the current minor log file by the &lt;code&gt;cth_log_redirect built-in hook&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3658d2cb7add73fe309b90a8d098bef38a4ef76d" translate="yes" xml:space="preserve">
          <source>The minus (hyphen) character can be used to specify a range of characters in a character class. For example, [d-m] matches any letter between d and m, inclusive. If a minus character is required in a class, it must be escaped with a backslash or appear in a position where it cannot be interpreted as indicating a range, typically as the first or last character in the class, or immediately after a range. For example, [b-d-z] matches letters in the range b to d, a hyphen character, or z.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9af303642ed501803e879dc12b0614d63b8151b7" translate="yes" xml:space="preserve">
          <source>The missing time can be found in the paragraph for &lt;code&gt;prim_file:drv_command/4&lt;/code&gt; where it is evident that not only &lt;code&gt;prim_file:drv_command/2&lt;/code&gt; is called but also a fun:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="606631313d3f4e567c75d609d36257f0ff021b82" translate="yes" xml:space="preserve">
          <source>The mode enables the use of non-atom states, for example, complex states or even hierarchical states. See section &lt;code&gt;&lt;a href=&quot;#Complex%20State&quot;&gt;Complex State&lt;/a&gt;&lt;/code&gt;. If, for example, a state diagram is largely alike for the client side and the server side of a protocol, you can have a state &lt;code&gt;{StateName,server}&lt;/code&gt; or &lt;code&gt;{StateName,client}&lt;/code&gt;, and make &lt;code&gt;StateName&lt;/code&gt; determine where in the code to handle most events in the state. The second element of the tuple is then used to select whether to handle special client-side or server-side events.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b970edef5d2db822eb3139eed01662d797b2d6c5" translate="yes" xml:space="preserve">
          <source>The mode properties are as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c74fbe5e44daec131d6f8bb6c1035938c0451e49" translate="yes" xml:space="preserve">
          <source>The mode where data is pumped through the port and the &lt;code&gt;uds_command&lt;/code&gt; routine regards every call as a call where sending is wanted. In this mode, all input available is read and sent to Erlang when it arrives on the socket, much like in the active mode of a &lt;code&gt;gen_tcp&lt;/code&gt; socket.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="881eb04bb7f343c8b06f98508313f6d367c9da3f" translate="yes" xml:space="preserve">
          <source>The modes are as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22f36ac434028664a5e69ab508016c7df24b7383" translate="yes" xml:space="preserve">
          <source>The module &lt;code&gt;&lt;a href=&quot;diameter_make&quot;&gt;diameter_make(3)&lt;/a&gt;&lt;/code&gt; provides an alternate compilation interface.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d77399e5aec1944b1adc6c9df8b906d840bfd80" translate="yes" xml:space="preserve">
          <source>The module &lt;code&gt;Mod&lt;/code&gt; referred to must be found in the code path and data returned by the function &lt;code&gt;Func&lt;/code&gt; is passed back to the client. Data returned from the function must take the form as specified in the CGI specification. For implementation details of the ESI callback function, see &lt;code&gt;&lt;a href=&quot;mod_esi&quot;&gt;mod_esi(3)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29ac46e3b904139d6e66b6ec6030181dc36b417e" translate="yes" xml:space="preserve">
          <source>The module &lt;code&gt;Module&lt;/code&gt; referred to must be found in the code path, and it must define a function &lt;code&gt;Function&lt;/code&gt; with an arity of two or three. It is preferable to implement a function with arity three, as it permits to send chunks of the web page to the client during the generation phase instead of first generating the whole web page and then sending it to the client. The option to implement a function with arity two is only kept for backwards compatibility reasons. For implementation details of the ESI callback function, see &lt;code&gt;&lt;a href=&quot;mod_esi&quot;&gt;mod_esi(3)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="982c2295d64987c5a6f9815d8a88586d4220b412" translate="yes" xml:space="preserve">
          <source>The module &lt;code&gt;asn1ct&lt;/code&gt;, which provides the compile-time functions (including the compiler)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a79e4d001488233c5a176bdd084c0905e60ecc9c" translate="yes" xml:space="preserve">
          <source>The module &lt;code&gt;asn1rt_nif&lt;/code&gt;, which provides the runtime functions for the ASN.1 decoder for the BER back end</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ef07ceefb72a3876e128fd3d25802cdcc467713" translate="yes" xml:space="preserve">
          <source>The module &lt;code&gt;cover&lt;/code&gt; provides a set of functions for coverage analysis of Erlang programs, counting how many times each &lt;code&gt;&lt;a href=&quot;#lines&quot;&gt;executable line&lt;/a&gt;&lt;/code&gt; is executed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="781caf54426d4fb478a304a7844ea80922cfcec9" translate="yes" xml:space="preserve">
          <source>The module &lt;code&gt;cover&lt;/code&gt; provides a set of functions for coverage analysis of Erlang programs, counting how many times each &lt;strong&gt;executable line&lt;/strong&gt; of code is executed when a program is run.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f91e217601b1dc046c35185750c3cff89af0626" translate="yes" xml:space="preserve">
          <source>The module &lt;code&gt;eprof&lt;/code&gt; provides a set of functions for time profiling of Erlang programs to find out how the execution time is used. The profiling is done using the Erlang trace BIFs. Tracing of local function calls for a specified set of processes is enabled when profiling is begun, and disabled when profiling is stopped.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c504d09107327f4319315c36b9c3bb90edddcb97" translate="yes" xml:space="preserve">
          <source>The module &lt;code&gt;et/examples/et_display_demo.erl&lt;/code&gt; illustrates how it can be used:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="259f6a111f8e10963d253f6c20a7ce32cd0fbcc2" translate="yes" xml:space="preserve">
          <source>The module &lt;code&gt;et/examples/et_trace_demo.erl&lt;/code&gt; achieves this.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e6fc57c9903415812e7aa14d0de98a4a3c76906" translate="yes" xml:space="preserve">
          <source>The module &lt;code&gt;init&lt;/code&gt; contains functions for restarting, rebooting, and stopping the runtime system:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3abc6c505ceadd88e545ffef89881ad4330aca42" translate="yes" xml:space="preserve">
          <source>The module &lt;code&gt;instrument&lt;/code&gt; contains support for studying the resource usage in an Erlang runtime system. Currently, only the allocation of memory can be studied.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="941709a144919cb9d4879d80ca49d5703f70c432" translate="yes" xml:space="preserve">
          <source>The module &lt;code&gt;lists&lt;/code&gt; contains many functions for manipulating lists, for example, for reversing them. So before writing a list-manipulating function it is a good idea to check if one not already is written for you (see the &lt;code&gt;lists(3)&lt;/code&gt; manual page in STDLIB).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b557c4c0674c40fdfca518a79b00693470cbb4b" translate="yes" xml:space="preserve">
          <source>The module &lt;code&gt;make&lt;/code&gt; provides a set of functions similar to the UNIX type &lt;code&gt;Make&lt;/code&gt; functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d33a6d96eeffbee10dd02fa8fc1a44592f775997" translate="yes" xml:space="preserve">
          <source>The module &lt;code&gt;mod_cgi&lt;/code&gt; enables execution of &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc3875.txt&quot;&gt;CGI scripts&lt;/a&gt;&lt;/code&gt; on the server. A file matching the definition of a ScriptAlias config directive is treated as a CGI script. A CGI script is executed by the server and its output is returned to the client.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89aebd55be35237517f0292d086307a4abfce4d9" translate="yes" xml:space="preserve">
          <source>The module &lt;code&gt;snmp&lt;/code&gt; contains interface functions to the SNMP toolkit.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a28864fb1efef12bf7914da0d813b6fa91aa2615" translate="yes" xml:space="preserve">
          <source>The module &lt;code&gt;snmp_community_mib&lt;/code&gt; implements the instrumentation functions for the SNMP-COMMUNITY-MIB, and functions for configuring the database.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef3d7428030a1ee96b52a462582efaf9645f114a" translate="yes" xml:space="preserve">
          <source>The module &lt;code&gt;snmp_framework_mib&lt;/code&gt; implements instrumentation functions for the SNMP-FRAMEWORK-MIB, and functions for initializing and configuring the database.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="095f5718c68bbc524071ea724e79d3350f41b68e" translate="yes" xml:space="preserve">
          <source>The module &lt;code&gt;snmp_generic&lt;/code&gt; contains generic functions for implementing tables (and variables) using the SNMP built-in database or Mnesia. These default functions are used if no instrumentation function is provided for a managed object in a MIB. Sometimes, it might be necessary to customize the behaviour of the default functions. For example, in some situations a trap should be sent if a row is deleted or modified, or some hardware is to be informed, when information is changed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82a890681bf1941535370d5663cafcbba66ae605" translate="yes" xml:space="preserve">
          <source>The module &lt;code&gt;snmp_index&lt;/code&gt; implements an Abstract Data Type (ADT) for an SNMP index structure for SNMP tables. It is implemented as an ets table of the ordered_set data-type, which means that all operations are O(log n). In the table, the key is an ASN.1 OBJECT IDENTIFIER.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2f9fd8895a2ad05f79cba6aa4a560674948ff16" translate="yes" xml:space="preserve">
          <source>The module &lt;code&gt;snmp_notification_mib&lt;/code&gt; implements the instrumentation functions for the SNMP-NOTIFICATION-MIB, and functions for configuring the database.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f8a67bb8f067e1a717000055707220ab821c05a" translate="yes" xml:space="preserve">
          <source>The module &lt;code&gt;snmp_pdus&lt;/code&gt; contains functions for encoding and decoding of SNMP protocol data units (PDUs). In short, this module converts a list of bytes to Erlang record representations and vice versa. The record definitions can be found in the file &lt;code&gt;snmp/include/snmp_types.hrl&lt;/code&gt;. If snmpv3 is used, the module that includes &lt;code&gt;snmp_types.hrl&lt;/code&gt; must define the constant &lt;code&gt;SNMP_USE_V3&lt;/code&gt; before the header file is included. Example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5725f0842bc0666fa7d375bd7f8ddd2c680d73f4" translate="yes" xml:space="preserve">
          <source>The module &lt;code&gt;snmp_standard_mib&lt;/code&gt; implements the instrumentation functions for the STANDARD-MIB and SNMPv2-MIB, and functions for configuring the database.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9794cfac19d7a807e63c08b3a5fe1b5a39649e0d" translate="yes" xml:space="preserve">
          <source>The module &lt;code&gt;snmp_target_mib&lt;/code&gt; implements the instrumentation functions for the SNMP-TARGET-MIB, and functions for configuring the database.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f6c026f9e309eb46ab31fc9b2d89fed73cf8841" translate="yes" xml:space="preserve">
          <source>The module &lt;code&gt;snmp_user_based_sm_mib&lt;/code&gt; implements the instrumentation functions for the SNMP-USER-BASED-SM-MIB, and functions for configuring the database.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57a4fcf0421c558f55d4b62d7f4d570a983d47de" translate="yes" xml:space="preserve">
          <source>The module &lt;code&gt;snmp_view_based_acm_mib&lt;/code&gt; implements the instrumentation functions for the SNMP-VIEW-BASED-ACM-MIB, and functions for configuring the database.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb84eb23430061b5d0ba52fb1f1dcb8cae6958c3" translate="yes" xml:space="preserve">
          <source>The module &lt;code&gt;snmpa&lt;/code&gt; contains interface functions to the SNMP agent.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2cc8950e817bfb35a3a5269149811e72d9216ab2" translate="yes" xml:space="preserve">
          <source>The module &lt;code&gt;snmpa_conf&lt;/code&gt; contains various utility functions to used for manipulating (write/append/read) the config files of the SNMP agent.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c00aa92168aea59cf4babd7411c60aa30b9bb12" translate="yes" xml:space="preserve">
          <source>The module &lt;code&gt;snmpa_error&lt;/code&gt; contains two callback functions which are called if an error occurs at different times during agent operation. These functions in turn calls the corresponding function in the configured error report module, which implements the actual report functionality.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7764fca7b7977a857a18cfe1fc6018c7939c753c" translate="yes" xml:space="preserve">
          <source>The module &lt;code&gt;snmpa_error_io&lt;/code&gt; implements the &lt;code&gt;snmp_error_report&lt;/code&gt; behaviour (see &lt;code&gt;&lt;a href=&quot;snmpa_error_report&quot;&gt;snmpa_error_report&lt;/a&gt;&lt;/code&gt;) containing two callback functions which are called in order to report SNMP errors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5fb427e1b1c2244f167076a6c28620f6bd0ca500" translate="yes" xml:space="preserve">
          <source>The module &lt;code&gt;snmpa_error_logger&lt;/code&gt; implements the &lt;code&gt;snmpa_error_report&lt;/code&gt; behaviour (see &lt;code&gt;&lt;a href=&quot;snmpa_error_report&quot;&gt;snmpa_error_report&lt;/a&gt;&lt;/code&gt;) containing two callback functions which are called in order to report SNMP errors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83bb96f4babc6a5eacc014cc415f81b568ec9857" translate="yes" xml:space="preserve">
          <source>The module &lt;code&gt;snmpa_local_db&lt;/code&gt; contains functions for implementing tables (and variables) using the SNMP built-in database. The database exists in two instances, one volatile and one persistent. The volatile database is implemented with ets. The persistent database is implemented with dets.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55631c2398416971197f57a07cee463eafb2a6d3" translate="yes" xml:space="preserve">
          <source>The module &lt;code&gt;snmpa_mpd&lt;/code&gt; implements the version independent Message Processing and Dispatch functionality in SNMP for the agent. It is supposed to be used from a Network Interface process (&lt;code&gt;&lt;a href=&quot;snmp_agent_netif&quot;&gt;Definition of Agent Net if&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="124a2b3f4d74eeec626680e394ad1513621980ef" translate="yes" xml:space="preserve">
          <source>The module &lt;code&gt;snmpc&lt;/code&gt; contains interface functions to the SNMP toolkit MIB compiler.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c53e4bdf4bb95582196719c70dc1fba81cd26c5b" translate="yes" xml:space="preserve">
          <source>The module &lt;code&gt;snmpm&lt;/code&gt; contains interface functions to the SNMP manager.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9deea834f053c18dad6106ffd7fd172a36d88d96" translate="yes" xml:space="preserve">
          <source>The module &lt;code&gt;snmpm_conf&lt;/code&gt; contains various utility functions to used for manipulating (write/append/read) the config files of the SNMP manager.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f85a168a189fdceec5a2d241d8dfe3e80b2124a7" translate="yes" xml:space="preserve">
          <source>The module &lt;code&gt;snmpm_mpd&lt;/code&gt; implements the version independent Message Processing and Dispatch functionality in SNMP for the manager. It is supposed to be used from a Network Interface process (&lt;code&gt;&lt;a href=&quot;snmp_manager_netif&quot;&gt;Definition of Manager Net if&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="301e9d486412f01bcf2672b9abce6a87a421abaf" translate="yes" xml:space="preserve">
          <source>The module &lt;code&gt;unicode&lt;/code&gt; even supports similar mixes with binaries containing other encodings than UTF-8, but that is a special case to allow for conversions to and from external data:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36591fbbad4d0a32aa408280d9af7fb21f38f345" translate="yes" xml:space="preserve">
          <source>The module begins with the usual directives, a function to start the I/O server and a main loop handling the requests:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="517094b39f1e8298c34a64523b0a81f6e27a7939" translate="yes" xml:space="preserve">
          <source>The module can be used as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84b7dab89c3e12645bda4285fa81fa7ba3e89769" translate="yes" xml:space="preserve">
          <source>The module can now be checked for calls to &lt;code&gt;&lt;a href=&quot;xref#deprecated_function&quot;&gt;deprecated functions&lt;/a&gt;&lt;/code&gt;, calls to &lt;code&gt;&lt;a href=&quot;xref#undefined_function&quot;&gt;undefined functions&lt;/a&gt;&lt;/code&gt;, and for unused local functions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b501a9e25197a0d2d4d8c4d153e95197c1dc5515" translate="yes" xml:space="preserve">
          <source>The module check and the predefined analyses are useful, but limited. Sometimes more flexibility is needed, for instance one might not need to apply a graph analysis on all calls, but some subset will do equally well. That flexibility is provided with a simple language. Below are some expressions of the language with comments, focusing on elements of the language rather than providing useful examples. The analyzed system is assumed to be OTP, so in order to run the queries, first evaluate these calls:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f34c93923a124126ae9987ed5ba7d0cd3a880a0" translate="yes" xml:space="preserve">
          <source>The module does not belong to any of the applications Kernel, STDLIB, GS, or Debugger.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df43f32272eb4d398f8b34dc6bda83d31dc742c2" translate="yes" xml:space="preserve">
          <source>The module exports the following functions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8324f5d5b875808800ad4bfccc10ff9a5ba92ef" translate="yes" xml:space="preserve">
          <source>The module has an &lt;code&gt;-on_load function&lt;/code&gt; that failed when it was called.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a549a328785c37eb26a4d0b0876090f69d89f62f" translate="yes" xml:space="preserve">
          <source>The module has been compiled with option &lt;code&gt;debug_info&lt;/code&gt; set.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4009d0d64b6afc399eea7069fcbf0bea4113eca2" translate="yes" xml:space="preserve">
          <source>The module has not been compiled with option &lt;code&gt;debug_info&lt;/code&gt; set.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61d3758ed9d8815ae40a582326b2d576731c58d3" translate="yes" xml:space="preserve">
          <source>The module implementing the default user. See the &lt;code&gt;&lt;a href=&quot;snmpm_user&quot;&gt;snmpm_user&lt;/a&gt;&lt;/code&gt; behaviour.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0b8a7cb2b22e6ad5a3d1b43145f3b8010311a6a" translate="yes" xml:space="preserve">
          <source>The module implementing this behaviour shall be supplied to to the servers configuration with the option &lt;code&gt;&lt;a href=&quot;httpd#prop_customize&quot;&gt;customize&lt;/a&gt;&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b66eedc6242758f2f48c0f5c1e1f06419d138c4f" translate="yes" xml:space="preserve">
          <source>The module is provided according to Erlang Enhancement Proposal (EEP) 31.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e32c3dc9ba3ffd5afe1da65ac5bac03e04a15fd8" translate="yes" xml:space="preserve">
          <source>The module name of the event handler.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="329e9b070ed603033e7dd3e45d35cd86f7bb6554" translate="yes" xml:space="preserve">
          <source>The module needs to create some kind of listening entity (process or port) and an acceptor process that accepts incoming connections using the listening entity. For each connection, the module at least needs to create one connection supervisor process, which also is responsible for the handshake when setting up the connection, and a distribution controller (process or port) responsible for transport of data over the connection. The distribution controller and the connection supervisor process should be linked together so both of them are cleaned up when the connection is taken down.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a0efe94bfa8ce9cd46e5764feb6320f9f30baae" translate="yes" xml:space="preserve">
          <source>The module supports &lt;code&gt;&lt;a href=&quot;unicode_usage#notes-about-raw-filenames&quot;&gt;raw filenames&lt;/a&gt;&lt;/code&gt; in the way that if a binary is present, or the filename cannot be interpreted according to the return value of &lt;code&gt;file:native_name_encoding/0&lt;/code&gt;, a raw filename is also returned. For example, &lt;code&gt;join/1&lt;/code&gt; provided with a path component that is a binary (and cannot be interpreted under the current native filename encoding) results in a raw filename that is returned (the join operation is performed of course). For more information about raw filenames, see the &lt;code&gt;file&lt;/code&gt; module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69b8aad69f452e4e151ee9bedf58e923325c5f2c" translate="yes" xml:space="preserve">
          <source>The module that implements the channel behaviour.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="334303a0b2e03a18e4f74196d147acdf2eda4f6c" translate="yes" xml:space="preserve">
          <source>The module that you specify gets passed down (eventually) into &lt;code&gt;Selector&lt;/code&gt;'s default &lt;code&gt;Filter&lt;/code&gt;. The format of the &lt;code&gt;et:trace_me/5&lt;/code&gt; function call is hardcoded in that &lt;code&gt;Filter&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9b6419eaf88095b6d469b88c58301f91a2d21d9" translate="yes" xml:space="preserve">
          <source>The module which handles the network interface part for the SNMP manager. It must implement the &lt;code&gt;&lt;a href=&quot;snmpm_network_interface&quot;&gt;snmpm_network_interface&lt;/a&gt;&lt;/code&gt; behaviour.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="523418eaa35d035f87ca00b206f2ef37af5e7c87" translate="yes" xml:space="preserve">
          <source>The module window is started by double clicking on an module name. The module window consists initially of two pages (tabs):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f14cab5a9810db8644af6de1dc33fee56bf0da0" translate="yes" xml:space="preserve">
          <source>The modules added will not be members of any applications.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49c86e71c1ea6137a22400599bd617796af2cd26" translate="yes" xml:space="preserve">
          <source>The modules found in the given directory are checked for calls to &lt;code&gt;&lt;a href=&quot;#deprecated_function&quot;&gt;deprecated functions&lt;/a&gt;&lt;/code&gt;, calls to &lt;code&gt;&lt;a href=&quot;#undefined_function&quot;&gt;undefined functions&lt;/a&gt;&lt;/code&gt;, and for unused local functions. The code path is used as &lt;code&gt;&lt;a href=&quot;#library_path&quot;&gt;library path&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1e420d1465bd766460e3f9194e1ada5445f2bda" translate="yes" xml:space="preserve">
          <source>The monitor functionality is expected to be extended. That is, other &lt;code&gt;Type&lt;/code&gt;s and &lt;code&gt;Item&lt;/code&gt;s are expected to be supported in a future release.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2df469dc538ecc56583353d35b1798e5f963f917" translate="yes" xml:space="preserve">
          <source>The monitor is &lt;strong&gt;not&lt;/strong&gt; automatically removed after it has been triggered. That is, repeated changes of the time offset trigger the monitor repeatedly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15ac3ec7a48d328efe660154448400a11004f42c" translate="yes" xml:space="preserve">
          <source>The monitor is triggered when the time offset is changed. This either if the time offset value is changed, or if the offset is changed from preliminary to final during &lt;code&gt;&lt;a href=&quot;#system_flag_time_offset&quot;&gt;finalization of the time offset&lt;/a&gt;&lt;/code&gt; when the &lt;code&gt;&lt;a href=&quot;time_correction#Single_Time_Warp_Mode&quot;&gt;single time warp mode&lt;/a&gt;&lt;/code&gt; is used. When a change from preliminary to final time offset is made, the monitor is triggered once regardless of whether the time offset value was changed or not.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9034b98321dccce18cf451d8ab9d47b947240ef" translate="yes" xml:space="preserve">
          <source>The monitor message is sent if the sum of the sizes of all memory blocks allocated for all heap generations after a garbage collection is equal to or higher than &lt;code&gt;Size&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="280bfd2e726362f1c09866455524beac7cfe5de9" translate="yes" xml:space="preserve">
          <source>The monitor request is an asynchronous signal. That is, it takes time before the signal reaches its destination.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b32b393fd0afad77f1403e24066f7c431fc21ce" translate="yes" xml:space="preserve">
          <source>The monitor tag is always &lt;code&gt;driver&lt;/code&gt;, as this function can only be used to create driver monitors. In the future, driver monitors will be integrated with process monitors, why this parameter has to be specified for consistence.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be29116d55d7dfe82c5e11e2f4acffe31864278e" translate="yes" xml:space="preserve">
          <source>The monitor was found and removed. In this case, no &lt;code&gt;'DOWN'&lt;/code&gt; message corresponding to this monitor has been delivered and will not be delivered.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0337b55edbb713b6c9fbbc890aad45af45f21f06" translate="yes" xml:space="preserve">
          <source>The monitor was not found and could not be removed. This probably because someone already has placed a &lt;code&gt;'DOWN'&lt;/code&gt; message corresponding to this monitor in the caller message queue.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aab04c2416f519588a8e783d3297a16514c4e755" translate="yes" xml:space="preserve">
          <source>The monitored driver instance is now unloaded. As the unload can be a result of a &lt;code&gt;reload/2&lt;/code&gt; request, the driver can once again have been loaded when this message arrives.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64d7c84598d002ae7b2cdc74963ff39c11423b77" translate="yes" xml:space="preserve">
          <source>The monitored entity, which triggered the event. When monitoring a local process or port, &lt;code&gt;Object&lt;/code&gt; will be equal to the &lt;code&gt;pid()&lt;/code&gt; or &lt;code&gt;port()&lt;/code&gt; that was being monitored. When monitoring process or port by name, &lt;code&gt;Object&lt;/code&gt; will have format &lt;code&gt;{RegisteredName, Node}&lt;/code&gt; where &lt;code&gt;RegisteredName&lt;/code&gt; is the name which has been used with &lt;code&gt;monitor/2&lt;/code&gt; call and &lt;code&gt;Node&lt;/code&gt; is local or remote node name (for ports monitored by name, &lt;code&gt;Node&lt;/code&gt; is always local node name).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6bf06e86189be19acddd04d200927d656e7dd37d" translate="yes" xml:space="preserve">
          <source>The most basic form of a batch is created by semicolons separated SQL queries, for example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a59719eda6e9d01c978b1c0cfa6a96f9fcd184fa" translate="yes" xml:space="preserve">
          <source>The most common application of transaction mechanisms is to keep row operations together. Since our agent sorts row operations, the mechanism implemented in combination with the RowStatus (particularly 'createAndWait' value) solve most problems elegantly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a9c06d55eedc6a8d2f902ccf52e01e8b01e26ff" translate="yes" xml:space="preserve">
          <source>The most commonly used BIFs belonging to &lt;code&gt;erlang(3)&lt;/code&gt; are &lt;strong&gt;auto-imported&lt;/strong&gt;. They do not need to be prefixed with the module name. Which BIFs that are auto-imported is specified in the &lt;code&gt;erlang(3)&lt;/code&gt; module in ERTS. For example, standard-type conversion BIFs like &lt;code&gt;atom_to_list&lt;/code&gt; and BIFs allowed in guards can be called without specifying the module name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f932fa2c48442351da05c7f82e31aff3efd5a23" translate="yes" xml:space="preserve">
          <source>The most commonly used types are &lt;code&gt;integer&lt;/code&gt;, &lt;code&gt;float&lt;/code&gt;, and &lt;code&gt;binary&lt;/code&gt;. See &lt;code&gt;Bit Syntax Expressions in the Reference Manual&lt;/code&gt; for a complete description.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac9d64e469ef7ced56b3eabcbe1d40968b713a6c" translate="yes" xml:space="preserve">
          <source>The most flexible way to specify what to test, is to use a test specification, which is a sequence of Erlang terms. The terms are normally declared in one or more text files (see &lt;code&gt;&lt;a href=&quot;ct#run_test-1&quot;&gt;ct:run_test/1&lt;/a&gt;&lt;/code&gt;), but can also be passed to &lt;code&gt;Common Test&lt;/code&gt; on the form of a list (see &lt;code&gt;&lt;a href=&quot;ct#run_testspec-1&quot;&gt;ct:run_testspec/1&lt;/a&gt;&lt;/code&gt;). There are two general types of terms: configuration terms and test specification terms.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c63e88fd2ffaffa754471ae2efc5aaf19cc51d66" translate="yes" xml:space="preserve">
          <source>The most notable difference between a match specification and an Erlang fun is the syntax. Match specifications are Erlang terms, not Erlang code. Also, a match specification has a strange concept of exceptions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2a46d708256a890cc8c5bbd317f2b1f19c5bc43" translate="yes" xml:space="preserve">
          <source>The most recent log file is the rightmost in each row. That is, the most recent file is the one with the highest number, or if there are already four files, the one before the skip.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd0e7640ef8705dad251d2e736a5efef30cdd300" translate="yes" xml:space="preserve">
          <source>The most significant bit is the &lt;code&gt;NewCacheEntryFlag&lt;/code&gt;. If set, the corresponding cache reference is new. The three least significant bits are the &lt;code&gt;SegmentIndex&lt;/code&gt; of the corresponding atom cache entry. An atom cache consists of 8 segments, each of size 256, that is, an atom cache can contain 2048 entries.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2788a4ce9749d7747a7b2405ff14fe489fb5bd3b" translate="yes" xml:space="preserve">
          <source>The most straightforward representation. Each character is stored in one single 32-bit number. There is no need for escapes or any variable number of entities for one character. All Unicode code points can be stored in one single 32-bit entity. As with UTF-16, there are byte-order issues. UTF-32 can be both big-endian and little-endian.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="276f7c971b5e4ce251c40cb717c8adebadd70cf8" translate="yes" xml:space="preserve">
          <source>The most use of this function would be if one for example uses the &lt;code&gt;io&lt;/code&gt; module to communicate with an I/O-server for a regular file, like in the following example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="750fc0fe85477bda2150e648c512e34c1afec03c" translate="yes" xml:space="preserve">
          <source>The most versatile way to handle time-outs is to use Erlang Timers; see &lt;code&gt;erlang:start_timer/3,4&lt;/code&gt;. Most time-out tasks can be performed with the time-out features in &lt;code&gt;gen_statem&lt;/code&gt;, but an example of one that can not is if you should need the return value from &lt;code&gt;erlang:cancel_timer(Tref)&lt;/code&gt;, that is; the remaining time of the timer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a0d9d7bcf952de8136817cdd4400566b2d55dbf" translate="yes" xml:space="preserve">
          <source>The motivation for alternate dictionaries is RFC 7683, Diameter Overload Indication Conveyance (DOIC), which defines AVPs to be piggybacked onto existing application messages rather than defining an application of its own. The DOIC dictionary is provided by the diameter application, as module &lt;code&gt;diameter_gen_doic_rfc7683&lt;/code&gt;, but alternate dictionaries can be used to encode/decode any set of AVPs not known to an application dictionary.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d91905ede33f8ff195d296077e558f92b868c336" translate="yes" xml:space="preserve">
          <source>The mouse buttons behave as expected. Use left-click to select objects, right-click to get a menu with the most used options, and double-click to display information about the selected object. In most viewers with many columns, you can change the sort order by left-clicking the column header.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d51d529839aa845352125415e30ac1e06dd6c469" translate="yes" xml:space="preserve">
          <source>The msg is either the binary &quot;cleartext&quot; data or it is the hashed value of &quot;cleartext&quot; i.e. the digest (plaintext).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b14b4a3785c5957a50b987dae462b671878b64ca" translate="yes" xml:space="preserve">
          <source>The msg is either the binary &quot;cleartext&quot; data to be signed or it is the hashed value of &quot;cleartext&quot; i.e. the digest (plaintext).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06e39bf8c6d5c07789729bace985f7385be5bc7d" translate="yes" xml:space="preserve">
          <source>The mstone (mstone1 and mstone2) module(s)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b37835e9362863cab04224df2d6371e6a0fb053b" translate="yes" xml:space="preserve">
          <source>The multi-request tag (&lt;code&gt;requests&lt;/code&gt;) is handled in a separate loop function applying the requests in the list one after another, returning the last result.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23debd07a945d566a02dcdb32a68d5943648993d" translate="yes" xml:space="preserve">
          <source>The multiblock carrier growth stages (&lt;code&gt;&lt;a href=&quot;#M_mbcgs&quot;&gt;mbcgs&lt;/a&gt;&lt;/code&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff5eb8ef08d964ccf13b2991de15ea2b46a940f2" translate="yes" xml:space="preserve">
          <source>The name &quot;word&quot; is a Perl extension, and &quot;blank&quot; is a GNU extension from Perl 5.8. Another Perl extension is negation, which is indicated by a ^ character after the colon. For example, the following matches &quot;1&quot;, &quot;2&quot;, or any non-digit:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f414a0fc6680e2dbcfe9f9956aebf12383da1b0d" translate="yes" xml:space="preserve">
          <source>The name (atom) of the group that the local node belongs to.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e804732505006dd7c7969c59d1f3efc6e15e1cf1" translate="yes" xml:space="preserve">
          <source>The name (atom) of the module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ea5812b14b364e780d92efa7352e85d9c8094a1" translate="yes" xml:space="preserve">
          <source>The name (string) of the BEAM file, or the binary from which the information was extracted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2274c550ae5b13836076f9a7929fd688045c89dd" translate="yes" xml:space="preserve">
          <source>The name &lt;code&gt;lait/1&lt;/code&gt; is a misspelling - do not use it anymore.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63f740169c092f330a56a6ac0c5a087138d89aff" translate="yes" xml:space="preserve">
          <source>The name of a generated dictionary module as generated by &lt;code&gt;&lt;a href=&quot;diameterc&quot;&gt;diameterc(1)&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;diameter_make#codec-2&quot;&gt;diameter_make:codec/2&lt;/a&gt;&lt;/code&gt;. The interface provided by a dictionary module is an implementation detail that may change.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cdd16490cd1c460a31b904b705bbc01a37d6d356" translate="yes" xml:space="preserve">
          <source>The name of a process group.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe553f36c37e4dc0b840932349b35c736986e7b9" translate="yes" xml:space="preserve">
          <source>The name of a registered port, as an atom.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="068c1e29898954da7dafd70c60c0281782bdf6c5" translate="yes" xml:space="preserve">
          <source>The name of a registered process, as an atom.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="781b85e865fd06d99312a507847ed2319f617cf1" translate="yes" xml:space="preserve">
          <source>The name of a zip file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14a3bc59edd8f43ed0656e84308b952ff50507a2" translate="yes" xml:space="preserve">
          <source>The name of all instrumentation functions must be the same as the corresponding managed object it implements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3fd2da7d7d7f0930e22b98a6d6e1a55d9b181147" translate="yes" xml:space="preserve">
          <source>The name of an executable program that can be used as an interface for specifying and running tests with &lt;code&gt;Common Test&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ceba45d1b18e3dd3cc8da1a11142ef2efd79c65f" translate="yes" xml:space="preserve">
          <source>The name of the ASN.1 specification</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="017669fbaeb7cca7f42900b9524557094afd427e" translate="yes" xml:space="preserve">
          <source>The name of the AVP as defined in the dictionary file in question, or &lt;code&gt;undefined&lt;/code&gt; if the AVP is unknown to the dictionary file in question.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb19f7e4ed9ccee1886a04f755cad374e6bf2833" translate="yes" xml:space="preserve">
          <source>The name of the command set by &lt;code&gt;erlang:open_port/2&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a69ba7d63607e672a0bddb87dd2b06b8084a0156" translate="yes" xml:space="preserve">
          <source>The name of the current function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d5f02fcd54d2c4aea3c80c0f03903502a3ce2db" translate="yes" xml:space="preserve">
          <source>The name of the current module, as a string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c44e0c83244028d9b0e30cf7a2d2504d40b0af59" translate="yes" xml:space="preserve">
          <source>The name of the current module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b706d162247dd36c2c34198513b7054a12041a8e" translate="yes" xml:space="preserve">
          <source>The name of the dumped table. If the table was a named table, a table with the same name cannot exist when the table is loaded from file with &lt;code&gt;&lt;a href=&quot;#file2tab-2&quot;&gt;file2tab/2&lt;/a&gt;&lt;/code&gt;. If the table is not saved as a named table, this field has no significance when loading the table from file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b173e28eec1dbfe6b6a9acf56060edd59ce91a80" translate="yes" xml:space="preserve">
          <source>The name of the element is found in the &lt;code&gt;name&lt;/code&gt; field. In the &lt;code&gt;parents&lt;/code&gt; field is the names of the parent elements saved. Parents is a list of tuples where the first element in each tuple is the name of the parent element. The list is in reverse order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9bdb35ccec0faa5ab435abc22ae894c98451909a" translate="yes" xml:space="preserve">
          <source>The name of the exclusive decode function</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9cd1cfd2a7c75e9d469f30e6b8aa44633fee5f8" translate="yes" xml:space="preserve">
          <source>The name of the executable as well as the arguments specifed in &lt;code&gt;cd&lt;/code&gt;, &lt;code&gt;env&lt;/code&gt;, &lt;code&gt;args&lt;/code&gt;, and &lt;code&gt;arg0&lt;/code&gt; are subject to Unicode filename translation if the system is running in Unicode filename mode. To avoid translation or to force, for example UTF-8, supply the executable and/or arguments as a binary in the correct encoding. For details, see the module &lt;code&gt;file(3)&lt;/code&gt;, the function &lt;code&gt;file:native_name_encoding/0&lt;/code&gt; in Kernel, and the &lt;code&gt;Using Unicode in Erlang&lt;/code&gt; User's Guide.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="145bef4824887ac958179d5dc67a74ef7822e376" translate="yes" xml:space="preserve">
          <source>The name of the file (actually a named pipe) that is to receive the information</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a03ff0e0c54f689b6ef65841c20ee8be07ab00cd" translate="yes" xml:space="preserve">
          <source>The name of the fragmented table</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e84326facd2f5685ce1620f764c65298c11a51af" translate="yes" xml:space="preserve">
          <source>The name of the module where the fun was defined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d9aeed296de66746c856a81bf8f9ded5e43cdf7" translate="yes" xml:space="preserve">
          <source>The name of the program which started Erlang:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98a9f43eda81f29bf9d5743946a9ea8fd9286582" translate="yes" xml:space="preserve">
          <source>The name of the remote node.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c050e4fb9fc899bdfcbcbf709859cc750e6a455f" translate="yes" xml:space="preserve">
          <source>The name of the saved file is the same as the name of the schema, but with &lt;code&gt;.xss&lt;/code&gt; extension.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e86acd0ca5b48cdb98c4c075c4205c3b79b72431" translate="yes" xml:space="preserve">
          <source>The name of the service that started the machine.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1f79a45516e8d9666e0b4109e4162f8073d0a02" translate="yes" xml:space="preserve">
          <source>The name of the socket file (the path prefix removed), which allows for deletion (&lt;code&gt;unlink&lt;/code&gt;) when the socket is closed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d325a204adba96bb16ee250d72f562304e27637" translate="yes" xml:space="preserve">
          <source>The name of the started node becomes &lt;code&gt;Name@Host&lt;/code&gt;. If no name is provided, the name becomes the same as the node that executes the call (except the host name part of the node name).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef518922fd516452499d2abfb02bdb4cf49f94a5" translate="yes" xml:space="preserve">
          <source>The name of the user function</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39f567390152e02d37fe6a831a2b17a677f34378" translate="yes" xml:space="preserve">
          <source>The name of your server, normally a fully qualified domain name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c657342b93672825ac56ce5aad93896816b11389" translate="yes" xml:space="preserve">
          <source>The name or IP address of the host where the TFTP daemon resides. This option is only used by the client.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="efd3b9bd3feb790c69b6f53e83bb01160208a7e5" translate="yes" xml:space="preserve">
          <source>The name server also maintains a fully connected network. For example, if node &lt;code&gt;N1&lt;/code&gt; connects to node &lt;code&gt;N2&lt;/code&gt; (which is already connected to &lt;code&gt;N3&lt;/code&gt;), the global name servers on the nodes &lt;code&gt;N1&lt;/code&gt; and &lt;code&gt;N3&lt;/code&gt; ensure that also &lt;code&gt;N1&lt;/code&gt; and &lt;code&gt;N3&lt;/code&gt; are connected. If this is not desired, command-line flag &lt;code&gt;-connect_all false&lt;/code&gt; can be used (see also &lt;code&gt;erl(1)&lt;/code&gt;). In this case, the name registration service cannot be used, but the lock mechanism still works.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70bbd5b825a0e3f16b591b2238348e211ea12fa7" translate="yes" xml:space="preserve">
          <source>The name(s) of the user-defined residence module(s) must be listed in the &lt;code&gt;Modules&lt;/code&gt; part of the child specification for the special process. Otherwise the release handler cannot find the process.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55639d1e8772a94a0b0836a082a724c02665921b" translate="yes" xml:space="preserve">
          <source>The named file is a directory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14d72b8811543846930a80f5f7f7859cd2878b00" translate="yes" xml:space="preserve">
          <source>The named pipe, usually &lt;code&gt;/tmp/&lt;/code&gt;. It must be suffixed by a &lt;code&gt;/&lt;/code&gt; (slash), that is, &lt;code&gt;/tmp/epipes/&lt;/code&gt;, not &lt;code&gt;/tmp/epipes&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f0fcca13871e6412c5bb752140a8243dc65e989" translate="yes" xml:space="preserve">
          <source>The names of all fragments</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38f3d4f81f2a3fb4b6790bd99cb201c153f2cb7b" translate="yes" xml:space="preserve">
          <source>The naming of the service in a system that uses release handling must follow the convention &lt;strong id=&quot;001&quot;&gt;NodeName&lt;/strong&gt;_&lt;strong&gt;Release&lt;/strong&gt;, where &lt;strong&gt;NodeName&lt;/strong&gt; is the first part of the Erlang node name (up to, but not including the &quot;@&quot;) and &lt;strong&gt;Release&lt;/strong&gt; is the current release of the application.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="865ddb889727f82a24bd4d5836d553df871c5cb5" translate="yes" xml:space="preserve">
          <source>The native code will be placed into the beam file and automatically loaded when the beam file is loaded.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e0d9e387da412c6854e55d2ea6c29168d1cc99c" translate="yes" xml:space="preserve">
          <source>The negotiated protocol can be retrieved using the &lt;code&gt;negotiated_protocol/1&lt;/code&gt; function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d19b33d4325de1693405141a928c25d4f21b350" translate="yes" xml:space="preserve">
          <source>The negotiation is simple: both peers sends their list of supported alghorithms to the other part. The first algorithm on the client's list that also in on the server's list is selected. So it is the client's orderering of the list that gives the priority for the algorithms.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0fb72997ab3557ef82a230bb3682011bf2c48d8" translate="yes" xml:space="preserve">
          <source>The net kernel is a system process, registered as &lt;code&gt;net_kernel&lt;/code&gt;, which must be operational for distributed Erlang to work. The purpose of this process is to implement parts of the BIFs &lt;code&gt;spawn/4&lt;/code&gt; and &lt;code&gt;spawn_link/4&lt;/code&gt;, and to provide monitoring of the network.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b9ff73038bb4f2d73ed04274ea6798f021e1bdd" translate="yes" xml:space="preserve">
          <source>The network connection to the client is broken.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da852eb6d3cd7c2bee53433293d851328338d462" translate="yes" xml:space="preserve">
          <source>The new &lt;code&gt;sys.config&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a02721e2497fbe700123fb9e3a729f740f43a941" translate="yes" xml:space="preserve">
          <source>The new API also consists of extensions of the following existing BIFs:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14ce5a3ea27213da49e5b9bde3bdc06535343fd3" translate="yes" xml:space="preserve">
          <source>The new API consists of the following new BIFs:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2e000cc20f5ca067c8f3696f8838efc3f818b18" translate="yes" xml:space="preserve">
          <source>The new application version &lt;code&gt;ch_app-2&lt;/code&gt; is installed under &lt;code&gt;$ROOT/lib&lt;/code&gt; next to &lt;code&gt;ch_app-1&lt;/code&gt;. The &lt;code&gt;kernel&lt;/code&gt;, &lt;code&gt;stdlib&lt;/code&gt;, and &lt;code&gt;sasl&lt;/code&gt; directories are not affected, as they have not changed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59032a152ed589ec4feaf1322f673d94f7aaad6d" translate="yes" xml:space="preserve">
          <source>The new configuration is merged with the existing formatter configuration.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83d81766969865b40c9a40366463e9a12358c346" translate="yes" xml:space="preserve">
          <source>The new default behaviour is that the SASL application no longer affects which log events that are logged. &lt;code&gt;&lt;a href=&quot;#supervisor_report&quot;&gt;Supervisor reports&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#crash_report&quot;&gt;crash reports&lt;/a&gt;&lt;/code&gt; are logged via the default logger handler which is setup by Kernel. &lt;code&gt;&lt;a href=&quot;#progress_report&quot;&gt;Progress reports&lt;/a&gt;&lt;/code&gt; are by default not logged, but can be enabled by setting the primary log level to &lt;code&gt;info&lt;/code&gt;, for example by using the Kernel configuration parameter &lt;code&gt;logger_level&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90289d546aac89c2e80a44e2dc66fc3797c85bff" translate="yes" xml:space="preserve">
          <source>The new handler is added even if the the specified old event handler is not installed, in which case &lt;code&gt;Term=error&lt;/code&gt;, or if &lt;code&gt;Module1:terminate/2&lt;/code&gt; fails with &lt;code&gt;Reason&lt;/code&gt;, in which case &lt;code&gt;Term={'EXIT',Reason}&lt;/code&gt;. The old handler is deleted even if &lt;code&gt;Module2:init/1&lt;/code&gt; fails.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="861a2e8c420a1842a7f2ab5f571c0efd4455430e" translate="yes" xml:space="preserve">
          <source>The new port owner gets linked to the port.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="902088f9e762def66cfe8ee46deb82a6a7c3b707" translate="yes" xml:space="preserve">
          <source>The new process starts executing in &lt;code&gt;Module:Name(Arg1,...,ArgN)&lt;/code&gt; where the arguments are the elements of the (possible empty) &lt;code&gt;Args&lt;/code&gt; argument list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01969408fe300767acbbb5a6a95d7a01999fe18a" translate="yes" xml:space="preserve">
          <source>The new profile has no proxy settings, so the connection is refused:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="272d17b899e78f71208c1a6461cad1aeb1df67f2" translate="yes" xml:space="preserve">
          <source>The new release must still be made permanent after the upgrade is completed, otherwise the old emulator is started if there is an emulator restart.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5848daab5022f7091ecd71b8112f54b552d8ba95" translate="yes" xml:space="preserve">
          <source>The new release package now also contains version &quot;2&quot; of &lt;code&gt;ch_app&lt;/code&gt; and the &lt;code&gt;relup&lt;/code&gt; file:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="151b13999b32ae6dd1c2edc6085a347c6f775003" translate="yes" xml:space="preserve">
          <source>The new release version must be made permanent when the new emulator is operational. Otherwise, the old version will be used if there is a new system reboot.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dcca389ca88db583caeb0a8f28a9b042cb4dbdc7" translate="yes" xml:space="preserve">
          <source>The new supervisor process calls the callback function &lt;code&gt;ch_sup:init([])&lt;/code&gt;. &lt;code&gt;init&lt;/code&gt; shall return &lt;code&gt;{ok, {SupFlags, ChildSpecs}}&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51319161abd02362f27a398a1fe31b0e9c37ac47" translate="yes" xml:space="preserve">
          <source>The new verbs make use of what was previously invalid syntax: an opening parenthesis followed by an asterisk. They are generally of the form (*VERB) or (*VERB:NAME). Some can take either form, possibly behaving differently depending on whether a name is present. A name is any sequence of characters that does not include a closing parenthesis. The maximum name length is 255 in the 8-bit library and 65535 in the 16-bit and 32-bit libraries. If the name is empty, that is, if the closing parenthesis immediately follows the colon, the effect is as if the colon was not there. Any number of these verbs can occur in a pattern.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="215b161818282063f148ff8da610c62e944bf7ef" translate="yes" xml:space="preserve">
          <source>The newline convention affects where the circumflex and dollar assertions are true. It also affects the interpretation of the dot metacharacter when &lt;code&gt;dotall&lt;/code&gt; is not set, and the behavior of \N. However, it does not affect what the \R escape sequence matches. By default, this is any Unicode newline sequence, for Perl compatibility. However, this can be changed; see the description of \R in section &lt;code&gt;&lt;a href=&quot;#newline_sequences&quot;&gt;Newline Sequences&lt;/a&gt;&lt;/code&gt;. A change of the \R setting can be combined with a change of the newline convention.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa9ce37388c079f08c2d34d6dbefdaceaae17a26" translate="yes" xml:space="preserve">
          <source>The next example has both &lt;code&gt;Subject&lt;/code&gt; and &lt;code&gt;Subject Alternate Name&lt;/code&gt; present:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4312b6eb6f9623ee8f0dbf0acd84042778ca8185" translate="yes" xml:space="preserve">
          <source>The next example is the ping pong program, yet again, but this time &quot;ping&quot; is started in another node:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a489b889bb50acfc73253c688e246f84e36bfb1" translate="yes" xml:space="preserve">
          <source>The next few commands assume that &lt;code&gt;test1:demo(X)&lt;/code&gt; is defined as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a78aa43091c6b8ceee531b79859ff361a0c70162" translate="yes" xml:space="preserve">
          <source>The next few commands show some record manipulation. It is assumed that &lt;code&gt;ex.erl&lt;/code&gt; defines a record as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb2f4c70a5ddd641a7c7cece836164fd20868016" translate="yes" xml:space="preserve">
          <source>The next template matches on the &lt;code&gt;bike&lt;/code&gt; element:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95db43fd70e2774066c2eb7f8160a4afc368f658" translate="yes" xml:space="preserve">
          <source>The nif writer is to provide the memory for storing the monitor when calling &lt;code&gt;&lt;a href=&quot;#enif_monitor_process&quot;&gt;enif_monitor_process&lt;/a&gt;&lt;/code&gt;. The address of the data is not stored by the runtime system, so &lt;code&gt;ErlNifMonitor&lt;/code&gt; can be used as any other data, it can be copied, moved in memory, forgotten, and so on. To compare two monitors, &lt;code&gt;&lt;a href=&quot;#enif_compare_monitors&quot;&gt;enif_compare_monitors&lt;/a&gt;&lt;/code&gt; must be used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08409f3c21c53e70ad49f4d51fc6209994cfdfe6" translate="yes" xml:space="preserve">
          <source>The node can handle extended pids and ports. This is required today. If not present, the connection is refused.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc5a5b212db7cd4390e6199cd85d2036154a00d5" translate="yes" xml:space="preserve">
          <source>The node implements an atom cache (obsolete).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="281b9f23f7b8d53d42a4c87c8c2ac676439952b2" translate="yes" xml:space="preserve">
          <source>The node implements atom cache in distribution header.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d081f7d6c9b36af20a121c7eb30cda4b27e3f40" translate="yes" xml:space="preserve">
          <source>The node implements distributed named process monitoring.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3fed8a46db41b2b3acc894e988a972c7e551cd4" translate="yes" xml:space="preserve">
          <source>The node implements distributed process monitoring.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c290f1695a97d158f0cca645bdaac52154a45a48" translate="yes" xml:space="preserve">
          <source>The node implements extended (3 &amp;times; 32 bits) references. This is required today. If not present, the connection is refused.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="220f04ba10adb170f6a597676f032142dfa5b439" translate="yes" xml:space="preserve">
          <source>The node in pid &lt;code&gt;t&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b04ef2a66fbcd0df01a238b3b604c182b6b0fdf3" translate="yes" xml:space="preserve">
          <source>The node in port &lt;code&gt;t&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75176ee78897d13c331b9db88b37a6e3a9d123c3" translate="yes" xml:space="preserve">
          <source>The node is accessible through a new pipe:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28fa0e5cd5fe4594591931d814b0c4ba1e753d94" translate="yes" xml:space="preserve">
          <source>The node is to be published and part of the global namespace.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d54e976693fcf1e41748b27bf394174406184e6a" translate="yes" xml:space="preserve">
          <source>The node name &lt;code&gt;Node&lt;/code&gt; is to be the name of the C node. If short node names are used, the plain name of the node is &lt;code&gt;cN&lt;/code&gt;, where &lt;code&gt;N&lt;/code&gt; is an integer. If long node names are used, there is no such restriction. An example of a C node name using short node names is thus &lt;code&gt;c1@idril&lt;/code&gt;, an example using long node names is &lt;code&gt;cnode@idril.ericsson.se&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec68e7e5a1c1e0362af0ba664dfbe218c891bbb8" translate="yes" xml:space="preserve">
          <source>The node name as an UTF-8 encoded string of &lt;code&gt;Nlen&lt;/code&gt; bytes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54e641481b78d40b7f0d13f44dc8ac44945e2bc1" translate="yes" xml:space="preserve">
          <source>The node name of the Erlang machine. Distribution is mandatory. Defaults to &lt;code&gt;-sname &amp;lt;service name&amp;gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7013f821805350971680d8e2b7cebcb41595b7b3" translate="yes" xml:space="preserve">
          <source>The node name of this node.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d86c6e1ca2f04c51bd365df74dcf158fdb370851" translate="yes" xml:space="preserve">
          <source>The node name will be &lt;code&gt;Name@Host&lt;/code&gt;, where &lt;code&gt;Host&lt;/code&gt; is the fully qualified host name of the current host. For short names, use flag &lt;code&gt;-sname&lt;/code&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7fca1953bdb5dbf94dcc8389d42b6cefbece8cd" translate="yes" xml:space="preserve">
          <source>The node name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9bcf7d5cb8ed6df1804c572bc6bf038771c7e18c" translate="yes" xml:space="preserve">
          <source>The node on which the client process resides has gone down.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41f458450045ddabec1cec2d090c135189e5c611" translate="yes" xml:space="preserve">
          <source>The node pool contains a list of nodes and can explicitly be set at table creation and later be changed with &lt;code&gt;{add_node, Node}&lt;/code&gt; or &lt;code&gt;{del_node, Node}&lt;/code&gt;. At table creation &lt;code&gt;Mnesia&lt;/code&gt; tries to distribute the replicas of each fragment evenly over all the nodes in the node pool. Hopefully all nodes end up with the same number of replicas. &lt;code&gt;node_pool&lt;/code&gt; defaults to the return value from the function &lt;code&gt;&lt;a href=&quot;mnesia#system_info-1&quot;&gt;mnesia:system_info(db_nodes)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="207f55f45138fa70f0de9e05412ca7fa4d942620" translate="yes" xml:space="preserve">
          <source>The node understand UTF-8 encoded atoms.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0361bcd66b03f6607ace0b0251db2af07f52cb88" translate="yes" xml:space="preserve">
          <source>The node understand big node creation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9bd7f509d096720411cce80a4c0204a3408b6f8e" translate="yes" xml:space="preserve">
          <source>The node understand new fun tags.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="894ceecec4e308228c7ad91a5d1bc07ff9266078" translate="yes" xml:space="preserve">
          <source>The node understand the &lt;code&gt;SMALL_ATOM_EXT&lt;/code&gt; tag.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="151f8180c3b312748f09057c417efde3a689457c" translate="yes" xml:space="preserve">
          <source>The node understand the map tag.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e934f26ef40068597701c482448fa6fcf04ed31" translate="yes" xml:space="preserve">
          <source>The node understands new float format.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91629496aa70f12f9dc344d8279c147f91e3a165" translate="yes" xml:space="preserve">
          <source>The node uses separate tag for funs (lambdas) in the distribution protocol.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f74fa1efb28b655576befa4c9558a73c950b9df2" translate="yes" xml:space="preserve">
          <source>The node where the table is stored. This field is no longer meaningful, as tables cannot be accessed from other nodes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ab9dd8f7f54478754ba9f39a29a916791467814" translate="yes" xml:space="preserve">
          <source>The nodes in a distributed Erlang system are loosely connected. The first time the name of another node is used, for example, if &lt;code&gt;spawn(Node,M,F,A)&lt;/code&gt; or &lt;code&gt;net_adm:ping(Node)&lt;/code&gt; is called, a connection attempt to that node is made.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ac2e00494210b4cb8b0c05904a98cf82ca69740" translate="yes" xml:space="preserve">
          <source>The nodes of the syntax tree must contain valid position information. This can be single integers, assumed to represent a line number, or 2- or 3-tuples where the first or second element is an integer, in which case the leftmost integer element is assumed to represent the line number. Line numbers less than one are ignored (usually, the default line number for newly created nodes is zero).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a500c6b344c68f0a4b0eb600d18358a8deed739" translate="yes" xml:space="preserve">
          <source>The non-local function handler &lt;strong&gt;is&lt;/strong&gt; however called with the evaluated arguments of the call to &lt;code&gt;erlang:apply/2,3&lt;/code&gt;: &lt;code&gt;Func(Fun, Args)&lt;/code&gt; or &lt;code&gt;Func({Module, Function}, Args)&lt;/code&gt; (assuming that &lt;code&gt;{Module, Function}&lt;/code&gt; is not &lt;code&gt;{erlang, apply}&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2104dfaf943c18e872cc21b511c0366a7ea1b0fb" translate="yes" xml:space="preserve">
          <source>The non-local function handler argument is probably not used as frequently as the local function handler argument. A possible use is to call &lt;code&gt;exit/1&lt;/code&gt; on calls to functions that for some reason are not allowed to be called.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7c221c15b667bea31580924db95e510885f6679" translate="yes" xml:space="preserve">
          <source>The normal use is to call the function without checking the return value, as it exits if it fails and the transaction is restarted by the transaction manager. It returns all the locked nodes if a write lock is acquired and &lt;code&gt;ok&lt;/code&gt; if it was a read lock.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80f684e59f18c37c44446b26508979681edb5449" translate="yes" xml:space="preserve">
          <source>The normal way to use the agent in a distributed environment is to use one master agent located at one node, and zero or more sub-agents located on other nodes. However, this configuration makes the master agent node a single point of failure. If that node goes down, the agent will not work.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e364c347f33083c7e078a191aa40c2608ebe1b9f" translate="yes" xml:space="preserve">
          <source>The notation &lt;code&gt;X &amp;lt;- [1,2,a,...]&lt;/code&gt; is a generator and the expression &lt;code&gt;X &amp;gt; 3&lt;/code&gt; is a filter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81f71b8120e4071fbcebde5e7f6026aa6ec9c5ff" translate="yes" xml:space="preserve">
          <source>The notification is sent as an Inform-Request to each target address in &lt;code&gt;Addresses&lt;/code&gt; and if there are no targets for which an Inform-Request is sent, &lt;code&gt;Addresses&lt;/code&gt; is the empty list &lt;code&gt;[]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6615a13126440b2f301d9feef9169efe1884cd9" translate="yes" xml:space="preserve">
          <source>The notification is sent to all management targets found in the tables. However, make sure that each manager has access to the variables in the notification. If a variable is outside a manager's MIB view, this manager will not receive the notification.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5c8e9a76a11f6a0d3766776061aee6dbbf3388a" translate="yes" xml:space="preserve">
          <source>The notifications are one-shot only. To receive further notifications of the same type (read or write), repeated calls to &lt;code&gt;enif_select&lt;/code&gt; must be made after receiving each notification.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="753c93a00c0ec14ac60e9c970f897dd5f7002f80" translate="yes" xml:space="preserve">
          <source>The notion that every fourth year is a leap year is not completely true. By the Gregorian rule, a year Y is a leap year if one of the following rules is valid:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf37afb1bc5f9dfefc13bbbfc7a24bfd243d1fbf" translate="yes" xml:space="preserve">
          <source>The number (in this case 85) is an integer from 1 to 100 that specifies the &quot;detail level&quot; of the message. The higher the number, the more important it is. This provides a crude form of priority filtering.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75565d0bbaf52f34d1f2ba494d3d8320058b3d47" translate="yes" xml:space="preserve">
          <source>The number &lt;code&gt;45&lt;/code&gt; in the example indicates the approximate number of objects that you expect to store in the registry. Internally the registry uses hash tables with collision chaining, so there is no absolute upper limit on the number of objects that the registry can contain, but if performance or memory usage is important, then you are to choose a number accordingly. The registry can be resized later.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79ec78d782f41f740663e090268ce34602ccfb0f" translate="yes" xml:space="preserve">
          <source>The number of ETS tables visible in the dump.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed2f858d504fbf2ee02e66edd9c9a034cd3c8f0e" translate="yes" xml:space="preserve">
          <source>The number of allocated heap fragments.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="511df0ea6957d5c04e1b4408f5d45d7fc95571c7" translate="yes" xml:space="preserve">
          <source>The number of arguments &lt;code&gt;N&lt;/code&gt; is the &lt;strong&gt;arity&lt;/strong&gt; of the function. A function is uniquely defined by the module name, function name, and arity. That is, two functions with the same name and in the same module, but with different arities are two different functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4219e3c77fe7b6dbf3a9ad6d1ab7b70fa1c036f8" translate="yes" xml:space="preserve">
          <source>The number of async threads in the async thread pool used by &lt;code&gt;&lt;a href=&quot;#driver_async&quot;&gt;driver_async&lt;/a&gt;&lt;/code&gt; (the same as returned by &lt;code&gt;&lt;a href=&quot;erlang#system_info_thread_pool_size&quot;&gt;erlang:system_info(thread_pool_size)&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6aed86243ce3461adf935203775b82c23ba81f19" translate="yes" xml:space="preserve">
          <source>The number of atoms in the atom table</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f5063a380fd018a365840c2dbb66e83694f1aa7" translate="yes" xml:space="preserve">
          <source>The number of atoms in the system at the time of the crash is shown as &lt;strong&gt;Atoms: &amp;lt;number&amp;gt;&lt;/strong&gt;. Some ten thousands atoms is perfectly normal, but more can indicate that the BIF &lt;code&gt;erlang:list_to_atom/1&lt;/code&gt; is used to generate many &lt;strong&gt;different&lt;/strong&gt; atoms dynamically, which is never a good idea.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d9211c3c41f9a0491a5cc3cd3b981543236ed4b" translate="yes" xml:space="preserve">
          <source>The number of bytes written (including terminating &lt;code&gt;NULL&lt;/code&gt; character)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae7a4579876ef85c9e9b38e1a9a4a8cc0f7ae5cf" translate="yes" xml:space="preserve">
          <source>The number of bytes written to the current wrap log file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0001e454297af213d4f16647035ec6c8df13a4c0" translate="yes" xml:space="preserve">
          <source>The number of characters equal to the field width are read (default is 1) and returned as an Erlang string. However, leading and trailing whitespace characters are not omitted as they are with &lt;code&gt;s&lt;/code&gt;. All characters are returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1137a738d4cfe43f2175847454d3ab0330b78877" translate="yes" xml:space="preserve">
          <source>The number of characters in the matched token.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28d997d875f7f8d0bd44b7c91e3ffe255434909a" translate="yes" xml:space="preserve">
          <source>The number of connections established depends on the user's configuration. Multiple connections per peer is possible.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="843b00b0f1b4bd5efff8041a104dc4a8c1ddc0ce" translate="yes" xml:space="preserve">
          <source>The number of dirty CPU scheduler threads created cannot exceed the number of normal scheduler threads created.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3138269edadb8dc8d29f17322230f4a4a908849" translate="yes" xml:space="preserve">
          <source>The number of dirty CPU scheduler threads is determined at emulator boot time and cannot be changed after that. However, the number of dirty CPU scheduler threads online can be changed at any time. The number of dirty CPU schedulers can be set at startup by passing command-line flag &lt;code&gt;+SDcpu&lt;/code&gt; or &lt;code&gt;+SDPcpu&lt;/code&gt; in &lt;code&gt;erl(1)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9da52b4c5d5ed584c408c7a1defe4da48427716" translate="yes" xml:space="preserve">
          <source>The number of dirty CPU scheduler threads online cannot exceed the number of normal scheduler threads online.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03808e9ad1a5bc412f55e40aed263839ec59bc4d" translate="yes" xml:space="preserve">
          <source>The number of dirty CPU schedulers online can be set at startup by passing command-line flag &lt;code&gt;+SDcpu&lt;/code&gt; in &lt;code&gt;erl(1)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e91fedb2f48921c5c8faa40b4bcc9a3dfcee32c3" translate="yes" xml:space="preserve">
          <source>The number of dirty CPU schedulers online can change if the number of schedulers online changes. For example, if 12 schedulers and 6 dirty CPU schedulers are online, and &lt;code&gt;system_flag/2&lt;/code&gt; is used to set the number of schedulers online to 6, then the number of dirty CPU schedulers online is automatically decreased by half as well, down to 3. Similarly, the number of dirty CPU schedulers online increases proportionally to increases in the number of schedulers online.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="296f215c8d873bb49890168fa9e88995a8c46221" translate="yes" xml:space="preserve">
          <source>The number of elements in the returned &lt;code&gt;OptionValues&lt;/code&gt; list does not necessarily correspond to the number of options asked for. If the operating system fails to support an option, it is left out in the returned list. An error tuple is returned only when getting options for the socket is impossible (that is, the socket is closed or the buffer size in a raw request is too large). This behavior is kept for backward compatibility reasons.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4cf38aefd99559296dffb26d07e3e9c61e6e9cb2" translate="yes" xml:space="preserve">
          <source>The number of elements in tuple &lt;code&gt;t&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26ac4cc854d74b2c6762d35018676306c4817781" translate="yes" xml:space="preserve">
          <source>The number of file descriptors for sockets exceeds 1024 (Unix only). The limit on file descriptors in some Unix flavors can be set to over 1024, but only 1024 sockets/pipes can be used simultaneously by Erlang (because of limitations in the Unix &lt;code&gt;select&lt;/code&gt; call). The number of open regular files is not affected by this.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6877de2384845937a41dca03e443b8b2ef2f56b" translate="yes" xml:space="preserve">
          <source>The number of free blocks available to the Erlang runtime system. This gives a fair indication of how fragmented the memory is.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2302ea4b081c2465e0482782a8cfc33a6b390e01" translate="yes" xml:space="preserve">
          <source>The number of free variables.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="520aa8d21c613166906958a988904ef3774762d4" translate="yes" xml:space="preserve">
          <source>The number of funs visible in the dump.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2f69372e36a07c28bf944db66a4eb608b5e6496" translate="yes" xml:space="preserve">
          <source>The number of intervals in the allocated block size histograms. Defaults to 18.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b9e6ddbdccc43d4ce9130240064e22a9d65b0ef" translate="yes" xml:space="preserve">
          <source>The number of intervals in the free block size histograms. Defaults to 14.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8443d0d1c03c60db5f3a78f878917394a94a0502" translate="yes" xml:space="preserve">
          <source>The number of items written to the current wrap log file, header inclusive.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d7b0fbb13153371168cb8b20a96211640b2aed4" translate="yes" xml:space="preserve">
          <source>The number of live argument registers. The argument registers if any are live will follow. These can contain the arguments of the function if they are not yet moved to the stack.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eaa55c6a7661cbf8bcd105fb5ba2accf528f1e54" translate="yes" xml:space="preserve">
          <source>The number of loads and unloads by different &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;users&lt;/a&gt;&lt;/code&gt; influences the loading and unloading of a driver file. The port killing therefore only occurs when the &lt;strong&gt;last&lt;/strong&gt;&lt;code&gt;&lt;a href=&quot;#users&quot;&gt;user&lt;/a&gt;&lt;/code&gt; unloads the driver, or when the last process having loaded the driver exits.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24dcf08225a4cd44c2b72687111ada888affaff5" translate="yes" xml:space="preserve">
          <source>The number of messages in the process' message queue.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="acf761f566ec0f6165b7b5bd0f0224040aa67d68" translate="yes" xml:space="preserve">
          <source>The number of messages processed in total (for all processes) is the mstone value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18ba056ef97bf335e6f0a4c98db5f6d989f8226b" translate="yes" xml:space="preserve">
          <source>The number of messages that the transaction coordinator and its participants need to exchange is few, as the &lt;code&gt;Mnesia&lt;/code&gt; table load mechanism takes care of the transaction recovery if the commit protocol gets interrupted. Since all involved tables are replicated symmetrically, the transaction is automatically recovered by loading the involved tables from the same node at startup of a failing node. It does not matter if the transaction was committed or terminated as long as the ACID properties can be ensured. The lightweight commit protocol is non-blocking, that is, the surviving participants and their coordinator finish the transaction, even if any node crashes in the middle of the commit protocol.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a9dd2a90b5afbfc3e6021a57e6d176d541df76e" translate="yes" xml:space="preserve">
          <source>The number of objects in the table when the table dump to file started. For a &lt;code&gt;public&lt;/code&gt; table, this number does not need to correspond to the number of objects saved to the file, as objects can have been added or deleted by another process during table dump.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2b7a9263d52e986e0825e5ba3ea4f95ca6e0342" translate="yes" xml:space="preserve">
          <source>The number of objects in the table.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0d1d535423cfacf2174f955ce39067569b39d55" translate="yes" xml:space="preserve">
          <source>The number of objects inserted in the table.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df0564a1b8506f23aaa82646ab79be6e878922a7" translate="yes" xml:space="preserve">
          <source>The number of objects written to the file is noted in the file footer, so file truncation can be verified even if the file was updated during dump.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85699df12b894cf4882879c296b009b318c0eb18" translate="yes" xml:space="preserve">
          <source>The number of outbound and inbound streams can be set by giving an &lt;code&gt;sctp_initmsg&lt;/code&gt; option to &lt;code&gt;connect&lt;/code&gt; as in:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1edbec7af58e779e6f3839b4b6e2a81fbb1ef2ff" translate="yes" xml:space="preserve">
          <source>The number of parts is to be a positive integer for a specific maximum number of parts, and &lt;code&gt;infinity&lt;/code&gt; for the maximum number of parts possible (the default). Specifying &lt;code&gt;{parts,0}&lt;/code&gt; gives as many parts as possible disregarding empty parts at the end, the same as specifying &lt;code&gt;trim&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2afdcddd62f1f4f544b050e244b0fb462484c316" translate="yes" xml:space="preserve">
          <source>The number of problems that arise when you always expect the wall clock time on the system to be correct can be immense. Erlang therefore introduced the &quot;corrected estimate of time&quot;, or the &quot;time correction&quot;, many years ago. The time correction relies on the fact that most operating systems have some kind of monotonic clock, either a real-time extension or some built-in &quot;tick counter&quot; that is independent of the wall clock settings. This counter can have microsecond resolution or much less, but it has a drift that cannot be ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57e379e562f068c00ec3666a97b2b72ec4e1ae9a" translate="yes" xml:space="preserve">
          <source>The number of processes on the node.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="216d68b131398c4d5787004436814a5409c5c6b7" translate="yes" xml:space="preserve">
          <source>The number of processes that are ready to run.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="290cb25c487c21d6fb8fcc8db9708b6206bd9cb5" translate="yes" xml:space="preserve">
          <source>The number of processes visible in the dump.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83a57a5a9d8d177f4eabd403df33513424ff9d76" translate="yes" xml:space="preserve">
          <source>The number of received messages in this example depends on which OS and which shell that is used on the machine running the &lt;code&gt;ssh&lt;/code&gt; daemon. See also &lt;code&gt;&lt;a href=&quot;ssh_connection#exec-4&quot;&gt;ssh_connection:exec/4&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="370052d660e4fe42c32d9343e6dadeb67604481b" translate="yes" xml:space="preserve">
          <source>The number of reductions a process is allowed to use before it is scheduled out is increased or reduced.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2bb198ca00ef4fce937de982b13112d9a0c04566" translate="yes" xml:space="preserve">
          <source>The number of reductions consumed by the process.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a35a61b164da1ac8ca925205248deac1f49ddb0" translate="yes" xml:space="preserve">
          <source>The number of reductions executed on the process.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b6c91666c81709e6916aac4bcc7db2c019f1985" translate="yes" xml:space="preserve">
          <source>The number of reductions executed on the process. This can be presented as accumulated values or as values since the last update.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e0994d6b82eb6222766c0e382dac55ae059c81e" translate="yes" xml:space="preserve">
          <source>The number of reductions performed before checking I/O is increased or reduced.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="468ae60b67a8e1bd0720dab30af034d085e6396a" translate="yes" xml:space="preserve">
          <source>The number of references to the fun.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="407623cffa34482fa1d651acd67eee8403ccbecb" translate="yes" xml:space="preserve">
          <source>The number of replicas with storage type &lt;code&gt;ram_copies&lt;/code&gt;, &lt;code&gt;disc_copies&lt;/code&gt;, and &lt;code&gt;disc_only_copies&lt;/code&gt;, respectively. The actual values are dynamically derived from the first fragment. The first fragment serves as a protype. When the actual values need to be computed (for example, when adding new fragments) they are determined by counting the number of each replica for each storage type. This means that when the functions &lt;code&gt;&lt;a href=&quot;mnesia#add_table_copy-3&quot;&gt;mnesia:add_table_copy/3&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;mnesia#del_table_copy-2&quot;&gt;mnesia:del_table_copy/2&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;mnesia#change_table_copy_type-3&quot;&gt;mnesia:change_table_copy_type/2&lt;/a&gt;&lt;/code&gt; are applied on the first fragment, it affects the settings on &lt;code&gt;n_ram_copies&lt;/code&gt;, &lt;code&gt;n_disc_copies&lt;/code&gt;, and &lt;code&gt;n_disc_only_copies&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a9702435fc48e2cb1af958102326978bfa82700" translate="yes" xml:space="preserve">
          <source>The number of requests that a client can do on one connection. When the server has responded to the number of requests defined by &lt;code&gt;max_keep_alive_requests&lt;/code&gt;, the server closes the connection. The server closes it even if there are queued request. Default is no limit.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e6e68ac95a410c172b5340729e962a534a2dd6f" translate="yes" xml:space="preserve">
          <source>The number of scheduler threads is determined at emulator boot time and cannot be changed later. However, the number of schedulers online can be changed at any time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5271e1c80bfa6c1f0d80364c70cd4221fb1fac88" translate="yes" xml:space="preserve">
          <source>The number of scheduler threads used by the runtime system (the same as returned by &lt;code&gt;&lt;a href=&quot;erlang#system_info_schedulers&quot;&gt;erlang:system_info(schedulers)&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32fda466767f8cc6473462d182e187e0d2a3c92f" translate="yes" xml:space="preserve">
          <source>The number of seconds the server waits for a subsequent request from the client before closing the connection. Default is &lt;code&gt;150&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6cd94e411933b9c1fa677dbde8d5b69166b1c7e8" translate="yes" xml:space="preserve">
          <source>The number of tables stored at one Erlang node &lt;strong&gt;used&lt;/strong&gt; to be limited. This is no longer the case (except by memory usage). The previous default limit was about 1400 tables and could be increased by setting the environment variable &lt;code&gt;ERL_MAX_ETS_TABLES&lt;/code&gt; or the command line option &lt;code&gt;+e&lt;/code&gt; before starting the Erlang runtime system. This hard limit has been removed, but it is currently useful to set the &lt;code&gt;ERL_MAX_ETS_TABLES&lt;/code&gt; anyway. It should be set to an approximate of the maximum amount of tables used. This since an internal table for named tables is sized using this value. If large amounts of named tables are used and &lt;code&gt;ERL_MAX_ETS_TABLES&lt;/code&gt; hasn't been increased, the performance of named table lookup will degrade.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ee6cef5045ecfc684ba415cb4ca61311f9f1874" translate="yes" xml:space="preserve">
          <source>The number of used reference numbers in ref &lt;code&gt;t&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b21087ec91e7492fc97a64907aa82ec4cec1d47" translate="yes" xml:space="preserve">
          <source>The number of whole megaseconds elapsed since the arbitrary point in time</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ac856f3d61651add159fe85d25637849ee12830" translate="yes" xml:space="preserve">
          <source>The number of whole microseconds elapsed since the arbitrary point in time</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7fc686361ce6577e49fbdfa1f7f9667a3114c986" translate="yes" xml:space="preserve">
          <source>The number of whole seconds elapsed since the arbitrary point in time</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54d5c18e70c70f565fba6a0087d94cc081284d10" translate="yes" xml:space="preserve">
          <source>The number of words (usually 4 bytes/word) allocated to data in the table.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47eb13f9275d0915b77640cef69cc834d1d7a797" translate="yes" xml:space="preserve">
          <source>The number of words allocated to the table.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34f864a2059c77fad570ae2b8b9aa8d55bc831b6" translate="yes" xml:space="preserve">
          <source>The numeric value of option &lt;code&gt;TCP_INFO&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc80d9d15d1bbefd0794c4eb3dc7e83893ef6e5a" translate="yes" xml:space="preserve">
          <source>The numeric value of protocol level &lt;code&gt;IPPROTO_TCP&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18b84a5716cb0140a4fa23575b7b99dd4e4ad89a" translate="yes" xml:space="preserve">
          <source>The object &lt;code&gt;object1&lt;/code&gt; is an instance of the class &lt;code&gt;GENERAL-PROCEDURE&lt;/code&gt; and has one type field and one fixed type value field. The object &lt;code&gt;object2&lt;/code&gt; has also an optional field &lt;code&gt;ERROR&lt;/code&gt;, which is a type field. The field &lt;code&gt;ADDRESS&lt;/code&gt; is a &lt;code&gt;UNIQUE&lt;/code&gt; field. Objects in an object set must have unique values in their &lt;code&gt;UNIQUE&lt;/code&gt; field, as in &lt;code&gt;GENERAL-PROCEDURES&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cbf8ca38a75143807f12207e1626da60e0683472" translate="yes" xml:space="preserve">
          <source>The object code can not be loaded because an old version of the code already exists.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e42f92b47527dda301da44c64b3f38f701eebfd" translate="yes" xml:space="preserve">
          <source>The object code could not be loaded because an old version of the code already existed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1c96d58c8d066eedb5b142300fba6386dd9f37a" translate="yes" xml:space="preserve">
          <source>The object code for all applications, structured according to the &lt;code&gt;&lt;a href=&quot;applications#app_dir&quot;&gt;application directory structure&lt;/a&gt;&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="312de602ae6cab5b49378f20db6833b3ebf51e54" translate="yes" xml:space="preserve">
          <source>The object code has an incorrect format or the module name in the object code is not the expected module name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9f74288a78af8c662bf58b4bfec75119b65998d" translate="yes" xml:space="preserve">
          <source>The object code in &lt;code&gt;Binary&lt;/code&gt; has an incorrect format &lt;strong&gt;or&lt;/strong&gt; the object code contains code for another module than &lt;code&gt;Module&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d86c3849edb93463e5fde8f6001389a8a8a16d72" translate="yes" xml:space="preserve">
          <source>The object code must be &lt;strong&gt;loaded&lt;/strong&gt; into the Erlang runtime system. This is handled by the &lt;strong&gt;code server&lt;/strong&gt;, see the &lt;code&gt;code(3)&lt;/code&gt; manual page in Kernel.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f7d279e2bf494f71d13acb1a9c0428dae21af2e" translate="yes" xml:space="preserve">
          <source>The object code resides in a sticky directory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9034bf7170e48c51bdec7372e69a543233e72148" translate="yes" xml:space="preserve">
          <source>The object has the wrong arity.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ce289dd810ddc811f5f67ba5e6a9137c550f27b" translate="yes" xml:space="preserve">
          <source>The object is removed from the registry after a call to &lt;code&gt;ei_reg_dump()&lt;/code&gt; or &lt;code&gt;ei_reg_purge()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50a81e0e0ac3bfcd2994a6155ab70f493367ff09" translate="yes" xml:space="preserve">
          <source>The objects in these MIBs are implemented in the modules &lt;code&gt;snmp_framework_mib&lt;/code&gt; and &lt;code&gt;snmp_standard_mib&lt;/code&gt;, respectively. All objects reside in volatile memory, and the configuration files are always reread at start-up.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1f269a0ce7fdbd2a517508eb670b7eae55c54f4" translate="yes" xml:space="preserve">
          <source>The objects of a table are distributed among slots, starting with slot &lt;code&gt;0&lt;/code&gt; and ending with slot &lt;code&gt;n&lt;/code&gt;. Returns the list of objects associated with slot &lt;code&gt;I&lt;/code&gt;. If &lt;code&gt;I&lt;/code&gt; &amp;gt; &lt;code&gt;n&lt;/code&gt;, &lt;code&gt;'$end_of_table'&lt;/code&gt; is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3cf193455ab85acb8426078bfa2d77fba608067" translate="yes" xml:space="preserve">
          <source>The octal value &lt;code&gt;ddd&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10825eec8b9992856eefc5e7184bd2d3d8b5728b" translate="yes" xml:space="preserve">
          <source>The offset, either a string or an integer, to be included in the formatted string. An empty string, which is the default, is interpreted as local time. A non-empty string is included as is. The time unit of the integer is the same as the one of &lt;code&gt;Time&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d661922c13a7026a70bf710f1f3e5ff84da384ab" translate="yes" xml:space="preserve">
          <source>The old &lt;code&gt;error_logger&lt;/code&gt; event handlers in STDLIB and SASL still exist, but they are not added by Erlang/OTP 21.0 or later.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e02582e73aee9b9d25f8eb0a27c6533b07e2b64" translate="yes" xml:space="preserve">
          <source>The old SASL error logging behaviour can be re-enabled by setting the Kernel configuration parameter &lt;code&gt;logger_sasl_compatible&lt;/code&gt; to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a76e919cb31d567d70f0c1884a6bff75f85a4f4" translate="yes" xml:space="preserve">
          <source>The old event category &lt;code&gt;{table, Tab}&lt;/code&gt; is the same event category as &lt;code&gt;{table, Tab, simple}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59f7e677b9778b0fb1d66db7316174f828de7a9a" translate="yes" xml:space="preserve">
          <source>The old module is still available for compatibility, but should not be used for new programs. The old module will not be maintained except for some error corrections</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4311de06755abb4e51609dffbdd9331251a3c42a" translate="yes" xml:space="preserve">
          <source>The old port owner stays linked to the port and must call &lt;code&gt;unlink(Port)&lt;/code&gt; if this is not desired. Any process can set the port owner to be any process with &lt;code&gt;port_connect/2&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="252509caf54119a65fc2fb237a753881b8ffad79" translate="yes" xml:space="preserve">
          <source>The old time API is based on &lt;code&gt;&lt;a href=&quot;erlang#now-0&quot;&gt;erlang:now/0&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;erlang:now/0&lt;/code&gt; was intended to be used for many unrelated things. This tied these unrelated operations together and caused issues with performance, scalability, accuracy, and precision for operations that did not need to have such issues. To improve this, the new API spreads different functionality over multiple functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0286a4a48dcade7c3397c916982a12af0309f49f" translate="yes" xml:space="preserve">
          <source>The old tuple format is kept for backwards compatibility, see &lt;code&gt;&lt;a href=&quot;#type-child_spec&quot;&gt;child_spec()&lt;/a&gt;&lt;/code&gt;, but the map is preferred.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5213f93470dcbb8caa4306da1f34f9dc9cde6c3f" translate="yes" xml:space="preserve">
          <source>The old tuple formats with &lt;code&gt;Ip&lt;/code&gt; address and &lt;code&gt;Udp&lt;/code&gt; port number found in old configurations still work.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c6a30a350aa9ef26562d44a342bd9fffb85daa0" translate="yes" xml:space="preserve">
          <source>The old user tag (if any) is returned, or &lt;code&gt;undefined&lt;/code&gt; if no user tag was present or dynamic tracing is not enabled.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="560418bd51e719aa06237064ddd18055f504721b" translate="yes" xml:space="preserve">
          <source>The only allowed driver option is &lt;code&gt;kill_ports&lt;/code&gt;, which means that all ports opened to the driver are killed with exit reason &lt;code&gt;driver_unloaded&lt;/code&gt; when no process any longer has the driver loaded. This situation arises either when the last &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;user&lt;/a&gt;&lt;/code&gt; calls &lt;code&gt;&lt;a href=&quot;#try_unload-2&quot;&gt;try_unload/2&lt;/a&gt;&lt;/code&gt;, or when the last process having loaded the driver exits.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b877b313b1006940c4cf41c60f09d3385fb04336" translate="yes" xml:space="preserve">
          <source>The only difference between &lt;code&gt;StateFunctionResult&lt;/code&gt; and &lt;code&gt;HandleEventResult&lt;/code&gt; is that for &lt;code&gt;StateFunctionResult&lt;/code&gt; the next state must be an atom, but for &lt;code&gt;HandleEventResult&lt;/code&gt; there is no restriction on the next state.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f50b6fea79bf8e8e2c3a8ded26b5d687ae24528" translate="yes" xml:space="preserve">
          <source>The only documentation that is recommended to be released in this way are the man pages. HTML and PDF will normally be distributed in some other manner.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1130e04c19ee8513c73e7178d0ff68d3aa9b5d59" translate="yes" xml:space="preserve">
          <source>The only exception to this rule is &lt;code&gt;error:undef&lt;/code&gt; which guarantees to include the Module, Function and Arity of the attempted function as the first stacktrace entry.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf2d1dc9bc29c7d67e629d6a36aab11ede21435f" translate="yes" xml:space="preserve">
          <source>The only exception to this rule is the class &lt;code&gt;error&lt;/code&gt; with the reason &lt;code&gt;undef&lt;/code&gt; which is guaranteed to include the &lt;code&gt;Module&lt;/code&gt;, &lt;code&gt;Function&lt;/code&gt; and &lt;code&gt;Arity&lt;/code&gt; of the attempted function as the first stacktrace entry.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cba16851052fe41ed6e022bc41a2dcd36c32376e" translate="yes" xml:space="preserve">
          <source>The only exported function from the driver is &lt;code&gt;driver_init&lt;/code&gt;. This function returns the &lt;code&gt;driver_entry&lt;/code&gt; structure that points to the other functions in the driver. The &lt;code&gt;driver_init&lt;/code&gt; function is declared with a macro, &lt;code&gt;DRIVER_INIT(drivername)&lt;/code&gt;. (This is because different operating systems have different names for it.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1696dc38d1cf9a5d02abc823dd0e7fc5c6596e2d" translate="yes" xml:space="preserve">
          <source>The only feature that not is implemented is the &lt;code&gt;netascii&lt;/code&gt; transfer mode.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5c833b89182cc5b90fce17ff719f78c8281aaac" translate="yes" xml:space="preserve">
          <source>The only new user interface function is the one provided by the user in the configuration file. The function is started by the &lt;code&gt;ModuleName:FunctionName&lt;/code&gt; notation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4c6a2cba6db5082ab2b924d01428d176098f7b4" translate="yes" xml:space="preserve">
          <source>The only possible error reason &lt;code&gt;Reason&lt;/code&gt; is &lt;code&gt;{&quot;global_groups definition error&quot;, Error}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4302c1a5eaa9921e04a9ee05f8db970b626954e6" translate="yes" xml:space="preserve">
          <source>The only reason to set it to &lt;code&gt;false&lt;/code&gt; is if you want to continue sending data to the socket after a close is detected, for example, if the peer uses &lt;code&gt;&lt;a href=&quot;gen_tcp#shutdown-2&quot;&gt;gen_tcp:shutdown/2&lt;/a&gt;&lt;/code&gt; to shut down the write side.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0bd2b35842e406e11aa99f3c06919005b7f0b40e" translate="yes" xml:space="preserve">
          <source>The only signal ordering guarantee given is the following: if an entity sends multiple signals to the same destination entity, the order is preserved; that is, if &lt;code&gt;A&lt;/code&gt; sends a signal &lt;code&gt;S1&lt;/code&gt; to &lt;code&gt;B&lt;/code&gt;, and later sends signal &lt;code&gt;S2&lt;/code&gt; to &lt;code&gt;B&lt;/code&gt;, &lt;code&gt;S1&lt;/code&gt; is guaranteed not to arrive after &lt;code&gt;S2&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16e25f07eac66ff46d41498e9c52f4e662f5d9c6" translate="yes" xml:space="preserve">
          <source>The only supported option is &lt;code&gt;{verify,boolean()}&lt;/code&gt;. If verification is turned on (by specifying &lt;code&gt;{verify,true}&lt;/code&gt;), the function uses whatever information is present in the file to assert that the information is not damaged. How this is done depends on which &lt;code&gt;extended_info&lt;/code&gt; was written using &lt;code&gt;&lt;a href=&quot;#tab2file-3&quot;&gt;tab2file/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4d83fec128ceaff5533b8b8493896363c149eb7" translate="yes" xml:space="preserve">
          <source>The only supported usage is to generate one distinct random sequence from this start state.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f32acd6c078a02af6a8141ee25a3cbecc6c24eae" translate="yes" xml:space="preserve">
          <source>The only syntactical limitation imposed by the preprocessor on the arguments to a macro application (viewed as sequences of tokens) is that they must be balanced with respect to parentheses, brackets, &lt;code&gt;begin ... end&lt;/code&gt;, &lt;code&gt;case ... end&lt;/code&gt;, etc. The &lt;code&gt;text&lt;/code&gt; node type can be used to represent arguments which are not regular Erlang constructs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5bcbae1f57b05af5cbe66ffd509cb1bd7d6129be" translate="yes" xml:space="preserve">
          <source>The only user which would return &lt;code&gt;{register, UserId, TargetName, AgentConfig}&lt;/code&gt; is the &lt;strong&gt;default user&lt;/strong&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1b3a9187732633f1cf125b19158045930fb9262" translate="yes" xml:space="preserve">
          <source>The only user which would return &lt;code&gt;{register, UserId, TargetName2, AgentConfig}&lt;/code&gt; is the &lt;strong&gt;default user&lt;/strong&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="856c8192723936f88433456a55a9d3e8225ac26b" translate="yes" xml:space="preserve">
          <source>The only user which would return &lt;code&gt;{register, UserId, TargetName2, agent_info()}&lt;/code&gt; is the &lt;strong&gt;default user&lt;/strong&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66ccb0d98fc09fa8872b21645b16bf70dd169beb" translate="yes" xml:space="preserve">
          <source>The only valid values for &lt;code&gt;&amp;lt;range&amp;gt;&lt;/code&gt; are &lt;code&gt;latin1&lt;/code&gt; and &lt;code&gt;unicode&lt;/code&gt;. &lt;code&gt;latin1&lt;/code&gt; means that only code points &amp;lt; 256 (except control characters, and so on) are considered printable. &lt;code&gt;unicode&lt;/code&gt; means that all printable characters in all Unicode character ranges are considered printable by the I/O functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02b1141f03eddf910011a4ff2a58eb780a8ab4e0" translate="yes" xml:space="preserve">
          <source>The opaque &lt;code&gt;&lt;a href=&quot;#type-handle&quot;&gt;handle()&lt;/a&gt;&lt;/code&gt; reference returned from this function can be used as client identifier when calling any other function in this module. However, if &lt;code&gt;KeyOrName&lt;/code&gt; is a &lt;code&gt;target_name()&lt;/code&gt;, that is, if the server is named through a call to &lt;code&gt;&lt;a href=&quot;ct#require-2&quot;&gt;ct:require/2&lt;/a&gt;&lt;/code&gt; or a &lt;code&gt;require&lt;/code&gt; statement in the test suite, then this name can be used instead of &lt;code&gt;&lt;a href=&quot;#type-handle&quot;&gt;handle()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="216692fe587eacd8f1cf30a3339eb308bb1cb50e" translate="yes" xml:space="preserve">
          <source>The opaque &lt;code&gt;&lt;a href=&quot;#type-handle&quot;&gt;handle()&lt;/a&gt;&lt;/code&gt; reference returned from this function can be used as client identifier when calling any other function in this module. However, if &lt;code&gt;KeyOrName&lt;/code&gt; is used and it is a &lt;code&gt;target_name()&lt;/code&gt;, that is, if the server is named through a call to &lt;code&gt;&lt;a href=&quot;ct#require-2&quot;&gt;ct:require/2&lt;/a&gt;&lt;/code&gt; or a &lt;code&gt;require&lt;/code&gt; statement in the test suite, then this name can be used instead of &lt;code&gt;&lt;a href=&quot;#type-handle&quot;&gt;handle()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dab51a13d4ecc21e5671204ca36e445fd1f3de37" translate="yes" xml:space="preserve">
          <source>The opaque &lt;code&gt;&lt;a href=&quot;#type-handle&quot;&gt;handle()&lt;/a&gt;&lt;/code&gt; reference returned from this function can be used as connection identifier when opening sessions over this connection, see &lt;code&gt;&lt;a href=&quot;#session-1&quot;&gt;session/1,2,3&lt;/a&gt;&lt;/code&gt;. However, if &lt;code&gt;KeyOrName&lt;/code&gt; is a &lt;code&gt;target_name()&lt;/code&gt;, that is, if the server is named through a call to &lt;code&gt;&lt;a href=&quot;ct#require-2&quot;&gt;ct:require/2&lt;/a&gt;&lt;/code&gt; or a &lt;code&gt;require&lt;/code&gt; statement in the test suite, then this name can be used instead of &lt;code&gt;&lt;a href=&quot;#type-handle&quot;&gt;handle()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a66edf19af62a3385d416b41ffcad011c88ad9a" translate="yes" xml:space="preserve">
          <source>The opaque &lt;code&gt;&lt;a href=&quot;#type-handle&quot;&gt;handle()&lt;/a&gt;&lt;/code&gt; reference returned from this function is required as client identifier when calling any other function in this module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dbb23ff6963a9fa5daa339e7b22a266927eaf0fb" translate="yes" xml:space="preserve">
          <source>The opaque &lt;code&gt;&lt;a href=&quot;#type-handle&quot;&gt;handle()&lt;/a&gt;&lt;/code&gt; reference returned from this function is required as connection identifier when opening sessions over this connection, see &lt;code&gt;&lt;a href=&quot;#session-1&quot;&gt;session/1,2,3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07aa6b76a1d620737ff1463895883152bf7bd915" translate="yes" xml:space="preserve">
          <source>The operating system has no concept of drives.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d1f7c571653276add5945991e7d8dbaf8340b38" translate="yes" xml:space="preserve">
          <source>The operating systems view of &lt;code&gt;&lt;a href=&quot;#POSIX_Time&quot;&gt;POSIX time&lt;/a&gt;&lt;/code&gt;. To retrieve it, call &lt;code&gt;os:system_time()&lt;/code&gt;. This may or may not be an accurate view of POSIX time. This time may typically be adjusted both backwards and forwards without limitation. That is, &lt;code&gt;&lt;a href=&quot;#Time_Warp&quot;&gt;time warps&lt;/a&gt;&lt;/code&gt; may be observed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b7dc04007a8243cf1e155a5507f9e9a7b4ed595" translate="yes" xml:space="preserve">
          <source>The operation was aborted, as the process needed to be garbage collected to determine the operation result, and the operation was requested by passing option &lt;code&gt;{allow_gc, false}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="028d2f9f2cf1ad6ba073b32e1d502dfedbbb24a1" translate="yes" xml:space="preserve">
          <source>The operator of a &lt;code&gt;Common Test&lt;/code&gt; system can receive event notifications continuously during a test run. For example, &lt;code&gt;Common Test&lt;/code&gt; reports when a test case starts and stops, the current count of successful, failed, and skipped cases, and so on. This information can be used for different purposes such as logging progress and results in another format than HTML, saving statistics to a database for report generation, and test system supervision.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ac9cd2f3357019ca23e28a1a5c29f888acd7d48" translate="yes" xml:space="preserve">
          <source>The opposite of &lt;code&gt;add_module&lt;/code&gt; is &lt;code&gt;delete_module&lt;/code&gt;, which unloads a module:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8201763988fd73d2d4e9e61c9df537349bc58481" translate="yes" xml:space="preserve">
          <source>The opposite of &lt;code&gt;use_stdio&lt;/code&gt;. It uses file descriptors 3 and 4 for communication with Erlang.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6947afa7b807cda54cd165aa32ce74a3d79f4c15" translate="yes" xml:space="preserve">
          <source>The optimization of the binary append operation requires that there is a &lt;strong&gt;single&lt;/strong&gt; ProcBin and a &lt;strong&gt;single reference&lt;/strong&gt; to the ProcBin for the binary. The reason is that the binary object can be moved (reallocated) during an append operation, and when that happens, the pointer in the ProcBin must be updated. If there would be more than one ProcBin pointing to the binary object, it would not be possible to find and update all of them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a7dfbb8b5004581e731dee0d182116bbc44ffc2" translate="yes" xml:space="preserve">
          <source>The option &lt;code&gt;agent_capabilities&lt;/code&gt;, if present, specifies that the AGENT-CAPABILITIES statement of the MIB shall be included (with a mib-entry record) in the compiled mib. The mib-entry record of the agent-capabilitie will contain &lt;code&gt;reference&lt;/code&gt; and &lt;code&gt;modules&lt;/code&gt; part(s) this info in the &lt;code&gt;assocList&lt;/code&gt; field).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06424cbe694389a0379fd6422e76eb2e7b311463" translate="yes" xml:space="preserve">
          <source>The option &lt;code&gt;db&lt;/code&gt; specifies which database should be used for the default instrumentation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1c38411f37d947a6f2316b11a66ae14df30f64e" translate="yes" xml:space="preserve">
          <source>The option &lt;code&gt;deprecated&lt;/code&gt; specifies if a deprecated definition should be kept or not. If the option is false the MIB compiler will ignore all deprecated definitions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55335984c5b08e8d1673e107cca029d522769243" translate="yes" xml:space="preserve">
          <source>The option &lt;code&gt;description&lt;/code&gt; specifies if the text of the DESCRIPTION field will be included or not.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09b9fb64f572f9490ecb854f2b8072cc568815e6" translate="yes" xml:space="preserve">
          <source>The option &lt;code&gt;group_check&lt;/code&gt; specifies whether the mib compiler should check the OBJECT-GROUP macro and the NOTIFICATION-GROUP macro for correctness or not.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee1cb6b787011127b81f08d59e1c6d1d5e4d9685" translate="yes" xml:space="preserve">
          <source>The option &lt;code&gt;i&lt;/code&gt; specifies the path to search for imported (compiled) MIB files. The directories should be strings with a trailing directory delimiter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eae87d7de383250a9c21b21bec8bbf0784d992a8" translate="yes" xml:space="preserve">
          <source>The option &lt;code&gt;il&lt;/code&gt; (include_lib) also specifies a list of directories to search for imported MIBs. It assumes that the first element in the directory name corresponds to an OTP application. The compiler will find the current installed version. For example, the value [&quot;snmp/mibs/&quot;] will be replaced by [&quot;snmp-3.1.1/mibs/&quot;] (or what the current version may be in the system). The current directory and the &lt;code&gt;&amp;lt;snmp-home&amp;gt;/priv/mibs/&lt;/code&gt; are always listed last in the include path.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aecef6269c58a221d8b83cd35b4abe167bc9b4fb" translate="yes" xml:space="preserve">
          <source>The option &lt;code&gt;imports&lt;/code&gt;, if present, specifies that the IMPORT statement of the MIB shall be included in the compiled mib.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d050cf3a9e6eaff748854538bc9531c00c71d49" translate="yes" xml:space="preserve">
          <source>The option &lt;code&gt;module&lt;/code&gt;, if present, specifies the name of a module which implements all instrumentation functions for the MIB.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2aabaa290b5cad088915be695ef4e5e2d192872" translate="yes" xml:space="preserve">
          <source>The option &lt;code&gt;module_compliance&lt;/code&gt;, if present, specifies that the MODULE-COMPLIANCE statement of the MIB shall be included (with a mib-entry record) in the compiled mib. The mib-entry record of the module-compliance will contain &lt;code&gt;reference&lt;/code&gt; and &lt;code&gt;module&lt;/code&gt; part(s) this info in the &lt;code&gt;assocList&lt;/code&gt; field).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4c88030e67c25f56859a203283edd3aad2cb537" translate="yes" xml:space="preserve">
          <source>The option &lt;code&gt;module_identity&lt;/code&gt;, if present, specifies that the info part of the MODULE-IDENTITY statement of the MIB shall be included in the compiled mib.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9f802c1128cac15a491e948fd2133dd4c271326" translate="yes" xml:space="preserve">
          <source>The option &lt;code&gt;no_defs&lt;/code&gt;, if present, specifies that if a managed object does not have an instrumentation function, the default instrumentation function should NOT be used, instead this is reported as an error, and the compilation aborts.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3534ebdcb42cec6bc4ed923a32d42f384e018c6f" translate="yes" xml:space="preserve">
          <source>The option &lt;code&gt;preferred_algorithms&lt;/code&gt; may be complicated to use for adding or removing single algorithms. First one has to list them with &lt;code&gt;ssh:default_algorithms()&lt;/code&gt; and then do changes in the lists.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0781dd6b89fb812468ff9fa696eedd3b05b73df" translate="yes" xml:space="preserve">
          <source>The option &lt;code&gt;reference&lt;/code&gt; specifies if the text of the REFERENCE field, when found in a table definition, will be included or not.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c2f0f1df982a9202e8988ea8ba0887c0ec765a3" translate="yes" xml:space="preserve">
          <source>The option &lt;code&gt;relaxed_row_name_assign_check&lt;/code&gt;, if present, specifies that the row name assign check shall not be done strictly according to the SMI (which allows only the value 1). With this option, all values greater than zero is allowed (&amp;gt;= 1). This means that the error will be converted to a warning.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="151eec6c2db1b331e575634845f94f69b16d7c18" translate="yes" xml:space="preserve">
          <source>The option &lt;code&gt;user_dir&lt;/code&gt; defaults to directory &lt;code&gt;users ~/.ssh&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29d7dbac9950684e60e65c932b5345b19e0b54d6" translate="yes" xml:space="preserve">
          <source>The option &lt;code&gt;verbosity&lt;/code&gt; specifies the verbosity of the SNMP mib compiler. I.e. if warning, info, log, debug and trace messages shall be shown.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5705298d46062a2bdcc353cd9d9485048e006df9" translate="yes" xml:space="preserve">
          <source>The option &lt;code&gt;warnings&lt;/code&gt; specifies whether warning messages should be shown.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6ac8043daec14dfce4fd3a09fc4e68dffb195c6" translate="yes" xml:space="preserve">
          <source>The option &lt;code&gt;warnings_as_errors&lt;/code&gt;, if present, specifies whether warnings should be treated as errors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="222e8e711eaedda0de12d881bcddb354da9d562f" translate="yes" xml:space="preserve">
          <source>The option &lt;code&gt;{inline_size,Size}&lt;/code&gt; controls how large functions that are allowed to be inlined. Default is &lt;code&gt;24&lt;/code&gt;, which keeps the size of the inlined code roughly the same as the un-inlined version (only relatively small functions are inlined).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d5f42ecfc1068f199f3ebaf4be4351cea9cfd06" translate="yes" xml:space="preserve">
          <source>The option &lt;strong&gt;does not&lt;/strong&gt; affect how data is returned from the I/O functions or how it is sent in the I/O protocol, it only affects how the I/O device is to handle Unicode characters to the &quot;physical&quot; device.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="338c829674166b013ae8d81f99bc61cb99452fea" translate="yes" xml:space="preserve">
          <source>The option also triggers port-killing (if driver option &lt;code&gt;kill_ports&lt;/code&gt; is used) although there are pending users, making it usable for forced driver replacement, but laying much responsibility on the driver &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;users&lt;/a&gt;&lt;/code&gt;. The pending option is seldom used as one does not want other &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;users&lt;/a&gt;&lt;/code&gt; to have loaded the driver when code change is underway.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2ca5efd3f45626d14f10b1048bf3a919d5d5db7" translate="yes" xml:space="preserve">
          <source>The option can be given in three different forms as seen above:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5c1f8228c64d69ef6b194e7e3a544bd5d6d3471" translate="yes" xml:space="preserve">
          <source>The option can be set by using flag &lt;code&gt;-cover_stop&lt;/code&gt; with &lt;code&gt;ct_run&lt;/code&gt;, by adding &lt;code&gt;{cover_stop,true|false}&lt;/code&gt; to argument &lt;code&gt;Opts&lt;/code&gt; to &lt;code&gt;&lt;a href=&quot;ct#run_test-1&quot;&gt;ct:run_test/1&lt;/a&gt;&lt;/code&gt;, or by adding a &lt;code&gt;cover_stop&lt;/code&gt; term in the test specification (see section &lt;code&gt;&lt;a href=&quot;run_test_chapter#test_specifications&quot;&gt;Test Specifications&lt;/a&gt;&lt;/code&gt; in section Running Tests and Analyzing Results).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a831925265214b18bff284c9cb5f8da772ac0d22" translate="yes" xml:space="preserve">
          <source>The option cooperates with the daemon-option &lt;code&gt;&lt;a href=&quot;#type-shell_daemon_option&quot;&gt;shell&lt;/a&gt;&lt;/code&gt; in the following way:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46610d896c3ed60bac06af5aa9b492b0218d289f" translate="yes" xml:space="preserve">
          <source>The option is good for reducing the risk of &quot;slow DoS&quot; attacks.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b36472af701f82ed3aadc8a7a7a28419165841c" translate="yes" xml:space="preserve">
          <source>The option list can contain the following options:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fbaef9197380d100811d0eacc53dce62a553d255" translate="yes" xml:space="preserve">
          <source>The option list given in the &lt;code&gt;&lt;a href=&quot;ssh#type-key_cb_common_option&quot;&gt;key_cb&lt;/a&gt;&lt;/code&gt; option is available with the key &lt;code&gt;key_cb_private&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df3c954b5ba9c1474ae29416fce03f6aaa090802" translate="yes" xml:space="preserve">
          <source>The option takes a list with instructions to append, prepend or remove algorithms:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2eb6213b7b87f0b7e6e4d25afe9e32cc806c629" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;Category&lt;/code&gt; argument can be used to categorize the log printout. Categories can be used for two things as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="447f5a3f76e3e9563c9b86d4ea43d4333c4ebffe" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;Descr&lt;/code&gt; parameter is included &quot;as is&quot; in the &lt;code&gt;relup&lt;/code&gt; file, see &lt;code&gt;&lt;a href=&quot;relup&quot;&gt;relup(4)&lt;/a&gt;&lt;/code&gt;. Defaults to the empty list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f923e9b577173731c7b96e064927ce55ee5384c" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;Timeout&lt;/code&gt; parameter specifies a time-out in milliseconds. Defaults to &lt;code&gt;infinity&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52335a394cf2ecea7217c7a04e3f8442f2097418" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;expect&lt;/code&gt; declaration can be placed anywhere before the last optional section with Erlang code. It is used for suppressing the warning about conflicts that is ordinarily given if the grammar is ambiguous. An example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="161604dc3e7d1bc8b928595e85930b898a263976" translate="yes" xml:space="preserve">
          <source>The optional argument &lt;code&gt;NonLocalFunctionHandler&lt;/code&gt; can be used to define a function that is called in the following cases:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0de6e1bc58d56088e6eddee453ec6c1aeb739d3a" translate="yes" xml:space="preserve">
          <source>The optional argument &lt;code&gt;Varbinds&lt;/code&gt; defines values for the objects in the notification. If no value is given for an object, the &lt;code&gt;Agent&lt;/code&gt; performs a get-operation to retrieve the value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9e24b2c05b3f59535f6993ef411d13d031da358" translate="yes" xml:space="preserve">
          <source>The options &lt;code&gt;'author'&lt;/code&gt; and &lt;code&gt;'version'&lt;/code&gt; are only used with &lt;code&gt;'windows'&lt;/code&gt; option mode.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6e6ee87f0886860f355c1e2932aa71133b1ec67" translate="yes" xml:space="preserve">
          <source>The options &lt;code&gt;cpu_time&lt;/code&gt; or &lt;code&gt;{cpu_time, true}&lt;/code&gt; makes the timestamps in the trace be in CPU time instead of wallclock time which is the default. This option is only allowed with the &lt;code&gt;start&lt;/code&gt; option.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a575a8485a0e80fe603347e1de8782c8007d6e61" translate="yes" xml:space="preserve">
          <source>The options &lt;code&gt;global&lt;/code&gt; and &lt;code&gt;local&lt;/code&gt; are mutually exclusive, and &lt;code&gt;global&lt;/code&gt; is the default (if no options are specified). The options &lt;code&gt;call_count&lt;/code&gt; and &lt;code&gt;meta&lt;/code&gt; perform a kind of local tracing, and cannot be combined with &lt;code&gt;global&lt;/code&gt;. A function can be globally or locally traced. If global tracing is specified for a set of functions, then local, meta, call time, and call count tracing for the matching set of local functions is disabled, and conversely.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="532c3466b01dbba024ee7d7263923dee4eb39f70" translate="yes" xml:space="preserve">
          <source>The options &lt;code&gt;verbose&lt;/code&gt; or &lt;code&gt;{verbose, true}&lt;/code&gt; adds some trace flags that &lt;code&gt;fprof&lt;/code&gt; does not need, but that may be interesting for general debugging purposes. This option is only allowed with the &lt;code&gt;start&lt;/code&gt; option.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42859c21f2b79ff6b36fc89627196cf7c13e3b9e" translate="yes" xml:space="preserve">
          <source>The options &lt;code&gt;{nowarn_unused_function, FAs}&lt;/code&gt;, &lt;code&gt;{nowarn_bif_clash, FAs}&lt;/code&gt;, and &lt;code&gt;{nowarn_deprecated_function, MFAs}&lt;/code&gt; are only recognized when given in files. They are not affected by options &lt;code&gt;warn_unused_function&lt;/code&gt;, &lt;code&gt;warn_bif_clash&lt;/code&gt;, or &lt;code&gt;warn_deprecated_function&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52fb8838009488073df993b32117ab4a617e4e27" translate="yes" xml:space="preserve">
          <source>The options above can be used both in clients and in daemons (servers). They are further explained below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9822c92221a3f35f766011a9109d3678a91584e" translate="yes" xml:space="preserve">
          <source>The options and values supported by the OTP I/O devices are as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="966a458ac5f5553b2b1772cc14d9f0802ad711ce" translate="yes" xml:space="preserve">
          <source>The options are &lt;code&gt;preferred_algorithms&lt;/code&gt; and &lt;code&gt;modify_algorithms&lt;/code&gt;. The first one replaces the default set, while the latter modifies the default set.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dbc030680dac1e5576f7a0a32beac02271b1de9f" translate="yes" xml:space="preserve">
          <source>The options are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0993030c5ac4d368f471285e301a74deb9b525f8" translate="yes" xml:space="preserve">
          <source>The options defaults to existing, write and keep.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a90ed84ac6c9da62366fd72993b92a3d6548993" translate="yes" xml:space="preserve">
          <source>The options for the tracee:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0d619e9e8a7b4ef0ea604d389b298331dfe1155" translate="yes" xml:space="preserve">
          <source>The options in &lt;code&gt;OptionList&lt;/code&gt; modify the defaults as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3cdec8fc084975065672d9bc75d5f2d7a5819ddb" translate="yes" xml:space="preserve">
          <source>The options in the &lt;code&gt;{server, Opts}&lt;/code&gt; tuple are used when calling &lt;code&gt;ssl:ssl_accept/3&lt;/code&gt;, and the options in the &lt;code&gt;{client, Opts}&lt;/code&gt; tuple are used when calling &lt;code&gt;ssl:connect/4&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7b32dbf5a7282fb93990ccd87cc73489c02dc49" translate="yes" xml:space="preserve">
          <source>The order in which a SetFun is applied to the elements of an unordered set is not specified, and can change in future versions of this module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f36c81c4641ae489656e683b39af63a52c09b9a1" translate="yes" xml:space="preserve">
          <source>The order in which keys are declared in matching has no relevance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba864cd36b5d9fc0734824a2d89b5010877afe23" translate="yes" xml:space="preserve">
          <source>The order in which test cases in a group are executed is under normal circumstances the same as the order specified in the test case list in the group definition. With property &lt;code&gt;shuffle&lt;/code&gt; set, however, &lt;code&gt;Common Test&lt;/code&gt; instead executes the test cases in random order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9181dd756bf0c244588172ca0c10840e8c09e01c" translate="yes" xml:space="preserve">
          <source>The order in which the expressions constructing the keys (and their associated values) are evaluated is not defined. The syntactic order of the key-value pairs in the construction is of no relevance, except in the recently mentioned case of two matching keys.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b2e651aff4100a2544284cdd623666e00826d4f" translate="yes" xml:space="preserve">
          <source>The order of &lt;code&gt;first&lt;/code&gt;/&lt;code&gt;last&lt;/code&gt; and &lt;code&gt;next&lt;/code&gt;/&lt;code&gt;prev&lt;/code&gt; is only valid for &lt;code&gt;ordered_set&lt;/code&gt; tables, they are synonyms for other tables. When the end of the table is reached, the special key &lt;code&gt;'$end_of_table'&lt;/code&gt; is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25f2ba6ee8246f16a08bc23339d4a331af938338" translate="yes" xml:space="preserve">
          <source>The order of AVPs in an encoded message is determined by the CCF of the message in question.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fca0f7684c3b5a228fba4c8df60980c0fb7304b8" translate="yes" xml:space="preserve">
          <source>The order of the &lt;code&gt;InfoTuple&lt;/code&gt;s is undefined and all &lt;code&gt;InfoTuple&lt;/code&gt;s are not mandatory. The &lt;code&gt;InfoTuple&lt;/code&gt;s part of the result can be changed without prior notice.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a424f07125a5351756bef9206873c14f5a6353a0" translate="yes" xml:space="preserve">
          <source>The order of the identifier types implies the hierarchy of the CPU topology. The valid orders are as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ef0543efe4d20b5865e3801acad36673d50a7e1" translate="yes" xml:space="preserve">
          <source>The order of the instructions is important.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40a9e5e0989674c7605430c6223ced2839090722" translate="yes" xml:space="preserve">
          <source>The order within an request is undefined and variables are not processed in a defined order. Do not assume that the first variable in the PDU will be processed before the second, even if the agent processes variables in this order. It cannot even be assumed that requests belonging to different sub-agents have any order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d9c8867ac57c93dfa1e9dd7ececb7cee20d1616" translate="yes" xml:space="preserve">
          <source>The ordinal for the current wrap log file in the range &lt;code&gt;1..MaxNoFiles&lt;/code&gt;, where &lt;code&gt;MaxNoFiles&lt;/code&gt; is specified by the &lt;code&gt;open/1&lt;/code&gt; option &lt;code&gt;size&lt;/code&gt; or set by &lt;code&gt;change_size/2&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6550278cb65a35db070f10d5936d5bb981ed919" translate="yes" xml:space="preserve">
          <source>The original &lt;code&gt;&lt;a href=&quot;#record-sctp_sndrcvinfo&quot;&gt;#sctp_sndrcvinfo{}&lt;/a&gt;&lt;/code&gt; record used in the failed &lt;code&gt;&lt;a href=&quot;#send-3&quot;&gt;send/*.&lt;/a&gt;&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="970df94b5a2d0508f33375517efeb60800ec3879" translate="yes" xml:space="preserve">
          <source>The original I/O protocol was simple and flexible. Demands for memory efficiency and execution time efficiency have triggered extensions to the protocol over the years, making the protocol larger and somewhat less easy to implement than the original. It can certainly be argued that the current protocol is too complex, but this section describes how it looks today, not how it should have looked.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f3737702a282f6801504751b80a23982a8e7770" translate="yes" xml:space="preserve">
          <source>The original balance condition &lt;strong&gt;h(T) &amp;lt;= ceil(c * log(|T|))&lt;/strong&gt; has been changed to the similar (but not quite equivalent) condition &lt;strong&gt;2 ^ h(T) &amp;lt;= |T| ^ c&lt;/strong&gt;. This should also be OK.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c191efd6920f25c3ba576f5b703e200e55bf2d5" translate="yes" xml:space="preserve">
          <source>The original implementation is mostly done by Scott Lystiger Fritchie as an Open Source Contribution and it should be viewed as such even though the source for dynamic tracing as well as this module is included in the main distribution. However, the ability to use dynamic tracing of the virtual machine is a very valuable contribution which OTP has every intention to maintain as a tool for the developer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1fb9c163b9ae8bc176015b798d7f0fe518b0cc1e" translate="yes" xml:space="preserve">
          <source>The original problem was to parse the grammar &lt;code&gt;(a | b) &amp;amp; (c | d)&lt;/code&gt;. The following code addresses this problem:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd881abf9ded0ff52d6c0c5cc6411dc02ab57f19" translate="yes" xml:space="preserve">
          <source>The originating module for a log event is only detected if the key &lt;code&gt;mfa&lt;/code&gt; exists in the metadata, and is associated with &lt;code&gt;{Module, Function, Arity}&lt;/code&gt;. When log macros are used, this association is automatically added to all log events. If an API function is called directly, without using a macro, the logging client must explicitly add this information if module levels shall have any effect.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a90fb6c08256a161c6eb483a2634b3ee24142c2" translate="yes" xml:space="preserve">
          <source>The originating user will wait for a reply or a timeout (defined by the request_timer). When it receives the reply this will optionally be acknowledged (regulated by auto_ack), and forwarded to the user. If an interim pending reply is received, the long_request_timer will be used instead of the usual request_timer, in order to enable avoidance of spurious re-sends of the request.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e92f5e32fcae91a4c9f4be9a317837d1de0ba2b" translate="yes" xml:space="preserve">
          <source>The other POSIX classes are unchanged, and match only characters with code points less than 128.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1b939845b7eda3d69e2e492e608d1e0b328d6c2" translate="yes" xml:space="preserve">
          <source>The other backtracking verbs are not treated specially if they appear in a positive assertion. In particular, (*THEN) skips to the next alternative in the innermost enclosing group that has alternations, regardless if this is within the assertion.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="500a74c2c6e51cd76905327b832ede2fe0521759" translate="yes" xml:space="preserve">
          <source>The other callback functions of &lt;code&gt;ch3&lt;/code&gt; must also be modified and perhaps a new interface function must be added, but this is not shown here.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1666602d3dd9e1b07910e384ad36de2d7fa0e9b" translate="yes" xml:space="preserve">
          <source>The other keys are ignored by &lt;code&gt;systools&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff87693daa403b15e56f02488339c0b3e4fa0a09" translate="yes" xml:space="preserve">
          <source>The other time stamps look as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d61abb80ef251301a72eea2a6b5eddae542b20ef" translate="yes" xml:space="preserve">
          <source>The output file &lt;code&gt;OutFile&lt;/code&gt; defaults to &lt;code&gt;Module.COVER.out&lt;/code&gt;, or &lt;code&gt;Module.COVER.html&lt;/code&gt; if the option &lt;code&gt;html&lt;/code&gt; was used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58ca31dbd1427ec5eab0714fa958680db4f60d0e" translate="yes" xml:space="preserve">
          <source>The output file contains Erlang source code for a parser module with module name equal to the &lt;code&gt;Parserfile&lt;/code&gt; parameter. After compilation, the parser can be called as follows (the module name is assumed to be &lt;code&gt;myparser&lt;/code&gt;):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="950bb6bb3590d1b255219966cda8abbac6d08f2f" translate="yes" xml:space="preserve">
          <source>The output files in this case get their names from the configuration file. If the configuration file is named &lt;code&gt;SetOfFiles.set.asn&lt;/code&gt;, the names of the output files are &lt;code&gt;SetOfFiles.hrl, SetOfFiles.erl, and SetOfFiles.asn1db&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6bb85e310428587626e30c116127a2422cb890a6" translate="yes" xml:space="preserve">
          <source>The output format is the same for all log events.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ed44c5ce1be01aac830a9b9d364b5bda8cb5f89" translate="yes" xml:space="preserve">
          <source>The output from Erlang Top is as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4375455178eca4e09ac1ea27af2822d564dd76b8" translate="yes" xml:space="preserve">
          <source>The output is a new file which is called &lt;code&gt;&amp;lt;mibname&amp;gt;.bin&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf16c507f23262a645872ad8bd5824124e5cfbee" translate="yes" xml:space="preserve">
          <source>The output is not to a file, but instead as a tuple &lt;code&gt;{FileName, binary()}&lt;/code&gt;. The binary is a full zip archive with header and can be extracted with, for example, &lt;code&gt;&lt;a href=&quot;#unzip-2&quot;&gt;unzip/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8d74c93a5b988198b9814a0f75a0ef9857da6e1" translate="yes" xml:space="preserve">
          <source>The output mechanisms are similar to the input. The &lt;code&gt;do_send&lt;/code&gt; routine is as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3eeb56a012bbd124b84f163ce270cf01c80c63bc" translate="yes" xml:space="preserve">
          <source>The output of the Erlang shell is discarded.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9c10e1f5cf0633868a0d6acdff9b23bdac7f561" translate="yes" xml:space="preserve">
          <source>The output produced by this function is a directory structure with the following structure:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="674403e3c388ef76a5e40cb3d72afaed1e950c87" translate="yes" xml:space="preserve">
          <source>The overall format of the term format is as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38835811defd1f6c34454d9d8396ca9e3e5af5d1" translate="yes" xml:space="preserve">
          <source>The overall size of data generated by &lt;code&gt;ttb&lt;/code&gt; can be greater than the wrap specification suggests. If a traced node restarts and autoresume is enabled, the old wrap log is always stored and a new one is created.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61cb6b8dd505955f977238c607e61cb7a82df0c8" translate="yes" xml:space="preserve">
          <source>The overall structure is shown in the following figure:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42d3d3de02c6a33e51e88647ce88261f5af1cf9c" translate="yes" xml:space="preserve">
          <source>The owner process can read and write to the table. Other processes can only read the table. This is the default setting for the access rights.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="089e146f1ffd790b907f38b914bb227184826d25" translate="yes" xml:space="preserve">
          <source>The palindrome-matching patterns above work only if the subject string does not start with a palindrome that is shorter than the entire string. For example, although &quot;abcba&quot; is correctly matched, if the subject is &quot;ababa&quot;, PCRE finds palindrome &quot;aba&quot; at the start, and then fails at top level, as the end of the string does not follow. Once again, it cannot jump back into the recursion to try other alternatives, so the entire match fails.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16b533f17b54668ffb1295b9bb8d4f9eb100b70f" translate="yes" xml:space="preserve">
          <source>The paragraphs are per default sorted in decreasing order of the ACC column for the marked function. The calling list and called list within one paragraph are also per default sorted in decreasing order of their ACC column.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5d4d2b62e1143e2dd17a07c3bb206ef9be5f7b2" translate="yes" xml:space="preserve">
          <source>The parameter &lt;code&gt;Echo&lt;/code&gt; guides the client about need to hide the password.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5cfbf68425808c36b1647fe7633ef469ae247239" translate="yes" xml:space="preserve">
          <source>The parameter &lt;code&gt;Receiver&lt;/code&gt; specifies where information about delivery of Inform-Requests should be sent. The agent sends Inform-Requests and waits for acknowledgments from the managers. &lt;code&gt;Receiver&lt;/code&gt; can have three values:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b93a8824964c3c68da73bbc8d10931f15f14a1ad" translate="yes" xml:space="preserve">
          <source>The parameter is ignored on platforms that are known to not be posix compatible (Windows and SunOS).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2e3af558ccfd68eba22bfa2a8b643ad678f8a28" translate="yes" xml:space="preserve">
          <source>The parameters &lt;code&gt;lines&lt;/code&gt;, &lt;code&gt;interval&lt;/code&gt;, &lt;code&gt;accumulate&lt;/code&gt;, and &lt;code&gt;sort&lt;/code&gt; can be changed during runtime with function &lt;code&gt;&lt;a href=&quot;etop#config-2&quot;&gt;etop:config/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8e6a51df5790dddef932d3398c6395529808020" translate="yes" xml:space="preserve">
          <source>The parameters are as described in &lt;code&gt;&lt;a href=&quot;#connect-5&quot;&gt;connect/*&lt;/a&gt;&lt;/code&gt;, except the &lt;code&gt;Timeout&lt;/code&gt; value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ce98213439a608e155e2aca750dfccce5c0b98e" translate="yes" xml:space="preserve">
          <source>The parameters of this function cannot be properly checked by the runtime system when executed by arbitrary threads. This can cause the function not to fail when it should.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ec665272ce04d7ab2f0ef6b068d9c3325cbd4bf" translate="yes" xml:space="preserve">
          <source>The parameters to &lt;code&gt;et:trace_me/5&lt;/code&gt; are the same as to &lt;code&gt;&lt;a href=&quot;#report_event&quot;&gt;et_collector:report_event/6&lt;/a&gt;&lt;/code&gt; in the previous chapter. The big difference between the two is in the semantics of the two functions. The second actually reports an &lt;code&gt;Event&lt;/code&gt; to the &lt;code&gt;Collector&lt;/code&gt; while the first does nothing, it just returns the atom &lt;code&gt;hopefully_traced&lt;/code&gt;. In order to make the parameters to &lt;code&gt;et:trace_me/5&lt;/code&gt; turn up in the &lt;code&gt;Collector&lt;/code&gt;, tracing of that function must be activated and the &lt;code&gt;Collector&lt;/code&gt; must be registered as a &lt;code&gt;Tracer&lt;/code&gt; of the &lt;code&gt;Raw Trace Data&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6476df9bd7becd5f1615533b733c1dab82d38f7" translate="yes" xml:space="preserve">
          <source>The parent of the process, that is, the process that executed &lt;code&gt;spawn&lt;/code&gt; or &lt;code&gt;spawn_link&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ee187ad5dff135b81bffe6ade6896261862f011" translate="yes" xml:space="preserve">
          <source>The parse result will be:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="908e2b3e43d5891b77738e237f36e159be4612ea" translate="yes" xml:space="preserve">
          <source>The parse transform is implemented in the module &lt;code&gt;ms_transform&lt;/code&gt; and the source &lt;strong&gt;must&lt;/strong&gt; include the file &lt;code&gt;ms_transform.hrl&lt;/code&gt; in STDLIB for this pseudo function to work. Failing to include the hrl file in the source will result in a runtime error, not a compile time ditto. The include file is easiest included by adding the line &lt;code&gt;-include_lib(&quot;stdlib/include/ms_transform.hrl&quot;).&lt;/code&gt; to the source file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a0fcc18541768fed9656f58cddeaa15df804db5" translate="yes" xml:space="preserve">
          <source>The parse transform is provided in the &lt;code&gt;ms_transform&lt;/code&gt; module and the source &lt;strong&gt;must&lt;/strong&gt; include file &lt;code&gt;ms_transform.hrl&lt;/code&gt; in STDLIB for this pseudo function to work. Failing to include the hrl file in the source results in a runtime error, not a compile time error. The include file is easiest included by adding line &lt;code&gt;-include_lib(&quot;stdlib/include/ms_transform.hrl&quot;).&lt;/code&gt; to the source file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa633312a20d20d1705e931b8f39b80fb7e1696b" translate="yes" xml:space="preserve">
          <source>The parser can be tested as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d631ad0e789906de6a0dbe0f9ecc3c2c43edfa6d" translate="yes" xml:space="preserve">
          <source>The parsing failed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c723b00d013bcc979e9e3335bbd7a9da3fabcff7" translate="yes" xml:space="preserve">
          <source>The parsing was successful.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a49afee373329c5d676f06380eda3a2c7220be60" translate="yes" xml:space="preserve">
          <source>The parsing was successful. &lt;code&gt;AbsForm&lt;/code&gt; is the abstract form of the parsed form.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb6f7d761bbc4ec8ae3eb1becad08674a67adfed" translate="yes" xml:space="preserve">
          <source>The parsing was successful. &lt;code&gt;ExprList&lt;/code&gt; is a list of the abstract forms of the parsed expressions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92efbe38030d8e57be00bf5943de97bce61a93f6" translate="yes" xml:space="preserve">
          <source>The parsing was successful. &lt;code&gt;Term&lt;/code&gt; is the Erlang term corresponding to the token list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd9391eec0e6a1677450d11b0522f2da3f205730" translate="yes" xml:space="preserve">
          <source>The parts of &lt;code&gt;Pattern&lt;/code&gt; found in &lt;code&gt;Subject&lt;/code&gt; are not included in the result.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b76c5acf9e48a823e1ce8da1feab2e91ccd0b05" translate="yes" xml:space="preserve">
          <source>The patched applications are appended to the list of installed applications. Take a look at &lt;code&gt;&amp;lt;InstallDir&amp;gt;/releases/OTP-REL/installed_application_versions&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de8aec81a8619523440bf735eef84868583ed273" translate="yes" xml:space="preserve">
          <source>The path &lt;code&gt;Path&lt;/code&gt; (file or directory) does not exist at the master node &lt;code&gt;Master&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9efed4ade7b3864058f4bc8126d22473cb9ba0df" translate="yes" xml:space="preserve">
          <source>The path &lt;code&gt;Path&lt;/code&gt; (file or directory) does not exist.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00b2a07ab726e41d953579382af2a4c7a39f62f9" translate="yes" xml:space="preserve">
          <source>The path is not relative.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="302ff460ef043ede1fb15ed8b241c07bf3d0af3a" translate="yes" xml:space="preserve">
          <source>The path is relative to the top-level log directory if &lt;code&gt;ct:run:testspec(TestSpec)&lt;/code&gt; executes the test.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed296092ce0cab58b679cc1f44b7eff89a2c0d6a" translate="yes" xml:space="preserve">
          <source>The path location is intended for persistent configuration files.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df84aee71581027a14aa1d0460434f6a1cd2bc48" translate="yes" xml:space="preserve">
          <source>The path location is intended for persistent data files.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f41c20a183605aaa02c5a050804cb5f85891fc8" translate="yes" xml:space="preserve">
          <source>The path location is intended for transient data files on a local machine.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24ac97a8853d3eb3c0e82e90ec7ff8a99f90d2b1" translate="yes" xml:space="preserve">
          <source>The path location is intended for transient log files on a local machine.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fabb1e75bc1356932aba105b5820e5c24d189a02" translate="yes" xml:space="preserve">
          <source>The path name is relative to the current working directory on a specified volume, or it is a specific file on the current working volume.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="329f4e1f9e1361ccb26d9048eedbf79a0fc09f6b" translate="yes" xml:space="preserve">
          <source>The path name is relative to the current working directory on the current volume.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="698e20309829f4ab61d3971bbd487b1bdda9857f" translate="yes" xml:space="preserve">
          <source>The path name refers to a specific file on a specific volume.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c82c62dcbb94f72c91af63848dc5e39d27171439" translate="yes" xml:space="preserve">
          <source>The path to the directory where the distribution modules reside must be known at boot. This can be achieved either by specifying &lt;code&gt;-pa &amp;lt;path&amp;gt;&lt;/code&gt; on the command line or by building a boot script containing the applications used for your distribution protocol. (In the &lt;code&gt;uds_dist&lt;/code&gt; protocol, only the &lt;code&gt;uds_dist&lt;/code&gt; application needs to be added to the script.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="698dcce20dfe46d840644fbd320bb371ef1dcc60" translate="yes" xml:space="preserve">
          <source>The paths could easily be changed by options: &lt;code&gt;&lt;a href=&quot;#type-user_dir_common_option&quot;&gt;user_dir&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#type-system_dir_daemon_option&quot;&gt;system_dir&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e863090f08be4587b861f731a6d55a6ce32f762" translate="yes" xml:space="preserve">
          <source>The pattern is forced to be &quot;anchored&quot;, that is, it is constrained to match only at the first matching point in the string that is searched (the &quot;subject string&quot;). This effect can also be achieved by appropriate constructs in the pattern itself.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56b998a50f666939e90060048d8bd7137cbf14f7" translate="yes" xml:space="preserve">
          <source>The pattern is here within parentheses so that the recursion refers to them instead of the whole pattern.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0cc98b553afe0b60b841f7b9f1c109087f0da93e" translate="yes" xml:space="preserve">
          <source>The pattern provided to the functions must be a valid record, and the first element of the provided tuple must be the &lt;code&gt;record_name&lt;/code&gt; of the table. The special element &lt;code&gt;'_'&lt;/code&gt; matches any data structure in Erlang (also known as an Erlang term). The special elements &lt;code&gt;'$&amp;lt;number&amp;gt;'&lt;/code&gt; behave as Erlang variables, that is, they match anything, bind the first occurrence, and match the coming occurrences of that variable against the bound value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c0886b7cf654b6b834bf58578aecb88e02ed55d" translate="yes" xml:space="preserve">
          <source>The pattern(s) must be matched multiple times. If &lt;code&gt;N&lt;/code&gt; is speciified, the pattern(s) are matched &lt;code&gt;N&lt;/code&gt; times, and the function returns &lt;code&gt;HaltReason = done&lt;/code&gt;. This option can be interrupted by one or more &lt;code&gt;HaltPatterns&lt;/code&gt;. &lt;code&gt;MatchList&lt;/code&gt; is always returned, that is, a list of &lt;code&gt;Match&lt;/code&gt; instead of only one &lt;code&gt;Match&lt;/code&gt;. Also &lt;code&gt;HaltReason&lt;/code&gt; is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="268d1764864d982e7120f74e74c9fd6647497d91" translate="yes" xml:space="preserve">
          <source>The patterns in the clause head can be successfully matched against the given arguments.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8cf98c378247e817abc5f228e3f59d4dd5e3a6c9" translate="yes" xml:space="preserve">
          <source>The peer certificate is returned as a DER-encoded binary. The certificate can be decoded with &lt;code&gt;public_key:pkix_decode_cert/2&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c33a7248317e3e4d5645db402b82fdf9bfcfb31" translate="yes" xml:space="preserve">
          <source>The performance degradation for a system that is enabled for sequential tracing is negligible as long as no tracing is activated. When tracing is activated, there is an extra cost for each traced message, but all other messages are unaffected.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8cbfc9b98e9849da11c2e28dbb992bbe4ea2486" translate="yes" xml:space="preserve">
          <source>The permissible options are the same as for &lt;code&gt;&lt;a href=&quot;#run-3&quot;&gt;run/3&lt;/a&gt;&lt;/code&gt;, except that option&lt;code&gt;capture&lt;/code&gt; is not allowed. Instead a &lt;code&gt;{return, ReturnType}&lt;/code&gt; is present. The default return type is &lt;code&gt;iodata&lt;/code&gt;, constructed in a way to minimize copying. The &lt;code&gt;iodata&lt;/code&gt; result can be used directly in many I/O operations. If a flat &lt;code&gt;list()&lt;/code&gt; is desired, specify &lt;code&gt;{return, list}&lt;/code&gt;. If a binary is desired, specify &lt;code&gt;{return, binary}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6319938072e5f5bf04da6b368d9c42dc62f6e008" translate="yes" xml:space="preserve">
          <source>The pid</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f16145e2d18587f6b89bcea6a5d1f5d05a57b75" translate="yes" xml:space="preserve">
          <source>The pid of the heir of the table, or &lt;code&gt;none&lt;/code&gt; if no heir is set.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bad35c800b2a5b5e2bf66d0ff3f487490a14c90c" translate="yes" xml:space="preserve">
          <source>The pid of the owner of the table.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb05b4cc61bcd44e5954e6a679ba99c62203c819" translate="yes" xml:space="preserve">
          <source>The pid of the receiving process. The pid is to refer to a process on the local node.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="826db1b9e643364ce8e57b8ab6ccf5be81118acd" translate="yes" xml:space="preserve">
          <source>The point of sending data as a list header, is to facilitate matching on the data received.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0dac0c856b6bd486d6d80e0c5f670c5e59ababc" translate="yes" xml:space="preserve">
          <source>The polling feature is controlled by the configuration values &lt;code&gt;poll_limit&lt;/code&gt; and &lt;code&gt;poll_interval&lt;/code&gt; and is by default disabled. This means that the function immediately returns all complete strings received and saves a remaining non-terminated string for a later &lt;code&gt;get_data&lt;/code&gt; call.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d6f13f29266bcb18f4282624a4022662ca669ae" translate="yes" xml:space="preserve">
          <source>The pool of nodes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f5b4ca13c9ab872bb6daaa4dfbebefbf017cc04" translate="yes" xml:space="preserve">
          <source>The port ID of the receiving port. The port ID is to refer to a port on the local node.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ddfe98846c7da18189a1df423baa1aaca1defcc" translate="yes" xml:space="preserve">
          <source>The port can only be used for input.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e788605ff88677668be04c2f0461ee176fc8414" translate="yes" xml:space="preserve">
          <source>The port can only be used for output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e5668c5527d21298d324cca59ff3c8059f2e94f" translate="yes" xml:space="preserve">
          <source>The port controlling communication with the remote node.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8add36b162d7f85fd7335d4a43fd4c5d3cb6a19" translate="yes" xml:space="preserve">
          <source>The port does &lt;strong&gt;not&lt;/strong&gt; reply with &lt;code&gt;{Port,connected}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1e2ddef440aa65eb46a9df15d1fd89471e5e732" translate="yes" xml:space="preserve">
          <source>The port handle of the port (driver instance) creating the new port.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="405194befe843be0a71985802205fb7d1880fe5a" translate="yes" xml:space="preserve">
          <source>The port handle of the port (driver instance) doing the acknowledgment.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95eb949bda5093de827dd6c5e24f46c8d5c5fb5e" translate="yes" xml:space="preserve">
          <source>The port identifier for the port that this structure corresponds to. It is needed for most &lt;code&gt;driver_XXX&lt;/code&gt; calls from the driver back to the emulator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66cfb7457c3ee07be7aa92ceb66e42b6845d40bb" translate="yes" xml:space="preserve">
          <source>The port identifier of the port that is currently executed by the scheduler.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d482aa64430d6219ae86b9b4af57ffcff9757f8" translate="yes" xml:space="preserve">
          <source>The port identifier.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56b2c676adbaff1c1e1e0d421f4b603ad3e33a68" translate="yes" xml:space="preserve">
          <source>The port is created using the BIF &lt;code&gt;open_port/2&lt;/code&gt; with &lt;code&gt;{spawn,ExtPrg}&lt;/code&gt; as the first argument. The string &lt;code&gt;ExtPrg&lt;/code&gt; is the name of the external program, including any command line arguments. The second argument is a list of options, in this case only &lt;code&gt;{packet,2}&lt;/code&gt;. This option says that a 2 byte length indicator is to be used to simplify the communication between C and Erlang. The Erlang port automatically adds the length indicator, but this must be done explicitly in the external C program.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d515078a6d0f1b9f22ce1b5d7e5c099ff2874fa5" translate="yes" xml:space="preserve">
          <source>The port is not closed at the end of the file and does not produce an exit signal. Instead, it remains open and a &lt;code&gt;{Port, eof}&lt;/code&gt; message is sent to the process holding the port.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a456a28936847225b9929c122d159c3ef3485f0" translate="yes" xml:space="preserve">
          <source>The port is then created using the BIF &lt;code&gt;open_port/2&lt;/code&gt;, with the tuple &lt;code&gt;{spawn, DriverName}&lt;/code&gt; as the first argument. The string &lt;code&gt;SharedLib&lt;/code&gt; is the name of the port driver. The second argument is a list of options, none in this case:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9fcfec977ea3c1e018c7d81f66fbf088c0f1d7b" translate="yes" xml:space="preserve">
          <source>The port message queue is set into a busy state when the amount of command data queued on the message queue reaches the &lt;code&gt;high&lt;/code&gt; limit. The port message queue is set into a not busy state when the amount of command data queued on the message queue falls below the &lt;code&gt;low&lt;/code&gt; limit. Command data is in this context data passed to the port using either &lt;code&gt;Port ! {Owner, {command, Data}}&lt;/code&gt; or &lt;code&gt;port_command/[2,3]&lt;/code&gt;. Notice that these limits only concerns command data that have not yet reached the port. The &lt;code&gt;&lt;a href=&quot;#set_busy_port&quot;&gt;busy port&lt;/a&gt;&lt;/code&gt; feature can be used for data that has reached the port.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20086dbd568a4d1794aae351e6d4783a1bb4f27a" translate="yes" xml:space="preserve">
          <source>The port name of the new port. You usually want to use the same port name as the driver name (&lt;code&gt;&lt;a href=&quot;driver_entry#driver_name&quot;&gt;driver_name&lt;/a&gt;&lt;/code&gt; field of the &lt;code&gt;&lt;a href=&quot;driver_entry&quot;&gt;driver_entry&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0f47e8645d1b1ba4480dbc54c2d1360eb57b767" translate="yes" xml:space="preserve">
          <source>The port number on which the node accept connection requests.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14a2d34036c08fb128310c5494cd65660394733e" translate="yes" xml:space="preserve">
          <source>The port owner &lt;code&gt;Pid&lt;/code&gt; can communicate with the port &lt;code&gt;Port&lt;/code&gt; by sending and receiving messages. (In fact, any process can send the messages to the port, but the port owner must be identified in the message).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53c673fa38fb63daad8279f5786d12a340c3879a" translate="yes" xml:space="preserve">
          <source>The port that the HTTP server listen to. If zero is specified as port, an arbitrary available port is picked and function &lt;code&gt;httpd:info/2&lt;/code&gt; can be used to determine which port was picked.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="303cb397a1becf617c4be6350ca5fd61cb80f620" translate="yes" xml:space="preserve">
          <source>The ports implemented by this driver operate in two major modes, named &lt;code&gt;command&lt;/code&gt; and &lt;code&gt;data&lt;/code&gt;. In &lt;code&gt;command&lt;/code&gt; mode, only passive reading and writing (like &lt;code&gt;gen_tcp:recv&lt;/code&gt;/&lt;code&gt;gen_tcp:send&lt;/code&gt;) can be done. The port is in this mode during the distribution handshake. When the connection is up, the port is switched to &lt;code&gt;data&lt;/code&gt; mode and all data is immediately read and passed further to the Erlang emulator. In &lt;code&gt;data&lt;/code&gt; mode, no data arriving to &lt;code&gt;uds_command&lt;/code&gt; is interpreted, only packaged and sent out on the socket. The &lt;code&gt;uds_control&lt;/code&gt; callback does the switching between those two modes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="479cb4b39a01954743d9faba125677bc9ccf6bba" translate="yes" xml:space="preserve">
          <source>The possessive quantifier syntax is an extension to the Perl 5.8 syntax. Jeffrey Friedl originated the idea (and the name) in the first edition of his book. Mike McCloskey liked it, so implemented it when he built the Sun Java package, and PCRE copied it from there. It ultimately found its way into Perl at release 5.10.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3636e381fdb27bd130356d04a1054555e03c668b" translate="yes" xml:space="preserve">
          <source>The possible commands are &lt;code&gt;call&lt;/code&gt;, &lt;code&gt;close&lt;/code&gt;, &lt;code&gt;command&lt;/code&gt;, &lt;code&gt;connect&lt;/code&gt;, &lt;code&gt;control&lt;/code&gt;, &lt;code&gt;flush&lt;/code&gt;, &lt;code&gt;info&lt;/code&gt;, &lt;code&gt;link&lt;/code&gt;, &lt;code&gt;open&lt;/code&gt;, and &lt;code&gt;unlink&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed31e825086e99a9550da0520a157f768b47fed9" translate="yes" xml:space="preserve">
          <source>The possible error reasons and the corresponding diagnostic strings returned by &lt;code&gt;formaterror/1&lt;/code&gt; are as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c76008544af718ead9afe49e6a29a494608280a0" translate="yes" xml:space="preserve">
          <source>The possible modifications are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f67dca2d282eb65ee7030798081655de26212d8e" translate="yes" xml:space="preserve">
          <source>The possible monitor messages to expect are the same as when using option &lt;code&gt;unloaded&lt;/code&gt; to function &lt;code&gt;&lt;a href=&quot;#monitor-2&quot;&gt;monitor/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3402737cdfb2af426a71f1abc6fcfd8e890b8dfe" translate="yes" xml:space="preserve">
          <source>The possible path validation errors are given on form &lt;code&gt;{bad_cert, Reason}&lt;/code&gt; where &lt;code&gt;Reason&lt;/code&gt; is:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a941da52cdacf4f18dab68834ca9a0b9b380d76" translate="yes" xml:space="preserve">
          <source>The possible values for &lt;code&gt;SeqTraceFlag&lt;/code&gt; are available in &lt;code&gt;seq_trace&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8463b8102b0a232e391b76c31a7662065c9a35d8" translate="yes" xml:space="preserve">
          <source>The possible values of &lt;code&gt;Reason&lt;/code&gt; returned when an error occurs are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9e7ad200abbd6c26753c3e135059d909819a0d3" translate="yes" xml:space="preserve">
          <source>The power of regular expressions comes from the ability to include alternatives and repetitions in the pattern. These are encoded in the pattern by the use of &lt;strong&gt;metacharacters&lt;/strong&gt;, which do not stand for themselves but instead are interpreted in some special way.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b75dfccef8bf15d11af3ec419501f78711191fcb" translate="yes" xml:space="preserve">
          <source>The pre (post) functions for different tables are evaluated in unspecified order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef1f9e226e4b6cb5e965d6e8bd26fbd505355d6e" translate="yes" xml:space="preserve">
          <source>The precise effect of \cx on ASCII characters is as follows: if x is a lowercase letter, it is converted to upper case. Then bit 6 of the character (hex 40) is inverted. Thus \cA to \cZ become hex 01 to hex 1A (A is 41, Z is 5A), but \c{ becomes hex 3B ({ is 7B), and \c; becomes hex 7B (; is 3B). If the data item (byte or 16-bit value) following \c has a value &amp;gt; 127, a compile-time error occurs. This locks out non-ASCII characters in all modes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9ec8174f3c0fbb4a103d0721bac0a4593311c47" translate="yes" xml:space="preserve">
          <source>The precision field selects base, for example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe3ebba2ea20548fa4e1d8023343d98509aee9ee" translate="yes" xml:space="preserve">
          <source>The preferred way to do driver code replacement is to let &lt;strong&gt;one single process&lt;/strong&gt; keep track of the driver. When the process starts, the driver is loaded. When replacement is required, the driver is reloaded. Unload is probably never done, or done when the process exits. If more than one &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;user&lt;/a&gt;&lt;/code&gt; has a driver loaded when code replacement is demanded, the replacement cannot occur until the last &quot;other&quot; &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;user&lt;/a&gt;&lt;/code&gt; has unloaded the driver.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="733bbb9127b2be9265fae567e547e0cecf362a58" translate="yes" xml:space="preserve">
          <source>The prefix can be a possibly deep list of characters or an atom. Example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dba1348d69926c90183adbcb04fa0974199d7975" translate="yes" xml:space="preserve">
          <source>The pretty printer &lt;code&gt;&lt;a href=&quot;erl_prettypr&quot;&gt;erl_prettypr&lt;/a&gt;&lt;/code&gt; is implemented on top of the library module &lt;code&gt;&lt;a href=&quot;prettypr&quot;&gt;prettypr&lt;/a&gt;&lt;/code&gt;: this is a powerful and flexible generic pretty printing library, which is also distributed separately.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55f286a009d576b38e8e85ec7239710e5fc14790" translate="yes" xml:space="preserve">
          <source>The previous &lt;code&gt;install/2&lt;/code&gt; procedure differs somewhat from that of the ordinary &lt;code&gt;Install&lt;/code&gt; shell script. In fact, &lt;code&gt;create/1&lt;/code&gt; makes the release package as complete as possible, and leave to the &lt;code&gt;install/2&lt;/code&gt; procedure to finish by only considering location-dependent files.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3fa312f724214bcc1cd80a76985d7a69b991d85b" translate="yes" xml:space="preserve">
          <source>The previous example can be simplified by using the &lt;code&gt;&lt;a href=&quot;erl_format&quot;&gt;erl_format&lt;/a&gt;&lt;/code&gt; module to create an Erlang term:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b46669f7567ee67b00ce88c3207ede01b10c7f03" translate="yes" xml:space="preserve">
          <source>The previous example of state time-outs only work if the state machine stays in the same state during the time-out time. And event time-outs only work if no disturbing unrelated events occur.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3459bae934771664d1dcbf0310cab83038c641d" translate="yes" xml:space="preserve">
          <source>The previous list comprehension expression contains a number of syntactical elements:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84ec95b9934bf0009efc315d92c2afbbfc37fa92" translate="yes" xml:space="preserve">
          <source>The previous sections describe how to get started with &lt;code&gt;Mnesia&lt;/code&gt; and how to build a &lt;code&gt;Mnesia&lt;/code&gt; database. This section describes the more advanced features available when building a distributed, fault-tolerant &lt;code&gt;Mnesia&lt;/code&gt; database. The following topics are included:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb3f030405dcf222bd64e25ad1c880d277340fe4" translate="yes" xml:space="preserve">
          <source>The previous write and read example can be extended with encryption and decryption as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57796ceed90f470b2305125d019084fa629b2ede" translate="yes" xml:space="preserve">
          <source>The primary Logger configuration is a map with the following keys:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff1cf20a564ba3e279a69440c710bf978e373ae2" translate="yes" xml:space="preserve">
          <source>The primary log level can be overridden by a log level configured per module. This is to, for instance, allow more verbose logging from a specific part of the system.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1ae98d9ae06c45e41cf5ff9b762c21068711a9b" translate="yes" xml:space="preserve">
          <source>The primary use case for this option is to bind sockets into &lt;code&gt;&lt;a href=&quot;http://www.kernel.org/doc/Documentation/networking/vrf.txt&quot;&gt;Linux VRF instances&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11e6f9bf4b0c0ac23f2c434d8c992babdb65c4e0" translate="yes" xml:space="preserve">
          <source>The primitive Erlang boot sequence was terminated, most probably because the boot script has errors or cannot be read. This is usually a configuration error; the system can have been started with a faulty &lt;code&gt;-boot&lt;/code&gt; parameter or with a boot script from the wrong OTP version.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f4b4edb0f46f3c079a1f4a56d0fa6ad3463effc" translate="yes" xml:space="preserve">
          <source>The printout consists of one paragraph per called function. The function &lt;strong&gt;marked&lt;/strong&gt; with '%' is the one the paragraph concerns - &lt;code&gt;foo:create_file_slow/2&lt;/code&gt;. Above the marked function are the &lt;strong&gt;calling&lt;/strong&gt; functions - those that has called the marked, and below are those &lt;strong&gt;called&lt;/strong&gt; by the marked function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb0cc2d12f7673987ac78181af36308d13b093fb" translate="yes" xml:space="preserve">
          <source>The printout continues:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88eb7754fad0268a64d4c07aa796eac3d3d2ab89" translate="yes" xml:space="preserve">
          <source>The printout starts with:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45f91a7c53ea68084b88cb17f900ef0b40205e6b" translate="yes" xml:space="preserve">
          <source>The printout to parse is typically the result of a &lt;code&gt;select&lt;/code&gt; command in SQL. The returned &lt;code&gt;Table&lt;/code&gt; is a list of tuples, where each tuple is a row in the table.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="324a8be8e8a88abcf82aab2f92ee5692197fd525" translate="yes" xml:space="preserve">
          <source>The priority of the Erlang emulator. Default to the Windows default priority.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9484243e544c5f1274424b246682b09a4351581e" translate="yes" xml:space="preserve">
          <source>The private internet extensions OID name atoms and their corresponding value types are as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3578adaa26da6e601dfec21f2beb5043ca19f9a3" translate="yes" xml:space="preserve">
          <source>The private key contains the public key.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb7c14f7ed96915fedd1cf72c76ce0b4318ac44c" translate="yes" xml:space="preserve">
          <source>The problem is the clause with the variable &lt;code&gt;Int&lt;/code&gt;. As a variable can match anything, including the atoms &lt;code&gt;four&lt;/code&gt;, &lt;code&gt;five&lt;/code&gt;, and &lt;code&gt;six&lt;/code&gt;, which the following clauses also match, the compiler must generate suboptimal code that executes as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97101ea56c3365ae0f09e70bee55a9ade66266a3" translate="yes" xml:space="preserve">
          <source>The problem of &lt;strong id=&quot;topsort&quot;&gt;topological sorting&lt;/strong&gt; is to find a total ordering of S that is a superset of the partial ordering. A digraph G = (V, E) is equivalent to a relation E on V (we neglect that the version of directed graphs provided by the &lt;code&gt;digraph&lt;/code&gt; module allows multiple edges between vertices). If the digraph has no cycles of length two or more, the reflexive and transitive closure of E is a partial ordering.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6dc36bb1f0c67349dd2ad95f241625aa11fedd24" translate="yes" xml:space="preserve">
          <source>The procedure described uses either Cygwin, MSYS or MSYS2 as a build environment. You run the bash shell in Cygwin/MSYS/MSYS2 and use the gnu make/configure/autoconf etc to do the build. The emulator C-source code is, however, mostly compiled with Microsoft Visual C++&amp;trade;, producing a native Windows binary. This is the same procedure as we use to build the pre-built binaries. Why we use VC++ and not gcc is explained further in the FAQ section.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3defe5ccf8f073a7bfba94a853f4b3e04c4fd936" translate="yes" xml:space="preserve">
          <source>The procedure for installing an embedded system is the same as for an ordinary system (see Installation Guide), except for the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e1ec300b173f8914d2686b10b0da9ca7aa25ede" translate="yes" xml:space="preserve">
          <source>The process &quot;pong&quot; now does:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db27ebbde3aba8040f9a717035d37465555bb852" translate="yes" xml:space="preserve">
          <source>The process &lt;code&gt;&amp;lt;0.Item.0&amp;gt;&lt;/code&gt; is traced.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23867be26ea372bdca1cdb7f994ce5aa95efde29" translate="yes" xml:space="preserve">
          <source>The process &lt;code&gt;&amp;lt;X.Y.Z&amp;gt;&lt;/code&gt; is traced.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8981f50685978b00cd49a2baa1c8ac07d3e68007" translate="yes" xml:space="preserve">
          <source>The process &lt;code&gt;Pid&lt;/code&gt; must be alive, local, and not already the owner of the table. The calling process must be the table owner.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7ce97685440137bac537d3a5eb324dcf9c30fc8" translate="yes" xml:space="preserve">
          <source>The process ID of the Erlang process to become owner of the new port. This process will be linked to the new port. You usually want to use &lt;code&gt;driver_caller(port)&lt;/code&gt; as &lt;code&gt;owner_pid&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="069991f41691da930cb8b00055cd75415a3bfbb4" translate="yes" xml:space="preserve">
          <source>The process called &lt;code&gt;exit/1&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff2c0d20578ead716abbff96344be128bf1b9a3f" translate="yes" xml:space="preserve">
          <source>The process called &lt;code&gt;throw/1&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="181d7e73097c8d6559d2b5b87438e37ef9de3355" translate="yes" xml:space="preserve">
          <source>The process executing the call does not belong to any application.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f1ecb9f48b736f7cd2db1444bab09f031bc5fcb" translate="yes" xml:space="preserve">
          <source>The process has terminated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e60b1f056e03500b54fc847d023aec3ec8683ca" translate="yes" xml:space="preserve">
          <source>The process identified by &lt;code&gt;Pid&lt;/code&gt; does not execute old code for &lt;code&gt;Module&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="efbf96e7df8ac572e485b865c501336d859faf3c" translate="yes" xml:space="preserve">
          <source>The process identified by &lt;code&gt;Pid&lt;/code&gt; executes old code for &lt;code&gt;Module&lt;/code&gt;. That is, the current call of the process executes old code for this module, or the process has references to old code for this module, or the process contains funs that references old code for this module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8fe4451cfd96b4642a3cd1e82d934d848d394bb5" translate="yes" xml:space="preserve">
          <source>The process identified by &lt;code&gt;Pid&lt;/code&gt; has been garbage collected.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c11a4446151542c2c9c338884f572b30ec36ffc" translate="yes" xml:space="preserve">
          <source>The process identified by &lt;code&gt;Suspendee&lt;/code&gt; is suspended unless the calling process already is suspending &lt;code&gt;Suspendee&lt;/code&gt;. If &lt;code&gt;unless_suspending&lt;/code&gt; is combined with option &lt;code&gt;asynchronous&lt;/code&gt;, a suspend request is sent unless the calling process already is suspending &lt;code&gt;Suspendee&lt;/code&gt; or if a suspend request already has been sent and is in transit. If the calling process already is suspending &lt;code&gt;Suspendee&lt;/code&gt;, or if combined with option &lt;code&gt;asynchronous&lt;/code&gt; and a send request already is in transit, &lt;code&gt;false&lt;/code&gt; is returned and the suspend count on &lt;code&gt;Suspendee&lt;/code&gt; remains unchanged.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc6dbdee5963a4c4de105af29cdc7452461b900b" translate="yes" xml:space="preserve">
          <source>The process identifier for the process that owns the port.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82a4df785e628bbb31440878eae2c3ce1aa2f090" translate="yes" xml:space="preserve">
          <source>The process identifier of the controlling process for a connection.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1019f88201ff8eebe4c4c8f11ee6ecb8f045c63" translate="yes" xml:space="preserve">
          <source>The process identifier of the process that is currently executed by the scheduler. If there is such a process, this entry is followed by the &lt;strong&gt;State&lt;/strong&gt;, &lt;strong&gt;Internal State&lt;/strong&gt;, &lt;strong&gt;Program Counter&lt;/strong&gt;, and &lt;strong&gt;CP&lt;/strong&gt; of that same process. The entries are described in section &lt;code&gt;&lt;a href=&quot;#processes&quot;&gt;Process Information&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="deb011da943a6720eb915f7c73d873d81a032acd" translate="yes" xml:space="preserve">
          <source>The process identifier.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27fe3ed1814a1292249730be37daf32c06d0df69" translate="yes" xml:space="preserve">
          <source>The process information returned by this function may be used to locate and terminate remaining processes after tests have finished executing. The function would typically by called from Common Test Hook functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6bedca78a3506c8b135dc2b8bd0767845069ac2" translate="yes" xml:space="preserve">
          <source>The process is also set to trap exits, which enables detection of failure of the external program:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="667f772f31f497429c78d5ea973176a8eb647545" translate="yes" xml:space="preserve">
          <source>The process is awaken when a message is sent to it, and control resumes in &lt;code&gt;Module:Function&lt;/code&gt; with the arguments specified by &lt;code&gt;Args&lt;/code&gt; with the call stack emptied, meaning that the process terminates when that function returns. Thus &lt;code&gt;erlang:hibernate/3&lt;/code&gt; never returns to its caller.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ba834279970a7606bdcc555a88858fe5cdb6aca" translate="yes" xml:space="preserve">
          <source>The process is running.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bfc91c3fc885823bbc69fd5edf12fc9288324645" translate="yes" xml:space="preserve">
          <source>The process is stopped at a breakpoint.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e77677e6bacc9af8fae16fce0e3ff20590fece9" translate="yes" xml:space="preserve">
          <source>The process is suspended, either by the BIF &lt;code&gt;erlang:suspend_process/1&lt;/code&gt; or because it tries to write to a busy port.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec639777c6fbd39eddc16455128329cd62f77aa3" translate="yes" xml:space="preserve">
          <source>The process is to wait indefinitely for a matching message; this is the same as not using a timeout. This can be useful for timeout values that are calculated at runtime.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f83208c2a966f339873e15e8fdadbc8eaec4e600" translate="yes" xml:space="preserve">
          <source>The process is waiting in a &lt;code&gt;receive&lt;/code&gt; statement.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="490d1a02b4671d2f440059a33d6b5bf46ed39b4c" translate="yes" xml:space="preserve">
          <source>The process locks are sorted after its class like all other locks. It is convenient to look at specific processes and ports as classes. We can do this by swapping class and class identifiers with &lt;code&gt;lcnt:swap_pid_keys/0&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab71454c03a7a40960af21879aaea3b714e94712" translate="yes" xml:space="preserve">
          <source>The process of abstracting out the common features of a number of different programs is called &lt;strong&gt;procedural abstraction&lt;/strong&gt;. Procedural abstraction can be used to write several different functions that have a similar structure, but differ in some minor detail. This is done as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ead71597be31bdb70e88141c28f9f2a4406c239b" translate="yes" xml:space="preserve">
          <source>The process of handling an HTTP request involves several steps, such as:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73248bb9e604234911f321cbc273914ed901fdd0" translate="yes" xml:space="preserve">
          <source>The process or port that the trace belongs to.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f33ec46395f0f62c1d01a1ea2da5eba9a23d0892" translate="yes" xml:space="preserve">
          <source>The process or port with the corresponding registered name is traced. The process or port may be a remote process (on another Erlang node). The node must be added with the &lt;code&gt;&lt;a href=&quot;#n-1&quot;&gt;n/1&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#tracer-3&quot;&gt;tracer/3&lt;/a&gt;&lt;/code&gt; function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="797b5a91a8e60a806f3452dece6f7cd3883f0a36" translate="yes" xml:space="preserve">
          <source>The process performing the registration will be monitored. Which means that if that process should die, all agents registered by that user process will be unregistered. All outstanding requests will be canceled.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1fb0435cbc590f55163deae437b8266e597b2e46" translate="yes" xml:space="preserve">
          <source>The process priority of the emulator. Can be one of the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd66a4360cd6cbde0a0ee9091b32df8224b27834" translate="yes" xml:space="preserve">
          <source>The process then terminates with reason &lt;code&gt;Reason&lt;/code&gt; for &lt;code&gt;exit/1&lt;/code&gt; or &lt;code&gt;{Reason,Stack}&lt;/code&gt; for the others.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1fd3ae34693cf45eb0f6d67aaf690952ebb7fe3" translate="yes" xml:space="preserve">
          <source>The process trace token is set to the trace token from the message.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c783222fca1057432e796e94441d99e31c4d2ed" translate="yes" xml:space="preserve">
          <source>The process was currently running. If the BIF &lt;code&gt;erlang:halt/1&lt;/code&gt; was called, this was the process calling it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82a3bf215f40b6a47f89483c4acc26d02d7b3f1c" translate="yes" xml:space="preserve">
          <source>The process was on its way to exit.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f141b2b54a0e0f93bea0340098e765164fced9dd" translate="yes" xml:space="preserve">
          <source>The process was scheduled to run but is currently not running (&quot;in the run queue&quot;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2810522b49b7629b84a03c4f78227a04b09abe5b" translate="yes" xml:space="preserve">
          <source>The process was waiting for something (in &lt;code&gt;receive&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27d3cd0b8797a36f6ea5cee6f120e89b7d3af94f" translate="yes" xml:space="preserve">
          <source>The processes created by the service can, as opposed to normal services, be &quot;killed&quot; with the task manager. Killing an emulator that is started by a service triggers the &quot;OnFail&quot; action specified for that service, which can be a reboot.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d0fdc2fce3dc489670b9aaebda13b3b3434f1aa" translate="yes" xml:space="preserve">
          <source>The profiling result is delivered as a term containing a sorted list of entries, one per module. Each module entry contains a sorted list of functions. The sorting order in both cases is of decreasing call count.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6855e78a7f0fc77588d6aebc869c8f249ff318eb" translate="yes" xml:space="preserve">
          <source>The program Igor merges the source code of one or more Erlang modules into a single module, which can then replace the original set of modules. Igor is also able to rename a set of (possibly interdependent) modules, without joining them into a single module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8195bc3c2103b70768bbe121c78ace9e38d4b38" translate="yes" xml:space="preserve">
          <source>The program at the other side of a port is often a C program. To help the C programmer, the Erl_Interface library has been developed, including the following five parts:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9cb003c21eb552de99312a5e6d1ef17c2df06991" translate="yes" xml:space="preserve">
          <source>The programmer must ensure that the function given as argument is truly synchronous and that no work continues after the function has returned a value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8563f5a39583bb15e30f23bba9afb2129b0dea31" translate="yes" xml:space="preserve">
          <source>The properties &lt;code&gt;proplist_file&lt;/code&gt; and &lt;code&gt;file&lt;/code&gt; are mutually exclusive. Also newer properties may not be supported as Apache-like options, this is a legacy feature.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec3820a1952a9bf6dd6589dfc08be32bf37ba810" translate="yes" xml:space="preserve">
          <source>The properties for a group are always printed in the top of the HTML log for &lt;code&gt;init_per_group/2&lt;/code&gt;. The total execution time for a group is included at the bottom of the log for &lt;code&gt;end_per_group/2&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0658e68a98aef88d6e658150857250258c9aa19" translate="yes" xml:space="preserve">
          <source>The properties for directories are as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c21d4cead30e9277ec44f6f7b10414a0626222c2" translate="yes" xml:space="preserve">
          <source>The properties for the security directories are as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1311e2c285781d781a81d4ea6d0fb15f0a88ba6" translate="yes" xml:space="preserve">
          <source>The properties of the sessions will be exactly the same, except that when using &lt;code&gt;&lt;a href=&quot;#connect-1&quot;&gt;connect/1,2&lt;/a&gt;&lt;/code&gt;, you may start multiple sessions over the same SSH connection. Each session is implemented as an SSH channel.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2db0406d66f21d5b36229de1553b67aafe2dce31" translate="yes" xml:space="preserve">
          <source>The property names represented by &lt;strong&gt;xx&lt;/strong&gt; above are limited to the Unicode script names, the general category properties, &quot;Any&quot;, which matches any character (including newline), and some special PCRE properties (described in the next section). Other Perl properties, such as &quot;InMusicalSymbols&quot;, are currently not supported by PCRE. Notice that \P{Any} does not match any characters and always causes a match failure.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b66b0619fa655f54cf968828bbc7d5585eb77d5" translate="yes" xml:space="preserve">
          <source>The property tests are assumed to be in subdirectory &lt;code&gt;property_test&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cecd3acaa022724f92df164ddb141a901162aee3" translate="yes" xml:space="preserve">
          <source>The protection of the dumped table (that is, &lt;code&gt;private&lt;/code&gt;, &lt;code&gt;protected&lt;/code&gt;, or &lt;code&gt;public&lt;/code&gt;). A table loaded from the file gets the same protection.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea098b4d622a71447129857377ff429cb6e98cf7" translate="yes" xml:space="preserve">
          <source>The protection of the table.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d49c5ef78ce098f6cf07e79b387a293a3f5f71d" translate="yes" xml:space="preserve">
          <source>The protocol (messages sent to and received from the server) is also hidden. This is good programming practice and allows one to change the protocol without changing the code using the interface functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af664d953b1ecbbc88733b368b7ab068bb4ba398" translate="yes" xml:space="preserve">
          <source>The protocol engine uses callback modules to handle various things:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45aaae8278825f7a88f5605ecd8a29c30678b26a" translate="yes" xml:space="preserve">
          <source>The protocol handling processes in &lt;code&gt;Common Test&lt;/code&gt;, implemented by &lt;code&gt;ct_telnet&lt;/code&gt;, &lt;code&gt;ct_ssh&lt;/code&gt;, &lt;code&gt;ct_ftp&lt;/code&gt;, and so on, do verbose printing to the test case logs. This can be switched off with flag &lt;code&gt;-silent_connections&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7483add893bc17e440cace13830412bb71cc8e83" translate="yes" xml:space="preserve">
          <source>The protocol stack does also handle things like automatic sending of acknowledgements, pending transactions, re-send of messages, supervision of connections etc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd90b6a6ff5727727e4daa87f469034b2b5161f8" translate="yes" xml:space="preserve">
          <source>The protocol type &lt;code&gt;http&lt;/code&gt; is only to be used for the first line when an &lt;code&gt;HttpRequest&lt;/code&gt; or an &lt;code&gt;HttpResponse&lt;/code&gt; is expected. The following calls are to use &lt;code&gt;httph&lt;/code&gt; to get &lt;code&gt;HttpHeader&lt;/code&gt;s until &lt;code&gt;http_eoh&lt;/code&gt; is returned, which marks the end of the headers and the beginning of any following message body.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="535cbad2526a219432d1c3150baaa80223145620" translate="yes" xml:space="preserve">
          <source>The protocol-independent architectural model on the network level is the well-known client-server model for management operations. This model is based on the client-server principle, where the manager (client) sends a request from a manager to an agent (server) when it accesses management information. The agent sends a reply back to the manager. There are two main differences to the normal client-server model:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b945eead3d07f17de2dbf5269f341d725ae12921" translate="yes" xml:space="preserve">
          <source>The public key handling can be customized by implementing the following behaviours from &lt;code&gt;ssh&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36b59dc532efc1e5c7b32fe689f2d2e6632ebccc" translate="yes" xml:space="preserve">
          <source>The public-key algorithm OID name atoms are as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a15b14b311d626350885eb389b70b1402e8566a" translate="yes" xml:space="preserve">
          <source>The purpose is to have a mechanism for a human to accept an otherwise faulty Certificate. In for example a web browser, you could get a question like</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2da4fdf22d3807497c8bad4c3fa2b75601232aeb" translate="yes" xml:space="preserve">
          <source>The purpose is to inform the &lt;code&gt;receiver&lt;/code&gt; of the result of the delivery (was the notification acknowledged or not) for each target.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3ba6f0037561095ae27788eb1fae4aa354ad82a" translate="yes" xml:space="preserve">
          <source>The purpose of notification filters is to allow for modification and/or suppression of a notification.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e9701b065192ac8404e84b8b9c52feac07c04bf" translate="yes" xml:space="preserve">
          <source>The purpose of the Erlang ODBC application is to provide the programmer with an ODBC interface that has a Erlang/OTP touch and feel. So that the programmer may concentrate on solving his/her actual problem instead of struggling with pointers and memory allocation which is not very relevant for Erlang. This user guide will give you some information about technical issues and provide some examples of how to use the Erlang ODBC interface.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3a6d9bf1c2c25a8cd3bddca112e22cfd0ab28d5" translate="yes" xml:space="preserve">
          <source>The purpose of the OTP_Mibs application is to provide an SNMP management information base for Erlang nodes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83e927dfda3dd650e3137512b144dd84450aebd9" translate="yes" xml:space="preserve">
          <source>The purpose of the function is mainly to convert combinations of Unicode characters into a pure Unicode string in list representation for further processing. For writing the data to an external entity, the reverse function &lt;code&gt;&lt;a href=&quot;#characters_to_binary-3&quot;&gt;characters_to_binary/3&lt;/a&gt;&lt;/code&gt; comes in handy.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ff9c9b9dec703339d3bdb8b0c4fd2008e1ebebd" translate="yes" xml:space="preserve">
          <source>The purpose of the network interface filter is to allow for filtering of messages (accept or reject) receive and send. This is done on two levels:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="380d75fe3dc7c1d9bcb891cc0287c70808132793" translate="yes" xml:space="preserve">
          <source>The purpose of the transaction sender is to accumulate transactions for a more efficient message sending. The transactions that are accumulated are transaction request and transaction ack. For transaction ack's the benefit is quite large, since the transactions are small and it is possible to have ranges (which means that transaction acks for transactions 1, 2, 3 and 4 can be sent as a range 1-4 in one transaction ack, instead of four separate transactions).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="285eddd7bec05e75e8a6d971be6aadc6efc04add" translate="yes" xml:space="preserve">
          <source>The purpose of this function is to do a minimal decode of Megaco message. A successfull result is a &lt;code&gt;'MegacoMessage'&lt;/code&gt; in which only version and mid has been initiated. This function is used by the megaco_messenger module when the &lt;code&gt;decode_message/3&lt;/code&gt; function fails to figure out the mid (the actual sender) of the message.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c094a70f3fb457644d9fe5a09333364897998e8" translate="yes" xml:space="preserve">
          <source>The purpose of this function is to generate the usm- related security data needed for usm processing in the agent. Specifically, updating the usmUserTable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4997df3d063972a7e3b9575b1cf9377dc21bae3" translate="yes" xml:space="preserve">
          <source>The purpose of this module is to simplify SNMP configuration for the test case writer. Many test cases can use default values for common operations and then no SNMP configuration files need to be supplied. When it is necessary to change particular configuration parameters, a subset of the relevant SNMP configuration files can be passed to &lt;code&gt;ct_snmp&lt;/code&gt; by &lt;code&gt;Common Test&lt;/code&gt; configuration files. For more specialized configuration parameters, a simple SNMP configuration file can be placed in the test suite data directory. To simplify the test suite, &lt;code&gt;Common Test&lt;/code&gt; keeps track of some of the SNMP manager information. This way the test suite does not have to handle as many input parameters as if it had to interface wthe OTP SNMP manager directly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d919b258d0197ec8d853aab267758bf87f5d968e" translate="yes" xml:space="preserve">
          <source>The purpose of this option is to increase performance by reducing the number of operating system calls. Thus, the &lt;code&gt;write/2&lt;/code&gt; calls must be for sizes significantly less than &lt;code&gt;Size&lt;/code&gt;, and not interspersed by too many other file operations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6764da434257370babfd601803893f5ca699a25d" translate="yes" xml:space="preserve">
          <source>The purpose of this section is to let the newcomer get started in quickly writing and executing some first simple tests with a &quot;learning by example&quot; approach. Most explanations are left for later sections. If you are not much into &quot;learning by example&quot; and prefer more technical details, go ahead and skip to the next section.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5baba518ef35fe89fecc8d2eabb40055ac16675f" translate="yes" xml:space="preserve">
          <source>The purpose of this tutorial is to describe different interoperability mechanisms that can be used when integrating a program written in Erlang with a program written in another programming language, from the Erlang programmer's perspective.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad7e63be85ec6284886f671e4aac3786bf5f89cd" translate="yes" xml:space="preserve">
          <source>The purpose of this user guide is to introduce you to the Erlang mode for Emacs and gives some relevant background information of the functions and features. See also &lt;code&gt;&lt;a href=&quot;erlang.el&quot;&gt;Erlang mode reference manual&lt;/a&gt;&lt;/code&gt; The purpose of the Erlang mode itself is to facilitate the developing process for the Erlang programmer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea3039623e684f7c81037387c6d7f5eb72507985" translate="yes" xml:space="preserve">
          <source>The quantifier {0} is permitted, causing the expression to behave as if the previous item and the quantifier were not present. This can be useful for subpatterns that are referenced as subroutines from elsewhere in the pattern (but see also section &lt;code&gt;&lt;a href=&quot;#defining_subpatterns&quot;&gt;Defining Subpatterns for Use by Reference Only&lt;/a&gt;&lt;/code&gt;). Items other than subpatterns that have a {0} quantifier are omitted from the compiled pattern.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ffdab0f26f651e47a43589852883c8b5ecab0d9" translate="yes" xml:space="preserve">
          <source>The query asks for the restriction of external calls except the unresolved calls to calls to functions that are externally used but neither exported nor built-in functions (the &lt;code&gt;||&lt;/code&gt; operator restricts the used functions while the &lt;code&gt;|&lt;/code&gt; operator restricts the calling functions). The &lt;code&gt;-&lt;/code&gt; operator returns the difference of two sets, and the &lt;code&gt;+&lt;/code&gt; operator to be used below returns the union of two sets.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f690a75130a74f61a6b149376be5c663bfe1f1d3" translate="yes" xml:space="preserve">
          <source>The queue can be manipulated from any threads if a port data lock is used. For more information, see &lt;code&gt;&lt;a href=&quot;#ErlDrvPDL&quot;&gt;ErlDrvPDL&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fca3c136aa3b7db81fe20cdb9588464345ea02d4" translate="yes" xml:space="preserve">
          <source>The ratio between the number of collisions and the number of tries (acquisitions) in percentage.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44affb61a9f1b3e79f7f910ffd11f6983e2b7acd" translate="yes" xml:space="preserve">
          <source>The raw data pointed to by &lt;code&gt;data&lt;/code&gt; is only mutable after a call to &lt;code&gt;&lt;a href=&quot;#enif_alloc_binary&quot;&gt;enif_alloc_binary&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#enif_realloc_binary&quot;&gt;enif_realloc_binary&lt;/a&gt;&lt;/code&gt;. All other functions that operate on a binary leave the data as read-only. A mutable binary must in the end either be freed with &lt;code&gt;&lt;a href=&quot;#enif_release_binary&quot;&gt;enif_release_binary&lt;/a&gt;&lt;/code&gt; or made read-only by transferring it to an Erlang term with &lt;code&gt;&lt;a href=&quot;#enif_make_binary&quot;&gt;enif_make_binary&lt;/a&gt;&lt;/code&gt;. However, it does not have to occur in the same NIF call. Read-only binaries do not have to be released.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e697470bc64df4548085b65b4119eaa00152f6fc" translate="yes" xml:space="preserve">
          <source>The raw memory information can be decoded by the Crashdump Viewer tool. You can then see the stack dump, the message queue (if any), and the dictionary (if any).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94b9348a6665f910941aa4666d77803d6bab3e84" translate="yes" xml:space="preserve">
          <source>The read operation failed and parameter &lt;code&gt;ErrorDescription&lt;/code&gt; gives a hint about the error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7bbc097f89bd9fc9542bcc569f782bd621e86844" translate="yes" xml:space="preserve">
          <source>The read operation failed and parameter &lt;code&gt;What&lt;/code&gt; gives a hint about the error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb6a39bb3dee1cf5c8904fe1074aac9c463a49da" translate="yes" xml:space="preserve">
          <source>The read was successful and &lt;code&gt;Terms&lt;/code&gt; is the list of successfully matched and read items.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dcfa32e23c0ed6b07d119f5cbe4a63799ba2a7c0" translate="yes" xml:space="preserve">
          <source>The reader of this section is assumed to be familiar with the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba2a82a53accd93542c2130c8adecd6ee219c0ca" translate="yes" xml:space="preserve">
          <source>The reading failed and &lt;code&gt;FreadError&lt;/code&gt; gives a hint about the error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="daa863f5699aef2a6313b5f617a1c72b21feead3" translate="yes" xml:space="preserve">
          <source>The real difference is instead in system characteristics, which is best shown with the mstone1 test.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45e718b5cc8c016eeb0b83bab7279b93e9d7f448" translate="yes" xml:space="preserve">
          <source>The reason for having this limit is that if the cache is large, the GC can potentially take a long time, during which the agent is locked.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="188404504e5ffcfc4e22d678f33dc7b1dabcdeee" translate="yes" xml:space="preserve">
          <source>The reason for not having an external representation of a compiled match specification is performance. It can be subject to change in future releases, while this interface remains for backward compatibility.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d12e3451eede4d21837264efccb2d76d8bb6ff89" translate="yes" xml:space="preserve">
          <source>The reason for not having an external representation of compiled match specifications is performance. It can be subject to change in future releases, while this interface remains for backward compatibility.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62037923291a9bc215c53f9d64f569edf7ad5f37" translate="yes" xml:space="preserve">
          <source>The reason for the dump is shown in the beginning of the file as:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2faab1fcd118d3b3332e3465dbb0be228ca6f80a" translate="yes" xml:space="preserve">
          <source>The reason for the latter is presumably interoperability: allowing arbitrary AVPs setting the M-bit in a command makes its interpretation implementation-dependent, since there's no guarantee that all implementations will understand the same set of arbitrary AVPs in the context of a given command. However, interpreting &lt;code&gt;AVP&lt;/code&gt; in a command grammar as any AVP, regardless of M-bit, renders 1.3.4 meaningless, since the receiver can simply ignore any AVP it thinks isn't relevant, regardless of the sender's intent.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="670dee16e7dda71243b144db55242f7df8863db8" translate="yes" xml:space="preserve">
          <source>The reason for this division of the interfaces into compile-time and runtime is that only runtime modules (&lt;code&gt;asn1rt*&lt;/code&gt;) need to be loaded in an embedded system.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78fc68d51d1cbc8283fa7ece8361aa9511ea81ac" translate="yes" xml:space="preserve">
          <source>The reason for this function is that continuation terms contain compiled match specifications and therefore are invalidated if converted to external term format. Given that the original match specification is kept intact, the continuation can be restored, meaning it can once again be used in subsequent &lt;code&gt;select/1&lt;/code&gt; calls even though it has been stored on disk or on another node.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e66b56334bd4302b0b55eee5e555ae3f6f42859" translate="yes" xml:space="preserve">
          <source>The reason is that a &lt;code&gt;&lt;a href=&quot;#match_context&quot;&gt;match context&lt;/a&gt;&lt;/code&gt; contains a direct pointer to the binary data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa3e28310c9f5068c3bc594e80fb7f8131e7f277" translate="yes" xml:space="preserve">
          <source>The reason we get a deadlock in the first example is because when TAB is pressed to expand the function name, the group leader (which handles character input) calls &lt;code&gt;mymod:module_info()&lt;/code&gt;. This generates a trace message which, in turn, causes the tracer process to send an IO request to the group leader (by calling &lt;code&gt;io:format/2&lt;/code&gt;). We end up in a deadlock.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d334c8815a940e1117cd6bf97ab09bf24cf15d4d" translate="yes" xml:space="preserve">
          <source>The recognized allocators are listed in &lt;code&gt;erts_alloc(3)&lt;/code&gt;. Information about super carriers can be obtained from ERTS 8.0 with &lt;code&gt;{allocator, erts_mmap}&lt;/code&gt; or from ERTS 5.10.4; the returned list when calling with &lt;code&gt;{allocator, mseg_alloc}&lt;/code&gt; also includes an &lt;code&gt;{erts_mmap, _}&lt;/code&gt; tuple as one element in the list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1601ceca58dc5bb418d4d058642b8127306f81a6" translate="yes" xml:space="preserve">
          <source>The record &lt;code&gt;file_info&lt;/code&gt; contains the following fields:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90fa624e6ef711e6538891034b680bc3cf375ce0" translate="yes" xml:space="preserve">
          <source>The record &lt;code&gt;megaco_incr_timer&lt;/code&gt; contains the following fields:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd91c53b0842e666e7eac373490635f53ee82f94" translate="yes" xml:space="preserve">
          <source>The record &lt;code&gt;snmpa_notification_delivery_info&lt;/code&gt; contains the following fields:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ef7e07ae45347add7e7787bb739a3aea7c0c97a" translate="yes" xml:space="preserve">
          <source>The record &lt;code&gt;xmlAttribute&lt;/code&gt; holds the name and value of an attribute in the fields &lt;code&gt;name&lt;/code&gt; and &lt;code&gt;value&lt;/code&gt;. All attributes of an element is a list of xmlAttribute in the field &lt;code&gt;attributes&lt;/code&gt; of the xmlElement record.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18b3b71ec5bfcc1ff63cbc72d59db895c56c0f72" translate="yes" xml:space="preserve">
          <source>The record &lt;code&gt;zip_comment&lt;/code&gt; only contains the archive comment for a zip archive.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="857d4f5792009846db2a99430f060ca57c895a3d" translate="yes" xml:space="preserve">
          <source>The record &lt;code&gt;zip_file&lt;/code&gt; contains the following fields:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72cb006aafe2a35c580dddc00f0e1af4643c65e2" translate="yes" xml:space="preserve">
          <source>The record &lt;code&gt;{boss, klacke, bjarne}&lt;/code&gt; can also be inserted. This record contains an implicit reference to another employee that does not yet exist in the database. &lt;code&gt;Mnesia&lt;/code&gt; does not enforce this.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eeb48859b3ad695cfb58e1472606a8b95d102ac9" translate="yes" xml:space="preserve">
          <source>The record declarations for a module &lt;code&gt;M&lt;/code&gt; are placed in a separate &lt;code&gt;M.hrl&lt;/code&gt; file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8f84ddcf67fb899e512597e0ee97ecc7c382394" translate="yes" xml:space="preserve">
          <source>The record definition is found in xmerl.hrl.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b708de2ffe05d9893e05e616dfbb164eb37b0f6f" translate="yes" xml:space="preserve">
          <source>The record initially returned by &lt;code&gt;megaco:connect/4,5&lt;/code&gt;. It identifies a &quot;virtual&quot; connection and may be reused after a reconnect (disconnect + connect).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7f4e92997b0d8825962c8c3544ff9c3495a9e48" translate="yes" xml:space="preserve">
          <source>The record is defined in the Kernel include file &lt;code&gt;&quot;inet.hrl&quot;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87950d43bd1bd589a1c9d9ae13c4a20a531dad00" translate="yes" xml:space="preserve">
          <source>The record must be defined in the shell to enable use of the record syntax in the examples:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7dc35961a83e47be02049c0ff9dabcb3687ccf9d" translate="yes" xml:space="preserve">
          <source>The record representation of the Diameter header. Values in a &lt;code&gt;&lt;a href=&quot;#packet&quot;&gt;packet()&lt;/a&gt;&lt;/code&gt; returned by &lt;code&gt;&lt;a href=&quot;#decode-2&quot;&gt;decode/2&lt;/a&gt;&lt;/code&gt; are as extracted from the incoming message. Values set in an &lt;code&gt;&lt;a href=&quot;#packet&quot;&gt;packet()&lt;/a&gt;&lt;/code&gt; passed to &lt;code&gt;&lt;a href=&quot;#encode-2&quot;&gt;encode/2&lt;/a&gt;&lt;/code&gt; are preserved in the encoded binary(), with the exception of &lt;code&gt;length&lt;/code&gt;, &lt;code&gt;cmd_code&lt;/code&gt; and &lt;code&gt;application_id&lt;/code&gt;, all of which are determined by the &lt;code&gt;&lt;a href=&quot;#dictionary&quot;&gt;dictionary()&lt;/a&gt;&lt;/code&gt; in question.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f1ffbe66bd5cda775f3eecb9e76ac9a6773796b" translate="yes" xml:space="preserve">
          <source>The reference count of driver binary is normally to be decremented by calling &lt;code&gt;&lt;a href=&quot;#driver_free_binary&quot;&gt;driver_free_binary&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d02f19c19b420c90f199ab4d6f0e29073cf27683" translate="yes" xml:space="preserve">
          <source>The reference material is divided into the following sections:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14b2330f91efad717120789b2f96d3d8f50d2e67" translate="yes" xml:space="preserve">
          <source>The reference objects &lt;strong&gt;sub binaries&lt;/strong&gt; and &lt;strong&gt;match contexts&lt;/strong&gt; can reference part of a refc binary or heap binary.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f3eb9a07f806c6c71dfeae710e0da778e14bc05" translate="yes" xml:space="preserve">
          <source>The registered name of the port, if any.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9cf711a7294ba24b8c0e11fc28d22a091e59813" translate="yes" xml:space="preserve">
          <source>The registered name of the process, if any.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5bafed5b0dd3a5d4eb9ad07383aa0c7c6a85578" translate="yes" xml:space="preserve">
          <source>The registered name, &lt;code&gt;RegName&lt;/code&gt;, can be any atom. The name can be ignored by the C code, or, for example, be used to distinguish between different types of messages. An example of Erlang code using short node names follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1514fe84ab0f4ebd6e6cad9a7b7bbf021b9cbbe" translate="yes" xml:space="preserve">
          <source>The registered name, if any. If a registered name is not displayed, it can be that Debugger received information about the process before the name was registered. Try selecting &lt;strong&gt;Edit &amp;gt; Refresh&lt;/strong&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="253fb5321acafacd5bcd81a207e0260e1e20f165" translate="yes" xml:space="preserve">
          <source>The registered names are stored in replica global name tables on every node. There is no central storage point. Thus, the translation of a name to a pid is fast, as it is always done locally. For any action resulting in a change to the global name table, all tables on other nodes are automatically updated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b656ecffd1ced10be89c73c0264120c641a1a963" translate="yes" xml:space="preserve">
          <source>The registry contains keys and values. Keys are like the directories in a file system, they form a hierarchy. Values are like files, they have a name and a value, and also a type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f19e0edc2bdf4a111b804cb06a4a4fda7a24377" translate="yes" xml:space="preserve">
          <source>The registry is a hierarchical database, used to store various system and software information in Windows. It contains installation data, and is updated by installers and system programs. The Erlang installer updates the registry by adding data that Erlang needs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1df08771ef4b4eb79805f54d0af976d930c81c1" translate="yes" xml:space="preserve">
          <source>The registry must have been opened in write mode.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e31d2327ae3a594ef721ad76afd4e76d34b773c" translate="yes" xml:space="preserve">
          <source>The regular expression &lt;code&gt;(|at)&lt;/code&gt; first match at the initial position of string &lt;code&gt;cat&lt;/code&gt;, giving the result set &lt;code&gt;[{0,0},{0,0}]&lt;/code&gt; (the second &lt;code&gt;{0,0}&lt;/code&gt; is because of the subexpression marked by the parentheses). As the length of the match is 0, we do not advance to the next position yet.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c67bde651eeeb2e55477d91b265e707252cb8bd3" translate="yes" xml:space="preserve">
          <source>The regular expression is specified as a Unicode &lt;code&gt;charlist()&lt;/code&gt; and the resulting regular expression code is to be run against a valid Unicode &lt;code&gt;charlist()&lt;/code&gt; subject. Also consider option &lt;code&gt;ucp&lt;/code&gt; when using Unicode characters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4b1e3caf6818ade884c58fbfd440b868fffc15b" translate="yes" xml:space="preserve">
          <source>The regular expressions allowed here is a subset of the set found in &lt;code&gt;egrep&lt;/code&gt; and in the AWK programming language, as defined in the book, The AWK Programming Language, by A. V. Aho, B. W. Kernighan, P. J. Weinberger. They are composed of the following characters:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f4fcc0ee2bcb5481ad7e8a8560c012d54b3a581" translate="yes" xml:space="preserve">
          <source>The relation of equality between the elements of {a,b,c}:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c26a1fbdd58094ae590c77744a027cfe086295e" translate="yes" xml:space="preserve">
          <source>The relationships between the predefined variables &lt;code&gt;XU&lt;/code&gt;, &lt;code&gt;X&lt;/code&gt;, &lt;code&gt;B&lt;/code&gt; and a few others are worth elaborating upon. The reference manual mentions two ways of expressing the set of all functions, one that focuses on how they are defined: &lt;code&gt;X&amp;nbsp;+&amp;nbsp;L&amp;nbsp;+&amp;nbsp;B&amp;nbsp;+&amp;nbsp;U&lt;/code&gt;, and one that focuses on how they are used: &lt;code&gt;UU&amp;nbsp;+&amp;nbsp;LU&amp;nbsp;+&amp;nbsp;XU&lt;/code&gt;. The reference also mentions some &lt;code&gt;&lt;a href=&quot;xref#simple_facts&quot;&gt;facts&lt;/a&gt;&lt;/code&gt; about the variables:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11c6e207d55ada23ec986425dc6bc5e23db12059" translate="yes" xml:space="preserve">
          <source>The relative product of binary relations can be generalized to n-ary relations as follows. Let TR be an ordered set (R[1], ..., R[n]) of binary relations from X to Y[i] and S a binary relation from (Y[1] &amp;times; ... &amp;times; Y[n]) to Z. The &lt;strong id=&quot;tuple_relative_product&quot;&gt;relative product&lt;/strong&gt; of TR and S is the binary relation T from X to Z defined so that x T z if and only if there exists an element y[i] in Y[i] for each 1 &amp;lt;= i &amp;lt;= n such that x R[i] y[i] and (y[1], ..., y[n]) S z. Now let TR be a an ordered set (R[1], ..., R[n]) of binary relations from X[i] to Y[i] and S a subset of X[1] &amp;times; ... &amp;times; X[n]. The &lt;strong id=&quot;multiple_relative_product&quot;&gt;multiple relative product&lt;/strong&gt; of TR and S is defined to be the set {z : z = ((x[1], ..., x[n]), (y[1],...,y[n])) for some (x[1], ..., x[n]) in S and for some (x[i], y[i]) in R[i], 1 &amp;lt;= i &amp;lt;= n}.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a5a729dfd664ee2cc4b65eb400d7906d640d28a" translate="yes" xml:space="preserve">
          <source>The relative product of two functions F1 and F2 is called the &lt;strong id=&quot;composite&quot;&gt;composite&lt;/strong&gt; of F1 and F2 if the range of F1 is a subset of the domain of F2.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3e4729853dcefec28c04c62495d1227e52695db" translate="yes" xml:space="preserve">
          <source>The release handler at a node running on a diskless machine, or with a read-only file system, must be configured accordingly using the following SASL configuration parameters (for details, see &lt;code&gt;sasl(6)&lt;/code&gt;):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aba90e774f5b7292d69eb5ee7c87083b704de367" translate="yes" xml:space="preserve">
          <source>The release handler can also be used to unpack and install release packages when not running Erlang as an embedded system. However, in this case the user must somehow ensure that correct boot scripts and configuration files are used if the system must be restarted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a98562301df489f924334591464c2abdffdac36" translate="yes" xml:space="preserve">
          <source>The release handler evalutes &lt;code&gt;apply(M, F, A)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5810b19374ebd0aa36b0ddc3dbb430e23ad41e2" translate="yes" xml:space="preserve">
          <source>The release handler process is a locally registered process on each node. When a release is installed in a distributed system, the release handler on each node must be called. The release installation can be synchronized between nodes. From an operator view, it can be unsatisfactory to specify each node. The aim is to install one release package in the system, no matter how many nodes there are. It is recommended that software management functions are written that take care of this problem. Such a function can have knowledge of the system architecture, so it can contact each individual release handler to install the package.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d789ea08f7bf36cfa8a0d6324e5d810748f8d2a" translate="yes" xml:space="preserve">
          <source>The release handler suspends, asks for code change, and resumes processes by calling the functions &lt;code&gt;sys:suspend/1,2&lt;/code&gt;, &lt;code&gt;sys:change_code/4,5&lt;/code&gt;, and &lt;code&gt;sys:resume/1,2&lt;/code&gt;, respectively.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd503abbdadf3c3e7f2d6dab188fa7588e61f6b8" translate="yes" xml:space="preserve">
          <source>The release handling instructions for adding, removing, and restarting applications apply to primary applications only. There are no corresponding instructions for included applications. However, since an included application is really a supervision tree with a topmost supervisor, started as a child process to a supervisor in the including application, a &lt;code&gt;relup&lt;/code&gt; file can be manually created.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3463f0904903fe50d36a8d31b7efcf59b3d94b17" translate="yes" xml:space="preserve">
          <source>The release of a maintenance patch package usually imply an increase of the OTP &lt;code&gt;&amp;lt;Minor&amp;gt;&lt;/code&gt; version while the release of an emergency patch package usually imply an increase of the OTP &lt;code&gt;&amp;lt;Patch&amp;gt;&lt;/code&gt; version. This is however not necessarily always the case since changes of OTP versions are based on the actual changes in the code and not based on whether the patch was planned or not. For more information see the &lt;code&gt;&lt;a href=&quot;#version_scheme&quot;&gt;Version Scheme&lt;/a&gt;&lt;/code&gt; section above.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f38068eb9610d0b0cbd1a9bc480aef4c5039577" translate="yes" xml:space="preserve">
          <source>The release package by default contains:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ddf2f95ffb2351a4606d3527df333525dbf30af" translate="yes" xml:space="preserve">
          <source>The release package can be &lt;strong&gt;unpacked&lt;/strong&gt;, which extracts the files. An unpacked release can be &lt;strong&gt;installed&lt;/strong&gt;. The currently used version of the release is then upgraded or downgraded to the specified version by evaluating the instructions in the &lt;code&gt;relup&lt;/code&gt; file. An installed release can be made &lt;strong&gt;permanent&lt;/strong&gt;. Only one permanent release can exist in the system, and this release is used if the system is restarted. An installed release, except the permanent one, can be &lt;strong&gt;removed&lt;/strong&gt;. When a release is removed, all files belonging to that release only are deleted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9b6c34e733e444ceb133eb0558e587c5c6c416c" translate="yes" xml:space="preserve">
          <source>The release resource file &lt;code&gt;Name.rel&lt;/code&gt; is compared with all release resource files &lt;code&gt;Name2.rel&lt;/code&gt;, specified in &lt;code&gt;UpFrom&lt;/code&gt; and &lt;code&gt;DownTo&lt;/code&gt;. For each such pair, the following is deducted:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7359f911881a84330db66568ed156a10773a2e38" translate="yes" xml:space="preserve">
          <source>The release resource file &lt;code&gt;Name.rel&lt;/code&gt; is read to determine which applications are included in the release. Then the relevant application resource files &lt;code&gt;App.app&lt;/code&gt; are read to determine the version and modules of each application (keys &lt;code&gt;vsn&lt;/code&gt; and &lt;code&gt;modules&lt;/code&gt;, see &lt;code&gt;app(4)&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20395e6c5537d7e841a28ec3e32487d66bee87cf" translate="yes" xml:space="preserve">
          <source>The release resource file &lt;code&gt;Name.rel&lt;/code&gt; is read to determine which applications are included in the release. Then the relevant application resource files &lt;code&gt;App.app&lt;/code&gt; are read to determine which modules to be loaded, and if and how the applications are to be started. (Keys &lt;code&gt;modules&lt;/code&gt; and &lt;code&gt;mod&lt;/code&gt;, see &lt;code&gt;app(4)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4eefac0bf9340fed3bf570202c8d7eea59ecf327" translate="yes" xml:space="preserve">
          <source>The release resource file &lt;code&gt;mysystem.rel&lt;/code&gt; is duplicated in the tar file. Originally, this file was only stored in the &lt;code&gt;releases&lt;/code&gt; directory to make it possible for the &lt;code&gt;release_handler&lt;/code&gt; to extract this file separately. After unpacking the tar file, &lt;code&gt;release_handler&lt;/code&gt; would automatically copy the file to &lt;code&gt;releases/FIRST&lt;/code&gt;. However, sometimes the tar file is unpacked without involving the &lt;code&gt;release_handler&lt;/code&gt; (for example, when unpacking the first target system) and the file is therefore now instead duplicated in the tar file so no manual copying is necessary.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c80217b964ae1583cdca52537267d331ce978fc" translate="yes" xml:space="preserve">
          <source>The release resource file &lt;code&gt;mysystem.rel&lt;/code&gt; is duplicated in the tar file. Originally, this file was only stored in the &lt;code&gt;releases&lt;/code&gt; directory to make it possible for the &lt;code&gt;release_handler&lt;/code&gt; to extract this file separately. After unpacking the tar file, &lt;code&gt;release_handler&lt;/code&gt; would automatically copy the file to &lt;code&gt;releases/FIRST&lt;/code&gt;. However, sometimes the tar file is unpacked without involving the &lt;code&gt;release_handler&lt;/code&gt; (for example, when unpacking the first target system). The file is therefore now instead duplicated in the tar file so no manual copying is needed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ef92a0cda894349ddeef7379b503e49a64bdb11" translate="yes" xml:space="preserve">
          <source>The release resource file is to be called &lt;code&gt;Name.rel&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5471bf3aa3be047811963240dcf5d4400757add" translate="yes" xml:space="preserve">
          <source>The release resource file is used to generate &lt;code&gt;&lt;a href=&quot;#boot&quot;&gt;boot scripts&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#pack&quot;&gt;release packages&lt;/a&gt;&lt;/code&gt;. A system that is transferred to and installed at another site is called a &lt;strong&gt;target system&lt;/strong&gt;. How to use a release package to create a target system is described in System Principles.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5c96a363d42d5cbc941b3bdee5cae6301bb427b" translate="yes" xml:space="preserve">
          <source>The releases directory (&lt;code&gt;&quot;/usr/local/erl-target/releases&quot;&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe0ac93c2480f7003ed1b072da8ef587cc263275" translate="yes" xml:space="preserve">
          <source>The releases page is incomplete and very experimental.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fca42c3d6efd5f3bf7036a14ae119c2bac9a56a9" translate="yes" xml:space="preserve">
          <source>The remaining Erlang script file can either contain Erlang &lt;strong&gt;source code&lt;/strong&gt;, an &lt;strong&gt;inlined beam file&lt;/strong&gt;, or an &lt;strong&gt;inlined archive file&lt;/strong&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="839a2a9520ffa3810212231d0366ad625cbea04a" translate="yes" xml:space="preserve">
          <source>The remaining arguments are pointers to callback functions that can be used to initialize the library. They are not used in this simple example, hence they are all set to &lt;code&gt;NULL&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="848fe4988b3ebd532672ddf229d63bf17a87732d" translate="yes" xml:space="preserve">
          <source>The remaining filters only show function calls and function returns. All other trace message are discarded. To get the most out of these filters, &lt;code&gt;et_viewer&lt;/code&gt; must know the caller of each function and the time of return. This can be obtained using both the &lt;code&gt;call&lt;/code&gt; and &lt;code&gt;return_to&lt;/code&gt; flags when tracing. Notice that flag &lt;code&gt;return_to&lt;/code&gt; only works with local call trace, that is, when trace patterns are set with &lt;code&gt;ttb:tpl&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff5ca4f7571fd6b542abb7d48ce27d3b2fc439a8" translate="yes" xml:space="preserve">
          <source>The remote host &lt;code&gt;node&lt;/code&gt; is unreachable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d37d54820fa9581d298dd9136f05c8334760d7a0" translate="yes" xml:space="preserve">
          <source>The remote mid (of the connection). &lt;code&gt;megaco_mid()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba62da86bb3f99cdfb2879e83169ae1e52ad3de4" translate="yes" xml:space="preserve">
          <source>The remote process was monitoring the local process at the time of the crash.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6bb61a4811825e7030b032141e0fc103f13c80c" translate="yes" xml:space="preserve">
          <source>The remote username of the client (&lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc931.txt&quot;&gt;RFC 931&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87cb1661c7bb66858ea881ceaeef4b6250aa903b" translate="yes" xml:space="preserve">
          <source>The renaming affects only remote calls (also when disguised by import declarations); local calls within a module are not affected, and no function definitions are renamed. Since the arity cannot change, the new name is represented by &lt;code&gt;{NewModule, NewName}&lt;/code&gt; only. Only calls matching the specified arity will match; multiple entries are necessary for renaming calls to functions that have the same module and function name, but different arities.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7db0a5b5bf696ee011ef06c85df210d03986dfa2" translate="yes" xml:space="preserve">
          <source>The repair time is still proportional to the number of records in the file, but Dets repairs used to be much slower in the past. Dets has been massively rewritten and improved.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2c4a2bf8d01876589d2d63a72ca740faf035967" translate="yes" xml:space="preserve">
          <source>The replacement string can contain the special character &lt;code&gt;&amp;amp;&lt;/code&gt;, which inserts the whole matching expression in the result, and the special sequence &lt;code&gt;\&lt;/code&gt;N (where N is an integer &amp;gt; 0), &lt;code&gt;\g&lt;/code&gt;N, or &lt;code&gt;\g{&lt;/code&gt;N&lt;code&gt;}&lt;/code&gt;, resulting in the subexpression number N, is inserted in the result. If no subexpression with that number is generated by the regular expression, nothing is inserted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="faa500aee01a190343697194d03c438c2c602d2a" translate="yes" xml:space="preserve">
          <source>The reply will be delivered to the user through a call to the snmpm_user callback function &lt;code&gt;handle_pdu&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a4f1cc106b1e894d4c96e8e317dc640fccb08d0" translate="yes" xml:space="preserve">
          <source>The reply, if it arrives, will be delivered to the user through a call to the snmpm_user callback function &lt;code&gt;handle_pdu&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f6b172375ebcae29181dbc0b6ea9f54803c80f5" translate="yes" xml:space="preserve">
          <source>The report browser is used to browse and format error reports written by the error logger handler &lt;code&gt;log_mf_h&lt;/code&gt; defined in STDLIB.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="462562f8f81a87927a15414f09bedcc8da9f2dcf" translate="yes" xml:space="preserve">
          <source>The reports are matched using the &lt;code&gt;proplists&lt;/code&gt; module in STDLIB. The report must be a proplist to be matched against any of the filters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3841a22e3cae4249c1648495d6d06b7dc360f0ae" translate="yes" xml:space="preserve">
          <source>The representation for an empty list, that is, the Erlang syntax &lt;code&gt;[]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90aa0c68b7c44e3dde7bae01a4485de7f117fcb2" translate="yes" xml:space="preserve">
          <source>The representation of a Diameter message as passed to &lt;code&gt;&lt;a href=&quot;diameter#call-4&quot;&gt;diameter:call/4&lt;/a&gt;&lt;/code&gt; or returned from a &lt;code&gt;handle_request/3&lt;/code&gt; callback. The record representation is as outlined in &lt;code&gt;&lt;a href=&quot;diameter_dict#MESSAGE_RECORDS&quot;&gt;diameter_dict(4)&lt;/a&gt;&lt;/code&gt;: a message as defined in a dictionary file is encoded as a record with one field for each component AVP. Equivalently, a message can also be encoded as a list whose head is the atom-valued message name (as specified in the relevant dictionary file) and whose tail is either a list of AVP name/values pairs or a map with values keyed on AVP names. The format at decode is determined by &lt;code&gt;&lt;a href=&quot;diameter#service_opt&quot;&gt;diameter:service_opt()&lt;/a&gt;&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;diameter#decode_format&quot;&gt;decode_format&lt;/a&gt;&lt;/code&gt;. Any of the formats is accepted at encode.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82a411d117dc57a26bcb9e1f9d378e3ca11f15b7" translate="yes" xml:space="preserve">
          <source>The req_data() argument to this function is the Erlang term returned by handle_trans_request/3.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23e7ef624fc47862089915bb4bc3e847e83284d8" translate="yes" xml:space="preserve">
          <source>The request &lt;code&gt;Type&lt;/code&gt; as passed to &lt;code&gt;&lt;a href=&quot;#setup&quot;&gt;setup/5&lt;/a&gt;&lt;/code&gt;. This is only mandatory when the connection has been initiated by this node. That is, the connection is set up via &lt;code&gt;setup/5&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb7e74979895ad253263a88483e0213dfefa217d" translate="yes" xml:space="preserve">
          <source>The request is &lt;strong&gt;ignored&lt;/strong&gt; because &lt;code&gt;net_kernel&lt;/code&gt; is busy changing &lt;code&gt;net_ticktime&lt;/code&gt; to &lt;code&gt;NewNetTicktime&lt;/code&gt; seconds.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e8fce11312bcfaed7ec364cadd3a5f46ff33d51" translate="yes" xml:space="preserve">
          <source>The request is made into a message and sent to the &lt;code&gt;gen_server&lt;/code&gt;. &lt;code&gt;cast&lt;/code&gt;, and thus &lt;code&gt;free&lt;/code&gt;, then returns &lt;code&gt;ok&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03229c07c994ef8bacaf94e79a42852e8c89a6f8" translate="yes" xml:space="preserve">
          <source>The request is made into a message and sent to the &lt;code&gt;gen_server&lt;/code&gt;. When the request is received, the &lt;code&gt;gen_server&lt;/code&gt; calls &lt;code&gt;handle_call(Request, From, State)&lt;/code&gt;, which is expected to return a tuple &lt;code&gt;{reply,Reply,State1}&lt;/code&gt;. &lt;code&gt;Reply&lt;/code&gt; is the reply that is to be sent back to the client, and &lt;code&gt;State1&lt;/code&gt; is a new value for the state of the &lt;code&gt;gen_server&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6363c9ddb932fe00abea80ec408ab4c1cea65ddc" translate="yes" xml:space="preserve">
          <source>The request line as it came from the client (&lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc1945.txt&quot;&gt;RFC 1945&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e51eb4e82ec44b07e0af2fe79e985e993a82848" translate="yes" xml:space="preserve">
          <source>The request line exactly as it came from the client (&lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc1945.txt&quot;&gt;RFC 1945&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3416c5291401473a7cf1526d471fda57329a38c" translate="yes" xml:space="preserve">
          <source>The request may have reached the server and may have been performed. However, no answer was received from the server within the expected time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0609829732d849e2037ce824c383ed1a7b424ab2" translate="yes" xml:space="preserve">
          <source>The request was accepted and &lt;code&gt;SupervisorPid&lt;/code&gt; is the process identifier of the connection supervisor process (which is created in the &lt;code&gt;&lt;a href=&quot;#accept_connection&quot;&gt;accept_connection/5&lt;/a&gt;&lt;/code&gt; callback).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d76fc415bd89f84963ae3ee419c891159d20a10c" translate="yes" xml:space="preserve">
          <source>The request was rejected. This is a fatal error. The acceptor process should terminate.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0af04869dc460d9fffda5c9cafebc1aa148f650e" translate="yes" xml:space="preserve">
          <source>The requests served by the EPMD are summarized in the following figure.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="766cb0fbb7f32280a11f9d0fcaaf21cc2abaa201" translate="yes" xml:space="preserve">
          <source>The resources can send notifications to the manager as well. Examples of notifications are events and alarms. The resource needs to generate protocol-independent notifications. The following picture illustrates how this is achieved:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c83b49760a86aadaf5f3b2f1036293a1e089f52" translate="yes" xml:space="preserve">
          <source>The response for a &lt;code&gt;DUMP_REQ&lt;/code&gt; is as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a65d28bc38322c3bd1cfbf2bf8711df7091101cd" translate="yes" xml:space="preserve">
          <source>The response for a &lt;code&gt;KILL_REQ&lt;/code&gt; is as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3c2ac7160df49c4588c05e57b87e5aff9422c1f" translate="yes" xml:space="preserve">
          <source>The response for a &lt;code&gt;NAMES_REQ&lt;/code&gt; is as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0dd3fa630ddc8b538f974287e27afabd12f4340d" translate="yes" xml:space="preserve">
          <source>The response for a &lt;code&gt;STOP_REQ&lt;/code&gt; is as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cbc3d39894fa2184326a46cadccf5d5f95e1ce70" translate="yes" xml:space="preserve">
          <source>The response message &lt;code&gt;ALIVE2_RESP&lt;/code&gt; is as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6677705b73ca8640b5bfd49e04c30a99a6b85930" translate="yes" xml:space="preserve">
          <source>The response shows that the file &lt;code&gt;FALLBACK.BUP&lt;/code&gt; has been created. This is called a backup file, and it contains an initial schema. If more than one node in the function &lt;code&gt;&lt;a href=&quot;mnesia#create_schema-1&quot;&gt;mnesia:create_schema/1&lt;/a&gt;&lt;/code&gt; had been specified, identical backup files would have been created on all nodes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4067e1f0937adfc4de129b497938ce1fa751f3a" translate="yes" xml:space="preserve">
          <source>The rest of the driver is more or less UDS-specific and not of general interest.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b248e72516f25e453000ce440baff629617e3ca9" translate="yes" xml:space="preserve">
          <source>The rest of this section is therefore deliberately not adapted for reading by the Erlang programmer, but the examples can help in understanding NAMES as they can be used by (*SKIP).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d01a53de4ed7d8cd3faf10a1aef24441bc36b6e" translate="yes" xml:space="preserve">
          <source>The restart strategy is specified by the &lt;code&gt;strategy&lt;/code&gt; key in the supervisor flags map returned by the callback function &lt;code&gt;init&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="536cf89c0e01376b78ab828ece36006c915f41c1" translate="yes" xml:space="preserve">
          <source>The restoration is performed as a single transaction. If the database is large, it cannot always be restored online. The old database must then be restored by installing a fallback, followed by a restart.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="afdaf9dae668c3f7bdc0ca10a94463ffda8086c1" translate="yes" xml:space="preserve">
          <source>The restriction operators are defined for closures as well; &lt;code&gt;closure&amp;nbsp;E&amp;nbsp;|&amp;nbsp;xref&amp;nbsp;:&amp;nbsp;Mod&lt;/code&gt; is interpreted as the direct or indirect function calls from the &lt;code&gt;xref&lt;/code&gt; module, while the interpretation of &lt;code&gt;E&amp;nbsp;|&amp;nbsp;xref&amp;nbsp;:&amp;nbsp;Mod&lt;/code&gt; is the set of direct calls from &lt;code&gt;xref&lt;/code&gt;. If some graph is to be used in several graph analyses, it saves time to assign the &lt;code&gt;digraph&lt;/code&gt; representation of the graph to a user variable, and then make sure that every graph analysis operates on that variable instead of the list representation of the graph.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="603dc83e6b9810f3ec3760b7629ba1cc75f2b142" translate="yes" xml:space="preserve">
          <source>The result &lt;code&gt;Excl_Message&lt;/code&gt; has the same structure as a complete decode would have, except for the parts of the top type that were not decoded. The undecoded parts are on their places in the structure on format &lt;code&gt;{Type_Key,Undecoded_Value}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5bf40f10fe2bffb0315d5af0604d375695096e5" translate="yes" xml:space="preserve">
          <source>The result above are the fastest of these configurations for each codec. The figures presented are the average of all used messages.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32893fd2ec1b1eb00ce0a52b29ac7e0d97610291" translate="yes" xml:space="preserve">
          <source>The result contains information about the following &lt;code&gt;Item&lt;/code&gt;s:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e8b477b4aed021fef6ebb0a1b67b1473cc13b37" translate="yes" xml:space="preserve">
          <source>The result from each test case is recorded in a dedicated HTML log file, created for the particular test run. An overview page displays each test case represented by a table row showing total execution time, if the case was successful, failed, or skipped, plus an optional user comment. For a failed test case, the reason for termination is also printed in the comment field. The overview page has a link to each test case log file, providing simple navigation with any standard HTML browser.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="200d78a9c16efccfba75389c2e312a153f45a8e8" translate="yes" xml:space="preserve">
          <source>The result from running the test is printed in log files in HTML format (stored in unique log directories on a different level). The following illustration shows the log file structure:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="374ecad7f3c9133bbe397289798ccaaa43ce127d" translate="yes" xml:space="preserve">
          <source>The result is &quot;normalized&quot;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="859cd92f58e2a9a54c26d7e8f5204e954bdffebd" translate="yes" xml:space="preserve">
          <source>The result is &lt;code&gt;[&quot;011103&quot;,&quot;076324&quot;]&lt;/code&gt;. The fun is straightforward, so the only problem is that all the data from the table must be transferred from the table to the calling process for filtering. That is inefficient compared to the &lt;code&gt;ets:match/2&lt;/code&gt; call where the filtering can be done &quot;inside&quot; the emulator and only the result is transferred to the process.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3cac868d8974153152b55d9efa1e40ff1114e69d" translate="yes" xml:space="preserve">
          <source>The result is &lt;code&gt;[&quot;052341&quot;,&quot;076324&quot;,&quot;535216&quot;,&quot;789789&quot;,&quot;989891&quot;]&lt;/code&gt;, as expected. The equivalent expression using a handwritten match specification would look like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8636350d1356e8fb3f319b7140bff8ef6a16d4e" translate="yes" xml:space="preserve">
          <source>The result is a list of characters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1bedbbe8e33126fcebf6fc95fcd5a51821596e48" translate="yes" xml:space="preserve">
          <source>The result is a pair &lt;code&gt;{Tree, Stubs}&lt;/code&gt;, where &lt;code&gt;Tree&lt;/code&gt; represents the source code that is the result of merging all the code in &lt;code&gt;Sources&lt;/code&gt; and &lt;code&gt;Files&lt;/code&gt;, and &lt;code&gt;Stubs&lt;/code&gt; is a list of stub module descriptors (see &lt;code&gt;merge_sources/3&lt;/code&gt; for details).</source>
          <target state="new"/>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
