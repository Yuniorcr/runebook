<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="erlang">
    <body>
      <group id="erlang">
        <trans-unit id="946db1924667eb983a11ec1edab5fe1131a72877" translate="yes" xml:space="preserve">
          <source>Argument &lt;code&gt;obj&lt;/code&gt; is pointer to the resource to hold the monitor and &lt;code&gt;*target_pid&lt;/code&gt; identifies the local process to be monitored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="759c092e66e225d8bfb0ee95cc9263fb1d2744cd" translate="yes" xml:space="preserve">
          <source>Argument &lt;code&gt;percent&lt;/code&gt; must be an integer between 1 and 100. This function must only be called from a NIF-calling thread, and argument &lt;code&gt;env&lt;/code&gt; must be the environment of the calling process.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2c2f60e2d8ae32461ae1eadddd46c13583f534f" translate="yes" xml:space="preserve">
          <source>Argument &lt;code&gt;pid&lt;/code&gt; may be &lt;code&gt;NULL&lt;/code&gt; to indicate the calling process.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="302f9a8d5949d2f9e3d699e1fadbaaf1fd2728b5" translate="yes" xml:space="preserve">
          <source>Argument &lt;code&gt;ref&lt;/code&gt; must be either a reference obtained from &lt;code&gt;&lt;a href=&quot;erlang#make_ref-0&quot;&gt;erlang:make_ref/0&lt;/a&gt;&lt;/code&gt; or the atom &lt;code&gt;undefined&lt;/code&gt;. It will be passed as &lt;code&gt;Ref&lt;/code&gt; in the notifications. If a selective &lt;code&gt;receive&lt;/code&gt; statement is used to wait for the notification then a reference created just before the &lt;code&gt;receive&lt;/code&gt; will exploit a runtime optimization that bypasses all earlier received messages in the queue.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7193c5fbe44de78fcb734160bf05a4992363162d" translate="yes" xml:space="preserve">
          <source>Argument &lt;code&gt;reserved&lt;/code&gt; is intended for future use and is to be ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47a1b242d8b4376bd70073509fcf4806ebd02558" translate="yes" xml:space="preserve">
          <source>Argument &lt;code&gt;to_enc&lt;/code&gt; is ignored. As from Erlang/OTP 20 the encoding is always done in UTF-8 which is readable by nodes as old as Erlang/OTP R16.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="765075133d0be0aa3a9dbc9bcb841e96fb89d790" translate="yes" xml:space="preserve">
          <source>Argument list for the &lt;code&gt;init&lt;/code&gt; function in the callback module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13185c544644b7f2a243ef918a03957be326a36d" translate="yes" xml:space="preserve">
          <source>Argument:</source>
          <target state="translated">Argument:</target>
        </trans-unit>
        <trans-unit id="cbb9fa252e60809efa55a7ad83aea5438ef56753" translate="yes" xml:space="preserve">
          <source>Arguments</source>
          <target state="translated">Arguments</target>
        </trans-unit>
        <trans-unit id="565865945dd4be2b94783c9b5e4f90518f12be80" translate="yes" xml:space="preserve">
          <source>Arguments &lt;code&gt;Format&lt;/code&gt; and &lt;code&gt;Args&lt;/code&gt; are used in a call to &lt;code&gt;io_lib:format/2&lt;/code&gt; to create the comment string. The behavior of &lt;code&gt;comment/2&lt;/code&gt; is otherwise the same as function &lt;code&gt;&lt;a href=&quot;#comment-1&quot;&gt;ct:comment/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0478ca5f4c068ca3ac12f9474f6a15865ce9053" translate="yes" xml:space="preserve">
          <source>Arguments:</source>
          <target state="translated">Arguments:</target>
        </trans-unit>
        <trans-unit id="a853cd0dac3624d36b7ac915686a7bf9b68613c0" translate="yes" xml:space="preserve">
          <source>Arithmetic bitshift left</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09257e94fa407278a59602ea81c51ef19d845892" translate="yes" xml:space="preserve">
          <source>Arithmetic bitwise XOR</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="206db889fe395b01fcd9ea9b88e2747a6dbb4f32" translate="yes" xml:space="preserve">
          <source>Arithmetic expressions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="296f27747464dfd4585fc68aca14b6147fb87a9b" translate="yes" xml:space="preserve">
          <source>Arithmetics: &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, &lt;code&gt;div&lt;/code&gt;, &lt;code&gt;rem&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fdadcc41e499fbe0cbed3e778cd50052fc53c2be" translate="yes" xml:space="preserve">
          <source>Arity ::= Number | &lt;code&gt;-1&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a0d21145500640fd3f6136eeba595bfe934d364" translate="yes" xml:space="preserve">
          <source>Armenian</source>
          <target state="translated">Armenian</target>
        </trans-unit>
        <trans-unit id="6c4709af989db804327c6ea436d6589b124f8253" translate="yes" xml:space="preserve">
          <source>Arranges documents horizontally or vertically, separated by whitespace. Returns a document representing two alternative layouts of the (nonempty) sequence &lt;code&gt;Docs&lt;/code&gt; of documents, such that either all elements in &lt;code&gt;Docs&lt;/code&gt; are concatenated horizontally, and separated by a space character, or all elements are concatenated vertically (without extra separation).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb6e8bc43bfadc15174aa7c7533ec25e49f627de" translate="yes" xml:space="preserve">
          <source>Arranges documents in a paragraph-like layout. Returns a document representing all possible left-aligned paragraph-like layouts of the (nonempty) sequence &lt;code&gt;Docs&lt;/code&gt; of documents. Elements in &lt;code&gt;Docs&lt;/code&gt; are separated horizontally by a single space character and vertically with a single line break. All lines following the first (if any) are indented to the same left column, whose indentation is specified by the optional &lt;code&gt;Offset&lt;/code&gt; parameter relative to the position of the first element in &lt;code&gt;Docs&lt;/code&gt;. For example, with an offset of -4, the following layout can be produced, for a list of documents representing the numbers 0 to 15:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b0401c5dcd8acaf55fb3e4a1e292be99ca524e1" translate="yes" xml:space="preserve">
          <source>Arrays uses &lt;strong&gt;zero&lt;/strong&gt;-based indexing. This is a deliberate design choice and differs from other Erlang data structures, for example, tuples.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8daa60e38c87072a49c49928224bef6c12c7e054" translate="yes" xml:space="preserve">
          <source>As &lt;code&gt;&lt;a href=&quot;#+sbwt&quot;&gt;+sbwt&lt;/a&gt;&lt;/code&gt; but affects dirty CPU schedulers. Defaults to &lt;code&gt;short&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="309dd2054ffb824320663f138850770c829b8b4e" translate="yes" xml:space="preserve">
          <source>As &lt;code&gt;&lt;a href=&quot;#+sbwt&quot;&gt;+sbwt&lt;/a&gt;&lt;/code&gt; but affects dirty IO schedulers. Defaults to &lt;code&gt;short&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b3946f390b5828658a54092e42e5c1aeb3b35f2" translate="yes" xml:space="preserve">
          <source>As &lt;code&gt;&lt;a href=&quot;#+swt&quot;&gt;+swt&lt;/a&gt;&lt;/code&gt; but affects dirty CPU schedulers. Defaults to &lt;code&gt;medium&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e2e5d1e1ed3c38e858012a446291d2ee5eda343" translate="yes" xml:space="preserve">
          <source>As &lt;code&gt;&lt;a href=&quot;#+swt&quot;&gt;+swt&lt;/a&gt;&lt;/code&gt; but affects dirty IO schedulers. Defaults to &lt;code&gt;medium&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc32ea3f593b79a1f69eaba316d39f23e652807c" translate="yes" xml:space="preserve">
          <source>As &lt;code&gt;&lt;a href=&quot;#binary_to_atom-2&quot;&gt;binary_to_atom/2&lt;/a&gt;&lt;/code&gt;, but the atom must exist.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="434cd7266c5993b7f305995750735748f31955d2" translate="yes" xml:space="preserve">
          <source>As &lt;code&gt;&lt;a href=&quot;#match-2&quot;&gt;match/2&lt;/a&gt;&lt;/code&gt;, but &lt;code&gt;Subject&lt;/code&gt; is searched until exhausted and a list of all non-overlapping parts matching &lt;code&gt;Pattern&lt;/code&gt; is returned (in order).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62392802bcfff15af67682cfdf06f0083a7bb98e" translate="yes" xml:space="preserve">
          <source>As &lt;code&gt;&lt;a href=&quot;#open-1&quot;&gt;open/1&lt;/a&gt;&lt;/code&gt;, but does not send a &lt;code&gt;hello&lt;/code&gt; message.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb9ffdb93aadccde648214772c8fec53159cd3ed" translate="yes" xml:space="preserve">
          <source>As &lt;code&gt;&lt;a href=&quot;#open-2&quot;&gt;open/2&lt;/a&gt;&lt;/code&gt;, but does not send a &lt;code&gt;hello&lt;/code&gt; message.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4fa21b36059529486327fb112773587da1a9d73d" translate="yes" xml:space="preserve">
          <source>As &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;S'&lt;/code&gt; depend only on &lt;code&gt;S&lt;/code&gt; and &lt;code&gt;E&lt;/code&gt;, the kind of state machine described here is a Mealy machine (see, for example, the Wikipedia article &quot;Mealy machine&quot;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7f0ebcdeb2935048365b1b7688d80f3aa697b38" translate="yes" xml:space="preserve">
          <source>As &lt;code&gt;Common Test&lt;/code&gt; always finishes at least the current test case, the time specified with &lt;code&gt;duration&lt;/code&gt; or &lt;code&gt;until&lt;/code&gt; is never definitive.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36e279355dc9b13486eb359a6a271e352bb9ca92" translate="yes" xml:space="preserve">
          <source>As &lt;code&gt;binary_to_list/1&lt;/code&gt;, but returns a list of integers corresponding to the bytes from position &lt;code&gt;Start&lt;/code&gt; to position &lt;code&gt;Stop&lt;/code&gt; in &lt;code&gt;Binary&lt;/code&gt;. The positions in the binary are numbered starting from 1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="356a2faa4b1e013f3d85b59d1af52dcdb569daaf" translate="yes" xml:space="preserve">
          <source>As &lt;code&gt;binary_to_term/1&lt;/code&gt;, but takes these options:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a20cd1597bfd4ebe1b9bc83959a610632302a2c" translate="yes" xml:space="preserve">
          <source>As &lt;code&gt;init_per_testcase&lt;/code&gt; and &lt;code&gt;end_per_testcase&lt;/code&gt; execute on the same Erlang process as the test case, printouts from these configuration functions are included in the test case log file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="077937866e1c72c70b5a0b14cb6e8cc697f67ab6" translate="yes" xml:space="preserve">
          <source>As &lt;code&gt;reload/2&lt;/code&gt; waits for the reloading to occur, a misbehaving process keeping open ports to the driver (or keeping the driver loaded) can cause infinite waiting for reload. Time-outs must be provided outside of the process demanding the reload or by using the low-level interface &lt;code&gt;&lt;a href=&quot;#try_load-3&quot;&gt;try_load/3&lt;/a&gt;&lt;/code&gt; in combination with driver monitors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="35dd6ddae6107d33b10d598d29bb9b8cf8efce75" translate="yes" xml:space="preserve">
          <source>As &lt;code&gt;{Unused,Binary}&lt;/code&gt; where &lt;code&gt;Unused&lt;/code&gt; denotes how many trailing zero-bits 0-7 that are unused in the least significant byte in &lt;code&gt;Binary&lt;/code&gt;. This format is accepted as input to the encode functions, and a &lt;code&gt;BIT STRING&lt;/code&gt; is decoded to this format if &lt;code&gt;compact_bit_string&lt;/code&gt; has been given.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40263cdf47a643660bd823252e4e54341b4e8e99" translate="yes" xml:space="preserve">
          <source>As Erl_Interface operates on the Erlang external term format, the port must be set to use binaries.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf5866c25e866f9c6f9b119f63b598360bcc9ad6" translate="yes" xml:space="preserve">
          <source>As Erlang has a fixed number of types, there is no need for a programmer to define a specification for the external format used within some application. All Erlang terms have an external representation and the interpretation of the different terms is application-specific.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7e5143ee8610dc021b9a09e083dc533d485e207" translate="yes" xml:space="preserve">
          <source>As a &lt;code&gt;simple_one_for_one&lt;/code&gt; supervisor can have many children, it shuts them all down asynchronously. This means that the children do their cleanup in parallel, and therefore the order in which they are stopped is not defined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2fd4a4764c6e535778fe8db9cbb1523710b87e3" translate="yes" xml:space="preserve">
          <source>As a NIF library is dynamically linked into the emulator process, this is the fastest way of calling C-code from Erlang (alongside port drivers). Calling NIFs requires no context switches. But it is also the least safe, because a crash in a NIF brings the emulator down too.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58e7b3f109198992ba59bec647e67726857b68a0" translate="yes" xml:space="preserve">
          <source>As a complement to the &lt;code&gt;set&lt;/code&gt; operation, it is possible to specify a test function. This function has the same syntax as the set operation above, except that the first argument is &lt;code&gt;is_set_ok&lt;/code&gt; instead of &lt;code&gt;set&lt;/code&gt;. This function is called before the variable is set. Its purpose is to ensure that it is permissible to set the variable to the new value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2948bceb43ecea497f0a445923a501687c512364" translate="yes" xml:space="preserve">
          <source>As a convenient shorthand, if any option settings are required at the start of a non-capturing subpattern, the option letters can appear between &quot;?&quot; and &quot;:&quot;. Thus, the following two patterns match the same set of strings:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6848c0bdaadb93a4b8d51c18e19a86434987f9a" translate="yes" xml:space="preserve">
          <source>As a convention, all I/O servers handle both &lt;code&gt;{setopts, [binary]}&lt;/code&gt;, &lt;code&gt;{setopts, [list]}&lt;/code&gt;, and &lt;code&gt;{setopts,[{binary, boolean()}]}&lt;/code&gt;, hence the trick with &lt;code&gt;proplists:substitute_negations/2&lt;/code&gt; and &lt;code&gt;proplists:unfold/1&lt;/code&gt;. If invalid options are sent to us, we send &lt;code&gt;{error, enotsup}&lt;/code&gt; back to the client.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="493adbb575cc27e47dde3943edacdea5778a9cf8" translate="yes" xml:space="preserve">
          <source>As a final example we demonstrate the use of &lt;code&gt;driver_async&lt;/code&gt;. We also use the driver term interface. The driver is written in C++. This enables us to use an algorithm from STL. We use the &lt;code&gt;next_permutation&lt;/code&gt; algorithm to get the next permutation of a list of integers. For large lists (&amp;gt; 100,000 elements), this takes some time, so we perform this as an asynchronous task.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1f3df7ed28f00795df09b73036126e4e8c30a4d" translate="yes" xml:space="preserve">
          <source>As a hexadecimal number (or an integer). Avoid this as it is easy to misinterpret a &lt;code&gt;BIT STRING&lt;/code&gt; value in this format.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7085268ee258ef21d5f659dd9a334d1661d8596c" translate="yes" xml:space="preserve">
          <source>As a last resort, the implementation solely based on the &lt;code&gt;gcc&lt;/code&gt;&lt;code&gt;__sync_*&lt;/code&gt; builtins. This will however cause lots of expensive and unnecessary memory barrier instructions to be issued. That is, performance will suffer. The &lt;code&gt;configure&lt;/code&gt; script will warn at the end of its execution if it cannot find any other alternative than this.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ebe4b26b3285c31b7e66a15f34435eba521d186d" translate="yes" xml:space="preserve">
          <source>As a match specification can turn on sequential tracing, the combination of &lt;code&gt;dbg&lt;/code&gt; and &lt;code&gt;seq_trace&lt;/code&gt; can be quite powerful. This brief example shows a session where sequential tracing is used:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57ca2c648144ecb05c83959a4bb6906fc7dba92e" translate="yes" xml:space="preserve">
          <source>As a part of the &lt;code&gt;add_frag&lt;/code&gt; procedure, Mnesia iterates over all fragments corresponding to the &lt;code&gt;IterFrags&lt;/code&gt; numbers and starts &lt;code&gt;key_to_frag_number(NewState,RecordKey)&lt;/code&gt; for each record. If the new fragment differs from the old fragment, the record is moved to the new fragment.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="afa5aac0272b889e29ab3d3e2445e190b23afd3b" translate="yes" xml:space="preserve">
          <source>As a part of the &lt;code&gt;del_frag&lt;/code&gt; procedure, Mnesia iterates over all fragments corresponding to the &lt;code&gt;IterFrags&lt;/code&gt; numbers and starts &lt;code&gt;key_to_frag_number(NewState,RecordKey)&lt;/code&gt; for each record. If the new fragment differs from the old fragment, the record is moved to the new fragment.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1a32b7616ffad81dc2a3990b12ee743d67d1150" translate="yes" xml:space="preserve">
          <source>As a port driver is dynamically linked into the emulator process, this is the fastest way of calling C-code from Erlang. Calling functions in the port driver requires no context switches. But it is also the least safe way, because a crash in the port driver brings the emulator down too.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67c16b741f04ea5b7b054409fb35ff1c48cb01da" translate="yes" xml:space="preserve">
          <source>As a side effect, the function prints the name of each module it tries to compile. If compilation fails for a module, the make procedure stops and &lt;code&gt;error&lt;/code&gt; is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bef2be0aff2e7e47dd8199f96ca616049e6fbecf" translate="yes" xml:space="preserve">
          <source>As a special case, &lt;code&gt;{message, false}&lt;/code&gt; disables sending of trace messages ('call' and 'return_to') for this function call, just like if the match specification had not matched. This can be useful if only the side effects of the &lt;code&gt;MatchBody&lt;/code&gt; part are desired.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc75067c89eb230d3aeaa930304e48d7ffc6b8ce" translate="yes" xml:space="preserve">
          <source>As a special case, drivers can be unloaded from processes that have done no corresponding call to &lt;code&gt;try_load/3&lt;/code&gt; if, and only if, there are &lt;strong&gt;no users of the driver at all&lt;/strong&gt;, which can occur if the process containing the last user dies.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5a63aa06a92181b3a5ed95aec64c64b4bdd7c17" translate="yes" xml:space="preserve">
          <source>As a special case, the following apply in the &lt;code&gt;MatchCondition/MatchBody&lt;/code&gt; parts:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03b85735e71929e52331dbf92e7f4188f735f3c7" translate="yes" xml:space="preserve">
          <source>As a test suite runs, all information (including output to &lt;code&gt;stdout&lt;/code&gt;) is recorded in many different log files. A minimum of information is displayed in the user console (only start and stop information, plus a note for each failed test case).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af27c23232c9332dfe458eed56f4e4ca1c250964" translate="yes" xml:space="preserve">
          <source>As all operations performed by Dets are disk operations, it is important to realize that a single look-up operation involves a series of disk seek and read operations. The Dets functions are therefore much slower than the corresponding &lt;code&gt;&lt;a href=&quot;ets&quot;&gt;ets(3)&lt;/a&gt;&lt;/code&gt; functions, although Dets exports a similar interface.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb95848bc99a15bbb0e15871e436bb30c7e336fc" translate="yes" xml:space="preserve">
          <source>As alternative branches are tried from left to right, and options are not reset until the end of the subpattern is reached, an option setting in one branch does affect subsequent branches, so the above patterns match both &quot;SUNDAY&quot; and &quot;Saturday&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c01043c234b4ec0c86a33f6ba721a734f751f6e" translate="yes" xml:space="preserve">
          <source>As an alternative to &lt;code&gt;-pa&lt;/code&gt;, if several directories are to be prepended to the code path and the directories have a common parent directory, that parent directory can be specified in environment variable &lt;code&gt;ERL_LIBS&lt;/code&gt;; see &lt;code&gt;code(3)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88dc064e87e4d93064611ba4390a686486fbcb39" translate="yes" xml:space="preserve">
          <source>As an alternative to building a bootscript, you can explicitly add the path to the SSL &lt;code&gt;ebin&lt;/code&gt; directory on the command line. This is done with command-line option &lt;code&gt;-pa&lt;/code&gt;. This works as the SSL application does not need to be started for the distribution to come up, as a clone of the SSL application is hooked into the Kernel application. So, as long as the SSL application code can be reached, the distribution starts. The &lt;code&gt;-pa&lt;/code&gt; method is only recommended for testing purposes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99c43706bedf3f37ba2bc1f77eaef7f141bffa35" translate="yes" xml:space="preserve">
          <source>As an alternative to sorting files, a function of one argument can be specified as input. When called with argument &lt;code&gt;read&lt;/code&gt;, the function is assumed to return either of the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa2f69a7cd9917454bfd5b22b175f310f6d2bfae" translate="yes" xml:space="preserve">
          <source>As an alternative to the &lt;code&gt;-callback&lt;/code&gt; and &lt;code&gt;-optional_callbacks&lt;/code&gt; attributes you may directly implement and export &lt;code&gt;behaviour_info()&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c35ac71302602496215802d2ceb07a268d8ab46b" translate="yes" xml:space="preserve">
          <source>As an alternative, an already open TCP socket could be passed to the function in &lt;code&gt;TcpSocket&lt;/code&gt;. The SSH initiation and negotiation will be initiated on that one and finaly a shell will be started on the host at the other end of the TCP socket.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="310627ae72667d56b80e90bfe9262f70c174ac28" translate="yes" xml:space="preserve">
          <source>As an alternative, an already open TCP socket could be passed to the function in &lt;code&gt;TcpSocket&lt;/code&gt;. The SSH initiation and negotiation will be initiated on that one when an SSH starts at the other end of the TCP socket.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="273b6d8022e0a14e661c5ebb9acfcaf89acecfbc" translate="yes" xml:space="preserve">
          <source>As an alternative, an already open TCP socket could be passed to the function in &lt;code&gt;TcpSocket&lt;/code&gt;. The SSH initiation and negotiation will be initiated on that one with the SSH that should be at the other end.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0d2d299871acdd7ed8b13c9605799bbdca8d746" translate="yes" xml:space="preserve">
          <source>As an example let's add the Diffie-Hellman Group1 first in the kex list. It is supported according to &lt;code&gt;Supported algoritms&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9fed952b378ed463bdf14ff665fe8061e73af37b" translate="yes" xml:space="preserve">
          <source>As an example of analyzing indirect calls, the following Erlang function tries to answer the question: if we want to know which modules are used indirectly by some module(s), is it worth while using the &lt;code&gt;&lt;a href=&quot;xref#call_graph&quot;&gt;function graph&lt;/a&gt;&lt;/code&gt; rather than the module graph? Recall that a module M1 is said to call a module M2 if there is some function in M1 that calls some function in M2. It would be nice if we could use the much smaller module graph, since it is available also in the light weight &lt;code&gt;modules&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;xref#mode&quot;&gt;mode&lt;/a&gt;&lt;/code&gt; of Xref servers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9dcf4f61625ae0867c30f6f2ec1a54ebcaa12ae" translate="yes" xml:space="preserve">
          <source>As an example of how the function can be used, we create an interpreted escript that uses &lt;code&gt;emu_args&lt;/code&gt; to set some emulator flag. In this case, it happens to disable the &lt;code&gt;smp_support&lt;/code&gt;. We also extract the different sections from the newly created script:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93e8253d4bef52c01714100b16613baca9f2eb65" translate="yes" xml:space="preserve">
          <source>As an example of how to use function &lt;code&gt;&lt;a href=&quot;#table-2&quot;&gt;table/2&lt;/a&gt;&lt;/code&gt;, the implementation of a QLC table for the &lt;code&gt;&lt;a href=&quot;gb_trees&quot;&gt;gb_trees&lt;/a&gt;&lt;/code&gt; module is given:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7686e8d3cae0d8b83f082414847869122b1c718" translate="yes" xml:space="preserve">
          <source>As an example of the default behavior, the following call returns, as first and only captured string, the matching part of the subject (&quot;abcd&quot; in the middle) as an index pair &lt;code&gt;{3,4}&lt;/code&gt;, where character positions are zero-based, just as in offsets:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1363c4916ced9b1c12e495d959e392b062a979b7" translate="yes" xml:space="preserve">
          <source>As an example of these rules, suppose you want to write the function &lt;code&gt;select&lt;/code&gt;, which selects certain elements from a list of tuples. Suppose you write &lt;code&gt;select(X, L) -&amp;gt; [Y || {X, Y} &amp;lt;- L].&lt;/code&gt; with the intention of extracting all tuples from &lt;code&gt;L&lt;/code&gt;, where the first item is &lt;code&gt;X&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d77fac41d8f6ac13e4c80ca8e1c35a37d97d30a" translate="yes" xml:space="preserve">
          <source>As an example, assume that the old maximum number of files is 10 and that the new maximum number of files is 6. If the current file number is not greater than the new maximum number of files, files 7-10 are removed when file 6 is full and the log starts to write to file number 1 again. Otherwise, the files greater than the current file are removed when the current file is full (for example, if the current file is 8, files 9 and 10 are removed). The files between the new maximum number of files and the current file (that is, files 7 and 8) are removed the next time file 6 is full.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6df1dd563dff5d559d5237ab7b1799899d2a4427" translate="yes" xml:space="preserve">
          <source>As an example, consider sorting the terms on a disk log file. A function that reads chunks from the disk log and returns a list of binaries is used as input. The results are collected in a list of terms.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ef05760a87925d5316892398ba7e6735c0cc668" translate="yes" xml:space="preserve">
          <source>As an example, consider the following record definition:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0bace29d40d7981ee102e27dfe23de3fe372b080" translate="yes" xml:space="preserve">
          <source>As an example, contemplate the issue of converting between upper and lower case letters. Reading the standard makes you realize that there is not a simple one to one mapping in all scripts, for example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e81b4992cba2b699d381459f734b8216213b6b3" translate="yes" xml:space="preserve">
          <source>As an example, list comprehensions can be used to simplify some of the functions in &lt;code&gt;lists.erl&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1e3067854a4c9b6a2c74afda818dcdb334e651b" translate="yes" xml:space="preserve">
          <source>As an example, one can insert an object with &lt;code&gt;integer()&lt;/code&gt;&lt;code&gt;1&lt;/code&gt; as a key in an &lt;code&gt;ordered_set&lt;/code&gt; and get the object returned as a result of doing a &lt;code&gt;lookup/2&lt;/code&gt; with &lt;code&gt;float()&lt;/code&gt;&lt;code&gt;1.0&lt;/code&gt; as the key to search for.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66fc66c449548ea231626daea7c93210ea8cbc49" translate="yes" xml:space="preserve">
          <source>As an example, one can let trace messages be sent over the network to another Erlang node (preferably &lt;strong&gt;not&lt;/strong&gt; distributed), where the formatting occurs:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7c1111ab56bf671a69f40fa390abccb417d88d6" translate="yes" xml:space="preserve">
          <source>As an example, suppose that you want to start a slave node at host &lt;code&gt;H&lt;/code&gt; with node name &lt;code&gt;Name@H&lt;/code&gt; and want the slave node to have the following properties:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f6e43ba50d78085627070b9be2ee7833e58261c" translate="yes" xml:space="preserve">
          <source>As an example, the I/O server for the interactive shell (in &lt;code&gt;group.erl&lt;/code&gt;) understands the following options:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d726847c4d6dbe66ba80230721adc5bfacc18e04" translate="yes" xml:space="preserve">
          <source>As an example, we will use the following function, that you may recognise as a slightly modified benchmark function from the manpage file(3):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67171017e640943dfb29d4cbec09fb767fa51114" translate="yes" xml:space="preserve">
          <source>As an snmp adaption usually keeps the index for the whole of the systems lifetime, this is rarely a problem.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="319bb3abd29884b1375ba09774a3c06c1a190a13" translate="yes" xml:space="preserve">
          <source>As another example, consider concatenating the answers to two queries &lt;code&gt;QH1&lt;/code&gt; and &lt;code&gt;QH2&lt;/code&gt; while removing all duplicates. This is accomplished by using option &lt;code&gt;unique&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="002e4414e669ace8432711f4ee7463efc45a9f68" translate="yes" xml:space="preserve">
          <source>As any other type of scripts, Erlang scripts do not work on Unix platforms if the execution bit for the script file is not set. (To turn on the execution bit, use &lt;code&gt;chmod +x script-name&lt;/code&gt;.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66b2e146ed4ec9e49f678bedfee3350f88534599" translate="yes" xml:space="preserve">
          <source>As any variable that occurs in the head of a fun is considered a new variable, it is equally valid to write as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90f853228a72190e3c182428d8aa021055665aa1" translate="yes" xml:space="preserve">
          <source>As can be noted above, the parameter list can be matched against a single &lt;code&gt;MatchVariable&lt;/code&gt; or an &lt;code&gt;'_'&lt;/code&gt;. To replace the whole parameter list with a single variable is a special case. In all other cases the &lt;code&gt;MatchHead&lt;/code&gt; must be a &lt;strong&gt;proper&lt;/strong&gt; list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f45447aff436963dfcba66b79f762faf452d90b1" translate="yes" xml:space="preserve">
          <source>As can be seen from the figures above there is no real difference between a non-reentrant and an reentrant flex scanner when it comes to the decode times of an individual message.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f43e75c9b3fbee4477b49b641a7fb630b3c13f5" translate="yes" xml:space="preserve">
          <source>As can be seen, the fun used with &lt;code&gt;dbg:fun2ms/1&lt;/code&gt; takes a single list as parameter instead of a single tuple. The list matches a list of the parameters to the traced function. A single variable can also be used. The body of the fun expresses, in a more imperative way, actions to be taken if the fun head (and the guards) matches. &lt;code&gt;true&lt;/code&gt; is returned here, only because the body of a fun cannot be empty. The return value is discarded.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="606f60b3cba3318c2eecb57b2a49a6b6b1a39eb6" translate="yes" xml:space="preserve">
          <source>As can be seen, the functions above are just the type of functions that are to be provided in &lt;code&gt;get_until&lt;/code&gt; requests.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="191e8e1e5a9e73a6798b23edb476be7abc2c9de8" translate="yes" xml:space="preserve">
          <source>As default result sets are returned as a lists of tuples. The &lt;code&gt;TupleMode&lt;/code&gt; option still exists to keep some degree of backwards compatibility. If the option is set to off, result sets will be returned as a lists of lists instead of a lists of tuples.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17700b7b2c5191dc7a064a620902163dd840f68f" translate="yes" xml:space="preserve">
          <source>As described in Robert's paper, I/O servers and clients communicate using &lt;code&gt;io_request&lt;/code&gt;/&lt;code&gt;io_reply&lt;/code&gt; tuples as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5e4f17183134fe62fa988455bb38a208a7f52d2" translate="yes" xml:space="preserve">
          <source>As documented, the election assumes knowledge of a peer's DiameterIdentity when initiating a connection, which diameter doesn't require. Connections will be accepted if configuration allows multiple connections per peer to be established or there is no existing connection. Note that the election process is only applicable when multiple connections per peer is disallowed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5435f11ff35ae6054509834ff9cbbd3dacb50a82" translate="yes" xml:space="preserve">
          <source>As each event handler is one callback module, an event manager has many callback modules that are added and deleted dynamically. &lt;code&gt;gen_event&lt;/code&gt; is therefore more tolerant of callback module errors than the other behaviors. If a callback function for an installed event handler fails with &lt;code&gt;Reason&lt;/code&gt;, or returns a bad value &lt;code&gt;Term&lt;/code&gt;, the event manager does not fail. It deletes the event handler by calling callback function &lt;code&gt;&lt;a href=&quot;#Module:terminate-2&quot;&gt;Module:terminate/2&lt;/a&gt;&lt;/code&gt;, giving as argument &lt;code&gt;{error,{'EXIT',Reason}}&lt;/code&gt; or &lt;code&gt;{error,Term}&lt;/code&gt;, respectively. No other event handler is affected.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf9e38f9c03cb4cfe6ebeed4a9cd9c1754bcff3e" translate="yes" xml:space="preserve">
          <source>As evaluating this function causes the process to terminate, it has no return value unless the arguments are invalid, in which case the function &lt;strong&gt;returns the error reason&lt;/strong&gt;&lt;code&gt;badarg&lt;/code&gt;. If you want to be sure not to return, you can call &lt;code&gt;error(erlang:raise(Class, Reason, Stacktrace))&lt;/code&gt; and hope to distinguish exceptions later.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2842aa39be48bf38b0c0560d59180375acac20be" translate="yes" xml:space="preserve">
          <source>As everyone trying to use &lt;code&gt;&lt;a href=&quot;ets#select-1&quot;&gt;ets:select/2&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;dbg&lt;/code&gt; seems to end up reading this manual page, this description is an introduction to the concept of match specifications.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91ed2cd090a035beba9495ca5c354901e71094c0" translate="yes" xml:space="preserve">
          <source>As expected, double of 10 is 20.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e58a012dddf03e3db23dd481662a4b03cf78027" translate="yes" xml:space="preserve">
          <source>As far as we know by the time of writing, it is infeasible to break &lt;code&gt;des3_cbc&lt;/code&gt; encryption without any knowledge of the key. Therefore, as long as the key is kept safe and is unguessable, the encrypted debug information &lt;strong&gt;should&lt;/strong&gt; be safe from intruders.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f24794a82149383ffae0568581aa4a52378ab67" translate="yes" xml:space="preserve">
          <source>As file times are stored in POSIX time on most OS, it is faster to query file information with option &lt;code&gt;posix&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61df7f84fe1d4826c5be72f8b4bc768821e8d381" translate="yes" xml:space="preserve">
          <source>As for &lt;code&gt;i/1&lt;/code&gt; and &lt;code&gt;ni/1&lt;/code&gt;, a module can be specified by its module name or filename.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a8f23a48e1867cb7be6b7e031f9615ed3dd2a0d" translate="yes" xml:space="preserve">
          <source>As for &lt;code&gt;select&lt;/code&gt;, the table is traversed by calling &lt;code&gt;&lt;a href=&quot;#select-3&quot;&gt;select/3&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#select-1&quot;&gt;select/1&lt;/a&gt;&lt;/code&gt;. The difference is that the match specification is explicitly specified. This is how to state match specifications that cannot easily be expressed within the syntax provided by QLC.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0387e8c16bce6477d55e9ca9b7e7cb6c002c7dd" translate="yes" xml:space="preserve">
          <source>As from ERTS 5.10 all signals from processes to ports are truly asynchronously delivered.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9113f3079af7b202922889fc7baf1985e8c3b0f" translate="yes" xml:space="preserve">
          <source>As from ERTS 5.5 (Erlang/OTP R11B), this value does not include reductions performed in current time slices of currently scheduled processes. If an exact value is wanted, use &lt;code&gt;&lt;a href=&quot;#statistics_exact_reductions&quot;&gt;statistics(exact_reductions)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9466fb03b2f8f448def70765eb14302f05b1d4a" translate="yes" xml:space="preserve">
          <source>As from ERTS 5.5.2 exit signals to processes are truly asynchronously delivered.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d8b23980173959043ec4b6b8e4640034ae1c36c" translate="yes" xml:space="preserve">
          <source>As from ERTS 5.5.3 the driver interface has been extended (see &lt;code&gt;&lt;a href=&quot;driver_entry#extended_marker&quot;&gt;extended marker&lt;/a&gt;&lt;/code&gt;). The extended interface introduces &lt;code&gt;&lt;a href=&quot;#version_management&quot;&gt;version management&lt;/a&gt;&lt;/code&gt;, the possibility to pass capability flags (see &lt;code&gt;&lt;a href=&quot;driver_entry#driver_flags&quot;&gt;driver_flags&lt;/a&gt;&lt;/code&gt;) to the runtime system at driver initialization, and some new driver API functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19ca09aeee3e5a4978501284aa2a30557b389ea8" translate="yes" xml:space="preserve">
          <source>As from ERTS 5.5.3 the driver interface was extended with version control and the possibility to pass capability information. Capability flags are present on line 48. As from ERTS 5.7.4 flag &lt;code&gt;&lt;a href=&quot;driver_entry#driver_flags&quot;&gt;ERL_DRV_FLAG_SOFT_BUSY&lt;/a&gt;&lt;/code&gt; is required for drivers that are to be used by the distribution. The soft busy flag implies that the driver can handle calls to the &lt;code&gt;output&lt;/code&gt; and &lt;code&gt;outputv&lt;/code&gt; callbacks although it has marked itself as busy. This has always been a requirement on drivers used by the distribution, but no capability information has been available about this previously. For more information. see &lt;code&gt;&lt;a href=&quot;erl_driver#set_busy_port&quot;&gt;erl_driver:set_busy_port()&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a78fa09b1376522e4bce196c1fb535907b82e7d" translate="yes" xml:space="preserve">
          <source>As from ERTS 5.5.4.3 the default stack size for threads in the async-thread pool is 16 kilowords, that is, 64 kilobyte on 32-bit architectures. This small default size has been chosen because the amount of async-threads can be quite large. The default stack size is enough for drivers delivered with Erlang/OTP, but is possibly not sufficiently large for other dynamically linked-in drivers that use the &lt;code&gt;driver_async&lt;/code&gt; functionality. A suggested stack size for threads in the async-thread pool can be configured through command-line argument &lt;code&gt;&lt;a href=&quot;erl#async_thread_stack_size&quot;&gt;+a&lt;/a&gt;&lt;/code&gt; in &lt;code&gt;&lt;a href=&quot;erl&quot;&gt;erl(1)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6e9cd2bd7de01214fb3ff560ba3219fdc3a33fd" translate="yes" xml:space="preserve">
          <source>As from ERTS 5.6.1 the emulator refuses to use this strategy on other allocators than &lt;code&gt;temp_alloc&lt;/code&gt;. This because it only causes problems for other allocators.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9cdb7d3c60a1b802e1be9fa56092fa96daa0110" translate="yes" xml:space="preserve">
          <source>As from ERTS 5.6.4, &lt;code&gt;erlang:memory/0&lt;/code&gt; requires that all &lt;code&gt;erts_alloc(3)&lt;/code&gt; allocators are enabled (default behavior).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0648017001664f8866e87e3887eab6500d7d8d5c" translate="yes" xml:space="preserve">
          <source>As from ERTS 5.6.4, &lt;code&gt;erlang:memory/1&lt;/code&gt; requires that all &lt;code&gt;&lt;a href=&quot;erts_alloc&quot;&gt;erts_alloc(3)&lt;/a&gt;&lt;/code&gt; allocators are enabled (default behavior).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03c3044d6f35884274a0ea9ce93bcb4a6dd2e7b8" translate="yes" xml:space="preserve">
          <source>As from ERTS 5.7.2 the old atom cache protocol was dropped and a new one was introduced. This protocol introduced the distribution header. Nodes with an ERTS version earlier than 5.7.2 can still communicate with new nodes, but no distribution header and no atom cache are used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0bf3fb747dbb4638699932cce5b52da0fd8c732" translate="yes" xml:space="preserve">
          <source>As from ERTS 5.7.2 the runtime system passes a distribution flag in the handshake stage that enables the use of a &lt;code&gt;&lt;a href=&quot;erl_ext_dist#distribution_header&quot;&gt;distribution header&lt;/a&gt;&lt;/code&gt; on all messages passed. Messages passed between nodes have in this case the following format:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32ca42b8d63db763c29dc94fc4d01b222bd06006" translate="yes" xml:space="preserve">
          <source>As from ERTS 5.9 (Erlang/OTP R15B) the driver interface has been changed with larger types for the callbacks &lt;code&gt;&lt;a href=&quot;#output&quot;&gt;output&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#control&quot;&gt;control&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;#call&quot;&gt;call&lt;/a&gt;&lt;/code&gt;. See driver &lt;code&gt;&lt;a href=&quot;erl_driver#version_management&quot;&gt;version management&lt;/a&gt;&lt;/code&gt; in &lt;code&gt;&lt;a href=&quot;erl_driver&quot;&gt;erl_driver&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed0ea6cc1d812d63e5d244adc339b28e36e76666" translate="yes" xml:space="preserve">
          <source>As from ERTS 5.9 (Erlang/OTP R15B) the runtime system does by default &lt;strong&gt;not&lt;/strong&gt; bind schedulers to logical processors. For more information, see system flag &lt;code&gt;&lt;a href=&quot;#+sbt&quot;&gt;+sbt&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90a69eabde7b774111db809b2a3f8cd2e6d93bb9" translate="yes" xml:space="preserve">
          <source>As from ERTS 5.9 old drivers must be recompiled and use the extended interface. They must also be adjusted to the &lt;code&gt;&lt;a href=&quot;#rewrites_for_64_bits&quot;&gt;64-bit capable driver interface&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d18bc1c72ccf3f56d64803c503d7a9ae14a8c4e0" translate="yes" xml:space="preserve">
          <source>As from ERTS 8.0 (Erlang/OTP 19), any lingering processes that still execute the old code is killed by this function. In earlier versions, such incorrect use could cause much more fatal failures, like emulator crash.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eaa0884ce96d8d06eafbfe246ea264efc463f164" translate="yes" xml:space="preserve">
          <source>As from ERTS 9.0 (OTP 20), atoms may contain any Unicode characters and are always encoded using the UTF-8 external formats &lt;code&gt;&lt;a href=&quot;#ATOM_UTF8_EXT&quot;&gt;ATOM_UTF8_EXT&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#SMALL_ATOM_UTF8_EXT&quot;&gt;SMALL_ATOM_UTF8_EXT&lt;/a&gt;&lt;/code&gt;. The old Latin-1 formats &lt;code&gt;&lt;a href=&quot;#ATOM_EXT&quot;&gt;ATOM_EXT&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#SMALL_ATOM_EXT&quot;&gt;SMALL_ATOM_EXT&lt;/a&gt;&lt;/code&gt; are deprecated and are only kept for backward compatibility when decoding terms encoded by older nodes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="432b2e5b8c0948df031dfa90355327eda74cb917" translate="yes" xml:space="preserve">
          <source>As from Erlang/OTP 17, the OTP release number corresponds to the major OTP version number. No &lt;code&gt;erlang:system_info()&lt;/code&gt; argument gives the exact OTP version. This is because the exact OTP version in the general case is difficult to determine. For more information, see the description of versions in &lt;code&gt;System principles&lt;/code&gt; in System Documentation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a73c626964af738d0bf5772ed44b01c65f1937d2" translate="yes" xml:space="preserve">
          <source>As from Erlang/OTP 18 (ERTS 7.0) the time functionality has been extended. This includes a &lt;code&gt;&lt;a href=&quot;#The_New_Time_API&quot;&gt;new API&lt;/a&gt;&lt;/code&gt; for time and &lt;code&gt;&lt;a href=&quot;#Time_Warp_Modes&quot;&gt;time warp modes&lt;/a&gt;&lt;/code&gt; that change the system behavior when system time changes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ecb4c90c54fe542574fe5a3d1dc6ac0bee28192e" translate="yes" xml:space="preserve">
          <source>As from Erlang/OTP 20, &lt;code&gt;String&lt;/code&gt; may contain any Unicode character. Earlier versions allowed only ISO-latin-1 characters as the implementation did not allow Unicode characters above 255. For more information on Unicode support in atoms, see &lt;code&gt;&lt;a href=&quot;erl_ext_dist#utf8_atoms&quot;&gt;note on UTF-8 encoded atoms&lt;/a&gt;&lt;/code&gt; in section &quot;External Term Format&quot; in the User's Guide.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a96169a26804822b5af1efdb6e68b574110fb9b3" translate="yes" xml:space="preserve">
          <source>As from Erlang/OTP 20, &lt;code&gt;binary_to_atom(Binary, utf8)&lt;/code&gt; is capable of encoding any Unicode character. Earlier versions would fail if the binary contained Unicode characters &amp;gt; 255. For more information about Unicode support in atoms, see the &lt;code&gt;&lt;a href=&quot;erl_ext_dist#utf8_atoms&quot;&gt;note on UTF-8 encoded atoms&lt;/a&gt;&lt;/code&gt; in section &quot;External Term Format&quot; in the User's Guide.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="880a395a4cc835daf564a6c2cb8b779237ad447e" translate="yes" xml:space="preserve">
          <source>As from Erlang/OTP 20, atoms can contain any Unicode character and &lt;code&gt;atom_to_binary(Atom, latin1)&lt;/code&gt; may fail if the text representation for &lt;code&gt;Atom&lt;/code&gt; contains a Unicode character &amp;gt; 255.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05e99f10299c611eb38d2e60ef290380c488aab4" translate="yes" xml:space="preserve">
          <source>As from Erlang/OTP 21.0, a field width of value &lt;code&gt;0&lt;/code&gt; can be used for specifying that a line is infinitely long, which means that no line breaks are inserted. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="201cedcfe08f8b8dd67e3f18b939fb9656e57837" translate="yes" xml:space="preserve">
          <source>As from Erlang/OTP R13A, data supplied to function &lt;code&gt;&lt;a href=&quot;#put_chars-2&quot;&gt;put_chars/2&lt;/a&gt;&lt;/code&gt; is to be in the &lt;code&gt;&lt;a href=&quot;unicode#type-chardata&quot;&gt;unicode:chardata()&lt;/a&gt;&lt;/code&gt; format. This means that programs supplying binaries to this function must convert them to UTF-8 before trying to output the data on an I/O device.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d33e90079df692505b294a1290c3639aac4d952d" translate="yes" xml:space="preserve">
          <source>As from Erlang/OTP R16, &lt;code&gt;Port ! {PortOwner, close}&lt;/code&gt; is truly asynchronous. Notice that this operation has always been documented as an asynchronous operation, while the underlying implementation has been synchronous. &lt;code&gt;port_close/1&lt;/code&gt; is however still fully synchronous because of its error behavior.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="847e19f07a1da0af86460018529c6ed10c09d277" translate="yes" xml:space="preserve">
          <source>As from Erlang/OTP R16, &lt;code&gt;Port ! {PortOwner, {command, Data}}&lt;/code&gt; is truly asynchronous. Notice that this operation has always been documented as an asynchronous operation, while the underlying implementation has been synchronous. &lt;code&gt;port_command/2&lt;/code&gt; is however still fully synchronous because of its error behavior.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ca95bf5c29d60d3f435edb308337e14ca27dfa7" translate="yes" xml:space="preserve">
          <source>As from Erlang/OTP R16, &lt;code&gt;Port ! {PortOwner, {connect, Pid}}&lt;/code&gt; is truly asynchronous. Notice that this operation has always been documented as an asynchronous operation, while the underlying implementation has been synchronous. &lt;code&gt;port_connect/2&lt;/code&gt; is however still fully synchronous because of its error behavior.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72f6bdc7a49b76220d72f254a24c40ac2103b81f" translate="yes" xml:space="preserve">
          <source>As from Erlang/OTP R16, Erlang source files can be written in UTF-8 or bytewise (&lt;code id=&quot;unicode_in_erlang&quot;&gt;latin1&lt;/code&gt;) encoding. For information about how to state the encoding of an Erlang source file, see the &lt;code&gt;epp(3)&lt;/code&gt; module. As from Erlang/OTP R16, strings and comments can be written using Unicode. As from Erlang/OTP 20, also atoms and functions can be written using Unicode. Modules, applications, and nodes must still be named using characters from the ISO Latin-1 character set. (These restrictions in the language are independent of the encoding of the source file.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7886b46a773db0e50442aecaebbaf32b222b9fd4" translate="yes" xml:space="preserve">
          <source>As from Erlang/OTP R16B you can select the ISO Latin-1 range or the whole Unicode range by supplying startup flag &lt;code&gt;+pc latin1&lt;/code&gt; or &lt;code&gt;+pc unicode&lt;/code&gt;, respectively. For backward compatibility, &lt;code&gt;latin1&lt;/code&gt; is default. This only controls how heuristic string detection is done. More ranges are expected to be added in the future, enabling tailoring of the heuristics to the language and region relevant to the user.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="716bfb66439cef7ad7bad31829606da528f05b26" translate="yes" xml:space="preserve">
          <source>As from Erlang/OTP R9C, the &lt;code&gt;abstract_code&lt;/code&gt; chunk contains &lt;code&gt;{raw_abstract_v1,AbstractCode}&lt;/code&gt;, where &lt;code&gt;AbstractCode&lt;/code&gt; is the abstract code as described in this section.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79439af412211da1e82f500e663913d9e02afa8d" translate="yes" xml:space="preserve">
          <source>As from Kernel version 2.11.4, and ERTS version 5.5.4, the following is guaranteed:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6086f606b9a19f3992ba56f0349c22f46bc841b" translate="yes" xml:space="preserve">
          <source>As from Kernel version 2.11.4, subscriptions can also be made before the &lt;code&gt;net_kernel&lt;/code&gt; server is started, that is, &lt;code&gt;net_kernel:monitor_nodes/[1,2]&lt;/code&gt; does not return &lt;code&gt;ignored&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a12edcd68388680c33d418efadc851c1c0e7b367" translate="yes" xml:space="preserve">
          <source>As from Kernel version 2.13, and ERTS version 5.7, the following is guaranteed:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c683a693696d1ac1e9f3a076bd2cf07e0602bc8" translate="yes" xml:space="preserve">
          <source>As from R14A and forward, the compiler resolves calls without module prefix to local or imported functions before trying with auto-imported BIFs. If the BIF is to be called, use the &lt;code&gt;erlang&lt;/code&gt; module prefix in the call, not &lt;code&gt;{no_auto_import,[{F,A}, ...]}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23bc1a56d40682c98cebd327d476b5499f2bfa45" translate="yes" xml:space="preserve">
          <source>As from beginning with R14A, the compiler no longer calls the auto-imported BIF if the name clashes with a local or explicitly imported function, and a call without explicit module name is issued. Instead, the local or imported function is called. Still accepting &lt;code&gt;nowarn_bif_clash&lt;/code&gt; would make a module calling functions clashing with auto-imported BIFs compile with both the old and new compilers, but with completely different semantics. This is why the option is removed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8624ad0f786ca708e353d31a82300424a2da173c" translate="yes" xml:space="preserve">
          <source>As functions are relations, the definitions of the last item (domain, range, and so on) apply to functions as well.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07695f74f1c383a64bbc45b6016faa64c5986911" translate="yes" xml:space="preserve">
          <source>As illustrated, properties can be combined. If, for example, &lt;code&gt;shuffle&lt;/code&gt;, &lt;code&gt;repeat_until_any_fail&lt;/code&gt;, and &lt;code&gt;sequence&lt;/code&gt; are all specified, the test cases in the group are executed repeatedly, and in random order, until a test case fails. Then execution is immediately stopped and the remaining cases are skipped.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68fe7148f0f6ccc13bf1a24fdc690584b0a600f5" translate="yes" xml:space="preserve">
          <source>As illustrated, the two directories reside on different nodes, because &lt;code&gt;/ldisc/scratch&lt;/code&gt; (the &quot;local&quot; disc) exists on the two different nodes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2998e8a048230bd280f5294610d17bc1bd53ffb" translate="yes" xml:space="preserve">
          <source>As in &lt;code&gt;&lt;a href=&quot;#run-3&quot;&gt;run/3&lt;/a&gt;&lt;/code&gt;, an &lt;code&gt;mp()&lt;/code&gt; compiled with option &lt;code&gt;unicode&lt;/code&gt; requires &lt;code&gt;Subject&lt;/code&gt; to be a Unicode &lt;code&gt;charlist()&lt;/code&gt;. If compilation is done implicitly and the &lt;code&gt;unicode&lt;/code&gt; compilation option is specified to this function, both the regular expression and &lt;code&gt;Subject&lt;/code&gt; are to be specified as valid Unicode &lt;code&gt;charlist()&lt;/code&gt;s.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="466e0ad8d0c7cbd5f38b33d59e9622626664550d" translate="yes" xml:space="preserve">
          <source>As in Erlang, messages can be sent to a pid or to a registered name. It is easier to send a message to a registered name, as it avoids the problem of finding a suitable pid.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4d88e181201a03cc3fb7ded4e3d176b1c280bd5" translate="yes" xml:space="preserve">
          <source>As in construction, the order in which the key and value expressions are evaluated is not defined. The syntactic order of the key-value pairs in the update is of no relevance, except in the case where two keys match. In that case, the latter value is used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc2ecf4ab7dc9e0eae158ae04299a70b115b03c8" translate="yes" xml:space="preserve">
          <source>As in function &lt;code&gt;run/3&lt;/code&gt;, an &lt;code&gt;mp()&lt;/code&gt; compiled with option &lt;code&gt;unicode&lt;/code&gt; requires &lt;code&gt;Subject&lt;/code&gt; to be a Unicode &lt;code&gt;charlist()&lt;/code&gt;. If compilation is done implicitly and the &lt;code&gt;unicode&lt;/code&gt; compilation option is specified to this function, both the regular expression and &lt;code&gt;Subject&lt;/code&gt; are to specified as valid Unicode &lt;code&gt;charlist()&lt;/code&gt;s.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3af4e7ec9b32aca75bcf09376c862c57bf6062d9" translate="yes" xml:space="preserve">
          <source>As in ordinary Erlang matching, you can bind a variable to the whole matched object using a &quot;match inside the match&quot;, that is, a &lt;code&gt;=&lt;/code&gt;. Unfortunately in funs translated to match specifications, it is allowed only at the &quot;top-level&quot;, that is, matching the &lt;strong&gt;whole&lt;/strong&gt; object arriving to be matched into a separate variable. If you are used to writing match specifications by hand, we mention that variable A is simply translated into '$_'. Alternatively, pseudo function &lt;code&gt;object/0&lt;/code&gt; also returns the whole matched object, see section &lt;code&gt;&lt;a href=&quot;#warnings_and_restrictions&quot;&gt;Warnings and Restrictions&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c43013c670a4d6155374f58258fab04f5fbbc072" translate="yes" xml:space="preserve">
          <source>As in the previous examples, it is your responsibility to free the memory allocated for Erlang terms. In this example, &lt;code&gt;erl_free_compound()&lt;/code&gt; ensures that the complete term pointed to by &lt;code&gt;ep&lt;/code&gt; is released. This is necessary because the pointer from the second call to &lt;code&gt;erl_format&lt;/code&gt; is lost.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d26ac3436bd27f40dd7ea34e33f65a20575923b6" translate="yes" xml:space="preserve">
          <source>As in the previous section the PEM file &lt;code&gt;&quot;/home/me/ssl/erlserver.pem&quot;&lt;/code&gt; contains both the server certificate and its private key.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="debb8560047fb0b42a46cc59f3c825a91b4209ba" translate="yes" xml:space="preserve">
          <source>As indicated by the name, emulator flags control the behavior of the emulator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f49bed7fb11b494819d4e36cc0258b2b542e095" translate="yes" xml:space="preserve">
          <source>As long as all character sets were limited to 256 characters, each character could be stored in one single byte, so there was more or less only one practical encoding for the characters. Encoding each character in one byte was so common that the encoding was not even named. With the Unicode system there are much more than 256 characters, so a common way is needed to represent these. The common ways of representing the code points are the encodings. This means a whole new concept to the programmer, the concept of character representation, which was a non-issue earlier.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b7153107281cf1e02599d91bf8553499b75800f" translate="yes" xml:space="preserve">
          <source>As long as real identifiers are correct, it is OK to pass a CPU topology that is not a correct description of the CPU topology. When used with care this can be very useful. This to trick the emulator to bind its schedulers as you want. For example, if you want to run multiple Erlang runtime systems on the same machine, you want to reduce the number of schedulers used and manipulate the CPU topology so that they bind to different logical CPUs. An example, with two Erlang runtime systems on a quad core machine:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a4531be2cf765e3ef8b54b63b05d246b380ee1c" translate="yes" xml:space="preserve">
          <source>As long as the &lt;code&gt;ftp&lt;/code&gt; application is operational, the FTP sessions are supervised and can be soft code upgraded.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b05ddb8fa8f81edfa35269196a6d393612d35a2a" translate="yes" xml:space="preserve">
          <source>As long as the data is always lists, modifier &lt;code&gt;t&lt;/code&gt; can be used for any string, but when binary data is involved, care must be taken to make the correct choice of formatting characters. A bytewise-encoded binary is also interpreted as a string, and printed even when using &lt;code&gt;~ts&lt;/code&gt;, but it can be mistaken for a valid UTF-8 string. Avoid therefore using the &lt;code&gt;~ts&lt;/code&gt; control if the binary contains bytewise-encoded characters and not UTF-8.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38beb3decd97936c9d002a776141659553006a04" translate="yes" xml:space="preserve">
          <source>As long as the length of the message queue is lower than this value, all log events are handled asynchronously. This means that the client process sending the log event, by calling a log function in the &lt;code&gt;&lt;a href=&quot;logger_chapter#logger_api&quot;&gt;Logger API&lt;/a&gt;&lt;/code&gt;, does not wait for a response from the handler but continues executing immediately after the event is sent. It is not affected by the time it takes the handler to print the event to the log device. If the message queue grows larger than this value, the handler starts handling log events synchronously instead, meaning that the client process sending the event must wait for a response. When the handler reduces the message queue to a level below the &lt;code&gt;sync_mode_qlen&lt;/code&gt; threshold, asynchronous operation is resumed. The switch from asynchronous to synchronous mode can slow down the logging tempo of one, or a few, busy senders, but cannot protect the handler sufficiently in a situation of many busy concurrent senders.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb54073b5c596b75c4d1032a2bc0e471288f7302" translate="yes" xml:space="preserve">
          <source>As long as there are no more than 16 schedulers, there will never be any lock contention on the port lock for the driver.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4b29322baa56d4c7a0700a6dec611b4da2d64c8" translate="yes" xml:space="preserve">
          <source>As many options are silently discarded by the stack if they are specified out of range; it can be a good idea to check that a raw option is accepted. The following code places the value in variable &lt;code&gt;TcpLinger2:&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cde1dbb415595f7822eb3d191139162bdd23a109" translate="yes" xml:space="preserve">
          <source>As matching proceeds from left to right, PCRE looks for each &quot;a&quot; in the subject and then sees if what follows matches the remaining pattern. If the pattern is specified as</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ca1c79babb9a0075f407b28d68680d2a199070e" translate="yes" xml:space="preserve">
          <source>As md5 is not available in FIPS mode it is only possible to use certificates that were signed using sha hashing. When validating an entire certificate chain all certificates (including the root CA's) must comply with this rule.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7c08fa4650f0a0fe94395e21e9822cf60a9f2f7" translate="yes" xml:space="preserve">
          <source>As mentioned earlier, a script can contains precompiled &lt;code&gt;beam&lt;/code&gt; code. In a precompiled script, the interpretation of the script header is the same as in a script containing source code. This means that you can make a &lt;code&gt;beam&lt;/code&gt; file executable by prepending the file with the lines starting with &lt;code&gt;#!&lt;/code&gt; and &lt;code&gt;%%!&lt;/code&gt; mentioned above. In a precompiled script, the &lt;code&gt;main/1&lt;/code&gt; function must be exported.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64feb9f4a1acc565bd79ae07225ce3ec20e86066" translate="yes" xml:space="preserve">
          <source>As mentioned earlier, queries are expressed in the list comprehension syntax as described in section &lt;code&gt;Expressions&lt;/code&gt; in Erlang Reference Manual. In the following, some familiarity with list comprehensions is assumed. The examples in section &lt;code&gt;List Comprehensions&lt;/code&gt; in Programming Examples can get you started. Notice that list comprehensions do not add any computational power to the language; anything that can be done with list comprehensions can also be done without them. But they add syntax for expressing simple search problems, which is compact and clear once you get used to it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dcc63d308b096795c5804a0be71fa661e287ba90" translate="yes" xml:space="preserve">
          <source>As mentioned earlier, segments have the following general syntax:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68d171b0ef9d17830114bdb2e45fbb538d0990d4" translate="yes" xml:space="preserve">
          <source>As mentioned in the &lt;code id=&quot;lengthy_work&quot;&gt;&lt;a href=&quot;#WARNING&quot;&gt;warning&lt;/a&gt;&lt;/code&gt; text at the beginning of this section, it is of vital importance that a driver callback returns relatively fast. It is difficult to give an exact maximum amount of time that a driver callback is allowed to work, but usually a well-behaving driver callback is to return within 1 millisecond. This can be achieved using different approaches. If you have full control over the code to execute in the driver callback, the best approach is to divide the work into multiple chunks of work, and trigger multiple calls to the &lt;code&gt;&lt;a href=&quot;driver_entry#timeout&quot;&gt;time-out callback&lt;/a&gt;&lt;/code&gt; using zero time-outs. Function &lt;code&gt;&lt;a href=&quot;#erl_drv_consume_timeslice&quot;&gt;erl_drv_consume_timeslice&lt;/a&gt;&lt;/code&gt; can be useful to determine when to trigger such time-out callback calls. However, sometimes it cannot be implemented this way, for example when calling third-party libraries. In this case, you typically want to dispatch the work to another thread. Information about thread primitives is provided below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="870908039e217eddb9cd9dd34c7a2a0d9565d41f" translate="yes" xml:space="preserve">
          <source>As mentioned in the &lt;code&gt;&lt;a href=&quot;#WARNING&quot;&gt;warning&lt;/a&gt;&lt;/code&gt; text at the beginning of this manual page, it is of &lt;strong&gt;vital importance&lt;/strong&gt; that a native function returns relatively fast. It is difficult to give an exact maximum amount of time that a native function is allowed to work, but usually a well-behaving native function is to return to its caller within 1 millisecond. This can be achieved using different approaches. If you have full control over the code to execute in the native function, the best approach is to divide the work into multiple chunks of work and call the native function multiple times. This is, however, not always possible, for example when calling third-party libraries.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d72cf22161ff39dc24cc56c84b763eb1ee94488" translate="yes" xml:space="preserve">
          <source>As of &lt;code&gt;Inets&lt;/code&gt; 5.0 the HTTP server is an easy to start/stop and customize web server providing the most basic web server functionality. Inets is designed for embedded systems and if you want a full-fledged web server there are exists other erlang open source alternatives.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0209ca89965504887d9fa6f1d52589a2103d8bad" translate="yes" xml:space="preserve">
          <source>As of ERTS version 10.0 support for distribution controller processes has been introduced. That is, the traffic over a distribution channel can be managed by a process instead of only by a port. This makes it possible to implement large parts of the logic in Erlang code, and you perhaps do not even need a new driver for the protocol. One example could be Erlang distribution over UDP using &lt;code&gt;gen_udp&lt;/code&gt; (your Erlang code will of course have to take care of retranspissions, etc in this example). That is, depending on what you want to do you perhaps do not need to implement a driver at all and can then skip the driver related sections below. The &lt;code&gt;gen_tcp_dist&lt;/code&gt; example described in the &lt;code&gt;&lt;a href=&quot;#distribution_module&quot;&gt;Distribution Module&lt;/a&gt;&lt;/code&gt; section utilize distribution controller processes and can be worth having a look at if you want to use distribution controller processes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c85a6ebe0161eb5757b5cd028db5ba4081c57741" translate="yes" xml:space="preserve">
          <source>As of ERTS version 9.0, a process is only considered to be lingering in the code if it has direct references to the code. For more information see documentation of &lt;code&gt;erlang:check_process_code/3&lt;/code&gt;, which is used in order to determine this.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="990b2f43003907f6ffa2fd600f8b8c5f6d4c0c81" translate="yes" xml:space="preserve">
          <source>As of ERTS version 9.0, also dirty CPU schedulers will be included in the result. That is, all scheduler threads that are expected to handle CPU bound work. If you also want information about dirty I/O schedulers, use &lt;code&gt;&lt;a href=&quot;#statistics_scheduler_wall_time_all&quot;&gt;statistics(scheduler_wall_time_all)&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="924b8134638ed9edf16b9abf6ee2f7cc8660dc0a" translate="yes" xml:space="preserve">
          <source>As of ERTS version 9.0, the Erlang runtime system will as default have more schedulers than logical processors. This due to the dirty schedulers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf90680c064454d2c96d45dd08744df7108b0b29" translate="yes" xml:space="preserve">
          <source>As of ERTS version 9.0, the check process code operation only checks for direct references to the code. Indirect references via &lt;code&gt;fun&lt;/code&gt;s will be ignored. If such &lt;code&gt;fun&lt;/code&gt;s exist and are used after a purge of the old code, an exception will be raised upon usage (same as the case when the &lt;code&gt;fun&lt;/code&gt; is received by the process after the purge). Literals will be taken care of (copied) at a later stage. This behavior can as of ERTS version 8.1 be enabled when &lt;code&gt;building OTP&lt;/code&gt;, and will automatically be enabled if dirty scheduler support is enabled.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4e1d3eb137cab5087aa6346ca40170ec41e8ce0" translate="yes" xml:space="preserve">
          <source>As of Erlang/OTP 17, most applications deliver a valid application upgrade file (&lt;code&gt;appup&lt;/code&gt;). In earlier releases, a majority of the applications in Erlang/OTP did not support upgrade. Many of the applications use the &lt;code&gt;restart_application&lt;/code&gt; instruction. These are applications for which it is not crucial to support real soft upgrade, for example, tools and library applications. The &lt;code&gt;restart_application&lt;/code&gt; instruction ensures that all modules in the application are reloaded and thereby running the new code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3896e9860076cb6efc826bd1af4282cf215a66b2" translate="yes" xml:space="preserve">
          <source>As of Erlang/OTP 21.0, the concept of SASL reports is removed, meaning that the default behaviour is as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5156993619ca489fb8cfd9ed4a3335d7b4428f29" translate="yes" xml:space="preserve">
          <source>As of Erlang/OTP R16, messages sent to ports are delivered truly asynchronously. The underlying implementation previously delivered messages to ports synchronously. Message passing has however always been documented as an asynchronous operation. Hence, this is not to be an issue for an Erlang program communicating with ports, unless false assumptions about ports have been made.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db7deccbe166e540f0b707dd76ed8fd8300520de" translate="yes" xml:space="preserve">
          <source>As of OTP 17.0 application versions use the same &lt;code&gt;&lt;a href=&quot;#version_scheme&quot;&gt;version scheme&lt;/a&gt;&lt;/code&gt; as the OTP version. Application versions part of a release candidate will however not have an &lt;code&gt;-rc&amp;lt;N&amp;gt;&lt;/code&gt; suffix as the OTP version. Also note that a major increment in an application version does not necessarily imply a major increment of the OTP version. This depends on whether the major change in the application is considered as a major change for OTP as a whole or not.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6a68f9772c180bbf4b9650571adc55b4582fbcd" translate="yes" xml:space="preserve">
          <source>As of OTP release 17, the OTP release number corresponds to the major part of the OTP version. The OTP version as a concept was introduced in OTP 17. The version scheme used is described in detail in &lt;code&gt;&lt;a href=&quot;#version_scheme&quot;&gt;Version Scheme&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa2be4113be53a8f180a26c5c4f8137c8f0b13cc" translate="yes" xml:space="preserve">
          <source>As of R15B01, the dynamic trace code is included in the OTP source distribution, although it's considered experimental. The main development of the dtrace code still happens outside of Ericsson, but there is no need to fetch a patched version of the OTP source to get the basic functionality.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3175e151baddb9462eaca8a3103721b845c4be90" translate="yes" xml:space="preserve">
          <source>As of version 4.4 the format of the info has been changed. This function is used to convert to the old (pre-4.4) info format.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc18a1e131252e89f07716dc1f6c84f4f113e552" translate="yes" xml:space="preserve">
          <source>As of version 4.4 the format of the info has been changed. To convert the info to the old format, call the &lt;code&gt;&lt;a href=&quot;#old_info_format&quot;&gt;old_info_format&lt;/a&gt;&lt;/code&gt; function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0806b3a57271c3368eb538cbf78e42f66a7befe" translate="yes" xml:space="preserve">
          <source>As operators are not terms in their own right, when operators are mentioned below, the representation of an operator is to be taken to be the atom with a printname consisting of the same characters as the operator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27aa2715207bd314b837c8f9f949d9e43e3fe153" translate="yes" xml:space="preserve">
          <source>As option &lt;code&gt;-M&lt;/code&gt;, except that the Makefile is written to &lt;code&gt;Makefile&lt;/code&gt;. No object file is produced.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d10554b44799b09a5d688a7590a7e6f973d1129" translate="yes" xml:space="preserve">
          <source>As option &lt;code&gt;-MT&lt;/code&gt;, except that characters special to &lt;code&gt;make/1&lt;/code&gt; are quoted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8f789d4c76adaa6e3ad489f09dfb73a7ef05683" translate="yes" xml:space="preserve">
          <source>As parameter &lt;code&gt;Config&lt;/code&gt; is a list of key-value tuples, that is, a data type called a property list, it can be handled by the &lt;code&gt;proplists&lt;/code&gt; module. A value can, for example, be searched for and returned with function &lt;code&gt;proplists:get_value/2&lt;/code&gt;. Also, or alternatively, the general &lt;code&gt;lists&lt;/code&gt; module contains useful functions. Normally, the only operations performed on &lt;code&gt;Config&lt;/code&gt; is insert (adding a tuple to the head of the list) and lookup. &lt;code&gt;Common Test&lt;/code&gt; provides a simple macro named &lt;code&gt;?config&lt;/code&gt;, which returns a value of an item in &lt;code&gt;Config&lt;/code&gt; given the key (exactly like &lt;code&gt;proplists:get_value&lt;/code&gt;). Example: &lt;code&gt;PrivDir = ?config(priv_dir, Config)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e768910eb46b5bf1b56cc0b04701d6e5fb8dd7f" translate="yes" xml:space="preserve">
          <source>As previously described, a Functional Object (Fun) performing table access operations, as listed here, can be passed on as arguments to the function &lt;code&gt;&lt;a href=&quot;mnesia#transaction-2&quot;&gt;mnesia:transaction/1,2,3&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="697d56b55fb0573091be8112b03dc468b6978a3a" translate="yes" xml:space="preserve">
          <source>As previously explained, this specification can also be provided by an entry like the following in a configuration file:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b4c831da626efb451c44f834caf79dfb78dcdf6" translate="yes" xml:space="preserve">
          <source>As previously stated, the locking strategy used by &lt;code&gt;Mnesia&lt;/code&gt; is to lock one record when reading a record, and lock all replicas of a record when writing a record. However, some applications use &lt;code&gt;Mnesia&lt;/code&gt; mainly for its fault-tolerant qualities. These applications can be configured with one node doing all the heavy work, and a standby node that is ready to take over if the main node fails. Such applications can benefit from using sticky locks instead of the normal locking scheme.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d595490ab4714d8a9871d8a09a973dfea9d0d3d" translate="yes" xml:space="preserve">
          <source>As received in the &lt;code&gt;stream_start message&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd5870133105312565312c6b2ab7ff3fd841d30a" translate="yes" xml:space="preserve">
          <source>As returned by &lt;code&gt;&lt;a href=&quot;#accept-1&quot;&gt;accept/1,2&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#connect-3&quot;&gt;connect/3,4&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b46cebaae7c70180ee044bb55a1784247c2f3b67" translate="yes" xml:space="preserve">
          <source>As returned by &lt;code&gt;&lt;a href=&quot;#async_call-4&quot;&gt;async_call/4&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6563f22087e6266633a8cc2568e501f807ea6a94" translate="yes" xml:space="preserve">
          <source>As returned by &lt;code&gt;&lt;a href=&quot;#new-0&quot;&gt;new/0&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="613b92ac4a60557f480687125ac1a95cb659b564" translate="yes" xml:space="preserve">
          <source>As returned by &lt;code&gt;&lt;a href=&quot;#open-1&quot;&gt;open/1,2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5ba5543136150606738a5ee102fcd04508cc21b" translate="yes" xml:space="preserve">
          <source>As returned by &lt;code&gt;&lt;a href=&quot;#open-1&quot;&gt;open/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="863aff4e4c6e39a97f1c4df4bc54ef46a778c1ae" translate="yes" xml:space="preserve">
          <source>As returned by &lt;code&gt;&lt;a href=&quot;#open-2&quot;&gt;open/2&lt;/a&gt;&lt;/code&gt;; &lt;code&gt;pid()&lt;/code&gt; is a process handling I/O-protocols.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4c95d43e70076905f6c54f0f92a6860693a2f6a" translate="yes" xml:space="preserve">
          <source>As returned by &lt;code&gt;&lt;a href=&quot;#start_link-4&quot;&gt;start_link/4&lt;/a&gt;&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90363fa78582864ae9fe09932744a0fa77aa02f7" translate="yes" xml:space="preserve">
          <source>As returned by &lt;code&gt;&lt;a href=&quot;#zip_open-2&quot;&gt;zip_open/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a102b38b674404b91761c097130f2c6e8ca2119" translate="yes" xml:space="preserve">
          <source>As returned by &lt;code&gt;&lt;a href=&quot;erl_parse#parse_exprs-1&quot;&gt;erl_parse:parse_exprs/1&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;io#parse_erl_exprs-2&quot;&gt;io:parse_erl_exprs/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d84d9f434fd43a7bcd5371be1f74578362aa6337" translate="yes" xml:space="preserve">
          <source>As returned by &lt;code&gt;&lt;a href=&quot;ssh#connect-3&quot;&gt;ssh:connect/3&lt;/a&gt;&lt;/code&gt;   As returned by &lt;code&gt;&lt;a href=&quot;ssh_connection#session_channel-2&quot;&gt;ssh_connection:session_channel/[2,4]&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66acc65c2b1802196c6e3511e7c37cac12a600c6" translate="yes" xml:space="preserve">
          <source>As seen in the help text -- unless you have not upgraded your Emacs yet (well, what are you waiting around here for? Off you go and upgrade!) -- &lt;code&gt;etags&lt;/code&gt; associate the file extensions &lt;code&gt;.erl&lt;/code&gt; and &lt;code&gt;.hrl&lt;/code&gt; with Erlang.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f01e0b8a20288a5e48191d860785e7700a74b5b" translate="yes" xml:space="preserve">
          <source>As seen, the basic syntax of a type is an atom followed by closed parentheses. New types are declared using &lt;code&gt;-type&lt;/code&gt; and &lt;code&gt;-opaque&lt;/code&gt; attributes as in the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3fd03dc2b283a58adbff3d43946bbc1c68e036d" translate="yes" xml:space="preserve">
          <source>As shown above, some files have extension &lt;code&gt;.hrl&lt;/code&gt;. These are header files that are included in the &lt;code&gt;.erl&lt;/code&gt; files by:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="644b5188f948ac22e42edad7ffd5f78d4eae0359" translate="yes" xml:space="preserve">
          <source>As shown by the example, the function can be called from the shell also. The fun must be literally in the call when used from the shell as well.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81045d7eeb4cf703574814aab4af0c68ba1e701f" translate="yes" xml:space="preserve">
          <source>As shown in section &lt;code&gt;&lt;a href=&quot;basics_chapter#External_Interfaces&quot;&gt;Common Test Basics&lt;/a&gt;&lt;/code&gt;, the test suite module implements &lt;code&gt;&lt;a href=&quot;common_test&quot;&gt;callback functions&lt;/a&gt;&lt;/code&gt; (mandatory or optional) for various purposes, for example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="030eefb3aa3439bedecb7d423ba21572f508483d" translate="yes" xml:space="preserve">
          <source>As shown, first it is checked if a year is leap. If a year is divisible by 400, it is a leap year. To determine this, first divide the year by 400 and use the BIF &lt;code&gt;trunc&lt;/code&gt; (more about this later) to cut off any decimals. Then multiply by 400 again and see if the same value is returned again. For example, year 2004:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="732c6e940059e650b01cb8f7c64bf6533a984dc1" translate="yes" xml:space="preserve">
          <source>As shown, the Erlang shell numbers the lines that can be entered, (as 1&amp;gt; 2&amp;gt;) and that it correctly says that 2 + 5 is 7. If you make writing mistakes in the shell, you can delete with the backspace key, as in most shells. There are many more editing commands in the shell (see &lt;code&gt;tty - A command line interface&lt;/code&gt; in ERTS User's Guide).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e71ec6804a29b4599e20b3e464961470ccc68635" translate="yes" xml:space="preserve">
          <source>As shown, the function &lt;code&gt;say_something&lt;/code&gt; writes its first argument the number of times specified by second argument. The function &lt;code&gt;start&lt;/code&gt; starts two Erlang processes, one that writes &quot;hello&quot; three times and one that writes &quot;goodbye&quot; three times. Both processes use the function &lt;code&gt;say_something&lt;/code&gt;. Notice that a function used in this way by &lt;code&gt;spawn&lt;/code&gt;, to start a process, must be exported from the module (that is, in the &lt;code&gt;-export&lt;/code&gt; at the start of the module).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8dddde7bbb47337791588e9c259e08ddee9bc47" translate="yes" xml:space="preserve">
          <source>As shown, the ping pong program has run. On the &quot;pong&quot; side:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad4c171e5c21c103c918431cb469ba42140798d7" translate="yes" xml:space="preserve">
          <source>As stated earlier, changing child specifications does not affect existing child processes. New child specifications are automatically added, but not deleted. Child processes are not automatically started or terminated, this must be done using &lt;code&gt;apply&lt;/code&gt; instructions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bab58f9f01e2ec9b0aff4a10808faf716038fb5e" translate="yes" xml:space="preserve">
          <source>As stated earlier, instruction &lt;code&gt;restart_new_emulator&lt;/code&gt; causes the emulator to be restarted with new versions of ERTS&amp;gt;, Kernel, STDLIB, and SASL. However, all other applications do at startup run their old versions in this new emulator. This is usually no problem, but every now and then incompatible changes occur to the core applications, which can cause trouble in this setting. Such incompatible changes (when functions are removed) are normally preceded by a deprecation over two major releases. To ensure that your application is not crashed by an incompatible change, always remove any call to deprecated functions as soon as possible.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2f8b1ba1c67fb67671d7cb5d1f4c6ff846076c9" translate="yes" xml:space="preserve">
          <source>As stated earlier, the order of the instructions is important. When upgrading, &lt;code&gt;m1&lt;/code&gt; must be loaded, and the supervisor child specification changed, before the new child process can be started. When downgrading, the child process must be terminated before the child specification is changed and the module is deleted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7ff2d94dd69653efaa6f0e2b153be55d281f264" translate="yes" xml:space="preserve">
          <source>As such a client cannot read a new &lt;code&gt;start_erl.data&lt;/code&gt; file (the file cannot be changed dynamically). The boot and config files are always fetched from the same place (but with new contents if a new release has been installed).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1714bc6ebf672752fb654342a2c562571522eab2" translate="yes" xml:space="preserve">
          <source>As the &lt;code&gt;++&lt;/code&gt; operator copies its left operand, the result is copied repeatedly, leading to quadratic complexity.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e226d4cd051311bceb315b8997b69c3409b32fc" translate="yes" xml:space="preserve">
          <source>As the &lt;code&gt;add_frag&lt;/code&gt; procedure is a part of a schema transaction, Mnesia acquires write locks on the affected tables. That is, both the fragments corresponding to &lt;code&gt;IterFrags&lt;/code&gt; and those corresponding to &lt;code&gt;AdditionalLockFrags&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8afd221610cfbc0c004b3e80d9cc06e7451e3b4" translate="yes" xml:space="preserve">
          <source>As the &lt;code&gt;address&lt;/code&gt; field was omitted, its default value is used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13444681318a2f85bf718682f9be9c04d867f14f" translate="yes" xml:space="preserve">
          <source>As the &lt;code&gt;del_frag&lt;/code&gt; procedure is a part of a schema transaction, Mnesia acquires write locks on the affected tables. That is, both the fragments corresponding to &lt;code&gt;IterFrags&lt;/code&gt; and those corresponding to &lt;code&gt;AdditionalLockFrags&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="996b8c87675fcbf684c10ebd80b9cfdfdf3cae34" translate="yes" xml:space="preserve">
          <source>As the &lt;code&gt;total&lt;/code&gt; value is the sum of &lt;code&gt;processes&lt;/code&gt; and &lt;code&gt;system&lt;/code&gt;, the error in &lt;code&gt;system&lt;/code&gt; propagates to the &lt;code&gt;total&lt;/code&gt; value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4195fa76015f84a5df8be91ff120efd14a713307" translate="yes" xml:space="preserve">
          <source>As the Erlang ODBC application is dependent on third party products there are a few administrative things that needs to be done before you can get things up and running.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20c8404a5de3c59614d50e29989cfead97f57ced" translate="yes" xml:space="preserve">
          <source>As the Erlang ODBC application relies on third party products and communicates with a database that probably runs on another computer in the network there are plenty of things that might go wrong. To fully understand the things that might happen it facilitate to know the design of the Erlang ODBC application, hence here follows a short description of the current design.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3558041c42459c9de0de1dcf3a8814d6434e5a6c" translate="yes" xml:space="preserve">
          <source>As the UTF-8 encoding is widely spread and provides some backward compatibility in the 7-bit ASCII range, it is selected as the standard encoding for Unicode characters in binaries for Erlang.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bdb9f25861a28ac570dd99575f72b2d8ad54d3fa" translate="yes" xml:space="preserve">
          <source>As the driver is a shared module, not a program, no main function is present. All function pointers are not used in this example, and the corresponding fields in the &lt;code&gt;driver_entry&lt;/code&gt; structure are set to NULL.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8406821028c9ff87cf4b1f089c352e4449600154" translate="yes" xml:space="preserve">
          <source>As the execution and structure of the match specifications are like that of a fun, it is more straightforward to write it using the familiar fun syntax and to have that translated into a match specification automatically. A real fun is clearly more powerful than the match specifications allow, but bearing the match specifications in mind, and what they can do, it is still more convenient to write it all as a fun. This module contains the code that translates the fun syntax into match specification terms.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="500258296a887dd562c74c1baf7dab1768136ec5" translate="yes" xml:space="preserve">
          <source>As the execution of the test suites proceed, events are logged in the following four different ways:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b99f096c11009199607e528c1ab4fde76715836" translate="yes" xml:space="preserve">
          <source>As the message is an &lt;code&gt;ETERM&lt;/code&gt; struct, Erl_Interface functions can be used to manipulate it. In this case, the message becomes a 3-tuple, because that is how the Erlang code is written. The second element will be the pid of the caller and the third element will be the tuple &lt;code&gt;{Function,Arg}&lt;/code&gt; determining which function to call, and with which argument. The result of calling the function is made into an &lt;code&gt;ETERM&lt;/code&gt; struct as well and sent back to Erlang using &lt;code&gt;erl_send()&lt;/code&gt;, which takes the open file descriptor, a pid, and a term as arguments:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7146c7ac731941ac40a19a992206ba27e74fa230" translate="yes" xml:space="preserve">
          <source>As the position is specified as a byte-offset, take special caution when working with files where &lt;code&gt;encoding&lt;/code&gt; is set to something else than &lt;code&gt;latin1&lt;/code&gt;, as not every byte position is a valid character boundary on such a file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f76a9267a5d5f392fb58b458fb3bf07880270ba9" translate="yes" xml:space="preserve">
          <source>As the runtime system handles the optimization (instead of the compiler), there are very few circumstances in which the optimization does not work.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b697dde1f8ec4fdc0c53e1bd6391f4323555d01f" translate="yes" xml:space="preserve">
          <source>As the source code is distributed, it can easily be modified to accept other options. The program must still accept option &lt;code&gt;-data&lt;/code&gt; with the semantics described above for the release handler to work correctly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8795a3307568900a68fbd017733b56af3116954b" translate="yes" xml:space="preserve">
          <source>As the time offset is not allowed to change, time correction must adjust the frequency of the Erlang monotonic clock to align Erlang system time with OS system time smoothly. A significant downside of this approach is that we on purpose will use a faulty frequency on the Erlang monotonic clock if adjustments are needed. This error can be as large as 1%. This error will show up in all time measurements in the runtime system.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c394e9d8956e53ffa12dda34b51f038d61fe77cf" translate="yes" xml:space="preserve">
          <source>As the two alternatives are inside a &lt;code&gt;(?|&lt;/code&gt; group, both sets of capturing parentheses are numbered one. Thus, when the pattern matches, you can look at captured substring number one, whichever alternative matched. This construct is useful when you want to capture a part, but not all, of one of many alternatives. Inside a &lt;code&gt;(?|&lt;/code&gt; group, parentheses are numbered as usual, but the number is reset at the start of each branch. The numbers of any capturing parentheses that follow the subpattern start after the highest number used in any branch. The following example is from the Perl documentation; the numbers underneath show in which buffer the captured content is stored:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b1ff2bd85ad93af178cdc629f19b070b543117b" translate="yes" xml:space="preserve">
          <source>As there can be many capturing parentheses in a pattern, all digits following the backslash are taken as part of a potential back reference number. If the pattern continues with a digit character, some delimiter must be used to terminate the back reference. If option &lt;code&gt;extended&lt;/code&gt; is set, this can be whitespace. Otherwise an empty comment (see section &lt;code&gt;&lt;a href=&quot;#sect19&quot;&gt;Comments&lt;/a&gt;&lt;/code&gt;) can be used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a74c4cf2304eafd1772e4800b2c34ab0218b1011" translate="yes" xml:space="preserve">
          <source>As there is no matching subexpression for the last part in the example (the &quot;g&quot;), nothing is inserted after that. To make the group of strings and the parts matching the subexpressions more obvious, one can use option &lt;code&gt;group&lt;/code&gt;, which groups together the part of the subject string with the parts matching the subexpressions when the string was split:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e2c8ed56878a9d0ce4d6f8c64f1107a4ec68580" translate="yes" xml:space="preserve">
          <source>As these are the C library, the same limitations apply.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c163dd9740f51616c09627b0819df111304b0a64" translate="yes" xml:space="preserve">
          <source>As this interface implies that ports are killed when the last user disappears, the function does not hang waiting for ports to get closed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="269a4f9e2c4144f24e95fc48fbc36000ea30889f" translate="yes" xml:space="preserve">
          <source>As this module is of interest only to the maintainers of the compiler, and to avoid the same description in two places, the elements of &lt;code&gt;Options&lt;/code&gt; that control the warnings are only described in the &lt;code&gt;compile(3)&lt;/code&gt; module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4808daf64c94ffd2d15ac09bfa7bb9ffab8a8096" translate="yes" xml:space="preserve">
          <source>As was mentioned before, the graph analyses operate on the &lt;code&gt;digraph&lt;/code&gt; representation of graphs. By default, the &lt;code&gt;digraph&lt;/code&gt; representation is created when needed (and deleted when no longer used), but it can also be created explicitly by use of the &lt;code&gt;closure&lt;/code&gt; operator:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08da2b535fd9c3da81a12df0eca527a12e4f65fc" translate="yes" xml:space="preserve">
          <source>As was mentioned in the previous section, &lt;code&gt;start_erl&lt;/code&gt; requires a &lt;code&gt;sys.config&lt;/code&gt; in the release version directory (&lt;code&gt;&quot;releases/FIRST/sys.config&quot;&lt;/code&gt;). If there is no such file, the system start fails. Such a file must therefore also be added.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f5cac0dfe306d70277c63b5386d001ed67533ac" translate="yes" xml:space="preserve">
          <source>As with &lt;code&gt;&lt;a href=&quot;#enif_make_resource&quot;&gt;enif_make_resource&lt;/a&gt;&lt;/code&gt;, no ownership transfer is done. The resource still needs to be released with &lt;code&gt;&lt;a href=&quot;#enif_release_resource&quot;&gt;enif_release_resource&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86dd8791c9b5f5dca561254006fe497e2d3994c7" translate="yes" xml:space="preserve">
          <source>As with &lt;code&gt;erlang:send_nosuspend/2,3&lt;/code&gt;: use with extreme care.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="efe69f566993703e5412e0783db54d43802e91bd" translate="yes" xml:space="preserve">
          <source>As with &lt;code&gt;run/3&lt;/code&gt;, compilation errors raise the &lt;code&gt;badarg&lt;/code&gt; exception. &lt;code&gt;&lt;a href=&quot;#compile-2&quot;&gt;compile/2&lt;/a&gt;&lt;/code&gt; can be used to get more information about the error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65ddbc78ec2288effbfbc27dc2887832b0da7683" translate="yes" xml:space="preserve">
          <source>As with all other functions starting with &lt;code&gt;ei_&lt;/code&gt;, you are &lt;strong&gt;not&lt;/strong&gt; expected to put the socket in non-blocking mode yourself in the program. Every use of non-blocking mode is embedded inside the time-out functions. The socket will always be back in blocking mode after the operations are completed (regardless of the result). To avoid problems, leave the socket options alone. &lt;code&gt;ei&lt;/code&gt; handles any socket options that need modification.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3c8339b0d633ff7f739e39a8bb36a1648a7db29" translate="yes" xml:space="preserve">
          <source>As with dynamically added child processes, the effects of deleting a static child process is lost if the supervisor itself restarts.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec50db8f3e13bb5768f12bc8a6a3b1ddcd9124a9" translate="yes" xml:space="preserve">
          <source>As with normal tree structures, lookup (membership testing), insertion, and deletion have logarithmic complexity.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96a345435dd16a7fc2f73434205466252ddf7e39" translate="yes" xml:space="preserve">
          <source>As with process monitors, each driver monitor set only generates &lt;strong&gt;one single message&lt;/strong&gt;. The monitor is &quot;destroyed&quot; after the message is sent, so it is then not needed to call &lt;code&gt;&lt;a href=&quot;#demonitor-1&quot;&gt;demonitor/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2467dbec656f95127f4a0e7d30ecc8a6ad6234f" translate="yes" xml:space="preserve">
          <source>As you can see by the example, the function can be called from the shell too. The &lt;code&gt;fun()&lt;/code&gt; needs to be literally in the call when used from the shell as well. Other means than the parse_transform are used in the shell case, but more or less the same restrictions apply (the exception being records, as they are not handled by the shell).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b8232bbed24ef8f629ce1816536b7c03bfad7c6" translate="yes" xml:space="preserve">
          <source>As you can understand from the illustration, &lt;code&gt;Common Test&lt;/code&gt; requires a test case to generate a runtime error to indicate failure (for example, by causing a bad match error or by calling &lt;code&gt;exit/1&lt;/code&gt;, preferably through the help function &lt;code&gt;&lt;a href=&quot;ct#fail-1&quot;&gt;ct:fail/1,2&lt;/a&gt;&lt;/code&gt;). A successful execution is indicated by a normal return from the test case function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b635d527fabae96e027fa225db3c0e9bac328ef" translate="yes" xml:space="preserve">
          <source>As you have seen, it is possible to use the &lt;code&gt;et_collector:report_event/5,6&lt;/code&gt; functions explicitly. By using those functions you can write your own trace client that reads trace data from any source stored in any format and just feed the &lt;code&gt;Collector&lt;/code&gt; with it. You may replace the default &lt;code&gt;Collector Filter&lt;/code&gt; with a filter that converts new exciting trace data formats to &lt;code&gt;Event Records&lt;/code&gt; or you may convert it to an &lt;code&gt;Event Record&lt;/code&gt; before you invoke &lt;code&gt;et_collector:report/2&lt;/code&gt; and then rely on the default &lt;code&gt;Collector Filter&lt;/code&gt; to handle the new format.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d261c2679b68d55f3f5768006262a218d859a604" translate="yes" xml:space="preserve">
          <source>Ask them to transform the internal state format and switch to the new version of the module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ccd30300261a4eca3d0f1af0fcf77d29e731e3c" translate="yes" xml:space="preserve">
          <source>Asking for and inspecting raw socket options require low-level information about the current operating system and TCP stack.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0599d793007329beb80221bb5065e2bf255ef6e5" translate="yes" xml:space="preserve">
          <source>Assert end of string (or line, in multiline mode)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf59339e55d5c656acd77a3516f63cf3ff15de3e" translate="yes" xml:space="preserve">
          <source>Assert start of string (or line, in multiline mode)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18d329141ee34e40c36d7b169bb7a159eb5aeb08" translate="yes" xml:space="preserve">
          <source>Assertion subpatterns are not capturing subpatterns. If such an assertion contains capturing subpatterns within it, these are counted for the purposes of numbering the capturing subpatterns in the whole pattern. However, substring capturing is done only for positive assertions. (Perl sometimes, but not always, performs capturing in negative assertions.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc3e91b0be656a68c41466178566755f49840e06" translate="yes" xml:space="preserve">
          <source>Assertions can be nested in any combination. For example, the following matches an occurrence of &quot;baz&quot; that is preceded by &quot;bar&quot;, which in turn is not preceded by &quot;foo&quot;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8383a156cd04a5d92aafffd1ec55eeaa8e37c727" translate="yes" xml:space="preserve">
          <source>Assigning a value to type &lt;code&gt;Operational&lt;/code&gt; in Erlang is possible by using the following Erlang code:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ad8afb43e64d75a730687d995308551590810c9" translate="yes" xml:space="preserve">
          <source>Assignment ::= Variable &lt;code&gt;:=&lt;/code&gt; Expression | Variable &lt;code&gt;=&lt;/code&gt; Expression</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31732955b5b879b8595ccb4012494c26bfc62323" translate="yes" xml:space="preserve">
          <source>Assigns a new controlling process &lt;code&gt;Pid&lt;/code&gt; to &lt;code&gt;Socket&lt;/code&gt;. Same implementation as &lt;code&gt;gen_udp:controlling_process/2&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="750263088fcf3a705a426666d4ba4253060235cc" translate="yes" xml:space="preserve">
          <source>Assigns a new controlling process &lt;code&gt;Pid&lt;/code&gt; to &lt;code&gt;Socket&lt;/code&gt;. The controlling process is the process that receives messages from the socket. If called by any other process than the current controlling process, &lt;code&gt;{error, not_owner}&lt;/code&gt; is returned. If the process identified by &lt;code&gt;Pid&lt;/code&gt; is not an existing local pid, &lt;code&gt;{error, badarg}&lt;/code&gt; is returned. &lt;code&gt;{error, badarg}&lt;/code&gt; may also be returned in some cases when &lt;code&gt;Socket&lt;/code&gt; is closed during the execution of this function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83e6ee60d090046ec0df21d8f20b308779b0123e" translate="yes" xml:space="preserve">
          <source>Assigns a new controlling process to the SSL socket. A controlling process is the owner of an SSL socket, and receives all messages from the socket.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2015efa67c45a84e357363963f8ef7cc19116af" translate="yes" xml:space="preserve">
          <source>Associate a result set containing the whole table &lt;code&gt;EMPLOYEE&lt;/code&gt; to the connection. The number of rows in the result set is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c01c817bd8220a9e426732586a19782a2ec8dae2" translate="yes" xml:space="preserve">
          <source>Associate a result set that contains the fields &lt;code&gt;FIRSTNAME&lt;/code&gt; and &lt;code&gt;NR&lt;/code&gt; for all female employees to the connection. The number of rows in the result set is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e682a3847cd3fad46ea3e5c2bf3acec87c695369" translate="yes" xml:space="preserve">
          <source>Associates &lt;code&gt;Key&lt;/code&gt; with value &lt;code&gt;Value&lt;/code&gt; and inserts the association into map &lt;code&gt;Map2&lt;/code&gt;. If key &lt;code&gt;Key&lt;/code&gt; already exists in map &lt;code&gt;Map1&lt;/code&gt;, the old associated value is replaced by value &lt;code&gt;Value&lt;/code&gt;. The function returns a new map &lt;code&gt;Map2&lt;/code&gt; containing the new association and the old associations in &lt;code&gt;Map1&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe25fda4b17970a0ef529403d3f726c24aae538c" translate="yes" xml:space="preserve">
          <source>Associates a UDP port number (&lt;code&gt;Port&lt;/code&gt;) with the calling process.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1f8648a03de87c0a9794d9b8e650c32fee361c7" translate="yes" xml:space="preserve">
          <source>Associates the name &lt;code&gt;Name&lt;/code&gt;, an atom, with the process &lt;code&gt;Pid&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="adba476945469569c82884884c1c62b87ee5beca" translate="yes" xml:space="preserve">
          <source>Associates the name &lt;code&gt;RegName&lt;/code&gt; with a process identifier (pid) or a port identifier. &lt;code&gt;RegName&lt;/code&gt;, which must be an atom, can be used instead of the pid or port identifier in send operator (&lt;code&gt;RegName ! Message&lt;/code&gt;). Example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41bb0af24396833201992ca15a0ccfba7ee7f093" translate="yes" xml:space="preserve">
          <source>Associates the test run with a name that gets printed in the overview HTML log files.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a929bb502012d59c211ba29e792fdfc1bcec65b6" translate="yes" xml:space="preserve">
          <source>Association is successfully established. This indicates a successful completion of &lt;code&gt;connect&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd321e5d28d57fcf199c5a0fe6ae644a0f00e982" translate="yes" xml:space="preserve">
          <source>Assume that a module is extended by adding an interface function, as in the example in &lt;code&gt;&lt;a href=&quot;release_handling#appup&quot;&gt;Release Handling&lt;/a&gt;&lt;/code&gt;, where a function &lt;code&gt;available/0&lt;/code&gt; is added to &lt;code&gt;ch3&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81e67a14a83897861024d39ef25a7c52fdc905a0" translate="yes" xml:space="preserve">
          <source>Assume that a test case for the following program should be verified:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71a8953ab141a80996cc4c7f627c6481c2d38dca" translate="yes" xml:space="preserve">
          <source>Assume that a user does not want Erlang to use the native lookup method, but wants Erlang to read all information necessary from start and use that for resolving names and addresses. If lookup fails, Erlang is to request the data from a nameserver (using the Erlang DNS client, set to use EDNS allowing larger responses). The resolver configuration is updated when its configuration file changes. Also, DNS records are never to be cached. The user configuration file (in this example named &lt;code&gt;erl_inetrc&lt;/code&gt;, stored in directory &lt;code&gt;./cfg_files&lt;/code&gt;) can then look as follows (Unix):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d48df2f1a8f0fd07793d2b425e8df418ef5bfad" translate="yes" xml:space="preserve">
          <source>Assume that nothing happens when tracing in this way. The function is never called with these parameters. We conclude that someone else (some other module) is doing it and realize that we must trace on &lt;code&gt;ets:insert/2&lt;/code&gt; and want to see the calling function. The calling function can be retrieved using the match specification function &lt;code&gt;caller&lt;/code&gt;. To get it into the trace message, the match specification function &lt;code&gt;message&lt;/code&gt; must be used. The filter call looks like this (looking for calls to &lt;code&gt;ets:insert/2&lt;/code&gt;):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="997882ed021f898e3c4711038cfd690fedaa8231" translate="yes" xml:space="preserve">
          <source>Assume that the module now passes all testing and goes into the system. After a while, it is found that table &lt;code&gt;toy_table&lt;/code&gt; grows while the system is running and that there are many elements with atoms as keys. We expected only integer keys and so does the rest of the system, but clearly not the entire system. We turn on call tracing and try to see calls to the module with an atom as the key:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f89a940266dfec94c78b06cb601b527f92f04417" translate="yes" xml:space="preserve">
          <source>Assume that the suite contains the test case &lt;code&gt;get_resource_status&lt;/code&gt; that is independent of the other two cases, then function &lt;code&gt;all&lt;/code&gt; can look as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d831964edca879d5d90599f59a999703ad024ad1" translate="yes" xml:space="preserve">
          <source>Assume that there are two systems, &lt;code&gt;s1&lt;/code&gt; and &lt;code&gt;s2&lt;/code&gt;, that are tested in separate test runs. System &lt;code&gt;s1&lt;/code&gt; contains a library module &lt;code&gt;m1&lt;/code&gt; tested by test run &lt;code&gt;s1&lt;/code&gt; and is included in the cover specification of &lt;code&gt;s1&lt;/code&gt; as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a42279cd9be030fbaa5a2fcc34c767220fae2bb" translate="yes" xml:space="preserve">
          <source>Assume that there is a network application that receives instances of the ASN.1 defined type &lt;code&gt;Person&lt;/code&gt;, modifies, and sends them back again:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33069b991dada2eb5da77ef53b4f64ef6b97abaa" translate="yes" xml:space="preserve">
          <source>Assume that there is an index on position &lt;code&gt;Pos&lt;/code&gt; for a certain record type. This function can be used to read the records without knowing the actual key for the record. For example, with an index in position 1 of table &lt;code&gt;person&lt;/code&gt;, the call &lt;code&gt;mnesia:index_read(person, 36, #person.age)&lt;/code&gt; returns a list of all persons with age 36. &lt;code&gt;Pos&lt;/code&gt; can also be an attribute name (atom), but if the notation &lt;code&gt;mnesia:index_read(person, 36, age)&lt;/code&gt; is used, the field position is searched for in runtime, for each call.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="829ce164f6e9881978858a93ac53473e3de7a2fe" translate="yes" xml:space="preserve">
          <source>Assume that we have not found the problem yet, and want to see what &lt;code&gt;ets:new/2&lt;/code&gt; returns. We use a slightly different trace pattern:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58d7492d43f93e533d2fc8b2893194dfb95c91d5" translate="yes" xml:space="preserve">
          <source>Assume that we want the whole object matching instead of only one element. One alternative is to assign a variable to every part of the record and build it up once again in the body of the fun, but the following is easier:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1bf62160b9303fd32fdad0cd34b9da4d1aef481" translate="yes" xml:space="preserve">
          <source>Assume that we want to get all the employee numbers of employees hired before year 2000. Using &lt;code&gt;ets:match/2&lt;/code&gt; is not an alternative here, as relational operators cannot be expressed there. Once again, &lt;code&gt;ets:foldr/3&lt;/code&gt; can do it (slowly, but correct):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ba39d9d328d97a989e24d8ac3124b4d21b0636f" translate="yes" xml:space="preserve">
          <source>Assume that you have an initiating process with &lt;code&gt;Pid == &amp;lt;0.30.0&amp;gt;&lt;/code&gt; like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59beb2deb0d2bf3ac19ece9f2db7b475398662e6" translate="yes" xml:space="preserve">
          <source>Assume that you want to calculate the factorial for 1:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81e6855c42a523802dad6f1c6e5e336c4662d743" translate="yes" xml:space="preserve">
          <source>Assume that you want to transform the &lt;code&gt;&lt;a href=&quot;#motorcyclesxml&quot;&gt;motorcycles.xml&lt;/a&gt;&lt;/code&gt; document to HTML. If you want the same structure and tags of the resulting HTML document as of the XML document then you can use the &lt;code&gt;xmerl:export/2&lt;/code&gt; function. The following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42a5d8a52feabf03d2cc601350c97037810f3131" translate="yes" xml:space="preserve">
          <source>Assume the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4dd172e924a451d443d3ebe731fdc5eb7eae97d" translate="yes" xml:space="preserve">
          <source>Assume we want to check the following module:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1917e9bb4b3ba3244f0149508301240f3ef84a5" translate="yes" xml:space="preserve">
          <source>Assumes that &lt;code&gt;Term&lt;/code&gt; is a term with the same structure as a &lt;code&gt;erl_parse&lt;/code&gt; tree, but with &lt;code&gt;&lt;a href=&quot;erl_anno#type-location&quot;&gt;locations&lt;/a&gt;&lt;/code&gt; where a &lt;code&gt;erl_parse&lt;/code&gt; tree has collections of annotations. Returns a &lt;code&gt;erl_parse&lt;/code&gt; tree where each location &lt;code&gt;L&lt;/code&gt; is replaced by the value returned by &lt;code&gt;&lt;a href=&quot;erl_anno#new-1&quot;&gt;erl_anno:new(L)&lt;/a&gt;&lt;/code&gt;. The term &lt;code&gt;Term&lt;/code&gt; is traversed in a depth-first, left-to-right fashion.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7cafb7be7f1db85e6934ccfbc9df1141dff9353" translate="yes" xml:space="preserve">
          <source>Assumes that &lt;code&gt;Term&lt;/code&gt; is a term with the same structure as a &lt;code&gt;erl_parse&lt;/code&gt; tree, but with terms, say &lt;code&gt;T&lt;/code&gt;, where a &lt;code&gt;erl_parse&lt;/code&gt; tree has collections of annotations. Returns a &lt;code&gt;erl_parse&lt;/code&gt; tree where each term &lt;code&gt;T&lt;/code&gt; is replaced by the value returned by &lt;code&gt;&lt;a href=&quot;erl_anno#from_term-1&quot;&gt;erl_anno:from_term(T)&lt;/a&gt;&lt;/code&gt;. The term &lt;code&gt;Term&lt;/code&gt; is traversed in a depth-first, left-to-right fashion.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0867c9c6c98bb1857eef83b5370df89b6931896a" translate="yes" xml:space="preserve">
          <source>Assuming &lt;code&gt;Forms&lt;/code&gt; represents a program (or any sequence of &quot;program forms&quot;), any comments whose first lines are not directly associated with a specific program form will become standalone comments inserted between the neighbouring program forms. Furthermore, comments whose column position is less than or equal to one will not be attached to a program form that begins at a conflicting line number (this can happen with preprocessor-generated &lt;code&gt;line&lt;/code&gt;-attributes).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85756eb2ccf84d68d4412ebf0e79850cfd5d276b" translate="yes" xml:space="preserve">
          <source>Assuming an Erlang system called ping (but not the &quot;ping&quot; process) has already been started on kosken, then on gollum this is done:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10a82aabb0e61cdb059228faa6975a490d22e3b9" translate="yes" xml:space="preserve">
          <source>Assuming an Ets table that uses &lt;code&gt;idno&lt;/code&gt; as key and contains the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18d8e312811328614a25350d0eb0a85b61ed61f9" translate="yes" xml:space="preserve">
          <source>Assuming that both the arguments and the results from the C functions are less than 256, a simple encoding/decoding scheme is employed. In this scheme, &lt;code&gt;foo&lt;/code&gt; is represented by byte 1, &lt;code&gt;bar&lt;/code&gt; is represented by 2, and the argument/result is represented by a single byte as well:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a66845ce6e93230866ff8e0772d20b4798a32003" translate="yes" xml:space="preserve">
          <source>Assuming that environment variables has been correctly set, a strings containing valid characters on the specific OS for environment variable names and values using &lt;code&gt;&lt;a href=&quot;file#native_name_encoding-0&quot;&gt;file:native_name_encoding()&lt;/a&gt;&lt;/code&gt; encoding. The first &lt;code&gt;$=&lt;/code&gt; characters appearing in the string separates environment variable name (on the left) from environment variable value (on the right).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a6f58980048155b748b7c9405f322e65c5a9184" translate="yes" xml:space="preserve">
          <source>Assuming that the call to &lt;code&gt;&lt;a href=&quot;mnesia#start-0&quot;&gt;mnesia:start/0&lt;/a&gt;&lt;/code&gt; does not find any schema to read on the disc, &lt;code&gt;Mnesia&lt;/code&gt; starts as a disc-less node, and then change it to a node that use the disc to store the schema locally.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6872420cefd05df68dce4eed3bc63d15db4f598" translate="yes" xml:space="preserve">
          <source>Assuming that the node has been started as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8499608ce735317421447e4bbbb5e480084db254" translate="yes" xml:space="preserve">
          <source>Assuming that these requirements are fulfilled, time correction is enabled, and OS system time is adjusted using a time adjustment protocol such as NTP, only small adjustments of Erlang monotonic time are needed to keep system times aligned after finalization. As long as the system is not suspended, the largest adjustments needed are for inserted (or deleted) leap seconds.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03367feb887591c7e80f18fd1145673d7dcffe3e" translate="yes" xml:space="preserve">
          <source>Assuming that these types are exported from module &lt;code&gt;'mod'&lt;/code&gt;, you can refer to them from other modules using remote type expressions like the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26267ff052ff06ed2dce21d69453c5f440474929" translate="yes" xml:space="preserve">
          <source>Assuming that we want the employee numbers of everyone in the sales department, there are several ways.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="266f66badd0d0b518b2e5df463ab8847e52c02bb" translate="yes" xml:space="preserve">
          <source>Assuming the &lt;code&gt;.rel file&lt;/code&gt; is stored in a file &lt;code&gt;start_ssl.rel&lt;/code&gt; in the current directory, a boot script can be built as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6fce84ccb66529fc8ed6e1c0f38776816b583ca0" translate="yes" xml:space="preserve">
          <source>Assuming the same &lt;code&gt;CLIENTDIR&lt;/code&gt; as above, the last line is to look like:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a0c79afff9d3483a1ae5e8cbc8205664dba4b83" translate="yes" xml:space="preserve">
          <source>Assuming there is an operational target system with installation root directory &lt;code&gt;$ROOT&lt;/code&gt;, the release package with the new version of the release is to be copied to &lt;code&gt;$ROOT/releases&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7c30a0e4666f7264a0489fe55f811dceafac52d" translate="yes" xml:space="preserve">
          <source>Assuming these definitions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4b10ac30756395c83923e7cf3c7d80acae92175" translate="yes" xml:space="preserve">
          <source>Async queue length is not defined for &lt;code&gt;put&lt;/code&gt; operations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3988dd15a01716f5457aa8c6239f3feeb9605755" translate="yes" xml:space="preserve">
          <source>Async threads are used by various linked-in drivers (mainly the file drivers) do offload non-CPU intensive work. See &lt;code&gt;erl +A&lt;/code&gt; for more details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f2ff86b0c85c68964cf97af02073f12b82e6dee" translate="yes" xml:space="preserve">
          <source>Asynchronous &lt;code&gt;get-bulk-request&lt;/code&gt; (See RFC1905).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3284d2626e5dc0e20ecd8465f9256541f56870e5" translate="yes" xml:space="preserve">
          <source>Asynchronous &lt;code&gt;get-next-request&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce12675017eba1aad96dc4af8158e8ade8a6e141" translate="yes" xml:space="preserve">
          <source>Asynchronous &lt;code&gt;get-request&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07690d2c187b7cfafc60389b63d0ee62b7cd3c1c" translate="yes" xml:space="preserve">
          <source>Asynchronous &lt;code&gt;set-request&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c4f45c7554c3415b2762a3d8f5669acc6525702" translate="yes" xml:space="preserve">
          <source>Asynchronous request cleanup time. For every requests, some info is stored internally, in order to be able to deliver the reply (when it arrives) to the proper destination. If the reply arrives, this info will be deleted. But if there is no reply (in time), the info has to be deleted after the &lt;strong&gt;best before&lt;/strong&gt; time has been passed. This cleanup will be performed at regular intervals, defined by the &lt;code&gt;server_timeout()&lt;/code&gt; time. The information will have a &lt;strong&gt;best before&lt;/strong&gt; time, defined by the &lt;code&gt;Expire&lt;/code&gt; time given when calling the request function (see &lt;code&gt;&lt;a href=&quot;snmpm#async_get&quot;&gt;async_get&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;snmpm#async_get_next&quot;&gt;async_get_next&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;snmpm#async_set&quot;&gt;async_set&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f4ef40b42e8c28e77390dcc6fa14ba97907a734" translate="yes" xml:space="preserve">
          <source>Asynchronous request for cancellation. &lt;code&gt;Async&lt;/code&gt; defaults to &lt;code&gt;false&lt;/code&gt;, which causes the cancellation to be performed synchronously. When &lt;code&gt;Async&lt;/code&gt; is set to &lt;code&gt;true&lt;/code&gt;, the cancel operation is performed asynchronously. That is, &lt;code&gt;cancel_timer()&lt;/code&gt; sends an asynchronous request for cancellation to the timer service that manages the timer, and then returns &lt;code&gt;ok&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95fd03b1444c479be3c52aee359cb2dfca32c856" translate="yes" xml:space="preserve">
          <source>Asynchronous request for state information. &lt;code&gt;Async&lt;/code&gt; defaults to &lt;code&gt;false&lt;/code&gt;, which causes the operation to be performed synchronously. In this case, the &lt;code&gt;Result&lt;/code&gt; is returned by &lt;code&gt;erlang:read_timer&lt;/code&gt;. When &lt;code&gt;Async&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;erlang:read_timer&lt;/code&gt; sends an asynchronous request for the state information to the timer service that manages the timer, and then returns &lt;code&gt;ok&lt;/code&gt;. A message on the format &lt;code&gt;{read_timer, TimerRef, Result}&lt;/code&gt; is sent to the caller of &lt;code&gt;erlang:read_timer&lt;/code&gt; when the operation has been processed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ca776a5d287d8b2a7dc6071e248dbb73c2d391b" translate="yes" xml:space="preserve">
          <source>Asynchronously append a list of items to a disk log. &lt;code&gt;alog_terms/2&lt;/code&gt; is used for internally formatted logs and &lt;code&gt;balog_terms/2&lt;/code&gt; for externally formatted logs. &lt;code&gt;balog_terms/2&lt;/code&gt; can also be used for internally formatted logs if the binaries are constructed with calls to &lt;code&gt;term_to_binary/1&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb5375e7ef1ea5eaaf79230eafedb013e5c6183e" translate="yes" xml:space="preserve">
          <source>Asynchronously append an item to a disk log. &lt;code&gt;alog/2&lt;/code&gt; is used for internally formatted logs and &lt;code&gt;balog/2&lt;/code&gt; for externally formatted logs. &lt;code&gt;balog/2&lt;/code&gt; can also be used for internally formatted logs if the binary is constructed with a call to &lt;code&gt;term_to_binary/1&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4919029fc256c29ef79f5f904616a2c8e94c3f2" translate="yes" xml:space="preserve">
          <source>At &quot;top-level&quot;, all these recursion test conditions are false. The syntax for recursive patterns is described below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f43d3dd154d77c634c392d671f75757f296a087e" translate="yes" xml:space="preserve">
          <source>At &lt;code&gt;success()&lt;/code&gt;, the &lt;code&gt;UserReply&lt;/code&gt; contains a list of 'ActionReply' records possibly containing error indications.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d45243ad2c3b8770cad6640db0cb04483b46411" translate="yes" xml:space="preserve">
          <source>At &lt;code&gt;success()&lt;/code&gt;, the &lt;code&gt;UserReply&lt;/code&gt; either contains:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a23e179a407d51751e1caa4f70ab6a111682bb8b" translate="yes" xml:space="preserve">
          <source>At any time, the current Erlang Top display can be dumped to a text file with function &lt;code&gt;&lt;a href=&quot;etop#dump-1&quot;&gt;etop:dump/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f1d3d95e4cd84ec49bb6d5fe0b90a58ea62ba48" translate="yes" xml:space="preserve">
          <source>At any time, to get the current status of the test nodes, call function &lt;code&gt;&lt;a href=&quot;ct_master#progress-0&quot;&gt;ct_master:progress()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd91a4b48e4394db081304cf8a7e752960166fb5" translate="yes" xml:space="preserve">
          <source>At each iteration of the subpattern, the back reference matches the character string corresponding to the previous iteration. In order for this to work, the pattern must be such that the first iteration does not need to match the back reference. This can be done using alternation, as in the example above, or by a quantifier with a minimum of zero.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b373a9f8122a8a2b8c68bd7132b1ca7c2848e49f" translate="yes" xml:space="preserve">
          <source>At each record access, &lt;code&gt;mnesia_frag&lt;/code&gt; first computes a hash value from the record key. Second, the name of the table fragment is determined from the hash value. Finally the actual table access is performed by the same functions as for non-fragmented tables. When the key is not known beforehand, all fragments are searched for matching records.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e791bb91b86137f009adcbd36f18e163d6c841d5" translate="yes" xml:space="preserve">
          <source>At least one other identifier type besides &lt;code&gt;&amp;lt;LogicalIds&amp;gt;&lt;/code&gt; must also have a list of identifiers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6e34fe0dc564614befa189e8748c8b5b71f49e4" translate="yes" xml:space="preserve">
          <source>At present only the default module is provided with the agent, &lt;code&gt;snmpa_mib_data_tttn&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52b6928d79b0ae8a32944a5857ee7a65e4d13aa4" translate="yes" xml:space="preserve">
          <source>At start-up, a node has a random atom assigned as its magic cookie and the cookie of other nodes is assumed to be &lt;code&gt;nocookie&lt;/code&gt;. The first action of the Erlang network authentication server (&lt;code&gt;auth&lt;/code&gt;) is then to read a file named &lt;code&gt;$HOME/.erlang.cookie&lt;/code&gt;. If the file does not exist, it is created. The UNIX permissions mode of the file is set to octal 400 (read-only by user) and its contents are a random string. An atom &lt;code&gt;Cookie&lt;/code&gt; is created from the contents of the file and the cookie of the local node is set to this using &lt;code&gt;erlang:set_cookie(node(), Cookie)&lt;/code&gt;. This also makes the local node assume that all other nodes have the same cookie &lt;code&gt;Cookie&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="518744e98c40235fc6bb7d9cc4f9e7b8cd708382" translate="yes" xml:space="preserve">
          <source>At startup, &lt;code&gt;Mnesia&lt;/code&gt; assumes that its local replica is the most recent version and loads the table from disc if either of the following situations is detected:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5838a6fe5958edaad5f512813e7c830bd8af3cc" translate="yes" xml:space="preserve">
          <source>At startup, &lt;code&gt;Mnesia&lt;/code&gt; connects different nodes to each other, then they exchange table definitions with each other, and the table definitions are merged. During the merge procedure, &lt;code&gt;Mnesia&lt;/code&gt; performs a sanity test to ensure that the table definitions are compatible with each other. If a table exists on several nodes, the cookie must be the same, otherwise &lt;code&gt;Mnesia&lt;/code&gt; shut down one of the nodes. This unfortunate situation occurs if a table has been created on two nodes independently of each other while they were disconnected. To solve this, one of the tables must be deleted (as the cookies differ, it is regarded to be two different tables even if they have the same name).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a627688b56cf27035c1a223f76b7c1a970186939" translate="yes" xml:space="preserve">
          <source>At startup, &lt;code&gt;Mnesia&lt;/code&gt; loads tables to make them accessible for its applications. Sometimes &lt;code&gt;Mnesia&lt;/code&gt; decides to load all tables that reside locally, and sometimes the tables are not accessible until &lt;code&gt;Mnesia&lt;/code&gt; brings a copy of the table from another node.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d42e266b7e766640fca49bd15e785ddd09a12678" translate="yes" xml:space="preserve">
          <source>At startup, Mnesia always loads &lt;code&gt;read_only&lt;/code&gt; table locally regardless of when and if Mnesia is terminated on other nodes. This argument returns the access mode of the table. The access mode can be &lt;code&gt;read_only&lt;/code&gt; or &lt;code&gt;read_write&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd3b6f4ef0dfb0e46121f11afdceab8754106c9b" translate="yes" xml:space="preserve">
          <source>At startup, notice that all tables residing on nodes without a &lt;code&gt;mnesia_down&lt;/code&gt; entry can have fresher replicas. Their replicas can have been updated after the termination of &lt;code&gt;Mnesia&lt;/code&gt; on the current node. To catch up with the latest updates, transfer a copy of the table from one of these other &quot;fresh&quot; nodes. If you are unlucky, other nodes can be down and you must wait for the table to be loaded on one of these nodes before receiving a fresh copy of the table.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cebd2da32e4452b268c6c9625fdcaae6da724209" translate="yes" xml:space="preserve">
          <source>At startup, the &lt;code&gt;Mnesia&lt;/code&gt; normal table load algorithm is bypassed and the table is loaded from one of the master nodes defined for the table, regardless of potential &lt;code&gt;mnesia_down&lt;/code&gt; entries in the log. &lt;code&gt;Nodes&lt;/code&gt; can only contain nodes where the table has a replica. If &lt;code&gt;Nodes&lt;/code&gt; is empty, the master node recovery mechanism for the particular table is reset and the normal load mechanism is used at the next restart.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6322370642204a58e29b000b086020c58026493" translate="yes" xml:space="preserve">
          <source>At system start, Logger is configured through Kernel configuration parameters. The parameters that apply to Logger are described in section &lt;code&gt;&lt;a href=&quot;#kernel_config_params&quot;&gt;Kernel Configuration Parameters&lt;/a&gt;&lt;/code&gt;. Examples are found in section &lt;code&gt;&lt;a href=&quot;#config_examples&quot;&gt;Configuration Examples&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74d12c0011c249bb23aab720fbf3331a64e7f920" translate="yes" xml:space="preserve">
          <source>At the Media Gateway Controller (MGC) side it is possible to reject a connection request (and send a message error reply to the gateway) by returning &lt;code&gt;{error, ErrorDescr}&lt;/code&gt; or simply &lt;code&gt;error&lt;/code&gt; which generates an error descriptor with code 402 (unauthorized) and reason &quot;Connection refused by user&quot; (this is also the case for all unknown results, such as exit signals or throw).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="082190436d06dd5d49208af168f795454a1d2c3e" translate="yes" xml:space="preserve">
          <source>At the end of a match, the values of capturing parentheses are those from the outermost level. If the pattern above is matched against</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0bd3386c01848e616038cd3be0a42aca1ff92e4" translate="yes" xml:space="preserve">
          <source>At the end of phase one, the user defined &lt;code&gt;is_set_ok&lt;/code&gt; functions are called for each scalar variable, and for each group of table operations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7141009a47e03284bdfb55bb6f57dbdb2f6af74" translate="yes" xml:space="preserve">
          <source>At the end of the file the following call is made to indicate the end of the transfer:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f5e152a75003f4c0eecbf24783ff86692b5ac63" translate="yes" xml:space="preserve">
          <source>At the moment this is always an empty list as policies are not currently supported.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ffb7455412e52bcc56b05d38e6e5253be2bc9d2d" translate="yes" xml:space="preserve">
          <source>At the other end, a server is listening on port 5678, accepts the connection, and receives the binary:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2ee7dea7134049488781051edab25bd2f008623" translate="yes" xml:space="preserve">
          <source>At the top level, the first character is matched, but as it is not at the end of the string, the first alternative fails, the second alternative is taken, and the recursion kicks in. The recursive call to subpattern 1 successfully matches the next character (&quot;b&quot;). (Notice that the beginning and end of line tests are not part of the recursion.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed2220b4de1fb3635d6a43309a72686050501dc1" translate="yes" xml:space="preserve">
          <source>At this point it would make sense to create a &lt;code&gt;&lt;a href=&quot;#sub_binary&quot;&gt;sub binary&lt;/a&gt;&lt;/code&gt;, but in this particular example the compiler sees that there will soon be a call to a function (in this case, to &lt;code&gt;my_binary_to_list/1&lt;/code&gt; itself) that immediately will create a new match context and discard the sub binary.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a5d6ede3e3967bfd759ea91b6f59bd9213c0242" translate="yes" xml:space="preserve">
          <source>At this stage when we have a couple of &lt;code&gt;Events&lt;/code&gt;, it is time to show how it looks like in the graphical interface of &lt;code&gt;et_viewer&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41dded417052424bdcf3c39f6c8664147fae6806" translate="yes" xml:space="preserve">
          <source>Atom</source>
          <target state="translated">Atom</target>
        </trans-unit>
        <trans-unit id="c3c309f16bf4b6076b8eb93fd32be986ed93ed91" translate="yes" xml:space="preserve">
          <source>Atom ::= - same as Erlang atoms -</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51343a15868219ae0470e742ba631bc7eec26597" translate="yes" xml:space="preserve">
          <source>Atom is another data type in Erlang. Atoms start with a small letter (see &lt;code&gt;Atom&lt;/code&gt;), for example, &lt;code&gt;charles&lt;/code&gt;, &lt;code&gt;centimeter&lt;/code&gt;, and &lt;code&gt;inch&lt;/code&gt;. Atoms are simply names, nothing else. They are not like variables, which can have a value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7195f879141a5a8ba030248689c692d5148b0ee2" translate="yes" xml:space="preserve">
          <source>AtomConst ::= Application | Module | Release</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c66839560fb43e9f121274907f35e59ef182189" translate="yes" xml:space="preserve">
          <source>Atomic Memory Operations and the VM</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="285aeb96eeef706de92b804eae05d172e8e0a60b" translate="yes" xml:space="preserve">
          <source>Atomic grouping subpatterns are not capturing subpatterns. Simple cases such as the above example can be thought of as a maximizing repeat that must swallow everything it can. So, while both \d+ and \d+? are prepared to adjust the number of digits they match to make the remaining pattern match, &lt;code&gt;(?&amp;gt;\d+)&lt;/code&gt; can only match an entire sequence of digits.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70263cc27057f40aecb08445d5e4246aa30c686a" translate="yes" xml:space="preserve">
          <source>Atomic groups in general can contain any complicated subpatterns, and can be nested. However, when the subpattern for an atomic group is just a single repeated item, as in the example above, a simpler notation, called a &quot;possessive quantifier&quot; can be used. This consists of an extra + character following a quantifier. Using this notation, the previous example can be rewritten as</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d74d1749d4da9ae8e4ba38276cc8935928009a4" translate="yes" xml:space="preserve">
          <source>Atomic transactions. A series of table manipulation operations can be grouped into a single atomic transaction.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e24ad40d30afa103adc1e00c3958d38ebb6700ca" translate="yes" xml:space="preserve">
          <source>Atomically changes the registered name &lt;code&gt;Name&lt;/code&gt; on all nodes to refer to &lt;code&gt;Pid&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee048f7e55224c5c36ed6495f528ec9c74109599" translate="yes" xml:space="preserve">
          <source>Atomicity is important when it is needed to write atomically more than one record in the same transaction. The function &lt;code&gt;raise/2&lt;/code&gt;, shown in the previous example, writes one record only. The function &lt;code&gt;insert_emp/3&lt;/code&gt;, shown in the program listing in &lt;code&gt;&lt;a href=&quot;mnesia_chap2#getting_started&quot;&gt;Getting Started&lt;/a&gt;&lt;/code&gt;, writes the record &lt;code&gt;employee&lt;/code&gt; as well as employee relations, such as &lt;code&gt;at_dep&lt;/code&gt; and &lt;code&gt;in_proj&lt;/code&gt;, into the database. If this latter code is run inside a transaction, the transaction handler ensures that the transaction either succeeds completely, or not at all.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e7bf26b3574db121c0f9c2d5135066a290bba9b" translate="yes" xml:space="preserve">
          <source>Atomicity means that database changes that are executed by a transaction take effect on all nodes involved, or on none of the nodes. That is, the transaction either succeeds entirely, or it fails entirely.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f53a98286f82798d588f67a7f0db19f7aebc839e" translate="yes" xml:space="preserve">
          <source>Atoms</source>
          <target state="translated">Atoms</target>
        </trans-unit>
        <trans-unit id="8b4ce0020874da6c44e911622f2debe1461e0f0d" translate="yes" xml:space="preserve">
          <source>Atoms and variables can use all Latin-1 letters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e89bc7b897d5b27ce2d498db94d099bf846c461" translate="yes" xml:space="preserve">
          <source>Atoms are not garbage-collected. Once an atom is created, it is never removed. The emulator terminates if the limit for the number of atoms (1,048,576 by default) is reached.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53953ef0095a671ea4007a14634a7ef6dcdd0975" translate="yes" xml:space="preserve">
          <source>Atoms starting with &lt;code&gt;@&lt;/code&gt;, for example &lt;code&gt;'@foo'&lt;/code&gt; or &lt;code&gt;'@Foo'&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf1f2e1b1dd67aa033d9dce573a905b7f9461d62" translate="yes" xml:space="preserve">
          <source>Attaches comments to a syntax tree. The result is a pair &lt;code&gt;{NewTree, Remainder}&lt;/code&gt; where &lt;code&gt;NewTree&lt;/code&gt; is the given &lt;code&gt;Tree&lt;/code&gt; where comments from the list &lt;code&gt;Comments&lt;/code&gt; have been attached at the proper places. &lt;code&gt;Remainder&lt;/code&gt; is the list of entries in &lt;code&gt;Comments&lt;/code&gt; which have not been inserted, because their line numbers are greater than those of any node in the tree. The entries in &lt;code&gt;Comments&lt;/code&gt; are inserted in order; if two comments become attached to the same node, they will appear in the same order in the program text.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2ceee4cae7cbba986c24f620add3c4dd9b79139" translate="yes" xml:space="preserve">
          <source>Attaches comments to the syntax tree/trees representing a program. The given &lt;code&gt;Forms&lt;/code&gt; should be a single syntax tree of type &lt;code&gt;form_list&lt;/code&gt;, or a list of syntax trees representing &quot;program forms&quot;. The syntax trees must contain valid position information (for details, see &lt;code&gt;recomment_tree/2&lt;/code&gt;). The result is a corresponding syntax tree of type &lt;code&gt;form_list&lt;/code&gt; in which all comments in the list &lt;code&gt;Comments&lt;/code&gt; have been attached at the proper places.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08f3c18f1ef82b85d187f359be8053ba60fcff3a" translate="yes" xml:space="preserve">
          <source>Attaches to the debugged process &lt;code&gt;Pid&lt;/code&gt;. An Attach Process window is opened for the process.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e858ba60db5ffa465fde04178472518163ea425c" translate="yes" xml:space="preserve">
          <source>Attaches to the debugged process &lt;code&gt;Pid&lt;/code&gt;. The interpreter calls &lt;code&gt;spawn(Module, Name, [Pid])&lt;/code&gt; (and ignores the result).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc33862cfcafa306527c136f22aeb55fbb46ae26" translate="yes" xml:space="preserve">
          <source>Attaches to the process and open an &lt;code&gt;&lt;a href=&quot;#attach&quot;&gt;Attach Process window&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a27b2860df5ad784c2a072eec792bd3ddbfbbcf2" translate="yes" xml:space="preserve">
          <source>Attempt to delete the current directory. On some platforms, &lt;code&gt;eacces&lt;/code&gt; is returned instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4dd873defa6a2d59737d4e84f136645c52891193" translate="yes" xml:space="preserve">
          <source>Attribute &lt;code&gt;-dialyzer()&lt;/code&gt; can also be used for turning on warnings. For example, if a module has been fixed regarding unmatched returns, adding the following line can help in assuring that no new unmatched return warnings are introduced:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94a2d033077fb7d4c11be4d28e975e8f7fa67d5d" translate="yes" xml:space="preserve">
          <source>Attribute &lt;code&gt;-dialyzer()&lt;/code&gt; can be used for turning off warnings in a module by specifying functions or warning options. For example, to turn off all warnings for the function &lt;code&gt;f/0&lt;/code&gt;, include the following line:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3bb46baccc6ddbcfec9893a911a5598494b5fa7f" translate="yes" xml:space="preserve">
          <source>Attribute &lt;code&gt;-dialyzer()&lt;/code&gt; is allowed after function declarations. Lists of warning options or functions are allowed:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20497f389e60747b76a9f4c282fe115ff9e65b81" translate="yes" xml:space="preserve">
          <source>Attribute = {atom(), term()}</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56cec620065c043a2c53d113a84f30cf04a24bfc" translate="yes" xml:space="preserve">
          <source>Attributes = [{Name, Value}| #xmlAttribute{}]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8196898f60a411611bff755ce53bcb927eed9bf5" translate="yes" xml:space="preserve">
          <source>Audit Trail Logging</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7a0dac799c2ac1aee5c36d21a89de6463f1070c" translate="yes" xml:space="preserve">
          <source>Auth-Application-Id AVP</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f57677bc7cc52df8c3d26defd5359054852e0c9" translate="yes" xml:space="preserve">
          <source>Auth-Grace-Period AVP</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ffad30279d0dbdebdba0995b72cf095104751ce5" translate="yes" xml:space="preserve">
          <source>Auth-Request-Type AVP</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bab9dd08fa19bdf6f1b4cf6e9f78668ae505c80e" translate="yes" xml:space="preserve">
          <source>Auth-Request-Type AVP Values</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8ff104e64da7ae152dbd68cb8bb5ac85c8606c8" translate="yes" xml:space="preserve">
          <source>Auth-Session-State AVP</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52aa2478028e9ddcf53894d8996729bb4145d0b1" translate="yes" xml:space="preserve">
          <source>Auth-Session-State AVP Values</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b01542a7f0aa1f0864e6a230526030dbd833afdd" translate="yes" xml:space="preserve">
          <source>Authenticate the connection using simple authentication.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="efdb86330764c8fbe68da0d4b6819ef23c162680" translate="yes" xml:space="preserve">
          <source>Authenticating the integrity of the handshake messages.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a30fd25c7a3f93a7b30740a0a98229a0638bb08" translate="yes" xml:space="preserve">
          <source>Authentication (done by &lt;code&gt;net_kernel(3)&lt;/code&gt;) (3)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc6b01190c75db5a643cf18f6685ef326b9bb4bb" translate="yes" xml:space="preserve">
          <source>Authentication determines which nodes are allowed to communicate with each other. In a network of different Erlang nodes, it is built into the system at the lowest possible level. Each node has its own &lt;strong&gt;magic cookie&lt;/strong&gt;, which is an Erlang atom.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b69c9c9364edcba7a03ffefeefa382cf82287356" translate="yes" xml:space="preserve">
          <source>Authentication of the peer is done by public key path validation as defined in RFC 3280. This means basically the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65b45c1a860b3348b9833c0a96364a1acd14c2b7" translate="yes" xml:space="preserve">
          <source>Authentication/access checks.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ba9c0e85dda9702580d19335be06fa7a8c504cb" translate="yes" xml:space="preserve">
          <source>Authorization Session State Machine</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd708bd6499f399dc5b86474d073a1c2f25376ad" translate="yes" xml:space="preserve">
          <source>Authorization and accounting AVPs are defined in provided dictionaries. Their proper use is the responsibility of the user.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f163341ede12f9adebdea0335c91c64ca9f864cb" translate="yes" xml:space="preserve">
          <source>Authorization is the responsibility of the user.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50b27cabe4dbb1d4ad17bfe9e56741a4affc2eea" translate="yes" xml:space="preserve">
          <source>Authorization is the responsibility of the user: diameter does not implement this state machine.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30ed2a3e728e1f003c2a2c8e103841be8b0ec854" translate="yes" xml:space="preserve">
          <source>Authorization-Lifetime AVP</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="edd7b5046b035f96ef22223b25da57cd6e60a20a" translate="yes" xml:space="preserve">
          <source>Authorized keys - OpenSSH format looks as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a574cde3f8131fcb2c5ef5b3ac87763f839e4628" translate="yes" xml:space="preserve">
          <source>Auto-imported BIFs are listed without module prefix. BIFs listed with module prefix are not auto-imported.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5883a7e0cca29e11fe6124ccc75bacf71f8b9f1" translate="yes" xml:space="preserve">
          <source>Automated execution of test suites (sets of test cases)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d436c113d37a4bf9ab8a69c9c589f736a5417312" translate="yes" xml:space="preserve">
          <source>Automatic compilation of test suites (and help modules)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fccc42c97a2ffc422d0e26337a4e4d5dff20a9b3" translate="yes" xml:space="preserve">
          <source>Automatic send transaction ack when the transaction reply has been received (see &lt;code&gt;trans_ack&lt;/code&gt; below).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca478c0ab639849e3541da90cb17a860b5490d08" translate="yes" xml:space="preserve">
          <source>Automatic send transaction pending if the timer expires before a transaction reply has been sent. This timer is also called provisional response timer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93da85ea44d26c2624d1e105b7f890bc46bd09ba" translate="yes" xml:space="preserve">
          <source>Automatic state enter calls</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a89768431c505706353574d66358c32a869dccc" translate="yes" xml:space="preserve">
          <source>Automatic type-casting probably makes these changes necessary only for a driver that encounters sizes &amp;gt; 32 bits.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ef94894ba2f4eb73cf0fd7bdecec218163555bf" translate="yes" xml:space="preserve">
          <source>Automatically inserted by Logger. The value is the same as the &lt;code&gt;HandlerId&lt;/code&gt; specified when adding the handler, and it cannot be changed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77c6bd373dea25df6392c697b76ebb783fd68b3e" translate="yes" xml:space="preserve">
          <source>Automatically inserted by Logger. The value is the same as the &lt;code&gt;Module&lt;/code&gt; specified when adding the handler, and it cannot be changed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32d8c661feaa1a96e94bb053c82356a83532060b" translate="yes" xml:space="preserve">
          <source>Automatically send pending if the timer expires before a transaction reply has been sent. This timer is also called provisional response timer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18da0ae80b2a3d06e9335371a77bc11e953c941d" translate="yes" xml:space="preserve">
          <source>Autoresume</source>
          <target state="translated">Autoresume</target>
        </trans-unit>
        <trans-unit id="440311567fa2e46e6495460ee5e7f6ca1160021b" translate="yes" xml:space="preserve">
          <source>Available only in some POSIX systems, this call results in a call to &lt;code&gt;fsync()&lt;/code&gt;, or has no effect in systems not providing the &lt;code&gt;fdatasync()&lt;/code&gt; syscall.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5325c58f3190f03981f3d4b6e263a0fcae8b5bc" translate="yes" xml:space="preserve">
          <source>Available options are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="057b4b33c8569c09b413019743ff85bf2e11c330" translate="yes" xml:space="preserve">
          <source>Available options:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e9d1b7f151f31fb76e5b9ef9857c7c1cae6dcf2" translate="yes" xml:space="preserve">
          <source>Available properties are the same as the start options of the server, but the properties &lt;code&gt;bind_address&lt;/code&gt; and &lt;code&gt;port&lt;/code&gt; cannot be changed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef104ec434506c3596f5487f13a01379d4ba6bd2" translate="yes" xml:space="preserve">
          <source>Available through &lt;code&gt;erlang:trace/3&lt;/code&gt; with trace flag &lt;code&gt;'receive'&lt;/code&gt; and &lt;code&gt;{tracer,dyntrace,[]}&lt;/code&gt; as tracer module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27f7db47a04206f9b18980fb6fca2934f7e7d231" translate="yes" xml:space="preserve">
          <source>Available through &lt;code&gt;erlang:trace/3&lt;/code&gt; with trace flag &lt;code&gt;call&lt;/code&gt; and &lt;code&gt;{tracer,dyntrace,[]}&lt;/code&gt; as tracer module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec9c72570d3ed2f9817e1e27636799b0c17600b7" translate="yes" xml:space="preserve">
          <source>Available through &lt;code&gt;erlang:trace/3&lt;/code&gt; with trace flag &lt;code&gt;call&lt;/code&gt; or &lt;code&gt;return_to&lt;/code&gt; and &lt;code&gt;{tracer,dyntrace,[]}&lt;/code&gt; as tracer module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19369e2b69d2d29bcf7d2b110bd632c0497eadc1" translate="yes" xml:space="preserve">
          <source>Available through &lt;code&gt;erlang:trace/3&lt;/code&gt; with trace flag &lt;code&gt;garbage_collection&lt;/code&gt; and &lt;code&gt;{tracer,dyntrace,[]}&lt;/code&gt; as tracer module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b14892085d0235611acf16621043bf554272c4b" translate="yes" xml:space="preserve">
          <source>Available through &lt;code&gt;erlang:trace/3&lt;/code&gt; with trace flag &lt;code&gt;ports&lt;/code&gt; and &lt;code&gt;{tracer,dyntrace,[]}&lt;/code&gt; as tracer module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98fc651851a4575e9edd1b04d22bca4d2ff1533e" translate="yes" xml:space="preserve">
          <source>Available through &lt;code&gt;erlang:trace/3&lt;/code&gt; with trace flag &lt;code&gt;procs&lt;/code&gt; and &lt;code&gt;{tracer,dyntrace,[]}&lt;/code&gt; as tracer module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f46a50dcc99ab759ab69e8cdf416560bd6713f8" translate="yes" xml:space="preserve">
          <source>Available through &lt;code&gt;erlang:trace/3&lt;/code&gt; with trace flag &lt;code&gt;running&lt;/code&gt; and &lt;code&gt;{tracer,dyntrace,[]}&lt;/code&gt; as tracer module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04747a5c4337891e1a74cc42657f396a199e1343" translate="yes" xml:space="preserve">
          <source>Available through &lt;code&gt;erlang:trace/3&lt;/code&gt; with trace flag &lt;code&gt;send&lt;/code&gt; and &lt;code&gt;{tracer,dyntrace,[]}&lt;/code&gt; as tracer module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0979e25ae12ecf75e6954405c51afc218144f433" translate="yes" xml:space="preserve">
          <source>Average packet size deviation, in bytes, received by the socket.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24a6380cb9d560f221f5bab0ac3ac216888c3989" translate="yes" xml:space="preserve">
          <source>Average packet size deviation, in bytes, sent from the socket.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba5da32502768a08b71f47f54787f1a18d984da2" translate="yes" xml:space="preserve">
          <source>Average size of packets, in bytes, received by the socket.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a548c980c935b270267b69573bc6d8a367a0ccd7" translate="yes" xml:space="preserve">
          <source>Average size of packets, in bytes, sent from the socket.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9310b13917c5edfa2bbc94f7c936299d95178f26" translate="yes" xml:space="preserve">
          <source>Avestan</source>
          <target state="translated">Avestan</target>
        </trans-unit>
        <trans-unit id="7666ec90c7fb3e6a7737d1ce78d04e16a63f834f" translate="yes" xml:space="preserve">
          <source>Avoid calling this on the root keys, as it can be slow.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8eebcbcc17ab43565fe594806f1d03745ee4ec86" translate="yes" xml:space="preserve">
          <source>Avoid mixing multiple &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;users&lt;/a&gt;&lt;/code&gt; with driver reload requests.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98289f5c4b0096f8495ef524df96672c88d3f383" translate="yes" xml:space="preserve">
          <source>Avoid the following values of &lt;code&gt;ResourceId&lt;/code&gt;, otherwise Erlang/OTP does not work properly:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ebd07d23bcd301e7132f885cb8e225fce4de1c1" translate="yes" xml:space="preserve">
          <source>Avoiding common mistakes:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8677c671e8bfb9480004f697032e107bf2d89ade" translate="yes" xml:space="preserve">
          <source>B/SFR</source>
          <target state="translated">B/SFR</target>
        </trans-unit>
        <trans-unit id="d6a2b7b76ae3b1331d97630c6fbdfda1e2e20faf" translate="yes" xml:space="preserve">
          <source>BEAM is a register-based virtual machine. It has 1024 virtual registers that are used for holding temporary values and for passing arguments when calling functions. Variables that need to survive a function call are saved to the stack.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e374de82335c7a8d86c8e4d74077c948da138e0" translate="yes" xml:space="preserve">
          <source>BEAM is a threaded-code interpreter. Each instruction is word pointing directly to executable C-code, making instruction dispatching very fast.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7efce4656362191b2f6893e9594afff40994fed8" translate="yes" xml:space="preserve">
          <source>BIFs are functions that for some reason are built-in to the Erlang virtual machine. BIFs often implement functionality that is impossible or is too inefficient to implement in Erlang. Some BIFs can be called using the function name only but they are by default belonging to the &lt;code&gt;erlang&lt;/code&gt; module. For example, the call to the BIF &lt;code&gt;trunc&lt;/code&gt; below is equivalent to a call to &lt;code&gt;erlang:trunc&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="890c2ec47feac80bf8654b893be74f130c02facf" translate="yes" xml:space="preserve">
          <source>BIFs are implemented in C code in the runtime system. BIFs do things that are difficult or impossible to implement in Erlang. Most of the BIFs belong to the module &lt;code&gt;erlang&lt;/code&gt; but there are also BIFs belonging to a few other modules, for example &lt;code&gt;lists&lt;/code&gt; and &lt;code&gt;ets&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42278b69b892fd26dcff3099719503a85d2ed515" translate="yes" xml:space="preserve">
          <source>BIFs can fail for various reasons. All BIFs fail with reason &lt;code&gt;badarg&lt;/code&gt; if they are called with arguments of an incorrect type. The other reasons are described in the description of each individual BIF.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0971b2037c9ec621fb794e414dbe4e3e6e9ea234" translate="yes" xml:space="preserve">
          <source>Back at the top level, the next character (&quot;c&quot;) is compared with what subpattern 2 matched, which was &quot;a&quot;. This fails. As the recursion is treated as an atomic group, there are now no backtracking points, and so the entire match fails. (Perl can now re-enter the recursion and try the second alternative.) However, if the pattern is written with the alternatives in the other order, things are different:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48a05ca6fa60802ff208e26ea9e34464ac28a529" translate="yes" xml:space="preserve">
          <source>Back references of this type cause the group that they reference to be treated as an atomic group. Once the whole group has been matched, a subsequent matching failure cannot cause backtracking into the middle of the group.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab429c0e231fa759e013662e3a14521ce2c5b79b" translate="yes" xml:space="preserve">
          <source>Backend functions used by &lt;code&gt;inet:gethostbyaddr/1&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4aa3add341382a466d659f858fca56aef2ce0f58" translate="yes" xml:space="preserve">
          <source>Backend functions used by &lt;code&gt;inet:gethostbyname/1,2&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a826c283ce6a52f2d32eb19de6510cb9098ad99b" translate="yes" xml:space="preserve">
          <source>Backslash</source>
          <target state="translated">Backslash</target>
        </trans-unit>
        <trans-unit id="88d130a66de8e5db01660642d9f23e1f0eef97dd" translate="yes" xml:space="preserve">
          <source>Backspace</source>
          <target state="translated">Backspace</target>
        </trans-unit>
        <trans-unit id="84e3bb9dd16cb2ba0f02d7245545feda5e3cabcb" translate="yes" xml:space="preserve">
          <source>Backspace.</source>
          <target state="translated">Backspace.</target>
        </trans-unit>
        <trans-unit id="7fc5d71b3eae328beb908064e6dec5ed2151041f" translate="yes" xml:space="preserve">
          <source>Backup and restore of C node state to and from &lt;code&gt;Mnesia&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="643aeb5ad5e07a8a0aedfaec9f291b8b2d8eb1e8" translate="yes" xml:space="preserve">
          <source>Backup operation are performed with the following functions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1b1261f879477741073cc5643737c50cece295a" translate="yes" xml:space="preserve">
          <source>Backup persistent data handled by the manager.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48159fb2ea43e7a90492b5cc62df25d733040b1d" translate="yes" xml:space="preserve">
          <source>Backup persistent/permanent data handled by the agent (such as local-db, mib-data and vacm).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76b2ca97753e81a47e64d73e23600b3684a357e4" translate="yes" xml:space="preserve">
          <source>Backup, restore, fallback, and disaster recovery</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8afb5bf327667dc553b8e9a32ac34a080d815b3b" translate="yes" xml:space="preserve">
          <source>BackupDir cannot be identical to DbDir.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f132fe31e8d713406288c3f7dcb9dbc8378cfdf5" translate="yes" xml:space="preserve">
          <source>Backward character</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82c36d6a4f52a2dc6589f184f22fdf4b95e97b1c" translate="yes" xml:space="preserve">
          <source>Backward kill line</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5be769b9776675c14c24d6f30ed3fba3e401a997" translate="yes" xml:space="preserve">
          <source>Backward kill word</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0b7a7d6f9015db486c407e9f3cba9dc8dea0ff8" translate="yes" xml:space="preserve">
          <source>Backward word</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1161e058ccd842cdd5e5fe2efd102fbd9ed43bbd" translate="yes" xml:space="preserve">
          <source>Bad argument in an arithmetic expression.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af4ade1fd757cc8bcb7e76a2f6d37f1ec5bbb7b5" translate="yes" xml:space="preserve">
          <source>Bad argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4cf9343231b13c7b7056a157910cd49cc8ff14e" translate="yes" xml:space="preserve">
          <source>Bad argument. The argument is of wrong data type, or is otherwise badly formed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3401e9b8481ac17e3759a0b06770cb6fc7bbc79c" translate="yes" xml:space="preserve">
          <source>Bad input arguments to &lt;code&gt;open_port&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c79c6d51e7687de96c195245b69faaf4a624b33e" translate="yes" xml:space="preserve">
          <source>Balinese</source>
          <target state="translated">Balinese</target>
        </trans-unit>
        <trans-unit id="00a38285d256e3839414c33b846ee83469fa016a" translate="yes" xml:space="preserve">
          <source>Bamum</source>
          <target state="translated">Bamum</target>
        </trans-unit>
        <trans-unit id="26e5990472188146a21fbe9216d5e35fd4688af2" translate="yes" xml:space="preserve">
          <source>Base Protocol Command AVP Table</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9e2287d49a0defabf83f04683cfd099fe9d2461" translate="yes" xml:space="preserve">
          <source>Based on this feature, the OTP application SASL provides a framework for upgrading and downgrading between different versions of an entire release in runtime. This is called &lt;strong&gt;release handling&lt;/strong&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37e7613ad8170257c16610a53d06cfb1a6379742" translate="yes" xml:space="preserve">
          <source>Basic AVP Data Formats</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b9ebfc825400dcd8efd5ccd3ed7166c57bc3280" translate="yes" xml:space="preserve">
          <source>Basic Encoding Rules (BER)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60289c0d7f3cdae9e1d8eee79fef52de4c163a03" translate="yes" xml:space="preserve">
          <source>Basic knowledge of Emacs and Erlang/OTP.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9dd9d44759000b74a8ffb28eb7a9b5d4bda605bf" translate="yes" xml:space="preserve">
          <source>Basic usage consists of creating a representation of a locally implemented Diameter node and its capabilities with &lt;code&gt;&lt;a href=&quot;#start_service-2&quot;&gt;start_service/2&lt;/a&gt;&lt;/code&gt;, adding transport capability using &lt;code&gt;&lt;a href=&quot;#add_transport-2&quot;&gt;add_transport/2&lt;/a&gt;&lt;/code&gt; and sending Diameter requests and receiving Diameter answers with &lt;code&gt;&lt;a href=&quot;#call-4&quot;&gt;call/4&lt;/a&gt;&lt;/code&gt;. Incoming Diameter requests are communicated as callbacks to a &lt;code&gt;diameter_app(3)&lt;/code&gt; callback modules as specified in the service configuration.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d03e3070f8930ea991974fa59117d8692bbcffdd" translate="yes" xml:space="preserve">
          <source>Basically the same as UTF-32, but without some Unicode semantics, defined by IEEE, and has little use as a separate encoding standard. For all normal (and possibly abnormal) use, UTF-32 and UCS-4 are interchangeable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7299a57060c9f81f94931f5581972334cd31d5c2" translate="yes" xml:space="preserve">
          <source>Basically, the &lt;code&gt;etags&lt;/code&gt; utility is ran using the following form:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38c83af4610a697d6724ff3bf3f45adb4124041d" translate="yes" xml:space="preserve">
          <source>Basically, the procedure is as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c6f5bb2c23fc72e02ed4fe91c08eb86ab7eb097" translate="yes" xml:space="preserve">
          <source>Basics on how computers are programmed</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="075b61c3bd00c5372d9b40a37e76d0e216819b8e" translate="yes" xml:space="preserve">
          <source>Bassa_Vah</source>
          <target state="translated">Bassa_Vah</target>
        </trans-unit>
        <trans-unit id="8c4b76d47cc4be674049d954ba4923101a8b3e4d" translate="yes" xml:space="preserve">
          <source>Batak</source>
          <target state="translated">Batak</target>
        </trans-unit>
        <trans-unit id="58c655b2cd5d86487b8917d2d93a7efbac26efff" translate="yes" xml:space="preserve">
          <source>Be aware that &lt;code&gt;enif_schedule_nif&lt;/code&gt;, as its name implies, only schedules the NIF for future execution. The calling NIF does not block waiting for the scheduled NIF to execute and return. This means that the calling NIF cannot expect to receive the scheduled NIF return value and use it for further operations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1bb1d4b8960f0882b546a0b46a0612e449641efb" translate="yes" xml:space="preserve">
          <source>Be careful when setting the shutdown time to &lt;code&gt;infinity&lt;/code&gt; when the child process is a worker. Because, in this situation, the termination of the supervision tree depends on the child process, it must be implemented in a safe way and its cleanup procedure must always return.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ffb65a64fc348102ef56127a672718177ad2a7ab" translate="yes" xml:space="preserve">
          <source>Be careful when setting the shutdown time to &lt;code&gt;infinity&lt;/code&gt; when the child process is a worker. Because, in this situation, the termination of the supervision tree depends on the child process; it must be implemented in a safe way and its cleanup procedure must always return.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2fd62499ab8def7b8b69fee274c4b8917538a4e1" translate="yes" xml:space="preserve">
          <source>Be careful with the version header, use &lt;code&gt;ei_x_new_with_version()&lt;/code&gt; when appropriate.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7301ce2a6e0b85e60f35ab88d520e5d9725285df" translate="yes" xml:space="preserve">
          <source>Be started in a way that makes the process fit into a supervision tree</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="105320a56b534ace4c0d31c6412a7c5d4168a815" translate="yes" xml:space="preserve">
          <source>Be sure &lt;strong&gt;not&lt;/strong&gt; no name the directory containing the measurement binaries starting with 'megaco-', e.g. megaco-meas. This will confuse the erlang application loader (erlang applications are named, e.g. megaco-1.0.2).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00d0130a026229dfaa52123c4c578740ea2d109c" translate="yes" xml:space="preserve">
          <source>Be sure to read about &lt;code&gt;Long-running NIFs&lt;/code&gt; before writing a NIF.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2edff3a35b65adb5039205d11c2d7f121323a42" translate="yes" xml:space="preserve">
          <source>Because a &lt;code&gt;simple_one_for_one&lt;/code&gt; supervisor can have many children, it shuts them all down asynchronously. This means that the children will do their cleanup in parallel and therefore the order in which they are stopped is not defined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="abef4f4009e13039f29fcccf0a57474c315686c1" translate="yes" xml:space="preserve">
          <source>Because lists are commonly used, they have shorthand type notations. The types &lt;code&gt;list(T)&lt;/code&gt; and &lt;code&gt;nonempty_list(T)&lt;/code&gt; have the shorthands &lt;code&gt;[T]&lt;/code&gt; and &lt;code&gt;[T,...]&lt;/code&gt;, respectively. The only difference between the two shorthands is that &lt;code&gt;[T]&lt;/code&gt; can be an empty list but &lt;code&gt;[T,...]&lt;/code&gt; cannot.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b3a7dd1ee18a1a87ef5bd7ed89f7551e8ad10ce" translate="yes" xml:space="preserve">
          <source>Because of network and processing delays, the period of tracing is approximate.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d37fd4abb225a06f4a6768bb951238ff22bfe669" translate="yes" xml:space="preserve">
          <source>Because of peculiarities in the dynamic loading interfaces on different platforms, the returned string is only guaranteed to describe the correct error &lt;strong&gt;if format_error/1 is called in the same instance of the Erlang virtual machine as the error appeared in&lt;/strong&gt; (meaning the same operating system process).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2937aec3114f354420a4dc65f7919f8480931c3a" translate="yes" xml:space="preserve">
          <source>Because of subtype relations that exist between types, types form a lattice where the top-most element, &lt;code&gt;any()&lt;/code&gt;, denotes the set of all Erlang terms and the bottom-most element, &lt;code&gt;none()&lt;/code&gt;, denotes the empty set of terms.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="022a498b7c46fc56b49452af050953c22bfbf306" translate="yes" xml:space="preserve">
          <source>Because of the limited length of atoms, it is recommended to use &lt;code&gt;-run&lt;/code&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1384b995beb9b21c8a759c386f9768bb6e9bf48f" translate="yes" xml:space="preserve">
          <source>Becomes &lt;strong&gt;\h&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="299f84debe52036e59ae03120fd4f1dabe601f72" translate="yes" xml:space="preserve">
          <source>Becomes &lt;strong&gt;\p{Ll}&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d91b3caacd37fdde510b95d27795a9af6bf8136" translate="yes" xml:space="preserve">
          <source>Becomes &lt;strong&gt;\p{Lu}&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c0abdb743817968c55df2e58d08673027964564" translate="yes" xml:space="preserve">
          <source>Becomes &lt;strong&gt;\p{L}&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="730c516db3536d87659465b8430f3c06b9b28d02" translate="yes" xml:space="preserve">
          <source>Becomes &lt;strong&gt;\p{Nd}&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af6446ff6bb33935f80c0e27353d8c85c94660f6" translate="yes" xml:space="preserve">
          <source>Becomes &lt;strong&gt;\p{Xan}&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="990d22b3bf8b56b82387696e9e8f32390beb8e0c" translate="yes" xml:space="preserve">
          <source>Becomes &lt;strong&gt;\p{Xps}&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89fc848e28a9b477f8a3b6e31d45687e11d42e23" translate="yes" xml:space="preserve">
          <source>Becomes &lt;strong&gt;\p{Xwd}&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ebae434cd88ef2302f9bbb202778d21d2e46d19" translate="yes" xml:space="preserve">
          <source>Before ERTS 10.0 (OTP 21.0), monitoring a process could fail with &lt;code&gt;badarg&lt;/code&gt; if the monitored process resided on a primitive node (such as erl_interface or jinterface), where remote process monitoring is not implemented.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2170fbb9997cb7343b013f87d0b07f06679bee2" translate="yes" xml:space="preserve">
          <source>Before ERTS 5.9 it was possible to configure a smaller number of thread-specific instances than schedulers. This is, however, not possible anymore.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60f2fe367a59604d77c1ee7cdc5c0f81f65eda6e" translate="yes" xml:space="preserve">
          <source>Before ERTS 7.0 (Erlang/OTP 18), the return value from &lt;code&gt;enif_make_badarg&lt;/code&gt; had to be returned from the NIF. This requirement is now lifted as the return value from the NIF is ignored if &lt;code&gt;enif_make_badarg&lt;/code&gt; has been invoked.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8ec3341c03352c2dcbc8cc1ae6efea67d454637" translate="yes" xml:space="preserve">
          <source>Before ERTS 9.0 (OTP-20.0), all resource terms did compare equal to each other and to empty binaries (&lt;code&gt;&amp;lt;&amp;lt;&amp;gt;&amp;gt;&lt;/code&gt;). If serialized, they would be recreated as plain empty binaries.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f16cc2c8df0cf217a1b01164cd474f9be586865b" translate="yes" xml:space="preserve">
          <source>Before ERTS 9.1 (OTP-20.1) only code points in the range 0-255 was accepted in the string. Now any unicode string is valid.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8815a40e2ba0160069e9df632d708ff9fef831a" translate="yes" xml:space="preserve">
          <source>Before Erlang/OTP 17.1, if your test run consisted of multiple tests, cover would be started and stopped for each test within the test run. Separate logs would be available through the &quot;Coverage log&quot; link on the test suite result pages. These links are still available, but now they all point to the same page as the button on the top-level index page. The log contains the accumulated results for the complete test run. For details about this change, see the release notes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="173b9788d3472306f8bca6acb906380d15ebb018" translate="yes" xml:space="preserve">
          <source>Before Erlang/OTP 19, for fields without initial values, the singleton type &lt;code&gt;'undefined'&lt;/code&gt; was added to all declared types. In other words, the following two record declarations had identical effects:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ebd17eea52effdc10d3b387a5f97c65de3d711a" translate="yes" xml:space="preserve">
          <source>Before Erlang/OTP R11B (ERTS 5.5) &lt;code&gt;demonitor/1&lt;/code&gt; behaved completely asynchronously, that is, the monitor was active until the &quot;demonitor signal&quot; reached the monitored entity. This had one undesirable effect. You could never know when you were guaranteed &lt;strong&gt;not&lt;/strong&gt; to receive a &lt;code&gt;DOWN&lt;/code&gt; message because of the monitor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c04cf745a3c4adfcd300b132adf03ceaef66e4c6" translate="yes" xml:space="preserve">
          <source>Before Erlang/OTP R11B (ERTS 5.5) &lt;code&gt;unlink/1&lt;/code&gt; behaved completely asynchronously, that is, the link was active until the &quot;unlink signal&quot; reached the linked entity. This had an undesirable effect, as you could never know when you were guaranteed &lt;strong&gt;not&lt;/strong&gt; to be effected by the link.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14149394b7877b033496395cfd6e420c1de55bda" translate="yes" xml:space="preserve">
          <source>Before Erlang/OTP R16, the port ID could be used as a key with proper casting, but after the rewrite of the port subsystem, this is no longer the case. With this function, you can achieve the same distribution based on port IDs as before Erlang/OTP R16.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="055828a24a30444b0c0047933c2db837ba4b5188" translate="yes" xml:space="preserve">
          <source>Before Linux 3.8, this socket option could be set, but could not retrieved with &lt;code&gt;&lt;a href=&quot;#getopts-2&quot;&gt;getopts/2&lt;/a&gt;&lt;/code&gt;. Since Linux 3.8, it is readable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de814773d3f4ef3f2f57f8421829e0616b1e21de" translate="yes" xml:space="preserve">
          <source>Before OTP 19, if the &lt;code&gt;on_load&lt;/code&gt; function failed, any previously current code would become old, essentially leaving the system without any working and reachable instance of the module. That problem has been eliminated in OTP 19.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0463b80fdbddc48ab1e8bca76239196573ee534f" translate="yes" xml:space="preserve">
          <source>Before OTP R14A (ERTS version 5.8), an implicitly qualified function call to a function having the same name as an auto-imported BIF always resulted in the BIF being called. In newer versions of the compiler, the local function is called instead. This is to avoid that future additions to the set of auto-imported BIFs do not silently change the behavior of old code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b947a51569cc1cfaeef7b7ff4bf48e678a02c245" translate="yes" xml:space="preserve">
          <source>Before R14, parentheses were needed as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="777f496c9fcf95c8a759b97ce9f5b072f83c3c75" translate="yes" xml:space="preserve">
          <source>Before a driver can be called from Erlang, it must be loaded and opened. Loading is done using the &lt;code&gt;erl_ddll&lt;/code&gt; module (the &lt;code&gt;erl_ddll&lt;/code&gt; driver that loads dynamic driver is actually a driver itself). If loading is successfull, the port can be opened with &lt;code&gt;open_port/2&lt;/code&gt;. The port name must match the name of the shared library and the name in the driver entry structure.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20019fdf1abe6fd7869945f2f7dac92f9f72ebdc" translate="yes" xml:space="preserve">
          <source>Before a file is transferred, the following call is made to indicate the start of the file transfer and how large the file is. The return value of the callback function is to be a new value for the &lt;code&gt;UserProgressTerm&lt;/code&gt; that will be used as input the next time the callback function is called.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="159e2277de857354c36db29ad08f2c463be464e2" translate="yes" xml:space="preserve">
          <source>Before an application can be started, it must be &lt;strong&gt;loaded&lt;/strong&gt;. The application controller reads and stores the information from the &lt;code&gt;.app&lt;/code&gt; file:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="afd284c8bc9adc5dd4975944173af35c38112da6" translate="yes" xml:space="preserve">
          <source>Before an application makes its first access to a table, &lt;code&gt;&lt;a href=&quot;mnesia#wait_for_tables-2&quot;&gt;mnesia:wait_for_tables(TabList, Timeout)&lt;/a&gt;&lt;/code&gt; is to be executed to ensure that the table is accessible from the local node. If the function times out, the application can choose to force a load of the local replica with &lt;code&gt;&lt;a href=&quot;mnesia#force_load_table-1&quot;&gt;mnesia:force_load_table(Tab)&lt;/a&gt;&lt;/code&gt; and deliberately lose all updates that can have been performed on the other nodes while the local node was down. If &lt;code&gt;Mnesia&lt;/code&gt; has loaded the table on another node already, or intends to do so, copy the table from that node to avoid unnecessary inconsistency.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75a2137a0d589f3ac4ee86651537916f812a4998" translate="yes" xml:space="preserve">
          <source>Before any analysis can take place, module data must be &lt;strong&gt;set up&lt;/strong&gt;. For instance, the cross reference and the unknown functions are computed when all module data are known. The functions that need complete data (&lt;code&gt;analyze&lt;/code&gt;, &lt;code&gt;q&lt;/code&gt;, &lt;code&gt;variables&lt;/code&gt;) take care of setting up data automatically. Module data need to be set up (again) after calls to any of the &lt;code&gt;add&lt;/code&gt;, &lt;code&gt;replace&lt;/code&gt;, &lt;code&gt;remove&lt;/code&gt;, &lt;code&gt;set_library_path&lt;/code&gt; or &lt;code&gt;update&lt;/code&gt; functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca67bda82873ef4332d857192e18635d990609ed" translate="yes" xml:space="preserve">
          <source>Before any analysis can take place, the involved modules must be &lt;strong&gt;Cover compiled&lt;/strong&gt;. This means that some extra information is added to the module before it is compiled into a binary which then is &lt;code&gt;&lt;a href=&quot;#loading&quot;&gt;loaded&lt;/a&gt;&lt;/code&gt;. The source file of the module is not affected and no &lt;code&gt;.beam&lt;/code&gt; file is created.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="258fe4cd782832c98fba1da0a69f9a8b68aa3908" translate="yes" xml:space="preserve">
          <source>Before any analysis can take place, the involved modules must be &lt;strong&gt;Cover compiled&lt;/strong&gt;. This means that some extra information is added to the module before it is compiled into a binary which then is loaded. The source file of the module is not affected and no &lt;code&gt;.beam&lt;/code&gt; file is created.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="451eac2b19829254921c8ba2920439b2b92145f5" translate="yes" xml:space="preserve">
          <source>Before applying a patch you need to do a &lt;strong&gt;full&lt;/strong&gt; build of OTP in the source directory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0af32825676162dfe9c05e6f703b3efa51985180" translate="yes" xml:space="preserve">
          <source>Before asking a question you can browse the &lt;a href=&quot;http://www.erlang.org/pipermail/erlang-questions/&quot;&gt; mailing list archive&lt;/a&gt; and read the &lt;a href=&quot;http://www.erlang.org/faq/faq.html&quot;&gt;Frequently Asked Questions&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cda5c6edb9898f9347103f74f622c57ddde1c654" translate="yes" xml:space="preserve">
          <source>Before calling any of the other &lt;code&gt;Erl_Interface&lt;/code&gt; functions, call &lt;code&gt;erl_init()&lt;/code&gt; exactly once to initialize the library. &lt;code&gt;erl_init()&lt;/code&gt; takes two arguments. However, the arguments are no longer used by &lt;code&gt;Erl_Interface&lt;/code&gt; and are therefore to be specified as &lt;code&gt;erl_init(NULL,0)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5913933d73f661127a755638c745adee88554860" translate="yes" xml:space="preserve">
          <source>Before calling any other function in Erl_Interface, the memory handling must be initiated:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c91078fc982ffe0902391841ac4ff114e2a4c572" translate="yes" xml:space="preserve">
          <source>Before execution of a group begins, the configuration function &lt;code&gt;&lt;a href=&quot;common_test#Module:init_per_group-2&quot;&gt;init_per_group(GroupName, Config)&lt;/a&gt;&lt;/code&gt; is called. The list of tuples returned from this function is passed to the test cases in the usual manner by argument &lt;code&gt;Config&lt;/code&gt;. &lt;code&gt;init_per_group/2&lt;/code&gt; is meant to be used for initializations common for the test cases in the group. After execution of the group is finished, function &lt;code&gt;&lt;a href=&quot;common_test#Module:end_per_group-2&quot;&gt;end_per_group(GroupName, Config)&lt;/a&gt;&lt;/code&gt; is called. This function is meant to be used for cleaning up after &lt;code&gt;init_per_group/2&lt;/code&gt;. If the init function is defined, so must the end function be.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dfe638852bde7e76a1e9584d5c09fb0ca66d3651" translate="yes" xml:space="preserve">
          <source>Before execution of the timetrap function (which is performed on a parallel, dedicated timetrap process), &lt;code&gt;Common Test&lt;/code&gt; cancels any previously set timer for the test case or configuration function. When the timetrap function returns, the time-out is triggered, &lt;strong&gt;unless&lt;/strong&gt; the return value is a valid timetrap time, such as an integer, or a &lt;code&gt;{SecMinOrHourTag,Time}&lt;/code&gt; tuple (for details, see module &lt;code&gt;&lt;a href=&quot;common_test&quot;&gt;common_test&lt;/a&gt;&lt;/code&gt;). If a time value is returned, a new timetrap is started to generate a time-out after the specified time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08b1254c8bec1bc486b54b5a55646cb74814353f" translate="yes" xml:space="preserve">
          <source>Before going into details of the supervision and error handling in an Erlang system, let us see how Erlang processes terminate, or in Erlang terminology, &lt;strong&gt;exit&lt;/strong&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="158d175d6b77bf980038361a2e334b0ed9a4b8fc" translate="yes" xml:space="preserve">
          <source>Before improving the messenger program, let us look at some general principles, using the ping pong program as an example. Recall that when &quot;ping&quot; finishes, it tells &quot;pong&quot; that it has done so by sending the atom &lt;code&gt;finished&lt;/code&gt; as a message to &quot;pong&quot; so that &quot;pong&quot; can also finish. Another way to let &quot;pong&quot; finish is to make &quot;pong&quot; exit if it does not receive a message from ping within a certain time. This can be done by adding a &lt;strong&gt;time-out&lt;/strong&gt; to &lt;code&gt;pong&lt;/code&gt; as shown in the following example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d0240a960734bd032bfb25f877be3ed95c27ca3" translate="yes" xml:space="preserve">
          <source>Before installation you should test whether your build is working properly by running our smoke test. The smoke test is a subset of the complete Erlang/OTP test suites. First you will need to build and release the test suites.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9b6bb02452d70c4cea213f1df9be77d0db03bc1" translate="yes" xml:space="preserve">
          <source>Before looking at how this program works, notice that a few comments are added to the code. A comment starts with a %-character and goes on to the end of the line. Notice also that the &lt;code&gt;-export([format_temps/1]).&lt;/code&gt; line only includes the function &lt;code&gt;format_temps/1&lt;/code&gt;. The other functions are &lt;strong&gt;local&lt;/strong&gt; functions, that is, they are not visible from outside the module &lt;code&gt;tut5&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12bcc79844186de606633bdd333ae924acec0daf" translate="yes" xml:space="preserve">
          <source>Before registering a name, you should already have registered your port number with &lt;code&gt;epmd&lt;/code&gt;. This is not strictly necessary, but if you neglect to do so, then other nodes wishing to communicate with your service cannot find or connect to your process.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26cb26b93d1388560e328aa535c6bbe4b5f0b51c" translate="yes" xml:space="preserve">
          <source>Before registering with &lt;code&gt;epmd&lt;/code&gt;, you must first create a listen socket and bind it to a port. Then:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c7e0e1b9fcac24580ab6b3d03b6e4b55f4c8972" translate="yes" xml:space="preserve">
          <source>Before starting &lt;code&gt;Mnesia&lt;/code&gt;, the following must be done:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a519a0020d8de31b673de93ded06a0618f853d2" translate="yes" xml:space="preserve">
          <source>Before starting, notice the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7011eaabfad589a3868b28c469ad42e5d05beb89" translate="yes" xml:space="preserve">
          <source>Before the call of &lt;code&gt;deflateParams&lt;/code&gt;, the stream state must be set as for a call of &lt;code&gt;deflate/3&lt;/code&gt;, as the currently available input may have to be compressed and flushed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78fa7e00043ebdf38881948abf63f1275524f7cf" translate="yes" xml:space="preserve">
          <source>Before the first call to &lt;code&gt;allow/1&lt;/code&gt;, any node with the correct cookie can be connected. When &lt;code&gt;allow/1&lt;/code&gt; is called, a list of allowed nodes is established. Any access attempts made from (or to) nodes not in that list will be rejected.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc3113c94757b2848bc9b3cfac6670102a406895" translate="yes" xml:space="preserve">
          <source>Before the log is dumped, the file &lt;code&gt;LATEST.LOG&lt;/code&gt; is renamed to &lt;code&gt;PREVIOUS.LOG&lt;/code&gt;, and a new &lt;code&gt;LATEST.LOG&lt;/code&gt; file is created. Once the log has been successfully dumped, the file &lt;code&gt;PREVIOUS.LOG&lt;/code&gt; is deleted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db255d80fd5fbd19169beeb79eff7051fb467716" translate="yes" xml:space="preserve">
          <source>Before the port is created, the driver must be loaded. This is done with the function &lt;code&gt;erl_dll:load_driver/1&lt;/code&gt;, with the name of the shared library as argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46a334a8ddbc15c984030c1582dd4508b5f21665" translate="yes" xml:space="preserve">
          <source>Before the traversal starts, the source backup media is opened with &lt;code&gt;SourceMod:open_read(Source)&lt;/code&gt;, and the target backup media is opened with &lt;code&gt;TargetMod:open_write(Target)&lt;/code&gt;. The arguments are as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1da9ec4f3c9fc4eb1c3cfeb7777f44d15e8f2fe" translate="yes" xml:space="preserve">
          <source>Before this instruction occurs, &lt;code&gt;Mod&lt;/code&gt; must have been loaded using &lt;code&gt;load_object_code&lt;/code&gt;. This instruction loads the module. &lt;code&gt;PrePurge&lt;/code&gt; is ignored. For a description of &lt;code&gt;PostPurge&lt;/code&gt;, see the high-level instruction &lt;code&gt;update&lt;/code&gt; earlier.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="352876a2381c0951748f4964cadc93f74da158b5" translate="yes" xml:space="preserve">
          <source>Begin the scope of a prefix-URI Namespace mapping. Note that start/endPrefixMapping events are not guaranteed to be properly nested relative to each other: all startPrefixMapping events will occur immediately before the corresponding startElement event, and all endPrefixMapping events will occur immediately after the corresponding endElement event, but their order is not otherwise guaranteed. There will not be start/endPrefixMapping events for the &quot;xml&quot; prefix, since it is predeclared and immutable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef3ba8079ba496eafefddd167fd69849d3349c1c" translate="yes" xml:space="preserve">
          <source>Beginning of line</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0541a24650d9da6d38c74c8da4b43cac73179f4" translate="yes" xml:space="preserve">
          <source>Beginning with Erlang/OTP R14, parentheses when accessing or updating nested records can be omitted. Assume the following record definitions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dbe51e0d3cf7fe095d04d74ded17ede0a93150c5" translate="yes" xml:space="preserve">
          <source>Behaves as &lt;code&gt;&lt;a href=&quot;#characters_to_list-2&quot;&gt;characters_to_list/2&lt;/a&gt;&lt;/code&gt;, but produces a binary instead of a Unicode list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89ade40ae04b2b1a7cb87dcb6495bdb4cd27f4c3" translate="yes" xml:space="preserve">
          <source>Behaves as &lt;code&gt;&lt;a href=&quot;#monitor_node-2&quot;&gt;monitor_node/2&lt;/a&gt;&lt;/code&gt; except that it allows an extra option to be specified, namely &lt;code&gt;allow_passive_connect&lt;/code&gt;. This option allows the BIF to wait the normal network connection time-out for the &lt;strong&gt;monitored node&lt;/strong&gt; to connect itself, even if it cannot be actively connected from this node (that is, it is blocked). The state where this can be useful can only be achieved by using the Kernel option &lt;code&gt;dist_auto_connect once&lt;/code&gt;. If that option is not used, option &lt;code&gt;allow_passive_connect&lt;/code&gt; has no effect.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64aaa639db43c0fb66ead8ebf5d3670fe4ea4ff0" translate="yes" xml:space="preserve">
          <source>Behavior describing the API for public key handling of an SSH client. By implementing the callbacks defined in this behavior, the public key handling of an SSH client can be customized. By default the &lt;code&gt;ssh&lt;/code&gt; application implements this behavior with help of the standard OpenSSH files, see the &lt;code&gt;ssh(6)&lt;/code&gt; application manual.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f16faae4208d9a96f7fb1bb23ef9cd7087ccfdeb" translate="yes" xml:space="preserve">
          <source>Behaviour describing the API for public key handling of an SSH server. By implementing the callbacks defined in this behavior, the public key handling of an SSH server can be customized. By default the SSH application implements this behavior with help of the standard OpenSSH files, see the &lt;code&gt;ssh(6)&lt;/code&gt; application manual.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0d4ec155f7430eef8a27415e38c4ad6595b98c0" translate="yes" xml:space="preserve">
          <source>Behaviour module for reporting SNMP agent errors</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d41c7e7235b92d9c78165f5ea1a1214538b7ae8" translate="yes" xml:space="preserve">
          <source>Behaviour module for the SNMP agent discovery handler.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d88eee718b5f101a30d4bf7abe96e2a4af445a2" translate="yes" xml:space="preserve">
          <source>Behaviour module for the SNMP agent mib storage.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="213836ecbce5c62ee5c70a707ff8f6efbfddb7e0" translate="yes" xml:space="preserve">
          <source>Behaviour module for the SNMP agent mib-server data module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b9ea5bbfad06ea1fc316484f53361a36304e0df" translate="yes" xml:space="preserve">
          <source>Behaviour module for the SNMP agent network interface.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7490591e615b37731085e0dc791786738305c7b" translate="yes" xml:space="preserve">
          <source>Behaviour module for the SNMP agent network-interface filter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d2c6aaaa587ce80e3a95c5e764e760aa91d874b" translate="yes" xml:space="preserve">
          <source>Behaviour module for the SNMP agent notification delivery information receiver.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="625c1c9de2b712103668af5814be0412885b49e5" translate="yes" xml:space="preserve">
          <source>Behaviour module for the SNMP agent notification filters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de9d0d8b19209222093743579cc0da909bbbb028" translate="yes" xml:space="preserve">
          <source>Behaviour module for the SNMP manager network interface.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f41f4d43078504e98d5de4dc916e14eb8a85ba6" translate="yes" xml:space="preserve">
          <source>Behaviour module for the SNMP manager network-interface filter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb1e7ed7fa32a13f652cc9e9bf36d2ab93e52c2b" translate="yes" xml:space="preserve">
          <source>Behaviour module for the SNMP manager user.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77b3fcb503c107fdcf78ea27b16f4310e4bd176a" translate="yes" xml:space="preserve">
          <source>Behaviour with optional callbacks to customize the inets HTTP server.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0f283a40056570ec143d350395380c52fd1c5b2" translate="yes" xml:space="preserve">
          <source>Below is a complete example of what should be added to a user's &lt;code&gt;.emacs&lt;/code&gt; provided that OTP is installed in the directory &lt;code&gt;/usr/local/otp&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1fad7bb629bd2e9041c6abf5bc0a920316f854b0" translate="yes" xml:space="preserve">
          <source>Below is a complete example of what should be added to a user's &lt;code&gt;.emacs&lt;/code&gt; provided that OTP is installed in the directory &lt;code&gt;C:\Program Files\erl&amp;lt;Ver&amp;gt;&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40217191ef85c64b525b787ccb400689f06f21a9" translate="yes" xml:space="preserve">
          <source>Below is an example of the grammar above with structure building code added:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d5970fcf1e0337426fd2a5c1de2fd3082f3b1fe" translate="yes" xml:space="preserve">
          <source>Benchmarks can measure wall-clock time or CPU time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bfb8b17cc74805621ef756d36abfea020e22ec89" translate="yes" xml:space="preserve">
          <source>Benchmarks that appear to be concurrent are often sequential. The estone benchmark, for example, is entirely sequential. So is the most common implementation of the &quot;ring benchmark&quot;; usually one process is active, while the others wait in a &lt;code&gt;receive&lt;/code&gt; statement.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="198e9c0851a2cebe3440bd1cafd71b98e2d83392" translate="yes" xml:space="preserve">
          <source>Bengali</source>
          <target state="translated">Bengali</target>
        </trans-unit>
        <trans-unit id="c274af2a723078651a0cf0e2bdc4b8cb3f48d70d" translate="yes" xml:space="preserve">
          <source>Besides &lt;code&gt;qlc:table/2&lt;/code&gt;, other functions return query handles. They are used more seldom than tables, but are sometimes useful. &lt;code&gt;&lt;a href=&quot;#append-1&quot;&gt;qlc:append/1,2&lt;/a&gt;&lt;/code&gt; traverses objects from many tables or lists after each other. If, for example, you want to traverse all answers to a query &lt;code&gt;QH&lt;/code&gt; and then finish off by a term &lt;code&gt;{finished}&lt;/code&gt;, you can do that by calling &lt;code&gt;qlc:append(QH, [{finished}])&lt;/code&gt;. &lt;code&gt;append/2&lt;/code&gt; first returns all objects of &lt;code&gt;QH&lt;/code&gt;, then &lt;code&gt;{finished}&lt;/code&gt;. If a tuple &lt;code&gt;{finished}&lt;/code&gt; exists among the answers to &lt;code&gt;QH&lt;/code&gt;, it is returned twice from &lt;code&gt;append/2&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6260580b5bc11052e617d5d44b018db15e9a982" translate="yes" xml:space="preserve">
          <source>Besides addressing a process by using its pid, there are also BIFs for registering a process under a name. The name must be an atom and is automatically unregistered if the process terminates:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b15bc3f2eceb04129fd4516b3b370516eb00424d" translate="yes" xml:space="preserve">
          <source>Besides reporting time, &lt;code&gt;erlang:now/0&lt;/code&gt; also produces unique and strictly monotonically increasing values. To detach this functionality from time measurements, we have introduced &lt;code&gt;&lt;a href=&quot;erlang#unique_integer-1&quot;&gt;erlang:unique_integer()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a52810e66627e5a80808e690811322ee8adf786" translate="yes" xml:space="preserve">
          <source>Besides test cases and groups, the test suite can also contain configuration functions. These functions are meant to be used for setting up (and verifying) environment and state in the SUT (and/or the &lt;code&gt;Common Test&lt;/code&gt; host node), required for the tests to execute correctly. Examples of operations are: Opening a connection to the SUT, initializing a database, running an installation script, and so on. Configuration can be performed per suite, per test case group, and per individual test case.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="007ac80b876d6b31b51d4c189993df4c58d1fc5a" translate="yes" xml:space="preserve">
          <source>Besides the already mentioned source parameters &lt;code&gt;root_dir&lt;/code&gt; and &lt;code&gt;lib_dirs&lt;/code&gt;, the following system (&lt;code&gt;sys&lt;/code&gt;) level options are supported:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d77fc5043db349a36fcc2530a0223317a9d51ded" translate="yes" xml:space="preserve">
          <source>Between modules</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e04d97ca7154dfa6468b97d3b9c42d0c616a358" translate="yes" xml:space="preserve">
          <source>Between nodes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3430043cce88789d3bd382a0b2a1bc3c39a24538" translate="yes" xml:space="preserve">
          <source>Between processes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f647ae7d5e7143915c4692eef6551f34333f508c" translate="yes" xml:space="preserve">
          <source>Beware of confusing mandatory in the sense of the M-bit with mandatory in the sense of the command grammar. The former is a semantic requirement: that the receiver understand the semantics of the AVP in the context in question. The latter is a syntactic requirement: whether or not the AVP must occur in the message in question.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a3b08c5bdc112934a46e49f93c6566926eb949f" translate="yes" xml:space="preserve">
          <source>Beware of trailing space in &lt;code&gt;Replacement&lt;/code&gt; to be used. If you must have a space in &lt;code&gt;Re&lt;/code&gt;, use, for example, the character encoding &lt;code&gt;\040&lt;/code&gt;, see &lt;code&gt;re(3)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99e106abb61082912f0a96161c0ad22a4eea32f3" translate="yes" xml:space="preserve">
          <source>Beware of using fun expressions of the form &lt;code&gt;fun Name/Arity&lt;/code&gt; in situations in which the fun is not short-lived and code is to be upgraded at runtime since any processes retaining such a fun will have a reference to old code. In particular, such a value is typically inappropriate in configuration passed to &lt;code&gt;&lt;a href=&quot;#start_service-2&quot;&gt;start_service/2&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#add_transport-2&quot;&gt;add_transport/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f04d9d4432e8383e468152a41bfa09dcf4f742e" translate="yes" xml:space="preserve">
          <source>Beware that RFC 6733 changed the DiameterURI transport/port defaults specified in RFC3588. Relying on the defaults can result in interoperability problems.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37789191d916ab6f4adfabdff7e05307d5bbf9ba" translate="yes" xml:space="preserve">
          <source>Beware the difference between &lt;strong&gt;diameter&lt;/strong&gt; (not capitalized) and &lt;strong&gt;Diameter&lt;/strong&gt; (capitalized). The former refers to the Erlang application named diameter whose main api is defined here, the latter to Diameter protocol in the sense of RFC 6733.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b68a0f135268fc97357fa1f2e8bec70aa5933a7" translate="yes" xml:space="preserve">
          <source>Bignums are stored in unary form with a &lt;code&gt;Sign&lt;/code&gt; byte, that is, 0 if the binum is positive and 1 if it is negative. The digits are stored with the least significant byte stored first. To calculate the integer, the following formula can be used:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0c51379d746d689abb0d4163480ae980cc1ea4f" translate="yes" xml:space="preserve">
          <source>Binaries are generated with bit syntax expression or with &lt;code&gt;erlang:list_to_binary/1&lt;/code&gt;, &lt;code&gt;erlang:term_to_binary/1&lt;/code&gt;, or as input from binary ports. The &lt;code&gt;Len&lt;/code&gt; length field is an unsigned 4 byte integer (big-endian).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="afb16785a033cecba113ba879f8a7ad266f9f880" translate="yes" xml:space="preserve">
          <source>Binaries are more troublesome. For performance reasons, programs often store textual data in binaries instead of lists, mainly because they are more compact (one byte per character instead of two words per character, as is the case with lists). Using &lt;code&gt;erlang:list_to_binary/1&lt;/code&gt;, an ISO Latin-1 Erlang string can be converted into a binary, effectively using bytewise encoding: one byte per character. This was convenient for those limited Erlang strings, but cannot be done for arbitrary Unicode lists.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9777da829501809520a535ef9e6d08ff6a5dcba9" translate="yes" xml:space="preserve">
          <source>Binaries are sequences of whole bytes. Bitstrings with an arbitrary bit length have no support yet.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ddb0d785eee554ca3ad9cce85a18ca8630f56b8c" translate="yes" xml:space="preserve">
          <source>Binaries can be efficiently built in the following way:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d0d3b67132c6fcaa92c679366fed8db13d485e2" translate="yes" xml:space="preserve">
          <source>Binaries can be efficiently matched like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66639f7d455dd71faa9147f5d69e5ce885d8bebd" translate="yes" xml:space="preserve">
          <source>Binary</source>
          <target state="translated">Binary</target>
        </trans-unit>
        <trans-unit id="892dde55806e241693a0b3bdfdd1efae250f381f" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;Bin&lt;/code&gt; contains the same information as the output from &lt;code&gt;erlang:process_display(Pid, backtrace)&lt;/code&gt;. Use &lt;code&gt;binary_to_list/1&lt;/code&gt; to obtain the string of characters from the binary.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ebbd4d9948de9c87d6e53af4cc41250b5709a590" translate="yes" xml:space="preserve">
          <source>Binary boot script</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ca5ef63e7a423ed4f0c902eb2201ec5aa53e26f" translate="yes" xml:space="preserve">
          <source>Binary callback function &lt;code id=&quot;lookup_fun&quot;&gt;LookupFun&lt;/code&gt; is used for looking up objects in the table. The first argument &lt;code&gt;Position&lt;/code&gt; is the key position or an indexed position and the second argument &lt;code&gt;Keys&lt;/code&gt; is a sorted list of unique values. The return value is to be a list of all objects (tuples), such that the element at &lt;code&gt;Position&lt;/code&gt; is a member of &lt;code&gt;Keys&lt;/code&gt;. Any other return value is immediately returned as value of the query evaluation. &lt;code&gt;LookupFun&lt;/code&gt; is called instead of traversing the table if the parse transform at compile time can determine that the filters match and compare the element at &lt;code&gt;Position&lt;/code&gt; in such a way that only &lt;code&gt;Keys&lt;/code&gt; need to be looked up to find all potential answers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91649b24f930abce26bedbe83f0148ebb05baa18" translate="yes" xml:space="preserve">
          <source>Binary codecs</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bfbd337015a6a1e9c7fe45e7f4ee5d33b7a0cc06" translate="yes" xml:space="preserve">
          <source>Binary data is shared among processes. If another process still references the larger binary, copying the part this process uses only consumes more memory and does not free up the larger binary for garbage collection. Use this kind of intrusive functions with extreme care and only if a real problem is detected.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0b461eb903baadd26c515cd4ef53be30f07dc47" translate="yes" xml:space="preserve">
          <source>Binary handling was significantly improved in R12B. Because code that was efficient in R11B might not be efficient in R12B, and vice versa, earlier revisions of this Efficiency Guide contained some information about binary handling in R11B.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3435ca67f0f051a1fea228cdb0770bf8e8bb3d65" translate="yes" xml:space="preserve">
          <source>Binary sharing occurs whenever binaries are taken apart. This is the fundamental reason why binaries are fast, decomposition can always be done with O(1) complexity. In rare circumstances this data sharing is however undesirable, why this function together with &lt;code&gt;copy/1&lt;/code&gt; can be useful when optimizing for memory use.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="444f4f33b9d5b0002c23fd9ec1a4edab1ded0af6" translate="yes" xml:space="preserve">
          <source>Binary with characters encoded in UTF-8 or UTF-16.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c065024f1e88a0e634a5d724af341ce692e22147" translate="yes" xml:space="preserve">
          <source>Binary with characters encoded in iso-latin-1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89f902f1a369dce968f46c3953a9e68e0d99f72f" translate="yes" xml:space="preserve">
          <source>BinaryGraphOp ::= &lt;code&gt;of&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7513e46be3c5ca02f1cd91f8479bcae815aa2cca" translate="yes" xml:space="preserve">
          <source>BinarySetOp ::= &lt;code&gt;+&lt;/code&gt; | &lt;code&gt;*&lt;/code&gt; | &lt;code&gt;-&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8264338650782cc58de94b15794c38a796b18c92" translate="yes" xml:space="preserve">
          <source>Binding of schedulers is not supported on the specific platform.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65e949b92a71c14d4ea442682069d67c76442e70" translate="yes" xml:space="preserve">
          <source>Binding of schedulers is only supported on newer Linux, Solaris, FreeBSD, and Windows systems.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e29acb46257f51cfc0f132df9d70d5a8cf45608" translate="yes" xml:space="preserve">
          <source>Bindings,</source>
          <target state="translated">Bindings,</target>
        </trans-unit>
        <trans-unit id="a255a9d3a4009bbdfcc5e9d159b353b687a30da6" translate="yes" xml:space="preserve">
          <source>Binds a socket to a specific network interface. This option must be used in a function call that creates a socket, that is, &lt;code&gt;&lt;a href=&quot;gen_tcp#connect-3&quot;&gt;gen_tcp:connect/3,4&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;gen_tcp#listen-2&quot;&gt;gen_tcp:listen/2&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;gen_udp#open-1&quot;&gt;gen_udp:open/1,2&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;gen_sctp#open-0&quot;&gt;gen_sctp:open/0,1,2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="360cda316649dfca67f2603c94b136a74b6c648a" translate="yes" xml:space="preserve">
          <source>Bit string comprehensions are analogous to List Comprehensions. They are used to generate bit strings efficiently and succinctly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9ef7ef37c0e6417fc396a660a24f1538c5ef671" translate="yes" xml:space="preserve">
          <source>Bit string comprehensions are written with the following syntax:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe2441919ecc33eba0d15c91c6774d8e118b27fa" translate="yes" xml:space="preserve">
          <source>Bit strings are expressed using the &lt;code&gt;&lt;a href=&quot;expressions#bit_syntax&quot;&gt;bit syntax&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef4786f28896f4e7ec27947fbbc93a25189b57f1" translate="yes" xml:space="preserve">
          <source>Bit strings that consist of a number of bits that are evenly divisible by eight, are called &lt;strong&gt;binaries&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71ef7d1974a07fcaa17eb97f44c3fb4fcef331ed" translate="yes" xml:space="preserve">
          <source>Bitshift right</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17e80e5f71e9b85954b350f117d4dfeb3c5cf70a" translate="yes" xml:space="preserve">
          <source>Bitwise AND</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4be0adcfa81c37e1e7bbf2e23630f30974d164f" translate="yes" xml:space="preserve">
          <source>Bitwise OR</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="567f521d0a70021d35df0a7429cd3579c200a9d3" translate="yes" xml:space="preserve">
          <source>Bitwise operators: &lt;code&gt;band&lt;/code&gt;, &lt;code&gt;bor&lt;/code&gt;, &lt;code&gt;bxor&lt;/code&gt;, &lt;code&gt;bnot&lt;/code&gt;, &lt;code&gt;bsl&lt;/code&gt;, &lt;code&gt;bsr&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae104d5e9f670270b20927f74417d76623f8773a" translate="yes" xml:space="preserve">
          <source>Black-box testing of target systems of any type (that is, not necessarily implemented in Erlang). This is performed through standard O&amp;amp;M interfaces (such as SNMP, HTTP, CORBA, and Telnet) and, if necessary, through user-specific interfaces (often called test ports).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a8a1cf314b7d5a93ed2c3c8500ce8e82ea060d8" translate="yes" xml:space="preserve">
          <source>Block ciphers -  DES and AES in Block Cipher Modes - &lt;code&gt;&lt;a href=&quot;http://csrc.nist.gov/groups/ST/toolkit/BCM/index.html&quot;&gt; ECB, CBC, CFB, OFB, CTR and GCM &lt;/a&gt;&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc11d63974d38781fdb2ea32c8ba8e895421285c" translate="yes" xml:space="preserve">
          <source>Block expressions provide a way to group a sequence of expressions, similar to a clause body. The return value is the value of the last expression &lt;code&gt;ExprN&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a11c7845b57dd764a4e0b6dfeac45510d039cbd4" translate="yes" xml:space="preserve">
          <source>Blocking of multi-scheduling and normal multi-scheduling is normally not needed. If you feel that you need to use these features, consider it a few more times again. Blocking multi-scheduling is only to be used as a last resort, as it is most likely a &lt;strong&gt;very inefficient&lt;/strong&gt; way to solve the problem.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f88bcddd0731f8535aab4cf6c4aea9771da5b592" translate="yes" xml:space="preserve">
          <source>Blocks that are larger than the value of the singleblock carrier threshold (&lt;code&gt;&lt;a href=&quot;#M_sbct&quot;&gt;sbct&lt;/a&gt;&lt;/code&gt;) parameter are placed in singleblock carriers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19edd385ea6503e1211246f52fb3bd015a6b72b6" translate="yes" xml:space="preserve">
          <source>Blocks that are smaller than the value of parameter &lt;code&gt;sbct&lt;/code&gt; are placed in multiblock carriers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4206776cd5ab32e70519cb42f90bc1cb4373333a" translate="yes" xml:space="preserve">
          <source>BoolFunction ::= &lt;code&gt;is_atom&lt;/code&gt; | &lt;code&gt;is_float&lt;/code&gt; | &lt;code&gt;is_integer&lt;/code&gt; | &lt;code&gt;is_list&lt;/code&gt; | &lt;code&gt;is_number&lt;/code&gt; | &lt;code&gt;is_pid&lt;/code&gt; | &lt;code&gt;is_port&lt;/code&gt; | &lt;code&gt;is_reference&lt;/code&gt; | &lt;code&gt;is_tuple&lt;/code&gt; | &lt;code&gt;is_map&lt;/code&gt; | &lt;code&gt;is_map_key&lt;/code&gt; | &lt;code&gt;is_binary&lt;/code&gt; | &lt;code&gt;is_function&lt;/code&gt; | &lt;code&gt;is_record&lt;/code&gt; | &lt;code&gt;is_seq_trace&lt;/code&gt; | &lt;code&gt;'and'&lt;/code&gt; | &lt;code&gt;'or'&lt;/code&gt; | &lt;code&gt;'not'&lt;/code&gt; | &lt;code&gt;'xor'&lt;/code&gt; | &lt;code&gt;'andalso'&lt;/code&gt; | &lt;code&gt;'orelse'&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3cde099dd0c2860dfd30f6b0378f3f056b13cc7" translate="yes" xml:space="preserve">
          <source>BoolFunction ::= &lt;code&gt;is_atom&lt;/code&gt; | &lt;code&gt;is_float&lt;/code&gt; | &lt;code&gt;is_integer&lt;/code&gt; | &lt;code&gt;is_list&lt;/code&gt; | &lt;code&gt;is_number&lt;/code&gt; | &lt;code&gt;is_pid&lt;/code&gt; | &lt;code&gt;is_port&lt;/code&gt; | &lt;code&gt;is_reference&lt;/code&gt; | &lt;code&gt;is_tuple&lt;/code&gt; | &lt;code&gt;is_map&lt;/code&gt; | &lt;code&gt;map_is_key&lt;/code&gt; | &lt;code&gt;is_binary&lt;/code&gt; | &lt;code&gt;is_function&lt;/code&gt; | &lt;code&gt;is_record&lt;/code&gt; | &lt;code&gt;'and'&lt;/code&gt; | &lt;code&gt;'or'&lt;/code&gt; | &lt;code&gt;'not'&lt;/code&gt; | &lt;code&gt;'xor'&lt;/code&gt; | &lt;code&gt;'andalso'&lt;/code&gt; | &lt;code&gt;'orelse'&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b76ff4906f33c2dd97ddd929b9662ba8cac6174c" translate="yes" xml:space="preserve">
          <source>Boolean</source>
          <target state="translated">Boolean</target>
        </trans-unit>
        <trans-unit id="60192723d1692fc0b5f8fc179416c38b9c58ae23" translate="yes" xml:space="preserve">
          <source>Boolean expressions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66182d005e228ccf7ad8ca7af48f43e62e8288b3" translate="yes" xml:space="preserve">
          <source>Boolean operators: &lt;code&gt;not&lt;/code&gt;, &lt;code&gt;and&lt;/code&gt;, &lt;code&gt;or&lt;/code&gt;, &lt;code&gt;andalso&lt;/code&gt;, &lt;code&gt;orelse&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff2372b936c678678613bf8145deb94c379766ad" translate="yes" xml:space="preserve">
          <source>Booleans in ASN.1 express values that can be either &lt;code&gt;TRUE&lt;/code&gt; or &lt;code&gt;FALSE&lt;/code&gt;. The meanings assigned to &lt;code&gt;TRUE&lt;/code&gt; and &lt;code&gt;FALSE&lt;/code&gt; are outside the scope of this text.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57f87135d0b5c7204e5e725d7f6d51c65d0e1da6" translate="yes" xml:space="preserve">
          <source>Boot script</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55cc3a7f7d6ae5f5575682107980e3293f644b52" translate="yes" xml:space="preserve">
          <source>Boot scripts are built using the &lt;code&gt;systools&lt;/code&gt; utility in the SASL application. For more information on &lt;code&gt;systools&lt;/code&gt;, see the SASL documentation. This is only an example of what can be done.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3d4144d275cc7e2f7cb03eca0c38a1d2569fa5e" translate="yes" xml:space="preserve">
          <source>Boot server for other Erlang machines.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="516f821cffde24557819cc9db18117f3a7da6530" translate="yes" xml:space="preserve">
          <source>Bopomofo</source>
          <target state="translated">Bopomofo</target>
        </trans-unit>
        <trans-unit id="aeca55061b1a7fcf42d399adecf44466466ea1f5" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;GetInfo&lt;/code&gt; and &lt;code&gt;GetBin&lt;/code&gt; must be called within the &lt;code&gt;Fun&lt;/code&gt;. Their behavior is undefined if they are called outside the context of &lt;code&gt;Fun&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="088b2c8092f1e119c8753dea210acbd5446d7101" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;WarningList&lt;/code&gt; and &lt;code&gt;ErrorList&lt;/code&gt; have the following format:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17f701bc8b6f6001358219750664486c85b21b5d" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;case&lt;/code&gt; and &lt;code&gt;if&lt;/code&gt; have &lt;strong&gt;return values&lt;/strong&gt;, that is, in the above example &lt;code&gt;case&lt;/code&gt; returned either &lt;code&gt;{inch,X/2.54}&lt;/code&gt; or &lt;code&gt;{centimeter,Y*2.54}&lt;/code&gt;. The behaviour of &lt;code&gt;case&lt;/code&gt; can also be modified by using guards. The following example clarifies this. It tells us the length of a month, given the year. The year must be known, since February has 29 days in a leap year.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28509f91486de7be6923a1aa53ee47118e6db5bf" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;sys&lt;/code&gt; and &lt;code&gt;proc_lib&lt;/code&gt; belong to the STDLIB application.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da40d11cd13d54f5078c0119cec66e0ccfe5dfdd" translate="yes" xml:space="preserve">
          <source>Both building with dynamic trace probes and using them is experimental and unsupported by Erlang/OTP. It is included as an option for the developer to trace and debug performance issues in their systems.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="272b41459c2a4ad1e5b3d0281a8c236f1fbb8ef5" translate="yes" xml:space="preserve">
          <source>Both clients and daemons accepts options that controls the exact behaviour. Some options are common to both. The three sets are called &lt;code&gt;&lt;a href=&quot;#type-client_options&quot;&gt;Client Options&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#type-daemon_options&quot;&gt;Daemon Options&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#type-common_options&quot;&gt;Common Options&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43500df87c9d667061a043ba9cd51b43abef2516" translate="yes" xml:space="preserve">
          <source>Both functions are described in the following.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8393123b8c640d62b0cc06dc60be2e57645d7426" translate="yes" xml:space="preserve">
          <source>Both increasing and decreasing &lt;code&gt;&amp;lt;IdRange&amp;gt;&lt;/code&gt;s are allowed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84d91e83adcd109e53d7f1d1718f4d0e6a80ae0d" translate="yes" xml:space="preserve">
          <source>Both mechanisms have the same theoretical time and memory complexity, while the selective receive language construct has smaller constant factors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1196a55702bdb5abaf2deea06cedc05c7a896fe" translate="yes" xml:space="preserve">
          <source>Both of them can be empty, but not at the same time. If &lt;code&gt;&amp;lt;ChangedAppVersions&amp;gt;&lt;/code&gt; is empty, no changes have been made that change the build result of any application. This could, for example, be a pure bug fix of the build system. The order of lines is undefined. All white-space characters in this file are either space (character 32) or line-break (character 10).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3442514fe2989d64511fbe704d87cbeac484a561" translate="yes" xml:space="preserve">
          <source>Both old and current code for a module are valid, and can even be evaluated concurrently. The difference is that exported functions in old code are unavailable. Hence, a global call cannot be made to an exported function in old code, but old code can still be evaluated because of processes lingering in it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a81666107cfaaf40864441b74f9792a8cc7fb8a" translate="yes" xml:space="preserve">
          <source>Both old and current code is valid, and can be evaluated concurrently. Fully qualified function calls always refer to current code. Old code can still be evaluated because of processes lingering in the old code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19893bb20867dad51e674f2c8283aa35e37963b9" translate="yes" xml:space="preserve">
          <source>Both options give the same effect, the input string is interpreted as UTF-8. Notice that with these instructions, the automatic conversion of lists to UTF-8 is not performed by the &lt;code&gt;re&lt;/code&gt; functions. Therefore, using these sequences is not recommended. Add option &lt;code&gt;unicode&lt;/code&gt; when running &lt;code&gt;&lt;a href=&quot;#compile-2&quot;&gt;compile/2&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04f750b6f7ecf467d03fd155880c2c08a8e8637a" translate="yes" xml:space="preserve">
          <source>Both server and event manager are registered processes which can be expected to be always accessible. Thus they are specified to be &lt;code&gt;permanent&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57dd8748ee1441894d656dd738cdc13c745b3ff2" translate="yes" xml:space="preserve">
          <source>Both source code and object code for the module is found.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0ebc6ec0ff8694d627315dcce4507da48f45e45" translate="yes" xml:space="preserve">
          <source>Both the agent and the manager can be configured to log incoming and outgoing messages. It uses the Erlang standard log mechanism &lt;code&gt;disk_log&lt;/code&gt; for logging. The size and location of the log files are configurable. A wrap log is used, which means that when the log has grown to a maximum size, it starts from the beginning of the log, overwriting existing log records.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31ef6ae37976246cbbb8302e6168cf2ddacebc06" translate="yes" xml:space="preserve">
          <source>Both the module declaration and the export declaration of the &lt;code&gt;main/1&lt;/code&gt; function are optional.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19b296fa85d6e817ce8e73a30a0d4e4ab33ce24a" translate="yes" xml:space="preserve">
          <source>Both the old and new versions of the &lt;code&gt;.app&lt;/code&gt; and &lt;code&gt;.rel&lt;/code&gt; files must be in the code path, as well as the &lt;code&gt;.appup&lt;/code&gt; and (new) &lt;code&gt;.beam&lt;/code&gt; files. The code path can be extended by using the option &lt;code&gt;path&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2a0efd65a8f4b932941a27e1ed06208576cd1ee" translate="yes" xml:space="preserve">
          <source>Both the registration and lock services are atomic. All nodes involved in these actions have the same view of the information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1ccfade4aa63d420f2f18a1184490432f9a36ed" translate="yes" xml:space="preserve">
          <source>Both these tools use the message package (time_test.msgs) provided with the tool(s), although it can run on any message package as long as it has the same structure.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ccbfe9c0e689e8b9dc53b4b4ec4a1a3a8c73326" translate="yes" xml:space="preserve">
          <source>Both transport security at connection establishment and negotiated via an Inband-Security AVP are supported.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c0eaabc27903558b46afc5c85515d4a1d0fc689" translate="yes" xml:space="preserve">
          <source>Bound on the expected size of incoming Diameter messages. Messages larger than the specified number of bytes are discarded.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0021328dee4879f40d348f1597841de3b466cc17" translate="yes" xml:space="preserve">
          <source>Bound parts (Erlang terms)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24afa8c574a58ec588a649b2ee14b50d33a8ca50" translate="yes" xml:space="preserve">
          <source>Braille</source>
          <target state="translated">Braille</target>
        </trans-unit>
        <trans-unit id="acd5609c99b4261f4b2a9f0f2cd2cd2a63fc35c8" translate="yes" xml:space="preserve">
          <source>Branches off an existing association &lt;code&gt;Assoc&lt;/code&gt; in a socket &lt;code&gt;Socket&lt;/code&gt; of type &lt;code&gt;seqpacket&lt;/code&gt; (one-to-many style) into a new socket &lt;code&gt;NewSocket&lt;/code&gt; of type &lt;code&gt;stream&lt;/code&gt; (one-to-one style).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7fb13ed24388f546ddc4203cc04ff019ad463378" translate="yes" xml:space="preserve">
          <source>Branches that match different length strings are permitted only at the top-level of a lookbehind assertion. This is an extension compared with Perl, which requires all branches to match the same length of string. An assertion such as the following is not permitted, as its single top-level branch can match two different lengths:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5a0f50acb3dd75574af8408fef3b88b8ceb46b5" translate="yes" xml:space="preserve">
          <source>Breaking up a long-running function in this manner enables the VM to regain control between calls to the NIFs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8bdcc7199154fffd9f8d9a9848283a3809fc361e" translate="yes" xml:space="preserve">
          <source>Breakpoints are created and deleted using the &lt;strong&gt;Break&lt;/strong&gt; menu of either the Monitor window, View Module window, or Attach Process window.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a8d8f460f3a399bfb04e89862d06e9b316c1004" translate="yes" xml:space="preserve">
          <source>Breakpoints are marked with a stop symbol.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0fac70209382c8083fb51c23797738064b31d35" translate="yes" xml:space="preserve">
          <source>Breakpoints are specified on a line basis. When a process executing code in an interpreted module reaches a breakpoint, it stops. This means that a breakpoint must be set at an executable line, that is, a code line containing an executable expression.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fbbe2bd05741e651732db1439c4df7101add2a7e" translate="yes" xml:space="preserve">
          <source>Briefly on Solaris 10</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c54c32cef81a294e27f0b55c17e9d3989656be7" translate="yes" xml:space="preserve">
          <source>Broadcasts on a condition variable. That is, if other threads are waiting on the condition variable being broadcast on, &lt;strong&gt;all&lt;/strong&gt; of them are woken.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="298841afbb7ef24f7711e916938def078c174299" translate="yes" xml:space="preserve">
          <source>Broadcasts the message &lt;code&gt;Msg&lt;/code&gt; asynchronously to the registered process &lt;code&gt;Name&lt;/code&gt; on the specified nodes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e9067bfac6a20153ac4defbe476694c9b168a4a" translate="yes" xml:space="preserve">
          <source>Broadcasts the message &lt;code&gt;Msg&lt;/code&gt; synchronously to the registered process &lt;code&gt;Name&lt;/code&gt; on the specified nodes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e87af70cba1f1e451d37824609594b2a73b9bafc" translate="yes" xml:space="preserve">
          <source>Browse the application configuration file (do &lt;strong&gt;not&lt;/strong&gt; edit it). The full name of the application configuration file is derived from the position of the &lt;code&gt;os_mon&lt;/code&gt; application in the file system by adding &lt;code&gt;/ebin/os_mon.app&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d698cd7b5307da0633f70f00f726e5dbe00ea1a" translate="yes" xml:space="preserve">
          <source>Browses table &lt;code&gt;Tab&lt;/code&gt; on a terminal.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f47b617427a681f5cc68845744e7adc91ae07ed8" translate="yes" xml:space="preserve">
          <source>Browsing the html pages by loading the page &lt;code&gt;/usr/local/lib/erlang/doc/erlang/index.html&lt;/code&gt; or &lt;code&gt;&amp;lt;BaseDir&amp;gt;/lib/erlang/doc/erlang/index.html&lt;/code&gt; if the prefix option has been used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="792fdd1cd5fd403216843c6560d9bf75c37a3a2e" translate="yes" xml:space="preserve">
          <source>Buf is initialized to contain object attributes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3caca7ca1e839168f274364c9d0c4a80119c3d3a" translate="yes" xml:space="preserve">
          <source>Buffer is too small.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c32cae74e192e8ea56db8683dfa3876fd9fa316b" translate="yes" xml:space="preserve">
          <source>Buginese</source>
          <target state="translated">Buginese</target>
        </trans-unit>
        <trans-unit id="c8eea1b80ba437eb2c7d9d8e4a7a1c0c36ddce4e" translate="yes" xml:space="preserve">
          <source>Bugs</source>
          <target state="translated">Bugs</target>
        </trans-unit>
        <trans-unit id="f55777a6f9cd8a9c1199724cddc2f176cde4e922" translate="yes" xml:space="preserve">
          <source>Buhid</source>
          <target state="translated">Buhid</target>
        </trans-unit>
        <trans-unit id="5e39e7697b21824bcc7130368908ca3db3109308" translate="yes" xml:space="preserve">
          <source>Build Erlang/OTP</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da71556c2060cac2828b51ce118c10a5f1cb07b2" translate="yes" xml:space="preserve">
          <source>Build Issues</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82de423db4cc623ec5f04ba52bfec4b055f722a1" translate="yes" xml:space="preserve">
          <source>Build or install the FIPS Object Module and a FIPS enabled OpenSSL library.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ca44d234eb0f2b9b591c5ee4decd555e8ce199c" translate="yes" xml:space="preserve">
          <source>Build the Erlang/OTP release.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07f491f3b5c090f34f2ee3e97cafbb3c5f5f8099" translate="yes" xml:space="preserve">
          <source>Build the boot script.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77d5d2f2a5f4a3ffbde6ae0d3e363ac721059f26" translate="yes" xml:space="preserve">
          <source>Build the documentation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55d9080383317c03f360d21bbd25b0561e946784" translate="yes" xml:space="preserve">
          <source>Building Erlang/OTP can be done either by using the &lt;code&gt;$ERL_TOP/otp_build&lt;/code&gt; script, or by invoking &lt;code&gt;$ERL_TOP/configure&lt;/code&gt; and &lt;code&gt;make&lt;/code&gt; directly. Building using &lt;code&gt;otp_build&lt;/code&gt; is easier since it involves fewer steps, but the &lt;code&gt;otp_build&lt;/code&gt; build procedure is not as flexible as the &lt;code&gt;configure&lt;/code&gt;/&lt;code&gt;make&lt;/code&gt; build procedure. Note that &lt;code&gt;otp_build configure&lt;/code&gt; will produce a default configuration that differs from what &lt;code&gt;configure&lt;/code&gt; will produce by default. For example, currently &lt;code&gt;--disable-dynamic-ssl-lib&lt;/code&gt; is added to the &lt;code&gt;configure&lt;/code&gt; command line arguments unless &lt;code&gt;--enable-dynamic-ssl-lib&lt;/code&gt; has been explicitly passed. The binary releases that we deliver are built using &lt;code&gt;otp_build&lt;/code&gt;. The defaults used by &lt;code&gt;otp_build configure&lt;/code&gt; may change at any time without prior notice.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0288be29544ae6b8e621446c1d716ba731ebd705" translate="yes" xml:space="preserve">
          <source>Building Erlang/OTP can be done either by using the &lt;code&gt;$ERL_TOP/otp_build&lt;/code&gt; script, or by invoking &lt;code&gt;$ERL_TOP/configure&lt;/code&gt; and &lt;code&gt;make&lt;/code&gt; directly. Building using &lt;code&gt;otp_build&lt;/code&gt; is easier since it involves fewer steps, but the &lt;code&gt;otp_build&lt;/code&gt; build procedure is not as flexible as the &lt;code&gt;configure&lt;/code&gt;/&lt;code&gt;make&lt;/code&gt; build procedure. The binary releases for Windows that we deliver are built using &lt;code&gt;otp_build&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9a1d72262f0ba28560224e8b5f84f82d3a37931" translate="yes" xml:space="preserve">
          <source>Building Erlang/OTP on a relatively fast computer takes approximately 5 minutes. To speed it up, you can utilize parallel make with the &lt;code&gt;-j&amp;lt;num_jobs&amp;gt;&lt;/code&gt; option.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ef5793998a525a29078ba78dcc6651a8e69241f" translate="yes" xml:space="preserve">
          <source>Building a Bootstrap System</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6fcd9e84832d8fc06ff9412088752b9ac40d1d27" translate="yes" xml:space="preserve">
          <source>Building in Git</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e610827003738b99e768b26958b3f36694ff33c" translate="yes" xml:space="preserve">
          <source>Building is easiest using the &lt;code&gt;otp_build&lt;/code&gt; script:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="840f8d32dc79d0e6d7906ca187022ffdcd65d433" translate="yes" xml:space="preserve">
          <source>Building on OS X</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0919d6c99c47efcb70329ed0ebdeb92cd58e964c" translate="yes" xml:space="preserve">
          <source>Building terms and patterns</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7b4eea65f50794546e0a9cd2e50530baa9d4e3f" translate="yes" xml:space="preserve">
          <source>Building with wxErlang</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03d9659d4e51ca391a6e1291a5a6e5195ec7e16f" translate="yes" xml:space="preserve">
          <source>Building with wxWidgets. Download wxWidgets-3.0.3 or higher.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a48efe1163ff4f604b0e75b0f8069e848d42294" translate="yes" xml:space="preserve">
          <source>Builds a BEAM module (as a binary) from a list of chunks.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04266b7610bbe7204641a5a18f1b641cc5a4ad92" translate="yes" xml:space="preserve">
          <source>Builds an internal structure representing a compilation of a search pattern, later to be used in functions &lt;code&gt;&lt;a href=&quot;#match-3&quot;&gt;match/3&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#matches-3&quot;&gt;matches/3&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#split-3&quot;&gt;split/3&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;#replace-4&quot;&gt;replace/4&lt;/a&gt;&lt;/code&gt;. The &lt;code&gt;cp()&lt;/code&gt; returned is guaranteed to be a &lt;code&gt;tuple()&lt;/code&gt; to allow programs to distinguish it from non-precompiled search patterns.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20f409cc87c744070ec80e942947a590f8db80d1" translate="yes" xml:space="preserve">
          <source>Built-in</source>
          <target state="translated">Built-in</target>
        </trans-unit>
        <trans-unit id="3685c8c87d2a5725cbc54a94228a1a89d1d88a57" translate="yes" xml:space="preserve">
          <source>Built-in term storage.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5849712291c78b1a99987a87b4b4819b9538fc4d" translate="yes" xml:space="preserve">
          <source>But if a constant is sent to another process (or stored in an Ets table), it is &lt;strong&gt;copied&lt;/strong&gt;. The reason is that the runtime system must be able to keep track of all references to constants to unload code containing constants properly. (When the code is unloaded, the constants are copied to the heap of the processes that refer to them.) The copying of constants might be eliminated in a future Erlang/OTP release.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12383ec381d6eef21e12692f3a3beac567f979cb" translate="yes" xml:space="preserve">
          <source>But in more complicated code, how can one know whether the optimization is applied or not?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13e80088d58b6e2e78ae703a190df34ce17a3ab1" translate="yes" xml:space="preserve">
          <source>But it will generate code that builds a sub binary in the first clause:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0a27a5b2ec989d8d33e3ef99ff2c029f3ccadb0" translate="yes" xml:space="preserve">
          <source>But that is history. Funs was given its own data type in R6B and was further optimized in R7B. Now the cost for a fun call falls roughly between the cost for a call to a local function and &lt;code&gt;apply/3&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9edeffd1c02cedcbcf042627c2b5c0c907cde008" translate="yes" xml:space="preserve">
          <source>But this fails as Fred has already logged off.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c55fef2a765c8d16ab4eacfbd4c2a04ae1406db" translate="yes" xml:space="preserve">
          <source>But this fails:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae29bf624e4dd4338883041af300ffb73e4829e9" translate="yes" xml:space="preserve">
          <source>But this is not enough. There is also a set of &lt;strong&gt;mandatory&lt;/strong&gt; messages which the network interface entity must be able to receive and be able to send. This is described in chapter &lt;code&gt;&lt;a href=&quot;snmp_agent_netif&quot;&gt;snmp_agent_netif&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45778b54cb8ef168c982efffe69e2d8b502fce93" translate="yes" xml:space="preserve">
          <source>But using &lt;code&gt;++&lt;/code&gt; as follows is not bad:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="521274df22007097293748284fe185141e772a3c" translate="yes" xml:space="preserve">
          <source>But you realize that it is unnecessary to have the Erlang compiler in this one:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94852e93461c3ce16031709d1ba53f77338d1422" translate="yes" xml:space="preserve">
          <source>But, if we nevertheless &lt;strong&gt;do&lt;/strong&gt; dig down we find the call to the linked in driver that does the file operations towards the host operating system:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aaa9717eecd88e22102280721e33d90c4f0a390a" translate="yes" xml:space="preserve">
          <source>By &lt;strong&gt;attaching to&lt;/strong&gt; a process executing interpreted code, it is possible to examine variable bindings and order stepwise execution. This is done by sending and receiving information to/from the process through a third process, called the meta process. You can implement your own attached process. See &lt;code&gt;int.erl&lt;/code&gt; for available functions and &lt;code&gt;dbg_wx_trace.erl&lt;/code&gt; for possible messages.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e25689214717ab6f387eff1ce87fefe79882799" translate="yes" xml:space="preserve">
          <source>By SASL reports we mean supervisor reports, crash reports and progress reports.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61329f5b77a1e8f4de56300ae6baa6480eff0a5f" translate="yes" xml:space="preserve">
          <source>By calling &lt;code&gt;blend/2&lt;/code&gt; on any color term created by &lt;code&gt;new/4&lt;/code&gt;, the resulting color can be calculated as determined by the two map terms.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e21b8bafe38feea973da163115371fd334e57e8" translate="yes" xml:space="preserve">
          <source>By calling function &lt;code&gt;info/0&lt;/code&gt; in a generated module, you get information about which compiler options were used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="817528d15c927d91ed8c4901f6bd96f0b70a6a47" translate="yes" xml:space="preserve">
          <source>By clicking the name in the column header of any table (for example, &quot;Ok&quot;, &quot;Case&quot;, &quot;Time&quot;, and so on), the table rows are sorted in whatever order makes sense for the type of value (for example, numerical for &quot;Ok&quot; or &quot;Time&quot;, and alphabetical for &quot;Case&quot;). The sorting is performed through JavaScript code, automatically inserted into the HTML log files. &lt;code&gt;Common Test&lt;/code&gt; uses the &lt;code&gt;&lt;a href=&quot;http://jquery.com&quot;&gt;jQuery&lt;/a&gt;&lt;/code&gt; library and the &lt;code&gt;&lt;a href=&quot;http://tablesorter.com&quot;&gt;tablesorter&lt;/a&gt;&lt;/code&gt; plugin, with customized sorting functions, for this implementation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e3f09bd43c71064511228990649461289b5c148" translate="yes" xml:space="preserve">
          <source>By configuration, you can also modify or disable the default handler, replace it by a custom handler, and install additional handlers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65dc91babe6148c48d235004a31fddc4c1120398" translate="yes" xml:space="preserve">
          <source>By convention, most Built-In Functions (BIFs) are included in this module. Some of the BIFs are viewed more or less as part of the Erlang programming language and are &lt;strong&gt;auto-imported&lt;/strong&gt;. Thus, it is not necessary to specify the module name. For example, the calls &lt;code&gt;atom_to_list(erlang)&lt;/code&gt; and &lt;code&gt;erlang:atom_to_list(erlang)&lt;/code&gt; are identical.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="082c66d79fe52cb570696433b4792152063b55b2" translate="yes" xml:space="preserve">
          <source>By convention, the name of a tar file is to end in &quot;&lt;code&gt;.tar&lt;/code&gt;&quot;. To abide to the convention, add &quot;&lt;code&gt;.tar&lt;/code&gt;&quot; to the name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e51e93220df3f4bd5dc8a32795232ab13e7f0c15" translate="yes" xml:space="preserve">
          <source>By convention, the name of a zip file is to end with &lt;code&gt;.zip&lt;/code&gt;. To abide to the convention, add &lt;code&gt;.zip&lt;/code&gt; to the filename.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="458ef8621b4f7c4ee2bf42d5b9e1f263171a21fb" translate="yes" xml:space="preserve">
          <source>By default 16 files are merged at a time. This option is rarely needed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f916c5ec73659e63b033b011cdae7b63d48ef9e3" translate="yes" xml:space="preserve">
          <source>By default &lt;code&gt;Mnesia&lt;/code&gt; either dumps the log whenever 100 records have been written in the log or when three minutes have passed. This is controlled by the two application parameters &lt;code&gt;-mnesia dump_log_write_threshold WriteOperations&lt;/code&gt; and &lt;code&gt;-mnesia dump_log_time_threshold MilliSecs&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e33f74e5fe8c2a189ae75982a8ae0619e585aa16" translate="yes" xml:space="preserve">
          <source>By default SSL/TLS is run over the TCP/IP protocol even though you can plug in any other reliable transport protocol with the same Application Programming Interface (API) as the &lt;code&gt;gen_tcp&lt;/code&gt; module in Kernel. DTLS is by default run over UDP/IP, which means that application data has no delivery guarentees. Other transports, such as SCTP, may be supported in future releases.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55b91f316a10114e643a738ef56cbce119a92d15" translate="yes" xml:space="preserve">
          <source>By default about 512*1024 bytes read from files are sorted internally. This option is rarely needed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e8fa96214b81833eb829752ba3cb11f2aac75f4" translate="yes" xml:space="preserve">
          <source>By default in OTP 17, the representation of the &lt;code&gt;BIT STRING&lt;/code&gt; and &lt;code&gt;OCTET STRING&lt;/code&gt; types as Erlang terms were changed. &lt;code&gt;BIT STRING&lt;/code&gt; values are now Erlang bit strings and &lt;code&gt;OCTET STRING&lt;/code&gt; values are binaries. Also, an undecoded open type is now wrapped in an &lt;code&gt;asn1_OPENTYPE&lt;/code&gt; tuple. For details, see &lt;code&gt;&lt;a href=&quot;asn1_getting_started#BIT%20STRING&quot;&gt;BIT STRING&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;asn1_getting_started#OCTET%20STRING&quot;&gt;OCTET STRING&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;asn1_getting_started#Information%20Object&quot;&gt;ASN.1 Information Objects&lt;/a&gt;&lt;/code&gt; in the User's Guide.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9dc86d1dada42ddb164640d0be1c9cd268646f6a" translate="yes" xml:space="preserve">
          <source>By default it is not included, but if this option is present it will be.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c97804b0eee285b037a2d076e7ba516d0e16e389" translate="yes" xml:space="preserve">
          <source>By default it is not included, but if this option is present it will be. The reference text will be placed in the allocList field of the mib-entry record (#me{}) for the table.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4cb7bdb00bc5f4f34ca644e957ab5ac212ab81d" translate="yes" xml:space="preserve">
          <source>By default on such systems, Erlang starts in &lt;code&gt;utf8&lt;/code&gt; filename mode if the terminal supports UTF-8, otherwise in &lt;code&gt;latin1&lt;/code&gt; mode.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66001038963df69c701cdea04de30818e23ced2f" translate="yes" xml:space="preserve">
          <source>By default only the running target is available, unless the server includes &lt;code&gt;:candidate&lt;/code&gt; or &lt;code&gt;:startup&lt;/code&gt; in its list of capabilities.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1f41b809750734c802dac0f55be66baad734531" translate="yes" xml:space="preserve">
          <source>By default the &lt;code&gt;Application inclusion policy&lt;/code&gt; on system level is used for all applications. Set the value to &lt;code&gt;include&lt;/code&gt; if you want to explicitly include one particular application. Set it to &lt;code&gt;exclude&lt;/code&gt; if you want to exclude the application despite that it is used by another (explicitly or implicitly) included application. &lt;code&gt;derived&lt;/code&gt; means that the application automatically will be included if some other (explicitly or implicitly) included application uses it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3bb33b9d4c2d5314003279505372f2bd591c4469" translate="yes" xml:space="preserve">
          <source>By default the &lt;code&gt;Module inclusion policy&lt;/code&gt; on system level is used for all applications. Set it to &lt;code&gt;derived&lt;/code&gt; if you only want actually used modules to be included. Set it to &lt;code&gt;app&lt;/code&gt; if you, besides derived modules, also want the modules listed in the app file to be included. Set it to &lt;code&gt;ebin&lt;/code&gt; if you, besides derived modules, also want the modules that exist as beam files in the ebin directory to be included. Set it to &lt;code&gt;all&lt;/code&gt; if you want all modules to be included, that is the union of modules found in the ebin directory and listed in the app file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81c493b42c1c2d3836dadd1b1f65d1b4066bbbb2" translate="yes" xml:space="preserve">
          <source>By default the EPMD listens on port 4369.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60c9fed0b81fb4b980269d86433bdb1dec183e3e" translate="yes" xml:space="preserve">
          <source>By default the TLS/DTLS clients try to reuse an available session and by default the TLS/DTLS servers agree to reuse sessions when clients ask for it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40a1d269c0b2f20066064de554ea4fe767edbe1b" translate="yes" xml:space="preserve">
          <source>By default the currently stored events (existing) are written to a brand new file (write) and the events are kept (keep) after they have been written to the file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b301155fe91b7f29a76df23651c02320368fef48" translate="yes" xml:space="preserve">
          <source>By default the flex scanner reports line-number of an error. But it can be built without line-number reporting. Instead token number is used. This will speed up the scanning some 5-10%. Use &lt;code&gt;--disable-megaco-flex-scanner-lineno&lt;/code&gt; when configuring the application.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c20eaae0e3f3676678ff09602bb8cee954cea155" translate="yes" xml:space="preserve">
          <source>By default the socket options set by function &lt;code&gt;&lt;a href=&quot;#set_options-1&quot;&gt;set_options/[1,2]&lt;/a&gt;&lt;/code&gt; are used when establishing a connection.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec72fa4eac79a3cc871f1f0e43828e92af1bb91b" translate="yes" xml:space="preserve">
          <source>By default time correction is enabled if support for it exists on the specific platform. Support for it includes both OS monotonic time, provided by the OS, and an implementation in the Erlang runtime system using OS monotonic time. To check if your system has support for OS monotonic time, call &lt;code&gt;&lt;a href=&quot;erlang#system_info_os_monotonic_time_source&quot;&gt;erlang:system_info(os_monotonic_time_source)&lt;/a&gt;&lt;/code&gt;. To check if time correction is enabled on your system, call &lt;code&gt;&lt;a href=&quot;erlang#system_info_time_correction&quot;&gt;erlang:system_info(time_correction)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ceb9ebe7b981aea32343aa2ebada87a65d18c16" translate="yes" xml:space="preserve">
          <source>By default, &lt;code&gt;&lt;a href=&quot;ttb#stop-1&quot;&gt;ttb:stop/1&lt;/a&gt;&lt;/code&gt; fetches trace logs and trace information files from all nodes. The logs are stored in a new directory named &lt;code&gt;ttb_upload-Filename-Timestamp&lt;/code&gt; under the working directory of the trace control node. Fetching can be disabled by providing option &lt;code&gt;nofetch&lt;/code&gt; to &lt;code&gt;ttb:stop/1&lt;/code&gt;. The user can specify a fetch directory by passing option &lt;code&gt;{fetch_dir, Dir}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e28d91aead7c4c840b960191290c3223a7f6126a" translate="yes" xml:space="preserve">
          <source>By default, &lt;code&gt;Char&lt;/code&gt; is &lt;code&gt;$\s&lt;/code&gt; and &lt;code&gt;Dir&lt;/code&gt; is &lt;code&gt;trailing&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="071766231ebcbb0e6dd0a89742db95d7cd2d08e3" translate="yes" xml:space="preserve">
          <source>By default, &lt;code&gt;Common Test&lt;/code&gt; creates one central private directory per test run, shared by all test cases. This is not always suitable. Especially if the same test cases are executed multiple times during a test run (that is, if they belong to a test case group with property &lt;code&gt;repeat&lt;/code&gt;) and there is a risk that files in the private directory get overwritten. Under these circumstances, &lt;code&gt;Common Test&lt;/code&gt; can be configured to create one dedicated private directory per test case and execution instead. This is accomplished with the flag/option &lt;code&gt;create_priv_dir&lt;/code&gt; (to be used with the &lt;code&gt;&lt;a href=&quot;ct_run&quot;&gt;ct_run&lt;/a&gt;&lt;/code&gt; program, the &lt;code&gt;&lt;a href=&quot;ct#run_test-1&quot;&gt;ct:run_test/1&lt;/a&gt;&lt;/code&gt; function, or as test specification term). There are three possible values for this option as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc3169458b9c52d0cd7a98448830679fb2a8731a" translate="yes" xml:space="preserve">
          <source>By default, &lt;code&gt;Dir&lt;/code&gt; is &lt;code&gt;leading&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28f74729db7b0c3b278863ef6db06bd5bab6afe7" translate="yes" xml:space="preserve">
          <source>By default, &lt;code&gt;ERTS&lt;/code&gt; is only guaranteed to be compatible with other Erlang/OTP components from the same release as &lt;code&gt;ERTS&lt;/code&gt; itself.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d10644009649e0b88125d8c14d6cdb3379fe167" translate="yes" xml:space="preserve">
          <source>By default, &lt;code&gt;IgnoreCase&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt; and &lt;code&gt;Norm&lt;/code&gt; is &lt;code&gt;none&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9d6341953fcce030f785b04ed13be99fb6431b5" translate="yes" xml:space="preserve">
          <source>By default, &lt;code&gt;Length&lt;/code&gt; is &lt;code&gt;infinity&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="737dbf79ae1fa944f9b53b6e9f296655a6f7aa71" translate="yes" xml:space="preserve">
          <source>By default, &lt;code&gt;relup&lt;/code&gt; file is located in the current working directory. If option &lt;code&gt;{outdir,Dir}&lt;/code&gt; is specified, the &lt;code&gt;relup&lt;/code&gt; file is located in &lt;code&gt;Dir&lt;/code&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e5740833bc9a00277b2eef37e4a06e9efa51635" translate="yes" xml:space="preserve">
          <source>By default, &lt;code&gt;{proc_lib,init_p,5}&lt;/code&gt; is returned if no information about the initial call can be found. It is assumed that the caller knows that the process has been spawned with the &lt;code&gt;proc_lib&lt;/code&gt; module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a09da640fbd6b16e4c97f30cbf385b23a15ab05" translate="yes" xml:space="preserve">
          <source>By default, Debugger only saves information about recursive function calls, that is, function calls that have not yet returned a value (option &lt;strong&gt;Stack On, No Tail&lt;/strong&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb83760fc1df1215ce919183bfc30967f2391d71" translate="yes" xml:space="preserve">
          <source>By default, Dialyzer caches the results of native compilation in directory &lt;code&gt;$XDG_CACHE_HOME/erlang/dialyzer_hipe_cache&lt;/code&gt;. &lt;code&gt;XDG_CACHE_HOME&lt;/code&gt; defaults to &lt;code&gt;$HOME/.cache&lt;/code&gt;. Use this option to disable caching.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca501566661fba6186a204103ba54062fe33920b" translate="yes" xml:space="preserve">
          <source>By default, Erlang is started so that only the &lt;code&gt;latin1&lt;/code&gt; range of characters indicate that a list of integers is a string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a82754162a45a0d73de414ecadee9a7ddca8c1b" translate="yes" xml:space="preserve">
          <source>By default, Erlang only detects lists of characters in the Latin-1 range as strings, but the &lt;code&gt;+pc unicode&lt;/code&gt; flag can be used to change this (see &lt;code&gt;&lt;a href=&quot;#printable_range-0&quot;&gt;printable_range/0&lt;/a&gt;&lt;/code&gt; for details). For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ddfb5846cc6e75b4d26cdc33d2870cc55885837f" translate="yes" xml:space="preserve">
          <source>By default, Erlang/OTP release will be installed in &lt;code&gt;/usr/local/{bin,lib/erlang}&lt;/code&gt;. If you for instance don't have the permission to install in the standard location, you can install Erlang/OTP somewhere else. For example, to install in &lt;code&gt;/opt/erlang/21.0/{bin,lib/erlang}&lt;/code&gt;, use the &lt;code&gt;--prefix=/opt/erlang/21.0&lt;/code&gt; option.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="449ac9961843b5846b7c02a09a67a56c7a856de8" translate="yes" xml:space="preserve">
          <source>By default, PCRE treats the subject string as consisting of a single line of characters (even if it contains newlines). The &quot;start of line&quot; metacharacter (&lt;code&gt;^&lt;/code&gt;) matches only at the start of the string, while the &quot;end of line&quot; metacharacter (&lt;code&gt;$&lt;/code&gt;) matches only at the end of the string, or before a terminating newline (unless option &lt;code&gt;dollar_endonly&lt;/code&gt; is specified). This is the same as in Perl.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5979203f447d5bf52653ed357687aa3ce1b0b5f" translate="yes" xml:space="preserve">
          <source>By default, a breakpoint is active, has trigger action &lt;code&gt;enable&lt;/code&gt;, and has no associated condition. For details about breakpoints, see the User's Guide.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ce5b679d831561af8a791cf34b427a861410973" translate="yes" xml:space="preserve">
          <source>By default, a name must be unique within a pattern, but this constraint can be relaxed by setting option &lt;code&gt;dupnames&lt;/code&gt; at compile time. (Duplicate names are also always permitted for subpatterns with the same number, set up as described in the previous section.) Duplicate names can be useful for patterns where only one instance of the named parentheses can match. Suppose that you want to match the name of a weekday, either as a 3-letter abbreviation or as the full name, and in both cases you want to extract the abbreviation. The following pattern (ignoring the line breaks) does the job:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c874b6a01a35c20ad7535dd46729e15bd7a18206" translate="yes" xml:space="preserve">
          <source>By default, after \x that is not followed by {, from zero to two hexadecimal digits are read (letters can be in upper or lower case). Any number of hexadecimal digits may appear between \x{ and }. If a character other than a hexadecimal digit appears between \x{ and }, or if there is no terminating }, an error occurs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1911d23f55521707a73b458b73f12a15fc75306a" translate="yes" xml:space="preserve">
          <source>By default, all I/O devices in OTP are set in &lt;code&gt;list&lt;/code&gt; mode. However, the I/O functions can handle any of these modes and so should other, user-written, modules behaving as clients to I/O servers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b2f7942ad86f7d74769554cdd60a7505d483c06" translate="yes" xml:space="preserve">
          <source>By default, all NETCONF traffic is logged in one single log file. However, different connections can be logged in separate files. To do this, use hook option &lt;code&gt;hosts&lt;/code&gt; and list the names of the servers/connections to be used in the suite. The connections must be named for this to work, that is, they must be opened with &lt;code&gt;&lt;a href=&quot;#open-2&quot;&gt;open/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d82598d7e978ba992edaa523f47e7a8ba20e371c" translate="yes" xml:space="preserve">
          <source>By default, all applications are loaded with permission &lt;code&gt;true&lt;/code&gt; on all nodes. The permission can be configured using the Kernel configuration parameter &lt;code&gt;permissions&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97ad4d1175f0f089a0071483175aa615b421ee54" translate="yes" xml:space="preserve">
          <source>By default, all existing files with the same name as files in the tar file are overwritten. With this option, existing files are not overwriten.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e40750937dae4fae3bc5f70b97a3f2528fbb80b" translate="yes" xml:space="preserve">
          <source>By default, all files are extracted from the tar file. With this option, only those files are extracted whose names are included in &lt;code&gt;FileList&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88e8684fe917ca09c774ce03048bec7c20dc7976" translate="yes" xml:space="preserve">
          <source>By default, all files are extracted from the zip archive. With option &lt;code&gt;{file_list, FileList}&lt;/code&gt;, function &lt;code&gt;unzip/2&lt;/code&gt; only extracts the files whose names are included in &lt;code&gt;FileList&lt;/code&gt;. The full paths, including the names of all subdirectories within the zip archive, must be specified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8373c854a1dcafc057dbfa5df0f447eef64bc1ef" translate="yes" xml:space="preserve">
          <source>By default, all files with the same name as files in the zip archive are overwritten. With option &lt;code&gt;keep_old_files&lt;/code&gt; set, function &lt;code&gt;unzip/2&lt;/code&gt; does not overwrite existing files. Notice that even with option &lt;code&gt;memory&lt;/code&gt; specified, which means that no files are overwritten, existing files are excluded from the result.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6de29fd7730a88164d057863c9dcf72fa1cb3f6c" translate="yes" xml:space="preserve">
          <source>By default, all log events originating from within OTP, except the former so called &quot;SASL reports&quot;, look the same as before.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2882c6abbebff5ea0f043573bc5ce53ddfde39c3" translate="yes" xml:space="preserve">
          <source>By default, all parts of the string, including the empty strings, are returned from the function, for example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74b4b269097f50b433c9602d13038dfa07527232" translate="yes" xml:space="preserve">
          <source>By default, an &lt;code&gt;OCTET STRING&lt;/code&gt; is always represented as an Erlang binary. If the specification has been compiled with option &lt;code&gt;legacy_erlang_types&lt;/code&gt;, the encode functions accept both lists and binaries, and the decode functions decode an &lt;code&gt;OCTET STRING&lt;/code&gt; to a list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0bac80eb92816a5a88bf3b52b9fd2aacd857eeb1" translate="yes" xml:space="preserve">
          <source>By default, autostart information is stored in a file named &lt;code&gt;ttb_autostart.bin&lt;/code&gt; on each node. If this is not desired (for example, on diskless nodes), a custom module handling autostart information storage and retrieval can be provided by specifying environment variable &lt;code&gt;ttb_autostart_module&lt;/code&gt; for the application Runtime_Tools. The module must respond to the following API:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad25aa21de1694492059b0bfb35caab2d579e0fb" translate="yes" xml:space="preserve">
          <source>By default, characters with values &amp;gt; 255 do not match any of the Posix character classes. However, if option &lt;code&gt;PCRE_UCP&lt;/code&gt; is passed to &lt;code&gt;pcre_compile()&lt;/code&gt;, some of the classes are changed so that Unicode character properties are used. This is achieved by replacing certain Posix classes by other sequences, as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="053346f97801947e69ed842b8b3fec738287fe79" translate="yes" xml:space="preserve">
          <source>By default, data for all Telnet connections is logged in one common file (named &lt;code&gt;default&lt;/code&gt;), which can get messy, for example, if multiple Telnet sessions are running in parallel. Therefore a separate log file can be created for each connection. To configure this, use hook option &lt;code&gt;hosts&lt;/code&gt; and list the names of the servers/connections to be used in the suite. The connections must be named for this to work (see &lt;code&gt;&lt;a href=&quot;#open-1&quot;&gt;ct_telnet:open/1,2,3,4&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="776bbd51980a39359333108981da5fd37cece1a7" translate="yes" xml:space="preserve">
          <source>By default, each CTH installed is executed in the order that they are installed for init calls, and then reversed for end calls. This is not always desired, so &lt;code&gt;Common Test&lt;/code&gt; allows the user to specify a priority for each hook. The priority can either be specified in the CTH function &lt;code&gt;&lt;a href=&quot;ct_hooks#Module:init-2&quot;&gt;init/2&lt;/a&gt;&lt;/code&gt; or when installing the hook. The priority specified at installation overrides the priority returned by the CTH.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="462e7da9c97e5f027114d96a2306c993c035da8a" translate="yes" xml:space="preserve">
          <source>By default, each installation of a CTH causes a new instance of it to be activated. This can cause problems if you want to override CTHs in test specifications while still having them in the suite information function. The &lt;code&gt;&lt;a href=&quot;ct_hooks#Module:id-1&quot;&gt;id/1&lt;/a&gt;&lt;/code&gt; callback exists to address this problem. By returning the same &lt;code&gt;id&lt;/code&gt; in both places, &lt;code&gt;Common Test&lt;/code&gt; knows that this CTH is already installed and does not try to install it again.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46480571329f9b5765128d1e4d2b38b49550c0a0" translate="yes" xml:space="preserve">
          <source>By default, errors and warnings are printed to tty and the function returns &lt;code&gt;ok&lt;/code&gt; or &lt;code&gt;error&lt;/code&gt;. If option &lt;code&gt;silent&lt;/code&gt; is specified, the function instead either returns &lt;code&gt;{ok,Relup,Module,Warnings}&lt;/code&gt;, where &lt;code&gt;Relup&lt;/code&gt; is the release upgrade file, or &lt;code&gt;{error,Module,Error}&lt;/code&gt;. Warnings and errors can be converted to strings by calling &lt;code&gt;Module:format_warning(Warnings)&lt;/code&gt; or &lt;code&gt;Module:format_error(Error)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="294052fb58119cdee244d014d8cb85f8f3d4b24a" translate="yes" xml:space="preserve">
          <source>By default, errors and warnings are printed to tty and the function returns &lt;code&gt;ok&lt;/code&gt; or &lt;code&gt;error&lt;/code&gt;. If option &lt;code&gt;silent&lt;/code&gt; is specified, the function instead returns &lt;code&gt;{ok,Module,Warnings}&lt;/code&gt; or &lt;code&gt;{error,Module,Error}&lt;/code&gt;. Warnings and errors can be converted to strings by calling &lt;code&gt;Module:format_warning(Warnings)&lt;/code&gt; or &lt;code&gt;Module:format_error(Error)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee3c67a77746a67e2bb8398f5d758b0ceca821c3" translate="yes" xml:space="preserve">
          <source>By default, function &lt;code&gt;open/2&lt;/code&gt; function opens the tar file in &lt;code&gt;raw&lt;/code&gt; mode, which is faster but does not allow a remote (Erlang) file server to be used. Adding &lt;code&gt;cooked&lt;/code&gt; to the mode list overrides the default and opens the tar file without option &lt;code&gt;raw&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c31b08201db8e452376ac550216866c4f0213c87" translate="yes" xml:space="preserve">
          <source>By default, function &lt;code&gt;open/2&lt;/code&gt; opens the tar file in &lt;code&gt;raw&lt;/code&gt; mode, which is faster but does not allow a remote (Erlang) file server to be used. Adding &lt;code&gt;cooked&lt;/code&gt; to the mode list overrides the default and opens the tar file without option &lt;code&gt;raw&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c4fa6e3241b3f16b2494ba76c92a8e6751097f9" translate="yes" xml:space="preserve">
          <source>By default, if any requested chunk is missing in &lt;code&gt;Beam&lt;/code&gt;, an &lt;code&gt;error&lt;/code&gt; tuple is returned. However, if option &lt;code&gt;allow_missing_chunks&lt;/code&gt; is specified, a result is returned even if chunks are missing. In the result list, any missing chunks are represented as &lt;code&gt;{ChunkRef,missing_chunk}&lt;/code&gt;. Notice however that if chunk &lt;code&gt;&quot;Atom&quot;&lt;/code&gt; is missing, that is considered a fatal error and the return value is an &lt;code&gt;error&lt;/code&gt; tuple.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f53b57e48d13ba35bc616bbd211c0e3f61e0177" translate="yes" xml:space="preserve">
          <source>By default, in &lt;code&gt;unicode&lt;/code&gt; mode, characters with values &amp;gt; 255, that is, all characters outside the ISO Latin-1 character set, never match \d, \s, or \w, and always match \D, \S, and \W. These sequences retain their original meanings from before UTF support was available, mainly for efficiency reasons. However, if option &lt;code&gt;ucp&lt;/code&gt; is set, the behavior is changed so that Unicode properties are used to determine character types, as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8dce2b9977241b689bc8a7cc79ba1876582a372f" translate="yes" xml:space="preserve">
          <source>By default, symbolic links are stored as symbolic links in the tar file. To override the default and store the file that the symbolic link points to into the tar file, use option &lt;code&gt;dereference&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="307631df678df3363024a8553c6845aa25ac4dbc" translate="yes" xml:space="preserve">
          <source>By default, that lock is at the driver level, that is, if several ports have been opened to the same driver, only code for one port at the same time can be running.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59ef4e65d1c06e09a6d712a392cd376d76f7e30c" translate="yes" xml:space="preserve">
          <source>By default, the &lt;code&gt;Erl_Interface&lt;/code&gt; libraries are only guaranteed to be compatible with other Erlang/OTP components from the same release as the libraries themselves. For information about how to communicate with Erlang/OTP components from earlier releases, see function &lt;code&gt;&lt;a href=&quot;ei#ei_set_compat_rel&quot;&gt;ei:ei_set_compat_rel&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;erl_eterm#erl_set_compat_rel&quot;&gt;erl_eterm:erl_set_compat_rel&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de70cb5ed283df211d9a60f565e19a6787b411b0" translate="yes" xml:space="preserve">
          <source>By default, the &lt;code&gt;Erl_Interface&lt;/code&gt; library is only guaranteed to be compatible with other Erlang/OTP components from the same release as the &lt;code&gt;Erl_Interface&lt;/code&gt; library itself. For example, &lt;code&gt;Erl_Interface&lt;/code&gt; from Erlang/OTP R10 is not compatible with an Erlang emulator from Erlang/OTP R9 by default.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5408a0e73229b9b5e967fe902da2634b16e6868a" translate="yes" xml:space="preserve">
          <source>By default, the &lt;code&gt;ei&lt;/code&gt; library is only guaranteed to be compatible with other Erlang/OTP components from the same release as the &lt;code&gt;ei&lt;/code&gt; library itself. For example, &lt;code&gt;ei&lt;/code&gt; from Erlang/OTP R10 is not compatible with an Erlang emulator from Erlang/OTP R9 by default.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc7855f5354d795a3773624d2090708d90c447ea" translate="yes" xml:space="preserve">
          <source>By default, the &lt;strong&gt;default user&lt;/strong&gt; is set to the &lt;code&gt;snmpm_user_default&lt;/code&gt; module, which simply sends an info message to the error_logger. It is however highly recommended that this module be replaced by another that does something useful (see &lt;code&gt;&lt;a href=&quot;snmp_config#configuration_params&quot;&gt;configuration params&lt;/a&gt;&lt;/code&gt; for more info).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8754a9737ab7ee6fe2f3b847124e99177bf4ce53" translate="yes" xml:space="preserve">
          <source>By default, the Cover tool is automatically stopped when the tests are completed. This causes the original (non-cover compiled) modules to be loaded back into the test node. If a process at this point still runs old code of any of the modules that are cover compiled, meaning that it has not done any fully qualified function call after the cover compilation, the process is killed. To avoid this, set the value of option &lt;code&gt;cover_stop&lt;/code&gt; to &lt;code&gt;false&lt;/code&gt;. This means that the modules stay cover compiled. Therefore, this is only recommended if the Erlang nodes under test are terminated after the test is completed, or if cover can be manually stopped.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9bc1af126fb19b5493bbbaf63937647ea51683fa" translate="yes" xml:space="preserve">
          <source>By default, the Kernel application installs one log handler at system start. This handler is named &lt;code&gt;default&lt;/code&gt;. It receives and processes standard log events produced by the Erlang runtime system, standard behaviours and different Erlang/OTP applications. The log events are by default printed to the terminal.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44204f5230679d2fef96d8949b078f4f3e6c9083" translate="yes" xml:space="preserve">
          <source>By default, the Kernel application installs one log handler at system start. This handler is named &lt;code&gt;default&lt;/code&gt;. It receives and processes standard log events produced by the Erlang runtime system, standard behaviours and different Erlang/OTP applications. The log events are by default written to the terminal.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05263651b062c95772f413d54c47f0b67ec3f917" translate="yes" xml:space="preserve">
          <source>By default, the actual access to the backup media is performed through module &lt;code&gt;mnesia_backup&lt;/code&gt; for both read and write. Currently &lt;code&gt;mnesia_backup&lt;/code&gt; is implemented with the standard library module &lt;code&gt;disc_log&lt;/code&gt;. However, you can write your own module with the same interface as &lt;code&gt;mnesia_backup&lt;/code&gt; and configure &lt;code&gt;Mnesia&lt;/code&gt; so that the alternative module performs the actual accesses to the backup media. The user can therefore put the backup on a media that &lt;code&gt;Mnesia&lt;/code&gt; does not know about, possibly on hosts where Erlang is not running. Use configuration parameter &lt;code&gt;-mnesia backup_module &amp;lt;module&amp;gt;&lt;/code&gt; for this purpose.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1afaf0fcbb8ede75fea0c65c21d25a0925f3450" translate="yes" xml:space="preserve">
          <source>By default, the agent has no knowledge of any other contexts than the default context, &lt;code&gt;&quot;&quot;&lt;/code&gt;. If it is to support more contexts, these must be explicitly added, by using an appropriate configuration file &lt;code&gt;&lt;a href=&quot;snmp_agent_config_files&quot;&gt;Agent Configuration Files&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90e34246dd8429aefe6c7b588f2a3b0f064042d2" translate="yes" xml:space="preserve">
          <source>By default, the boot script and boot file are located in the same directory as &lt;code&gt;Name.rel&lt;/code&gt;. That is, in the current working directory unless &lt;code&gt;Name&lt;/code&gt; contains a path. If option &lt;code&gt;{outdir,Dir}&lt;/code&gt; is specified, they are located in &lt;code&gt;Dir&lt;/code&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d3804b66310d736d0a24d21cca9ed0959844c03" translate="yes" xml:space="preserve">
          <source>By default, the generated code for operation &lt;code&gt;Record#record_tag.field&lt;/code&gt; verifies that the tuple &lt;code&gt;Record&lt;/code&gt; has the correct size for the record, and that the first element is the tag &lt;code&gt;record_tag&lt;/code&gt;. Use this option to omit the verification code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92ed03811630a1034411365747a68f1b027d08b7" translate="yes" xml:space="preserve">
          <source>By default, the maximum number of atoms is 1,048,576. This limit can be raised or lowered using the &lt;code&gt;+t&lt;/code&gt; option.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c86aae6b772372c0ae40b88282e56c074aa7a5f1" translate="yes" xml:space="preserve">
          <source>By default, the parser that was generated will not print out error messages to the screen. The user will have to do this either by printing the returned error messages, or by inserting tests and print instructions in the Erlang code associated with the syntax rules of the grammar file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e241a1115343866b033984b2e0f3224cbedbb8d1" translate="yes" xml:space="preserve">
          <source>By default, the quantifiers are &quot;greedy&quot;, that is, they match as much as possible (up to the maximum number of permitted times), without causing the remaining pattern to fail. The classic example of where this gives problems is in trying to match comments in C programs. These appear between /* and */. Within the comment, individual * and / characters can appear. An attempt to match C comments by applying the pattern</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c85bc6c43eb52272e65af88f8cd9d253d828366" translate="yes" xml:space="preserve">
          <source>By default, the release package contains the directories &lt;code&gt;lib/App-Vsn/ebin&lt;/code&gt; and &lt;code&gt;lib/App-Vsn/priv&lt;/code&gt; for each included application. If more directories are to be included, option &lt;code&gt;dirs&lt;/code&gt; is specified, for example, &lt;code&gt;{dirs,[src,examples]}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f48b56c162fe6bc8e83c9024713b2063795276f9" translate="yes" xml:space="preserve">
          <source>By default, the release package file is located in the same directory as &lt;code&gt;Name.rel&lt;/code&gt;. That is, in the current working directory unless &lt;code&gt;Name&lt;/code&gt; contains a path. If option &lt;code&gt;{outdir,Dir}&lt;/code&gt; is specified, it is located in &lt;code&gt;Dir&lt;/code&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd67be193ef985280c7869e02ad1eaa76d02cee6" translate="yes" xml:space="preserve">
          <source>By default, the script will be interpreted. You can force it to be compiled by including the following line somewhere in the script file:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2a64b819e1641df3c5bc639a09bb56418f80b28" translate="yes" xml:space="preserve">
          <source>By default, the tar file is opened in &lt;code&gt;raw&lt;/code&gt; mode, which is faster but does not allow a remote (Erlang) file server to be used. Adding &lt;code&gt;cooked&lt;/code&gt; to the mode list overrides the default and opens the tar file without option &lt;code&gt;raw&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="968238200f11724a49fdbda317cbe260c831d025" translate="yes" xml:space="preserve">
          <source>By default, the value is as before, that is, &lt;code&gt;minimal&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e69fa5b82743edee630d33a79817b045aafc5d81" translate="yes" xml:space="preserve">
          <source>By default, this function adds a new line to the end of the specified command. If this is not desired, use option &lt;code&gt;{newline,false}&lt;/code&gt;. This is necessary, for example, when sending Telnet command sequences prefixed with character Interprete As Command (IAC).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d49eba4b9253b8356ed12159ecfe231995c2f898" translate="yes" xml:space="preserve">
          <source>By default, this function adds a newline to the end of the specified command. If this is not desired, option &lt;code&gt;{newline,false}&lt;/code&gt; can be used. This is necessary, for example, when sending Telnet command sequences prefixed with character Interprete As Command (IAC).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9e7714f2d506552215115a4ebf113d003a0acf0" translate="yes" xml:space="preserve">
          <source>By default, this function opens the zip file in &lt;code&gt;raw&lt;/code&gt; mode, which is faster but does not allow a remote (Erlang) file server to be used. Adding &lt;code&gt;cooked&lt;/code&gt; to the mode list overrides the default and opens the zip file without option &lt;code&gt;raw&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d14a17c6143d2f118a5dcf4b9f9f2f606d6beef7" translate="yes" xml:space="preserve">
          <source>By default, this function opens the zip file in &lt;code&gt;raw&lt;/code&gt; mode, which is faster but does not allow a remote (Erlang) file server to be used. Adding &lt;code&gt;cooked&lt;/code&gt; to the mode list overrides the default and opens the zip file without option &lt;code&gt;raw&lt;/code&gt;. The same applies for the files extracted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a8f2bce9d4e28310f04f71c37d623d77632500e" translate="yes" xml:space="preserve">
          <source>By default, this function opens the zip file in mode &lt;code&gt;raw&lt;/code&gt;, which is faster but does not allow a remote (Erlang) file server to be used. Adding &lt;code&gt;cooked&lt;/code&gt; to the mode list overrides the default and opens the zip file without the &lt;code&gt;raw&lt;/code&gt; option. The same applies for the files added.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="679e4d02c8183bf697056897c283fb7c9fe1a240" translate="yes" xml:space="preserve">
          <source>By default, this option is not set. This means that the number is not limited.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6486abd515b1ceb341dd61657f6cfe722ef188e0" translate="yes" xml:space="preserve">
          <source>By default, this rule is written to &lt;code&gt;&amp;lt;File&amp;gt;.Pbeam&lt;/code&gt;. However, if option &lt;code&gt;binary&lt;/code&gt; is set, nothing is written and the rule is returned in &lt;code&gt;Binary&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3dc5c5c502173feaca81300d649a4642ade965d9" translate="yes" xml:space="preserve">
          <source>By default, this will &lt;strong&gt;not&lt;/strong&gt; be used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e77c5d7a27dc1e5cf909f3bf8e3e3ad53b629c2" translate="yes" xml:space="preserve">
          <source>By default, warnings are emitted for unused variables, except for variables beginning with an underscore (&quot;Prolog style warnings&quot;). Use this option to turn off this kind of warnings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20ba07e398dad932a7a5314c1ee7e53c53da657a" translate="yes" xml:space="preserve">
          <source>By default, when &lt;code&gt;[]&lt;/code&gt; is passed as &lt;code&gt;ModifierList&lt;/code&gt;, both negative and positive integers can be returned. This to use the range of integers that do not need heap memory allocation as much as possible. By default the returned integers are also only guaranteed to be unique, that is, any returned integer can be smaller or larger than previously returned integers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11b69da7024ea541c3dc95c3ee7904796b05dd49" translate="yes" xml:space="preserve">
          <source>By definition, it is not possible to send objects with ACCESS &lt;code&gt;not-accessible&lt;/code&gt; in notifications. However, historically this is often done and for this reason we allow it in notification sending. If a variable has ACCESS &lt;code&gt;not-accessible&lt;/code&gt;, the user must provide a value for the variable in the &lt;code&gt;Varbinds&lt;/code&gt; list. It is not possible for the agent to perform a get-operation to retrieve this value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1fe4bf7551fb0bca40b8408258d2d9b38f061a30" translate="yes" xml:space="preserve">
          <source>By deliberately copying a single binary to avoid referencing a larger binary, one can, instead of freeing up the larger binary for later garbage collection, create much more binary data than needed. Sharing binary data is usually good. Only in special cases, when small parts reference large binaries and the large binaries are no longer used in any process, deliberate copying can be a good idea.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a1bde088e58ddc2e236cd1237348e4ca2d354a9" translate="yes" xml:space="preserve">
          <source>By executing these commands, two Erlang nodes are configured to run the &lt;code&gt;Company&lt;/code&gt; database, and therefore, initialize the database. This is required only once when setting up. The next time the system is started, &lt;code&gt;&lt;a href=&quot;mnesia#start-0&quot;&gt;mnesia:start()&lt;/a&gt;&lt;/code&gt; is called on both nodes, to initialize the system from disc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4cbb518f731cd8bac9f82803da816e494e6c084" translate="yes" xml:space="preserve">
          <source>By far the most common situation where this occurs, is when you get lists of UTF-8 instead of proper Unicode strings, and then convert them to UTF-8 in a binary or on a file:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e536308fb486e25402a1208f98bf1f7153e3c15e" translate="yes" xml:space="preserve">
          <source>By focusing on getting the code to pass the tests, the programmer can become more productive, not overspecify or get lost in premature optimizations, and create code that is correct from the very beginning (so-called &lt;strong&gt;test-driven development&lt;/strong&gt;; see &lt;code&gt;&lt;a href=&quot;#Terminology&quot;&gt;Terminology&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1be6092d2f04d5672bbcc552b76ea03252377f9a" translate="yes" xml:space="preserve">
          <source>By giving the format handler &lt;code&gt;&lt;a href=&quot;ttb#get_et_handler-0&quot;&gt;ttb:get_et_handler()&lt;/a&gt;&lt;/code&gt;, you can have the trace log presented graphically with &lt;code&gt;et_viewer&lt;/code&gt; in the ET application (see section &lt;code&gt;&lt;a href=&quot;#et_viewer&quot;&gt;Presenting Trace Logs with Event Tracer&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d1f348639ff071f4f3a637874209a8d2a2be427" translate="yes" xml:space="preserve">
          <source>By giving the format handler &lt;code&gt;&lt;a href=&quot;ttb#get_et_handler-0&quot;&gt;ttb:get_et_handler()&lt;/a&gt;&lt;/code&gt;, you can have the trace log presented graphically with &lt;code&gt;et_viewer&lt;/code&gt; in the ET application. &lt;code&gt;ttb&lt;/code&gt; provides filters that can be selected from the menu &lt;strong&gt;Filter&lt;/strong&gt; in the &lt;code&gt;et_viewer&lt;/code&gt; window. The filters are names according to the type of actors they present (that is, what each vertical line in the sequence diagram represents). Interaction between actors is shown as red arrows between two vertical lines, and activities within an actor are shown as blue text to the right of the actors line.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c38dcce4fbbcbaa49db2c494d622ac31a93af9e" translate="yes" xml:space="preserve">
          <source>By inspecting the headers or writing a small C program, it is found that &lt;code&gt;IPPROTO_TCP&lt;/code&gt; is 6, &lt;code&gt;TCP_INFO&lt;/code&gt; is 11, the structure size is 92 (bytes), the offset of &lt;code&gt;tcpi_sacked&lt;/code&gt; is 28 bytes, and the value is a 32-bit integer. The following code can be used to retrieve the value:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="018fc7c90872dc5bcc3ecc8ce71bc58db7e38b60" translate="yes" xml:space="preserve">
          <source>By inspecting the implementation, you might notice that some specific signal gives a stricter guarantee than described above. It is of vital importance that such knowledge about the implementation is &lt;strong&gt;not&lt;/strong&gt; used by Erlang code, as the implementation can change at any time without prior notice.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8b879e7731e558078b8cea840f1fb4c1f690b4a" translate="yes" xml:space="preserve">
          <source>By looking at the results from the analyses, it can be deducted that the test case does not cover the case when all channels are allocated and &lt;code&gt;test.erl&lt;/code&gt; should be extended accordingly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0adc0a428da4933a5c912fbd894ed220b7168db5" translate="yes" xml:space="preserve">
          <source>By parsing an XML document you will get a record, displaying the structure of the document, as return value. The record also holds the data of the document. xmerl is convenient to use in for instance the following scenarios:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="805a7a9a8ddfb1ba7400cf31f92187edc3ff9a77" translate="yes" xml:space="preserve">
          <source>By passing a pointer to an integer variable containing the value &lt;code&gt;ERL_DRV_BUSY_MSGQ_READ_ONLY&lt;/code&gt;, the currently used limit is read and written back to the integer variable. A new limit can be set by passing a pointer to an integer variable containing a valid limit. The passed value is written to the internal limit. The internal limit is then adjusted. After this the adjusted limit is written back to the integer variable from which the new value was read. Values are in bytes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75da6c1f2ebad0633762bf86ba622c3a4f5ba6cd" translate="yes" xml:space="preserve">
          <source>By passing the same &quot;fun&quot; as an argument to the function &lt;code&gt;&lt;a href=&quot;mnesia#sync_dirty-2&quot;&gt;mnesia:sync_dirty(Fun [, Args])&lt;/a&gt;&lt;/code&gt;, it is performed in almost the same context as the function &lt;code&gt;&lt;a href=&quot;mnesia#async_dirty-2&quot;&gt;mnesia:async_dirty/1,2&lt;/a&gt;&lt;/code&gt;. The difference is that the operations are performed synchronously. The caller waits for the updates to be performed on all active replicas. Using &lt;code&gt;mnesia:sync_dirty/1,2&lt;/code&gt; is useful in the following cases:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="808cd51c3638fb04adece47349170a09569ccf1c" translate="yes" xml:space="preserve">
          <source>By passing the same &quot;fun&quot; as argument to the function &lt;code&gt;&lt;a href=&quot;mnesia#async_dirty-2&quot;&gt;mnesia:async_dirty(Fun [, Args])&lt;/a&gt;&lt;/code&gt;, it is performed in dirty context. The function calls are mapped to the corresponding dirty functions. This still involves logging, replication, and subscriptions but no locking, local transaction storage, or commit protocols are involved. Checkpoint retainers are updated but updated &quot;dirty&quot;. Thus, they are updated asynchronously. The functions wait for the operation to be performed on one node but not the others. If the table resides locally, no waiting occurs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5fe18782111712f87288c23d1c8fb50a83e580df" translate="yes" xml:space="preserve">
          <source>By passing the same &quot;fun&quot; as argument to the function &lt;code&gt;&lt;a href=&quot;mnesia#sync_transaction-3&quot;&gt;mnesia:sync_transaction(Fun [, Args])&lt;/a&gt;&lt;/code&gt; it is performed in synced transaction context. Synced transactions wait until all active replicas has committed the transaction (to disc) before returning from the &lt;code&gt;mnesia:sync_transaction&lt;/code&gt; call. Using &lt;code&gt;sync_transaction&lt;/code&gt; is useful in the following cases:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d8e68091d4403f0e83bd114c70649e6a566d00b" translate="yes" xml:space="preserve">
          <source>By preference, these functions can be included in module &lt;code&gt;shell_default&lt;/code&gt;. By default, they are included in that module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f254d4f66995179ccfd6ad20889ce3083eb5612" translate="yes" xml:space="preserve">
          <source>By setting &lt;code&gt;SourceMod&lt;/code&gt; and &lt;code&gt;TargetMod&lt;/code&gt; to different modules, a backup can be copied from one backup media to another.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d49dba3e2b5c5cceb098125c642fa912b7e82445" translate="yes" xml:space="preserve">
          <source>By testing in a bottom-up fashion, beginning with the smallest program units and creating a confidence in that they work as they should, it becomes easier to test that a higher-level component, consisting of several such units, also behaves according to specification (known as &lt;strong&gt;integration testing&lt;/strong&gt;; see &lt;code&gt;&lt;a href=&quot;#Terminology&quot;&gt;Terminology&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff05bbe6b9df494deffc0d26f620950719c544d4" translate="yes" xml:space="preserve">
          <source>By this means, options can be made to have different settings in different parts of the pattern. Any changes made in one alternative do carry on into subsequent branches within the same subpattern. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="35ec349917181f956c0a4c9c0f4a81caa7003c00" translate="yes" xml:space="preserve">
          <source>By using &lt;code&gt;&lt;a href=&quot;debugger#start-1&quot;&gt;debugger:start/1&lt;/a&gt;&lt;/code&gt;, you can specify if Debugger is to be started in local or global mode:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6da8978f9ea68a7c6f48f6d3c9e527498ef08964" translate="yes" xml:space="preserve">
          <source>By using option &lt;code&gt;handler&lt;/code&gt; when starting the tracer, the information about how to format the file is stored in the trace information file (&lt;code&gt;.ti&lt;/code&gt;). This is not necessary, as it can be specified when formatting instead. However, It can be useful if you, for example, want to format trace logs automatically using option &lt;code&gt;format&lt;/code&gt; in &lt;code&gt;ttb:stop/1&lt;/code&gt;. Also, you do not need any knowledge of the content of a binary log to format it the way it is intended. If option &lt;code&gt;handler&lt;/code&gt; is specified both when starting the tracer and when formatting, the one specified when formatting is used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02d1325592a3ef565e5e7f405f91fc17bcd0d42f" translate="yes" xml:space="preserve">
          <source>By using ordinary UNIX tools like &lt;code&gt;sed&lt;/code&gt; and &lt;code&gt;grep&lt;/code&gt; one can easily find answers to various questions like:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2d275dd09349865f8c3284b6c4fd5293841ad62" translate="yes" xml:space="preserve">
          <source>By using the new API, you automatically get scalability and performance improvements. This also enables you to use the &lt;code&gt;&lt;a href=&quot;#Multi_Time_Warp_Mode&quot;&gt;multi-time warp mode&lt;/a&gt;&lt;/code&gt; that improves accuracy and precision of time measurements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77c257b7be9bfb86770597be303f8b67e4aa586a" translate="yes" xml:space="preserve">
          <source>By wrapping the API with functions that fall back on &lt;code&gt;erlang:now/0&lt;/code&gt; when the new API is unavailable, and using these wrappers instead of using the API directly, the problem is solved. These wrappers can, for example, be implemented as in &lt;code&gt;$ERL_TOP/erts/example/time_compat.erl&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00bf079d821f3a0145d168bfcf76ce42b727b9c4" translate="yes" xml:space="preserve">
          <source>Bypass all messages to the receiving process.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0cfa66375624ff2bee2fec17b2715898b2615b30" translate="yes" xml:space="preserve">
          <source>Bypass the native code compilation of some key files that Dialyzer heuristically performs when dialyzing many files. This avoids the compilation time, but can result in (much) longer analysis time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eed4df1a2c0521e891f717551aca2cc2df95a04a" translate="yes" xml:space="preserve">
          <source>Bytes that are out of the range 0x2A, 0x2D, 0x2E, 0x30 to 0x39, 0x41 to 0x5A, 0x5F, 0x61 to 0x7A, are percent-encoded (U+0025 PERCENT SIGN character (%) followed by uppercase ASCII hex digits representing the hexadecimal value of the byte).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ca15868aa5caba5cda8401a4c79d41061a3d6a4" translate="yes" xml:space="preserve">
          <source>Bytes written to the file by any means are translated to UTF-8 encoding before being stored on the disk file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32096c2e0eff33d844ee6d675407ace18289357d" translate="yes" xml:space="preserve">
          <source>C</source>
          <target state="translated">C</target>
        </trans-unit>
        <trans-unit id="e48d8a1314ac59090c047f1cace030d6174ffe04" translate="yes" xml:space="preserve">
          <source>C nodes can also register themselves with &lt;code&gt;epmd&lt;/code&gt; if they want other nodes in the system to be able to find and connect to them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7aaca542e8937ae72090fdd955fe659422678461" translate="yes" xml:space="preserve">
          <source>C-Left</source>
          <target state="translated">C-Left</target>
        </trans-unit>
        <trans-unit id="e2bb854461c349ecc3ae2bfb00ac6727ba113ad8" translate="yes" xml:space="preserve">
          <source>C-Right</source>
          <target state="translated">C-Right</target>
        </trans-unit>
        <trans-unit id="3bff8fb1aa290267671b1c50e3b32db24f00b295" translate="yes" xml:space="preserve">
          <source>C-a</source>
          <target state="translated">C-a</target>
        </trans-unit>
        <trans-unit id="c204a76fc3c1123c96b13dd7ec922d02d4b00e91" translate="yes" xml:space="preserve">
          <source>C-b</source>
          <target state="translated">C-b</target>
        </trans-unit>
        <trans-unit id="1d8e75405de8be939b05db3eef9ab4daa516674d" translate="yes" xml:space="preserve">
          <source>C-d</source>
          <target state="translated">C-d</target>
        </trans-unit>
        <trans-unit id="a7ef1e89e28b60bd53a0a5ab746fbcd131fdf224" translate="yes" xml:space="preserve">
          <source>C-e</source>
          <target state="translated">C-e</target>
        </trans-unit>
        <trans-unit id="dd71d43937255c2ba419c077fa824865f8267186" translate="yes" xml:space="preserve">
          <source>C-f</source>
          <target state="translated">C-f</target>
        </trans-unit>
        <trans-unit id="a6d13ed5d2d00101157246b7ae1e91a19d7d7406" translate="yes" xml:space="preserve">
          <source>C-g</source>
          <target state="translated">C-g</target>
        </trans-unit>
        <trans-unit id="d5eeac2f32301e2b964f421e02a44c5afa000881" translate="yes" xml:space="preserve">
          <source>C-k</source>
          <target state="translated">C-k</target>
        </trans-unit>
        <trans-unit id="2fef5b5a274737535a312ecc5d6b8de717c1cb77" translate="yes" xml:space="preserve">
          <source>C-l</source>
          <target state="translated">C-l</target>
        </trans-unit>
        <trans-unit id="aa3408adf600065cf33c17971e8cdd9f76e5d785" translate="yes" xml:space="preserve">
          <source>C-n</source>
          <target state="translated">C-n</target>
        </trans-unit>
        <trans-unit id="332268c029d8126391ff9151361238bdf44870d8" translate="yes" xml:space="preserve">
          <source>C-p</source>
          <target state="translated">C-p</target>
        </trans-unit>
        <trans-unit id="68b4cf03a08cd7bf7acc0d39d68cca6ef0f409f3" translate="yes" xml:space="preserve">
          <source>C-t</source>
          <target state="translated">C-t</target>
        </trans-unit>
        <trans-unit id="ac7de9aff7d0daffb3ae53140a783f411f89c587" translate="yes" xml:space="preserve">
          <source>C-u</source>
          <target state="translated">C-u</target>
        </trans-unit>
        <trans-unit id="8e0be97e2cc76979d93e15014888863a6e79a7af" translate="yes" xml:space="preserve">
          <source>C-w</source>
          <target state="translated">C-w</target>
        </trans-unit>
        <trans-unit id="f286461016d3e4db77e8a575a1f55b2d71886961" translate="yes" xml:space="preserve">
          <source>C-y</source>
          <target state="translated">C-y</target>
        </trans-unit>
        <trans-unit id="27ae2e5d9b51df18972eb310bdefaba625476830" translate="yes" xml:space="preserve">
          <source>CEA is sent and received by diameter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff534b0e9ae18ae782f79e9fe262a000f3c6ff49" translate="yes" xml:space="preserve">
          <source>CER is sent and received by diameter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="112d72d949c9bbe40789456cde8492d907b63e28" translate="yes" xml:space="preserve">
          <source>CHARACTER (size), CHAR (size)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24ecce9e5657a884a70aea047867075f09d39ad6" translate="yes" xml:space="preserve">
          <source>CHARACTER VARYING(size), CHAR VARYING(size)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a4f0e1b5b9cde6b772cb89e0e6bdb0a6ab6de56" translate="yes" xml:space="preserve">
          <source>CR, LF, or CRLF only</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5ab3cb5603f8a4df9b9b5741bc8bf57061a02e7" translate="yes" xml:space="preserve">
          <source>CRL cache</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff86d60418e1cef1253cf01c43b18051224fcb54" translate="yes" xml:space="preserve">
          <source>CTHs are run with the same process scoping as normal test suites, that is, a different process executes the &lt;code&gt;init_per_suite&lt;/code&gt; hooks then the &lt;code&gt;init_per_group&lt;/code&gt; or &lt;code&gt;per_testcase&lt;/code&gt; hooks. So if you want to spawn a process in the CTH, you cannot link with the CTH process, as it exits after the post hook ends. Also, if you for some reason need an ETS table with your CTH, you must spawn a process that handles it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e6e1792db904ba826af372ccec45b6e25fb5024" translate="yes" xml:space="preserve">
          <source>CTHs can also be added within a test suite. This is done by returning &lt;code&gt;{ct_hooks,[CTH]}&lt;/code&gt; in the configuration list from &lt;code&gt;&lt;a href=&quot;common_test#Module:suite-0&quot;&gt;suite/0&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;common_test#Module:init_per_suite-1&quot;&gt;init_per_suite/1&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;common_test#Module:init_per_group-2&quot;&gt;init_per_group/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cebcaf761552337b6a6de3a9db00451f69633f4b" translate="yes" xml:space="preserve">
          <source>CTHs can be used to synchronize test runs with external user applications. The init function can, for example, start and/or communicate with an application that has the purpose of preparing the SUT for an upcoming test run, or initialize a database for saving test data to during the test run. The terminate function can similarly order such an application to reset the SUT after the test run, and/or tell the application to finish active sessions and terminate. Any system error- or progress reports generated during the init- or termination stage are saved in the &lt;code&gt;&lt;a href=&quot;run_test_chapter#pre_post_test_io_log&quot;&gt;Pre- and Post Test I/O Log&lt;/a&gt;&lt;/code&gt;. (This is also true for any printouts made with &lt;code&gt;ct:log/2&lt;/code&gt; and &lt;code&gt;ct:pal/2&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1413152f77878171b8b1aa5bd33bfea4b91b1e35" translate="yes" xml:space="preserve">
          <source>CTHs cannot be added here right now. That feature may be added in a later release, but it would right now break backwards compatibility.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27930480546a406089acbe7e97d210e59cf3f0a5" translate="yes" xml:space="preserve">
          <source>Caches a new session or updates an already cached one. Is only called from the cache handling process.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a61c27140fecb8e4a22ce80c81760b45147855bd" translate="yes" xml:space="preserve">
          <source>Calculate scheduler utilizations for the time interval from when &lt;code&gt;Sample&lt;/code&gt; was taken and &quot;now&quot;. The same as calling &lt;code&gt;scheduler:utilization(Sample, scheduler:sample_all())&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3159ceb44a5156030b65aa273f276c3747dcacc9" translate="yes" xml:space="preserve">
          <source>Calculates a key for later use in &lt;code&gt;&lt;a href=&quot;#driver_async&quot;&gt;driver_async&lt;/a&gt;&lt;/code&gt;. The keys are evenly distributed so that a fair mapping between port IDs and async thread IDs is achieved.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97a16654177af632fa24a3c60a60a85917da19f0" translate="yes" xml:space="preserve">
          <source>Calculates a ssh fingerprint from a public host key as openssh does.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96b67c5752326af1f998bcfc9d0641aa609cb938" translate="yes" xml:space="preserve">
          <source>Calculates an MD5 redundancy check for the code of the module (compilation date and other attributes are not included).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49556b91adcf0245cb3d710749c75861fa022a4f" translate="yes" xml:space="preserve">
          <source>Calculates and returns the length of queue &lt;code&gt;Q&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e81ece084c83acdfbcc583fdce8e53ba5b901b1" translate="yes" xml:space="preserve">
          <source>Calculates scheduler utilizations for the time interval between the two samples obtained from calling &lt;code&gt;&lt;a href=&quot;#sample-0&quot;&gt;sample/0&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#sample_all-0&quot;&gt;sample_all/0&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="227b790ced77d840153cd69f4b9d2467f87af6d9" translate="yes" xml:space="preserve">
          <source>Calculates the Adler-32 checksum for &lt;code&gt;Data&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f486ba07e5a51271bcf5c7397d6baef999b087f1" translate="yes" xml:space="preserve">
          <source>Calculates the CRC checksum for &lt;code&gt;Data&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a8a87c52d80ef29c6c7f4e720f1eb69b8f5e769" translate="yes" xml:space="preserve">
          <source>Calculates the time difference &lt;code&gt;Tdiff = T2 - T1&lt;/code&gt; in &lt;strong&gt;microseconds&lt;/strong&gt;, where &lt;code&gt;T1&lt;/code&gt; and &lt;code&gt;T2&lt;/code&gt; are time-stamp tuples on the same format as returned from &lt;code&gt;erlang:timestamp/0&lt;/code&gt; or &lt;code&gt;os:timestamp/0&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31e631ed71da6b22331e1ba2c1ab40350acc8c94" translate="yes" xml:space="preserve">
          <source>Calculates, without doing the encoding, the maximum byte size for a term encoded in the Erlang external term format. The following condition applies always:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9a2b0161d342ba687bae1cf3bd6fc16726fc85e" translate="yes" xml:space="preserve">
          <source>Call ::= FunSpec &lt;code&gt;-&amp;gt;&lt;/code&gt; FunSpec | &lt;code&gt;{&lt;/code&gt;MFA&lt;code&gt;,&lt;/code&gt; MFA&lt;code&gt;}&lt;/code&gt; | AtomConst &lt;code&gt;-&amp;gt;&lt;/code&gt; AtomConst | &lt;code&gt;{&lt;/code&gt;AtomConst&lt;code&gt;,&lt;/code&gt; AtomConst&lt;code&gt;}&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e87defee9508517c6c10659d4e0fee5236449ad6" translate="yes" xml:space="preserve">
          <source>Call &lt;code&gt;&lt;a href=&quot;#enif_schedule_nif&quot;&gt;enif_schedule_nif&lt;/a&gt;&lt;/code&gt;, pass to it a pointer to the dirty NIF to be executed, and indicate with argument &lt;code&gt;flags&lt;/code&gt; whether it expects the operation to be CPU-bound or I/O-bound.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69bfcf4495124cb65edd6183c66a7288de41dd51" translate="yes" xml:space="preserve">
          <source>Call &lt;code&gt;analyze&lt;/code&gt; with &lt;code&gt;total&lt;/code&gt; option when profiling has been stopped to display the results per function call, that is in which function calls the time has been spent.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="166bcff3bd03bad3b22be129a767e953b92bb7c5" translate="yes" xml:space="preserve">
          <source>Call &lt;code&gt;info&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b32de2da67e0b479c6558da688c298d2c8d61df" translate="yes" xml:space="preserve">
          <source>Call Graph Edges (*).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee61800f5d1b4760400245c96aa2f8c30730dd00" translate="yes" xml:space="preserve">
          <source>Call Graph Vertices (*).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4517bf0f809aaf1e241952932bd6d071e97a1670" translate="yes" xml:space="preserve">
          <source>Call a NIF that first performs a chunk of the work, then invokes the &lt;code&gt;&lt;a href=&quot;#enif_schedule_nif&quot;&gt;enif_schedule_nif&lt;/a&gt;&lt;/code&gt; function to schedule another NIF call to perform the next chunk. The final call scheduled in this manner can then return the overall result.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e64aca1cbd78581418480040f30e164b840d03b" translate="yes" xml:space="preserve">
          <source>Call back function to accumulate contents of entity.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25cbcf90fa280c9778e7621dfdd70289b3357c4e" translate="yes" xml:space="preserve">
          <source>Call back function to decide what to do if the scanner runs into EOF before the document is complete.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="305e72ce9d0178fb37627379b7066e3998f1aaff" translate="yes" xml:space="preserve">
          <source>Call back function to fetch an external resource.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1d17c05f561817d9262782ed4703874ffa16a47" translate="yes" xml:space="preserve">
          <source>Call back function to handle scanner events.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="967a892c17aad400146f3cd8a0b41cd0e008b98d" translate="yes" xml:space="preserve">
          <source>Call back function to process the document entities once identified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e43990d9029a1b5faffe47cfb2a73c40d38948b7" translate="yes" xml:space="preserve">
          <source>Call count tracing is very lightweight compared to other forms of tracing since no trace message has to be generated. Some measurements indicates performance degradation in the vicinity of 10 percent.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d9d8ff2abc216537369a4f6c51252cf41bb671a" translate="yes" xml:space="preserve">
          <source>Call count tracing is very lightweight compared to other forms of tracing since no trace message has to be generated. Some measurements indicates performance degradations in the vicinity of 10 percent.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ed8c88acf1e0b8225e507d6c8cef5617c61d6b6" translate="yes" xml:space="preserve">
          <source>Call these iteration functions on nodes that contain a replica of the table. Each call to the function &lt;code&gt;Fun&lt;/code&gt; access the table and if the table resides on another node it generates much unnecessary network traffic.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92a83b9ff602a28ae97d4ee0c90eb3fa1240e7fa" translate="yes" xml:space="preserve">
          <source>Call this function to stop cover test on nodes previously added with &lt;code&gt;&lt;a href=&quot;#add_nodes-1&quot;&gt;ct_cover:add_nodes/1&lt;/a&gt;&lt;/code&gt;. Results on the remote node are transferred to the &lt;code&gt;Common Test&lt;/code&gt; node.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37045b168b3bc333ac8bca52ef56747d12a1101f" translate="yes" xml:space="preserve">
          <source>Call this function when profiling has been stopped to display the results per process, that is:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eea8e2a2479f703038c465d2c2ffcd082e88cb6f" translate="yes" xml:space="preserve">
          <source>Callback = atom()</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61dfb922d9f46c947d009d0fb95ea292779f3dc7" translate="yes" xml:space="preserve">
          <source>Callback for &lt;code&gt;ct_telnet.erl&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e45c8484398e4aeac5267b27d0e1fb6f862e303" translate="yes" xml:space="preserve">
          <source>Callback function &lt;code&gt;TraverseFun&lt;/code&gt; is used for traversing the table. It is to return a list of objects terminated by either &lt;code&gt;[]&lt;/code&gt; or a nullary fun to be used for traversing the not yet traversed objects of the table. Any other return value is immediately returned as value of the query evaluation. Unary &lt;code&gt;TraverseFun&lt;/code&gt;s are to accept a match specification as argument. The match specification is created by the parse transform by analyzing the pattern of the generator calling &lt;code&gt;qlc:table/2&lt;/code&gt; and filters using variables introduced in the pattern. If the parse transform cannot find a match specification equivalent to the pattern and filters, &lt;code&gt;TraverseFun&lt;/code&gt; is called with a match specification returning every object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04f9a377a5245adf1c0c727ef509b19ea04d764a" translate="yes" xml:space="preserve">
          <source>Callback functions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37556ac19058ca5c17bab63cd838a12f2880d206" translate="yes" xml:space="preserve">
          <source>Callback functions that are optional for the user of the behaviour to implement are specified by use of the &lt;code&gt;-optional_callbacks&lt;/code&gt; attribute:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a04bb6692677302b06dcc4155d24ffed7a1d8b90" translate="yes" xml:space="preserve">
          <source>Callback invoked prior to terminating the transport process of a transport connection having watchdog state &lt;code&gt;OKAY&lt;/code&gt;. Applied to &lt;code&gt;application|service|transport&lt;/code&gt; and the &lt;code&gt;&lt;code&gt;&lt;a href=&quot;#transport_ref&quot;&gt;transport_ref()&lt;/a&gt;&lt;/code&gt;&lt;/code&gt; and &lt;code&gt;&lt;code&gt;diameter_app:peer()&lt;/code&gt;&lt;/code&gt; in question: &lt;code&gt;application&lt;/code&gt; indicates that the diameter application is being stopped, &lt;code&gt;service&lt;/code&gt; that the service in question is being stopped by &lt;code&gt;&lt;a href=&quot;#stop_service-1&quot;&gt;stop_service/1&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;transport&lt;/code&gt; that the transport in question is being removed by &lt;code&gt;&lt;a href=&quot;#remove_transport-2&quot;&gt;remove_transport/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66eade566a1aabb00b9616d9f85c98561a92d0e8" translate="yes" xml:space="preserve">
          <source>Callback invoked upon reception of CER/CEA during capabilities exchange in order to ask whether or not the connection should be accepted. Applied to the &lt;code&gt;&lt;code&gt;&lt;a href=&quot;#transport_ref&quot;&gt;transport_ref()&lt;/a&gt;&lt;/code&gt;&lt;/code&gt; and &lt;code&gt;#diameter_caps{}&lt;/code&gt; record of the connection.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8170a9b43176c43c83ab38fea10e4e72c195d1f2" translate="yes" xml:space="preserve">
          <source>Callback module for &lt;code&gt;&lt;a href=&quot;ct_telnet&quot;&gt;ct_telnet&lt;/a&gt;&lt;/code&gt;, for connecting to a Telnet server on a UNIX host.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="723d576b61f4090ef99d45ef635768456422a654" translate="yes" xml:space="preserve">
          <source>Callback module for ct_telnet, for connecting to a Telnet server on a UNIX host.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6227e8f008e1e3653b7695696953858c51a783a" translate="yes" xml:space="preserve">
          <source>Callback module for customized logging of errors, warnings, and info messages. The callback module must implement the &lt;code&gt;tftp_logger&lt;/code&gt; behavior, see &lt;code&gt;&lt;a href=&quot;#tftp_logger&quot;&gt;LOGGER FUNCTIONS&lt;/a&gt;&lt;/code&gt;. The default module is &lt;code&gt;tftp_logger&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac834d27797dbad127ce8fd6d8a2319b5f46c402" translate="yes" xml:space="preserve">
          <source>Callback module for users of the Megaco application</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55798c61abfa41a7a5297d6740d1e64b1d565485" translate="yes" xml:space="preserve">
          <source>Callback module in which messages of the Diameter application are handled. See &lt;code&gt;diameter_app(3)&lt;/code&gt; for the required interface and semantics.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63edefe6aafdd040e89d039ff830e8a61ffa1b95" translate="yes" xml:space="preserve">
          <source>Callback modules for &lt;code&gt;gen_server&lt;/code&gt;, &lt;code&gt;gen_statem&lt;/code&gt;, and &lt;code&gt;gen_event&lt;/code&gt; can also change the value of &lt;code&gt;Misc&lt;/code&gt; by exporting a function &lt;code&gt;format_status/2&lt;/code&gt;, which contributes module-specific information. For details, see &lt;code&gt;&lt;a href=&quot;gen_server#Module:format_status-2&quot;&gt;gen_server:format_status/2&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;gen_statem#Module:format_status-2&quot;&gt;gen_statem:format_status/2&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;gen_event#Module:format_status-2&quot;&gt;gen_event:format_status/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a42e9b08e0786b523d53e7aaa69806b6b4c7c7b" translate="yes" xml:space="preserve">
          <source>Callback timeouts</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1424d68bc26afe36f6e438d92e2344fe5359e183" translate="yes" xml:space="preserve">
          <source>Called after an asynchronous call has completed. The asynchronous call is started with &lt;code&gt;&lt;a href=&quot;erl_driver#driver_async&quot;&gt;erl_driver:driver_async&lt;/a&gt;&lt;/code&gt;. This function is called from the Erlang emulator thread, as opposed to the asynchronous function, which is called in some thread (if multi-threading is enabled).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="308f76c161337017286f205aef3ab09cb6ea041d" translate="yes" xml:space="preserve">
          <source>Called after the basic message processing (MPD) has been done, but before the pdu is handed over to the master-agent for primary processing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a313d3073d9eea56873be11a826fd840a7e0d86d" translate="yes" xml:space="preserve">
          <source>Called after the basic message processing (MPD) has been done, but before the pdu is handed over to the server for primary processing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5fe3aacb675f5586e55ac426e9e29a0553867e0" translate="yes" xml:space="preserve">
          <source>Called any time after the driver's timer reaches &lt;code&gt;0&lt;/code&gt;. The timer is activated with &lt;code&gt;&lt;a href=&quot;erl_driver#driver_set_timer&quot;&gt;erl_driver:driver_set_timer&lt;/a&gt;&lt;/code&gt;. No priorities or ordering exist among drivers, so if several drivers time out at the same time, anyone of them is called first.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81eabbdc5601ceaa0bccb714043c53b451726d6f" translate="yes" xml:space="preserve">
          <source>Called at the reception of a message (before &lt;strong&gt;any&lt;/strong&gt; processing has been done).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf59df7706e69db3cc159c1ee57e97f02070c14b" translate="yes" xml:space="preserve">
          <source>Called before the basic message processing (MPD) is done, when a pdu has been received from the master-agent.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67cc06ab5c5cdaf22f4e18059ff7135bed75b26e" translate="yes" xml:space="preserve">
          <source>Called before the fun is unregistered. Here any cleaning up can be done. The return value is not important, but is passed back to the caller of &lt;code&gt;clear_crypto_key_fun/0&lt;/code&gt; as part of its return value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60cc53ceda191e4c7c43073a2ca95d2429376ca7" translate="yes" xml:space="preserve">
          <source>Called before the sending of a message (after &lt;strong&gt;all&lt;/strong&gt; processing has been done).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="411e859542f736dac045f8721e0a466752068640" translate="yes" xml:space="preserve">
          <source>Called by &lt;code&gt;&lt;a href=&quot;net_adm&quot;&gt;net_adm:names/0&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;Host&lt;/code&gt; defaults to the localhost. Returns the names and associated port numbers of the Erlang nodes that &lt;code&gt;epmd&lt;/code&gt; registered at the specified host. Returns &lt;code&gt;{error, address}&lt;/code&gt; if &lt;code&gt;epmd&lt;/code&gt; is not operational.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="754186ab8b7082c0674d04f3bdaf7fcddc1ab3a3" translate="yes" xml:space="preserve">
          <source>Called by the &lt;code&gt;erl_ddll&lt;/code&gt; driver when the driver is unloaded. (It is only called in dynamic drivers.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="650a5975977f531507f62d29a2ce95a7a1cfb83f" translate="yes" xml:space="preserve">
          <source>Called by the distribution module. Resolves the &lt;code&gt;Host&lt;/code&gt; to an IP address.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6e67ee5139f5c3d24c6add77615125e4e640a01" translate="yes" xml:space="preserve">
          <source>Called directly after the driver has been loaded by &lt;code&gt;erl_ddll:load_driver/2&lt;/code&gt; (actually when the driver is added to the driver list). The driver is to return &lt;code&gt;0&lt;/code&gt;, or, if the driver cannot initialize, &lt;code&gt;-1&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="262d7b78c6487d8a39946866f1d11a39d5496a09" translate="yes" xml:space="preserve">
          <source>Called from &lt;code&gt;&lt;a href=&quot;#handle_system_msg-6&quot;&gt;handle_system_msg/6&lt;/a&gt;&lt;/code&gt; when the process is to continue its execution (for example, after it has been suspended). This function never returns.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73172cc1a7cb2d69c85f4a96da6765b4101ba755" translate="yes" xml:space="preserve">
          <source>Called from &lt;code&gt;&lt;a href=&quot;#handle_system_msg-6&quot;&gt;handle_system_msg/6&lt;/a&gt;&lt;/code&gt; when the process is to perform a code change. The code change is used when the internal data structure has changed. This function converts argument &lt;code&gt;Misc&lt;/code&gt; to the new data structure. &lt;code&gt;OldVsn&lt;/code&gt; is attribute &lt;strong&gt;vsn&lt;/strong&gt; of the old version of the &lt;code&gt;Module&lt;/code&gt;. If no such attribute is defined, the atom &lt;code&gt;undefined&lt;/code&gt; is sent.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="594143f9a65ae1c6fe10c4f338068b8a9f905601" translate="yes" xml:space="preserve">
          <source>Called from &lt;code&gt;&lt;a href=&quot;#handle_system_msg-6&quot;&gt;handle_system_msg/6&lt;/a&gt;&lt;/code&gt; when the process is to replace its current state. &lt;code&gt;NState&lt;/code&gt; is the value returned by &lt;code&gt;&lt;a href=&quot;#replace_state-3&quot;&gt;replace_state/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9b3e834b715a254168526e411e95a8a48713b20" translate="yes" xml:space="preserve">
          <source>Called from &lt;code&gt;&lt;a href=&quot;#handle_system_msg-6&quot;&gt;handle_system_msg/6&lt;/a&gt;&lt;/code&gt; when the process is to return a term that reflects its current state. &lt;code&gt;State&lt;/code&gt; is the value returned by &lt;code&gt;&lt;a href=&quot;#get_state-2&quot;&gt;get_state/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4c98925793456e56a2d33122eb6a311fa293f3d" translate="yes" xml:space="preserve">
          <source>Called from &lt;code&gt;&lt;a href=&quot;#handle_system_msg-6&quot;&gt;handle_system_msg/6&lt;/a&gt;&lt;/code&gt; when the process is to terminate. For example, this function is called when the process is suspended and its parent orders shutdown. It gives the process a chance to do a cleanup. This function never returns.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee779128abb96dcaaa77c4845eb5b58fcbdf4ab2" translate="yes" xml:space="preserve">
          <source>Called from &lt;code&gt;&lt;a href=&quot;erlang#port_call-3&quot;&gt;erlang:port_call/3&lt;/a&gt;&lt;/code&gt;. It works a lot like the &lt;code&gt;control&lt;/code&gt; callback, but uses the external term format for input and output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eda5333bad3b8e6536c6e400a545bf0c68561f86" translate="yes" xml:space="preserve">
          <source>Called from &lt;code&gt;erlang:open_port/2&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52c95806576ffd5c6e9bda3738995849c83e6d48" translate="yes" xml:space="preserve">
          <source>Called from &lt;code&gt;erlang:port_call/3&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37967ef10d51ab9623c55cce347e8ac82ffaa69f" translate="yes" xml:space="preserve">
          <source>Called from &lt;code&gt;erlang:port_control/3&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76a9c293f08a9964ffe8949415ea15fcd479022c" translate="yes" xml:space="preserve">
          <source>Called from &lt;code&gt;erlang:send/2&lt;/code&gt; and &lt;code&gt;erlang:port_command/2&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b7712d2af65521477e16f6013575117d34b96c0" translate="yes" xml:space="preserve">
          <source>Called in order to close the &lt;code&gt;Listen&lt;/code&gt; handle that originally was passed from the &lt;code&gt;&lt;a href=&quot;#listen&quot;&gt;listen/1&lt;/a&gt;&lt;/code&gt; callback.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="470a1c0ce98f90a6c63285d61ce7082f47f6706f" translate="yes" xml:space="preserve">
          <source>Called on behalf of &lt;code&gt;&lt;a href=&quot;erl_driver#driver_select&quot;&gt;erl_driver:driver_select&lt;/a&gt;&lt;/code&gt; when it is safe to close an event object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23ff0ae2399ea44f77132823a27ee56494ae7347" translate="yes" xml:space="preserve">
          <source>Called to instruct the manager that this agent shall be handled. This function is used when the user knows in advance which agents the manager shall handle. Note that there is an alternate way to do the same thing: Add the agent to the manager config files (see &lt;code&gt;&lt;a href=&quot;snmp_manager_config_files#agents&quot;&gt;agents.conf&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c4e12b2b87e916464a480eeba6c90e011990c07" translate="yes" xml:space="preserve">
          <source>Called when a driver event (specified in parameter &lt;code&gt;event&lt;/code&gt;) is signaled. This is used to help asynchronous drivers &quot;wake up&quot; when something occurs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5f6a024fd8f77a2ea9867d6adcf09937e5b321e" translate="yes" xml:space="preserve">
          <source>Called when a monitored process exits. The &lt;code&gt;drv_data&lt;/code&gt; is the data associated with the port for which the process is monitored (using &lt;code&gt;&lt;a href=&quot;erl_driver#driver_monitor_process&quot;&gt;erl_driver:driver_monitor_process&lt;/a&gt;&lt;/code&gt;) and the &lt;code&gt;monitor&lt;/code&gt; corresponds to the &lt;code&gt;ErlDrvMonitor&lt;/code&gt; structure filled in when creating the monitor. The driver interface function &lt;code&gt;&lt;a href=&quot;erl_driver#driver_get_monitored_process&quot;&gt;erl_driver:driver_get_monitored_process&lt;/a&gt;&lt;/code&gt; can be used to retrieve the process ID of the exiting process as an &lt;code&gt;ErlDrvTermData&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d67e2aa0c472d7e1f331918d874d82a46a103385" translate="yes" xml:space="preserve">
          <source>Called when a port is closed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f79f35f10e231c1c5d46754dcc831f0124571c5" translate="yes" xml:space="preserve">
          <source>Called when an Erlang process has sent data to the port. The data is pointed to by &lt;code&gt;buf&lt;/code&gt;, and is &lt;code&gt;len&lt;/code&gt; bytes. Data is sent to the port with &lt;code&gt;Port ! {self(), {command, Data}}&lt;/code&gt; or with &lt;code&gt;erlang:port_command/2&lt;/code&gt;. Depending on how the port was opened, it is to be either a list of integers &lt;code&gt;0...255&lt;/code&gt; or a binary. See &lt;code&gt;&lt;a href=&quot;erlang#open_port-2&quot;&gt;erlang:open_port/2&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;erlang#port_command-2&quot;&gt;erlang:port_command/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fefd076009119dd92492aabc22699c37cd1acfde" translate="yes" xml:space="preserve">
          <source>Called when document has been completely parsed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9d5c990ed44bfe60f747ede5eb6362b963aa6ee" translate="yes" xml:space="preserve">
          <source>Called when it is possible to write to a socket.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea08619d53f9130eaa9e346bb5fa5aec56010fde" translate="yes" xml:space="preserve">
          <source>Called when the driver is instantiated, when &lt;code&gt;&lt;a href=&quot;erlang#open_port-2&quot;&gt;erlang:open_port/2&lt;/a&gt;&lt;/code&gt; is called. The driver is to return a number &amp;gt;= 0 or a pointer, or, if the driver cannot be started, one of three error codes:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7878482ce6f10c4027034352ce73f5aaa4ce9cf" translate="yes" xml:space="preserve">
          <source>Called when the driver is unloaded. A distribution driver will never be unloaded, but we include this for completeness. To be able to clean up after oneself is always a good thing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9777a1b7d37a6943bc53bf03a6d0e91d50d751f" translate="yes" xml:space="preserve">
          <source>Called when the fun is registered, in the process that holds the fun. Here the crypto key fun can do any necessary initializations. If &lt;code&gt;{ok, NewCryptoKeyFun}&lt;/code&gt; is returned, &lt;code&gt;NewCryptoKeyFun&lt;/code&gt; is registered instead of &lt;code&gt;CryptoKeyFun&lt;/code&gt;. If &lt;code&gt;{error, Term}&lt;/code&gt; is returned, the registration is aborted and &lt;code&gt;crypto_key_fun/1&lt;/code&gt; also returns &lt;code&gt;{error, Term}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98ad7a8527ae38bbbd2d4e06002457415af632b3" translate="yes" xml:space="preserve">
          <source>Called when the key is needed for module &lt;code&gt;Module&lt;/code&gt; in the file named &lt;code&gt;Filename&lt;/code&gt;. &lt;code&gt;Mode&lt;/code&gt; is the type of crypto algorithm; currently, the only possible value is &lt;code&gt;des3_cbc&lt;/code&gt;. The call is to fail (raise an exception) if no key is available.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0dcbf03fb42831c6723cb1715f47765453867f67" translate="yes" xml:space="preserve">
          <source>Called when the port is about to be closed, and there is data in the driver queue that must be flushed before 'stop' can be called.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8919d79f584bde48131fa0a13624f5f0b5dd1e5e" translate="yes" xml:space="preserve">
          <source>Called when the port is closed, with &lt;code&gt;&lt;a href=&quot;erlang#port_close-1&quot;&gt;erlang:port_close/1&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;Port ! {self(), close}&lt;/code&gt;. Notice that terminating the port owner process also closes the port. If &lt;code&gt;drv_data&lt;/code&gt; is a pointer to memory allocated in &lt;code&gt;start&lt;/code&gt;, then &lt;code&gt;stop&lt;/code&gt; is the place to deallocate that memory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bce5d5b2decf756f58e8642c565207befb9d1e4c" translate="yes" xml:space="preserve">
          <source>Called when there is something to read from a socket.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb06eda8927a232da24c20e732e3e2949f2b101f" translate="yes" xml:space="preserve">
          <source>Called whenever the port is written to. If it is &lt;code&gt;NULL&lt;/code&gt;, the &lt;code&gt;output&lt;/code&gt; function is called instead. This function is faster than &lt;code&gt;output&lt;/code&gt;, as it takes an &lt;code&gt;ErlIOVec&lt;/code&gt; directly, which requires no copying of the data. The port is to be in binary mode, see &lt;code&gt;&lt;a href=&quot;erlang#open_port-2&quot;&gt;erlang:open_port/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c4da0ebceae11eff6b7919b2ddd46f27587b04d" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;&lt;a href=&quot;erlang#halt-1&quot;&gt;erlang:halt/1&lt;/a&gt;&lt;/code&gt; with a string argument still produces a crash dump. On Unix systems, sending an emulator process a &lt;code&gt;SIGUSR1&lt;/code&gt; signal also forces a crash dump.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="655a22092d77d88145d5c50ca50e242cddc91b3d" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;demonitor(MonitorRef, [flush])&lt;/code&gt; is equivalent to the following, but more efficient:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8abf86e315d47dada23e450fdd1a6d2f9ae320c2" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;erlang:system_time()&lt;/code&gt; is equivalent to &lt;code&gt;&lt;a href=&quot;#monotonic_time-0&quot;&gt;erlang:monotonic_time()&lt;/a&gt;&lt;/code&gt;&lt;code&gt;+&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;#time_offset-0&quot;&gt;erlang:time_offset()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b083a75a2460c0a8048c36cd9fefa43e466519e" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;erlang:system_time(Unit)&lt;/code&gt; is equivalent to &lt;code&gt;&lt;a href=&quot;#convert_time_unit-3&quot;&gt;erlang:convert_time_unit&lt;/a&gt;&lt;/code&gt;&lt;code&gt;(&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;#system_time-0&quot;&gt;erlang:system_time()&lt;/a&gt;&lt;/code&gt;&lt;code&gt;, native, Unit)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac8161866033e5fba00c9f967a358dd87e252b77" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;merl:print(Call)&lt;/code&gt; will then print the following code:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2cedca3701bb5e353b3d951a1078a1fe4f284c28" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;os:system_time(Unit)&lt;/code&gt; is equivalent to &lt;code&gt;erlang:convert_time_unit&lt;/code&gt;(&lt;code&gt;&lt;a href=&quot;#system_time-0&quot;&gt;os:system_time()&lt;/a&gt;&lt;/code&gt;&lt;code&gt;, native, Unit)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="afeabfe36eaf236b85f9317a022e3a32b2c67b0d" translate="yes" xml:space="preserve">
          <source>Calling and applying a fun does not involve any hash-table lookup. A fun contains an (indirect) pointer to the function that implements the fun.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90124b2b5c5e8b577f502d3a36088e606891a366" translate="yes" xml:space="preserve">
          <source>Calling or applying a fun (&lt;code&gt;Fun()&lt;/code&gt;, &lt;code&gt;apply(Fun, [])&lt;/code&gt;) is about &lt;strong&gt;three times&lt;/strong&gt; as expensive as calling a local function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4977f905b190f9bbe202e2e85576e00836e9734e" translate="yes" xml:space="preserve">
          <source>Calling the function with &lt;code&gt;{MonitorPid, Options}&lt;/code&gt; as argument is the same as calling &lt;code&gt;&lt;a href=&quot;#system_monitor-2&quot;&gt;erlang:system_monitor(MonitorPid,Options)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b42cc7ad99418c1a03de8a69add23747a547065" translate="yes" xml:space="preserve">
          <source>Calling this function will trigger the &quot;user&quot; trace probe user_trace_i4s4 in the dyntrace NIF module, sending a trace message containing all the integer()'s and string()'s provided, as well as any user tag set in the current process.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="444f79602e491b38e25cb8c13003f56f8345ff63" translate="yes" xml:space="preserve">
          <source>Calling this function will trigger the &quot;user&quot; trace probe user_trace_i4s4 in the dyntrace NIF module, sending a trace message containing the user tag and the integer or string parameter in the first integer/string field.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca84bd13b57ed20dc137036dea97bc867dd9acff" translate="yes" xml:space="preserve">
          <source>Calling this function will trigger the &quot;user&quot; trace probe user_trace_i4s4 in the dyntrace NIF module, sending a trace message containing the user tag and the integer() or string() parameters as the first fields of respective type. integer() parameters should be put before any string() parameters, as in &lt;code&gt;&lt;a href=&quot;#p-2&quot;&gt;p/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d6504b8ed29fe9b52bfa13411a0abbd154f8e3e" translate="yes" xml:space="preserve">
          <source>Calling this function will trigger the &quot;user&quot; trace probe user_trace_i4s4 in the dyntrace NIF module, sending a trace message containing the user tag and the integer() or string() parameters as the first fields of respective type. integer() parameters should be put before any string() parameters. I.e. &lt;code&gt;p(1,&quot;Hello&quot;)&lt;/code&gt; is ok, as is &lt;code&gt;p(1,1)&lt;/code&gt; and &lt;code&gt;p(&quot;Hello&quot;,&quot;Again&quot;)&lt;/code&gt;, but not &lt;code&gt;p(&quot;Hello&quot;,1)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba80ef3622f6d7266790c78fbbdd6b4544d6f3ea" translate="yes" xml:space="preserve">
          <source>Calling this function will trigger the &quot;user&quot; trace probe user_trace_i4s4 in the dyntrace NIF module, sending a trace message only containing the user tag and zeroes/empty strings in all other fields.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc31c095d153129fc853cf06c728a75bf3b46c60" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;&lt;a href=&quot;#resolve-3&quot;&gt;resolve/*&lt;/a&gt;&lt;/code&gt; with the same arguments and filters the result, so &lt;code&gt;Opts&lt;/code&gt; is described for those functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64e4f69ad9125f63ba8df8f7d7d250f3cecda4ae" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;F(K, V, AccIn)&lt;/code&gt; for every &lt;code&gt;K&lt;/code&gt; to value &lt;code&gt;V&lt;/code&gt; association in &lt;code&gt;MapOrIter&lt;/code&gt; in any order. Function &lt;code&gt;fun F/3&lt;/code&gt; must return a new accumulator, which is passed to the next successive call. This function returns the final value of the accumulator. The initial accumulator value &lt;code&gt;Init&lt;/code&gt; is returned if the map is empty.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4295c8a20ece7cf06d43d6ebf25e275c406c6e5f" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;Fun(Elem)&lt;/code&gt; for each element &lt;code&gt;Elem&lt;/code&gt; in &lt;code&gt;List&lt;/code&gt;. This function is used for its side effects and the evaluation order is defined to be the same as the order of the elements in the list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63f2bd2bc7b570ff8e3f588bc3a35e7f39bb021c" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;Fun(Elem)&lt;/code&gt; on successive elements &lt;code&gt;Elem&lt;/code&gt; of &lt;code&gt;List1&lt;/code&gt;. &lt;code&gt;Fun/1&lt;/code&gt; must return either a Boolean or a tuple &lt;code&gt;{true, Value}&lt;/code&gt;. The function returns the list of elements for which &lt;code&gt;Fun&lt;/code&gt; returns a new value, where a value of &lt;code&gt;true&lt;/code&gt; is synonymous with &lt;code&gt;{true, Elem}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50d89c32ea4d0c6ee1b26f9c66ad9e11c8879726" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;Fun(Elem, AccIn)&lt;/code&gt; on successive elements &lt;code&gt;A&lt;/code&gt; of &lt;code&gt;List&lt;/code&gt;, starting with &lt;code&gt;AccIn == Acc0&lt;/code&gt;. &lt;code&gt;Fun/2&lt;/code&gt; must return a new accumulator, which is passed to the next call. The function returns the final value of the accumulator. &lt;code&gt;Acc0&lt;/code&gt; is returned if the list is empty.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d14f785e84c0e45ac023a87056c299dcc94c604" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;Fun(Elem, AccIn)&lt;/code&gt; on successive elements of the cache, starting with &lt;code&gt;AccIn == Acc0&lt;/code&gt;. &lt;code&gt;Fun/2&lt;/code&gt; must return a new accumulator, which is passed to the next call. The function returns the final value of the accumulator. &lt;code&gt;Acc0&lt;/code&gt; is returned if the cache is empty.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d85b7bf8f7b8acf4c9a5d164bbe2b412bc74ce98" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;Fun(FileInArchive, GetInfo, GetBin, AccIn)&lt;/code&gt; on successive files in the &lt;code&gt;Archive&lt;/code&gt;, starting with &lt;code&gt;AccIn == Acc0&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ecb1b12376680c06a8dcd6a14c87f88b97c0f362" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;Fun&lt;/code&gt; on successive keys and values of &lt;code&gt;Orddict1&lt;/code&gt; tvo return a new value for each key.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41cc957320ee93c3d6a8d2c0cf887c390c051f0c" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;Fun&lt;/code&gt; on successive keys and values of &lt;code&gt;Orddict&lt;/code&gt; together with an extra argument &lt;code&gt;Acc&lt;/code&gt; (short for accumulator). &lt;code&gt;Fun&lt;/code&gt; must return a new accumulator that is passed to the next call. &lt;code&gt;Acc0&lt;/code&gt; is returned if the list is empty.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db2c15c0e80df0b70d2a4c08c9328f07d292a334" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;Fun&lt;/code&gt; on successive keys and values of dictionary &lt;code&gt;Dict1&lt;/code&gt; to return a new value for each key. The evaluation order is undefined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51e98c878f8461c82b19b807000534c1ee895d35" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;Fun&lt;/code&gt; on successive keys and values of dictionary &lt;code&gt;Dict&lt;/code&gt; together with an extra argument &lt;code&gt;Acc&lt;/code&gt; (short for accumulator). &lt;code&gt;Fun&lt;/code&gt; must return a new accumulator that is passed to the next call. &lt;code&gt;Acc0&lt;/code&gt; is returned if the dictionary is empty. The evaluation order is undefined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e38b9bc9aa02fa070ce4650030edfd32a81b7dd" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;Function&lt;/code&gt; on successive answers to the query handle together with an extra argument &lt;code&gt;AccIn&lt;/code&gt;. The query handle and the function are evaluated in the calling process. &lt;code&gt;Function&lt;/code&gt; must return a new accumulator, which is passed to the next call. &lt;code&gt;Acc0&lt;/code&gt; is returned if there are no answers to the query handle.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="411261c708a55893631cad145cf652a3f25bc6dd" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;Function&lt;/code&gt; on successive elements of table &lt;code&gt;Name&lt;/code&gt; together with an extra argument &lt;code&gt;AccIn&lt;/code&gt;. The table elements are traversed in unspecified order. &lt;code&gt;Function&lt;/code&gt; must return a new accumulator that is passed to the next call. &lt;code&gt;Acc0&lt;/code&gt; is returned if the table is empty.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4d0f89deb9513a8ea8d66e61b19ec50cb6a197f" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;erlang:apply(Func, Args)&lt;/code&gt; surrounded by &lt;code&gt;trace([start, ...])&lt;/code&gt; and &lt;code&gt;trace(stop)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8e905cfa5d08f37d1d656135714c1381b168281" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;mnesia:activity(AccessContext, Fun, Args, AccessMod)&lt;/code&gt;, where &lt;code&gt;AccessMod&lt;/code&gt; is the default access callback module obtained by &lt;code&gt;mnesia:system_info(access_module)&lt;/code&gt;. &lt;code&gt;Args&lt;/code&gt; defaults to &lt;code&gt;[]&lt;/code&gt; (empty list).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ba5ad987837e04f29a6e17ab4165c3bf8a13ef5" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;mnesia:async_dirty(Fun, Args)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ffcbed2136c4dbb9cb540ca3e3bb945d48a84489" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;mnesia:delete(Tab, Key, write)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6cd2ad960a91e2c7b84aad8b8cab2b4af89af1d4" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;mnesia:delete_object(Tab, Record, write)&lt;/code&gt;, where &lt;code&gt;Tab&lt;/code&gt; is &lt;code&gt;element(1, Record)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1619836284281d3b4ace7f8138860d37a317d20" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;mnesia:dirty_delete(Tab, Key)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7eff8e0d0f21895a3712d8b82ab68aad9ff93c2" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;mnesia:dirty_delete_object(Tab, Record)&lt;/code&gt;, where &lt;code&gt;Tab&lt;/code&gt; is &lt;code&gt;element(1, Record)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b968f64643fdd3ef4196ca7f2353074d34a25592" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;mnesia:dirty_match_object(Tab, Pattern)&lt;/code&gt;, where &lt;code&gt;Tab&lt;/code&gt; is &lt;code&gt;element(1, Pattern)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc9bba8191f80d74baf71dc1c6ce5482c73891a5" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;mnesia:dirty_read(Tab, Key)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="672698b739738396e1aaa279f1425416fa4ed4d3" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;mnesia:dirty_update_counter(Tab, Key, Incr)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f15de5c4989490ba445d84120b63ae4fef3a10da" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;mnesia:dirty_write(Tab, Record)&lt;/code&gt;, where &lt;code&gt;Tab&lt;/code&gt; is &lt;code&gt;element(1, Record)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a49f85d237c7a52c5025bd7a45bcefecee838aed" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;mnesia:ets(Fun, Args)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1e1b27f2b3d32c30f1a9af2546f7ff28be30d84" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;mnesia:install_fallback(Opaque, Args)&lt;/code&gt;, where &lt;code&gt;Args&lt;/code&gt; is &lt;code&gt;[{scope, global}, {module, BackupMod}]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="adefbd4d29b6f99f9c5284fcea99a93af40e2354" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;mnesia:install_fallback(Opaque, Args)&lt;/code&gt;, where &lt;code&gt;Args&lt;/code&gt; is &lt;code&gt;[{scope, global}]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6371048f46424da76665133d09722d29e17eb95d" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;mnesia:match_object(Tab, Pattern, read)&lt;/code&gt;, where &lt;code&gt;Tab&lt;/code&gt; is &lt;code&gt;element(1, Pattern)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="506bd136b0f38c6b5c4e9aba7994479cbf8607c2" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;mnesia:sync_dirty(Fun, Args)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4768e4194eaa19668e98e8297432714da38f80fe" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;mnesia:sync_transaction(Fun, Args, Retries)&lt;/code&gt;. Notice that the result from &lt;code&gt;Fun&lt;/code&gt; is returned if the transaction is successful (atomic), otherwise the function exits with an abort reason.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4238a5e661c7a2d85c9a77b9854e4b9f7ca29a9" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;mnesia:transaction(Fun, Args, Retries)&lt;/code&gt;. Notice that the result from &lt;code&gt;Fun&lt;/code&gt; is returned if the transaction is successful (atomic), otherwise the function exits with an abort reason.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4bef8126b535186f1c6f440c4f89eb4f6b6acd97" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;mnesia:transform_table(Tab, Fun, NewAttributeList, RecName)&lt;/code&gt;, where &lt;code&gt;RecName&lt;/code&gt; is &lt;code&gt;mnesia:table_info(Tab, record_name)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f8dac520c4ed465440262ceedf36f6b5ee392b4" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;names(Host)&lt;/code&gt; for all hosts that are specified in the Erlang host file &lt;code&gt;.hosts.erlang&lt;/code&gt;, collects the replies, and then evaluates &lt;code&gt;ping(Node)&lt;/code&gt; on all those nodes. Returns the list of all nodes that are successfully pinged.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f89caf1a58d70de4bc1545d4d2c63f722e1134d" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;pseudo(Master, ServerList)&lt;/code&gt;. If you want to start a node from the command line and set up a number of pseudo servers, an Erlang runtime system can be started as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2fd282143317f0c95d38258aa5488afaefacb19b" translate="yes" xml:space="preserve">
          <source>Calls a fun, passing the elements in &lt;code&gt;Args&lt;/code&gt; as arguments.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc1df90caee2a0f744537886d1a4a5d884e3a1f0" translate="yes" xml:space="preserve">
          <source>Calls between functions are either  &lt;strong id=&quot;local_call&quot;&gt;local calls&lt;/strong&gt; like &lt;code&gt;f()&lt;/code&gt;, or  &lt;strong id=&quot;external_call&quot;&gt;external calls&lt;/strong&gt; like &lt;code&gt;m:f()&lt;/code&gt;.  &lt;strong id=&quot;module_data&quot;&gt;Module data&lt;/strong&gt;, which are extracted from BEAM files, include local functions, exported functions, local calls and external calls. By default, calls to built-in functions (BIF) are ignored, but if the option &lt;code&gt;builtins&lt;/code&gt;, accepted by some of this module's functions, is set to &lt;code&gt;true&lt;/code&gt;, calls to BIFs are included as well. It is the analyzing OTP version that decides what functions are BIFs. Functional objects are assumed to be called where they are created (and nowhere else).  &lt;strong id=&quot;unresolved_call&quot;&gt;Unresolved calls&lt;/strong&gt; are calls to &lt;code&gt;apply&lt;/code&gt; or &lt;code&gt;spawn&lt;/code&gt; with variable module, variable function, or variable arguments. Examples are &lt;code&gt;M:F(a)&lt;/code&gt;, &lt;code&gt;apply(M,&amp;nbsp;f,&amp;nbsp;[a])&lt;/code&gt;, and &lt;code&gt;spawn(m,&amp;nbsp;f(),&amp;nbsp;Args)&lt;/code&gt;. Unresolved calls are represented by calls where variable modules have been replaced with the atom &lt;code&gt;'$M_EXPR'&lt;/code&gt;, variable functions have been replaced with the atom &lt;code&gt;'$F_EXPR'&lt;/code&gt;, and variable number of arguments have been replaced with the number &lt;code&gt;-1&lt;/code&gt;. The above mentioned examples are represented by calls to &lt;code&gt;'$M_EXPR':'$F_EXPR'/1&lt;/code&gt;, &lt;code&gt;'$M_EXPR':f/1&lt;/code&gt;, and &lt;code&gt;m:'$F_EXPR'/-1&lt;/code&gt;. The unresolved calls are a subset of the external calls.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e175a0645ad31688c1ad90ebe51d1f98332790c8" translate="yes" xml:space="preserve">
          <source>Calls between modules, applications and releases are also directed graphs. The  &lt;strong id=&quot;type&quot;&gt;types&lt;/strong&gt; of the vertices and edges of these graphs are (ranging from the most special to the most general): &lt;code&gt;Fun&lt;/code&gt; for functions; &lt;code&gt;Mod&lt;/code&gt; for modules; &lt;code&gt;App&lt;/code&gt; for applications; and &lt;code&gt;Rel&lt;/code&gt; for releases. The following paragraphs will describe the different constructs of the language used for selecting and analyzing parts of the graphs, beginning with the  &lt;strong id=&quot;constants&quot;&gt;constants&lt;/strong&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be43177e95bbd471940bc32f6f4691d58dabae5d" translate="yes" xml:space="preserve">
          <source>Calls function &lt;code&gt;mnesia:read(Tab, Key, read)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1ab266a520f0fa15f418f121757a95a2f87b8a3" translate="yes" xml:space="preserve">
          <source>Calls quickcheck and returns the result in a form suitable for &lt;code&gt;Common Test&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c7c891f9853016ddc130d88be49b034108f4922" translate="yes" xml:space="preserve">
          <source>Calls the &lt;code&gt;Fun&lt;/code&gt; in a context that is not protected by a transaction. The Mnesia function calls performed in the &lt;code&gt;Fun&lt;/code&gt; are mapped to the corresponding dirty functions. It is performed in almost the same context as &lt;code&gt;mnesia:async_dirty/1,2&lt;/code&gt;. The difference is that the operations are performed synchronously. The caller waits for the updates to be performed on all active replicas before the &lt;code&gt;Fun&lt;/code&gt; returns. For details, see &lt;code&gt;mnesia:activity/4&lt;/code&gt; and the User's Guide.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f3ec8be69b09a2c810b010167a3f606775918ce" translate="yes" xml:space="preserve">
          <source>Calls the &lt;code&gt;Fun&lt;/code&gt; in a context that is not protected by a transaction. The Mnesia function calls performed in the &lt;code&gt;Fun&lt;/code&gt; are mapped to the corresponding dirty functions. This still involves logging, replication, and subscriptions, but there is no locking, local transaction storage, or commit protocols involved. Checkpoint retainers and indexes are updated, but they are updated dirty. As for normal &lt;code&gt;mnesia:dirty_*&lt;/code&gt; operations, the operations are performed semi-asynchronously. For details, see &lt;code&gt;mnesia:activity/4&lt;/code&gt; and the User's Guide.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d819d67bdd8cdeb2caeeb18f61988b23312e64a2" translate="yes" xml:space="preserve">
          <source>Calls the &lt;code&gt;Fun&lt;/code&gt; in a raw context that is not protected by a transaction. The Mnesia function call is performed in the &lt;code&gt;Fun&lt;/code&gt; and performed directly on the local ETS tables on the assumption that the local storage type is &lt;code&gt;ram_copies&lt;/code&gt; and the tables are not replicated to other nodes. Subscriptions are not triggered and checkpoints are not updated, but it is extremely fast. This function can also be applied to &lt;code&gt;disc_copies&lt;/code&gt; tables if all operations are read only. For details, see &lt;code&gt;mnesia:activity/4&lt;/code&gt; and the User's Guide.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8a784dd04ba58d02965f17a28a416dac496f4c6" translate="yes" xml:space="preserve">
          <source>Calls the function &lt;code&gt;mnesia:delete(Tab, Key, sticky_write)&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ecca9949a5635aaf8c27410eea7636e30e459fb0" translate="yes" xml:space="preserve">
          <source>Calls the function &lt;code&gt;mnesia:delete_object(Tab, Record, sticky_write)&lt;/code&gt;, where &lt;code&gt;Tab&lt;/code&gt; is &lt;code&gt;element(1, Record)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="949e11ed9c4c541b273d5f803d7f14e93decf845" translate="yes" xml:space="preserve">
          <source>Calls the function &lt;code&gt;mnesia:lock({table, Tab}, read)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a8c4bc10158fea84b8bc4d0f51afdb0e35c5827" translate="yes" xml:space="preserve">
          <source>Calls the function &lt;code&gt;mnesia:lock({table, Tab}, write)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cddc0b283837cd9cf6bfc5ffbfc0d1ab69ceebc5" translate="yes" xml:space="preserve">
          <source>Calls the function &lt;code&gt;mnesia:read(Tab, Key, write)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55f266ac7f0a7fd8339f6a382397f015c2d00cb9" translate="yes" xml:space="preserve">
          <source>Calls the function &lt;code&gt;mnesia:uninstall_fallback([{scope, global}])&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a04316f127b21a90e451cb0328b531e879c5c8a6" translate="yes" xml:space="preserve">
          <source>Calls the function &lt;code&gt;mnesia:write(Tab, Record, sticky_write)&lt;/code&gt;, where &lt;code&gt;Tab&lt;/code&gt; is &lt;code&gt;element(1, Record)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6619bcc0446814c6bc36959f774872812e839577" translate="yes" xml:space="preserve">
          <source>Calls the function &lt;code&gt;mnesia:write(Tab, Record, write)&lt;/code&gt;, where &lt;code&gt;Tab&lt;/code&gt; is &lt;code&gt;element(1, Record)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b9dce33ce75c3e0cd20ec5b024a2864ee93e989" translate="yes" xml:space="preserve">
          <source>Calls the standard &lt;code&gt;free()&lt;/code&gt; function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b90d8d44b261c3e05c2a69f75c7d0d01e3b518f9" translate="yes" xml:space="preserve">
          <source>Calls the standard &lt;code&gt;malloc()&lt;/code&gt; function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f325b7e41b1fdb81e7bc7cb001482dfdf57640d" translate="yes" xml:space="preserve">
          <source>Calls to &lt;code&gt;&lt;a href=&quot;error_logger#error_report-1&quot;&gt;error_logger:error_report/1,2&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;error_logger#error_msg-1&quot;&gt;error_logger:error_msg/1,2&lt;/a&gt;&lt;/code&gt;, and corresponding functions for warning and info messages, are all forwarded to Logger as calls to &lt;code&gt;&lt;a href=&quot;logger#log-3&quot;&gt;logger:log(Level,Report,Metadata)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="681ce3661a9a40c6caccc2250ea6929229c7aac3" translate="yes" xml:space="preserve">
          <source>Calls to functions defined by evaluating fun expressions &lt;code&gt;&quot;fun ... end&quot;&lt;/code&gt; are also hidden from non-local function handlers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a78c70fc8985fb6668305436210f739782826d6b" translate="yes" xml:space="preserve">
          <source>Calls to local or external functions (&lt;code&gt;foo()&lt;/code&gt;, &lt;code&gt;m:foo()&lt;/code&gt;) are the fastest calls.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1368b924e595a7f64353a1c8704cd02aa9b58af" translate="yes" xml:space="preserve">
          <source>Calls to the BIFs specified in table &lt;code&gt;Type Test BIFs&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5e2dbf1a74a301e38682ebfa666c1939e25bd23" translate="yes" xml:space="preserve">
          <source>Can another internal data representation be used to make things more efficient?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce2b0460aad57730836f17162000a27e6d1988d5" translate="yes" xml:space="preserve">
          <source>Can any redundant tests be removed?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14d70599293b8e413ef952c38a0440843056f84c" translate="yes" xml:space="preserve">
          <source>Can any test be run less often if the order of tests is changed?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1dbbd23b5878e1a733c169db6ec8393bc170cde2" translate="yes" xml:space="preserve">
          <source>Can be a back reference, or another way of writing a tab</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ff3af864aead7cd729fa897ed19cd40dd3bea5a" translate="yes" xml:space="preserve">
          <source>Can be a back reference, otherwise the character with octal code 113</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca748588186d1a7e973cd887d71235755974030e" translate="yes" xml:space="preserve">
          <source>Can be a back reference, otherwise value 255 (decimal)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d7475380f4be07d179c7231bb2dd90fbd5279b2" translate="yes" xml:space="preserve">
          <source>Can be called by a process to unregister a specified node from EPMD on the local host. This is, however, usually not allowed, unless EPMD was started with flag &lt;code&gt;-relaxed_command_check&lt;/code&gt;, which it normally is not.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f44b4080b46d42a3270b0b18ff48ce34cd9d5ec2" translate="yes" xml:space="preserve">
          <source>Can be implemented as:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="435b9419e03f7e525befa539fe46b7b2779ce303" translate="yes" xml:space="preserve">
          <source>Can be one of the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18e0b766363b36ea716659f6503b3ddde9e7ec85" translate="yes" xml:space="preserve">
          <source>Can be removed in a future release of the halfword emulator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a329dd98b578890314d90cd00ae46894da7e6ba8" translate="yes" xml:space="preserve">
          <source>Can be set to &lt;code&gt;strict&lt;/code&gt; or &lt;code&gt;relaxed&lt;/code&gt;. It controls how each directory in the code path is to be interpreted:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61d2fdff92dff8eebb470df37755eb8b633955c3" translate="yes" xml:space="preserve">
          <source>Can be set to a comma-separated list of IP addresses, in which case the &lt;code&gt;&lt;a href=&quot;epmd&quot;&gt;epmd&lt;/a&gt;&lt;/code&gt; daemon listens only on the specified address(es) and on the loopback address (which is implicitly added to the list if it has not been specified).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d6e47517b6960079a15e323f8e14b95671cfd59" translate="yes" xml:space="preserve">
          <source>Can be set to a comma-separated list of IP addresses, in which case the &lt;code&gt;epmd&lt;/code&gt; daemon will listen only on the specified address(es) and on the loopback address (which is implicitly added to the list if it has not been specified). The default behavior is to listen on all available IP addresses.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32027351ef478fb666878cfb7ea809e9ec8104be" translate="yes" xml:space="preserve">
          <source>Can be used as a name resolving function for &lt;code&gt;&lt;a href=&quot;#register_name-3&quot;&gt;register_name/3&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#re_register_name-3&quot;&gt;re_register_name/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a41238ba1ffe4cd44c8669bf5362c16badbd6e66" translate="yes" xml:space="preserve">
          <source>Can be used by a process that initiates a debug structure from a list of options. The values of argument &lt;code&gt;Opt&lt;/code&gt; are the same as for the corresponding functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e44e4550227750d3133233de3b9ab784df8d5876" translate="yes" xml:space="preserve">
          <source>Can be used if interactive performance is not to be affected by the emulator process.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4554428a28a365553523e827200f0a4801491275" translate="yes" xml:space="preserve">
          <source>Can be used if the size of the trace logs must be limited. Default values are &lt;code&gt;Size=128*1024&lt;/code&gt; and &lt;code&gt;Count=8&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52514699bbc5fce906ba4874a907b457ea6b2ad1" translate="yes" xml:space="preserve">
          <source>Can be used if two Erlang nodes are to reside on one dedicated system and one is to have precedence over the other.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1cfd6096580c6f0fc105f7dae283a846f824ac79" translate="yes" xml:space="preserve">
          <source>Can be used to determine which crypto algorithms that are supported by the underlying OpenSSL library</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ac2e838e28c4e79b7b0173c19b32b3299e09f77" translate="yes" xml:space="preserve">
          <source>Can be used to determine which named elliptic curves are supported.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0139eb1de3d0a9614c9b210a184d4b0320912f6e" translate="yes" xml:space="preserve">
          <source>Can be used to make the client act as an &lt;code&gt;HTTP/1.0&lt;/code&gt; or &lt;code&gt;HTTP/0.9&lt;/code&gt; client. By default this is an &lt;code&gt;HTTP/1.1&lt;/code&gt; client. When using &lt;code&gt;HTTP/1.0&lt;/code&gt; persistent connections are not used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9de6dfb4b293a374f8bbe2fd001451aff895674" translate="yes" xml:space="preserve">
          <source>Can be used to retrieve information about the C-node. These values are initially set with &lt;code&gt;ei_connect_init()&lt;/code&gt; or &lt;code&gt;ei_connect_xinit()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6b6b3b3a5a2150a389c6b25e1e84aa23960992c" translate="yes" xml:space="preserve">
          <source>Can be used when interacting with a server called &lt;code&gt;Name&lt;/code&gt; on node &lt;code&gt;Node&lt;/code&gt;. It is assumed that the server receives messages in the format &lt;code&gt;{From, Msg}&lt;/code&gt; and replies using &lt;code&gt;From ! {ReplyWrapper, Node, Reply}&lt;/code&gt;. This function makes such a server call and ensures that the entire call is packed into an atomic transaction, which either succeeds or fails. It never hangs, unless the server itself hangs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb8693797500f3627529857787e0f8552cc7d7b2" translate="yes" xml:space="preserve">
          <source>Can be used when interacting with servers called &lt;code&gt;Name&lt;/code&gt; on the specified nodes. It is assumed that the servers receive messages in the format &lt;code&gt;{From, Msg}&lt;/code&gt; and reply using &lt;code&gt;From ! {Name, Node, Reply}&lt;/code&gt;, where &lt;code&gt;Node&lt;/code&gt; is the name of the node where the server is located. The function returns &lt;code&gt;{Replies, BadNodes}&lt;/code&gt;, where &lt;code&gt;Replies&lt;/code&gt; is a list of all &lt;code&gt;Reply&lt;/code&gt; values, and &lt;code&gt;BadNodes&lt;/code&gt; is one of the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="413a11e06a5cc3367aeaca579508da6cce5c360b" translate="yes" xml:space="preserve">
          <source>Can be used with &lt;code&gt;chunk/2,3&lt;/code&gt; and &lt;code&gt;bchunk/2,3&lt;/code&gt; to search through an internally formatted wrap log. It takes as argument a continuation as returned by &lt;code&gt;chunk/2,3&lt;/code&gt;, &lt;code&gt;bchunk/2,3&lt;/code&gt;, or &lt;code&gt;chunk_step/3&lt;/code&gt;, and steps forward (or backward) &lt;code&gt;Step&lt;/code&gt; files in the wrap log. The continuation returned, points to the first log item in the new current file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54b689659783bb6b4ac1454db70e48394a638a38" translate="yes" xml:space="preserve">
          <source>Can contain the port number &lt;code&gt;epmd&lt;/code&gt; will use. The default port will work fine in most cases. A different port can be specified to allow several instances of &lt;code&gt;epmd&lt;/code&gt;, representing independent clusters of nodes, to co-exist on the same host. All nodes in a cluster must use the same &lt;code&gt;epmd&lt;/code&gt; port number.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1d4e8ff3c787597c2cdf851d9445ac7a46d3eec" translate="yes" xml:space="preserve">
          <source>Can contain the port number to use when communicating with &lt;code&gt;&lt;a href=&quot;epmd&quot;&gt;epmd&lt;/a&gt;&lt;/code&gt;. The default port works fine in most cases. A different port can be specified to allow nodes of independent clusters to co-exist on the same host. All nodes in a cluster must use the same &lt;code&gt;epmd&lt;/code&gt; port number.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="763e2024cfbffcaa35312ea836b3ce5e41e09735" translate="yes" xml:space="preserve">
          <source>Can either be the originals passed into the calling NIF, or can be values created by the calling NIF.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1762b945a07d7a0928b055cdfb86c61f5e180a18" translate="yes" xml:space="preserve">
          <source>Can enable trace on all functions or only exported functions on chosen modules.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6d98498dcb02bc77d5362ec71948bf4dcb80403" translate="yes" xml:space="preserve">
          <source>Can only be used to check the local time of day if the time-zone information of the underlying OS is properly configured.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b665cc5f87b4b96a8b89bb4858d5c6ded666e00" translate="yes" xml:space="preserve">
          <source>Can only be used with TLS/DTLS connections; &lt;code&gt;{error, undefined}&lt;/code&gt; is returned for SSLv3 connections.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65065adca48747308c795b0ca8e2fa3439ca68c0" translate="yes" xml:space="preserve">
          <source>Canadian_Aboriginal</source>
          <target state="translated">Canadian_Aboriginal</target>
        </trans-unit>
        <trans-unit id="0ce7f9b48109071ca45af63e2c7f4cded74fe895" translate="yes" xml:space="preserve">
          <source>Cancel a previous asynchronous request.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c0d517ae93b9275421781af37452eec4bb2fa47" translate="yes" xml:space="preserve">
          <source>Cancel a previous request to be notified of SNMP manager start.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9a0f30cfff3cf2f7919e74d440e32f436d7292c" translate="yes" xml:space="preserve">
          <source>Cancel all outstanding messages for this connection</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e83179d769a2b44650615f9d44ca78b37a04604" translate="yes" xml:space="preserve">
          <source>Cancel the handshake with a fatal &lt;code&gt;USER_CANCELED&lt;/code&gt; alert.</source>
          <target state="new"/>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
