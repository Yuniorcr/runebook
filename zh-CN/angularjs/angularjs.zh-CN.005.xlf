<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="angularjs">
    <body>
      <group id="angularjs">
        <trans-unit id="3452bf57ac43f5bb1c78e3470aa773a04375cfd7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ngModel&lt;/code&gt; directive binds an &lt;code&gt;input&lt;/code&gt;,&lt;code&gt;select&lt;/code&gt;, &lt;code&gt;textarea&lt;/code&gt; (or custom form control) to a property on the scope using &lt;a href=&quot;type/ngmodel.ngmodelcontroller&quot;&gt;NgModelController&lt;/a&gt;, which is created and exposed by this directive.</source>
          <target state="translated">所述 &lt;code&gt;ngModel&lt;/code&gt; 指令结合的 &lt;code&gt;input&lt;/code&gt; ， &lt;code&gt;select&lt;/code&gt; ， &lt;code&gt;textarea&lt;/code&gt; （或定制表单控件），以使用所述范围属性&lt;a href=&quot;type/ngmodel.ngmodelcontroller&quot;&gt;NgModelController&lt;/a&gt;，其中创建和由该指令露出。</target>
        </trans-unit>
        <trans-unit id="b487d1121c7dae27fef086afefdf78374bec811f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ngModelOptions&lt;/code&gt; expression is only evaluated once when the directive is linked; it is not watched for changes. However, it is possible to override the options on a single &lt;a href=&quot;../type/ngmodel.ngmodelcontroller&quot;&gt;&lt;code&gt;ngModel.NgModelController&lt;/code&gt;&lt;/a&gt; instance with &lt;a href=&quot;../type/ngmodel.ngmodelcontroller#%24overrideModelOptions.html&quot;&gt;&lt;code&gt;NgModelController#$overrideModelOptions()&lt;/code&gt;&lt;/a&gt;. See also the example for &lt;a href=&quot;ngmodeloptions#default-events-extra-triggers-and-catch-all-debounce-values.html&quot;&gt;Default events, extra triggers, and catch-all debounce values&lt;/a&gt;.</source>
          <target state="translated">链接指令后， &lt;code&gt;ngModelOptions&lt;/code&gt; 表达式仅计算一次；它不会监视更改。但是，可以使用&lt;a href=&quot;../type/ngmodel.ngmodelcontroller#%24overrideModelOptions.html&quot;&gt; &lt;code&gt;NgModelController#$overrideModelOptions()&lt;/code&gt; &lt;/a&gt;单个&lt;a href=&quot;../type/ngmodel.ngmodelcontroller&quot;&gt; &lt;code&gt;ngModel.NgModelController&lt;/code&gt; &lt;/a&gt;实例上的选项。另请参见示例，了解&lt;a href=&quot;ngmodeloptions#default-events-extra-triggers-and-catch-all-debounce-values.html&quot;&gt;默认事件，额外的触发器和全部反跳值&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="dd5b88d74d5a86e48055f8cee80df84b803c4347" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ngModelOptions&lt;/code&gt; settings are found by evaluating the value of the attribute directive as an AngularJS expression. This expression should evaluate to an object, whose properties contain the settings. For example: &lt;code&gt;&amp;lt;div ng-model-options=&quot;{ debounce: 100 }&quot;&lt;/code&gt;.</source>
          <target state="translated">的 &lt;code&gt;ngModelOptions&lt;/code&gt; 设置由评估属性指令作为AngularJS表达式的值找到。该表达式应求值为一个对象，其属性包含设置。例如： &lt;code&gt;&amp;lt;div ng-model-options=&quot;{ debounce: 100 }&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e4a18f3d8624d933a72990e8d9aace68d9a5fa17" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ngNonBindable&lt;/code&gt; directive tells AngularJS not to compile or bind the contents of the current DOM element, including directives on the element itself that have a lower priority than &lt;code&gt;ngNonBindable&lt;/code&gt;. This is useful if the element contains what appears to be AngularJS directives and bindings but which should be ignored by AngularJS. This could be the case if you have a site that displays snippets of code, for instance.</source>
          <target state="translated">该 &lt;code&gt;ngNonBindable&lt;/code&gt; 指令告诉AngularJS不编译或绑定当前的DOM元素的内容，其中包括具有优先级低于元素本身的指令 &lt;code&gt;ngNonBindable&lt;/code&gt; 。如果元素包含看似AngularJS指令和绑定但AngularJS应该忽略的元素，则这很有用。例如，如果您有一个显示代码片段的站点，则可能是这种情况。</target>
        </trans-unit>
        <trans-unit id="18a8b01c2ac198af1bf17bd98c83cf041280c3cf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ngOn&lt;/code&gt; directive adds an event listener to a DOM element via &lt;a href=&quot;../function/angular.element&quot;&gt;angular.element().on()&lt;/a&gt;, and evaluates an expression when the event is fired. &lt;code&gt;ngOn&lt;/code&gt; allows adding listeners for arbitrary events by including the event name in the attribute, e.g. &lt;code&gt;ng-on-drop=&quot;onDrop()&quot;&lt;/code&gt; executes the 'onDrop()' expression when the &lt;code&gt;drop&lt;/code&gt; event is fired.</source>
          <target state="translated">该 &lt;code&gt;ngOn&lt;/code&gt; 指令通过添加一个事件侦听到DOM元素&lt;a href=&quot;../function/angular.element&quot;&gt;angular.element（）。在（） &lt;/a&gt;，并且当事件被触发计算表达式。 &lt;code&gt;ngOn&lt;/code&gt; 允许通过在属性中包含事件名称来添加任意事件的侦听器，例如 &lt;code&gt;ng-on-drop=&quot;onDrop()&quot;&lt;/code&gt; 触发 &lt;code&gt;drop&lt;/code&gt; 事件时，ng-on-drop =&amp;ldquo; onDrop（）&amp;rdquo;执行'onDrop（）'表达式。</target>
        </trans-unit>
        <trans-unit id="2138d9397e0192f72c874be961465bd1c28d35a6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ngOn&lt;/code&gt; directive adds an event listener to a DOM element via &lt;a href=&quot;function/angular.element&quot;&gt;angular.element().on()&lt;/a&gt;, and evaluates an expression when the event is fired. &lt;code&gt;ngOn&lt;/code&gt; allows adding listeners for arbitrary events by including the event name in the attribute, e.g. &lt;code&gt;ng-on-drop=&quot;onDrop()&quot;&lt;/code&gt; executes the 'onDrop()' expression when the &lt;code&gt;drop&lt;/code&gt; event is fired.</source>
          <target state="translated">该 &lt;code&gt;ngOn&lt;/code&gt; 指令通过添加一个事件侦听到DOM元素&lt;a href=&quot;function/angular.element&quot;&gt;angular.element（）。在（） &lt;/a&gt;，并且当事件被触发计算表达式。 &lt;code&gt;ngOn&lt;/code&gt; 允许通过在属性中包含事件名称来添加任意事件的侦听器，例如 &lt;code&gt;ng-on-drop=&quot;onDrop()&quot;&lt;/code&gt; 触发 &lt;code&gt;drop&lt;/code&gt; 事件时，ng-on-drop =&amp;ldquo; onDrop（）&amp;rdquo;执行'onDrop（）'表达式。</target>
        </trans-unit>
        <trans-unit id="3a5a3a5904b2e8cda5702d2eb4603a6e9e1ab0ca" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ngOptions&lt;/code&gt; attribute can be used to dynamically generate a list of &lt;code&gt;&amp;lt;option&amp;gt;&lt;/code&gt; elements for the &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt; element using the array or object obtained by evaluating the &lt;code&gt;ngOptions&lt;/code&gt; comprehension expression.</source>
          <target state="translated">所述 &lt;code&gt;ngOptions&lt;/code&gt; 属性可以被用于动态地生成的列表 &lt;code&gt;&amp;lt;option&amp;gt;&lt;/code&gt; 为元素 &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt; 使用通过评估所获得的数组或对象元素 &lt;code&gt;ngOptions&lt;/code&gt; 理解表达。</target>
        </trans-unit>
        <trans-unit id="edcab80c917b627233174b158849e232c488cd89" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ngParseExt&lt;/code&gt; module provides functionality to allow Unicode characters in identifiers inside AngularJS expressions.</source>
          <target state="translated">所述 &lt;code&gt;ngParseExt&lt;/code&gt; 模块提供的功能，以允许在内部AngularJS表达式标识符Unicode字符。</target>
        </trans-unit>
        <trans-unit id="09d3a0b1ee99482f4b3b7b520c3b0c94485099f1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ngPattern&lt;/code&gt; attribute must be an expression, while the &lt;code&gt;pattern&lt;/code&gt; value must be interpolated.</source>
          <target state="translated">所述 &lt;code&gt;ngPattern&lt;/code&gt; 属性必须是一个表达式，而 &lt;code&gt;pattern&lt;/code&gt; 值必须被内插。</target>
        </trans-unit>
        <trans-unit id="271ae01d79e2590ed7016379f17a5f47d6f0272e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ngProp&lt;/code&gt; directive binds an expression to a DOM element property. &lt;code&gt;ngProp&lt;/code&gt; allows writing to arbitrary properties by including the property name in the attribute, e.g. &lt;code&gt;ng-prop-value=&quot;'my value'&quot;&lt;/code&gt; binds 'my value' to the &lt;code&gt;value&lt;/code&gt; property.</source>
          <target state="translated">所述 &lt;code&gt;ngProp&lt;/code&gt; 指令结合到DOM元素属性的表达式。 &lt;code&gt;ngProp&lt;/code&gt; 允许通过在属性中包含属性名称来写入任意属性，例如 &lt;code&gt;ng-prop-value=&quot;'my value'&quot;&lt;/code&gt; 将'my value'绑定到 &lt;code&gt;value&lt;/code&gt; 属性。</target>
        </trans-unit>
        <trans-unit id="56078d890909a913d837393b28aca4870aaa743e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ngRef&lt;/code&gt; attribute tells AngularJS to assign the controller of a component (or a directive) to the given property in the current scope. It is also possible to add the jqlite-wrapped DOM element to the scope.</source>
          <target state="translated">所述 &lt;code&gt;ngRef&lt;/code&gt; 属性告诉AngularJS到组件的控制器（或指令）分配给在当前范围内的给定属性。也可以将jqlite包裹的DOM元素添加到范围中。</target>
        </trans-unit>
        <trans-unit id="6ff4989bbff6fa7c231c2f0eb3505b944b90b0e8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ngRepeat&lt;/code&gt; directive instantiates a template once per item from a collection. Each template instance gets its own scope, where the given loop variable is set to the current collection item, and &lt;code&gt;$index&lt;/code&gt; is set to the item index or key.</source>
          <target state="translated">该 &lt;code&gt;ngRepeat&lt;/code&gt; 指令实例从集合中每个项目一次的模板。每个模板实例都有其自己的作用域，其中给定的循环变量设置为当前集合项， &lt;code&gt;$index&lt;/code&gt; 设置为项索引或键。</target>
        </trans-unit>
        <trans-unit id="f3258a5d7b59d2f657f7fe17a611da1f014e37dd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ngResource&lt;/code&gt; module provides interaction support with RESTful services via the $resource service.</source>
          <target state="translated">该 &lt;code&gt;ngResource&lt;/code&gt; 模块提供了通过$资源服务RESTful服务交互的支持。</target>
        </trans-unit>
        <trans-unit id="9ddc195a90e2c72b0358a7cc99d02ccb7323a2b2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ngRoute&lt;/code&gt; module provides routing and deeplinking services and directives for AngularJS apps.</source>
          <target state="translated">该 &lt;code&gt;ngRoute&lt;/code&gt; 模块提供路由和deeplinking为AngularJS应用服务和指令。</target>
        </trans-unit>
        <trans-unit id="b3e208ecff40d20920929e835051dd884ba87ba7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ngSanitize&lt;/code&gt; module provides functionality to sanitize HTML.</source>
          <target state="translated">该 &lt;code&gt;ngSanitize&lt;/code&gt; 模块提供的功能来处理HTML。</target>
        </trans-unit>
        <trans-unit id="52b3ba27765007bf524e878fcbc2019dfd26ae3f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ngShow&lt;/code&gt; directive shows or hides the given HTML element based on the expression provided to the &lt;code&gt;ngShow&lt;/code&gt; attribute.</source>
          <target state="translated">所述 &lt;code&gt;ngShow&lt;/code&gt; 指令显示或隐藏在指定的HTML基于提供给所述的表达元件 &lt;code&gt;ngShow&lt;/code&gt; 属性。</target>
        </trans-unit>
        <trans-unit id="faf99d24631b3a829e4bcd7302c5c47d13b5ad16" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ngStyle&lt;/code&gt; directive allows you to set CSS style on an HTML element conditionally.</source>
          <target state="translated">该 &lt;code&gt;ngStyle&lt;/code&gt; 指令允许您设置CSS样式的HTML元素上有条件。</target>
        </trans-unit>
        <trans-unit id="100ff07ef6149d7ca57d5a58fc1db3c2ed44c1fc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ngSwitch&lt;/code&gt; directive is used to conditionally swap DOM structure on your template based on a scope expression. Elements within &lt;code&gt;ngSwitch&lt;/code&gt; but without &lt;code&gt;ngSwitchWhen&lt;/code&gt; or &lt;code&gt;ngSwitchDefault&lt;/code&gt; directives will be preserved at the location as specified in the template.</source>
          <target state="translated">该 &lt;code&gt;ngSwitch&lt;/code&gt; 指令用于有条件地交换DOM结构基于一个范围的表达你的模板。 &lt;code&gt;ngSwitch&lt;/code&gt; 中的元素但不 &lt;code&gt;ngSwitchWhen&lt;/code&gt; 或 &lt;code&gt;ngSwitchDefault&lt;/code&gt; 指令将保留在模板中指定的位置。</target>
        </trans-unit>
        <trans-unit id="a891433d4f844a3439f6448464836003a6666e46" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ngTouch&lt;/code&gt; module provides helpers for touch-enabled devices. The implementation is based on jQuery Mobile touch event handling (&lt;a href=&quot;http://jquerymobile.com/&quot;&gt;jquerymobile.com&lt;/a&gt;). *</source>
          <target state="translated">该 &lt;code&gt;ngTouch&lt;/code&gt; 模块提供了helper启用触摸的设备。该实现基于jQuery Mobile触摸事件处理（&lt;a href=&quot;http://jquerymobile.com/&quot;&gt;jquerymobile.com&lt;/a&gt;）。*</target>
        </trans-unit>
        <trans-unit id="719edff275929380e8a63e3ec29b0aaffc381b87" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;obj&lt;/code&gt; collection is observed via standard $watch operation and is examined on every call to $digest() to see if any items have been added, removed, or moved.</source>
          <target state="translated">该 &lt;code&gt;obj&lt;/code&gt; 集合通过标准$表操作和观察检查在每次调用$摘要（）来查看是否有任何项目已被添加，删除或移动。</target>
        </trans-unit>
        <trans-unit id="851c27c48ef1a184f216635c0032b8034ac64b06" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;object&lt;/code&gt; or &lt;code&gt;function&lt;/code&gt; returned by the service</source>
          <target state="translated">服务返回的 &lt;code&gt;object&lt;/code&gt; 或 &lt;code&gt;function&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="78f03e71ba8da4c772e22f7cefb6a86de28fb156" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;offset&lt;/code&gt; attribute allows further customization of pluralized text, which can result in a better user experience. For example, instead of the message &quot;4 people are viewing this document&quot;, you might display &quot;John, Kate and 2 others are viewing this document&quot;. The offset attribute allows you to offset a number by any desired value. Let's take a look at an example:</source>
          <target state="translated">该 &lt;code&gt;offset&lt;/code&gt; 属性允许多元化的文字进一步定制，这可能会导致更好的用户体验。例如，代替显示消息&amp;ldquo; 4个人正在查看此文档&amp;rdquo;，您可以显示&amp;ldquo;约翰，凯特和另外2个人正在查看此文档&amp;rdquo;。offset属性允许您将数字偏移任何所需的值。让我们看一个例子：</target>
        </trans-unit>
        <trans-unit id="3841cc9d8c6ce2f408224f3cae680aa991a2ad9a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;oldCollection&lt;/code&gt; object is a copy of the former collection data. Due to performance considerations, the&lt;code&gt;oldCollection&lt;/code&gt; value is computed only if the &lt;code&gt;listener&lt;/code&gt; function declares two or more arguments.</source>
          <target state="translated">该 &lt;code&gt;oldCollection&lt;/code&gt; 对象是前收集数据的副本。 &lt;code&gt;oldCollection&lt;/code&gt; 性能考虑，仅当 &lt;code&gt;listener&lt;/code&gt; 函数声明两个或多个参数时才计算oldCollection值。</target>
        </trans-unit>
        <trans-unit id="92de2adf4257cb98e99d7c66015a3a4463b7f324" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;params&lt;/code&gt; object in the &lt;strong&gt;callback&lt;/strong&gt; will now have properties with these keys, which hold the value of the corresponding &lt;strong&gt;group&lt;/strong&gt; in the &lt;strong&gt;regex&lt;/strong&gt;.</source>
          <target state="translated">的 &lt;code&gt;params&lt;/code&gt; 在对象&lt;strong&gt;的回调&lt;/strong&gt;现在将有与这些键，其中保持相应的值的属性&lt;strong&gt;组&lt;/strong&gt;中的&lt;strong&gt;正则表达式&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="c809664e3f03c3d8135c609d28867a41b149ee5f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;required&lt;/code&gt; message will be displayed to the user since it appears before the &lt;code&gt;email&lt;/code&gt; message in the DOM. Once the user types a single character, the &lt;code&gt;required&lt;/code&gt; message will disappear (since the field now has a value) but the &lt;code&gt;email&lt;/code&gt; message will be visible because it is still applicable.</source>
          <target state="translated">该 &lt;code&gt;required&lt;/code&gt; ，因为它之前出现的消息将显示给用户 &lt;code&gt;email&lt;/code&gt; 中的DOM消息。用户键入单个字符后， &lt;code&gt;required&lt;/code&gt; 消息将消失（因为该字段现在具有值），但是由于该 &lt;code&gt;email&lt;/code&gt; 消息仍然适用，因此该电子邮件消息将可见。</target>
        </trans-unit>
        <trans-unit id="4185c522e4249b9336c8172126c02efcc1c08358" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;restrict&lt;/code&gt; option is typically set to:</source>
          <target state="translated">该 &lt;code&gt;restrict&lt;/code&gt; 选项通常设置为：</target>
        </trans-unit>
        <trans-unit id="a4a3705bd9ff2aae6d9842de77dd5be730d87c0a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;routeTemplateMonitor&lt;/code&gt; service depends on the built-in &lt;a href=&quot;../api/ngroute/service/%24route&quot;&gt;&lt;code&gt;$route&lt;/code&gt;&lt;/a&gt; service and our custom &lt;code&gt;batchLog&lt;/code&gt; service.</source>
          <target state="translated">该 &lt;code&gt;routeTemplateMonitor&lt;/code&gt; 服务依赖于内置的&lt;a href=&quot;../api/ngroute/service/%24route&quot;&gt; &lt;code&gt;$route&lt;/code&gt; &lt;/a&gt;服务，我们的定制 &lt;code&gt;batchLog&lt;/code&gt; 服务。</target>
        </trans-unit>
        <trans-unit id="afc148e7de524b6d85fc2a2af328dfe7cc13d5f0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;scope()&lt;/code&gt; function is only available when &lt;a href=&quot;../api/ng/provider/%24compileprovider#debugInfoEnabled.html&quot;&gt;&lt;code&gt;$compileProvider.debugInfoEnabled()&lt;/code&gt;&lt;/a&gt; is true (which is the default).</source>
          <target state="translated">仅当&lt;a href=&quot;../api/ng/provider/%24compileprovider#debugInfoEnabled.html&quot;&gt; &lt;code&gt;$compileProvider.debugInfoEnabled()&lt;/code&gt; &lt;/a&gt;为true（默认设置）时， &lt;code&gt;scope()&lt;/code&gt; 函数才可用。</target>
        </trans-unit>
        <trans-unit id="9fe9f3176578380f2a8892095126bf450cc2e55b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;scope&lt;/code&gt; argument refers to the current scope.</source>
          <target state="translated">该 &lt;code&gt;scope&lt;/code&gt; 参数是指当前范围。</target>
        </trans-unit>
        <trans-unit id="081d217fe995efb27d071685f735b72868a5a5e7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;select&lt;/code&gt; directive is used together with &lt;a href=&quot;ngmodel&quot;&gt;&lt;code&gt;ngModel&lt;/code&gt;&lt;/a&gt; to provide data-binding between the scope and the &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt; control (including setting default values). It also handles dynamic &lt;code&gt;&amp;lt;option&amp;gt;&lt;/code&gt; elements, which can be added using the &lt;a href=&quot;ngrepeat&quot;&gt;&lt;code&gt;ngRepeat&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;ngoptions&quot;&gt;&lt;code&gt;ngOptions&lt;/code&gt;&lt;/a&gt; directives.</source>
          <target state="translated">的 &lt;code&gt;select&lt;/code&gt; 指令与一起使用&lt;a href=&quot;ngmodel&quot;&gt; &lt;code&gt;ngModel&lt;/code&gt; &lt;/a&gt;提供数据绑定的范围和间 &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt; 控制（包括设置默认值）。它还处理动态的 &lt;code&gt;&amp;lt;option&amp;gt;&lt;/code&gt; 元素，可以使用&lt;a href=&quot;ngrepeat&quot;&gt; &lt;code&gt;ngRepeat&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;ngoptions&quot;&gt; &lt;code&gt;ngOptions&lt;/code&gt; &lt;/a&gt;指令添加这些元素。</target>
        </trans-unit>
        <trans-unit id="764c088d4b58451c39c5d707cf0b855450c788f2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;this&lt;/code&gt; for the invoked method.</source>
          <target state="translated">在 &lt;code&gt;this&lt;/code&gt; 被调用方法。</target>
        </trans-unit>
        <trans-unit id="1f00eea4dd41ef348229b3babc12267733b6ae2b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;transclude&lt;/code&gt; option changes the way scopes are nested. It makes it so that the &lt;strong&gt;contents&lt;/strong&gt; of a transcluded directive have whatever scope is outside the directive, rather than whatever scope is on the inside. In doing so, it gives the contents access to the outside scope.</source>
          <target state="translated">该 &lt;code&gt;transclude&lt;/code&gt; 选项更改范围嵌套的方式。这样可以使已包含指令的&lt;strong&gt;内容&lt;/strong&gt;具有该指令外部的任何作用域，而不是内部的任何作用域。这样，它可以使内容访问外部范围。</target>
        </trans-unit>
        <trans-unit id="0592776fbfd3e45c05d0a220d4166d8e78eef8e0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;updateOn&lt;/code&gt; and &lt;code&gt;debounce&lt;/code&gt; properties allow you to specify a custom list of events that will trigger a model update and/or a debouncing delay so that the actual update only takes place when a timer expires; this timer will be reset after another change takes place.</source>
          <target state="translated">该 &lt;code&gt;updateOn&lt;/code&gt; 和 &lt;code&gt;debounce&lt;/code&gt; 特性允许你指定事件的自定义列表，将触发模型更新和/或去除抖动延迟，以便当计时器到期实际更新仅发生; 再次更改后，此计时器将被重置。</target>
        </trans-unit>
        <trans-unit id="865d012686bd8519148229c77d24cb9da639e749" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;value&lt;/code&gt; that was originally provided to &lt;a href=&quot;%24scedelegate#trustAs.html&quot;&gt;&lt;code&gt;$sceDelegate.trustAs&lt;/code&gt;&lt;/a&gt; if &lt;code&gt;value&lt;/code&gt; is the result of such a call. Otherwise, returns &lt;code&gt;value&lt;/code&gt; unchanged.</source>
          <target state="translated">该 &lt;code&gt;value&lt;/code&gt; 最初提供给&lt;a href=&quot;%24scedelegate#trustAs.html&quot;&gt; &lt;code&gt;$sceDelegate.trustAs&lt;/code&gt; &lt;/a&gt;如果 &lt;code&gt;value&lt;/code&gt; 是这样的调用的结果。否则，返回 &lt;code&gt;value&lt;/code&gt; 不变。</target>
        </trans-unit>
        <trans-unit id="024e3409a1e0aafe121f0936f278bfdbd6b8eded" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;watchExpression&lt;/code&gt; is called on every call to &lt;a href=&quot;%24rootscope.scope#%24digest.html&quot;&gt;$digest()&lt;/a&gt; and should return the value that will be watched. (&lt;code&gt;watchExpression&lt;/code&gt; should not change its value when executed multiple times with the same input because it may be executed multiple times by &lt;a href=&quot;%24rootscope.scope#%24digest.html&quot;&gt;$digest()&lt;/a&gt;. That is, &lt;code&gt;watchExpression&lt;/code&gt; should be &lt;a href=&quot;http://en.wikipedia.org/wiki/Idempotence&quot;&gt;idempotent&lt;/a&gt;.)</source>
          <target state="translated">该 &lt;code&gt;watchExpression&lt;/code&gt; 被称为在每次调用&lt;a href=&quot;%24rootscope.scope#%24digest.html&quot;&gt;$摘要（）&lt;/a&gt;和应该返回将要观看的价值。（ &lt;code&gt;watchExpression&lt;/code&gt; 在使用同一输入多次执行时不应更改其值，因为&lt;a href=&quot;%24rootscope.scope#%24digest.html&quot;&gt;$ digest（）&lt;/a&gt;可能多次执行 &lt;code&gt;watchExpression&lt;/code&gt; 。也就是说，watchExpression应该是&lt;a href=&quot;http://en.wikipedia.org/wiki/Idempotence&quot;&gt;幂等的&lt;/a&gt;。）</target>
        </trans-unit>
        <trans-unit id="c77aba6041c9b36ae3635fef59bf7730092422df" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;when&lt;/code&gt; attribute specifies the mappings between plural categories and the actual string to be displayed. The value of the attribute should be a JSON object.</source>
          <target state="translated">在 &lt;code&gt;when&lt;/code&gt; 属性指定要显示的多个类别和实际的字符串之间的对应关系。该属性的值应为JSON对象。</target>
        </trans-unit>
        <trans-unit id="29c7438c3e58ad6cfeb1ab043f1d56e6013584d8" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;default value&lt;/strong&gt; when no whitelist has been explicitly set is &lt;code&gt;['self']&lt;/code&gt; allowing only same origin resource requests.</source>
          <target state="translated">未明确设置白名单时的&lt;strong&gt;默认值为&lt;/strong&gt; &lt;code&gt;['self']&lt;/code&gt; ，仅允许相同的原始资源请求。</target>
        </trans-unit>
        <trans-unit id="971a8e0fa1cf0babaa204065768792f07fb82390" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;default value&lt;/strong&gt; when no whitelist has been explicitly set is the empty array (i.e. there is no blacklist.)</source>
          <target state="translated">未明确设置白名单时的&lt;strong&gt;默认值为&lt;/strong&gt;空数组（即没有黑名单）。</target>
        </trans-unit>
        <trans-unit id="30b3a9c87fe99e11ad5c482f252d8b2795c7d39c" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;normalization&lt;/strong&gt; process is as follows:</source>
          <target state="translated">的&lt;strong&gt;归一化&lt;/strong&gt;过程如下：</target>
        </trans-unit>
        <trans-unit id="c92de0945f5d858e55599f74eae5a30cddcf871d" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;scope option&lt;/strong&gt; is an object that contains a property for each isolate scope binding. In this case it has just one property:</source>
          <target state="translated">的&lt;strong&gt;范围选择&lt;/strong&gt;是包含各分离物范围结合的性质的物体。在这种情况下，它只有一个属性：</target>
        </trans-unit>
        <trans-unit id="e6b40743da77f9678b10414f875798e060c42324" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;service factory function&lt;/strong&gt; generates the single object or function that represents the service to the rest of the application. The object or function returned by the service is injected into any component (controller, service, filter or directive) that specifies a dependency on the service.</source>
          <target state="translated">的&lt;strong&gt;服务工厂函数&lt;/strong&gt;生成单个对象或函数表示服务给应用程序的其余部分。服务返回的对象或函数被注入到指定对服务依赖的任何组件（控制器，服务，过滤器或指令）中。</target>
        </trans-unit>
        <trans-unit id="5ceadcbdd30d6b737f519c6b13401595572885d1" translate="yes" xml:space="preserve">
          <source>The AngularJS approach produces a stable DOM. The DOM element instance bound to a model item instance does not change for the lifetime of the binding. This means that the code can get hold of the elements and register event handlers and know that the reference will not be destroyed by template data merge.</source>
          <target state="translated">AngularJS的方法会产生一个稳定的DOM。绑定到模型项实例的DOM元素实例在绑定的生命周期内不会改变。这意味着代码可以掌握元素和注册事件处理程序,并知道引用不会被模板数据合并破坏。</target>
        </trans-unit>
        <trans-unit id="cda5f891e99782bb7f2b57b3956c0a05ebdb49e3" translate="yes" xml:space="preserve">
          <source>The AngularJS datetime filter uses the time zone settings of the browser. The same application will show different time information depending on the time zone settings of the computer that the application is running on. Neither JavaScript nor AngularJS currently supports displaying the date with a timezone specified by the developer.</source>
          <target state="translated">AngularJS日期时间过滤器使用浏览器的时区设置。根据应用程序运行的计算机的时区设置,同一应用程序将显示不同的时间信息。目前JavaScript和AngularJS都不支持显示开发者指定时区的日期。</target>
        </trans-unit>
        <trans-unit id="0ed09a1c05ea064927146d6b96bb2d8d5f52f6be" translate="yes" xml:space="preserve">
          <source>The AngularJS expression is followed by &lt;code&gt;, select,&lt;/code&gt; where the spaces are optional.</source>
          <target state="translated">AngularJS表达式后跟 &lt;code&gt;, select,&lt;/code&gt; 其中空格是可选的。</target>
        </trans-unit>
        <trans-unit id="3e68d99150c2f319df83ed6c3b871e24960e46dc" translate="yes" xml:space="preserve">
          <source>The AngularJS injector subsystem is in charge of creating components, resolving their dependencies, and providing them to other components as requested.</source>
          <target state="translated">AngularJS注入器子系统负责创建组件,解析它们的依赖关系,并按要求提供给其他组件。</target>
        </trans-unit>
        <trans-unit id="a093f7952b1838c4dd6aeda28ea5e1fc38030960" translate="yes" xml:space="preserve">
          <source>The Basics</source>
          <target state="translated">基础知识</target>
        </trans-unit>
        <trans-unit id="9d032f695a01d9cd7a1b6d3c12def6c50b9bd99f" translate="yes" xml:space="preserve">
          <source>The Component config object. (Note that, unlike the &lt;code&gt;.directive()&lt;/code&gt; method, this method does &lt;strong&gt;not&lt;/strong&gt; take a factory function.)</source>
          <target state="translated">组件配置对象。（需要注意的是，不像 &lt;code&gt;.directive()&lt;/code&gt; 方法，这种方法并&lt;strong&gt;没有&lt;/strong&gt;采取工厂函数）。</target>
        </trans-unit>
        <trans-unit id="8bac82729a1c26fcbe3c4f5867ac3b7453bf9540" translate="yes" xml:space="preserve">
          <source>The Controller methods and properties are available in the template (for both the &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; element and its children).</source>
          <target state="translated">模板中提供了Controller方法和属性（用于 &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; 元素及其子元素）。</target>
        </trans-unit>
        <trans-unit id="af868017ccf0c187453928340ab193c6139324bb" translate="yes" xml:space="preserve">
          <source>The DOM property name.</source>
          <target state="translated">DOM属性名称。</target>
        </trans-unit>
        <trans-unit id="d443ac9ac3502ca4aa895decc917e0fc27f2931f" translate="yes" xml:space="preserve">
          <source>The Deferred API</source>
          <target state="translated">递延的API</target>
        </trans-unit>
        <trans-unit id="1e7c1b13eac086e0802b173f73532f7f37f2370c" translate="yes" xml:space="preserve">
          <source>The DemoController is instantiated via its constructor, every time the app needs an instance of DemoController (in our simple app it's just once). So unlike services, controllers are not singletons. The constructor is called with all the requested services, in our case the &lt;code&gt;clientId&lt;/code&gt; service.</source>
          <target state="translated">每当应用程序需要一个DemoController实例时，都会通过其构造函数实例化DemoController（在我们的简单应用程序中，它只是一次）。因此，与服务不同，控制器不是单例。使用所有请求的服务调用构造函数，在本例中为 &lt;code&gt;clientId&lt;/code&gt; 服务。</target>
        </trans-unit>
        <trans-unit id="b3fa2746de6d7246f13d0d1cffdff95010c93ad4" translate="yes" xml:space="preserve">
          <source>The Factory recipe constructs a new service using a function with zero or more arguments (these are dependencies on other services). The return value of this function is the service instance created by this recipe.</source>
          <target state="translated">工厂配方使用一个有零个或多个参数的函数(这些是对其他服务的依赖)来构造一个新的服务。该函数的返回值是由该配方创建的服务实例。</target>
        </trans-unit>
        <trans-unit id="ac50a19bbd375fef86664e01f67fa8affc02aed1" translate="yes" xml:space="preserve">
          <source>The HTTP request template URL</source>
          <target state="translated">HTTP请求模板URL</target>
        </trans-unit>
        <trans-unit id="ae5f1f8e1b81cdc0e20901352fa4e651557871f5" translate="yes" xml:space="preserve">
          <source>The JavaScript specification does not define the order of keys returned for an object, so AngularJS relies on the order returned by the browser when running &lt;code&gt;for key in myObj&lt;/code&gt;. Browsers generally follow the strategy of providing keys in the order in which they were defined, although there are exceptions when keys are deleted and reinstated. See the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/delete#Cross-browser_notes&quot;&gt;MDN page on &lt;code&gt;delete&lt;/code&gt; for more info&lt;/a&gt;.</source>
          <target state="translated">JavaScript规范未定义为对象返回的键的顺序，因此AngularJS依赖于 &lt;code&gt;for key in myObj&lt;/code&gt; 运行时浏览器返回的顺序。浏览器通常遵循按定义顺序提供密钥的策略，尽管在删除和恢复密钥后会有例外。有关&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/delete#Cross-browser_notes&quot;&gt;更多信息，&lt;/a&gt;请参阅MDN页面上的 &lt;code&gt;delete&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3bf8ccad6f9791756a44c25e1221b6b0a5e4e10b" translate="yes" xml:space="preserve">
          <source>The Promise API</source>
          <target state="translated">Promise API</target>
        </trans-unit>
        <trans-unit id="c9652e0712d85f53b10f54c8b3d21746e8926806" translate="yes" xml:space="preserve">
          <source>The Provider recipe is syntactically defined as a custom type that implements a &lt;code&gt;$get&lt;/code&gt; method. This method is a factory function just like the one we use in the Factory recipe. In fact, if you define a Factory recipe, an empty Provider type with the &lt;code&gt;$get&lt;/code&gt; method set to your factory function is automatically created under the hood.</source>
          <target state="translated">Provider配方在语法上定义为实现 &lt;code&gt;$get&lt;/code&gt; 的自定义类型方法。该方法是一种工厂功能，就像我们在工厂配方中使用的那样。实际上，如果定义了工厂配方，则会在后台自动创建一个空的提供程序类型，并将 &lt;code&gt;$get&lt;/code&gt; 方法设置为工厂函数。</target>
        </trans-unit>
        <trans-unit id="5c03e42c5800d984cbbf4b29ceb9ec72c21a0335" translate="yes" xml:space="preserve">
          <source>The Provider recipe is the core recipe type and all the other ones are just syntactic sugar on it.</source>
          <target state="translated">提供者配方是核心的配方类型,其他的配方都只是在它上面加了语法糖。</target>
        </trans-unit>
        <trans-unit id="a892a7bf5def9b0ea2286339b6f7a5da993546d3" translate="yes" xml:space="preserve">
          <source>The Resource instances and collections have these additional methods:</source>
          <target state="translated">资源实例和集合有这些附加方法。</target>
        </trans-unit>
        <trans-unit id="e66076755327d887f686ad69f837103a8b754a30" translate="yes" xml:space="preserve">
          <source>The Resource instances and collections have these additional properties:</source>
          <target state="translated">资源实例和集合具有这些附加属性。</target>
        </trans-unit>
        <trans-unit id="34621a3a20f723701bf1858b04f4ad3fb921a112" translate="yes" xml:space="preserve">
          <source>The Resource instances have these additional methods:</source>
          <target state="translated">资源实例有这些附加方法。</target>
        </trans-unit>
        <trans-unit id="a71937c0cf05c12db3a4b4bba8de6a062c6cf8f4" translate="yes" xml:space="preserve">
          <source>The Router holds reference to one or more of Outlets.</source>
          <target state="translated">路由器拥有对一个或多个Outlets的引用。</target>
        </trans-unit>
        <trans-unit id="87ff180e9a06b8bf6a17a8b51f3125e4d192aa91" translate="yes" xml:space="preserve">
          <source>The SCE context in which this result will be used.</source>
          <target state="translated">使用该结果的SCE上下文。</target>
        </trans-unit>
        <trans-unit id="823fe0827cbf252db7bc25081089c81fb8cdd103" translate="yes" xml:space="preserve">
          <source>The Safari browser throws a &lt;code&gt;RangeError&lt;/code&gt; instead of returning &lt;code&gt;null&lt;/code&gt; when it tries to stringify a &lt;code&gt;Date&lt;/code&gt; object with an invalid date value. The only reliable way to prevent this is to monkeypatch the &lt;code&gt;Date.prototype.toJSON&lt;/code&gt; method as follows:</source>
          <target state="translated">当Safari浏览器尝试使用无效的日期值对 &lt;code&gt;Date&lt;/code&gt; 对象进行字符串化处理时，将引发 &lt;code&gt;RangeError&lt;/code&gt; 而不是返回 &lt;code&gt;null&lt;/code&gt; 。防止这种情况发生的唯一可靠方法是对 &lt;code&gt;Date.prototype.toJSON&lt;/code&gt; 按如下方式 Date.prototype.toJSON方法：</target>
        </trans-unit>
        <trans-unit id="afb43aa0cd18509de40731a13b780ba28edd09b0" translate="yes" xml:space="preserve">
          <source>The Service recipe produces a service just like the Value or Factory recipes, but it does so by &lt;em&gt;invoking a constructor with the &lt;code&gt;new&lt;/code&gt; operator&lt;/em&gt;. The constructor can take zero or more arguments, which represent dependencies needed by the instance of this type.</source>
          <target state="translated">服务配方产生的服务就像Value或Factory配方一样，但是它通过&lt;em&gt;使用&lt;/em&gt;&lt;em&gt; &lt;code&gt;new&lt;/code&gt; &lt;/em&gt;&lt;em&gt;的构造函数&lt;/em&gt;来&lt;em&gt;调用运算符&lt;/em&gt;。构造函数可以使用零个或多个参数，这些参数表示此类型的实例所需的依赖关系。</target>
        </trans-unit>
        <trans-unit id="25546288f27af1b214ed293ad490dde0ee7283f3" translate="yes" xml:space="preserve">
          <source>The Value recipe is very simple to write, but lacks some important features we often need when creating services. Let's now look at the Value recipe's more powerful sibling, the Factory. The Factory recipe adds the following abilities:</source>
          <target state="translated">Value配方的编写非常简单,但缺乏一些我们在创建服务时经常需要的重要功能。现在让我们看看Value配方的更强大的兄弟姐妹--Factory。Factory配方增加了以下能力。</target>
        </trans-unit>
        <trans-unit id="f208762d78ff0661e5bda0e7aac4b7d59f109453" translate="yes" xml:space="preserve">
          <source>The Zen of AngularJS</source>
          <target state="translated">AngularJS的禅意</target>
        </trans-unit>
        <trans-unit id="c29d1c1afd3d55fd76dd7231c901e094f9916538" translate="yes" xml:space="preserve">
          <source>The above affects all kinds of element re-use due to tracking, but may be especially visible when tracking by &lt;code&gt;$index&lt;/code&gt; due to the way ngRepeat re-uses elements.</source>
          <target state="translated">上面的内容会影响所有由于跟踪而导致的元素重用，但是当通过 &lt;code&gt;$index&lt;/code&gt; 由于ngRepeat重用元素的方式而在$ index。</target>
        </trans-unit>
        <trans-unit id="1d020ab0c4519b74d0e2f34f58f59c7bb5764a61" translate="yes" xml:space="preserve">
          <source>The above is a suggestion. Tailor it to your needs.</source>
          <target state="translated">以上是一个建议。根据自己的需要,量身定做。</target>
        </trans-unit>
        <trans-unit id="97d188a64eaf391575058d7091fc3fa4a7f72e3b" translate="yes" xml:space="preserve">
          <source>The action methods on the class object or instance object can be invoked with the following parameters:</source>
          <target state="translated">类对象或实例对象上的动作方法可以用以下参数来调用。</target>
        </trans-unit>
        <trans-unit id="7eff8e112c923d4408ba2e75a0a922cfc87c536b" translate="yes" xml:space="preserve">
          <source>The actual value from the control's view. For &lt;code&gt;input&lt;/code&gt; elements, this is a String. See &lt;a href=&quot;ngmodel.ngmodelcontroller#%24setViewValue.html&quot;&gt;&lt;code&gt;ngModel.NgModelController&lt;/code&gt;&lt;/a&gt; for information about when the $viewValue is set.</source>
          <target state="translated">从控件的角度看的实际值。对于 &lt;code&gt;input&lt;/code&gt; 元素，这是一个字符串。参见&lt;a href=&quot;ngmodel.ngmodelcontroller#%24setViewValue.html&quot;&gt; &lt;code&gt;ngModel.NgModelController&lt;/code&gt; &lt;/a&gt;有关何时设置$ viewValue的信息，。</target>
        </trans-unit>
        <trans-unit id="48378b09bf8458398be6b8d6a8a1f336579bf8ba" translate="yes" xml:space="preserve">
          <source>The amount of time moved forward.</source>
          <target state="translated">前进的时间量。</target>
        </trans-unit>
        <trans-unit id="2b948d265fc57c10625e1ce0862575d8dd243a43" translate="yes" xml:space="preserve">
          <source>The application can have multiple scopes, because &lt;a href=&quot;directive&quot;&gt;directives&lt;/a&gt; can create new child scopes. When new scopes are created, they are added as children of their parent scope. This creates a tree structure which parallels the DOM where they're attached.</source>
          <target state="translated">该应用程序可以具有多个作用域，因为 &lt;a href=&quot;directive&quot;&gt;指令&lt;/a&gt;可以创建新的子作用域。创建新作用域时，它们将作为其父作用域的子级添加。这将创建一个树形结构，该树形结构与附加了DOM的DOM平行。</target>
        </trans-unit>
        <trans-unit id="38e5bbdd08561c9153847e92a500562dc014b342" translate="yes" xml:space="preserve">
          <source>The application developer is responsible for loading the code containing the modules; and for ensuring that lazy scripts are not downloaded and executed more often that desired.</source>
          <target state="translated">应用程序开发人员负责加载包含模块的代码;并负责确保懒惰的脚本不会被下载和执行更多所需的次数。</target>
        </trans-unit>
        <trans-unit id="60f11f10d202320b748ee12a06796244dbd227a5" translate="yes" xml:space="preserve">
          <source>The arguments present in the callback function are:</source>
          <target state="translated">回调函数中存在的参数是:</target>
        </trans-unit>
        <trans-unit id="81e6f0d0a80e18b7562f471ce77dd5009db58a45" translate="yes" xml:space="preserve">
          <source>The array notation</source>
          <target state="translated">阵列符号</target>
        </trans-unit>
        <trans-unit id="9ca59792e60c6511fe9a49d6033cb2a4c1439819" translate="yes" xml:space="preserve">
          <source>The attribute magic of ngAria may not work for every scenario. To disable individual attributes, you can use the &lt;a href=&quot;../api/ngaria/provider/%24ariaprovider#config.html&quot;&gt;config&lt;/a&gt; method. Just keep in mind this will tell ngAria to ignore the attribute globally.</source>
          <target state="translated">ngAria的属性魔术可能不适用于每种情况。要禁用单个属性，可以使用&lt;a href=&quot;../api/ngaria/provider/%24ariaprovider#config.html&quot;&gt;config&lt;/a&gt;方法。请记住，这将告诉ngAria全局忽略该属性。</target>
        </trans-unit>
        <trans-unit id="14d833ec5a36b34606ff7ead177dd258878c59e5" translate="yes" xml:space="preserve">
          <source>The behaviour of the directive is affected by the use of the &lt;code&gt;ngTrim&lt;/code&gt; attribute.</source>
          <target state="translated">指令的行为受 &lt;code&gt;ngTrim&lt;/code&gt; 的使用影响属性。</target>
        </trans-unit>
        <trans-unit id="8aeca93c2626363ee4548fe610e8099df9c9c8b3" translate="yes" xml:space="preserve">
          <source>The boolean &lt;code&gt;readonly&lt;/code&gt; attribute is only valid for native form controls such as &lt;code&gt;input&lt;/code&gt; and &lt;code&gt;textarea&lt;/code&gt;. To properly indicate custom element directives such as &lt;code&gt;&amp;lt;md-checkbox&amp;gt;&lt;/code&gt; or &lt;code&gt;&amp;lt;custom-input&amp;gt;&lt;/code&gt; as required, using ngAria with &lt;a href=&quot;../api/ng/directive/ngreadonly&quot;&gt;ngReadonly&lt;/a&gt; will also add &lt;code&gt;aria-readonly&lt;/code&gt;. This tells accessibility APIs when a custom control is read-only.</source>
          <target state="translated">布尔值 &lt;code&gt;readonly&lt;/code&gt; 属性仅对本机表单控件（例如 &lt;code&gt;input&lt;/code&gt; 和 &lt;code&gt;textarea&lt;/code&gt; )有效。为了根据需要正确指示诸如 &lt;code&gt;&amp;lt;md-checkbox&amp;gt;&lt;/code&gt; 或 &lt;code&gt;&amp;lt;custom-input&amp;gt;&lt;/code&gt; 之类的自定义元素指令，将ngAria与&lt;a href=&quot;../api/ng/directive/ngreadonly&quot;&gt;ngReadonly&lt;/a&gt;一起使用还会添加 &lt;code&gt;aria-readonly&lt;/code&gt; 。这告诉自定义控件何时只读的可访问性API。</target>
        </trans-unit>
        <trans-unit id="935e2113acf37c8fa60e8d363d9a4163dc3c40a0" translate="yes" xml:space="preserve">
          <source>The boolean &lt;code&gt;required&lt;/code&gt; attribute is only valid for native form controls such as &lt;code&gt;input&lt;/code&gt; and &lt;code&gt;textarea&lt;/code&gt;. To properly indicate custom element directives such as &lt;code&gt;&amp;lt;md-checkbox&amp;gt;&lt;/code&gt; or &lt;code&gt;&amp;lt;custom-input&amp;gt;&lt;/code&gt; as required, using ngAria with &lt;a href=&quot;../api/ng/directive/ngrequired&quot;&gt;ngRequired&lt;/a&gt; will also add &lt;code&gt;aria-required&lt;/code&gt;. This tells accessibility APIs when a custom control is required.</source>
          <target state="translated">布尔值 &lt;code&gt;required&lt;/code&gt; 属性仅对本机表单控件（例如 &lt;code&gt;input&lt;/code&gt; 和 &lt;code&gt;textarea&lt;/code&gt; )有效。为了根据需要正确指示诸如 &lt;code&gt;&amp;lt;md-checkbox&amp;gt;&lt;/code&gt; 或 &lt;code&gt;&amp;lt;custom-input&amp;gt;&lt;/code&gt; 之类的自定义元素指令，将ngAria与&lt;a href=&quot;../api/ng/directive/ngrequired&quot;&gt;ngRequired&lt;/a&gt;一起使用还会添加 &lt;code&gt;aria-required&lt;/code&gt; 。这告诉可访问性API，何时需要自定义控件。</target>
        </trans-unit>
        <trans-unit id="9e8a4e50e5a91fb8867fe908b441bbfda7d826ab" translate="yes" xml:space="preserve">
          <source>The browser re-renders the view with the updated text.</source>
          <target state="translated">浏览器会用更新的文本重新渲染视图。</target>
        </trans-unit>
        <trans-unit id="65cf3e169c60d4db4937d1da68550b314b1b6e3d" translate="yes" xml:space="preserve">
          <source>The browser's event-loop waits for an event to arrive. An event is a user interaction, timer event, or network event (response from a server).</source>
          <target state="translated">浏览器的事件循环等待一个事件的到来。事件是指用户交互、定时器事件或网络事件(来自服务器的响应)。</target>
        </trans-unit>
        <trans-unit id="707ecbb38e755bff0a1ac8d5a41800f59ce92ee0" translate="yes" xml:space="preserve">
          <source>The buggy way to write it:</source>
          <target state="translated">错误的写法。</target>
        </trans-unit>
        <trans-unit id="7daed9593b5b371d72c261edea4b25b4a7fbc58e" translate="yes" xml:space="preserve">
          <source>The built-in &lt;code&gt;$id()&lt;/code&gt; function can be used to assign a unique &lt;code&gt;$$hashKey&lt;/code&gt; property to each item in the collection. This property is then used as a key to associated DOM elements with the corresponding item in the collection by identity. Moving the same object would move the DOM element in the same way in the DOM. Note that the default id function does not support duplicate primitive values (&lt;code&gt;number&lt;/code&gt;, &lt;code&gt;string&lt;/code&gt;), but supports duplictae non-primitive values (&lt;code&gt;object&lt;/code&gt;) that are &lt;em&gt;equal&lt;/em&gt; in shape.</source>
          <target state="translated">内置的 &lt;code&gt;$id()&lt;/code&gt; 函数可用于为集合中的每个项目分配唯一的 &lt;code&gt;$$hashKey&lt;/code&gt; 属性。然后将此属性用作通过标识将DOM元素与集合中相应项目关联的键。移动相同的对象将以相同的方式在DOM中移动DOM元素。请注意，默认的id函数不支持重复的原始值（ &lt;code&gt;number&lt;/code&gt; ， &lt;code&gt;string&lt;/code&gt; ），但支持形状&lt;em&gt;相同的&lt;/em&gt;双份非原始值（ &lt;code&gt;object&lt;/code&gt; ）。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="de84fb848d7974c1538967d70a061f09d136e209" translate="yes" xml:space="preserve">
          <source>The built-in AngularJS directives show in their documentation page which type of matching they support.</source>
          <target state="translated">内置的AngularJS指令在其文档页中显示了它们支持的匹配类型。</target>
        </trans-unit>
        <trans-unit id="962a6ec28bdb795347091d826dbdec1364731a71" translate="yes" xml:space="preserve">
          <source>The built-in DOM manipulation directives, such as &lt;a href=&quot;../directive/ngif&quot;&gt;&lt;code&gt;ngIf&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../directive/ngswitch&quot;&gt;&lt;code&gt;ngSwitch&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../directive/ngrepeat&quot;&gt;&lt;code&gt;ngRepeat&lt;/code&gt;&lt;/a&gt; automatically destroy their transcluded clones as necessary so you do not need to worry about this if you are simply using &lt;a href=&quot;../directive/ngtransclude&quot;&gt;&lt;code&gt;ngTransclude&lt;/code&gt;&lt;/a&gt; to inject the transclusion into your directive.</source>
          <target state="translated">内置的DOM操作指令（例如&lt;a href=&quot;../directive/ngif&quot;&gt; &lt;code&gt;ngIf&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;../directive/ngswitch&quot;&gt; &lt;code&gt;ngSwitch&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../directive/ngrepeat&quot;&gt; &lt;code&gt;ngRepeat&lt;/code&gt; )会&lt;/a&gt;在必要时自动销毁其已被克隆的克隆，因此，如果您只是使用&lt;a href=&quot;../directive/ngtransclude&quot;&gt; &lt;code&gt;ngTransclude&lt;/code&gt; &lt;/a&gt;来将其包含在指令中，则无需担心。</target>
        </trans-unit>
        <trans-unit id="8d5255e53ef3607b163dc1dff9b5cf6c85ff7edd" translate="yes" xml:space="preserve">
          <source>The built-in filters &lt;a href=&quot;../filter/orderby&quot;&gt;orderBy&lt;/a&gt; and &lt;a href=&quot;../filter/filter&quot;&gt;filter&lt;/a&gt; do not work with objects, and will throw an error if used with one.</source>
          <target state="translated">内置的过滤器&lt;a href=&quot;../filter/orderby&quot;&gt;orderBy&lt;/a&gt;和&lt;a href=&quot;../filter/filter&quot;&gt;filter&lt;/a&gt;不适用于对象，如果与对象一起使用将引发错误。</target>
        </trans-unit>
        <trans-unit id="ff2c0fad2a4d5f40e3c8e45c0cb4b216d27b9103" translate="yes" xml:space="preserve">
          <source>The cache key is the request URL including search parameters; headers are not considered.</source>
          <target state="translated">缓存键是包括搜索参数在内的请求URL,不考虑头文件。</target>
        </trans-unit>
        <trans-unit id="e4616eff1fba05855b623c26f362604c6b703e08" translate="yes" xml:space="preserve">
          <source>The child elements of the &lt;code&gt;ngMessages&lt;/code&gt; directive are matched to the collection keys by a &lt;code&gt;ngMessage&lt;/code&gt; or &lt;code&gt;ngMessageExp&lt;/code&gt; directive. The value of these attributes must match a key in the collection that is provided by the &lt;code&gt;ngMessages&lt;/code&gt; directive.</source>
          <target state="translated">&lt;code&gt;ngMessages&lt;/code&gt; 指令的子元素通过 &lt;code&gt;ngMessage&lt;/code&gt; 或 &lt;code&gt;ngMessageExp&lt;/code&gt; 指令与集合键匹配。这些属性的值必须与 &lt;code&gt;ngMessages&lt;/code&gt; 指令提供的集合中的键匹配。</target>
        </trans-unit>
        <trans-unit id="5336897e60e004333ab19b29ea3db63cbe8dfa69" translate="yes" xml:space="preserve">
          <source>The className expression which will be checked against all animations</source>
          <target state="translated">将对所有动画进行检查的类名表达式。</target>
        </trans-unit>
        <trans-unit id="2c1b1a48a0af433b1673ea81113c3f7424fa7fcb" translate="yes" xml:space="preserve">
          <source>The className value that will be added to the element</source>
          <target state="translated">将被添加到元素中的className值。</target>
        </trans-unit>
        <trans-unit id="01da935870671cfe5daa21f385f055010d61e8c9" translate="yes" xml:space="preserve">
          <source>The className value that will be removed from the element</source>
          <target state="translated">从元素中删除的className值。</target>
        </trans-unit>
        <trans-unit id="4ee4fb39e9e5de140b856309f8187236336a4e7a" translate="yes" xml:space="preserve">
          <source>The collection (array or array-like object) to sort.</source>
          <target state="translated">要排序的集合(数组或类数组对象)。</target>
        </trans-unit>
        <trans-unit id="e22835faffad5508a02cb513445c12617c69ea54" translate="yes" xml:space="preserve">
          <source>The comparator function is used to sort the items, based on the derived values, types and indices.</source>
          <target state="translated">比较器函数用于根据派生值、类型和指数对项目进行排序。</target>
        </trans-unit>
        <trans-unit id="a43646046dc2a965f4d42e43008db64616266c7b" translate="yes" xml:space="preserve">
          <source>The comparator function used to determine the relative order of value pairs. If omitted, the built-in comparator will be used.</source>
          <target state="translated">比较器函数,用于确定值对的相对顺序。如果省略,将使用内置比较器。</target>
        </trans-unit>
        <trans-unit id="6baf3ab50c289d17bf3cfb5a4993fa32161e5046" translate="yes" xml:space="preserve">
          <source>The comparison is done using the &lt;code&gt;comparator&lt;/code&gt; function. If none is specified, a default, built-in comparator is used (see below for details - in a nutshell, it compares numbers numerically and strings alphabetically).</source>
          <target state="translated">使用 &lt;code&gt;comparator&lt;/code&gt; 功能进行比较。如果未指定，则使用默认的内置比较器（有关详细信息，请参见下文-简而言之，它比较数字和字母顺序的数字）。</target>
        </trans-unit>
        <trans-unit id="67bff779900ff80c2c3c68a68a6f55dc6ec358a9" translate="yes" xml:space="preserve">
          <source>The compilation is a process of walking the DOM tree and matching DOM elements to &lt;a href=&quot;../provider/%24compileprovider#directive.html&quot;&gt;directives&lt;/a&gt;.</source>
          <target state="translated">编译是遍历DOM树并将DOM元素与&lt;a href=&quot;../provider/%24compileprovider#directive.html&quot;&gt;指令&lt;/a&gt;匹配的过程。</target>
        </trans-unit>
        <trans-unit id="10e4998d3da4ae02bc4b02f740db293d195492a3" translate="yes" xml:space="preserve">
          <source>The compile function deals with transforming the template DOM. Since most directives do not do template transformation, it is not used often. The compile function takes the following arguments:</source>
          <target state="translated">编译函数处理的是模板DOM的转换。由于大多数指令不做模板转换,所以不经常使用。编译函数接受以下参数。</target>
        </trans-unit>
        <trans-unit id="e3ba37f0f20632b21daa2b1d0d783a59cb927a72" translate="yes" xml:space="preserve">
          <source>The compiler does not suspend the entire compilation to wait for templates to be loaded because this would result in the whole app &quot;stalling&quot; until all templates are loaded asynchronously - even in the case when only one deeply nested directive has &lt;code&gt;templateUrl&lt;/code&gt;.</source>
          <target state="translated">编译器不会暂停整个编译以等待模板被加载，因为这将导致整个应用&amp;ldquo;停顿&amp;rdquo;，直到异步加载所有模板，即使只有一个深层嵌套的指令具有 &lt;code&gt;templateUrl&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8325dd3ca7b9ffd07716c535f23b0e8400e6a2b0" translate="yes" xml:space="preserve">
          <source>The component can create the dependency, typically using the &lt;code&gt;new&lt;/code&gt; operator.</source>
          <target state="translated">该组件通常可以使用 &lt;code&gt;new&lt;/code&gt; 运算符来创建依赖关系。</target>
        </trans-unit>
        <trans-unit id="079e1d898e7f8138744541edc30b9716548afef5" translate="yes" xml:space="preserve">
          <source>The component can have the dependency passed to it where it is needed.</source>
          <target state="translated">组件可以在需要的地方有依赖性传递给它。</target>
        </trans-unit>
        <trans-unit id="6d494d536751a59fe5fb79ed0078239843fed4f8" translate="yes" xml:space="preserve">
          <source>The component can look up the dependency, by referring to a global variable.</source>
          <target state="translated">组件可以通过引用一个全局变量来查找依赖关系。</target>
        </trans-unit>
        <trans-unit id="ba1696b0ee510ce7b698742d313d7841389de75d" translate="yes" xml:space="preserve">
          <source>The configuration object. May only contain the options that need to be updated. Supported keys:</source>
          <target state="translated">配置对象。可能只包含需要更新的选项。支持的键。</target>
        </trans-unit>
        <trans-unit id="c0221af8fa9351901bedb66ce06849fb170fa5da" translate="yes" xml:space="preserve">
          <source>The constant value.</source>
          <target state="translated">的恒定值。</target>
        </trans-unit>
        <trans-unit id="21b4017fe5c763384985b8ae7689d4c632ed24d0" translate="yes" xml:space="preserve">
          <source>The context in which this value is safe for use, e.g. &lt;code&gt;$sce.URL&lt;/code&gt;, &lt;code&gt;$sce.RESOURCE_URL&lt;/code&gt;, &lt;code&gt;$sce.HTML&lt;/code&gt;, &lt;code&gt;$sce.JS&lt;/code&gt; or &lt;code&gt;$sce.CSS&lt;/code&gt;.</source>
          <target state="translated">该值可以安全使用的上下文，例如 &lt;code&gt;$sce.URL&lt;/code&gt; ， &lt;code&gt;$sce.RESOURCE_URL&lt;/code&gt; ， &lt;code&gt;$sce.HTML&lt;/code&gt; ， &lt;code&gt;$sce.JS&lt;/code&gt; 或 &lt;code&gt;$sce.CSS&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e02f32b11d4a96e094cc4cd481703dd1fae3a4d8" translate="yes" xml:space="preserve">
          <source>The context in which this value is to be used (such as &lt;code&gt;$sce.HTML&lt;/code&gt;).</source>
          <target state="translated">使用此值的上下文（例如 &lt;code&gt;$sce.HTML&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="b2a00503e1aada1817f217fc39da46317b85f521" translate="yes" xml:space="preserve">
          <source>The context in which this value is to be used.</source>
          <target state="translated">使用该值的上下文。</target>
        </trans-unit>
        <trans-unit id="527160a78c0a817c7ef349fdf9b2c7b8b40a0021" translate="yes" xml:space="preserve">
          <source>The contexts that can be sanitized are $sce.MEDIA_URL, $sce.URL and $sce.HTML. The first two are available by default, and the third one relies on the &lt;code&gt;$sanitize&lt;/code&gt; service (which may be loaded through the &lt;code&gt;ngSanitize&lt;/code&gt; module). Furthermore, for $sce.RESOURCE_URL context, a plain string may be accepted if the resource url policy defined by &lt;a href=&quot;../provider/%24scedelegateprovider#resourceUrlWhitelist.html&quot;&gt;&lt;code&gt;$sceDelegateProvider.resourceUrlWhitelist&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../provider/%24scedelegateprovider#resourceUrlBlacklist.html&quot;&gt;&lt;code&gt;$sceDelegateProvider.resourceUrlBlacklist&lt;/code&gt;&lt;/a&gt; accepts that resource.</source>
          <target state="translated">可以清理的上下文是$ sce.MEDIA_URL，$ sce.URL和$ sce.HTML。前两个默认情况下可用，第三个依赖 &lt;code&gt;$sanitize&lt;/code&gt; 服务（可以通过 &lt;code&gt;ngSanitize&lt;/code&gt; 模块加载）。此外，对于$ sce.RESOURCE_URL上下文，如果&lt;a href=&quot;../provider/%24scedelegateprovider#resourceUrlWhitelist.html&quot;&gt; &lt;code&gt;$sceDelegateProvider.resourceUrlWhitelist&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../provider/%24scedelegateprovider#resourceUrlBlacklist.html&quot;&gt; &lt;code&gt;$sceDelegateProvider.resourceUrlBlacklist&lt;/code&gt; &lt;/a&gt;定义的资源URL策略接受该资源，则可以接受纯字符串。</target>
        </trans-unit>
        <trans-unit id="f1ed1aa0329c6ec125f16d62f3f72745317d7c05" translate="yes" xml:space="preserve">
          <source>The control in this example updates by &quot;default&quot;, &quot;click&quot;, and &quot;blur&quot;, with different &lt;code&gt;debounce&lt;/code&gt; values. You can see that &quot;click&quot; doesn't have an individual &lt;code&gt;debounce&lt;/code&gt; value - therefore it uses the &lt;code&gt;*&lt;/code&gt; debounce value.</source>
          <target state="translated">本示例中的控件通过&amp;ldquo;默认&amp;rdquo;，&amp;ldquo;单击&amp;rdquo;和&amp;ldquo;模糊&amp;rdquo;更新，具有不同的 &lt;code&gt;debounce&lt;/code&gt; 值。您会看到&amp;ldquo;点击&amp;rdquo;没有单独的 &lt;code&gt;debounce&lt;/code&gt; 值-因此它使用 &lt;code&gt;*&lt;/code&gt; 去抖动值。</target>
        </trans-unit>
        <trans-unit id="abfb67eb59ab08df12629d4b3ef24f1ebe6f52a0" translate="yes" xml:space="preserve">
          <source>The control is considered valid only if value is entered.</source>
          <target state="translated">只有在输入值的情况下,该控件才被认为是有效的。</target>
        </trans-unit>
        <trans-unit id="fa321ff4c1ce8fe572062a8932217d90b3164a6f" translate="yes" xml:space="preserve">
          <source>The controller for the &lt;a href=&quot;../directive/select&quot;&gt;select&lt;/a&gt; directive. The controller exposes a few utility methods that can be used to augment the behavior of a regular or an &lt;a href=&quot;../directive/ngoptions&quot;&gt;ngOptions&lt;/a&gt; select element.</source>
          <target state="translated">&lt;a href=&quot;../directive/select&quot;&gt;select&lt;/a&gt;指令的控制器。控制器公开了一些实用程序方法，可用于增强常规或&lt;a href=&quot;../directive/ngoptions&quot;&gt;ngOptions&lt;/a&gt; select元素的行为。</target>
        </trans-unit>
        <trans-unit id="7009c81217bd6326e450d4c97f26dbfd83bc15a0" translate="yes" xml:space="preserve">
          <source>The controller for the &lt;a href=&quot;directive/select&quot;&gt;select&lt;/a&gt; directive. The controller exposes a few utility methods that can be used to augment the behavior of a regular or an &lt;a href=&quot;directive/ngoptions&quot;&gt;ngOptions&lt;/a&gt; select element.</source>
          <target state="translated">&lt;a href=&quot;directive/select&quot;&gt;select&lt;/a&gt;指令的控制器。控制器公开了一些实用程序方法，可用于增强常规或&lt;a href=&quot;directive/ngoptions&quot;&gt;ngOptions&lt;/a&gt; select元素的行为。</target>
        </trans-unit>
        <trans-unit id="498432a4da793f7e778133b7144b7aa9f4769cd3" translate="yes" xml:space="preserve">
          <source>The controller instance can be published into a scope property by specifying &lt;code&gt;ng-controller=&quot;as propertyName&quot;&lt;/code&gt;.</source>
          <target state="translated">通过指定 &lt;code&gt;ng-controller=&quot;as propertyName&quot;&lt;/code&gt; 可以将控制器实例发布到范围属性中。</target>
        </trans-unit>
        <trans-unit id="d8ae95787b8cec655ad357bed40a98949c9101e8" translate="yes" xml:space="preserve">
          <source>The controller whose validity state is triggering the change.</source>
          <target state="translated">有效性状态触发变化的控制器。</target>
        </trans-unit>
        <trans-unit id="5e5b86677d2c9438f2a6d9bb85589a00354fcb67" translate="yes" xml:space="preserve">
          <source>The controls can be accessed normally, but adding to, or removing controls from the array has no effect on the form. Instead, use &lt;a href=&quot;form.formcontroller#%24addControl.html&quot;&gt;&lt;code&gt;$addControl()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;form.formcontroller#%24removeControl.html&quot;&gt;&lt;code&gt;$removeControl()&lt;/code&gt;&lt;/a&gt; for this use-case. Likewise, adding a control to, or removing a control from the form is not reflected in the shallow copy. That means you should get a fresh copy from &lt;code&gt;$getControls()&lt;/code&gt; every time you need access to the controls.</source>
          <target state="translated">可以正常访问控件，但是添加到数组中或从数组中删除控件对表单没有影响。而是在此用例中使用&lt;a href=&quot;form.formcontroller#%24addControl.html&quot;&gt; &lt;code&gt;$addControl()&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;form.formcontroller#%24removeControl.html&quot;&gt; &lt;code&gt;$removeControl()&lt;/code&gt; &lt;/a&gt;。同样，在表单中添加控件或从表单中删除控件也不会反映在浅表副本中。这意味着，每次需要访问控件时，都应该从 &lt;code&gt;$getControls()&lt;/code&gt; 获取一个新副本。</target>
        </trans-unit>
        <trans-unit id="90313e345675668509c608402c284aebafe8c90b" translate="yes" xml:space="preserve">
          <source>The copy or updated &lt;code&gt;destination&lt;/code&gt;, if &lt;code&gt;destination&lt;/code&gt; was specified.</source>
          <target state="translated">复制或更新的 &lt;code&gt;destination&lt;/code&gt; （如果指定了 &lt;code&gt;destination&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="2ced3c50f80c61d3e28cb231ba0b8420428955dc" translate="yes" xml:space="preserve">
          <source>The correct way to write it:</source>
          <target state="translated">正确的写法。</target>
        </trans-unit>
        <trans-unit id="8375ae9af024014319d46b0caa7eb954a5fa2f4b" translate="yes" xml:space="preserve">
          <source>The current CSS className expression value. If null then there is no expression value</source>
          <target state="translated">当前CSS className表达式的值。如果为空,则没有表达式值。</target>
        </trans-unit>
        <trans-unit id="4382786c94714f27b89613774f7c4bebd55f76e9" translate="yes" xml:space="preserve">
          <source>The current CSS className value</source>
          <target state="translated">当前的CSS className值</target>
        </trans-unit>
        <trans-unit id="c0b92d2699b7faed501975cc1cf13d3e78b33478" translate="yes" xml:space="preserve">
          <source>The current default is 10 iterations.</source>
          <target state="translated">目前的默认值是10次迭代。</target>
        </trans-unit>
        <trans-unit id="7aedd08ef47f8be2668af8dd80fb24b7ee28cfe2" translate="yes" xml:space="preserve">
          <source>The current filter function or &lt;code&gt;null&lt;/code&gt; if there is none set.</source>
          <target state="translated">当前过滤器函数；如果未设置，则为 &lt;code&gt;null&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="66a28e07fb4d893df0b667def66654991100a49e" translate="yes" xml:space="preserve">
          <source>The current info object for this module if called as a getter, or &lt;code&gt;this&lt;/code&gt; if called as a setter.</source>
          <target state="translated">此模块的电流信息对象，如果被称为一个getter，或者 &lt;code&gt;this&lt;/code&gt; 是否称为二传手。</target>
        </trans-unit>
        <trans-unit id="9a9d02cc8cc112d35feadb1312a2714232a47ad3" translate="yes" xml:space="preserve">
          <source>The current scope is excluded from the count. The count includes all isolate child scopes.</source>
          <target state="translated">当前作用域不包括在计数中。该计数包括所有孤立的子作用域。</target>
        </trans-unit>
        <trans-unit id="a3ef084525022e52ff91e7bc6b6be1d8ef3c412b" translate="yes" xml:space="preserve">
          <source>The current value of the &lt;code&gt;eagerInstantiationEnabled&lt;/code&gt; flag if used as a getter or itself (for chaining) if used as a setter.</source>
          <target state="translated">&lt;code&gt;eagerInstantiationEnabled&lt;/code&gt; 标志的当前值（如果用作获取器）或本身（用于链接）（如果用作设置器）。</target>
        </trans-unit>
        <trans-unit id="3c55e9fab58239a31ab41674e07793cb9edc1d92" translate="yes" xml:space="preserve">
          <source>The currently set blacklist array.</source>
          <target state="translated">当前设置的黑名单数组。</target>
        </trans-unit>
        <trans-unit id="9b8df1933a459dcfe4c11ef0936f54fd838b71b8" translate="yes" xml:space="preserve">
          <source>The currently set whitelist array.</source>
          <target state="translated">当前设置的白名单数组。</target>
        </trans-unit>
        <trans-unit id="8c2f3e1e231bfffe01f6a171d21c8de2da159f70" translate="yes" xml:space="preserve">
          <source>The custom &lt;code&gt;redirectTo&lt;/code&gt; function is expected to return a string which will be used to update &lt;code&gt;$location.url()&lt;/code&gt;. If the function throws an error, no further processing will take place and the &lt;a href=&quot;../service/%24route#%24routeChangeError.html&quot;&gt;$routeChangeError&lt;/a&gt; event will be fired.</source>
          <target state="translated">自定义 &lt;code&gt;redirectTo&lt;/code&gt; 函数应返回一个字符串，该字符串将用于更新 &lt;code&gt;$location.url()&lt;/code&gt; 。如果函数抛出错误，则不会进行进一步处理，并且会触发&lt;a href=&quot;../service/%24route#%24routeChangeError.html&quot;&gt;$ routeChangeError&lt;/a&gt;事件。</target>
        </trans-unit>
        <trans-unit id="517928a1a0c975c35a5f6371b16dbf98f8e18922" translate="yes" xml:space="preserve">
          <source>The custom start and end points for ngRepeat also support all other HTML directive syntax flavors provided in AngularJS (such as &lt;strong&gt;data-ng-repeat-start&lt;/strong&gt;, &lt;strong&gt;x-ng-repeat-start&lt;/strong&gt; and &lt;strong&gt;ng:repeat-start&lt;/strong&gt;).</source>
          <target state="translated">ngRepeat的自定义起点和终点还支持AngularJS中提供的所有其他HTML指令语法风格（例如&lt;strong&gt;data-ng-repeat-start&lt;/strong&gt;，&lt;strong&gt;x-ng-repeat-start&lt;/strong&gt;和&lt;strong&gt;ng：repeat-start&lt;/strong&gt;）。</target>
        </trans-unit>
        <trans-unit id="6cf9ca1b48f086d137d2fcb4ce7667c3b44ff3ed" translate="yes" xml:space="preserve">
          <source>The debugger allows you to access the currently selected element in the console as &lt;code&gt;$0&lt;/code&gt; variable.</source>
          <target state="translated">调试器允许您将控制台中当前选定的元素作为 &lt;code&gt;$0&lt;/code&gt; 变量进行访问。</target>
        </trans-unit>
        <trans-unit id="3082e7b0af57ed1e4eff6c089ae1878d3da1901b" translate="yes" xml:space="preserve">
          <source>The declaration should be created in the format of &lt;a href=&quot;../../ng/service/%24http#usage.html&quot;&gt;$http.config&lt;/a&gt;:</source>
          <target state="translated">声明应以&lt;a href=&quot;../../ng/service/%24http#usage.html&quot;&gt;$ http.config&lt;/a&gt;格式创建：</target>
        </trans-unit>
        <trans-unit id="d28f0c2f0f5b42bd7a8d61c72d07ab41bac315ed" translate="yes" xml:space="preserve">
          <source>The declarative process is easier to understand.</source>
          <target state="translated">声明式的过程比较容易理解。</target>
        </trans-unit>
        <trans-unit id="c0cfb0f1a7c425f909fe0bc36aa9ca3838fbff7c" translate="yes" xml:space="preserve">
          <source>The default &lt;code&gt;$isEmpty&lt;/code&gt; function checks whether the value is &lt;code&gt;undefined&lt;/code&gt;, &lt;code&gt;''&lt;/code&gt;, &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;NaN&lt;/code&gt;.</source>
          <target state="translated">默认的 &lt;code&gt;$isEmpty&lt;/code&gt; 函数检查该值是 &lt;code&gt;undefined&lt;/code&gt; ， &lt;code&gt;''&lt;/code&gt; ， &lt;code&gt;null&lt;/code&gt; 还是 &lt;code&gt;NaN&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6418bf8b84a736c531737d93d5eebd5e4c6bf159" translate="yes" xml:space="preserve">
          <source>The default CSS for &lt;code&gt;ngHide&lt;/code&gt;, the inverse method to &lt;code&gt;ngShow&lt;/code&gt;, makes ngAria redundant. It toggles &lt;code&gt;aria-hidden&lt;/code&gt; on the directive when it is hidden or shown, but the content is already hidden with &lt;code&gt;display: none&lt;/code&gt;. See explanation for &lt;a href=&quot;accessibility#ngshow.html&quot;&gt;ngShow&lt;/a&gt; when overriding the default CSS.</source>
          <target state="translated">默认CSS &lt;code&gt;ngHide&lt;/code&gt; ，逆方法 &lt;code&gt;ngShow&lt;/code&gt; ，使得ngAria冗余。当隐藏或显示指令时，它会在指令上切换 &lt;code&gt;aria-hidden&lt;/code&gt; ，但其内容已通过 &lt;code&gt;display: none&lt;/code&gt; 隐藏。覆盖默认CSS时，请参见&lt;a href=&quot;accessibility#ngshow.html&quot;&gt;ngShow的&lt;/a&gt;说明。</target>
        </trans-unit>
        <trans-unit id="58168ad0626f3db21d1a561fbfb468e194ad0a4e" translate="yes" xml:space="preserve">
          <source>The default actions are:</source>
          <target state="translated">默认动作是:</target>
        </trans-unit>
        <trans-unit id="165f67c4b986077c141a0b4eb8be5a4d57bb86e9" translate="yes" xml:space="preserve">
          <source>The default behaviour in &lt;code&gt;ngModel&lt;/code&gt; is that the model value is set to &lt;code&gt;undefined&lt;/code&gt; when the validation determines that the value is invalid. By setting the &lt;code&gt;allowInvalid&lt;/code&gt; property to true, the model will still be updated even if the value is invalid.</source>
          <target state="translated">&lt;code&gt;ngModel&lt;/code&gt; 中的默认行为是，当验证确定该值无效时，将模型值设置为 &lt;code&gt;undefined&lt;/code&gt; 。通过将 &lt;code&gt;allowInvalid&lt;/code&gt; 属性设置为true，即使值无效，模型仍将更新。</target>
        </trans-unit>
        <trans-unit id="f996c0e32ed6964a734c9d13e1970793b933d9c8" translate="yes" xml:space="preserve">
          <source>The default cache value can be set by updating the &lt;a href=&quot;%24http#defaults.html&quot;&gt;&lt;code&gt;$http.defaults.cache&lt;/code&gt;&lt;/a&gt; property or the &lt;a href=&quot;../provider/%24httpprovider#defaults.html&quot;&gt;&lt;code&gt;$httpProvider.defaults.cache&lt;/code&gt;&lt;/a&gt; property.</source>
          <target state="translated">可以通过更新&lt;a href=&quot;%24http#defaults.html&quot;&gt; &lt;code&gt;$http.defaults.cache&lt;/code&gt; &lt;/a&gt;属性或&lt;a href=&quot;../provider/%24httpprovider#defaults.html&quot;&gt; &lt;code&gt;$httpProvider.defaults.cache&lt;/code&gt; &lt;/a&gt;属性来设置默认缓存值。</target>
        </trans-unit>
        <trans-unit id="a306ec119f2eaccbe8d649fada9aaf660ff1448f" translate="yes" xml:space="preserve">
          <source>The default comparator</source>
          <target state="translated">默认比较器</target>
        </trans-unit>
        <trans-unit id="465c73e00ec2667af675d53734d888ec91f718c7" translate="yes" xml:space="preserve">
          <source>The default instance of &lt;code&gt;$sceDelegate&lt;/code&gt; should work out of the box with little pain. While you can override it completely to change the behavior of &lt;code&gt;$sce&lt;/code&gt;, the common case would involve configuring the &lt;a href=&quot;../provider/%24scedelegateprovider&quot;&gt;$sceDelegateProvider&lt;/a&gt; instead by setting your own whitelists and blacklists for trusting URLs used for loading AngularJS resources such as templates. Refer &lt;a href=&quot;../provider/%24scedelegateprovider#resourceUrlWhitelist.html&quot;&gt;$sceDelegateProvider.resourceUrlWhitelist&lt;/a&gt; and &lt;a href=&quot;../provider/%24scedelegateprovider#resourceUrlBlacklist.html&quot;&gt;$sceDelegateProvider.resourceUrlBlacklist&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;$sceDelegate&lt;/code&gt; 的默认实例应该可以轻松使用。虽然您可以完全覆盖它来更改 &lt;code&gt;$sce&lt;/code&gt; 的行为，但常见的情况是配置&lt;a href=&quot;../provider/%24scedelegateprovider&quot;&gt;$ sceDelegateProvider，&lt;/a&gt;而不是通过设置自己的白名单和黑名单来信任用于加载AngularJS资源（例如模板）的URL。请参考&lt;a href=&quot;../provider/%24scedelegateprovider#resourceUrlWhitelist.html&quot;&gt;$ sceDelegateProvider.resourceUrlWhitelist&lt;/a&gt;和&lt;a href=&quot;../provider/%24scedelegateprovider#resourceUrlBlacklist.html&quot;&gt;$ sceDelegateProvider.resourceUrlBlacklist&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3fe33aadf3de1f1f3b0fe8806c8376a4a04f5ea1" translate="yes" xml:space="preserve">
          <source>The default is to log &lt;code&gt;debug&lt;/code&gt; messages. You can use &lt;a href=&quot;../provider/%24logprovider&quot;&gt;ng.$logProvider#debugEnabled&lt;/a&gt; to change this.</source>
          <target state="translated">默认为记录 &lt;code&gt;debug&lt;/code&gt; 消息。您可以使用&lt;a href=&quot;../provider/%24logprovider&quot;&gt;ng。$ logProvider＃debugEnabled&lt;/a&gt;进行更改。</target>
        </trans-unit>
        <trans-unit id="04bb80a0e51b2e3fa92fe97b18ff2c753c1617a0" translate="yes" xml:space="preserve">
          <source>The default value for the prefix is &lt;code&gt;'!'&lt;/code&gt;.</source>
          <target state="translated">前缀的默认值为 &lt;code&gt;'!'&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5bced592a048c4e28bc51dd718accfdb3fc3710b" translate="yes" xml:space="preserve">
          <source>The default value is false.</source>
          <target state="translated">默认值为假。</target>
        </trans-unit>
        <trans-unit id="d93c5aa93414c0c9151cab4bbeb573041c98a22c" translate="yes" xml:space="preserve">
          <source>The default value is true.</source>
          <target state="translated">默认值为 &quot;true&quot;。</target>
        </trans-unit>
        <trans-unit id="1d4e6cb0347f97a10e0bfcabf516d77b15974d7c" translate="yes" xml:space="preserve">
          <source>The default values satisfy a wide range of usecases, but you may choose to overwrite any of them to further customize your instances. The available properties are:</source>
          <target state="translated">默认值满足了广泛的使用情况,但你可以选择覆盖其中的任何一个,以进一步定制你的实例。可用的属性有:</target>
        </trans-unit>
        <trans-unit id="8d058a405d150881e8c02cef5a763d1a9cac9129" translate="yes" xml:space="preserve">
          <source>The default, built-in comparator should be sufficient for most usecases. In short, it compares numbers numerically, strings alphabetically (and case-insensitively), for objects falls back to using their index in the original collection, sorts values of different types by type and puts &lt;code&gt;undefined&lt;/code&gt; and &lt;code&gt;null&lt;/code&gt; values at the end of the sorted list.</source>
          <target state="translated">对于大多数用例，默认的内置比较器应该足够了。简而言之，它以数字方式对数字进行比较，以字母顺序（且不区分大小写）对字符串进行比较，因为对象会退回到使用其原始集合中的索引的位置，按类型对不同类型的值进行排序，并将 &lt;code&gt;undefined&lt;/code&gt; 和 &lt;code&gt;null&lt;/code&gt; 值放在排序列表的末尾。</target>
        </trans-unit>
        <trans-unit id="f8a104f5d8a2055e932927787187ea1605cde61f" translate="yes" xml:space="preserve">
          <source>The defaults can also be set at runtime via the &lt;code&gt;$http.defaults&lt;/code&gt; object in the same fashion. For example:</source>
          <target state="translated">也可以在运行时通过 &lt;code&gt;$http.defaults&lt;/code&gt; 对象以相同的方式设置默认值。例如：</target>
        </trans-unit>
        <trans-unit id="a63d9c4d9deff7d05bd9e7b756db067981e19e91" translate="yes" xml:space="preserve">
          <source>The diagram and the example below describe how AngularJS interacts with the browser's event loop.</source>
          <target state="translated">下面的图和示例描述了AngularJS如何与浏览器的事件循环交互。</target>
        </trans-unit>
        <trans-unit id="5985a11da86b3a9b2c8dd516c741a69a00b22550" translate="yes" xml:space="preserve">
          <source>The difference between Compile and Link</source>
          <target state="translated">编译和链接的区别</target>
        </trans-unit>
        <trans-unit id="282c0e17a8f643432cf46d1ac582e22bfd94be70" translate="yes" xml:space="preserve">
          <source>The difference resides in the return value of the factory function. You can either return a &lt;a href=&quot;%24compile#directive-definition-object.html&quot;&gt;Directive Definition Object (see below)&lt;/a&gt; that defines the directive properties, or just the &lt;code&gt;postLink&lt;/code&gt; function (all other properties will have the default values).</source>
          <target state="translated">区别在于工厂函数的返回值。您可以返回定义指令属性的&lt;a href=&quot;%24compile#directive-definition-object.html&quot;&gt;指令定义对象（如下所示）&lt;/a&gt;，也可以返回 &lt;code&gt;postLink&lt;/code&gt; 函数（所有其他属性将具有默认值）。</target>
        </trans-unit>
        <trans-unit id="9dd111b228d3d65fff5c43c5f7db648c685d4fa3" translate="yes" xml:space="preserve">
          <source>The directive can be applied to the &lt;code&gt;&amp;lt;body&amp;gt;&lt;/code&gt; element, but the preferred usage is to apply multiple &lt;code&gt;ngCloak&lt;/code&gt; directives to small portions of the page to permit progressive rendering of the browser view.</source>
          <target state="translated">该指令可以应用于 &lt;code&gt;&amp;lt;body&amp;gt;&lt;/code&gt; 元素，但是首选用法是将多个 &lt;code&gt;ngCloak&lt;/code&gt; 指令应用于页面的一小部分，以允许逐步呈现浏览器视图。</target>
        </trans-unit>
        <trans-unit id="73b6dab32084cac10b23ad24d2acde7b9e588021" translate="yes" xml:space="preserve">
          <source>The directive definition object provides instructions to the &lt;a href=&quot;%24compile&quot;&gt;compiler&lt;/a&gt;. The attributes are:</source>
          <target state="translated">指令定义对象向&lt;a href=&quot;%24compile&quot;&gt;编译器&lt;/a&gt;提供指令。这些属性是：</target>
        </trans-unit>
        <trans-unit id="15084cf390b2739682db07ef53f0e5ed0841df53" translate="yes" xml:space="preserve">
          <source>The directive itself works similar to ngInclude, however, instead of downloading template code (or loading it from the template cache), &lt;code&gt;ngSwitch&lt;/code&gt; simply chooses one of the nested elements and makes it visible based on which element matches the value obtained from the evaluated expression. In other words, you define a container element (where you place the directive), place an expression on the &lt;strong&gt;&lt;code&gt;on=&quot;...&quot;&lt;/code&gt; attribute&lt;/strong&gt; (or the &lt;strong&gt;&lt;code&gt;ng-switch=&quot;...&quot;&lt;/code&gt; attribute&lt;/strong&gt;), define any inner elements inside of the directive and place a when attribute per element. The when attribute is used to inform ngSwitch which element to display when the on expression is evaluated. If a matching expression is not found via a when attribute then an element with the default attribute is displayed.</source>
          <target state="translated">该指令本身的工作原理类似于ngInclude，但是，而不是下载模板代码（或从模板缓存加载它）， &lt;code&gt;ngSwitch&lt;/code&gt; 简单地选择嵌套元件中的一个，并使其可见根据其元件从所评估的表达式获得的值相匹配。换句话说，您定义一个容器元素（放置指令的位置），在&lt;strong&gt; &lt;code&gt;on=&quot;...&quot;&lt;/code&gt; 属性&lt;/strong&gt;（或&lt;strong&gt; &lt;code&gt;ng-switch=&quot;...&quot;&lt;/code&gt; &lt;/strong&gt;&lt;strong&gt;属性&lt;/strong&gt;）上放置一个表达式&lt;strong&gt;&lt;/strong&gt;），在指令内部定义任何内部元素，并为每个元素放置when属性。when属性用于通知ngSwitch在评估on表达式时显示哪个元素。如果通过when属性未找到匹配的表达式，则显示具有默认属性的元素。</target>
        </trans-unit>
        <trans-unit id="bc305a9daf06fb29b927a141c769f1857bf13fe7" translate="yes" xml:space="preserve">
          <source>The directive operates in three different ways, depending on which of three types the expression evaluates to:</source>
          <target state="translated">该指令有三种不同的操作方式,取决于表达式所评估的三种类型中的哪一种。</target>
        </trans-unit>
        <trans-unit id="00457ef4c0d1bfc1d66159cc11032117ca66eb2f" translate="yes" xml:space="preserve">
          <source>The directive sets the &lt;code&gt;required&lt;/code&gt; attribute on the element if the AngularJS expression inside &lt;code&gt;ngRequired&lt;/code&gt; evaluates to true. A special directive for setting &lt;code&gt;required&lt;/code&gt; is necessary because we cannot use interpolation inside &lt;code&gt;required&lt;/code&gt;. See the &lt;a href=&quot;../../../guide/interpolation&quot;&gt;interpolation guide&lt;/a&gt; for more info.</source>
          <target state="translated">如果 &lt;code&gt;ngRequired&lt;/code&gt; 中的AngularJS表达式的值为true ，则指令将在元素上设置 &lt;code&gt;required&lt;/code&gt; 属性。必须使用一个特殊的指令来设置 &lt;code&gt;required&lt;/code&gt; ，因为我们不能在 &lt;code&gt;required&lt;/code&gt; 内部使用插值。有关更多信息，请参见&lt;a href=&quot;../../../guide/interpolation&quot;&gt;插值指南&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="511cc4dca94e3becdfd05d6159bf6c72e0c27b2a" translate="yes" xml:space="preserve">
          <source>The directive that identifies where the &lt;a href=&quot;../type/router&quot;&gt;&lt;code&gt;Router&lt;/code&gt;&lt;/a&gt; should render its &lt;strong&gt;Components&lt;/strong&gt;.</source>
          <target state="translated">指示&lt;a href=&quot;../type/router&quot;&gt; &lt;code&gt;Router&lt;/code&gt; &lt;/a&gt;应在何处呈现其&lt;strong&gt;Components&lt;/strong&gt;的指令。</target>
        </trans-unit>
        <trans-unit id="a19715b5a8ea141e59e2b3d389be6963e887a773" translate="yes" xml:space="preserve">
          <source>The directive that identifies where the &lt;a href=&quot;ngcomponentrouter/type/router&quot;&gt;&lt;code&gt;Router&lt;/code&gt;&lt;/a&gt; should render its &lt;strong&gt;Components&lt;/strong&gt;.</source>
          <target state="translated">指示&lt;a href=&quot;ngcomponentrouter/type/router&quot;&gt; &lt;code&gt;Router&lt;/code&gt; &lt;/a&gt;应在何处呈现其&lt;strong&gt;Components&lt;/strong&gt;的指令。</target>
        </trans-unit>
        <trans-unit id="91b3106d7e0128b073f59400b2d855bf5dc85ef6" translate="yes" xml:space="preserve">
          <source>The directive that identifies where the &lt;a href=&quot;type/router&quot;&gt;&lt;code&gt;Router&lt;/code&gt;&lt;/a&gt; should render its &lt;strong&gt;Components&lt;/strong&gt;.</source>
          <target state="translated">指示&lt;a href=&quot;type/router&quot;&gt; &lt;code&gt;Router&lt;/code&gt; &lt;/a&gt;应在何处呈现其&lt;strong&gt;Components&lt;/strong&gt;的指令。</target>
        </trans-unit>
        <trans-unit id="f8e427fdf8b7a0e2bc769988a131cb6027a72d85" translate="yes" xml:space="preserve">
          <source>The directive won't add duplicate classes if a particular class was already set.</source>
          <target state="translated">如果已经设置了特定的类,该指令将不会增加重复的类。</target>
        </trans-unit>
        <trans-unit id="af273d442182f77e2838bf78efeac232e7701baf" translate="yes" xml:space="preserve">
          <source>The easiest way to reference the control's &lt;a href=&quot;../type/ngmodel.ngmodelcontroller#%24rollbackViewValue.html&quot;&gt;&lt;code&gt;ngModel.NgModelController&lt;/code&gt;&lt;/a&gt; method is by making sure the input is placed inside a form that has a &lt;code&gt;name&lt;/code&gt; attribute. This is important because &lt;code&gt;form&lt;/code&gt; controllers are published to the related scope under the name in their &lt;code&gt;name&lt;/code&gt; attribute.</source>
          <target state="translated">引用控件的&lt;a href=&quot;../type/ngmodel.ngmodelcontroller#%24rollbackViewValue.html&quot;&gt; &lt;code&gt;ngModel.NgModelController&lt;/code&gt; &lt;/a&gt;方法的最简单方法是确保输入放置在具有 &lt;code&gt;name&lt;/code&gt; 属性的表单内。这很重要，因为 &lt;code&gt;form&lt;/code&gt; 控制器是在其 &lt;code&gt;name&lt;/code&gt; 属性中的名称下发布到相关范围的。</target>
        </trans-unit>
        <trans-unit id="b2fa37ba708729a70880e839aacbcf83f7ee4ecc" translate="yes" xml:space="preserve">
          <source>The easiest way to unit-test a component controller is by using the &lt;a href=&quot;../api/ngmock/service/%24componentcontroller&quot;&gt;$componentController&lt;/a&gt; that is included in &lt;a href=&quot;../api/ngmock&quot;&gt;&lt;code&gt;ngMock&lt;/code&gt;&lt;/a&gt;. The advantage of this method is that you do not have to create any DOM elements. The following example shows how to do this for the &lt;code&gt;heroDetail&lt;/code&gt; component from above.</source>
          <target state="translated">对组件控制器进行单元测试的最简单方法是使用&lt;a href=&quot;../api/ngmock&quot;&gt; &lt;code&gt;ngMock&lt;/code&gt; 中&lt;/a&gt;包含的&lt;a href=&quot;../api/ngmock/service/%24componentcontroller&quot;&gt;$ componentController&lt;/a&gt;。此方法的优点是您不必创建任何DOM元素。以下示例从上方显示了如何对 &lt;code&gt;heroDetail&lt;/code&gt; 组件执行此操作。</target>
        </trans-unit>
        <trans-unit id="1dba15ddc68176129beff67ce23ae391d8f5e9b2" translate="yes" xml:space="preserve">
          <source>The element is shown or hidden by removing or adding the &lt;code&gt;.ng-hide&lt;/code&gt; CSS class onto the element. The &lt;code&gt;.ng-hide&lt;/code&gt; CSS class is predefined in AngularJS and sets the display style to none (using an &lt;code&gt;!important&lt;/code&gt; flag). For CSP mode please add &lt;code&gt;angular-csp.css&lt;/code&gt; to your HTML file (see &lt;a href=&quot;ngcsp&quot;&gt;ngCsp&lt;/a&gt;).</source>
          <target state="translated">通过删除 &lt;code&gt;.ng-hide&lt;/code&gt; CSS类到该元素上，可以显示或隐藏该元素。该 &lt;code&gt;.ng-hide&lt;/code&gt; CSS类在AngularJS预先定义并设置显示风格为none（使用 &lt;code&gt;!important&lt;/code&gt; 标志）。对于CSP模式，请在您的HTML文件中添加 &lt;code&gt;angular-csp.css&lt;/code&gt; （请参阅&lt;a href=&quot;ngcsp&quot;&gt;ngCsp&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="7ccfb7caa29243ea5f83ef0ab8642feaa5add93c" translate="yes" xml:space="preserve">
          <source>The element name or '*' to match any element.</source>
          <target state="translated">元素名称或'*'来匹配任何元素。</target>
        </trans-unit>
        <trans-unit id="d6f6332d7faa347a9930f464a7c8e2d5542086d4" translate="yes" xml:space="preserve">
          <source>The empty array in &lt;code&gt;angular.module('myApp', [])&lt;/code&gt;. This array is the list of modules &lt;code&gt;myApp&lt;/code&gt; depends on.</source>
          <target state="translated">&lt;code&gt;angular.module('myApp', [])&lt;/code&gt; 的空数组。此数组是 &lt;code&gt;myApp&lt;/code&gt; 所依赖的模块的列表。</target>
        </trans-unit>
        <trans-unit id="7bc9a115378ed99db9c2142b56d9fc3aa535767e" translate="yes" xml:space="preserve">
          <source>The enter and leave animation occur concurrently.</source>
          <target state="translated">进入和离开的动画同时发生。</target>
        </trans-unit>
        <trans-unit id="b13d56ee0aa77bc8cf191a0098e0ae12681eb3cb" translate="yes" xml:space="preserve">
          <source>The event life cycle starts at the scope on which &lt;code&gt;$broadcast&lt;/code&gt; was called. All &lt;a href=&quot;%24rootscope.scope#%24on.html&quot;&gt;listeners&lt;/a&gt; listening for &lt;code&gt;name&lt;/code&gt; event on this scope get notified. Afterwards, the event propagates to all direct and indirect scopes of the current scope and calls all registered listeners along the way. The event cannot be canceled.</source>
          <target state="translated">事件生命周期始于调用 &lt;code&gt;$broadcast&lt;/code&gt; 的范围。所有&lt;a href=&quot;%24rootscope.scope#%24on.html&quot;&gt;听众&lt;/a&gt;收听 &lt;code&gt;name&lt;/code&gt; 在此范围内的事件得到通知。然后，事件传播到当前作用域的所有直接和间接作用域，并在此过程中调用所有已注册的侦听器。该事件无法取消。</target>
        </trans-unit>
        <trans-unit id="ef1ec4f5065965f767cdb19361d488e339b8e865" translate="yes" xml:space="preserve">
          <source>The event life cycle starts at the scope on which &lt;code&gt;$emit&lt;/code&gt; was called. All &lt;a href=&quot;%24rootscope.scope#%24on.html&quot;&gt;listeners&lt;/a&gt; listening for &lt;code&gt;name&lt;/code&gt; event on this scope get notified. Afterwards, the event traverses upwards toward the root scope and calls all registered listeners along the way. The event will stop propagating if one of the listeners cancels it.</source>
          <target state="translated">事件生命周期始于调用 &lt;code&gt;$emit&lt;/code&gt; 的范围。所有&lt;a href=&quot;%24rootscope.scope#%24on.html&quot;&gt;听众&lt;/a&gt;收听 &lt;code&gt;name&lt;/code&gt; 在此范围内的事件得到通知。然后，事件向上遍历到根作用域，并在此过程中调用所有已注册的侦听器。如果其中一个侦听器取消了该事件，则该事件将停止传播。</target>
        </trans-unit>
        <trans-unit id="9dba21cdf767393b24f9c532ed6d7024629e7654" translate="yes" xml:space="preserve">
          <source>The event listener function format is: &lt;code&gt;function(event, args...)&lt;/code&gt;. The &lt;code&gt;event&lt;/code&gt; object passed into the listener has the following attributes:</source>
          <target state="translated">事件侦听器函数格式为： &lt;code&gt;function(event, args...)&lt;/code&gt; 。传递给侦听器的 &lt;code&gt;event&lt;/code&gt; 对象具有以下属性：</target>
        </trans-unit>
        <trans-unit id="a9dc8aea8f492b469f1f28002083ced0171b9068" translate="yes" xml:space="preserve">
          <source>The event's callback gets executed. This enters the JavaScript context. The callback can modify the DOM structure.</source>
          <target state="translated">事件的回调被执行。这就进入了JavaScript上下文。回调可以修改DOM结构。</target>
        </trans-unit>
        <trans-unit id="e6d577c1df19a49c4d3d3fea271e11112de46dcd" translate="yes" xml:space="preserve">
          <source>The example above also contains a &lt;a href=&quot;filter&quot;&gt;filter&lt;/a&gt;. A filter formats the value of an expression for display to the user. In the example above, the filter &lt;a href=&quot;../api/ng/filter/currency&quot;&gt;&lt;code&gt;currency&lt;/code&gt;&lt;/a&gt; formats a number into an output that looks like money.</source>
          <target state="translated">上面的示例还包含一个&lt;a href=&quot;filter&quot;&gt;过滤器&lt;/a&gt;。过滤器格式化表达式的值以显示给用户。在上面的示例中，过滤&lt;a href=&quot;../api/ng/filter/currency&quot;&gt; &lt;code&gt;currency&lt;/code&gt; &lt;/a&gt;将数字格式化为看起来像货币的输出。</target>
        </trans-unit>
        <trans-unit id="93c49d25f095d6630edee2c4ee7687214904ed84" translate="yes" xml:space="preserve">
          <source>The example above sets up a transition for both the in and out phases, but we can also target the out or in phases directly via &lt;code&gt;ng-anchor-out&lt;/code&gt; and &lt;code&gt;ng-anchor-in&lt;/code&gt;.</source>
          <target state="translated">上面的示例为in和out阶段设置了过渡，但是我们也可以直接通过 &lt;code&gt;ng-anchor-out&lt;/code&gt; 和 &lt;code&gt;ng-anchor-in&lt;/code&gt; 来针对out或in阶段。</target>
        </trans-unit>
        <trans-unit id="ae348e668faf38c45aa29b06f0b38359e62a7332" translate="yes" xml:space="preserve">
          <source>The example also shows the &quot;offset&quot; keyword, which allows you to offset the value of the &quot;#&quot; variable.</source>
          <target state="translated">这个例子还显示了 &quot;offset &quot;关键字,它允许你偏移 &quot;#&quot;变量的值。</target>
        </trans-unit>
        <trans-unit id="dcef32a0c9e7e773d2caa1d0facc04649077955b" translate="yes" xml:space="preserve">
          <source>The example below demonstrates a simple &lt;a href=&quot;../directive/ngrepeat&quot;&gt;ngRepeat&lt;/a&gt;, where the data is sorted by age in descending order (expression is set to &lt;code&gt;'-age'&lt;/code&gt;). The &lt;code&gt;comparator&lt;/code&gt; is not set, which means it defaults to the built-in comparator.</source>
          <target state="translated">下面的示例演示了一个简单的&lt;a href=&quot;../directive/ngrepeat&quot;&gt;ngRepeat&lt;/a&gt;，其中数据按年龄降序排序（表达式设置为 &lt;code&gt;'-age'&lt;/code&gt; ）。所述 &lt;code&gt;comparator&lt;/code&gt; 未设置，这意味着它默认为内置比较。</target>
        </trans-unit>
        <trans-unit id="118b4a4365ad487da58b1630aea69b571bfdefff" translate="yes" xml:space="preserve">
          <source>The example below demonstrates how to perform animations using ngClass.</source>
          <target state="translated">下面的例子演示了如何使用ngClass执行动画。</target>
        </trans-unit>
        <trans-unit id="b5901cc794ac4afcb24616439a439ca1a38725ff" translate="yes" xml:space="preserve">
          <source>The example below illustrates the use of a vertical scroll-offset (specified as a fixed value). See &lt;a href=&quot;%24anchorscroll#yOffset.html&quot;&gt;$anchorScroll.yOffset&lt;/a&gt; for more details.</source>
          <target state="translated">下面的示例说明了垂直滚动偏移量（指定为固定值）的用法。有关更多详细信息，请参见&lt;a href=&quot;%24anchorscroll#yOffset.html&quot;&gt;$ anchorScroll.yOffset&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a78d05887665a9a98ad3b3ca5dd98170ce670e6e" translate="yes" xml:space="preserve">
          <source>The example below makes use of this feature:</source>
          <target state="translated">下面的例子就利用了这个功能。</target>
        </trans-unit>
        <trans-unit id="14f320b8cc2e2763c82039f6b188aeca101a77fe" translate="yes" xml:space="preserve">
          <source>The example below showcases a more advanced version of the &lt;code&gt;.fold-animation&lt;/code&gt; from the example above:</source>
          <target state="translated">下面的示例展示了上面示例中的 &lt;code&gt;.fold-animation&lt;/code&gt; 的更高级版本：</target>
        </trans-unit>
        <trans-unit id="e6fe351ea2c33b51b2ae753847781d2a1ebb1324" translate="yes" xml:space="preserve">
          <source>The example below shows how an &lt;code&gt;enter&lt;/code&gt; animation can be made possible on an element using &lt;code&gt;ng-if&lt;/code&gt;:</source>
          <target state="translated">下面的示例显示了如何使用 &lt;code&gt;ng-if&lt;/code&gt; 在元素上实现 &lt;code&gt;enter&lt;/code&gt; 动画：</target>
        </trans-unit>
        <trans-unit id="d01c3c0993f97fc120473f6fed8b31a7663c420f" translate="yes" xml:space="preserve">
          <source>The example below shows how to perform animations during class changes:</source>
          <target state="translated">下面的例子展示了如何在换类时执行动画。</target>
        </trans-unit>
        <trans-unit id="6205078d09d3fd1c6edadc598319a67cba2952e4" translate="yes" xml:space="preserve">
          <source>The example below shows how we can create a folding animation on an element using &lt;code&gt;ng-if&lt;/code&gt;:</source>
          <target state="translated">以下示例显示了如何使用 &lt;code&gt;ng-if&lt;/code&gt; 在元素上创建折叠动画：</target>
        </trans-unit>
        <trans-unit id="9e746afeaac000344d9d6b97ab0c580a09fc7751" translate="yes" xml:space="preserve">
          <source>The example below therefore calls the filter directly in the controller. By this, the controller is able to call the filter only when needed (e.g. when the data is loaded from the backend or the filter expression is changed).</source>
          <target state="translated">因此,下面的例子直接在控制器中调用过滤器。通过这种方式,控制器能够只在需要的时候调用过滤器(例如,当数据从后端加载或过滤器表达式被改变时)。</target>
        </trans-unit>
        <trans-unit id="de23243571a260c0d0fc8a2c48e1af5d73b5b207" translate="yes" xml:space="preserve">
          <source>The example below uses the filter called &lt;a href=&quot;../api/ng/filter/filter&quot;&gt;&lt;code&gt;filter&lt;/code&gt;&lt;/a&gt;. This filter reduces arrays into sub arrays based on conditions. The filter can be applied in the view template with markup like &lt;code&gt;{{ctrl.array | filter:'a'}}&lt;/code&gt;, which would do a fulltext search for &quot;a&quot;. However, using a filter in a view template will reevaluate the filter on every digest, which can be costly if the array is big.</source>
          <target state="translated">下面的示例使用名为&lt;a href=&quot;../api/ng/filter/filter&quot;&gt; &lt;code&gt;filter&lt;/code&gt; &lt;/a&gt;的过滤器。该过滤器根据条件将阵列简化为子阵列。该过滤器可以应用在视图模板中，并带有诸如 &lt;code&gt;{{ctrl.array | filter:'a'}}&lt;/code&gt; ，它将对&amp;ldquo; a&amp;rdquo;进行全文搜索。但是，在视图模板中使用过滤器将重新评估每个摘要上的过滤器，如果数组很大，这可能会很昂贵。</target>
        </trans-unit>
        <trans-unit id="dffb86218d7a4f9da6fc690c45a79f6af3702634" translate="yes" xml:space="preserve">
          <source>The example below will overwrite the default &lt;code&gt;$exceptionHandler&lt;/code&gt; in order to (a) log uncaught errors to the backend for later inspection by the developers and (b) to use &lt;code&gt;$log.warn()&lt;/code&gt; instead of &lt;code&gt;$log.error()&lt;/code&gt;.</source>
          <target state="translated">下面的示例将覆盖默认的 &lt;code&gt;$exceptionHandler&lt;/code&gt; ，以便（a）将未捕获的错误记录到后端以供开发人员以后检查，以及（b）使用 &lt;code&gt;$log.warn()&lt;/code&gt; 而不是 &lt;code&gt;$log.error()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ffbd243d6aa30bd959233397fedd53c9c8be3b8b" translate="yes" xml:space="preserve">
          <source>The example module below has two services, each with various dependencies:</source>
          <target state="translated">下面的示例模块有两个服务,每个服务都有不同的依赖关系。</target>
        </trans-unit>
        <trans-unit id="26b88996606efd1a2fa2d1f8ee91c2b93f5de125" translate="yes" xml:space="preserve">
          <source>The examples use the &lt;a href=&quot;http://jasmine.github.io/&quot;&gt;Jasmine&lt;/a&gt; testing framework.</source>
          <target state="translated">这些示例使用&lt;a href=&quot;http://jasmine.github.io/&quot;&gt;Jasmine&lt;/a&gt;测试框架。</target>
        </trans-unit>
        <trans-unit id="69df9ff2c507a1bca5d9605667ecdf1f7c1667e3" translate="yes" xml:space="preserve">
          <source>The expression indicating how to enumerate a collection. These formats are currently supported:</source>
          <target state="translated">表示如何枚举一个集合的表达式。目前支持这些格式。</target>
        </trans-unit>
        <trans-unit id="fb146546194737424a42b8fcad30d7883d5da959" translate="yes" xml:space="preserve">
          <source>The factory function is invoked only once when the &lt;a href=&quot;../api/ng/service/%24compile&quot;&gt;compiler&lt;/a&gt; matches the directive for the first time. You can perform any initialization work here. The function is invoked using &lt;a href=&quot;../api/auto/service/%24injector#invoke.html&quot;&gt;$injector.invoke&lt;/a&gt; which makes it injectable just like a controller.</source>
          <target state="translated">当&lt;a href=&quot;../api/ng/service/%24compile&quot;&gt;编译器&lt;/a&gt;首次与指令匹配时，工厂函数仅被调用一次。您可以在此处执行任何初始化工作。该函数使用&lt;a href=&quot;../api/auto/service/%24injector#invoke.html&quot;&gt;$ injector.invoke&lt;/a&gt;调用，这使其像控制器一样可注入。</target>
        </trans-unit>
        <trans-unit id="bac0300463ee737a9762b2ab131e79710f19a302" translate="yes" xml:space="preserve">
          <source>The factory function that will be executed to return the animation object.</source>
          <target state="translated">将执行的工厂函数,以返回动画对象。</target>
        </trans-unit>
        <trans-unit id="9b2b49cac29c83329e4d2e42cf31d5ed84a9baa0" translate="yes" xml:space="preserve">
          <source>The filter function is registered with the &lt;code&gt;$injector&lt;/code&gt; under the filter name suffix with &lt;code&gt;Filter&lt;/code&gt;.</source>
          <target state="translated">过滤器函数在 &lt;code&gt;$injector&lt;/code&gt; 以 &lt;code&gt;Filter&lt;/code&gt; 过滤器后缀注册。</target>
        </trans-unit>
        <trans-unit id="ad14f184c35849cbc77ad9f33986e01e4fc80461" translate="yes" xml:space="preserve">
          <source>The filter function should be a &lt;a href=&quot;http://en.wikipedia.org/wiki/Pure_function&quot;&gt;pure function&lt;/a&gt;, which means that it should always return the same result given the same input arguments and should not affect external state, for example, other AngularJS services. AngularJS relies on this contract and will by default execute a filter only when the inputs to the function change. &lt;a href=&quot;filter#stateful-filters.html&quot;&gt;Stateful filters&lt;/a&gt; are possible, but less performant.</source>
          <target state="translated">filter函数应该是一个&lt;a href=&quot;http://en.wikipedia.org/wiki/Pure_function&quot;&gt;纯函数&lt;/a&gt;，这意味着在给定相同的输入参数的情况下，它应始终返回相同的结果，并且不应影响外部状态，例如其他AngularJS服务。 AngularJS依赖此协定，并且默认情况下，仅当函数的输入发生更改时，才会执行过滤器。&lt;a href=&quot;filter#stateful-filters.html&quot;&gt;有状态过滤器&lt;/a&gt;是可能的，但性能较差。</target>
        </trans-unit>
        <trans-unit id="17c03d18cc2cc78ca4084addd3298d3bc070061e" translate="yes" xml:space="preserve">
          <source>The filter function which will be used to filter all animations. If a falsy value is returned, no animation will be performed. The function will be called with the following arguments:</source>
          <target state="translated">过滤函数,用于过滤所有动画。如果返回一个错误的值,将不执行任何动画。调用该函数时,将使用以下参数。</target>
        </trans-unit>
        <trans-unit id="a937ae27c98f5d7954639b98bccb584d67a2cdbf" translate="yes" xml:space="preserve">
          <source>The final result is an array of those elements that the predicate returned true for.</source>
          <target state="translated">最后的结果是一个数组,其中包含了谓词返回真的元素。</target>
        </trans-unit>
        <trans-unit id="c07e6b5dfc2388c07c722e7af813875eb5b9564a" translate="yes" xml:space="preserve">
          <source>The first issue we have to solve is that the dialog box template expects &lt;code&gt;title&lt;/code&gt; to be defined. But we would like the template's scope property &lt;code&gt;title&lt;/code&gt; to be the result of interpolating the &lt;code&gt;&amp;lt;dialog&amp;gt;&lt;/code&gt; element's &lt;code&gt;title&lt;/code&gt; attribute (i.e. &lt;code&gt;&quot;Hello {{username}}&quot;&lt;/code&gt;). Furthermore, the buttons expect the &lt;code&gt;onOk&lt;/code&gt; and &lt;code&gt;onCancel&lt;/code&gt; functions to be present in the scope. This limits the usefulness of the widget. To solve the mapping issue we use the &lt;code&gt;scope&lt;/code&gt; to create local variables which the template expects as follows:</source>
          <target state="translated">我们要解决的第一个问题是对话框模板期望定义 &lt;code&gt;title&lt;/code&gt; 。但是我们希望模板的scope属性 &lt;code&gt;title&lt;/code&gt; 是对 &lt;code&gt;&amp;lt;dialog&amp;gt;&lt;/code&gt; 元素的 &lt;code&gt;title&lt;/code&gt; 属性（即 &lt;code&gt;&quot;Hello {{username}}&quot;&lt;/code&gt; ）进行插值的结果。此外，按钮希望在示波器中存在 &lt;code&gt;onOk&lt;/code&gt; 和 &lt;code&gt;onCancel&lt;/code&gt; 函数。这限制了小部件的用途。为了解决映射问题，我们使用 &lt;code&gt;scope&lt;/code&gt; 创建模板期望的局部变量，如下所示：</target>
        </trans-unit>
        <trans-unit id="afe6d764a0f6fdc60d923fd9d9a7197ddd360bfa" translate="yes" xml:space="preserve">
          <source>The first kind of new markup are the &lt;a href=&quot;directive&quot;&gt;directives&lt;/a&gt;. They apply special behavior to attributes or elements in the HTML. In the example above we use the &lt;a href=&quot;../api/ng/directive/ngapp&quot;&gt;&lt;code&gt;ng-app&lt;/code&gt;&lt;/a&gt; attribute, which is linked to a directive that automatically initializes our application. AngularJS also defines a directive for the &lt;a href=&quot;../api/ng/directive/input&quot;&gt;&lt;code&gt;input&lt;/code&gt;&lt;/a&gt; element that adds extra behavior to the element. The &lt;a href=&quot;../api/ng/directive/ngmodel&quot;&gt;&lt;code&gt;ng-model&lt;/code&gt;&lt;/a&gt; directive stores/updates the value of the input field into/from a variable.</source>
          <target state="translated">第一种新标记是&lt;a href=&quot;directive&quot;&gt;指令&lt;/a&gt;。它们将特殊行为应用于HTML中的属性或元素。在上面的示例中，我们使用&lt;a href=&quot;../api/ng/directive/ngapp&quot;&gt; &lt;code&gt;ng-app&lt;/code&gt; &lt;/a&gt;属性，该属性链接到自动初始化应用程序的指令。AngularJS还为&lt;a href=&quot;../api/ng/directive/input&quot;&gt; &lt;code&gt;input&lt;/code&gt; &lt;/a&gt;元素定义了一条指令，该指令向该元素添加了额外的行为。的&lt;a href=&quot;../api/ng/directive/ngmodel&quot;&gt; &lt;code&gt;ng-model&lt;/code&gt; &lt;/a&gt;指令存储/更新输入字段的值到/从一个变量。</target>
        </trans-unit>
        <trans-unit id="72248b4ea7e8efbe0801cfc5a9d27f183313c350" translate="yes" xml:space="preserve">
          <source>The first time a template is used, it is loaded in the template cache for quick retrieval. You can load templates directly into the cache in a &lt;code&gt;script&lt;/code&gt; tag, by using &lt;a href=&quot;%24templaterequest&quot;&gt;&lt;code&gt;$templateRequest&lt;/code&gt;&lt;/a&gt;, or by consuming the &lt;code&gt;$templateCache&lt;/code&gt; service directly.</source>
          <target state="translated">首次使用模板时，会将其加载到模板缓存中以进行快速检索。您可以加载模板直接进入一个高速缓存 &lt;code&gt;script&lt;/code&gt; 标签，使用&lt;a href=&quot;%24templaterequest&quot;&gt; &lt;code&gt;$templateRequest&lt;/code&gt; &lt;/a&gt;，或通过消耗 &lt;code&gt;$templateCache&lt;/code&gt; 直接服务。</target>
        </trans-unit>
        <trans-unit id="61770f6e44a5dc9205ef2b85eee18df352de6525" translate="yes" xml:space="preserve">
          <source>The first two options of creating or looking up dependencies are not optimal because they hard code the dependency to the component. This makes it difficult, if not impossible, to modify the dependencies. This is especially problematic in tests, where it is often desirable to provide mock dependencies for test isolation.</source>
          <target state="translated">前两种创建或查找依赖关系的方法并不是最佳选择,因为它们将依赖关系硬编码到组件中。这使得修改依赖关系变得很困难,甚至不可能。这在测试中尤其容易出现问题,因为在测试中通常需要提供模拟依赖关系来进行测试隔离。</target>
        </trans-unit>
        <trans-unit id="62d51362fba403748b0965a7020906ff662204d7" translate="yes" xml:space="preserve">
          <source>The following &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; element also &lt;strong&gt;matches&lt;/strong&gt;&lt;code&gt;ngModel&lt;/code&gt;:</source>
          <target state="translated">以下 &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; 元素也&lt;strong&gt;匹配&lt;/strong&gt; &lt;code&gt;ngModel&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="1ce1ad6bc1a7291d5ceb94bf63f28f4491ef44ee" translate="yes" xml:space="preserve">
          <source>The following CSS classes are added and removed on the associated input/select/textarea element depending on the validity of the model.</source>
          <target state="translated">根据模型的有效性,在相关的输入/选择/textarea元素上添加和删除以下CSS类。</target>
        </trans-unit>
        <trans-unit id="24d21f0a2fb05faaab9a9fee5841089389838e09" translate="yes" xml:space="preserve">
          <source>The following actions are performed by this method:</source>
          <target state="translated">本方法可进行以下操作:</target>
        </trans-unit>
        <trans-unit id="973c90fb359da23554571110c18a1c4f53efc003" translate="yes" xml:space="preserve">
          <source>The following always holds true:</source>
          <target state="translated">以下内容始终是正确的。</target>
        </trans-unit>
        <trans-unit id="36b240b14e8533a4756636899c699ce28b123d00" translate="yes" xml:space="preserve">
          <source>The following code demonstrates adding a new response transformation to be run after the default response transformations have been run.</source>
          <target state="translated">下面的代码演示了添加一个新的响应变换,以便在运行默认的响应变换后运行。</target>
        </trans-unit>
        <trans-unit id="5254b655f465a130e45d925ee2b74ce105150f95" translate="yes" xml:space="preserve">
          <source>The following code shows how to setup and use the mock backend when unit testing a controller. First we create the controller under test:</source>
          <target state="translated">以下代码展示了如何在单元测试控制器时设置和使用模拟后台。首先我们创建被测控制器。</target>
        </trans-unit>
        <trans-unit id="df345b34d500c13d2031f5af048b74463c6d90d4" translate="yes" xml:space="preserve">
          <source>The following code snippet shows a template with &lt;a href=&quot;directive&quot;&gt;directives&lt;/a&gt; and curly-brace &lt;a href=&quot;expression&quot;&gt;expression&lt;/a&gt; bindings:</source>
          <target state="translated">以下代码片段显示了具有&lt;a href=&quot;directive&quot;&gt;指令&lt;/a&gt;和大括号&lt;a href=&quot;expression&quot;&gt;表达式&lt;/a&gt;绑定的模板：</target>
        </trans-unit>
        <trans-unit id="c60eb5d3ceb258f2551ba66c48b7dc7f79064316" translate="yes" xml:space="preserve">
          <source>The following code will issue the &lt;strong&gt;ng-leave-stagger&lt;/strong&gt; event on the element provided:</source>
          <target state="translated">以下代码将在提供的元素上发出&lt;strong&gt;ng-leave-stagger&lt;/strong&gt;事件：</target>
        </trans-unit>
        <trans-unit id="4fd205de158756329787742f78166e78f85ffa62" translate="yes" xml:space="preserve">
          <source>The following default rules in CSP affect AngularJS:</source>
          <target state="translated">CSP中的以下默认规则会影响AngularJS。</target>
        </trans-unit>
        <trans-unit id="90134ab79d7f6b3200f1037dc0cc7a63032e5047" translate="yes" xml:space="preserve">
          <source>The following demonstrates the various ways a directive (&lt;code&gt;myDir&lt;/code&gt; in this case) that matches all 4 types can be referenced from within a template.</source>
          <target state="translated">以下内容演示了可以从模板内引用与所有4种类型匹配的指令（在本例中为 &lt;code&gt;myDir&lt;/code&gt; ）的各种方式。</target>
        </trans-unit>
        <trans-unit id="cc2bb4d34c36efedb43f32cea70a8768eb4ff2f4" translate="yes" xml:space="preserve">
          <source>The following directives are &quot;animation aware&quot;:</source>
          <target state="translated">以下指令是 &quot;动画意识&quot;。</target>
        </trans-unit>
        <trans-unit id="4afa83c5e442e93a0c03e046c0962ecf7210c99b" translate="yes" xml:space="preserve">
          <source>The following example demonstrates creating a &lt;code&gt;GreetingController&lt;/code&gt;, which attaches a &lt;code&gt;greeting&lt;/code&gt; property containing the string &lt;code&gt;'Hola!'&lt;/code&gt; to the &lt;code&gt;$scope&lt;/code&gt;:</source>
          <target state="translated">下面的例子演示如何创建一个 &lt;code&gt;GreetingController&lt;/code&gt; ，它附加一个 &lt;code&gt;greeting&lt;/code&gt; 包含字符串属性 &lt;code&gt;'Hola!'&lt;/code&gt; 到 &lt;code&gt;$scope&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="8f31c0ae4dcad4687f763e1857697fa67941c2cf" translate="yes" xml:space="preserve">
          <source>The following example expands on the simple component example and incorporates the concepts we introduced above:</source>
          <target state="translated">下面的例子是对简单组件例子的扩展,并结合了我们上面介绍的概念。</target>
        </trans-unit>
        <trans-unit id="a68dc016c804a0669d2cdafc91c3941186cea38f" translate="yes" xml:space="preserve">
          <source>The following example shows a simple way to utilize CSS transitions to style a form element that has been rendered as invalid after it has been validated:</source>
          <target state="translated">下面的例子展示了一种简单的方法来利用CSS过渡来样式一个表单元素,该元素在被验证后被渲染为无效。</target>
        </trans-unit>
        <trans-unit id="56aa8c2fcf843e9817067b3a89350a550b362ccb" translate="yes" xml:space="preserve">
          <source>The following example shows a simple way to utilize CSS transitions to style an input element that has been rendered as invalid after it has been validated:</source>
          <target state="translated">下面的例子展示了一种简单的方法来利用CSS过渡来样式一个输入元素,该元素在被验证后被渲染为无效。</target>
        </trans-unit>
        <trans-unit id="afb31a9a68862c6afcf96f6c3e11bb32e67080a5" translate="yes" xml:space="preserve">
          <source>The following example shows how to add two-way data-binding to contentEditable elements.</source>
          <target state="translated">下面的例子展示了如何为contentEditable元素添加双向数据绑定。</target>
        </trans-unit>
        <trans-unit id="d29bf3e06de230de3418eaafced38ca904f8bad6" translate="yes" xml:space="preserve">
          <source>The following example shows how to bind to getter/setters:</source>
          <target state="translated">下面的例子显示了如何绑定到getter/setters。</target>
        </trans-unit>
        <trans-unit id="cf64ab22fdb663548e6a4a5465819cfebca2122b" translate="yes" xml:space="preserve">
          <source>The following example shows how to configure ngPluralize:</source>
          <target state="translated">下面的例子显示了如何配置ngPluralize。</target>
        </trans-unit>
        <trans-unit id="e211088f2987b057c3e47ee8d0f916c1b541890a" translate="yes" xml:space="preserve">
          <source>The following example shows how to create a simple event tracking service and register it using &lt;a href=&quot;%24provide#provider.html&quot;&gt;$provide.provider()&lt;/a&gt;.</source>
          <target state="translated">以下示例说明如何创建简单的事件跟踪服务并使用&lt;a href=&quot;%24provide#provider.html&quot;&gt;$ provide.provider（）进行&lt;/a&gt;注册。</target>
        </trans-unit>
        <trans-unit id="49e8cb0259845374b5503fd5a0834e0ef3de3ec3" translate="yes" xml:space="preserve">
          <source>The following example shows how to override immediate updates. Changes on the inputs within the form will update the model only when the control loses focus (blur event).</source>
          <target state="translated">下面的例子展示了如何覆盖即时更新。只有当控件失去焦点(模糊事件)时,对表单中输入的更改才会更新模型。</target>
        </trans-unit>
        <trans-unit id="608da6d18fbad58a833f943d30704c458a019301" translate="yes" xml:space="preserve">
          <source>The following example shows how to override immediate updates. Changes on the inputs within the form will update the model only when the control loses focus (blur event). If &lt;code&gt;escape&lt;/code&gt; key is pressed while the input field is focused, the value is reset to the value in the current model.</source>
          <target state="translated">下面的示例演示如何覆盖即时更新。仅当控件失去焦点（模糊事件）时，表单中输入的更改才会更新模型。如果在聚焦输入字段的同时按 &lt;code&gt;escape&lt;/code&gt; 键，则该值将重置为当前模型中的值。</target>
        </trans-unit>
        <trans-unit id="e25b61977236b595c690c1add8ceee3f297224e6" translate="yes" xml:space="preserve">
          <source>The following example shows how to use &lt;code&gt;ngModel&lt;/code&gt; with a getter/setter:</source>
          <target state="translated">以下示例显示了如何将 &lt;code&gt;ngModel&lt;/code&gt; 与getter / setter结合使用：</target>
        </trans-unit>
        <trans-unit id="d8828073febfc88b7e929349ee1005c112427e4d" translate="yes" xml:space="preserve">
          <source>The following example shows the effects of different actions with tracking:</source>
          <target state="translated">下面的例子显示了不同动作与跟踪的效果。</target>
        </trans-unit>
        <trans-unit id="49526c0cbe72823024948149f2ba222e9dcacf1d" translate="yes" xml:space="preserve">
          <source>The following example uses a Controller to add a method, which doubles a number, to the scope:</source>
          <target state="translated">下面的例子使用Controller向作用域中添加一个方法,该方法使一个数字翻倍。</target>
        </trans-unit>
        <trans-unit id="c5d5572a6af9e099a94051501ec7017d831c20b8" translate="yes" xml:space="preserve">
          <source>The following example uses the CSS to display validity of each form control. In the example both &lt;code&gt;user.name&lt;/code&gt; and &lt;code&gt;user.email&lt;/code&gt; are required, but are rendered with red background only after the input is blurred (loses focus). This ensures that the user is not distracted with an error until after interacting with the control, and failing to satisfy its validity.</source>
          <target state="translated">下面的示例使用CSS来显示每个表单控件的有效性。在该示例中， &lt;code&gt;user.name&lt;/code&gt; 和 &lt;code&gt;user.email&lt;/code&gt; 都是必需的，但是只有在输入模糊（失去焦点）之后，才会用红色背景呈现。这样可以确保用户在与控件进行交互之前不会因错误而分散注意力，并且无法满足其有效性。</target>
        </trans-unit>
        <trans-unit id="33f68f854869fc32d143f52645cecc54d4d0c1ad" translate="yes" xml:space="preserve">
          <source>The following graphic shows how everything works together after we introduced the controller:</source>
          <target state="translated">下面的图形显示了我们引入控制器后的一切工作情况。</target>
        </trans-unit>
        <trans-unit id="385ffec593477822ca164a235f1fdf7ebf15040e" translate="yes" xml:space="preserve">
          <source>The following is a unit test for the &lt;code&gt;notify&lt;/code&gt; service from the &lt;a href=&quot;services#creating-services.html&quot;&gt;Creating AngularJS Services&lt;/a&gt; example above. The unit test example uses a Jasmine spy (mock) instead of a real browser alert.</source>
          <target state="translated">以下是上述&amp;ldquo; &lt;a href=&quot;services#creating-services.html&quot;&gt;创建AngularJS服务&amp;rdquo;&lt;/a&gt;示例中对 &lt;code&gt;notify&lt;/code&gt; 服务的单元测试。单元测试示例使用Jasmine间谍（模拟）而不是真正的浏览器警报。</target>
        </trans-unit>
        <trans-unit id="fb989a297b5370085b89e00c936b323f1015a9ee" translate="yes" xml:space="preserve">
          <source>The following sample filter reverses a text string. In addition, it conditionally makes the text upper-case.</source>
          <target state="translated">下面的示例过滤器反转了一个文本字符串。此外,它还会有条件地使文本大写。</target>
        </trans-unit>
        <trans-unit id="5abf89865b72c60e74a4308a79f260298a1552b3" translate="yes" xml:space="preserve">
          <source>The following sections provide examples each of a service decorator, a directive decorator, and a filter decorator.</source>
          <target state="translated">下面将分别介绍服务装饰器、指令装饰器和过滤器装饰器的例子。</target>
        </trans-unit>
        <trans-unit id="ef6e74dc8057c84b4bdc44fbe57d05d3eb5ca2ac" translate="yes" xml:space="preserve">
          <source>The former CSS className value</source>
          <target state="translated">以前的CSS className值</target>
        </trans-unit>
        <trans-unit id="c347b16354fe80c4ac3b3f67a7e1632c4e3f4b10" translate="yes" xml:space="preserve">
          <source>The four events are &lt;code&gt;start&lt;/code&gt;, &lt;code&gt;move&lt;/code&gt;, &lt;code&gt;end&lt;/code&gt;, and &lt;code&gt;cancel&lt;/code&gt;. &lt;code&gt;start&lt;/code&gt;, &lt;code&gt;move&lt;/code&gt;, and &lt;code&gt;end&lt;/code&gt; receive as a parameter a coordinates object of the form &lt;code&gt;{ x: 150, y: 310 }&lt;/code&gt; and the raw &lt;code&gt;event&lt;/code&gt;. &lt;code&gt;cancel&lt;/code&gt; receives the raw &lt;code&gt;event&lt;/code&gt; as its single parameter.</source>
          <target state="translated">这四个事件是 &lt;code&gt;start&lt;/code&gt; ， &lt;code&gt;move&lt;/code&gt; ， &lt;code&gt;end&lt;/code&gt; 和 &lt;code&gt;cancel&lt;/code&gt; 。 &lt;code&gt;start&lt;/code&gt; ， &lt;code&gt;move&lt;/code&gt; 和 &lt;code&gt;end&lt;/code&gt; 接收 &lt;code&gt;{ x: 150, y: 310 }&lt;/code&gt; 形式的坐标对象和原始 &lt;code&gt;event&lt;/code&gt; 。 &lt;code&gt;cancel&lt;/code&gt; 接收原始 &lt;code&gt;event&lt;/code&gt; 作为其单个参数。</target>
        </trans-unit>
        <trans-unit id="2c9494e0230a76ef255530c7ab61e30820ac57e4" translate="yes" xml:space="preserve">
          <source>The function that will decide whether the given character is a valid identifier continue character.</source>
          <target state="translated">决定给定字符是否为有效的标识符继续字符的函数。</target>
        </trans-unit>
        <trans-unit id="e9633fa9ea971735772836de085d84d26552cd07" translate="yes" xml:space="preserve">
          <source>The function that will decide whether the given character is a valid identifier start character.</source>
          <target state="translated">决定给定字符是否为有效标识符起始字符的函数。</target>
        </trans-unit>
        <trans-unit id="f07c9484695ff7d7e62cb833d2009d5141f8f9c6" translate="yes" xml:space="preserve">
          <source>The functions are called in array order, each passing its return value through to the next. The last return value is forwarded to the &lt;a href=&quot;ngmodel.ngmodelcontroller#%24validators.html&quot;&gt;&lt;code&gt;$validators&lt;/code&gt;&lt;/a&gt; collection.</source>
          <target state="translated">这些函数按数组顺序调用，每个函数将其返回值传递给下一个。最后的返回值将转发到&lt;a href=&quot;ngmodel.ngmodelcontroller#%24validators.html&quot;&gt; &lt;code&gt;$validators&lt;/code&gt; &lt;/a&gt;集合。</target>
        </trans-unit>
        <trans-unit id="dae7ea2912e98ee65a104da6c13925bc30a72664" translate="yes" xml:space="preserve">
          <source>The functions are called in reverse array order, each passing the value through to the next. The last return value is used as the actual DOM value.</source>
          <target state="translated">这些函数是以相反的数组顺序调用的,每一个函数都会将值传递给下一个函数,最后一个返回值作为实际的DOM值。最后一个返回值被用作实际的DOM值。</target>
        </trans-unit>
        <trans-unit id="c1882a81b786a1f235f2e723e4c9aff45edba984" translate="yes" xml:space="preserve">
          <source>The gender support is provided by the more generic &quot;select&quot; syntax that is more akin to a switch statement. It is general enough to support use for gender based messages.</source>
          <target state="translated">性别支持是由更通用的 &quot;select &quot;语法提供的,它更类似于一个切换语句。它的通用性足以支持基于性别的信息的使用。</target>
        </trans-unit>
        <trans-unit id="f59bd7db60de9ce08437e7f3e011e5ca3fab98ac" translate="yes" xml:space="preserve">
          <source>The general syntax in templates is as follows:</source>
          <target state="translated">模板中的一般语法如下。</target>
        </trans-unit>
        <trans-unit id="56c426b734bed528f39225878bb25f07045e803d" translate="yes" xml:space="preserve">
          <source>The goal of ngAria is to improve AngularJS's default accessibility by enabling common &lt;a href=&quot;http://www.w3.org/TR/wai-aria/&quot;&gt;ARIA&lt;/a&gt; attributes that convey state or semantic information for assistive technologies used by persons with disabilities.</source>
          <target state="translated">ngAria的目标是通过启用常见的&lt;a href=&quot;http://www.w3.org/TR/wai-aria/&quot;&gt;ARIA&lt;/a&gt;属性（可传达残疾人使用的辅助技术的状态或语义信息）来改善AngularJS的默认可访问性。</target>
        </trans-unit>
        <trans-unit id="62f795492acd77aa418074f3e83eb0705e35bd74" translate="yes" xml:space="preserve">
          <source>The hash specifying the element to scroll to. If omitted, the value of &lt;a href=&quot;%24location#hash.html&quot;&gt;$location.hash()&lt;/a&gt; will be used.</source>
          <target state="translated">指定要滚动到的元素的哈希。如果省略，将使用&lt;a href=&quot;%24location#hash.html&quot;&gt;$ location.hash（）&lt;/a&gt;的值。</target>
        </trans-unit>
        <trans-unit id="02053663b4fa96bc136f66df077e6715d30724e9" translate="yes" xml:space="preserve">
          <source>The header will &amp;mdash; by default &amp;mdash; &lt;strong&gt;not&lt;/strong&gt; be set for cross-domain requests. This prevents unauthorized servers (e.g. malicious or compromised 3rd-party APIs) from gaining access to your users' XSRF tokens and exposing them to Cross Site Request Forgery. If you want to, you can whitelist additional origins to also receive the XSRF token, by adding them to &lt;a href=&quot;../provider/%24httpprovider#xsrfWhitelistedOrigins.html&quot;&gt;xsrfWhitelistedOrigins&lt;/a&gt;. This might be useful, for example, if your application, served from &lt;code&gt;example.com&lt;/code&gt;, needs to access your API at &lt;code&gt;api.example.com&lt;/code&gt;. See &lt;a href=&quot;../provider/%24httpprovider#xsrfWhitelistedOrigins.html&quot;&gt;$httpProvider.xsrfWhitelistedOrigins&lt;/a&gt; for more details.</source>
          <target state="translated">默认情况下，&lt;strong&gt;不会&lt;/strong&gt;为跨域请求设置标头。这样可以防止未授权的服务器（例如，恶意的或受感染的第三方API）获得对用户XSRF令牌的访问权限，并将其暴露给跨站点请求伪造。如果愿意，可以通过将其他来源添加到&lt;a href=&quot;../provider/%24httpprovider#xsrfWhitelistedOrigins.html&quot;&gt;xsrfWhitelistedOrigins&lt;/a&gt;来将其他来源列入白名单，以也接收XSRF令牌。例如，如果从 &lt;code&gt;example.com&lt;/code&gt; 提供服务的应用程序需要访问 &lt;code&gt;api.example.com&lt;/code&gt; 上的API，这可能会很有用。有关更多详细信息，请参见&lt;a href=&quot;../provider/%24httpprovider#xsrfWhitelistedOrigins.html&quot;&gt;$ httpProvider.xsrfWhitelistedOrigins&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d9d882e0eea82bc7f30ad5b0b72c42474eb4cf87" translate="yes" xml:space="preserve">
          <source>The heroDetail component now contains new functionality:</source>
          <target state="translated">heroDetail组件现在包含新功能。</target>
        </trans-unit>
        <trans-unit id="118554a0cc7bb4ae6da007dc27bdce1b33af2df3" translate="yes" xml:space="preserve">
          <source>The impedance mismatch between dynamic applications and static documents is often solved with:</source>
          <target state="translated">动态应用和静态文件之间的阻抗不匹配,通常用解决。</target>
        </trans-unit>
        <trans-unit id="bc88ca9137a8a789d4223b3543e8b24f06c1df98" translate="yes" xml:space="preserve">
          <source>The important thing in the example is that AngularJS provides &lt;em&gt;live&lt;/em&gt; bindings: Whenever the input values change, the value of the expressions are automatically recalculated and the DOM is updated with their values. The concept behind this is &lt;a href=&quot;databinding&quot;&gt;two-way data binding&lt;/a&gt;.</source>
          <target state="translated">该示例中的重要之处在于AngularJS提供了&lt;em&gt;实时&lt;/em&gt;绑定：只要输入值发生更改，表达式的值就会自动重新计算，并且DOM会使用其值进行更新。其背后的概念是&lt;a href=&quot;databinding&quot;&gt;双向数据绑定&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="feb47f0357163525e9a17e43f4fdaa136b3a9b3a" translate="yes" xml:space="preserve">
          <source>The included &lt;a href=&quot;%24scedelegate&quot;&gt;$sceDelegate&lt;/a&gt; comes with sane defaults to allow you to load templates in &lt;code&gt;ng-include&lt;/code&gt; from your application's domain without having to even know about SCE. It blocks loading templates from other domains or loading templates over http from an https served document. You can change these by setting your own custom &lt;a href=&quot;../provider/%24scedelegateprovider#resourceUrlWhitelist.html&quot;&gt;whitelists&lt;/a&gt; and &lt;a href=&quot;../provider/%24scedelegateprovider#resourceUrlBlacklist.html&quot;&gt;blacklists&lt;/a&gt; for matching such URLs.</source>
          <target state="translated">随附的&lt;a href=&quot;%24scedelegate&quot;&gt;$ sceDelegate&lt;/a&gt;具有默认值，可让您从应用程序域中以 &lt;code&gt;ng-include&lt;/code&gt; 加载模板，而无需了解SCE。它阻止从其他域加载模板，或者阻止从https提供的文档通过http加载模板。您可以通过设置自己的自定义&lt;a href=&quot;../provider/%24scedelegateprovider#resourceUrlWhitelist.html&quot;&gt;白名单&lt;/a&gt;和&lt;a href=&quot;../provider/%24scedelegateprovider#resourceUrlBlacklist.html&quot;&gt;黑名单&lt;/a&gt;以匹配此类URL 来更改它们。</target>
        </trans-unit>
        <trans-unit id="0d86ce90e809e5dafdbfc54a177b73d2ccac67ae" translate="yes" xml:space="preserve">
          <source>The inject function wraps a function into an injectable function. The inject() creates new instance of &lt;a href=&quot;../../auto/service/%24injector&quot;&gt;$injector&lt;/a&gt; per test, which is then used for resolving references.</source>
          <target state="translated">注入函数将函数包装为可注入函数。inject（）&lt;a href=&quot;../../auto/service/%24injector&quot;&gt;为&lt;/a&gt;每个测试创建$ injector的新实例，然后将其用于解析引用。</target>
        </trans-unit>
        <trans-unit id="c1092c772bcfea30a4aa4090625e6d56119e573a" translate="yes" xml:space="preserve">
          <source>The injectable $getFn for the instance creation. Internally this is a short hand for &lt;code&gt;$provide.provider(name, {$get: $getFn})&lt;/code&gt;.</source>
          <target state="translated">用于创建实例的可注入$ getFn。在内部，这是 &lt;code&gt;$provide.provider(name, {$get: $getFn})&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="605987405f3ba59ce7d26ad7a79cb1575f0f779c" translate="yes" xml:space="preserve">
          <source>The injectable function to invoke. Function parameters are injected according to the &lt;a href=&quot;../../../guide/di&quot;&gt;$inject Annotation&lt;/a&gt; rules.</source>
          <target state="translated">可调用的可注入函数。函数参数是根据&lt;a href=&quot;../../../guide/di&quot;&gt;$ inject注释&lt;/a&gt;规则注入的。</target>
        </trans-unit>
        <trans-unit id="677dfa999d3a98fad688a00276274a8900d320b0" translate="yes" xml:space="preserve">
          <source>The injector creates two types of objects, &lt;strong&gt;services&lt;/strong&gt; and &lt;strong&gt;specialized objects&lt;/strong&gt;.</source>
          <target state="translated">注入程序创建两种类型的对象，即&lt;strong&gt;服务&lt;/strong&gt;&lt;strong&gt;对象&lt;/strong&gt;和&lt;strong&gt;专用对象&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="0e94cb4879f562aa129066b04f883ce6312f54d9" translate="yes" xml:space="preserve">
          <source>The injector needs to know how to create these objects. You tell it by registering a &quot;recipe&quot; for creating your object with the injector. There are five recipe types.</source>
          <target state="translated">注入器需要知道如何创建这些对象。您可以通过注册一个 &quot;配方 &quot;来告诉它,以便向注入器创建您的对象。有五种配方类型。</target>
        </trans-unit>
        <trans-unit id="6273feccee525d43053ba5dbf6fca985976d17e5" translate="yes" xml:space="preserve">
          <source>The injector uses recipes to create two types of objects: services and special purpose objects</source>
          <target state="translated">注入器使用配方来创建两种类型的对象:服务和特殊目的对象。</target>
        </trans-unit>
        <trans-unit id="f953d4b077ce6a518bf5b06d0aef4b5f97e7e535" translate="yes" xml:space="preserve">
          <source>The input is sanitized by parsing the HTML into tokens. All safe tokens (from a whitelist) are then serialized back to a properly escaped HTML string. This means that no unsafe input can make it into the returned string.</source>
          <target state="translated">通过将HTML解析为标记,对输入进行消毒。所有安全的标记(来自白名单)都会被序列化为一个正确转义的HTML字符串。这意味着没有不安全的输入可以进入返回的字符串。</target>
        </trans-unit>
        <trans-unit id="59f809f5d96cab71f45dcf3fd61d5ada6a5b1113" translate="yes" xml:space="preserve">
          <source>The input may also contain SVG markup if this is enabled via &lt;a href=&quot;../provider/%24sanitizeprovider&quot;&gt;&lt;code&gt;$sanitizeProvider&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果通过&lt;a href=&quot;../provider/%24sanitizeprovider&quot;&gt; &lt;code&gt;$sanitizeProvider&lt;/code&gt; &lt;/a&gt;启用了此输入，则输入也可能包含SVG标记。</target>
        </trans-unit>
        <trans-unit id="c9721cff229ea27eaddea830cb215d9ecb24c54d" translate="yes" xml:space="preserve">
          <source>The instance.</source>
          <target state="translated">该实例。</target>
        </trans-unit>
        <trans-unit id="d06ec46a0f6db466ce39dca76188695efd2cff45" translate="yes" xml:space="preserve">
          <source>The instructions for the injector to create these special objects (with the exception of the Controller objects) use the Factory recipe behind the scenes.</source>
          <target state="translated">注射器创建这些特殊对象的指令(除Controller对象外)都是在幕后使用Factory配方。</target>
        </trans-unit>
        <trans-unit id="9641656e0f057252f61c1fb2d165a7e89b9e6899" translate="yes" xml:space="preserve">
          <source>The interceptors are service factories that are registered with the &lt;code&gt;$httpProvider&lt;/code&gt; by adding them to the &lt;code&gt;$httpProvider.interceptors&lt;/code&gt; array. The factory is called and injected with dependencies (if specified) and returns the interceptor.</source>
          <target state="translated">拦截器是与该注册服务工厂 &lt;code&gt;$httpProvider&lt;/code&gt; 将它们添加到 &lt;code&gt;$httpProvider.interceptors&lt;/code&gt; 阵列。调用工厂并注入依赖项（如果指定），并返回拦截器。</target>
        </trans-unit>
        <trans-unit id="259abe29ae4ace32d8058fd4b583122111a0a58c" translate="yes" xml:space="preserve">
          <source>The items in the &lt;code&gt;watchExpressions&lt;/code&gt; array are observed via the standard &lt;code&gt;$watch&lt;/code&gt; operation. Their return values are examined for changes on every call to &lt;code&gt;$digest&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;watchExpressions&lt;/code&gt; 数组中的项目通过标准 &lt;code&gt;$watch&lt;/code&gt; 操作进行观察。在每次调用 &lt;code&gt;$digest&lt;/code&gt; ，都会检查它们的返回值是否有变化。</target>
        </trans-unit>
        <trans-unit id="ac4e2ed2134c4627770fca158ca734471daad86e" translate="yes" xml:space="preserve">
          <source>The key directive in understanding two-way data-binding is &lt;a href=&quot;../api/ng/directive/ngmodel&quot;&gt;ngModel&lt;/a&gt;. The &lt;code&gt;ngModel&lt;/code&gt; directive provides the two-way data-binding by synchronizing the model to the view, as well as view to the model. In addition it provides an &lt;a href=&quot;../api/ng/type/ngmodel.ngmodelcontroller&quot;&gt;API&lt;/a&gt; for other directives to augment its behavior.</source>
          <target state="translated">理解双向数据绑定的关键指令是&lt;a href=&quot;../api/ng/directive/ngmodel&quot;&gt;ngModel&lt;/a&gt;。所述 &lt;code&gt;ngModel&lt;/code&gt; 指令提供双向通过同步模式向视图，以及图到模型数据绑定。另外，它为其他指令提供了&lt;a href=&quot;../api/ng/type/ngmodel.ngmodelcontroller&quot;&gt;API&lt;/a&gt;，以增强其行为。</target>
        </trans-unit>
        <trans-unit id="cf8fd3854844a5b37d09ac63b2f2a2265faf671e" translate="yes" xml:space="preserve">
          <source>The key thing to remember here is that, depending on the animation event (which each of the directives above trigger depending on what's going on) two generated CSS classes will be applied to the element; in the example above we have &lt;code&gt;.ng-enter&lt;/code&gt; and &lt;code&gt;.ng-enter-active&lt;/code&gt;. For CSS transitions, the transition code &lt;strong&gt;must&lt;/strong&gt; be defined within the starting CSS class (in this case &lt;code&gt;.ng-enter&lt;/code&gt;). The destination class is what the transition will animate towards.</source>
          <target state="translated">这里要记住的关键是，根据动画事件（上面的每个指令根据发生的事情触发），两个生成的CSS类将应用于该元素。在上面的示例中，我们有 &lt;code&gt;.ng-enter&lt;/code&gt; 和 &lt;code&gt;.ng-enter-active&lt;/code&gt; 。对于CSS过渡，过渡代码&lt;strong&gt;必须&lt;/strong&gt;在起始CSS类中定义（在本例中为 &lt;code&gt;.ng-enter&lt;/code&gt; ）。目标类是过渡所要实现的目标。</target>
        </trans-unit>
        <trans-unit id="9bfe88c198504d0cc14a7b1ffef4d2e83779de3b" translate="yes" xml:space="preserve">
          <source>The last thing that changed in the example between the previous section and this section is that we now pass an array to the &lt;code&gt;module.controller&lt;/code&gt; function, instead of a plain function. The array first contains the names of the service dependencies that the controller needs. The last entry in the array is the controller constructor function. AngularJS uses this array syntax to define the dependencies so that the DI also works after minifying the code, which will most probably rename the argument name of the controller constructor function to something shorter like &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">在上一节和本节之间的示例中，最后发生的更改是，我们现在将一个数组传递给 &lt;code&gt;module.controller&lt;/code&gt; 函数，而不是普通函数。该数组首先包含控制器需要的服务依赖项的名称。数组中的最后一项是控制器构造函数。 AngularJS使用此数组语法定义依赖项，以便DI在缩小代码后也可以工作，这很可能会将控制器构造函数的参数名称重命名为较短的名称，例如 &lt;code&gt;a&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9bc17242596383b2aa73f58fe188aa93577a2dc8" translate="yes" xml:space="preserve">
          <source>The length of the returned array or string. If the &lt;code&gt;limit&lt;/code&gt; number is positive, &lt;code&gt;limit&lt;/code&gt; number of items from the beginning of the source array/string are copied. If the number is negative, &lt;code&gt;limit&lt;/code&gt; number of items from the end of the source array/string are copied. The &lt;code&gt;limit&lt;/code&gt; will be trimmed if it exceeds &lt;code&gt;array.length&lt;/code&gt;. If &lt;code&gt;limit&lt;/code&gt; is undefined, the input will be returned unchanged.</source>
          <target state="translated">返回的数组或字符串的长度。如果 &lt;code&gt;limit&lt;/code&gt; 数为正，则将复制源数组/字符串开头的 &lt;code&gt;limit&lt;/code&gt; 项数。如果数字为负，则复制源数组/字符串末尾的 &lt;code&gt;limit&lt;/code&gt; 项目数。如果超过 &lt;code&gt;array.length&lt;/code&gt; ,则将修剪该 &lt;code&gt;limit&lt;/code&gt; 。如果未定义 &lt;code&gt;limit&lt;/code&gt; ，则输入将保持不变。</target>
        </trans-unit>
        <trans-unit id="96f80bb4132ab5893f0e229db73744e61363387b" translate="yes" xml:space="preserve">
          <source>The link function is responsible for registering DOM listeners as well as updating the DOM. It is executed after the template has been cloned. This is where most of the directive logic will be put.</source>
          <target state="translated">链接函数负责注册DOM监听器以及更新DOM。它是在模板被克隆后执行的。这是大部分指令逻辑的地方。</target>
        </trans-unit>
        <trans-unit id="25992899d7d94510e26d6aadc430072c9ca0c0f0" translate="yes" xml:space="preserve">
          <source>The main method of &lt;code&gt;$swipe&lt;/code&gt;. It takes an element to be watched for swipe motions, and an object containing event handlers. The pointer types that should be used can be specified via the optional third argument, which is an array of strings &lt;code&gt;'mouse'&lt;/code&gt;, &lt;code&gt;'touch'&lt;/code&gt; and &lt;code&gt;'pointer'&lt;/code&gt;. By default, &lt;code&gt;$swipe&lt;/code&gt; will listen for &lt;code&gt;mouse&lt;/code&gt;, &lt;code&gt;touch&lt;/code&gt; and &lt;code&gt;pointer&lt;/code&gt; events.</source>
          <target state="translated">&lt;code&gt;$swipe&lt;/code&gt; 的主要方法。它需要一个元素来监视其滑动动作，以及一个包含事件处理程序的对象。可以通过可选的第三个参数指定应使用的指针类型，该参数是字符串 &lt;code&gt;'mouse'&lt;/code&gt; ， &lt;code&gt;'touch'&lt;/code&gt; 和 &lt;code&gt;'pointer'&lt;/code&gt; 的数组。默认情况下， &lt;code&gt;$swipe&lt;/code&gt; 将侦听 &lt;code&gt;mouse&lt;/code&gt; ， &lt;code&gt;touch&lt;/code&gt; 和 &lt;code&gt;pointer&lt;/code&gt; 事件。</target>
        </trans-unit>
        <trans-unit id="1a172ed357f81e2238a43ea9dd78f148e9988e2e" translate="yes" xml:space="preserve">
          <source>The main purpose is to create Date-like instances with timezone fixed to the specified timezone offset, so that we can test code that depends on local timezone settings without dependency on the time zone settings of the machine where the code is running.</source>
          <target state="translated">主要目的是创建时区固定为指定时区偏移的Date-like实例,这样我们就可以测试依赖于本地时区设置的代码,而不依赖于代码运行机器的时区设置。</target>
        </trans-unit>
        <trans-unit id="0b310ca323bcc83d7a5a4af3c0bc0d4391022eb7" translate="yes" xml:space="preserve">
          <source>The main purpose of one-time binding expression is to provide a way to create a binding that gets deregistered and frees up resources once the binding is stabilized. Reducing the number of expressions being watched makes the digest loop faster and allows more information to be displayed at the same time.</source>
          <target state="translated">一次性绑定表达式的主要目的是提供一种创建绑定的方式,一旦绑定稳定后就会被取消注册,释放资源。减少被注视的表达式数量,使得文摘循环的速度更快,可以同时显示更多的信息。</target>
        </trans-unit>
        <trans-unit id="25503d1e5d98a9ab3cd9eaf52b8e382fdd6b749a" translate="yes" xml:space="preserve">
          <source>The main purpose of this service is to simplify debugging and troubleshooting.</source>
          <target state="translated">该服务的主要目的是简化调试和故障排除。</target>
        </trans-unit>
        <trans-unit id="91c342052b273fbc763e3a770d83c916c0e2fd15" translate="yes" xml:space="preserve">
          <source>The map object is:</source>
          <target state="translated">地图对象是:</target>
        </trans-unit>
        <trans-unit id="c3ba921f13d5d29a579ae0d65aabb1cf6c6ce2b7" translate="yes" xml:space="preserve">
          <source>The mapping between plural category to its corresponding strings.</source>
          <target state="translated">复数类别与对应字符串之间的映射。</target>
        </trans-unit>
        <trans-unit id="91b978fa871e53cfbb4757ac12f850437d085924" translate="yes" xml:space="preserve">
          <source>The message in our template contains a binding to the &lt;code&gt;spice&lt;/code&gt; model which, by default, is set to the string &quot;very&quot;. Depending on which button is clicked, the &lt;code&gt;spice&lt;/code&gt; model is set to &lt;code&gt;chili&lt;/code&gt; or &lt;code&gt;jalape&amp;ntilde;o&lt;/code&gt;, and the message is automatically updated by data-binding.</source>
          <target state="translated">我们模板中的消息包含与 &lt;code&gt;spice&lt;/code&gt; 模型的绑定，默认情况下，该绑定设置为字符串&amp;ldquo;非常&amp;rdquo;。根据单击哪个按钮，将 &lt;code&gt;spice&lt;/code&gt; 模型设置为 &lt;code&gt;chili&lt;/code&gt; 或 &lt;code&gt;jalape&amp;ntilde;o&lt;/code&gt; ，并且通过数据绑定自动更新消息。</target>
        </trans-unit>
        <trans-unit id="c79e17a2b6e79907beb19b379baae598ffbe689b" translate="yes" xml:space="preserve">
          <source>The missing pieces here are that we do not have a transition set (within the CSS code nor within the &lt;code&gt;$animateCss&lt;/code&gt; options) and the duration of the animation is going to be detected from what the keyframe styles on the CSS class are. In this event, &lt;code&gt;$animateCss&lt;/code&gt; will automatically create an inline transition style matching the duration detected from the keyframe style (which is present in the CSS class that is being added) and then prepare both the transition and keyframe animations to run in parallel on the element. Then when the animation is underway the provided &lt;code&gt;from&lt;/code&gt; and &lt;code&gt;to&lt;/code&gt; CSS styles will be applied and spread across the transition and keyframe animation.</source>
          <target state="translated">这里缺少的部分是我们没有过渡集（在CSS代码内或 &lt;code&gt;$animateCss&lt;/code&gt; 选项内），并且将从CSS类上的关键帧样式中检测出动画的持续时间。在这种情况下， &lt;code&gt;$animateCss&lt;/code&gt; 将自动创建一个内联过渡样式，该样式与从关键帧样式（在要添加的CSS类中存在）​​检测到的持续时间匹配，然后准备过渡动画和关键帧动画以在元素上并行运行。然后，当正在进行中所提供的动画 &lt;code&gt;from&lt;/code&gt; 和 &lt;code&gt;to&lt;/code&gt; CSS样式将被应用，横跨过渡和关键帧动画蔓延。</target>
        </trans-unit>
        <trans-unit id="5c0949f1bb9728ff0ffb32f807d413d44806a30f" translate="yes" xml:space="preserve">
          <source>The model must be assigned an entirely new object or collection before a re-rendering will occur.</source>
          <target state="translated">在重新渲染之前,必须为模型分配一个全新的对象或集合。</target>
        </trans-unit>
        <trans-unit id="3ae22dc48b481f4e02eb16cb19edc1733fe699ba" translate="yes" xml:space="preserve">
          <source>The modules can be loaded in any order (or even in parallel) because modules delay execution.</source>
          <target state="translated">模块可以按照任何顺序加载(甚至可以并行加载),因为模块会延迟执行。</target>
        </trans-unit>
        <trans-unit id="529f242a37709897dbd946c5165c8aee6256feb1" translate="yes" xml:space="preserve">
          <source>The most common way to keep Controllers slim is by encapsulating work that doesn't belong to controllers into services and then using these services in Controllers via dependency injection. This is discussed in the &lt;a href=&quot;di&quot;&gt;Dependency Injection&lt;/a&gt; and &lt;a href=&quot;services&quot;&gt;Services&lt;/a&gt; sections of this guide.</source>
          <target state="translated">使控制器保持苗条的最常见方法是将不属于控制器的工作封装到服务中，然后通过依赖注入在控制器中使用这些服务。本指南的&amp;ldquo; &lt;a href=&quot;di&quot;&gt;依赖关系注入&lt;/a&gt;和&lt;a href=&quot;services&quot;&gt;服务&amp;rdquo;&lt;/a&gt;部分对此进行了讨论。</target>
        </trans-unit>
        <trans-unit id="faf758b67dc590ad824277c5b5f2a314b0605341" translate="yes" xml:space="preserve">
          <source>The most verbose, but also the most comprehensive one is a Provider recipe. The remaining four recipe types &amp;mdash; Value, Factory, Service and Constant &amp;mdash; are just syntactic sugar on top of a provider recipe.</source>
          <target state="translated">提供程序最详细，但也最全面。其余四种配方类型-值，工厂，服务和常量-只是提供者配方之上的语法糖。</target>
        </trans-unit>
        <trans-unit id="e93ee1a6dab4177437aeb5008d2c15cdeb9c5c03" translate="yes" xml:space="preserve">
          <source>The name attribute of the control.</source>
          <target state="translated">控件的名称属性。</target>
        </trans-unit>
        <trans-unit id="52a1406be0fd9b4498790d2b937925b4d86eab44" translate="yes" xml:space="preserve">
          <source>The name of the Component (as string).</source>
          <target state="translated">组件的名称(字符串)。</target>
        </trans-unit>
        <trans-unit id="f6aadfe17e9d7e5921f17aa8f89b4addde7625ab" translate="yes" xml:space="preserve">
          <source>The name of the animation (this is what the class-based CSS value will be compared to).</source>
          <target state="translated">动画的名称(这是基于类的CSS值将被比较的内容)。</target>
        </trans-unit>
        <trans-unit id="5fa60c10f1cb65ee0552af457bf2e526a3e8f002" translate="yes" xml:space="preserve">
          <source>The name of the constant.</source>
          <target state="translated">常的名称。</target>
        </trans-unit>
        <trans-unit id="5ebd3314617eb25c4ca63e475dab29179d07a68b" translate="yes" xml:space="preserve">
          <source>The name of the cookie and the header can be specified using the &lt;code&gt;xsrfCookieName&lt;/code&gt; and &lt;code&gt;xsrfHeaderName&lt;/code&gt; properties of either &lt;code&gt;$httpProvider.defaults&lt;/code&gt; at config-time, &lt;code&gt;$http.defaults&lt;/code&gt; at run-time, or the per-request config object.</source>
          <target state="translated">可以使用 &lt;code&gt;$httpProvider.defaults&lt;/code&gt; 在配置时，运行时 &lt;code&gt;$http.defaults&lt;/code&gt; 或按请求配置对象的 &lt;code&gt;xsrfCookieName&lt;/code&gt; 和 &lt;code&gt;xsrfHeaderName&lt;/code&gt; 属性来指定cookie的名称和标头。</target>
        </trans-unit>
        <trans-unit id="b5688f633c9943ed9963b6fac42bbab391f315da" translate="yes" xml:space="preserve">
          <source>The name of the instance to retrieve.</source>
          <target state="translated">要检索的实例名称。</target>
        </trans-unit>
        <trans-unit id="3ce9a1a3f858c924570c179ce1f797aef67a7010" translate="yes" xml:space="preserve">
          <source>The name of the instance.</source>
          <target state="translated">实例的名称。</target>
        </trans-unit>
        <trans-unit id="6914eeeb46cd50ced441dc387497bcc06ba59c09" translate="yes" xml:space="preserve">
          <source>The name of the instance. NOTE: the provider will be available under &lt;code&gt;name +
                        'Provider'&lt;/code&gt; key.</source>
          <target state="translated">实例的名称。注意：提供程序将在 &lt;code&gt;name + 'Provider'&lt;/code&gt; 键下可用。</target>
        </trans-unit>
        <trans-unit id="ef527986f7dd95521960193aaf626a363e2146dd" translate="yes" xml:space="preserve">
          <source>The name of the module to create or retrieve.</source>
          <target state="translated">要创建或检索的模块名称。</target>
        </trans-unit>
        <trans-unit id="5d9dc085c378b2687e35cbb2d483853c9af87fd6" translate="yes" xml:space="preserve">
          <source>The name of the service to decorate.</source>
          <target state="translated">的服务名称来装饰。</target>
        </trans-unit>
        <trans-unit id="a630443a3a5826d0976b6447615bfaff1727aedd" translate="yes" xml:space="preserve">
          <source>The names of the services which the function requires.</source>
          <target state="translated">该函数所需的服务名称。</target>
        </trans-unit>
        <trans-unit id="d6e70987a77c802441d477d6206f9cfb9463cba2" translate="yes" xml:space="preserve">
          <source>The new Angular also uses life-cycle hooks for its components. While the AngularJS life-cycle hooks are similar there are some differences that you should be aware of, especially when it comes to moving your code from AngularJS to Angular:</source>
          <target state="translated">新的Angular也为其组件使用了生命周期钩子。虽然AngularJS的生命周期钩子是相似的,但也有一些差异,你应该注意,特别是当你的代码从AngularJS转移到Angular时。</target>
        </trans-unit>
        <trans-unit id="a41b334b9554bd05233c2fb4d0a3daaade91fce8" translate="yes" xml:space="preserve">
          <source>The newly created child scope.</source>
          <target state="translated">新创建的子范围。</target>
        </trans-unit>
        <trans-unit id="f3ce6bf462a57a8d8b163717a5d0f046f25c3465" translate="yes" xml:space="preserve">
          <source>The newly created promise.</source>
          <target state="translated">新创建的承诺。</target>
        </trans-unit>
        <trans-unit id="ae09afc16f38ae9a9387c7b12e77a3a66d8888da" translate="yes" xml:space="preserve">
          <source>The next example shows how to debounce model changes. Model will be updated only 1 sec after last change. If the &lt;code&gt;Clear&lt;/code&gt; button is pressed, any debounced action is canceled and the value becomes empty.</source>
          <target state="translated">下一个示例显示如何消除模型更改。上次更改后仅1秒钟将更新模型。如果按下 &lt;code&gt;Clear&lt;/code&gt; 按钮，则任何反跳动作都会被取消，并且该值将变为空。</target>
        </trans-unit>
        <trans-unit id="b76887d9d0fb60e4fc34d27b04b0219ff2d5a890" translate="yes" xml:space="preserve">
          <source>The ng-[event]-prepare class</source>
          <target state="translated">ng-[event]-prepare类。</target>
        </trans-unit>
        <trans-unit id="83832e96d19a35ce36d51f03002d6ffdbe1a0358" translate="yes" xml:space="preserve">
          <source>The ng-animate CSS class</source>
          <target state="translated">ng-animate CSS类</target>
        </trans-unit>
        <trans-unit id="9a9d315c0358a5c5e8b194937e0eee872f4b7280" translate="yes" xml:space="preserve">
          <source>The ngAnimate &lt;code&gt;$animate&lt;/code&gt; service documentation is the same for the core &lt;code&gt;$animate&lt;/code&gt; service.</source>
          <target state="translated">ngAnimate &lt;code&gt;$animate&lt;/code&gt; 服务文档与核心 &lt;code&gt;$animate&lt;/code&gt; 服务相同。</target>
        </trans-unit>
        <trans-unit id="c26c0cdee12de4e472917c56086b0a3fb2d3b22f" translate="yes" xml:space="preserve">
          <source>The ngClass directive still supports CSS3 Transitions/Animations even if they do not follow the ngAnimate CSS naming structure. Upon animation ngAnimate will apply supplementary CSS classes to track the start and end of an animation, but this will not hinder any pre-existing CSS transitions already on the element. To get an idea of what happens during a class-based animation, be sure to view the step by step details of &lt;a href=&quot;../service/%24animate#addClass.html&quot;&gt;$animate.addClass&lt;/a&gt; and &lt;a href=&quot;../service/%24animate#removeClass.html&quot;&gt;$animate.removeClass&lt;/a&gt;.</source>
          <target state="translated">即使ngClass指令不遵循ngAnimate CSS命名结构，它们仍支持CSS3 Transitions / Animations。在动画上，ngAnimate将应用补充CSS类来跟踪动画的开始和结束，但这不会妨碍元素上已经存在的任何CSS过渡。要了解在基于类的动画中会发生什么，请确保逐步查看&lt;a href=&quot;../service/%24animate#addClass.html&quot;&gt;$ animate.addClass&lt;/a&gt;和&lt;a href=&quot;../service/%24animate#removeClass.html&quot;&gt;$ animate.removeClass的&lt;/a&gt;详细信息。</target>
        </trans-unit>
        <trans-unit id="0635f6269423a28f71e76e780ec63cd5fb218795" translate="yes" xml:space="preserve">
          <source>The ngClick directive allows you to specify custom behavior when an element is clicked.</source>
          <target state="translated">ngClick指令允许你指定元素被点击时的自定义行为。</target>
        </trans-unit>
        <trans-unit id="223eb922ce0ea7ac3447fe285277dffc1916f050" translate="yes" xml:space="preserve">
          <source>The ngMessageFormat module extends the AngularJS &lt;a href=&quot;ng/service/%24interpolate&quot;&gt;&lt;code&gt;$interpolate&lt;/code&gt;&lt;/a&gt; service with a syntax for handling pluralization and gender specific messages, which is based on the &lt;a href=&quot;http://userguide.icu-project.org/formatparse/messages#TOC-MessageFormat&quot;&gt;ICU MessageFormat syntax&lt;/a&gt;.</source>
          <target state="translated">ngMessageFormat模块使用基于&lt;a href=&quot;http://userguide.icu-project.org/formatparse/messages#TOC-MessageFormat&quot;&gt;ICU MessageFormat语法的&lt;/a&gt;用于处理复数和性别特定消息的语法扩展了AngularJS &lt;a href=&quot;ng/service/%24interpolate&quot;&gt; &lt;code&gt;$interpolate&lt;/code&gt; &lt;/a&gt;服务。</target>
        </trans-unit>
        <trans-unit id="d6139af9198c6ea6591d92b0c6e44a5918b0ef3f" translate="yes" xml:space="preserve">
          <source>The ngMessages module makes it easy to display form validation or other messages with priority sequencing and animation. To expose these visual messages to screen readers, ngAria injects &lt;code&gt;aria-live=&quot;assertive&quot;&lt;/code&gt;, causing them to be read aloud any time a message is shown, regardless of the user's focus location.</source>
          <target state="translated">ngMessages模块使通过优先级排序和动画显示表单验证或其他消息变得容易。为了将这些可视消息显示给屏幕阅读器，ngAria注入 &lt;code&gt;aria-live=&quot;assertive&quot;&lt;/code&gt; ，从而在显示消息时就大声地读取它们，而与用户的焦点位置无关。</target>
        </trans-unit>
        <trans-unit id="e5dcb2f0c1ee73bf49cf4d3307449f52a66c89cb" translate="yes" xml:space="preserve">
          <source>The ngMousedown directive allows you to specify custom behavior on mousedown event.</source>
          <target state="translated">ngMousedown指令允许你在mousedown事件上指定自定义行为。</target>
        </trans-unit>
        <trans-unit id="12a24db6cdaf7c8d7b5c7c9ac1712f0a02f045a2" translate="yes" xml:space="preserve">
          <source>The ngTouch module with the &lt;a href=&quot;ngtouch/service/%24swipe&quot;&gt;&lt;code&gt;$swipe&lt;/code&gt;&lt;/a&gt; service and the &lt;a href=&quot;ngtouch/directive/ngswipeleft&quot;&gt;&lt;code&gt;ngSwipeLeft&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;ngtouch/directive/ngswiperight&quot;&gt;&lt;code&gt;ngSwipeRight&lt;/code&gt;&lt;/a&gt; directives are deprecated. Instead, stand-alone libraries for touch handling and gesture interaction should be used, for example &lt;a href=&quot;https://hammerjs.github.io/&quot;&gt;HammerJS&lt;/a&gt; (which is also used by Angular).</source>
          <target state="translated">不建议使用带有&lt;a href=&quot;ngtouch/service/%24swipe&quot;&gt; &lt;code&gt;$swipe&lt;/code&gt; &lt;/a&gt;服务以及&lt;a href=&quot;ngtouch/directive/ngswipeleft&quot;&gt; &lt;code&gt;ngSwipeLeft&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;ngtouch/directive/ngswiperight&quot;&gt; &lt;code&gt;ngSwipeRight&lt;/code&gt; &lt;/a&gt;指令的ngTouch模块。相反，应该使用用于触摸处理和手势交互的独立库，例如&lt;a href=&quot;https://hammerjs.github.io/&quot;&gt;HammerJS&lt;/a&gt;（Angular也使用它）。</target>
        </trans-unit>
        <trans-unit id="bd0e07d269ab6c4c785c9230592a8e454b8abbf0" translate="yes" xml:space="preserve">
          <source>The nice thing about JS-based animations is that we can inject other services and make use of advanced animation libraries such as greensock.js and velocity.js.</source>
          <target state="translated">基于JS的动画的好处是,我们可以注入其他服务,并利用高级动画库,如greensock.js和velocity.js。</target>
        </trans-unit>
        <trans-unit id="fc6b6e566f3c4a65197842b008029ca49468b417" translate="yes" xml:space="preserve">
          <source>The nice thing here is that we can save bandwidth by sticking to our CSS-based animation code and we don't need to rely on a 3rd-party animation framework.</source>
          <target state="translated">这里的好处是,我们可以通过坚持使用我们基于CSS的动画代码来节省带宽,我们不需要依赖第三方动画框架。</target>
        </trans-unit>
        <trans-unit id="b33d91c29f5b7375a54f9743cd38ebe14c38ac55" translate="yes" xml:space="preserve">
          <source>The normal flow of a browser receiving an event is that it executes a corresponding JavaScript callback. Once the callback completes the browser re-renders the DOM and returns to waiting for more events.</source>
          <target state="translated">浏览器接收到一个事件的正常流程是,它执行一个相应的JavaScript回调。一旦回调完成,浏览器会重新渲染DOM,并返回等待更多事件。</target>
        </trans-unit>
        <trans-unit id="e595827e846ea3517809cce5d8c144967ea0c1ef" translate="yes" xml:space="preserve">
          <source>The number of &lt;code&gt;$onChanges&lt;/code&gt; hook iterations.</source>
          <target state="translated">数 &lt;code&gt;$onChanges&lt;/code&gt; 钩迭代。</target>
        </trans-unit>
        <trans-unit id="10748404b29dfc81bb9c7e5cd26dc4c6c3875599" translate="yes" xml:space="preserve">
          <source>The number of digest iterations.</source>
          <target state="translated">文摘的迭代次数。</target>
        </trans-unit>
        <trans-unit id="0ec2f5ba906afbf68077b33918a003e2cbe4f8cd" translate="yes" xml:space="preserve">
          <source>The number of milliseconds to flush.</source>
          <target state="translated">冲洗的毫秒数。</target>
        </trans-unit>
        <trans-unit id="3ec3b6d1b9bf0ba9bca47ebec8531321e98b8a2c" translate="yes" xml:space="preserve">
          <source>The number of spaces to use per indentation, defaults to 2.</source>
          <target state="translated">每个缩进的空格数,默认为2。</target>
        </trans-unit>
        <trans-unit id="e318b90e5449cb088bf22638bad5bf3451b67f6f" translate="yes" xml:space="preserve">
          <source>The object may have following properties:</source>
          <target state="translated">该对象可能具有以下属性:</target>
        </trans-unit>
        <trans-unit id="c455371f2478051b104228b4d093ce69f37c3dee" translate="yes" xml:space="preserve">
          <source>The object returned from a call to &lt;code&gt;$resource&lt;/code&gt; is a resource &quot;class&quot; which has one &quot;static&quot; method for each action in the definition.</source>
          <target state="translated">从调用 &lt;code&gt;$resource&lt;/code&gt; 返回的对象是资源&amp;ldquo;类&amp;rdquo;，该类对定义中的每个操作都有一个&amp;ldquo;静态&amp;rdquo;方法。</target>
        </trans-unit>
        <trans-unit id="0021d7966fedb869c64e8e751b9c6b3663b8b853" translate="yes" xml:space="preserve">
          <source>The observer function will be invoked once during the next &lt;code&gt;$digest&lt;/code&gt; following compilation. The observer is then invoked whenever the interpolated value changes.</source>
          <target state="translated">在编译之后的下一个 &lt;code&gt;$digest&lt;/code&gt; ，观察者函数将被调用一次。每当插值改变时，观察者就会被调用。</target>
        </trans-unit>
        <trans-unit id="f09b420cec82adc9e93555eea36b1573051e63e6" translate="yes" xml:space="preserve">
          <source>The options to be passed to the &lt;a href=&quot;../service/%24http&quot;&gt;&lt;code&gt;$http&lt;/code&gt;&lt;/a&gt; service when making the request. You can use this to override options such as the &quot;Accept&quot; header for template requests.</source>
          <target state="translated">发出请求时传递给&lt;a href=&quot;../service/%24http&quot;&gt; &lt;code&gt;$http&lt;/code&gt; &lt;/a&gt;服务的选项。您可以使用它来覆盖选项，例如模板请求的&amp;ldquo; Accept&amp;rdquo;标头。</target>
        </trans-unit>
        <trans-unit id="f020acdfb92309bd111f3fab8ddc649fcd4938a1" translate="yes" xml:space="preserve">
          <source>The order of identifiers in the array is the same as the order of argument names in the factory function.</source>
          <target state="translated">数组中标识符的顺序与工厂函数中参数名的顺序相同。</target>
        </trans-unit>
        <trans-unit id="035c8a97bdb0e87e941aebeda2e7e759c1233766" translate="yes" xml:space="preserve">
          <source>The page should reload and the debug information should now be available.</source>
          <target state="translated">该页面应重新加载,现在应该可以获得调试信息。</target>
        </trans-unit>
        <trans-unit id="269c704d66caa90f4de39092f24e2ae227e2de22" translate="yes" xml:space="preserve">
          <source>The parent scope will propagate the &lt;a href=&quot;%24rootscope.scope#%24digest.html&quot;&gt;$digest()&lt;/a&gt; event. The scope can be removed from the scope hierarchy using &lt;a href=&quot;%24rootscope.scope#%24destroy.html&quot;&gt;$destroy()&lt;/a&gt;.</source>
          <target state="translated">父作用域将传播&lt;a href=&quot;%24rootscope.scope#%24digest.html&quot;&gt;$ digest（）&lt;/a&gt;事件。可以使用&lt;a href=&quot;%24rootscope.scope#%24destroy.html&quot;&gt;$ destroy（）&lt;/a&gt;从范围层次结构中删除范围。</target>
        </trans-unit>
        <trans-unit id="d8541058d76a0f7d9d5c86cb32a517c836066fea" translate="yes" xml:space="preserve">
          <source>The plural syntax supports an optional &lt;code&gt;offset&lt;/code&gt; syntax that is used in matching. It's simpler to explain this with an example.</source>
          <target state="translated">复数语法支持在匹配中使用的可选 &lt;code&gt;offset&lt;/code&gt; 语法。用一个例子来解释它更简单。</target>
        </trans-unit>
        <trans-unit id="ba16850007938f287f3d5f3ebf4f4bdd4d282552" translate="yes" xml:space="preserve">
          <source>The predicate to be used for selecting items from &lt;code&gt;array&lt;/code&gt;.</source>
          <target state="translated">用于从 &lt;code&gt;array&lt;/code&gt; 中选择项目的谓词。</target>
        </trans-unit>
        <trans-unit id="82cb53a88d473e7292dcc9cba41cca1fec750b0a" translate="yes" xml:space="preserve">
          <source>The presence of the &lt;code&gt;draggable&lt;/code&gt; attribute on any element gives the element new behavior. We extended the vocabulary of the browser in a way which is natural to anyone who is familiar with the principles of HTML.</source>
          <target state="translated">任何元素上都存在 &lt;code&gt;draggable&lt;/code&gt; 属性，这会给元素新的行为。对于熟悉HTML原理的任何人，我们都以一种自然的方式扩展了浏览器的词汇表。</target>
        </trans-unit>
        <trans-unit id="e8b3768b71fbf0ccd49b698b097de049160fa839" translate="yes" xml:space="preserve">
          <source>The previous &lt;code&gt;ModelOptions&lt;/code&gt; value will not be modified. Instead, a new &lt;code&gt;ModelOptions&lt;/code&gt; object will inherit from the previous one overriding or inheriting settings that are defined in the given parameter.</source>
          <target state="translated">先前的 &lt;code&gt;ModelOptions&lt;/code&gt; 值将不会被修改。取而代之的是，新的 &lt;code&gt;ModelOptions&lt;/code&gt; 对象将从先前的一个覆盖或继承给定参数中定义的设置中继承。</target>
        </trans-unit>
        <trans-unit id="f32c9a1255f13a76d79607f3121c109beee3aef7" translate="yes" xml:space="preserve">
          <source>The purpose of the deferred object is to expose the associated Promise instance as well as APIs that can be used for signaling the successful or unsuccessful completion, as well as the status of the task.</source>
          <target state="translated">延迟对象的目的是暴露相关的Promise实例以及API,这些API可用于发出成功或不成功完成的信号,以及任务的状态。</target>
        </trans-unit>
        <trans-unit id="84e8768d7c2eb6eea9fb7b09e5578fa5d987cd4d" translate="yes" xml:space="preserve">
          <source>The purpose of the promise object is to allow for interested parties to get access to the result of the deferred task when it completes.</source>
          <target state="translated">承诺对象的目的是允许相关方在延迟任务完成后获得对其结果的访问。</target>
        </trans-unit>
        <trans-unit id="12c0a0d61ee769dc0a7c1715994804f7277a2078" translate="yes" xml:space="preserve">
          <source>The recipe for getting help on your unique issue is to create an example that could work (even if it doesn't) in a shareable example on &lt;a href=&quot;http://plnkr.co/&quot;&gt;Plunker&lt;/a&gt;, &lt;a href=&quot;http://jsfiddle.net/&quot;&gt;JSFiddle&lt;/a&gt;, or similar site and then post to one of the following:</source>
          <target state="translated">在您的独特问题上寻求帮助的秘诀是在&lt;a href=&quot;http://plnkr.co/&quot;&gt;Plunker&lt;/a&gt;，&lt;a href=&quot;http://jsfiddle.net/&quot;&gt;JSFiddle&lt;/a&gt;或类似站点上的一个共享示例中创建一个可以工作（即使不起作用）的示例，然后发布到以下其中之一：</target>
        </trans-unit>
        <trans-unit id="35fb232d4894865030ea1759887368f2aded3f73" translate="yes" xml:space="preserve">
          <source>The reference to &lt;code&gt;myApp&lt;/code&gt; module in &lt;code&gt;&amp;lt;div ng-app=&quot;myApp&quot;&amp;gt;&lt;/code&gt;. This is what bootstraps the app using your module.</source>
          <target state="translated">&lt;code&gt;&amp;lt;div ng-app=&quot;myApp&quot;&amp;gt;&lt;/code&gt; 对 &lt;code&gt;myApp&lt;/code&gt; 模块的引用。这就是使用您的模块引导应用程序的内容。</target>
        </trans-unit>
        <trans-unit id="d8810477942beaeaee286fe81161c775d9da02eb" translate="yes" xml:space="preserve">
          <source>The regular expression must be an instance of RegExp (i.e. not a string.) It is matched against the &lt;strong&gt;entire&lt;/strong&gt;&lt;em&gt;normalized / absolute URL&lt;/em&gt; of the resource being tested (even when the RegExp did not have the &lt;code&gt;^&lt;/code&gt; and &lt;code&gt;$&lt;/code&gt; codes.) In addition, any flags present on the RegExp (such as multiline, global, ignoreCase) are ignored.</source>
          <target state="translated">正则表达式必须是RegExp的一个实例（即不是字符串）。它与要测试的资源的&lt;strong&gt;整个&lt;/strong&gt;&lt;em&gt;规范化/绝对URL&lt;/em&gt;匹配（即使RegExp没有 &lt;code&gt;^&lt;/code&gt; 和 &lt;code&gt;$&lt;/code&gt; 代码也是如此）。 RegExp中存在的标志（例如多行，全局，ignoreCase）将被忽略。</target>
        </trans-unit>
        <trans-unit id="862fa8a8a687fa2b536d9c358bd6db3e5af9b82c" translate="yes" xml:space="preserve">
          <source>The replacement process migrates all of the attributes / classes from the old element to the new one. See the &lt;a href=&quot;../../../guide/directive#template-expanding-directive.html&quot;&gt;Directives Guide&lt;/a&gt; for an example.</source>
          <target state="translated">替换过程将所有属性/类从旧元素迁移到新元素。有关示例，请参见《&lt;a href=&quot;../../../guide/directive#template-expanding-directive.html&quot;&gt;指令指南》&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="baae8e3179a72344916f02ad84053532a8debe76" translate="yes" xml:space="preserve">
          <source>The response object has these properties:</source>
          <target state="translated">响应对象具有这些属性。</target>
        </trans-unit>
        <trans-unit id="954fa0733320ae27181ccf9760b44cb912d27915" translate="yes" xml:space="preserve">
          <source>The result of a prior &lt;a href=&quot;%24sce#trustAs.html&quot;&gt;&lt;code&gt;$sce.trustAs&lt;/code&gt;&lt;/a&gt; call, or anything else (which will not be considered trusted.)</source>
          <target state="translated">先前&lt;a href=&quot;%24sce#trustAs.html&quot;&gt; &lt;code&gt;$sce.trustAs&lt;/code&gt; &lt;/a&gt;调用或其他任何结果（不会被认为是可信的）的结果。</target>
        </trans-unit>
        <trans-unit id="778ed68784500d80168f4f1cb8de42f22ef35550" translate="yes" xml:space="preserve">
          <source>The result of a prior &lt;a href=&quot;%24scedelegate#trustAs.html&quot;&gt;&lt;code&gt;$sceDelegate.trustAs&lt;/code&gt;&lt;/a&gt; call or anything else.</source>
          <target state="translated">先前&lt;a href=&quot;%24scedelegate#trustAs.html&quot;&gt; &lt;code&gt;$sceDelegate.trustAs&lt;/code&gt; &lt;/a&gt;调用或其他任何结果。</target>
        </trans-unit>
        <trans-unit id="f6e45a4404226652de8c58acd05d8e6b3ea99beb" translate="yes" xml:space="preserve">
          <source>The result of a prior &lt;a href=&quot;%24scedelegate#trustAs.html&quot;&gt;&lt;code&gt;$sceDelegate.trustAs&lt;/code&gt;&lt;/a&gt; call, or anything else (which will not be considered trusted.)</source>
          <target state="translated">先前&lt;a href=&quot;%24scedelegate#trustAs.html&quot;&gt; &lt;code&gt;$sceDelegate.trustAs&lt;/code&gt; &lt;/a&gt;调用或其他任何结果（不会被认为是可信的）的结果。</target>
        </trans-unit>
        <trans-unit id="0fbfd9ab10f2fcfc0e43605231238f6c0ded7faf" translate="yes" xml:space="preserve">
          <source>The result of evaluating the expression.</source>
          <target state="translated">评价表达式的结果。</target>
        </trans-unit>
        <trans-unit id="24d1f7d570b94cc6ad9c9b7d800fac81d6320b04" translate="yes" xml:space="preserve">
          <source>The result of this is a live binding between the scope and the DOM. So at this point, a change in a model on the compiled scope will be reflected in the DOM.</source>
          <target state="translated">这样做的结果是作用域和DOM之间的实时绑定。因此,在这一点上,编译后的作用域上的模型变化将反映在DOM中。</target>
        </trans-unit>
        <trans-unit id="a6b6643299e7c2857ed4c1427bec152f0e242127" translate="yes" xml:space="preserve">
          <source>The return value of &lt;code&gt;$sce.getTrusted($sce.CSS, value)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;$sce.getTrusted($sce.CSS, value)&lt;/code&gt; 的返回值</target>
        </trans-unit>
        <trans-unit id="45a813410d787bc2a054b283286cdbe7c1020ab1" translate="yes" xml:space="preserve">
          <source>The return value of &lt;code&gt;$sce.getTrusted($sce.HTML, value)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;$sce.getTrusted($sce.HTML, value)&lt;/code&gt; 的返回值</target>
        </trans-unit>
        <trans-unit id="b3ca9d9ba8ef58892b2647a2857931cb76ed96f4" translate="yes" xml:space="preserve">
          <source>The return value of &lt;code&gt;$sce.getTrusted($sce.JS, value)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;$sce.getTrusted($sce.JS, value)&lt;/code&gt; 的返回值</target>
        </trans-unit>
        <trans-unit id="7f0c5cf3a8e15099fba3a60e6508cb831477a19c" translate="yes" xml:space="preserve">
          <source>The return value of &lt;code&gt;$sce.getTrusted($sce.RESOURCE_URL, value)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;$sce.getTrusted($sce.RESOURCE_URL, value)&lt;/code&gt; 的返回值</target>
        </trans-unit>
        <trans-unit id="295e8d1672e32e8c877e2dda418b912ffdc21e8b" translate="yes" xml:space="preserve">
          <source>The return value of &lt;code&gt;$sce.getTrusted($sce.URL, value)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;$sce.getTrusted($sce.URL, value)&lt;/code&gt; 的返回值</target>
        </trans-unit>
        <trans-unit id="85ef2c181da5028df11fbde1df5de14ad91e5d03" translate="yes" xml:space="preserve">
          <source>The return value of calling &lt;code&gt;$timeout&lt;/code&gt; is a promise, which will be resolved when the delay has passed and the timeout function, if provided, is executed.</source>
          <target state="translated">调用 &lt;code&gt;$timeout&lt;/code&gt; 的返回值是一个承诺，当延迟已过去并且执行了超时功能（如果提供）时，将解决该承诺。</target>
        </trans-unit>
        <trans-unit id="3b91569091098ef8818bad33c1660a55b8735e97" translate="yes" xml:space="preserve">
          <source>The return value of registering an interval function is a promise. This promise will be notified upon each tick of the interval, and will be resolved after &lt;code&gt;count&lt;/code&gt; iterations, or run indefinitely if &lt;code&gt;count&lt;/code&gt; is not defined. The value of the notification will be the number of iterations that have run. To cancel an interval, call &lt;code&gt;$interval.cancel(promise)&lt;/code&gt;.</source>
          <target state="translated">注册间隔函数的返回值是一个承诺。该承诺将在间隔的每个刻度上通知，并在 &lt;code&gt;count&lt;/code&gt; 迭代后解决，或者如果未定义 &lt;code&gt;count&lt;/code&gt; 则无限期运行。通知的值将是已运行的迭代数。要取消间隔，请调用 &lt;code&gt;$interval.cancel(promise)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ffa5113ebf43540eb4e8acfea21d2d33bd174676" translate="yes" xml:space="preserve">
          <source>The returned function also has the following properties:</source>
          <target state="translated">返回的函数还具有以下属性。</target>
        </trans-unit>
        <trans-unit id="b5179be6b86116655b38058f0ad19bd9de4712c8" translate="yes" xml:space="preserve">
          <source>The returned resource object has action methods which provide high-level behaviors without the need to interact with the low level &lt;a href=&quot;../../ng/service/%24http&quot;&gt;$http&lt;/a&gt; service.</source>
          <target state="translated">返回的资源对象具有可提供高级行为的操作方法，而无需与低级&lt;a href=&quot;../../ng/service/%24http&quot;&gt;$ http&lt;/a&gt;服务进行交互。</target>
        </trans-unit>
        <trans-unit id="6023496af7670d9c11586559bb4cd6e937a06ca6" translate="yes" xml:space="preserve">
          <source>The root element of AngularJS application. This is either the element where &lt;a href=&quot;../directive/ngapp&quot;&gt;ngApp&lt;/a&gt; was declared or the element passed into &lt;a href=&quot;../function/angular.bootstrap&quot;&gt;&lt;code&gt;angular.bootstrap&lt;/code&gt;&lt;/a&gt;. The element represents the root element of application. It is also the location where the application's &lt;a href=&quot;../../auto/service/%24injector&quot;&gt;$injector&lt;/a&gt; service gets published, and can be retrieved using &lt;code&gt;$rootElement.injector()&lt;/code&gt;.</source>
          <target state="translated">AngularJS应用程序的根元素。这是声明&lt;a href=&quot;../directive/ngapp&quot;&gt;ngApp&lt;/a&gt;的元素，也可能是传递到&lt;a href=&quot;../function/angular.bootstrap&quot;&gt; &lt;code&gt;angular.bootstrap&lt;/code&gt; &lt;/a&gt;的元素。元素表示应用程序的根元素。这也是应用程序的&lt;a href=&quot;../../auto/service/%24injector&quot;&gt;$ injector&lt;/a&gt;服务发布的位置，可以使用 &lt;code&gt;$rootElement.injector()&lt;/code&gt; 进行检索。</target>
        </trans-unit>
        <trans-unit id="24dbde550866bde503deb0950b1e8e1246eac032" translate="yes" xml:space="preserve">
          <source>The root element of AngularJS application. This is either the element where &lt;a href=&quot;directive/ngapp&quot;&gt;ngApp&lt;/a&gt; was declared or the element passed into &lt;a href=&quot;function/angular.bootstrap&quot;&gt;&lt;code&gt;angular.bootstrap&lt;/code&gt;&lt;/a&gt;. The element represents the root element of application. It is also the location where the application's &lt;a href=&quot;../auto/service/%24injector&quot;&gt;$injector&lt;/a&gt; service gets published, and can be retrieved using &lt;code&gt;$rootElement.injector()&lt;/code&gt;.</source>
          <target state="translated">AngularJS应用程序的根元素。这是声明&lt;a href=&quot;directive/ngapp&quot;&gt;ngApp&lt;/a&gt;的元素，也可能是传递到&lt;a href=&quot;function/angular.bootstrap&quot;&gt; &lt;code&gt;angular.bootstrap&lt;/code&gt; &lt;/a&gt;的元素。元素表示应用程序的根元素。这也是应用程序的&lt;a href=&quot;../auto/service/%24injector&quot;&gt;$ injector&lt;/a&gt;服务发布的位置，可以使用 &lt;code&gt;$rootElement.injector()&lt;/code&gt; 进行检索。</target>
        </trans-unit>
        <trans-unit id="9fcf79b2ca7c0e61431c4ddcce676e6a46e50533" translate="yes" xml:space="preserve">
          <source>The root scope</source>
          <target state="translated">根范围</target>
        </trans-unit>
        <trans-unit id="af6c0993a1b0bfa5a18a6aaa404dc362b0e915a7" translate="yes" xml:space="preserve">
          <source>The route change (and the &lt;code&gt;$location&lt;/code&gt; change that triggered it) can be prevented by calling &lt;code&gt;preventDefault&lt;/code&gt; method of the event. See &lt;a href=&quot;../../ng/type/%24rootscope.scope#%24on.html&quot;&gt;&lt;code&gt;$rootScope.Scope&lt;/code&gt;&lt;/a&gt; for more details about event object.</source>
          <target state="translated">可以通过调用事件的 &lt;code&gt;preventDefault&lt;/code&gt; 方法来防止路由更改（以及触发它的 &lt;code&gt;$location&lt;/code&gt; 更改）。有关事件对象的更多详细信息，请参见&lt;a href=&quot;../../ng/type/%24rootscope.scope#%24on.html&quot;&gt; &lt;code&gt;$rootScope.Scope&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="fa7560a7875748906d4d03990b3f182804ac86d0" translate="yes" xml:space="preserve">
          <source>The route parameters are a combination of &lt;a href=&quot;../../ng/service/%24location&quot;&gt;&lt;code&gt;$location&lt;/code&gt;&lt;/a&gt;'s &lt;a href=&quot;../../ng/service/%24location#search.html&quot;&gt;&lt;code&gt;search()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../ng/service/%24location#path.html&quot;&gt;&lt;code&gt;path()&lt;/code&gt;&lt;/a&gt;. The &lt;code&gt;path&lt;/code&gt; parameters are extracted when the &lt;a href=&quot;%24route&quot;&gt;&lt;code&gt;$route&lt;/code&gt;&lt;/a&gt; path is matched.</source>
          <target state="translated">路径参数是&lt;a href=&quot;../../ng/service/%24location&quot;&gt; &lt;code&gt;$location&lt;/code&gt; &lt;/a&gt;的&lt;a href=&quot;../../ng/service/%24location#search.html&quot;&gt; &lt;code&gt;search()&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../../ng/service/%24location#path.html&quot;&gt; &lt;code&gt;path()&lt;/code&gt; 的组合&lt;/a&gt;。该 &lt;code&gt;path&lt;/code&gt; 时，被提取的参数&lt;a href=&quot;%24route&quot;&gt; &lt;code&gt;$route&lt;/code&gt; &lt;/a&gt;路径匹配。</target>
        </trans-unit>
        <trans-unit id="a43d955a33928fdf9831543b7e1ccfb18aac7d0a" translate="yes" xml:space="preserve">
          <source>The same approach to animation can be used using JavaScript code (&lt;strong&gt;for simplicity, we rely on jQuery to perform animations here&lt;/strong&gt;):</source>
          <target state="translated">可以使用JavaScript代码使用相同的动画方法（&lt;strong&gt;为简单起见，我们在这里依靠jQuery来执行动画&lt;/strong&gt;）：</target>
        </trans-unit>
        <trans-unit id="523d2b0e20860e85d563f00d6bc85a673967639f" translate="yes" xml:space="preserve">
          <source>The sanitization is a security measure aimed at prevent XSS attacks via html links.</source>
          <target state="translated">净化是一种安全措施,旨在防止通过html链接进行XSS攻击。</target>
        </trans-unit>
        <trans-unit id="1c5c39472248d0e17c07e839034df405aa0eb20b" translate="yes" xml:space="preserve">
          <source>The sanitization is a security measure aimed at preventing XSS attacks via html links.</source>
          <target state="translated">净化是一种安全措施,旨在防止通过html链接进行XSS攻击。</target>
        </trans-unit>
        <trans-unit id="b4a02425298ded7dac67b95b4a87a03949623e78" translate="yes" xml:space="preserve">
          <source>The scope property can be &lt;code&gt;false&lt;/code&gt;, &lt;code&gt;true&lt;/code&gt;, or an object:</source>
          <target state="translated">scope属性可以是 &lt;code&gt;false&lt;/code&gt; ， &lt;code&gt;true&lt;/code&gt; 或对象：</target>
        </trans-unit>
        <trans-unit id="f955ab37c085081f8ecb0e355fa65bbe8fdd0a33" translate="yes" xml:space="preserve">
          <source>The second approach (including the locale JavaScript file in &lt;code&gt;index.html&lt;/code&gt;) may be slower because an extra script needs to be loaded.</source>
          <target state="translated">第二种方法（包括 &lt;code&gt;index.html&lt;/code&gt; 中的语言环境JavaScript文件）可能较慢，因为需要加载额外的脚本。</target>
        </trans-unit>
        <trans-unit id="ef0a91ee83246c2362ec6b21594ab31561d60a90" translate="yes" xml:space="preserve">
          <source>The second kind of new markup are the double curly braces &lt;code&gt;{{ expression | filter }}&lt;/code&gt;: When the compiler encounters this markup, it will replace it with the evaluated value of the markup. An &lt;a href=&quot;expression&quot;&gt;expression&lt;/a&gt; in a template is a JavaScript-like code snippet that allows AngularJS to read and write variables. Note that those variables are not global variables. Just like variables in a JavaScript function live in a scope, AngularJS provides a &lt;a href=&quot;scope&quot;&gt;scope&lt;/a&gt; for the variables accessible to expressions. The values that are stored in variables on the scope are referred to as the &lt;em&gt;model&lt;/em&gt; in the rest of the documentation. Applied to the example above, the markup directs AngularJS to &quot;take the data we got from the input widgets and multiply them together&quot;.</source>
          <target state="translated">第二种新标记是双花括号 &lt;code&gt;{{ expression | filter }}&lt;/code&gt; ：当编译器遇到该标记时，它将用标记的评估值替换它。模板中的&lt;a href=&quot;expression&quot;&gt;表达式&lt;/a&gt;是类似于JavaScript的代码段，允许AngularJS读取和写入变量。请注意，这些变量不是全局变量。就像JavaScript函数中的变量存在于作用域中一样，AngularJS为表达式可访问的变量提供了&lt;a href=&quot;scope&quot;&gt;作用域&lt;/a&gt;。存储在范围内变量中的值在本文档的其余部分中称为&lt;em&gt;模型&lt;/em&gt;。在上面的示例中，标记指示AngularJS&amp;ldquo;从输入小部件中获取数据并将它们相乘&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="2ebae70ef1fa6d7815534c38bd1f7fc688ed15c4" translate="yes" xml:space="preserve">
          <source>The second option is more common in the AngularJS community, and is generally used in boilerplates and in this guide. However, there are advantages to binding properties directly to the controller and avoiding scope.</source>
          <target state="translated">第二种方案在AngularJS社区比较常见,一般在锅炉模板和本指南中使用。不过,直接将属性绑定到控制器上,避免了作用域,也是有好处的。</target>
        </trans-unit>
        <trans-unit id="58b2b19de1ee7661079f7d4e8bb9f6b0ded798f9" translate="yes" xml:space="preserve">
          <source>The section &lt;a href=&quot;scope#directives-that-create-scopes.html&quot;&gt;Directives that Create Scopes&lt;/a&gt; has more info about which directives create scopes.</source>
          <target state="translated">&amp;ldquo; &lt;a href=&quot;scope#directives-that-create-scopes.html&quot;&gt;创建作用域的指令&lt;/a&gt; &amp;rdquo;部分提供了有关哪些指令创建作用域的更多信息。</target>
        </trans-unit>
        <trans-unit id="7899b56cd85970f84bbdd5c6f66e1f854610afa5" translate="yes" xml:space="preserve">
          <source>The selection keywords can be either exact matches or language dependent &lt;a href=&quot;http://cldr.unicode.org/index/cldr-spec/plural-rules&quot;&gt;plural categories&lt;/a&gt;.</source>
          <target state="translated">选择关键字可以是完全匹配，也可以是语言相关的&lt;a href=&quot;http://cldr.unicode.org/index/cldr-spec/plural-rules&quot;&gt;复数类别&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b8625b6727f5759d3c8e5906c05a932804143e94" translate="yes" xml:space="preserve">
          <source>The service guarantees that the identity of the &lt;code&gt;$routeParams&lt;/code&gt; object will remain unchanged (but its properties will likely change) even when a route change occurs.</source>
          <target state="translated">该服务保证 &lt;code&gt;$routeParams&lt;/code&gt; 对象的身份将保持不变（但其属性可能会更改），即使发生路由更改也是如此。</target>
        </trans-unit>
        <trans-unit id="60b4ba9fbc0c43d1d89edc827281cf4b26db6b11" translate="yes" xml:space="preserve">
          <source>The simplest form is to extract the dependencies from the arguments of the function. This is done by converting the function into a string using &lt;code&gt;toString()&lt;/code&gt; method and extracting the argument names.</source>
          <target state="translated">最简单的形式是从函数的参数中提取依赖项。这是通过使用 &lt;code&gt;toString()&lt;/code&gt; 方法将函数转换为字符串并提取参数名称来完成的。</target>
        </trans-unit>
        <trans-unit id="3d8b353bfb07213b4379a03d5d422c15fb95b7ac" translate="yes" xml:space="preserve">
          <source>The simplest way to get hold of the dependencies is to assume that the function parameter names are the names of the dependencies.</source>
          <target state="translated">掌握依赖关系的最简单方法是假设函数参数名就是依赖关系的名称。</target>
        </trans-unit>
        <trans-unit id="c64a50b85ba98a676c625d981a6a8bbf9f4f8a52" translate="yes" xml:space="preserve">
          <source>The singleton instance of the &lt;a href=&quot;../type/rootrouter&quot;&gt;&lt;code&gt;RootRouter&lt;/code&gt;&lt;/a&gt; type, which is associated with the top level &lt;a href=&quot;%24routerrootcomponent&quot;&gt;&lt;code&gt;$routerRootComponent&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../type/rootrouter&quot;&gt; &lt;code&gt;RootRouter&lt;/code&gt; &lt;/a&gt;类型的单例实例，与顶级&lt;a href=&quot;%24routerrootcomponent&quot;&gt; &lt;code&gt;$routerRootComponent&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ba995a06669ab9293ed40548419fa1f16acfcf3f" translate="yes" xml:space="preserve">
          <source>The singleton instance of the &lt;a href=&quot;ngcomponentrouter/type/rootrouter&quot;&gt;&lt;code&gt;RootRouter&lt;/code&gt;&lt;/a&gt; type, which is associated with the top level &lt;a href=&quot;ngcomponentrouter/service/%24routerrootcomponent&quot;&gt;&lt;code&gt;$routerRootComponent&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;ngcomponentrouter/type/rootrouter&quot;&gt; &lt;code&gt;RootRouter&lt;/code&gt; &lt;/a&gt;类型的单例实例，与顶级&lt;a href=&quot;ngcomponentrouter/service/%24routerrootcomponent&quot;&gt; &lt;code&gt;$routerRootComponent&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d028290d2d263328b04957680190b4fc0e324747" translate="yes" xml:space="preserve">
          <source>The singleton instance of the &lt;a href=&quot;type/rootrouter&quot;&gt;&lt;code&gt;RootRouter&lt;/code&gt;&lt;/a&gt; type, which is associated with the top level &lt;a href=&quot;service/%24routerrootcomponent&quot;&gt;&lt;code&gt;$routerRootComponent&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;type/rootrouter&quot;&gt; &lt;code&gt;RootRouter&lt;/code&gt; &lt;/a&gt;类型的单例实例，与顶级&lt;a href=&quot;service/%24routerrootcomponent&quot;&gt; &lt;code&gt;$routerRootComponent&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="767e784d7ccc55d7ed23bfc011d3d6882f0b815d" translate="yes" xml:space="preserve">
          <source>The solution is to break the compilation process into two phases:</source>
          <target state="translated">解决办法是将编译过程分为两个阶段。</target>
        </trans-unit>
        <trans-unit id="44bd33d4e5c5dbd425e1b01d352cce7c15b457b1" translate="yes" xml:space="preserve">
          <source>The sorted array.</source>
          <target state="translated">排序后的数组。</target>
        </trans-unit>
        <trans-unit id="2132b1a1146e5e5ced071e842080bf9a009b6944" translate="yes" xml:space="preserve">
          <source>The source array.</source>
          <target state="translated">源数组。</target>
        </trans-unit>
        <trans-unit id="0e88179bff5210ac7427674521c7a3345e2dd3b9" translate="yes" xml:space="preserve">
          <source>The source that will be used to make a copy. Can be any type, including primitives, &lt;code&gt;null&lt;/code&gt;, and &lt;code&gt;undefined&lt;/code&gt;.</source>
          <target state="translated">用来制作副本的来源。可以是任何类型，包括基本类型， &lt;code&gt;null&lt;/code&gt; 和 &lt;code&gt;undefined&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d85a9cbe026aa1a3ba5f747284fb0ad3f412ddf3" translate="yes" xml:space="preserve">
          <source>The special &lt;strong&gt;string&lt;/strong&gt;, &lt;code&gt;'self'&lt;/code&gt;, can be used to match against all URLs of the &lt;strong&gt;same domain&lt;/strong&gt; as the application document using the &lt;strong&gt;same protocol&lt;/strong&gt;.</source>
          <target state="translated">特殊&lt;strong&gt;的字符串&lt;/strong&gt;， &lt;code&gt;'self'&lt;/code&gt; ，可以用于匹配所述的所有URL &lt;strong&gt;相同的域&lt;/strong&gt;为使用应用程序文件&lt;strong&gt;相同的协议&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="b55be8e2b115455f7e384250866854b317142fba" translate="yes" xml:space="preserve">
          <source>The special property name that matches against any property. By default &lt;code&gt;$&lt;/code&gt;.</source>
          <target state="translated">与任何属性匹配的特殊属性名称。默认情况下 &lt;code&gt;$&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7279a354975752084c586a2a76858e65adbcf9b6" translate="yes" xml:space="preserve">
          <source>The streamlined ES6 style promise is essentially just using $q as a constructor which takes a &lt;code&gt;resolver&lt;/code&gt; function as the first argument. This is similar to the native Promise implementation from ES6, see &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt;MDN&lt;/a&gt;.</source>
          <target state="translated">简化的ES6样式承诺实际上只是使用$ q作为构造函数，该构造函数将 &lt;code&gt;resolver&lt;/code&gt; 功能作为第一个参数。这类似于ES6中的本机Promise实现，请参见&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt;MDN&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a25884531cd967bc8dd68721f141065ccbf8a1a8" translate="yes" xml:space="preserve">
          <source>The string can use the &lt;code&gt;controller as property&lt;/code&gt; syntax, where the controller instance is published as the specified property on the &lt;code&gt;scope&lt;/code&gt;; the &lt;code&gt;scope&lt;/code&gt; must be injected into &lt;code&gt;locals&lt;/code&gt; param for this to work correctly.</source>
          <target state="translated">该字符串可以将 &lt;code&gt;controller as property&lt;/code&gt; 语法，在该实例中，controller实例作为 &lt;code&gt;scope&lt;/code&gt; 的指定属性发布；该 &lt;code&gt;scope&lt;/code&gt; 必须被注入到 &lt;code&gt;locals&lt;/code&gt; 参数有关使其正常工作。</target>
        </trans-unit>
        <trans-unit id="a64f560cdc5bc1215f3896949fd70a8f33418cdb" translate="yes" xml:space="preserve">
          <source>The string is matched against the full &lt;em&gt;normalized / absolute URL&lt;/em&gt; of the resource being tested (substring matches are not good enough.)</source>
          <target state="translated">字符串与要测试的资源的完整&lt;em&gt;规范化/绝对URL&lt;/em&gt;匹配（子字符串匹配不够好。）</target>
        </trans-unit>
        <trans-unit id="14ebe6cf667e2257d2375b20acaba4b014d40a48" translate="yes" xml:space="preserve">
          <source>The syntax extension is based on a subset of the ICU MessageFormat syntax that covers plurals and gender selections. Please refer to the links in the &amp;ldquo;Further Reading&amp;rdquo; section at the bottom of this section.</source>
          <target state="translated">语法扩展基于ICU MessageFormat语法的子集，该子集涵盖了复数形式和性别选择。请参考本节底部&amp;ldquo;更多阅读&amp;rdquo;部分中的链接。</target>
        </trans-unit>
        <trans-unit id="b15b3f178b589324cba127ffcc8609a03ddf2842" translate="yes" xml:space="preserve">
          <source>The syntax for gender based message selection looks like the following:</source>
          <target state="translated">基于性别的信息选择的语法如下。</target>
        </trans-unit>
        <trans-unit id="514dc6d368ee619bf7af44246bc3cca46261a937" translate="yes" xml:space="preserve">
          <source>The syntax for plural based message selection looks like the following:</source>
          <target state="translated">基于复数的消息选择的语法如下。</target>
        </trans-unit>
        <trans-unit id="331463984a3b27be7e66de67f6ec1c8959531bed" translate="yes" xml:space="preserve">
          <source>The text with markup to interpolate.</source>
          <target state="translated">带标记的文本进行插值。</target>
        </trans-unit>
        <trans-unit id="236530003226f5a2700778994862268772faf8ef" translate="yes" xml:space="preserve">
          <source>The third option is the most viable, since it removes the responsibility of locating the dependency from the component. The dependency is simply handed to the component.</source>
          <target state="translated">第三种方案是最可行的,因为它免除了组件定位依赖关系的责任。依赖关系只是交给了组件。</target>
        </trans-unit>
        <trans-unit id="4caf4221a8f1aa9f8dc16ac34dd67bede58930f0" translate="yes" xml:space="preserve">
          <source>The thrown error or the rejection reason of the promise. Usually the rejection reason is the error that caused the promise to get rejected.</source>
          <target state="translated">抛出的错误或承诺的拒绝原因。通常拒绝的原因是导致承诺被拒绝的错误。</target>
        </trans-unit>
        <trans-unit id="7a7b44ea3970e86105ad586eeb8a71485b91c29b" translate="yes" xml:space="preserve">
          <source>The top level &lt;strong&gt;Routing Component&lt;/strong&gt; associated with the &lt;a href=&quot;%24rootrouter&quot;&gt;&lt;code&gt;$rootRouter&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">与&lt;a href=&quot;%24rootrouter&quot;&gt; &lt;code&gt;$rootRouter&lt;/code&gt; &lt;/a&gt;关联的顶级&lt;strong&gt;路由组件&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="548afd75a531de9081c581cb6d8715fb94f8f938" translate="yes" xml:space="preserve">
          <source>The top level &lt;strong&gt;Routing Component&lt;/strong&gt; associated with the &lt;a href=&quot;ngcomponentrouter/service/%24rootrouter&quot;&gt;&lt;code&gt;$rootRouter&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">与&lt;a href=&quot;ngcomponentrouter/service/%24rootrouter&quot;&gt; &lt;code&gt;$rootRouter&lt;/code&gt; &lt;/a&gt;关联的顶级&lt;strong&gt;路由组件&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="386ecc261ed1232a9a17fbea9ac69f87afe81bba" translate="yes" xml:space="preserve">
          <source>The top level &lt;strong&gt;Routing Component&lt;/strong&gt; associated with the &lt;a href=&quot;service/%24rootrouter&quot;&gt;&lt;code&gt;$rootRouter&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">与&lt;a href=&quot;service/%24rootrouter&quot;&gt; &lt;code&gt;$rootRouter&lt;/code&gt; &lt;/a&gt;关联的顶级&lt;strong&gt;路由组件&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="5864476324c5e315d5688546efeaae47300579a1" translate="yes" xml:space="preserve">
          <source>The two images match since they share the same ref value. ngAnimate will now create a transport element (which is a clone of the first image element) and it will then attempt to animate to the position of the second image element in the next view. For the animation to work a special CSS class called &lt;code&gt;ng-anchor&lt;/code&gt; will be added to the transported element.</source>
          <target state="translated">这两个图像匹配，因为它们共享相同的参考值。ngAnimate现在将创建一个传输元素（它是第一个图像元素的副本），然后将尝试在下一个视图中动画化第二个图像元素的位置。为了使动画正常工作，将在传输的元素中添加一个名为 &lt;code&gt;ng-anchor&lt;/code&gt; 的特殊CSS类。</target>
        </trans-unit>
        <trans-unit id="0e52841430957d24c12d016a27d0ebbbbee23eb5" translate="yes" xml:space="preserve">
          <source>The type of tasks to check for.</source>
          <target state="translated">要检查的任务类型。</target>
        </trans-unit>
        <trans-unit id="c9809d2c6f9fe9599eaef845df8e9b7ac65b418e" translate="yes" xml:space="preserve">
          <source>The types of tasks that are flushed include:</source>
          <target state="translated">被刷新的任务类型包括。</target>
        </trans-unit>
        <trans-unit id="46b2bd429084177f8681f56d4ade922af6dc9c27" translate="yes" xml:space="preserve">
          <source>The typical usage for the blacklist is to &lt;strong&gt;block &lt;a href=&quot;http://cwe.mitre.org/data/definitions/601.html&quot;&gt;open redirects&lt;/a&gt;&lt;/strong&gt; served by your domain as these would otherwise be trusted but actually return content from the redirected domain.</source>
          <target state="translated">黑名单的典型用法是&lt;strong&gt;阻止&lt;a href=&quot;http://cwe.mitre.org/data/definitions/601.html&quot;&gt;&lt;/a&gt;&lt;/strong&gt;您的域提供的&lt;strong&gt;开放重定向&lt;/strong&gt;，否则这些&lt;strong&gt;重定向&lt;/strong&gt;将受到信任，但实际上会从重定向的域返回内容。</target>
        </trans-unit>
        <trans-unit id="0870b31834bb02fbc73aaf4c9ab88489da8144fb" translate="yes" xml:space="preserve">
          <source>The underlying API is the &lt;a href=&quot;../api/ng/provider/%24filterprovider&quot;&gt;&lt;code&gt;$filterProvider&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">基础API是&lt;a href=&quot;../api/ng/provider/%24filterprovider&quot;&gt; &lt;code&gt;$filterProvider&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7da48aa48cb58f7d4f1b84542c5c4e396f23ea4f" translate="yes" xml:space="preserve">
          <source>The use of &lt;code&gt;eval()&lt;/code&gt;, &lt;code&gt;Function(string)&lt;/code&gt; and similar functions to dynamically create and execute code from strings is forbidden. AngularJS makes use of this in the &lt;a href=&quot;../service/%24parse&quot;&gt;&lt;code&gt;$parse&lt;/code&gt;&lt;/a&gt; service to provide a 30% increase in the speed of evaluating AngularJS expressions. (This CSP rule can be disabled with the CSP keyword &lt;code&gt;unsafe-eval&lt;/code&gt;, but it is generally not recommended as it would weaken the protections offered by CSP.)</source>
          <target state="translated">禁止使用 &lt;code&gt;eval()&lt;/code&gt; ， &lt;code&gt;Function(string)&lt;/code&gt; 和类似函数从字符串动态创建和执行代码。 AngularJS在&lt;a href=&quot;../service/%24parse&quot;&gt; &lt;code&gt;$parse&lt;/code&gt; &lt;/a&gt;服务中利用了这一点，从而使AngularJS表达式的求值速度提高了30％。 （可以使用CSP关键字 &lt;code&gt;unsafe-eval&lt;/code&gt; 禁用此CSP规则，但通常不建议使用它，因为它会削弱CSP提供的保护。）</target>
        </trans-unit>
        <trans-unit id="ab18458a0f8961320a15a220d2d9624ea8d111c4" translate="yes" xml:space="preserve">
          <source>The use of inline resources, such as inline &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;style&amp;gt;&lt;/code&gt; elements, are forbidden. This prevents apps from injecting custom styles directly into the document. AngularJS makes use of this to include some CSS rules (e.g. &lt;a href=&quot;ngcloak&quot;&gt;&lt;code&gt;ngCloak&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;nghide&quot;&gt;&lt;code&gt;ngHide&lt;/code&gt;&lt;/a&gt;). To make these directives work when a CSP rule is blocking inline styles, you must link to the &lt;code&gt;angular-csp.css&lt;/code&gt; in your HTML manually. (This CSP rule can be disabled with the CSP keyword &lt;code&gt;unsafe-inline&lt;/code&gt;, but it is generally not recommended as it would weaken the protections offered by CSP.)</source>
          <target state="translated">禁止使用内联资源，例如内联 &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; 和 &lt;code&gt;&amp;lt;style&amp;gt;&lt;/code&gt; 元素。这样可以防止应用将自定义样式直接注入文档中。 AngularJS利用它来包含一些CSS规则（例如&lt;a href=&quot;ngcloak&quot;&gt; &lt;code&gt;ngCloak&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;nghide&quot;&gt; &lt;code&gt;ngHide&lt;/code&gt; &lt;/a&gt;）。要使这些指令在CSP规则阻止内联样式时起作用，必须手动链接到HTML中的 &lt;code&gt;angular-csp.css&lt;/code&gt; 。 （可以使用CSP关键字 &lt;code&gt;unsafe-inline&lt;/code&gt; 禁用此CSP规则，但通常不建议使用它，因为它会削弱CSP提供的保护。）</target>
        </trans-unit>
        <trans-unit id="eebb37fdb7d6c174eb9c065210d8ec5ba28ee2bf" translate="yes" xml:space="preserve">
          <source>The validator sets the &lt;code&gt;maxlength&lt;/code&gt; error key if the &lt;a href=&quot;../type/ngmodel.ngmodelcontroller#%24viewValue.html&quot;&gt;&lt;code&gt;ngModel.$viewValue&lt;/code&gt;&lt;/a&gt; is longer than the integer obtained by evaluating the AngularJS expression given in the &lt;code&gt;ngMaxlength&lt;/code&gt; attribute value.</source>
          <target state="translated">如果&lt;a href=&quot;../type/ngmodel.ngmodelcontroller#%24viewValue.html&quot;&gt; &lt;code&gt;ngModel.$viewValue&lt;/code&gt; &lt;/a&gt;大于通过评估 &lt;code&gt;ngMaxlength&lt;/code&gt; 属性值中给出的AngularJS表达式获得的整数，则验证器将设置 &lt;code&gt;maxlength&lt;/code&gt; 错误密钥。</target>
        </trans-unit>
        <trans-unit id="95e23f64426ffefd09f928fb9dadff94eb920e6f" translate="yes" xml:space="preserve">
          <source>The validator sets the &lt;code&gt;minlength&lt;/code&gt; error key if the &lt;a href=&quot;../type/ngmodel.ngmodelcontroller#%24viewValue.html&quot;&gt;&lt;code&gt;ngModel.$viewValue&lt;/code&gt;&lt;/a&gt; is shorter than the integer obtained by evaluating the AngularJS expression given in the &lt;code&gt;ngMinlength&lt;/code&gt; attribute value.</source>
          <target state="translated">验证器设置 &lt;code&gt;minlength&lt;/code&gt; 错误键，如果&lt;a href=&quot;../type/ngmodel.ngmodelcontroller#%24viewValue.html&quot;&gt; &lt;code&gt;ngModel.$viewValue&lt;/code&gt; &lt;/a&gt;比通过评估在给定的AngularJS表达式获得整数较短 &lt;code&gt;ngMinlength&lt;/code&gt; 属性值。</target>
        </trans-unit>
        <trans-unit id="e24301c2cb5d52b2ea32feb0ec399b5f0d739449" translate="yes" xml:space="preserve">
          <source>The validator sets the &lt;code&gt;pattern&lt;/code&gt; error key if the &lt;a href=&quot;../type/ngmodel.ngmodelcontroller#%24viewValue.html&quot;&gt;&lt;code&gt;ngModel.$viewValue&lt;/code&gt;&lt;/a&gt; does not match a RegExp which is obtained from the &lt;code&gt;ngPattern&lt;/code&gt; attribute value:</source>
          <target state="translated">如果&lt;a href=&quot;../type/ngmodel.ngmodelcontroller#%24viewValue.html&quot;&gt; &lt;code&gt;ngModel.$viewValue&lt;/code&gt; &lt;/a&gt;与从 &lt;code&gt;ngPattern&lt;/code&gt; 属性值获得的RegExp不匹配，则验证器将设置 &lt;code&gt;pattern&lt;/code&gt; 错误密钥：</target>
        </trans-unit>
        <trans-unit id="8b8747fb2ca401641b1a4ecf5eb6042bf5b61777" translate="yes" xml:space="preserve">
          <source>The validator will set the &lt;code&gt;required&lt;/code&gt; error key to true if the &lt;code&gt;required&lt;/code&gt; attribute is set and calling &lt;a href=&quot;../type/ngmodel.ngmodelcontroller#%24isEmpty.html&quot;&gt;&lt;code&gt;NgModelController.$isEmpty&lt;/code&gt;&lt;/a&gt; with the &lt;a href=&quot;../type/ngmodel.ngmodelcontroller#%24viewValue.html&quot;&gt;&lt;code&gt;ngModel.$viewValue&lt;/code&gt;&lt;/a&gt; returns &lt;code&gt;true&lt;/code&gt;. For example, the &lt;code&gt;$isEmpty()&lt;/code&gt; implementation for &lt;code&gt;input[text]&lt;/code&gt; checks the length of the &lt;code&gt;$viewValue&lt;/code&gt;. When developing custom controls, &lt;code&gt;$isEmpty()&lt;/code&gt; can be overwritten to account for a $viewValue that is not string-based.</source>
          <target state="translated">如果设置了 &lt;code&gt;required&lt;/code&gt; 属性，则验证器会将 &lt;code&gt;required&lt;/code&gt; 错误密钥设置为true，并使用&lt;a href=&quot;../type/ngmodel.ngmodelcontroller#%24viewValue.html&quot;&gt; &lt;code&gt;ngModel.$viewValue&lt;/code&gt; &lt;/a&gt;调用&lt;a href=&quot;../type/ngmodel.ngmodelcontroller#%24isEmpty.html&quot;&gt; &lt;code&gt;NgModelController.$isEmpty&lt;/code&gt; &lt;/a&gt;返回 &lt;code&gt;true&lt;/code&gt; 。例如， &lt;code&gt;input[text]&lt;/code&gt; 的 &lt;code&gt;$isEmpty()&lt;/code&gt; 实现检查 &lt;code&gt;$viewValue&lt;/code&gt; 的长度。在开发自定义控件时，可以覆盖 &lt;code&gt;$isEmpty()&lt;/code&gt; 以说明不是基于字符串的$ viewValue。</target>
        </trans-unit>
        <trans-unit id="da43acb6e9a82ff95654a25655433849b9f27b07" translate="yes" xml:space="preserve">
          <source>The value in the model that the control is bound to.</source>
          <target state="translated">在模型中,控制权所绑定的值。</target>
        </trans-unit>
        <trans-unit id="14b23e5ee2cfb999b445acbc780311b9a12fe737" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;ngModel&lt;/code&gt; won't be set unless it passes validation for the input field. For example: inputs of type &lt;code&gt;email&lt;/code&gt; must have a value in the form of &lt;code&gt;user@domain&lt;/code&gt;.</source>
          <target state="translated">除非通过输入字段的验证，否则不会设置 &lt;code&gt;ngModel&lt;/code&gt; 的值。例如：类型为 &lt;code&gt;email&lt;/code&gt; 的输入必须具有 &lt;code&gt;user@domain&lt;/code&gt; 形式的值。</target>
        </trans-unit>
        <trans-unit id="b7c0a4135d026e4590cabdf020b1214be6ef8102" translate="yes" xml:space="preserve">
          <source>The value of the &lt;code&gt;count&lt;/code&gt; attribute can be either a string or an &lt;a href=&quot;../../../guide/expression&quot;&gt;AngularJS expression&lt;/a&gt;; these are evaluated on the current scope for its bound value.</source>
          <target state="translated">&lt;code&gt;count&lt;/code&gt; 属性的值可以是字符串，也可以是&lt;a href=&quot;../../../guide/expression&quot;&gt;AngularJS表达式&lt;/a&gt;；在当前范围内对它们的绑定值进行评估。</target>
        </trans-unit>
        <trans-unit id="1b73e986ca72f64054cdba299a9701373d5dfec0" translate="yes" xml:space="preserve">
          <source>The value of the input to check for emptiness.</source>
          <target state="translated">输入的值,以检查是否空虚。</target>
        </trans-unit>
        <trans-unit id="44463f976abf31a5394099b3a0a4e6208a67f0fc" translate="yes" xml:space="preserve">
          <source>The value referenced by &lt;code&gt;ng-model&lt;/code&gt; is changed programmatically and both the &lt;code&gt;$modelValue&lt;/code&gt; and the &lt;code&gt;$viewValue&lt;/code&gt; are different from last time.</source>
          <target state="translated">&lt;code&gt;ng-model&lt;/code&gt; 引用的值以编程方式更改，并且 &lt;code&gt;$modelValue&lt;/code&gt; 和 &lt;code&gt;$viewValue&lt;/code&gt; 都与上次不同。</target>
        </trans-unit>
        <trans-unit id="6b0143fd9ece1d0387124beb89dd5c7fd4bc5a91" translate="yes" xml:space="preserve">
          <source>The value that should be considered trusted.</source>
          <target state="translated">应该认为是可信的值。</target>
        </trans-unit>
        <trans-unit id="6b506880f20531602ad2eb0fa099daa12bfb5b84" translate="yes" xml:space="preserve">
          <source>The value that that should be considered trusted.</source>
          <target state="translated">值,应该认为是可信的。</target>
        </trans-unit>
        <trans-unit id="3174f6de2b1a572b3ef68f749f440587119fa478" translate="yes" xml:space="preserve">
          <source>The value to mark as trusted for &lt;code&gt;$sce.CSS&lt;/code&gt; context.</source>
          <target state="translated">标记为 &lt;code&gt;$sce.CSS&lt;/code&gt; 上下文受信任的值。</target>
        </trans-unit>
        <trans-unit id="c130aa44236fc44f23102a665d5d5963b688f052" translate="yes" xml:space="preserve">
          <source>The value to mark as trusted for &lt;code&gt;$sce.HTML&lt;/code&gt; context.</source>
          <target state="translated">标记为 &lt;code&gt;$sce.HTML&lt;/code&gt; 上下文受信任的值。</target>
        </trans-unit>
        <trans-unit id="cf9b76745715759b224d248b10d334a51d267341" translate="yes" xml:space="preserve">
          <source>The value to mark as trusted for &lt;code&gt;$sce.JS&lt;/code&gt; context.</source>
          <target state="translated">&lt;code&gt;$sce.JS&lt;/code&gt; 上下文标记为受信任的值。</target>
        </trans-unit>
        <trans-unit id="def9516ca7a6eb4975cef660dfbfbd813f67783b" translate="yes" xml:space="preserve">
          <source>The value to mark as trusted for &lt;code&gt;$sce.RESOURCE_URL&lt;/code&gt; context.</source>
          <target state="translated">&lt;code&gt;$sce.RESOURCE_URL&lt;/code&gt; 上下文标记为受信任的值。</target>
        </trans-unit>
        <trans-unit id="055605c6f52998605859dc20359c0bf18aa8a534" translate="yes" xml:space="preserve">
          <source>The value to mark as trusted for &lt;code&gt;$sce.URL&lt;/code&gt; context.</source>
          <target state="translated">标记为 &lt;code&gt;$sce.URL&lt;/code&gt; 上下文受信任的值。</target>
        </trans-unit>
        <trans-unit id="435759993cef3a1ebd9ea38393b7168b54598cf3" translate="yes" xml:space="preserve">
          <source>The value to pass to &lt;code&gt;$sce.getTrusted&lt;/code&gt;.</source>
          <target state="translated">传递给 &lt;code&gt;$sce.getTrusted&lt;/code&gt; 的值。</target>
        </trans-unit>
        <trans-unit id="35971100dfde05b044e38f25dc4ec52471feb171" translate="yes" xml:space="preserve">
          <source>The value to pass to &lt;code&gt;$sceDelegate.getTrusted&lt;/code&gt;.</source>
          <target state="translated">传递给 &lt;code&gt;$sceDelegate.getTrusted&lt;/code&gt; 的值。</target>
        </trans-unit>
        <trans-unit id="36090b23e6b19abea403f7cf11708f739d6ebe0a" translate="yes" xml:space="preserve">
          <source>The value.</source>
          <target state="translated">价值。</target>
        </trans-unit>
        <trans-unit id="62a76571179e7a797adcf5b0dca4482159e1774f" translate="yes" xml:space="preserve">
          <source>The variable to be bound to.</source>
          <target state="translated">要绑定的变量。</target>
        </trans-unit>
        <trans-unit id="eb0c8dfaa72fe998ded88b434f150524ba3c8874" translate="yes" xml:space="preserve">
          <source>The version could then be read back out by accessing the module elsewhere:</source>
          <target state="translated">然后,可以通过在其他地方访问该模块将版本读回。</target>
        </trans-unit>
        <trans-unit id="43454983a5496d952f24ef6981aa235148e2e821" translate="yes" xml:space="preserve">
          <source>The watch &lt;code&gt;listener&lt;/code&gt; may change the model, which may trigger other &lt;code&gt;listener&lt;/code&gt;s to fire. This is achieved by rerunning the watchers until no changes are detected. The rerun iteration limit is 10 to prevent an infinite loop deadlock.</source>
          <target state="translated">监视 &lt;code&gt;listener&lt;/code&gt; 可能会更改模型，这可能会触发其他 &lt;code&gt;listener&lt;/code&gt; 触发。这可以通过重新运行观察程序直到未检测到任何更改来实现。重运行迭代限制为10，以防止无限循环死锁。</target>
        </trans-unit>
        <trans-unit id="b3908c90281bc35a0fa4df23a51dff370901b1f6" translate="yes" xml:space="preserve">
          <source>The watchers of the current scope are included in the count and so are all the watchers of isolate child scopes.</source>
          <target state="translated">当前作用域的监视者被包括在计数中,隔离子作用域的所有监视者也是如此。</target>
        </trans-unit>
        <trans-unit id="f561ff816ae7aefdfc8fd009517d7b9fcbad64ce" translate="yes" xml:space="preserve">
          <source>The way you define a directive, service, or filter is with a factory function. The factory methods are registered with modules. The recommended way of declaring factories is:</source>
          <target state="translated">你定义指令、服务或过滤器的方式是用工厂函数。工厂方法是用模块注册的。推荐的声明工厂的方式是。</target>
        </trans-unit>
        <trans-unit id="fb5175d364ed0ee1ef08306c1d28e391169ff525" translate="yes" xml:space="preserve">
          <source>The whitelist for URL sanitization of attribute values is configured using the functions &lt;code&gt;aHrefSanitizationWhitelist&lt;/code&gt; and &lt;code&gt;imgSrcSanitizationWhitelist&lt;/code&gt; of &lt;a href=&quot;../../ng/provider/%24compileprovider&quot;&gt;&lt;code&gt;$compileProvider&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">属性值的URL消毒的白名单使用的功能配置 &lt;code&gt;aHrefSanitizationWhitelist&lt;/code&gt; 和 &lt;code&gt;imgSrcSanitizationWhitelist&lt;/code&gt; 的&lt;a href=&quot;../../ng/provider/%24compileprovider&quot;&gt; &lt;code&gt;$compileProvider&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6bcb4b40a369e071e66ceee940ccd85ed11ee25c" translate="yes" xml:space="preserve">
          <source>The workaround is to ensure that such instances are separated by whitespace:</source>
          <target state="translated">变通的办法是确保这些实例用空格隔开。</target>
        </trans-unit>
        <trans-unit id="b08b5bc31a0f9b0aaed1244795ed5323c9f55509" translate="yes" xml:space="preserve">
          <source>The wrong way to write it:</source>
          <target state="translated">错误的写法。</target>
        </trans-unit>
        <trans-unit id="987f327e589afcef1c088418e5aec840d608c486" translate="yes" xml:space="preserve">
          <source>Then load the module in your application by adding it as a dependent module:</source>
          <target state="translated">然后在你的应用程序中通过添加该模块作为依赖模块来加载该模块。</target>
        </trans-unit>
        <trans-unit id="7d2b29d57502f260e757766c62c868a34c233461" translate="yes" xml:space="preserve">
          <source>Then the CSS animation code for the message container looks like so:</source>
          <target state="translated">那么消息容器的CSS动画代码是这样的。</target>
        </trans-unit>
        <trans-unit id="4420f082e957bdeb70a28e331407c72ac0fa9f6e" translate="yes" xml:space="preserve">
          <source>Then you can create an injector and load your modules like this:</source>
          <target state="translated">然后你可以创建一个注入器并像这样加载你的模块。</target>
        </trans-unit>
        <trans-unit id="b74684d8de56bfaa1c2e51da13b1734863d4fb9f" translate="yes" xml:space="preserve">
          <source>Then, configure your test runner to load &lt;code&gt;angular-mocks.js&lt;/code&gt; after &lt;code&gt;angular.js&lt;/code&gt;. This example uses &lt;a href=&quot;http://karma-runner.github.io/&quot;&gt;Karma&lt;/a&gt;:</source>
          <target state="translated">然后，将您的测试运行器配置为在 &lt;code&gt;angular-mocks.js&lt;/code&gt; 之后加载angular- &lt;code&gt;angular.js&lt;/code&gt; 。本示例使用&lt;a href=&quot;http://karma-runner.github.io/&quot;&gt;Karma&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="d32bb96d5e92506ee0985b73373006273831ce51" translate="yes" xml:space="preserve">
          <source>Then, include &lt;code&gt;angular-animate.js&lt;/code&gt; in your HTML:</source>
          <target state="translated">然后，在您的HTML中包含 &lt;code&gt;angular-animate.js&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="be42b1b9ea22296aed835ed67fd0503f2d1c7ce1" translate="yes" xml:space="preserve">
          <source>Then, include &lt;code&gt;angular-aria.js&lt;/code&gt; in your HTML:</source>
          <target state="translated">然后，在您的HTML中包含 &lt;code&gt;angular-aria.js&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="ac37b863957206f52a67a02d8148afa2722ae351" translate="yes" xml:space="preserve">
          <source>Then, include &lt;code&gt;angular-cookies.js&lt;/code&gt; in your HTML:</source>
          <target state="translated">然后，在您的HTML中包含 &lt;code&gt;angular-cookies.js&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="ae69b27ed53748a28e2133d629a343fe3e5b36d0" translate="yes" xml:space="preserve">
          <source>Then, include &lt;code&gt;angular-message-format.js&lt;/code&gt; in your HTML:</source>
          <target state="translated">然后，在HTML中包含 &lt;code&gt;angular-message-format.js&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="33510a8d30ee13097925c8687d0b4a0dc5b54dd9" translate="yes" xml:space="preserve">
          <source>Then, include &lt;code&gt;angular-messages.js&lt;/code&gt; in your HTML:</source>
          <target state="translated">然后，在您的HTML中包含 &lt;code&gt;angular-messages.js&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="bb1a4ae9bcaf5171467ecc41d0db098c41b54bdb" translate="yes" xml:space="preserve">
          <source>Then, include &lt;code&gt;angular-mocks.js&lt;/code&gt; in your HTML:</source>
          <target state="translated">然后，在您的HTML中包含 &lt;code&gt;angular-mocks.js&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="b063c697f244bfb6f28cfccd98309c35fe2f0e16" translate="yes" xml:space="preserve">
          <source>Then, include &lt;code&gt;angular-parse-ext.js&lt;/code&gt; in your HTML:</source>
          <target state="translated">然后，在您的HTML中包括 &lt;code&gt;angular-parse-ext.js&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="14e0b01648408cdb8437a7490c7878d70c602c47" translate="yes" xml:space="preserve">
          <source>Then, include &lt;code&gt;angular-resource.js&lt;/code&gt; in your HTML:</source>
          <target state="translated">然后，在您的HTML中包含 &lt;code&gt;angular-resource.js&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="d20a74b3dd55a1d4eca8992c7a14fa2a1d9e3918" translate="yes" xml:space="preserve">
          <source>Then, include &lt;code&gt;angular-route.js&lt;/code&gt; in your HTML:</source>
          <target state="translated">然后，在您的HTML中包含 &lt;code&gt;angular-route.js&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="e735fd0e46663b7101645180fb23c07bb057a514" translate="yes" xml:space="preserve">
          <source>Then, include &lt;code&gt;angular-sanitize.js&lt;/code&gt; in your HTML:</source>
          <target state="translated">然后，在您的HTML中包含 &lt;code&gt;angular-sanitize.js&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="4104e34a174331405f4b0d2b7199cfaf3401d567" translate="yes" xml:space="preserve">
          <source>Then, include &lt;code&gt;angular-touch.js&lt;/code&gt; in your HTML:</source>
          <target state="translated">然后，在您的HTML中包含 &lt;code&gt;angular-touch.js&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="d12134494475237ef73f311dad22d23a4a004ddd" translate="yes" xml:space="preserve">
          <source>Then, the &lt;a href=&quot;../api/ng/type/angular.module#run.html&quot;&gt;run&lt;/a&gt; blocks that have been collected from each module are executed in order of requirement.</source>
          <target state="translated">然后，按要求顺序执行从每个模块收集的&lt;a href=&quot;../api/ng/type/angular.module#run.html&quot;&gt;运行&lt;/a&gt;块。</target>
        </trans-unit>
        <trans-unit id="2e850ec6b850797a6a79db638c878c1fdc64c72f" translate="yes" xml:space="preserve">
          <source>There also exists a special &lt;a href=&quot;http://code.google.com/web/ajaxcrawling/docs/specification.html&quot;&gt;AJAX crawling scheme&lt;/a&gt; developed by Google that allows bots to crawl the static equivalent of a dynamically generated page, but this schema has been deprecated, and support for it may vary by search engine.</source>
          <target state="translated">Google 还开发了一种特殊的&lt;a href=&quot;http://code.google.com/web/ajaxcrawling/docs/specification.html&quot;&gt;AJAX抓取方案&lt;/a&gt;，该方案允许漫游器抓取动态生成的页面的静态等效内容，但是该架构已被弃用，并且对它的支持可能会因搜索引擎而异。</target>
        </trans-unit>
        <trans-unit id="130d9b350defbba659ae904cdf720b49833cb081" translate="yes" xml:space="preserve">
          <source>There are a couple of things to note here. Just like the &lt;code&gt;module.controller&lt;/code&gt; API, the function argument in &lt;code&gt;module.directive&lt;/code&gt; is dependency injected. Because of this, we can use &lt;code&gt;$interval&lt;/code&gt; and &lt;code&gt;dateFilter&lt;/code&gt; inside our directive's &lt;code&gt;link&lt;/code&gt; function.</source>
          <target state="translated">这里有几件事要注意。就像 &lt;code&gt;module.controller&lt;/code&gt; API，在功能参数 &lt;code&gt;module.directive&lt;/code&gt; 是依赖注入。因此，我们可以在指令的 &lt;code&gt;link&lt;/code&gt; 函数中使用 &lt;code&gt;$interval&lt;/code&gt; 和 &lt;code&gt;dateFilter&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="22aac06fcbba861d9deabbd7db65ea5290a0d817" translate="yes" xml:space="preserve">
          <source>There are a few examples that showcase how to use AngularJS filters with various locale rule sets in the &lt;a href=&quot;https://github.com/angular/angular.js/tree/master/i18n/e2e&quot;&gt;&lt;code&gt;i18n/e2e&lt;/code&gt; directory&lt;/a&gt; of the AngularJS source code.</source>
          <target state="translated">在AngularJS源代码的&lt;a href=&quot;https://github.com/angular/angular.js/tree/master/i18n/e2e&quot;&gt; &lt;code&gt;i18n/e2e&lt;/code&gt; 目录中&lt;/a&gt;，有一些示例展示了如何在各种语言环境规则集中使用AngularJS过滤器。</target>
        </trans-unit>
        <trans-unit id="d1bfb8991ae5c4f9e31fb56a70d6baff7aba4e7f" translate="yes" xml:space="preserve">
          <source>There are a few special events that AngularJS emits. When a DOM node that has been compiled with AngularJS's compiler is destroyed, it emits a &lt;code&gt;$destroy&lt;/code&gt; event. Similarly, when an AngularJS scope is destroyed, it broadcasts a &lt;code&gt;$destroy&lt;/code&gt; event to listening scopes.</source>
          <target state="translated">AngularJS会发出一些特殊事件。当已经用AngularJS的编译器编译的DOM节点被破坏时，它将发出 &lt;code&gt;$destroy&lt;/code&gt; 事件。同样，当AngularJS范围被销毁时，它将向侦听范围广播 &lt;code&gt;$destroy&lt;/code&gt; 事件。</target>
        </trans-unit>
        <trans-unit id="2f1db69945853c0d37d9a79a76c27844cddebc4a" translate="yes" xml:space="preserve">
          <source>There are a few things to keep in mind regardless of automatic or manual bootstrapping:</source>
          <target state="translated">不管是自动还是手动引导,都有几件事需要注意。</target>
        </trans-unit>
        <trans-unit id="95101ca63f8d69f5d9cdd1c823a21dd5e29b3a87" translate="yes" xml:space="preserve">
          <source>There are a few things to keep in mind when using &lt;code&gt;ngApp&lt;/code&gt;:</source>
          <target state="translated">使用 &lt;code&gt;ngApp&lt;/code&gt; 时要牢记以下几点：</target>
        </trans-unit>
        <trans-unit id="eaf3ee4bd5875653a956ae013e1f9a754843ecf9" translate="yes" xml:space="preserve">
          <source>There are a few things you might consider when running your AngularJS application in production.</source>
          <target state="translated">当你在生产中运行AngularJS应用程序时,可能会考虑一些事情。</target>
        </trans-unit>
        <trans-unit id="d4c519b820846227a1173c2c2eabfe5a86e6afa6" translate="yes" xml:space="preserve">
          <source>There are a number of ways that templates and expressions can be controlled:</source>
          <target state="translated">有很多方法可以控制模板和表达式。</target>
        </trans-unit>
        <trans-unit id="6f12a2ba7d25176e96b87dc8a9715efae8e42b4f" translate="yes" xml:space="preserve">
          <source>There are exactly &lt;strong&gt;two wildcard sequences&lt;/strong&gt; - &lt;code&gt;*&lt;/code&gt; and &lt;code&gt;**&lt;/code&gt;. All other characters match themselves.</source>
          <target state="translated">正好有&lt;strong&gt;两个通配符序列&lt;/strong&gt; - &lt;code&gt;*&lt;/code&gt; 和 &lt;code&gt;**&lt;/code&gt; 。所有其他字符都匹配。</target>
        </trans-unit>
        <trans-unit id="016247ec0111e77189147435add0171b2c62c098" translate="yes" xml:space="preserve">
          <source>There are five recipe types that define how to create objects: Value, Factory, Service, Provider and Constant.</source>
          <target state="translated">有五种配方类型来定义如何创建对象。Value,Factory,Service,Provider 和 Constant.</target>
        </trans-unit>
        <trans-unit id="b990c7868d77b4c950319ea8bf70ed42696c2ff8" translate="yes" xml:space="preserve">
          <source>There are many different options for a directive.</source>
          <target state="translated">指令有许多不同的选择。</target>
        </trans-unit>
        <trans-unit id="44a999479cdafb004f6c8616bcc95ef2dfa72651" translate="yes" xml:space="preserve">
          <source>There are no CSS or JS context bindings in AngularJS currently, so their corresponding &lt;code&gt;$sce.trustAs&lt;/code&gt; functions aren't useful yet. This might evolve.</source>
          <target state="translated">当前在AngularJS中没有CSS或JS上下文绑定，因此它们对应的 &lt;code&gt;$sce.trustAs&lt;/code&gt; 函数还没有用。这可能会演变。</target>
        </trans-unit>
        <trans-unit id="00f60ceec8589342669960dc8d147c35c7893ead" translate="yes" xml:space="preserve">
          <source>There are only three ways a component (object or function) can get a hold of its dependencies:</source>
          <target state="translated">一个组件(对象或函数)只有三种方式可以获得它的依赖关系。</target>
        </trans-unit>
        <trans-unit id="66f6fbd80fe8ea46a687b78aa0411b5df8473d11" translate="yes" xml:space="preserve">
          <source>There are several different ways to disable animations, both globally and for specific animations. Disabling specific animations can help to speed up the render performance, for example for large &lt;code&gt;ngRepeat&lt;/code&gt; lists that don't actually have animations. Because &lt;code&gt;ngAnimate&lt;/code&gt; checks at runtime if animations are present, performance will take a hit even if an element has no animation.</source>
          <target state="translated">全局和特定动画有几种不同的禁用动画的方法。禁用特定的动画可以帮助提高渲染性能，例如，对于实际上没有动画的大型 &lt;code&gt;ngRepeat&lt;/code&gt; 列表。因为 &lt;code&gt;ngAnimate&lt;/code&gt; 在运行时检查是否存在动画，所以即使元素没有动画，性能也会受到影响。</target>
        </trans-unit>
        <trans-unit id="5215767d4d7638b5c9fa856bf4e4ce676b7f648e" translate="yes" xml:space="preserve">
          <source>There are several way to mitigate this problem:</source>
          <target state="translated">有几种方法可以缓解这个问题。</target>
        </trans-unit>
        <trans-unit id="e6acde2bec5e72bfd06e3cfbf1f79236cbb60d66" translate="yes" xml:space="preserve">
          <source>There are three kinds of transclusion depending upon whether you want to transclude just the contents of the directive's element, the entire element or multiple parts of the element contents:</source>
          <target state="translated">有三种transclusion,取决于你是想只转发指令元素的内容、整个元素还是元素内容的多个部分。</target>
        </trans-unit>
        <trans-unit id="2199989a69d3b490219217eaf3cfa4a17c693346" translate="yes" xml:space="preserve">
          <source>There are two &lt;a href=&quot;http://unicode.org/repos/cldr-tmp/trunk/diff/supplemental/language_plural_rules.html&quot;&gt;plural categories&lt;/a&gt; in AngularJS's default en-US locale: &quot;one&quot; and &quot;other&quot;.</source>
          <target state="translated">AngularJS在默认的美国英语语言环境中有两个&lt;a href=&quot;http://unicode.org/repos/cldr-tmp/trunk/diff/supplemental/language_plural_rules.html&quot;&gt;复数类别&lt;/a&gt;：&amp;ldquo;一个&amp;rdquo;和&amp;ldquo;其他&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="9e4cfb93c504b3cf5f31483d3014aea04a7a10e9" translate="yes" xml:space="preserve">
          <source>There are two approaches to providing locale rules to AngularJS:</source>
          <target state="translated">为AngularJS提供locale规则有两种方法。</target>
        </trans-unit>
        <trans-unit id="69520fd35811ca565d4a03687080e48476082679" translate="yes" xml:space="preserve">
          <source>There are two exceptions to this rule:</source>
          <target state="translated">这一规则有两个例外。</target>
        </trans-unit>
        <trans-unit id="3a315166c5b92460227594ad824a5f7dffe1174e" translate="yes" xml:space="preserve">
          <source>There are two kinds of Router: &lt;a href=&quot;rootrouter&quot;&gt;&lt;code&gt;RootRouter&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;childrouter&quot;&gt;&lt;code&gt;ChildRouter&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">路由器有两种：&lt;a href=&quot;rootrouter&quot;&gt; &lt;code&gt;RootRouter&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;childrouter&quot;&gt; &lt;code&gt;ChildRouter&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8457172152396945221a9bb7abc47bdb2fb360a4" translate="yes" xml:space="preserve">
          <source>There are two kinds of interceptors (and two kinds of rejection interceptors):</source>
          <target state="translated">拦截器有两种(和两种拒绝拦截器)。</target>
        </trans-unit>
        <trans-unit id="984ce92ebd9ffa671cbef47120514527e6ec5ced" translate="yes" xml:space="preserve">
          <source>There are two main differences:</source>
          <target state="translated">主要有两个区别。</target>
        </trans-unit>
        <trans-unit id="71aafbc13740296ddff7de52f6fd4b006802c2b8" translate="yes" xml:space="preserve">
          <source>There are two ways to register decorators</source>
          <target state="translated">注册装饰师有两种方式</target>
        </trans-unit>
        <trans-unit id="f29586d91e000a0120c5f20624018b52e64c8adc" translate="yes" xml:space="preserve">
          <source>There are two ways to specify what test data should be returned as http responses by the mock backend when the code under test makes http requests:</source>
          <target state="translated">有两种方法可以指定当被测代码发出http请求时,mock后端应该将哪些测试数据作为http响应返回。</target>
        </trans-unit>
        <trans-unit id="05eed5a5bae2275e702df7fc9bbddf5598e8921e" translate="yes" xml:space="preserve">
          <source>There are various places that the browser can store (or cache) data. Within AngularJS there are objects created by the &lt;a href=&quot;../api/ng/service/%24cachefactory&quot;&gt;&lt;code&gt;$cacheFactory&lt;/code&gt;&lt;/a&gt;. These objects, such as &lt;a href=&quot;../api/ng/service/%24templatecache&quot;&gt;&lt;code&gt;$templateCache&lt;/code&gt;&lt;/a&gt; are used to store and retrieve data, primarily used by &lt;a href=&quot;../api/ng/service/%24http&quot;&gt;&lt;code&gt;$http&lt;/code&gt;&lt;/a&gt; and the &lt;a href=&quot;../api/ng/directive/script&quot;&gt;&lt;code&gt;script&lt;/code&gt;&lt;/a&gt; directive to cache templates and other data.</source>
          <target state="translated">浏览器可以在许多地方存储（或缓存）数据。在AngularJS中，有&lt;a href=&quot;../api/ng/service/%24cachefactory&quot;&gt; &lt;code&gt;$cacheFactory&lt;/code&gt; &lt;/a&gt;创建的对象。这些对象（例如&lt;a href=&quot;../api/ng/service/%24templatecache&quot;&gt; &lt;code&gt;$templateCache&lt;/code&gt; &lt;/a&gt;用于存储和检索数据，主要由&lt;a href=&quot;../api/ng/service/%24http&quot;&gt; &lt;code&gt;$http&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../api/ng/directive/script&quot;&gt; &lt;code&gt;script&lt;/code&gt; &lt;/a&gt;指令用于缓存模板和其他数据。</target>
        </trans-unit>
        <trans-unit id="c8876989e9de229aee2aea75b9ae2ca7d7de6211" translate="yes" xml:space="preserve">
          <source>There are very few scenarios where element replacement is required for the application function, the main one being reusable custom components that are used within SVG contexts (because SVG doesn't work with custom elements in the DOM tree).</source>
          <target state="translated">对于应用功能来说,需要进行元素替换的场景非常少,主要是在SVG上下文中使用的可重用的自定义组件(因为SVG无法使用DOM树中的自定义元素)。</target>
        </trans-unit>
        <trans-unit id="4e6b2724368909d72a2a983621849f26c6af516a" translate="yes" xml:space="preserve">
          <source>There is a special &lt;code&gt;replace&lt;/code&gt; method which can be used to tell the $location service that the next time the $location service is synced with the browser, the last history record should be replaced instead of creating a new one. This is useful when you want to implement redirection, which would otherwise break the back button (navigating back would retrigger the redirection). To change the current URL without creating a new browser history record you can call:</source>
          <target state="translated">有一种特殊的 &lt;code&gt;replace&lt;/code&gt; 方法，可以用来告诉$ location服务，下次$ location服务与浏览器同步时，应该替换最后一个历史记录，而不是创建一个新的历史记录。当您要实现重定向时，此功能很有用，否则将损坏后退按钮（向后导航将重新触发重定向）。要更改当前URL而不创建新的浏览器历史记录，可以调用：</target>
        </trans-unit>
        <trans-unit id="ad79f1d43f88c0ade864387a26e37d58a6049c9d" translate="yes" xml:space="preserve">
          <source>There is also a button that calls &lt;a href=&quot;../type/ngmodel.ngmodelcontroller#%24setViewValue.html&quot;&gt;$setViewValue&lt;/a&gt; directly with a &quot;custom&quot; event. Since &quot;custom&quot; is not defined in the &lt;code&gt;updateOn&lt;/code&gt; list, it is considered a &quot;default&quot; event and will update the control if &quot;default&quot; is defined in &lt;code&gt;updateOn&lt;/code&gt;, and will receive the &quot;default&quot; debounce value. Note that this is just to illustrate how custom controls would possibly call &lt;code&gt;$setViewValue&lt;/code&gt;.</source>
          <target state="translated">还有一个按钮可通过&amp;ldquo; custom&amp;rdquo;事件直接调用&lt;a href=&quot;../type/ngmodel.ngmodelcontroller#%24setViewValue.html&quot;&gt;$ setViewValue&lt;/a&gt;。由于未在 &lt;code&gt;updateOn&lt;/code&gt; 列表中定义&amp;ldquo; custom&amp;rdquo; ，因此将其视为&amp;ldquo; default&amp;rdquo;事件，如果在 &lt;code&gt;updateOn&lt;/code&gt; 中定义了&amp;ldquo; default&amp;rdquo;，则它将更新控件，并且将接收&amp;ldquo; default&amp;rdquo;去抖动值。请注意，这只是为了说明自定义控件将如何调用 &lt;code&gt;$setViewValue&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="36ecab9037408b71383cabd20abb76e35492f942" translate="yes" xml:space="preserve">
          <source>There is no guarantee that it works for every directive, because interpolation itself is a directive. If another directive accesses attribute data before interpolation has run, it will get the raw interpolation markup and not data.</source>
          <target state="translated">不能保证它对每个指令都有效,因为插值本身就是一个指令。如果另一个指令在内插运行之前访问属性数据,它将得到原始内插标记,而不是数据。</target>
        </trans-unit>
        <trans-unit id="4803d73431676005c82886122ad66c28a6c074d3" translate="yes" xml:space="preserve">
          <source>There is one exception: Links that only contain a hash fragment (e.g. &lt;code&gt;&amp;lt;a href=&quot;#target&quot;&amp;gt;&lt;/code&gt;) will only change &lt;code&gt;$location.hash()&lt;/code&gt; and not modify the url otherwise. This is useful for scrolling to anchors on the same page without needing to know on which page the user currently is.</source>
          <target state="translated">有一个例外：仅包含哈希片段的链接（例如 &lt;code&gt;&amp;lt;a href=&quot;#target&quot;&amp;gt;&lt;/code&gt; ）只会更改 &lt;code&gt;$location.hash()&lt;/code&gt; ，否则不会修改url。这对于滚动到同一页面上的锚点很有用，而无需知道用户当前在哪个页面上。</target>
        </trans-unit>
        <trans-unit id="2027737bb7068a96f000d4d33b193fa46fdcc492" translate="yes" xml:space="preserve">
          <source>There is only one instance of this type in a Component Router application injectable as the &lt;a href=&quot;../service/%24rootrouter&quot;&gt;&lt;code&gt;$rootRouter&lt;/code&gt;&lt;/a&gt; service. This &lt;strong&gt;Router&lt;/strong&gt; is associate with the &lt;strong&gt;Top Level Component&lt;/strong&gt; (&lt;a href=&quot;../service/%24routerrootcomponent&quot;&gt;&lt;code&gt;$routerRootComponent&lt;/code&gt;&lt;/a&gt;). It acts as the connection between the &lt;strong&gt;Routers&lt;/strong&gt; and the &lt;strong&gt;Location&lt;/strong&gt;.</source>
          <target state="translated">在组件路由器应用程序中只有一个这种类型的实例可以作为&lt;a href=&quot;../service/%24rootrouter&quot;&gt; &lt;code&gt;$rootRouter&lt;/code&gt; &lt;/a&gt;服务注入。该&lt;strong&gt;路由器&lt;/strong&gt;与&lt;strong&gt;顶级组件&lt;/strong&gt;（&lt;a href=&quot;../service/%24routerrootcomponent&quot;&gt; &lt;code&gt;$routerRootComponent&lt;/code&gt; &lt;/a&gt;）相关联。它充当&lt;strong&gt;路由器&lt;/strong&gt;和&lt;strong&gt;Location&lt;/strong&gt;之间的连接。</target>
        </trans-unit>
        <trans-unit id="72de6f193fb85300105ca6265046e6df92fea694" translate="yes" xml:space="preserve">
          <source>There was an error loading this resource. Please try again later.</source>
          <target state="translated">加载此资源时出现错误。请稍后再试。</target>
        </trans-unit>
        <trans-unit id="3eda2078fc3d76325ba60baef00e4fc07ad7239d" translate="yes" xml:space="preserve">
          <source>Therefore the above can be simplified as:</source>
          <target state="translated">因此,上述内容可以简化为:</target>
        </trans-unit>
        <trans-unit id="02108554d592d8fbabf9029cd9d2d981395f0bae" translate="yes" xml:space="preserve">
          <source>Therefore the final directive definition looks something like this:</source>
          <target state="translated">因此,最后的指令定义是这样的。</target>
        </trans-unit>
        <trans-unit id="dd132ceaead68d5aa4334853896ecc475000f044" translate="yes" xml:space="preserve">
          <source>Therefore, animations can be applied to an element using this temporary class directly via CSS.</source>
          <target state="translated">因此,可以通过CSS直接使用这个临时类将动画应用到元素上。</target>
        </trans-unit>
        <trans-unit id="e76f4192528514d19abc24671684646a83898011" translate="yes" xml:space="preserve">
          <source>Therefore, the CSS code for the inner messages looks like so:</source>
          <target state="translated">因此,内部消息的CSS代码是这样的。</target>
        </trans-unit>
        <trans-unit id="258dce51948dfa8d6b97e686c254e38bdd7527fc" translate="yes" xml:space="preserve">
          <source>These are the types of AngularJS elements and attributes you can use:</source>
          <target state="translated">这些是你可以使用的AngularJS元素和属性的类型。</target>
        </trans-unit>
        <trans-unit id="b4f66b8b15edc1f5323a3f2fe41e4c47e2e5caa0" translate="yes" xml:space="preserve">
          <source>These directives take an expression inside the attribute, and set the corresponding boolean attribute to true when the expression evaluates to truthy.</source>
          <target state="translated">这些指令在属性里面取一个表达式,当表达式评价为truthy时,将对应的布尔属性设置为true。</target>
        </trans-unit>
        <trans-unit id="0914ebf2d4a4b0b0e72a29f4b227f8a9a21e62e7" translate="yes" xml:space="preserve">
          <source>These restrictions can all be combined as needed:</source>
          <target state="translated">这些限制都可以根据需要进行组合。</target>
        </trans-unit>
        <trans-unit id="d1cc4346d96d189e151b816986a2f69e722fafcd" translate="yes" xml:space="preserve">
          <source>These service factories are ordered by request, i.e. they are applied in the same order as the array, on request, but reverse order, on response.</source>
          <target state="translated">这些服务工厂是按请求排序的,即在请求时按与数组相同的顺序应用,而在响应时则按相反的顺序应用。</target>
        </trans-unit>
        <trans-unit id="86ea12079184e49e6888fb5f8e9bf4a333312277" translate="yes" xml:space="preserve">
          <source>They can be used in view templates, controllers or services. AngularJS comes with a collection of &lt;a href=&quot;../filter&quot;&gt;built-in filters&lt;/a&gt;, but it is easy to define your own as well.</source>
          <target state="translated">它们可以在视图模板，控制器或服务中使用。AngularJS附带了一组&lt;a href=&quot;../filter&quot;&gt;内置过滤器&lt;/a&gt;，但是定义自己的过滤器也很容易。</target>
        </trans-unit>
        <trans-unit id="4824221375d3ce9b6f04cd13e1f0c90e7b5aac9d" translate="yes" xml:space="preserve">
          <source>Things to keep in mind</source>
          <target state="translated">需要注意的事项</target>
        </trans-unit>
        <trans-unit id="ab45627ffd28ba0b37493f184de9a27c3fad2e12" translate="yes" xml:space="preserve">
          <source>Things to notice in the example above:</source>
          <target state="translated">上面的例子中需要注意的地方。</target>
        </trans-unit>
        <trans-unit id="4d9616f497178549a1ceba85134b191dff85dc0a" translate="yes" xml:space="preserve">
          <source>This &lt;a href=&quot;../api/ng/type/angular.module#decorator.html&quot;&gt;function&lt;/a&gt; is the same as the &lt;code&gt;$provide.decorator&lt;/code&gt; function except it is exposed through the module API. This allows you to separate your decorator patterns from your module config blocks.</source>
          <target state="translated">该&lt;a href=&quot;../api/ng/type/angular.module#decorator.html&quot;&gt;函数&lt;/a&gt;与 &lt;code&gt;$provide.decorator&lt;/code&gt; 函数相同，但它是通过模块API公开的。这使您可以将装饰器模式与模块配置块分开。</target>
        </trans-unit>
        <trans-unit id="d2df585301cdbd155523396bd3c907ba55115f87" translate="yes" xml:space="preserve">
          <source>This allows to easily create arbitrarily complex rules for filtering animations, such as allowing specific events only, or enabling animations on specific subtrees of the DOM, etc. Filtering animations can also boost performance for low-powered devices, as well as applications containing a lot of structural operations.</source>
          <target state="translated">这允许轻松地创建任意复杂的动画过滤规则,例如只允许特定事件,或在DOM的特定子树上启用动画等。过滤动画还可以提高低功耗设备的性能,以及包含大量结构性操作的应用。</target>
        </trans-unit>
        <trans-unit id="62506bcdde04f9729f5e76db6021ecd55a120d85" translate="yes" xml:space="preserve">
          <source>This allows us to extend the above example with these features:</source>
          <target state="translated">这样我们就可以用这些功能来扩展上面的例子。</target>
        </trans-unit>
        <trans-unit id="2b868a8a849cb543857bdf88802803ebaca814e1" translate="yes" xml:space="preserve">
          <source>This also applies to the &lt;code&gt;when&lt;/code&gt; and &lt;code&gt;expect&lt;/code&gt; shortcut methods.</source>
          <target state="translated">这也适用于 &lt;code&gt;when&lt;/code&gt; 和 &lt;code&gt;expect&lt;/code&gt; 快捷方式方法。</target>
        </trans-unit>
        <trans-unit id="0e5d6967a2a93dd0eac33db309a1c3df407c1b33" translate="yes" xml:space="preserve">
          <source>This also means that just about any combination of adding classes, removing classes, setting styles, dynamically setting a keyframe animation, applying a hardcoded duration or delay value, changing the animation easing or applying a stagger animation are all options that work with &lt;code&gt;$animateCss&lt;/code&gt;. The service itself is smart enough to figure out the combination of options and examine the element styling properties in order to provide a working animation that will run in CSS.</source>
          <target state="translated">这也意味着添加类，删除类，设置样式，动态设置关键帧动画，应用硬编码的持续时间或延迟值，更改动画缓动或应用交错动画的任何组合都是与 &lt;code&gt;$animateCss&lt;/code&gt; 一起使用的所有选项。该服务本身很聪明，可以找出选项的组合并检查元素的样式属性，以便提供可以在CSS中运行的动画。</target>
        </trans-unit>
        <trans-unit id="9b79236b9af035a359b621e03d1e7e1f5da1644b" translate="yes" xml:space="preserve">
          <source>This applies both to the &lt;a href=&quot;../directive/nginclude&quot;&gt;&lt;code&gt;ng-include&lt;/code&gt;&lt;/a&gt; directive as well as &lt;code&gt;templateUrl&lt;/code&gt;'s specified by &lt;a href=&quot;../../../guide/directive&quot;&gt;directives&lt;/a&gt;.</source>
          <target state="translated">这适用于&lt;a href=&quot;../directive/nginclude&quot;&gt; &lt;code&gt;ng-include&lt;/code&gt; &lt;/a&gt;指令以及&lt;a href=&quot;../../../guide/directive&quot;&gt;指令&lt;/a&gt;指定的 &lt;code&gt;templateUrl&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="58dd13a809bb64e55c8c52e976d75660f7dabd26" translate="yes" xml:space="preserve">
          <source>This behavior makes sense for a directive that wraps some content, because otherwise you'd have to pass in each model you wanted to use separately. If you have to pass in each model that you want to use, then you can't really have arbitrary contents, can you?</source>
          <target state="translated">这种行为对于封装一些内容的指令来说是有意义的,因为如果不这样做,你就必须分别传入你想使用的每个模型。如果你必须传入每个你想使用的模型,那么你就不能真正拥有任意的内容,对吗?</target>
        </trans-unit>
        <trans-unit id="1a337bc5cc0b991a707d4b759d185330407dbe1c" translate="yes" xml:space="preserve">
          <source>This can be set explicitly by calling $sce.trustAs(type, value) on the value that is trusted before passing it to the &lt;code&gt;ng-prop-*&lt;/code&gt; directive. There are exist shorthand methods for each context type in the form of &lt;a href=&quot;../service/%24sce#trustAsResourceUrl.html&quot;&gt;$sce.trustAsResourceUrl()&lt;/a&gt; et al.</source>
          <target state="translated">可以通过将$ sce.trustAs（type，value）传递到 &lt;code&gt;ng-prop-*&lt;/code&gt; 指令之前，对受信任的值调用$ sce.trustAs（type，value）来显式设置。对于每种上下文类型，都有&lt;a href=&quot;../service/%24sce#trustAsResourceUrl.html&quot;&gt;$ sce.trustAsResourceUrl（）&lt;/a&gt;等形式的速记方法。</target>
        </trans-unit>
        <trans-unit id="a642393bdc5a3f60fc505ec099d289ef977421cd" translate="yes" xml:space="preserve">
          <source>This can be used to optimize your application when you know that running those watchers is redundant.</source>
          <target state="translated">当你知道运行这些看板是多余的时候,可以用它来优化你的应用程序。</target>
        </trans-unit>
        <trans-unit id="5484a478821be02a7e449725201e87872e9c0d6b" translate="yes" xml:space="preserve">
          <source>This can be used to queue up multiple expressions which need to be evaluated in the same digest.</source>
          <target state="translated">这可以用来排队等候需要在同一摘要中评估的多个表达式。</target>
        </trans-unit>
        <trans-unit id="eafa978f765a5d0f54a51aca4a5c7f591b5982c5" translate="yes" xml:space="preserve">
          <source>This can cause unpredictable behavior, e.g. &lt;code&gt;ngClick&lt;/code&gt; or other event handlers will be attached again. It can also degrade performance, as watchers for text interpolation are added twice to the scope.</source>
          <target state="translated">这可能导致无法预测的行为，例如 &lt;code&gt;ngClick&lt;/code&gt; 或其他事件处理程序将再次被附加。它还会降低性能，因为将文本插值的观察者添加到示波器两次。</target>
        </trans-unit>
        <trans-unit id="31737a8a0cfe19e93889da90104baa99509af66f" translate="yes" xml:space="preserve">
          <source>This change can be prevented by calling &lt;code&gt;preventDefault&lt;/code&gt; method of the event. See &lt;a href=&quot;../type/%24rootscope.scope#%24on.html&quot;&gt;&lt;code&gt;$rootScope.Scope&lt;/code&gt;&lt;/a&gt; for more details about event object. Upon successful change &lt;a href=&quot;%24location#%24locationChangeSuccess.html&quot;&gt;$locationChangeSuccess&lt;/a&gt; is fired.</source>
          <target state="translated">可以通过调用事件的 &lt;code&gt;preventDefault&lt;/code&gt; 方法来防止此更改。有关事件对象的更多详细信息，请参见&lt;a href=&quot;../type/%24rootscope.scope#%24on.html&quot;&gt; &lt;code&gt;$rootScope.Scope&lt;/code&gt; &lt;/a&gt;。成功更改后，将触发&lt;a href=&quot;%24location#%24locationChangeSuccess.html&quot;&gt;$ locationChangeSuccess&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="deaca4d4f1715e3cb81009a0b59af1557a02ca34" translate="yes" xml:space="preserve">
          <source>This continues until all module dependencies has been resolved.</source>
          <target state="translated">这个过程一直持续到所有模块的依赖关系被解决为止。</target>
        </trans-unit>
        <trans-unit id="0fdd710f9dc596720a9478bac918072a2e288c46" translate="yes" xml:space="preserve">
          <source>This directive allows you to modify the behaviour of &lt;a href=&quot;directive/ngmodel&quot;&gt;&lt;code&gt;ngModel&lt;/code&gt;&lt;/a&gt; directives within your application. You can specify an &lt;code&gt;ngModelOptions&lt;/code&gt; directive on any element. All &lt;a href=&quot;directive/ngmodel&quot;&gt;&lt;code&gt;ngModel&lt;/code&gt;&lt;/a&gt; directives will use the options of their nearest &lt;code&gt;ngModelOptions&lt;/code&gt; ancestor.</source>
          <target state="translated">该指令允许您在应用程序中修改&lt;a href=&quot;directive/ngmodel&quot;&gt; &lt;code&gt;ngModel&lt;/code&gt; &lt;/a&gt;指令的行为。您可以在任何元素上指定 &lt;code&gt;ngModelOptions&lt;/code&gt; 指令。所有&lt;a href=&quot;directive/ngmodel&quot;&gt; &lt;code&gt;ngModel&lt;/code&gt; &lt;/a&gt;指令将使用最接近的 &lt;code&gt;ngModelOptions&lt;/code&gt; 祖先的选项。</target>
        </trans-unit>
        <trans-unit id="ac964e329bac06459a562f99c7acc0f4d9f8bc69" translate="yes" xml:space="preserve">
          <source>This directive allows you to modify the behaviour of &lt;a href=&quot;ngmodel&quot;&gt;&lt;code&gt;ngModel&lt;/code&gt;&lt;/a&gt; directives within your application. You can specify an &lt;code&gt;ngModelOptions&lt;/code&gt; directive on any element. All &lt;a href=&quot;ngmodel&quot;&gt;&lt;code&gt;ngModel&lt;/code&gt;&lt;/a&gt; directives will use the options of their nearest &lt;code&gt;ngModelOptions&lt;/code&gt; ancestor.</source>
          <target state="translated">该指令允许您在应用程序中修改&lt;a href=&quot;ngmodel&quot;&gt; &lt;code&gt;ngModel&lt;/code&gt; &lt;/a&gt;指令的行为。您可以在任何元素上指定 &lt;code&gt;ngModelOptions&lt;/code&gt; 指令。所有&lt;a href=&quot;ngmodel&quot;&gt; &lt;code&gt;ngModel&lt;/code&gt; &lt;/a&gt;指令将使用最接近的 &lt;code&gt;ngModelOptions&lt;/code&gt; 祖先的选项。</target>
        </trans-unit>
        <trans-unit id="7965d373726e20c973548077757bfccc70ce0246" translate="yes" xml:space="preserve">
          <source>This directive can be abused to add unnecessary amounts of logic into your templates. There are only a few appropriate uses of &lt;code&gt;ngInit&lt;/code&gt;:</source>
          <target state="translated">可以滥用此伪指令在模板中添加不必要的逻辑量。 &lt;code&gt;ngInit&lt;/code&gt; 只有几种适当的用法：</target>
        </trans-unit>
        <trans-unit id="cbcba47b501b44e1b242996ce2f2fcb658bdde02" translate="yes" xml:space="preserve">
          <source>This directive can be applied only within the scope of an &lt;a href=&quot;ngrepeat&quot;&gt;ngRepeat&lt;/a&gt;.</source>
          <target state="translated">该指令只能在&lt;a href=&quot;ngrepeat&quot;&gt;ngRepeat&lt;/a&gt;的范围内应用。</target>
        </trans-unit>
        <trans-unit id="eed1d5dab4e2a48debbd34ee6dd14a061b9c554b" translate="yes" xml:space="preserve">
          <source>This directive can be used as &lt;a href=&quot;../service/%24compile#-multielement-.html&quot;&gt;multiElement&lt;/a&gt;</source>
          <target state="translated">该指令可用作多&lt;a href=&quot;../service/%24compile#-multielement-.html&quot;&gt;元素&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="408d771ebedb5301b2e1e5d11014f21ad0ac991f" translate="yes" xml:space="preserve">
          <source>This directive creates new scope.</source>
          <target state="translated">该指令创建新的范围。</target>
        </trans-unit>
        <trans-unit id="b9eb9dfc0b36b5fb31bc5f06b2291cbce4731e8e" translate="yes" xml:space="preserve">
          <source>This directive executes at priority level -400.</source>
          <target state="translated">该指令在优先级-400时执行。</target>
        </trans-unit>
        <trans-unit id="11bb46f7885f2d0fb62afc45043a006f99b5c779" translate="yes" xml:space="preserve">
          <source>This directive executes at priority level 0.</source>
          <target state="translated">该指令在优先级为0时执行。</target>
        </trans-unit>
        <trans-unit id="ba1fba935acedd5a393ae9e732b4ecad2e9ba52a" translate="yes" xml:space="preserve">
          <source>This directive executes at priority level 1.</source>
          <target state="translated">该指令在优先级为1时执行。</target>
        </trans-unit>
        <trans-unit id="57fa09288f6c223f6b042c6fed89bc149865df0e" translate="yes" xml:space="preserve">
          <source>This directive executes at priority level 10.</source>
          <target state="translated">该指令在优先级10时执行。</target>
        </trans-unit>
        <trans-unit id="20282e77f198233dc571257734f9c2d2da4f5aef" translate="yes" xml:space="preserve">
          <source>This directive executes at priority level 100.</source>
          <target state="translated">该指令在优先级100时执行。</target>
        </trans-unit>
        <trans-unit id="83a14caae6f6310a1c64fde8d891125d5595d161" translate="yes" xml:space="preserve">
          <source>This directive executes at priority level 1000.</source>
          <target state="translated">该指令在优先级1000时执行。</target>
        </trans-unit>
        <trans-unit id="9042e7730b88dc8812901abaa43a978bb9618917" translate="yes" xml:space="preserve">
          <source>This directive executes at priority level 1200.</source>
          <target state="translated">该指令在优先级1200时执行。</target>
        </trans-unit>
        <trans-unit id="1b9ad97e1cbe1b2045ab90cbbde8cfbd6f81734f" translate="yes" xml:space="preserve">
          <source>This directive executes at priority level 400 restrict: AE.</source>
          <target state="translated">该指令在优先级400限制下执行。AE.</target>
        </trans-unit>
        <trans-unit id="35ed58116dc2b01b349cc12677bcd3280b0cd2dd" translate="yes" xml:space="preserve">
          <source>This directive executes at priority level 400.</source>
          <target state="translated">该指令在优先级400时执行。</target>
        </trans-unit>
        <trans-unit id="b6c8d120968e554de79c9923d45c2f7f16a1758c" translate="yes" xml:space="preserve">
          <source>This directive executes at priority level 450.</source>
          <target state="translated">该指令在优先级450时执行。</target>
        </trans-unit>
        <trans-unit id="1aa13b7c0c442d44e8f33979384eb48bd2e2e8df" translate="yes" xml:space="preserve">
          <source>This directive executes at priority level 500.</source>
          <target state="translated">该指令在优先级500时执行。</target>
        </trans-unit>
        <trans-unit id="7df93f519af67379f099a16f4ead3293cda924b8" translate="yes" xml:space="preserve">
          <source>This directive executes at priority level 600.</source>
          <target state="translated">该指令在优先级600时执行。</target>
        </trans-unit>
        <trans-unit id="d60b4c0c247cba5c4a5f6b245e42416ae3e44c71" translate="yes" xml:space="preserve">
          <source>This directive executes at priority level 99.</source>
          <target state="translated">该指令在优先级99时执行。</target>
        </trans-unit>
        <trans-unit id="749a139249322e3a0fa2d9fc94fa82bcb541e03b" translate="yes" xml:space="preserve">
          <source>This directive is used as a tag &lt;code&gt;&amp;lt;a-great-eye&amp;gt;&amp;lt;/a-great-eye&amp;gt;&lt;/code&gt;. It replaces the entire tag with the template &lt;code&gt;&amp;lt;h1&amp;gt;lidless, wreathed in flame, {{1 + 1}} times&amp;lt;/h1&amp;gt;&lt;/code&gt;. Now we are going to write a jasmine unit test to verify this functionality. Note that the expression &lt;code&gt;{{1 + 1}}&lt;/code&gt; times will also be evaluated in the rendered content.</source>
          <target state="translated">该指令用作标签 &lt;code&gt;&amp;lt;a-great-eye&amp;gt;&amp;lt;/a-great-eye&amp;gt;&lt;/code&gt; 。它用模板 &lt;code&gt;&amp;lt;h1&amp;gt;lidless, wreathed in flame, {{1 + 1}} times&amp;lt;/h1&amp;gt;&lt;/code&gt; 替换整个标签。现在，我们将编写一个茉莉花单元测试来验证此功能。请注意，表达式 &lt;code&gt;{{1 + 1}}&lt;/code&gt; 次也将在渲染的内容中求值。</target>
        </trans-unit>
        <trans-unit id="0988891d1e4c9bf100a94a539e74ab83063f9e67" translate="yes" xml:space="preserve">
          <source>This directive sets the &lt;code&gt;disabled&lt;/code&gt; attribute on the element (typically a form control, e.g. &lt;code&gt;input&lt;/code&gt;, &lt;code&gt;button&lt;/code&gt;, &lt;code&gt;select&lt;/code&gt; etc.) if the &lt;a href=&quot;../../../guide/expression&quot;&gt;expression&lt;/a&gt; inside &lt;code&gt;ngDisabled&lt;/code&gt; evaluates to truthy.</source>
          <target state="translated">如果 &lt;code&gt;ngDisabled&lt;/code&gt; 内部的&lt;a href=&quot;../../../guide/expression&quot;&gt;表达式&lt;/a&gt;计算为true，则此伪指令在元素上设置 &lt;code&gt;disabled&lt;/code&gt; 属性（通常是表单控件，例如 &lt;code&gt;input&lt;/code&gt; ， &lt;code&gt;button&lt;/code&gt; ， &lt;code&gt;select&lt;/code&gt; 等）。</target>
        </trans-unit>
        <trans-unit id="c070fd68811002fede70f580a5780cdfa9a578c2" translate="yes" xml:space="preserve">
          <source>This directive sets the &lt;code&gt;disabled&lt;/code&gt; attribute on the element (typically a form control, e.g. &lt;code&gt;input&lt;/code&gt;, &lt;code&gt;button&lt;/code&gt;, &lt;code&gt;select&lt;/code&gt; etc.) if the &lt;a href=&quot;../../guide/expression&quot;&gt;expression&lt;/a&gt; inside &lt;code&gt;ngDisabled&lt;/code&gt; evaluates to truthy.</source>
          <target state="translated">如果 &lt;code&gt;ngDisabled&lt;/code&gt; 内部的&lt;a href=&quot;../../guide/expression&quot;&gt;表达式&lt;/a&gt;计算为true，则此伪指令在元素上设置 &lt;code&gt;disabled&lt;/code&gt; 属性（通常是表单控件，例如 &lt;code&gt;input&lt;/code&gt; ， &lt;code&gt;button&lt;/code&gt; ， &lt;code&gt;select&lt;/code&gt; 等）。</target>
        </trans-unit>
        <trans-unit id="a6e956b460cca90e672670086cda8aabd21f1997" translate="yes" xml:space="preserve">
          <source>This document explains some of AngularJS's security features and best practices that you should keep in mind as you build your application.</source>
          <target state="translated">本文档解释了AngularJS的一些安全特性和最佳实践,您在构建应用程序时应该牢记这些特性和实践。</target>
        </trans-unit>
        <trans-unit id="637bbb3be2c198a8a65ee2584634b52d3430c20e" translate="yes" xml:space="preserve">
          <source>This document explains when you'd want to create your own directives in your AngularJS app, and how to implement them.</source>
          <target state="translated">这个文档解释了什么时候你会想要在AngularJS应用中创建自己的指令,以及如何实现它们。</target>
        </trans-unit>
        <trans-unit id="ba8f1e4ba7e8dbd333bd05bd1a50c7b95a9e90fd" translate="yes" xml:space="preserve">
          <source>This enables web-servers to prevent script injection attacks and defacing attacks, to some degree, while also enabling code examples to work without relying on the &lt;a href=&quot;../directive/ngnonbindable&quot;&gt;ngNonBindable&lt;/a&gt; directive.</source>
          <target state="translated">这使Web服务器在某种程度上可以防止脚本注入攻击和破坏攻击，同时还可以使代码示例在不依赖&lt;a href=&quot;../directive/ngnonbindable&quot;&gt;ngNonBindable&lt;/a&gt;指令的情况下工作。</target>
        </trans-unit>
        <trans-unit id="076b9997e5dd41c8b9220b76be3ac831b79b0b74" translate="yes" xml:space="preserve">
          <source>This error is harmless but annoying. To prevent the error from showing up, put the &lt;code&gt;ngCsp&lt;/code&gt; directive on an element of the HTML document that appears before the &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; tag that loads the &lt;code&gt;angular.js&lt;/code&gt; file.</source>
          <target state="translated">该错误是无害的但令人讨厌。为了防止出现该错误，请将 &lt;code&gt;ngCsp&lt;/code&gt; 指令放在HTML文档的元素上，该元素出现在加载 &lt;code&gt;angular.js&lt;/code&gt; 文件的 &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; 标记之前。</target>
        </trans-unit>
        <trans-unit id="0f6664d3c705a07b165dfd285730cd6fb277477c" translate="yes" xml:space="preserve">
          <source>This example demonstrates basic transclusion of content into a component directive.</source>
          <target state="translated">这个例子演示了将内容转入组件指令的基本方法。</target>
        </trans-unit>
        <trans-unit id="1f9ed6e6472967fa32c46a4975e28dfb3de3211f" translate="yes" xml:space="preserve">
          <source>This example demonstrates the &quot;attach to &lt;code&gt;$scope&lt;/code&gt;&quot; style of controller.</source>
          <target state="translated">此示例演示了控制器的&amp;ldquo;附加到 &lt;code&gt;$scope&lt;/code&gt; &amp;rdquo;样式。</target>
        </trans-unit>
        <trans-unit id="28190992499c1193b7ef8ed135006e6081be0f60" translate="yes" xml:space="preserve">
          <source>This example demonstrates the &lt;code&gt;controller as&lt;/code&gt; syntax.</source>
          <target state="translated">本示例将 &lt;code&gt;controller as&lt;/code&gt; 演示为语法。</target>
        </trans-unit>
        <trans-unit id="62ca703b8851a5d6363ffcdd5aa7392a42b74357" translate="yes" xml:space="preserve">
          <source>This example demonstrates using multi-slot transclusion in a component directive.</source>
          <target state="translated">这个例子演示了如何在组件指令中使用多槽转包容。</target>
        </trans-unit>
        <trans-unit id="54d4f92cb5daaa1c9a5ccf8ff554cfa4e0608d51" translate="yes" xml:space="preserve">
          <source>This example illustrates scopes in application, and prototypical inheritance of properties. The example is followed by a diagram depicting the scope boundaries.</source>
          <target state="translated">这个例子说明了应用程序中的作用域,以及属性的原型继承。这个例子后面是一个描述作用域边界的图。</target>
        </trans-unit>
        <trans-unit id="964cf011bd5b116e12f4ea04fcf7924afb7cb764" translate="yes" xml:space="preserve">
          <source>This example sets a custom error &quot;unknownValue&quot; on the ngModelController when the select element's unknown option is selected, i.e. when the model is set to a value that is not matched by any option.</source>
          <target state="translated">这个例子在选择元素的未知选项时,即当模型被设置为一个没有任何选项匹配的值时,在ngModelController上设置了一个自定义错误 &quot;unknownValue&quot;。</target>
        </trans-unit>
        <trans-unit id="2d1c53bde144ac2b71271ea09e4914b32aa2f17e" translate="yes" xml:space="preserve">
          <source>This example show how you might use &lt;code&gt;$doCheck&lt;/code&gt; to trigger changes in your component's inputs even if the actual identity of the component doesn't change. (Be aware that cloning and deep equality checks on large arrays or objects can have a negative impact on your application performance)</source>
          <target state="translated">本示例说明了即使组件的实际身份没有更改，如何使用 &lt;code&gt;$doCheck&lt;/code&gt; 触发组件输入中的更改。 （请注意，对大型数组或对象进行克隆和深度相等检查可能会对应用程序性能产生负面影响）</target>
        </trans-unit>
        <trans-unit id="5ae8a0234d80385adab6edf6c69b9755596e3742" translate="yes" xml:space="preserve">
          <source>This example shows how &lt;code&gt;ngRef&lt;/code&gt; works with child scopes. The &lt;code&gt;ngRepeat&lt;/code&gt;-ed &lt;code&gt;myWrapper&lt;/code&gt; components are assigned to the scope of &lt;code&gt;myRoot&lt;/code&gt;, because the &lt;code&gt;toggles&lt;/code&gt; property has been initialized. The repeated &lt;code&gt;myToggle&lt;/code&gt; components are published to the child scopes created by &lt;code&gt;ngRepeat&lt;/code&gt;. &lt;code&gt;ngIf&lt;/code&gt; behaves similarly - the assignment of &lt;code&gt;myToggle&lt;/code&gt; happens in the &lt;code&gt;ngIf&lt;/code&gt; child scope, because the target property has not been initialized on the &lt;code&gt;myRoot&lt;/code&gt; component controller.</source>
          <target state="translated">此示例显示 &lt;code&gt;ngRef&lt;/code&gt; 如何与子作用域一起工作。该 &lt;code&gt;ngRepeat&lt;/code&gt; -ed &lt;code&gt;myWrapper&lt;/code&gt; 组件被分配到的范围 &lt;code&gt;myRoot&lt;/code&gt; ，因为 &lt;code&gt;toggles&lt;/code&gt; 属性已被初始化。重复的 &lt;code&gt;myToggle&lt;/code&gt; 组件将发布到 &lt;code&gt;ngRepeat&lt;/code&gt; 创建的子范围。 &lt;code&gt;ngIf&lt;/code&gt; 表现同样-的分配 &lt;code&gt;myToggle&lt;/code&gt; 发生在 &lt;code&gt;ngIf&lt;/code&gt; 子范围，因为目标属性尚未开启初始化 &lt;code&gt;myRoot&lt;/code&gt; 组件控制器。</target>
        </trans-unit>
        <trans-unit id="ee14ef2d78087f730132d6249684daaf02439508" translate="yes" xml:space="preserve">
          <source>This example shows how changing the URL hash causes the &lt;code&gt;$route&lt;/code&gt; to match a route against the URL, and the &lt;code&gt;ngView&lt;/code&gt; pulls in the partial.</source>
          <target state="translated">此示例显示了更改URL哈希如何使 &lt;code&gt;$route&lt;/code&gt; route与该URL匹配路由，以及 &lt;code&gt;ngView&lt;/code&gt; 提取部分路由。</target>
        </trans-unit>
        <trans-unit id="9f4785f3aeb8fb8df8ff217d8f7532f2381938df" translate="yes" xml:space="preserve">
          <source>This example shows how the &quot;plural&quot; keyword is used to account for a variable number of entities. The &quot;#&quot; variable holds the current number and can be embedded in the message.</source>
          <target state="translated">这个例子展示了如何使用 &quot;复数 &quot;关键字来说明实体的可变数量。&quot;#&quot;变量表示当前的数量,可以嵌入到消息中。</target>
        </trans-unit>
        <trans-unit id="e55cb6ec0ca6093526d7c62828c0edb1a5287a8f" translate="yes" xml:space="preserve">
          <source>This example shows how the controller of the component toggle is reused in the template through the scope to use its logic.</source>
          <target state="translated">这个例子展示了如何在模板中通过作用域重用组件切换的控制器来使用其逻辑。</target>
        </trans-unit>
        <trans-unit id="69e881047eb340059e7a5c610f077c2d20a3c79a" translate="yes" xml:space="preserve">
          <source>This example shows how to apply the &lt;code&gt;ngCsp&lt;/code&gt; directive to the &lt;code&gt;html&lt;/code&gt; tag.</source>
          <target state="translated">本示例说明如何将 &lt;code&gt;ngCsp&lt;/code&gt; 指令应用于 &lt;code&gt;html&lt;/code&gt; 标记。</target>
        </trans-unit>
        <trans-unit id="ed56fc3aaeb01e292a55fc62f95abc22c84a204a" translate="yes" xml:space="preserve">
          <source>This example shows how to debounce model changes. Model will be updated only 250 milliseconds after last change.</source>
          <target state="translated">这个例子展示了如何解除模型变化。模型将在最后一次更改后仅更新250毫秒。</target>
        </trans-unit>
        <trans-unit id="dc222f9782b698d44e5acc2eade213e958921a1d" translate="yes" xml:space="preserve">
          <source>This example shows how to force jqLite using the &lt;code&gt;ngJq&lt;/code&gt; directive to the &lt;code&gt;html&lt;/code&gt; tag.</source>
          <target state="translated">本示例说明如何使用 &lt;code&gt;ngJq&lt;/code&gt; 伪指令对 &lt;code&gt;html&lt;/code&gt; 标签强制jqLit​​e 。</target>
        </trans-unit>
        <trans-unit id="29ee8b3617765a9363a9be166a628c4aca7bac28" translate="yes" xml:space="preserve">
          <source>This example shows how to use &lt;code&gt;NgModelController&lt;/code&gt; with a custom control to achieve data-binding. Notice how different directives (&lt;code&gt;contenteditable&lt;/code&gt;, &lt;code&gt;ng-model&lt;/code&gt;, and &lt;code&gt;required&lt;/code&gt;) collaborate together to achieve the desired result.</source>
          <target state="translated">本示例说明如何将 &lt;code&gt;NgModelController&lt;/code&gt; 与自定义控件一起使用以实现数据绑定。注意不同的指令（ &lt;code&gt;contenteditable&lt;/code&gt; ， &lt;code&gt;ng-model&lt;/code&gt; 和 &lt;code&gt;required&lt;/code&gt; ）如何一起协作以实现所需的结果。</target>
        </trans-unit>
        <trans-unit id="61fd9907007de818b0a51eb35a082e1bfacde0e8" translate="yes" xml:space="preserve">
          <source>This example shows how to use &lt;code&gt;NgTransclude&lt;/code&gt; with fallback content, that is displayed if no transcluded content is provided.</source>
          <target state="translated">本示例说明如何将 &lt;code&gt;NgTransclude&lt;/code&gt; 与后备内容一起使用，如果未提供任何被包含的内容，则会显示该内容。</target>
        </trans-unit>
        <trans-unit id="e6557ff22ab6eb5f2546a30b5f46c79ffc013794" translate="yes" xml:space="preserve">
          <source>This example shows how to use a jQuery based library of a different name. The library name must be available at the top most 'window'.</source>
          <target state="translated">这个例子展示了如何使用一个基于jQuery的不同名称的库。库名必须在最上面的 &quot;窗口 &quot;中可用。</target>
        </trans-unit>
        <trans-unit id="1bc1e70306fccb4e924402e50a8c62fd84c5d7bf" translate="yes" xml:space="preserve">
          <source>This example shows how we can replace the $log service with our own to display log messages.</source>
          <target state="translated">这个例子展示了我们如何用自己的服务替换$log服务来显示日志消息。</target>
        </trans-unit>
        <trans-unit id="98d3805b27d8a26b73944c9f271d3372cd57cd4f" translate="yes" xml:space="preserve">
          <source>This example shows how you can check for mutations to a Date object even though the identity of the object has not changed.</source>
          <target state="translated">这个例子展示了如何检查Date对象的突变,即使对象的身份没有改变。</target>
        </trans-unit>
        <trans-unit id="85cde9bfa8ac1bdf2bd3651b32a94cf481a55c6e" translate="yes" xml:space="preserve">
          <source>This example shows how you can specify gender rules for specific plural matches - in this case, =1 is special cased for gender.</source>
          <target state="translated">这个例子展示了如何为特定的复数匹配指定性别规则--在本例中,=1是性别的特殊写法。</target>
        </trans-unit>
        <trans-unit id="9749a4623a260025246f8b93aa5465ed0e4db5e8" translate="yes" xml:space="preserve">
          <source>This example shows the recommended path for integrating AngularJS with what we call automatic initialization.</source>
          <target state="translated">这个例子展示了将AngularJS与我们所说的自动初始化整合的推荐路径。</target>
        </trans-unit>
        <trans-unit id="16aad3f4a7cb6d7e3f26212344ec18cf12df0870" translate="yes" xml:space="preserve">
          <source>This example shows the relationship between &quot;default&quot; update events and additional &lt;code&gt;updateOn&lt;/code&gt; triggers.</source>
          <target state="translated">此示例显示&amp;ldquo;默认&amp;rdquo;更新事件与其他 &lt;code&gt;updateOn&lt;/code&gt; 触发器之间的关系。</target>
        </trans-unit>
        <trans-unit id="5a8998cc45e803c5f7423eaa2a721c7a2920c113" translate="yes" xml:space="preserve">
          <source>This example shows various combinations of &lt;code&gt;href&lt;/code&gt;, &lt;code&gt;ng-href&lt;/code&gt; and &lt;code&gt;ng-click&lt;/code&gt; attributes in links and their different behaviors:</source>
          <target state="translated">此示例显示链接中 &lt;code&gt;href&lt;/code&gt; ， &lt;code&gt;ng-href&lt;/code&gt; 和 &lt;code&gt;ng-click&lt;/code&gt; 属性的各种组合及其不同的行为：</target>
        </trans-unit>
        <trans-unit id="05ca10821b1fd973b5ab4a8e10404776b2b56f8c" translate="yes" xml:space="preserve">
          <source>This example uses &lt;code&gt;ngRepeat&lt;/code&gt; to display a list of people. A filter is used to restrict the displayed results by name or by age. New (entering) and removed (leaving) items are animated.</source>
          <target state="translated">本示例使用 &lt;code&gt;ngRepeat&lt;/code&gt; 显示人员列表。过滤器用于按名称或年龄限制显示的结果。新（输入）和已删除（离开）的项目会设置动画。</target>
        </trans-unit>
        <trans-unit id="69806b8ba755780069d6f6cc5178b21da806ae26" translate="yes" xml:space="preserve">
          <source>This example uses the &quot;select&quot; keyword to specify the message based on gender.</source>
          <target state="translated">这个例子使用 &quot;select &quot;关键字来指定基于性别的消息。</target>
        </trans-unit>
        <trans-unit id="9d7aedeff039b8214af79d9d1aa1f2262c75c572" translate="yes" xml:space="preserve">
          <source>This feature enables tools like &lt;a href=&quot;https://github.com/angular/angularjs-batarang&quot;&gt;Batarang&lt;/a&gt; and test runners to hook into angular's bootstrap process and sneak in more modules into the DI registry which can replace or augment DI services for the purpose of instrumentation or mocking out heavy dependencies.</source>
          <target state="translated">此功能使&lt;a href=&quot;https://github.com/angular/angularjs-batarang&quot;&gt;Batarang&lt;/a&gt;和测试运行器之类的工具可以挂接到angular的引导过程中，并将更多模块潜入DI注册表中，这些注册表可以替换或扩充DI服务，以便进行检测或消除严重的依赖性。</target>
        </trans-unit>
        <trans-unit id="c02ae2a8961bbe5f114d4fe421285b2cfe5838cc" translate="yes" xml:space="preserve">
          <source>This feature is sometimes used to mix different markup languages, e.g. to wrap an AngularJS template within a Python Jinja template (or any other template language). Mixing templating languages is &lt;strong&gt;very dangerous&lt;/strong&gt;. The embedding template language will not safely escape AngularJS expressions, so any user-controlled values in the template will cause Cross Site Scripting (XSS) security bugs!</source>
          <target state="translated">有时，此功能用于混合不同的标记语言，例如，将AngularJS模板包装在Python Jinja模板（或任何其他模板语言）中。混合模板语言&lt;strong&gt;非常危险&lt;/strong&gt;。嵌入模板语言将无法安全地转义AngularJS表达式，因此模板中任何用户控制的值都将导致跨站点脚本（XSS）安全错误！</target>
        </trans-unit>
        <trans-unit id="72e289eefaf5aaf4145ca3a0206a0d8bebdbb225" translate="yes" xml:space="preserve">
          <source>This feels like too much overhead</source>
          <target state="translated">这感觉好像开销太大</target>
        </trans-unit>
        <trans-unit id="e37ade63953d0e46c93b36ee67acdb6a7374a215" translate="yes" xml:space="preserve">
          <source>This filter is mostly useful for debugging. When using the double curly {{value}} notation the binding is automatically converted to JSON.</source>
          <target state="translated">这个过滤器主要用于调试。当使用双曲{{value}}符号时,绑定会自动转换为JSON。</target>
        </trans-unit>
        <trans-unit id="55e88b554c469156081629a31c90300b4541a621" translate="yes" xml:space="preserve">
          <source>This function can be called during the &lt;a href=&quot;../api/ng/type/angular.module#config.html&quot;&gt;config&lt;/a&gt; phase of an app. It takes a filter function as the only argument, which will then be used to &quot;filter&quot; animations (based on the animated element, the event type, and the animation options). Only when the filter function returns &lt;code&gt;true&lt;/code&gt;, will the animation be performed. This allows great flexibility - you can easily create complex rules, such as allowing specific events only or enabling animations on specific subtrees of the DOM, and dynamically modify them, for example disabling animations at certain points in time or under certain circumstances.</source>
          <target state="translated">可以在应用程序的&lt;a href=&quot;../api/ng/type/angular.module#config.html&quot;&gt;配置&lt;/a&gt;阶段调用此函数。它仅将过滤器功能作为参数，然后将其用于&amp;ldquo;过滤&amp;rdquo;动画（基于动画元素，事件类型和动画选项）。仅当filter函数返回 &lt;code&gt;true&lt;/code&gt; 时，才会执行动画。这提供了极大的灵活性-您可以轻松创建复杂的规则，例如仅允许特定事件或在DOM的特定子树上启用动画，并动态修改它们，例如在某些时间点或某些情况下禁用动画。</target>
        </trans-unit>
        <trans-unit id="59700d24630b5cf9b8040af13c05f801039b3bd8" translate="yes" xml:space="preserve">
          <source>This function can be used to enable / disable animations in two different ways:</source>
          <target state="translated">这个功能可以用两种不同的方式来启用/禁用动画。</target>
        </trans-unit>
        <trans-unit id="e0c8ee3e6d86ff0ba46d68a1e4de3e4dd2d574fb" translate="yes" xml:space="preserve">
          <source>This function can be used when the &lt;code&gt;$viewValue&lt;/code&gt; or the rendered DOM value are not correctly formatted and the &lt;code&gt;$modelValue&lt;/code&gt; must be run through the &lt;code&gt;$formatters&lt;/code&gt; again.</source>
          <target state="translated">当 &lt;code&gt;$viewValue&lt;/code&gt; 或呈现的DOM值的格式不正确并且 &lt;code&gt;$modelValue&lt;/code&gt; 必须再次通过 &lt;code&gt;$formatters&lt;/code&gt; 运行时，可以使用此函数。</target>
        </trans-unit>
        <trans-unit id="cbe05ce09a70d470f85ee4dd7a1f4dd51855e2eb" translate="yes" xml:space="preserve">
          <source>This function ensures a single injector will be used for all tests in a given describe context. This contrasts with the default behaviour where a new injector is created per test case.</source>
          <target state="translated">这个函数确保在一个给定的描述上下文中,所有的测试都将使用一个注入器。这与默认的行为形成鲜明对比,即每个测试用例都会创建一个新的注入器。</target>
        </trans-unit>
        <trans-unit id="874dbb62e56a0d601c13b08f260529654912b687" translate="yes" xml:space="preserve">
          <source>This function is deprecated, but will not be removed in the 1.x lifecycle. There are edge cases (see &lt;a href=&quot;angular.merge#known-issues.html&quot;&gt;known issues&lt;/a&gt;) that are not supported by this function. We suggest using another, similar library for all-purpose merging, such as &lt;a href=&quot;https://lodash.com/docs/4.17.4#merge&quot;&gt;lodash's merge()&lt;/a&gt;.</source>
          <target state="translated">此功能已弃用，但不会在1.x生命周期中删除。此功能不支持某些极端情况（请参阅&lt;a href=&quot;angular.merge#known-issues.html&quot;&gt;已知问题&lt;/a&gt;）。我们建议为通用合并使用另一个类似的库，例如&lt;a href=&quot;https://lodash.com/docs/4.17.4#merge&quot;&gt;lodash的merge（）&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="104e4ee7bf47164b402b647bc9d4f92d3444f4cb" translate="yes" xml:space="preserve">
          <source>This function registers a module configuration code. It collects the configuration information which will be used when the injector is created by &lt;a href=&quot;angular.mock.inject&quot;&gt;inject&lt;/a&gt;.</source>
          <target state="translated">该功能注册模块配置代码。它收集配置信息，该信息将在通过&lt;a href=&quot;angular.mock.inject&quot;&gt;ject&lt;/a&gt;创建注入器时使用。</target>
        </trans-unit>
        <trans-unit id="66a348d878643285a3617b02bb385a84d7bd067c" translate="yes" xml:space="preserve">
          <source>This function too can be called during the &lt;a href=&quot;../api/ng/type/angular.module#config.html&quot;&gt;config&lt;/a&gt; phase of an app. It takes a regex as the only argument, which will then be matched against the classes of any element that is about to be animated. The regex allows a lot of flexibility - you can either allow animations for specific classes only (useful when you are working with 3rd party animations), or exclude specific classes from getting animated.</source>
          <target state="translated">该功能也可以在应用程序的&lt;a href=&quot;../api/ng/type/angular.module#config.html&quot;&gt;配置&lt;/a&gt;阶段调用。它使用正则表达式作为唯一参数，然后将其与将要进行动画处理的任何元素的类进行匹配。正则表达式具有很大的灵活性-您可以只允许特定类的动画（在使用第三方动画时有用），也可以排除特定类的动画。</target>
        </trans-unit>
        <trans-unit id="c159109652872117256320d96144b40d035fe7a8" translate="yes" xml:space="preserve">
          <source>This function will be invoked when the service needs to be instantiated and should return the decorated service instance.</source>
          <target state="translated">这个函数将在需要实例化服务时被调用,应该返回被装饰的服务实例。</target>
        </trans-unit>
        <trans-unit id="a119154461db6dbbb0ee1429bb68c89f82a67750" translate="yes" xml:space="preserve">
          <source>This function will be invoked when the service needs to be provided and should return the decorated service instance. The function is called using the &lt;a href=&quot;%24injector#invoke.html&quot;&gt;injector.invoke&lt;/a&gt; method and is therefore fully injectable. Local injection arguments:</source>
          <target state="translated">当需要提供服务时，将调用此函数，并应返回装饰后的服务实例。该函数使用&lt;a href=&quot;%24injector#invoke.html&quot;&gt;jector.invoke&lt;/a&gt;方法调用，因此可以完全注入。局部注入参数：</target>
        </trans-unit>
        <trans-unit id="7ace1d7e9d12a0251168d9e9c7837973f650e71b" translate="yes" xml:space="preserve">
          <source>This function will throw if the safe type isn't appropriate for this context, or if the value given cannot be accepted in the context (which might be caused by sanitization not being available, or the value not being recognized as safe).</source>
          <target state="translated">如果安全类型不适合这个上下文,或者给定的值在上下文中不能被接受(可能是由于消毒不可用,或者值没有被识别为安全类型),这个函数将抛出。</target>
        </trans-unit>
        <trans-unit id="868f6b7d204bd6db32315fed3c1b9cdaa4a62fb2" translate="yes" xml:space="preserve">
          <source>This implementation can be used to respond with static or dynamic responses via the &lt;code&gt;when&lt;/code&gt; api and its shortcuts (&lt;code&gt;whenGET&lt;/code&gt;, &lt;code&gt;whenPOST&lt;/code&gt;, etc) and optionally pass through requests to the real $httpBackend for specific requests (e.g. to interact with certain remote apis or to fetch templates from a webserver).</source>
          <target state="translated">此实现可用于通过 &lt;code&gt;when&lt;/code&gt; api及其快捷方式（ &lt;code&gt;whenGET&lt;/code&gt; ， &lt;code&gt;whenPOST&lt;/code&gt; 等）还可以选择将请求传递给实际的$ httpBackend以获取特定请求（例如与某些远程api进行交互或获取）来自网络服务器的模板）。</target>
        </trans-unit>
        <trans-unit id="bbf3e56350b9c22d5e436b82ecd7c89f7a51c73d" translate="yes" xml:space="preserve">
          <source>This implies that the internal state of both the form and the control is available for binding in the view using the standard binding primitives.</source>
          <target state="translated">这意味着表单和控件的内部状态均可在视图中使用标准绑定基元进行绑定。</target>
        </trans-unit>
        <trans-unit id="6e4e2dd3c9342812b2650439b3f4dfe11726f42e" translate="yes" xml:space="preserve">
          <source>This includes the &quot;special&quot; numbers &lt;code&gt;NaN&lt;/code&gt;, &lt;code&gt;+Infinity&lt;/code&gt; and &lt;code&gt;-Infinity&lt;/code&gt;.</source>
          <target state="translated">这包括&amp;ldquo;特殊&amp;rdquo;数字 &lt;code&gt;NaN&lt;/code&gt; ， &lt;code&gt;+Infinity&lt;/code&gt; 和 &lt;code&gt;-Infinity&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="80c58f6b6a5db22c94200d23e6f5ba515e0f7db1" translate="yes" xml:space="preserve">
          <source>This is a &lt;a href=&quot;https://promisesaplus.com/&quot;&gt;Promises/A+&lt;/a&gt;-compliant implementation of promises/deferred objects inspired by &lt;a href=&quot;https://github.com/kriskowal/q&quot;&gt;Kris Kowal's Q&lt;/a&gt;.</source>
          <target state="translated">这是受&lt;a href=&quot;https://github.com/kriskowal/q&quot;&gt;Kris Kowal Q&lt;/a&gt;启发而实现的&lt;a href=&quot;https://promisesaplus.com/&quot;&gt;Promise / A +&lt;/a&gt;兼容的Promise /递延对象的实现。</target>
        </trans-unit>
        <trans-unit id="0dba2df7f6ddcb854fb3341d09b04f21dab2773e" translate="yes" xml:space="preserve">
          <source>This is a collection of external, 3rd party resources for learning and developing AngularJS.</source>
          <target state="translated">这是一个学习和开发AngularJS的外部、第三方资源的集合。</target>
        </trans-unit>
        <trans-unit id="21aeaba9662970643b7a9fb7ec7ea1ef8bfe63ac" translate="yes" xml:space="preserve">
          <source>This is a global (window) function that is only available when the &lt;a href=&quot;../../ngmock&quot;&gt;&lt;code&gt;ngMock&lt;/code&gt;&lt;/a&gt; module is included.</source>
          <target state="translated">这是一个全局（窗口）功能，仅在&lt;a href=&quot;../../ngmock&quot;&gt; &lt;code&gt;ngMock&lt;/code&gt; &lt;/a&gt;时可用模块。</target>
        </trans-unit>
        <trans-unit id="3aeed192065b716e51303fafb7933c0cc0d12aa7" translate="yes" xml:space="preserve">
          <source>This is a global (window) function that is only available when the &lt;a href=&quot;../ngmock&quot;&gt;&lt;code&gt;ngMock&lt;/code&gt;&lt;/a&gt; module is included.</source>
          <target state="translated">这是一个全局（窗口）功能，仅在&lt;a href=&quot;../ngmock&quot;&gt; &lt;code&gt;ngMock&lt;/code&gt; &lt;/a&gt;时可用模块。</target>
        </trans-unit>
        <trans-unit id="940be712194ff22a2b0c9f05c98206545090b459" translate="yes" xml:space="preserve">
          <source>This is a global (window) function that is only available when the &lt;a href=&quot;ngmock&quot;&gt;&lt;code&gt;ngMock&lt;/code&gt;&lt;/a&gt; module is included.</source>
          <target state="translated">这是一个全局（窗口）功能，仅在&lt;a href=&quot;ngmock&quot;&gt; &lt;code&gt;ngMock&lt;/code&gt; &lt;/a&gt;时可用模块。</target>
        </trans-unit>
        <trans-unit id="a9bc078a3179c93a01b2304ea5af8b2a3d4add3a" translate="yes" xml:space="preserve">
          <source>This is a list of (known) object types that are not handled correctly by this function:</source>
          <target state="translated">这是本函数不能正确处理的(已知)对象类型的列表。</target>
        </trans-unit>
        <trans-unit id="e8e04a228b77e4ceb9e95143b611a06958ab031c" translate="yes" xml:space="preserve">
          <source>This is a list of libraries that enhance AngularJS, add common UI components or integrate with other libraries. You can find a larger list of AngularJS external libraries at &lt;a href=&quot;http://ngmodules.org/&quot;&gt;ngmodules.org&lt;/a&gt;.</source>
          <target state="translated">这是增强AngularJS，添加通用UI组件或与其他库集成的库的列表。您可以在&lt;a href=&quot;http://ngmodules.org/&quot;&gt;ngmodules.org上&lt;/a&gt;找到更多的AngularJS外部库列表。</target>
        </trans-unit>
        <trans-unit id="8b4d2f9c6398ff6489ba72736fd69aa6792f94f7" translate="yes" xml:space="preserve">
          <source>This is a non-exhaustive list of object types / features that are not handled correctly by &lt;code&gt;angular.copy&lt;/code&gt;. Note that since this functions is used by the change detection code, this means binding or watching objects of these types (or that include these types) might not work correctly.</source>
          <target state="translated">这是由 &lt;code&gt;angular.copy&lt;/code&gt; 无法正确处理的对象类型/特征的详尽列表。请注意，由于此功能由变更检测代码使用，因此这意味着绑定或监视这些类型（或包括这些类型）的对象可能无法正常工作。</target>
        </trans-unit>
        <trans-unit id="243531736be9806625723a16f6421de48871a398" translate="yes" xml:space="preserve">
          <source>This is a special class that can be used to prevent unwanted flickering / flash of content before the actual animation starts. The class is added as soon as an animation is initialized, but removed before the actual animation starts (after waiting for a $digest). It is also only added for &lt;em&gt;structural&lt;/em&gt; animations (&lt;code&gt;enter&lt;/code&gt;, &lt;code&gt;move&lt;/code&gt;, and &lt;code&gt;leave&lt;/code&gt;).</source>
          <target state="translated">这是一个特殊的类，可用于在实际动画开始之前防止不必要的内容闪烁/闪烁。动画初始化后立即添加该类，但在实际动画开始之前（等待$ digest之后）将其删除。它也只为&lt;em&gt;结构&lt;/em&gt;动画添加（ &lt;code&gt;enter&lt;/code&gt; ， &lt;code&gt;move&lt;/code&gt; 和 &lt;code&gt;leave&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="8c921d5dab3491a0ede284d2c4169c0796dd9692" translate="yes" xml:space="preserve">
          <source>This is all done behind the scenes. Notice that by having the &lt;code&gt;ng-controller&lt;/code&gt; ask the injector to instantiate the class, it can satisfy all of the dependencies of &lt;code&gt;MyController&lt;/code&gt; without the controller ever knowing about the injector.</source>
          <target state="translated">这些都是在后台完成的。请注意，通过让 &lt;code&gt;ng-controller&lt;/code&gt; 要求注入器实例化该类，它可以满足 &lt;code&gt;MyController&lt;/code&gt; 的所有依赖关系，而无需控制器知道注入器。</target>
        </trans-unit>
        <trans-unit id="c0c13bc636a5e20f5b33c815c14d171efa71421f" translate="yes" xml:space="preserve">
          <source>This is called when we need to determine if the value of an input is empty.</source>
          <target state="translated">当我们需要确定一个输入的值是否为空时,就会调用这个函数。</target>
        </trans-unit>
        <trans-unit id="0705b013e2055b12840aa9f33bf1c6e01e702f6d" translate="yes" xml:space="preserve">
          <source>This is clearly not a great solution.</source>
          <target state="translated">这显然不是一个好办法。</target>
        </trans-unit>
        <trans-unit id="8c0b33e0f52faca414488a07a74d8d29174945ba" translate="yes" xml:space="preserve">
          <source>This is desirable, but it puts the responsibility of getting hold of the dependency on the code that constructs &lt;code&gt;SomeClass&lt;/code&gt;.</source>
          <target state="translated">这是合乎需要的，但是它将责任保持在构造 &lt;code&gt;SomeClass&lt;/code&gt; 的代码上。</target>
        </trans-unit>
        <trans-unit id="6e19cc504a64dbc7e5223f67be790ee5a786042e" translate="yes" xml:space="preserve">
          <source>This is followed by a list of selection keyword and corresponding message pairs. The &quot;other&quot; keyword and corresponding message are &lt;strong&gt;required&lt;/strong&gt; but you may have as few or as many of the other categories as you need.</source>
          <target state="translated">随后是选择关键字和相应消息对的列表。&amp;ldquo; other&amp;rdquo;关键字和相应的消息是&lt;strong&gt;必需的，&lt;/strong&gt;但是您可能需要的其他类别也可能少或多。</target>
        </trans-unit>
        <trans-unit id="830044fcd0e944858b0f63daf06beb477ee3aa4f" translate="yes" xml:space="preserve">
          <source>This is followed by a list of selection keyword and corresponding message pairs. The &quot;other&quot; keyword and corresponding message are &lt;strong&gt;required&lt;/strong&gt; but you may have as few or as many of the other gender values as you need (i.e. it isn't restricted to male/female.) Note however, that the matching is &lt;strong&gt;case-sensitive&lt;/strong&gt;.</source>
          <target state="translated">随后是选择关键字和相应消息对的列表。需要&amp;ldquo; other&amp;rdquo;关键字和相应的消息，但是您可以&lt;strong&gt;根据需要&lt;/strong&gt;拥有任意数量的性别值（即不限于男性/女性。）但是请注意，匹配项&lt;strong&gt;区分大小写&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="bcc3f10937fdf2eb5b1c0d43e9871f7899de9628" translate="yes" xml:space="preserve">
          <source>This is necessary when developing things like Google Chrome Extensions or Universal Windows Apps.</source>
          <target state="translated">在开发Google Chrome Extensions或Universal Windows Apps等东西时,这是必要的。</target>
        </trans-unit>
        <trans-unit id="6f9743eeaff280817f27f1c2c3f8c185c14b8871" translate="yes" xml:space="preserve">
          <source>This is similar to &lt;code&gt;template&lt;/code&gt; but the template is loaded from the specified URL, asynchronously.</source>
          <target state="translated">这类似于 &lt;code&gt;template&lt;/code&gt; 但是模板是从指定的URL异步加载的。</target>
        </trans-unit>
        <trans-unit id="c2a22a93c5db90cc0e312d0bd6caa04b04b4c2eb" translate="yes" xml:space="preserve">
          <source>This is taken from the above example.</source>
          <target state="translated">这是从上面的例子中提取的。</target>
        </trans-unit>
        <trans-unit id="6cc3106a660e4677bcc273826723ac7286f55964" translate="yes" xml:space="preserve">
          <source>This is the best outcome. The application code simply declares the dependencies it needs, without having to deal with the injector. This setup does not break the Law of Demeter.</source>
          <target state="translated">这是最好的结果。应用程序代码只需声明它所需要的依赖关系,而不必与注入器打交道。这种设置并不违反德墨忒尔定律。</target>
        </trans-unit>
        <trans-unit id="42cf60690a82822d827602db3861e00f4b6e5726" translate="yes" xml:space="preserve">
          <source>This is the core version of &lt;code&gt;$animateCss&lt;/code&gt;. By default, only when the &lt;code&gt;ngAnimate&lt;/code&gt; is included, then the &lt;code&gt;$animateCss&lt;/code&gt; service will actually perform animations.</source>
          <target state="translated">这是 &lt;code&gt;$animateCss&lt;/code&gt; 的核心版本。默认情况下，仅当包含 &lt;code&gt;ngAnimate&lt;/code&gt; 时， &lt;code&gt;$animateCss&lt;/code&gt; 服务才会实际执行动画。</target>
        </trans-unit>
        <trans-unit id="8fe7c930ab124d17cccc4266216fed96a7db7677" translate="yes" xml:space="preserve">
          <source>This is the preferred way to annotate application components. This is how the examples in the documentation are written.</source>
          <target state="translated">这是注释应用程序组件的首选方式。文档中的例子就是这样写的。</target>
        </trans-unit>
        <trans-unit id="e99173c0622fc29819acb26a64190ef25cec6946" translate="yes" xml:space="preserve">
          <source>This is the sequence that your code should follow:</source>
          <target state="translated">这是你的代码应该遵循的顺序。</target>
        </trans-unit>
        <trans-unit id="bd952f6c2b0ab426ac04bd58194e1818a961d2b2" translate="yes" xml:space="preserve">
          <source>This is useful if a you have a default response that is overriden inside specific tests.</source>
          <target state="translated">如果你有一个默认的响应,并在特定的测试中被覆盖,这是很有用的。</target>
        </trans-unit>
        <trans-unit id="106a413d228469230b2f1ee6489f09b04a5ce051" translate="yes" xml:space="preserve">
          <source>This is where &lt;a href=&quot;di&quot;&gt;Dependency Injection&lt;/a&gt; comes into play. Dependency Injection (DI) is a software design pattern that deals with how objects and functions get created and how they get a hold of their dependencies. Everything within AngularJS (directives, filters, controllers, services, ...) is created and wired using dependency injection. Within AngularJS, the DI container is called the &lt;a href=&quot;di&quot;&gt;injector&lt;/a&gt;.</source>
          <target state="translated">这就是&lt;a href=&quot;di&quot;&gt;依赖注入的&lt;/a&gt;作用。依赖注入（DI）是一种软件设计模式，涉及对象和函数的创建方式以及它们如何保持依赖关系。AngularJS中的所有内容（指令，过滤器，控制器，服务等）都是使用依赖注入创建和连接的。在AngularJS中，DI容器称为&lt;a href=&quot;di&quot;&gt;注射器&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="bd73e2280f08f2867f649e593661732c488f0cde" translate="yes" xml:space="preserve">
          <source>This is, however, exactly the use-case that the Service recipe is the most suitable for.</source>
          <target state="translated">然而,这恰恰是服务配方最适合的使用情况。</target>
        </trans-unit>
        <trans-unit id="7558a0b4c85e4c406f419884da5d0524791d2c44" translate="yes" xml:space="preserve">
          <source>This looks like normal HTML, with some new markup. In AngularJS, a file like this is called a &lt;a href=&quot;templates&quot;&gt;template&lt;/a&gt;. When AngularJS starts your application, it parses and processes this new markup from the template using the &lt;a href=&quot;compiler&quot;&gt;compiler&lt;/a&gt;. The loaded, transformed and rendered DOM is then called the &lt;em&gt;view&lt;/em&gt;.</source>
          <target state="translated">这看起来像普通的HTML，带有一些新的标记。在AngularJS中，这样的文件称为&lt;a href=&quot;templates&quot;&gt;template&lt;/a&gt;。AngularJS启动您的应用程序时，它将使用&lt;a href=&quot;compiler&quot;&gt;编译器&lt;/a&gt;从模板解析并处理此新标记。加载，转换和渲染的DOM称为&lt;em&gt;视图&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="38b2e8311081c7751c2533d1619c905371007bd7" translate="yes" xml:space="preserve">
          <source>This makes it easier to write an app in a way that's similar to using Web Components or using the new Angular's style of application architecture.</source>
          <target state="translated">这使得编写应用程序的方式更容易,类似于使用Web Components或使用新的Angular的应用程序架构风格。</target>
        </trans-unit>
        <trans-unit id="a7f46c84b99f6c66daf57e614d0604305863fdee" translate="yes" xml:space="preserve">
          <source>This makes it possible for the widget to have private state for its template, while the transcluded content has access to its originating scope.</source>
          <target state="translated">这使得widget可以为它的模板拥有私有状态,而转入的内容可以访问它的原始范围。</target>
        </trans-unit>
        <trans-unit id="5b547a3365f5455bb23472c7583140ed975d34a1" translate="yes" xml:space="preserve">
          <source>This may seem to be unexpected complexity, but it gives the widget user and developer the least surprise.</source>
          <target state="translated">这看起来似乎是意想不到的复杂,但它给widget用户和开发者带来了最小的惊喜。</target>
        </trans-unit>
        <trans-unit id="c9d2b0a1a474c5c524a2e46ab836d1ad41fbe991" translate="yes" xml:space="preserve">
          <source>This means that any changes to the data need to be re-merged with the template and then &lt;code&gt;innerHTML&lt;/code&gt;ed into the DOM. Some of the issues with this approach are:</source>
          <target state="translated">这意味着对数据的任何更改都需要与模板重新合并，然后将 &lt;code&gt;innerHTML&lt;/code&gt; 编辑到DOM中。这种方法的一些问题是：</target>
        </trans-unit>
        <trans-unit id="3797c257375c657fdb65bc7afd3178dde6553049" translate="yes" xml:space="preserve">
          <source>This method &lt;em&gt;returns a new promise&lt;/em&gt; which is resolved or rejected via the return value of the &lt;code&gt;successCallback&lt;/code&gt;, &lt;code&gt;errorCallback&lt;/code&gt; (unless that value is a promise, in which case it is resolved with the value which is resolved in that promise using &lt;a href=&quot;http://www.html5rocks.com/en/tutorials/es6/promises/#toc-promises-queues&quot;&gt;promise chaining&lt;/a&gt;). It also notifies via the return value of the &lt;code&gt;notifyCallback&lt;/code&gt; method. The promise cannot be resolved or rejected from the notifyCallback method. The errorCallback and notifyCallback arguments are optional.</source>
          <target state="translated">此方法&lt;em&gt;返回一个新的promise&lt;/em&gt;，可通过 &lt;code&gt;successCallback&lt;/code&gt; ， &lt;code&gt;errorCallback&lt;/code&gt; 的返回值来解决或拒绝&lt;em&gt;该新promise&lt;/em&gt;（除非该值是一个promise，在这种情况下，将使用&lt;a href=&quot;http://www.html5rocks.com/en/tutorials/es6/promises/#toc-promises-queues&quot;&gt;promise链&lt;/a&gt;使用在那个promise中解析的值来解析它）。它还通过 &lt;code&gt;notifyCallback&lt;/code&gt; 方法的返回值进行通知。无法通过notifyCallback方法解决或拒绝诺言。errorCallback和notifyCallback参数是可选的。</target>
        </trans-unit>
        <trans-unit id="dfa92648c02e81fae7a25858df34af1dba44e2d7" translate="yes" xml:space="preserve">
          <source>This method can be called to add the 'ng-dirty' class and set the form to a dirty state (ng-dirty class). This method will also propagate to parent forms.</source>
          <target state="translated">这个方法可以被调用来添加'ng-dirty'类,并将表单设置为脏状态(ng-dirty类)。这个方法也会传播给父级表单。</target>
        </trans-unit>
        <trans-unit id="7b64a60d991bc92f86edf62edf6b119177e9387d" translate="yes" xml:space="preserve">
          <source>This method can be called to remove the 'ng-touched' class and set the form controls to their untouched state (ng-untouched class).</source>
          <target state="translated">这个方法可以被调用来删除 &quot;ng-touched &quot;类,并将表单控件设置为未被触及的状态(ng-untouched类)。</target>
        </trans-unit>
        <trans-unit id="dce764038d2f1e780d1e96003245444b77962bbc" translate="yes" xml:space="preserve">
          <source>This method can be called to remove the &lt;code&gt;ng-dirty&lt;/code&gt; class and set the control to its pristine state (&lt;code&gt;ng-pristine&lt;/code&gt; class). A model is considered to be pristine when the control has not been changed from when first compiled.</source>
          <target state="translated">可以调用此方法以删除 &lt;code&gt;ng-dirty&lt;/code&gt; 类并将控件设置为其原始状态（ &lt;code&gt;ng-pristine&lt;/code&gt; 类）。如果从第一次编译起就没有更改控件，则认为该模型是原始模型。</target>
        </trans-unit>
        <trans-unit id="a104f18bb62aee421639fe99f1a6b3715893e9cd" translate="yes" xml:space="preserve">
          <source>This method can be called to remove the &lt;code&gt;ng-pristine&lt;/code&gt; class and set the control to its dirty state (&lt;code&gt;ng-dirty&lt;/code&gt; class). A model is considered to be dirty when the control has been changed from when first compiled.</source>
          <target state="translated">可以调用此方法以删除 &lt;code&gt;ng-pristine&lt;/code&gt; 类并将控件设置为脏状态（ &lt;code&gt;ng-dirty&lt;/code&gt; 类）。当控件从首次编译时被更改时，模型被认为是肮脏的。</target>
        </trans-unit>
        <trans-unit id="be236d70e3b76ac627108d742a7d930b6e5345dc" translate="yes" xml:space="preserve">
          <source>This method can be called to remove the &lt;code&gt;ng-touched&lt;/code&gt; class and set the control to its untouched state (&lt;code&gt;ng-untouched&lt;/code&gt; class). Upon compilation, a model is set as untouched by default, however this function can be used to restore that state if the model has already been touched by the user.</source>
          <target state="translated">可以调用此方法以删除 &lt;code&gt;ng-touched&lt;/code&gt; 类并将控件设置为其未触摸状态（ &lt;code&gt;ng-untouched&lt;/code&gt; 类）。编译时，默认情况下将模型设置为未触摸，但是如果用户已经触摸过该模型，则可以使用此功能恢复该状态。</target>
        </trans-unit>
        <trans-unit id="09d3c1d51e251c93d6c1a6dd38b04fbbfccbd791" translate="yes" xml:space="preserve">
          <source>This method can be called to remove the &lt;code&gt;ng-untouched&lt;/code&gt; class and set the control to its touched state (&lt;code&gt;ng-touched&lt;/code&gt; class). A model is considered to be touched when the user has first focused the control element and then shifted focus away from the control (blur event).</source>
          <target state="translated">这个方法可以被调用以除去 &lt;code&gt;ng-untouched&lt;/code&gt; 类，并设置控制到它的触摸状态（ &lt;code&gt;ng-touched&lt;/code&gt; 类）。当用户首先将控制元素聚焦然后将焦点从控件移开（模糊事件）时，就认为该模型已被触摸。</target>
        </trans-unit>
        <trans-unit id="039cf05d82b99db28639e2f0df0e8df9fed6d706" translate="yes" xml:space="preserve">
          <source>This method can be called within $parsers/$formatters or a custom validation implementation. However, in most cases it should be sufficient to use the &lt;code&gt;ngModel.$validators&lt;/code&gt; and &lt;code&gt;ngModel.$asyncValidators&lt;/code&gt; collections which will call &lt;code&gt;$setValidity&lt;/code&gt; automatically.</source>
          <target state="translated">可以在$ parsers / $ formatters或自定义验证实现中调用此方法。但是，在大多数情况下，使用 &lt;code&gt;ngModel.$validators&lt;/code&gt; 和 &lt;code&gt;ngModel.$asyncValidators&lt;/code&gt; 集合就足够了，它们将自动调用 &lt;code&gt;$setValidity&lt;/code&gt; setValidity。</target>
        </trans-unit>
        <trans-unit id="2a0539f5b7dcaa5c95fe933397c2c13fa49ebc03" translate="yes" xml:space="preserve">
          <source>This method can be used to change which mocked responses &lt;code&gt;$httpBackend&lt;/code&gt; returns, when defining them with &lt;a href=&quot;%24httpbackend#when.html&quot;&gt;$httpBackend.when()&lt;/a&gt; (and shortcut methods). By default, &lt;code&gt;$httpBackend&lt;/code&gt; returns the first definition that matches. When setting &lt;code&gt;$http.matchLatestDefinitionEnabled(true)&lt;/code&gt;, it will use the last response that matches, i.e. the one that was added last.</source>
          <target state="translated">当使用&lt;a href=&quot;%24httpbackend#when.html&quot;&gt;$ httpBackend.when（）&lt;/a&gt;（和快捷方式方法）定义响应时，此方法可用于更改 &lt;code&gt;$httpBackend&lt;/code&gt; 返回的模拟响应。默认情况下， &lt;code&gt;$httpBackend&lt;/code&gt; 返回匹配的第一个定义。设置 &lt;code&gt;$http.matchLatestDefinitionEnabled(true)&lt;/code&gt; ，它将使用匹配的最后一个响应，即最后添加的一个。</target>
        </trans-unit>
        <trans-unit id="dcc61f9b44cb07452831de5334ffe49067b455e3" translate="yes" xml:space="preserve">
          <source>This method can be used to change which mocked responses &lt;code&gt;$httpBackend&lt;/code&gt; returns, when defining them with &lt;a href=&quot;../../ngmock/service/%24httpbackend#when.html&quot;&gt;$httpBackend.when()&lt;/a&gt; (and shortcut methods). By default, &lt;code&gt;$httpBackend&lt;/code&gt; returns the first definition that matches. When setting &lt;code&gt;$http.matchLatestDefinitionEnabled(true)&lt;/code&gt;, it will use the last response that matches, i.e. the one that was added last.</source>
          <target state="translated">当使用&lt;a href=&quot;../../ngmock/service/%24httpbackend#when.html&quot;&gt;$ httpBackend.when（）&lt;/a&gt;（和快捷方式方法）定义响应时，此方法可用于更改 &lt;code&gt;$httpBackend&lt;/code&gt; 返回的模拟响应。默认情况下， &lt;code&gt;$httpBackend&lt;/code&gt; 返回匹配的第一个定义。设置 &lt;code&gt;$http.matchLatestDefinitionEnabled(true)&lt;/code&gt; ，它将使用匹配的最后一个响应，即最后添加的一个。</target>
        </trans-unit>
        <trans-unit id="95660a3cb5771d7b45b7bbb186218a518c26a470" translate="yes" xml:space="preserve">
          <source>This method does not work with code minification / obfuscation. For this reason the following annotation strategies are supported.</source>
          <target state="translated">此方法不能与代码精简/混淆一起使用。因此,支持以下注解策略。</target>
        </trans-unit>
        <trans-unit id="3743c06b6e4464fc92789fb6a0e779ba20b62ec9" translate="yes" xml:space="preserve">
          <source>This method flushes all types of tasks (not only timeouts), which is unintuitive. It is recommended to use &lt;a href=&quot;%24flushpendingtasks&quot;&gt;&lt;code&gt;$flushPendingTasks&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">此方法刷新所有类型的任务（不仅超时），这是不直观的。建议改用&lt;a href=&quot;%24flushpendingtasks&quot;&gt; &lt;code&gt;$flushPendingTasks&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8360fbd33c9d5e68f4591a6c59f7a211a01b3d67" translate="yes" xml:space="preserve">
          <source>This method is called by ngModel internally when the bound scope value changes. Application developers usually do not have to call this function themselves.</source>
          <target state="translated">当绑定的范围值发生变化时,ngModel会在内部调用这个方法。应用开发者通常不需要自己调用这个函数。</target>
        </trans-unit>
        <trans-unit id="111861b1f33e6ba16e0e2a46b6e09b6bdb15aa32" translate="yes" xml:space="preserve">
          <source>This method is getter / setter.</source>
          <target state="translated">这个方法是getter/setter。</target>
        </trans-unit>
        <trans-unit id="ae01763d0e34b30b2df6b37f5dcec088ef8e5dfa" translate="yes" xml:space="preserve">
          <source>This method is getter only.</source>
          <target state="translated">本方法只适用于getter。</target>
        </trans-unit>
        <trans-unit id="c81e50c18dfe60ee4fd5f2abbf2491d1ef6cf978" translate="yes" xml:space="preserve">
          <source>This method is used to flush the pending callbacks and animation frames to either start an animation or conclude an animation. Note that this will not actually close an actively running animation (see &lt;a href=&quot;%24animate#closeAndFlush.html&quot;&gt;&lt;code&gt;closeAndFlush()&lt;/code&gt;&lt;/a&gt; for that).</source>
          <target state="translated">此方法用于刷新挂起的回调和动画帧以开始动画或结束动画。请注意，这实际上不会关闭正在运行的动画（请参见&lt;a href=&quot;%24animate#closeAndFlush.html&quot;&gt; &lt;code&gt;closeAndFlush()&lt;/code&gt; &lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="d2f5be6e2442f3e5478eb9133bc83673c67fcec1" translate="yes" xml:space="preserve">
          <source>This method must be called during the &lt;a href=&quot;../../ng/type/angular.module#config.html&quot;&gt;config&lt;/a&gt; phase. Once the &lt;code&gt;$sanitize&lt;/code&gt; service has been instantiated, this method has no effect.</source>
          <target state="translated">必须在&lt;a href=&quot;../../ng/type/angular.module#config.html&quot;&gt;配置&lt;/a&gt;阶段调用此方法。一旦 &lt;code&gt;$sanitize&lt;/code&gt; 服务已被实例化，这种方法没有任何效果。</target>
        </trans-unit>
        <trans-unit id="b8fcc4fc5c0078d0531686af3fc817e06fcdb9f7" translate="yes" xml:space="preserve">
          <source>This method returns a &lt;strong&gt;shallow copy&lt;/strong&gt; of the controls that are currently part of this form. The controls can be instances of &lt;a href=&quot;form.formcontroller&quot;&gt;&lt;code&gt;FormController&lt;/code&gt;&lt;/a&gt; (&lt;a href=&quot;../directive/ngform&quot;&gt;&quot;child-forms&quot;&lt;/a&gt;) and of &lt;a href=&quot;ngmodel.ngmodelcontroller&quot;&gt;&lt;code&gt;NgModelController&lt;/code&gt;&lt;/a&gt;. If you need access to the controls of child-forms, you have to call &lt;code&gt;$getControls()&lt;/code&gt; recursively on them. This can be used for example to iterate over all controls to validate them.</source>
          <target state="translated">此方法返回当前属于此窗体的控件的&lt;strong&gt;浅表副本&lt;/strong&gt;。控件可以是&lt;a href=&quot;form.formcontroller&quot;&gt; &lt;code&gt;FormController&lt;/code&gt; &lt;/a&gt;（&lt;a href=&quot;../directive/ngform&quot;&gt;&amp;ldquo;子窗体&amp;rdquo;&lt;/a&gt;）和&lt;a href=&quot;ngmodel.ngmodelcontroller&quot;&gt; &lt;code&gt;NgModelController&lt;/code&gt; 的实例&lt;/a&gt;。如果您需要访问子窗体的控件，则必须对它们进行递归调用 &lt;code&gt;$getControls()&lt;/code&gt; 。例如，这可以用于遍历所有控件以验证它们。</target>
        </trans-unit>
        <trans-unit id="7eb2bbddf37cf7ff14a48397a4375854d8e571a9" translate="yes" xml:space="preserve">
          <source>This method sets the form's &lt;code&gt;$pristine&lt;/code&gt; state to true, the &lt;code&gt;$dirty&lt;/code&gt; state to false, removes the &lt;code&gt;ng-dirty&lt;/code&gt; class and adds the &lt;code&gt;ng-pristine&lt;/code&gt; class. Additionally, it sets the &lt;code&gt;$submitted&lt;/code&gt; state to false.</source>
          <target state="translated">此方法将窗体的 &lt;code&gt;$pristine&lt;/code&gt; 状态设置为true，将 &lt;code&gt;$dirty&lt;/code&gt; 状态设置为false，删除 &lt;code&gt;ng-dirty&lt;/code&gt; 类并添加 &lt;code&gt;ng-pristine&lt;/code&gt; 类。此外，它将 &lt;code&gt;$submitted&lt;/code&gt; 状态设置为false。</target>
        </trans-unit>
        <trans-unit id="00f75c22912ee6d84e2b4439725f1730667f3fa5" translate="yes" xml:space="preserve">
          <source>This method should be called when a control wants to change the view value; typically, this is done from within a DOM event handler. For example, the &lt;a href=&quot;../directive/input&quot;&gt;input&lt;/a&gt; directive calls it when the value of the input changes and &lt;a href=&quot;../directive/select&quot;&gt;select&lt;/a&gt; calls it when an option is selected.</source>
          <target state="translated">当控件要更改视图值时，应调用此方法。通常，这是在DOM事件处理程序中完成的。例如，&lt;a href=&quot;../directive/input&quot;&gt;输入&lt;/a&gt;伪指令在输入值更改时调用它，在选择选项时&lt;a href=&quot;../directive/select&quot;&gt;选择&lt;/a&gt;调用它。</target>
        </trans-unit>
        <trans-unit id="f87b6459717eafeb949467a7b18ce6ab71215fa0" translate="yes" xml:space="preserve">
          <source>This method takes all types of tasks (not only timeouts) into account, which is unintuitive. It is recommended to use &lt;a href=&quot;%24verifynopendingtasks&quot;&gt;&lt;code&gt;$verifyNoPendingTasks&lt;/code&gt;&lt;/a&gt; instead, which additionally allows checking for timeouts only (with &lt;code&gt;$verifyNoPendingTasks('$timeout')&lt;/code&gt;).</source>
          <target state="translated">此方法将所有类型的任务（不仅是超时）都考虑在内，这是不直观的。建议改用&lt;a href=&quot;%24verifynopendingtasks&quot;&gt; &lt;code&gt;$verifyNoPendingTasks&lt;/code&gt; &lt;/a&gt;，它另外只允许检查超时（使用 &lt;code&gt;$verifyNoPendingTasks('$timeout')&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="d2705a3d550a46eddae0f388fab27d18be36a157" translate="yes" xml:space="preserve">
          <source>This method will add each of the injectables to the injector and execute all of the config and run blocks for each module passed to the method.</source>
          <target state="translated">该方法将把每一个注射剂添加到注射器中,并为传递给该方法的每个模块执行所有的配置和运行块。</target>
        </trans-unit>
        <trans-unit id="2a37d1349d00a1da78883f5fe65c38c4d72feb8f" translate="yes" xml:space="preserve">
          <source>This method will also propagate to all the controls contained in this form.</source>
          <target state="translated">这个方法也会传播到这个表单中包含的所有控件。</target>
        </trans-unit>
        <trans-unit id="27ac794b33b9e4188249c87bb5a53b20e784a575" translate="yes" xml:space="preserve">
          <source>This method will close all pending animations (both &lt;a href=&quot;../../nganimate#javascript-based-animations.html&quot;&gt;Javascript&lt;/a&gt; and &lt;a href=&quot;../../nganimate/service/%24animatecss&quot;&gt;CSS&lt;/a&gt;) and it will also flush any remaining animation frames and/or callbacks.</source>
          <target state="translated">此方法将关闭所有待处理的动画（包括&lt;a href=&quot;../../nganimate#javascript-based-animations.html&quot;&gt;Javascript&lt;/a&gt;和&lt;a href=&quot;../../nganimate/service/%24animatecss&quot;&gt;CSS&lt;/a&gt;），还将刷新所有剩余的动画帧和/或回调。</target>
        </trans-unit>
        <trans-unit id="915cfaa2d3ed2fa450c656592c6f02599354a0d6" translate="yes" xml:space="preserve">
          <source>This might also happen because some third-party frameworks place animation duration defaults across many element or className selectors in order to make their code small and reusable.</source>
          <target state="translated">这种情况也可能发生,因为一些第三方框架将动画持续时间默认值放置在许多元素或className选择器中,以使其代码小而可重用。</target>
        </trans-unit>
        <trans-unit id="6ee006904db7800e4b79b052720172e93492d2b3" translate="yes" xml:space="preserve">
          <source>This mock implementation can be used to respond with static or dynamic responses via the &lt;code&gt;expect&lt;/code&gt; and &lt;code&gt;when&lt;/code&gt; apis and their shortcuts (&lt;code&gt;expectGET&lt;/code&gt;, &lt;code&gt;whenPOST&lt;/code&gt;, etc).</source>
          <target state="translated">这种模拟实现可以通过使用与静态或动态响应响应的 &lt;code&gt;expect&lt;/code&gt; 和 &lt;code&gt;when&lt;/code&gt; API和其快捷方式（ &lt;code&gt;expectGET&lt;/code&gt; ， &lt;code&gt;whenPOST&lt;/code&gt; 等）。</target>
        </trans-unit>
        <trans-unit id="fb22f4802e38eb9995c979b6ca1295aabe3cf8e8" translate="yes" xml:space="preserve">
          <source>This mode is implemented by the &lt;a href=&quot;../api/ng/service/%24sce&quot;&gt;&lt;code&gt;$sce&lt;/code&gt;&lt;/a&gt; service and various core directives.</source>
          <target state="translated">此模式由&lt;a href=&quot;../api/ng/service/%24sce&quot;&gt; &lt;code&gt;$sce&lt;/code&gt; &lt;/a&gt;服务和各种核心指令实现。</target>
        </trans-unit>
        <trans-unit id="c233a6582d2d1e6bb77664600a84be278e1f11d2" translate="yes" xml:space="preserve">
          <source>This module allows the usage of any identifier that follows ES6 identifier naming convention to be used as an identifier in an AngularJS expression. ES6 delegates some of the identifier rules definition to Unicode, this module uses ES6 and Unicode 8.0 identifiers convention.</source>
          <target state="translated">该模块允许使用任何遵循ES6标识符命名惯例的标识符作为AngularJS表达式中的标识符。ES6将部分标识符规则的定义委托给Unicode,本模块使用ES6和Unicode 8.0标识符约定。</target>
        </trans-unit>
        <trans-unit id="da9bb8e1f58198b53e9f9b910bc27da80d253883" translate="yes" xml:space="preserve">
          <source>This object has the following properties:</source>
          <target state="translated">该对象具有以下属性:</target>
        </trans-unit>
        <trans-unit id="e7dde314902c57d9644c192713d0db6e938ac456" translate="yes" xml:space="preserve">
          <source>This object is a map where the keys are the name of the slot to fill and the value is an element selector used to match the HTML to the slot. The element selector should be in normalized form (e.g. &lt;code&gt;myElement&lt;/code&gt;) and will match the standard element variants (e.g. &lt;code&gt;my-element&lt;/code&gt;, &lt;code&gt;my:element&lt;/code&gt;, &lt;code&gt;data-my-element&lt;/code&gt;, etc).</source>
          <target state="translated">该对象是一个映射，其中的键是要填充的插槽的名称，而值是用于将HTML与插槽匹配的元素选择器。元素选择器应采用规范化形式（例如 &lt;code&gt;myElement&lt;/code&gt; ），并将与标准元素变体（例如 &lt;code&gt;my-element&lt;/code&gt; ， &lt;code&gt;my:element&lt;/code&gt; ， &lt;code&gt;data-my-element&lt;/code&gt; 等）匹配。</target>
        </trans-unit>
        <trans-unit id="f1709dc043ae963fcb6fd267e6b932727b496895" translate="yes" xml:space="preserve">
          <source>This page explains the AngularJS initialization process and how you can manually initialize AngularJS if necessary.</source>
          <target state="translated">本页解释了AngularJS的初始化过程,以及在必要时如何手动初始化AngularJS。</target>
        </trans-unit>
        <trans-unit id="2b833d5b65cdc313f0a542c48b1308d0e041ebe8" translate="yes" xml:space="preserve">
          <source>This property is used only if the &lt;code&gt;compile&lt;/code&gt; property is not defined.</source>
          <target state="translated">仅当未定义 &lt;code&gt;compile&lt;/code&gt; 属性时，才使用此属性。</target>
        </trans-unit>
        <trans-unit id="883346a7fad915ebeff0e77021b15cf3830eda47" translate="yes" xml:space="preserve">
          <source>This property is used to bind scope properties directly to the controller. It can be either &lt;code&gt;true&lt;/code&gt; or an object hash with the same format as the &lt;code&gt;scope&lt;/code&gt; property.</source>
          <target state="translated">此属性用于将范围属性直接绑定到控制器。它可以是 &lt;code&gt;true&lt;/code&gt; ，也可以是具有与 &lt;code&gt;scope&lt;/code&gt; 属性相同格式的对象哈希。</target>
        </trans-unit>
        <trans-unit id="a357c7aacd82c6ccff19e2526aedf02dcd86f146" translate="yes" xml:space="preserve">
          <source>This provider allows controller registration via the &lt;a href=&quot;%24controllerprovider#register.html&quot;&gt;register&lt;/a&gt; method.</source>
          <target state="translated">该提供程序允许通过&lt;a href=&quot;%24controllerprovider#register.html&quot;&gt;register&lt;/a&gt;方法注册控制器。</target>
        </trans-unit>
        <trans-unit id="0617c66c55cb594ee37dad4d27bb3dac77e7f902" translate="yes" xml:space="preserve">
          <source>This section briefly touches on all of the important parts of AngularJS using a simple example. For a more in-depth explanation, see the &lt;a href=&quot;https://code.angularjs.org/1.7.8/docs/guide/tutorial/&quot;&gt;tutorial&lt;/a&gt;.</source>
          <target state="translated">本节使用一个简单的示例简要介绍AngularJS的所有重要部分。有关更深入的说明，请参见&lt;a href=&quot;https://code.angularjs.org/1.7.8/docs/guide/tutorial/&quot;&gt;教程&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e465c56fdc1919202e61b4c838abdb2efdbe6b09" translate="yes" xml:space="preserve">
          <source>This section is useful to you if you're already familiar with the ICU MessageFormat syntax.</source>
          <target state="translated">如果你已经熟悉ICU MessageFormat语法,本节对你很有用。</target>
        </trans-unit>
        <trans-unit id="629fe3d641b010dc22c32cf60d9c51461dbc815f" translate="yes" xml:space="preserve">
          <source>This section motivates and explains AngularJS's use of DI. For how to use DI, see above.</source>
          <target state="translated">本节激励并解释AngularJS对DI的使用。关于如何使用DI,请参见上文。</target>
        </trans-unit>
        <trans-unit id="4b368495e290571221704fff68dedde03e3d8a9d" translate="yes" xml:space="preserve">
          <source>This service handles the lifecycle of callbacks to handle JSONP requests. Override this service if you wish to customise where the callbacks are stored and how they vary compared to the requested url.</source>
          <target state="translated">该服务处理回调的生命周期,以处理JSONP请求。如果你想自定义回调的存储位置,以及它们与请求的url相比如何变化,那么就覆盖这个服务。</target>
        </trans-unit>
        <trans-unit id="91d45badcd0e43333ab51b6632a69a56a2a8478d" translate="yes" xml:space="preserve">
          <source>This service is just a simple decorator for &lt;a href=&quot;../../ng/service/%24timeout&quot;&gt;$timeout&lt;/a&gt; service that adds a &quot;flush&quot; and &quot;verifyNoPendingTasks&quot; methods.</source>
          <target state="translated">该服务只是&lt;a href=&quot;../../ng/service/%24timeout&quot;&gt;$ timeout&lt;/a&gt;服务的简单装饰器，它添加了&amp;ldquo; flush&amp;rdquo;和&amp;ldquo; verifyNoPendingTasks&amp;rdquo;方法。</target>
        </trans-unit>
        <trans-unit id="11801c68b71dbf7b43ee58c584c0b6ddc76ef833" translate="yes" xml:space="preserve">
          <source>This service is just a simple decorator for &lt;a href=&quot;../ng/service/%24timeout&quot;&gt;$timeout&lt;/a&gt; service that adds a &quot;flush&quot; and &quot;verifyNoPendingTasks&quot; methods.</source>
          <target state="translated">该服务只是&lt;a href=&quot;../ng/service/%24timeout&quot;&gt;$ timeout&lt;/a&gt;服务的简单装饰器，它添加了&amp;ldquo; flush&amp;rdquo;和&amp;ldquo; verifyNoPendingTasks&amp;rdquo;方法。</target>
        </trans-unit>
        <trans-unit id="1f835173917891572ec34a779591da7e750f83cc" translate="yes" xml:space="preserve">
          <source>This service is just a simple decorator for &lt;a href=&quot;ng/service/%24timeout&quot;&gt;$timeout&lt;/a&gt; service that adds a &quot;flush&quot; and &quot;verifyNoPendingTasks&quot; methods.</source>
          <target state="translated">该服务只是&lt;a href=&quot;ng/service/%24timeout&quot;&gt;$ timeout&lt;/a&gt;服务的简单装饰器，它添加了&amp;ldquo; flush&amp;rdquo;和&amp;ldquo; verifyNoPendingTasks&amp;rdquo;方法。</target>
        </trans-unit>
        <trans-unit id="0ea40af4b0cece7853eaf6005c23cbc42ab9d2f2" translate="yes" xml:space="preserve">
          <source>This should not be used to watch for changes in objects that are (or contain) &lt;a href=&quot;https://developer.mozilla.org/docs/Web/API/File&quot;&gt;File&lt;/a&gt; objects due to limitations with &lt;a href=&quot;../function/angular.copy&quot;&gt;&lt;code&gt;angular.copy&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">由于&lt;a href=&quot;../function/angular.copy&quot;&gt; &lt;code&gt;angular.copy&lt;/code&gt; 的&lt;/a&gt;限制，不应将其用于监视&lt;a href=&quot;https://developer.mozilla.org/docs/Web/API/File&quot;&gt;文件&lt;/a&gt;对象（或包含文件对象）中的更改。</target>
        </trans-unit>
        <trans-unit id="8a1af7647b98d0fb330f0d8c1c4942701a28f04d" translate="yes" xml:space="preserve">
          <source>This significantly reduces the overhead. It is far easier to pay the small overhead and have an application that's secure and can be audited to verify that with much more ease than bolting security onto an application later.</source>
          <target state="translated">这大大降低了开销。付出小的开销,拥有一个安全的应用程序,并且可以通过审计来验证,这比以后把安全问题栓在应用程序上要容易得多。</target>
        </trans-unit>
        <trans-unit id="9fef39daed2db411efe5a4c7dfa116cf26686648" translate="yes" xml:space="preserve">
          <source>This simple example shows a formatter that would convert the model value to uppercase:</source>
          <target state="translated">这个简单的例子显示了一个将模型值转换为大写的格式器。</target>
        </trans-unit>
        <trans-unit id="c4a9089b94815bb38543c89a6cef1127501717c7" translate="yes" xml:space="preserve">
          <source>This simple example shows a parser that would convert text input value to lowercase:</source>
          <target state="translated">这个简单的例子展示了一个将文本输入值转换为小写的解析器。</target>
        </trans-unit>
        <trans-unit id="514273f310733c11cdf3627df583ea49721cf88c" translate="yes" xml:space="preserve">
          <source>This site and all of its contents are referring to AngularJS (version 1.x), if you are looking for the latest Angular, please visit &lt;a href=&quot;https://angular.io/&quot;&gt;angular.io&lt;/a&gt;.</source>
          <target state="translated">该站点及其所有内容均引用AngularJS（版本1.x），如果您正在寻找最新的Angular，请访问&lt;a href=&quot;https://angular.io/&quot;&gt;angular.io&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3996593ddc4d041ab4093149112bcf781b10defe" translate="yes" xml:space="preserve">
          <source>This site refers to AngularJS (v1.x). &lt;a href=&quot;https://angular.io/&quot;&gt;Go to the latest Angular&lt;/a&gt;.</source>
          <target state="translated">该站点引用AngularJS（v1.x）。&lt;a href=&quot;https://angular.io/&quot;&gt;转到最新的Angular&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="13256ca7859242e20651198514af51bbfcbee712" translate="yes" xml:space="preserve">
          <source>This syntax extension is provided by way of the &lt;code&gt;ngMessageFormat&lt;/code&gt; module that your application can depend upon (shipped separately as &lt;code&gt;angular-message-format.min.js&lt;/code&gt; and &lt;code&gt;angular-message-format.js&lt;/code&gt;.) A current limitation of the &lt;code&gt;ngMessageFormat&lt;/code&gt; module, is that it does not support redefining the &lt;code&gt;$interpolate&lt;/code&gt; start and end symbols. Only the default &lt;code&gt;{{&lt;/code&gt; and &lt;code&gt;}}&lt;/code&gt; are allowed.</source>
          <target state="translated">此语法扩展是通过您的应用程序可以依赖的 &lt;code&gt;ngMessageFormat&lt;/code&gt; 模块提供的（分别作为 &lt;code&gt;angular-message-format.min.js&lt;/code&gt; 和 &lt;code&gt;angular-message-format.js&lt;/code&gt; 装运。） &lt;code&gt;ngMessageFormat&lt;/code&gt; 模块的当前限制是：它不支持重新定义 &lt;code&gt;$interpolate&lt;/code&gt; 开始和结束符号。仅允许使用默认的 &lt;code&gt;{{&lt;/code&gt; 和 &lt;code&gt;}}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fa80acf811fb7d3bc5d4d2945ffc786c2f86cb56" translate="yes" xml:space="preserve">
          <source>This syntax extension, while based on MessageFormat, has been designed to be backwards compatible with existing AngularJS interpolation expressions. The key rule is simply this: &lt;strong&gt;All interpolations are done inside double curlies.&lt;/strong&gt; The top level comma operator after an expression inside the double curlies causes MessageFormat extensions to be recognized. Such a top level comma is otherwise illegal in an AngularJS expression and is used by MessageFormat to specify the function (such as plural/select) and it's related syntax.</source>
          <target state="translated">该语法扩展虽然基于MessageFormat，但被设计为与现有AngularJS插值表达式向后兼容。关键规则很简单：&lt;strong&gt;所有插值均在双毛轮内完成。&lt;/strong&gt;在双curl内的表达式后的顶级逗号运算符使MessageFormat扩展被识别。否则，此类顶级逗号在AngularJS表达式中是非法的，并由MessageFormat用于指定函数（例如，复数/选择）及其相关语法。</target>
        </trans-unit>
        <trans-unit id="e599113b0edd4e670329932acb818d5adc536965" translate="yes" xml:space="preserve">
          <source>This technique is often used in unit tests to mock out a service's dependencies.</source>
          <target state="translated">在单元测试中经常使用这种技术来模拟服务的依赖关系。</target>
        </trans-unit>
        <trans-unit id="addac971dd419fb36735ec5e40bf3e153ccc3c01" translate="yes" xml:space="preserve">
          <source>This test describes the requirements of a ToDo list, specifically, that it should be able to filter the list of items.</source>
          <target state="translated">这个测试描述了对ToDo列表的要求,具体来说,就是它应该能够过滤列表中的项目。</target>
        </trans-unit>
        <trans-unit id="00229fe7fc0568eb82dd05f9f9c12e34d0b73a38" translate="yes" xml:space="preserve">
          <source>This type extends the &lt;a href=&quot;ngcomponentrouter/type/router&quot;&gt;&lt;code&gt;Router&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">此类型扩展了&lt;a href=&quot;ngcomponentrouter/type/router&quot;&gt; &lt;code&gt;Router&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9a55be7ee54799e91a1baaf9ec346a8b069e7054" translate="yes" xml:space="preserve">
          <source>This type extends the &lt;a href=&quot;router&quot;&gt;&lt;code&gt;Router&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">此类型扩展了&lt;a href=&quot;router&quot;&gt; &lt;code&gt;Router&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3c90b3267c6b0702ff318db2cb8b8a8a313f9b31" translate="yes" xml:space="preserve">
          <source>This type extends the &lt;a href=&quot;type/router&quot;&gt;&lt;code&gt;Router&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">此类型扩展了&lt;a href=&quot;type/router&quot;&gt; &lt;code&gt;Router&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="194bdef428dc42d35d6d30db6c9d019109b9627e" translate="yes" xml:space="preserve">
          <source>This usually happens when the &lt;a href=&quot;../../nganimate&quot;&gt;ngAnimate module&lt;/a&gt; is included, but no actual animations are defined for &lt;a href=&quot;ngshow&quot;&gt;&lt;code&gt;ngShow&lt;/code&gt;&lt;/a&gt; / &lt;a href=&quot;nghide&quot;&gt;&lt;code&gt;ngHide&lt;/code&gt;&lt;/a&gt;. Internet Explorer is affected more often than other browsers.</source>
          <target state="translated">通常在包含&lt;a href=&quot;../../nganimate&quot;&gt;ngAnimate模块&lt;/a&gt;时发生这种情况，但是没有为&lt;a href=&quot;ngshow&quot;&gt; &lt;code&gt;ngShow&lt;/code&gt; &lt;/a&gt; / &lt;a href=&quot;nghide&quot;&gt; &lt;code&gt;ngHide&lt;/code&gt; &lt;/a&gt;定义实际的动画。与其他浏览器相比，Internet Explorer受到的影响更大。</target>
        </trans-unit>
        <trans-unit id="89941c3846f435420c0a0b5a2605676a55d335a2" translate="yes" xml:space="preserve">
          <source>This will ensure that all services in your application are properly annotated. See the &lt;a href=&quot;di#using-strict-dependency-injection.html&quot;&gt;dependency injection strict mode&lt;/a&gt; docs for more.</source>
          <target state="translated">这将确保正确注释应用程序中的所有服务。有关更多信息，请参见&lt;a href=&quot;di#using-strict-dependency-injection.html&quot;&gt;依赖项注入严格模式&lt;/a&gt;文档。</target>
        </trans-unit>
        <trans-unit id="f281cdd5d821befaa87c95331b8e4df644d3d012" translate="yes" xml:space="preserve">
          <source>This will not render properly, unless we do some scope magic.</source>
          <target state="translated">这将无法正常渲染,除非我们做一些范围魔法。</target>
        </trans-unit>
        <trans-unit id="7b981c7b156731dee59fa70a3a4d07e3181b03de" translate="yes" xml:space="preserve">
          <source>This will work:</source>
          <target state="translated">这将是工作。</target>
        </trans-unit>
        <trans-unit id="aa02d37789c0eb90c790d94a8e42c3470d3ddc29" translate="yes" xml:space="preserve">
          <source>Those that stray from AngularJS standards (such as modifying AngularJS's core) may have difficulty updating, so keeping to AngularJS standards is not just a functionality issue, it's also critical in order to facilitate rapid security updates.</source>
          <target state="translated">那些游离于AngularJS标准之外的标准(比如修改AngularJS的核心)可能会给更新带来困难,所以保持AngularJS标准不仅仅是一个功能问题,为了方便快速的安全更新也是至关重要的。</target>
        </trans-unit>
        <trans-unit id="18ff4d25dda80968c984aa603ada71e7f8445542" translate="yes" xml:space="preserve">
          <source>Though we have a core group of core contributors at Google, AngularJS is an open source project with hundreds of contributors. We'd love you to be one of them. When you're ready, please read the &lt;a href=&quot;https://code.angularjs.org/1.7.8/docs/misc/contribute&quot;&gt;Guide for contributing to AngularJS&lt;/a&gt;.</source>
          <target state="translated">尽管我们在Google拥有核心的核心贡献者小组，但是AngularJS是一个开放源代码项目，拥有数百个贡献者。我们希望您成为其中一员。准备就绪后，请阅读&lt;a href=&quot;https://code.angularjs.org/1.7.8/docs/misc/contribute&quot;&gt;AngularJS贡献指南&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d2c02671e16ad1b484fd37216c00f1f05c7c934d" translate="yes" xml:space="preserve">
          <source>Timestamp representing the desired time in &lt;em&gt;UTC&lt;/em&gt;</source>
          <target state="translated">时间戳记，以&lt;em&gt;UTC&lt;/em&gt;表示所需时间&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="bf36ae8fcb1d23b61ad6567c0e9d250610eb4692" translate="yes" xml:space="preserve">
          <source>Timezone to be used for formatting. It understands UTC/GMT and the continental US time zone abbreviations, but for general use, use a time zone offset, for example, &lt;code&gt;'+0430'&lt;/code&gt; (4 hours, 30 minutes east of the Greenwich meridian) If not specified, the timezone of the browser will be used.</source>
          <target state="translated">用于格式化的时区。它了解UTC / GMT和美国大陆时区的缩写，但对于一般用途，请使用时区偏移量，例如 &lt;code&gt;'+0430'&lt;/code&gt; （格林威治子午线以东4小时30分钟）。如果未指定，则为使用浏览器。</target>
        </trans-unit>
        <trans-unit id="791214dda21a45673e6a00a407416e403372c00e" translate="yes" xml:space="preserve">
          <source>Timezones</source>
          <target state="translated">Timezones</target>
        </trans-unit>
        <trans-unit id="a6f821f5dc3ea799d7cb08f9d99e08572d83b3a9" translate="yes" xml:space="preserve">
          <source>To actually start the animation we need to run &lt;code&gt;animation.start()&lt;/code&gt; which will then return a promise that we can hook into to detect when the animation ends. If we choose not to run the animation then we MUST run &lt;code&gt;animation.end()&lt;/code&gt; to perform a cleanup on the element (since some CSS classes and styles may have been applied to the element during the preparation phase). Note that all other properties such as duration, delay, transitions and keyframes are just properties and that changing them will not reconfigure the parameters of the animation.</source>
          <target state="translated">要真正开始动画，我们需要运行 &lt;code&gt;animation.start()&lt;/code&gt; ，然后将返回一个promise，我们可以将其挂钩以检测动画何时结束。如果选择不运行动画，则必须运行 &lt;code&gt;animation.end()&lt;/code&gt; 对元素进行清理（因为在准备阶段可能已将某些CSS类和样式应用于该元素）。请注意，所有其他属性（例如持续时间，延迟，过渡和关键帧）仅是属性，并且更改它们不会重新配置动画的参数。</target>
        </trans-unit>
        <trans-unit id="e9fc69ae1586e6188ab11de16fef9caf3e9a3443" translate="yes" xml:space="preserve">
          <source>To add or overwrite these defaults, simply add or remove a property from these configuration objects. To add headers for an HTTP method other than POST or PUT, simply add a new object with the lowercased HTTP method name as the key, e.g. &lt;code&gt;$httpProvider.defaults.headers.get = { 'My-Header' : 'value' }&lt;/code&gt;.</source>
          <target state="translated">要添加或覆盖这些默认值，只需在这些配置对象中添加或删除属性。要为POST或PUT以外的HTTP方法添加标头，只需添加一个新对象，并以小写的HTTP方法名称作为键，例如 &lt;code&gt;$httpProvider.defaults.headers.get = { 'My-Header' : 'value' }&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="440d40ccd05fbc44211e69b24f08900b7177a1db" translate="yes" xml:space="preserve">
          <source>To allow styling of form as well as controls, &lt;code&gt;ngModel&lt;/code&gt; adds these CSS classes:</source>
          <target state="translated">为了允许样式以及控件的样式， &lt;code&gt;ngModel&lt;/code&gt; 添加了以下CSS类：</target>
        </trans-unit>
        <trans-unit id="978b24255f9e2043c3815ab1e3ee6525a4048630" translate="yes" xml:space="preserve">
          <source>To allow the minifiers to rename the function parameters and still be able to inject the right services, the function needs to be annotated with the &lt;code&gt;$inject&lt;/code&gt; property. The &lt;code&gt;$inject&lt;/code&gt; property is an array of service names to inject.</source>
          <target state="translated">为了允许Minifier重命名函数参数并仍然能够注入正确的服务，需要使用 &lt;code&gt;$inject&lt;/code&gt; 属性对函数进行注释。该 &lt;code&gt;$inject&lt;/code&gt; 属性是服务名称的数组注入。</target>
        </trans-unit>
        <trans-unit id="227bb446f977c7e7c29690779a58e5dcd3f7bc4a" translate="yes" xml:space="preserve">
          <source>To be secure by default, AngularJS makes sure bindings go through that sanitization, or any similar validation process, unless there's a good reason to trust the given value in this context. That trust is formalized with a function call. This means that as a developer, you can assume all untrusted bindings are safe. Then, to audit your code for binding security issues, you just need to ensure the values you mark as trusted indeed are safe - because they were received from your server, sanitized by your library, etc. You can organize your codebase to help with this - perhaps allowing only the files in a specific directory to do this. Ensuring that the internal API exposed by that code doesn't markup arbitrary values as safe then becomes a more manageable task.</source>
          <target state="translated">为了保证默认情况下的安全,AngularJS会确保绑定经过该消毒,或任何类似的验证过程,除非有一个很好的理由来信任这个上下文中的给定值。这种信任是通过一个函数调用来正式确定的。这意味着,作为开发人员,你可以假设所有不信任的绑定都是安全的。然后,要审计你的代码是否存在绑定安全问题,你只需要确保你标记为信任的值确实是安全的--因为它们是从你的服务器接收的,经过你的库的消毒等等。你可以组织你的代码库来帮助解决这个问题--也许只允许特定目录下的文件来做这件事。确保该代码所暴露的内部API不会将任意值标记为安全值,那么就变成了一个更容易管理的任务。</target>
        </trans-unit>
        <trans-unit id="a3936bf1237487c27fb7d5526e836b9e6d510539" translate="yes" xml:space="preserve">
          <source>To bind the model to a non-string value, you can use one of the following strategies:</source>
          <target state="translated">要将模型绑定到一个非字符串值,您可以使用以下策略之一。</target>
        </trans-unit>
        <trans-unit id="23a4965aa6aa6aa1e840b66494467e36b1d73b3a" translate="yes" xml:space="preserve">
          <source>To cancel a timeout request, call &lt;code&gt;$timeout.cancel(promise)&lt;/code&gt;.</source>
          <target state="translated">要取消超时请求，请调用 &lt;code&gt;$timeout.cancel(promise)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="56d3d8bb492af54889dcc66038949954edcd5e47" translate="yes" xml:space="preserve">
          <source>To configure the &lt;code&gt;$location&lt;/code&gt; service, retrieve the &lt;a href=&quot;../api/ng/provider/%24locationprovider&quot;&gt;$locationProvider&lt;/a&gt; and set the parameters as follows:</source>
          <target state="translated">要配置 &lt;code&gt;$location&lt;/code&gt; 服务，请检索&lt;a href=&quot;../api/ng/provider/%24locationprovider&quot;&gt;$ locationProvider&lt;/a&gt;并按如下所示设置参数：</target>
        </trans-unit>
        <trans-unit id="14e661d075a8d1d3220a38ac7fd86eacc04d62de" translate="yes" xml:space="preserve">
          <source>To cope with this you simply ensure that your 'element' transclude directive is wrapped in an element, such as a &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">为了解决这个问题，您只需确保将'element'transclude指令包装在一个元素中，例如 &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="31fe0e47804d71db9cfd7fffc117d4ab85d47fab" translate="yes" xml:space="preserve">
          <source>To disable comment and css class directives use the &lt;code&gt;$compileProvider&lt;/code&gt;:</source>
          <target state="translated">要禁用注释和CSS类指令，请使用 &lt;code&gt;$compileProvider&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="5387d2c27cc9dee45bb8cdc85e369fc9f5f17777" translate="yes" xml:space="preserve">
          <source>To disable the mouse click and drag functionality, add &lt;code&gt;ng-swipe-disable-mouse&lt;/code&gt; to the &lt;code&gt;ng-swipe-left&lt;/code&gt; or &lt;code&gt;ng-swipe-right&lt;/code&gt; DOM Element.</source>
          <target state="translated">要禁用鼠标单击和拖动功能，请将 &lt;code&gt;ng-swipe-disable-mouse&lt;/code&gt; 添加到 &lt;code&gt;ng-swipe-left&lt;/code&gt; 或 &lt;code&gt;ng-swipe-right&lt;/code&gt; DOM元素中。</target>
        </trans-unit>
        <trans-unit id="5bc2cad6e2a562908f313cb486e4136ebcb8eee1" translate="yes" xml:space="preserve">
          <source>To do this, we need to use the &lt;code&gt;transclude&lt;/code&gt; option.</source>
          <target state="translated">为此，我们需要使用 &lt;code&gt;transclude&lt;/code&gt; 选项。</target>
        </trans-unit>
        <trans-unit id="035a6a87408acdde8a23ee0cf037d6f472188af6" translate="yes" xml:space="preserve">
          <source>To ease the transition between native inputs and custom controls, ngAria now supports &lt;a href=&quot;../api/ng/directive/ngvalue&quot;&gt;ngValue&lt;/a&gt; and &lt;a href=&quot;../api/ng/directive/ngchecked&quot;&gt;ngChecked&lt;/a&gt;. The original directives were created for native inputs only, so ngAria extends support to custom elements by managing &lt;code&gt;aria-checked&lt;/code&gt; for accessibility.</source>
          <target state="translated">为了简化本机输入和自定义控件之间的转换，ngAria现在支持&lt;a href=&quot;../api/ng/directive/ngvalue&quot;&gt;ngValue&lt;/a&gt;和&lt;a href=&quot;../api/ng/directive/ngchecked&quot;&gt;ngChecked&lt;/a&gt;。原始指令仅用于本机输入，因此ngAria通过管理 &lt;code&gt;aria-checked&lt;/code&gt; 的可访问性，将支持扩展到自定义元素。</target>
        </trans-unit>
        <trans-unit id="5d168eb9b869dbfb344d7855a584554963333f9c" translate="yes" xml:space="preserve">
          <source>To enable strict di mode, you have two options:</source>
          <target state="translated">要启用严格di模式,你有两个选择。</target>
        </trans-unit>
        <trans-unit id="4fb64437b796f4ba9a62ece5fde0e8c967dba837" translate="yes" xml:space="preserve">
          <source>To examine the scope in the debugger:</source>
          <target state="translated">在调试器中检查作用域。</target>
        </trans-unit>
        <trans-unit id="b590774031a2cf4725192dcbb7db9c57480cef1d" translate="yes" xml:space="preserve">
          <source>To explicitly remove a header automatically added via $httpProvider.defaults.headers on a per request basis, Use the &lt;code&gt;headers&lt;/code&gt; property, setting the desired header to &lt;code&gt;undefined&lt;/code&gt;. For example:</source>
          <target state="translated">要显式删除通过$ httpProvider.defaults.headers在每个请求基础上自动添加的 &lt;code&gt;headers&lt;/code&gt; ，请使用headers属性，将所需的标头设置为 &lt;code&gt;undefined&lt;/code&gt; 。例如：</target>
        </trans-unit>
        <trans-unit id="c80d1fb8ce1e4bf1cd40c9acaf0eb4fe7ea79e3f" translate="yes" xml:space="preserve">
          <source>To help with this, the injected parameters can, optionally, be enclosed with underscores. These are ignored by the injector when the reference name is resolved.</source>
          <target state="translated">为了帮助解决这个问题,注入的参数可以选择性地用下划线括起来。当引用名被解析时,这些参数会被注入者忽略。</target>
        </trans-unit>
        <trans-unit id="220d6276002b8cffd3f24e9bec07ba42bc0c1add" translate="yes" xml:space="preserve">
          <source>To illustrate further how Controller components work in AngularJS, let's create a little app with the following components:</source>
          <target state="translated">为了进一步说明Controller组件在AngularJS中是如何工作的,让我们用以下组件创建一个小程序。</target>
        </trans-unit>
        <trans-unit id="4f97b5d532edfe4940fd9b38ad40a3cd6585eed2" translate="yes" xml:space="preserve">
          <source>To illustrate this, consider the &lt;code&gt;ng-bind-html&lt;/code&gt; directive. It renders its value directly as HTML: we call that the &lt;em&gt;context&lt;/em&gt;. When given an untrusted input, AngularJS will attempt to sanitize it before rendering if a sanitizer is available, and throw otherwise. To bypass sanitization and render the input as-is, you will need to mark it as trusted for that context before attempting to bind it.</source>
          <target state="translated">为了说明这一点，请考虑 &lt;code&gt;ng-bind-html&lt;/code&gt; 指令。它直接将其值呈现为HTML：我们称其为&lt;em&gt;context&lt;/em&gt;。如果提供了不受信任的输入，AngularJS将尝试在呈现之前（如果有可用的清理程序）清理它，否则抛出该异常。要绕过清理并按原样呈现输入，您需要在尝试绑定它之前将其标记为对该上下文可信。</target>
        </trans-unit>
        <trans-unit id="902ec43adccfdb69ffa83ad123da01d2e0b94c0b" translate="yes" xml:space="preserve">
          <source>To illustrate this, see the example below. Notice that we've added a &lt;code&gt;link&lt;/code&gt; function in &lt;code&gt;script.js&lt;/code&gt; that redefines &lt;code&gt;name&lt;/code&gt; as &lt;code&gt;Jeff&lt;/code&gt;. What do you think the &lt;code&gt;{{name}}&lt;/code&gt; binding will resolve to now?</source>
          <target state="translated">为了说明这一点，请参见下面的示例。请注意，我们在 &lt;code&gt;script.js&lt;/code&gt; 中添加了一个 &lt;code&gt;link&lt;/code&gt; 函数，该函数将 &lt;code&gt;name&lt;/code&gt; 重定义为 &lt;code&gt;Jeff&lt;/code&gt; 。您认为 &lt;code&gt;{{name}}&lt;/code&gt; 绑定将解决什么？</target>
        </trans-unit>
        <trans-unit id="e178b4a4fddd5e3eedf206140142188444cdeb8c" translate="yes" xml:space="preserve">
          <source>To learn more about enabling animation support, click here to visit the &lt;a href=&quot;../../nganimate&quot;&gt;ngAnimate module page&lt;/a&gt;.</source>
          <target state="translated">要了解有关启用动画支持的更多信息，请单击此处访问&lt;a href=&quot;../../nganimate&quot;&gt;ngAnimate模块页面&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="adee17c33df52d3638d95bce546f5bc1b50438c9" translate="yes" xml:space="preserve">
          <source>To learn more about what's possible be sure to visit the &lt;a href=&quot;nganimate/service/%24animatecss&quot;&gt;$animateCss service&lt;/a&gt;.</source>
          <target state="translated">要了解更多信息，请务必访问&lt;a href=&quot;nganimate/service/%24animatecss&quot;&gt;$ animateCss服务&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="97a771699a9dc113a310959b23249232d9279e3f" translate="yes" xml:space="preserve">
          <source>To manage the responsibility of dependency creation, each AngularJS application has an &lt;a href=&quot;../api/ng/function/angular.injector&quot;&gt;injector&lt;/a&gt;. The injector is a &lt;a href=&quot;http://en.wikipedia.org/wiki/Service_locator_pattern&quot;&gt;service locator&lt;/a&gt; that is responsible for construction and lookup of dependencies.</source>
          <target state="translated">为了管理依赖关系创建的责任，每个AngularJS应用程序都有一个&lt;a href=&quot;../api/ng/function/angular.injector&quot;&gt;注射器&lt;/a&gt;。注入程序是一个&lt;a href=&quot;http://en.wikipedia.org/wiki/Service_locator_pattern&quot;&gt;服务定位器&lt;/a&gt;，负责构造和查找依赖项。</target>
        </trans-unit>
        <trans-unit id="87b7d6ced2affdb289caee17d8f374aa66ff02f9" translate="yes" xml:space="preserve">
          <source>To minimize creation of DOM elements, &lt;code&gt;ngRepeat&lt;/code&gt; uses a function to &quot;keep track&quot; of all items in the collection and their corresponding DOM elements. For example, if an item is added to the collection, &lt;code&gt;ngRepeat&lt;/code&gt; will know that all other items already have DOM elements, and will not re-render them.</source>
          <target state="translated">为了最大程度地减少DOM元素的创建， &lt;code&gt;ngRepeat&lt;/code&gt; 使用一个函数来&amp;ldquo;跟踪&amp;rdquo;集合中的所有项目及其对应的DOM元素。例如，如果将一个项目添加到集合中，则 &lt;code&gt;ngRepeat&lt;/code&gt; 将知道所有其他项目已经具有DOM元素，并且不会重新呈现它们。</target>
        </trans-unit>
        <trans-unit id="dec799d727684b5ec439ffba56606b33413cfdb2" translate="yes" xml:space="preserve">
          <source>To prevent double execution of the handler, use only one of the &lt;a href=&quot;ngsubmit&quot;&gt;ngSubmit&lt;/a&gt; or &lt;a href=&quot;ngclick&quot;&gt;ngClick&lt;/a&gt; directives. This is because of the following form submission rules in the HTML specification:</source>
          <target state="translated">为防止重复执行该处理程序，请仅使用&lt;a href=&quot;ngsubmit&quot;&gt;ngSubmit&lt;/a&gt;或&lt;a href=&quot;ngclick&quot;&gt;ngClick&lt;/a&gt;指令之一。这是由于HTML规范中的以下表单提交规则：</target>
        </trans-unit>
        <trans-unit id="7f0c03c455bcc97cd1a6acf7ad3e2c93c1a12ed0" translate="yes" xml:space="preserve">
          <source>To prevent this, you can apply styles to the &lt;code&gt;ng-[event]-prepare&lt;/code&gt; class, which is added as soon as an animation is initialized, but removed before the actual animation starts (after waiting for a &lt;code&gt;$digest&lt;/code&gt;). This class is only added for &lt;em&gt;structural&lt;/em&gt; animations (&lt;code&gt;enter&lt;/code&gt;, &lt;code&gt;move&lt;/code&gt;, and &lt;code&gt;leave&lt;/code&gt;).</source>
          <target state="translated">为防止这种情况，您可以将样式应用于 &lt;code&gt;ng-[event]-prepare&lt;/code&gt; 类，该类在初始化动画后立即添加，但在实际动画开始之前已删除（在等待 &lt;code&gt;$digest&lt;/code&gt; ）。此类仅用于&lt;em&gt;结构&lt;/em&gt;动画（ &lt;code&gt;enter&lt;/code&gt; ， &lt;code&gt;move&lt;/code&gt; 和 &lt;code&gt;leave&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="fea899b0c5f1ec32df106a9c01c18f45fc405eb5" translate="yes" xml:space="preserve">
          <source>To protect against these, explicitly setup &lt;code&gt;overflow: hidden&lt;/code&gt; css rule for all potential svg tags within the sanitized content:</source>
          <target state="translated">为了防止这些情况，请明确设置 &lt;code&gt;overflow: hidden&lt;/code&gt; 清理内容中所有潜在svg标签的隐藏 CSS规则：</target>
        </trans-unit>
        <trans-unit id="943f7d13999a1f50a97c045b022c8dd2e2f3dcbb" translate="yes" xml:space="preserve">
          <source>To repeat a series of elements instead of just one parent element, ngRepeat (as well as other ng directives) supports extending the range of the repeater by defining explicit start and end points by using &lt;strong&gt;ng-repeat-start&lt;/strong&gt; and &lt;strong&gt;ng-repeat-end&lt;/strong&gt; respectively. The &lt;strong&gt;ng-repeat-start&lt;/strong&gt; directive works the same as &lt;strong&gt;ng-repeat&lt;/strong&gt;, but will repeat all the HTML code (including the tag it's defined on) up to and including the ending HTML tag where &lt;strong&gt;ng-repeat-end&lt;/strong&gt; is placed.</source>
          <target state="translated">重复一系列元素而不是仅仅一个父元素，ngRepeat的（以及其他纳克指令）通过使用定义明确的开始和结束点延伸的中继器的范围的载体&lt;strong&gt;纳克重复启动&lt;/strong&gt;和&lt;strong&gt;NG-重复端&lt;/strong&gt;分别。在&lt;strong&gt;NG-重复启动&lt;/strong&gt;指令的工作方式相同&lt;strong&gt;NG-重复&lt;/strong&gt;，但会重复所有的HTML代码（包括它的定义标签）截至及包括结束HTML标签，其中&lt;strong&gt;NG-重复结束&lt;/strong&gt;放置。</target>
        </trans-unit>
        <trans-unit id="f668b9db355d141127ee33b275331ca28c9dfb88" translate="yes" xml:space="preserve">
          <source>To retrieve the associated scope in console execute: &lt;code&gt;angular.element($0).scope()&lt;/code&gt;</source>
          <target state="translated">要在控制台中检索关联的范围，请执行： &lt;code&gt;angular.element($0).scope()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="de4573d3b8e714d7e13c12a8ebcb5312e186616d" translate="yes" xml:space="preserve">
          <source>To retrieve the template later, simply use it in your component:</source>
          <target state="translated">要在以后检索模板,只需在你的组件中使用它。</target>
        </trans-unit>
        <trans-unit id="6b58c4c9070bb055028259d5cf6d5b517e4abcc6" translate="yes" xml:space="preserve">
          <source>To reveal the location of the calls to &lt;code&gt;$log&lt;/code&gt; in the JavaScript console, you can &quot;blackbox&quot; the AngularJS source in your browser:</source>
          <target state="translated">要显示在JavaScript控制台中调用 &lt;code&gt;$log&lt;/code&gt; 的位置，您可以在浏览器中&amp;ldquo;黑盒&amp;rdquo; AngularJS源：</target>
        </trans-unit>
        <trans-unit id="2541170fa16acdab2fc366c6c63c6f8ff8ecc82c" translate="yes" xml:space="preserve">
          <source>To see a complete demo, see the &lt;a href=&quot;https://code.angularjs.org/1.7.8/docs/guide/tutorial/step_14&quot;&gt;animation step in the phonecat tutorial&lt;/a&gt;.</source>
          <target state="translated">要查看完整的演示，请参阅&lt;a href=&quot;https://code.angularjs.org/1.7.8/docs/guide/tutorial/step_14&quot;&gt;phonecat教程中&lt;/a&gt;的动画步骤。</target>
        </trans-unit>
        <trans-unit id="b8d8130d29419030e1a83b2c86e3ff758ba4c5db" translate="yes" xml:space="preserve">
          <source>To see the functional implementation check out &lt;code&gt;src/ngAnimate/animate.js&lt;/code&gt;.</source>
          <target state="translated">要查看功能实现，请查看 &lt;code&gt;src/ngAnimate/animate.js&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="48944de5e140f1f4917a4abe8d0e9716456f969d" translate="yes" xml:space="preserve">
          <source>To setup the application to run with this http backend, you have to create a module that depends on the &lt;code&gt;ngMockE2E&lt;/code&gt; and your application modules and defines the fake backend:</source>
          <target state="translated">要将应用程序设置为与此http后端一起运行，您必须创建一个模块，该模块依赖于 &lt;code&gt;ngMockE2E&lt;/code&gt; 和您的应用程序模块并定义伪造的后端：</target>
        </trans-unit>
        <trans-unit id="22caed9641a69d6681b70e0e73387ff932f2cc11" translate="yes" xml:space="preserve">
          <source>To solve the issue of lack of isolation, the directive declares a new &lt;code&gt;isolated&lt;/code&gt; scope. An isolated scope does not prototypically inherit from the parent scope, and therefore we don't have to worry about accidentally clobbering any properties.</source>
          <target state="translated">为了解决缺少隔离的问题，该指令声明了一个新的 &lt;code&gt;isolated&lt;/code&gt; 范围。隔离的作用域通常不会从父作用域继承，因此我们不必担心会意外破坏任何属性。</target>
        </trans-unit>
        <trans-unit id="3a25c283d366fb9b4b8a14a99d214847f2dc0c90" translate="yes" xml:space="preserve">
          <source>To systematically block XSS security bugs, AngularJS treats all values as untrusted by default in HTML or sensitive URL bindings. When binding untrusted values, AngularJS will automatically run security checks on them (sanitizations, whitelists, depending on context), or throw when it cannot guarantee the security of the result. That behavior depends strongly on contexts: HTML can be sanitized, but template URLs cannot, for instance.</source>
          <target state="translated">为了系统性地阻断XSS安全漏洞,AngularJS在HTML或敏感的URL绑定中,默认将所有的值都视为不可信任。当绑定不受信任的值时,AngularJS会自动对其进行安全检查(根据上下文进行消毒、白名单),或者在无法保证结果安全时进行抛出。这种行为在很大程度上取决于上下文。例如,HTML可以被消毒,但模板URL不能。</target>
        </trans-unit>
        <trans-unit id="06ebef4f171a37657a117bc224081111b0d7f222" translate="yes" xml:space="preserve">
          <source>To take advantage of this, your server needs to set a token in a JavaScript readable session cookie called &lt;code&gt;XSRF-TOKEN&lt;/code&gt; on the first HTTP GET request. On subsequent XHR requests the server can verify that the cookie matches the &lt;code&gt;X-XSRF-TOKEN&lt;/code&gt; HTTP header, and therefore be sure that only JavaScript running on your domain could have sent the request. The token must be unique for each user and must be verifiable by the server (to prevent the JavaScript from making up its own tokens). We recommend that the token is a digest of your site's authentication cookie with a &lt;a href=&quot;https://en.wikipedia.org/wiki/Salt_(cryptography)&quot;&gt;salt&lt;/a&gt; for added security.</source>
          <target state="translated">为了利用这一点，您的服务器需要在第一个HTTP GET请求的名为 &lt;code&gt;XSRF-TOKEN&lt;/code&gt; 的JavaScript可读会话cookie中设置令牌。在随后的XHR请求上，服务器可以验证cookie是否与 &lt;code&gt;X-XSRF-TOKEN&lt;/code&gt; HTTP标头匹配，因此，请确保只有在您的域上运行的JavaScript才可以发送请求。令牌对于每个用户必须是唯一的，并且必须可由服务器验证（以防止JavaScript构成自己的令牌）。我们建议令牌是您网站的身份验证Cookie的摘要，并添加&lt;a href=&quot;https://en.wikipedia.org/wiki/Salt_(cryptography)&quot;&gt;盐&lt;/a&gt;以增强安全性。</target>
        </trans-unit>
        <trans-unit id="a0203afddf9d65db821d61605534ec6d67099780" translate="yes" xml:space="preserve">
          <source>To turn the tinfoil shielding on in our app, we need to create a config function via the module API and have the UnicornLauncherProvider injected into it:</source>
          <target state="translated">为了在我们的应用中开启锡纸屏蔽,我们需要通过模块API创建一个config函数,并让UnicornLauncherProvider注入其中。</target>
        </trans-unit>
        <trans-unit id="553205f92ef2e18fbc6290adc32954aaf6a56cd0" translate="yes" xml:space="preserve">
          <source>To understand the extension, take a look at the ICU MessageFormat syntax as specified by the ICU documentation. Anywhere in that MessageFormat that you have regular message text and you want to substitute an expression, just put it in double curlies instead of single curlies that MessageFormat dictates. This has a huge advantage. &lt;strong&gt;You are no longer limited to simple identifiers for substitutions&lt;/strong&gt;. Because you are using double curlies, you can stick in any arbitrary interpolation syntax there, including nesting more MessageFormat expressions!</source>
          <target state="translated">要了解扩展名，请查看ICU文档指定的ICU MessageFormat语法。在该MessageFormat中您具有常规消息文本并且想要替换表达式的任何位置，只需将其放入Double curl中，而不是MessageFormat规定的单个curl中即可。这具有巨大的优势。&lt;strong&gt;您不再局限于替换的简单标识符&lt;/strong&gt;。因为您使用的是双curly，所以您可以在其中使用任意插值语法，包括嵌套更多MessageFormat表达式！</target>
        </trans-unit>
        <trans-unit id="668388e5a3f0bc129762bfbfd5aa23b7c1098592" translate="yes" xml:space="preserve">
          <source>To understand, let's look at a real-world example with &lt;code&gt;ngRepeat&lt;/code&gt;:</source>
          <target state="translated">为了理解，让我们来看一个使用 &lt;code&gt;ngRepeat&lt;/code&gt; 的真实示例：</target>
        </trans-unit>
        <trans-unit id="3d7ed49b07662b8833b62e5f33bb9164b025e055" translate="yes" xml:space="preserve">
          <source>To use &lt;code&gt;jQuery&lt;/code&gt;, simply ensure it is loaded before the &lt;code&gt;angular.js&lt;/code&gt; file. You can also use the &lt;a href=&quot;../directive/ngjq&quot;&gt;&lt;code&gt;ngJq&lt;/code&gt;&lt;/a&gt; directive to specify that jqlite should be used over jQuery, or to use a specific version of jQuery if multiple versions exist on the page.</source>
          <target state="translated">要使用 &lt;code&gt;jQuery&lt;/code&gt; ，只需确保已在 &lt;code&gt;angular.js&lt;/code&gt; 文件之前加载了它。您还可以使用&lt;a href=&quot;../directive/ngjq&quot;&gt; &lt;code&gt;ngJq&lt;/code&gt; &lt;/a&gt;指令来指定应在jQuery上使用jqlite，或者如果页面上存在多个版本，则使用特定版本的jQuery。</target>
        </trans-unit>
        <trans-unit id="0b532a90142adf829020e98b53c46a1fe9b0e63b" translate="yes" xml:space="preserve">
          <source>To use DI, there needs to be a place where all the things that should work together are registered. In AngularJS, this is the purpose of the &lt;a href=&quot;module&quot;&gt;modules&lt;/a&gt;. When AngularJS starts, it will use the configuration of the module with the name defined by the &lt;code&gt;ng-app&lt;/code&gt; directive, including the configuration of all modules that this module depends on.</source>
          <target state="translated">要使用DI，必须在所有应该一起工作的地方进行注册。在AngularJS中，这就是&lt;a href=&quot;module&quot;&gt;模块&lt;/a&gt;的目的。AngularJS启动时，它将使用 &lt;code&gt;ng-app&lt;/code&gt; 指令定义的名称使用模块的配置，包括该模块所依赖的所有模块的配置。</target>
        </trans-unit>
        <trans-unit id="61b10e4c62d5b605a789c76144449e0198436d85" translate="yes" xml:space="preserve">
          <source>To use an AngularJS service, you add it as a dependency for the component (controller, service, filter or directive) that depends on the service. AngularJS's &lt;a href=&quot;di&quot;&gt;dependency injection&lt;/a&gt; subsystem takes care of the rest.</source>
          <target state="translated">要使用AngularJS服务，请将其添加为依赖于该服务的组件（控制器，服务，过滤器或指令）的依赖项。AngularJS的&lt;a href=&quot;di&quot;&gt;依赖注入&lt;/a&gt;子系统负责其余的工作。</target>
        </trans-unit>
        <trans-unit id="eb5a31df8b9aafc070a499ecf9c86a92d155038d" translate="yes" xml:space="preserve">
          <source>To use it for serializing &lt;code&gt;$http&lt;/code&gt; request parameters, set it as the &lt;code&gt;paramSerializer&lt;/code&gt; property:</source>
          <target state="translated">要将其用于序列化 &lt;code&gt;$http&lt;/code&gt; 请求参数，请将其设置为 &lt;code&gt;paramSerializer&lt;/code&gt; 属性：</target>
        </trans-unit>
        <trans-unit id="34fe5ca24f7655ef4c0df8a8ce1da864c5daffcc" translate="yes" xml:space="preserve">
          <source>To wrap it up, let's summarize the most important points:</source>
          <target state="translated">总结一下,我们总结一下最重要的几点。</target>
        </trans-unit>
        <trans-unit id="67e87905406bc002d915c4e863d71aecb21a48f5" translate="yes" xml:space="preserve">
          <source>Toaster Notifications</source>
          <target state="translated">多士炉通知</target>
        </trans-unit>
        <trans-unit id="89699e63b193e1ad3c1e57e75c1c6bbec6885d66" translate="yes" xml:space="preserve">
          <source>Token for the literal value. The literal name value must be a valid literal name.</source>
          <target state="translated">字符值的标记,字符值必须是有效的字符名。字面名称的值必须是有效的字面名称。</target>
        </trans-unit>
        <trans-unit id="4fa8cc860c52b268dc6a3adcde7305e9415db5bb" translate="yes" xml:space="preserve">
          <source>Tools</source>
          <target state="translated">Tools</target>
        </trans-unit>
        <trans-unit id="43fad2672c530239402dc3cd0dc6902dc62473f7" translate="yes" xml:space="preserve">
          <source>Tools like &lt;a href=&quot;https://github.com/angular/protractor&quot;&gt;Protractor&lt;/a&gt; and &lt;a href=&quot;https://github.com/angular/angularjs-batarang&quot;&gt;Batarang&lt;/a&gt; need this information to run, but you can disable this in production for a significant performance boost with:</source>
          <target state="translated">诸如&lt;a href=&quot;https://github.com/angular/protractor&quot;&gt;Protractor&lt;/a&gt;和&lt;a href=&quot;https://github.com/angular/angularjs-batarang&quot;&gt;Batarang之&lt;/a&gt;类的工具都需要运行此信息，但是您可以在生产中禁用此信息，以通过以下方法显着提高性能：</target>
        </trans-unit>
        <trans-unit id="c1530f9880b2af5eaf175a15ace085e93796c97a" translate="yes" xml:space="preserve">
          <source>Tools like &lt;a href=&quot;https://github.com/olov/ng-annotate&quot;&gt;ng-annotate&lt;/a&gt; let you use implicit dependency annotations in your app and automatically add inline array annotations prior to minifying. If you decide to take this approach, you probably want to use &lt;code&gt;ng-strict-di&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/olov/ng-annotate&quot;&gt;ng-annotate之&lt;/a&gt;类的工具可让您在应用程序中使用隐式依赖项注释，并在最小化之前自动添加内联数组注释。如果您决定采用这种方法，则可能要使用 &lt;code&gt;ng-strict-di&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="aafa2966091cfe18b0886a79db159933dbbadccd" translate="yes" xml:space="preserve">
          <source>Total number of child scopes.</source>
          <target state="translated">儿童范围总数:</target>
        </trans-unit>
        <trans-unit id="a47abbef75ed2b9d1d65dbb4c1ee8007c1065795" translate="yes" xml:space="preserve">
          <source>Total number of watchers.</source>
          <target state="translated">观察者总人数。</target>
        </trans-unit>
        <trans-unit id="4d568499903ebd2d220b4d1aebe5751fe7c8e35c" translate="yes" xml:space="preserve">
          <source>Tracking and Duplicates</source>
          <target state="translated">追踪和复制</target>
        </trans-unit>
        <trans-unit id="66e03a0ac4dbd759832dd1962270988fb63c7705" translate="yes" xml:space="preserve">
          <source>Transclude fallback content</source>
          <target state="translated">包括后备内容</target>
        </trans-unit>
        <trans-unit id="2ff8fb7265f6145db1964ce88bbfd53d7161548a" translate="yes" xml:space="preserve">
          <source>Transcluded content exists on a scope that inherits from outside a directive but exists as a child of the directive's containing scope. If the containing scope is suspended the transcluded scope will also be suspended, even if the scope from which the transcluded scope inherits is not suspended.</source>
          <target state="translated">Transcluded 内容存在于从指令外部继承的作用域上,但它是作为指令的包含作用域的子代而存在。如果包含的作用域被暂停,则转入的作用域也将被暂停,即使转入的作用域所继承的作用域没有被暂停。</target>
        </trans-unit>
        <trans-unit id="795ce1bfcced4d4049cae5ddaeacbcb0c25e5cff" translate="yes" xml:space="preserve">
          <source>Transclusion</source>
          <target state="translated">Transclusion</target>
        </trans-unit>
        <trans-unit id="a5ed75b850fe44412f536f842d6bad363b3d1dc0" translate="yes" xml:space="preserve">
          <source>Transclusion Functions</source>
          <target state="translated">Transclusion功能</target>
        </trans-unit>
        <trans-unit id="989bb50d78d8c039c498ff1aa5c4035592d45823" translate="yes" xml:space="preserve">
          <source>Transclusion Scopes</source>
          <target state="translated">Transclusion Scopes</target>
        </trans-unit>
        <trans-unit id="bd9f20a87bc27f598593beab138842764756b017" translate="yes" xml:space="preserve">
          <source>Transclusion is the process of extracting a collection of DOM elements from one part of the DOM and copying them to another part of the DOM, while maintaining their connection to the original AngularJS scope from where they were taken.</source>
          <target state="translated">Transclusion是将DOM元素集合从DOM的一个部分提取出来,然后复制到DOM的另一个部分,同时保持它们与原始AngularJS作用域的联系。</target>
        </trans-unit>
        <trans-unit id="34a69ce955b679dd8ef55bd68ef5d2fb2de59126" translate="yes" xml:space="preserve">
          <source>Transclusion is used (often with &lt;a href=&quot;../directive/ngtransclude&quot;&gt;&lt;code&gt;ngTransclude&lt;/code&gt;&lt;/a&gt;) to insert the original contents of a directive's element into a specified place in the template of the directive. The benefit of transclusion, over simply moving the DOM elements manually, is that the transcluded content has access to the properties on the scope from which it was taken, even if the directive has isolated scope. See the &lt;a href=&quot;../../../guide/directive#creating-a-directive-that-wraps-other-elements.html&quot;&gt;Directives Guide&lt;/a&gt;.</source>
          <target state="translated">使用包含（通常与&lt;a href=&quot;../directive/ngtransclude&quot;&gt; &lt;code&gt;ngTransclude&lt;/code&gt; 结合使用&lt;/a&gt;）将指令元素的原始内容插入到指令模板中的指定位置。相对于简单地手动移动DOM元素而言，包含的好处在于，即使指令具有隔离的范围，被包含的内容也可以访问其来源范围内的属性。请参阅《&lt;a href=&quot;../../../guide/directive#creating-a-directive-that-wraps-other-elements.html&quot;&gt;指令指南》&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5f5aa3a8fc4b42447f88fc712a14afe2cdc1f412" translate="yes" xml:space="preserve">
          <source>Transforming Requests and Responses</source>
          <target state="translated">转变请求和响应</target>
        </trans-unit>
        <trans-unit id="e66820e4851b71dffa2d6714b446c9480ae287d1" translate="yes" xml:space="preserve">
          <source>Translated strings/datetime formats can vary greatly in length. For example, &lt;code&gt;June 3, 1977&lt;/code&gt; will be translated to Spanish as &lt;code&gt;3 de junio de 1977&lt;/code&gt;.</source>
          <target state="translated">转换后的字符串/日期时间格式的长度可以相差很大。例如， &lt;code&gt;June 3, 1977&lt;/code&gt; 将被翻译成西班牙语1977年5月3 &lt;code&gt;3 de junio de 1977&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5ea519c83af9abea32e76f378b69d1f735efd77a" translate="yes" xml:space="preserve">
          <source>Translation length</source>
          <target state="translated">翻译长度</target>
        </trans-unit>
        <trans-unit id="529ba88fd78ba49c6c2f6f2560bd2ca3b71c2359" translate="yes" xml:space="preserve">
          <source>Triggering and debouncing model updates</source>
          <target state="translated">触发和解除模型更新</target>
        </trans-unit>
        <trans-unit id="b30aa7b64c97b21bb201e26ce39656a62ae3ba6f" translate="yes" xml:space="preserve">
          <source>Triggers a removeClass animation surrounding the removal of the provided CSS class(es). Upon execution, the removeClass operation will only be handled after the next digest and it will not trigger an animation if element does not contain the CSS class or if the class is added at a later step. Note that class-based animations are treated differently compared to structural animations (like enter, move and leave) since the CSS classes may be added/removed at different points depending if CSS or JavaScript animations are used.</source>
          <target state="translated">在删除所提供的CSS类时触发removeClass动画。在执行时,只有在下一个摘要之后才会处理removeClass操作,如果元素中不包含CSS类,或者CSS类是在以后添加的,则不会触发动画。请注意,与结构性动画(如进入、移动和离开)相比,基于类的动画被区别对待,因为CSS类可能在不同的点添加/删除,这取决于是否使用了CSS或JavaScript动画。</target>
        </trans-unit>
        <trans-unit id="a8c60d34c5c475354e584429d0db24f6b56f4c26" translate="yes" xml:space="preserve">
          <source>Triggers an addClass animation surrounding the addition of the provided CSS class(es). Upon execution, the addClass operation will only be handled after the next digest and it will not trigger an animation if element already contains the CSS class or if the class is removed at a later step. Note that class-based animations are treated differently compared to structural animations (like enter, move and leave) since the CSS classes may be added/removed at different points depending if CSS or JavaScript animations are used.</source>
          <target state="translated">在添加CSS类时触发addClass动画。在执行时,addClass操作只会在下一个摘要之后被处理,如果元素已经包含CSS类,或者在以后的步骤中删除了CSS类,它将不会触发动画。请注意,与结构性动画(如进入、移动和离开)相比,基于类的动画被区别对待,因为CSS类可能在不同的点添加/删除,这取决于是否使用了CSS或JavaScript动画。</target>
        </trans-unit>
        <trans-unit id="a1ea2af226764114c06246658ad6eb3995bac408" translate="yes" xml:space="preserve">
          <source>Triggers an animation and then removes the element from the DOM. When the function is called a promise is returned that will be resolved during the next digest once the animation has completed.</source>
          <target state="translated">触发一个动画,然后从DOM中移除元素。当函数被调用时,将返回一个承诺,该承诺将在动画完成后的下一个摘要中被解析。</target>
        </trans-unit>
        <trans-unit id="d33a09cfae6955e8ea96021c02a14a6f2135e6d2" translate="yes" xml:space="preserve">
          <source>True if &lt;code&gt;value&lt;/code&gt; is &quot;empty&quot;.</source>
          <target state="translated">如果 &lt;code&gt;value&lt;/code&gt; 是&amp;ldquo;空&amp;rdquo;，则为true 。</target>
        </trans-unit>
        <trans-unit id="7e9f928080be6817472e3edba6cd3728c6b44b07" translate="yes" xml:space="preserve">
          <source>True if &lt;code&gt;value&lt;/code&gt; is a &lt;code&gt;Date&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;value&lt;/code&gt; 是 &lt;code&gt;Date&lt;/code&gt; ,则为True 。</target>
        </trans-unit>
        <trans-unit id="9d4620ea3af47d4b59be6c1ad6d376625a3bc5a3" translate="yes" xml:space="preserve">
          <source>True if &lt;code&gt;value&lt;/code&gt; is a &lt;code&gt;Function&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;value&lt;/code&gt; 是 &lt;code&gt;Function&lt;/code&gt; ,则为True 。</target>
        </trans-unit>
        <trans-unit id="f2dc22bb4abc37c763c32e208299d55940817939" translate="yes" xml:space="preserve">
          <source>True if &lt;code&gt;value&lt;/code&gt; is a &lt;code&gt;Number&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;value&lt;/code&gt; 是 &lt;code&gt;Number&lt;/code&gt; ,则为True 。</target>
        </trans-unit>
        <trans-unit id="629f2e041c0522e13feab339a108446527250afa" translate="yes" xml:space="preserve">
          <source>True if &lt;code&gt;value&lt;/code&gt; is a &lt;code&gt;String&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;value&lt;/code&gt; 是 &lt;code&gt;String&lt;/code&gt; ,则为True 。</target>
        </trans-unit>
        <trans-unit id="c7206f8d3d0972b3265fbd63b451b2d141ee6fe8" translate="yes" xml:space="preserve">
          <source>True if &lt;code&gt;value&lt;/code&gt; is a DOM element (or wrapped jQuery element).</source>
          <target state="translated">如果 &lt;code&gt;value&lt;/code&gt; 是DOM元素（或包装的jQuery元素），则为true 。</target>
        </trans-unit>
        <trans-unit id="e55cf1550d8a7a76c67c0e00faabad1dcabda075" translate="yes" xml:space="preserve">
          <source>True if &lt;code&gt;value&lt;/code&gt; is an &lt;code&gt;Array&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;value&lt;/code&gt; 是 &lt;code&gt;Array&lt;/code&gt; ,则为True 。</target>
        </trans-unit>
        <trans-unit id="b7156770c7f10d6373aa8baaafb2baaeb8df6fff" translate="yes" xml:space="preserve">
          <source>True if &lt;code&gt;value&lt;/code&gt; is an &lt;code&gt;Object&lt;/code&gt; but not &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;value&lt;/code&gt; 是一个 &lt;code&gt;Object&lt;/code&gt; ,则为true，但不为 &lt;code&gt;null&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="61bd97fd0cb8d2d1c177255faefe3a90f7d26d11" translate="yes" xml:space="preserve">
          <source>True if &lt;code&gt;value&lt;/code&gt; is defined.</source>
          <target state="translated">如果定义了 &lt;code&gt;value&lt;/code&gt; 则为True 。</target>
        </trans-unit>
        <trans-unit id="f4ccefcaf72f594cb16e5d8ae91db2c94271cc38" translate="yes" xml:space="preserve">
          <source>True if &lt;code&gt;value&lt;/code&gt; is undefined.</source>
          <target state="translated">如果 &lt;code&gt;value&lt;/code&gt; 未定义，则为真。</target>
        </trans-unit>
        <trans-unit id="0aa8d4b081c0f21cabda208483e50d393282d028" translate="yes" xml:space="preserve">
          <source>True if SCE is enabled, false otherwise.</source>
          <target state="translated">如果启用SCE,则为真,否则为假。</target>
        </trans-unit>
        <trans-unit id="9974e802cce85a25ca164e8503f6d27e58b29226" translate="yes" xml:space="preserve">
          <source>True if SCE is enabled, false otherwise. If you want to set the value, you have to do it at module config time on &lt;a href=&quot;../provider/%24sceprovider&quot;&gt;$sceProvider&lt;/a&gt;.</source>
          <target state="translated">如果启用了SCE，则为true，否则为false。如果要设置值，则必须在模块配置时在&lt;a href=&quot;../provider/%24sceprovider&quot;&gt;$ sceProvider&lt;/a&gt;上进行设置。</target>
        </trans-unit>
        <trans-unit id="7b26669371aa537bd9fb78e54420fba225d69357" translate="yes" xml:space="preserve">
          <source>True if all of the containing forms and controls are valid.</source>
          <target state="translated">如果所有包含的表单和控件都有效,则为真。</target>
        </trans-unit>
        <trans-unit id="43aa5083507a3dfc1a3cb7fdf232cd1f4bf4e91f" translate="yes" xml:space="preserve">
          <source>True if arguments are equal.</source>
          <target state="translated">如果参数相同,则为真。</target>
        </trans-unit>
        <trans-unit id="9d333018eec7b900f39b653771161777b87197ae" translate="yes" xml:space="preserve">
          <source>True if at least one containing control or form is invalid.</source>
          <target state="translated">如果至少一个包含的控件或表单无效,则为真。</target>
        </trans-unit>
        <trans-unit id="181d1025fe366a64c937b96da6ec883bbf6e7ba0" translate="yes" xml:space="preserve">
          <source>True if at least one error on the control.</source>
          <target state="translated">如果控制上至少有一个错误,则为真。</target>
        </trans-unit>
        <trans-unit id="56ff20210bccab95fcbf58367144ac067af68148" translate="yes" xml:space="preserve">
          <source>True if control has lost focus.</source>
          <target state="translated">如果控制失去焦点,则为真。</target>
        </trans-unit>
        <trans-unit id="c7fbe9ee2795fbddf37ec8d8c2d62f113e612f3b" translate="yes" xml:space="preserve">
          <source>True if control has not lost focus yet.</source>
          <target state="translated">如果控制还没有失去焦点,则为真。</target>
        </trans-unit>
        <trans-unit id="3fa62205eae963b6a217b7f9c96dcf716528f35e" translate="yes" xml:space="preserve">
          <source>True if there is no error.</source>
          <target state="translated">如果没有错误,则为真。</target>
        </trans-unit>
        <trans-unit id="25ffcfd59486b9a5399542b4690b410851ea2474" translate="yes" xml:space="preserve">
          <source>True if user has already interacted with the control.</source>
          <target state="translated">如果用户已经与控件进行了交互,则为真。</target>
        </trans-unit>
        <trans-unit id="dbcbfbb295b5a8ea5518852d000e90ababb1c7f2" translate="yes" xml:space="preserve">
          <source>True if user has already interacted with the form.</source>
          <target state="translated">如果用户已经与表单进行了交互,则为真。</target>
        </trans-unit>
        <trans-unit id="29b344f09475639539f4e83c2d015aaaed0bbd1d" translate="yes" xml:space="preserve">
          <source>True if user has not interacted with the control yet.</source>
          <target state="translated">如果用户还没有与控件交互,则为真。</target>
        </trans-unit>
        <trans-unit id="635c3755d9bde31ca73c1d749bc707a37d18b709" translate="yes" xml:space="preserve">
          <source>True if user has not interacted with the form yet.</source>
          <target state="translated">如果用户还没有与表单交互,则为真。</target>
        </trans-unit>
        <trans-unit id="65825ee641a9445d6459e2ab76bdc68b70985738" translate="yes" xml:space="preserve">
          <source>True if user has submitted the form even if its invalid.</source>
          <target state="translated">如果用户已经提交了表单,即使表单无效,也为真。</target>
        </trans-unit>
        <trans-unit id="b88445bdd7bea1365372168f7dbf74b80d853d03" translate="yes" xml:space="preserve">
          <source>Try it here: enter text in text box and watch the greeting change.</source>
          <target state="translated">在这里尝试一下:在文本框中输入文字,然后看着问候语的变化。</target>
        </trans-unit>
        <trans-unit id="df5a54a82b0bebef0de0f478ec3ab5b4c9f5c3ea" translate="yes" xml:space="preserve">
          <source>Try out the Live Preview above, and then let's walk through the example and describe what's going on.</source>
          <target state="translated">试试上面的实时预览,然后我们通过这个例子来描述一下是怎么回事。</target>
        </trans-unit>
        <trans-unit id="2701a94c0eb55cbd958a87dff3e959673ff1bf53" translate="yes" xml:space="preserve">
          <source>Tutorial</source>
          <target state="translated">Tutorial</target>
        </trans-unit>
        <trans-unit id="5392c950bdde4be7e5f5b8fdc6a1ca5f21e905cf" translate="yes" xml:space="preserve">
          <source>Twitter</source>
          <target state="translated">Twitter</target>
        </trans-unit>
        <trans-unit id="96e344023c95f59d40b4739ed0a85a635eee1b78" translate="yes" xml:space="preserve">
          <source>Two different declaration styles are included below:</source>
          <target state="translated">下面包括两种不同的声明风格。</target>
        </trans-unit>
        <trans-unit id="ecb76bbc89ca1321805d931b227686253a851eed" translate="yes" xml:space="preserve">
          <source>Two objects or values are considered equivalent if at least one of the following is true:</source>
          <target state="translated">如果以下至少一项为真,则认为两个对象或值是等价的:</target>
        </trans-unit>
        <trans-unit id="85d3dd1c7508b8b456f004ed6161495afea6f854" translate="yes" xml:space="preserve">
          <source>Two-way binding to $location</source>
          <target state="translated">双向绑定到$location</target>
        </trans-unit>
        <trans-unit id="3deb7456519697ecf4eefc455516c969a3681bae" translate="yes" xml:space="preserve">
          <source>Type</source>
          <target state="translated">Type</target>
        </trans-unit>
        <trans-unit id="e80662327a53bb36ba8ecc569bceb07d8d355e87" translate="yes" xml:space="preserve">
          <source>Type components in ng</source>
          <target state="translated">类型组件</target>
        </trans-unit>
        <trans-unit id="a435bd7da8a147120f1a4b79e547e5c008143436" translate="yes" xml:space="preserve">
          <source>Type components in ngComponentRouter</source>
          <target state="translated">ngComponentRouter中的组件类型。</target>
        </trans-unit>
        <trans-unit id="50a5d371f802a731c130768b7356728d742c17f8" translate="yes" xml:space="preserve">
          <source>Type components in ngMock</source>
          <target state="translated">ngMock中的组件类型</target>
        </trans-unit>
        <trans-unit id="ee3fb11d05c90c37311491cf33008925b13b487f" translate="yes" xml:space="preserve">
          <source>Type:</source>
          <target state="translated">Type:</target>
        </trans-unit>
        <trans-unit id="a37965c6d74cd91c105a5af7d17ac48c2ae2ac45" translate="yes" xml:space="preserve">
          <source>Typical usage</source>
          <target state="translated">典型用途</target>
        </trans-unit>
        <trans-unit id="c8d61bd71fa3d7cafbb7128d3d9893fb96df94a4" translate="yes" xml:space="preserve">
          <source>Typically beforeAll is used to make many assertions about a single operation. This can cut down test run-time as the test setup doesn't need to be re-run, and enabling focussed tests each with a single assertion.</source>
          <target state="translated">通常beforeAll用于对一个操作进行许多断言。这可以减少测试运行时间,因为测试设置不需要重新运行,并使每一个测试都能以单一的断言为中心。</target>
        </trans-unit>
        <trans-unit id="e6f0ae9524ce6acd2d2f63e97dbf18fe3aca600b" translate="yes" xml:space="preserve">
          <source>Typically, when you create an application you need to set up the initial state for the AngularJS &lt;code&gt;$scope&lt;/code&gt;. You set up the initial state of a scope by attaching properties to the &lt;code&gt;$scope&lt;/code&gt; object. The properties contain the &lt;strong&gt;view model&lt;/strong&gt; (the model that will be presented by the view). All the &lt;code&gt;$scope&lt;/code&gt; properties will be available to the &lt;a href=&quot;templates&quot;&gt;template&lt;/a&gt; at the point in the DOM where the Controller is registered.</source>
          <target state="translated">通常，在创建应用程序时，需要为AngularJS &lt;code&gt;$scope&lt;/code&gt; 设置初始状态。您可以通过将属性附加到 &lt;code&gt;$scope&lt;/code&gt; 对象来设置作用域的初始状态。这些属性包含&lt;strong&gt;视图模型&lt;/strong&gt;（&lt;strong&gt;视图&lt;/strong&gt;将显示的模型）。在&lt;a href=&quot;templates&quot;&gt;模板&lt;/a&gt;中注册Controller的点，所有 &lt;code&gt;$scope&lt;/code&gt; 属性都可用于模板。</target>
        </trans-unit>
        <trans-unit id="82ca3e622f497504b13ae95ba5174ca088e4d1be" translate="yes" xml:space="preserve">
          <source>Typically, you don't use &lt;code&gt;ngBind&lt;/code&gt; directly, but instead you use the double curly markup like &lt;code&gt;{{ expression }}&lt;/code&gt; which is similar but less verbose.</source>
          <target state="translated">通常，您不直接使用 &lt;code&gt;ngBind&lt;/code&gt; ，而是使用类似 &lt;code&gt;{{ expression }}&lt;/code&gt; 的双重卷曲标记，它虽然相似，但比较冗长。</target>
        </trans-unit>
        <trans-unit id="f6a19ff69e8d695fff05426906779eaaae870446" translate="yes" xml:space="preserve">
          <source>Typically, you would call this method following each test case that asserts requests using an &quot;afterEach&quot; clause.</source>
          <target state="translated">通常情况下,你会在每个使用 &quot;afterEach &quot;子句断言请求的测试用例后调用这个方法。</target>
        </trans-unit>
        <trans-unit id="7fdf8e24fee9641029d910c77e727fa987ff0d84" translate="yes" xml:space="preserve">
          <source>Typically, you would configure or override the &lt;a href=&quot;%24scedelegate&quot;&gt;$sceDelegate&lt;/a&gt; instead of the &lt;code&gt;$sce&lt;/code&gt; service to customize the way Strict Contextual Escaping works in AngularJS. This is because, while the &lt;code&gt;$sce&lt;/code&gt; provides numerous shorthand methods, etc., you really only need to override 3 core functions (&lt;code&gt;trustAs&lt;/code&gt;, &lt;code&gt;getTrusted&lt;/code&gt; and &lt;code&gt;valueOf&lt;/code&gt;) to replace the way things work because &lt;code&gt;$sce&lt;/code&gt; delegates to &lt;code&gt;$sceDelegate&lt;/code&gt; for these operations.</source>
          <target state="translated">通常，您将配置或覆盖&lt;a href=&quot;%24scedelegate&quot;&gt;$ sceDelegate&lt;/a&gt;而不是 &lt;code&gt;$sce&lt;/code&gt; 服务，以自定义严格上下文转义在AngularJS中的工作方式。这是因为，尽管 &lt;code&gt;$sce&lt;/code&gt; 提供了许多速记方法等，但实际上您只需要重写3个核心函数（ &lt;code&gt;trustAs&lt;/code&gt; ， &lt;code&gt;getTrusted&lt;/code&gt; 和 &lt;code&gt;valueOf&lt;/code&gt; ）来替换工作方式，因为 &lt;code&gt;$sce&lt;/code&gt; 将这些操作委托给 &lt;code&gt;$sceDelegate&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4949e7b471c62f07ef5e8f49abbfc90b2fcee84d" translate="yes" xml:space="preserve">
          <source>URL format</source>
          <target state="translated">URL格式</target>
        </trans-unit>
        <trans-unit id="e18613f7569df4e87d46ab0c50bd2f0aa9fd3721" translate="yes" xml:space="preserve">
          <source>URL of content to load.</source>
          <target state="translated">要加载的内容的URL。</target>
        </trans-unit>
        <trans-unit id="30e531717661ab3417ebc4cbe0c1de475ab6be26" translate="yes" xml:space="preserve">
          <source>URL of the request.</source>
          <target state="translated">请求的URL。</target>
        </trans-unit>
        <trans-unit id="d7bbc289db7f0b0052507421a9bcb3e65c45c45e" translate="yes" xml:space="preserve">
          <source>URL that was before it was changed.</source>
          <target state="translated">改之前的URL。</target>
        </trans-unit>
        <trans-unit id="218f37ac7c7d3d4188879070d19d295a2d90c29a" translate="yes" xml:space="preserve">
          <source>Under the hood</source>
          <target state="translated">引擎盖下</target>
        </trans-unit>
        <trans-unit id="443978f12d579b038c008dea8e752b5d3e01d6d0" translate="yes" xml:space="preserve">
          <source>Understanding How Scopes Work with Transcluded Directives</source>
          <target state="translated">了解作用域如何与转入指令一起工作</target>
        </trans-unit>
        <trans-unit id="b476afa4e9575435e81ebe1e34e1ccc258d54e8e" translate="yes" xml:space="preserve">
          <source>Understanding Scopes</source>
          <target state="translated">了解范围</target>
        </trans-unit>
        <trans-unit id="3aea8612a3778098d091872872cceefb5e6bd7de" translate="yes" xml:space="preserve">
          <source>Understanding View</source>
          <target state="translated">了解视图</target>
        </trans-unit>
        <trans-unit id="629ffb1444dbbb1b0dac1c29021a48b25b040df3" translate="yes" xml:space="preserve">
          <source>Unique scope ID (monotonically increasing) useful for debugging.</source>
          <target state="translated">唯一的作用域ID(单调递增),对调试有用。</target>
        </trans-unit>
        <trans-unit id="438d23452047f4defac8e18aecae37372fcea335" translate="yes" xml:space="preserve">
          <source>Unit Testing</source>
          <target state="translated">单元测试</target>
        </trans-unit>
        <trans-unit id="3b563841706d01128f360a08ae70337b23f59c44" translate="yes" xml:space="preserve">
          <source>Unit testing with mock $httpBackend</source>
          <target state="translated">使用mock $httpBackend进行单元测试</target>
        </trans-unit>
        <trans-unit id="03f9dd1dbb0519b8fb0d50867eeaf9173813a3e3" translate="yes" xml:space="preserve">
          <source>Unit testing, as the name implies, is about testing individual units of code. Unit tests try to answer questions such as &quot;Did I think about the logic correctly?&quot; or &quot;Does the sort function order the list in the right order?&quot;</source>
          <target state="translated">单元测试,顾名思义,就是测试各个代码单元。单元测试试图回答一些问题,比如 &quot;我考虑的逻辑是否正确?&quot;或者 &quot;排序函数是否按照正确的顺序排列列表?&quot;</target>
        </trans-unit>
        <trans-unit id="57c368e336d005ba762d838d65c9d99e26f84dac" translate="yes" xml:space="preserve">
          <source>Unit tests only have to load relevant modules, which keeps them fast.</source>
          <target state="translated">单元测试只需要加载相关的模块,这样可以保持测试的速度。</target>
        </trans-unit>
        <trans-unit id="3fb4e286e502a759b76367b0dba26a4db6774e6a" translate="yes" xml:space="preserve">
          <source>Unit-testing Component Controllers</source>
          <target state="translated">单元测试组件控制器</target>
        </trans-unit>
        <trans-unit id="c532fb030d4057cff1a4adcec6eb4756fc91ef75" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;angular.extend&quot;&gt;extend()&lt;/a&gt;, &lt;code&gt;merge()&lt;/code&gt; recursively descends into object properties of source objects, performing a deep copy.</source>
          <target state="translated">与&lt;a href=&quot;angular.extend&quot;&gt;extend（）&lt;/a&gt;不同， &lt;code&gt;merge()&lt;/code&gt; 递归地归入源对象的对象属性，执行深层复制。</target>
        </trans-unit>
        <trans-unit id="c99e4d44f0c339bd48a75c15f4c96bd079f56c71" translate="yes" xml:space="preserve">
          <source>Unlike ES262's &lt;a href=&quot;http://www.ecma-international.org/ecma-262/5.1/#sec-15.4.4.18&quot;&gt;Array.prototype.forEach&lt;/a&gt;, providing 'undefined' or 'null' values for &lt;code&gt;obj&lt;/code&gt; will not throw a TypeError, but rather just return the value provided.</source>
          <target state="translated">与ES262的&lt;a href=&quot;http://www.ecma-international.org/ecma-262/5.1/#sec-15.4.4.18&quot;&gt;Array.prototype.forEach&lt;/a&gt;不同，为 &lt;code&gt;obj&lt;/code&gt; 提供'undefined'或'null'值不会抛出TypeError，而只是返回所提供的值。</target>
        </trans-unit>
        <trans-unit id="209c8097836b9258765844c6a5792b2eb42a2408" translate="yes" xml:space="preserve">
          <source>Unlike services, there can be many instances of the same type of controller in an application.</source>
          <target state="translated">与服务不同,在一个应用程序中,可以有许多相同类型的控制器实例。</target>
        </trans-unit>
        <trans-unit id="41ae88da458d1d682765ae9e4d1fc2981948283c" translate="yes" xml:space="preserve">
          <source>Unlike simple values, object-literals are watched until every key is defined. See &lt;a href=&quot;http://www.bennadel.com/blog/2760-one-time-data-bindings-for-object-literal-expressions-in-angularjs-1-3.htm&quot;&gt;http://www.bennadel.com/blog/2760-one-time-data-bindings-for-object-literal-expressions-in-angularjs-1-3.htm&lt;/a&gt;</source>
          <target state="translated">与简单值不同，将监视对象文字，直到定义了每个键。参见&lt;a href=&quot;http://www.bennadel.com/blog/2760-one-time-data-bindings-for-object-literal-expressions-in-angularjs-1-3.htm&quot;&gt;http://www.bennadel.com/blog/2760-one-time-data-bindings-for-object-literal-expressions-in-angularjs-1-3.htm&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="73ae224e8735ac30c004ffdc6115aecdf9718361" translate="yes" xml:space="preserve">
          <source>Up until AngularJS 1.3, &lt;code&gt;$cookies&lt;/code&gt; exposed properties that represented the current browser cookie values. In version 1.4, this behavior has changed, and &lt;code&gt;$cookies&lt;/code&gt; now provides a standard api of getters, setters etc.</source>
          <target state="translated">直到AngularJS 1.3， &lt;code&gt;$cookies&lt;/code&gt; 公开表示当前浏览器cookie值的属性。在版本1.4中，此行为已更改，并且 &lt;code&gt;$cookies&lt;/code&gt; 现在提供了标准的getter，setter等api。</target>
        </trans-unit>
        <trans-unit id="6a24966329bd38080b15cb29a9d8d9bbe7a67aba" translate="yes" xml:space="preserve">
          <source>Update the view value.</source>
          <target state="translated">更新视图值。</target>
        </trans-unit>
        <trans-unit id="48d94c781db18d8b60bf067bb589536cbf58bd78" translate="yes" xml:space="preserve">
          <source>Updates may be pending by a debounced event or because the input is waiting for a some future event defined in &lt;code&gt;ng-model-options&lt;/code&gt;. This method is rarely needed as &lt;code&gt;NgModelController&lt;/code&gt; usually handles calling this in response to input events.</source>
          <target state="translated">更新可能会因反跳事件而挂起，或者因为输入正在等待 &lt;code&gt;ng-model-options&lt;/code&gt; 中定义的某个将来的事件。很少需要此方法，因为 &lt;code&gt;NgModelController&lt;/code&gt; 通常会响应输入事件来处理调用此方法。</target>
        </trans-unit>
        <trans-unit id="a5ece24f05232383c973b3dcd8d5ec955602e4f9" translate="yes" xml:space="preserve">
          <source>Updates may be pending by a debounced event or because the input is waiting for a some future event defined in &lt;code&gt;ng-model-options&lt;/code&gt;. This method is typically needed by the reset button of a form that uses &lt;code&gt;ng-model-options&lt;/code&gt; to pend updates.</source>
          <target state="translated">更新可能会因反跳事件而挂起，或者因为输入正在等待 &lt;code&gt;ng-model-options&lt;/code&gt; 中定义的某个将来的事件。使用 &lt;code&gt;ng-model-options&lt;/code&gt; 进行更新的表单的重置按钮通常需要此方法。</target>
        </trans-unit>
        <trans-unit id="c32c26b09b60884932de0735cac06908d3f7ccf0" translate="yes" xml:space="preserve">
          <source>Updates may be pending by a debounced event or because the input is waiting for a some future event defined in &lt;code&gt;ng-model-options&lt;/code&gt;. this method is rarely needed as &lt;code&gt;NgModelController&lt;/code&gt; usually handles calling this in response to input events.</source>
          <target state="translated">更新可能会因反跳事件而挂起，或者因为输入正在等待 &lt;code&gt;ng-model-options&lt;/code&gt; 中定义的某个将来的事件。很少需要此方法，因为 &lt;code&gt;NgModelController&lt;/code&gt; 通常会响应输入事件来处理调用此方法。</target>
        </trans-unit>
        <trans-unit id="0bb18642b70b9f8a9c12ccf39487328f306b8e19" translate="yes" xml:space="preserve">
          <source>Usage</source>
          <target state="translated">Usage</target>
        </trans-unit>
        <trans-unit id="e78c2b095e755aab9f8caa006dd4fd278929ad41" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;%24interval#flush.html&quot;&gt;&lt;code&gt;$interval.flush(millis)&lt;/code&gt;&lt;/a&gt; to move forward by &lt;code&gt;millis&lt;/code&gt; milliseconds and trigger any functions scheduled to run in that time.</source>
          <target state="translated">使用&lt;a href=&quot;%24interval#flush.html&quot;&gt; &lt;code&gt;$interval.flush(millis)&lt;/code&gt; &lt;/a&gt;通过向前移动 &lt;code&gt;millis&lt;/code&gt; 毫秒，触发计划在这段时间运行的任何功能。</target>
        </trans-unit>
        <trans-unit id="9d10cf3ebaf3f699b7cd183a40113d2096935796" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;../provider/%24interpolateprovider#endSymbol.html&quot;&gt;&lt;code&gt;$interpolateProvider.endSymbol&lt;/code&gt;&lt;/a&gt; to change the symbol.</source>
          <target state="translated">使用&lt;a href=&quot;../provider/%24interpolateprovider#endSymbol.html&quot;&gt; &lt;code&gt;$interpolateProvider.endSymbol&lt;/code&gt; &lt;/a&gt;更改符号。</target>
        </trans-unit>
        <trans-unit id="d014a1c84c0cea27fad3b0edad9bcbb55cee2222" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;../provider/%24interpolateprovider#startSymbol.html&quot;&gt;&lt;code&gt;$interpolateProvider.startSymbol&lt;/code&gt;&lt;/a&gt; to change the symbol.</source>
          <target state="translated">使用&lt;a href=&quot;../provider/%24interpolateprovider#startSymbol.html&quot;&gt; &lt;code&gt;$interpolateProvider.startSymbol&lt;/code&gt; &lt;/a&gt;更改符号。</target>
        </trans-unit>
        <trans-unit id="6a641c4af45db61a4d45240e4bc451c61620dd29" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;ngif&quot;&gt;&lt;code&gt;ngIf&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;ngswitch&quot;&gt;&lt;code&gt;ngSwitch&lt;/code&gt;&lt;/a&gt; instead of &lt;a href=&quot;ngshow&quot;&gt;&lt;code&gt;ngShow&lt;/code&gt;&lt;/a&gt; / &lt;a href=&quot;nghide&quot;&gt;&lt;code&gt;ngHide&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">使用&lt;a href=&quot;ngif&quot;&gt; &lt;code&gt;ngIf&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;ngswitch&quot;&gt; &lt;code&gt;ngSwitch&lt;/code&gt; &lt;/a&gt;代替&lt;a href=&quot;ngshow&quot;&gt; &lt;code&gt;ngShow&lt;/code&gt; &lt;/a&gt; / &lt;a href=&quot;nghide&quot;&gt; &lt;code&gt;ngHide&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="218b05a9d83c943a410d416413419b99ab64cf02" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;$anchorScrollProvider&lt;/code&gt; to disable automatic scrolling whenever &lt;a href=&quot;../service/%24location#hash.html&quot;&gt;$location.hash()&lt;/a&gt; changes.</source>
          <target state="translated">每当&lt;a href=&quot;../service/%24location#hash.html&quot;&gt;$ location.hash（）&lt;/a&gt;更改时，请使用 &lt;code&gt;$anchorScrollProvider&lt;/code&gt; 禁用自动滚动。</target>
        </trans-unit>
        <trans-unit id="b968b0787da9eecc71135a165258514b44ef0734" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;$anchorScrollProvider&lt;/code&gt; to disable automatic scrolling whenever &lt;a href=&quot;service/%24location#hash.html&quot;&gt;$location.hash()&lt;/a&gt; changes.</source>
          <target state="translated">每当&lt;a href=&quot;service/%24location#hash.html&quot;&gt;$ location.hash（）&lt;/a&gt;更改时，请使用 &lt;code&gt;$anchorScrollProvider&lt;/code&gt; 禁用自动滚动。</target>
        </trans-unit>
        <trans-unit id="354512147e4e601cc546a9ec65841a61f9421903" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;$cookiesProvider&lt;/code&gt; to change the default behavior of the &lt;a href=&quot;../service/%24cookies&quot;&gt;$cookies&lt;/a&gt; service.</source>
          <target state="translated">使用 &lt;code&gt;$cookiesProvider&lt;/code&gt; 更改&lt;a href=&quot;../service/%24cookies&quot;&gt;$ cookies&lt;/a&gt;服务的默认行为。</target>
        </trans-unit>
        <trans-unit id="a148f7331f736ce00c51361a431bda51bee1ed1d" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;$cookiesProvider&lt;/code&gt; to change the default behavior of the &lt;a href=&quot;ngcookies/service/%24cookies&quot;&gt;$cookies&lt;/a&gt; service.</source>
          <target state="translated">使用 &lt;code&gt;$cookiesProvider&lt;/code&gt; 更改&lt;a href=&quot;ngcookies/service/%24cookies&quot;&gt;$ cookies&lt;/a&gt;服务的默认行为。</target>
        </trans-unit>
        <trans-unit id="ef936e3e20232f9a1650cc302f357cad6c4156ca" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;$cookiesProvider&lt;/code&gt; to change the default behavior of the &lt;a href=&quot;service/%24cookies&quot;&gt;$cookies&lt;/a&gt; service.</source>
          <target state="translated">使用 &lt;code&gt;$cookiesProvider&lt;/code&gt; 更改&lt;a href=&quot;service/%24cookies&quot;&gt;$ cookies&lt;/a&gt;服务的默认行为。</target>
        </trans-unit>
        <trans-unit id="15fb01e25077c75bad5d011e5094bc75c8f3d896" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;$httpProvider&lt;/code&gt; to change the default behavior of the &lt;a href=&quot;../service/%24http&quot;&gt;$http&lt;/a&gt; service.</source>
          <target state="translated">使用 &lt;code&gt;$httpProvider&lt;/code&gt; 更改&lt;a href=&quot;../service/%24http&quot;&gt;$ http&lt;/a&gt;服务的默认行为。</target>
        </trans-unit>
        <trans-unit id="687465cea5c0906f2e3249d57fd88fb9d657fefe" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;$httpProvider&lt;/code&gt; to change the default behavior of the &lt;a href=&quot;service/%24http&quot;&gt;$http&lt;/a&gt; service.</source>
          <target state="translated">使用 &lt;code&gt;$httpProvider&lt;/code&gt; 更改&lt;a href=&quot;service/%24http&quot;&gt;$ http&lt;/a&gt;服务的默认行为。</target>
        </trans-unit>
        <trans-unit id="2392b2da1088beefbc29590ab2eda9ddba143d0a" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;$resourceProvider&lt;/code&gt; to change the default behavior of the &lt;a href=&quot;../service/%24resource&quot;&gt;&lt;code&gt;$resource&lt;/code&gt;&lt;/a&gt; service.</source>
          <target state="translated">使用 &lt;code&gt;$resourceProvider&lt;/code&gt; 更改&lt;a href=&quot;../service/%24resource&quot;&gt; &lt;code&gt;$resource&lt;/code&gt; &lt;/a&gt;服务的默认行为。</target>
        </trans-unit>
        <trans-unit id="b88771011fc3cd5358447dc36675101538ddffcf" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;$resourceProvider&lt;/code&gt; to change the default behavior of the &lt;a href=&quot;ngresource/service/%24resource&quot;&gt;&lt;code&gt;$resource&lt;/code&gt;&lt;/a&gt; service.</source>
          <target state="translated">使用 &lt;code&gt;$resourceProvider&lt;/code&gt; 更改&lt;a href=&quot;ngresource/service/%24resource&quot;&gt; &lt;code&gt;$resource&lt;/code&gt; &lt;/a&gt;服务的默认行为。</target>
        </trans-unit>
        <trans-unit id="7ca460ac7b4debf1921b9d34cfa7a7f3a1ebd02a" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;$resourceProvider&lt;/code&gt; to change the default behavior of the &lt;a href=&quot;service/%24resource&quot;&gt;&lt;code&gt;$resource&lt;/code&gt;&lt;/a&gt; service.</source>
          <target state="translated">使用 &lt;code&gt;$resourceProvider&lt;/code&gt; 更改&lt;a href=&quot;service/%24resource&quot;&gt; &lt;code&gt;$resource&lt;/code&gt; &lt;/a&gt;服务的默认行为。</target>
        </trans-unit>
        <trans-unit id="cc1ec7cfcbd0280881371f3aa4ee3069843966fe" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;ng-class=&quot;{'ng-hide': expression}&lt;/code&gt; instead of instead of &lt;a href=&quot;ngshow&quot;&gt;&lt;code&gt;ngShow&lt;/code&gt;&lt;/a&gt; / &lt;a href=&quot;nghide&quot;&gt;&lt;code&gt;ngHide&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">使用 &lt;code&gt;ng-class=&quot;{'ng-hide': expression}&lt;/code&gt; 代替&lt;a href=&quot;ngshow&quot;&gt; &lt;code&gt;ngShow&lt;/code&gt; &lt;/a&gt; / &lt;a href=&quot;nghide&quot;&gt; &lt;code&gt;ngHide&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="252932316ac080237bfbd49d94e69b42c8202774" translate="yes" xml:space="preserve">
          <source>Use controllers to:</source>
          <target state="translated">使用控制器来。</target>
        </trans-unit>
        <trans-unit id="ec78e24bb1beaec2fff0a05e747e3a518fdbd042" translate="yes" xml:space="preserve">
          <source>Use sharedInjector when you want to take advantage of Jasmine's &lt;code&gt;beforeAll()&lt;/code&gt;, or mocha's &lt;code&gt;before()&lt;/code&gt; methods. Call &lt;code&gt;module.sharedInjector()&lt;/code&gt; before you setup any other hooks that will create (i.e call &lt;code&gt;module()&lt;/code&gt;) or use (i.e call &lt;code&gt;inject()&lt;/code&gt;) the injector.</source>
          <target state="translated">当您想利用Jasmine的 &lt;code&gt;beforeAll()&lt;/code&gt; 或mocha的 &lt;code&gt;before()&lt;/code&gt; 方法时，请使用sharedInjector 。在设置任何其他将创建（例如，调用 &lt;code&gt;module()&lt;/code&gt; ）或使用（例如，调用 &lt;code&gt;inject()&lt;/code&gt; ）注入器的）钩子之前，请调用 &lt;code&gt;module.sharedInjector()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="eb362d3d265854877b73c2022104238b8f662f3f" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;$locationProvider&lt;/code&gt; to configure how the application deep linking paths are stored.</source>
          <target state="translated">使用 &lt;code&gt;$locationProvider&lt;/code&gt; 配置应用程序深层链接路径的存储方式。</target>
        </trans-unit>
        <trans-unit id="7a7084daedcbcf3cf58f8478d3a4ef6d9e3042e1" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;$logProvider&lt;/code&gt; to configure how the application logs messages</source>
          <target state="translated">使用 &lt;code&gt;$logProvider&lt;/code&gt; 配置应用程序记录消息的方式</target>
        </trans-unit>
        <trans-unit id="359920a71e60b24c3e8679f4d1142b9de40dfe80" translate="yes" xml:space="preserve">
          <source>Use the latest AngularJS possible</source>
          <target state="translated">尽可能使用最新的AngularJS</target>
        </trans-unit>
        <trans-unit id="9d4a7cc07d13aee2118147eae5b6204e02526bb6" translate="yes" xml:space="preserve">
          <source>Use the special CSS selector &lt;code&gt;ng-hide.ng-hide-animate&lt;/code&gt; to set &lt;code&gt;{display: none}&lt;/code&gt; or similar on the affected elements.</source>
          <target state="translated">使用特殊的CSS选择器 &lt;code&gt;ng-hide.ng-hide-animate&lt;/code&gt; 在受影响的元素上设置 &lt;code&gt;{display: none}&lt;/code&gt; 或类似设置。</target>
        </trans-unit>
        <trans-unit id="01b6831d8484c409e8aabc8e2f585a365a461d33" translate="yes" xml:space="preserve">
          <source>Use this directive to &lt;strong&gt;auto-bootstrap&lt;/strong&gt; an AngularJS application. The &lt;code&gt;ngApp&lt;/code&gt; directive designates the &lt;strong&gt;root element&lt;/strong&gt; of the application and is typically placed near the root element of the page - e.g. on the &lt;code&gt;&amp;lt;body&amp;gt;&lt;/code&gt; or &lt;code&gt;&amp;lt;html&amp;gt;&lt;/code&gt; tags.</source>
          <target state="translated">使用此指令&lt;strong&gt;自动引导&lt;/strong&gt; AngularJS应用程序。所述 &lt;code&gt;ngApp&lt;/code&gt; 指令指定&lt;strong&gt;根元素&lt;/strong&gt;的应用程序的，并且通常放置在页面的根元素近-例如在 &lt;code&gt;&amp;lt;body&amp;gt;&lt;/code&gt; 或 &lt;code&gt;&amp;lt;html&amp;gt;&lt;/code&gt; 标记。</target>
        </trans-unit>
        <trans-unit id="cffba56063404188829cf8f1f82edf386bbc1e59" translate="yes" xml:space="preserve">
          <source>Use this directive to force the angular.element library. This should be used to force either jqLite by leaving ng-jq blank or setting the name of the jquery variable under window (eg. jQuery).</source>
          <target state="translated">使用这条指令来强制使用angular.Element库。这应该用来强制jqLite,让ng-jq留空,或者在window下设置jquery变量的名称(例如jQuery)。</target>
        </trans-unit>
        <trans-unit id="294fecfb6e5d5ea18318309468bfa41aee69ee2b" translate="yes" xml:space="preserve">
          <source>Use this function to manually start up AngularJS application.</source>
          <target state="translated">使用此功能可以手动启动AngularJS应用程序。</target>
        </trans-unit>
        <trans-unit id="c6f82f5bd67956f87473eb69dd807927f89430cf" translate="yes" xml:space="preserve">
          <source>Use this function to reload the current application with debug information turned on. This takes precedence over a call to &lt;code&gt;$compileProvider.debugInfoEnabled(false)&lt;/code&gt;.</source>
          <target state="translated">使用此功能可以在打开调试信息的情况下重新加载当前应用程序。这优先于对 &lt;code&gt;$compileProvider.debugInfoEnabled(false)&lt;/code&gt; 的调用。</target>
        </trans-unit>
        <trans-unit id="d5a771a46afd23a79112854e27f186a09e2c9ba1" translate="yes" xml:space="preserve">
          <source>Use this method to configure services by injecting their &lt;a href=&quot;angular.module#provider.html&quot;&gt;&lt;code&gt;providers&lt;/code&gt;&lt;/a&gt;, e.g. for adding routes to the &lt;a href=&quot;../../ngroute/provider/%24routeprovider&quot;&gt;$routeProvider&lt;/a&gt;.</source>
          <target state="translated">使用此方法通过注入服务的&lt;a href=&quot;angular.module#provider.html&quot;&gt; &lt;code&gt;providers&lt;/code&gt; &lt;/a&gt;来配置服务，例如，将路由添加到&lt;a href=&quot;../../ngroute/provider/%24routeprovider&quot;&gt;$ routeProvider&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="94c8a5728df153aa8ef0f96f8c05e84b03dfd3da" translate="yes" xml:space="preserve">
          <source>Use this method to disable automatic scrolling.</source>
          <target state="translated">使用此方法可禁用自动滚动。</target>
        </trans-unit>
        <trans-unit id="b46c8e2625e9d1d564150470d764ef83f44ed6cd" translate="yes" xml:space="preserve">
          <source>Use this method to register work which should be performed when the injector is done loading all modules.</source>
          <target state="translated">使用此方法来注册当注入器完成所有模块的加载时应该执行的工作。</target>
        </trans-unit>
        <trans-unit id="e2c9ca4a68dc2a6884892d41b5a73fcdd5783521" translate="yes" xml:space="preserve">
          <source>Used for configuring routes.</source>
          <target state="translated">用于配置路由。</target>
        </trans-unit>
        <trans-unit id="1e20f817510e56e9b96cac2070c3e22126811c3b" translate="yes" xml:space="preserve">
          <source>Used for configuring the ARIA attributes injected and managed by ngAria.</source>
          <target state="translated">用于配置由ngAria注入和管理的ARIA属性。</target>
        </trans-unit>
        <trans-unit id="655c8e5a053e43f0c11ecfabef9bcc1912abfe26" translate="yes" xml:space="preserve">
          <source>Used for configuring the interpolation markup. Defaults to &lt;code&gt;{{&lt;/code&gt; and &lt;code&gt;}}&lt;/code&gt;.</source>
          <target state="translated">用于配置插值标记。默认为 &lt;code&gt;{{&lt;/code&gt; 和 &lt;code&gt;}}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1fb44e414995a58ae7d8e047aff02bcff4d56e5c" translate="yes" xml:space="preserve">
          <source>Used to configure the options passed to the &lt;a href=&quot;../service/%24http&quot;&gt;&lt;code&gt;$http&lt;/code&gt;&lt;/a&gt; service when making a template request.</source>
          <target state="translated">用于在发出模板请求时配置传递给&lt;a href=&quot;../service/%24http&quot;&gt; &lt;code&gt;$http&lt;/code&gt; &lt;/a&gt;服务的选项。</target>
        </trans-unit>
        <trans-unit id="e98fe6396bfb3427cbaf00c58b5487eb76c4659a" translate="yes" xml:space="preserve">
          <source>Used to configure the options passed to the &lt;a href=&quot;service/%24http&quot;&gt;&lt;code&gt;$http&lt;/code&gt;&lt;/a&gt; service when making a template request.</source>
          <target state="translated">用于在发出模板请求时配置传递给&lt;a href=&quot;service/%24http&quot;&gt; &lt;code&gt;$http&lt;/code&gt; &lt;/a&gt;服务的选项。</target>
        </trans-unit>
        <trans-unit id="1992cf3bd475bebb63dff75def762449cd8f0921" translate="yes" xml:space="preserve">
          <source>Used to get and set whether animations are enabled or not on the entire application or on an element and its children. This function can be called in four ways:</source>
          <target state="translated">用于获取和设置是否在整个应用程序或一个元素及其子元素上启用动画。该函数有四种调用方式。</target>
        </trans-unit>
        <trans-unit id="77ca86ada0f9252bb106a6e6efdbff01c4a20438" translate="yes" xml:space="preserve">
          <source>Using $animate in your directive code</source>
          <target state="translated">在你的指令代码中使用$animate</target>
        </trans-unit>
        <trans-unit id="613a81888b42fb0d4ca5df60f2f42af801bb1b12" translate="yes" xml:space="preserve">
          <source>Using $location</source>
          <target state="translated">使用$location</target>
        </trans-unit>
        <trans-unit id="27c0cbbddba59723567250ee8aaf043d300dad88" translate="yes" xml:space="preserve">
          <source>Using $location outside of the scope life-cycle</source>
          <target state="translated">在 scope 生命周期之外使用 $location。</target>
        </trans-unit>
        <trans-unit id="29169efc69847444ce3da0120339548bb93f2578" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;../api/ngaria&quot;&gt;ngAria&lt;/a&gt; is as simple as requiring the ngAria module in your application. ngAria hooks into standard AngularJS directives and quietly injects accessibility support into your application at runtime.</source>
          <target state="translated">使用&lt;a href=&quot;../api/ngaria&quot;&gt;ngAria&lt;/a&gt;就像在应用程序中需要ngAria模块一样简单。ngAria挂接到标准AngularJS指令，并在运行时悄悄地将可访问性支持注入您的应用程序。</target>
        </trans-unit>
        <trans-unit id="187503b822cc41efce6fddb7ffa2ed2aec83c324" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;controller as&lt;/code&gt; makes it obvious which controller you are accessing in the template when multiple controllers apply to an element.</source>
          <target state="translated">当多个控制器应用于一个元素时，使用 &lt;code&gt;controller as&lt;/code&gt; 可以很明显地在模板中访问哪个控制器。</target>
        </trans-unit>
        <trans-unit id="75fa788af800c949aecf96d72fda73c3d6a4da58" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;ngStrictDi&lt;/code&gt;, you would see something like this:</source>
          <target state="translated">使用 &lt;code&gt;ngStrictDi&lt;/code&gt; ，您将看到类似以下内容：</target>
        </trans-unit>
        <trans-unit id="618b214c025a81d4cdc55abe11cf88128651105c" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;select&lt;/code&gt;&lt;strong&gt;&lt;code&gt;as&lt;/code&gt;&lt;/strong&gt; will bind the result of the &lt;code&gt;select&lt;/code&gt; expression to the model, but the value of the &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;option&amp;gt;&lt;/code&gt; html elements will be either the index (for array data sources) or property name (for object data sources) of the value within the collection. If a &lt;strong&gt;&lt;code&gt;track by&lt;/code&gt;&lt;/strong&gt; expression is used, the result of that expression will be set as the value of the &lt;code&gt;option&lt;/code&gt; and &lt;code&gt;select&lt;/code&gt; elements.</source>
          <target state="translated">使用 &lt;code&gt;select&lt;/code&gt; &lt;strong&gt; &lt;code&gt;as&lt;/code&gt; &lt;/strong&gt;将 &lt;code&gt;select&lt;/code&gt; 表达式的结果绑定到模型，但是 &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt; 和 &lt;code&gt;&amp;lt;option&amp;gt;&lt;/code&gt; html元素的值将是索引（对于数组数据源）或属性名（对于对象数据源）集合中的值。如果使用&lt;strong&gt; &lt;code&gt;track by&lt;/code&gt; &lt;/strong&gt;表达式&lt;strong&gt;跟踪，&lt;/strong&gt;则该表达式的结果将设置为 &lt;code&gt;option&lt;/code&gt; 和 &lt;code&gt;select&lt;/code&gt; 元素的值。</target>
        </trans-unit>
        <trans-unit id="b48a3f6a40b09344260d8ec7bc24924a4a77ab6a" translate="yes" xml:space="preserve">
          <source>Using ARIA in HTML</source>
          <target state="translated">在HTML中使用ARIA</target>
        </trans-unit>
        <trans-unit id="c4171cbd1d6f3ea14fcb721dacfb4707975d43ea" translate="yes" xml:space="preserve">
          <source>Using AngularJS markup like &lt;code&gt;{{hash}}&lt;/code&gt; in a &lt;code&gt;src&lt;/code&gt; attribute doesn't work right: The browser will fetch from the URL with the literal text &lt;code&gt;{{hash}}&lt;/code&gt; until AngularJS replaces the expression inside &lt;code&gt;{{hash}}&lt;/code&gt;. The &lt;code&gt;ngSrc&lt;/code&gt; directive solves this problem.</source>
          <target state="translated">在 &lt;code&gt;src&lt;/code&gt; 属性中使用类似 &lt;code&gt;{{hash}}&lt;/code&gt; 的 AngularJS标记无法正常工作：浏览器将使用文本文本 &lt;code&gt;{{hash}}&lt;/code&gt; 从URL提取，直到AngularJS替换 &lt;code&gt;{{hash}}&lt;/code&gt; 中的表达式。该 &lt;code&gt;ngSrc&lt;/code&gt; 指令解决了这个问题。</target>
        </trans-unit>
        <trans-unit id="1544e2d4e4ae1fb37109d1352ffdb29d3bc70e81" translate="yes" xml:space="preserve">
          <source>Using AngularJS markup like &lt;code&gt;{{hash}}&lt;/code&gt; in a &lt;code&gt;srcset&lt;/code&gt; attribute doesn't work right: The browser will fetch from the URL with the literal text &lt;code&gt;{{hash}}&lt;/code&gt; until AngularJS replaces the expression inside &lt;code&gt;{{hash}}&lt;/code&gt;. The &lt;code&gt;ngSrcset&lt;/code&gt; directive solves this problem.</source>
          <target state="translated">在 &lt;code&gt;srcset&lt;/code&gt; 属性中使用类似 &lt;code&gt;{{hash}}&lt;/code&gt; 的 AngularJS标记无法正常工作：浏览器将使用文本文本 &lt;code&gt;{{hash}}&lt;/code&gt; 从URL获取，直到AngularJS替换 &lt;code&gt;{{hash}}&lt;/code&gt; 中的表达式。该 &lt;code&gt;ngSrcset&lt;/code&gt; 指令解决了这个问题。</target>
        </trans-unit>
        <trans-unit id="1c81f10b2e8d7a29e274525eca136b9b2754c57d" translate="yes" xml:space="preserve">
          <source>Using AngularJS markup like &lt;code&gt;{{hash}}&lt;/code&gt; in an href attribute will make the link go to the wrong URL if the user clicks it before AngularJS has a chance to replace the &lt;code&gt;{{hash}}&lt;/code&gt; markup with its value. Until AngularJS replaces the markup the link will be broken and will most likely return a 404 error. The &lt;code&gt;ngHref&lt;/code&gt; directive solves this problem.</source>
          <target state="translated">在href属性中使用 &lt;code&gt;{{hash}}&lt;/code&gt; 之类的AngularJS标记会使链接转到错误的URL（如果用户在AngularJS有机会用其值替换 &lt;code&gt;{{hash}}&lt;/code&gt; 标记之前单击链接）。在AngularJS替换标记之前，链接将断开，并且很可能会返回404错误。该 &lt;code&gt;ngHref&lt;/code&gt; 指令解决了这个问题。</target>
        </trans-unit>
        <trans-unit id="26651671e648d817c38c64754ab40d68a2c9123a" translate="yes" xml:space="preserve">
          <source>Using CSS classes</source>
          <target state="translated">使用CSS类</target>
        </trans-unit>
        <trans-unit id="22c59955943e9707b80f15aec8a1b0a32409db33" translate="yes" xml:space="preserve">
          <source>Using Dependency Injection</source>
          <target state="translated">使用依赖注入</target>
        </trans-unit>
        <trans-unit id="3f12d56b74c2eb2c6b5988dda7a6704cc676d3d4" translate="yes" xml:space="preserve">
          <source>Using Factory recipes, you can also define AngularJS's filters and animations, but the controllers are a bit special. You create a controller as a custom type that declares its dependencies as arguments for its constructor function. This constructor is then registered with a module. Let's take a look at the &lt;code&gt;DemoController&lt;/code&gt;, created in one of the early examples:</source>
          <target state="translated">使用Factory配方，您还可以定义AngularJS的过滤器和动画，但是控制器有些特殊。您将控制器创建为自定义类型，该控制器将其依赖项声明为其构造函数的参数。然后，此构造函数将在模块中注册。让我们看一下在早期示例之一中创建的 &lt;code&gt;DemoController&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="142274a4bb4939c13a749da4226dd8927425fd22" translate="yes" xml:space="preserve">
          <source>Using Local Caches</source>
          <target state="translated">使用本地缓存</target>
        </trans-unit>
        <trans-unit id="e8729bc93021a2e5283ed88952093ee0c9a0a8f3" translate="yes" xml:space="preserve">
          <source>Using Protractor</source>
          <target state="translated">使用量角器</target>
        </trans-unit>
        <trans-unit id="cf6f695a6a43d5695aeb78a9aefcac36d5324914" translate="yes" xml:space="preserve">
          <source>Using Strict Dependency Injection</source>
          <target state="translated">使用严格的依赖注入</target>
        </trans-unit>
        <trans-unit id="9e041c266624208fa4e65afd24d87690238c5434" translate="yes" xml:space="preserve">
          <source>Using a Service</source>
          <target state="translated">使用服务</target>
        </trans-unit>
        <trans-unit id="1870160824edb5f5d781284d76bb684b36c8a3ae" translate="yes" xml:space="preserve">
          <source>Using a custom comparator</source>
          <target state="translated">使用自定义比较器</target>
        </trans-unit>
        <trans-unit id="1513de7002759ec420dfa96ea93dd443a199efcb" translate="yes" xml:space="preserve">
          <source>Using an element for the &lt;code&gt;myCustomer&lt;/code&gt; directive is clearly the right choice because you're not decorating an element with some &quot;customer&quot; behavior; you're defining the core behavior of the element as a customer component.</source>
          <target state="translated">为 &lt;code&gt;myCustomer&lt;/code&gt; 指令使用元素显然是正确的选择，因为您没有以某种&amp;ldquo;客户&amp;rdquo;行为来装饰元素。您正在将元素的核心行为定义为客户组件。</target>
        </trans-unit>
        <trans-unit id="0b7f582cdde801c5eb7ccd1f5f093fd2b744221d" translate="yes" xml:space="preserve">
          <source>Using beforeAll()</source>
          <target state="translated">使用 beforeAll()</target>
        </trans-unit>
        <trans-unit id="3bf81a946b8d6c54f33bc47f1e13b86d15e48e46" translate="yes" xml:space="preserve">
          <source>Using filters in controllers, services, and directives</source>
          <target state="translated">在控制器、服务和指令中使用过滤器。</target>
        </trans-unit>
        <trans-unit id="e5733313ce1e48569bbeb7efa880f179d91eb616" translate="yes" xml:space="preserve">
          <source>Using filters in view templates</source>
          <target state="translated">在视图模板中使用过滤器</target>
        </trans-unit>
        <trans-unit id="77968546fbbe30427c877e1f02f60fd695c65843" translate="yes" xml:space="preserve">
          <source>Using interceptors</source>
          <target state="translated">使用拦截器</target>
        </trans-unit>
        <trans-unit id="ebf3d55846a7cd7f43e5f8cb0e431673ff8d2495" translate="yes" xml:space="preserve">
          <source>Using ngAria</source>
          <target state="translated">使用ngAria</target>
        </trans-unit>
        <trans-unit id="0f90dda5b5582c6398d02b0a5b0ebe328da00024" translate="yes" xml:space="preserve">
          <source>Using ngDisabled with ngAria:</source>
          <target state="translated">用ngAria使用ngDisabled。</target>
        </trans-unit>
        <trans-unit id="1937d07736980fa1e1cf14044c2d1eaa38088d68" translate="yes" xml:space="preserve">
          <source>Using ngRepeat to generate select options</source>
          <target state="translated">使用ngRepeat生成选择选项</target>
        </trans-unit>
        <trans-unit id="5f900837ceda875bf4c544ccac4d6058c4d6e857" translate="yes" xml:space="preserve">
          <source>Using ngValue to bind the model to an array of objects</source>
          <target state="translated">使用ngValue将模型绑定到对象数组上</target>
        </trans-unit>
        <trans-unit id="175501655ff7f1694fc035936c74e9c893e388e0" translate="yes" xml:space="preserve">
          <source>Using orderBy inside a controller</source>
          <target state="translated">在控制器中使用orderBy</target>
        </trans-unit>
        <trans-unit id="e38d72e573ba15e9d4f27541cef1ca49dafb855c" translate="yes" xml:space="preserve">
          <source>Using select with ngOptions and setting a default value</source>
          <target state="translated">使用ngOptions选择并设置默认值</target>
        </trans-unit>
        <trans-unit id="0726f73ae0c0e6e634886be4cf9fd3ceb9cfeaff" translate="yes" xml:space="preserve">
          <source>Using strict di mode in your production application will throw errors when an injectable function is not &lt;a href=&quot;di#dependency-annotation.html&quot;&gt;annotated explicitly&lt;/a&gt;. Strict di mode is intended to help you make sure that your code will work when minified. However, it also will force you to make sure that your injectable functions are explicitly annotated which will improve angular's performance when injecting dependencies in your injectable functions because it doesn't have to dynamically discover a function's dependencies. It is recommended to automate the explicit annotation via a tool like &lt;a href=&quot;https://github.com/olov/ng-annotate&quot;&gt;ng-annotate&lt;/a&gt; when you deploy to production (and enable strict di mode)</source>
          <target state="translated">如果未&lt;a href=&quot;di#dependency-annotation.html&quot;&gt;显式注释&lt;/a&gt;可注入函数，则在生产应用程序中使用严格的di模式将引发错误。严格的di模式旨在帮助您确保代码最小化。但是，这也将迫使您确保对可注入函数进行显式注释，这将在向可注入函数中注入依赖项时提高angular的性能，因为它不必动态发现函数的依赖项。建议在部署到生产环境时通过&lt;a href=&quot;https://github.com/olov/ng-annotate&quot;&gt;ng-annotate之&lt;/a&gt;类的工具自动执行显式注释（并启用严格的di模式）</target>
        </trans-unit>
        <trans-unit id="9c094e712cb148afcafcaaa4238f6b76abc53b26" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;$inject&lt;/code&gt; property annotation</source>
          <target state="translated">使用 &lt;code&gt;$inject&lt;/code&gt; 属性注释</target>
        </trans-unit>
        <trans-unit id="cc139db8875164b29e6054bd8d872efa13f3e432" translate="yes" xml:space="preserve">
          <source>Using the inline array annotation (preferred)</source>
          <target state="translated">使用内联数组注解(首选)</target>
        </trans-unit>
        <trans-unit id="a32ba4858e6ecdf40bb878f10445086068b003aa" translate="yes" xml:space="preserve">
          <source>Using this mode requires URL rewriting on server side, basically you have to rewrite all your links to entry point of your application (e.g. index.html). Requiring a &lt;code&gt;&amp;lt;base&amp;gt;&lt;/code&gt; tag is also important for this case, as it allows AngularJS to differentiate between the part of the url that is the application base and the path that should be handled by the application.</source>
          <target state="translated">使用此模式需要在服务器端重写URL，基本上，您必须重写指向应用程序入口点的所有链接（例如index.html）。在这种情况下，需要 &lt;code&gt;&amp;lt;base&amp;gt;&lt;/code&gt; 标记也很重要，因为它允许AngularJS区分作为应用程序基础的url部分和应由应用程序处理的路径。</target>
        </trans-unit>
        <trans-unit id="dd90e467c164134d79cd404122f3459c75ef6850" translate="yes" xml:space="preserve">
          <source>Using your favorite element inspector, look for attributes added by ngAria in your own code.</source>
          <target state="translated">使用你喜欢的元素检查器,在你自己的代码中寻找ngAria添加的属性。</target>
        </trans-unit>
        <trans-unit id="a66911e37d51e0c3a3a47af728e0570297be65e2" translate="yes" xml:space="preserve">
          <source>Usually, it's not necessary to write to properties in AngularJS, as the built-in directives handle the most common use cases (instead of the above example, you would use &lt;a href=&quot;ngvalue&quot;&gt;&lt;code&gt;ngValue&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">通常，没有必要在AngularJS中写入属性，因为内置指令处理最常见的用例（而不是上面的示例，您将使用&lt;a href=&quot;ngvalue&quot;&gt; &lt;code&gt;ngValue&lt;/code&gt; &lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="9117e3d156ca57a740fa2681f3cbe9bcb779f7cd" translate="yes" xml:space="preserve">
          <source>Usually, you don't call &lt;code&gt;$digest()&lt;/code&gt; directly in &lt;a href=&quot;../directive/ngcontroller&quot;&gt;controllers&lt;/a&gt; or in &lt;a href=&quot;../provider/%24compileprovider#directive.html&quot;&gt;directives&lt;/a&gt;. Instead, you should call &lt;a href=&quot;%24rootscope.scope#%24apply.html&quot;&gt;$apply()&lt;/a&gt; (typically from within a &lt;a href=&quot;../provider/%24compileprovider#directive.html&quot;&gt;directive&lt;/a&gt;), which will force a &lt;code&gt;$digest()&lt;/code&gt;.</source>
          <target state="translated">通常，您不会直接在&lt;a href=&quot;../directive/ngcontroller&quot;&gt;控制器&lt;/a&gt;或&lt;a href=&quot;../provider/%24compileprovider#directive.html&quot;&gt;指令中&lt;/a&gt;调用 &lt;code&gt;$digest()&lt;/code&gt; 。相反，您应该调用&lt;a href=&quot;%24rootscope.scope#%24apply.html&quot;&gt;$ apply（）&lt;/a&gt;（通常从&lt;a href=&quot;../provider/%24compileprovider#directive.html&quot;&gt;指令内部&lt;/a&gt;），这将强制使用 &lt;code&gt;$digest()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="dd74d182c641e4c78502d863b44d0aeff1575e54" translate="yes" xml:space="preserve">
          <source>Validation</source>
          <target state="translated">Validation</target>
        </trans-unit>
        <trans-unit id="8dce170de238b1feda2ecd9674ea3ca0d068fbcb" translate="yes" xml:space="preserve">
          <source>Value</source>
          <target state="translated">Value</target>
        </trans-unit>
        <trans-unit id="5cff1d4dcbaa6169803c618f64323129b1539f3d" translate="yes" xml:space="preserve">
          <source>Value Recipe</source>
          <target state="translated">超值配方</target>
        </trans-unit>
        <trans-unit id="c113bc7c7f7db6557f503b649e374f64b15937e5" translate="yes" xml:space="preserve">
          <source>Value for this literal. All literal values must be primitives or &lt;code&gt;undefined&lt;/code&gt;.</source>
          <target state="translated">此文字的值。所有文字值都必须是原语或 &lt;code&gt;undefined&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="48274bf7792e3199e036a65ed34f449dc89eaf60" translate="yes" xml:space="preserve">
          <source>Value may be:</source>
          <target state="translated">价值可能是:</target>
        </trans-unit>
        <trans-unit id="5c7b89964a32b7847cc384c42d59157b6aa66118" translate="yes" xml:space="preserve">
          <source>Value or a promise</source>
          <target state="translated">价值或承诺</target>
        </trans-unit>
        <trans-unit id="6c81a08fcf7fb2e50a04e9b948fa82e0ea17df4a" translate="yes" xml:space="preserve">
          <source>Value services are similar to constant services, except that they cannot be injected into a module configuration function (see &lt;a href=&quot;../../ng/type/angular.module#config.html&quot;&gt;&lt;code&gt;angular.Module&lt;/code&gt;&lt;/a&gt;) but they can be overridden by an AngularJS &lt;a href=&quot;%24provide#decorator.html&quot;&gt;decorator&lt;/a&gt;.</source>
          <target state="translated">值服务类似于常量服务，不同之处在于它们不能被注入模块配置函数（请参见&lt;a href=&quot;../../ng/type/angular.module#config.html&quot;&gt; &lt;code&gt;angular.Module&lt;/code&gt; &lt;/a&gt;），但是可以被AngularJS &lt;a href=&quot;%24provide#decorator.html&quot;&gt;装饰器&lt;/a&gt;覆盖。</target>
        </trans-unit>
        <trans-unit id="3aa197e2c8a5fb13e9b7816824a89f4b3c5b3507" translate="yes" xml:space="preserve">
          <source>Value stabilization algorithm</source>
          <target state="translated">价值稳定算法</target>
        </trans-unit>
        <trans-unit id="6c469ec6aaa554802630547915725303bf8f8b8f" translate="yes" xml:space="preserve">
          <source>Value to be stored.</source>
          <target state="translated">要存储的值。</target>
        </trans-unit>
        <trans-unit id="605788684850e8a238a8726e1a0cb4c5099a9922" translate="yes" xml:space="preserve">
          <source>Value to set the attribute to. The value can be an interpolated string.</source>
          <target state="translated">设置属性的值。该值可以是一个内插的字符串。</target>
        </trans-unit>
        <trans-unit id="19de69cb601f53a4ea7af22a65c71ae63251365c" translate="yes" xml:space="preserve">
          <source>Variable</source>
          <target state="translated">Variable</target>
        </trans-unit>
        <trans-unit id="a47ec135f296824132839931bbbe778322d52156" translate="yes" xml:space="preserve">
          <source>Verifies that all of the requests defined via the &lt;code&gt;expect&lt;/code&gt; api were made. If any of the requests were not made, verifyNoOutstandingExpectation throws an exception.</source>
          <target state="translated">验证所有通过定义的请求的 &lt;code&gt;expect&lt;/code&gt; API作了。如果未发出任何请求，则verifyNoOutstandingExpectation会引发异常。</target>
        </trans-unit>
        <trans-unit id="2b0950bdfc9c6382c1d7d6a757ca980cb3de9e74" translate="yes" xml:space="preserve">
          <source>Verifies that there are no outstanding requests that need to be flushed.</source>
          <target state="translated">核查是否有需要冲刷的未决请求。</target>
        </trans-unit>
        <trans-unit id="d7f325a18a825f860634333d989a1d777ced5162" translate="yes" xml:space="preserve">
          <source>Verifies that there are no pending tasks that need to be flushed. It throws an error if there are still pending tasks.</source>
          <target state="translated">验证是否没有需要刷新的待处理任务。如果仍有待处理的任务,则会抛出错误。</target>
        </trans-unit>
        <trans-unit id="7c6656dc823a752a3eb9bcea6c50275b8cfac7b8" translate="yes" xml:space="preserve">
          <source>Via CSS styles: overwriting styles in the ng-animate CSS class</source>
          <target state="translated">通过CSS样式:覆盖ng-animate CSS类中的样式。</target>
        </trans-unit>
        <trans-unit id="56b71e89fb1079caaadefd0889e9a22e8b0560e3" translate="yes" xml:space="preserve">
          <source>Videos</source>
          <target state="translated">Videos</target>
        </trans-unit>
        <trans-unit id="aa76b6711f0b6f7b9b50c7a4cf8c5e8df5a2790e" translate="yes" xml:space="preserve">
          <source>Videos:</source>
          <target state="translated">Videos:</target>
        </trans-unit>
        <trans-unit id="69bd4ef9fbd0894a22759c3766b859defbdedbc8" translate="yes" xml:space="preserve">
          <source>View</source>
          <target state="translated">View</target>
        </trans-unit>
        <trans-unit id="8a0159fc319678e56cbe357335bec37e3f693d44" translate="yes" xml:space="preserve">
          <source>View &amp;mdash; The template (HTML with data bindings) that is rendered into the View.</source>
          <target state="translated">视图&amp;mdash;呈现到视图中的模板（带有数据绑定的HTML）。</target>
        </trans-unit>
        <trans-unit id="a0f83aaccc440d1cf25ada9bc1856e7eb2641833" translate="yes" xml:space="preserve">
          <source>View-independent business logic: Services</source>
          <target state="translated">独立于视图的业务逻辑。服务</target>
        </trans-unit>
        <trans-unit id="80fbd7d99df33af15d63e1fddfb91adaa3951721" translate="yes" xml:space="preserve">
          <source>Views and routes (see the example)</source>
          <target state="translated">视图和路线(见示例)</target>
        </trans-unit>
        <trans-unit id="346631241a6bd165883391eb2bf20f0dac472e27" translate="yes" xml:space="preserve">
          <source>W3C Accessibility Testing</source>
          <target state="translated">W3C无障碍测试</target>
        </trans-unit>
        <trans-unit id="6173f8eb0b947a810d1db5e56255e90b7667262d" translate="yes" xml:space="preserve">
          <source>Watch and observe the URL.</source>
          <target state="translated">看着观察网址。</target>
        </trans-unit>
        <trans-unit id="3db346c9726b530d1a2ae4cfb73287c8e81c97cc" translate="yes" xml:space="preserve">
          <source>Watching &lt;em&gt;by reference&lt;/em&gt; (&lt;a href=&quot;../api/ng/type/%24rootscope.scope#%24watch.html&quot;&gt;scope.$watch&lt;/a&gt;&lt;code&gt;(watchExpression, listener)&lt;/code&gt;) detects a change when the whole value returned by the watch expression switches to a new value. If the value is an array or an object, changes inside it are not detected. This is the most efficient strategy.</source>
          <target state="translated">观看&lt;em&gt;通过引用&lt;/em&gt;（&lt;a href=&quot;../api/ng/type/%24rootscope.scope#%24watch.html&quot;&gt;范围。$手表&lt;/a&gt; &lt;code&gt;(watchExpression, listener)&lt;/code&gt; ）检测到变化时的钟表表达式返回的整个值切换到一个新的值。如果值是数组或对象，则不会检测到其内部的更改。这是最有效的策略。</target>
        </trans-unit>
        <trans-unit id="473a9c40eedd5fb0f115c451dd30526bd2c650ad" translate="yes" xml:space="preserve">
          <source>Watching &lt;em&gt;by value&lt;/em&gt; (&lt;a href=&quot;../api/ng/type/%24rootscope.scope#%24watch.html&quot;&gt;scope.$watch&lt;/a&gt;&lt;code&gt;(watchExpression, listener, true)&lt;/code&gt;) detects any change in an arbitrarily nested data structure. It is the most powerful change detection strategy, but also the most expensive. A full traversal of the nested data structure is needed on each digest, and a full copy of it needs to be held in memory.</source>
          <target state="translated">看&lt;em&gt;由值&lt;/em&gt;（&lt;a href=&quot;../api/ng/type/%24rootscope.scope#%24watch.html&quot;&gt;范围。$手表&lt;/a&gt; &lt;code&gt;(watchExpression, listener, true)&lt;/code&gt; ）检测在任意嵌套的数据结构的任何改变。它是最强大的变更检测策略，但也是最昂贵的。每个摘要都需要对嵌套数据结构进行完整遍历，并且需要将其完整副本保留在内存中。</target>
        </trans-unit>
        <trans-unit id="2af6bb4a94b9a1cb0fd67c6d5fc0095196e94650" translate="yes" xml:space="preserve">
          <source>Watching &lt;em&gt;collection contents&lt;/em&gt; (&lt;a href=&quot;../api/ng/type/%24rootscope.scope#%24watchCollection.html&quot;&gt;scope.$watchCollection&lt;/a&gt;&lt;code&gt;(watchExpression, listener)&lt;/code&gt;) detects changes that occur inside an array or an object: When items are added, removed, or reordered. The detection is shallow - it does not reach into nested collections. Watching collection contents is more expensive than watching by reference, because copies of the collection contents need to be maintained. However, the strategy attempts to minimize the amount of copying required.</source>
          <target state="translated">看&lt;em&gt;收集内容&lt;/em&gt;（&lt;a href=&quot;../api/ng/type/%24rootscope.scope#%24watchCollection.html&quot;&gt;。范围$ watchCollection &lt;/a&gt; &lt;code&gt;(watchExpression, listener)&lt;/code&gt; ）检测的阵列或对象内所发生的变化：当添加的物品，移除或重新排序。检测很浅-不会进入嵌套集合。观看收藏内容比通过参考观看要贵得多，因为需要维护收藏内容的副本。但是，该策略试图使所需的复制量最小化。</target>
        </trans-unit>
        <trans-unit id="e57f32a79f955dc80e7b98c93ef9c5dff9e8992b" translate="yes" xml:space="preserve">
          <source>We also &lt;strong&gt;must&lt;/strong&gt; include animations for the views that are being entered and removed (otherwise anchoring wouldn't be possible since the new view would be inserted right away).</source>
          <target state="translated">我们还&lt;strong&gt;必须&lt;/strong&gt;为要输入和删除的视图添加动画（否则将无法进行锚定，因为将立即插入新视图）。</target>
        </trans-unit>
        <trans-unit id="48d50b84720d06df376f308744283f116a6daf37" translate="yes" xml:space="preserve">
          <source>We also changed all expressions in the page to read and write variables within that controller instance by prefixing them with &lt;code&gt;invoice.&lt;/code&gt; . The possible currencies are defined in the controller and added to the template using &lt;a href=&quot;../api/ng/directive/ngrepeat&quot;&gt;&lt;code&gt;ng-repeat&lt;/code&gt;&lt;/a&gt;. As the controller contains a &lt;code&gt;total&lt;/code&gt; function we are also able to bind the result of that function to the DOM using &lt;code&gt;{{ invoice.total(...) }}&lt;/code&gt;.</source>
          <target state="translated">我们还更改了页面中的所有表达式，以在控制器实例中通过在其前面加上 &lt;code&gt;invoice.&lt;/code&gt; 变量来读写变量。。可能的货币在控制器中定义，并使用&lt;a href=&quot;../api/ng/directive/ngrepeat&quot;&gt; &lt;code&gt;ng-repeat&lt;/code&gt; &lt;/a&gt;添加到模板中。由于控制器包含一个 &lt;code&gt;total&lt;/code&gt; 函数，因此我们也可以使用 &lt;code&gt;{{ invoice.total(...) }}&lt;/code&gt; 将该函数的结果绑定到DOM 。</target>
        </trans-unit>
        <trans-unit id="e45e195299e27595cc434211c5af3181e81a8bd7" translate="yes" xml:space="preserve">
          <source>We are now ready to launch unicorns, but notice that UnicornLauncher depends on our &lt;code&gt;apiToken&lt;/code&gt;. We can satisfy this dependency on &lt;code&gt;apiToken&lt;/code&gt; using the Factory recipe:</source>
          <target state="translated">我们现在可以启动独角兽了，但是请注意UnicornLauncher取决于我们的 &lt;code&gt;apiToken&lt;/code&gt; 。我们可以使用Factory配方满足对 &lt;code&gt;apiToken&lt;/code&gt; 的依赖：</target>
        </trans-unit>
        <trans-unit id="ac1ea31a9d43166687a50ed3692e05ce4153dc7a" translate="yes" xml:space="preserve">
          <source>We are using the &lt;a href=&quot;../service/%24sce&quot;&gt;$sce&lt;/a&gt; service here and include the &lt;a href=&quot;../../ngsanitize&quot;&gt;$sanitize&lt;/a&gt; module to automatically remove &quot;bad&quot; content like inline event listener (e.g. &lt;code&gt;&amp;lt;span onclick=&quot;...&quot;&amp;gt;&lt;/code&gt;). However, as we are using &lt;code&gt;$sce&lt;/code&gt; the model can still decide to provide unsafe content if it marks that content using the &lt;code&gt;$sce&lt;/code&gt; service.</source>
          <target state="translated">我们在这里使用&lt;a href=&quot;../service/%24sce&quot;&gt;$ sce&lt;/a&gt;服务，并包括&lt;a href=&quot;../../ngsanitize&quot;&gt;$ sanitize&lt;/a&gt;模块来自动删除&amp;ldquo;不良&amp;rdquo;内容，例如内联事件监听器（例如 &lt;code&gt;&amp;lt;span onclick=&quot;...&quot;&amp;gt;&lt;/code&gt; ）。但是，当我们使用 &lt;code&gt;$sce&lt;/code&gt; ，如果模型使用 &lt;code&gt;$sce&lt;/code&gt; 服务标记了不安全的内容，则该模型仍可以决定提供不安全的内容。</target>
        </trans-unit>
        <trans-unit id="0ddbe3412df53532770a5870b95d26cf007568fd" translate="yes" xml:space="preserve">
          <source>We attach our controller to the DOM using the &lt;code&gt;ng-controller&lt;/code&gt; directive. The &lt;code&gt;greeting&lt;/code&gt; property can now be data-bound to the template:</source>
          <target state="translated">我们使用 &lt;code&gt;ng-controller&lt;/code&gt; 指令将控制器附加到DOM 。现在， &lt;code&gt;greeting&lt;/code&gt; 属性可以绑定到模板：</target>
        </trans-unit>
        <trans-unit id="ddeae2cedf9a788113de391be2a82b5796c82f33" translate="yes" xml:space="preserve">
          <source>We can also make use of &lt;strong&gt;CSS Keyframes&lt;/strong&gt; by referencing the keyframe animation within the starting CSS class:</source>
          <target state="translated">我们还可以通过引用起始CSS类中的关键帧动画来使用&lt;strong&gt;CSS关键&lt;/strong&gt;帧：</target>
        </trans-unit>
        <trans-unit id="a40a9d552fb5bc988807680efe848c3a0e26cf2b" translate="yes" xml:space="preserve">
          <source>We can also make use of CSS keyframes by placing them within the CSS classes.</source>
          <target state="translated">我们也可以通过将CSS关键帧放在CSS类中来利用。</target>
        </trans-unit>
        <trans-unit id="844c06e399ab04678015537239ffb4d4f3dc9652" translate="yes" xml:space="preserve">
          <source>We can now attach a transition onto the &lt;code&gt;.banner.ng-anchor&lt;/code&gt; CSS class and then ngAnimate will handle the entire transition for us as well as the addition and removal of any changes of CSS classes between the elements:</source>
          <target state="translated">现在，我们可以将过渡添加到 &lt;code&gt;.banner.ng-anchor&lt;/code&gt; CSS类上，然后ngAnimate将为我们处理整个过渡以及在元素之间添加和删除CSS类的任何更改：</target>
        </trans-unit>
        <trans-unit id="4e80494b0409a0d993fa81a7d1f333388f5be423" translate="yes" xml:space="preserve">
          <source>We can show this by adding another property, &lt;code&gt;vojta&lt;/code&gt;, to our scope and trying to access it from within our directive's template:</source>
          <target state="translated">我们可以通过在我们的范围内添加另一个属性 &lt;code&gt;vojta&lt;/code&gt; 并尝试从指令的模板中访问它来显示这一点：</target>
        </trans-unit>
        <trans-unit id="fce0871e367a5372f3bc98dd4c0252dc8c77c3c6" translate="yes" xml:space="preserve">
          <source>We can specify functions to run at configuration and run time for a module by calling the &lt;code&gt;config&lt;/code&gt; and &lt;code&gt;run&lt;/code&gt; methods. These functions are injectable with dependencies just like the factory functions above.</source>
          <target state="translated">我们可以通过调用 &lt;code&gt;config&lt;/code&gt; 和 &lt;code&gt;run&lt;/code&gt; 方法来指定要在模块的配置和运行时运行的函数。这些函数可以注入依赖项，就像上面的工厂函数一样。</target>
        </trans-unit>
        <trans-unit id="e36459843d047d9df4a4211084dc5c402b38cf07" translate="yes" xml:space="preserve">
          <source>We can then use the component like this:</source>
          <target state="translated">我们就可以这样使用这个组件。</target>
        </trans-unit>
        <trans-unit id="21324a462f2b8d5e0c7c5b4446052c135414c236" translate="yes" xml:space="preserve">
          <source>We could then configure the unicornLauncherProvider like this:</source>
          <target state="translated">然后我们可以像这样配置unicornLauncherProvider。</target>
        </trans-unit>
        <trans-unit id="ac57f6df21dcb977cf78d72cfa768c34c7356753" translate="yes" xml:space="preserve">
          <source>We create an &lt;a href=&quot;module&quot;&gt;AngularJS Module&lt;/a&gt;, &lt;code&gt;myApp&lt;/code&gt;, for our application. Then we add the controller's constructor function to the module using the &lt;code&gt;.controller()&lt;/code&gt; method. This keeps the controller's constructor function out of the global scope.</source>
          <target state="translated">我们创建一个&lt;a href=&quot;module&quot;&gt;AngularJS模块&lt;/a&gt;， &lt;code&gt;myApp&lt;/code&gt; ，我们的应用程序。然后，使用 &lt;code&gt;.controller()&lt;/code&gt; 方法将控制器的构造函数添加到模块中。这使控制器的构造函数不属于全局范围。</target>
        </trans-unit>
        <trans-unit id="90dc4f28f2aa88baf0a0053350aecee511d1b878" translate="yes" xml:space="preserve">
          <source>We do our best to intercept calls to &quot;unimplemented&quot; methods, but since the list of methods is incomplete we might be missing some non-standard methods. This can result in errors like: &quot;Date.prototype.foo called on incompatible Object&quot;.</source>
          <target state="translated">我们尽力拦截对 &quot;未实现 &quot;方法的调用,但由于方法列表不完整,我们可能会遗漏一些非标准方法。这可能会导致错误,比如 &quot;Date.prototype.foo在不兼容的对象上被调用&quot;.</target>
        </trans-unit>
        <trans-unit id="e6fc82dc5284ffbf38ea98e85e63bcc39b7510a8" translate="yes" xml:space="preserve">
          <source>We have built &lt;a href=&quot;https://github.com/angular/protractor&quot;&gt;Protractor&lt;/a&gt;, an end to end test runner which simulates user interactions that will help you verify the health of your AngularJS application.</source>
          <target state="translated">我们已经构建了&lt;a href=&quot;https://github.com/angular/protractor&quot;&gt;Protractor&lt;/a&gt;，这是一个端到端的测试运行器，它可以模拟用户交互，从而帮助您验证AngularJS应用程序的运行状况。</target>
        </trans-unit>
        <trans-unit id="eff730b8cb2d8bb324e06d0e737eb8eccaed14f5" translate="yes" xml:space="preserve">
          <source>We have set up a guide to many resources provided by the community, where you can find lots of additional information and material on these topics, a list of complimentary libraries, and much more.</source>
          <target state="translated">我们为社区提供的许多资源设置了一个指南,在这里你可以找到许多关于这些主题的额外信息和材料,免费图书馆的列表,以及更多。</target>
        </trans-unit>
        <trans-unit id="ca17b1356cdf6d9a99a47902186386c56a19dd9d" translate="yes" xml:space="preserve">
          <source>We have used an &lt;strong&gt;inline injection annotation&lt;/strong&gt; to explicitly specify the dependency of the Controller on the &lt;code&gt;$scope&lt;/code&gt; service provided by AngularJS. See the guide on &lt;a href=&quot;di&quot;&gt;Dependency Injection&lt;/a&gt; for more information.</source>
          <target state="translated">我们使用了&lt;strong&gt;内联注入注释&lt;/strong&gt;来显式指定Controller对AngularJS提供的 &lt;code&gt;$scope&lt;/code&gt; 服务的依赖关系。有关更多信息，请参见&lt;a href=&quot;di&quot;&gt;依赖注入&lt;/a&gt;指南。</target>
        </trans-unit>
        <trans-unit id="9ca11f9dea4678a83cbe765017c379b901fb7de5" translate="yes" xml:space="preserve">
          <source>We inject the $compile service and $rootScope before each jasmine test. The $compile service is used to render the aGreatEye directive. After rendering the directive we ensure that the directive has replaced the content and &quot;lidless, wreathed in flame, 2 times&quot; is present.</source>
          <target state="translated">我们在每次jasmine测试前注入$compile服务和$rootScope。$compile服务用于渲染aGreatEye指令。在渲染指令后,我们确保指令已经替换了内容,并且 &quot;无睑,被火焰包围,2次 &quot;是存在的。</target>
        </trans-unit>
        <trans-unit id="ae572490bcf1a384d00d809014f9ef3a389a0f5d" translate="yes" xml:space="preserve">
          <source>We moved the &lt;code&gt;convertCurrency&lt;/code&gt; function and the definition of the existing currencies into the new file &lt;code&gt;finance2.js&lt;/code&gt;. But how does the controller get a hold of the now separated function?</source>
          <target state="translated">我们将 &lt;code&gt;convertCurrency&lt;/code&gt; 函数和现有货币的定义移至新文件 &lt;code&gt;finance2.js&lt;/code&gt; 中。但是控制器如何控制现在分离的功能？</target>
        </trans-unit>
        <trans-unit id="023a9b93224bd84cddfe8a629e03f8aa9c858380" translate="yes" xml:space="preserve">
          <source>We register an event &lt;code&gt;element.on('$destroy', ...)&lt;/code&gt;. What fires this &lt;code&gt;$destroy&lt;/code&gt; event?</source>
          <target state="translated">我们注册一个事件 &lt;code&gt;element.on('$destroy', ...)&lt;/code&gt; 。是什么触发此 &lt;code&gt;$destroy&lt;/code&gt; 事件？</target>
        </trans-unit>
        <trans-unit id="9d48b2c91f5a6af75293c06facac5a89ab2fa1aa" translate="yes" xml:space="preserve">
          <source>We saw earlier how to use &lt;code&gt;=attr&lt;/code&gt; in the &lt;code&gt;scope&lt;/code&gt; option, but in the above example, we're using &lt;code&gt;&amp;amp;attr&lt;/code&gt; instead. The &lt;code&gt;&amp;amp;&lt;/code&gt; binding allows a directive to trigger evaluation of an expression in the context of the original scope, at a specific time. Any legal expression is allowed, including an expression which contains a function call. Because of this, &lt;code&gt;&amp;amp;&lt;/code&gt; bindings are ideal for binding callback functions to directive behaviors.</source>
          <target state="translated">我们之前已经看到了如何在 &lt;code&gt;scope&lt;/code&gt; 选项中使用 &lt;code&gt;=attr&lt;/code&gt; ，但是在上面的示例中，我们使用的是 &lt;code&gt;&amp;amp;attr&lt;/code&gt; 。所述 &lt;code&gt;&amp;amp;&lt;/code&gt; 绑定允许一个指令以在原始范围的上下文中表达的触发评价，在特定的时间。允许使用任何合法表达式，包括包含函数调用的表达式。因此， &lt;code&gt;&amp;amp;&lt;/code&gt; 绑定是将回调函数绑定到指令行为的理想选择。</target>
        </trans-unit>
        <trans-unit id="d1926692f60d5568acf1d0bee7f667e3d7c0c99e" translate="yes" xml:space="preserve">
          <source>We want to run the function we pass by invoking it from the directive's scope, but have it run in the context of the scope where it's registered.</source>
          <target state="translated">我们希望通过从指令的作用域中调用函数来运行我们传递的函数,但要在它注册的作用域的上下文中运行。</target>
        </trans-unit>
        <trans-unit id="e8e0776ae3afa2fad60ff172ae662a5d77e9f6f7" translate="yes" xml:space="preserve">
          <source>We would expect AngularJS to be able to bind to this, but when we check the console we see something like &lt;code&gt;Error: Invalid value for attribute cx=&quot;{{cx}}&quot;&lt;/code&gt;. Because of the SVG DOM API's restrictions, you cannot simply write &lt;code&gt;cx=&quot;{{cx}}&quot;&lt;/code&gt;.</source>
          <target state="translated">我们希望AngularJS能够绑定到它，但是当我们检查控制台时，我们会看到类似 &lt;code&gt;Error: Invalid value for attribute cx=&quot;{{cx}}&quot;&lt;/code&gt; 。由于SVG DOM API的限制，您不能简单地编写 &lt;code&gt;cx=&quot;{{cx}}&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="252941e0a55657728f76a621bbe228cd9bed318b" translate="yes" xml:space="preserve">
          <source>We'll go over a few common examples of directives, then dive deep into the different options and compilation process.</source>
          <target state="translated">我们将介绍几个常见的指令示例,然后深入了解不同的选项和编译过程。</target>
        </trans-unit>
        <trans-unit id="3db74eddb5abe4c6d69ca5073939b2ffdcd30492" translate="yes" xml:space="preserve">
          <source>We've just learned how AngularJS splits the life-cycle into configuration phase and run phase and how you can provide configuration to your application via the config function. Since the config function runs in the configuration phase when no services are available, it doesn't have access even to simple value objects created via the Value recipe.</source>
          <target state="translated">我们刚刚学习了AngularJS如何将生命周期分为配置阶段和运行阶段,以及如何通过config函数为应用提供配置。由于config函数在配置阶段运行时没有服务,所以它甚至无法访问通过Value配方创建的简单值对象。</target>
        </trans-unit>
        <trans-unit id="e7c295f69a771afaeb6fd0ffad7c2c66be9dc3e3" translate="yes" xml:space="preserve">
          <source>We've moved the duplication out and into the &lt;code&gt;beforeEach&lt;/code&gt; block. Each individual test now only contains the code specific to that test, and not code that is general across all tests. As you expand your tests, keep an eye out for locations where you can use &lt;code&gt;beforeEach&lt;/code&gt; to tidy up tests. &lt;code&gt;beforeEach&lt;/code&gt; isn't the only function of this sort that Jasmine provides, and the &lt;a href=&quot;http://jasmine.github.io/1.3/introduction.html#section-Setup_and_Teardown&quot;&gt;documentation lists the others&lt;/a&gt;.</source>
          <target state="translated">我们已经将重复项移到了 &lt;code&gt;beforeEach&lt;/code&gt; 块中。现在，每个单独的测试仅包含特定于该测试的代码，而不包含所有测试中通用的代码。当你扩大你的测试，留意了地点，你可以使用 &lt;code&gt;beforeEach&lt;/code&gt; 收拾测试。 &lt;code&gt;beforeEach&lt;/code&gt; 并不是Jasmine提供的这种唯一功能，并且&lt;a href=&quot;http://jasmine.github.io/1.3/introduction.html#section-Setup_and_Teardown&quot;&gt;文档列出了其他功能&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a5f49816240da5c5e93a09a217e5e15251e2f600" translate="yes" xml:space="preserve">
          <source>We've seen that you can pass in models to a directive using the isolate scope, but sometimes it's desirable to be able to pass in an entire template rather than a string or an object. Let's say that we want to create a &quot;dialog box&quot; component. The dialog box should be able to wrap any arbitrary content.</source>
          <target state="translated">我们已经看到,你可以使用隔离作用域将模型传入指令,但有时希望能够传入整个模板,而不是一个字符串或一个对象。比方说,我们想创建一个 &quot;对话框 &quot;组件。对话框应该能够包裹任何任意的内容。</target>
        </trans-unit>
        <trans-unit id="abb1d6054f0ea55e7ce30bf24912bdf732c1589f" translate="yes" xml:space="preserve">
          <source>Web browsers are sometimes picky about what values they consider valid for attributes.</source>
          <target state="translated">Web浏览器有时会对他们认为有效的属性值进行挑剔。</target>
        </trans-unit>
        <trans-unit id="4f9f39d112f26b6b483e5752ed5019d0587ba101" translate="yes" xml:space="preserve">
          <source>WebAIM</source>
          <target state="translated">WebAIM</target>
        </trans-unit>
        <trans-unit id="216b85a80c0458fafdebd3ba9ff38b76e657305e" translate="yes" xml:space="preserve">
          <source>What are Directives?</source>
          <target state="translated">什么是指令?</target>
        </trans-unit>
        <trans-unit id="12c179e827df1ac7383cddb213d45ff08f32ebad" translate="yes" xml:space="preserve">
          <source>What are decorators?</source>
          <target state="translated">什么是装饰师?</target>
        </trans-unit>
        <trans-unit id="f9f442481556abfd102cc7155daba690e1a9a733" translate="yes" xml:space="preserve">
          <source>What changed?</source>
          <target state="translated">是什么改变了?</target>
        </trans-unit>
        <trans-unit id="6352305971f4abc98ce5ffab5abff8ed01207f3c" translate="yes" xml:space="preserve">
          <source>What changed? Our &lt;code&gt;currencyConverter&lt;/code&gt; service of the &lt;code&gt;finance&lt;/code&gt; module now uses the &lt;a href=&quot;../api/ng/service/%24http&quot;&gt;&lt;code&gt;$http&lt;/code&gt;&lt;/a&gt;, a built-in service provided by AngularJS for accessing a server backend. &lt;code&gt;$http&lt;/code&gt; is a wrapper around &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest&quot;&gt;&lt;code&gt;XMLHttpRequest&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;http://en.wikipedia.org/wiki/JSONP&quot;&gt;JSONP&lt;/a&gt; transports.</source>
          <target state="translated">发生了什么变化？现在，我们的 &lt;code&gt;finance&lt;/code&gt; 模块的 &lt;code&gt;currencyConverter&lt;/code&gt; 服务使用AngularJS提供的内置服务&lt;a href=&quot;../api/ng/service/%24http&quot;&gt; &lt;code&gt;$http&lt;/code&gt; &lt;/a&gt;来访问服务器后端。 &lt;code&gt;$http&lt;/code&gt; 是&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest&quot;&gt; &lt;code&gt;XMLHttpRequest&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;http://en.wikipedia.org/wiki/JSONP&quot;&gt;JSONP&lt;/a&gt;传输的包装。</target>
        </trans-unit>
        <trans-unit id="c9eedc43181be3fbaa803cb63186981f99ccc887" translate="yes" xml:space="preserve">
          <source>What does it not do?</source>
          <target state="translated">它不做什么?</target>
        </trans-unit>
        <trans-unit id="3cfacea0972e3e84df3a18186fd33468ca795ebb" translate="yes" xml:space="preserve">
          <source>What does this &lt;code&gt;transclude&lt;/code&gt; option do, exactly? &lt;code&gt;transclude&lt;/code&gt; makes the contents of a directive with this option have access to the scope &lt;strong&gt;outside&lt;/strong&gt; of the directive rather than inside.</source>
          <target state="translated">确切地说，这个 &lt;code&gt;transclude&lt;/code&gt; 选项有什么作用？ &lt;code&gt;transclude&lt;/code&gt; 使具有此选项的指令的内容可以访问指令&lt;strong&gt;外部&lt;/strong&gt;而不是内部的范围。</target>
        </trans-unit>
        <trans-unit id="ada0e0f2c7af87060d54e95e4a96fd7138d3489e" translate="yes" xml:space="preserve">
          <source>What is AngularJS?</source>
          <target state="translated">什么是AngularJS?</target>
        </trans-unit>
        <trans-unit id="447644911a568d0214e937333a19ccc004de8c3e" translate="yes" xml:space="preserve">
          <source>What is a Module?</source>
          <target state="translated">什么是模块?</target>
        </trans-unit>
        <trans-unit id="fe08c3c8244699c5a8b273b2cab8b4200356ffcb" translate="yes" xml:space="preserve">
          <source>What is a locale ID?</source>
          <target state="translated">什么是locale ID?</target>
        </trans-unit>
        <trans-unit id="beba7ea743f1dc2173ee282f653943a35f2a106b" translate="yes" xml:space="preserve">
          <source>What is ngMessageFormat?</source>
          <target state="translated">什么是ngMessageFormat?</target>
        </trans-unit>
        <trans-unit id="3943480da5771dbbb46c706aaaea42bf22c5390d" translate="yes" xml:space="preserve">
          <source>What is returned</source>
          <target state="translated">返回的内容</target>
        </trans-unit>
        <trans-unit id="fbe9fcf5a0f59f8dbc56de5c706eccfe1288f8b9" translate="yes" xml:space="preserve">
          <source>What trusted context types are supported?</source>
          <target state="translated">支持哪些可信上下文类型?</target>
        </trans-unit>
        <trans-unit id="a4e67c138282d3bd3498f65dbfecf946d52210e9" translate="yes" xml:space="preserve">
          <source>What we want to be able to do is separate the scope inside a directive from the scope outside, and then map the outer scope to a directive's inner scope. We can do this by creating what we call an &lt;strong&gt;isolate scope&lt;/strong&gt;. To do this, we can use a &lt;a href=&quot;../api/ng/service/%24compile#-scope-.html&quot;&gt;directive's &lt;code&gt;scope&lt;/code&gt;&lt;/a&gt; option:</source>
          <target state="translated">我们想要做的是将指令内部的作用域与外部作用域分开，然后将外部作用域映射到指令的内部作用域。我们可以通过创建&lt;strong&gt;隔离范围&lt;/strong&gt;来做到这一点。为此，我们可以使用&lt;a href=&quot;../api/ng/service/%24compile#-scope-.html&quot;&gt;指令的 &lt;code&gt;scope&lt;/code&gt; &lt;/a&gt;选项：</target>
        </trans-unit>
        <trans-unit id="be6b5657e71d140a3fc95978d677de4ea44df671" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;$animate&lt;/code&gt; is called it returns a promise that can be used to capture when the animation has ended. Therefore if we were to trigger an animation (within our directive code) then we can continue performing directive and scope related activities after the animation has ended by chaining onto the returned promise that animation method returns.</source>
          <target state="translated">当 &lt;code&gt;$animate&lt;/code&gt; 被称为它返回时，可以使用动画已经结束拍摄的承诺。因此，如果要触发动画（在指令代码内），则可以在动画结束后继续执行与指令和范围相关的活动，方法是链接到动画方法返回的承诺中。</target>
        </trans-unit>
        <trans-unit id="e5e660649c875315903afc08f2df11dfa21f3355" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;$setViewValue&lt;/code&gt; is called, the new &lt;code&gt;value&lt;/code&gt; will be staged for committing through the &lt;code&gt;$parsers&lt;/code&gt; and &lt;code&gt;$validators&lt;/code&gt; pipelines. If there are no special &lt;a href=&quot;../directive/ngmodeloptions&quot;&gt;&lt;code&gt;ngModelOptions&lt;/code&gt;&lt;/a&gt; specified then the staged value is sent directly for processing through the &lt;code&gt;$parsers&lt;/code&gt; pipeline. After this, the &lt;code&gt;$validators&lt;/code&gt; and &lt;code&gt;$asyncValidators&lt;/code&gt; are called and the value is applied to &lt;code&gt;$modelValue&lt;/code&gt;. Finally, the value is set to the &lt;strong&gt;expression&lt;/strong&gt; specified in the &lt;code&gt;ng-model&lt;/code&gt; attribute and all the registered change listeners, in the &lt;code&gt;$viewChangeListeners&lt;/code&gt; list are called.</source>
          <target state="translated">当 &lt;code&gt;$setViewValue&lt;/code&gt; 被调用时，新的 &lt;code&gt;value&lt;/code&gt; 将上演过犯 &lt;code&gt;$parsers&lt;/code&gt; 和 &lt;code&gt;$validators&lt;/code&gt; 管道。如果没有指定特殊的&lt;a href=&quot;../directive/ngmodeloptions&quot;&gt; &lt;code&gt;ngModelOptions&lt;/code&gt; ,&lt;/a&gt;则暂存值将直接通过 &lt;code&gt;$parsers&lt;/code&gt; 管道发送以进行处理。之后，将调用 &lt;code&gt;$validators&lt;/code&gt; 和 &lt;code&gt;$asyncValidators&lt;/code&gt; 并将该值应用于 &lt;code&gt;$modelValue&lt;/code&gt; 。最后，将该值设置为 &lt;code&gt;ng-model&lt;/code&gt; 属性中指定的&lt;strong&gt;表达式&lt;/strong&gt;，并调用 &lt;code&gt;$viewChangeListeners&lt;/code&gt; 列表中的所有已注册的更改侦听器。</target>
        </trans-unit>
        <trans-unit id="15cbb91f0e77da9c30b5e74feba1ad5742a72dcd" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;objectEquality == true&lt;/code&gt;, inequality of the &lt;code&gt;watchExpression&lt;/code&gt; is determined according to the &lt;a href=&quot;../function/angular.equals&quot;&gt;&lt;code&gt;angular.equals&lt;/code&gt;&lt;/a&gt; function. To save the value of the object for later comparison, the &lt;a href=&quot;../function/angular.copy&quot;&gt;&lt;code&gt;angular.copy&lt;/code&gt;&lt;/a&gt; function is used. This therefore means that watching complex objects will have adverse memory and performance implications.</source>
          <target state="translated">当 &lt;code&gt;objectEquality == true&lt;/code&gt; ，所述的不等式 &lt;code&gt;watchExpression&lt;/code&gt; 根据确定&lt;a href=&quot;../function/angular.equals&quot;&gt; &lt;code&gt;angular.equals&lt;/code&gt; &lt;/a&gt;功能。为了保存对象的值以供以后比较，使用了&lt;a href=&quot;../function/angular.copy&quot;&gt; &lt;code&gt;angular.copy&lt;/code&gt; &lt;/a&gt;函数。因此，这意味着观看复杂的对象将对内存和性能产生不利影响。</target>
        </trans-unit>
        <trans-unit id="8ce2cc0dab402897ec4863ce029e781d2d6d52fb" translate="yes" xml:space="preserve">
          <source>When AngularJS compiles the HTML, it processes the &lt;code&gt;ng-controller&lt;/code&gt; directive, which in turn asks the injector to create an instance of the controller and its dependencies.</source>
          <target state="translated">当AngularJS编译HTML时，它会处理 &lt;code&gt;ng-controller&lt;/code&gt; 指令，该指令又要求注入器创建控制器及其依赖项的实例。</target>
        </trans-unit>
        <trans-unit id="ec9b10f946fc02c68139f8c80da5ef591eb2ef7e" translate="yes" xml:space="preserve">
          <source>When AngularJS evaluates &lt;code&gt;{{name}}&lt;/code&gt;, it first looks at the scope associated with the given element for the &lt;code&gt;name&lt;/code&gt; property. If no such property is found, it searches the parent scope and so on until the root scope is reached. In JavaScript this behavior is known as prototypical inheritance, and child scopes prototypically inherit from their parents.</source>
          <target state="translated">当AngularJS评估 &lt;code&gt;{{name}}&lt;/code&gt; 时，它首先查看与给定元素关联的 &lt;code&gt;name&lt;/code&gt; 属性的范围。如果找不到这样的属性，它将搜索父范围，依此类推，直到达到根范围为止。在JavaScript中，此行为称为原型继承，子作用域原型也从其父级继承。</target>
        </trans-unit>
        <trans-unit id="51c935ad5701756b22938226bcc6b67e883b4629" translate="yes" xml:space="preserve">
          <source>When DOM elements are re-used, ngRepeat updates the scope for the element, which will automatically update any active bindings on the template. However, other functionality will not be updated, because the element is not re-created:</source>
          <target state="translated">当DOM元素被重新使用时,ngRepeat会更新该元素的作用域,从而自动更新模板上的任何活动绑定。然而,其他功能不会被更新,因为元素没有被重新创建。</target>
        </trans-unit>
        <trans-unit id="185ed32d1839cf6b6b86790a50f091c5cad18d3a" translate="yes" xml:space="preserve">
          <source>When a &lt;code&gt;replace&lt;/code&gt; directive encounters the same attribute on the original and the replace node, it will simply deduplicate the attribute and join the values with a space or with a &lt;code&gt;;&lt;/code&gt; in case of the &lt;code&gt;style&lt;/code&gt; attribute.</source>
          <target state="translated">当 &lt;code&gt;replace&lt;/code&gt; 指令在原始节点和replace节点上遇到相同的属性时，它将简单地对属性进行重复数据删除，并使用空格或 &lt;code&gt;;&lt;/code&gt; 将值连接在一起。如果是 &lt;code&gt;style&lt;/code&gt; 属性。</target>
        </trans-unit>
        <trans-unit id="5c230d77dd585240729675f16f4ddd67901e2eba" translate="yes" xml:space="preserve">
          <source>When a directive requests transclusion, the compiler extracts its contents and provides a &lt;strong&gt;transclusion function&lt;/strong&gt; to the directive's &lt;code&gt;link&lt;/code&gt; function and &lt;code&gt;controller&lt;/code&gt;. This transclusion function is a special &lt;strong&gt;linking function&lt;/strong&gt; that will return the compiled contents linked to a new transclusion scope.</source>
          <target state="translated">当指令请求包含时，编译器将提取其内容，并将&lt;strong&gt;包含功能&lt;/strong&gt;提供给该指令的 &lt;code&gt;link&lt;/code&gt; 函数和 &lt;code&gt;controller&lt;/code&gt; 。此包含函数是一个特殊的&lt;strong&gt;链接函数&lt;/strong&gt;，它将返回链接到新的包含范围的已编译内容。</target>
        </trans-unit>
        <trans-unit id="27ba11fbb2203f0c5d97308aa2a93fd81f5c7f9e" translate="yes" xml:space="preserve">
          <source>When a user clicks on this link,</source>
          <target state="translated">当用户点击这个链接时。</target>
        </trans-unit>
        <trans-unit id="fbf62f2a97f03d4ac746191d9d45dd4869d7d443" translate="yes" xml:space="preserve">
          <source>When an &lt;code&gt;offset&lt;/code&gt; is specified, the matching works as follows. First, the exact value of the AngularJS expression is matched against the exact matches (i.e. &lt;code&gt;=N&lt;/code&gt; selectors) to find a match. If there is one, that message is used. If there was no match, then the offset value is subtracted from the value of the expression and locale specific pluralization rules are applied to this new value to obtain its plural category (such as &amp;ldquo;one&amp;rdquo;, &amp;ldquo;few&amp;rdquo;, &amp;ldquo;many&amp;rdquo;, etc.) and a match is attempted against the keyword selectors and the matching message is used. If there was no match, then the &amp;ldquo;other&amp;rdquo; category (required) is used. The value of the &lt;code&gt;#&lt;/code&gt; character inside a message is the value of original expression reduced by the offset value that was specified.</source>
          <target state="translated">当 &lt;code&gt;offset&lt;/code&gt; 被指定时，所述匹配的工作原理如下。首先，将AngularJS表达式的精确值与精确匹配项（即 &lt;code&gt;=N&lt;/code&gt; 选择器）进行匹配以找到匹配项。如果有一个，则使用该消息。如果不匹配，则从表达式的值中减去偏移值，并将特定于语言环境的复数规则应用于此新值以获得其复数类别（例如&amp;ldquo;一个&amp;rdquo;，&amp;ldquo;少数&amp;rdquo;，&amp;ldquo;许多&amp;rdquo;等） 。），并尝试与关键字选择器进行匹配，并使用匹配的消息。如果不存在匹配项，则使用&amp;ldquo;其他&amp;rdquo;类别（必填）。消息中的 &lt;code&gt;#&lt;/code&gt; 字符的值是原始表达式的值减去指定的偏移值。</target>
        </trans-unit>
        <trans-unit id="a149b30987e7663899511dac68ffedfef81a9f01" translate="yes" xml:space="preserve">
          <source>When an AngularJS application needs some data from a server, it calls the $http service, which sends the request to a real server using $httpBackend service. With dependency injection, it is easy to inject $httpBackend mock (which has the same API as $httpBackend) and use it to verify the requests and respond with some testing data without sending a request to a real server.</source>
          <target state="translated">当一个AngularJS应用需要从服务器上获取一些数据时,它会调用$http服务,它使用$httpBackend服务将请求发送到真正的服务器。通过依赖注入,可以很容易地注入$httpBackend mock(它与$httpBackend具有相同的API),并使用它来验证请求并响应一些测试数据,而无需向真实服务器发送请求。</target>
        </trans-unit>
        <trans-unit id="0819d9d7539f9a79a347a5055715a2649bfc1a04" translate="yes" xml:space="preserve">
          <source>When an AngularJS application starts with a given application module, AngularJS creates a new instance of injector, which in turn creates a registry of recipes as a union of all recipes defined in the core &quot;ng&quot; module, application module and its dependencies. The injector then consults the recipe registry when it needs to create an object for your application.</source>
          <target state="translated">当一个AngularJS应用用一个给定的应用模块启动时,AngularJS会创建一个新的注入器实例,进而创建一个配方注册表,作为核心 &quot;ng &quot;模块、应用模块及其依赖关系中定义的所有配方的联合。然后,当注入器需要为你的应用程序创建一个对象时,它就会参考配方注册表。</target>
        </trans-unit>
        <trans-unit id="65f2bf10923606bb898bed54285676cbbd6a723c" translate="yes" xml:space="preserve">
          <source>When an anchor animation occurs, ngAnimate will clone the starting element and position it exactly where the starting element is located on screen via absolute positioning. The cloned element will be placed inside of the root element of the application (where ng-app was defined) and all of the CSS classes of the starting element will be applied. The element will then animate into the &lt;code&gt;out&lt;/code&gt; and &lt;code&gt;in&lt;/code&gt; animations and will eventually reach the coordinates and match the dimensions of the destination element. During the entire animation a CSS class of &lt;code&gt;.ng-animate-shim&lt;/code&gt; will be applied to both the starting and destination elements in order to hide them from being visible (the CSS styling for the class is: &lt;code&gt;visibility:hidden&lt;/code&gt;). Once the anchor reaches its destination then it will be removed and the destination element will become visible since the shim class will be removed.</source>
          <target state="translated">发生锚动画时，ngAnimate将克隆起始元素，并通过绝对定位将其精确定位到屏幕上起始元素所在的位置。克隆的元素将放置在应用程序的根元素（定义ng-app）的内部，并且将应用起始元素的所有CSS类。该元素将动画，然后进入 &lt;code&gt;out&lt;/code&gt; 和 &lt;code&gt;in&lt;/code&gt; 动画和最终到达的坐标和匹配目标元件的尺寸。在整个动画过程中， &lt;code&gt;.ng-animate-shim&lt;/code&gt; 的CSS类将同时应用于开始和目标元素，以使它们不可见（该类的CSS样式为：visible &lt;code&gt;visibility:hidden&lt;/code&gt; ）。一旦锚到达其目的地，则将其移除，并且由于将移除垫片类，因此目的地元素将变得可见。</target>
        </trans-unit>
        <trans-unit id="14f3f7bcb4a87c6124202a009713b7534c14dfdf" translate="yes" xml:space="preserve">
          <source>When an external event (such as a user action, timer or XHR) is received, the associated &lt;a href=&quot;expression&quot;&gt;expression&lt;/a&gt; must be applied to the scope through the &lt;a href=&quot;../api/ng/type/%24rootscope.scope#%24apply.html&quot;&gt;$apply()&lt;/a&gt; method so that all listeners are updated correctly.</source>
          <target state="translated">收到外部事件（例如用户操作，计时器或XHR）时，必须通过&lt;a href=&quot;../api/ng/type/%24rootscope.scope#%24apply.html&quot;&gt;$ apply（）&lt;/a&gt;方法将关联的&lt;a href=&quot;expression&quot;&gt;表达式&lt;/a&gt;应用于作用域，以便正确更新所有侦听器。</target>
        </trans-unit>
        <trans-unit id="c139d2a36c5e7dae8ba86d6f3fc970378a2fd7a1" translate="yes" xml:space="preserve">
          <source>When an isolate scope is used for a directive (see above), &lt;code&gt;bindToController: true&lt;/code&gt; will allow a component to have its properties bound to the controller, rather than to scope.</source>
          <target state="translated">当隔离范围用于指令时（请参见上文）， &lt;code&gt;bindToController: true&lt;/code&gt; 将允许组件将其属性绑定到控制器，而不是绑定到范围。</target>
        </trans-unit>
        <trans-unit id="3153ef599b44531bab9272b7bd946ae582bdb412" translate="yes" xml:space="preserve">
          <source>When an item in the &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt; menu is selected, the array element or object property represented by the selected option will be bound to the model identified by the &lt;code&gt;ngModel&lt;/code&gt; directive.</source>
          <target state="translated">&lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt; 菜单中的一项时，由selected选项表示的数组元素或对象属性将绑定到 &lt;code&gt;ngModel&lt;/code&gt; 指令标识的模型。</target>
        </trans-unit>
        <trans-unit id="3a676ca96b413f93e2b10f02f22a45badb9199fb" translate="yes" xml:space="preserve">
          <source>When an item in the &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt; menu is selected, the value of the selected option will be bound to the model identified by the &lt;code&gt;ngModel&lt;/code&gt; directive. With static or repeated options, this is the content of the &lt;code&gt;value&lt;/code&gt; attribute or the textContent of the &lt;code&gt;&amp;lt;option&amp;gt;&lt;/code&gt;, if the value attribute is missing. Value and textContent can be interpolated.</source>
          <target state="translated">&lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt; 菜单中的项目时，所选选项的值将绑定到 &lt;code&gt;ngModel&lt;/code&gt; 指令标识的模型。对于静态或重复选项，这是 &lt;code&gt;value&lt;/code&gt; 属性的内容或 &lt;code&gt;&amp;lt;option&amp;gt;&lt;/code&gt; 的textContent（如果缺少value属性）。值和textContent可以插值。</target>
        </trans-unit>
        <trans-unit id="d91d5acbcb6e8adb1db7278d2b85940b8c059799" translate="yes" xml:space="preserve">
          <source>When an item is added, a new instance of the template is added to the DOM.</source>
          <target state="translated">当一个项目被添加时,一个新的模板实例被添加到DOM中。</target>
        </trans-unit>
        <trans-unit id="6812fd0a944e938e939802bbf208e98821182752" translate="yes" xml:space="preserve">
          <source>When an item is removed, its template instance is removed from the DOM.</source>
          <target state="translated">当一个项目被移除时,它的模板实例将从DOM中移除。</target>
        </trans-unit>
        <trans-unit id="81dc823adbdf6d2fe5dc8bb040d0c817d8aeaa14" translate="yes" xml:space="preserve">
          <source>When caching is enabled, &lt;a href=&quot;%24http&quot;&gt;&lt;code&gt;$http&lt;/code&gt;&lt;/a&gt; stores the response from the server using the relevant cache object. The next time the same request is made, the response is returned from the cache without sending a request to the server.</source>
          <target state="translated">启用缓存后，&lt;a href=&quot;%24http&quot;&gt; &lt;code&gt;$http&lt;/code&gt; &lt;/a&gt;使用相关的缓存对象存储来自服务器的响应。下次发出相同请求时，将从缓存中返回响应，而不会向服务器发送请求。</target>
        </trans-unit>
        <trans-unit id="789467cb9245497d6ba720add302b2f1f1af706a" translate="yes" xml:space="preserve">
          <source>When called with a single argument the method acts as a setter, setting the &lt;code&gt;search&lt;/code&gt; component of &lt;code&gt;$location&lt;/code&gt; to the specified value.</source>
          <target state="translated">当使用单个参数调用时，该方法充当设置器，将 &lt;code&gt;$location&lt;/code&gt; 的 &lt;code&gt;search&lt;/code&gt; 组件设置为指定值。</target>
        </trans-unit>
        <trans-unit id="14865eb2b6a51a444dc86a06c71f0100af295db4" translate="yes" xml:space="preserve">
          <source>When called, it scrolls to the element related to the specified &lt;code&gt;hash&lt;/code&gt; or (if omitted) to the current value of &lt;a href=&quot;%24location#hash.html&quot;&gt;$location.hash()&lt;/a&gt;, according to the rules specified in the &lt;a href=&quot;http://www.w3.org/html/wg/drafts/html/master/browsers.html#an-indicated-part-of-the-document&quot;&gt;HTML5 spec&lt;/a&gt;.</source>
          <target state="translated">调用时，它会根据&lt;a href=&quot;http://www.w3.org/html/wg/drafts/html/master/browsers.html#an-indicated-part-of-the-document&quot;&gt;HTML5规范中&lt;/a&gt;指定的规则滚动到与指定的 &lt;code&gt;hash&lt;/code&gt; 相关的元素，或者滚动到（如果省略的话）到&lt;a href=&quot;%24location#hash.html&quot;&gt;$ location.hash（）&lt;/a&gt;的当前值。</target>
        </trans-unit>
        <trans-unit id="e711b7dd7dcf0670b3366c5231f7791291b42079" translate="yes" xml:space="preserve">
          <source>When called, it scrolls to the element related to the specified &lt;code&gt;hash&lt;/code&gt; or (if omitted) to the current value of &lt;a href=&quot;service/%24location#hash.html&quot;&gt;$location.hash()&lt;/a&gt;, according to the rules specified in the &lt;a href=&quot;http://www.w3.org/html/wg/drafts/html/master/browsers.html#an-indicated-part-of-the-document&quot;&gt;HTML5 spec&lt;/a&gt;.</source>
          <target state="translated">调用时，它会根据&lt;a href=&quot;http://www.w3.org/html/wg/drafts/html/master/browsers.html#an-indicated-part-of-the-document&quot;&gt;HTML5规范中&lt;/a&gt;指定的规则滚动到与指定的 &lt;code&gt;hash&lt;/code&gt; 相关的元素，或者滚动到（如果省略的话）到&lt;a href=&quot;service/%24location#hash.html&quot;&gt;$ location.hash（）&lt;/a&gt;的当前值。</target>
        </trans-unit>
        <trans-unit id="20cc03eae13b474c55c6832e1df3a3881e25f1de" translate="yes" xml:space="preserve">
          <source>When calling instance methods, the instance itself is used as the request body (if the action should have a body). By default, only actions using &lt;code&gt;POST&lt;/code&gt;, &lt;code&gt;PUT&lt;/code&gt; or &lt;code&gt;PATCH&lt;/code&gt; have request bodies, but you can use the &lt;code&gt;hasBody&lt;/code&gt; configuration option to specify whether an action should have a body or not (regardless of its HTTP method).</source>
          <target state="translated">调用实例方法时，实例本身用作请求主体（如果操作应具有主体）。默认情况下，只有使用 &lt;code&gt;POST&lt;/code&gt; ， &lt;code&gt;PUT&lt;/code&gt; 或 &lt;code&gt;PATCH&lt;/code&gt; 的动作才具有请求主体，但是您可以使用 &lt;code&gt;hasBody&lt;/code&gt; 配置选项来指定一个动作是否应该具有主体（无论其HTTP方法如何）。</target>
        </trans-unit>
        <trans-unit id="839a4c899e007e634295e0d40ee38c44ffb9e7a9" translate="yes" xml:space="preserve">
          <source>When child scopes are no longer needed, it is the responsibility of the child scope creator to destroy them via &lt;a href=&quot;../api/ng/type/%24rootscope.scope#%24destroy.html&quot;&gt;scope.$destroy()&lt;/a&gt; API. This will stop propagation of &lt;code&gt;$digest&lt;/code&gt; calls into the child scope and allow for memory used by the child scope models to be reclaimed by the garbage collector.</source>
          <target state="translated">当不再需要子范围时，子范围创建者有责任通过&lt;a href=&quot;../api/ng/type/%24rootscope.scope#%24destroy.html&quot;&gt;scope。$ destroy（）&lt;/a&gt; API 销毁它们。这将停止将 &lt;code&gt;$digest&lt;/code&gt; 调用传播到子作用域，并允许垃圾回收器回收该子作用域模型使用的内存。</target>
        </trans-unit>
        <trans-unit id="22459911d88501ffcc063a47051430d4e2088c3f" translate="yes" xml:space="preserve">
          <source>When comparing deferreds/promises to the familiar behavior of try/catch/throw, think of &lt;code&gt;reject&lt;/code&gt; as the &lt;code&gt;throw&lt;/code&gt; keyword in JavaScript. This also means that if you &quot;catch&quot; an error via a promise error callback and you want to forward the error to the promise derived from the current promise, you have to &quot;rethrow&quot; the error by returning a rejection constructed via &lt;code&gt;reject&lt;/code&gt;.</source>
          <target state="translated">将延迟/承诺与熟悉的try / catch / throw行为进行比较时，请将 &lt;code&gt;reject&lt;/code&gt; 视为JavaScript中的 &lt;code&gt;throw&lt;/code&gt; 关键字。这也意味着，如果您通过promise错误回调&amp;ldquo;捕获&amp;rdquo;错误，并且想要将错误转发到从当前promise派生的promise，则必须通过返回一个由 &lt;code&gt;reject&lt;/code&gt; 创建的拒绝来&amp;ldquo; throwth&amp;rdquo;错误。</target>
        </trans-unit>
        <trans-unit id="7544d7a6d40240f2568b1c59cdeebb817b07875a" translate="yes" xml:space="preserve">
          <source>When designing web applications, consider security threats from:</source>
          <target state="translated">在设计Web应用程序时,要考虑到来自的安全威胁。</target>
        </trans-unit>
        <trans-unit id="1be6f29866ea88fbd287202394805d3eb43fe1cb" translate="yes" xml:space="preserve">
          <source>When digest loop is done and all the values have settled, process the queue of watch deregistration tasks. For each watch to be deregistered, check if it still evaluates to a value that is not &lt;code&gt;undefined&lt;/code&gt;. If that's the case, deregister the watch. Otherwise, keep dirty-checking the watch in the future digest loops by following the same algorithm starting from step 1</source>
          <target state="translated">当摘要循环完成并且所有值都已确定时，请处理监视取消注册任务队列。对于要注销的每只手表，请检查其是否仍然评估为 &lt;code&gt;undefined&lt;/code&gt; 。在这种情况下，请注销手表的注册。否则，请遵循从步骤1开始的相同算法，在以后的摘要循环中继续对手表进行脏检查。</target>
        </trans-unit>
        <trans-unit id="ada11b8bb4889ba1645ad55c7065dc38a11b087e" translate="yes" xml:space="preserve">
          <source>When filters are executed</source>
          <target state="translated">当过滤器被执行时</target>
        </trans-unit>
        <trans-unit id="bc763fc382925e726e695a57a972bb42b82d1fcf" translate="yes" xml:space="preserve">
          <source>When interacting with &lt;code&gt;Scope&lt;/code&gt; in tests, additional helper methods are available on the instances of &lt;code&gt;Scope&lt;/code&gt; type. See &lt;a href=&quot;../../ngmock/type/%24rootscope.scope&quot;&gt;ngMock Scope&lt;/a&gt; for additional details.</source>
          <target state="translated">在测试中与 &lt;code&gt;Scope&lt;/code&gt; 交互时，在 &lt;code&gt;Scope&lt;/code&gt; 类型的实例上可以使用其他辅助方法。有关其他详细信息，请参见&lt;a href=&quot;../../ngmock/type/%24rootscope.scope&quot;&gt;ngMock Scope&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2316ea99ea91caa4a7fb2d4b06f1b8e10ed600db" translate="yes" xml:space="preserve">
          <source>When internationalizing your app, you need to do thorough testing to make sure UI components behave as expected even when their contents vary greatly in content size.</source>
          <target state="translated">当您的应用程序国际化时,您需要进行彻底的测试,以确保UI组件的行为与预期一致,即使它们的内容大小差异很大。</target>
        </trans-unit>
        <trans-unit id="750c827a48343dda9e5fe8addc1f6d41b2ad613b" translate="yes" xml:space="preserve">
          <source>When interpolating text or attributes:</source>
          <target state="translated">当插值文字或属性时。</target>
        </trans-unit>
        <trans-unit id="3383a24d31d85f720ecee22674153dda0032675f" translate="yes" xml:space="preserve">
          <source>When items are reordered, their respective templates are reordered in the DOM.</source>
          <target state="translated">当项目被重新排序时,它们各自的模板会在DOM中重新排序。</target>
        </trans-unit>
        <trans-unit id="6632f6bff4755ea5460332c4224ec9a11c1cb149" translate="yes" xml:space="preserve">
          <source>When nesting elements with structural animations, such as &lt;code&gt;ngIf&lt;/code&gt;, into elements that have class-based animations such as &lt;code&gt;ngClass&lt;/code&gt;, it sometimes happens that before the actual animation starts, there is a brief flicker or flash of content where the animated element is briefly visible.</source>
          <target state="translated">当嵌套元素与结构动画，如 &lt;code&gt;ngIf&lt;/code&gt; ，到具有基于类的动画，比如元素 &lt;code&gt;ngClass&lt;/code&gt; ，有时会发生实际的动画开始之前，有一个短暂的闪烁或内容闪存，其中动画元素是短暂可见。</target>
        </trans-unit>
        <trans-unit id="f71bcb4df00d381895c0df3a5c8a7dbd4ffa348d" translate="yes" xml:space="preserve">
          <source>When ngAnimate is animating an element it will apply the &lt;code&gt;ng-animate&lt;/code&gt; CSS class to the element for the duration of the animation. This is a temporary CSS class and it will be removed once the animation is over (for both JavaScript and CSS-based animations).</source>
          <target state="translated">当ngAnimate对元素进行动画处理时，它将在动画期间将 &lt;code&gt;ng-animate&lt;/code&gt; CSS类应用于该元素。这是一个临时CSS类，动画结束后将被删除（对于基于JavaScript和基于CSS的动画）。</target>
        </trans-unit>
        <trans-unit id="3b8455755d949278198fe66a8823e52081309775" translate="yes" xml:space="preserve">
          <source>When not to use Components:</source>
          <target state="translated">什么时候不使用组件。</target>
        </trans-unit>
        <trans-unit id="6625b1391d7be3b24e194fa9d4b7155f0f6abba7" translate="yes" xml:space="preserve">
          <source>When provided, replaces the resourceUrlBlacklist with the value provided. This must be an array or null. A snapshot of this array is used so further changes to the array are ignored.</source>
          <target state="translated">当提供时,用提供的值替换资源UrlBlacklist。这个值必须是一个数组或空值。这个数组的快照被使用,所以对数组的进一步修改将被忽略。</target>
        </trans-unit>
        <trans-unit id="4d9fdadc8992417ef4226cc2cbace2ccffdff1f6" translate="yes" xml:space="preserve">
          <source>When provided, replaces the resourceUrlWhitelist with the value provided. This must be an array or null. A snapshot of this array is used so further changes to the array are ignored. Follow &lt;a href=&quot;../service/%24sce#resourceUrlPatternItem.html&quot;&gt;this link&lt;/a&gt; for a description of the items allowed in this array.</source>
          <target state="translated">提供时，用提供的值替换resourceUrlWhitelist。该值必须为数组或null。使用此阵列的快照，因此将忽略对该阵列的进一步更改。单击&lt;a href=&quot;../service/%24sce#resourceUrlPatternItem.html&quot;&gt;此链接&lt;/a&gt;以获取此数组中允许的项目的描述。</target>
        </trans-unit>
        <trans-unit id="fefb6e795ed34de308a60ccca17742a8573190c3" translate="yes" xml:space="preserve">
          <source>When should I use $location?</source>
          <target state="translated">什么时候应该使用$location?</target>
        </trans-unit>
        <trans-unit id="fc081f8c14691f7b31edca6d4fe98a8c36e29d01" translate="yes" xml:space="preserve">
          <source>When specifying the &lt;code&gt;placeholder&lt;/code&gt; attribute of &lt;code&gt;&amp;lt;textarea&amp;gt;&lt;/code&gt;, Internet Explorer will temporarily insert the placeholder value as the textarea's content. If the placeholder value contains interpolation (&lt;code&gt;{{ ... }}&lt;/code&gt;), an error will be logged in the console when AngularJS tries to update the value of the by-then-removed text node. This doesn't affect the functionality of the textarea, but can be undesirable.</source>
          <target state="translated">当指定 &lt;code&gt;&amp;lt;textarea&amp;gt;&lt;/code&gt; 的 &lt;code&gt;placeholder&lt;/code&gt; 属性时，Internet Explorer会临时插入占位符值作为textarea的内容。如果占位符值包含插值（ &lt;code&gt;{{ ... }}&lt;/code&gt; ），则当AngularJS尝试更新&amp;ldquo;然后被移除&amp;rdquo;文本节点的值时，控制台中将记录错误。这不会影响文本区域的功能，但是可能是不希望的。</target>
        </trans-unit>
        <trans-unit id="9f2ae1c603fd24b2d92261b8648add410fc1b1db" translate="yes" xml:space="preserve">
          <source>When testing promises, it's important to know that the resolution of promises is tied to the &lt;a href=&quot;../api/ng/type/%24rootscope.scope#%24digest.html&quot;&gt;digest cycle&lt;/a&gt;. That means a promise's &lt;code&gt;then&lt;/code&gt;, &lt;code&gt;catch&lt;/code&gt; and &lt;code&gt;finally&lt;/code&gt; callback functions are only called after a digest has run. In tests, you can trigger a digest by calling a scope's &lt;a href=&quot;../api/ng/type/%24rootscope.scope#%24apply.html&quot;&gt;&lt;code&gt;$apply&lt;/code&gt; function&lt;/a&gt;. If you don't have a scope in your test, you can inject the &lt;a href=&quot;../api/ng/service/%24rootscope&quot;&gt;$rootScope&lt;/a&gt; and call &lt;code&gt;$apply&lt;/code&gt; on it. There is also an example of testing promises in the &lt;a href=&quot;../api/ng/service/%24q#testing.html&quot;&gt;&lt;code&gt;$q&lt;/code&gt; service documentation&lt;/a&gt;.</source>
          <target state="translated">在测试promise时，重要的是要知道promise的分辨率与&lt;a href=&quot;../api/ng/type/%24rootscope.scope#%24digest.html&quot;&gt;摘要周期有关&lt;/a&gt;。这意味着仅在摘要运行后才调用promise的 &lt;code&gt;then&lt;/code&gt; ， &lt;code&gt;catch&lt;/code&gt; 和 &lt;code&gt;finally&lt;/code&gt; 回调函数。在测试中，您可以通过调用作用域的&lt;a href=&quot;../api/ng/type/%24rootscope.scope#%24apply.html&quot;&gt; &lt;code&gt;$apply&lt;/code&gt; 函数&lt;/a&gt;来触发摘要。如果您的测试中没有示波器，则可以注入&lt;a href=&quot;../api/ng/service/%24rootscope&quot;&gt;$ rootScope&lt;/a&gt;并对其调用 &lt;code&gt;$apply&lt;/code&gt; 。&lt;a href=&quot;../api/ng/service/%24q#testing.html&quot;&gt; &lt;code&gt;$q&lt;/code&gt; 服务文档中&lt;/a&gt;还有一个测试promise的示例。</target>
        </trans-unit>
        <trans-unit id="2a9b3721c7237b75d3afd4715763f1ab811416bc" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;ngHide&lt;/code&gt; expression evaluates to a truthy value then the &lt;code&gt;.ng-hide&lt;/code&gt; CSS class is added to the class attribute on the element causing it to become hidden. When falsy, the &lt;code&gt;.ng-hide&lt;/code&gt; CSS class is removed from the element causing the element not to appear hidden.</source>
          <target state="translated">当 &lt;code&gt;ngHide&lt;/code&gt; 表达式的值为真值时， &lt;code&gt;.ng-hide&lt;/code&gt; CSS类添加到元素上的class属性，使其隐藏。伪造时，将从元素中删除 &lt;code&gt;.ng-hide&lt;/code&gt; CSS类，以使该元素不会隐藏。</target>
        </trans-unit>
        <trans-unit id="a297ab931629d5a0763f7da3d096f081788fc874" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;ngShow&lt;/code&gt; expression evaluates to a falsy value then the &lt;code&gt;.ng-hide&lt;/code&gt; CSS class is added to the class attribute on the element causing it to become hidden. When truthy, the &lt;code&gt;.ng-hide&lt;/code&gt; CSS class is removed from the element causing the element not to appear hidden.</source>
          <target state="translated">当 &lt;code&gt;ngShow&lt;/code&gt; 表达式的值为假值时， &lt;code&gt;.ng-hide&lt;/code&gt; CSS类添加到该元素的class属性上，从而使其隐藏。没错时， &lt;code&gt;.ng-hide&lt;/code&gt; CSS类将从元素中删除，从而使元素不会隐藏。</target>
        </trans-unit>
        <trans-unit id="4bfc193dcf03be5fdd2e2cdb87b257d2455c123e" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;willBreak&lt;/code&gt; service is instantiated, AngularJS will throw an error because of strict mode. This is useful when using a tool like &lt;a href=&quot;https://github.com/olov/ng-annotate&quot;&gt;ng-annotate&lt;/a&gt; to ensure that all of your application components have annotations.</source>
          <target state="translated">当 &lt;code&gt;willBreak&lt;/code&gt; 服务被实例化，AngularJS将抛出，因为严格模式的错误。当使用&lt;a href=&quot;https://github.com/olov/ng-annotate&quot;&gt;ng-annotate之&lt;/a&gt;类的工具来确保所有应用程序组件都具有注释时，这很有用。</target>
        </trans-unit>
        <trans-unit id="c7c18ae4170652195c550cf6ea2dba7c36696d41" translate="yes" xml:space="preserve">
          <source>When the above example is compiled, the compiler visits every node and looks for directives.</source>
          <target state="translated">当上面的例子被编译时,编译器会访问每一个节点并寻找指令。</target>
        </trans-unit>
        <trans-unit id="4f3975f977c06069a05aff73f180e1132f61ab9c" translate="yes" xml:space="preserve">
          <source>When the application containing &lt;code&gt;angular_de-de.js&lt;/code&gt; script instead of the generic angular.js script starts, AngularJS is automatically pre-configured with localization rules for the german locale.</source>
          <target state="translated">当包含 &lt;code&gt;angular_de-de.js&lt;/code&gt; 脚本而不是通用angular.js脚本的应用程序启动时，AngularJS会自动使用德语语言环境的本地化规则进行预配置。</target>
        </trans-unit>
        <trans-unit id="9dc89b2e726de5f584f7c7b43803949e197d4a32" translate="yes" xml:space="preserve">
          <source>When the browser calls into JavaScript the code executes outside the AngularJS execution context, which means that AngularJS is unaware of model modifications. To properly process model modifications the execution has to enter the AngularJS execution context using the &lt;a href=&quot;../api/ng/type/%24rootscope.scope#%24apply.html&quot;&gt;&lt;code&gt;$apply&lt;/code&gt;&lt;/a&gt; method. Only model modifications which execute inside the &lt;code&gt;$apply&lt;/code&gt; method will be properly accounted for by AngularJS. For example if a directive listens on DOM events, such as &lt;a href=&quot;../api/ng/directive/ngclick&quot;&gt;&lt;code&gt;ng-click&lt;/code&gt;&lt;/a&gt; it must evaluate the expression inside the &lt;code&gt;$apply&lt;/code&gt; method.</source>
          <target state="translated">当浏览器调用JavaScript时，代码将在AngularJS执行上下文之外执行，这意味着AngularJS不了解模型修改。为了正确地处理模型修改，执行必须使用&lt;a href=&quot;../api/ng/type/%24rootscope.scope#%24apply.html&quot;&gt; &lt;code&gt;$apply&lt;/code&gt; &lt;/a&gt;方法进入AngularJS执行上下文。AngularJS将只考虑在 &lt;code&gt;$apply&lt;/code&gt; 方法内部执行的模型修改。例如，如果某个指令侦听DOM事件（例如&lt;a href=&quot;../api/ng/directive/ngclick&quot;&gt; &lt;code&gt;ng-click&lt;/code&gt; ),&lt;/a&gt;则它必须在 &lt;code&gt;$apply&lt;/code&gt; 方法内评估表达式。</target>
        </trans-unit>
        <trans-unit id="c4a0073d43d8ed80547cc46f1c39992f55fe9dcd" translate="yes" xml:space="preserve">
          <source>When the data is returned from the server then the object is an instance of the resource type and all of the non-GET methods are available with &lt;code&gt;$&lt;/code&gt; prefix. This allows you to easily support CRUD operations (create, read, update, delete) on server-side data.</source>
          <target state="translated">当从服务器返回数据时，该对象是资源类型的实例，并且所有非GET方法都可以使用 &lt;code&gt;$&lt;/code&gt; 前缀。这使您可以轻松地支持服务器端数据的CRUD操作（创建，读取，更新，删除）。</target>
        </trans-unit>
        <trans-unit id="a1ed9027d5eb4faa2d10f802af6772e8ffd7a989" translate="yes" xml:space="preserve">
          <source>When the expression changes, the previously added classes are removed and only then are the new classes added.</source>
          <target state="translated">当表达式发生变化时,之前添加的类会被删除,然后才会添加新的类。</target>
        </trans-unit>
        <trans-unit id="3821805d3a6f4eb90bb7345d51e2b2e665b5adba" translate="yes" xml:space="preserve">
          <source>When the first argument is a native DOM or jqLite/jQuery element, the function enables / disables animations on this element &lt;em&gt;and all its children&lt;/em&gt;: &lt;code&gt;$animate.enabled(myElement, false)&lt;/code&gt;. You can still use it to re-enable animations for a child element, even if you have disabled them on a parent element. And compared to the &lt;code&gt;classNameFilter&lt;/code&gt;, you can change the animation status at runtime instead of during the config phase.</source>
          <target state="translated">当第一个参数是本机DOM或jqLit​​e / jQuery元素时，该函数启用/禁用此元素&lt;em&gt;及其所有子&lt;/em&gt;元素的动画： &lt;code&gt;$animate.enabled(myElement, false)&lt;/code&gt; 。您仍然可以使用它为子元素重新启用动画，即使您已在父元素上禁用了动画也是如此。与 &lt;code&gt;classNameFilter&lt;/code&gt; 相比，您可以在运行时而不是在配置阶段更改动画状态。</target>
        </trans-unit>
        <trans-unit id="d2b8c3726e19191da644ea15837b664d0107b25a" translate="yes" xml:space="preserve">
          <source>When the original node and the replace template declare the same directive(s), they will be &lt;a href=&quot;../../../guide/compiler#double-compilation-and-how-to-avoid-it.html&quot;&gt;compiled twice&lt;/a&gt; because the compiler does not deduplicate them. In many cases, this is not noticable, but e.g. &lt;a href=&quot;../directive/ngmodel&quot;&gt;&lt;code&gt;ngModel&lt;/code&gt;&lt;/a&gt; will attach &lt;code&gt;$formatters&lt;/code&gt; and &lt;code&gt;$parsers&lt;/code&gt; twice.</source>
          <target state="translated">当原始节点和替换模板声明相同的指令时，它们将被&lt;a href=&quot;../../../guide/compiler#double-compilation-and-how-to-avoid-it.html&quot;&gt;编译两次，&lt;/a&gt;因为编译器不会对它们进行重复数据删除。在许多情况下，这不是很明显，但是例如&lt;a href=&quot;../directive/ngmodel&quot;&gt; &lt;code&gt;ngModel&lt;/code&gt; &lt;/a&gt;将 &lt;code&gt;$formatters&lt;/code&gt; 和 &lt;code&gt;$parsers&lt;/code&gt; 附加两次。</target>
        </trans-unit>
        <trans-unit id="fd9c02d96b63bdc77f81f45e93ccaf214f2bcea7" translate="yes" xml:space="preserve">
          <source>When the replace template has a directive at the root node that uses &lt;a href=&quot;%24compile#-transclude-.html&quot;&gt;&lt;code&gt;transclude: element&lt;/code&gt;&lt;/a&gt;, e.g. &lt;a href=&quot;../directive/ngif&quot;&gt;&lt;code&gt;ngIf&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../directive/ngrepeat&quot;&gt;&lt;code&gt;ngRepeat&lt;/code&gt;&lt;/a&gt;, the DOM structure or scope inheritance can be incorrect. See the following issues:</source>
          <target state="translated">如果替换模板在根节点上具有使用&lt;a href=&quot;../directive/ngif&quot;&gt; &lt;code&gt;ngIf&lt;/code&gt; &lt;/a&gt;&lt;a href=&quot;%24compile#-transclude-.html&quot;&gt; &lt;code&gt;transclude: element&lt;/code&gt; &lt;/a&gt;的指令，例如ngIf或&lt;a href=&quot;../directive/ngrepeat&quot;&gt; &lt;code&gt;ngRepeat&lt;/code&gt; &lt;/a&gt;，则DOM结构或范围继承可能不正确。请参阅以下问题：</target>
        </trans-unit>
        <trans-unit id="9342cec159ce1c208d8802a510ac44a9f06fba8a" translate="yes" xml:space="preserve">
          <source>When the user clicks the &lt;code&gt;x&lt;/code&gt; in the dialog, the directive's &lt;code&gt;close&lt;/code&gt; function is called, thanks to &lt;code&gt;ng-click.&lt;/code&gt; This call to &lt;code&gt;close&lt;/code&gt; on the isolated scope actually evaluates the expression &lt;code&gt;hideDialog(message)&lt;/code&gt; in the context of the original scope, thus running &lt;code&gt;Controller&lt;/code&gt;'s &lt;code&gt;hideDialog&lt;/code&gt; function.</source>
          <target state="translated">当用户单击对话框中的 &lt;code&gt;x&lt;/code&gt; 时，由于 &lt;code&gt;ng-click.&lt;/code&gt; ，该指令的 &lt;code&gt;close&lt;/code&gt; 函数被调用。对隔离范围的 &lt;code&gt;close&lt;/code&gt; 调用实际上是在原始范围的上下文中计算表达式 &lt;code&gt;hideDialog(message)&lt;/code&gt; ，从而运行 &lt;code&gt;Controller&lt;/code&gt; 的 &lt;code&gt;hideDialog&lt;/code&gt; 函数。</target>
        </trans-unit>
        <trans-unit id="88a38c58d7d80b367d19d209a82c71a873027d20" translate="yes" xml:space="preserve">
          <source>When there are multiple directives defined on a single DOM element, sometimes it is necessary to specify the order in which the directives are applied. The &lt;code&gt;priority&lt;/code&gt; is used to sort the directives before their &lt;code&gt;compile&lt;/code&gt; functions get called. Priority is defined as a number. Directives with greater numerical &lt;code&gt;priority&lt;/code&gt; are compiled first. Pre-link functions are also run in priority order, but post-link functions are run in reverse order. The order of directives with the same priority is undefined. The default priority is &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">当在单个DOM元素上定义了多个指令时，有时必须指定指令的应用顺序。将 &lt;code&gt;priority&lt;/code&gt; 使用它们之前的指令排序 &lt;code&gt;compile&lt;/code&gt; 函数被调用。优先级定义为数字。首先编译具有更高数字 &lt;code&gt;priority&lt;/code&gt; 指令。链接前功能也按优先级顺序运行，但链接后功能则以相反顺序运行。具有相同优先级的指令的顺序是不确定的。默认优先级为 &lt;code&gt;0&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="848b2612d0c87e93e24fbe2550122caa0f1c577b" translate="yes" xml:space="preserve">
          <source>When this css rule is loaded by the browser, all html elements (including their children) that are tagged with the &lt;code&gt;ngCloak&lt;/code&gt; directive are hidden. When AngularJS encounters this directive during the compilation of the template it deletes the &lt;code&gt;ngCloak&lt;/code&gt; element attribute, making the compiled element visible.</source>
          <target state="translated">当浏览器加载此CSS规则时，所有带有 &lt;code&gt;ngCloak&lt;/code&gt; 指令标记的html元素（包括其子元素）都将被隐藏。当AngularJS在模板编译期间遇到此指令时，它将删除 &lt;code&gt;ngCloak&lt;/code&gt; 元素属性，从而使编译后的元素可见。</target>
        </trans-unit>
        <trans-unit id="2fc91990fa11ae11c26ee5a24353aaebf1125812" translate="yes" xml:space="preserve">
          <source>When this property is set to true (default is &lt;code&gt;false&lt;/code&gt;), the HTML compiler will collect DOM nodes between nodes with the attributes &lt;code&gt;directive-name-start&lt;/code&gt; and &lt;code&gt;directive-name-end&lt;/code&gt;, and group them together as the directive elements. It is recommended that this feature be used on directives which are not strictly behavioral (such as &lt;a href=&quot;../directive/ngclick&quot;&gt;&lt;code&gt;ngClick&lt;/code&gt;&lt;/a&gt;), and which do not manipulate or replace child nodes (such as &lt;a href=&quot;../directive/nginclude&quot;&gt;&lt;code&gt;ngInclude&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">当此属性设置为true（默认为 &lt;code&gt;false&lt;/code&gt; ）时，HTML编译器将收集属性为 &lt;code&gt;directive-name-start&lt;/code&gt; 和 &lt;code&gt;directive-name-end&lt;/code&gt; 节点之间的DOM节点，并将它们作为指令元素组合在一起。建议将此功能用于行为严格的指令（例如&lt;a href=&quot;../directive/ngclick&quot;&gt; &lt;code&gt;ngClick&lt;/code&gt; &lt;/a&gt;），并且不要操纵或替换子节点（例如&lt;a href=&quot;../directive/nginclude&quot;&gt; &lt;code&gt;ngInclude&lt;/code&gt; &lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="0235d8d7bcd040be16e73b4398069ebc939ca474" translate="yes" xml:space="preserve">
          <source>When to use directives, controllers or services</source>
          <target state="translated">何时使用指令、控制器或服务?</target>
        </trans-unit>
        <trans-unit id="799c93d8465b6c7356d72990ebf0c31dcca5897e" translate="yes" xml:space="preserve">
          <source>When unit testing (using &lt;a href=&quot;../../ngmock&quot;&gt;ngMock&lt;/a&gt;), it is necessary to call &lt;a href=&quot;../../ngmock/service/%24httpbackend#flush.html&quot;&gt;$httpBackend.flush()&lt;/a&gt; to flush each pending request using trained responses.</source>
          <target state="translated">&lt;a href=&quot;../../ngmock&quot;&gt;在进行&lt;/a&gt;单元测试时（使用ngMock），有必要调用&lt;a href=&quot;../../ngmock/service/%24httpbackend#flush.html&quot;&gt;$ httpBackend.flush（）&lt;/a&gt;使用经过训练的响应来刷新每个未决的请求。</target>
        </trans-unit>
        <trans-unit id="866465e227471da7aace7e851aaccc0bf7b51a44" translate="yes" xml:space="preserve">
          <source>When used with standard inputs, the view value will always be a string (which is in some cases parsed into another type, such as a &lt;code&gt;Date&lt;/code&gt; object for &lt;code&gt;input[date]&lt;/code&gt;.) However, custom controls might also pass objects to this method. In this case, we should make a copy of the object before passing it to &lt;code&gt;$setViewValue&lt;/code&gt;. This is because &lt;code&gt;ngModel&lt;/code&gt; does not perform a deep watch of objects, it only looks for a change of identity. If you only change the property of the object then ngModel will not realize that the object has changed and will not invoke the &lt;code&gt;$parsers&lt;/code&gt; and &lt;code&gt;$validators&lt;/code&gt; pipelines. For this reason, you should not change properties of the copy once it has been passed to &lt;code&gt;$setViewValue&lt;/code&gt;. Otherwise you may cause the model value on the scope to change incorrectly.</source>
          <target state="translated">与标准输入一起使用时，视图值将始终为字符串（在某些情况下，该值将解析为另一种类型，例如 &lt;code&gt;input[date]&lt;/code&gt; 的 &lt;code&gt;Date&lt;/code&gt; 对象。）但是，自定义控件也可能将对象传递给此方法。在这种情况下，我们应该在将对象传递给 &lt;code&gt;$setViewValue&lt;/code&gt; 之前对其进行复制。这是因为 &lt;code&gt;ngModel&lt;/code&gt; 不会对对象进行深入监视，它只会查找标识的更改。如果仅更改对象的属性，则ngModel将不会意识到该对象已更改，并且不会调用 &lt;code&gt;$parsers&lt;/code&gt; 和 &lt;code&gt;$validators&lt;/code&gt; 管道。因此，一旦将副本传递给副本，就不应更改其属性。 &lt;code&gt;$setViewValue&lt;/code&gt; 。否则，可能导致示波器上的模型值更改不正确。</target>
        </trans-unit>
        <trans-unit id="cc64a729cd2e490dc065221b82d1cb45ab84daeb" translate="yes" xml:space="preserve">
          <source>When using &lt;a href=&quot;../api/ngroute/provider/%24routeprovider&quot;&gt;$routeProvider&lt;/a&gt;, you can often avoid some boilerplate, by passing the resolved route dependencies directly to the component. Since 1.5, ngRoute automatically assigns the resolves to the route scope property &lt;code&gt;$resolve&lt;/code&gt; (you can also configure the property name via &lt;code&gt;resolveAs&lt;/code&gt;). When using components, you can take advantage of this and pass resolves directly into your component without creating an extra route controller:</source>
          <target state="translated">使用&lt;a href=&quot;../api/ngroute/provider/%24routeprovider&quot;&gt;$ routeProvider时&lt;/a&gt;，通常可以通过将已解决的路由依赖关系直接传递给组件来避免一些重复。从1.5开始，ngRoute自动将解析分配给路由范围属性 &lt;code&gt;$resolve&lt;/code&gt; （您也可以通过 &lt;code&gt;resolveAs&lt;/code&gt; 配置属性名称）。使用组件时，您可以利用此优势并将解析直接传递到您的组件中，而无需创建额外的路由控制器：</target>
        </trans-unit>
        <trans-unit id="9ba0f63480183afb2de1595c7ae8b25bef84a87f" translate="yes" xml:space="preserve">
          <source>When using &lt;a href=&quot;ngshow&quot;&gt;&lt;code&gt;ngShow&lt;/code&gt;&lt;/a&gt; and / or &lt;a href=&quot;nghide&quot;&gt;&lt;code&gt;ngHide&lt;/code&gt;&lt;/a&gt; to toggle between elements, it can happen that both the element to show and the element to hide are visible for a very short time.</source>
          <target state="translated">使用&lt;a href=&quot;ngshow&quot;&gt; &lt;code&gt;ngShow&lt;/code&gt; &lt;/a&gt;和/或&lt;a href=&quot;nghide&quot;&gt; &lt;code&gt;ngHide&lt;/code&gt; &lt;/a&gt;在元素之间切换时，可能会在很短的时间内同时显示要显示的元素和要隐藏的元素。</target>
        </trans-unit>
        <trans-unit id="2d06d724db84ddaaec9c56ac07d4b9edf55b4c22" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;$location&lt;/code&gt; service during testing, you are outside of the angular's &lt;a href=&quot;../api/ng/type/%24rootscope.scope&quot;&gt;scope&lt;/a&gt; life-cycle. This means it's your responsibility to call &lt;code&gt;scope.$apply()&lt;/code&gt;.</source>
          <target state="translated">在测试期间使用 &lt;code&gt;$location&lt;/code&gt; 服务时，您不在角度&lt;a href=&quot;../api/ng/type/%24rootscope.scope&quot;&gt;范围的&lt;/a&gt;生命周期内。这意味着调用 &lt;code&gt;scope.$apply()&lt;/code&gt; 是您的责任。</target>
        </trans-unit>
        <trans-unit id="308def7ce1040ce8f8e90c771104d822bf9c454e" translate="yes" xml:space="preserve">
          <source>When using a directive that takes an expression:</source>
          <target state="translated">当使用接受表达式的指令时。</target>
        </trans-unit>
        <trans-unit id="9af3cc5f2e0ae3fda308cd5ccc2df4b745158ea7" translate="yes" xml:space="preserve">
          <source>When using a directive with bidirectional binding and parameters that will not change:</source>
          <target state="translated">当使用具有双向绑定和参数不会改变的指令时。</target>
        </trans-unit>
        <trans-unit id="ce320691763ef56ed7bc8d8107895e1c4a8418eb" translate="yes" xml:space="preserve">
          <source>When using this type of annotation, take care to keep the annotation array in sync with the parameters in the function declaration.</source>
          <target state="translated">在使用这种类型的注解时,注意保持注解数组与函数声明中的参数同步。</target>
        </trans-unit>
        <trans-unit id="0788f3e044fd333f645148040ef0b7a3426b7c04" translate="yes" xml:space="preserve">
          <source>When you call a transclude function it returns a DOM fragment that is pre-bound to a &lt;strong&gt;transclusion scope&lt;/strong&gt;. This scope is special, in that it is a child of the directive's scope (and so gets destroyed when the directive's scope gets destroyed) but it inherits the properties of the scope from which it was taken.</source>
          <target state="translated">调用transclude函数时，它将返回预先绑定到&lt;strong&gt;包含范围&lt;/strong&gt;的DOM片段。此范围是特殊的，因为它是指令范围的子级（因此，在销毁指令范围时会被销毁），但是它继承了从中获取该范围的属性。</target>
        </trans-unit>
        <trans-unit id="adc8cb01135df3a93cfcf63923b01b0b4bcfd2e2" translate="yes" xml:space="preserve">
          <source>When you call a transclusion function you can pass in a &lt;strong&gt;clone attach function&lt;/strong&gt;. This function accepts two parameters, &lt;code&gt;function(clone, scope) { ... }&lt;/code&gt;, where the &lt;code&gt;clone&lt;/code&gt; is a fresh compiled copy of your transcluded content and the &lt;code&gt;scope&lt;/code&gt; is the newly created transclusion scope, which the clone will be linked to.</source>
          <target state="translated">调用包含函数时，可以传入&lt;strong&gt;克隆附加函数&lt;/strong&gt;。此函数接受两个参数， &lt;code&gt;function(clone, scope) { ... }&lt;/code&gt; ，其中 &lt;code&gt;clone&lt;/code&gt; 是被包含内容的新编译副本，并且该 &lt;code&gt;scope&lt;/code&gt; 是将与该链接链接的新创建的包含范围。</target>
        </trans-unit>
        <trans-unit id="c0d63bac8ebb474dd0a18c50994a65c24b136a76" translate="yes" xml:space="preserve">
          <source>When you call the &lt;code&gt;absUrl()&lt;/code&gt; method, the returned value is a full url with its segments encoded.</source>
          <target state="translated">当您调用 &lt;code&gt;absUrl()&lt;/code&gt; 方法时，返回的值是带有段编码的完整URL。</target>
        </trans-unit>
        <trans-unit id="96856534f37714d279ae2c0dc01f3e86884722a6" translate="yes" xml:space="preserve">
          <source>When you call the &lt;code&gt;url()&lt;/code&gt; method, the returned value is path, search and hash, in the form &lt;code&gt;/path?search=a&amp;amp;b=c#hash&lt;/code&gt;. The segments are encoded as well.</source>
          <target state="translated">当您调用 &lt;code&gt;url()&lt;/code&gt; 方法时，返回的值为path，search和hash，格式为 &lt;code&gt;/path?search=a&amp;amp;b=c#hash&lt;/code&gt; 。段也被编码。</target>
        </trans-unit>
        <trans-unit id="8e2a897977982bc35240ddd6d90240a08cedadc8" translate="yes" xml:space="preserve">
          <source>When you request a service, the &lt;a href=&quot;%24injector&quot;&gt;$injector&lt;/a&gt; is responsible for finding the correct &lt;strong&gt;service provider&lt;/strong&gt;, instantiating it and then calling its &lt;code&gt;$get&lt;/code&gt;&lt;strong&gt;service factory&lt;/strong&gt; function to get the instance of the &lt;strong&gt;service&lt;/strong&gt;.</source>
          <target state="translated">当您请求服务时，&lt;a href=&quot;%24injector&quot;&gt;$ injector&lt;/a&gt;负责查找正确的&lt;strong&gt;服务提供者&lt;/strong&gt;，将其实例化，然后调用其 &lt;code&gt;$get&lt;/code&gt; &lt;strong&gt;service factory&lt;/strong&gt;函数以获取&lt;strong&gt;服务&lt;/strong&gt;的实例。</target>
        </trans-unit>
        <trans-unit id="aa6de81ecf4cb6e26917389d536bee77c7c57932" translate="yes" xml:space="preserve">
          <source>When you use HTML5 history API mode, you will not need special hashbang links. All you have to do is specify regular URL links, such as: &lt;code&gt;&amp;lt;a href=&quot;/some?foo=bar&quot;&amp;gt;link&amp;lt;/a&amp;gt;&lt;/code&gt;</source>
          <target state="translated">使用HTML5历史记录API模式时，不需要特殊的hashbang链接。您所需要做的就是指定常规的URL链接，例如： &lt;code&gt;&amp;lt;a href=&quot;/some?foo=bar&quot;&amp;gt;link&amp;lt;/a&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8d89b9c3c7ad0e72f71a638e459b847a4a1b6c92" translate="yes" xml:space="preserve">
          <source>Whenever an animation is started, &lt;code&gt;ngAnimate&lt;/code&gt; applies the &lt;code&gt;ng-animate&lt;/code&gt; class to the element for the whole duration of the animation. By applying CSS transition / animation styling to that class, you can skip an animation:</source>
          <target state="translated">每当启动动画时， &lt;code&gt;ngAnimate&lt;/code&gt; 都会在整个 &lt;code&gt;ng-animate&lt;/code&gt; 中将ng-animate类应用于该元素。通过对该类应用CSS过渡/动画样式，您可以跳过动画：</target>
        </trans-unit>
        <trans-unit id="986037565cd6579ad9d0ba68772c304b34c53a56" translate="yes" xml:space="preserve">
          <source>Whenever an inner message is attached (becomes visible) or removed (becomes hidden) then the enter and leave animation is triggered for each particular element bound to the &lt;code&gt;ngMessage&lt;/code&gt; directive.</source>
          <target state="translated">每当附加了内部消息（变为可见）或删除内部消息（变为隐藏）时，就会为绑定到 &lt;code&gt;ngMessage&lt;/code&gt; 指令的每个特定元素触发进入和离开动画。</target>
        </trans-unit>
        <trans-unit id="65ee722d839e36aed52fa460253fb75029459549" translate="yes" xml:space="preserve">
          <source>Whenever the &lt;code&gt;ngMessages&lt;/code&gt; directive contains one or more visible messages then the &lt;code&gt;.ng-active&lt;/code&gt; CSS class will be added to the element. The &lt;code&gt;.ng-inactive&lt;/code&gt; CSS class will be applied when there are no messages present. Therefore, CSS transitions and keyframes as well as JavaScript animations can hook into the animations whenever these classes are added/removed.</source>
          <target state="translated">只要 &lt;code&gt;ngMessages&lt;/code&gt; 指令包含一个或多个可见消息，就会将 &lt;code&gt;.ng-active&lt;/code&gt; CSS类添加到元素中。所述 &lt;code&gt;.ng-inactive&lt;/code&gt; 当没有本消息CSS类将被应用。因此，每当添加/删除这些类时，CSS过渡和关键帧以及JavaScript动画就可以挂接到这些动画中。</target>
        </trans-unit>
        <trans-unit id="7960d3c2618b44613a36486dbb58d967ec476048" translate="yes" xml:space="preserve">
          <source>Whenever your application makes requests to a server there are potential security issues that need to be blocked. Both server and the client must cooperate in order to eliminate these threats. AngularJS comes pre-configured with strategies that address these issues, but for this to work backend server cooperation is required.</source>
          <target state="translated">每当你的应用程序向服务器发出请求时,就会有潜在的安全问题需要被阻止。为了消除这些威胁,服务器和客户端都必须合作。AngularJS 预先配置了解决这些问题的策略,但要做到这一点,需要后端服务器的配合。</target>
        </trans-unit>
        <trans-unit id="460854c303f2e0076b9be3c2cbeafbd2741f25c0" translate="yes" xml:space="preserve">
          <source>Where the compiler has created a new scope, the scope and either &lt;code&gt;ng-scope&lt;/code&gt; or &lt;code&gt;ng-isolated-scope&lt;/code&gt; CSS class are attached to the corresponding element. These scope references can then be accessed via &lt;code&gt;element.scope()&lt;/code&gt; and &lt;code&gt;element.isolateScope()&lt;/code&gt;.</source>
          <target state="translated">在编译器创建了新作用域的情况下，该作用域以及 &lt;code&gt;ng-scope&lt;/code&gt; 或 &lt;code&gt;ng-isolated-scope&lt;/code&gt; CSS类将附加到相应的元素。然后可以通过 &lt;code&gt;element.scope()&lt;/code&gt; 和 &lt;code&gt;element.isolateScope()&lt;/code&gt; 访问这些范围引用。</target>
        </trans-unit>
        <trans-unit id="7e741bc3dcef0123eeda11543758853be2aac149" translate="yes" xml:space="preserve">
          <source>Where:</source>
          <target state="translated">Where:</target>
        </trans-unit>
        <trans-unit id="750881ed39d8d4dbbabc8a525246358035450087" translate="yes" xml:space="preserve">
          <source>Whether &lt;code&gt;ngInclude&lt;/code&gt; should call &lt;a href=&quot;../service/%24anchorscroll&quot;&gt;$anchorScroll&lt;/a&gt; to scroll the viewport after the content is loaded.</source>
          <target state="translated">无论 &lt;code&gt;ngInclude&lt;/code&gt; 应该调用&lt;a href=&quot;../service/%24anchorscroll&quot;&gt;$ anchorScroll&lt;/a&gt;内容加载后滚动视口。</target>
        </trans-unit>
        <trans-unit id="95e30e407f19a0df15c35e9a06f966233d1296da" translate="yes" xml:space="preserve">
          <source>Whether &lt;code&gt;ngView&lt;/code&gt; should call &lt;a href=&quot;../../ng/service/%24anchorscroll&quot;&gt;$anchorScroll&lt;/a&gt; to scroll the viewport after the view is updated.</source>
          <target state="translated">无论 &lt;code&gt;ngView&lt;/code&gt; 应该调用&lt;a href=&quot;../../ng/service/%24anchorscroll&quot;&gt;$ anchorScroll&lt;/a&gt;视图更新后滚动视口。</target>
        </trans-unit>
        <trans-unit id="b0799f71a28a8d4e41670e7cf10ec92b54b2fb4f" translate="yes" xml:space="preserve">
          <source>Whether or not to ignore the exception when the request fails or the template is empty</source>
          <target state="translated">当请求失败或模板为空时,是否要忽略异常。</target>
        </trans-unit>
        <trans-unit id="7a494ff3bb52752d0bc384651bd7d37989465cdc" translate="yes" xml:space="preserve">
          <source>Whether the current state is valid (true), invalid (false), pending (undefined), or skipped (null). Pending is used for unfulfilled &lt;code&gt;$asyncValidators&lt;/code&gt;. Skipped is used by AngularJS when validators do not run because of parse errors and when &lt;code&gt;$asyncValidators&lt;/code&gt; do not run because any of the &lt;code&gt;$validators&lt;/code&gt; failed.</source>
          <target state="translated">当前状态是有效（true），无效（false），未决（undefined）还是已跳过（null）。待处理用于未实现的 &lt;code&gt;$asyncValidators&lt;/code&gt; 。当验证器由于解析错误而无法运行，并且 &lt;code&gt;$asyncValidators&lt;/code&gt; 由于任何 &lt;code&gt;$validators&lt;/code&gt; 失败而无法运行时，AngularJS将使用Skipped 。</target>
        </trans-unit>
        <trans-unit id="a7d197b14bb22dde26e7930ba72573db4afd74e5" translate="yes" xml:space="preserve">
          <source>Whether the injector should be in strict mode, which disallows argument name annotation inference.</source>
          <target state="translated">注入器是否应该采用严格模式,即不允许参数名注释推理。</target>
        </trans-unit>
        <trans-unit id="64739ed39c37793d5116ffd8cf13bce51648999d" translate="yes" xml:space="preserve">
          <source>Whether to generate an error when a rejected promise is not handled.</source>
          <target state="translated">当拒绝的承诺未被处理时,是否产生错误。</target>
        </trans-unit>
        <trans-unit id="04340f702909efe15652bdcae7630aa8d0a6c6a3" translate="yes" xml:space="preserve">
          <source>Which directives support animations?</source>
          <target state="translated">哪些指令支持动画?</target>
        </trans-unit>
        <trans-unit id="202e1367c10ec97bf55bcb003c4e2b1a5fb4d701" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;ngMessages&lt;/code&gt; will by default only display one error element at a time, the &lt;code&gt;ng-messages-multiple&lt;/code&gt; attribute can be applied to the &lt;code&gt;ngMessages&lt;/code&gt; container element to cause it to display all applicable error messages at once:</source>
          <target state="translated">虽然 &lt;code&gt;ngMessages&lt;/code&gt; 默认情况下一次仅显示一个错误元素，但是 &lt;code&gt;ng-messages-multiple&lt;/code&gt; 属性可以应用于 &lt;code&gt;ngMessages&lt;/code&gt; 容器元素，以使其一次显示所有适用的错误消息：</target>
        </trans-unit>
        <trans-unit id="b61c2bda7d6957ce6223a10bb226a52513d7256a" translate="yes" xml:space="preserve">
          <source>While a plural category may match many numbers (for example, in en-US locale, &quot;other&quot; can match any number that is not 1), an explicit number rule can only match one number. For example, the explicit number rule for &quot;3&quot; matches the number 3. There are examples of plural categories and explicit number rules throughout the rest of this documentation.</source>
          <target state="translated">虽然一个复数类别可能会匹配许多数字(例如,在美国语言中,&quot;其他 &quot;可以匹配任何非 1 的数字),但一个显式数字规则只能匹配一个数字。例如,&quot;3 &quot;的显式数字规则匹配的是数字3。在本文档的其余部分,还有复数类别和显式数字规则的例子。</target>
        </trans-unit>
        <trans-unit id="65f1a4c7640c97be8f83de892ee1d05acd23dd84" translate="yes" xml:space="preserve">
          <source>While it is recommended to register injectables directly with the &lt;a href=&quot;../api/ng/type/angular.module&quot;&gt;module API&lt;/a&gt;, it is also possible to register services, directives etc. by injecting &lt;a href=&quot;../api/auto/service/%24provide&quot;&gt;$provide&lt;/a&gt; or the individual service providers into the config function:</source>
          <target state="translated">虽然建议直接使用&lt;a href=&quot;../api/ng/type/angular.module&quot;&gt;模块API&lt;/a&gt;注册可注入对象，但也可以通过将&lt;a href=&quot;../api/auto/service/%24provide&quot;&gt;$ provide&lt;/a&gt;或各个服务提供者注入config函数来注册服务，指令等：</target>
        </trans-unit>
        <trans-unit id="79ae9ea22fa5db92c007dbd07a4fbcab0aa55fb4" translate="yes" xml:space="preserve">
          <source>While it's possible to bootstrap more than one AngularJS application per page, we don't actively test against this scenario. It's possible that you'll run into problems, especially with complex apps, so caution is advised.</source>
          <target state="translated">虽然每个页面有可能引导一个以上的AngularJS应用,但我们不会主动针对这种情况进行测试。你有可能会遇到问题,特别是对于复杂的应用程序,所以建议谨慎行事。</target>
        </trans-unit>
        <trans-unit id="a82dee00b39d8daed1da5528800a8c7ddbde426f" translate="yes" xml:space="preserve">
          <source>While the constructor-style use is supported, not all of the supporting methods from ES6 promises are available yet.</source>
          <target state="translated">虽然支持构造函数式的使用,但还不是所有ES6承诺的支持方法都可以使用。</target>
        </trans-unit>
        <trans-unit id="6cf978fc045daec3f25c0b99dc31760cd612ada9" translate="yes" xml:space="preserve">
          <source>While the example above is simple, it will not scale to large applications. Instead we recommend that you break your application to multiple modules like this:</source>
          <target state="translated">虽然上面的例子很简单,但它不会扩展到大型应用程序。相反,我们建议你将你的应用程序分解成多个模块,就像这样。</target>
        </trans-unit>
        <trans-unit id="fc6d8b80151efa65b509365d35de859e6d9b813c" translate="yes" xml:space="preserve">
          <source>While this may seem obvious it can be very difficult to call an individual function on a typical project. The reason is that the developers often mix concerns resulting in a piece of code which does everything. It makes an XHR request, it sorts the response data, and then it manipulates the DOM.</source>
          <target state="translated">虽然这看起来很明显,但在一个典型的项目中调用一个单独的函数是非常困难的。原因是开发人员经常混合关注的问题,导致一段代码什么都做。它发出XHR请求,对响应数据进行排序,然后对DOM进行操作。</target>
        </trans-unit>
        <trans-unit id="5d61d9a0a6e161682e0342ed06bfaa12eee85ebc" translate="yes" xml:space="preserve">
          <source>Why Dependency Injection?</source>
          <target state="translated">为什么要进行依赖性注入?</target>
        </trans-unit>
        <trans-unit id="669ff9e2a6793d3b75b94d0260040d47b3cbc679" translate="yes" xml:space="preserve">
          <source>Why is !important used?</source>
          <target state="translated">为什么要使用 !important?</target>
        </trans-unit>
        <trans-unit id="4616c58d9adc2d069251d8014e9dc1d4fb26a27f" translate="yes" xml:space="preserve">
          <source>Why mixing interpolation and expressions is bad practice:</source>
          <target state="translated">为什么将插值和表达式混用是不好的做法。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
