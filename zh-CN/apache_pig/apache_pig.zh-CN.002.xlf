<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="apache_pig">
    <body>
      <group id="apache_pig">
        <trans-unit id="ab5146bc0337c0c4ec162adcbc0f516bf45e19f0" translate="yes" xml:space="preserve">
          <source>For usage, see &lt;a href=&quot;#partitionby&quot;&gt;Example: PARTITION BY&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f9184fa3102a195538324a094c9f3e87e8512af" translate="yes" xml:space="preserve">
          <source>For usage, see &lt;a href=&quot;#partitionby&quot;&gt;Example: PARTITION BY&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0950ec5daec19b5369e8db389d77d478ef703948" translate="yes" xml:space="preserve">
          <source>For use with functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e73207156965726452940b3f15d34faa203e678" translate="yes" xml:space="preserve">
          <source>For use with streaming.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e710be2705e01b5fdc5bc69b770043ff7d7443e6" translate="yes" xml:space="preserve">
          <source>Force parallel &quot;1&quot; for &quot;group all&quot; statement. That's because even if we set parallel to N, only 1 reducer will be used in this case and all other reducer produce empty result.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4f05734f466b587d8c8a1997c40b3f98c2fd069" translate="yes" xml:space="preserve">
          <source>Format floats/doubles with %f, hexadecimal integers with %x (there are others besides -- see the &lt;a href=&quot;http://docs.oracle.com/javase/7/docs/api/java/util/Formatter.html&quot;&gt;Java docs&lt;/a&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65b19c46035a1e459a4e6bb765528e1af24e48c0" translate="yes" xml:space="preserve">
          <source>Format strings with %s, integers with %d. Types are converted for you where reasonable (here, int -&amp;gt; string).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0c02fc6d4fa96dcda39151919580b8f3027d3c2" translate="yes" xml:space="preserve">
          <source>Formats a set of values according to a printf-style template, using the &lt;a href=&quot;http://docs.oracle.com/javase/7/docs/api/java/util/Formatter.html&quot;&gt;native Java Formatter&lt;/a&gt; library.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37a95ef7b2da5e9dfb0b25b33a9688c6a79aa3a1" translate="yes" xml:space="preserve">
          <source>Fragment replicate join is a special type of join that works well if one or more relations are small enough to fit into main memory. In such cases, Pig can perform a very efficient join because all of the hadoop work is done on the map side. In this type of join the large relation is followed by one or more small relations. The small relations must be small enough to fit into main memory; if they don't, the process fails and an error is generated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7d2029d8a7b6c3c5acd074ab389e6e84bd20928" translate="yes" xml:space="preserve">
          <source>Fragment replicate joins are experimental; we don't have a strong sense of how small the small relation must be to fit into memory. In our tests with a simple query that involves just a JOIN, a relation of up to 100 M can be used if the process overall gets 1 GB of memory. Please share your observations and experience with us.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3b8fd3a28a763d9eab819f563e9a8f0681fa259" translate="yes" xml:space="preserve">
          <source>From your current working directory, compile the program. (Note that idlocal.class is written to your current working directory. Include &amp;ldquo;.&amp;rdquo; in the class path when you run the program.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68b6e84a59d14c66e17c94d2084cee2765bf4216" translate="yes" xml:space="preserve">
          <source>From your current working directory, compile the program. (Note that idmapreduce.class is written to your current working directory. Include &amp;ldquo;.&amp;rdquo; in the class path when you run the program.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d3c6572188487e7d0f0bf43f11a330f71f5a985" translate="yes" xml:space="preserve">
          <source>From your current working directory, run the program. To view the results, check the idout directory on your Hadoop system.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ae11fbd09e929b80dba1b8d2891594f82f70b9d" translate="yes" xml:space="preserve">
          <source>From your current working directory, run the program. To view the results, check the output file, id.out.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7a933fc62edcf10d9c4963f8596c7a787656527" translate="yes" xml:space="preserve">
          <source>Full outer join is not supported for bloom joins.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f3f294cdfe303f5625a901ee7d581a06175c157" translate="yes" xml:space="preserve">
          <source>Full outer join.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd51a32f96535333dd4e1a84807c6dd179d912eb" translate="yes" xml:space="preserve">
          <source>Function Instantiation</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84101354a0a57697de0f255638b9cba689a57826" translate="yes" xml:space="preserve">
          <source>Function Overloading</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41a40e8fa627c3e0562970952ab6b5e561ad1d21" translate="yes" xml:space="preserve">
          <source>Function names PigStorage and COUNT are case sensitive.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="160b3670e04858fde7e4140b45e86e3c1b2090a9" translate="yes" xml:space="preserve">
          <source>Function:</source>
          <target state="translated">Function:</target>
        </trans-unit>
        <trans-unit id="8a60d2c69bf2f39201997d6084ec499f9e7d4ad3" translate="yes" xml:space="preserve">
          <source>Functions can be a part of almost every operator in Pig. The &lt;a href=&quot;func&quot;&gt;Built In Functions&lt;/a&gt; guide describes Pig's built in functions. The &lt;a href=&quot;udf&quot;&gt;User Defined Functions&lt;/a&gt; manual shows you how to how to write your own functions and how to access/contribute functions using the Piggy Bank repository.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a1198fbca49df3b9353761343f6ab00ba7526e3" translate="yes" xml:space="preserve">
          <source>Functions:</source>
          <target state="translated">Functions:</target>
        </trans-unit>
        <trans-unit id="69c25d3382693097f4ee01b8b77967c5ef7e79d1" translate="yes" xml:space="preserve">
          <source>Future Enhancements</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c47a6ad23578fb44a406e049fe66c07a90f32a42" translate="yes" xml:space="preserve">
          <source>GENERATE expression [AS schema] [expression [AS schema]&amp;hellip;.]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea5a383494f81c4f464965d03bf916c41d68ced5" translate="yes" xml:space="preserve">
          <source>GROUP</source>
          <target state="translated">GROUP</target>
        </trans-unit>
        <trans-unit id="013e1ba0cbe0583ac34e8b6e095d4f74e6839fce" translate="yes" xml:space="preserve">
          <source>General Expressions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba7ce2025ad3e9884daf361153c61aba79035239" translate="yes" xml:space="preserve">
          <source>General expressions can be made up of UDFs and almost any operator. Since Pig does not consider boolean a base type, the result of a general expression cannot be a boolean. Field expressions are the simpliest general expressions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05659366d857f4eb5690afb9bdc9b7cff8960f88" translate="yes" xml:space="preserve">
          <source>Generates data transformations based on columns of data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d31621c5fbd4db9066caabd502e7f486ee3e5b1" translate="yes" xml:space="preserve">
          <source>GetDay</source>
          <target state="translated">GetDay</target>
        </trans-unit>
        <trans-unit id="a2818cfc533e59e26a20d03c8af18c62d9b9c5cb" translate="yes" xml:space="preserve">
          <source>GetDay(datetime)</source>
          <target state="translated">GetDay(datetime)</target>
        </trans-unit>
        <trans-unit id="3b156f58cad62688611629fcdf71abc53cfef5f1" translate="yes" xml:space="preserve">
          <source>GetHour</source>
          <target state="translated">GetHour</target>
        </trans-unit>
        <trans-unit id="7f19466d1ae92343794e23e8bd7e86f438306630" translate="yes" xml:space="preserve">
          <source>GetHour(datetime)</source>
          <target state="translated">GetHour(datetime)</target>
        </trans-unit>
        <trans-unit id="58893931dfea4b07fda21ca1e5395092265e2c3a" translate="yes" xml:space="preserve">
          <source>GetMilliSecond</source>
          <target state="translated">GetMilliSecond</target>
        </trans-unit>
        <trans-unit id="afef00aa595fe91edb36d72cf45140620b780d38" translate="yes" xml:space="preserve">
          <source>GetMilliSecond(datetime)</source>
          <target state="translated">GetMilliSecond(datetime)</target>
        </trans-unit>
        <trans-unit id="fbac074c454a28eb5bc3652325337229670aceab" translate="yes" xml:space="preserve">
          <source>GetMinute</source>
          <target state="translated">GetMinute</target>
        </trans-unit>
        <trans-unit id="6ddb6810694ebf38157652de08ac6474351f11dd" translate="yes" xml:space="preserve">
          <source>GetMinute(datetime)</source>
          <target state="translated">GetMinute(datetime)</target>
        </trans-unit>
        <trans-unit id="9a9c8d02c50cc38f21c8d41bc770a3c35f506480" translate="yes" xml:space="preserve">
          <source>GetMonth</source>
          <target state="translated">GetMonth</target>
        </trans-unit>
        <trans-unit id="f2fff6f22018398e947df0b8d628bc57c850fec7" translate="yes" xml:space="preserve">
          <source>GetMonth(datetime)</source>
          <target state="translated">GetMonth(datetime)</target>
        </trans-unit>
        <trans-unit id="ff6d2cdc9cd0bca91c09f0335184b3630e5b2deb" translate="yes" xml:space="preserve">
          <source>GetSecond</source>
          <target state="translated">GetSecond</target>
        </trans-unit>
        <trans-unit id="45f99eb79a9b7a9ba3bd539dcbbaf4f8c0817e77" translate="yes" xml:space="preserve">
          <source>GetSecond(datetime)</source>
          <target state="translated">GetSecond(datetime)</target>
        </trans-unit>
        <trans-unit id="dbe83da717d9b3ecc4a104bf9633dbb6f97546bc" translate="yes" xml:space="preserve">
          <source>GetWeek</source>
          <target state="translated">GetWeek</target>
        </trans-unit>
        <trans-unit id="b1f08071cdcc6fbf37da9c2cb680ecaa83720d89" translate="yes" xml:space="preserve">
          <source>GetWeek(datetime)</source>
          <target state="translated">GetWeek(datetime)</target>
        </trans-unit>
        <trans-unit id="535b65cc823f05d8dee165e5013a86a55c020e85" translate="yes" xml:space="preserve">
          <source>GetWeekYear</source>
          <target state="translated">GetWeekYear</target>
        </trans-unit>
        <trans-unit id="05f2caa2e1cdd71879407becb731af0dcee8c734" translate="yes" xml:space="preserve">
          <source>GetWeekYear(datetime)</source>
          <target state="translated">GetWeekYear(datetime)</target>
        </trans-unit>
        <trans-unit id="834cef9635aab01a61de7d362e8845f769065b31" translate="yes" xml:space="preserve">
          <source>GetYear</source>
          <target state="translated">GetYear</target>
        </trans-unit>
        <trans-unit id="fb7ba0f88bff662f921c57e03488fa999f79c2f9" translate="yes" xml:space="preserve">
          <source>GetYear(datetime)</source>
          <target state="translated">GetYear(datetime)</target>
        </trans-unit>
        <trans-unit id="010b85ad56b34c34c7c2a3b2436c740e30428ed5" translate="yes" xml:space="preserve">
          <source>Getting Started</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4682593736b76df959401b0677e46c3da95e5f88" translate="yes" xml:space="preserve">
          <source>Given a field named alpha whose value is ABCDEF, to return substring BCD use this statement: SUBSTRING(alpha,1,4). Note that 1 is the index of B (the first character of the substring) and 4 is the index of E (the character &lt;em&gt;following&lt;/em&gt; the last character of the substring).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2904ccdb85701307c7a4cf0211c6c673432f8e03" translate="yes" xml:space="preserve">
          <source>Given relation A above, the three fields are separated out in this table.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a460e02a6c7ad51f55a1454d1e43a85fd04b53c" translate="yes" xml:space="preserve">
          <source>Given this {$1, $2} Pig creates this {($1), ($2)} a bag with two tuples</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="819d769c6789870f4f6ec3bd99567803b29a16b7" translate="yes" xml:space="preserve">
          <source>Given this {($1), $2} Pig creates this {($1), ($2)} a bag with two tuples</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b8a3b30656b5b8d1c274bf06cf27e2edc4a7002" translate="yes" xml:space="preserve">
          <source>Given this {($1, $2)} Pig creates this {($1, $2)} a bag with a single tuple</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c18327c070894ced2aa384e5bac6ad7ebbd23172" translate="yes" xml:space="preserve">
          <source>Groovy to Pig</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="671afc89df0401f9442ee7ad8b3683045e599c39" translate="yes" xml:space="preserve">
          <source>Group/Organization and Version are optional fields. In such cases you can leave them blank.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="748922032ec9b2f255ede26d965bccd104ad8a43" translate="yes" xml:space="preserve">
          <source>GroupByConstParallelSetter</source>
          <target state="translated">GroupByConstParallelSetter</target>
        </trans-unit>
        <trans-unit id="6ac2bc105d01b75f0cb6647c28ad7b1ded321074" translate="yes" xml:space="preserve">
          <source>Grouped and ordered data &amp;ndash; The data for the same grouped key is guaranteed to be provided to the streaming application contiguously. Additionally, the data within the group is guaranteed to be sorted by the provided secondary key.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8cb388e32ba9398b3d8e495be2290836a832d3ca" translate="yes" xml:space="preserve">
          <source>Grouped data &amp;ndash; The data for the same grouped key is guaranteed to be provided to the streaming application contiguously</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20439eb031c2c2b9f6f2b1f7678cd259da8c350d" translate="yes" xml:space="preserve">
          <source>Groups the data in one or more relations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5b29066a94b56a4df47b36a243e361e26fd8c0a" translate="yes" xml:space="preserve">
          <source>HBaseStorage</source>
          <target state="translated">HBaseStorage</target>
        </trans-unit>
        <trans-unit id="bc02175406f48d300473a8fc281831d54e6647b9" translate="yes" xml:space="preserve">
          <source>HBaseStorage stores and loads data from HBase. The function takes two arguments. The first argument is a space seperated list of columns. The second optional argument is a space seperated list of options. Column syntax and available options are listed above. Note that HBaseStorage always disable split combination.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42e829762cee04a70bc5305f66fd119de2d0708d" translate="yes" xml:space="preserve">
          <source>HBaseStorage('columns', ['options'])</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a681ca832e37b54f22d309ff4273f4866e57dab0" translate="yes" xml:space="preserve">
          <source>Hadoop configuration files (include pig-cluster-hadoop-site.xml)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="020d890f6143875ea62437b4701c7f2b8c694a7e" translate="yes" xml:space="preserve">
          <source>Hadoop counters are easily accessible within EvalFunc by using PigStatusReporter object. Here is one example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="efd0ea6d637892905e05f7688a0e68aa55230d64" translate="yes" xml:space="preserve">
          <source>Hadoop properties are not interpreted by Pig but are passed directly to Hadoop. Any Hadoop property can be passed this way.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c073bed947ef004c13b391708120392ca11dadb" translate="yes" xml:space="preserve">
          <source>Handling Compression</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f90cbd026c5d20793d9146514d003112f491dc9" translate="yes" xml:space="preserve">
          <source>Handling null values in dimensions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="456113f4880e946d95b861c54ca030a6ccd9d9bc" translate="yes" xml:space="preserve">
          <source>Has no effect.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae32223dae550e038f070d4468e48d2258fd9abe" translate="yes" xml:space="preserve">
          <source>Hash-based Aggregation in Map Task</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41e875e1fcc46eff88f8e5016b5fc7b546a006fe" translate="yes" xml:space="preserve">
          <source>Hash-based aggregation has been shown to improve the speed of group-by operations by up to 50%. However, since this is a very new feature, it is currently turned OFF by default. To turn it ON, set the property pig.exec.mapPartAgg to true.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c2640b5898454356e628151c15672d38e055e19" translate="yes" xml:space="preserve">
          <source>Having a deterministic schema is very powerful; however, sometimes it comes at the cost of performance. Consider the following example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bfef818e148e3b8356ff2f774f2b9ee7df4e0e3b" translate="yes" xml:space="preserve">
          <source>Here D will be splitted into:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b126cd838c032776e841c16e4e7635096eb5aff" translate="yes" xml:space="preserve">
          <source>Here Python UDFs means C Python UDFs. It uses python command line to run the Python UDFs. It is different than Jython, which relies on Jython library. Instead, it streams the data in and out of the python process. The implementation mechanism is completely different than Jython.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f2c08c455258fee101fb67d0b42f00bc1baf24c" translate="yes" xml:space="preserve">
          <source>Here are two complete Ruby UDF samples.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8dcfe1b81cf245877e8f5d58903219442973ef1" translate="yes" xml:space="preserve">
          <source>Here is how AvroStorage translates Avro values to Pig:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e9d5893cd22a1028524ead1e3803b984d8322c6" translate="yes" xml:space="preserve">
          <source>Here is how AvroStorage translates Pig values to Avro:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d29548e0cb2915ac50ffc61f38a48d8d0a1e70d9" translate="yes" xml:space="preserve">
          <source>Here is the code for SimpleCustomPartitioner:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d42a9f211cf946a11b895acfcf50eecca384660" translate="yes" xml:space="preserve">
          <source>Here us a code snippet of the integer version of the MAX function that implements the interface:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69363bb44856067aa39c56a08488523df0c874c7" translate="yes" xml:space="preserve">
          <source>Here's the way to think about this in the Hadoop world. The exec function of the Initial class is invoked once for each input tuple by the map process and produces partial results. The exec function of the Intermed class is invoked once by each combiner invocation (which can happen zero or more times) and also produces partial results. The exec function of the Final class is invoked once by the reducer and produces the final result.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="729230c39ce6b3b3af88b635a6fffcb4e16631bf" translate="yes" xml:space="preserve">
          <source>Here's what the multi-query execution does to increase the performance:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d08b502754ac5a29f00b79cc168f4200278b24f3" translate="yes" xml:space="preserve">
          <source>Here, we read the file 'flights.txt' out of HDFS and store the results into the relation A. We extract a unique ID for the flight, its source and destination and the tail number from the given file. When STORE'ing back into Accumulo, we specify the column specifications (in this case, just a column family). It is also important to note that four elements are provided as columns because the first element in the Tuple is used as the row in Accumulo.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88f4ff51e4104da0415333a640e6fd975154c6c2" translate="yes" xml:space="preserve">
          <source>Hive UDF</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9ce0b773269b974a71ef6d3a6fce10ebf9a16ec" translate="yes" xml:space="preserve">
          <source>Hive UDF name. This can be a fully qualified class name of the Hive UDF/UDTF/UDAF class, or a registered short name in Hive FunctionRegistry (most Hive builtin UDF does that)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5b9d1b74a891758ac6053ce9ef2656a452abb0a" translate="yes" xml:space="preserve">
          <source>HiveUDAF</source>
          <target state="translated">HiveUDAF</target>
        </trans-unit>
        <trans-unit id="a7bf7f603ccf4f8e5fd4d24a6b4801fd41785386" translate="yes" xml:space="preserve">
          <source>HiveUDAF with constant parameter</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6be8ec051a4a129cb854a01427a634a2d62c1beb" translate="yes" xml:space="preserve">
          <source>HiveUDF</source>
          <target state="translated">HiveUDF</target>
        </trans-unit>
        <trans-unit id="1f5b904784c7a83976cd781e900ba741b08bcc25" translate="yes" xml:space="preserve">
          <source>HiveUDF(name[, constant parameters])</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57b25bdd42a8bfd89cde5d17150a800bbdd82d46" translate="yes" xml:space="preserve">
          <source>HiveUDF, HiveUDAF, HiveUDTF share the same syntax.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b176b48a267bfe0c13f39e147ccb976626dc67ed" translate="yes" xml:space="preserve">
          <source>HiveUDTF</source>
          <target state="translated">HiveUDTF</target>
        </trans-unit>
        <trans-unit id="0c649e2ec017b5914ee8ac547ddec61818f46581" translate="yes" xml:space="preserve">
          <source>Horizontal ellipsis points indicate that you can repeat a portion of the code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3c07a08d24fc29656223d7ad5fe33d21d2ff9db" translate="yes" xml:space="preserve">
          <source>HoursBetween</source>
          <target state="translated">HoursBetween</target>
        </trans-unit>
        <trans-unit id="d85ad836458e49eb6188932c56b1a9f36287859a" translate="yes" xml:space="preserve">
          <source>HoursBetween(datetime1, datetime2)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="100cb0b9b76cf128bd36c57de623e9519f3f1a9c" translate="yes" xml:space="preserve">
          <source>How it Works</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a512c42842d315c68d30298afe72953eec16d9c" translate="yes" xml:space="preserve">
          <source>How to Use a Simple Eval Function</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="859136ad08aa1c154af53341ef9e723eb18c7e39" translate="yes" xml:space="preserve">
          <source>How to Write a Simple Eval Function</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d404f08d8481d9ea8efead4d447a2938101dcb8f" translate="yes" xml:space="preserve">
          <source>How to enable Tez</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a04bea978466940a152fd73b98e9fbace4a67cf" translate="yes" xml:space="preserve">
          <source>However, if you further process relation X (Y = FILTER X BY $0 &amp;gt; 1;) there is no guarantee that the data will be processed in the order you originally specified (descending).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7be63e2881f7da8faa393bfe0ce4667f10916b66" translate="yes" xml:space="preserve">
          <source>IF</source>
          <target state="translated">IF</target>
        </trans-unit>
        <trans-unit id="74d77878ac50a503b2a5ae4d6f5d12f747eb630d" translate="yes" xml:space="preserve">
          <source>ILLUSTRATE</source>
          <target state="translated">ILLUSTRATE</target>
        </trans-unit>
        <trans-unit id="4cf3dfa0284dcad8ef3078afd5ea4e09752b0fad" translate="yes" xml:space="preserve">
          <source>ILLUSTRATE is based on an example generator (see &lt;a href=&quot;http://research.yahoo.com/files/paper_5.pdf&quot;&gt;Generating Example Data for Dataflow Programs&lt;/a&gt;). The algorithm works by retrieving a small sample of the input data and then propagating this data through the pipeline. However, some operators, such as JOIN and FILTER, can eliminate tuples from the data - and this could result in no data following through the pipeline. To address this issue, the algorithm will automatically generate example data, in near real-time. Thus, you might see data propagating through the pipeline that was not found in the original input data, but this data changes nothing and ensures that you will be able to examine the semantics of your Pig Latin statements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3eac28999aea33c81cb98bea80ea6fcce043fe8e" translate="yes" xml:space="preserve">
          <source>ILLUSTRATE {alias | -script scriptfile};</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b034fe864d511351df0ee4a7cfd55942cb62d4ba" translate="yes" xml:space="preserve">
          <source>IMPORT</source>
          <target state="translated">IMPORT</target>
        </trans-unit>
        <trans-unit id="89fff016f6b8ebc8add59a5f8f96f47f4a92e5df" translate="yes" xml:space="preserve">
          <source>IMPORT 'file-with-macro';</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1167b0e824163ea9e215a382f87b8f12fbf29970" translate="yes" xml:space="preserve">
          <source>IMPORT (macros)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5badbc082509a68348d1b2de0b506786bd7658d9" translate="yes" xml:space="preserve">
          <source>IMPORT adds the macro definitions to the Pig Latin namespace; these macros can then be invoked as if they were defined in the same file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6fca55ca3c828a46bfe96a10e69f572b61ce540c" translate="yes" xml:space="preserve">
          <source>IN</source>
          <target state="translated">IN</target>
        </trans-unit>
        <trans-unit id="059d298a40b3fec4385406229f5af45d61612a3d" translate="yes" xml:space="preserve">
          <source>IN (expression)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c55aaf120352287dba10abc369c393e2d067b025" translate="yes" xml:space="preserve">
          <source>IN operator allows you to easily test if an expression matches any value in a list of values. It is used to help reduce the need for multiple OR conditions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d85ce819eaff4a81308dc90de69623bf9480d8a" translate="yes" xml:space="preserve">
          <source>IN operator allows you to easily test if an expression matches any value in a list of values. It is used to reduce the need for multiple OR conditions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f22e0a8543ace135a5f509674fc4700b89a5896" translate="yes" xml:space="preserve">
          <source>IN operator is equivalent to nested OR operators.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d219b4dc13cdee432eb9cf599decd114b681ee36" translate="yes" xml:space="preserve">
          <source>INDEXOF</source>
          <target state="translated">INDEXOF</target>
        </trans-unit>
        <trans-unit id="2c95e05e2e3fc975e680d037087c38ecaa793399" translate="yes" xml:space="preserve">
          <source>INDEXOF(string, 'character', startIndex)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="091cedb09a5345c158de5c9b9ce5201d93e5d038" translate="yes" xml:space="preserve">
          <source>INPUT &amp;ndash; Keyword.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2e6f67f49f77e6f17a5a4a70377d85084890b16" translate="yes" xml:space="preserve">
          <source>INPUT ( {stdin | 'path'} [USING serializer] [, {stdin | 'path'} [USING serializer] &amp;hellip;] )</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce45b16212fe00c28d1a00de9cdfe954aa5bdc83" translate="yes" xml:space="preserve">
          <source>INTO</source>
          <target state="translated">INTO</target>
        </trans-unit>
        <trans-unit id="649d2864df18704de32e689e69e63f2483e8b76e" translate="yes" xml:space="preserve">
          <source>Identifiers</source>
          <target state="translated">Identifiers</target>
        </trans-unit>
        <trans-unit id="0fe012d40367d7664e9b3bf78c05516e6b49cdfd" translate="yes" xml:space="preserve">
          <source>Identifiers include the names of relations (aliases), fields, variables, and so on. In Pig, identifiers start with a letter and can be followed by any number of letters, digits, or underscores.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33cf76ea88eecf41631c2c6696ed2f52f782942a" translate="yes" xml:space="preserve">
          <source>If A is a relation (outer bag), a FOREACH statement could look like this.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="afe0e53cb4d9d90b6ba1aca74a93d2f8445ecde1" translate="yes" xml:space="preserve">
          <source>If A is an inner bag, a FOREACH statement could look like this.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c63da8e13e1306df1c5329f267b1cf013f00c39" translate="yes" xml:space="preserve">
          <source>If CUBE and ROLLUP operations are used together, the output groups will be the cross product of all groups generated by cube and rollup operation. If there are m dimensions in cube operations and n dimensions in rollup operation then overall number of combinations will be (2^m) * (n+1).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53995723b5b706a6616e5f264aad6a4b93b46fe0" translate="yes" xml:space="preserve">
          <source>If MyUDF is algebraic, the query will use combiner and run much faster. You can run explain command on your query to make sure that combiner is used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fbc88faf080a72258643a84cf95f10e149e13ae3" translate="yes" xml:space="preserve">
          <source>If Pig cannot resolve incompatible types through implicit casts, an error will occur. For example, you cannot add chararray and float (see the &lt;a href=&quot;#types-table-add&quot;&gt;Types Table for addition and subtraction&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e01f1d7383a02a96bedbc379dd0c0288bc379a73" translate="yes" xml:space="preserve">
          <source>If Pig determines that it needs to auto-ship an absolute path it will not ship it at all since there is no way to ship files to the necessary location (lack of permissions and so on).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e62658035d80920f5b1abb78f7987725661dad47" translate="yes" xml:space="preserve">
          <source>If Pig is unable to process the expression, Pig returns an exception.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3816a983fff2acee696300df0a392ba6e758130e" translate="yes" xml:space="preserve">
          <source>If a UDF returns a tuple or a bag and schema information is not provided, Pig assumes that the tuple contains a single field of type bytearray. If this is not the case, then not specifying the schema can cause failures. We look at this next.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="486e4f66991631e2d049a07741fd4d7ef1bfe823" translate="yes" xml:space="preserve">
          <source>If a custom loader using a text-based InputFormat or a file-based InputFormat would like to read files in all subdirectories under a given input directory recursively, then it should use the PigTextInputFormat and PigFileInputFormat classes provided in org.apache.pig.backend.hadoop.executionengine.mapReduceLayer. The Pig InputFormat classes work around a current limitation in the Hadoop TextInputFormat and FileInputFormat classes which only read one level down from the provided input directory. For example, if the input in the load statement is 'dir1' and there are subdirs 'dir2' and 'dir2/dir3' beneath dir1, the Hadoop TextInputFormat and FileInputFormat classes read the files under 'dir1' only. Using PigTextInputFormat or PigFileInputFormat (or by extending them), the files in all the directories can be read.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4794078ab3e12dc82064bb4f0a80d07b3c59c8f" translate="yes" xml:space="preserve">
          <source>If a function is algebraic but can be used in a FOREACH statement with accumulator functions, it needs to implement the Accumulator interface in addition to the Algebraic interface.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ccda3daa249c8bc65b4370e66326a311939c526e" translate="yes" xml:space="preserve">
          <source>If a loader implements IndexableLoadFunc, or implements OrderedLoadFunc and CollectableLoadFunc, its input splits won't be subject to possible combinations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d22536397a6526bff16d2b44ae5ad32b2dad3166" translate="yes" xml:space="preserve">
          <source>If a schema is defined as part of a load statement, the load function will attempt to enforce the schema. If the data does not conform to the schema, the loader will generate a null value or an error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d20b21a086aff45ff998ceac8189b33486fbc4c6" translate="yes" xml:space="preserve">
          <source>If a script has dependencies on the execution order outside of what Pig knows about, execution may fail.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c60b8394e3c8ca844c4dd6c95b31ff82395596c7" translate="yes" xml:space="preserve">
          <source>If a script with a alias is specified, it will output the plan for the given alias.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c929a573b654a6447af3bebd28ecf3072a0bfa7e" translate="yes" xml:space="preserve">
          <source>If a script without an alias is specified, it will output the entire execution graph (logical, physical, or map reduce).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b66f4af28f8442dd36e47f974b35d46ae1ab601" translate="yes" xml:space="preserve">
          <source>If a type is declared then ALL values in the map must be of this type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9165157e4c228dc6b25213c7bef47de768cebba" translate="yes" xml:space="preserve">
          <source>If an explicit cast is not supported, an error will occur. For example, you cannot cast a chararray to int.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c8c61b8e893dc2134f7b454bd561bcf24bcadc6" translate="yes" xml:space="preserve">
          <source>If any subexpression is null, the resulting expression is null.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb9518c418a6a42b64160ff3fdffbdf9e983c161" translate="yes" xml:space="preserve">
          <source>If arguments are not bags, an IOException is thrown.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67c0548636f03fb391aff763f50ae24a819f4ca2" translate="yes" xml:space="preserve">
          <source>If desired, custom logic can also be implemented for error handling by creating a subclass of MonitoredUDFExecutor.ErrorCallback, and overriding its handleError and/or handleTimeout methods. Both of those methods are static, and are passed in the instance of the EvalFunc that produced an exception, as well as an exception, so you may use any state you have in the UDF to process the errors as desired. The default behavior is to increment Hadoop counters every time an error is encountered. Once you have an implementation of the ErrorCallback that performs your custom logic, you can provide it in the annotation:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9eef31189a46ca896e1a11d04cfdc69be907574" translate="yes" xml:space="preserve">
          <source>If either subexpression is null, the result is null.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fbb8787a10e9277578f3bacf3c583933a72af49a" translate="yes" xml:space="preserve">
          <source>If either subexpression is null, the resulting expression is null.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df9492dcb135b34471ac4c01597f6c3e6e9d0c72" translate="yes" xml:space="preserve">
          <source>If either the string being matched against or the string defining the match is null, the result is null.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c7b8337ae5bc3235aee39b3bf00c4a3b18c0f1e" translate="yes" xml:space="preserve">
          <source>If field_delimiter is null or not passed, the following will be used as delimiters: space [ ], double quote [ &quot; ], coma [ , ] parenthesis [ () ], star [ * ].</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d38b38abb97f4eb1e0dcf9186921de58382f8118" translate="yes" xml:space="preserve">
          <source>If invoking Pig in Java, there is change in PigStats and PigProgressNotificationListener if using PigRunner.run(), check &lt;a href=&quot;test#pig-statistics&quot;&gt;Pig Statistics&lt;/a&gt; and &lt;a href=&quot;test#ppnl&quot;&gt;Pig Progress Notification Listener&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94ca295cf76f515a0109ec429d1f4a34670cbbe4" translate="yes" xml:space="preserve">
          <source>If load statement specify a schema, Pig will convert the complex type according to schema. If conversion fails, the affected item will be null (see &lt;a href=&quot;basic#nulls&quot;&gt;Nulls and Pig Latin&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f3c3c0240ae80e56e35fc2fe724ffaf7f5b93b5" translate="yes" xml:space="preserve">
          <source>If neither &quot;set default parallel&quot; nor the PARALLEL clause are used, Pig sets the number of reducers using a heuristic based on the size of the input data. You can set the values for these properties:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1dbfad22027ead0b9c53033155be2cdf92f70af" translate="yes" xml:space="preserve">
          <source>If no script is given:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c30b8a15458b41c3c14a039867b1afab3f19551" translate="yes" xml:space="preserve">
          <source>If null, bag arguments are replaced by empty bags.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f86825c5ae24539f35706c23d25d87bce6d588c" translate="yes" xml:space="preserve">
          <source>If one is running Pig in Tez mode (or both Tez/MapReduce mode), should pass PigTezProgressNotificationListener which extends PigProgressNotificationListener to PigRunner.run() to make sure to get notification in both Tez mode or MapReduce mode.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a520e683b22094fd77e688c9dcd1fed6eddf94bb" translate="yes" xml:space="preserve">
          <source>If one of the data sets is small enough to fit into memory, a Replicated Join is very likely to provide better performance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="207190487fec91fe50bf8a8e561b556722ac4451" translate="yes" xml:space="preserve">
          <source>If only one argument is given, the field is delimited with underscore characters</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="979bda1c695b72deb2de992c0dbc8fd750122f17" translate="yes" xml:space="preserve">
          <source>If parameters are specified in the Pig command line or in a parameter file, the script should include a $param_name for each para_name included in the command line or parameter file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3bd4de29e52beea43d5160ea3b5d527766906ff" translate="yes" xml:space="preserve">
          <source>If parameters are specified using the preprocessor statements, the script should include either %declare or %default.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52ce5e98f919ecf8fe4edf9131ddd0faddc8d6f2" translate="yes" xml:space="preserve">
          <source>If sort is provided by the loader, rather than an explicit Order operation, the right-side loader must implement either the {OrderedLoadFunc} interface or {IndexableLoadFunc} interface.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aee0b5384005bdfb9e581a456be8ae8427f85fcd" translate="yes" xml:space="preserve">
          <source>If tagPath or tagFile option is specified, PigStorage will add a pseudo-column INPUT_FILE_PATH or INPUT_FILE_NAME respectively to the beginning of the record. As the name suggests, it is the input file path/name containing this particular record. Please note tagsource is deprecated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d16362f5232337bd67ea5e2e860c60236bd2764" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;#flatten&quot;&gt;FLATTEN&lt;/a&gt; operator is used, enclose the schema in parentheses.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0caf7a1673c2590cb133f449af480656dad1cb8b" translate="yes" xml:space="preserve">
          <source>If the FLATTEN operator is not used, don't enclose the schema in parentheses.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8742c01ca7dfdb8c7b97679f58a80857cfe6e74b" translate="yes" xml:space="preserve">
          <source>If the STORE and LOAD both had exact matching file paths, Pig will recognize the implicit dependency and launch two different mapreduce jobs/Tez DAGs with the second job depending on the output of the first one. exec is not required to be specified in that case.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce8a9990603bf3420d85f373d9702d4a3cac5619" translate="yes" xml:space="preserve">
          <source>If the USING clause is omitted, the default load function PigStorage is used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="caf383bc86d8a53d213a4ff08b295b5cdb463fbc" translate="yes" xml:space="preserve">
          <source>If the USING clause is omitted, the default store function PigStorage is used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ade11ca523a11122e604fa8fcd322615b76561d" translate="yes" xml:space="preserve">
          <source>If the build is successful, you should see the pig.jar file created in that directory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e73841d4f5c17efd8924856bacadb48c1718106" translate="yes" xml:space="preserve">
          <source>If the de-referenced tuple or map is null, returns null.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="136bbc1ae8c1804896ccba758e270481404a38b7" translate="yes" xml:space="preserve">
          <source>If the first word on the streaming command is perl or python, Pig assumes that the binary is the first non-quoted string it encounters that does not start with dash.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2edbaa925c2b4bb7fab3191de0feae3407e8c8ae" translate="yes" xml:space="preserve">
          <source>If the group-by keys used for grouping don't result in a sufficient reduction in the number of records, the performance might be worse with this feature turned ON. To prevent this from happening, the feature turns itself off if the reduction in records sent to combiner is not more than a configurable threshold. This threshold can be set using the property pig.exec.mapPartAgg.minReduction. It is set to a default value of 10, which means that the number of records that get sent to the combiner should be reduced by a factor of 10 or more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0a0dbd61aa62c74fcf75355267ae83889868c65" translate="yes" xml:space="preserve">
          <source>If the input relation has a schema, you can refer to columns by alias rather than by column position. You can also combine aliases and column positions in an expression; for example, &quot;col1 .. $5&quot; is valid.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1aceb56e8670ae04161c5161bd71a70daf79faf0" translate="yes" xml:space="preserve">
          <source>If the macro has no return alias, then void must be specified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab05a18b7e2fd87f280e1388a3db09480d98d569" translate="yes" xml:space="preserve">
          <source>If the noschema option is NOT specified, and a schema is found, it gets loaded when loading data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc815978d8fbacfa3f024e4ccf2f529fd09fcb51" translate="yes" xml:space="preserve">
          <source>If the parameters of the EvalFunc are all constants, Pig could evaluate the result at compile time. The benefit of evaluating at compile time is performance optimization, and enable certain other optimizations at front end (such as partition pruning, which only allow constant not UDF in filter condition). By default, compile time evaluation is disabled in EvalFunc to prevent potential side effect. To enable it, override allowCompileTimeCalculation. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37792a4c1c43f548d87fd2c3c9b325971248e022" translate="yes" xml:space="preserve">
          <source>If the query is rewritten to</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="884e911c9fc042d4017b9c9111d9b8041a7952e3" translate="yes" xml:space="preserve">
          <source>If the result value is not a number (NaN), Pig returns null.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c1585043821cee828c177bd1dee01acb15c382d" translate="yes" xml:space="preserve">
          <source>If the result value is null or empty, Pig returns null.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="832a57705057f4442db3191d05182bfe04aabc3e" translate="yes" xml:space="preserve">
          <source>If the schema is null, Pig treats all fields as bytearray (in the backend, Pig will determine the real type for the fields dynamically)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0b624c38d08281a478732651dc5b82106034b90" translate="yes" xml:space="preserve">
          <source>If the schema of a relation can&amp;rsquo;t be inferred, Pig will just use the runtime data as is and propagate it through the pipeline.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e6717986491eb0953097c78d9d3c2a67abe2393" translate="yes" xml:space="preserve">
          <source>If the schema option is NOT specified, a schema will not be written when storing data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff2b36c03367bc79f4d31985e06636e1530acb9a" translate="yes" xml:space="preserve">
          <source>If the schema option is specified, a hidden &quot;.pig_schema&quot; file is created in the output directory when storing data. It is used by PigStorage (with or without -schema) during loading to determine the field names and types of the data without the need for a user to explicitly provide the schema in an as clause, unless noschema is specified. No attempt to merge conflicting schemas is made during loading. The first schema encountered during a file system scan is used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eda78a9c0114a6e6fb5cb21af8108768e29477da" translate="yes" xml:space="preserve">
          <source>If the script doesn't re-load A' for the processing of A the steps above A' will be duplicated. This is a special case of Example 2 above, so the same steps are recommended. With multi-query execution, the script will process A and dump A' as a side-effect.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56ff9b9e7d57fa5c8fe5a67569d32c6b3312a279" translate="yes" xml:space="preserve">
          <source>If the ship and cache options are not specified, Pig will attempt to auto-ship the binary in the following way:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6540b7615ec5950ced044baf9a5fecbbb70e65b7" translate="yes" xml:space="preserve">
          <source>If the specified number of output tuples is equal to or exceeds the number of tuples in the relation, all tuples in the relation are returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="661dd3451b1f1f8a9425df1c0a8c2855275567c4" translate="yes" xml:space="preserve">
          <source>If the specified number of output tuples is less than the number of tuples in the relation, then n tuples are returned. There is no guarantee which n tuples will be returned, and the tuples that are returned can change from one run to the next. A particular set of tuples can be requested using the ORDER operator followed by LIMIT.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="018691f5562232d00cbae123ff01bedb87fa8b15" translate="yes" xml:space="preserve">
          <source>If the tested object is null, returns null.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e1b93c2a09e03a21f0905f246868a8fad2e9176" translate="yes" xml:space="preserve">
          <source>If the tested object is null, the SIZE function returns null.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52452dd37cfe0e014d1a5eeb279eb873c8dd2f17" translate="yes" xml:space="preserve">
          <source>If the tested value is not null, returns true; otherwise, returns false (see &lt;a href=&quot;#null_operators&quot;&gt;Null Operators&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05bcf78db415053b73d510bab61b81cfa58b8490" translate="yes" xml:space="preserve">
          <source>If the tested value is null, returns true; otherwise, returns false (see &lt;a href=&quot;#null_operators&quot;&gt;Null Operators&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45e72887e023eb789c7ad2ce2f5d3f8a9395e06f" translate="yes" xml:space="preserve">
          <source>If the the underlying data is sufficiently skewed, bloom join might not help. Skewed join can be considered for those cases.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a278eee26bc0d40cd14c07492b34d0e32ef8c022" translate="yes" xml:space="preserve">
          <source>If the type is omitted, the field defaults to type bytearray.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df75bf757439ba68f277b7d366c1fe4887dcb0d3" translate="yes" xml:space="preserve">
          <source>If the value is negative, no limit is applied for the length of the result tuple.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36672551acc7fb0ca7d3aa692155b038a5a092b7" translate="yes" xml:space="preserve">
          <source>If the value is negative, no limit is applied to the size of the result bag.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="989efda04814537696830f9d12387663f1d8fe4d" translate="yes" xml:space="preserve">
          <source>If the value is positive, the pattern (the compiled representation of the regular expression) is applied at most limit-1 times, therefore the value of the argument means the maximum length of the result tuple. The last element of the result tuple will contain all input after the last match.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6d264e7216fcd7fd94f7b27901536988583458c" translate="yes" xml:space="preserve">
          <source>If the value is positive, the pattern (the compiled representation of the regular expression) is applied at most limit-1 times, therefore the value of the argument means the maximum size of the result bag. The last tuple of the result bag will contain all input after the last match.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03070291f5db09d8b1e48844535ce39e98bd447f" translate="yes" xml:space="preserve">
          <source>If the value is zero, no limit is applied for the length of the result tuple too, and trailing empty strings (if any) will be removed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e89973f6facf127728c69232069efe9c532fbb6" translate="yes" xml:space="preserve">
          <source>If the value is zero, no limit is applied to the size of the result bag too, and trailing empty strings (if any) will be removed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6231df4fcddcd0669f4101ebd7715a2f671b8fe9" translate="yes" xml:space="preserve">
          <source>If there is a filter statement right after OrcStorage, Pig will push the filter condition to the loader. OrcStorage will prune file/stripe/row group which does not satisfy the condition entirely. For the file/stripe/row group contains data that satisfies the filter condition, OrcStorage will load the file/stripe/row group and Pig will evaluate the filter condition again to remove additional data which does not satisfy the filter condition.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59ca04d3d9150ea272608b03ae0156c687fc7b38" translate="yes" xml:space="preserve">
          <source>If types are not specified in the load statement, Pig assumes the type of =double= for numeric computations. A lot of the time, your data would be much smaller, maybe, integer or long. Specifying the real type will help with speed of arithmetic computation. It has an additional advantage of early error detection.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24fb50f409eb821f7919123b47b4f273f7700fc1" translate="yes" xml:space="preserve">
          <source>If user specify neither &quot;parallel&quot; or &quot;default_parallel&quot;, Pig will use automatic parallelism. In MapReduce, Pig submit one MapReduce job a time and before submiting a job, Pig has chance to automatically set reduce parallelism based on the size of input file. On the contrary, Tez submit a DAG as a unit and automatic parallelism is managed in three parts</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4dc665c403c330f35903b458f6fe6096a2ced59" translate="yes" xml:space="preserve">
          <source>If you FLATTEN a bag with empty inner schema, the schema for the resulting relation is null.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9dad6c87764738da3cfc061e6f727d2a6799327" translate="yes" xml:space="preserve">
          <source>If you UNION two relations with incompatible schema, the schema for resulting relation is null.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56e8101602c2d9c75a14cf49e518adb7c0ea62ba" translate="yes" xml:space="preserve">
          <source>If you are just a user of UDFs, this is most of what you need to know about UDFs to use them in your code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c772834e2a9aed00764a6e96ad1c9163813c083" translate="yes" xml:space="preserve">
          <source>If you are using Spark, you will also need to specify SPARK_HOME and specify SPARK_JAR which is the hdfs location where you uploaded $SPARK_HOME/lib/spark-assembly*.jar:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6cb81c239c67bf888e13b2d22dde63010dbe3dfb" translate="yes" xml:space="preserve">
          <source>If you are using Tez, you will also need to put Tez configuration directory (the directory that contains the tez-site.xml):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f86801fd7dc0106a735a5ab7b2fbc69bbc1e2ca3" translate="yes" xml:space="preserve">
          <source>If you assign a name to a field, you can refer to that field using the name or by positional notation. If you don't assign a name to a field (the field is un-named) you can only refer to the field using positional notation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c2068efddb33c739f6e1e4118009324d44d4dc5" translate="yes" xml:space="preserve">
          <source>If you assign a type to a field, you can subsequently change the type using the cast operators. If you don't assign a type to a field, the field defaults to bytearray; you can change the default type using the cast operators.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93009caea4faeed63c7a3f49e29e15e2d31dcaf9" translate="yes" xml:space="preserve">
          <source>If you do &lt;a href=&quot;test#describe&quot;&gt;DESCRIBE&lt;/a&gt; on B, you will see a single column of type double. This is because Pig makes the safest choice and uses the largest numeric type when the schema is not know. In practice, the input data could contain integer values; however, Pig will cast the data to double and make sure that a double result is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c200fd2558a69c650aaf5de63cfc921f16db98be" translate="yes" xml:space="preserve">
          <source>If you don't supply a DEFINE for a given streaming command, then auto-shipping is turned off.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7d732bcc63d3993a0471861bd1df7f8145f5af3" translate="yes" xml:space="preserve">
          <source>If you have more questions, you can ask on the &lt;a href=&quot;http://hadoop.apache.org/pig/mailing_lists.html&quot;&gt;Pig Mailing Lists&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76dbbb85aae7650b87268f029aecb7ef5ea47ad5" translate="yes" xml:space="preserve">
          <source>If you need an alternative format, you will need to create a custom serializer/deserializer by implementing the following interfaces.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ab330aaf103a3416195109dc88d65171a3113af" translate="yes" xml:space="preserve">
          <source>If you order relation A to produce relation X (X = ORDER A BY * DESC;) relations A and X still contain the same data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e50578ad11c2c7c9f284f3844fbe57c5a3d59d7" translate="yes" xml:space="preserve">
          <source>If you pass a parameter to a script that the script does not use, this parameter is silently ignored. If the script has a parameter and no value is supplied or substituted, an error will result.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1369a59a2bb2e259294a035010e7c4da3f78013e" translate="yes" xml:space="preserve">
          <source>If you retrieve relation X (DUMP X;) the data is guaranteed to be in the order you specified (descending).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07b727742d1a4fca1de7143e1c07d0e86425235b" translate="yes" xml:space="preserve">
          <source>If you specify a directory name, all the files in the directory are loaded.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b27e9a3e53e3fef81b3d326d2e23e78ab25c9ea" translate="yes" xml:space="preserve">
          <source>If you use a local cluster, you need to set the required environment variables before starting it:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6a85122c8dd900955aa81ccb9781c63a8e5c20c" translate="yes" xml:space="preserve">
          <source>If you use concatenated bzip files with your Pig jobs, you will NOT see a failure but the results will be INCORRECT.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec27bed12f5b3966ebd9a9d8528ad6a6ed6a7aba" translate="yes" xml:space="preserve">
          <source>If your Pig script generates a sequence of MapReduce jobs, you can compress the output of the intermediate jobs using LZO compression. (Use the &lt;a href=&quot;test#EXPLAIN&quot;&gt;EXPLAIN&lt;/a&gt; operator to determine if your script produces multiple MapReduce Jobs.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1239ee562b13227e2353dd2b5d0642351c9fb666" translate="yes" xml:space="preserve">
          <source>If your UDF can't be made Algebraic but is able to deal with getting input in chunks rather than all at once, consider implementing the Accumulator interface to reduce the amount of memory used by your script. If your function &lt;em&gt;is&lt;/em&gt; Algebraic and can be used on conjunction with Accumulator functions, you will need to implement the Accumulator interface as well as the Algebraic interface. For more information, see &lt;a href=&quot;udf#accumulator-interface&quot;&gt;Accumulator Interface&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="349f0b1b2f441677a38531ccee38d0d7d15aa938" translate="yes" xml:space="preserve">
          <source>If your data and loaders satisfy these conditions, the &amp;lsquo;merge&amp;rsquo; clause to perform an optimized version of COGROUP; the operation will execute on the map side and avoid running the reduce phase.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f86b761e8e078b0506cc07cd02d05eb34d02e1a7" translate="yes" xml:space="preserve">
          <source>If your data and loaders satisfy these conditions, use the &amp;lsquo;collected&amp;rsquo; clause to perform an optimized version of GROUP; the operation will execute on the map side and avoid running the reduce phase.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="feef6e3b59816e49d675edf99fac1a33a1fb5a57" translate="yes" xml:space="preserve">
          <source>If your loader implementation makes use of the PigSplit object passed through the prepareToRead method, then you may need to rebuild the loader since the definition of PigSplit has been modified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dee1bf176cbe01fd0441b1a12c13b06adb1b7153" translate="yes" xml:space="preserve">
          <source>Implement UDF by Simulation</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5827f6f79b07ec443d93d8058ad81cc9d4d2ac27" translate="yes" xml:space="preserve">
          <source>Implicit Dependencies</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c4d1de553948a314adeca034d84e23cd3b9ae4a" translate="yes" xml:space="preserve">
          <source>Import Lists</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e56c1186fa7d5c3374f67d59101df99e56c90cb" translate="yes" xml:space="preserve">
          <source>Import macros defined in a separate file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe0f554fef6d8bbe2bada744a7a99611cdfdc416" translate="yes" xml:space="preserve">
          <source>Importing Modules</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="398119218cf11b626396e7917ac6cf24641f838c" translate="yes" xml:space="preserve">
          <source>Improvements and other components based on PigUnit that could be built later.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab855867b4034f4bb99051d1f3ccaf64cefc7280" translate="yes" xml:space="preserve">
          <source>In Pig Latin,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b89c2531e0f47016cb2eac1f0115cc5c90e90d9" translate="yes" xml:space="preserve">
          <source>In Pig Latin, expressions are language constructs used with the FILTER, FOREACH, GROUP, and SPLIT operators as well as the eval functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="047330b0ff963c6df380d337f23e804c0fa8f828" translate="yes" xml:space="preserve">
          <source>In Pig Latin, nulls are implemented using the SQL definition of null as unknown or non-existent. Nulls can occur naturally in data or can be the result of an operation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2b472a5cb1d2bb6677c5894a233ab880022ee5b" translate="yes" xml:space="preserve">
          <source>In Pig, problems with memory usage can occur when data, which results from a group or cogroup operation, needs to be placed in a bag and passed in its entirety to a UDF.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77ac446bcfdd607749e9908e882446119d984b45" translate="yes" xml:space="preserve">
          <source>In Pig, relations are unordered (see &lt;a href=&quot;#relations&quot;&gt;Relations, Bags, Tuples, Fields&lt;/a&gt;):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77395bf675c2c5145ba7cb6ba484de1ce1ad1445" translate="yes" xml:space="preserve">
          <source>In Tez, jvm could reuse for other tasks. It is important to cleanup static variable to make sure there is no side effect. Here is one example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7dd89a54572b05053fd654da00615655e3c8186b" translate="yes" xml:space="preserve">
          <source>In a load statement, the loader will inject null into the tuple. The actual value that is substituted for null is loader specific; for example, PigStorage substitutes an empty field for null.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ab73a609fcb251095ae635071ba701b69b3b5ae" translate="yes" xml:space="preserve">
          <source>In a non-load statement, if a requested field is missing from a tuple, Pig will inject null.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="761d64cc264226017ae6e486dbdb548f042b4ea4" translate="yes" xml:space="preserve">
          <source>In addition to position, data grouping and ordering can be determined by the data itself. However, you need to know the property of the data to be able to take advantage of its structure.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e5448a648336936524e336b0e640a723e9a9434" translate="yes" xml:space="preserve">
          <source>In addition to providing Pig script via a string, you can store it in a file and pass the file to the compile call:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ea3be12b2777f643d5e98b83b6f48b651f89c54" translate="yes" xml:space="preserve">
          <source>In cases where the schema is stored as part of the StoreFunc like PigStorage, JsonStorage, AvroStorage or OrcStorage, users generally have to use an extra FOREACH before STORE to rename the field names and remove the disambiguate operator from the names. To automatically remove the disambiguate operator from the schema for the STORE operation, the pig.store.schema.disambiguate Pig property can be set to &quot;false&quot;. It is the responsibility of the user to make sure that there is no conflict in the field names when using this setting.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb09a5599dba9a08193e6ba5ca41cf184a2941b2" translate="yes" xml:space="preserve">
          <source>In general, lowercase type indicates elements that you supply.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="667bae580123f622168d5ecaf410d9ca73353cd3" translate="yes" xml:space="preserve">
          <source>In general, uppercase type indicates elements the system supplies.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43385afe9d70e705c298432cd61a48b9ebab8e78" translate="yes" xml:space="preserve">
          <source>In its basic form, compile just takes a Pig Latin fragment that defines the pipeline as described in the previous section. Additionally, the pipeline can be given a name. This name is only used when the embedded script is invoked via the PigRunner Java API (as discussed later in this document).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c386aecc87f49116be4bbc8980ea9301e6beef05" translate="yes" xml:space="preserve">
          <source>In its simplest form, bind takes no parameters. In this case, an implicit bind is performed; Pig internally constructs a map of parameters from the local variables specified by the user in the script.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6ce11ff76294b5348b9aa96365ef9638cb0d1b7" translate="yes" xml:space="preserve">
          <source>In many cases, AvroStorage will automatically translate your data correctly and you will not need to provide any more information to AvroStorage. But sometimes, it may be convenient to manually provide a schema to AvroStorge. See the example selection below for examples on manually specifying a schema with AvroStorage.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d274aa391941e3db3eaf1d92d4ca5b2b777dcc2" translate="yes" xml:space="preserve">
          <source>In map-reduce mode, the following script will load from &quot;hdfs://&amp;lt;host&amp;gt;:&amp;lt;port&amp;gt;/data1&quot; and store into &quot;hdfs://&amp;lt;host&amp;gt;:&amp;lt;port&amp;gt;/tmp/out1&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fbac605553184ef19261778bcb7ec6f398ca51e3" translate="yes" xml:space="preserve">
          <source>In order to avoid replicated joins on large relations, we fail if size of relation(s) to be replicated (in bytes) is greater than pig.join.replicated.max.bytes (default = 1GB).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6df614c8a5e9de3ecdeefdab6a02557f17f3174" translate="yes" xml:space="preserve">
          <source>In parameter file, as part of a command line.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a83607c547c007f3cf1a9c56712a1e100cdccaa1" translate="yes" xml:space="preserve">
          <source>In prior Pig releases, Example 1 will dump A' to disk and then start jobs for B' and C'. Example 2 will execute all the dependencies of B' and store it and then execute all the dependencies of C' and store it. Both are equivalent, but the performance will be different.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3dd2199bc012d7207d555ef9e715d44419202375" translate="yes" xml:space="preserve">
          <source>In some cases it might be desirable to fail the entire script upon detecting the first failed job. This can be achieved with the &quot;-F&quot; or &quot;-stop_on_failure&quot; command line flag. If used, Pig will stop execution when the first failed job is detected and discontinue further processing. This also means that file commands that come after a failed store in the script will not be executed (this can be used to create &quot;done&quot; files).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a902912f349147fbbe0eb2d57a40fcb3a4e6de06" translate="yes" xml:space="preserve">
          <source>In the FOREACH statement, the field in relation B is referred to by positional notation ($0).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0534091b29b78ead8b83df710a7671a6499bd98e" translate="yes" xml:space="preserve">
          <source>In the SQL case, the SQLLoader function is invoked with 'sql://mytable'.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7013811a67a11af4ac23552269ed48873de74a1b" translate="yes" xml:space="preserve">
          <source>In the above example, a variety of expressions can be applied to algebraic functions including:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e34e2cb53ddbb0085cbc3e5a61b4772c7d5c3c2" translate="yes" xml:space="preserve">
          <source>In the above example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="789a8aaef2965b6eb70d651d97130eed1c314f0f" translate="yes" xml:space="preserve">
          <source>In the case of inner join and right outer join, the right most relation is used for building the bloom filter and the users are expected to specify the smaller dataset as the right most relation. But in the case of left outer join, the left most relation is used for building the bloom filter and is expected to be the smaller dataset. This is because all records of the outer relation should be in the result and no records can be filtered. If the left relation turns out to be the bigger dataset, it would not be as efficient to build the bloom filter on the bigger dataset. But it might still perform better than a regular join if it is able to filter lot of records from the right relation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="366cfaa9f77dcf4de6672d5c4eeb8495d9aab995" translate="yes" xml:space="preserve">
          <source>In the example above relation A is loaded from HDFS and stored in HBase. Note that the schema of relation A is a tuple of size 3, but only two column descriptor names are passed to the HBaseStorage constructor. This is because the first entry in the tuple is used as the HBase rowKey.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8768ae4a7963f867789d54883f792a4b049338c3" translate="yes" xml:space="preserve">
          <source>In the example below, note the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="810f4025eba8164da7f5c931db880c74c3f881c2" translate="yes" xml:space="preserve">
          <source>In the script, parameter names can be escaped with the backslash character ( \ ) in which case substitution does not take place.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="823a66cbb60bb79080f0a8b1ea0d329c7d74614e" translate="yes" xml:space="preserve">
          <source>In these examples a directory is created, a file is copied, a file is listed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9fb53acc5fc864b189dffd5763e2ccfc43d29a03" translate="yes" xml:space="preserve">
          <source>In this example A is a relation or bag of tuples. You can think of this bag as an outer bag.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2b8d5695ad31a39e71eead60f9a78e531f16388" translate="yes" xml:space="preserve">
          <source>In this example BinStorage is used to load multiple locations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb4dad7abc1d7506c6a665f7d105adc4e5904a6a" translate="yes" xml:space="preserve">
          <source>In this example BinStorage is used with the LOAD and STORE functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a58d2ef04a5cda433ef29f50daa6af7e7faab9f" translate="yes" xml:space="preserve">
          <source>In this example COUNT_STAR is used to count the tuples in a bag.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ff7470c5528ca285c04a3c3ac0c8d55936316c0" translate="yes" xml:space="preserve">
          <source>In this example DIFF compares the tuples in two bags.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59300d5fb1b29001840b069de1bdcfdde402ef36" translate="yes" xml:space="preserve">
          <source>In this example FOREACH is nested to the second level.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1481519e4226587e1177016b76ec2132f08cef8" translate="yes" xml:space="preserve">
          <source>In this example HBaseStorage is used to store a relation into HBase.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab84b86ed1cd0f81d89240b20eeb6f47b9930a87" translate="yes" xml:space="preserve">
          <source>In this example HBaseStorage is used with the LOAD function with an explicit schema.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="435c4dd4d77b5e857be6bf8ad142ee3d71a0e7a5" translate="yes" xml:space="preserve">
          <source>In this example PARALLEL is used with the GROUP operator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40cb6c5ae4d9ef5896bcd6d4b036252b875f816a" translate="yes" xml:space="preserve">
          <source>In this example Pig will validate, but not execute, the LOAD and FOREACH statements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de61ae61ea6032b2e228021c21932ce307a7c989" translate="yes" xml:space="preserve">
          <source>In this example PigDump is used with the STORE function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46d2148592ebc16cb761333836a92127b54281f5" translate="yes" xml:space="preserve">
          <source>In this example PigStorage expects input.txt to contain tab-separated fields and newline-separated records. The statements are equivalent.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6470b4bdc80ce6ec14c6b369cff173d8a96a70af" translate="yes" xml:space="preserve">
          <source>In this example PigStorage stores the contents of X into files with fields that are delimited with an asterisk ( * ). The STORE statement specifies that the files will be located in a directory named output and that the files will be named part-nnnnn (for example, part-00000).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3545f3dfb4a61c191d5ce7c17db12055dbea1552" translate="yes" xml:space="preserve">
          <source>In this example PigStreaming is the default serialization/deserialization function. The tuples from relation A are converted to tab-delimited lines that are passed to the script.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53acd63180313d053382b996221400c3670c3ad0" translate="yes" xml:space="preserve">
          <source>In this example PigStreaming is used as the serialization/deserialization function, but a comma is used as the delimiter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="505900e4da0fa482992eb1a2f88bcc0e5d38a43b" translate="yes" xml:space="preserve">
          <source>In this example REGISTER states that the JavaScript module, myfunc.js, is located in the /src directory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50cb9301684455fe267eae841880105c8315f523" translate="yes" xml:space="preserve">
          <source>In this example TextLoader is used with the LOAD function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c5e9d3dd6f9a44bb764a99545f07562b251abc9" translate="yes" xml:space="preserve">
          <source>In this example X is a relation or bag of tuples. The tuples in relation X have two fields. The first field is type int. The second field is type bag; you can think of this bag as an inner bag.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2bf5f5dc213edcf0c2a75a62d467adfd719f4117" translate="yes" xml:space="preserve">
          <source>In this example a CROSS is performed within the nested block.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d96da638dd744c8666b0a4d7441d6698bbcae66" translate="yes" xml:space="preserve">
          <source>In this example a JAR file stored in HDFS and a local JAR file are registered.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c853730b16a0a6d3de6a48047bf1fd0903963d8c" translate="yes" xml:space="preserve">
          <source>In this example a and null are projected.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="252278b82d54611f8604f3c1c4920b5131753f06" translate="yes" xml:space="preserve">
          <source>In this example a bytearray (fld in relation A) is cast to type bag.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52be4343435f44112a5462538218eec269b8c99a" translate="yes" xml:space="preserve">
          <source>In this example a bytearray (fld in relation A) is cast to type map.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="adc6b1c539b7f3b4f765bf66f1bbf223243eec17" translate="yes" xml:space="preserve">
          <source>In this example a bytearray (fld in relation A) is cast to type tuple.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b780edd4e748b15aca64e2b122fa86c500341bd8" translate="yes" xml:space="preserve">
          <source>In this example a command is defined for use with the &lt;a href=&quot;#stream&quot;&gt;STREAM&lt;/a&gt; operator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a42086ec48674799538294ab226a5ef8414b48d8" translate="yes" xml:space="preserve">
          <source>In this example a dump is performed after each statement.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28b34e252e518f10cb207856de095b2d0a0edae9" translate="yes" xml:space="preserve">
          <source>In this example a field delimiter is specified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="231dd12f30cc168f8fe434f1dc9d10741002943a" translate="yes" xml:space="preserve">
          <source>In this example a function is defined for use with the FOREACH &amp;hellip;GENERATE operator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="902f7920721a3a412c9e07306586280fa07bbed2" translate="yes" xml:space="preserve">
          <source>In this example a macro (group_with_parallel) refers to another macro (foreach_count).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c526f01c29f290403e51e19b0ba26f8e808e9d41" translate="yes" xml:space="preserve">
          <source>In this example a multi-field tuple is used. For the FILTER statement, Pig performs an implicit cast. For the FOREACH statement, an explicit cast is used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f34e9ccd45ed5247a9948b597bda137a57066df6" translate="yes" xml:space="preserve">
          <source>In this example a name collision will occur. Here letter B is used as alias name and as name in user-defined schema. Pig will throw an exception when name collision is detected.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe539b60b5336a69ebbb6e4634bb45d1f0a5d224" translate="yes" xml:space="preserve">
          <source>In this example a schema is specified as part of the STREAM statement.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06061e753d06a1e6057c5ffcb4a812aa78fbf9d1" translate="yes" xml:space="preserve">
          <source>In this example a schema is specified using the AS clause. If all data conforms to the schema, Pig will use the assigned types.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34acf70f365e4b31c6e0e3cccb93c0182b8a1c41" translate="yes" xml:space="preserve">
          <source>In this example a schema is specified using the AS keyword. The two LOAD statements are equivalent. You can use the DESCRIBE and ILLUSTRATE operators to view the schema.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc43776c73d7d053427079800e34a406b2a45d68" translate="yes" xml:space="preserve">
          <source>In this example additional JAR files are registered via PIG_OPTS environment variable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16dcc4a12858c636c8fa146c2aad2b889eb7fae9" translate="yes" xml:space="preserve">
          <source>In this example all duplicate tuples are removed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b618f5f0bcbb7b8e5bdafd32f7a9e4baece8803f" translate="yes" xml:space="preserve">
          <source>In this example all students with an SSN but no name are located.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79068ccaa260466fc6f972d14a88f57c0fcfb5d3" translate="yes" xml:space="preserve">
          <source>In this example all the MapReduce jobs that get launched use 20 reducers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b770e6fe233709b0a9582cf8bb7b9270df9258d2" translate="yes" xml:space="preserve">
          <source>In this example an error is generated because the requested column ($3) is outside of the declared schema (positional notation begins with $0). Note that the error is caught before the statements are executed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="019c413fae337da8ece686fc5d54f62505ef2c7a" translate="yes" xml:space="preserve">
          <source>In this example an int is cast to type chararray (see relation X).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93db6358d966d0c7d514bd2decd538210cc879e4" translate="yes" xml:space="preserve">
          <source>In this example both a and null will be cast to int, a implicitly, and null explicitly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f959bad76d0bbfd8004a39fa235bd4ca5f054f65" translate="yes" xml:space="preserve">
          <source>In this example both a and null will be implicitly cast to double.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e27f98b53bc5588e16ad4f1af469c5dfda881206" translate="yes" xml:space="preserve">
          <source>In this example cache is used to specify a file located on the cluster compute nodes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0dfa087e0c75a861542022b8ebc000c17d370200" translate="yes" xml:space="preserve">
          <source>In this example data is loaded with a schema.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d52a2a475a46079874a2842b0e1af3a3ae07325b" translate="yes" xml:space="preserve">
          <source>In this example data is loaded without a schema; it assumes there is a .pig_schema (produced by JsonStorage) in the input directory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98510e7774ca7a3b39f659179e898062288bbc9c" translate="yes" xml:space="preserve">
          <source>In this example data is stored using PigStorage and the asterisk character (*) as the field delimiter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="993517c57ee376d2b7b84473441b0326f8a923af" translate="yes" xml:space="preserve">
          <source>In this example default_parallel is set in the Pig script; all MapReduce jobs that get launched will use 20 reducers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="004f088c97324626f2f5dd9f710d01d17559c6aa" translate="yes" xml:space="preserve">
          <source>In this example dereferencing is used to look up the value of key 'open'.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b80a144f43f789acea82e8c85d4bcbd2d95337f" translate="yes" xml:space="preserve">
          <source>In this example dereferencing is used to project a field (f1) from a tuple (group) and a field (f1) from a bag (a).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="212fc5892a721a0060e45e75350a1fbdbf50b4be" translate="yes" xml:space="preserve">
          <source>In this example dereferencing is used to retrieve two fields from tuple f2.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="904d63269308c6655e00fc821dff1fc33db0eed0" translate="yes" xml:space="preserve">
          <source>In this example dereferencing is used with relation X to project the first field (f1) of each tuple in the bag (a).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd906ea6b105d25e2f0d5b0003b730ae52af1ed4" translate="yes" xml:space="preserve">
          <source>In this example field &quot;gpa&quot; will default to bytearray because no type is declared.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71b7c69ad52a06b1bcb69143364d7c4a4045b02f" translate="yes" xml:space="preserve">
          <source>In this example if one of the fields in the input relation is a tuple, bag or map, we can perform a projection on that field (using a deference operator).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="381c3ad80f6a75a1d6369b158db1f23e56c0c1a2" translate="yes" xml:space="preserve">
          <source>In this example key value pairs are set at the command line.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="036d7f9ad9b7cc7d5a796a8fa59f8957b424182b" translate="yes" xml:space="preserve">
          <source>In this example multiple key value pairs are set in the Pig script. These key value pairs are put in job-conf by Pig (making the pairs available to Pig and Hadoop). This is a script-wide setting; if a key value is defined multiple times in the script the last value will take effect and will be set for all jobs generated by the script.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f41fb70f423cb0dbfced17b805614a0b220128e" translate="yes" xml:space="preserve">
          <source>In this example multiple nested columns are retained.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d5857ac7ca8abbc90407cf41477661d258b1c55" translate="yes" xml:space="preserve">
          <source>In this example multiple parameters are specified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74314f14b6f4d8ce3ccc71bc58e4f39e20febcce" translate="yes" xml:space="preserve">
          <source>In this example my_macro (defined above) is expanded. Because alias B is not visible from the outside it is renamed macro_my_macro_B_0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ef086a29e25d0a628246ae86a8dfd0251c73a5a" translate="yes" xml:space="preserve">
          <source>In this example no parameters are passed to the macro.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c2b33f77cda03a397ae83edefe497af878760f6" translate="yes" xml:space="preserve">
          <source>In this example no schema is specified. All fields default to type bytearray or long (see Data Types).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60048a1c8591e593e65c99554a20d95fc58747db" translate="yes" xml:space="preserve">
          <source>In this example nulls are injected if fields do not have data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8c2d3f0591222c2c9f03e628a85df359bc7b283" translate="yes" xml:space="preserve">
          <source>In this example of an outer join, if the join key is missing from a table it is replaced by null.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0107821bc8812479bdbf1f64b26078690d140226" translate="yes" xml:space="preserve">
          <source>In this example output is limited to 3 tuples. Note that there is no guarantee which three tuples will be output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6926a0c31dcd9e33a949b13c70271304c004ba03" translate="yes" xml:space="preserve">
          <source>In this example parameter substitution is used with the exec command.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8418fd14b7d1e17833903e6a625c75e3ce956813" translate="yes" xml:space="preserve">
          <source>In this example parameter substitution is used with the run command.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="829f361647b770f5f6f543d85b2622ed7c6cd584" translate="yes" xml:space="preserve">
          <source>In this example parameters are passed and returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8309b5f7726c99d87799e05a93319a66d843c5f" translate="yes" xml:space="preserve">
          <source>In this example relation A is sorted by the third field, f3 in descending order. Note that the order of the three tuples ending in 3 can vary.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7a76748d23607d469a11fdd632d38e8948725ce" translate="yes" xml:space="preserve">
          <source>In this example relation A is split into three relations, X, Y, and Z.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea5ae7eac546e34a2d13c3fafaa1736e62a4a6ac" translate="yes" xml:space="preserve">
          <source>In this example relation X will contain 1% of the data in relation A.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e048f00ed84c4268f680319e8d3e4543df48f677" translate="yes" xml:space="preserve">
          <source>In this example relations A and B are joined by their first fields.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1fbb00b56354e90b99f0d0abee287efa949183ef" translate="yes" xml:space="preserve">
          <source>In this example ship is used to send the script to the cluster compute nodes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb32f8e1cb739afed30691ec54c7d7d010de23a0" translate="yes" xml:space="preserve">
          <source>In this example single word values that don't use special characters (in this case, mydata) don't have to be enclosed in quotes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb06a1600d91e4a228d8c694d3f8cc460e0f109e" translate="yes" xml:space="preserve">
          <source>In this example the &lt;a href=&quot;#flatten&quot;&gt;FLATTEN&lt;/a&gt; operator is used to eliminate nesting.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00106135a67fa0fb49d05b22a6af49367f72d99b" translate="yes" xml:space="preserve">
          <source>In this example the EXPLAIN operator produces all three plans. (Note that only a portion of the output is shown in this example.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7c916eb550f56bcc8d23590cbf1cf0c80f42104" translate="yes" xml:space="preserve">
          <source>In this example the FOREACH statement includes FLATTEN and a schema for simple data types.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="417fccbcd046561d8ffe25457defbd55e880d1fe" translate="yes" xml:space="preserve">
          <source>In this example the FOREACH statement includes a schema for simple expression.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7d9bf5151735fb7eac9687d81ce6fb8ed553219" translate="yes" xml:space="preserve">
          <source>In this example the FOREACH statement includes a schemas for multiple fields.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24842feb372ec793af9f761b6b82120ae0b6939d" translate="yes" xml:space="preserve">
          <source>In this example the LOAD statement includes a schema definition for simple data types.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b1685e1972a2735b748823663c7d18cc3169868" translate="yes" xml:space="preserve">
          <source>In this example the ORDER operator is used to order the tuples and the LIMIT operator is used to output the first three tuples.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d46d714daa065ac64bf616b27d931b45616989ad" translate="yes" xml:space="preserve">
          <source>In this example the asterisk (*) is used to project all fields from relation A to relation X. Relation A and X are identical.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f747b7eff53d66ec54b4dcd3a59958f8f656a8bc" translate="yes" xml:space="preserve">
          <source>In this example the average GPA for each student is computed (see the &lt;a href=&quot;basic#group&quot;&gt;GROUP&lt;/a&gt; operator for information about the field names in relation B).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce3f8dbd72e1ca5670215036e9a44f0b071ca7c3" translate="yes" xml:space="preserve">
          <source>In this example the bincond operator is used with fields f2 and B. The condition is &quot;f2 equals 1&quot;; if the condition is true, return 1; if the condition is false, return the count of the number of tuples in B.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6aaa13edf7e147edb799d5432c00b145a2899bd3" translate="yes" xml:space="preserve">
          <source>In this example the built in function SUM() is used to sum a set of numbers in a bag.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0ad9fb42b25648f0ae623cc3fafcfffe7daac86" translate="yes" xml:space="preserve">
          <source>In this example the case operator is used with field f2. The expression is &quot;f2 % 2&quot;; if the expression is equal to 0, return 'even'; if the expression is equal to 1, return 'odd'.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="092f4e5a8bef8cb9851796d251a7997b165bdd80" translate="yes" xml:space="preserve">
          <source>In this example the characters (in this case, Joe's URL) can be enclosed in single or double quotes, and quotes within the sequence of characters can be escaped.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ede799c3bc9b3029dc9c8360cd04456907800fde" translate="yes" xml:space="preserve">
          <source>In this example the clear command clean up Pig grunt shell.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25d6ee41375a393d7a680688e835a625f56d5bef" translate="yes" xml:space="preserve">
          <source>In this example the command is enclosed in back ticks. First, the parameters mycmd and date are substituted when the declare statement is encountered. Then the resulting command is executed and its stdout is placed in the path before the load statement is run.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b89b66c6c88049c686630255f175fff0f626bdcf" translate="yes" xml:space="preserve">
          <source>In this example the command is executed and its stdout is used as the parameter value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ce0f2c976b3fe8e4f40f38c3029dab1eb1cec85" translate="yes" xml:space="preserve">
          <source>In this example the condition states that if the first field equals 8 or if the sum of fields f2 and f3 is not greater than first field, then include the tuple relation X.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26b224c7415697f3852d73862430dd9075adbd5f" translate="yes" xml:space="preserve">
          <source>In this example the condition states that if the third field equals 3, then include the tuple with relation X.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1025ef014af40aa64437028c4999384b00c45c4" translate="yes" xml:space="preserve">
          <source>In this example the cross product of relation A and B is computed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="acbe209f9e9a1e61b98b326bbd67ec1907b268ea" translate="yes" xml:space="preserve">
          <source>In this example the data file contains tuples. A schema for complex data types (in this case, tuples) is used to load the data. Then, dereference operators (the dot in t1.t1a and t2.$0) are used to access the fields in the tuples. Note that when you assign names to fields you can still refer to these fields using positional notation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e4e82302c1dcf3cf245b321e2f2024b324f3f18" translate="yes" xml:space="preserve">
          <source>In this example the data is grouped and ordered.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6c450e1b8e75a80b634b42feb0e20c5b019d350" translate="yes" xml:space="preserve">
          <source>In this example the data is grouped.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb28ee9adf8539445368e3a7354c61897a47de43" translate="yes" xml:space="preserve">
          <source>In this example the data is unordered.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6603ac59abe4e83a9f3630ed1514e5ee65f95568" translate="yes" xml:space="preserve">
          <source>In this example the default load function, PigStorage, loads data from myfile.txt to form relation A. The two LOAD statements are equivalent. Note that, because no schema is specified, the fields are not named and all fields default to type bytearray.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb0d387430982dda1c08cffe6bc594f972418231" translate="yes" xml:space="preserve">
          <source>In this example the history command shows all the statements with line numbers and without them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="476af286c3ec71967ab312182ce2b62adf926b94" translate="yes" xml:space="preserve">
          <source>In this example the job with id job_0001 is killed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b029e1c370efb6daa4ba5eb4f901c821a93416f8" translate="yes" xml:space="preserve">
          <source>In this example the limit is expressed as a scalar.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e34eec81ca9c49c22acf02db69215d8d4e34e78" translate="yes" xml:space="preserve">
          <source>In this example the ls command is invoked.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76f374ece7dcad13158f830af8da60b38d97b189" translate="yes" xml:space="preserve">
          <source>In this example the macro does not have a return alias; thus, void must be specified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd64ffc9b96611ae3793e3e5ba859e7d36b80811" translate="yes" xml:space="preserve">
          <source>In this example the macro is named my_macro. Note that only aliases A and C are visible from the outside; alias B is not visible from the outside.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6404afa0a6b34470610936e43c5cf53ae1ed10be" translate="yes" xml:space="preserve">
          <source>In this example the map includes two key value pairs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1711a19cfa3302a682910d13c83d53af9d0f1b78" translate="yes" xml:space="preserve">
          <source>In this example the maximum GPA for all terms is computed for each student (see the GROUP operator for information about the field names in relation B).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d880bfbdf389fd36ac97f66b734bd7cf322568a" translate="yes" xml:space="preserve">
          <source>In this example the minimum GPA for all terms is computed for each student (see the GROUP operator for information about the field names in relation B).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f6938263aa57a2bb9d2caa685487136b07bb471" translate="yes" xml:space="preserve">
          <source>In this example the modulo operator is used with fields f1 and f2.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9587d64b9e55a467c8f05370b86a5919538e4e78" translate="yes" xml:space="preserve">
          <source>In this example the number of characters in the first field is computed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b286a09468d93c61174ef82f5d5ce20e0200311" translate="yes" xml:space="preserve">
          <source>In this example the number of pets is computed. (see the GROUP operator for information about the field names in relation B).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1317fabb77110a5157dbf3c1989811a052d00d38" translate="yes" xml:space="preserve">
          <source>In this example the parameter (DATE) and value ('20090101') are specified in the Pig script using the default statement. If a value for DATE is not specified elsewhere, the default value 20090101 is used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e98bd8685b77fd467a6fbb1af6b37b502f7b21e" translate="yes" xml:space="preserve">
          <source>In this example the parameter (data) and the parameter value (mydata) are specified in the command line. If the parameter name in the command line (data) and the parameter name in the script ($data) do not match, the script will not run. If the value for the parameter (mydata) is not found, an error is generated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ed4d9d9c3e64f1c8ed8531ebff8cca25da2370b" translate="yes" xml:space="preserve">
          <source>In this example the parameters and values are passed to the script using the parameter file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1b2909b057f9a09ca537aaf439edc1877ad06cf" translate="yes" xml:space="preserve">
          <source>In this example the percentage of clicks belonging to a particular user are computed. For the FOREACH statement, an explicit cast is used. If the SUM is not given a name, a position can be used as well (userid, clicks/(double)C.$0).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4aff9a2fd5846372e7438a9400d514b26787e3a" translate="yes" xml:space="preserve">
          <source>In this example the quit command exits the Pig grunt shall.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d4709cf6d5853667a759dfa1d106eed84020b7e" translate="yes" xml:space="preserve">
          <source>In this example the same data is loaded twice using aliases A and B.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc5789de4d75cad94be41c5facecc34fe4971feb" translate="yes" xml:space="preserve">
          <source>In this example the schema defines a bag. The two load statements are equivalent.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8755ba412043fe803f3282f9a04a78a7dee177a3" translate="yes" xml:space="preserve">
          <source>In this example the schema defines a tuple, bag, and map.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7cd7118a92ca87fa2d331c8470cf4842dff265de" translate="yes" xml:space="preserve">
          <source>In this example the schema defines an untyped map (the map values default to bytearray). The load statements are equivalent.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5cd0cb1fc97ce5841696cd76163b3e5eb768aca1" translate="yes" xml:space="preserve">
          <source>In this example the schema defines multiple types.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82f2e4223d2166be4de020826791e51ada52b60a" translate="yes" xml:space="preserve">
          <source>In this example the schema defines one tuple. The load statements are equivalent.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf67db086de69e41eae0849cf525acbd64482062" translate="yes" xml:space="preserve">
          <source>In this example the schema defines two tuples.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="374e1d1c9089f64e9a3f6e17445b7108876892bc" translate="yes" xml:space="preserve">
          <source>In this example the script interacts with the results of commands issued via the Grunt shell.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99317ecfb2f2d2f8e22397ef775944c5ef25b329" translate="yes" xml:space="preserve">
          <source>In this example the script is displayed and run.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e598eccd5a601dd744d347f16c97195afdc76a1" translate="yes" xml:space="preserve">
          <source>In this example the streaming stderr is stored in the _logs/&amp;lt;dir&amp;gt; directory of the job's output directory. Because the job can have multiple streaming applications associated with it, you need to ensure that different directory names are used to avoid conflicts. Pig stores up to 100 tasks per streaming job.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12004346bfe8b9058047ed1fff89d8df9e7971b7" translate="yes" xml:space="preserve">
          <source>In this example the strings in each row are split.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ca70fcce90aa1c6cf4766d1a9176002ded5188b" translate="yes" xml:space="preserve">
          <source>In this example the top 10 occurrences are returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="021afd1412e5a5955bb3fb59bfd3c0a85c063129" translate="yes" xml:space="preserve">
          <source>In this example the tuple contains three fields.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f597683856676d8bafb6405513e3ebe7baf66915" translate="yes" xml:space="preserve">
          <source>In this example the tuples are grouped using an expression, f2*f3.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e310234a9bc1536d78449f454a40dbd0fea419f" translate="yes" xml:space="preserve">
          <source>In this example the tuples in the bag are counted (see the &lt;a href=&quot;basic#group&quot;&gt;GROUP&lt;/a&gt; operator for information about the field names in relation B).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c431411d674fcbd3d4993f3b148f0ab1fd9627c8" translate="yes" xml:space="preserve">
          <source>In this example the union of relation A and B is computed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d9b64e41ad4836645b8177be3ac9c0030fd0d8b" translate="yes" xml:space="preserve">
          <source>In this example tuples are co-grouped using field &amp;ldquo;owner&amp;rdquo; from relation A and field &amp;ldquo;friend2&amp;rdquo; from relation B as the key fields. The DESCRIBE operator shows the schema for relation X, which has three fields, &quot;group&quot;, &quot;A&quot; and &quot;B&quot; (see the GROUP operator for information about the field names).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dde4ecc1f27426000ba5fe853e50128821f2f398" translate="yes" xml:space="preserve">
          <source>In this example two fields from relation A are projected to form relation X.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc47fb195353fb6458455bd7a9f15093c04fb95c" translate="yes" xml:space="preserve">
          <source>In this example two fields in relation A are summed to form relation X. A schema is defined for the projected field.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="374e1a3a44b5c072bbee353fcde0ae6d5ba08c31" translate="yes" xml:space="preserve">
          <source>In this example user defined serialization/deserialization functions are used with the script.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c1a5311dceb63c974e9b2cfc727be221f3bb244" translate="yes" xml:space="preserve">
          <source>In this example we filter out ID 4 and 6.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12cea5022f6e359ede64a2f3cade86cdf43e9f89" translate="yes" xml:space="preserve">
          <source>In this example we perform two of the operations allowed in a nested block, FILTER and DISTINCT. Note that the last statement in the nested block must be GENERATE. Also, note the use of projection (PA = FA.outlink;) to retrieve a field. DISTINCT can be applied to a subset of fields (as opposed to a relation) only within a nested block.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa386fd96cd26dfb68e71c6977b54eb2ca55f776" translate="yes" xml:space="preserve">
          <source>In this example, Pig will validate and then execute the LOAD, FOREACH, and DUMP statements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4558a0e1b18bdd5eee2ed93dafa87c2da9e505c" translate="yes" xml:space="preserve">
          <source>In this example, PigStorage loads data with complex data type, a bag of map and double.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9f6baa8723253b0ff5da6f6200823682a8e7924" translate="yes" xml:space="preserve">
          <source>In this example, SUBTRACT creates a new bag composed of B1 elements that are not in B2.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="628bdb7c844633083f052de93a85c78a122db14c" translate="yes" xml:space="preserve">
          <source>In this example, a bag containing tuples with one field is converted to a tuple.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31ad0d826c111e02076048c8e848b2bc5512a7f5" translate="yes" xml:space="preserve">
          <source>In this example, a bag containing tuples with two fields is converted to a tuple.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ba1ab45b8d5e801bda851513ebce706791389a2" translate="yes" xml:space="preserve">
          <source>In this example, a scalar expression is used (it will sample approximately 1000 records from the input).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c050f08cf94a0faf1569c2cd017c23c7029793b" translate="yes" xml:space="preserve">
          <source>In this example, because a path is not given, Pig will use the import path specified in pig.import.search.path.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8d18d2738156bb9536be2726da1b0055af29572" translate="yes" xml:space="preserve">
          <source>In this example, fields f1 and f3 are converted to tuples that are then placed in a bag.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b5550925189ae7bf57a03a71682900e5449f00f" translate="yes" xml:space="preserve">
          <source>In this example, fields f1, an underscore string literal, f2 and f3 are concatenated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ab2c3d36b021dc631caeb2e9d192769dc62ae3c" translate="yes" xml:space="preserve">
          <source>In this example, fields f1, f2 and f3 are converted to a tuple.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7924a4aff410ec62e1625fb749420c25e9e40967" translate="yes" xml:space="preserve">
          <source>In this example, parameters passed to run/exec command or declared within the called scripts are not visible to the caller.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3bb04af80246e86e73ab32302c82691b112dec27" translate="yes" xml:space="preserve">
          <source>In this example, student names (type chararray) and student GPAs (type float) are used to create three maps.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7bb96091fb633aa0dd9a62cf0641bf708fbda94" translate="yes" xml:space="preserve">
          <source>In this example, the CONCAT function is used to format the data before it is stored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="067351e08e674c5bf43312d16f3cfc906bf4efea" translate="yes" xml:space="preserve">
          <source>In this example, the RANK operator does not change the order of the relation and simply prepends to each tuple a sequential value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f697de11b6e8be82a227e004decddf6bf4447be5" translate="yes" xml:space="preserve">
          <source>In this example, the RANK operator works with f1 and f2 fields, and each one with different sorting order. RANK sorts the relation on these fields and prepends the rank value to each tuple. Otherwise, the RANK operator uses each field (or set of fields) to sort the relation. The rank of a tuple is one plus the number of different rank values preceding it. If two or more tuples tie on the sorting field values, they will receive the same rank.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f3b4221a79d008988b7876075995e6b8d7835e6" translate="yes" xml:space="preserve">
          <source>In this example, the SPLIT and FILTER statements are essentially equivalent. However, because SPLIT is implemented as &quot;split the data stream and then apply filters&quot; the SPLIT statement is more expensive than the FILTER statement because Pig needs to filter and store two data streams.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14d08384e4aaff3f8be0a78561d22848f60f1375" translate="yes" xml:space="preserve">
          <source>In this example, the function gets one parameter of type float and another of type double. The best fit will be the function that takes two double values. Pig makes this choice on the user's behalf by inserting implicit casts for the parameters. Running the script above is equivalent to running the script below:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="881155eba58f9e850386857207058c2bcc0dde01" translate="yes" xml:space="preserve">
          <source>In this example, the negation operator is applied to the &quot;x&quot; values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed1b3ee3654de3cdf2209317bbe036a32a65e1c9" translate="yes" xml:space="preserve">
          <source>In this example, to disambiguate y, use A::y or B::y. In cases where there is no ambiguity, such as z, the :: is not necessary but is still supported.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0224a2baaf9cd9707e2e7cf53337aeaeaf373da6" translate="yes" xml:space="preserve">
          <source>In this example, values that are not null are obtained.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e4679058adb8da48ed2faf2b2035bd49505dbe0" translate="yes" xml:space="preserve">
          <source>In this example, we pass (null, &quot;names.txt&quot;) to the construct of UDF in_file, meaning the first parameter is regular, the second parameter is a constant. names.txt can be double quoted (unlike other Pig syntax), or quoted in \'. Note we need to pass 'names.txt' again in line 3. This looks stupid but we need to do this to fill the semantic gap between Pig and Hive. We need to pass the constant in the data pipeline in line 3, which is similar Pig UDF. Initialization code in Hive UDF takes ObjectInspector, which capture the data type and whether or not the parameter is a constant. However, initialization code in Pig takes schema, which only capture the former. We need to use additional mechanism (construct parameter) to convey the later.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c2dcd3fec58a0ebe5b61ce427c75e4270cee26f" translate="yes" xml:space="preserve">
          <source>In this example, we're passing a BigInteger and using NOT operator, thereby negating the passed list of fields in the IN clause</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8ac1c53434de8d305b7f189975c25cebec6a49b" translate="yes" xml:space="preserve">
          <source>In this script, MYUDF might try to read from out1, a file that A was just stored into. However, Pig does not know that MYUDF depends on the out1 file and might submit the jobs producing the out2 and out1 files at the same time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eaeebfe1f5eff1ee401092bdf4bfaa13b02e1352" translate="yes" xml:space="preserve">
          <source>In this script, the STORE/LOAD operators have different file paths; however, the LOAD operator depends on the STORE operator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="388a7f3ab68e1015ed7e6c293c2ff263c2a3d0ea" translate="yes" xml:space="preserve">
          <source>Increase the parallelism of a job by specifying the number of reduce tasks, n.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9a90a62d3ab8cd810db61a4caae391f73d2d675" translate="yes" xml:space="preserve">
          <source>Inner merge join (between two tables) will only work under these conditions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03a548863c266dc43de099b2b4dcd58730363f30" translate="yes" xml:space="preserve">
          <source>InputStats</source>
          <target state="translated">InputStats</target>
        </trans-unit>
        <trans-unit id="a881c6dfaceae2347739afd1176127808734fa29" translate="yes" xml:space="preserve">
          <source>Inside your script, you can define parameters and then pass parameters from command line to your script. There are two ways to pass parameters to your script:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d38ec86271222cf540ae29ce6fdce3cf0bb0bdae" translate="yes" xml:space="preserve">
          <source>Instead of figuring out the dependencies manually, downloading them and registering each jar using the above &lt;a href=&quot;#register-jar&quot;&gt;register command&lt;/a&gt;, you can specify the artifact's coordinates and expect pig to automatically fetch the required dependencies, download and register them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6e225003256a2a1b59e6d92b0617521bd13c8e2" translate="yes" xml:space="preserve">
          <source>Instead use ToString to format the date/time portions and SPRINTF to layout the results.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4cf0450c6e840f4cdcb5c3195b6b05d10c9d0ad9" translate="yes" xml:space="preserve">
          <source>Instead, assemble it in pieces. In step 2, we sort on one field but process another; it remains in the sorted order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9edcffff4461c9083fbff857f8dcee0f0769cbd4" translate="yes" xml:space="preserve">
          <source>Integer</source>
          <target state="translated">Integer</target>
        </trans-unit>
        <trans-unit id="724b5422dc05c791b8cf0befd732972c0409722e" translate="yes" xml:space="preserve">
          <source>Integers</source>
          <target state="translated">Integers</target>
        </trans-unit>
        <trans-unit id="94dc8e4a59fafe99eded0ffa98b6e8ea00efeca7" translate="yes" xml:space="preserve">
          <source>Interaction</source>
          <target state="translated">Interaction</target>
        </trans-unit>
        <trans-unit id="af3758608388b05871589b2b19e12008ace4a0d4" translate="yes" xml:space="preserve">
          <source>Interactive Mode</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2473e96bc614a911821242119918a241a41836d6" translate="yes" xml:space="preserve">
          <source>Introduction</source>
          <target state="translated">Introduction</target>
        </trans-unit>
        <trans-unit id="048850efc4e3902868045111cefcac3a0e527ce7" translate="yes" xml:space="preserve">
          <source>Invalid identifiers:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="888bb77151bd6eaba885bae449bb376eb7118989" translate="yes" xml:space="preserve">
          <source>Invocation Basics</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b747cea14bf58e7def2e01119aae868ffb489ab7" translate="yes" xml:space="preserve">
          <source>Invocation Details</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb31f6339e723fd50bd0157d6fe131b36204092b" translate="yes" xml:space="preserve">
          <source>Invokes any FsShell command from within a Pig script or the Grunt shell.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="387341bd057cbb29666274908fe3359e6d22dd4f" translate="yes" xml:space="preserve">
          <source>Invokes any sh shell command from within a Pig script or the Grunt shell.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="002b9d3672a67b31dde384d5c82b77b20d5c5873" translate="yes" xml:space="preserve">
          <source>IsEmpty</source>
          <target state="translated">IsEmpty</target>
        </trans-unit>
        <trans-unit id="363a45b6f463769784d3f21486a12e29d0abf261" translate="yes" xml:space="preserve">
          <source>IsEmpty(expression)</source>
          <target state="translated">IsEmpty(expression)</target>
        </trans-unit>
        <trans-unit id="88de2259b3b3f72d4d9041583c92b54b45aa01e0" translate="yes" xml:space="preserve">
          <source>It is possible to enable a Hadoop job to request new tickets when they expire by creating a keytab file and make it part of the job that is running in the cluster. This will extend the maximum job duration beyond the maximum renew time of the kerberos tickets.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33cd6ef902f5caf739b2a2823cacab7fda072487" translate="yes" xml:space="preserve">
          <source>It is safe only to ship files to be executed from the current working directory on the task on the cluster.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9433ba5a82fa587313360ad26116c0000526441" translate="yes" xml:space="preserve">
          <source>It is simple to fetch all columns from Airport codes that fall between Boston and San Francisco that can be viewed with 'auth1' and/or 'auth2' Accumulo authorizations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb8f70933c32c8862ef0e315b9d3b91803410867" translate="yes" xml:space="preserve">
          <source>It is very important for performance to make sure that aggregate functions that are algebraic are implemented as such. Let's look at the implementation of the COUNT function to see what this means. (Error handling and some other code is omitted to save space. The full code can be accessed &lt;a href=&quot;http://svn.apache.org/viewvc/pig/trunk/src/org/apache/pig/builtin/COUNT.java?view=markup&quot;&gt; here&lt;/a&gt;.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27ef4d2a6cf1d08c5ea52e79fbc6638e458ce3ab" translate="yes" xml:space="preserve">
          <source>It's OK to supply too many, though</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="720a64aa2e384f654ad24f02483f843d4fa544c7" translate="yes" xml:space="preserve">
          <source>JOIN (inner)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10dbe28c733242b09a204b8afa7bda322c04edfb" translate="yes" xml:space="preserve">
          <source>JOIN (outer)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d1cb24c2595ad4575c4ec6e01cbd73136b6732a" translate="yes" xml:space="preserve">
          <source>Jars required for user defined functions (UDFs) are copied to distributed cache by pig to make them available on task nodes. To put these jars on distributed cache, pig clients copy these jars to HDFS under a temporary location. For scheduled jobs, these jars do not change frequently. Also, creating a lot of small jar files on HDFS is not HDFS friendly. To avoid copying these small jar files to HDFS again and again, pig allows users to configure a user level jar cache (readable only to the user for security reasons). If pig.user.cache.enabled flag is set to true, UDF jars are copied to jar cache location (configurable) under a directory named with the hash (SHA) of the jar. Hash of the jar is used to identify the existence of the jar in subsequent uses of the jar by the user. If a jar with same hash and filename is found in the cache, it is used avoiding copy of the jar to hdfs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95430344cb2583fdd1f91fe40b6a426c6cdb7d10" translate="yes" xml:space="preserve">
          <source>Java API</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="220874040658928dfd28599011834e1d343f6a06" translate="yes" xml:space="preserve">
          <source>Java BigDecimal</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08f070a244c3d5ae1d6e726845ba3cf27ed3a4ee" translate="yes" xml:space="preserve">
          <source>Java BigInteger</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c689b2df07d5ac7a956c5d5f96beb6beed619e6" translate="yes" xml:space="preserve">
          <source>Java Class</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ecdb578d70bdad641779bb3cf2409b8a930d4cc0" translate="yes" xml:space="preserve">
          <source>Java Objects</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e2d7efd6e5d57f9e2fd04c772bf368801395eaf" translate="yes" xml:space="preserve">
          <source>Java Test</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c016599191077ac21a20ca4a9937da89712a611b" translate="yes" xml:space="preserve">
          <source>Java UDFs can be invoked multiple ways. The simplest UDF can just extend EvalFunc, which requires only the exec function to be implemented (see &lt;a href=&quot;#eval-functions-write&quot;&gt; How to Write a Simple Eval Function&lt;/a&gt;). Every eval UDF must implement this. Additionally, if a function is algebraic, it can implement Algebraic interface to significantly improve query performance in the cases when combiner can be used (see &lt;a href=&quot;#algebraic-interface&quot;&gt;Algebraic Interface&lt;/a&gt;). Finally, a function that can process tuples in an incremental fashion can also implement the Accumulator interface to improve query memory consumption (see &lt;a href=&quot;#accumulator-interface&quot;&gt;Accumulator Interface&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5889044826a763834c9c012a37f5c86407ecc85" translate="yes" xml:space="preserve">
          <source>Job XML</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6cc61673b0dee9980ed3e68bb162982c295dc41b" translate="yes" xml:space="preserve">
          <source>JobStats</source>
          <target state="translated">JobStats</target>
        </trans-unit>
        <trans-unit id="5753a498f025464d72e088a9d5d6e872592d5f91" translate="yes" xml:space="preserve">
          <source>John</source>
          <target state="translated">John</target>
        </trans-unit>
        <trans-unit id="13b0d0b8d9cc13668684c1e4def8925fe90d5929" translate="yes" xml:space="preserve">
          <source>JsonLoader( ['schema'] )</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ecc1bbc9be4c62ea582a64bff9ee07d59799f5d" translate="yes" xml:space="preserve">
          <source>JsonLoader, JsonStorage</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="606d2a58b14210dd67ff5015b481adddb0d11fcd" translate="yes" xml:space="preserve">
          <source>JsonStorage( )</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f52e476a57f572278206a16e11c4378156dad2a" translate="yes" xml:space="preserve">
          <source>Just like &lt;a href=&quot;#load-functions&quot;&gt;Load Function&lt;/a&gt; and &lt;a href=&quot;basic#pig-streaming-input-output&quot;&gt;Streaming&lt;/a&gt;, Java UDF has a getLoadCaster() method that returns &lt;a href=&quot;http://svn.apache.org/viewvc/pig/trunk/src/org/apache/pig/LoadCaster.java?view=markup&quot;&gt;LoadCaster&lt;/a&gt; to convert byte arrays to specific types. A UDf implementation should implement this if casts (implicit or explicit) from DataByteArray fields to other types need to be supported. Default implementation returns null and Pig will determine if all parameters passed to the UDF have identical loadcaster and use it when true.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b07a29909bdb4a7c9a4c7d68a06e09221fc27e7c" translate="yes" xml:space="preserve">
          <source>Just like MapReduce, if user specify &quot;parallel&quot; in their Pig statement, or user define default_parallel in Tez mode, Pig will honor it (the only exception is if user specify a parallel which is apparently too low, Pig will override it)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="362ce6c69aec6aa228025cdea51fbad41241c2ee" translate="yes" xml:space="preserve">
          <source>Kerberos is a authentication system that uses tickets with a limited validity time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c67dd20ee842986086a0a915ddc2a279490130ed" translate="yes" xml:space="preserve">
          <source>Key</source>
          <target state="translated">Key</target>
        </trans-unit>
        <trans-unit id="134d1eb6aa3d758c6d2a1058ae3736bf8dd9041a" translate="yes" xml:space="preserve">
          <source>Key (see table). Case sensitive.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6cca404086c0c970a335a2fb82ffafe8356b46e5" translate="yes" xml:space="preserve">
          <source>Key value pairs are separated by the pound sign #.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8098eb09dd0aab077b1f27f175c7ab7b69b5f496" translate="yes" xml:space="preserve">
          <source>Key values within a relation must be unique.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3926e039fd753c472f6e172496fda0574369261" translate="yes" xml:space="preserve">
          <source>Keyword</source>
          <target state="translated">Keyword</target>
        </trans-unit>
        <trans-unit id="20f56842c9025d12cf677dcfcfc8d42101d62d87" translate="yes" xml:space="preserve">
          <source>Keyword.</source>
          <target state="translated">Keyword.</target>
        </trans-unit>
        <trans-unit id="59a29873cf3f108383cd6005d3b1061f15d203a8" translate="yes" xml:space="preserve">
          <source>Keyword. Use ALL if you want all tuples to go to a single group; for example, when doing aggregates across entire relations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7c4c244651ed2eef71562ff0f3f4ddcc23cb537" translate="yes" xml:space="preserve">
          <source>Keyword. Use this clause to group the relation by field, tuple or expression.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="319289cdafee96fb1df0ad9cc8cefb1bd579fb6b" translate="yes" xml:space="preserve">
          <source>Keyword. Use this clause to name the store function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67bd5860f834413aaa7d43179cf49527a0e0a2a6" translate="yes" xml:space="preserve">
          <source>Keywords LOAD, USING, AS, GROUP, BY, FOREACH, GENERATE, and DUMP are case insensitive. They can also be written as load, using, as, group, by, etc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0edfbf0b2bd967f0c42ea28a41230fdd455d94f6" translate="yes" xml:space="preserve">
          <source>Kills a job.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b05203cf89b60eb36609a1a8b7f3cafe0927486a" translate="yes" xml:space="preserve">
          <source>Known issues</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="081687e57ce32b0d5310545712b5004fdc61e427" translate="yes" xml:space="preserve">
          <source>LAST_INDEX_OF</source>
          <target state="translated">LAST_INDEX_OF</target>
        </trans-unit>
        <trans-unit id="df47fe57bbca631a9709a10608e1b138590b99bd" translate="yes" xml:space="preserve">
          <source>LAST_INDEX_OF(string, 'character')</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52e4213745bcac792482d968e621c5b7a8d439c9" translate="yes" xml:space="preserve">
          <source>LCFIRST</source>
          <target state="translated">LCFIRST</target>
        </trans-unit>
        <trans-unit id="97e019a4f6ed7512191b214c6cc6b45d3f156619" translate="yes" xml:space="preserve">
          <source>LCFIRST(expression)</source>
          <target state="translated">LCFIRST(expression)</target>
        </trans-unit>
        <trans-unit id="969e2cc476ff76be41815b17d8fb9c685f97e243" translate="yes" xml:space="preserve">
          <source>LEFT</source>
          <target state="translated">LEFT</target>
        </trans-unit>
        <trans-unit id="9c590af5665cfc2916823206547377e482547e1d" translate="yes" xml:space="preserve">
          <source>LIMIT</source>
          <target state="translated">LIMIT</target>
        </trans-unit>
        <trans-unit id="97eb8c80f7fd9d9f6120c3bffd79e5e23e575196" translate="yes" xml:space="preserve">
          <source>LOAD</source>
          <target state="translated">LOAD</target>
        </trans-unit>
        <trans-unit id="4774d9fc38721cde600e4accf82d0e696ef36f65" translate="yes" xml:space="preserve">
          <source>LOAD '/mydata/20110423{00,01,02,03,04,05,06,07,08,09,{10..23}}00//&lt;strong&gt;part &lt;/strong&gt;'</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a4fc268593a3d77b3f981e8ec7b7ac700de71ad" translate="yes" xml:space="preserve">
          <source>LOAD 'data' [USING function] [AS schema];</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="285ba2da17d87dd834eefed1cada61171d7d941f" translate="yes" xml:space="preserve">
          <source>LOAD ... USING ... AS</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a8f5f55cccc7758440851683be6f04c67cd6f96" translate="yes" xml:space="preserve">
          <source>LOAD, AS - Pig keywords</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94b16081400651bfe270528a0e3ee7024a5f9ca3" translate="yes" xml:space="preserve">
          <source>LOG</source>
          <target state="translated">LOG</target>
        </trans-unit>
        <trans-unit id="fd8045b04b52cf7e9e6124cd894331256d12dd1a" translate="yes" xml:space="preserve">
          <source>LOG(expression)</source>
          <target state="translated">LOG(expression)</target>
        </trans-unit>
        <trans-unit id="bc31df31706dbabb2fd79fd247573138a9a82419" translate="yes" xml:space="preserve">
          <source>LOG10</source>
          <target state="translated">LOG10</target>
        </trans-unit>
        <trans-unit id="bf7398056782a2eb6fd651f94e9a8d6d8204c678" translate="yes" xml:space="preserve">
          <source>LOG10(expression)</source>
          <target state="translated">LOG10(expression)</target>
        </trans-unit>
        <trans-unit id="e2b5c793d8e006e471a5275e68adfb98fe059dc4" translate="yes" xml:space="preserve">
          <source>LOWER</source>
          <target state="translated">LOWER</target>
        </trans-unit>
        <trans-unit id="92aead129812450be477e67e7eb989a4e9f71ce9" translate="yes" xml:space="preserve">
          <source>LOWER(expression)</source>
          <target state="translated">LOWER(expression)</target>
        </trans-unit>
        <trans-unit id="13cbd920c001e22788dd4d82cdc291c6caac4662" translate="yes" xml:space="preserve">
          <source>LTRIM</source>
          <target state="translated">LTRIM</target>
        </trans-unit>
        <trans-unit id="27e73e8192dd9ba4f47ae3488ff498e67ffd4019" translate="yes" xml:space="preserve">
          <source>LTRIM(expression)</source>
          <target state="translated">LTRIM(expression)</target>
        </trans-unit>
        <trans-unit id="fc5aafa84439164f5915b1b47617fd862bbd82b2" translate="yes" xml:space="preserve">
          <source>Left outer join.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13b628b4ab8b2509575a1cd6f8cb5fda2b247abd" translate="yes" xml:space="preserve">
          <source>Left-most loader must implement the {CollectableLoader} interface as well as {OrderedLoadFunc} interface.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73cd7b56ef42ec03731837023a47cd87b79de49f" translate="yes" xml:space="preserve">
          <source>Left-most loader must implement {CollectableLoader} interface as well as {OrderedLoadFunc}.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca2f7f65c0903edf089f4879169677e242e0ac7f" translate="yes" xml:space="preserve">
          <source>Let's assume that we have UDF Swap that, given a tuple with two fields, swaps their order. Let's assume that the UDF does not specify a schema and look at the scripts below:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32d45a02984af444cda547a94ac518a5c5a58bc4" translate="yes" xml:space="preserve">
          <source>Let's now look at the implementation of the UPPER UDF.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe6299c19bf8df974b9bebf8fccacccb0c36ebbe" translate="yes" xml:space="preserve">
          <source>Let's now see how this function can be used in a Pig script:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea4e0d6736c7d827cc4e7a66876464026006c55b" translate="yes" xml:space="preserve">
          <source>Let's revisit the UPPER function from our first example. As it is written now, it would only work if the data passed to it is of type chararray. To make it work with data whose type is not explicitly set, a function table with a single entry needs to be added:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="475a9652b88fed65852bd4b23c1359282ee6e175" translate="yes" xml:space="preserve">
          <source>Licensed under the Apache Software License version 2.0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ae3881b2b0fb732bb6de9dde72017285f72800a" translate="yes" xml:space="preserve">
          <source>Like any other expression, null constants can be implicitly or explicitly cast.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="854814e315400972c4441dad1114f75bef4e9cc4" translate="yes" xml:space="preserve">
          <source>Likewise, TrevniStorage is very closely related to AvroStorage, and shares the same options as AvroStorage. See &lt;a href=&quot;#AvroStorage&quot;&gt;AvroStorage&lt;/a&gt; for a detailed description of the arguments for TrevniStorage.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b87f80550d82a9e0365779f8be23adc0ee585a43" translate="yes" xml:space="preserve">
          <source>LimitOptimizer</source>
          <target state="translated">LimitOptimizer</target>
        </trans-unit>
        <trans-unit id="6195b6b19ca290cb1f0c777b8f337e23861be917" translate="yes" xml:space="preserve">
          <source>Limited support is provided for Jython, Python, JavaScript, Ruby and Groovy functions. These functions are new, still evolving, additions to the system. Currently only the basic interface is supported; load/store functions are not supported. Furthermore, JavaScript, Ruby and Groovy are provided as experimental features because they did not go through the same amount of testing as Java or Jython. At runtime note that Pig will automatically detect the usage of a scripting UDF in the Pig script and will automatically ship the corresponding scripting jar, either Jython, Rhino, JRuby or Groovy-all, to the backend. Python does not require any runtime engine since it invoke python command line and stream data in and out of it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7515906f2285af7d60e86a7d43455b7a249592bf" translate="yes" xml:space="preserve">
          <source>Limits the number of output tuples.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="956e1330b61723ff186fcbcfd265adba91e6af54" translate="yes" xml:space="preserve">
          <source>Line 1 indicates that the function is part of the myudfs package. The UDF class extends the EvalFunc class which is the base class for all eval functions. It is parameterized with the return type of the UDF which is a Java String in this case. We will look into the EvalFunc class in more detail later, but for now all we need to do is to implement the exec function. This function is invoked on every input tuple. The input into the function is a tuple with input parameters in the order they are passed to the function in the Pig script. In our example, it will contain a single string field corresponding to the student name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5caa6119e5a5784410641134836063fbda7a2642" translate="yes" xml:space="preserve">
          <source>List Pig properties.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92e97e035f44f8980e413b0d3167603ea36902ee" translate="yes" xml:space="preserve">
          <source>Literal</source>
          <target state="translated">Literal</target>
        </trans-unit>
        <trans-unit id="f021aa6572ced84b6338a8aa2d7c6ec393f0e8e9" translate="yes" xml:space="preserve">
          <source>Load Example</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c6f5e374c495440813dfb8c43762f92a485801a" translate="yes" xml:space="preserve">
          <source>Load Examples</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="153ed64057be54f8d2533568f5517a405ba5a31f" translate="yes" xml:space="preserve">
          <source>Load Functions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c84877c34cdbb71bdceab39a857b49dc7dd074db" translate="yes" xml:space="preserve">
          <source>Load or store JSON data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8a5a6a4984d874b5d5fc5f56453ae2255a611d3" translate="yes" xml:space="preserve">
          <source>Load statements &amp;ndash; PigStorage expects data to be formatted using field delimiters, either the tab character ('\t') or other specified character.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8394a86595651bd6aa48839d4b9509225529fe8b" translate="yes" xml:space="preserve">
          <source>Load/Store Functions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ff3612ad5b787d3be631d6699ef0010173126d2" translate="yes" xml:space="preserve">
          <source>Load/store functions determine how data goes into Pig and comes out of Pig. Pig provides a set of built-in load/store functions, described in the sections below. You can also write your own load/store functions (see &lt;a href=&quot;udf&quot;&gt;User Defined Functions&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c431ce3cc6de545c006a5dc4f55812d9901c37ac" translate="yes" xml:space="preserve">
          <source>Loader side:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="292c202d7f33de20bb18cb9b0cd78363326e07b9" translate="yes" xml:space="preserve">
          <source>Loader will be instructed to loader the partition with dt=='201310' and state=='CA'</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1bbec1f2925e33de29cc103440eaad38ddc86d8c" translate="yes" xml:space="preserve">
          <source>Loading Data</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2683406031d7a18de1fd67e1e11494ce9bebe57" translate="yes" xml:space="preserve">
          <source>Loads and stores data as structured text files.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5ab9df0752359ce2a9010c5aca5c7b13218b8ac" translate="yes" xml:space="preserve">
          <source>Loads and stores data from Avro files.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd223bb0ff10c21f09b831e58eea8a6f58904d01" translate="yes" xml:space="preserve">
          <source>Loads and stores data from Trevni files.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80db5f3f39fbbc84dd2b14e51899dff294e39ece" translate="yes" xml:space="preserve">
          <source>Loads and stores data from an HBase table.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d72f04a406a7e49e13a302e150306baf032923ec" translate="yes" xml:space="preserve">
          <source>Loads and stores data in machine-readable format.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c132ef27274638f19bb72b1001c8a9395135f95" translate="yes" xml:space="preserve">
          <source>Loads data from the file system.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eea9cefa9b896289e9167b60ed8b404fccfd5b53" translate="yes" xml:space="preserve">
          <source>Loads from or stores data to Orc file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18e8e0842b1999e676731438c4dea4a56f79cd4c" translate="yes" xml:space="preserve">
          <source>Loads or stores data from an Accumulo table. The first element in a Tuple is equivalent to the &quot;row&quot; from the Accumulo Key, while the columns in that row are can be grouped in various static or wildcarded ways. Basic wildcarding functionality exists to group various columns families/qualifiers into a Map for LOADs, or serialize a Map into some group of column families or qualifiers on STOREs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="740ccec530db15440e48181713136ee050ab7097" translate="yes" xml:space="preserve">
          <source>Loads unstructured data in UTF-8 format.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3b24cc821e27fff117200af94d65c12872874b1" translate="yes" xml:space="preserve">
          <source>Local Mode</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea7076530ceab2e77fb3cb520efd850a7ddef48b" translate="yes" xml:space="preserve">
          <source>Log file, Excite search engine (local mode)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="863629ee92f0cce989f168afc709eb06192b10b7" translate="yes" xml:space="preserve">
          <source>Log file, Excite search engine (mapreduce)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11eda67f9b15a760342f8e98a3fc78d8d3ea9945" translate="yes" xml:space="preserve">
          <source>Long</source>
          <target state="translated">Long</target>
        </trans-unit>
        <trans-unit id="0178a9a96c884d695567e06fe46d3aa4cbf9b156" translate="yes" xml:space="preserve">
          <source>Long lived jobs</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c95e7e6f6a263bc67561c7fc8ceb0607d15d1cba" translate="yes" xml:space="preserve">
          <source>Long: long</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3316c8ddabfaccc1e70bfecfd5b7747a06043e4b" translate="yes" xml:space="preserve">
          <source>Longs</source>
          <target state="translated">Longs</target>
        </trans-unit>
        <trans-unit id="7b186e235f284107df6b4dbe6060d2b6a5d9f1e5" translate="yes" xml:space="preserve">
          <source>MAX</source>
          <target state="translated">MAX</target>
        </trans-unit>
        <trans-unit id="3ada24ec29991deafbe9dbcbe2155e2e6ee05875" translate="yes" xml:space="preserve">
          <source>MAX(expression)</source>
          <target state="translated">MAX(expression)</target>
        </trans-unit>
        <trans-unit id="04e66352aa8f9c4c5f26b71bf380973ada994760" translate="yes" xml:space="preserve">
          <source>MIN</source>
          <target state="translated">MIN</target>
        </trans-unit>
        <trans-unit id="9f16fb3a367f47ced429f9a96ee8af3d40dcccdd" translate="yes" xml:space="preserve">
          <source>MIN(expression)</source>
          <target state="translated">MIN(expression)</target>
        </trans-unit>
        <trans-unit id="4a83930aeba65503717c88ca93580a0d643e3c2d" translate="yes" xml:space="preserve">
          <source>Macro expansion is not a complete replacement for function calls. Recursive expansions are not supported.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90103d0b5c28db7922249a3fa2ea7bfff2ba0064" translate="yes" xml:space="preserve">
          <source>Macro names are global and all macros share the same name space. While the file can contain more than one macro definition, having two macros with the same name in your execution context will result in an error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a950d781ec76e0d5d8f9a49df1d80136a24daf6d" translate="yes" xml:space="preserve">
          <source>Macros are NOT alllowed inside a nested block.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0fe92ab842bd9468af7fe40e3c0e996ece09d87" translate="yes" xml:space="preserve">
          <source>Macros are not allowed inside a &lt;a href=&quot;basic#nested-block&quot;&gt;FOREACH&lt;/a&gt; nested block.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec793f1eac030adf34d2e41a8195b5aa6af3faa2" translate="yes" xml:space="preserve">
          <source>Macros can only contain Pig Latin statements; Grunt shell commands are not supported. REGISTER statements and parameter definitions with %default or %declare are both valid however. Your macro file also IMPORT other macro files, so long as these imports are not recursive.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f5d729039ce92b99bf31323c027bd3e1999e4d3" translate="yes" xml:space="preserve">
          <source>Macros cannot contain &lt;a href=&quot;cmds#shell-cmds&quot;&gt;Grunt shell commands&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb4798c01e02a87a25ab288415fe8315792ab65a" translate="yes" xml:space="preserve">
          <source>Macros cannot include a user-defined schema that has a name collision with an alias in the macro.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b90c9bc525fef91c7051e223d84db955ed26d8b6" translate="yes" xml:space="preserve">
          <source>Make Your UDFs Algebraic</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c76e7b16941afa21f1bc061662c5afc67e30d7d" translate="yes" xml:space="preserve">
          <source>Make sure that for each function, you add a corresponding test class in the test part of the tree.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89075a765b1a0bbdfb1037d1e343f2d19beb8ffd" translate="yes" xml:space="preserve">
          <source>Make sure that your code follows Pig coding conventions described in &lt;a href=&quot;https://cwiki.apache.org/confluence/display/PIG/HowToContribute&quot;&gt;How to Contribute to Pig&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1453bf305e9c5ecb3fb272c5a0f810f865052a67" translate="yes" xml:space="preserve">
          <source>Make sure that your function is well documented and uses the &lt;a href=&quot;http://docs.oracle.com/javase/6/docs/technotes/tools/solaris/javadoc.html&quot;&gt;javadoc&lt;/a&gt; style of documentation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02bf56b1b68374b208d34a48eae88f93b5114cb8" translate="yes" xml:space="preserve">
          <source>Make sure the JAVA_HOME environment variable is set the root of your Java installation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0a14e7b46d7b053eeee4d905350e82494b9e784" translate="yes" xml:space="preserve">
          <source>Make sure your PATH includes bin/pig (this enables you to run the tutorials using the &quot;pig&quot; command).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f2f922bc9ecd3f2a3cdc0e7b3ae6ed62fb20721" translate="yes" xml:space="preserve">
          <source>Makes the split non-blocking and allows processing to continue. This helps reduce the amount of data that has to be stored right at the split.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="209567b32f8fea5e9ef198fb3941b8730fad033c" translate="yes" xml:space="preserve">
          <source>Many PigUnit examples are available in the &lt;a href=&quot;http://svn.apache.org/viewvc/pig/trunk/test/org/apache/pig/test/pigunit/TestPigTest.java&quot;&gt;PigUnit tests&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab478f3efc840eebab919dff1b9512286f70c10c" translate="yes" xml:space="preserve">
          <source>Map</source>
          <target state="translated">Map</target>
        </trans-unit>
        <trans-unit id="dae74f13b986a147221f41b0053b991ea203fea3" translate="yes" xml:space="preserve">
          <source>Map Schemas</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8af46e94e502b7aa7a2f1aa05b12cb0c07e01870" translate="yes" xml:space="preserve">
          <source>Map dereferencing must be done by key (field_name#key or $0#key). If the pound operator is applied to a bytearray, the bytearray is assumed to be a map. If the key does not exist, the empty string is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="172c8b9363030fc7be69a2798cd806007e34c86e" translate="yes" xml:space="preserve">
          <source>Map&amp;lt;Object, Object&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a376ab0b0389e27d40fa426227bc396c3d2e452" translate="yes" xml:space="preserve">
          <source>Map: java.util.Map</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80071cd75107cd5c4afdb2571725ea6733631038" translate="yes" xml:space="preserve">
          <source>Maps</source>
          <target state="translated">Maps</target>
        </trans-unit>
        <trans-unit id="1a50f5954df4dfe8722ed6d174a9520e089c8ce6" translate="yes" xml:space="preserve">
          <source>Maps are enclosed in straight brackets [ ].</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1756bec08ab2e5a4f6f3ea1577c5665ca0e8a418" translate="yes" xml:space="preserve">
          <source>Math Functions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0efdce50032a40b3a3914e5fc8bfa6cd4288bb5" translate="yes" xml:space="preserve">
          <source>Memory Management</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ffc4d0fd84372762976635002c427e810e8329a6" translate="yes" xml:space="preserve">
          <source>Merge Joins</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="627dc8ff0cef660b000fb836bad32ded77d9db38" translate="yes" xml:space="preserve">
          <source>Merge filter conditions after PushUpFilter rule to decrease the number of filter statements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51c7b431837f24885f18db611764cb39830ff71e" translate="yes" xml:space="preserve">
          <source>Merge-Sparse Joins</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8fea2fed8c16c2288bb31ada275a77e267a6ab5c" translate="yes" xml:space="preserve">
          <source>Merge-Sparse join is a specialization of merge join. Merge-sparse join is intended for use when one of the tables is very sparse, meaning you expect only a small number of records to be matched during the join. In tests this join performed well for cases where less than 1% of the data was matched in the join.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4bdcc67e1fd583bc328f53c3b10ec1e75cec47e" translate="yes" xml:space="preserve">
          <source>Merge-sparse join only works for inner joins and is not currently implemented for outer joins.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8fae7f7316c44f46454df38407830d960deca78" translate="yes" xml:space="preserve">
          <source>MergeFilter</source>
          <target state="translated">MergeFilter</target>
        </trans-unit>
        <trans-unit id="23a02331f579c7154e40a84a1946289d36647520" translate="yes" xml:space="preserve">
          <source>MergeForEach</source>
          <target state="translated">MergeForEach</target>
        </trans-unit>
        <trans-unit id="6b121c3e89581e5ceab18466104db8aab4915066" translate="yes" xml:space="preserve">
          <source>MilliSecondsBetween</source>
          <target state="translated">MilliSecondsBetween</target>
        </trans-unit>
        <trans-unit id="e71ec4d9c2fb04eac5ce8aa7ddfc94b4e537dc73" translate="yes" xml:space="preserve">
          <source>MilliSecondsBetween(datetime1, datetime2)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6295a9ae493dccb2f773f064edfa765b839ab428" translate="yes" xml:space="preserve">
          <source>MiniCluster generates one in build/classes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13b68c92e094101ca904236df27e6d286dfc4604" translate="yes" xml:space="preserve">
          <source>MinutesBetween</source>
          <target state="translated">MinutesBetween</target>
        </trans-unit>
        <trans-unit id="121265c9da1c27a9e91b296b9a032f9dc043e2cf" translate="yes" xml:space="preserve">
          <source>MinutesBetween(datetime1, datetime2)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5af6b4c2a5b65cc8ab62dc972a6b79fd159c1004" translate="yes" xml:space="preserve">
          <source>MissingFormatArgumentException: Format specifier '%-8s'</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99a3402325144d291bec7ddf15b2b92ddc5bc907" translate="yes" xml:space="preserve">
          <source>Mocking</source>
          <target state="translated">Mocking</target>
        </trans-unit>
        <trans-unit id="98c1556eb14f903ff0cc6da7fce11300097e4f71" translate="yes" xml:space="preserve">
          <source>Monitoring Long-Running UDFs</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4e4587a8e5bc89978b95fd14712b5c637d334c7" translate="yes" xml:space="preserve">
          <source>MonthsBetween</source>
          <target state="translated">MonthsBetween</target>
        </trans-unit>
        <trans-unit id="c2497de4c3a7f46f52e471bf016580c8b05abe79" translate="yes" xml:space="preserve">
          <source>MonthsBetween(datetime1, datetime2)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d01423227f4b2cd4ded59e2cdbfb0057686b879" translate="yes" xml:space="preserve">
          <source>Most Orc data type has one to one mapping to Pig data type. Several exceptions are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cdfa5243b3d54966023e586cfec06cfd9d7a42dd" translate="yes" xml:space="preserve">
          <source>Most existing Pig scripts will produce the same result with or without the multi-query execution. There are cases though where this is not true. Path names and schemes are discussed here.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b10b3ed627fb4772162ce992b3ea0544246f7c8b" translate="yes" xml:space="preserve">
          <source>Most of the time, single-tuple processing within a UDF is very short and does not require a UDF to heartbeat. The same is true for aggregate functions that operate on large bags because bag iteration code takes care of it. However, if you have a function that performs a complex computation that can take an order of minutes to execute, you should add a progress indicator to your code. This is very easy to accomplish. The EvalFunc class provides a progress function that you need to call in your exec method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6ca4666a38ad0441b66ffd38051824a3e1f9b9e" translate="yes" xml:space="preserve">
          <source>Most times, it is not necessary, nor desired for performance reasons, to fetch all columns.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12fdb217bf25b1d89a39ced7476e27e33bf049f6" translate="yes" xml:space="preserve">
          <source>Move to the Pig tutorial directory (.../pig-0.17.0/tutorial).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31c02a320c089f6597a14f81e99bbbb176a8d14f" translate="yes" xml:space="preserve">
          <source>Move to the pigtmp directory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ac8dd3fbae422b42dfb2b029fcf9ffa579e90ba" translate="yes" xml:space="preserve">
          <source>Multi-Query Execution</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01b85aabcb3b39447e1aab1a2ca45fed5b213163" translate="yes" xml:space="preserve">
          <source>Multi-query execution introduces some changes:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be0c81ed15124e2c9f58dac0249e297166b9f212" translate="yes" xml:space="preserve">
          <source>Multi-query execution is turned on by default. To turn it off and revert to Pig's &quot;execute-on-dump/store&quot; behavior, use the &quot;-M&quot; or &quot;-no_multiquery&quot; options.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df511d0b9ccb7e1d2a7d7c5c3de6213920d670e9" translate="yes" xml:space="preserve">
          <source>Multiple fields are enclosed in parentheses and separated by commas.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49c92016401e9e368896026aade96455b23a26cb" translate="yes" xml:space="preserve">
          <source>Multiple files can be specified. If the same parameter is present multiple times in the file, the last value will be used and a warning will be generated. If a parameter present in multiple files, the value from the last file will be used and a warning will be generated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78de899b1c722999a754115b391c3f6d8afcc630" translate="yes" xml:space="preserve">
          <source>Multiple items:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4fd56e73c50d1cf9df45651cb8969f782fc4bd9d" translate="yes" xml:space="preserve">
          <source>Multiple parameters can be specified. If the same parameter is specified multiple times, the last value will be used and a warning will be generated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7224113267e40a9f1083035389fd70d294aaf25" translate="yes" xml:space="preserve">
          <source>Multiple register commands can be used in the same script. If the same fully-qualified function is present in multiple jars, the first occurrence will be used consistently with Java semantics.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e91b337a11e8be469e11fd079a265758b7d0f67" translate="yes" xml:space="preserve">
          <source>Must be chararray data type. Must be a unique value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08d2e98e6754af941484848930ccbaddfefe13d6" translate="yes" xml:space="preserve">
          <source>N/A</source>
          <target state="translated">N/A</target>
        </trans-unit>
        <trans-unit id="dbda54bf8f5b0c2cab6b61e46d69af778895241e" translate="yes" xml:space="preserve">
          <source>NATIVE</source>
          <target state="translated">NATIVE</target>
        </trans-unit>
        <trans-unit id="8e7f35442a0cbdf6e52522bf252417e0672f3cf5" translate="yes" xml:space="preserve">
          <source>NGramGenerator</source>
          <target state="translated">NGramGenerator</target>
        </trans-unit>
        <trans-unit id="969e7d8dee132181523a501a068fec75bded3005" translate="yes" xml:space="preserve">
          <source>NOT</source>
          <target state="translated">NOT</target>
        </trans-unit>
        <trans-unit id="434fe5f55d2da77a8c38d9d086d184382c0431af" translate="yes" xml:space="preserve">
          <source>Names are assigned by you using schemas (or, in the case of the GROUP operator and some functions, by the system). You can use any name that is not a Pig keyword (see &lt;a href=&quot;#identifiers&quot;&gt;Identifiers&lt;/a&gt; for valid name examples).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1cd1435493b07624397f0caecc9c127f1237605" translate="yes" xml:space="preserve">
          <source>Nested FOREACH...GENERATE block used with a inner bag. Use this syntax:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="856b986d3b3538c9f63c14a8bfa923da457a6cbf" translate="yes" xml:space="preserve">
          <source>No gap in the ranking values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8afea8785f2d471644a7e2ce83ccf7eaafc476b5" translate="yes" xml:space="preserve">
          <source>No other operations can be done between the LOAD and COGROUP statements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6cacbef0c08a2a634815e58b66c00fed7c2c41d6" translate="yes" xml:space="preserve">
          <source>No other operations can be done between the load and join statements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37c34486a47e980837dfed80ad60c633165578bc" translate="yes" xml:space="preserve">
          <source>No terms.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f05f854bcf667613eb1bcf644bf89bea7c04c22" translate="yes" xml:space="preserve">
          <source>Non-empty bag: {code}{(tuple1),(tuple2),(tuple3)}{code}</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9028fbba3faab3bb8d6374d3d3b12e55ec4d07e" translate="yes" xml:space="preserve">
          <source>Non-empty map: [key1#value1,key2#value2]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="454c82816301c007849136a6a6afd39e636c7a7d" translate="yes" xml:space="preserve">
          <source>Non-empty tuple: (item1,item2,item3)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8bb35935b1c067f8f5b9269c75f07f122dc91e0b" translate="yes" xml:space="preserve">
          <source>NonURLDetector</source>
          <target state="translated">NonURLDetector</target>
        </trans-unit>
        <trans-unit id="f3a561a666d179ca85f5eca5281a4cc29dc561d4" translate="yes" xml:space="preserve">
          <source>Not applicable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3097e34dbf20e18d2f69780a551e61726fd84f2e" translate="yes" xml:space="preserve">
          <source>Not only inside outputSchema at compile time, input schema is also accessible in exec at runtime. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c924e3088204ee77ba681f72be3444357932fca" translate="yes" xml:space="preserve">
          <source>Note</source>
          <target state="translated">Note</target>
        </trans-unit>
        <trans-unit id="fe6878280c596a2dd5322865b0537fe6209c86bf" translate="yes" xml:space="preserve">
          <source>Note 1: boolean (Tuple A is equal to tuple B if they have the same size s, and for all 0 &amp;lt;= i &amp;lt; s A[i] == B[i])</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7ce1a756a8dac8acf02cf7ce21512a25d378b81" translate="yes" xml:space="preserve">
          <source>Note 2: boolean (Map A is equal to map B if A and B have the same number of entries, and for every key k1 in A with a value of v1, there is a key k2 in B with a value of v2, such that k1 == k2 and v1 == v2)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b6c6d89bc2c99329a0bff371ae22ebd24929b95" translate="yes" xml:space="preserve">
          <source>Note that a DUMP or STORE statement is required to generate output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7830de9d278f278b280af353b2b1e821813572b3" translate="yes" xml:space="preserve">
          <source>Note that host languages and the languages of UDFs (included as part of the embedded Pig) are completely orthogonal. For example, a Pig Latin statement that registers a Java UDF may be embedded in Python, JavaScript, Groovy, or Java. The exception to this rule is &quot;combined&quot; scripts &amp;ndash; here the languages must match (see the &lt;a href=&quot;udf#jython-advanced&quot;&gt;Advanced Topics for Python&lt;/a&gt;, &lt;a href=&quot;udf#js-advanced&quot;&gt;Advanced Topics for JavaScript&lt;/a&gt; and &lt;a href=&quot;udf#groovy-advanced&quot;&gt;Advanced Topics for Groovy&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ced2283529be7070b1816e7bc88ea7c4ff8a20e9" translate="yes" xml:space="preserve">
          <source>Note that host languages and the languages of UDFs (included as part of the embedded Pig) are completely orthogonal. For example, a Pig Latin statement that registers a Python UDF may be embedded in Python, JavaScript, or Java. The exception to this rule is &quot;combined&quot; scripts &amp;ndash; here the languages must match (see the &lt;a href=&quot;udf#jython-advanced&quot;&gt;Advanced Topics for Python&lt;/a&gt;, &lt;a href=&quot;udf#js-advanced&quot;&gt;Advanced Topics for JavaScript&lt;/a&gt; and &lt;a href=&quot;udf#groovy-advanced&quot;&gt;Advanced Topics for Groovy&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a92b6e8e114c8750692dc7d3c9a3cb2162bb5174" translate="yes" xml:space="preserve">
          <source>Note that only real programs can be run form the sh command. Commands such as cd are not programs but part of the shell environment and as such cannot be executed unless the user invokes the shell explicitly, like &quot;bash cd&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3b397cb98d2ff8d3aff186a2a49ff9b5ce0dce4" translate="yes" xml:space="preserve">
          <source>Note that production scripts SHOULD NOT use DUMP as it will disable multi-query optimizations and is likely to slow down execution (see &lt;a href=&quot;perf#store-dump&quot;&gt;Store vs. Dump&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="220abe9e473e98cfec1e0a00df725cde1dc89b0a" translate="yes" xml:space="preserve">
          <source>Note that regardless of whether or not you store the schema, you always need to specify the correct delimiter to read your data. If you store using delimiter &quot;#&quot; and then load using the default delimiter, your data will not be parsed correctly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd60f49eedb0eb2995d8bffd71cf6b05d7d5ba0e" translate="yes" xml:space="preserve">
          <source>Note that the REPLACE function is internally implemented using &lt;a href=&quot;http://docs.oracle.com/javase/6/docs/api/java/lang/String.html#replaceAll(java.lang.String,%20java.lang.String)&quot;&gt; java.string.replaceAll(String regex, String replacement)&lt;/a&gt; where 'regExp' and 'newChar' are passed as the 1st and 2nd argument respectively. If you want to replace &lt;a href=&quot;http://docs.oracle.com/javase/6/docs/api/java/util/regex/Pattern.html#bs&quot;&gt; special characters&lt;/a&gt; such as '[' in the string literal, it is necessary to escape them in 'regExp' by prefixing them with double backslashes (e.g. '\\[').</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e09f5334aab86da1b1a89569910200108793437" translate="yes" xml:space="preserve">
          <source>Note that the ship option has two components: the source specification, provided in the ship( ) clause, is the view of your machine; the command specification is the view of the actual cluster. The only guarantee is that the shipped files are available in the current working directory of the launched job and that your current working directory is also on the PATH environment variable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e1565e4014885607dad5c0c2988001edad8fcbf" translate="yes" xml:space="preserve">
          <source>Note that there is no concept of delimit in JsonLoader or JsonStorage. The data is encoded in standard JSON format. JsonLoader optionally takes a schema as the construct argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f363dfb66c51fc8e96f3f1500d605d9e9288e8c2" translate="yes" xml:space="preserve">
          <source>Note that type is NOT part of parameter definition. It is your responsibility to document the types of the parameters in a macro.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d208e362ac7a9c4e5eb23ba8f74811e2d7eaa7a" translate="yes" xml:space="preserve">
          <source>Note that, even if filtering is omitted, the same results will be produced because the foreach results is a cross product and cross products get rid of empty bags. However, doing up-front filtering is more efficient since it reduces the input of the cross product.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ed3db195fd189a63eb841d3fbd72406806084cd" translate="yes" xml:space="preserve">
          <source>Note the following about bags:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3b92c42da2b629b81e09e80527a3382ab34212d" translate="yes" xml:space="preserve">
          <source>Note the following about the GROUP/COGROUP and JOIN operators:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc2f3dea19169906a9c3f9ebf1959122ab5b196c" translate="yes" xml:space="preserve">
          <source>Note the following general observations about data types:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69a5304de52ed596021b9b04debf06f38d8482d3" translate="yes" xml:space="preserve">
          <source>Note the following restrictions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20d78a8e421517dfc8501178399cb2a435e63306" translate="yes" xml:space="preserve">
          <source>Note the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="473512170f0fb2c20a02c7d3b244817ba7bd30ab" translate="yes" xml:space="preserve">
          <source>Note the second column, &amp;lsquo;cube&amp;rsquo; field which is a bag of all tuples that belong to &amp;lsquo;group&amp;rsquo;. Also note that the measure attribute &amp;lsquo;sales&amp;rsquo; along with other unused dimensions in load statement are pushed down so that it can be referenced later while computing aggregates on the measure, like in this case SUM(cube.sales).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e3c6dd868a0b7f3f2667d05913760948c880115" translate="yes" xml:space="preserve">
          <source>Note, the legacy property pig.additional.jars which use colon as separator is still supported. But we recommend to use pig.additional.jars.uris since colon is also used in URL scheme, and thus we cannot use full scheme in the list. We will deprecate pig.additional.jar in future releases.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="965007b15476572db9ef0dd93fbea3f0a4093cfd" translate="yes" xml:space="preserve">
          <source>Note: A few Hive 0.14 UDF contains bug which affects Pig and are fixed in Hive 1.0. Here is a list: compute_stats, context_ngrams, count, ewah_bitmap, histogram_numeric, collect_list, collect_set, ngrams, case, in, named_struct, stack, percentile_approx.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1dc746cfe7d74da28d435069888547345cd0e6c0" translate="yes" xml:space="preserve">
          <source>Note: FOREACH statements can be nested to two levels only. FOREACH statements that are nested to three or more levels will result in a grammar error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80e6a55bf31a90c13baf56b918aa0883b6a73cca" translate="yes" xml:space="preserve">
          <source>Note: For performance reasons the loader may not immediately convert the data to the specified format; however, you can still operate on the data assuming the specified type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef3e4fdc51f94140b39d0bd6e49fb88dc740fa81" translate="yes" xml:space="preserve">
          <source>Note: PigStorage and TextLoader correctly read compressed files as long as they are NOT CONCATENATED bz/bz2 FILES generated in this manner:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0518f86c35b79620a3094a43a0ad3c6c991d598" translate="yes" xml:space="preserve">
          <source>Note: The GROUP and COGROUP operators are identical. Both operators work with one or more relations. For readability GROUP is used in statements involving one relation and COGROUP is used in statements involving two or more relations. You can COGROUP up to but no more than 127 relations at a time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1dd595d75ed7d8086119b3f8ba5b4bdfe66882d8" translate="yes" xml:space="preserve">
          <source>Note: The LIMIT operator allows Pig to avoid processing all tuples in a relation. In most cases a query that uses LIMIT will run more efficiently than an identical query that does not use LIMIT. It is always a good idea to use limit if you can.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b9a0acdfe2379b3842f287d992bccd78205e712" translate="yes" xml:space="preserve">
          <source>Note: The expression can consist of constants or scalars; it cannot contain any columns from the input relation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0f3237ae0f4fc4380931b678193ed2fc302b2e4" translate="yes" xml:space="preserve">
          <source>Note: To debug scripts during development, you can use &lt;a href=&quot;test#dump&quot;&gt;DUMP&lt;/a&gt; to check intermediate results.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b80c89e4cc5f492c5be085c22ab1f50cca4f91fc" translate="yes" xml:space="preserve">
          <source>Note: Using a scalar instead of a constant in LIMIT automatically disables most optimizations (only push-before-foreach is performed).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee0e474fc81852f36c5fdc6b3952b10b45bbe057" translate="yes" xml:space="preserve">
          <source>Note: You cannot use the tuple designator (*) with COUNT; that is, COUNT(*) will not work.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="109a6c5afefe5d900d28ab42046f4fa5d0b0d109" translate="yes" xml:space="preserve">
          <source>Note: exec, run, and explain also support parameter substitution.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70440046a3dc2e079f23ee1c57dfa76669b732aa" translate="yes" xml:space="preserve">
          <source>Notes</source>
          <target state="translated">Notes</target>
        </trans-unit>
        <trans-unit id="c256885553501e3fcd67fb31c3651f0b8df34e96" translate="yes" xml:space="preserve">
          <source>Now that we have the function implemented, it needs to be compiled and included in a jar. You will need to build pig.jar to compile your UDF. You can use the following set of commands to checkout the code from SVN repository and create pig.jar:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb88ad100d7880e07c6d760abded0864a9d02ad0" translate="yes" xml:space="preserve">
          <source>Now the following script will ran:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f2d994aef96688f7037755c22498e05bc932790" translate="yes" xml:space="preserve">
          <source>Now, suppose we group relation A by the first field to form relation X.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80712e1ab7247b5e2bf95f9c76ec0fce22fb65e3" translate="yes" xml:space="preserve">
          <source>Now, suppose we group relation A on field &quot;age&quot; for form relation B. We can use the DESCRIBE and ILLUSTRATE operators to examine the structure of relation B. Relation B has two fields. The first field is named &quot;group&quot; and is type int, the same as field &quot;age&quot; in relation A. The second field is name &quot;A&quot; after relation A and is type bag.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="217dc9412f1631b0d14b11b385eb5f1c8fece4f7" translate="yes" xml:space="preserve">
          <source>Now, you can assert that a0 column in your data is &amp;gt;0, fail if otherwise</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5fa110064ef2aba05aa7955d4237db465bf6269" translate="yes" xml:space="preserve">
          <source>Null Operators</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d723cf2b44d40a1ac71aeacb0490bce050f06594" translate="yes" xml:space="preserve">
          <source>Null operator:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a0b4f0bceedd8bee0e9f98e565c8e1a7a905e08" translate="yes" xml:space="preserve">
          <source>Nulls and Constants</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8e886cfbe6cffa98e03a6ad89d5caf8d8cf99de" translate="yes" xml:space="preserve">
          <source>Nulls and GROUP/COGROUP Operators</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d0af334fae1ee9bc62facfa1200db1ece9b07c4" translate="yes" xml:space="preserve">
          <source>Nulls and JOIN Operator</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b3c1a0927de16437ff4e83643fa705f3fbadba3" translate="yes" xml:space="preserve">
          <source>Nulls and Load Functions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3eb7d232fed3cb6080570b64943cc8ecee344e0" translate="yes" xml:space="preserve">
          <source>Nulls and Pig Latin</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6da7a1f37680b518d10a94f89d73ceb2846a7f55" translate="yes" xml:space="preserve">
          <source>Nulls are considered smaller than evertyhing. If data contains null keys, they should occur before anything else.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e071444e347313a47d45e426ba220f983bb2317e" translate="yes" xml:space="preserve">
          <source>Nulls can be used as constant expressions in place of expressions of any type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1208e9e89c0a8cbfe9919e6706a3a570ae6c30f8" translate="yes" xml:space="preserve">
          <source>Nulls, Operators, and Functions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67b2f87c7a2f07028b46ec3058b64c67312a49b0" translate="yes" xml:space="preserve">
          <source>Numerics take a prefix modifier: , for locale-specific thousands-delimiting, 0 for zero-padding; + to always show a plus sign for positive numbers; space  to allow a space preceding positive numbers; ( to indicate negative numbers with parentheses (accountant-style).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e98bff99da15229b9b6d25ba78b508e05e344875" translate="yes" xml:space="preserve">
          <source>ONSCHEMA</source>
          <target state="translated">ONSCHEMA</target>
        </trans-unit>
        <trans-unit id="f579c523960af1aec824c6fdc57af6d4abd76a1f" translate="yes" xml:space="preserve">
          <source>OR</source>
          <target state="translated">OR</target>
        </trans-unit>
        <trans-unit id="2164bde64d5e67a9aad0e7c0543250365dc40e72" translate="yes" xml:space="preserve">
          <source>ORDER BY</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b09d896b967e0241fb1f8e717db211b19ad86b0" translate="yes" xml:space="preserve">
          <source>OTHERWISE</source>
          <target state="translated">OTHERWISE</target>
        </trans-unit>
        <trans-unit id="a032f6607e24aa99492871d19a553d714048e163" translate="yes" xml:space="preserve">
          <source>OUTER</source>
          <target state="translated">OUTER</target>
        </trans-unit>
        <trans-unit id="91ecfe414d0fb8ea8961b0c7b022ed8849f2e096" translate="yes" xml:space="preserve">
          <source>OUTPUT &amp;ndash; Keyword.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e8b6c4fabb5fcd98502309908c5ae2f7f3b3d89" translate="yes" xml:space="preserve">
          <source>OUTPUT ( {stdout | stderr | 'path'} [USING deserializer] [, {stdout | stderr | 'path'} [USING deserializer] &amp;hellip;] )</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="436316c809cb5512af5763e373c28a63cb305e4d" translate="yes" xml:space="preserve">
          <source>Object[]: Tuple</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a921503fb0dae8fda28f9d3615aba523991068c2" translate="yes" xml:space="preserve">
          <source>Occasionally, users use BinStorage to store their own data. However, because BinStorage is a proprietary binary format, the original data is never in BinStorage - it is always a derivation of some other data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0bc92801b465b9bb97e55a1a664340f960368994" translate="yes" xml:space="preserve">
          <source>Often user data is stored such that both inputs are already sorted on the join key. In this case, it is possible to join the data in the map phase of a MapReduce job. This provides a significant performance improvement compared to passing all of the data through unneeded sort and shuffle phases.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f378e4a14200e531d64d8be58a4840b795824261" translate="yes" xml:space="preserve">
          <source>Often you are not interested in the entire output but rather a sample or top results. In such cases, using LIMIT can yield a much better performance as we push the limit as high as possible to minimize the amount of data travelling through the pipeline.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf71a41255fb73b5c3854a80e8b93532dd87b916" translate="yes" xml:space="preserve">
          <source>Often you may need to use a simple function that is already provided by standard Java libraries, but for which a &lt;a href=&quot;udf&quot;&gt;user defined functions&lt;/a&gt; (UDF) has not been written. Dynamic invokers allow you to refer to Java functions without having to wrap them in custom UDFs, at the cost of doing some Java reflection on every function call.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0734e56926091020e2bafbec598196d6c34bd12" translate="yes" xml:space="preserve">
          <source>Omit line numbers in the list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5922013b0865acdbeeb785909913820c1e623db4" translate="yes" xml:space="preserve">
          <source>On UTF-8 systems you can specify string constants consisting of printable ASCII characters such as 'abc'; you can specify control characters such as '\t'; and, you can specify a character in Unicode by starting it with '\u', for instance, '\u0001' represents Ctrl-A in hexadecimal (see Wikipedia &lt;a href=&quot;http://en.wikipedia.org/wiki/ASCII&quot;&gt;ASCII&lt;/a&gt;, &lt;a href=&quot;http://en.wikipedia.org/wiki/Unicode&quot;&gt;Unicode&lt;/a&gt;, and &lt;a href=&quot;http://en.wikipedia.org/wiki/UTF-8&quot;&gt;UTF-8&lt;/a&gt;). In theory, you should be able to specify non-UTF-8 constants on non-UTF-8 systems but as far as we know this has not been tested.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fccca353eb6301c93d9f86e365716c6debf47b6c" translate="yes" xml:space="preserve">
          <source>On the non-trivial queries (one ran longer than a couple of minutes) we saw significant improvements both in terms of query latency and space usage. For some queries we saw up to 96% disk saving and up to 4x query speed up. Of course, the performance characteristics are very much query and data dependent and testing needs to be done to determine gains. We did not see any slowdown in the tests we peformed which means that you are at least saving on space while using compression.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c24fbf5c7d7120112ceec12106504825249996b" translate="yes" xml:space="preserve">
          <source>One case where pushing filters up might not be a good idea is if the cost of applying filter is very high and only a small amount of data is filtered out.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2cbc2e2cd29c7b36db51b7156f79f696494a899" translate="yes" xml:space="preserve">
          <source>One downside of MapReduce is the startup cost for a job is very high. That hurts the performance especially for small job. Tez alleviate the problem by using session and container reuse, so it is not necessary to start an application master for every job, and start a JVM for every task. By default, session/container reuse is on and we usually shall not turn it off. JVM reuse might cause some side effect if static variable is used since static variable might live across different jobs. So if static variable is used in EvalFunc/LoadFunc/StoreFunc, be sure to implement a cleanup function and register with &lt;a href=&quot;http://pig.apache.org/docs/r0.17.0/api/org/apache/pig/JVMReuseManager.html&quot;&gt;JVMReuseManager&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01399f316fca8487fd4f55faaee3ac7bb6836292" translate="yes" xml:space="preserve">
          <source>One more note about schemas and UDFs. Users have requested the ability to examine the input schema of the data before processing the data via a UDF. For example, they would like to know how to convert an input tuple to a map such that the keys in the map are the names of the input columns. Currently there is no way to do this. This is a feature we would like to support in the future.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86b1a003236c7726fc8c1ef65c53f5899623c990" translate="yes" xml:space="preserve">
          <source>One or more Pig Latin statements, enclosed in curly brackets.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb292bd04b825808a658558eceff1f99e3746de2" translate="yes" xml:space="preserve">
          <source>One problem that users run into is when they make assumption about how many times a constructor for their UDF is called. For instance, they might be creating side files in the store function and doing it in the constructor seems like a good idea. The problem with this approach is that in most cases Pig instantiates functions on the client side to, for instance, examine the schema of the data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="768e440f42a11fcbfa95a4b6852f49f12632d6f7" translate="yes" xml:space="preserve">
          <source>Only files, not directories, can be specified with the ship option. One way to work around this limitation is to tar all the dependencies into a tar file that accurately reflects the structure needed on the compute nodes, then have a wrapper for your script that un-tars the dependencies prior to execution.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f500bcae0ac1d9a7f69a316f1483fc4cc7418c1" translate="yes" xml:space="preserve">
          <source>Only left outer join is supported for replicated joins.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98c134b4570970f85b7a28cd1d729744bbdd592f" translate="yes" xml:space="preserve">
          <source>Only methods annotated with either @OutputSchema or @OutputSchemaFunction will be exposed to Pig as UDFs. In the example above, squareSchema will not be available in Pig as a UDF.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7404c733035e01f2951203e52a17f2d7b25c3f70" translate="yes" xml:space="preserve">
          <source>Only primitives can be used for numbers; no capital-letter numeric classes can be used as arguments. Depending on the return type, a specific kind of invoker must be used: InvokeForString, InvokeForInt, InvokeForLong, InvokeForDouble, or InvokeForFloat.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c500f72032e0fffa7307e38303bd6bd22f060e21" translate="yes" xml:space="preserve">
          <source>Operations That Produce Nulls</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0e687b079fb70f2208d1f8d2c75d64d74925496" translate="yes" xml:space="preserve">
          <source>Operator</source>
          <target state="translated">Operator</target>
        </trans-unit>
        <trans-unit id="6ff265181afd92a333026e2c5d5e199dc5da7ef8" translate="yes" xml:space="preserve">
          <source>Operators:</source>
          <target state="translated">Operators:</target>
        </trans-unit>
        <trans-unit id="6c7f4f579b94c45bf7d1ec93c8760a07327897b1" translate="yes" xml:space="preserve">
          <source>Optimization Rules</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04659a29a038f8b6f95d9df28a89681d94dc2803" translate="yes" xml:space="preserve">
          <source>Optimization can also be achieved using fragment replicate joins, skewed joins, and merge joins. For more information see &lt;a href=&quot;perf#specialized-joins&quot;&gt;Specialized Joins&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f92b41bb13aa91ef73f2405bc184ea22fe7ab53" translate="yes" xml:space="preserve">
          <source>Optimization for regular joins ensures that the last table in the join is not brought into memory but streamed through instead. Optimization reduces the amount of memory used which means you can avoid spilling the data and also should be able to scale your query to larger data volumes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8766608ab14ae4c0ace8e4aee51b7a378f862b8" translate="yes" xml:space="preserve">
          <source>Optional items:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9efc8753c1e4995cd0d1185902d8c3c9200a5b32" translate="yes" xml:space="preserve">
          <source>Optional keyword. Designates a default relation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9d88b237b4a78d338edf7da6c0b3e11382d6f4d" translate="yes" xml:space="preserve">
          <source>Optional tuple representing constant parameters of a Hive UDF/UDTF/UDAF. If Hive UDF requires a constant parameter, there is no other way Pig can pass that information to Hive, since Pig schema does not carry the information whether a parameter is constant or not. Null item in the tuple means this field is not a constant. Non-null item represents a constant field. Data type for the item is determined by Pig contant parser.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6bf5da9c080bee3a8142586c412aa39971137eee" translate="yes" xml:space="preserve">
          <source>Options</source>
          <target state="translated">Options</target>
        </trans-unit>
        <trans-unit id="371b0ae2ff2ab087176f32bee166d4da2913bff3" translate="yes" xml:space="preserve">
          <source>Or if you are using Spark local mode:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="095b0c2883ec0b939fed65357c1b04420e296e0a" translate="yes" xml:space="preserve">
          <source>Or if you are using Spark:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="907c1518b24f449be57666853914f303931b978f" translate="yes" xml:space="preserve">
          <source>Or if you are using Tez local mode:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a4c4c74b3f7d241b86e5336001adb11c6de88bf" translate="yes" xml:space="preserve">
          <source>Or if you are using Tez:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c9450cd3b04d1fd47af444a11a91bb90f9a49d5" translate="yes" xml:space="preserve">
          <source>Orc BYTE/BINARY all map to Pig bytearray</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b510b6858c4b9765788f82d0e9c521f50419cd2f" translate="yes" xml:space="preserve">
          <source>Orc DECIMAL maps to Pig bigdecimal</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9961f1b05ddf0fc66a4ab6a46c676c806aebb176" translate="yes" xml:space="preserve">
          <source>Orc STRING/CHAR/VARCHAR all map to Pig varchar</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d27972086aacd281681114b9c28fd369d9c4b9f" translate="yes" xml:space="preserve">
          <source>Orc TIMESTAMP/DATE all maps to Pig datetime</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1591da02510a2712f04308058e399add5eca1dd" translate="yes" xml:space="preserve">
          <source>OrcStorage</source>
          <target state="translated">OrcStorage</target>
        </trans-unit>
        <trans-unit id="4c9f23c645f12bfa00bd50f98ef015ca573fdaf2" translate="yes" xml:space="preserve">
          <source>OrcStorage as a LoadFunc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3eb7b9cec1cdd27213bef34fc6170acf9fdd4faa" translate="yes" xml:space="preserve">
          <source>OrcStorage as a StoreFunc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="469606f67e8335e115993b24e3f6965fc1459c33" translate="yes" xml:space="preserve">
          <source>OrcStorage predicate pushdown currently support all primitive data types but none of the complex data types. For example, map condition cannot push into OrcStorage:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1bfcf8f6cfd1ff12ec733abbdfb29a53dcdc9dcc" translate="yes" xml:space="preserve">
          <source>OrcStorage(['options'])</source>
          <target state="translated">OrcStorage(['options'])</target>
        </trans-unit>
        <trans-unit id="d0fe29562a7c21056884a2c410f56a9812b54c99" translate="yes" xml:space="preserve">
          <source>Original Avro Types</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="882617723625c587393c99fb5f6b0d0cf3ad5a0e" translate="yes" xml:space="preserve">
          <source>Original Pig Type</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be0be73dfa142afb06644b4bd429b15778e4bac4" translate="yes" xml:space="preserve">
          <source>Other Modes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ebe6018e98731e126f80812a6b4853d5ee2275d6" translate="yes" xml:space="preserve">
          <source>Other properties</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="701a7e9210bdedb5978458dbeba9fb2d822971a2" translate="yes" xml:space="preserve">
          <source>Otherwise, Pig will attempt to ship the first string from the command line as long as it does not come from /bin, /usr/bin, /usr/local/bin. Pig will determine this by scanning the path if an absolute path is provided or by executing which. The paths can be made configurable using the &lt;a href=&quot;cmds#set&quot;&gt;set stream.skippath&lt;/a&gt; option (you can use multiple set commands to specify more than one path to skip).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a338e1e79d114a1522d9eb5979c8db612a93073a" translate="yes" xml:space="preserve">
          <source>Otherwise, the RANK operator uses each field (or set of fields) to sort the relation. The rank of a tuple is one plus the number of different rank values preceding it. If two or more tuples tie on the sorting field values, they will receive the same rank.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5cd2e1cb8ff03e85d7add8f6016467a3f5e57d79" translate="yes" xml:space="preserve">
          <source>Outer joins will only work for two-way joins; to perform a multi-way outer join, you will need to perform multiple two-way outer join statements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="600054c2fe7432d844752d909a7af30d0a800923" translate="yes" xml:space="preserve">
          <source>Outer joins will only work provided the relations which need to produce nulls (in the case of non-matching keys) have schemas.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c746f245398c7408bb6df1ccfc1430c711902402" translate="yes" xml:space="preserve">
          <source>Outer merge join (between two tables) and inner merge join (between three or more tables) will only work under these conditions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d2a263550d66b9f4e2dd5cc2ce0bd6b5aa3b982" translate="yes" xml:space="preserve">
          <source>Output location strict check</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5729f9b287de5b3dfc0238cb6432a164885bc6a" translate="yes" xml:space="preserve">
          <source>Output schema</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1657b858c692a8810b394c9fbe10ef1f3ebefa9" translate="yes" xml:space="preserve">
          <source>OutputStats</source>
          <target state="translated">OutputStats</target>
        </trans-unit>
        <trans-unit id="efbc45e086170113898fb269e6cf4a872cd68ed5" translate="yes" xml:space="preserve">
          <source>Overall you would create a file that looks like this (assume we call it niels.kerberos.properties):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0efc2e6be4c23b9a513d7ce0dcff8ed80e8912e7" translate="yes" xml:space="preserve">
          <source>Overview</source>
          <target state="translated">Overview</target>
        </trans-unit>
        <trans-unit id="96ce24f1a92e6b30382bcf71beddd1d02bbf7658" translate="yes" xml:space="preserve">
          <source>PARALLEL n</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b00fec6efa227099463e118d74a38da9dc9e323c" translate="yes" xml:space="preserve">
          <source>PARTITION BY partitioner</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b338af39aea20defe562c404d22d384da1fb4d9" translate="yes" xml:space="preserve">
          <source>Parallel Execution</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58171bd8fa88aa62d26baf06d454a174292bf115" translate="yes" xml:space="preserve">
          <source>Parallel joins are vulnerable to the presence of skew in the underlying data. If the underlying data is sufficiently skewed, load imbalances will swamp any of the parallelism gains. In order to counteract this problem, skewed join computes a histogram of the key space and uses this data to allocate reducers for a given key. Skewed join does not place a restriction on the size of the input keys. It accomplishes this by splitting the left input on the join predicate and streaming the right input. The left input is sampled to create the histogram.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3375c065590ef4a44f56b15335a0387a3cccbc5a" translate="yes" xml:space="preserve">
          <source>Parameter Substitution</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7790c9a165b0c914283a93f7037cf0b0cc4cb830" translate="yes" xml:space="preserve">
          <source>Parameter files are scanned in the order they are specified on the command line. Within each file, the parameters are processed in the order they are listed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70117576ffa2ad03e5513ff9b3fbd512b8641d45" translate="yes" xml:space="preserve">
          <source>Parameter names are case insensitive.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6466211ad9aa97ba4dc313d987046ab6af23120" translate="yes" xml:space="preserve">
          <source>Parameter substitution enables you to write Pig scripts that include parameters and to supply values for these parameters at run time. For instance, suppose you have a job that needs to run every day using the current day's data. You can create a Pig script that includes a parameter for the date. Then, when you run this script you can specify or supply a value for the date parameter using one of the supported methods.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f69e14d703d0fb6cfc378c0a831efb4f72f66bf1" translate="yes" xml:space="preserve">
          <source>Parameter substitution may be used inside of macros. When there are conflicts between names of parameters defined at the top level and names of arguments or return values for a given macro, then ones inside the macro are used. See &lt;a href=&quot;#define-macros&quot;&gt;DEFINE (macros)&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c256c12a753b5b6bd6decc3861da77cc5d8f2234" translate="yes" xml:space="preserve">
          <source>Parameters Supported in the Query String</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="769003fbcc6fc353a4044c923e34ca968752f228" translate="yes" xml:space="preserve">
          <source>Parameters are processed as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0074ddadeda7d41356f958931e0fcd57e8b79c9b" translate="yes" xml:space="preserve">
          <source>Parameters defined in parameter files specified by -param_file</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70543f43b0b77a80afe0d18b065682a97d7fcc6d" translate="yes" xml:space="preserve">
          <source>Parameters defined in the command line using -param</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7a454f5498afc7a5bd9a3b2032372bdf7551245" translate="yes" xml:space="preserve">
          <source>Parameters defined using the declare statement</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7030e575509b3a9849a213f50450f6c3ea2b9a16" translate="yes" xml:space="preserve">
          <source>Parameters defined using the default statement</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef98d6e375037bebdef260ca6d55bd8ab3dd0e64" translate="yes" xml:space="preserve">
          <source>Parentheses are also used to indicate the tuple data type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ddc4e9e14a7a05acd86ecf4b274ad71ee33e5bcd" translate="yes" xml:space="preserve">
          <source>Parentheses enclose one or more items.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9277a0569e80e9b319b019aefc95b0225b6e8571" translate="yes" xml:space="preserve">
          <source>PartitionFilterOptimizer</source>
          <target state="translated">PartitionFilterOptimizer</target>
        </trans-unit>
        <trans-unit id="97a0e02c60f7bd5b056aeeb4d721b45b24381261" translate="yes" xml:space="preserve">
          <source>Partitions a relation into two or more relations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5fffb570a05163ec7d3a9ee94c710223f45deb55" translate="yes" xml:space="preserve">
          <source>Passing Configurations to UDFs</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="900e8b0d2c1088af54281fa7b734ee24070da72e" translate="yes" xml:space="preserve">
          <source>Passing Parameters to a Script</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30e96c64e3d87a1b3ae0dcab374223bf047c1fd7" translate="yes" xml:space="preserve">
          <source>Passing a Pig Script</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc0b27a7477f8ed02a5b4c719673367cbbf610fe" translate="yes" xml:space="preserve">
          <source>Perform a bloom join with the USING clause (see &lt;a href=&quot;basic#join-inner&quot;&gt;JOIN (inner)&lt;/a&gt; and &lt;a href=&quot;basic#join-outer&quot;&gt;JOIN (outer)&lt;/a&gt;). In this example, a large relation is joined with two smaller relations. Note that the large relation comes first followed by the smaller relations. Bloom filter is built from join keys of the right most relation which is small and the filter is applied on the big and medium relations. None of the relations are required to fit into main memory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67969b99648d91d1035f722084db31dddca473ad" translate="yes" xml:space="preserve">
          <source>Perform a merge join with the USING clause (see &lt;a href=&quot;basic#join-inner&quot;&gt;JOIN (inner)&lt;/a&gt; and &lt;a href=&quot;basic#join-outer&quot;&gt;JOIN (outer)&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd5572ed8b373fc67c4f3724a55aa798b14ca3c3" translate="yes" xml:space="preserve">
          <source>Perform a merge-sparse join with the USING clause (see &lt;a href=&quot;basic#join-inner&quot;&gt;JOIN (inner)&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="402e4b589f5a0d62e1e68cc5769ea6fe810721f3" translate="yes" xml:space="preserve">
          <source>Perform a replicated join with the USING clause (see &lt;a href=&quot;basic#join-inner&quot;&gt;JOIN (inner)&lt;/a&gt; and &lt;a href=&quot;basic#join-outer&quot;&gt;JOIN (outer)&lt;/a&gt;). In this example, a large relation is joined with two smaller relations. Note that the large relation comes first followed by the smaller relations; and, all small relations together must fit into main memory, otherwise an error is generated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f464de18fcec5cc28885815dcee4e7667a7ec7e" translate="yes" xml:space="preserve">
          <source>Perform a skewed join with the USING clause (see &lt;a href=&quot;basic#join-inner&quot;&gt;JOIN (inner)&lt;/a&gt; and &lt;a href=&quot;basic#join-outer&quot;&gt;JOIN (outer)&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3130994b43da1d8950109e1c6564a8348e9d6104" translate="yes" xml:space="preserve">
          <source>Performance Considerations</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f24e3938bb4e4cb45e3fceea03006c92f75688c9" translate="yes" xml:space="preserve">
          <source>Performance Enhancers</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25a6857524ecb9afe00595831a6eabce0d0dfafa" translate="yes" xml:space="preserve">
          <source>Performance and Efficiency</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f76637cf34db3a94cdd1b0e2b9af4d58294a730" translate="yes" xml:space="preserve">
          <source>Performs an inner join of two or more relations based on common field values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e1e34d4c871c8f4da9be20b9f4469a363f98b73" translate="yes" xml:space="preserve">
          <source>Performs an outer join of two relations based on common field values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cad8be75b29842759141027890e92f4432bb017a" translate="yes" xml:space="preserve">
          <source>Performs cube/rollup operations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d24cf8c587230b4ed2537a805a07c9584dcfb6ca" translate="yes" xml:space="preserve">
          <source>Performs regular expression matching and extracts all matched groups.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9018076e46e8c3ab55cf8633b09942355fa4aec9" translate="yes" xml:space="preserve">
          <source>Performs regular expression matching and extracts the matched group defined by an index parameter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ebeb13a8133f2d73bb66dcd9301c11a7ab8ac32f" translate="yes" xml:space="preserve">
          <source>Performs regular expression matching and searches all matched characters in a string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28e7ba6ea4395e9894a796bb57462b156a7c5827" translate="yes" xml:space="preserve">
          <source>Pig JAR file</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92283693de8e1c937c436504772afa7e54d4d779" translate="yes" xml:space="preserve">
          <source>Pig Latin Basics</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="278a8301cb0641c9a4edbfd68852047e3b82ffe2" translate="yes" xml:space="preserve">
          <source>Pig Latin Statements</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="abe1ac30b366cc27ad64f6b2a535541e0d5bd848" translate="yes" xml:space="preserve">
          <source>Pig Latin operators and functions interact with nulls as shown in this table.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c6a60413a273559ed0f210ce1379e5ecd049483" translate="yes" xml:space="preserve">
          <source>Pig Latin provides operators that can help you debug your Pig Latin statements:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f38d85519e485d8e2d061fcc97d35bf4ac9736e0" translate="yes" xml:space="preserve">
          <source>Pig Latin statement:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aafb100d0f8b7f3882c6325c161b1a4b645fc993" translate="yes" xml:space="preserve">
          <source>Pig Latin statements are generally organized as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dfefbefcd550d25bef5229b93a8fd8ba2bde0953" translate="yes" xml:space="preserve">
          <source>Pig Latin statements are the basic constructs you use to process data using Pig. A Pig Latin statement is an operator that takes a &lt;a href=&quot;basic#relations&quot;&gt;relation&lt;/a&gt; as input and produces another relation as output. (This definition applies to all Pig Latin operators except LOAD and STORE which read data from and write data to the file system.) Pig Latin statements may include &lt;a href=&quot;basic#expressions&quot;&gt;expressions&lt;/a&gt; and &lt;a href=&quot;basic#schemas&quot;&gt;schemas&lt;/a&gt;. Pig Latin statements can span multiple lines and must end with a semi-colon ( ; ). By default, Pig Latin statements are processed using &lt;a href=&quot;perf#multi-query-execution&quot;&gt;multi-query execution&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d6b1b831ea171957ed0e1ca09e2fcb0f0cc8198" translate="yes" xml:space="preserve">
          <source>Pig Latin supports casts as shown in this table.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d272d6e8e9fd410fba40f8d7f45eb3ef23d66fd5" translate="yes" xml:space="preserve">
          <source>Pig Latin supports the definition, expansion, and import of macros.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a52974cdd3ea4e71d39c1a5b454a4491f41f2366" translate="yes" xml:space="preserve">
          <source>Pig Latin syntax statement:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6de2cdfe9e769e638ae13f67688e2ebf50c4116" translate="yes" xml:space="preserve">
          <source>Pig Macros</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a2ca1d4b92ee91ccc81dde3263e5535ea441ba7" translate="yes" xml:space="preserve">
          <source>Pig Object</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9fd1a1cb2d567f7a5ff0480ca9134d87032c5949" translate="yes" xml:space="preserve">
          <source>Pig Progress Notification Listener</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99c542779d91327bc9bd3447f9526c2088c67b88" translate="yes" xml:space="preserve">
          <source>Pig Properties</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="734f02bedf731c9ba833109c0b94942fe59227b8" translate="yes" xml:space="preserve">
          <source>Pig Script 1, Query Phrase Popularity (local mode)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e141603768346ca22cbf8799fa641ebc9a2665a" translate="yes" xml:space="preserve">
          <source>Pig Script 1, Query Phrase Popularity (mapreduce mode)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2da304232e645beee888e58d6826aa40479df310" translate="yes" xml:space="preserve">
          <source>Pig Script 1: Query Phrase Popularity</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9be711a0ed7d8a9d09e991f0c431dfed287b99e" translate="yes" xml:space="preserve">
          <source>Pig Script 2, Temporal Query Phrase Popularity (local mode)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2397170eecb6952fd14aafebda31090031e9196" translate="yes" xml:space="preserve">
          <source>Pig Script 2, Temporal Query Phrase Popularity (mapreduce mode)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96a4246b4d848f77f5340b34b8f5f9356de36427" translate="yes" xml:space="preserve">
          <source>Pig Script 2: Temporal Query Phrase Popularity</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d650e124b03231e4f6e63a60633af92981457281" translate="yes" xml:space="preserve">
          <source>Pig Scripts</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3711a90b3c1fa50c85635bc7e599451f34dc20e0" translate="yes" xml:space="preserve">
          <source>Pig Scripts and MapReduce Job IDs (MapReduce mode only)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43590fd010743d8912e0f24af54d70fb5088bcc6" translate="yes" xml:space="preserve">
          <source>Pig Setup</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad6533e178840e687da8395d7e65379f0284aea8" translate="yes" xml:space="preserve">
          <source>Pig Statistics</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e124c110e55a5e3fc700ba74964a062c34387574" translate="yes" xml:space="preserve">
          <source>Pig Statistics is a framework for collecting and storing script-level statistics for Pig Latin. Characteristics of Pig Latin scripts and the resulting MapReduce jobs are collected while the script is executed. These statistics are then available for Pig users and tools using Pig (such as Oozie) to retrieve after the job is done.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="612dd975aa5ad31fc345b7a3ddd612ad0616e4ab" translate="yes" xml:space="preserve">
          <source>Pig Tutorial</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4757ba63e67d355d84729fef8914757bf15f22dd" translate="yes" xml:space="preserve">
          <source>Pig Tutorial Files</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4e3c20276b1374c79d691d19de05b31570ed547" translate="yes" xml:space="preserve">
          <source>Pig Type</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47775b7064fc01c255082ec71e837ab11cb3bfdc" translate="yes" xml:space="preserve">
          <source>Pig Types and Native Java Types</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="763ba17130114f0d728d2c9da6a94cee2662e38e" translate="yes" xml:space="preserve">
          <source>Pig allocates a fix amount of memory to store bags and spills to disk as soon as the memory limit is reached. This is very similar to how Hadoop decides when to spill data accumulated by the combiner.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11d7036422db3b031d72375b00787ef03de9aa59" translate="yes" xml:space="preserve">
          <source>Pig allows you to cast the elements of a single-tuple relation into a scalar value. The tuple can be a single-field or multi-field tulple. If the relation contains more than one tuple, however, a runtime error is generated: &quot;Scalar has more than one row in the output&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6f9793557df721a51315601bec2173f9083f743" translate="yes" xml:space="preserve">
          <source>Pig allows you to transform data in many ways. As a starting point, become familiar with these operators:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73604424b7f623aa52673331d4844b85c87dfa4e" translate="yes" xml:space="preserve">
          <source>Pig also provides support for Piggy Bank, a repository for JAVA UDFs. Through Piggy Bank you can access Java UDFs written by other users and contribute Java UDFs that you have written.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2ee3d36a3dc27b7f962519361eb68284ec849ad" translate="yes" xml:space="preserve">
          <source>Pig bigdecimal/biginteger all map to Orc DECIMAL</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a000788cb7b838a8a19059f606035a562b8829b" translate="yes" xml:space="preserve">
          <source>Pig bytearray maps to Orc BINARY</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da371b573e3bcb43e639b2160b5c518b0b7700f1" translate="yes" xml:space="preserve">
          <source>Pig chararray maps to Orc STRING</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d31dc542bef65e4c473198b27d60992d79d21e7" translate="yes" xml:space="preserve">
          <source>Pig comes with a set of built in functions (the eval, load/store, math, string, bag and tuple functions). Two main properties differentiate built in functions from &lt;a href=&quot;udf&quot;&gt;user defined functions&lt;/a&gt; (UDFs). First, built in functions don't need to be registered because Pig knows where they are. Second, built in functions don't need to be qualified when they are used because Pig knows where to find them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec76128e5910a6c0dc476b3ee3f3c86bf0e02469" translate="yes" xml:space="preserve">
          <source>Pig currently drops all STORE and DUMP commands. You can tell PigUnit to keep the commands and execute the script:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ad1529318465104bd4cda2ad68472350964be44" translate="yes" xml:space="preserve">
          <source>Pig currently supports ordering on fields with simple types or by tuple designator (*). You cannot order on fields with complex types or by expressions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9f5530e025cc570af7472498b65ad3cdc347893" translate="yes" xml:space="preserve">
          <source>Pig datetime maps to Orc TIMESTAMP</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b06635ad448da689ef56ed31a6a822d359c09cd2" translate="yes" xml:space="preserve">
          <source>Pig does not (yet) determine when a field is no longer needed and drop the field from the row. For example, say you have a query like:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c9e85a8b2e0c0dd60b8ab7196e655a11595d0e5" translate="yes" xml:space="preserve">
          <source>Pig does not provide a loader that supports outer merge joins. You will need to build your own loader to take advantage of this feature.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78bf7455f2e9a63798376b4de79dec1915e2cc29" translate="yes" xml:space="preserve">
          <source>Pig function names are case sensitive and UPPER CASE.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3497b8a9c4307da9ad98ce7b329893e102bfadf9" translate="yes" xml:space="preserve">
          <source>Pig has implemented a merge join algorithm, or sort-merge join. It works on pre-sorted data, and does not sort data for you. See Conditions, below, for restrictions that apply when using this join algorithm. Pig implements the merge join algorithm by selecting the left input of the join to be the input file for the map phase, and the right input of the join to be the side file. It then samples records from the right input to build an index that contains, for each sampled record, the key(s) the filename and the offset into the file the record begins at. This sampling is done in the first MapReduce job. A second MapReduce job is then initiated, with the left input as its input. Each map uses the index to seek to the appropriate record in the right input and begin doing the join.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c465a5a14c5bf2028d4313b2065c52ed6b1f407" translate="yes" xml:space="preserve">
          <source>Pig has six execution modes or exectypes:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="abe1a7ac5158db2e5d49b5c0bf1750141f4b1162" translate="yes" xml:space="preserve">
          <source>Pig invokes all types of Hive UDF, including UDF, GenericUDF, UDAF, GenericUDAF and GenericUDTF. Depending on the Hive UDF you want to use, you need to declare it in Pig with HiveUDF(handles UDF and GenericUDF), HiveUDAF(handles UDAF and GenericUDAF), HiveUDTF(handles GenericUDTF).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab624fcbf738a4b8acd080c76087b67d14708f02" translate="yes" xml:space="preserve">
          <source>Pig may process results differently than as stated in the Java API Specification. If any of the input parameters are null or if an insufficient number of parameters are supplied, NULL is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a922bbffcd1b5032fad1768816830c613580833" translate="yes" xml:space="preserve">
          <source>Pig may process results differently than as stated in the Java API Specification:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9471d85941c65173fff582e14b71cf4f967ea913" translate="yes" xml:space="preserve">
          <source>Pig provides constant representations for all data types except bytearrays.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87c574c013f523193858b45a84f91642023a8f10" translate="yes" xml:space="preserve">
          <source>Pig provides extensive support for user defined functions (UDFs) as a way to specify custom processing. Pig UDFs can currently be implemented in six languages: Java, Jython, Python, JavaScript, Ruby and Groovy.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ceda33dea4ba3f881c49648249091f447f7a880a" translate="yes" xml:space="preserve">
          <source>Pig provides shortcuts for the frequently used debugging operators (DUMP, DESCRIBE, EXPLAIN, ILLUSTRATE). These shortcuts can be used in Grunt shell or within pig scripts. Following are the shortcuts supported by pig</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e8994ca2f5728663eb94fb005036ffcd6396df7" translate="yes" xml:space="preserve">
          <source>Pig provides the ability to register a listener to receive event notifications during the execution of a script. Events include MapReduce plan creation, script launch, script progress, script completion, job submit, job start, job completion and job failure.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa6596e8905b3938c3700ea230f899c89f11a17f" translate="yes" xml:space="preserve">
          <source>Pig reserved keywords are listed here.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ee530c88eb069019e89fb162c7af7e0491d6334" translate="yes" xml:space="preserve">
          <source>Pig scripts allow you to pass values to parameters using &lt;a href=&quot;cont#Parameter-Sub&quot;&gt;parameter substitution&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7af5953cb1970013fe65b12593533955cde08d36" translate="yes" xml:space="preserve">
          <source>Pig scripts could contain multiple STORE statements. There are cases when one would like to avoid writing to the same output location. Pig provides admins/script writers with a property to check if multiple STORE statements make an attempt to write to the same output directory. And fail fast letting the user know of the same.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4f54e08d6f27a21247ba6b73114b665162748d1" translate="yes" xml:space="preserve">
          <source>Pig stores the intermediate data generated between MapReduce jobs in a temporary location on HDFS. This location must already exist on HDFS prior to use. This location can be configured using the pig.temp.dir property. The property's default value is &quot;/tmp&quot; which is the same as the hardcoded location in Pig 0.7.0 and earlier versions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="714c7646d7666c8d22f8f121acb63f13797f2c2b" translate="yes" xml:space="preserve">
          <source>Pig string functions have an extra, first parameter: the string to which all the operations are applied.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d463cd387da41f017a06eeec2ec8c8e1a5cb86d2" translate="yes" xml:space="preserve">
          <source>Pig supports a number of Java properties that you can use to customize Pig behavior. You can retrieve a list of the properties using the &lt;a href=&quot;cmds#help&quot;&gt;help properties&lt;/a&gt; command. All of these properties are optional; none are required.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="baff641180058647b74777d2576baee8385ad92c" translate="yes" xml:space="preserve">
          <source>Pig supports running scripts (and Jar files) that are stored in HDFS, Amazon S3, and other distributed file systems. The script's full location URI is required (see &lt;a href=&quot;basic#register&quot;&gt;REGISTER&lt;/a&gt; for information about Jar files). For example, to run a Pig script on HDFS, do the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93b8509eca6765e62d9376104cd05a29add5f154" translate="yes" xml:space="preserve">
          <source>Pig supports various &lt;a href=&quot;perf#optimization-rules&quot;&gt;optimization rules&lt;/a&gt; which are turned on by default. Become familiar with these rules.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7db2788da4d3cb08c1ef2ff25689ec2ee8056211" translate="yes" xml:space="preserve">
          <source>Pig supports various optimization rules, all of which are enabled by default. To disable all or specific optimizations, use one or more of the following methods. Note some optimization rules are mandatory and cannot be disabled.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dec5b4fd96103af2122e2313ddd5abca5934ce71" translate="yes" xml:space="preserve">
          <source>Pig to Groovy</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ffd9764afd639133c7dcafbb3bfb8b5a0f6b5c57" translate="yes" xml:space="preserve">
          <source>Pig uses BinStorage to load and store the temporary data that is generated between multiple MapReduce jobs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6f964ef2f2e1463a5575b90549505104722c310" translate="yes" xml:space="preserve">
          <source>Pig uses type information for validation and performance. It is important for UDFs to participate in type propagation. Our UDFs generally make no effort to communicate their output schema to Pig. This is because Pig can usually figure out this information by using Java's &lt;a href=&quot;http://www.oracle.com/technetwork/articles/java/javareflection-1536171.html&quot;&gt; Reflection&lt;/a&gt;. If your UDF returns a scalar or a map, no work is required. However, if your UDF returns a tuple or a bag (of tuples), it needs to help Pig figure out the structure of the tuple.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6c4f473278cb2c4d79b79244d369de45127e72f" translate="yes" xml:space="preserve">
          <source>Pig will look for the #!/usr/bin/python line in the script.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e77ea84c3c6071688fbeecc5c58ee3a6a8b11e23" translate="yes" xml:space="preserve">
          <source>Pig will look for the *.groovy extension in the script.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0364a2ce40f5c70f5452cfa0554c3480442e1323" translate="yes" xml:space="preserve">
          <source>Pig will look for the *.js extension in the script.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91634384ed9e6b31da4cf199ee9633830ca9b602" translate="yes" xml:space="preserve">
          <source>Pig will not auto-ship files in the following system directories (this is determined by executing 'which &amp;lt;file&amp;gt;' command).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25b2234668fa28c694ddf8954f0db6fd297cd55d" translate="yes" xml:space="preserve">
          <source>PigDump</source>
          <target state="translated">PigDump</target>
        </trans-unit>
        <trans-unit id="cd0f4a6c71f7d548ed016babe0f1794757d97253" translate="yes" xml:space="preserve">
          <source>PigDump stores data as tuples in human-readable UTF-8 format.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="076d83430955260169fb65f99eac100421155024" translate="yes" xml:space="preserve">
          <source>PigDump()</source>
          <target state="translated">PigDump()</target>
        </trans-unit>
        <trans-unit id="7e5a4069b9fdb2979478c1ee4fdbc3e2c6ad6bac" translate="yes" xml:space="preserve">
          <source>PigProgressNotificationListener Object</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b203b52f09d0ae21512293305adfa539797f50a" translate="yes" xml:space="preserve">
          <source>PigRunner API</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c591d5d2fae917bd8241460a851795d39ef7fd4d" translate="yes" xml:space="preserve">
          <source>PigServer Interface</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f322dd1e3ab68730e8f4ea4e48514c5d2b0e8fe" translate="yes" xml:space="preserve">
          <source>PigStats</source>
          <target state="translated">PigStats</target>
        </trans-unit>
        <trans-unit id="09ef3422b57b20584bb4bd1065c0d793e6c60aa6" translate="yes" xml:space="preserve">
          <source>PigStats Object</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c9ea42da56c5bce11828868d9a6b3bd2007fda6" translate="yes" xml:space="preserve">
          <source>PigStats is now an abstract class. (PigStats as it was before has become SimplePigStats.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25cdca4514b647129134787cd149f41de99035d4" translate="yes" xml:space="preserve">
          <source>PigStorage</source>
          <target state="translated">PigStorage</target>
        </trans-unit>
        <trans-unit id="189d56b69a7325ea9365151a6fd186619f7dba18" translate="yes" xml:space="preserve">
          <source>PigStorage is the default function used by Pig to load/store the data. PigStorage supports structured text files (in human-readable UTF-8 format) in compressed or uncompressed form (see &lt;a href=&quot;#handling-compression&quot;&gt;Handling Compression&lt;/a&gt;). All Pig &lt;a href=&quot;basic#data-types&quot;&gt;data types&lt;/a&gt; (both simple and complex) can be read/written using this function. The input data to the load can be a file, a directory or a glob.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db2e71c500f2a58ecf6be6205a6d15e6c21c547c" translate="yes" xml:space="preserve">
          <source>PigStorage is the default load function for the LOAD operator. In this example the is not null operator is used to filter names with null values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="851b7752cd0d7ce793cb4e4ca346b699d8bf7ba9" translate="yes" xml:space="preserve">
          <source>PigStorage( [field_delimiter] , ['options'] )</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d3b09a00028b253cd0f1f6c7b23a76114298a8a" translate="yes" xml:space="preserve">
          <source>PigUnit</source>
          <target state="translated">PigUnit</target>
        </trans-unit>
        <trans-unit id="dbc328ccebde1c387467a71ae41410ef063708a6" translate="yes" xml:space="preserve">
          <source>PigUnit Example</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e58deab3203c61b8478e84f609cbbfd6830c6870" translate="yes" xml:space="preserve">
          <source>PigUnit also runs in Pig's mapreduce/tez/tez_local mode. Mapreduce/Tez mode requires you to use a Hadoop cluster and HDFS installation. It is enabled when the Java system property pigunit.exectype is set to specific values (mr/tez/tez_local): e.g. -Dpigunit.exectype=mr or System.getProperties().setProperty(&quot;pigunit.exectype&quot;, &quot;mr&quot;), which means PigUnit will run in mr mode. The cluster you select to run mr/tez test must be specified in the CLASSPATH (similar to the HADOOP_CONF_DIR variable).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5efb4aafd77f51485d9e22a5331f73c21b84e2d1" translate="yes" xml:space="preserve">
          <source>PigUnit is a simple xUnit framework that enables you to easily test your Pig scripts. With PigUnit you can perform unit testing, regression testing, and rapid prototyping. No cluster set up is required if you run Pig in local mode.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e825c7a9656dd5933b89b6587e34170d6f8b825d" translate="yes" xml:space="preserve">
          <source>PigUnit runs in Pig's local mode by default. Local mode is fast and enables you to use your local file system as the HDFS cluster. Local mode does not require a real cluster but a new local one is created each time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51485a7e9c11278ddb30a38747984651921c7357" translate="yes" xml:space="preserve">
          <source>Piggy Bank</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94706352a7655c2f04cd6d5b3c48f2991946cce6" translate="yes" xml:space="preserve">
          <source>Piggy Bank is a place for Pig users to share the Java UDFs they have written for use with Pig. The functions are contributed &quot;as-is.&quot; If you find a bug in a function, take the time to fix it and contribute the fix to Piggy Bank. If you don't find the UDF you need, take the time to write and contribute the function to Piggy Bank.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="548bf24c348f6ecb39a696616e88c2bdb8fc7c48" translate="yes" xml:space="preserve">
          <source>Piggybank now contains a load function called org.apache.pig.piggybank.storage.IndexedStorage that is a derivation of PigStorage and implements IndexedLoadFunc. This is the only loader included in the standard Pig distribution that can be used for merge-sparse join.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80e46ef91cf972b79cfeb37c8c0b0f1a663a2b3c" translate="yes" xml:space="preserve">
          <source>Place your java code in the directory that makes sense for your function. The directory structure currently has two levels: (1) function type, as described in &lt;a href=&quot;#piggbank-access&quot;&gt;Accessing Functions&lt;/a&gt;, and (2) function subtype, for some of the types (like math or string for eval functions). If you think your function requires a new subtype, feel free to add one.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45b51fb4489a0001750d8a0d80a1eabd943fd26b" translate="yes" xml:space="preserve">
          <source>Please note that all parameters must be resolved during bind. Having unbound parameters while running your script is an error. Also note that even if your script is fully defined during compile, bind without parameters still must be called.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a06967c386bbcf581bbbff0858c5a65621763d0" translate="yes" xml:space="preserve">
          <source>Please note that the script above can be made more efficient by performing filtering before the GROUP statement:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e1fc2184a267b82bd60f72a9ca2cc38f005be8b" translate="yes" xml:space="preserve">
          <source>Please note the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e0f495264f489ed260b938fbaf923286b89db5c" translate="yes" xml:space="preserve">
          <source>Please see &lt;a href=&quot;http://joda-time.sourceforge.net/timezones.html&quot;&gt;the Joda-Time doc&lt;/a&gt; for available timezone IDs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3414cc34b87b848682458107bbe3817781eebf0" translate="yes" xml:space="preserve">
          <source>PluckTuple</source>
          <target state="translated">PluckTuple</target>
        </trans-unit>
        <trans-unit id="5d6a4911520319a2d3e4452f20e0a79aefaaa5b1" translate="yes" xml:space="preserve">
          <source>Point $HADOOPDIR to the directory that contains the hadoop-site.xml file. Example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dbec33ded970d7645cff3e7a90ffcb1db17bf2b3" translate="yes" xml:space="preserve">
          <source>Positional notation (generated by system)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a1a9c9263f88ba37537ce91842a5071d4c86b03" translate="yes" xml:space="preserve">
          <source>Positional notation is generated by the system. Positional notation is indicated with the dollar sign ($) and begins with zero (0); for example, $0, $1, $2.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="470b7c6b31d52098c05a7c0eb3537e05b562b162" translate="yes" xml:space="preserve">
          <source>Possible name (assigned by you using a schema)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab86fb82a986460447b29bbb55ca5b9bf867bad6" translate="yes" xml:space="preserve">
          <source>Precedence</source>
          <target state="translated">Precedence</target>
        </trans-unit>
        <trans-unit id="c62fe3da66de5300e411627aa04bcf8aba54c94e" translate="yes" xml:space="preserve">
          <source>Precedence for parameters is as follows, from highest to lowest:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa06e8fd282659ac6d432bb0788f9503111f1ec3" translate="yes" xml:space="preserve">
          <source>Predicate pushdown</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67219f57bcad6686b5aafd1fa4c0f49cde92f4ad" translate="yes" xml:space="preserve">
          <source>PredicatePushdownOptimizer</source>
          <target state="translated">PredicatePushdownOptimizer</target>
        </trans-unit>
        <trans-unit id="8adf8f822b81878db822737e2402a291fabdb7a0" translate="yes" xml:space="preserve">
          <source>Prefer DISTINCT over GROUP BY/GENERATE</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71ee3d895930077b420791fb640e0fcf277eb35a" translate="yes" xml:space="preserve">
          <source>Preprocessor statement included in a Pig script.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e7683a0a1b3a8c7fba74716254c107f2f5e90e3" translate="yes" xml:space="preserve">
          <source>Prerequisite: Tez requires the tez tarball to be available in hdfs while running a job on the cluster and a tez-site.xml with tez.lib.uris setting pointing to that hdfs location in classpath. Copy the tez tarball to hdfs and add the tez conf directory($TEZ_HOME/conf) containing tez-site.xml to environmental variable &quot;PIG_CLASSPATH&quot; if pig on tez fails with &quot;tez.lib.uris is not defined&quot;. This is required by the Apache Pig distribution.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68c4f7f4e32d071edfecdccbc2955d1848fe5d3f" translate="yes" xml:space="preserve">
          <source>Previous Relation Shortcut</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91668392239b2ed6e082ab66f5115752a3228d5d" translate="yes" xml:space="preserve">
          <source>Prints a list of Pig commands or properties.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64172510397f433c399b5d42e0b1269626b1a958" translate="yes" xml:space="preserve">
          <source>Processing Order and Precedence</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="985f018300a3bcf017393d943a21bd0b142ab797" translate="yes" xml:space="preserve">
          <source>Processing input (either user input or intermediate input) from multiple small files can be inefficient because a separate map has to be created for each file. Pig can now combined small files so that they are processed as a single map.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="068b6f370b0ca1593f3b3fbac750583d9d7d8efa" translate="yes" xml:space="preserve">
          <source>Processing small mapreduce jobs on hadoop cluster could be slow as it has overhead of job startup and job scheduling. For jobs with small input data, pig can convert them to run them as in-process mapreduce with hadoop's local mode. If pig.auto.local.enabled flag is set to true, pig will convert mapreduce jobs with input data less than pig.auto.local.input.maxbytes (100MB by default) to run in local mode, provided the number of reducers required by the job are less than or equal to 1. Note, jobs converted to run in local mode load and store data from HDFS, so any job in the pig workflow(dag) could be converted to run in local mode without affecting its downstream jobs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d28a282560bb759052a3e6e6fcd13088d888408" translate="yes" xml:space="preserve">
          <source>Project Early and Often</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9155c425ec77a3089191509a98c385937bbb07a9" translate="yes" xml:space="preserve">
          <source>Project-Range Expressions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="549f47352730051b89a49356a5aa47d12e349987" translate="yes" xml:space="preserve">
          <source>Project-range ( .. ) expressions can be used to project a range of columns from input. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="badce2f5aad822deab06383975c71e3c2b6f9be2" translate="yes" xml:space="preserve">
          <source>Project-range can be used in all cases where the &lt;a href=&quot;#sexp&quot;&gt;star expression&lt;/a&gt; ( * ) is allowed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c69909c9dc93448f96162044d8b25b4d837f86e" translate="yes" xml:space="preserve">
          <source>Project-range can be used in the following statements: &lt;a href=&quot;#foreach&quot;&gt;FOREACH&lt;/a&gt;, &lt;a href=&quot;#join-inner&quot;&gt;JOIN&lt;/a&gt;, &lt;a href=&quot;#group&quot;&gt;GROUP&lt;/a&gt;, &lt;a href=&quot;#cogroup&quot;&gt;COGROUP&lt;/a&gt;, and &lt;a href=&quot;#order-by&quot;&gt;ORDER BY&lt;/a&gt; (also when ORDER BY is used within a nested FOREACH block).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa33f39f5421ef81d13a830fb4443370104ee3c9" translate="yes" xml:space="preserve">
          <source>Projections (dimensions) of the relation. Supports field, star and project-range expressions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ec840bd9176cde5b4141fc791989284f3e9ed0c" translate="yes" xml:space="preserve">
          <source>Prune the loader to only load necessary columns. The performance gain is more significant if the corresponding loader support column pruning and only load necessary columns (See LoadPushDown.pushProjection). Otherwise, ColumnMapKeyPrune will insert a ForEach statement right after loader.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c46a0e7afbefa23c27c29686d94920c8b40fe658" translate="yes" xml:space="preserve">
          <source>Prune unused column as soon as possible. In addition to prune the loader in ColumnMapKeyPrune, we can prune a column as soon as it is not used in the rest of the script</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7931337f31f75950cb4c2cdebc73bd2f84097cc" translate="yes" xml:space="preserve">
          <source>Push the filter condition to loader.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc4197eb949bc0da0a0aeedd23a8819a37dc696c" translate="yes" xml:space="preserve">
          <source>Push the filter condition to loader. Different than PartitionFilterOptimizer, the filter condition will be evaluated in Pig. In other words, the filter condition pushed to the loader is a hint. Loader might still load records which does not satisfy filter condition.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6019407474c8f4cd672f2782447a068a3eff87a" translate="yes" xml:space="preserve">
          <source>PushDownForEachFlatten</source>
          <target state="translated">PushDownForEachFlatten</target>
        </trans-unit>
        <trans-unit id="00d23fd27f64adf999e795e338babf1919b5159b" translate="yes" xml:space="preserve">
          <source>PushUpFilter</source>
          <target state="translated">PushUpFilter</target>
        </trans-unit>
        <trans-unit id="9e91ff7fcaea97ed1e629c1ea1dd3a3be1f9a961" translate="yes" xml:space="preserve">
          <source>Queries that can take advantage of the combiner generally ran much faster (sometimes several times faster) than the versions that don't. The latest code significantly improves combiner usage; however, you need to make sure you do your part. If you have a UDF that works on grouped data and is, by nature, algebraic (meaning their computation can be decomposed into multiple steps) make sure you implement it as such. For details on how to write algebraic UDFs, see &lt;a href=&quot;udf#algebraic-interface&quot;&gt;Algebraic Interface&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7189bc7a153aae22c9ad9fbdd927084b0fc40f73" translate="yes" xml:space="preserve">
          <source>Quits from the Pig grunt shell.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="620db5d9320e96ee12d500dbe6be7488db8de087" translate="yes" xml:space="preserve">
          <source>RANDOM</source>
          <target state="translated">RANDOM</target>
        </trans-unit>
        <trans-unit id="9e3bfd1f2a524ee518de592cf7435459586a3d76" translate="yes" xml:space="preserve">
          <source>RANDOM( )</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9cc2229409ebf7a451b2509c23892c92fff169d6" translate="yes" xml:space="preserve">
          <source>RANK</source>
          <target state="translated">RANK</target>
        </trans-unit>
        <trans-unit id="94e87841c18078a6be5f0c47297fcf1078db118b" translate="yes" xml:space="preserve">
          <source>REGEX_EXTRACT</source>
          <target state="translated">REGEX_EXTRACT</target>
        </trans-unit>
        <trans-unit id="25060cd6008a61bda5883baa15d7cfb4500fcb19" translate="yes" xml:space="preserve">
          <source>REGEX_EXTRACT (string, regex, index)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0921fe22357a6d6189cafbbaccb9446992f7c4b5" translate="yes" xml:space="preserve">
          <source>REGEX_EXTRACT_ALL</source>
          <target state="translated">REGEX_EXTRACT_ALL</target>
        </trans-unit>
        <trans-unit id="0b2e921ca3a52345dca73d874d8ecb7ca4ad0cc1" translate="yes" xml:space="preserve">
          <source>REGEX_EXTRACT_ALL (string, regex)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7aa14173b8000e15aca4adfdc3b1a5e0d8c44ef0" translate="yes" xml:space="preserve">
          <source>REGEX_SEARCH</source>
          <target state="translated">REGEX_SEARCH</target>
        </trans-unit>
        <trans-unit id="4c56880804c60faefafcbee89177e1727de2dff4" translate="yes" xml:space="preserve">
          <source>REGEX_SEARCH(string, 'regExp');</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="018678424b56c2120abb69e981ef3eec820e05dd" translate="yes" xml:space="preserve">
          <source>REGISTER (a jar/script)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c28d820c6f95eb8bc2a1c939755c4308dae8a884" translate="yes" xml:space="preserve">
          <source>REGISTER (an artifact)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2f18c3d25c024de2d314688e5568c2e2b885ce4" translate="yes" xml:space="preserve">
          <source>REGISTER ivy://group:module:version?querystring</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3213ec58664edb7df53533dc66ffd9af231fd2cb" translate="yes" xml:space="preserve">
          <source>REGISTER ivy://org:module:version?classifier=value</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="298b74bfc4131cf922f0663bebad6b611ebc696d" translate="yes" xml:space="preserve">
          <source>REGISTER ivy://org:module:version?exclude=org:mod,org:mod,...</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9f07df8a78db31fca096c05b31f0bcd7a3a50f7" translate="yes" xml:space="preserve">
          <source>REGISTER ivy://org:module:version?transitive=false</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="523fb225d3a2759dc8655903d1bc6a8288ada1ba" translate="yes" xml:space="preserve">
          <source>REGISTER path;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c336fcec997db68ba1a16ff95d4b5a6b5f133c3b" translate="yes" xml:space="preserve">
          <source>REPLACE</source>
          <target state="translated">REPLACE</target>
        </trans-unit>
        <trans-unit id="e04cf56acc0c4981837a53b7ff1256bf0c0ff4fe" translate="yes" xml:space="preserve">
          <source>REPLACE(string, 'regExp', 'newChar');</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95253203f79304981143599cedfdaa606f083ca2" translate="yes" xml:space="preserve">
          <source>RIGHT</source>
          <target state="translated">RIGHT</target>
        </trans-unit>
        <trans-unit id="7f78099ba5db4acf80827e5f3d1a83db2ae525ec" translate="yes" xml:space="preserve">
          <source>ROLLUP</source>
          <target state="translated">ROLLUP</target>
        </trans-unit>
        <trans-unit id="8580cec9b53e98ece67f310e025d4a349121f88a" translate="yes" xml:space="preserve">
          <source>ROUND</source>
          <target state="translated">ROUND</target>
        </trans-unit>
        <trans-unit id="cacfa70692e87c3321966a012a48ba58ce3bb591" translate="yes" xml:space="preserve">
          <source>ROUND(expression)</source>
          <target state="translated">ROUND(expression)</target>
        </trans-unit>
        <trans-unit id="c4c0b1ef3217efe1d9bf9b7d827e6ad059b864bd" translate="yes" xml:space="preserve">
          <source>ROUND(x)</source>
          <target state="translated">ROUND(x)</target>
        </trans-unit>
        <trans-unit id="0715c249cd668d5284678dca026287c3e463851a" translate="yes" xml:space="preserve">
          <source>ROUND_TO</source>
          <target state="translated">ROUND_TO</target>
        </trans-unit>
        <trans-unit id="9e50ef723b8064863d96f779d169424a37563aa0" translate="yes" xml:space="preserve">
          <source>ROUND_TO(val, digits [, mode])</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8552829751a281e6ba49d05c41a939ede5eaafcb" translate="yes" xml:space="preserve">
          <source>ROUND_TO(val, digits)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43bc1be6b036dd85df3053c47dc4432d982cf8e0" translate="yes" xml:space="preserve">
          <source>RTRIM</source>
          <target state="translated">RTRIM</target>
        </trans-unit>
        <trans-unit id="d0176c9b5630a9edca1e76d654fc1c435437c454" translate="yes" xml:space="preserve">
          <source>RTRIM(expression)</source>
          <target state="translated">RTRIM(expression)</target>
        </trans-unit>
        <trans-unit id="2a967919b023bdd7576620af97326ae9c9f3491d" translate="yes" xml:space="preserve">
          <source>Record Deliminters &amp;ndash; For load statements Pig interprets the line feed ( '\n' ), carriage return ( '\r' or CTRL-M) and combined CR + LF ( '\r\n' ) characters as record delimiters (do not use these characters as field delimiters). For store statements Pig uses the line feed ('\n') character as the record delimiter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef6b7434b39836c7b5476b127140cb9fc733f047" translate="yes" xml:space="preserve">
          <source>Reduce Your Operator Pipeline</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5b5c7ea81e2d801d5ee70f53f3a6c23d9a8c4e6" translate="yes" xml:space="preserve">
          <source>Reducer Estimation</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62beeb3ebea5d1b6fbcca509b70d060344fdd22b" translate="yes" xml:space="preserve">
          <source>Refer to args positionally and as many times as you like using %(pos)$.... Use %&amp;lt;... to refer to the previously-specified arg.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4737d8da85fe53493025312e1f0d18e0867c487c" translate="yes" xml:space="preserve">
          <source>Referencing Fields</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4cae9bdf3920da7757a8c85f6b54d8738dd7967d" translate="yes" xml:space="preserve">
          <source>Referencing Fields that are Complex Data Types</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d23bb24e2f8bcaae71a9d10cc001c98353b1b509" translate="yes" xml:space="preserve">
          <source>Referencing Relations</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc42ec7da7d0e19f1a5ed6e62ea29d2d256d89ad" translate="yes" xml:space="preserve">
          <source>Register the tutorial JAR file so that the included UDFs can be called in the script.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6692a10545ad9ae35c076d55ecf3df797aeb3ad4" translate="yes" xml:space="preserve">
          <source>Register the tutorial JAR file so that the user defined functions (UDFs) can be called in the script.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26c92f3731d6fecfb43c28c225f8c2bc30998abb" translate="yes" xml:space="preserve">
          <source>Registering an Artifact and all its dependencies.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc29b2e11b3b43cda736fcba0bb6760a606e849e" translate="yes" xml:space="preserve">
          <source>Registering an artifact by excluding specific dependencies.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f4ed5bdc8024ad52459ee1a00ab28199dd38f89" translate="yes" xml:space="preserve">
          <source>Registering an artifact without a group or organization. Just skip them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d4a9d6f350eea88c38c96fd0c95e87ab7bbad29" translate="yes" xml:space="preserve">
          <source>Registering an artifact without getting its dependencies.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da1d3a98f791337ad0a4ec68eae079eb6ef95ae7" translate="yes" xml:space="preserve">
          <source>Registering the UDF</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a29de9c3832ce4b8e6b18747e5a829713fca18d" translate="yes" xml:space="preserve">
          <source>Registering the latest artifact.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd54c0c65bf4584f34e8a3942380ffcf0970fe76" translate="yes" xml:space="preserve">
          <source>Registers a JAR file so that the UDFs in the file can be used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="428be11df215f5cd15290e03edfab6e2024b704f" translate="yes" xml:space="preserve">
          <source>Relation X looks like this. A tuple is created for each unique key field. The tuple includes the key field and two bags. The first bag is the tuples from the first relation with the matching key field. The second bag is the tuples from the second relation with the matching key field. If no tuples match the key field, the bag is empty.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="354032ada697719ccb58ca87cd221831508c42b3" translate="yes" xml:space="preserve">
          <source>Relational Operators</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac6eb526c4d3427712a60a1a682dfb9f6e58dad9" translate="yes" xml:space="preserve">
          <source>Relations are referred to by name (or alias). Names are assigned by you as part of the Pig Latin statement. In this example the name (alias) of the relation is A.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="657fe9adf3cabd570b43f36ea037911276330628" translate="yes" xml:space="preserve">
          <source>Relations, Bags, Tuples, Fields</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47f90b570611ed6b62f0263d679682900ef503e8" translate="yes" xml:space="preserve">
          <source>Remove the boiler plate code appearing when there is more than one test methods.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f90556d367ec2b7b89d6cb1145ec2ab9a7d43795" translate="yes" xml:space="preserve">
          <source>Removes duplicate tuples in a relation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5aed14a2d8cc1e13aa0226552743bc08f973991" translate="yes" xml:space="preserve">
          <source>Removes the record if the query field is empty or a URL.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01b967cc6fcf66fa1a327d6e23a3adcc183a7585" translate="yes" xml:space="preserve">
          <source>Replaces existing characters in a string with new characters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c9f7314d870cf506926a81a725609a309180df7" translate="yes" xml:space="preserve">
          <source>Replicated Joins</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e2d170ab822648a868ed17db41712a1e458ed56" translate="yes" xml:space="preserve">
          <source>Reporting Progress</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3ab25ae5e2cc5df52b11a23cfbf50e86331bacb" translate="yes" xml:space="preserve">
          <source>Required keyword.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09a428f93ec07a73d726f8bd037ecacfaaf8b044" translate="yes" xml:space="preserve">
          <source>Requirements</source>
          <target state="translated">Requirements</target>
        </trans-unit>
        <trans-unit id="4fef845de7495dcd1565cda432d4b9908db6c9c9" translate="yes" xml:space="preserve">
          <source>Reserved Keywords</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d486788d225653651eb6a74aed6bf2b553d1d42b" translate="yes" xml:space="preserve">
          <source>Return Types and Schemas</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d4dbb16b26776ff0a9681435fb191cc339ea164" translate="yes" xml:space="preserve">
          <source>Return code 0: All jobs succeeded</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dcf12244c4ffa52bf59195a2ed18fd4736d7b67b" translate="yes" xml:space="preserve">
          <source>Return code 1: &lt;em&gt;Used for retrievable errors&lt;/em&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0358e44b177069a82ad64649295be297b6b49ac" translate="yes" xml:space="preserve">
          <source>Return code 2: All jobs have failed</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1491195b66e37f39862ac3347539de9fd938e5ac" translate="yes" xml:space="preserve">
          <source>Return code 3: Some jobs have failed</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="419dc24bbf3839e94617bca8e82b80dcf575f429" translate="yes" xml:space="preserve">
          <source>Returns Euler's number e raised to the power of x.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="513587fb94f9ca8a02c2130dbf24ce9970499d45" translate="yes" xml:space="preserve">
          <source>Returns a DateTime object according to parameters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36cf64f64f1683a1f6fd71ff4731efb70faacd64" translate="yes" xml:space="preserve">
          <source>Returns a copy of a string with leading and trailing white space removed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="881fb398d9c55cad7a537386644c3c3154142c43" translate="yes" xml:space="preserve">
          <source>Returns a copy of a string with only leading white space removed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7af3ae3ff3f406d011103cff7ba952d404e72e2" translate="yes" xml:space="preserve">
          <source>Returns a copy of a string with only trailing white space removed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2fc98512d189e4d3f3c0cca8ae024088810e4bc5" translate="yes" xml:space="preserve">
          <source>Returns a pseudo random number.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08d59bcf7e4da2d316cce1fe0f800acd9ca0e768" translate="yes" xml:space="preserve">
          <source>Returns a string converted to upper case.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60bd6525d26a868296aef9ef39229cb4f21b553b" translate="yes" xml:space="preserve">
          <source>Returns a string with the first character converted to upper case.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a6ceee3abe688e26f32d11ad4e8bfa6056694d1" translate="yes" xml:space="preserve">
          <source>Returns a string, an int, a long, a double, or a float</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="149929531961b59343eac086b94315964280e9c6" translate="yes" xml:space="preserve">
          <source>Returns a substring from a given string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f650c7101aebe01253479ec3832aa36457dd38e0" translate="yes" xml:space="preserve">
          <source>Returns a unique id string for each record in the alias.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d2e7b7f3392f0d0a7f4edac2ffbf6e49ec75c21" translate="yes" xml:space="preserve">
          <source>Returns each tuple with the rank within a relation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5de4cf3d0ef61696c28177da2c48a786b952ce4f" translate="yes" xml:space="preserve">
          <source>Returns from user defined functions (UDFs)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22f2b5afc5bcb54987844be722ae41dd06fae1e6" translate="yes" xml:space="preserve">
          <source>Returns null (no error or warning) if any single argument is null.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9d33c367a852dbfb596f52d5473ef9e15fc1757" translate="yes" xml:space="preserve">
          <source>Returns null (no error or warning) with a null format string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69abd17980fc8fc326fac6f58dfef8a3d54c981e" translate="yes" xml:space="preserve">
          <source>Returns the DateTime object of the current time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37ef5243e85c9e64bfe6667ede2cdc7c7805da8c" translate="yes" xml:space="preserve">
          <source>Returns the Unix Time as long for a DateTime object. UnixTime is the number of seconds elapsed since January 1, 1970, 00:00:00.000 GMT.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2205e5e3349d473a1aa00a87ddbbfaf4cef2bfb" translate="yes" xml:space="preserve">
          <source>Returns the absolute value of an expression.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85b804678f1cf453ee531619aad616e9ee0444a6" translate="yes" xml:space="preserve">
          <source>Returns the arc cosine of an expression.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e39a89b4ea91acef8e89dd0bab73bd8c9003ffe3" translate="yes" xml:space="preserve">
          <source>Returns the arc sine of an expression.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed3aecce972de660c52bf3943dca60cdc02e893a" translate="yes" xml:space="preserve">
          <source>Returns the arc tangent of an expression.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11d674b8dd60cc025724efb8108982d963bec977" translate="yes" xml:space="preserve">
          <source>Returns the base 10 logarithm of an expression.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6204881bdacb24f052b8f2ce9e963bcd536065ea" translate="yes" xml:space="preserve">
          <source>Returns the cube root of an expression.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b91499640701da81cac5582f0880c4af26e4863c" translate="yes" xml:space="preserve">
          <source>Returns the day of a month from a DateTime object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="046718c428dc7dd4d4c49d04ec41ba4ec46e1f95" translate="yes" xml:space="preserve">
          <source>Returns the hour of a day from a DateTime object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9e27533f3b351679e918b0146c940f249292548" translate="yes" xml:space="preserve">
          <source>Returns the hyperbolic cosine of an expression.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41ba86c915c553776146f87efe83c29cb5788f94" translate="yes" xml:space="preserve">
          <source>Returns the hyperbolic sine of an expression.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29c1b5b8c50562788b9f9d48e7847459fbd66840" translate="yes" xml:space="preserve">
          <source>Returns the hyperbolic tangent of an expression.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ba0b6ea8572bf47f2c36352a0d682f2633e3113" translate="yes" xml:space="preserve">
          <source>Returns the index of the first occurrence of a character in a string, searching forward from a start index.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b507a1b60d4ec92ab20324dabd54b2a53b040481" translate="yes" xml:space="preserve">
          <source>Returns the index of the last occurrence of a character in a string, searching backward from the end of the string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1cb694fbca257bfbfaa8a2e38404b491899885aa" translate="yes" xml:space="preserve">
          <source>Returns the millisecond of a second from a DateTime object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38e5458a5bbfe1c1e08c75b6ab2b15f6d398a004" translate="yes" xml:space="preserve">
          <source>Returns the minute of a hour from a DateTime object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b592cc480e5ac16c4831e12d57d73c66abb6b01" translate="yes" xml:space="preserve">
          <source>Returns the month of a year from a DateTime object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48a6c81ffdf6d2cf4cf5ac04a474905115f8080f" translate="yes" xml:space="preserve">
          <source>Returns the natural logarithm (base e) of an expression.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12c23b2ca17df96650ee9ee563cc87b5e17096da" translate="yes" xml:space="preserve">
          <source>Returns the number of days between two DateTime objects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e807d5135f00cb9c11e91294361fc38911f84ce8" translate="yes" xml:space="preserve">
          <source>Returns the number of hours between two DateTime objects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29fdd2cb901cf9d6cedf200b96a4083351a2cbef" translate="yes" xml:space="preserve">
          <source>Returns the number of milliseconds between two DateTime objects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="454ce2c667f43fe5c79bf50c7bd8507796c70a8a" translate="yes" xml:space="preserve">
          <source>Returns the number of milliseconds elapsed since January 1, 1970, 00:00:00.000 GMT for a DateTime object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="121e43fe18bf40c290d3191cfc7659d7eb7c5f0a" translate="yes" xml:space="preserve">
          <source>Returns the number of minutes between two DateTime objects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f78df41df2f2e976bbae604765220c5169483d0" translate="yes" xml:space="preserve">
          <source>Returns the number of months between two DateTime objects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7fd3b014ec0a7ff566e268eee49fccc5fe1a7e48" translate="yes" xml:space="preserve">
          <source>Returns the number of seconds between two DateTime objects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb227e6e9a62373e0c416d76c20a65d7d2dfeb0a" translate="yes" xml:space="preserve">
          <source>Returns the number of weeks between two DateTime objects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="223d8b607ac03fc9f2f03460164780e62eb5f639" translate="yes" xml:space="preserve">
          <source>Returns the number of years between two DateTime objects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52badd610226f06179fe93b678ec80a1a5fd11d0" translate="yes" xml:space="preserve">
          <source>Returns the positive square root of an expression.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8616431c76cac4a8057fb11c41e0a7fb048ca004" translate="yes" xml:space="preserve">
          <source>Returns the remainder of a divided by b (a%b).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f34c6241173dbb432200f51aab86ac7ba22ce94" translate="yes" xml:space="preserve">
          <source>Returns the result of a DateTime object minus a &lt;a href=&quot;http://en.wikipedia.org/wiki/ISO_8601#Durations&quot;&gt;Duration object&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e5f4ea42054712389ba9d161a9241dc2d2bed6b" translate="yes" xml:space="preserve">
          <source>Returns the result of a DateTime object plus a &lt;a href=&quot;http://en.wikipedia.org/wiki/ISO_8601#Durations&quot;&gt;Duration object&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a14b74942cf37d4ce87b5279887777ffece87cb2" translate="yes" xml:space="preserve">
          <source>Returns the schema of a relation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7604d46e673c7c005c76a6bb8363f23077180df5" translate="yes" xml:space="preserve">
          <source>Returns the second of a minute from a DateTime object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9900dd72cfc78443973c5927397ba417d993936" translate="yes" xml:space="preserve">
          <source>Returns the sine of an expression.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="afb424818b35ef253e9f9b4a24ce670200b714b6" translate="yes" xml:space="preserve">
          <source>Returns the top-n tuples from a bag of tuples.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="429dc3c96810cd8514fb775c6cad21f062815f57" translate="yes" xml:space="preserve">
          <source>Returns the trignometric tangent of an angle.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="439e6280c2aec77be8bdbea9ad7666662569a20a" translate="yes" xml:space="preserve">
          <source>Returns the trigonometric cosine of an expression.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba4f750d033224c623421cf67f35d53975b95e79" translate="yes" xml:space="preserve">
          <source>Returns the value of an expression rounded down to the nearest integer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3231b2172ae518d230e21f3d1aaf0c9d68054c6c" translate="yes" xml:space="preserve">
          <source>Returns the value of an expression rounded to a fixed number of decimal digits.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="732dc5476d1cc4d243ec593b786a34517d6cbbaa" translate="yes" xml:space="preserve">
          <source>Returns the value of an expression rounded to an integer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7f0f91270d33bf1639a9d2e64d27739473916df" translate="yes" xml:space="preserve">
          <source>Returns the value of an expression rounded up to the nearest integer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0214274502e7a06d319f46f09e8cd90ba878642c" translate="yes" xml:space="preserve">
          <source>Returns the week of a week year from a DateTime object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06c0ada39ef7630382e9d8499fc52074d7bb307d" translate="yes" xml:space="preserve">
          <source>Returns the week year from a DateTime object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6e941db4f0d8d0912857032d9ad159b271b32cc" translate="yes" xml:space="preserve">
          <source>Returns the year from a DateTime object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5764aae9ab18ee498e93f36852feed2c93bdc9fc" translate="yes" xml:space="preserve">
          <source>Review the result files, located in the script1-hadoop-results or script2-hadoop-results HDFS directory:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87c76b6e92d7e26b17fa88c6d0f6bf26b951de10" translate="yes" xml:space="preserve">
          <source>Review the result files, located in the script1-local-results.txt directory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="012599a8c6f241f3c89808b0514daa3a79a4c971" translate="yes" xml:space="preserve">
          <source>Right outer join.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7469e8632182ae0e8d493ab42d0b639213cfaf09" translate="yes" xml:space="preserve">
          <source>Rollup operation</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18b5daa46c0d001f3238ed5f9ad432b325e08c58" translate="yes" xml:space="preserve">
          <source>Rollup operations computes multiple levels of aggregates based on hierarchical ordering of specified group by dimensions. Rollup is useful when there is hierarchical ordering on the dimensions. The number of group by combinations generated by rollup for n dimensions will be n+1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1b392607deaf29a7e81453e069b7c07a32a6b18" translate="yes" xml:space="preserve">
          <source>Run</source>
          <target state="translated">Run</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
