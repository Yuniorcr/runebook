<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="elixir">
    <body>
      <group id="elixir">
        <trans-unit id="27bd571c88e679120d69355a8855de7b06b30a1a" translate="yes" xml:space="preserve">
          <source>The collection types are compared using the following rules:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c5b2a728faaf0d704086c8a732474d34b64c7d1" translate="yes" xml:space="preserve">
          <source>The comma should be followed by a space.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="139636692335607d6eb4460b93391d027f1c3267" translate="yes" xml:space="preserve">
          <source>The command above fails because we have switched shells. Since shells are isolated from each other, you can't access the variables defined in one shell from the other one.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="000af91ba82011c87383cf8f5a08713fe7fef900" translate="yes" xml:space="preserve">
          <source>The command above returns &lt;code&gt;:error&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93e8c4e8d6a9562251088181806121ea8983b620" translate="yes" xml:space="preserve">
          <source>The command above returns &lt;code&gt;{:ok, bucket}&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="919db13977d98a781eec05aba6aea3150c8048e9" translate="yes" xml:space="preserve">
          <source>The command above will start a new shell and connect to it. Create a new variable called &lt;code&gt;hello&lt;/code&gt; and assign some value to it:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ecae1fb9875a4247d5f5ea9609a8cfd1c1df1d2" translate="yes" xml:space="preserve">
          <source>The community has also created its own tools, often to aid in production, other times in development:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f587be913201bd350f5a6a58f7e5d2545a34fce" translate="yes" xml:space="preserve">
          <source>The comparison between elements must be done using &lt;a href=&quot;kernel#===/2&quot;&gt;&lt;code&gt;===/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b72ead9d1380c933dae651b694aba918748f04d3" translate="yes" xml:space="preserve">
          <source>The compilation will fail because &lt;code&gt;My.Module&lt;/code&gt; when quoted is not an atom, but a syntax tree as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd0d32bee722121f8e488a947a395b8badae67cf" translate="yes" xml:space="preserve">
          <source>The compiled pattern is useful when the same match will be done over and over again. Note though that the compiled pattern cannot be stored in a module attribute as the pattern is generated at runtime and does not survive compile time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c261a06d80c478e0111d6983a7ae911378fd70b" translate="yes" xml:space="preserve">
          <source>The compiler is telling us that invoking the &lt;code&gt;join&lt;/code&gt; function with two arguments will always choose the first definition of &lt;code&gt;join&lt;/code&gt; whereas the second one will only be invoked when three arguments are passed:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a5b9456e8b2526749824cf107036fdea5219003" translate="yes" xml:space="preserve">
          <source>The compiler translates this into multiple functions with different arities, here &lt;code&gt;MyMath.multiply_by/1&lt;/code&gt; and &lt;code&gt;MyMath.multiply_by/2&lt;/code&gt;, that represent cases when arguments for parameters with default values are passed or not passed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25ad36289d9fc32f9ce285a83c0db949e85318f5" translate="yes" xml:space="preserve">
          <source>The compiler utilizes temporary modules to compile code. For example, &lt;code&gt;elixir_compiler_1&lt;/code&gt;, &lt;code&gt;elixir_compiler_2&lt;/code&gt;, etc. In case the compiled code stores references to anonymous functions or similar, the Elixir compiler may be unable to reclaim those modules, keeping an unnecessary amount of code in memory and eventually leading to modules such as &lt;code&gt;elixir_compiler_12345&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e326f0b1277ff195521c682d15083f035944526" translate="yes" xml:space="preserve">
          <source>The compiler will infer this argument as &lt;code&gt;map&lt;/code&gt;. Sometimes the inference will be suboptimal, especially if the function contains multiple clauses with the argument matching on different values each time. You can specify the proper names for documentation by declaring only the function head at any moment before the implementation:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68165d5af4e0c7518ce750565d2875d5f1b99f6f" translate="yes" xml:space="preserve">
          <source>The complexity of &lt;code&gt;a ++ b&lt;/code&gt; is proportional to &lt;code&gt;length(a)&lt;/code&gt;, so avoid repeatedly appending to lists of arbitrary length, e.g. &lt;code&gt;list ++ [element]&lt;/code&gt;. Instead, consider prepending via &lt;code&gt;[element | rest]&lt;/code&gt; and then reversing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce5190846b0b9ce88bde5e1fb9838155c0302562" translate="yes" xml:space="preserve">
          <source>The complexity of &lt;code&gt;a -- b&lt;/code&gt; is proportional to &lt;code&gt;length(a) * length(b)&lt;/code&gt;, meaning that it will be very slow if both &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; are long lists. In such cases, consider converting each list to a &lt;a href=&quot;mapset&quot;&gt;&lt;code&gt;MapSet&lt;/code&gt;&lt;/a&gt; and using &lt;a href=&quot;mapset#difference/2&quot;&gt;&lt;code&gt;MapSet.difference/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84ce76ba55c26126100351cef4100465580a3f63" translate="yes" xml:space="preserve">
          <source>The compressed option must be combined with either read or write, but not both. Note that the file size obtained with &lt;a href=&quot;#stat/1&quot;&gt;&lt;code&gt;stat/1&lt;/code&gt;&lt;/a&gt; will most probably not match the number of bytes that can be read from a compressed file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d2bc42beb1d07a11bffabca4e75ecee65b8f3cc" translate="yes" xml:space="preserve">
          <source>The concurrency can be increased or decreased using the &lt;code&gt;:max_concurrency&lt;/code&gt; option. For example, if the tasks are IO heavy, the value can be increased:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2dcb06049bb00d9d82db3a23393505f88e85183b" translate="yes" xml:space="preserve">
          <source>The configurations are merged together with the values in the second one having higher preference than the first in case of conflicts. In case both values are set to keyword lists, it deep merges them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8bfd0598c3186c98ed3b75f81d353f661a54c9d0" translate="yes" xml:space="preserve">
          <source>The console backend allows you to customize the format of your log messages with the &lt;code&gt;:format&lt;/code&gt; option.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7235027880d78a2aea2ca7dc4debaca1a57f60b0" translate="yes" xml:space="preserve">
          <source>The console backend logs messages by printing them to the console. It supports the following options:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8de6b43b33ab75286e101ec804e217bdf4636eeb" translate="yes" xml:space="preserve">
          <source>The context is used to pass information from the callbacks to the test. In order to pass information from the test to the callback, ExUnit provides tags.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df9b547258c058ce1d60f5a04eb16b39a7714b90" translate="yes" xml:space="preserve">
          <source>The continuation is the closure returned as a result when the enumeration is suspended. When invoked, it expects a new accumulator and it returns the result.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95e2451a8bd06ec3ff7404ffc596006e9814e181" translate="yes" xml:space="preserve">
          <source>The correct way to write the refutation above is to use &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#match?/2&quot;&gt;&lt;code&gt;Kernel.match?/2&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="471e051b1dfc7605a0864374979ff909fdd918ff" translate="yes" xml:space="preserve">
          <source>The corresponding child process must not be running; use &lt;a href=&quot;#terminate_child/2&quot;&gt;&lt;code&gt;terminate_child/2&lt;/code&gt;&lt;/a&gt; to terminate it if it's running.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25f2832dc850f5e3ce868623e448ed6173ae8a76" translate="yes" xml:space="preserve">
          <source>The crypto module</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ecd090fb1dcdddfdde8d184412bdb4ef34572bf" translate="yes" xml:space="preserve">
          <source>The current environment can be accessed at any time as &lt;a href=&quot;kernel.specialforms#__ENV__/0&quot;&gt;&lt;code&gt;__ENV__/0&lt;/code&gt;&lt;/a&gt;. Inside macros, the caller environment can be accessed as &lt;a href=&quot;kernel.specialforms#__CALLER__/0&quot;&gt;&lt;code&gt;__CALLER__/0&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2d538224a6564739f222b37335408e88b676276" translate="yes" xml:space="preserve">
          <source>The date and time fields in the struct can be accessed directly:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="104ca7733bdc0fce19ec1a42bd6f6c3a9728b295" translate="yes" xml:space="preserve">
          <source>The days are counted as Gregorian days. The date is returned in the same calendar as it was given in.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81de1658f9b930a338fa7d15b3cd46a31f6ce081" translate="yes" xml:space="preserve">
          <source>The default engine used by EEx.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1841b4dcd409156ad003b434d7d06485770c7448" translate="yes" xml:space="preserve">
          <source>The default node is &lt;a href=&quot;node#self/0&quot;&gt;&lt;code&gt;Node.self/0&lt;/code&gt;&lt;/a&gt;, the local node. If &lt;code&gt;node&lt;/code&gt; is the local node, the function also sets the cookie of all other unknown nodes to &lt;code&gt;cookie&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee7448078e00a12f44bc6d6a512061a6e8e76068" translate="yes" xml:space="preserve">
          <source>The default output contains data gathered from all matching functions. The first row after the header contains the sums of the partial results and the average time for all the function calls listed. The following rows contain the function call, followed by the number of times that the function was called, then by the percentage of time that the call uses, then the total time for that function in microseconds, and, finally, the average time per call in microseconds.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea39ed70f4785b6c480b790dacca9bfe36cb2b1f" translate="yes" xml:space="preserve">
          <source>The default output contains data gathered from all matching functions. The left column structures each module and its total call count trace is presented on the right. Each module has its count discriminated by function below. The &lt;code&gt;&amp;lt;--&lt;/code&gt; symbol is meant to help visualize where a new module call count begins.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="819e6f3391fb45f7ce5241a6dd1d1431dc481702" translate="yes" xml:space="preserve">
          <source>The default output contains data gathered from all profiled processes. All times are wall clock milliseconds. The columns have the following meaning:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="380321e8388d234e55ec92513260d8b22df6e305" translate="yes" xml:space="preserve">
          <source>The definition above wouldn't work for this particular example, as it would attempt to start the counter with an initial value of an empty list. However, this may be a viable option in your own agents. A common approach is to use a keyword list, as that would allow setting the initial value and giving a name to the counter process, for example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14e3a7f1b4ff430ef2347af078514bfcd6aac53f" translate="yes" xml:space="preserve">
          <source>The dependencies' versions are expected to be formatted according to Semantic Versioning and the requirements must be specified as defined in the &lt;a href=&quot;https://hexdocs.pm/elixir/Version.html&quot;&gt;&lt;code&gt;Version&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0199850bb5adebc71f4018576818506ad556f1cc" translate="yes" xml:space="preserve">
          <source>The device will be created and sent to the function given. When the function returns, the device will be closed. The final result will be a tuple with &lt;code&gt;:ok&lt;/code&gt; and the result of the function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92c1c70614d3e16189eb567106d0cd377288e598" translate="yes" xml:space="preserve">
          <source>The difference between &lt;code&gt;==&lt;/code&gt; and &lt;code&gt;===&lt;/code&gt; is that the latter is more strict when comparing integers and floats:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b165d79002d46e097dd675e283b2c25db64a858" translate="yes" xml:space="preserve">
          <source>The difference between the two approaches is that a module-based supervisor gives you more direct control over how the supervisor is initialized. Instead of calling &lt;a href=&quot;supervisor#start_link/2&quot;&gt;&lt;code&gt;Supervisor.start_link/2&lt;/code&gt;&lt;/a&gt; with a list of children that are automatically initialized, we manually initialized the children by calling &lt;a href=&quot;supervisor#init/2&quot;&gt;&lt;code&gt;Supervisor.init/2&lt;/code&gt;&lt;/a&gt; inside its &lt;a href=&quot;#c:init/1&quot;&gt;&lt;code&gt;init/1&lt;/code&gt;&lt;/a&gt; callback.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b5eb7b6faff508891acf9d2eb056d03565a244c" translate="yes" xml:space="preserve">
          <source>The difference is that anonymous functions require the target node to have exactly the same code version as the caller. Using module, function, and arguments is more robust because you only need to find a function with matching arity in the given module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5358501133f2ba56bf1b306cdd649fc8fee2e62a" translate="yes" xml:space="preserve">
          <source>The difference is that the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;DynamicSupervisor&lt;/code&gt;&lt;/a&gt; expects the child specification at the moment &lt;a href=&quot;#start_child/2&quot;&gt;&lt;code&gt;start_child/2&lt;/code&gt;&lt;/a&gt; is called, and no longer on the init callback. If there are any initial arguments given on initialization, such as &lt;code&gt;[initial_arg]&lt;/code&gt;, it can be given in the &lt;code&gt;:extra_arguments&lt;/code&gt; flag on &lt;a href=&quot;dynamicsupervisor#init/1&quot;&gt;&lt;code&gt;DynamicSupervisor.init/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53c4296a8b739f59bee25619f4e6585ba6646d78" translate="yes" xml:space="preserve">
          <source>The digraph module</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3687778e68f2e38fa3eb29706a7417475b459a2" translate="yes" xml:space="preserve">
          <source>The document starts flat (without breaks) until a group is found.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ad969954076e16dcc1ff7f0c2aba06e5e46ee7f" translate="yes" xml:space="preserve">
          <source>The dot (&lt;code&gt;.&lt;/code&gt;) in Elixir can be used for remote calls:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="555f5e20b9d1a7a0564cfc99c5aa3c497147b302" translate="yes" xml:space="preserve">
          <source>The dot may be used to invoke anonymous functions too:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b457ad21100bb14e953ebf6025ecbe3add69796" translate="yes" xml:space="preserve">
          <source>The elements in both the returned lists are in the same relative order as they were in the original enumerable (if such enumerable was ordered, like a list). See the examples below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46fd29816806a299fb407c730c9ba36ba20c158f" translate="yes" xml:space="preserve">
          <source>The encoder function is supposed to create an atom from the given string. It is required to return either &lt;code&gt;{:ok, term}&lt;/code&gt;, where term is an atom. It is possible to return something else than an atom, however, in that case the AST is no longer &quot;valid&quot; in that it cannot be used to compile or evaluate Elixir code. A use case for this is if you want to use the Elixir parser in a user-facing situation, but you don't want to exhaust the atom table.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7abcd054d6c0c3b0676a107d280986f037e15ba1" translate="yes" xml:space="preserve">
          <source>The encoder function will receive the atom name (as a binary) and a keyword list with the current file, line and column. It must return &lt;code&gt;{:ok, token :: term} | {:error, reason :: binary}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d93739e1f908805f248fbd3ca05efb8a31a93ffb" translate="yes" xml:space="preserve">
          <source>The environment</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1059c7023600cf66d37436e09b5b8c7e27f7d77" translate="yes" xml:space="preserve">
          <source>The environment applies only to the current project. As we will see in future chapters, any dependency you add to your project will by default run in the &lt;code&gt;:prod&lt;/code&gt; environment.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="569fc959f1dad768558df72d1e65bcb68e016b15" translate="yes" xml:space="preserve">
          <source>The environment can be changed via the command line by setting the &lt;code&gt;MIX_ENV&lt;/code&gt; environment variable, for example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cfd48ae86d7fb6e0cc9118fb73487346d9610f87" translate="yes" xml:space="preserve">
          <source>The environment can be read via &lt;a href=&quot;mix#env/0&quot;&gt;&lt;code&gt;Mix.env/0&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79b786be3813b81bda2dd7613367e75b678039b6" translate="yes" xml:space="preserve">
          <source>The environment is available after loading the application, which is a process explained later:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97a5f35bc8e443b15b7816310584c96da8ae8afe" translate="yes" xml:space="preserve">
          <source>The error state returned by &lt;a href=&quot;exunit.test&quot;&gt;&lt;code&gt;ExUnit.Test&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;exunit.testmodule&quot;&gt;&lt;code&gt;ExUnit.TestModule&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd79581f4945ce7000f24bd77d80edb09d58223a" translate="yes" xml:space="preserve">
          <source>The example above broadcasted the message &lt;code&gt;{:broadcast, &quot;world&quot;}&lt;/code&gt; to all processes registered under the &quot;topic&quot; (or &quot;key&quot; as we called it until now) &lt;code&gt;&quot;hello&quot;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85cebbc730e74ea1586122c70e3648ace6b606a3" translate="yes" xml:space="preserve">
          <source>The example above has a pipeline of operations. We start with a range and then multiply each element in the range by 3. This first operation will now create and return a list with &lt;code&gt;100_000&lt;/code&gt; items. Then we keep all odd elements from the list, generating a new list, now with &lt;code&gt;50_000&lt;/code&gt; items, and then we sum all entries.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7a86a0bce3d2d4979cfe2b252cb1ba44bf3ffc0" translate="yes" xml:space="preserve">
          <source>The example above is the same as calling &lt;code&gt;List.flatten([1, [2], 3])&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34a98e7e58a5ad26483cead8675329ffdc04e919" translate="yes" xml:space="preserve">
          <source>The example above rescues the runtime error and returns the error itself which is then printed in the &lt;code&gt;iex&lt;/code&gt; session.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1acf2309aa592e7d6d6148eb2c43c7439baf836" translate="yes" xml:space="preserve">
          <source>The example above shows the preferred strategy for customizing exception messages.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c4ee977260f8fcae5e39eaa8c9f47beb473c79e" translate="yes" xml:space="preserve">
          <source>The example above will define two modules: &lt;code&gt;Foo&lt;/code&gt; and &lt;code&gt;Foo.Bar&lt;/code&gt;. The second can be accessed as &lt;code&gt;Bar&lt;/code&gt; inside &lt;code&gt;Foo&lt;/code&gt; as long as they are in the same lexical scope. The code above is exactly the same as:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8af5b80536d2c072fd5d6366536aa5700dca7b65" translate="yes" xml:space="preserve">
          <source>The example above will fetch the first 10 lines of the file you have selected. This means streams can be very useful for handling large files or even slow resources like network resources.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5335acb8d877ec62b7cb06ce91a567ae1709575" translate="yes" xml:space="preserve">
          <source>The example above will only work if &lt;code&gt;x&lt;/code&gt; matches the first value in the right list. Otherwise, it will raise a &lt;a href=&quot;matcherror&quot;&gt;&lt;code&gt;MatchError&lt;/code&gt;&lt;/a&gt; (like the &lt;code&gt;=&lt;/code&gt; operator would do).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b460f75ed7a246aed0999b0840cd9a86244be18" translate="yes" xml:space="preserve">
          <source>The example above will print:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb87f61c9de07aa0c29854b1fe6c1165c0f17fed" translate="yes" xml:space="preserve">
          <source>The example above will run all tests that have the external option set to &lt;code&gt;true&lt;/code&gt;. It is also possible to include all examples that have a given tag, regardless of its value:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a35cc3928c93cd1525534e5aae37a525e3a1f63a" translate="yes" xml:space="preserve">
          <source>The example below prints the available compilers and then the list of dependencies.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="977b62dac31ac2298799e3e82efadb76ace792aa" translate="yes" xml:space="preserve">
          <source>The examples below will use &lt;code&gt;break!&lt;/code&gt;, assuming that you are setting a breakpoint directly from your IEx shell. But you can set up a break from anywhere by using the fully qualified name &lt;code&gt;IEx.break!&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="598b6c321009ab41147aeda0cc432613c93bc6ff" translate="yes" xml:space="preserve">
          <source>The exception type</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef1dcbe751c0f9e41d4eb9dc12ae9aa4ff81e740" translate="yes" xml:space="preserve">
          <source>The fact this function uses Erlang's term ordering means that the comparison is structural and not semantic. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8e9535a979f24690a83f0d69ec866c95c5b87d9" translate="yes" xml:space="preserve">
          <source>The feature is effectively deprecated by emitting warnings on usage. This is also known as hard-deprecation. In order to deprecate a feature, the proposed alternative MUST exist for AT LEAST THREE minor versions. For example, &lt;code&gt;Enum.uniq/2&lt;/code&gt; was soft-deprecated in favor of &lt;a href=&quot;enum#uniq_by/2&quot;&gt;&lt;code&gt;Enum.uniq_by/2&lt;/code&gt;&lt;/a&gt; in Elixir v1.1. This means a deprecation warning may only be emitted by Elixir v1.4 or later.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77826c76ea0072ad69d2f391c353d094902019fd" translate="yes" xml:space="preserve">
          <source>The feature is removed. This can only happen on major releases. This means deprecated features in Elixir v1.x shall only be removed by Elixir v2.x.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64f27bcc28943bbd06806f078df1fb5cd0c4fa41" translate="yes" xml:space="preserve">
          <source>The feature is soft-deprecated. It means both CHANGELOG and documentation must list the feature as deprecated but no warning is effectively emitted by running the code. There is no requirement to soft-deprecate a feature.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aaf695dceb54489cced53f84555aabadc2f0e697" translate="yes" xml:space="preserve">
          <source>The file is created if it does not exist. If it exists, the previous contents are overwritten. Returns &lt;code&gt;:ok&lt;/code&gt; if successful, or &lt;code&gt;{:error, reason}&lt;/code&gt; if an error occurs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d594748254e0bf9d6de08774efbf46885ccdc846" translate="yes" xml:space="preserve">
          <source>The file is created if it doesn't exist. Requires datetime in UTC (as returned by &lt;code&gt;:erlang.universaltime()&lt;/code&gt;) or an integer representing the POSIX timestamp (as returned by &lt;code&gt;System.os_time(:second)&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16e6a8d0dd5fc8fad11975b4cd8380cee1d272d3" translate="yes" xml:space="preserve">
          <source>The file is opened, given to the function as an argument and automatically closed after the function returns, regardless if there was an error when executing the function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7da78c24b03af92a331655b22affad9970828441" translate="yes" xml:space="preserve">
          <source>The file will be compiled in memory and executed, printing &amp;ldquo;3&amp;rdquo; as the result. No bytecode file will be created. In the following examples, we recommend you write your code into script files and execute them as shown above.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="163b392b3771b3d68e4cabd76e12f649d752ed1d" translate="yes" xml:space="preserve">
          <source>The final code for the application built in this guide is in &lt;a href=&quot;https://github.com/josevalim/kv_umbrella&quot;&gt;this repository&lt;/a&gt; and can be used as a reference.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eeed0a9446d454784748ae3c92f5f970ae5e8749" translate="yes" xml:space="preserve">
          <source>The final module name will be &lt;code&gt;MyHelpers.Module&lt;/code&gt; and not &lt;code&gt;My.Module&lt;/code&gt;. With &lt;a href=&quot;macro#expand/2&quot;&gt;&lt;code&gt;Macro.expand/2&lt;/code&gt;&lt;/a&gt;, such aliases are taken into consideration. Local and remote macros are also expanded. We could rewrite our macro above to use this function as:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c94b7aa6c8d6098097b882564487315e75f42062" translate="yes" xml:space="preserve">
          <source>The first argument given to &lt;a href=&quot;#start_link/2&quot;&gt;&lt;code&gt;start_link/2&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#init/2&quot;&gt;&lt;code&gt;init/2&lt;/code&gt;&lt;/a&gt; is a list of child specifications as defined in the &quot;child_spec/1&quot; section above.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3bd0d4cfc55b69d9253066edc78349e5a5f0a43e" translate="yes" xml:space="preserve">
          <source>The first clause above will only match when &lt;code&gt;x&lt;/code&gt; is positive.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb035f0f30f88032dbb2e6101c25284087903853" translate="yes" xml:space="preserve">
          <source>The first clause has a guard which says &amp;ldquo;use this definition if and only if &lt;code&gt;n&lt;/code&gt; is less than or equal to &lt;code&gt;1&lt;/code&gt;&amp;rdquo;. Since this is not the case, Elixir proceeds to the next clause&amp;rsquo;s definition.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89e50c2ad64d1cb084a88caace5a204ed21c004f" translate="yes" xml:space="preserve">
          <source>The first column is the version the feature was hard deprecated. The second column shortly describes the deprecated feature and the third column explains the replacement and from which the version the replacement is available from.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="090b48aa7b27ba7aabd1d7a17461511059a79e62" translate="yes" xml:space="preserve">
          <source>The first element is always dropped, unless &lt;code&gt;nth&lt;/code&gt; is 0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f10968f84672fced5f1e4ec8ec8d8d3398ac17ef" translate="yes" xml:space="preserve">
          <source>The first element is always included, unless &lt;code&gt;nth&lt;/code&gt; is 0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d62944a019ad040d05e692b397bd4389633cb416" translate="yes" xml:space="preserve">
          <source>The first element is always passed to the given function, unless &lt;code&gt;nth&lt;/code&gt; is &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d3d07fd30dfdee5089f7add816955448e8a7e62" translate="yes" xml:space="preserve">
          <source>The first element is always passed to the given function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a20362c2ee76acf3525cfe072360096fe727a0f9" translate="yes" xml:space="preserve">
          <source>The first element is an atom or another tuple in the same representation;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de5cd0ed2836b580d20a53b60b89fdbc3744b2af" translate="yes" xml:space="preserve">
          <source>The first element is the function name, the second is a keyword list containing metadata and the third is the arguments list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b93358d99cbfe2c9b65df07674bef6d363d42e0" translate="yes" xml:space="preserve">
          <source>The first element of the &lt;code&gt;enumerable&lt;/code&gt; is used as the initial value of the accumulator. Then the function is invoked with the next element and the accumulator. The result returned by the function is used as the accumulator for the next iteration, recursively. When the &lt;code&gt;enumerable&lt;/code&gt; is done, the last accumulator is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff5ed72f8d68d33e831fb03d181cb08f9312e39a" translate="yes" xml:space="preserve">
          <source>The first element of the tuple is always an atom or another tuple in the same representation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="753965fc9c8c958c1adc18030905ea9a9fce1c71" translate="yes" xml:space="preserve">
          <source>The first function blocks the agent. The second function copies all the state to the client and then executes the operation in the client. One aspect to consider is whether the data is large enough to require processing in the server, at least initially, or small enough to be sent to the client cheaply. Another factor is whether the data needs to be processed atomically: getting the state and calling &lt;code&gt;do_something_expensive(state)&lt;/code&gt; outside of the agent means that the agent's state can be updated in the meantime. This is specially important in case of updates as computing the new state in the client rather than in the server can lead to race conditions if multiple clients are trying to update the same state to different values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a8bdc0ad5ea0cf6a739758090fdb5a2d0573fc4" translate="yes" xml:space="preserve">
          <source>The first function is &lt;code&gt;start_link/1&lt;/code&gt;, which starts a new GenServer passing a list of options. &lt;code&gt;start_link/1&lt;/code&gt; calls out to &lt;code&gt;GenServer.start_link/3&lt;/code&gt;, which takes three arguments:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6da90265feaa08cdbd5c291c792941296efaf6fb" translate="yes" xml:space="preserve">
          <source>The first is the &lt;code&gt;init/1&lt;/code&gt; callback, that receives the second argument given to &lt;code&gt;GenServer.start_link/3&lt;/code&gt; and returns &lt;code&gt;{:ok, state}&lt;/code&gt;, where state is a new map. We can already notice how the &lt;code&gt;GenServer&lt;/code&gt; API makes the client/server segregation more apparent. &lt;code&gt;start_link/3&lt;/code&gt; happens in the client, while &lt;code&gt;init/1&lt;/code&gt; is the respective callback that runs on the server.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56525212a2d836e7b2e6c9fc3d438debd74b1ce4" translate="yes" xml:space="preserve">
          <source>The first occurrence of each element is kept.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6fdbbd4ad4f56c5f2d4b83c9b51836d3c3baff1c" translate="yes" xml:space="preserve">
          <source>The first one is related to operator precedence. For example, the following expression:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb6432ba2d593bb02b187beac0081aecf4153a10" translate="yes" xml:space="preserve">
          <source>The first one is that the code is truly evaluated and not compiled. This means that any benchmarking done in the shell is going to have skewed results. So never run any profiling nor benchmarks in the shell.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9aa7af0b736df8170b447c11a0b1486409c8447e" translate="yes" xml:space="preserve">
          <source>The first one is with &lt;a href=&quot;https://hexdocs.pm/iex/IEx.html#pry/0&quot;&gt;&lt;code&gt;IEx.pry/0&lt;/code&gt;&lt;/a&gt; which we can use instead of &lt;code&gt;IO.inspect binding()&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cece2699937857700a6e57ae7a8e2fdab1620e09" translate="yes" xml:space="preserve">
          <source>The first part, the match pattern, must be a tuple that will match the structure of the the data stored in the registry, which is &lt;code&gt;{key, pid, value}&lt;/code&gt;. The atom &lt;code&gt;:_&lt;/code&gt; can be used to ignore a given value or tuple element, while the atom &lt;code&gt;:&quot;$1&quot;&lt;/code&gt; can be used to temporarily assign part of pattern to a variable for a subsequent comparison. This can be combined like &lt;code&gt;{:&quot;$1&quot;, :_, :_}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33bf9cc2d09af8093ef73164f4425101ddcff356" translate="yes" xml:space="preserve">
          <source>The first row (Total) is the sum of all function calls. In the last row the number of matching functions that were considered for profiling is presented.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c85192b0b88529b2ffa5c7dc5ed794fb80bfa927" translate="yes" xml:space="preserve">
          <source>The first row (Total) is the sum of all functions executed in all profiled processes. For the given output, we had a total of 200279 function calls and spent about 2 seconds running the code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7cd60f6007c291382d0b163734079218de4d7d65" translate="yes" xml:space="preserve">
          <source>The first step in our implementation is to call &lt;code&gt;use Agent&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="868cc4dcae35b14912938b182f9884b2f9e36c22" translate="yes" xml:space="preserve">
          <source>The first step is to tell our application definition (i.e. our &lt;code&gt;.app&lt;/code&gt; file) which module is going to implement the application callback. Let&amp;rsquo;s do so by opening &lt;code&gt;mix.exs&lt;/code&gt; and changing &lt;code&gt;def application&lt;/code&gt; to the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08b35c8002543aef4eef62b9715905dd1c3e096e" translate="yes" xml:space="preserve">
          <source>The first test invokes &lt;code&gt;Kernel.node/0&lt;/code&gt;, which returns the name of the current node, based on the bucket names &amp;ldquo;hello&amp;rdquo; and &amp;ldquo;world&amp;rdquo;. According to our routing table so far, we should get &lt;code&gt;foo@computer-name&lt;/code&gt; and &lt;code&gt;bar@computer-name&lt;/code&gt; as responses, respectively.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aac5f450f7a22287bfbd1ca580bfb413b84283d5" translate="yes" xml:space="preserve">
          <source>The first time this task is run with &lt;code&gt;--stale&lt;/code&gt;, all tests are run and a manifest is generated. On subsequent runs, a test file is marked &quot;stale&quot; if any modules it references (and any modules those modules reference, recursively) were modified since the last run with &lt;code&gt;--stale&lt;/code&gt;. A test file is also marked &quot;stale&quot; if it has been changed since the last run with &lt;code&gt;--stale&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="295fb12141f4c89eb596a5dac17f4949547acbec" translate="yes" xml:space="preserve">
          <source>The following attributes are part of typespecs and are also built-in in Elixir:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ddb17433dfdb141914290560e8f56274113cff7" translate="yes" xml:space="preserve">
          <source>The following behaviour applies if &lt;code&gt;reason&lt;/code&gt; is any term except &lt;code&gt;:normal&lt;/code&gt; or &lt;code&gt;:kill&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7cc6a385de289ddbe867800f5a4d45eaf506d87a" translate="yes" xml:space="preserve">
          <source>The following code is clearer:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab6fa07c7c4a4b08ed5ab5840982521232d9dc60" translate="yes" xml:space="preserve">
          <source>The following configuration applies to &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Logger&lt;/code&gt;&lt;/a&gt;'s wrapper around Erlang's logging functionalities. All the configurations below must be set before the &lt;code&gt;:logger&lt;/code&gt; application starts.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b59ddac9c85343e9c0315f555148e29de15b834" translate="yes" xml:space="preserve">
          <source>The following configuration must be set via config files (such as &lt;code&gt;config/config.exs&lt;/code&gt;) before the &lt;code&gt;:logger&lt;/code&gt; application is started.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7468ef5075d9f1bb00ad4478b84201c0051a39d2" translate="yes" xml:space="preserve">
          <source>The following configurations apply only for Erlang/OTP 20 and earlier:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5bee2fb68242ae2a980fb37c51c72ff07363e60a" translate="yes" xml:space="preserve">
          <source>The following contents are expanded:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="184db633c0e9a1d1d50d51efc796a68bbb36b312" translate="yes" xml:space="preserve">
          <source>The following document has 10 bytes and therefore it does not format to width 9 without breaks:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de1fd9b941b49b602c0ebc3107ff23bc87d50045" translate="yes" xml:space="preserve">
          <source>The following escape codes can be used in strings and char lists:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d46d9ba3da9322ecdf037e20b892895d0db04656" translate="yes" xml:space="preserve">
          <source>The following fields are available:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7293829d505cc3a0054aa1a59ac73bad4f509dae" translate="yes" xml:space="preserve">
          <source>The following fields are deprecated and must not be accessed or relied on:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30c2e9695ce3105ad651330d3b52e46b3a324658" translate="yes" xml:space="preserve">
          <source>The following fields are public:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ecaaab8e8eae9b4df4d22551bafa8feaa1ec9420" translate="yes" xml:space="preserve">
          <source>The following fields pertain to variable handling and must not be accessed or relied on. To get a list of all variables, see &lt;a href=&quot;#vars/1&quot;&gt;&lt;code&gt;vars/1&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8fcb5815c5a0952c38de454edd61e7d1f142d6d" translate="yes" xml:space="preserve">
          <source>The following is a list of all operators that Elixir is capable of parsing, ordered from higher to lower precedence, alongside their associativity:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9104e819567333a6da0e8ce2dab5b947458c30fd" translate="yes" xml:space="preserve">
          <source>The following is a table of all the operators that Elixir is capable of parsing, but that are not used by default:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ba751c3adfd8a7fc2856a1dbf3e62fbc4ec76f2" translate="yes" xml:space="preserve">
          <source>The following keys are optional:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b884b576e7fc0feccc202abb8a4a3d2fbce2d97" translate="yes" xml:space="preserve">
          <source>The following keys are returned:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf2cdc4ebfa3f4a0590ef2625ba82e196ae8c2a8" translate="yes" xml:space="preserve">
          <source>The following literals are also supported in typespecs:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b914b4fb7bd70067053e9e95983328f16ab1fd00" translate="yes" xml:space="preserve">
          <source>The following macros are generated:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3a2d7253e70d0b7ab68844ea930f5d415637299" translate="yes" xml:space="preserve">
          <source>The following modules build on top of processes to provide concurrency, fault-tolerance, and more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4f887b33e0c44ae6b51e81b5ab7bc56ab3d3fc4" translate="yes" xml:space="preserve">
          <source>The following modules handle Elixir built-in data types:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16b7215fb9d992fc605683d883c23ca3932275a5" translate="yes" xml:space="preserve">
          <source>The following names are reserved and cannot be assigned to processes nor ports:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b3878c8ab3dccd7e89f167b65de39bd2f92844f" translate="yes" xml:space="preserve">
          <source>The following operators are used by the &lt;a href=&quot;bitwise&quot;&gt;&lt;code&gt;Bitwise&lt;/code&gt;&lt;/a&gt; module when imported: &lt;a href=&quot;bitwise#&amp;amp;&amp;amp;&amp;amp;/2&quot;&gt;&lt;code&gt;&amp;amp;&amp;amp;&amp;amp;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;bitwise#%255E%255E%255E/2&quot;&gt;&lt;code&gt;^^^&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;bitwise#%253C%253C%253C/2&quot;&gt;&lt;code&gt;&amp;lt;&amp;lt;&amp;lt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;bitwise#%253E%253E%253E/2&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;bitwise#%257C%257C%257C/2&quot;&gt;&lt;code&gt;|||&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;bitwise#~~~/1&quot;&gt;&lt;code&gt;~~~&lt;/code&gt;&lt;/a&gt;. See the documentation for &lt;a href=&quot;bitwise&quot;&gt;&lt;code&gt;Bitwise&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77f3895c41618839ee5e26a20028be3be4ec2b1d" translate="yes" xml:space="preserve">
          <source>The following option must be specified in your &lt;code&gt;mix.exs&lt;/code&gt; under &lt;code&gt;:escript&lt;/code&gt; key:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4d77afab2cb5c0e79177397fed4c21c74e5e9f3" translate="yes" xml:space="preserve">
          <source>The following options are accepted:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ab6a9f1a0bbaef19cacfbc5c31136467bf2e22d" translate="yes" xml:space="preserve">
          <source>The following options are supported:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a63388a7d9c69cb081c0bd25c0b348227ea8b98e" translate="yes" xml:space="preserve">
          <source>The following restart values are supported in the &lt;code&gt;:restart&lt;/code&gt; option:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3bfac8b769dcde18c31230db7c8155e1610b73f" translate="yes" xml:space="preserve">
          <source>The following sets up a breakpoint on &lt;a href=&quot;https://hexdocs.pm/elixir/URI.html#decode_query/2&quot;&gt;&lt;code&gt;URI.decode_query/2&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af7f88d381759e98fbd8a59a2974fdc1427bfa5a" translate="yes" xml:space="preserve">
          <source>The following shutdown values are supported in the &lt;code&gt;:shutdown&lt;/code&gt; option:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62c95490240e6721731c2a4166fbf474d701eaa5" translate="yes" xml:space="preserve">
          <source>The following switches take one argument:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09182b59468032ac91eb3e19cfac73cd63919777" translate="yes" xml:space="preserve">
          <source>The following switches types take no arguments:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="656560aa5a4b69ea097162499366d646d82b57a2" translate="yes" xml:space="preserve">
          <source>The following tags are set automatically by ExUnit and are therefore reserved:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5fc9716a622a264a8eff71eefa013048286d3378" translate="yes" xml:space="preserve">
          <source>The following tags customize how tests behave:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3f1a1a3a62e3160fd586f6ee95d4fab3af95423" translate="yes" xml:space="preserve">
          <source>The following tasks are automatically reenabled: &lt;a href=&quot;mix.tasks.cmd&quot;&gt;&lt;code&gt;mix cmd&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;mix.tasks.do&quot;&gt;&lt;code&gt;mix do&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;mix.tasks.loadconfig&quot;&gt;&lt;code&gt;mix loadconfig&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;mix.tasks.profile.cprof&quot;&gt;&lt;code&gt;mix profile.cprof&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;mix.tasks.profile.eprof&quot;&gt;&lt;code&gt;mix profile.eprof&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;mix.tasks.profile.fprof&quot;&gt;&lt;code&gt;mix profile.fprof&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;mix.tasks.run&quot;&gt;&lt;code&gt;mix run&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;mix.tasks.xref&quot;&gt;&lt;code&gt;mix xref&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94b02fa4807601cf95b13d7bfacf63de52daec08" translate="yes" xml:space="preserve">
          <source>The following types are also provided by Elixir as shortcuts on top of the basic and literal types described above.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23128f3afb79fe9776e7ccf884ae9b5f280de2c5" translate="yes" xml:space="preserve">
          <source>The following values in the prompt string will be replaced appropriately:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd9e27e386ddec7a2956d45d1104ee9dcf8cf427" translate="yes" xml:space="preserve">
          <source>The following will answer with &lt;code&gt;&quot;Meg&quot;&lt;/code&gt; to the prompt &lt;code&gt;&quot;What's your name?&quot;&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc2e84198cf648d67efe0dc56f0a0d3f7a6c41f5" translate="yes" xml:space="preserve">
          <source>The formatter also extracts all trailing comments to their previous line. For example, the code below</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2dbb773aae103d1ac648bef9a245406adea93a6" translate="yes" xml:space="preserve">
          <source>The formatter also handles code comments in a way to guarantee a space is always added between the beginning of the comment (#) and the next character.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="174a1bba642104242141e782016509d0a3307dd9" translate="yes" xml:space="preserve">
          <source>The formatter attempts to fit the most it can on a single line and introduces line breaks wherever possible when it cannot.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db2d1c69ac2af0675a9fbaa3dbf3bb62be0f48e5" translate="yes" xml:space="preserve">
          <source>The formatter does not hard code names. The formatter will not behave specially because a function is named &lt;code&gt;defmodule&lt;/code&gt;, &lt;code&gt;def&lt;/code&gt;, etc. This principle mirrors Elixir's goal of being an extensible language where developers can extend the language with new constructs as if they were part of the language. When it is absolutely necessary to change behaviour based on the name, this behaviour should be configurable, such as the &lt;code&gt;:locals_without_parens&lt;/code&gt; option.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03003fdc11feaf71c728ace4a4e8175ee7b4844f" translate="yes" xml:space="preserve">
          <source>The formatter receives a string representing Elixir code and returns iodata representing the formatted code according to pre-defined rules.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72e5baea79c2662552fd592f7668202474a199d4" translate="yes" xml:space="preserve">
          <source>The formatter respects the input format in some cases. Those are listed below:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73147abbfb07a1782272353b129dfe6ae2759140" translate="yes" xml:space="preserve">
          <source>The formatter was designed under three principles.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54861fc5081e64334a71df9d50b523e9ef441995" translate="yes" xml:space="preserve">
          <source>The formatter wraps the algebra document representing the map in &lt;a href=&quot;#next_break_fits/1&quot;&gt;&lt;code&gt;next_break_fits/1&lt;/code&gt;&lt;/a&gt; so the code is formatted as:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="619bfcd8852612a615d36e293bdf93e9442a2fd9" translate="yes" xml:space="preserve">
          <source>The foundation of Mix is a project. A project can be defined by using &lt;a href=&quot;mix.project&quot;&gt;&lt;code&gt;Mix.Project&lt;/code&gt;&lt;/a&gt; in a module, usually placed in a file named &lt;code&gt;mix.exs&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27f8279b8cd5628c38c64722e539ac026a11da8b" translate="yes" xml:space="preserve">
          <source>The function &lt;a href=&quot;#put_env/3&quot;&gt;&lt;code&gt;put_env/3&lt;/code&gt;&lt;/a&gt; allows dynamic configuration of the application environment, but as a rule of thumb each application is responsible for its own environment. Please do not use the functions in this module for directly accessing or modifying the environment of other applications.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44dd7e8c0883ba7364643058445d069f16c2e43c" translate="yes" xml:space="preserve">
          <source>The function &lt;a href=&quot;#struct!/2&quot;&gt;&lt;code&gt;struct!/2&lt;/code&gt;&lt;/a&gt; emulates the compile time behaviour of structs. This means that:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e0639c36ddd40dd4d3c1545de8b7ff6af66a1a8" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;fun&lt;/code&gt; is sent to the &lt;code&gt;agent&lt;/code&gt; which invokes the function passing the agent state. The function must return a tuple with two elements, the first being the value to return (that is, the &quot;get&quot; value) and the second one being the new state of the agent.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="216982854731717320607d5aa3e2c69ffa39cfa0" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;fun&lt;/code&gt; is sent to the &lt;code&gt;agent&lt;/code&gt; which invokes the function passing the agent state. The result of the function invocation is returned from this function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc7b0ec15b4d375100169c807030b178d76cb224" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;fun&lt;/code&gt; is sent to the &lt;code&gt;agent&lt;/code&gt; which invokes the function passing the agent state. The return value of &lt;code&gt;fun&lt;/code&gt; becomes the new state of the agent.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cad7f93891da662dbbaf24dfbad6e47a904e9038" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;fun&lt;/code&gt; maps every element to a term which is used to determine if two elements are duplicates.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2063958f17451467d712f93ea552d845434a5f7b" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;fun&lt;/code&gt; maps every element to a term. Two elements are considered duplicates if the return value of &lt;code&gt;fun&lt;/code&gt; is equal for both of them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="786bdba792da55f0fb2aae425ae917dfa7672afd" translate="yes" xml:space="preserve">
          <source>The function must receive the exit status code as an argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a56026b8a6cb0f0aeff01c85c9ee7342a99db076" translate="yes" xml:space="preserve">
          <source>The function must return:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78c45238f9f6bc55b2be81844c73ef2dab477691" translate="yes" xml:space="preserve">
          <source>The function receives the arguments and passes them to &lt;code&gt;if&lt;/code&gt;. However, as we learned in the &lt;a href=&quot;quote-and-unquote&quot;&gt;previous chapter&lt;/a&gt;, the macro will receive quoted expressions, inject them into the quote, and finally return another quoted expression.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="970e1abe8c2a97edfeb1747215a9aaebefbaf05f" translate="yes" xml:space="preserve">
          <source>The function returns &lt;code&gt;:ok&lt;/code&gt; in case of success. Otherwise, it returns &lt;code&gt;{:error, reason}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42211e9c17fc840b6d18e986bbdd31d79b28999c" translate="yes" xml:space="preserve">
          <source>The function returns &lt;code&gt;{:ok, files_and_directories}&lt;/code&gt; in case of success, &lt;code&gt;files_and_directories&lt;/code&gt; lists all files and directories copied in no specific order. It returns &lt;code&gt;{:error, reason, file}&lt;/code&gt; otherwise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b12965a38c8943a04c360761ab1a75653a316455" translate="yes" xml:space="preserve">
          <source>The function should return a non empty list where the amount of elements is equal to &lt;code&gt;length&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="370959ce1313e0ee1574bb7b4f639ad8e764cdd3" translate="yes" xml:space="preserve">
          <source>The function, &lt;code&gt;fun&lt;/code&gt;, receives two arguments: the first one is the element, and the second one is the accumulator. &lt;code&gt;fun&lt;/code&gt; must return a tuple with two elements in the form of &lt;code&gt;{result, accumulator}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5956f11dd1602a7d0b839eecd3ea612fa5aace7" translate="yes" xml:space="preserve">
          <source>The functions &lt;a href=&quot;#nest/2&quot;&gt;&lt;code&gt;nest/2&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#space/2&quot;&gt;&lt;code&gt;space/2&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#line/2&quot;&gt;&lt;code&gt;line/2&lt;/code&gt;&lt;/a&gt; help you put the document together into a rigid structure. However, the document algebra gets interesting when using functions like &lt;a href=&quot;#glue/3&quot;&gt;&lt;code&gt;glue/3&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#group/1&quot;&gt;&lt;code&gt;group/1&lt;/code&gt;&lt;/a&gt;. A glue inserts a break between two documents. A group indicates a document that must fit the current line, otherwise breaks are rendered as new lines. Let's glue two docs together with a break, group it and then render it:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c253790d407e18b7d5f0c9bb8af92800693543dd" translate="yes" xml:space="preserve">
          <source>The functions in &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Keyword&lt;/code&gt;&lt;/a&gt; do not guarantee any property when it comes to ordering. However, since a keyword list is simply a list, all the operations defined in &lt;a href=&quot;enum&quot;&gt;&lt;code&gt;Enum&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;list&quot;&gt;&lt;code&gt;List&lt;/code&gt;&lt;/a&gt; can be applied too, especially when ordering is required.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc395b4f1565e86a3f414d5f43f358ea3ab4b968" translate="yes" xml:space="preserve">
          <source>The functions in &lt;code&gt;IO&lt;/code&gt; and &lt;code&gt;File&lt;/code&gt; also allow lists to be given as arguments. Not only that, they also allow a mixed list of lists, integers, and binaries to be given:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c24702aeda4cc39358f5c9073ad6385b684128ba" translate="yes" xml:space="preserve">
          <source>The functions in the &lt;code&gt;ets&lt;/code&gt; module will modify the state of the table as a side-effect.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="645c924b3f04d5643fc9c0295858b7ef02f4fe7d" translate="yes" xml:space="preserve">
          <source>The functions in the Enum module are limited to, as the name says, enumerating values in data structures. For specific operations, like inserting and updating particular elements, you may need to reach for modules specific to the data type. For example, if you want to insert an element at a given position in a list, you should use the &lt;code&gt;List.insert_at/3&lt;/code&gt; function from &lt;a href=&quot;https://hexdocs.pm/elixir/List.html&quot;&gt;the &lt;code&gt;List&lt;/code&gt; module&lt;/a&gt;, as it would make little sense to insert a value into, for example, a range.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77cce334a46132ba295a248960c6d018c960a8aa" translate="yes" xml:space="preserve">
          <source>The functions in this module act according to the Unicode Standard, version 11.0.0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="173416c87fd5ec34f77cd8d34322b0332ac7cfcb" translate="yes" xml:space="preserve">
          <source>The functions in this module are deprecated and they do not work with the module-based child specs introduced in Elixir v1.5. Please see the &lt;a href=&quot;supervisor&quot;&gt;&lt;code&gt;Supervisor&lt;/code&gt;&lt;/a&gt; documentation instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96e74349f320a8c58dc1c59108496ee930024bf1" translate="yes" xml:space="preserve">
          <source>The functions in this module may receive a chardata as argument (i.e. a string or a list of characters / string) and will always return a string (encoded in UTF-8).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b429b5ce2f9a2392aff46c5515cf68d49d6d6adf" translate="yes" xml:space="preserve">
          <source>The functions in this module support chardata, so giving a list will treat it as a single entity:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="255d1a73d20d6ce6127802c33ec8ce540df5e39c" translate="yes" xml:space="preserve">
          <source>The functions in this module that add and remove elements from tuples are rarely used in practice, as they typically imply tuples are being used as collections. To append to a tuple, it is preferable to extract the elements from the old tuple with pattern matching, and then create a new tuple:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33b30755a342f20f218b83071cf71f52c8757557" translate="yes" xml:space="preserve">
          <source>The functions in this module that need to find a specific key work in logarithmic time. This means that the time it takes to find keys grows as the map grows, but it's not directly proportional to the map size. In comparison to finding an element in a list, it performs better because lists have a linear time complexity. Some functions, such as &lt;a href=&quot;#keys/1&quot;&gt;&lt;code&gt;keys/1&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#values/1&quot;&gt;&lt;code&gt;values/1&lt;/code&gt;&lt;/a&gt;, run in linear time because they need to get to every element in the map.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f0853ffd0b6dd95f29653e4a1c1ad06e52385c2" translate="yes" xml:space="preserve">
          <source>The functions in this module work in linear time. This means that, the time it takes to perform an operation grows at the same rate as the length of the enumerable. This is expected on operations such as &lt;a href=&quot;enum#map/2&quot;&gt;&lt;code&gt;Enum.map/2&lt;/code&gt;&lt;/a&gt;. After all, if we want to traverse every element on a list, the longer the list, the more elements we need to traverse, and the longer it will take.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="709dd48512a8ffdaa9639efcdf5626b90390736d" translate="yes" xml:space="preserve">
          <source>The functions on this module work with the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; struct as well as any struct that contains the same fields as the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; struct, such as &lt;a href=&quot;naivedatetime&quot;&gt;&lt;code&gt;NaiveDateTime&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;datetime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt;. Such functions expect &lt;a href=&quot;calendar#t:date/0&quot;&gt;&lt;code&gt;Calendar.date/0&lt;/code&gt;&lt;/a&gt; in their typespecs (instead of &lt;a href=&quot;#t:t/0&quot;&gt;&lt;code&gt;t/0&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd7fe8f3288c5b63dba38948e86e695e4e2b2557" translate="yes" xml:space="preserve">
          <source>The functions on this module work with the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Time&lt;/code&gt;&lt;/a&gt; struct as well as any struct that contains the same fields as the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Time&lt;/code&gt;&lt;/a&gt; struct, such as &lt;a href=&quot;naivedatetime&quot;&gt;&lt;code&gt;NaiveDateTime&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;datetime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt;. Such functions expect &lt;a href=&quot;calendar#t:time/0&quot;&gt;&lt;code&gt;Calendar.time/0&lt;/code&gt;&lt;/a&gt; in their typespecs (instead of &lt;a href=&quot;#t:t/0&quot;&gt;&lt;code&gt;t/0&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="003b5d0dd560d869b45725f5251941da4e2978b9" translate="yes" xml:space="preserve">
          <source>The general Elixir identifier rule is specified as:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="279b2d1d6d51ad298e11acb6402db1bbf4467c85" translate="yes" xml:space="preserve">
          <source>The generated files are similar to the ones we first generated for &lt;code&gt;kv&lt;/code&gt;, with a few differences. Let&amp;rsquo;s open up &lt;code&gt;mix.exs&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe11b786cb48918f9b05dccc30b89f3c9d182f54" translate="yes" xml:space="preserve">
          <source>The generated macros can also be used in order to pattern match on records and to bind variables during the match:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50f5c0fcf4c39bd1e0e3ce49d94a449eccf8a5ee" translate="yes" xml:space="preserve">
          <source>The given &lt;code&gt;datetime_string&lt;/code&gt; must include &quot;Z&quot; or &quot;00:00&quot; offset which marks it as UTC, otherwise an error is raised.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5945d8ce9d0ed7b935712680470e46feacdd1644" translate="yes" xml:space="preserve">
          <source>The given &lt;code&gt;fun&lt;/code&gt; is called for every node in the AST with two arguments: the AST of the node being printed and the string representation of that same node. The return value of this function is used as the final string representation for that AST node.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a83da51956cb3348840e43e856af798fc100e9ea" translate="yes" xml:space="preserve">
          <source>The given &lt;code&gt;opts&lt;/code&gt; are merged into the existing configuration for the given &lt;code&gt;root_key&lt;/code&gt;. Conflicting keys are overridden by the ones specified in &lt;code&gt;opts&lt;/code&gt;. For example, the application configuration below</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b05f234517d759a8cb3f7b2d59dc801482a98965" translate="yes" xml:space="preserve">
          <source>The given &lt;code&gt;opts&lt;/code&gt; are merged into the existing values for &lt;code&gt;key&lt;/code&gt; in the given &lt;code&gt;root_key&lt;/code&gt;. Conflicting keys are overridden by the ones specified in &lt;code&gt;opts&lt;/code&gt;. For example, the application configuration below</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02ef5a607d49adbb7866b57f819df6b77fdbb345" translate="yes" xml:space="preserve">
          <source>The given config should not:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44e635edac5e4e08e828b82a2eaab3164491a4b7" translate="yes" xml:space="preserve">
          <source>The given datetime is returned unchanged if it already has lower precision than the given precision.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d2a43a0c7f321f6321fd1b9eb5b43b059a8e70b" translate="yes" xml:space="preserve">
          <source>The given naive datetime is returned unchanged if it already has lower precision than the given precision.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8ff7c40025099fed2b47a6ca6bd7d1bee58abb9" translate="yes" xml:space="preserve">
          <source>The given options can either be a binary with the characters representing the same regex options given to the &lt;code&gt;~r&lt;/code&gt; (see &lt;a href=&quot;kernel#sigil_r/2&quot;&gt;&lt;code&gt;Kernel.sigil_r/2&lt;/code&gt;&lt;/a&gt;) sigil, or a list of options, as expected by the Erlang's &lt;code&gt;:re&lt;/code&gt; module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ee391432291b1d23474c64748cd369ce3de6c17" translate="yes" xml:space="preserve">
          <source>The given time is returned unchanged if it already has lower precision than the given precision.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="595ea9127c2b29264915dada8a0a74f247f402db" translate="yes" xml:space="preserve">
          <source>The goal in this chapter is to build a module named &lt;code&gt;TestCase&lt;/code&gt; that allows us to write the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="005035c0ac9ba5b2d03b96ccf393ae5ff11ffe11" translate="yes" xml:space="preserve">
          <source>The goal of a &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt; is to abstract the &quot;receive&quot; loop for developers, automatically handling system messages, supporting code change, synchronous calls and more. Therefore, you should never call your own &quot;receive&quot; inside the GenServer callbacks as doing so will cause the GenServer to misbehave.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a6d568374392c51e27178f8aac8e2da82bbf64d" translate="yes" xml:space="preserve">
          <source>The good news is that breaking an umbrella apart is quite straightforward, as you simply need to move applications outside of the umbrella project&amp;rsquo;s &lt;code&gt;apps/&lt;/code&gt; directory. In the worst case scenario, you can discard the umbrella project and all related configuration (&lt;code&gt;build_path&lt;/code&gt;, &lt;code&gt;config_path&lt;/code&gt;, &lt;code&gt;deps_path&lt;/code&gt; and &lt;code&gt;lockfile&lt;/code&gt;) and still leverage the &amp;ldquo;mono-repo&amp;rdquo; pattern by keeping all applications together in the same repository. Each application will have its own dependencies and configuration. Dependencies between those applications can still be explicitly listed by using the &lt;code&gt;:path&lt;/code&gt; option (in contrast to &lt;code&gt;:git&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18abb99c49c0cd9f625ee8db0e020cadbbd4d636" translate="yes" xml:space="preserve">
          <source>The greatest common divisor (GCD) of &lt;code&gt;integer1&lt;/code&gt; and &lt;code&gt;integer2&lt;/code&gt; is the largest positive integer that divides both &lt;code&gt;integer1&lt;/code&gt; and &lt;code&gt;integer2&lt;/code&gt; without leaving a remainder.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04a15f34a10083efdd1b4c7fb23d6409a2799f7b" translate="yes" xml:space="preserve">
          <source>The group mode can also be set to &lt;code&gt;:inherit&lt;/code&gt;, which means it automatically breaks if the parent group has broken too.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="abae706b2e9875a2d4fe24ac37232c3285b58047" translate="yes" xml:space="preserve">
          <source>The handler always executes in a different process from the one it was registered in. As a consequence, any resources managed by the calling process (ETS tables, open files, etc.) won't be available by the time the handler function is invoked.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91dc0be92537f81da316aa8d3834b6a0c2b63c02" translate="yes" xml:space="preserve">
          <source>The head element of aliases can be any term that must expand to an atom at compilation time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5f5e37ee6e6bb7829dd572b3c957edcc2f9784b" translate="yes" xml:space="preserve">
          <source>The implementation above is arguably not a reasonable one. For example, it makes no sense to say that the size of a &lt;code&gt;PID&lt;/code&gt; or an &lt;code&gt;Integer&lt;/code&gt; is &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a82e7d1f4f1afb4f634e8bc16b67baab165570d" translate="yes" xml:space="preserve">
          <source>The implementation is based on the &lt;a href=&quot;https://en.wikipedia.org/wiki/Reservoir_sampling#Relation_to_Fisher-Yates_shuffle&quot;&gt;reservoir sampling&lt;/a&gt; algorithm. It assumes that the sample being returned can fit into memory; the input &lt;code&gt;enumerable&lt;/code&gt; doesn't have to, as it is traversed just once.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b8d2b9e0c9b1879d05717152c53da40bcc3437b" translate="yes" xml:space="preserve">
          <source>The implementation of &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Inspect.Algebra&lt;/code&gt;&lt;/a&gt; is based on the Strictly Pretty paper by &lt;a href=&quot;http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.34.2200&quot;&gt;Lindig&lt;/a&gt; which builds on top of previous pretty printing algorithms but is tailored to strict languages, such as Elixir. The core idea in the paper is the use of explicit document groups which are rendered as flat (breaks as spaces) or as break (breaks as newlines).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a573a08337f6f0cf025ec9ae17d9092603c49c35" translate="yes" xml:space="preserve">
          <source>The implementation of this callback should invoke &lt;code&gt;fun&lt;/code&gt; with the value under &lt;code&gt;key&lt;/code&gt; in the passed structure &lt;code&gt;data&lt;/code&gt;, or with &lt;code&gt;nil&lt;/code&gt; if &lt;code&gt;key&lt;/code&gt; is not present in it. This function must return either &lt;code&gt;{get_value, update_value}&lt;/code&gt; or &lt;code&gt;:pop&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="791ef5c45db6655a2b8e0d52e101cc594625c78d" translate="yes" xml:space="preserve">
          <source>The initial backends are loaded via the &lt;code&gt;:backends&lt;/code&gt; configuration, which must be set before the &lt;code&gt;:logger&lt;/code&gt; application is started.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5d99b4bc070e331607e6d5df8659a98abe40c48" translate="yes" xml:space="preserve">
          <source>The initial value of the accumulator is &lt;code&gt;acc&lt;/code&gt;. The function is invoked for each element in the enumerable with the accumulator. The result returned by the function is used as the accumulator for the next iteration. The function returns the last accumulator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3d8510abacaf7b1519659fdcdb00b6e366da892" translate="yes" xml:space="preserve">
          <source>The initialization arguments, in this case the atom &lt;code&gt;:ok&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1ddbc45c619f8049cea4c440a4edb65fecbed96" translate="yes" xml:space="preserve">
          <source>The integer can be given in different unit according to &lt;a href=&quot;system#convert_time_unit/3&quot;&gt;&lt;code&gt;System.convert_time_unit/3&lt;/code&gt;&lt;/a&gt; and it will be converted to microseconds internally.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5f1e2568ac6af5c9527d828828602700a4893a4" translate="yes" xml:space="preserve">
          <source>The interesting thing about this approach is that Mix has many conveniences for working with such projects, such as the ability to compile and test all applications inside &lt;code&gt;apps&lt;/code&gt; with a single command. However, even though they are all listed together inside &lt;code&gt;apps&lt;/code&gt;, they are still decoupled from each other, so you can build, test and deploy each application in isolation if you want to.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ccef43e698ff7f77a039db9e5b5b3d002b852b8a" translate="yes" xml:space="preserve">
          <source>The internal date format that is used when converting between calendars.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5490fd4bbe326611a1d9b742e7e1f91649638437" translate="yes" xml:space="preserve">
          <source>The internal representation is opaque and cannot be converted to external term format and then back again without losing its properties (meaning it can not be sent to a process on another node and still remain a valid compiled match_spec, nor can it be stored on disk).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7334ee5b04d77d686d637a0f70cc9375ca49af7d" translate="yes" xml:space="preserve">
          <source>The internal time format is used when converting between calendars.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c746eb548e21139e2d2543ac649c03aeac54f5a" translate="yes" xml:space="preserve">
          <source>The key &lt;code&gt;env&lt;/code&gt; of an application resource file has a list of tuples that map atoms to terms, and its contents are known as the application &lt;em&gt;environment&lt;/em&gt;. Note that this environment is unrelated to the operating system environment.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3409677dd18b558166751c16ef637b64275c9b00" translate="yes" xml:space="preserve">
          <source>The key types in maps are allowed to overlap, and if they do, the leftmost key takes precedence. A map value does not belong to this type if it contains a key that is not in the allowed map keys.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32d41944ca5b336f1b48c86344355078fd3da940" translate="yes" xml:space="preserve">
          <source>The keyword list used with &lt;code&gt;defstruct&lt;/code&gt; defines what fields the struct will have along with their default values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e67b4b10fb8bead468c4a33dc123a05fee573455" translate="yes" xml:space="preserve">
          <source>The kind (&lt;code&gt;:def&lt;/code&gt; or &lt;code&gt;:defp&lt;/code&gt;) must be given, the function name, its arguments and the compilation options.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4db3abef2e6392ab0276950699e4f4e0f758b4c0" translate="yes" xml:space="preserve">
          <source>The kind handled by formatting functions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="35b01fa192b09fbd575c96a38ea9c12c69135b18" translate="yes" xml:space="preserve">
          <source>The last step is to change the registry to use the dynamic supervisor:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec09c363bc1673984c9ef7c8fd26b487f2e86ec0" translate="yes" xml:space="preserve">
          <source>The last step is to implement &lt;code&gt;KVServer.Command.run/1&lt;/code&gt;, to run the parsed commands against the &lt;code&gt;:kv&lt;/code&gt; application. Its implementation is shown below:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1505f07b9a5dea491d06c3282407488da838a326" translate="yes" xml:space="preserve">
          <source>The last syntax convenience are &lt;code&gt;do&lt;/code&gt;/&lt;code&gt;end&lt;/code&gt; blocks. &lt;code&gt;do&lt;/code&gt;/&lt;code&gt;end&lt;/code&gt; blocks are equivalent to keywords as the last argument of a function call where the block contents are wrapped in parentheses. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc0ec7829a3c5fbbae5ba7d71fb20b1484d4bd86" translate="yes" xml:space="preserve">
          <source>The left to right arrow (&lt;code&gt;-&amp;gt;&lt;/code&gt;) is represented similar to operators except that they are always part of a list, its left side represents a list of arguments and the right side is an expression.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6289423275f2a3ff2ff61d789c2121d3f39f1f8" translate="yes" xml:space="preserve">
          <source>The left to right arrow (&lt;code&gt;-&amp;gt;&lt;/code&gt;) is used to establish a relationship between left and right, commonly referred as clauses. The left side may have zero, one, or more arguments; the right side is zero, one, or more expressions separated by new line. The &lt;code&gt;-&amp;gt;&lt;/code&gt; may appear one or more times between one of the following terminators: &lt;code&gt;do&lt;/code&gt;/&lt;code&gt;end&lt;/code&gt;, &lt;code&gt;fn&lt;/code&gt;/&lt;code&gt;end&lt;/code&gt; or &lt;code&gt;(&lt;/code&gt;/&lt;code&gt;)&lt;/code&gt;. When &lt;code&gt;-&amp;gt;&lt;/code&gt; is used, only other clauses are allowed between those terminators. Mixing clauses and regular expressions is invalid syntax.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62dfa2cc28c3ba61b288f1d13e4cdc1ed0d38af0" translate="yes" xml:space="preserve">
          <source>The left-hand side supports any expression you would use on the left-hand side of a match:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="452a67adaa49211fbae18840ab0e8f40710191cd" translate="yes" xml:space="preserve">
          <source>The length of the match is equal to the &lt;code&gt;unit&lt;/code&gt; (a number of bits) times the &lt;code&gt;size&lt;/code&gt; (the number of repeated segments of length &lt;code&gt;unit&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b58150e587a8ab776f8c034fd8c13d895af6209" translate="yes" xml:space="preserve">
          <source>The level of concurrency and the time tasks are allowed to run can be controlled via options (see the &quot;Options&quot; section below).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f521fe02fee98ba137b8a2f629c9607b50efc70" translate="yes" xml:space="preserve">
          <source>The limit in the given &lt;code&gt;inspect_opts&lt;/code&gt; is respected and when reached this function stops processing and outputs &lt;code&gt;&quot;...&quot;&lt;/code&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1945f9bf3a795845e8993a19f7a9dfe86f17eea" translate="yes" xml:space="preserve">
          <source>The line above makes &lt;code&gt;:kv&lt;/code&gt; available as a dependency inside &lt;code&gt;:kv_server&lt;/code&gt; and automatically starts the &lt;code&gt;:kv&lt;/code&gt; application before the server starts.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f3150330fa7863de05e8e4f528741a7ca7bb476" translate="yes" xml:space="preserve">
          <source>The line where the module is defined and its file &lt;strong&gt;must&lt;/strong&gt; be passed as options.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65e5d401ccb2b8279fcac802ea4250628d92a6f3" translate="yes" xml:space="preserve">
          <source>The list of &lt;code&gt;entries&lt;/code&gt; is a non-empty list of two-element tuples where the first element is the PID and the second element is the value associated to the PID. If there are no entries for the given key, the callback is never invoked.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8d60e505b52f11e3ed1a46b8da9d55ffe759f2d" translate="yes" xml:space="preserve">
          <source>The list of callers of the current process can be retrieved from the Process dictionary with &lt;code&gt;Process.get(:&quot;$callers&quot;)&lt;/code&gt;. This will return either &lt;code&gt;nil&lt;/code&gt; or a list &lt;code&gt;[pid_n, ..., pid2, pid1]&lt;/code&gt; with at least one entry Where &lt;code&gt;pid_n&lt;/code&gt; is the PID that called the current process, &lt;code&gt;pid2&lt;/code&gt; called &lt;code&gt;pid_n&lt;/code&gt;, and &lt;code&gt;pid2&lt;/code&gt; was called by &lt;code&gt;pid1&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ed6bd036ce9220742f24381556f3269068288d9" translate="yes" xml:space="preserve">
          <source>The list of documents is folded &quot;from the right&quot;; in that, this function is similar to &lt;a href=&quot;list#foldr/3&quot;&gt;&lt;code&gt;List.foldr/3&lt;/code&gt;&lt;/a&gt;, except that it doesn't expect an initial accumulator and uses the last element of &lt;code&gt;docs&lt;/code&gt; as the initial accumulator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1a2ec347d3bbd914ac71de3130a3ca5d8e9ba73" translate="yes" xml:space="preserve">
          <source>The lower case &lt;code&gt;~d&lt;/code&gt; variant does not exist as interpolation and escape characters are not useful for date sigils.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="243770f815841be461d24f785d91a84dc8f25160" translate="yes" xml:space="preserve">
          <source>The lower case &lt;code&gt;~n&lt;/code&gt; variant does not exist as interpolation and escape characters are not useful for date time sigils.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61c4050f1d545dfb95cf8194b35027ab14a85e08" translate="yes" xml:space="preserve">
          <source>The lower case &lt;code&gt;~t&lt;/code&gt; variant does not exist as interpolation and escape characters are not useful for time sigils.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32388371298b5aa74ba2be98958ecd5080c981d1" translate="yes" xml:space="preserve">
          <source>The lower case &lt;code&gt;~u&lt;/code&gt; variant does not exist as interpolation and escape characters are not useful for date time sigils.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8467f6194459766a9d70ef8dad6012fd6200c681" translate="yes" xml:space="preserve">
          <source>The macros &lt;a href=&quot;#debug/2&quot;&gt;&lt;code&gt;debug/2&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#warn/2&quot;&gt;&lt;code&gt;warn/2&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#info/2&quot;&gt;&lt;code&gt;info/2&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#error/2&quot;&gt;&lt;code&gt;error/2&lt;/code&gt;&lt;/a&gt; are preferred over this macro as they can automatically eliminate the call to &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Logger&lt;/code&gt;&lt;/a&gt; altogether at compile time if desired (see the documentation for the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Logger&lt;/code&gt;&lt;/a&gt; module).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="824174ce5b570e4d9805c05f1124ce5c26a319b1" translate="yes" xml:space="preserve">
          <source>The macros &lt;a href=&quot;#defrecord/3&quot;&gt;&lt;code&gt;defrecord/3&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#defrecordp/3&quot;&gt;&lt;code&gt;defrecordp/3&lt;/code&gt;&lt;/a&gt; can be used to create records while &lt;a href=&quot;#extract/2&quot;&gt;&lt;code&gt;extract/2&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#extract_all/1&quot;&gt;&lt;code&gt;extract_all/1&lt;/code&gt;&lt;/a&gt; can be used to extract records from Erlang files.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd1487033e0043998b4a55854f41e5aff164999a" translate="yes" xml:space="preserve">
          <source>The macros in this module come in two flavors: named or operators. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38f9dca5177d03726cc73b1076b1d78de398e382" translate="yes" xml:space="preserve">
          <source>The main function in this module is &lt;a href=&quot;#parse/2&quot;&gt;&lt;code&gt;parse/2&lt;/code&gt;&lt;/a&gt;, which parses a list of command line options and arguments into a keyword list:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="852a05b0450dc656348efc6729f9e523cd593860" translate="yes" xml:space="preserve">
          <source>The majority of the functions expect chardata. In case another type is given, functions will convert those types to string via the &lt;a href=&quot;string.chars&quot;&gt;&lt;code&gt;String.Chars&lt;/code&gt;&lt;/a&gt; protocol (as shown in typespecs). For more information on chardata, see the &quot;IO data&quot; section below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99c734179f1102a008e516a50860fb644aef0bb8" translate="yes" xml:space="preserve">
          <source>The majority of the functions in the &lt;code&gt;File&lt;/code&gt; module expect paths as arguments. Most commonly, those paths will be regular binaries. The &lt;a href=&quot;https://hexdocs.pm/elixir/Path.html&quot;&gt;&lt;code&gt;Path&lt;/code&gt;&lt;/a&gt; module provides facilities for working with such paths:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14d50e0537a311e097eac9e5b800ff509846d646" translate="yes" xml:space="preserve">
          <source>The majority of the functions in this module do not interact with the file system, except for a few functions that require it (like &lt;a href=&quot;#wildcard/2&quot;&gt;&lt;code&gt;wildcard/2&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#expand/1&quot;&gt;&lt;code&gt;expand/1&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53cb17dd3de6e34ca6338dd415345dba7ba819e3" translate="yes" xml:space="preserve">
          <source>The majority of times we spawn processes in Elixir, we spawn them as linked processes. Before we show an example with &lt;code&gt;spawn_link/1&lt;/code&gt;, let&amp;rsquo;s see what happens when a process started with &lt;code&gt;spawn/1&lt;/code&gt; fails:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10d66e531d4200425ddeb9a59e3170249b7e1aed" translate="yes" xml:space="preserve">
          <source>The map above defines a supervisor with &lt;code&gt;:id&lt;/code&gt; of &lt;code&gt;Stack&lt;/code&gt; that is started by calling &lt;code&gt;Stack.start_link([:hello])&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8bb3eb4a71679f85fc1f23e76313b0ee7d67d6ad" translate="yes" xml:space="preserve">
          <source>The map contains the following keys:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89c1e1079a87250a9082cabf85f0e2b686337098" translate="yes" xml:space="preserve">
          <source>The map must be a function. The function receives an integer representing the code point of the character it wants to unescape. Here is the default mapping function implemented by Elixir:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23154a42b58e45ef674deb33492b4a7b042bd7a7" translate="yes" xml:space="preserve">
          <source>The mapping between code and data (the underlying AST) is what allows Elixir to implement &lt;code&gt;defmodule&lt;/code&gt;, &lt;code&gt;def&lt;/code&gt;, &lt;code&gt;if&lt;/code&gt;, and others in Elixir itself. Elixir makes the constructs available for building the language accessible to developers who want to extend the language to new domains.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6991efb82e0a459b03a5b7c2a6877fbcec33018" translate="yes" xml:space="preserve">
          <source>The marker is what follows exactly after &lt;code&gt;&amp;lt;%&lt;/code&gt;. For example, &lt;code&gt;&amp;lt;% foo %&amp;gt;&lt;/code&gt; has an empty marker, but &lt;code&gt;&amp;lt;%= foo %&amp;gt;&lt;/code&gt; has &lt;code&gt;&quot;=&quot;&lt;/code&gt; as marker. The allowed markers so far are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cbb00df7fd3fe762840c451309786ffe89ed55ff" translate="yes" xml:space="preserve">
          <source>The match operator</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8693773fd6ff53ba9de6646d15390dd067bbab4" translate="yes" xml:space="preserve">
          <source>The match operator is not only used to match against simple values, but it is also useful for destructuring more complex data types. For example, we can pattern match on tuples:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9ee80ea2fa936cf7002a1188db1c8b023133c11" translate="yes" xml:space="preserve">
          <source>The math module</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a810ba47e0afb01caa643d3b27868322a40ed5d7" translate="yes" xml:space="preserve">
          <source>The maximum atom size is of 255 Unicode code points.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da10e2a3fe264c784b7e0fdd60cc0177cfc3d0fb" translate="yes" xml:space="preserve">
          <source>The message is formatted and displayed in the same format as used by Elixir's CLI.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae60ef8d035658452d72bdc4024fef29dc953c1c" translate="yes" xml:space="preserve">
          <source>The message is not sent immediately. Therefore, &lt;code&gt;dest&lt;/code&gt; can receive other messages in-between even when &lt;code&gt;time&lt;/code&gt; is &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1852e95a6b1b63c415d7d9c305bc3d2ad89962d3" translate="yes" xml:space="preserve">
          <source>The messages supported by ports and their counterpart function APIs are listed below:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d94502ad54e0168b2a0dd7bb477e4117c14a5e51" translate="yes" xml:space="preserve">
          <source>The minimum example of a &lt;code&gt;test_helper.exs&lt;/code&gt; file would be:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36e330d350d67652867a9b1fa816fde5c72c65e0" translate="yes" xml:space="preserve">
          <source>The modifiers available when creating a Regex are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="554bd8892a2a2f959aaf3286fab34f7cb4eab543" translate="yes" xml:space="preserve">
          <source>The module &lt;a href=&quot;bitwise&quot;&gt;&lt;code&gt;Bitwise&lt;/code&gt;&lt;/a&gt; also includes a handful of &lt;a href=&quot;bitwise#guards&quot;&gt;Erlang bitwise operations as guards&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6173752a29eeb047f2dfafc51f6c1560f53e16b" translate="yes" xml:space="preserve">
          <source>The module containing the custom sigil must be imported before the sigil syntax can be used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11a697026fe35980b1003f6f8535e1c516332e63" translate="yes" xml:space="preserve">
          <source>The module documentation above contains documentation and examples for the supported &lt;code&gt;name&lt;/code&gt; values, summarized below:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6052f32cd5500caeb9f54ee4b03cfe6002f80902" translate="yes" xml:space="preserve">
          <source>The module where the server callbacks are implemented, in this case &lt;code&gt;__MODULE__&lt;/code&gt; (meaning the current module)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d69468bc82e2cdb38bbc6e03284931c1987f717" translate="yes" xml:space="preserve">
          <source>The modules &lt;a href=&quot;http://erlang.org/doc/man/ets.html&quot;&gt;&lt;code&gt;ets&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;http://erlang.org/doc/man/dets.html&quot;&gt;&lt;code&gt;dets&lt;/code&gt;&lt;/a&gt; handle storage of large data structures in memory or on disk respectively.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aad5655a8df039c1d174539db815749409e4e0c7" translate="yes" xml:space="preserve">
          <source>The modules defined in the file are not removed; calling this function only removes them from the list, allowing them to be required again.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea2b347a7bc6a5535356bac28ba3f2b363ebc47b" translate="yes" xml:space="preserve">
          <source>The most common Erlang errors will be transformed into their Elixir counterpart. Those which are not will be transformed into the more generic &lt;a href=&quot;erlangerror&quot;&gt;&lt;code&gt;ErlangError&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cdce2f67135b244ca8a17c4bfd6e3995d0cb745a" translate="yes" xml:space="preserve">
          <source>The most common sigil in Elixir is &lt;code&gt;~r&lt;/code&gt;, which is used to create &lt;a href=&quot;https://en.wikipedia.org/wiki/Regular_Expressions&quot;&gt;regular expressions&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a6e4e1aba3cc5896f4b550cdd6a497deff0ddb9" translate="yes" xml:space="preserve">
          <source>The most common tasks are &lt;code&gt;mix deps.get&lt;/code&gt; and &lt;code&gt;mix deps.update&lt;/code&gt;. Once fetched, dependencies are automatically compiled for you. You can read more about deps by typing &lt;code&gt;mix help deps&lt;/code&gt;, and in the &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Deps.html&quot;&gt;documentation for the Mix.Tasks.Deps module&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b9cc7f30985b20ae7924700825d31d820820e24" translate="yes" xml:space="preserve">
          <source>The most common use case for heredoc sigils is when writing documentation. For example, writing escape characters in the documentation would soon become error prone because of the need to double-escape some characters:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3b38c4c7bf2ec83c1026ecdaac1402a38fdf641" translate="yes" xml:space="preserve">
          <source>The most common way to raise an exception is via &lt;a href=&quot;#raise/2&quot;&gt;&lt;code&gt;raise/2&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec63aea88c70e103879cfde37537cf2e076faa36" translate="yes" xml:space="preserve">
          <source>The name of the generated macros will be &lt;code&gt;name&lt;/code&gt; (which has to be an atom). &lt;code&gt;tag&lt;/code&gt; is also an atom and is used as the &quot;tag&quot; for the record (i.e., the first element of the record tuple); by default (if &lt;code&gt;nil&lt;/code&gt;), it's the same as &lt;code&gt;name&lt;/code&gt;. &lt;code&gt;kv&lt;/code&gt; is a keyword list of &lt;code&gt;name: default_value&lt;/code&gt; fields for the new record.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="090750250669854ad5f2a1b18b4694400b5de691" translate="yes" xml:space="preserve">
          <source>The named sequences are represented by atoms.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84dca7c82c4adab78e96e4275650ccd595bf63f7" translate="yes" xml:space="preserve">
          <source>The need for monitoring</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d5693a336fde96fc9f4a9263d265529c9d65820" translate="yes" xml:space="preserve">
          <source>The next two functions, &lt;code&gt;lookup/2&lt;/code&gt; and &lt;code&gt;create/2&lt;/code&gt;, are responsible for sending these requests to the server. In this case, we have used &lt;code&gt;{:lookup, name}&lt;/code&gt; and &lt;code&gt;{:create, name}&lt;/code&gt; respectively. Requests are often specified as tuples, like this, in order to provide more than one &amp;ldquo;argument&amp;rdquo; in that first argument slot. It&amp;rsquo;s common to specify the action being requested as the first element of a tuple, and arguments for that action in the remaining elements. Note that the requests must match the first argument to &lt;code&gt;handle_call/3&lt;/code&gt; or &lt;code&gt;handle_cast/2&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="987bf5fe1a29a589006df7a1c4246dedd1188aa8" translate="yes" xml:space="preserve">
          <source>The node list defaults to a list of all connected nodes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e4f23ef668efde946b979656f1273bb8fc04978" translate="yes" xml:space="preserve">
          <source>The notation to represent the union of types is the pipe &lt;code&gt;|&lt;/code&gt;. For example, the typespec &lt;code&gt;type :: atom() | pid() | tuple()&lt;/code&gt; creates a type &lt;code&gt;type&lt;/code&gt; that can be either an &lt;code&gt;atom&lt;/code&gt;, a &lt;code&gt;pid&lt;/code&gt;, or a &lt;code&gt;tuple&lt;/code&gt;. This is usually called a &lt;a href=&quot;https://en.wikipedia.org/wiki/Tagged_union&quot;&gt;sum type&lt;/a&gt; in other languages</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ab75e9fdd50914ae4096566ba3ee4815b968a2a" translate="yes" xml:space="preserve">
          <source>The number of arguments in each anonymous function clause needs to be the same, otherwise an error is raised.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58646d5d2a31b22e08348e0987be6fb1b1552f1b" translate="yes" xml:space="preserve">
          <source>The offset is capped to the length of the string. Returns a tuple with two elements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ac751725399e216969e58864613bb897ae9753a" translate="yes" xml:space="preserve">
          <source>The only difference between &lt;a href=&quot;kernel#==/2&quot;&gt;&lt;code&gt;==&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;kernel#===/2&quot;&gt;&lt;code&gt;===&lt;/code&gt;&lt;/a&gt; is that &lt;a href=&quot;kernel#===/2&quot;&gt;&lt;code&gt;===&lt;/code&gt;&lt;/a&gt; is strict when it comes to comparing integers and floats:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42fcb26dc86b08d995f11bae71b9989f2f7b728a" translate="yes" xml:space="preserve">
          <source>The only exception to the compatibility guarantees above are experimental features, which will be explicitly marked as such, and do not provide any compatibility guarantee until they are stabilized.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b80c752c5e1cd83678df53e132bab989245bf95" translate="yes" xml:space="preserve">
          <source>The only function required to be implemented is &lt;a href=&quot;#to_charlist/1&quot;&gt;&lt;code&gt;to_charlist/1&lt;/code&gt;&lt;/a&gt; which does the conversion.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3738a03df0b0292cd0fc541a62dccb969b8d4008" translate="yes" xml:space="preserve">
          <source>The only function required to be implemented is &lt;a href=&quot;#to_string/1&quot;&gt;&lt;code&gt;to_string/1&lt;/code&gt;&lt;/a&gt;, which does the conversion.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ade81e07849e4708797e256e50ea8daa5d7c1c81" translate="yes" xml:space="preserve">
          <source>The only restrictions when creating anonymous functions is that at least one placeholder must be present, i.e. it must contain at least &lt;code&gt;&amp;amp;1&lt;/code&gt;, and that block expressions are not supported:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5bde5d825d53af6907621f0cb4672e1213049a4a" translate="yes" xml:space="preserve">
          <source>The operation is Unicode unsafe.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="820323122693cc928f8711400bb7374b1eb73417" translate="yes" xml:space="preserve">
          <source>The operation is performed on the binary floating point, without a conversion to decimal.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54a4338b50a933ea4de60119e3d7bc1ba6605f93" translate="yes" xml:space="preserve">
          <source>The operators that Elixir uses (for example, &lt;code&gt;+&lt;/code&gt;) can be defined by any module and used in place of the ones defined by Elixir, provided they're specifically not imported from &lt;a href=&quot;kernel&quot;&gt;&lt;code&gt;Kernel&lt;/code&gt;&lt;/a&gt; (which is imported everywhere by default). For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="35424357ca8ff1662dd08fa3f02518cdf95e9618" translate="yes" xml:space="preserve">
          <source>The opposite of converting a string to its quoted form is &lt;a href=&quot;macro#to_string/2&quot;&gt;&lt;code&gt;Macro.to_string/2&lt;/code&gt;&lt;/a&gt;, which converts a quoted form to a string/binary representation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="648996e2b78ff86fed25658983c86c1ca75fe83d" translate="yes" xml:space="preserve">
          <source>The option &lt;code&gt;--abort-if-any&lt;/code&gt; can be used for the command to fail if deprecated calls exist.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="719eb9d884931feb59017fec9c07b6c8395fab97" translate="yes" xml:space="preserve">
          <source>The option &lt;code&gt;--abort-if-any&lt;/code&gt; can be used for the command to fail if unreachable calls exist.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="098132f317e5ef6b4049ca986c6beb4394ebb00e" translate="yes" xml:space="preserve">
          <source>The options &lt;code&gt;:only&lt;/code&gt; and &lt;code&gt;:except&lt;/code&gt; can be used with &lt;code&gt;@derive&lt;/code&gt; to specify which fields should and should not appear in the algebra document:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ca038b4953a725a1168758bdb05bf6957d97558" translate="yes" xml:space="preserve">
          <source>The options above have different properties. Both &lt;code&gt;:rpc&lt;/code&gt; and using a GenServer would serialize your requests on a single server, while tasks are effectively running asynchronously on the remote node, with the only serialization point being the spawning done by the supervisor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec569bf070d46fd1797683900e4e0d1b42dd476e" translate="yes" xml:space="preserve">
          <source>The options can also be used to register a supervisor name. The supported values are described under the &quot;Name registration&quot; section in the &lt;a href=&quot;genserver&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt; module docs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b29b1695f7e1a72d94e875780fae402a43a9edf2" translate="yes" xml:space="preserve">
          <source>The options given in the child specification are documented in &lt;a href=&quot;#start_link/1&quot;&gt;&lt;code&gt;start_link/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29149d2185c124051b475d7edf03c7125bd21d1c" translate="yes" xml:space="preserve">
          <source>The options not available are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df79e73939e2f96120d0bd91e6ec1e8015418fd3" translate="yes" xml:space="preserve">
          <source>The original &lt;code&gt;List&lt;/code&gt; can still be accessed within &lt;code&gt;Stats&lt;/code&gt; by the fully-qualified name &lt;code&gt;Elixir.List&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1668a9a07e94faf6e48dc573decf8c9122af382" translate="yes" xml:space="preserve">
          <source>The output can be decorated with a label, by providing the &lt;code&gt;:label&lt;/code&gt; option to easily distinguish it from other &lt;a href=&quot;io#inspect/2&quot;&gt;&lt;code&gt;IO.inspect/2&lt;/code&gt;&lt;/a&gt; calls. The label will be printed before the inspected &lt;code&gt;item&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="313b3334ac8a23ead5e2d1a7fbc216efaabeea04" translate="yes" xml:space="preserve">
          <source>The path is expanded with &lt;a href=&quot;path#expand/1&quot;&gt;&lt;code&gt;Path.expand/1&lt;/code&gt;&lt;/a&gt; before being appended. If this path does not exist, an error is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d4310f7386df1164fbd8636a1690c05bd665337" translate="yes" xml:space="preserve">
          <source>The path is expanded with &lt;a href=&quot;path#expand/1&quot;&gt;&lt;code&gt;Path.expand/1&lt;/code&gt;&lt;/a&gt; before being deleted. If the path does not exist, this function returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="838b6d73e0a2709d4a72a878f5b42de538ac3faf" translate="yes" xml:space="preserve">
          <source>The path is expanded with &lt;a href=&quot;path#expand/1&quot;&gt;&lt;code&gt;Path.expand/1&lt;/code&gt;&lt;/a&gt; before being prepended. If this path does not exist, an error is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e091aa0884c675c72ffb53e03abf27a7e2087b1e" translate="yes" xml:space="preserve">
          <source>The paths can be either a charlist or a string. Internally they are worked on as charlists, so passing them as lists avoid extra conversion.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="668bfdcbbc88064352f1db03b861c85f89d02114" translate="yes" xml:space="preserve">
          <source>The pattern can be a module name, such as &lt;a href=&quot;https://hexdocs.pm/elixir/String.html&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; to count all calls to that module, a call without arity, such as &lt;code&gt;String.split&lt;/code&gt;, to count all calls to that function regardless of arity, or a call with arity, such as &lt;a href=&quot;https://hexdocs.pm/elixir/String.html#split/2&quot;&gt;&lt;code&gt;String.split/2&lt;/code&gt;&lt;/a&gt;, to count all calls to that exact module, function and arity.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6382a5f5628ad82e683e23e1297c423e36e37f3" translate="yes" xml:space="preserve">
          <source>The pattern may also be a list of strings and the replacement may also be a function that receives the matched patterns:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c2c0506c6452af899d4d254cc14a3c00d8d753c" translate="yes" xml:space="preserve">
          <source>The pattern of keeping multiple applications in the same repository is known as &amp;ldquo;mono-repo&amp;rdquo;. Umbrella projects maximize this pattern by providing conveniences to compile, test and run multiple applications at once.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5336f2e10af99a0ddce0df1dbcc6953c1b3edca" translate="yes" xml:space="preserve">
          <source>The pin operator</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a16097e3345670b784d58d96c0daf29bd6b6363" translate="yes" xml:space="preserve">
          <source>The pipe operator</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38ac69a732c3ec695582cbd0d48d9b6cb576dd15" translate="yes" xml:space="preserve">
          <source>The port can be opened through four main mechanisms.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16f2f4882ba1e010d9493752e86925be5a3100f2" translate="yes" xml:space="preserve">
          <source>The power of Elixir&amp;rsquo;s extensibility comes when protocols and structs are used together.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4539c5e2ab058d8719dac59fa3bb2dc3b38cff89" translate="yes" xml:space="preserve">
          <source>The precision represents the number of digits that must be used when representing the microseconds to external format. If the precision is 0, it means microseconds must be skipped.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b62847898ead6d12d866064984b0e4967caa7b6" translate="yes" xml:space="preserve">
          <source>The previous implementation used pipelines which made the logic straightforward to follow. However, now that we need to handle different error codes along the way, our server logic is nested inside many &lt;code&gt;case&lt;/code&gt; calls.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="199cc5f932aae17375561fec949a9c5a51d6d815" translate="yes" xml:space="preserve">
          <source>The problem with the code above is that, if the user supplies an invalid input, the error will be raised deep inside the library, which makes it confusing for users. Furthermore, when you don't validate the values at the boundary, the internals of your library are never quite sure which kind of values they are working with.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="523d730771dc4a286c57cbc053f5c708e3c1f6ea" translate="yes" xml:space="preserve">
          <source>The process is terminated, if there's one. The child specification is kept unless the child is temporary.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b431d95d4131709473d087764c74e5d0bd63926d" translate="yes" xml:space="preserve">
          <source>The process of taking a list and &lt;em&gt;reducing&lt;/em&gt; it down to one value is known as a &lt;em&gt;reduce algorithm&lt;/em&gt; and is central to functional programming.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2fe675ae074650fc0dd2cca82261ebbd5e4a0afa" translate="yes" xml:space="preserve">
          <source>The process that sends the message does not block on &lt;code&gt;send/2&lt;/code&gt;, it puts the message in the recipient&amp;rsquo;s mailbox and continues. In particular, a process can send messages to itself.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f279aa503c0e9c1a8851aaff4d4667435775ccbe" translate="yes" xml:space="preserve">
          <source>The project name is given in the &lt;code&gt;snake_case&lt;/code&gt; convention where all letters are lowercase and words are separate with underscores. This is the same convention used by variables, function names and atoms in Elixir. See the &lt;a href=&quot;naming-conventions&quot;&gt;Naming Conventions&lt;/a&gt; document for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee55aee8e2dfe77fe02c53dba2352810a3c64b0a" translate="yes" xml:space="preserve">
          <source>The protocol definition would look like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc915ce7d8df69961e91346b51ae1b4406aeabbb" translate="yes" xml:space="preserve">
          <source>The queue module</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0af8f5620b697ca5fb92373212c500e4cb31990a" translate="yes" xml:space="preserve">
          <source>The rand module</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="231da92c7cb81a49b248aa20d7528608e5de9c35" translate="yes" xml:space="preserve">
          <source>The rationale behind this behaviour is to better support Erlang libraries which may return text as charlists instead of Elixir strings. One example of such functions is &lt;a href=&quot;application#loaded_applications/0&quot;&gt;&lt;code&gt;Application.loaded_applications/0&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd093bcc0572d7db8f0249b943686c7ab44cd28f" translate="yes" xml:space="preserve">
          <source>The real benefit of protocols comes when mixed with structs. For instance, Elixir ships with many data types implemented as structs, like &lt;a href=&quot;mapset&quot;&gt;&lt;code&gt;MapSet&lt;/code&gt;&lt;/a&gt;. We can implement the &lt;code&gt;Size&lt;/code&gt; protocol for those types as well:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd7d714c1aa6b48b1d5593fcc16114d85e6a86ca" translate="yes" xml:space="preserve">
          <source>The reason behind supporting different delimiters is to provide a way to write literals without escaped delimiters. For example, a regular expression with forward slashes like &lt;code&gt;~r(^https?://)&lt;/code&gt; reads arguably better than &lt;code&gt;~r/^https?:\/\//&lt;/code&gt;. Similarly, if the regular expression has forward slashes and capturing groups (that use &lt;code&gt;()&lt;/code&gt;), you may then choose double quotes instead of parentheses.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ebf61cf3ca7649d4a079542dcbdefccc549e8d6" translate="yes" xml:space="preserve">
          <source>The reason those failures are happening is because, for didactic purposes, we have made two mistakes:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c08560839cd14ff160f58cb4ece9a90b113b6018" translate="yes" xml:space="preserve">
          <source>The reason we can compare different data types is pragmatism. Sorting algorithms don&amp;rsquo;t need to worry about different data types in order to sort. The overall sorting order is defined below:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96b6eb1d3d1c2f52c89893113a0264a48486f7f0" translate="yes" xml:space="preserve">
          <source>The reason we can compare different data types is pragmatism. Sorting algorithms don't need to worry about different data types in order to sort. For reference, the overall sorting order is defined below:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9745fde52cc90f68fc3769f51bdd3839a79e7909" translate="yes" xml:space="preserve">
          <source>The reason why defining the &lt;code&gt;__using__&lt;/code&gt; macro above should be avoided is because when a developer writes:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ec6b8d401a0e57e5eec7caca955764b74ee728d" translate="yes" xml:space="preserve">
          <source>The reducer function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe9b615b4b2367b7daee50e253cbdf23dba26c40" translate="yes" xml:space="preserve">
          <source>The registry can be used for different purposes, such as name lookups (using the &lt;code&gt;:via&lt;/code&gt; option), storing properties, custom dispatching rules, or a pubsub implementation. We explore some of those use cases below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="830561c69ec1b44d20b1476b8ca91dcfe652b847" translate="yes" xml:space="preserve">
          <source>The registry creates the bucket and updates the cache table</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e02149d4dfcef116ac8ae8bc7c958f58a3e9c0d" translate="yes" xml:space="preserve">
          <source>The registry identifier</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c262eba9d17501af95e8d89e43d93764b4ff9c4" translate="yes" xml:space="preserve">
          <source>The registry may also be transparently partitioned, which provides more scalable behaviour for running registries on highly concurrent environments with thousands or millions of entries.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6dcaa3fc50cf9fd5531a012d77c058d5085b7bd8" translate="yes" xml:space="preserve">
          <source>The registry needs to guarantee that it is always up to date. For example, if one of the bucket processes crashes due to a bug, the registry must notice this change and avoid serving stale entries. In Elixir, we say the registry needs to &lt;em&gt;monitor&lt;/em&gt; each bucket. Because our &lt;em&gt;registry&lt;/em&gt; needs to be able to receive and handle ad-hoc messages from the system, the &lt;code&gt;Agent&lt;/code&gt; API is not enough.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a058f690e57a3aca65e5ad6c344df9d0e9611d7" translate="yes" xml:space="preserve">
          <source>The registry requires the following keys:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66187ff2a57d2c76b021b6e86b887377c3911cc5" translate="yes" xml:space="preserve">
          <source>The remaining fields are private and should not be accessed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f0abbf815761f3e816424020ca8e718d8880a26" translate="yes" xml:space="preserve">
          <source>The remaining options can be specified to further customize the escript:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b880036afa4f762da2230a6fa814b25c0b9e585" translate="yes" xml:space="preserve">
          <source>The replacement can be either a string or a function. The string is used as a replacement for every match and it allows specific captures to be accessed via &lt;code&gt;\N&lt;/code&gt; or &lt;code&gt;\g{N}&lt;/code&gt;, where &lt;code&gt;N&lt;/code&gt; is the capture. In case &lt;code&gt;\0&lt;/code&gt; is used, the whole match is inserted. Note that in regexes the backslash needs to be escaped, hence in practice you'll need to use &lt;code&gt;\\N&lt;/code&gt; and &lt;code&gt;\\g{N}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d12dcacc64e49f2ca797e3a42d48c6b95c4c021d" translate="yes" xml:space="preserve">
          <source>The reply sent by the task will be in the format &lt;code&gt;{ref, result}&lt;/code&gt;, where &lt;code&gt;ref&lt;/code&gt; is the monitor reference held by the task struct and &lt;code&gt;result&lt;/code&gt; is the return value of the task function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fbae3095fe06d4c7dbe53db6c416f757e85aa9e2" translate="yes" xml:space="preserve">
          <source>The requirement operand after the &lt;code&gt;~&amp;gt;&lt;/code&gt; is allowed to omit the patch version, allowing us to express &lt;code&gt;~&amp;gt; 2.1&lt;/code&gt; or &lt;code&gt;~&amp;gt; 2.1-dev&lt;/code&gt;, something that wouldn't be allowed when using the common comparison operators.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48c107c58db2b694200d1ee8f97e6cacd70556ad" translate="yes" xml:space="preserve">
          <source>The requirements for this guide are (see &lt;code&gt;elixir -v&lt;/code&gt;):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="510fb68883c75cfa0f5726ad2958e2b2d1f8df13" translate="yes" xml:space="preserve">
          <source>The rest of this document will cover how child processes are specified, how they can be started and stopped, different supervision strategies and more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34f71128fc5223e069e44135ef71e787278b7b2a" translate="yes" xml:space="preserve">
          <source>The result depends on the given options. In particular, if &lt;code&gt;:monitor&lt;/code&gt; is given as an option, it will return a tuple containing the PID and the monitoring reference, otherwise just the spawned process PID.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c0864a3fd323ad326bf0ff0a4ae750f6f28b62b" translate="yes" xml:space="preserve">
          <source>The result is a map where each key is given by &lt;code&gt;key_fun&lt;/code&gt; and each value is a list of elements given by &lt;code&gt;value_fun&lt;/code&gt;. The order of elements within each list is preserved from the &lt;code&gt;enumerable&lt;/code&gt;. However, like all maps, the resulting map is unordered.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c937afc93e905039ed962f46e31ce761b0b7910" translate="yes" xml:space="preserve">
          <source>The result is a tuple with the code point and the remainder of the string or &lt;code&gt;nil&lt;/code&gt; in case the string reached its end.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b054d17c2daa0de49da800a95e641450c215bba5" translate="yes" xml:space="preserve">
          <source>The result is a tuple with the grapheme and the remainder of the string or &lt;code&gt;nil&lt;/code&gt; in case the String reached its end.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf56030549a526b9bf11fca22b129025175f9e01" translate="yes" xml:space="preserve">
          <source>The result is a tuple with the next grapheme size and the remainder of the string or &lt;code&gt;nil&lt;/code&gt; in case the string reached its end.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69c824c2f4dd9e92c63e7c43b613daec936f10e9" translate="yes" xml:space="preserve">
          <source>The result is always a float. Use &lt;a href=&quot;#div/2&quot;&gt;&lt;code&gt;div/2&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#rem/2&quot;&gt;&lt;code&gt;rem/2&lt;/code&gt;&lt;/a&gt; if you want an integer division or the remainder.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e60b28a7c2d9f237889da5d63ad55cd56db26e5f" translate="yes" xml:space="preserve">
          <source>The result is returned in the &lt;code&gt;:native&lt;/code&gt; time unit.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e378125d134cee06b90778b774e2ca53b3a689f" translate="yes" xml:space="preserve">
          <source>The result is returned in the given time unit &lt;code&gt;unit&lt;/code&gt;. The returned offset, added to an Erlang monotonic time (e.g., obtained with &lt;a href=&quot;#monotonic_time/1&quot;&gt;&lt;code&gt;monotonic_time/1&lt;/code&gt;&lt;/a&gt;), gives the Erlang system time that corresponds to that monotonic time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad2bb7bf504a7a31fc692bc22a46a7f6c26558df" translate="yes" xml:space="preserve">
          <source>The result is rounded via the floor function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c9d24e7e55d00cf51e7d7ac4365534956cf6af0" translate="yes" xml:space="preserve">
          <source>The result of the reduce operation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c33a08ba308a53a6a04ff3b3a415b2906539c81" translate="yes" xml:space="preserve">
          <source>The result of this function is used to check if two calendars rollover at the same time of day. If they do not, we can only convert datetimes and times between them. If they do, this means that we can also convert dates as well as naive datetimes between them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="deee6a8e2cf3a1dc01e05f85abd7a333a49b9743" translate="yes" xml:space="preserve">
          <source>The result returned when the argument is a list, is the list of nodes satisfying the disjunction(s) of the list elements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de9d80b1ab304736a1d1cf097b00ab6920ddf496" translate="yes" xml:space="preserve">
          <source>The return value for &lt;code&gt;fun&lt;/code&gt; is expected to be</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c789d5090be5fd4830e5650f8cf224329bb3d092" translate="yes" xml:space="preserve">
          <source>The return value of &lt;a href=&quot;#c:init/1&quot;&gt;&lt;code&gt;init/1&lt;/code&gt;&lt;/a&gt; or any of the &lt;code&gt;handle_*&lt;/code&gt; callbacks may include a timeout value in milliseconds; if not, &lt;code&gt;:infinity&lt;/code&gt; is assumed. The timeout can be used to detect a lull in incoming messages.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="637f2543c6c71a469bb5665295bb80f1c21c7816" translate="yes" xml:space="preserve">
          <source>The return value of this function is always &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aee9968a076604f4bf8eb65e4e57dfeed366595f" translate="yes" xml:space="preserve">
          <source>The return value of this function is the value that was previously stored under &lt;code&gt;key&lt;/code&gt;, or &lt;code&gt;nil&lt;/code&gt; in case no value was stored under it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f600704ad2a1d265216e1874920599247dcd864b" translate="yes" xml:space="preserve">
          <source>The returned function is typically passed as an accessor to &lt;a href=&quot;kernel#get_in/2&quot;&gt;&lt;code&gt;Kernel.get_in/2&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;kernel#get_and_update_in/3&quot;&gt;&lt;code&gt;Kernel.get_and_update_in/3&lt;/code&gt;&lt;/a&gt;, and friends.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="feb14c2276580a5fb93fd8afe56dfe5ef725b402" translate="yes" xml:space="preserve">
          <source>The returned function raises if &lt;code&gt;index&lt;/code&gt; is out of bounds.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f18363f66f41ea776d213b7a358943fee2fbf810" translate="yes" xml:space="preserve">
          <source>The returned function receives a term and a command and injects the term into the collectable on every &lt;code&gt;{:cont, term}&lt;/code&gt; command.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03b6bd0a789c54c65fa616d4c3d05a787c9fac95" translate="yes" xml:space="preserve">
          <source>The returned function uses the default value if the key does not exist. This can be used to specify defaults and safely traverse missing keys:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17eadcc2531c98be75b3d36e9d02f1db40badbf9" translate="yes" xml:space="preserve">
          <source>The returned information is a two-element tuple in the shape of &lt;code&gt;{info, value}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40619e10ae25c330063c65535cf867c78a0305e7" translate="yes" xml:space="preserve">
          <source>The returned keys (with the corresponding possible values) for all types of functions (local and external) are the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ee75b4eeb81fcc96ebfd98173bc87ddff369546" translate="yes" xml:space="preserve">
          <source>The returned path will be expanded.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d71c99a8e09f63bf55427e1e561d5818b8e3777" translate="yes" xml:space="preserve">
          <source>The returned reference will re-occur after approximately 2^82 calls; therefore it is unique enough for practical purposes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6710b3a068da95fe2b8593d7add9ec761b0835bc" translate="yes" xml:space="preserve">
          <source>The returned value is a map containing name-value pairs. Variable names and their values are strings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b373635bb9902337ad9e10b973bd7b4caeea100c" translate="yes" xml:space="preserve">
          <source>The returned value is a tuple with the &quot;get&quot; value returned by &lt;code&gt;fun&lt;/code&gt; and a new keyword list with the updated value under &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b42137d3006c00e4b619eab71021a2f058571bc2" translate="yes" xml:space="preserve">
          <source>The returned value is a tuple with the &quot;get&quot; value returned by &lt;code&gt;fun&lt;/code&gt; and a new map with the updated value under &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bcdf4e0951183ef655924f609aa3f331a6262b10" translate="yes" xml:space="preserve">
          <source>The returned value is a two-element tuple with the &quot;get&quot; value returned by &lt;code&gt;fun&lt;/code&gt; and a new container with the updated value under &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e65f7f051c44e5c9c75a8f2f854fabd880fc538" translate="yes" xml:space="preserve">
          <source>The returned value of the environment variable &lt;code&gt;varname&lt;/code&gt; is a string. If the environment variable is not set, returns the string specified in &lt;code&gt;default&lt;/code&gt; or &lt;code&gt;nil&lt;/code&gt; if none is specified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f847cce0d292ae271a717b61d78816a1f1ea3fd" translate="yes" xml:space="preserve">
          <source>The right path will always be expanded to its relative format and any trailing slash will be removed when joining.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="643a7d1289fc8c2df27def8f3faf469415ebab11" translate="yes" xml:space="preserve">
          <source>The right side of &lt;code&gt;.&lt;/code&gt; may be a word starting with an uppercase letter, which represents an alias, a word starting with lowercase or underscore, any valid language operator or any name wrapped in single- or double-quotes. Those are all valid examples:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c04e1c8f69c2f1a88e36a20e9901940c66e8dcfe" translate="yes" xml:space="preserve">
          <source>The rounding direction always ties to half up. The operation is performed on the binary floating point, without a conversion to decimal.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4144dd4219963dfd0900f8f0b48ec21d6f4d014e" translate="yes" xml:space="preserve">
          <source>The router will check the first byte of the bucket name against the table and dispatch to the appropriate node based on that. For example, a bucket starting with the letter &amp;ldquo;a&amp;rdquo; (&lt;code&gt;?a&lt;/code&gt; represents the Unicode codepoint of the letter &amp;ldquo;a&amp;rdquo;) will be dispatched to node &lt;code&gt;foo@computer-name&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ff8ac86ff623f4bf3fb0733f54cbe348a65e9dc" translate="yes" xml:space="preserve">
          <source>The routing layer will receive a routing table of the following format:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c154bbe6784f06daaef10626cc0bf86a4376497" translate="yes" xml:space="preserve">
          <source>The same applies to duplicate registries:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8461a29f68bfc60f9acb948d5fe98c088c56fd3e" translate="yes" xml:space="preserve">
          <source>The same applies to maps where each pair is treated as a list of tuples with two elements:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b487f77f15de12365c59e270fe90d68cbbe73146" translate="yes" xml:space="preserve">
          <source>The same applies to qualified calls such as &lt;code&gt;Foo.bar(1, 2, 3)&lt;/code&gt;, which is the same as &lt;code&gt;Foo.bar 1, 2, 3&lt;/code&gt;. However, remember parentheses are not optional for non-qualified calls with no arguments, such as &lt;code&gt;sum()&lt;/code&gt;. Removing the parentheses for &lt;code&gt;sum&lt;/code&gt; causes it to be represented as the variable &lt;code&gt;sum&lt;/code&gt;, which means they would be no longer equivalent.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47e032a5027ea138ef1f6dce21b412d852e000c1" translate="yes" xml:space="preserve">
          <source>The same as &lt;a href=&quot;#cd/1&quot;&gt;&lt;code&gt;cd/1&lt;/code&gt;&lt;/a&gt;, but raises a &lt;a href=&quot;file.error&quot;&gt;&lt;code&gt;File.Error&lt;/code&gt;&lt;/a&gt; exception if it fails.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18e01d0d75a4c60af88fee26dd31622d04f96a97" translate="yes" xml:space="preserve">
          <source>The same as &lt;a href=&quot;#copy/3&quot;&gt;&lt;code&gt;copy/3&lt;/code&gt;&lt;/a&gt; but raises a &lt;a href=&quot;file.copyerror&quot;&gt;&lt;code&gt;File.CopyError&lt;/code&gt;&lt;/a&gt; exception if it fails. Returns the &lt;code&gt;bytes_copied&lt;/code&gt; otherwise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2cf6de4f99822a7c8fe3b408ab5d4cf7f42930ca" translate="yes" xml:space="preserve">
          <source>The same as &lt;a href=&quot;#cp/3&quot;&gt;&lt;code&gt;cp/3&lt;/code&gt;&lt;/a&gt;, but raises a &lt;a href=&quot;file.copyerror&quot;&gt;&lt;code&gt;File.CopyError&lt;/code&gt;&lt;/a&gt; exception if it fails. Returns &lt;code&gt;:ok&lt;/code&gt; otherwise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f92c875af9b9262d24ee988fee5dadfcecefeb5a" translate="yes" xml:space="preserve">
          <source>The same as &lt;a href=&quot;#cp_r/3&quot;&gt;&lt;code&gt;cp_r/3&lt;/code&gt;&lt;/a&gt;, but raises a &lt;a href=&quot;file.copyerror&quot;&gt;&lt;code&gt;File.CopyError&lt;/code&gt;&lt;/a&gt; exception if it fails. Returns the list of copied files otherwise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f459fdf18e68c368ea8cc4aa8ed5c7cc8b9dd88a" translate="yes" xml:space="preserve">
          <source>The same as &lt;a href=&quot;#cwd/0&quot;&gt;&lt;code&gt;cwd/0&lt;/code&gt;&lt;/a&gt;, but raises a &lt;a href=&quot;file.error&quot;&gt;&lt;code&gt;File.Error&lt;/code&gt;&lt;/a&gt; exception if it fails.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e983c20087a73c47c1b91cd7c2c300a823c39d00" translate="yes" xml:space="preserve">
          <source>The same as &lt;a href=&quot;#ls/1&quot;&gt;&lt;code&gt;ls/1&lt;/code&gt;&lt;/a&gt; but raises a &lt;a href=&quot;file.error&quot;&gt;&lt;code&gt;File.Error&lt;/code&gt;&lt;/a&gt; exception in case of an error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94d50f21dfa011da9b3d948e9722047f3d7526a9" translate="yes" xml:space="preserve">
          <source>The same as &lt;a href=&quot;#parse/2&quot;&gt;&lt;code&gt;parse/2&lt;/code&gt;&lt;/a&gt; but raises an &lt;a href=&quot;optionparser.parseerror&quot;&gt;&lt;code&gt;OptionParser.ParseError&lt;/code&gt;&lt;/a&gt; exception if any invalid options are given.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5050ef6fcebfe967949f495038b1cf5998440f0" translate="yes" xml:space="preserve">
          <source>The same as &lt;a href=&quot;#parse_head/2&quot;&gt;&lt;code&gt;parse_head/2&lt;/code&gt;&lt;/a&gt; but raises an &lt;a href=&quot;optionparser.parseerror&quot;&gt;&lt;code&gt;OptionParser.ParseError&lt;/code&gt;&lt;/a&gt; exception if any invalid options are given.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44ad2c47fd323d50a1b7a9d773f54ea42bbc2572" translate="yes" xml:space="preserve">
          <source>The same as &lt;a href=&quot;#read_imports!/2&quot;&gt;&lt;code&gt;read_imports!/2&lt;/code&gt;&lt;/a&gt; but only returns the configuration in the given file, without returning the imported paths.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76551e442cf0920ecab6d0eb8ea56bcf94c15620" translate="yes" xml:space="preserve">
          <source>The same as &lt;a href=&quot;#rename/2&quot;&gt;&lt;code&gt;rename/2&lt;/code&gt;&lt;/a&gt; but raises a &lt;a href=&quot;file.renameerror&quot;&gt;&lt;code&gt;File.RenameError&lt;/code&gt;&lt;/a&gt; exception if it fails. Returns &lt;code&gt;:ok&lt;/code&gt; otherwise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff7e3f389bbffc2c11af04820517b44446f5b5b0" translate="yes" xml:space="preserve">
          <source>The second approach uses function calls which better suits more complex APIs (for example, if you need to pass many options) and reads nicely in Elixir thanks to the pipe operator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4989f7d201fe4b48e470058521e1ca80ae6c9569" translate="yes" xml:space="preserve">
          <source>The second argument is a keyword list of options:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43642aa7f67e7784c0b111753a92ead35aec4a5a" translate="yes" xml:space="preserve">
          <source>The second argument is either a timeout or &lt;code&gt;:brutal_kill&lt;/code&gt;. In case of a timeout, a &lt;code&gt;:shutdown&lt;/code&gt; exit signal is sent to the task process and if it does not exit within the timeout, it is killed. With &lt;code&gt;:brutal_kill&lt;/code&gt; the task is killed straight away. In case the task terminates abnormally (possibly killed by another process), this function will exit with the same reason.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fcb757bd7051270d8c819a13491903d89a8704fd" translate="yes" xml:space="preserve">
          <source>The second argument is first expanded to an absolute path.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="524ef427f3aceff5423ab5acc031269f5e3169df" translate="yes" xml:space="preserve">
          <source>The second argument specifying every &lt;code&gt;nth&lt;/code&gt; element must be a non-negative integer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a6d508d801e049e82fe48d35683e28b76dc2200" translate="yes" xml:space="preserve">
          <source>The second change is in the &lt;code&gt;application&lt;/code&gt; function inside &lt;code&gt;mix.exs&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36314cd4001b7103421433826074baa427430f61" translate="yes" xml:space="preserve">
          <source>The second concern is that, while using &lt;code&gt;mix run&lt;/code&gt; is completely fine to run our software in production, the command we use to start our services is getting increasingly more complex. For example, imagine we also want to &lt;code&gt;--preload-modules&lt;/code&gt;, to all code is loaded upfront, as well as set the &lt;code&gt;MIX_ENV=prod&lt;/code&gt; environment variable:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59db642f7ebf3826674361ba0acf5de33120795d" translate="yes" xml:space="preserve">
          <source>The second definition matches the pattern and has no guard so it will be executed. It first prints our &lt;code&gt;msg&lt;/code&gt; and then calls itself passing &lt;code&gt;n - 1&lt;/code&gt; (&lt;code&gt;2&lt;/code&gt;) as the second argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dae9460a51adde13fd535bc1aee22f1354a6ed7b" translate="yes" xml:space="preserve">
          <source>The second element is a keyword list containing metadata, like numbers and contexts;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09930d4769fdab8c631461548dda5978d0ffac47" translate="yes" xml:space="preserve">
          <source>The second element of the tuple represents metadata.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49369ce9190f9083bafea50347ba1f7b69ded63d" translate="yes" xml:space="preserve">
          <source>The second flaw is related to the supervision strategy. If &lt;code&gt;KV.Registry&lt;/code&gt; dies, all information linking &lt;code&gt;KV.Bucket&lt;/code&gt; names to bucket processes is lost. Therefore the &lt;code&gt;KV.BucketSupervisor&lt;/code&gt; and all children must terminate too - otherwise we will have orphan processes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b27ec208e18d1eae9448f08cbc57e44112bc1f3" translate="yes" xml:space="preserve">
          <source>The second is to make sure your &lt;a href=&quot;#import_config/1&quot;&gt;&lt;code&gt;import_config/1&lt;/code&gt;&lt;/a&gt; calls do not have a wildcard character. If so, you need to perform the wildcard lookup manually. For example, if you did:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03c8c69c3a8917dcc36201eb8826bb675ed3a306" translate="yes" xml:space="preserve">
          <source>The second part, the guards, is a list of conditions that allow filtering the results. Each guard is a tuple, which describes checks that should be passed by assigned part of pattern. For example the &lt;code&gt;$1 &amp;gt; 1&lt;/code&gt; guard condition would be expressed as the &lt;code&gt;{:&amp;gt;, :&quot;$1&quot;, 1}&lt;/code&gt; tuple. Please note that guard conditions will work only for assigned variables like &lt;code&gt;:&quot;$1&quot;&lt;/code&gt;, &lt;code&gt;:&quot;$2&quot;&lt;/code&gt;, etc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8279ae6c0770b2c5c483279a964f5a0fd686e18a" translate="yes" xml:space="preserve">
          <source>The second pitfall is that the &lt;code&gt;|&amp;gt;&lt;/code&gt; operator works on calls. For example, when you write:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="494117d2d88c4ce9741e6ac16716fddbb8f4cbe4" translate="yes" xml:space="preserve">
          <source>The second principle is to provide as little configuration as possible. This eases the formatter adoption by removing contention points while making sure a single style is followed consistently by the community as a whole.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="661a367f5412305ec9e82e19ba1e4e566dc26d28" translate="yes" xml:space="preserve">
          <source>The second test checks that the code raises for unknown entries.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8cd7d01257f835cc5a3247359bf87ad73936ce2f" translate="yes" xml:space="preserve">
          <source>The server is now running, and you will even notice the console is blocked. Let&amp;rsquo;s use &lt;a href=&quot;https://en.wikipedia.org/wiki/Telnet&quot;&gt;a &lt;code&gt;telnet&lt;/code&gt; client&lt;/a&gt; to access our server. There are clients available on most operating systems, and their command lines are generally similar:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd585ae8b1d0205e194512ad32642a694a88c604" translate="yes" xml:space="preserve">
          <source>The server reference.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d40bf167b8d71e1dda39cd357ab868e4586251d2" translate="yes" xml:space="preserve">
          <source>The server responsibilities include:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff65793db264093aa3a7a1cf46e0cbfc1e4b8a04" translate="yes" xml:space="preserve">
          <source>The setup callbacks are defined via macros and each one can optionally receive a map with test state and metadata, usually referred to as &lt;code&gt;context&lt;/code&gt;. The context to be used in the tests can be optionally extended by the setup callbacks by returning a properly structured value (see below).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be70f07b576f3a68fa738cef7302c8e28346ebfb" translate="yes" xml:space="preserve">
          <source>The shutdown process happens in reverse order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a344948a2691ee6269fc2879136d40e4dca1f373" translate="yes" xml:space="preserve">
          <source>The size can be a variable:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8111a6aa75f3c6e4735d59b2e853a7faeadebe29" translate="yes" xml:space="preserve">
          <source>The size of a map is the number of key-value pairs that the map contains.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0078ede4075127860c2ade218ba7d232c2981cd7" translate="yes" xml:space="preserve">
          <source>The snippet above only works because numbers implement the &lt;code&gt;String.Chars&lt;/code&gt; protocol. Passing a tuple, for example, will lead to an error:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6272c1202f90648d2a2419029598638bd1dd5c26" translate="yes" xml:space="preserve">
          <source>The solution is to provide configuration as close as possible to where it is used and not via the application environment. In case of a function, you could expect keyword lists as a new argument:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c2456d942f9ee207983a501b269e82c8ae7c4b6" translate="yes" xml:space="preserve">
          <source>The sorting algorithm will be stable as long as the given function returns &lt;code&gt;true&lt;/code&gt; for values considered equal:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="972944894d27378714ceb941dffde3e2074c4f7f" translate="yes" xml:space="preserve">
          <source>The spec also provides a &lt;code&gt;&amp;lt;Medial&amp;gt;&lt;/code&gt; set but Elixir does not include any character on this set. Therefore the identifier rule has been simplified to consider this.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc80cf8cc0e875b59d4cb7a74f58a13e82e8e79b" translate="yes" xml:space="preserve">
          <source>The stack is a small wrapper around lists. It allows us to put an element on the top of the stack, by prepending to the list, and to get the top of the stack by pattern matching.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="464d44c8fa9af2bc062b88f7cb6e09d51921375c" translate="yes" xml:space="preserve">
          <source>The standard library</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c90a34e2afaa39e30146b58a596138ac46c6ee44" translate="yes" xml:space="preserve">
          <source>The steps necessary to work across nodes is already commented out as an example. You can enable full distribution by uncommenting the last two lines by removing the leading &lt;code&gt;# &lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6547b77a17d5ef12542c7afee97cc798fc8b1249" translate="yes" xml:space="preserve">
          <source>The stream implements both &lt;a href=&quot;enumerable&quot;&gt;&lt;code&gt;Enumerable&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;collectable&quot;&gt;&lt;code&gt;Collectable&lt;/code&gt;&lt;/a&gt; protocols, which means it can be used both for read and write.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0a2b7409cbfc04d5907be0d98cbcaddcde54753" translate="yes" xml:space="preserve">
          <source>The string between the parentheses in the prompt is the name of your node. We can retrieve it by calling the &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#node/0&quot;&gt;&lt;code&gt;node/0&lt;/code&gt;&lt;/a&gt; function:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81e25ea527122c6269507a786b1fac990f5269a4" translate="yes" xml:space="preserve">
          <source>The string concatenation makes the code fit on a single line and also gives more options to the formatter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86cdec7e4462e9309a1a4eb1db8bbf7175736e0b" translate="yes" xml:space="preserve">
          <source>The string concatenation operation is actually a binary concatenation operator:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8259167cccd8df309147297c84a34df6a1de5df3" translate="yes" xml:space="preserve">
          <source>The string is split into as many parts as possible by default, but can be controlled via the &lt;code&gt;:parts&lt;/code&gt; option.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff34135d2b9fe9bf18a8b4692de3737dabb31735" translate="yes" xml:space="preserve">
          <source>The struct fields are private and should not be accessed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="571837e3b232d92d474e8917fdedc1786ba58276" translate="yes" xml:space="preserve">
          <source>The struct fields can be given when building the struct:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92bf51de3e3e5df1170754020b84a38130fd526e" translate="yes" xml:space="preserve">
          <source>The supervision strategy dictates what happens when one of the children crashes. &lt;code&gt;:one_for_one&lt;/code&gt; means that if a child dies, it will be the only one restarted. Since we have only one child now, that&amp;rsquo;s all we need. The &lt;code&gt;Supervisor&lt;/code&gt; behaviour supports many different strategies and we will discuss them in this chapter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d45ea759f46bff3ba089e89707b504285b2e2aff" translate="yes" xml:space="preserve">
          <source>The supervisor flags returned on init</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3742ff69698c4acf77e80f28496fe07172ab4b1" translate="yes" xml:space="preserve">
          <source>The supervisor reference</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5aec5d17ff71d8a46be456b119441ed148f52e07" translate="yes" xml:space="preserve">
          <source>The supervisor specification</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55243bfac4a971c230124af0cb70d274159f15f1" translate="yes" xml:space="preserve">
          <source>The supervisor will then invoke &lt;code&gt;Stack.child_spec([:hello])&lt;/code&gt; to retrieve a child specification. Now the &lt;code&gt;Stack&lt;/code&gt; module is responsible for building its own specification, for example, we could write:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48df4bde49257478d542a437f9de2f0a2ea29a61" translate="yes" xml:space="preserve">
          <source>The supported class names are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2acb742979d49cdd1ce894f691b11d6c69ead543" translate="yes" xml:space="preserve">
          <source>The supported forms are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8f9a7d8961a3767298fcfbab64cbbb6e0e6ee0b" translate="yes" xml:space="preserve">
          <source>The supported keys in the &lt;code&gt;:colors&lt;/code&gt; keyword list are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7878d33057652c5e4e57d591e83ecedf612c203" translate="yes" xml:space="preserve">
          <source>The supported levels, ordered by precedence, are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db2280a174b18020a2620736642518bf66a11dab" translate="yes" xml:space="preserve">
          <source>The supported options are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a909fba4eceb102c979e5e9c2b15d4702c456bf4" translate="yes" xml:space="preserve">
          <source>The syntax Elixir provides for type specifications is similar to &lt;a href=&quot;http://www.erlang.org/doc/reference_manual/typespec.html&quot;&gt;the one in Erlang&lt;/a&gt;. Most of the built-in types provided in Erlang (for example, &lt;code&gt;pid()&lt;/code&gt;) are expressed in the same way: &lt;code&gt;pid()&lt;/code&gt; (or simply &lt;code&gt;pid&lt;/code&gt;). Parameterized types (such as &lt;code&gt;list(integer)&lt;/code&gt;) are supported as well and so are remote types (such as &lt;code&gt;Enum.t&lt;/code&gt;). Integers and atom literals are allowed as types (e.g., &lt;code&gt;1&lt;/code&gt;, &lt;code&gt;:atom&lt;/code&gt;, or &lt;code&gt;false&lt;/code&gt;). All other types are built out of unions of predefined types. Some shorthands are allowed, such as &lt;code&gt;[...]&lt;/code&gt;, &lt;code&gt;&amp;lt;&amp;lt;&amp;gt;&amp;gt;&lt;/code&gt;, and &lt;code&gt;{...}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d0036cfb43509daaf5a87c862104d3f9568ed85" translate="yes" xml:space="preserve">
          <source>The syntax above requires the given key to exist. It cannot be used to add new keys. For example, using it with the &lt;code&gt;:c&lt;/code&gt; key failed because there is no &lt;code&gt;:c&lt;/code&gt; in the map.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e74604ffed887af469a3ff79efc01a49993440e8" translate="yes" xml:space="preserve">
          <source>The syntax above will guarantee the given keys are valid at compilation time and it will guarantee at runtime the given argument is a struct, failing with &lt;a href=&quot;badstructerror&quot;&gt;&lt;code&gt;BadStructError&lt;/code&gt;&lt;/a&gt; otherwise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15e9fc5e9c4c2be91d093aa25daa8c7249775f24" translate="yes" xml:space="preserve">
          <source>The tail elements of aliases are guaranteed to always be atoms.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0bcdf2274bc91e89bdf8524fe117cd1e390a0aae" translate="yes" xml:space="preserve">
          <source>The task can now be invoked with &lt;code&gt;mix hello&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60d7de295785ea0605333a1eba6bb25d621b6acc" translate="yes" xml:space="preserve">
          <source>The terms are only considered to be exactly equal if they have the same value and are of the same type. For example, &lt;code&gt;1 == 1.0&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;, but since they are of different types, &lt;code&gt;1 === 1.0&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="705df9c2e6adef6ee615fd1500b80411120b3a6b" translate="yes" xml:space="preserve">
          <source>The test above will fail on the last assertion as the bucket name remains in the registry even after we stop the bucket process.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2570223385e731ad04d7b7880f45f2e4a73c2ce4" translate="yes" xml:space="preserve">
          <source>The test is similar to &amp;ldquo;removes bucket on exit&amp;rdquo; except that we are being a bit more harsh by sending &lt;code&gt;:shutdown&lt;/code&gt; as the exit reason instead of &lt;code&gt;:normal&lt;/code&gt;. If a process terminates with a reason different than &lt;code&gt;:normal&lt;/code&gt;, all linked processes receive an EXIT signal, causing the linked process to also terminate unless it is trapping exits.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bdde6c13039b2d4b85652376fce95fabfa20deef" translate="yes" xml:space="preserve">
          <source>The test should pass.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3bf29b425a5cead446e53e0022f0fce0236e0195" translate="yes" xml:space="preserve">
          <source>The test type will be converted to a string and pluralized for display. You can use &lt;a href=&quot;exunit#plural_rule/2&quot;&gt;&lt;code&gt;ExUnit.plural_rule/2&lt;/code&gt;&lt;/a&gt; to set a custom pluralization.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a927d1705beb862013fa4736d80e7112683437e5" translate="yes" xml:space="preserve">
          <source>The third approach uses macros, and is by far the most complex. It will take more lines of code to implement, it is hard and expensive to test (compared to testing simple functions), and it limits how the user may use the library since all validations need to be defined inside a module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d45004d92cd0fa8dd37a67dc40c34ac5fe7a8f6" translate="yes" xml:space="preserve">
          <source>The third argument given to &lt;a href=&quot;#register/3&quot;&gt;&lt;code&gt;register/3&lt;/code&gt;&lt;/a&gt; is a value associated to the current process. While in the previous section we used it when dispatching, in this particular example we are not interested in it, so we have set it to an empty list. You could store a more meaningful value if necessary.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="286a4f81139162ba612e0fc78d910245b92506ae" translate="yes" xml:space="preserve">
          <source>The third argument is the stacktrace which is used to enrich a normalized error with more information. It is only used when the kind is an error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0469bb3fc164355009dcbe32b659229c5de7434" translate="yes" xml:space="preserve">
          <source>The third element is either a list of arguments for the function call or an atom. When this element is an atom, it means the tuple represents a variable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61d0bd68d9312dd1a2b6bc353f3631650af592e9" translate="yes" xml:space="preserve">
          <source>The third element of the tuple are the arguments for the function call. The third argument may be an atom, which is usually a variable (or a local call).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e03e20762e8bbf0a5e287057fa9da1be08a2ebb0" translate="yes" xml:space="preserve">
          <source>The third part, the body, is a list of shapes of the returned entries. Like guards, you have access to assigned variables like &lt;code&gt;:&quot;$1&quot;&lt;/code&gt;, which you can combine with hardcoded values to freely shape entries Note that tuples have to be wrapped in an additional tuple. To get a result format like &lt;code&gt;%{key: key, pid: pid, value: value}&lt;/code&gt;, assuming you bound those variables in order in the match part, you would provide a body like &lt;code&gt;[%{key: :&quot;$1&quot;, pid: :&quot;$2&quot;, value: :&quot;$3&quot;}]&lt;/code&gt;. Like guards, you can use some operations like &lt;code&gt;:element&lt;/code&gt; to modify the output format.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd8a93e3bf717eed4a2e3026f8f31870641fb464" translate="yes" xml:space="preserve">
          <source>The time functions in this module work in the &lt;code&gt;:native&lt;/code&gt; unit (unless specified otherwise), which is operating system dependent. Most of the time, all calculations are done in the &lt;code&gt;:native&lt;/code&gt; unit, to avoid loss of precision, with &lt;a href=&quot;#convert_time_unit/3&quot;&gt;&lt;code&gt;convert_time_unit/3&lt;/code&gt;&lt;/a&gt; being invoked at the end to convert to a specific time unit like &lt;code&gt;:millisecond&lt;/code&gt; or &lt;code&gt;:microsecond&lt;/code&gt;. See the &lt;a href=&quot;#t:time_unit/0&quot;&gt;&lt;code&gt;time_unit/0&lt;/code&gt;&lt;/a&gt; type for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c81a5f56c30620f4ca3fdbd7994e540bcd3307ec" translate="yes" xml:space="preserve">
          <source>The time type returned in &lt;code&gt;atime&lt;/code&gt;, &lt;code&gt;mtime&lt;/code&gt;, and &lt;code&gt;ctime&lt;/code&gt; is dependent on the time type set in options. &lt;code&gt;{:time, type}&lt;/code&gt; where type can be &lt;code&gt;:local&lt;/code&gt;, &lt;code&gt;:universal&lt;/code&gt;, or &lt;code&gt;:posix&lt;/code&gt;. Default is &lt;code&gt;:universal&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ccc7b51abb959b7b6a642bc36ea122d38002d9a" translate="yes" xml:space="preserve">
          <source>The time unit to be passed to functions like &lt;a href=&quot;#monotonic_time/1&quot;&gt;&lt;code&gt;monotonic_time/1&lt;/code&gt;&lt;/a&gt; and others.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1bbd3b4515f159eff3b51909840a9c295b77b423" translate="yes" xml:space="preserve">
          <source>The time zone ID according to the IANA tz database (e.g. Europe/Zurich)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b125596c86be66bad3036f66746716d52648f027" translate="yes" xml:space="preserve">
          <source>The time zone UTC offset in seconds</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a33e0326e0255c69b66326b76b995f67cc50bc7" translate="yes" xml:space="preserve">
          <source>The time zone abbreviation (e.g. CET or CEST or BST etc.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fcad795376e4abb458cc8e3841c41b9eba5c998c" translate="yes" xml:space="preserve">
          <source>The time zone standard offset in seconds (not zero in summer times)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cce73f4a8a7c3c6d7d87f75bc5aa727351d2f2f2" translate="yes" xml:space="preserve">
          <source>The timer will be automatically canceled if the given &lt;code&gt;dest&lt;/code&gt; is a PID which is not alive or when the given PID exits. Note that timers will not be automatically canceled when &lt;code&gt;dest&lt;/code&gt; is an atom (as the atom resolution is done on delivery).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95f67c03b8dd416c9af30e47423ea3401d29e99a" translate="yes" xml:space="preserve">
          <source>The trait can be one of two options:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c51e1e67805ed16c58e9c1e802e36335ea6aca4" translate="yes" xml:space="preserve">
          <source>The trouble with state</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1d02c2f92fc207d7072d19d88bfe702734e4f16" translate="yes" xml:space="preserve">
          <source>The tuple above represents a function call to &lt;code&gt;sum&lt;/code&gt; passing 1, 2 and 3 as arguments. The tuple elements are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0be32613fcd0e0034d6c53c421573b087961e380" translate="yes" xml:space="preserve">
          <source>The two syntaxes are completely equivalent. Like atoms, keywords must be composed of Unicode characters such as letters, numbers, underscore, and &lt;code&gt;@&lt;/code&gt;. If the keyword has a character that does not belong to the category above, such as spaces, you can wrap it in quotes:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7bf824f894b5901f732af99ee1c6741c2c8f9460" translate="yes" xml:space="preserve">
          <source>The two syntaxes for accessing keys reveal the dual nature of maps. The &lt;code&gt;map[key]&lt;/code&gt; syntax is used for dynamically created maps that may have any key, of any type. &lt;code&gt;map.key&lt;/code&gt; is used with maps that hold a predetermined set of atoms keys, which are expected to always be present. Structs, defined via &lt;a href=&quot;kernel#defstruct/1&quot;&gt;&lt;code&gt;defstruct/1&lt;/code&gt;&lt;/a&gt;, are one example of such &quot;static maps&quot;, where the keys can also be checked during compile time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27b2df44172f3a57aa97a9d731e7cf407e529ef4" translate="yes" xml:space="preserve">
          <source>The type of keys allowed on registration</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2981849bde4b665272891869623a6b0939beaaa5" translate="yes" xml:space="preserve">
          <source>The type of registry metadata keys</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b222464dab205a6bd54b94d0bb3729d611af5dc" translate="yes" xml:space="preserve">
          <source>The type of registry metadata values</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d6b108d320c16acf0d32c924ccacb139089d8c7" translate="yes" xml:space="preserve">
          <source>The type of the registry</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53279e10023dca8a2288968b9bcf710b0c986964" translate="yes" xml:space="preserve">
          <source>The type of values allowed on registration</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96d309a1ca8c9b49d61652c9574ee5761b49d46b" translate="yes" xml:space="preserve">
          <source>The types &lt;code&gt;String.t()&lt;/code&gt; and &lt;code&gt;binary()&lt;/code&gt; are equivalent to analysis tools. Although, for those reading the documentation, &lt;code&gt;String.t()&lt;/code&gt; implies it is a UTF-8 encoded binary.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb8c250a62b4261ebc510b4a71573c121311d0bb" translate="yes" xml:space="preserve">
          <source>The types of the struct fields that are not included in &lt;code&gt;%User{}&lt;/code&gt; default to &lt;code&gt;term()&lt;/code&gt; (see &lt;a href=&quot;typespecs#built-in-types&quot;&gt;&lt;code&gt;term/0&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b47b534c105a2118838e65f4bd8f13e6c75b738" translate="yes" xml:space="preserve">
          <source>The unit can also be an integer as in &lt;a href=&quot;system#t:time_unit/0&quot;&gt;&lt;code&gt;System.time_unit/0&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a447ce422905d13f06edc954109b01bb1211f3ed" translate="yes" xml:space="preserve">
          <source>The unreachable and deprecated checks below happen every time your project is compiled via &lt;a href=&quot;mix.tasks.compile.xref&quot;&gt;&lt;code&gt;mix compile.xref&lt;/code&gt;&lt;/a&gt;. See &lt;a href=&quot;mix.tasks.compile.xref&quot;&gt;&lt;code&gt;Mix.Tasks.Compile.Xref&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f350c7b62e10906702ea9465bc4c4e8ee009110d" translate="yes" xml:space="preserve">
          <source>The usage of &lt;code&gt;:ok&lt;/code&gt;/&lt;code&gt;:error&lt;/code&gt; tuples is about the domain that the function works on, in this case, file system access. Bad arguments, logical errors, invalid options should raise regardless of the function name. If in doubt, prefer to return tuples instead of raising, as users of your library can always match on the results and raise if necessary.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2761fc5ed5c6c550d3c3f11fa24ee7951107bd4" translate="yes" xml:space="preserve">
          <source>The user must press Enter or type one of &quot;y&quot;, &quot;yes&quot;, &quot;Y&quot;, &quot;YES&quot; or &quot;Yes&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="067adddb8899b26a44c6d119cc5060679343ac3f" translate="yes" xml:space="preserve">
          <source>The valid parameters you can use are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e5fe130617142d21e815f74a253669918514b41" translate="yes" xml:space="preserve">
          <source>The value emitted is &lt;code&gt;0&lt;/code&gt;. This operation will block the caller by the given time until the element is streamed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d90bdb7c5d59a88b306900023f5ca84001349ca6" translate="yes" xml:space="preserve">
          <source>The value is a keyword list with two possible keys representing prompt types:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="caa6577865e36568b3711626c14e00f9b424ae56" translate="yes" xml:space="preserve">
          <source>The value is no longer a binary, but a bitstring &amp;ndash; a bunch of bits! So a binary is a bitstring where the number of bits is divisible by 8.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3cc68a54cd0dbc959bc6164a6a2b53075dfa30ea" translate="yes" xml:space="preserve">
          <source>The values emitted are an increasing counter starting at &lt;code&gt;0&lt;/code&gt;. This operation will block the caller by the given interval every time a new element is streamed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be1b57a18ace41fb8f93930afe8b1ad887b40d1d" translate="yes" xml:space="preserve">
          <source>The values for &lt;code&gt;:case&lt;/code&gt; can be:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a8416871ca07e4a4f59fb2e54024c09ce510c3d" translate="yes" xml:space="preserve">
          <source>The values for &lt;code&gt;:padding&lt;/code&gt; can be:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48b014b54ab14e39b32c6219693fd725eede8847" translate="yes" xml:space="preserve">
          <source>The values for &lt;code&gt;:time&lt;/code&gt; can be:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21f3f4f945d9026f4fff4e43f08cf7f4707e46e4" translate="yes" xml:space="preserve">
          <source>The variable &lt;code&gt;_&lt;/code&gt; is special in that it can never be read from. Trying to read from it gives a compile error:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e1be81239623e7fbf2a82d7e2a4f2b80599067d" translate="yes" xml:space="preserve">
          <source>The variables defined inside &lt;code&gt;quote&lt;/code&gt; won't be available during prying due to the hygiene mechanism in quoted expressions. The hygiene mechanism changes the variable names in quoted expressions so they don't collide with variables defined by the users of the macros. Therefore the original names are not available.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d0b621f78879c76c317ddf557989e7b4d0a18c9" translate="yes" xml:space="preserve">
          <source>The version is represented by the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Version&lt;/code&gt;&lt;/a&gt; struct and fields are named according to SemVer: &lt;code&gt;:major&lt;/code&gt;, &lt;code&gt;:minor&lt;/code&gt;, &lt;code&gt;:patch&lt;/code&gt;, &lt;code&gt;:pre&lt;/code&gt;, and &lt;code&gt;:build&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64e09f157d5e5070ea793feca6351f0810f54544" translate="yes" xml:space="preserve">
          <source>The version without &lt;code&gt;!&lt;/code&gt; is preferred when you want to handle different outcomes using pattern matching:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2528fcfa71e426e6f186925ba5d183a72e0825f" translate="yes" xml:space="preserve">
          <source>The wildcard looks like an ordinary path, except that the following &quot;wildcard characters&quot; are interpreted in a special way:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0fcbc9b2e71d94abc862c5aacc86295bf5f87ef7" translate="yes" xml:space="preserve">
          <source>The year parsed by this function is limited to four digits and, while ISO 8601 allows datetimes to specify 24:00:00 as the zero hour of the next day, this notation is not supported by Elixir. Note leap seconds are not supported by the built-in Calendar.ISO.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43359a56ca5b9f74f8ed54225f235a4eac841d33" translate="yes" xml:space="preserve">
          <source>The year parsed by this function is limited to four digits.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42c8fd279491ba3a5a79a3fc57c18b896f2e8d7e" translate="yes" xml:space="preserve">
          <source>The zip and zlib modules</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a928b0d99e54733f051669ca9f28257ad67f0a00" translate="yes" xml:space="preserve">
          <source>The zipping finishes as soon as any enumerable completes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92c61e8c081422e6cb087e5091e2eef8743332a7" translate="yes" xml:space="preserve">
          <source>The zipping finishes as soon as any enumerable in the given collection completes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5390d109c8d9531238497e8770981143c5154c71" translate="yes" xml:space="preserve">
          <source>The zipping finishes as soon as any list terminates.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b625dd872916e65cdac731dbaa58c2540d9b95a9" translate="yes" xml:space="preserve">
          <source>Then we define a &lt;code&gt;start_link/1&lt;/code&gt; function, which will effectively start the agent. It is a convention to define a &lt;code&gt;start_link/1&lt;/code&gt; function that always accepts a list of options. We don&amp;rsquo;t plan on using any options right now, but we might later on. We then proceed to call &lt;code&gt;Agent.start_link/1&lt;/code&gt;, which receives an anonymous function that returns the Agent&amp;rsquo;s initial state.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9efffd6370bf177135cf0838aedef8c490edaff" translate="yes" xml:space="preserve">
          <source>Then when specifying your release, you can specify the provider:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90be63383bb86c2a9b4266d11b3e7f59bb1305ef" translate="yes" xml:space="preserve">
          <source>Then, we add the head of the list to the accumulator &lt;code&gt;head + accumulator&lt;/code&gt; and call &lt;code&gt;sum_list&lt;/code&gt; again, recursively, passing the tail of the list as its first argument. The tail will once again match &lt;code&gt;[head | tail]&lt;/code&gt; until the list is empty, as seen below:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b87f84651e39aeea5d926774256f894a29c7180" translate="yes" xml:space="preserve">
          <source>Then, whenever desired, those tests could be included in the run via the &lt;code&gt;--include&lt;/code&gt; option:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b194d7af362d9259824b1fbfd5de6ca884c3d2da" translate="yes" xml:space="preserve">
          <source>There are a couple of ways to retrieve a character integer code point. One may use the &lt;code&gt;?&lt;/code&gt; construct:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1fd8e7b8f98e5336f83be9a7d713b450297e94ab" translate="yes" xml:space="preserve">
          <source>There are a couple other options here. One option is to spawn the distributed node programmatically at the beginning of &lt;code&gt;test/test_helper.exs&lt;/code&gt;. Erlang/OTP does provide APIs for doing so, but they are non-trivial and therefore we won&amp;rsquo;t cover them here.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c36172e9cd5c05c77e84149217392745df0757dd" translate="yes" xml:space="preserve">
          <source>There are a few attributes available in Mix tasks to configure them in Mix:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29207daf154a421b800aeacb77caf5c5eb506793" translate="yes" xml:space="preserve">
          <source>There are a few suitable alternatives to replace GenEvent. Each of them can be the most beneficial based on the use case.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10bcc082a2d994b16cb89b80b77c2f9140673c29" translate="yes" xml:space="preserve">
          <source>There are a few ways to quit the IEx shell:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d8ce000a8dc139890c07c24e80b5de5ae99f4f0" translate="yes" xml:space="preserve">
          <source>There are a number of customization options provided by IEx. Take a look at the docs for the &lt;a href=&quot;iex#configure/1&quot;&gt;&lt;code&gt;IEx.configure/1&lt;/code&gt;&lt;/a&gt; function by typing &lt;code&gt;h IEx.configure/1&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09d8b4775b01e8f623175d798409cd369f28544b" translate="yes" xml:space="preserve">
          <source>There are a number of ways to debug code in Elixir. In this chapter we will cover some of the more common ways of doing so.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa57737d9360fbe5afeae180cdd5ea0fce51697c" translate="yes" xml:space="preserve">
          <source>There are additional macros for other levels.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a57a74b23748fb93cbfac3d76920a5b6c297f9f8" translate="yes" xml:space="preserve">
          <source>There are also other known problems like flooring or rounding numbers. See &lt;a href=&quot;#round/2&quot;&gt;&lt;code&gt;round/2&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#floor/2&quot;&gt;&lt;code&gt;floor/2&lt;/code&gt;&lt;/a&gt; for more details about them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e4e195bc2fdfc89b8bda777699ef0647f0c7ff7" translate="yes" xml:space="preserve">
          <source>There are also some non-paired functions, with no non-bang variant. The bang still signifies that it will raise an exception on failure. Example: &lt;a href=&quot;protocol#assert_protocol!/1&quot;&gt;&lt;code&gt;Protocol.assert_protocol!/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae5ae6e32d973b8c6e5e16938f53a6274e7ce3ca" translate="yes" xml:space="preserve">
          <source>There are currently no plans for a major v2 release.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70fbc19347af9335ddb73d64b97e33f72c2ab414" translate="yes" xml:space="preserve">
          <source>There are functions related to floating-point numbers on the &lt;a href=&quot;kernel&quot;&gt;&lt;code&gt;Kernel&lt;/code&gt;&lt;/a&gt; module too. Here is a list of them:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0447596598be1689749a73489423ead2b26c8b89" translate="yes" xml:space="preserve">
          <source>There are many functions in Elixir's standard library that return streams, some examples are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87db69fabab6d8aebc72fcaa67f0f5d2378adab2" translate="yes" xml:space="preserve">
          <source>There are many other helpers available, here are some examples:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="926409681cd9a91dbce4de89116e3485c968a501" translate="yes" xml:space="preserve">
          <source>There are many situations where using the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; module can be avoided in favor of binary functions or pattern matching. For example, imagine you have a string &lt;code&gt;prefix&lt;/code&gt; and you want to remove this prefix from another string named &lt;code&gt;full&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8989cd7033f2099b81956882184639864ede98b" translate="yes" xml:space="preserve">
          <source>There are no guarantees about the order of keys in the returned keyword.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54c0f70e4a42a4d0d67a77196f05623f3bcdb80e" translate="yes" xml:space="preserve">
          <source>There are other protocols in Elixir but this covers the most common ones.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3101471cbaca1a87da38ada818ec10b102a0a294" translate="yes" xml:space="preserve">
          <source>There are other tuple formats both &lt;code&gt;handle_call/3&lt;/code&gt; and &lt;code&gt;handle_cast/2&lt;/code&gt; callbacks may return. There are also other callbacks like &lt;code&gt;terminate/2&lt;/code&gt; and &lt;code&gt;code_change/3&lt;/code&gt; that we could implement. You are welcome to explore the &lt;a href=&quot;https://hexdocs.pm/elixir/GenServer.html&quot;&gt;full GenServer documentation&lt;/a&gt; to learn more about those.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c6bd7329e736075fbed60e12572ebdf4871cb55" translate="yes" xml:space="preserve">
          <source>There are probably many more to come too!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eabb9c46f92e64d3211aa2057e1cb64ad70409b3" translate="yes" xml:space="preserve">
          <source>There are some modules that Elixir does not currently implement but it may be implement in the future. Those modules are reserved and defining them will result in a compilation error:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb77960230e6dd3139afa82409f2f1ffc3a5c2e5" translate="yes" xml:space="preserve">
          <source>There are some very well known problems with floating-point numbers and arithmetics due to the fact most decimal fractions cannot be represented by a floating-point binary and most operations are not exact, but operate on approximations. Those issues are not specific to Elixir, they are a property of floating point representation itself.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3154b8cdccf8ec261d752f5f3690d9739db0824" translate="yes" xml:space="preserve">
          <source>There are three better alternatives to &lt;code&gt;Node.spawn_link/2&lt;/code&gt; that we could use in our implementation:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a011fd8fc19265bbdfa804b9e46482377afe2df" translate="yes" xml:space="preserve">
          <source>There are three callbacks that are invoked when functions are defined, as well as before and immediately after the module bytecode is generated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0cff0a96056604973d2ce970f4952a288926525" translate="yes" xml:space="preserve">
          <source>There are three main use cases for not replying using the return value:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="adbd396ed0556c8293f2a87ae93d14c10746024c" translate="yes" xml:space="preserve">
          <source>There are two APIs for working with ports. It can be either asynchronous via message passing, as in the example above, or by calling the functions on this module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="701240237d3a52a3d32e044be779f88e8b80021f" translate="yes" xml:space="preserve">
          <source>There are two common pitfalls when using the pipe operator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="406dbf0d435a200ca4cabd1441349a8cdaeded38" translate="yes" xml:space="preserve">
          <source>There are two concerns in this approach.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5cac6c30b6750da044a369458652387600eab8a0" translate="yes" xml:space="preserve">
          <source>There are two data types without an accompanying module:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b081e88ef54c7ae6048998f8dea958b729c0be39" translate="yes" xml:space="preserve">
          <source>There are two important things to consider when using &lt;code&gt;async&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a03d1dfcb5538f40d22abd10d512a80d2c451bc1" translate="yes" xml:space="preserve">
          <source>There are two topics left before we move on to the next chapter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6bcf7cf68be2f9527622d710936107d32e56ffb" translate="yes" xml:space="preserve">
          <source>There are two types of captured functions: &lt;strong&gt;external&lt;/strong&gt; and &lt;strong&gt;local&lt;/strong&gt;. External functions are functions residing in modules that are captured with &lt;a href=&quot;kernel.specialforms#&amp;amp;/1&quot;&gt;&lt;code&gt;&amp;amp;/1&lt;/code&gt;&lt;/a&gt;, such as &lt;code&gt;&amp;amp;String.length/1&lt;/code&gt;. Local functions are anonymous functions defined with &lt;a href=&quot;kernel.specialforms#fn/1&quot;&gt;&lt;code&gt;fn/1&lt;/code&gt;&lt;/a&gt; or with the capture operator &lt;a href=&quot;kernel.specialforms#&amp;amp;/1&quot;&gt;&lt;code&gt;&amp;amp;/1&lt;/code&gt;&lt;/a&gt; using &lt;code&gt;&amp;amp;1&lt;/code&gt;, &lt;code&gt;&amp;amp;2&lt;/code&gt;, and so on as replacements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71487477c04c1e20b0a1c8eb6cde1dc3cb98c687" translate="yes" xml:space="preserve">
          <source>There are two types of requests you can send to a GenServer: calls and casts. Calls are synchronous and the server &lt;strong&gt;must&lt;/strong&gt; send a response back to such requests. While the server computes the response, the client is &lt;strong&gt;waiting&lt;/strong&gt;. Casts are asynchronous: the server won&amp;rsquo;t send a response back and therefore the client won&amp;rsquo;t wait for one. Both requests are messages sent to the server, and will be handled in sequence. In the above implementation, we pattern-match on the &lt;code&gt;:create&lt;/code&gt; messages, to be handled as cast, and on the &lt;code&gt;:lookup&lt;/code&gt; messages, to be handled as call.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c9ea73ebc91f0affdf337778b29e743e68daec7" translate="yes" xml:space="preserve">
          <source>There exists an additional way to simplify a chain of &lt;code&gt;or&lt;/code&gt;s in guards: Elixir supports writing &quot;multiple guards&quot; in the same clause. This:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36182dc39abbf8ba08b014521f410bb7023fa49b" translate="yes" xml:space="preserve">
          <source>There is a sixth key, &lt;code&gt;:modules&lt;/code&gt;, that is rarely changed. It is set automatically based on the value in &lt;code&gt;:start&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cacb5192e79338de26b6ff207a8ab99cd8a36150" translate="yes" xml:space="preserve">
          <source>There is also a deprecated strategy called &lt;code&gt;:simple_one_for_one&lt;/code&gt; which has been replaced by the &lt;a href=&quot;dynamicsupervisor&quot;&gt;&lt;code&gt;DynamicSupervisor&lt;/code&gt;&lt;/a&gt;. The &lt;code&gt;:simple_one_for_one&lt;/code&gt; supervisor was similar to &lt;code&gt;:one_for_one&lt;/code&gt; but suits better when dynamically attaching children. Many functions in this module behaved slightly differently when this strategy was used. See the &lt;a href=&quot;dynamicsupervisor&quot;&gt;&lt;code&gt;DynamicSupervisor&lt;/code&gt;&lt;/a&gt; module for more information and migration strategies.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21605b424eea559d8c71a63a6ba5de9f7a6c7351" translate="yes" xml:space="preserve">
          <source>There is also a private function named &lt;code&gt;deps&lt;/code&gt;, which is invoked from the &lt;code&gt;project&lt;/code&gt; function, that defines our project dependencies. Defining &lt;code&gt;deps&lt;/code&gt; as a separate function is not required, but it helps keep the project configuration tidy.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb7b6e86fbf7b732fa4c4c68a1745621601d30ca" translate="yes" xml:space="preserve">
          <source>There is more to learn about &lt;code&gt;put_in/2&lt;/code&gt; and &lt;code&gt;update_in/2&lt;/code&gt;, including the &lt;code&gt;get_and_update_in/2&lt;/code&gt; that allows us to extract a value and update the data structure at once. There are also &lt;code&gt;put_in/3&lt;/code&gt;, &lt;code&gt;update_in/3&lt;/code&gt; and &lt;code&gt;get_and_update_in/3&lt;/code&gt; which allow dynamic access into the data structure. &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html&quot;&gt;Check their respective documentation in the &lt;code&gt;Kernel&lt;/code&gt; module for more information&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b4424ea8037c81012b4a89fa0c4119c6711e1c4" translate="yes" xml:space="preserve">
          <source>There is much more to Mix, and we will continue to explore it as we build our project. A &lt;a href=&quot;https://hexdocs.pm/mix/&quot;&gt;general overview is available on the Mix documentation&lt;/a&gt;. Read &lt;a href=&quot;https://github.com/elixir-lang/elixir/tree/master/lib/mix&quot;&gt;the Mix source code here&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="237778ff123bf6054865096a64c61845e79b8f82" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;try/rescue&lt;/code&gt; here. In case you want to handle multiple outcomes of opening a file, you can use pattern matching within the &lt;code&gt;case&lt;/code&gt; construct:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0bc74ac50000eb990e97f6493bd512424cfda40" translate="yes" xml:space="preserve">
          <source>There is one important difference between the &lt;code&gt;setup&lt;/code&gt; block we wrote for &lt;code&gt;KV.Registry&lt;/code&gt; and the one we wrote for &lt;code&gt;KV.Bucket&lt;/code&gt;. Instead of starting the registry by hand by calling &lt;code&gt;KV.Registry.start_link/1&lt;/code&gt;, we instead called &lt;a href=&quot;https://hexdocs.pm/ex_unit/ExUnit.Callbacks.html#start_supervised/2&quot;&gt;the &lt;code&gt;start_supervised!/2&lt;/code&gt; function&lt;/a&gt;, passing the &lt;code&gt;KV.Registry&lt;/code&gt; module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02df8421114d1f579a4430e4f56430c17c3fdd06" translate="yes" xml:space="preserve">
          <source>There is one project-level option that affects how the escript is generated:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="690ca402cdab5a8902f2e2787a305dd6116dc3d0" translate="yes" xml:space="preserve">
          <source>There is quite a bit more ceremony in the GenServer code but, as we will see, it brings some benefits too.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="868c9d3de02a9c397e5804f3e5b1beeb25227226" translate="yes" xml:space="preserve">
          <source>There isn't a comprehensive list of all the options that can be returned by &lt;code&gt;project/0&lt;/code&gt; since many Mix tasks define their own options that they read from this configuration. For example, look at the &quot;Configuration&quot; section in the documentation for the &lt;a href=&quot;mix.tasks.compile&quot;&gt;&lt;code&gt;Mix.Tasks.Compile&lt;/code&gt;&lt;/a&gt; task.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06cb32d59125a8444c6ab67709a472cedf77eb2d" translate="yes" xml:space="preserve">
          <source>There, &lt;code&gt;byte_size/1&lt;/code&gt; counts the underlying raw bytes, and &lt;code&gt;String.length/1&lt;/code&gt; counts characters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4307601f224307e22cd02454aa0b8b4d5545438a" translate="yes" xml:space="preserve">
          <source>Therefore it is not guaranteed that &lt;a href=&quot;#c:terminate/2&quot;&gt;&lt;code&gt;terminate/2&lt;/code&gt;&lt;/a&gt; is called when a &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt; exits. For such reasons, we usually recommend important clean-up rules to happen in separated processes either by use of monitoring or by links themselves. There is no cleanup needed when the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt; controls a &lt;code&gt;port&lt;/code&gt; (e.g. &lt;code&gt;:gen_tcp.socket&lt;/code&gt;) or &lt;a href=&quot;file#t:io_device/0&quot;&gt;&lt;code&gt;File.io_device/0&lt;/code&gt;&lt;/a&gt;, because these will be closed on receiving a &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt;'s exit signal and do not need to be closed manually in &lt;a href=&quot;#c:terminate/2&quot;&gt;&lt;code&gt;terminate/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4064ff8458c4f5d1958ee9109a3740ff3b2b0e6" translate="yes" xml:space="preserve">
          <source>Therefore, an Elixir developer prefers to &amp;ldquo;let it crash&amp;rdquo; or &amp;ldquo;fail fast&amp;rdquo;. And one of the most common ways we can recover from a failure is by restarting whatever part of the system crashed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67da13e4777f268949639e3941225f274f61e540" translate="yes" xml:space="preserve">
          <source>Therefore, if you don&amp;rsquo;t want to handle the error outcomes, prefer using &lt;code&gt;File.read!/1&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88ef416d8b169a4f47a3dda56e98187b8d57d742" translate="yes" xml:space="preserve">
          <source>Therefore, if you plan to compare multiple strings, multiple times in a row, you may normalize them upfront and compare them directly to avoid multiple normalization passes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5cb2ec194ba3355670294e9c457ea3adb567e875" translate="yes" xml:space="preserve">
          <source>Therefore, in order to minimize the distributed tests, let&amp;rsquo;s pick a routing table that does not require distribution. Then, for the distributed tests, we will programatically change the routing table. Back in &lt;code&gt;config/config.exs&lt;/code&gt;, add this line:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af72f8d5888562059c52cc4bad66a2a3aa2e8b0b" translate="yes" xml:space="preserve">
          <source>Therefore, this function is used to check if a module is loaded before using it and allows one to react accordingly. For example, the &lt;a href=&quot;uri&quot;&gt;&lt;code&gt;URI&lt;/code&gt;&lt;/a&gt; module uses this function to check if a specific parser exists for a given URI scheme.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d10b167c94497dff77b11dad17668b97ba38a48a" translate="yes" xml:space="preserve">
          <source>These are a few options that are not used by just one Mix task (and will thus be documented here):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41d198d3d66dfd7fa75bf909de01737698c3fc91" translate="yes" xml:space="preserve">
          <source>These are the reserved words in the Elixir language. They are detailed throughout this guide but summed up here for convenience:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26cd6bcff6d81ebade774a0f501e5b9a49a3141c" translate="yes" xml:space="preserve">
          <source>These can be used anywhere you want to refer to a characters codepoint.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a33f02a3cf972439fc9644228266bf6ac583f283" translate="yes" xml:space="preserve">
          <source>These characteristics are what prompted keyword lists to be the default mechanism for passing options to functions in Elixir. In chapter 5, when we discussed the &lt;code&gt;if/2&lt;/code&gt; macro, we mentioned the following syntax is supported:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76567fa6ed57b5e28a73659cbd673c9a7f350853" translate="yes" xml:space="preserve">
          <source>These functions and macros follow the Erlang convention of an &lt;code&gt;is_&lt;/code&gt; prefix, instead of a trailing question mark, precisely to indicate that they are allowed in guard clauses.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="add5b2dbfbafe6da3d0a22b6f870b2eed75d677f" translate="yes" xml:space="preserve">
          <source>These options are expected to be literals (including the binary values) at compile time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ec1191cd2717326d5b2f8e25c4fb58ff593d194" translate="yes" xml:space="preserve">
          <source>These options are global since they are stored by Elixir's Code Server.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8aca497f05ede32d92fad7a0a08861307fed5d02" translate="yes" xml:space="preserve">
          <source>These paths are based on the &lt;code&gt;:apps_path&lt;/code&gt; and &lt;code&gt;:apps&lt;/code&gt; configurations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90f90a0bd1abd66881352917a593420e21df4638" translate="yes" xml:space="preserve">
          <source>They also support &lt;code&gt;else&lt;/code&gt; blocks:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c272e830fb2eeca6af73d25f9dc7ec1a9ffc0efc" translate="yes" xml:space="preserve">
          <source>They are discussed individually in the sections below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d984bcb0628847679167196f524ecb516b6c251c" translate="yes" xml:space="preserve">
          <source>They serve to annotate the module, often with information to be used by the user or the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97ca407460ebb22e0ec5bdeff0b3e028c669bf37" translate="yes" xml:space="preserve">
          <source>They work as a temporary module storage to be used during compilation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee6dd5d64b66e821ff94c4d17d21b9f93db749f2" translate="yes" xml:space="preserve">
          <source>They work as constants.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e53339d9d0bc53c58fe8778d10ade8bb49736f46" translate="yes" xml:space="preserve">
          <source>This &lt;a href=&quot;https://elixir-lang.org/crash-course.html&quot;&gt;Erlang Syntax: A Crash Course&lt;/a&gt; provides a concise intro to Erlang&amp;rsquo;s syntax. Each code snippet is accompanied by equivalent code in Elixir. This is an opportunity for you to not only get some exposure to Erlang&amp;rsquo;s syntax but also review some of the things you have learned in this guide.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3d65d16574f84519ba2e69aa0d37e68059885e5" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;fun&lt;/code&gt; argument receives the value of &lt;code&gt;key&lt;/code&gt; (or &lt;code&gt;nil&lt;/code&gt; if &lt;code&gt;key&lt;/code&gt; is not present) and must return a two-element tuple: the &quot;get&quot; value (the retrieved value, which can be operated on before being returned) and the new value to be stored under &lt;code&gt;key&lt;/code&gt;. The &lt;code&gt;fun&lt;/code&gt; may also return &lt;code&gt;:pop&lt;/code&gt;, implying the current value shall be removed from the keyword list and returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21531bdd28fd8a4fab193e8f907a1304804427e8" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;fun&lt;/code&gt; argument receives the value of &lt;code&gt;key&lt;/code&gt; and must return a two-element tuple: the &quot;get&quot; value (the retrieved value, which can be operated on before being returned) and the new value to be stored under &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="106724662d1a48acf5e96ebf33c77969eed35e72" translate="yes" xml:space="preserve">
          <source>This advice does not only apply to libraries but to any Elixir code. Every time you receive multiple options or work with external data, you should validate the data at the boundary and convert it to structured data. For example, if you provide a &lt;a href=&quot;genserver&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt; that can be started with multiple options, you want to validate those options when the server starts and rely only on structured data throughout the process life cycle. Similarly, if a database or a socket gives you a map of strings, after you receive the data, you should validate it and potentially convert it to a struct or a map of atoms.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38b51c7863a18d9dea71afde173bd863c4339d77" translate="yes" xml:space="preserve">
          <source>This also works with nested structs and the &lt;code&gt;struct.path.to.value&lt;/code&gt; way to specify paths:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c86b0384c6fa0ab23e023705951a2e26ece47398" translate="yes" xml:space="preserve">
          <source>This behaviour is deprecated. Use Erlang/OTP's :gen_event module instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72f035035b3d70bcbf1171738b7f8c7d508d05aa" translate="yes" xml:space="preserve">
          <source>This behaviour is relied on in many different places. For example, &lt;a href=&quot;https://hexdocs.pm/ex_unit/ExUnit.html&quot;&gt;&lt;code&gt;ExUnit&lt;/code&gt;&lt;/a&gt; uses &lt;code&gt;exit(:shutdown)&lt;/code&gt; when exiting the test process to signal linked processes, supervision trees and so on to politely shut down too.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8eb2df7e5f6ba76a64892942e28c56d4c4a7f04" translate="yes" xml:space="preserve">
          <source>This break can be rendered as a linebreak or as the given &lt;code&gt;string&lt;/code&gt;, depending on the &lt;code&gt;mode&lt;/code&gt; of the chosen layout.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab7ad5339c141f0de9e312dc2f25b5df3e7d8cb4" translate="yes" xml:space="preserve">
          <source>This breakpoint will never be reached, because a macro never receives a PID. Even if you call the macro as &lt;code&gt;MyModule.some_macro(self())&lt;/code&gt;, the macro will receive the AST representing the &lt;code&gt;self()&lt;/code&gt; call, and not the PID itself.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8761ea35931ac08c3f3679fbf6f993fa3ef09746" translate="yes" xml:space="preserve">
          <source>This calendar implements the proleptic Gregorian calendar and is therefore compatible with the calendar used in most countries today. The proleptic means the Gregorian rules for leap years are applied for all time, consequently the dates give different results before the year 1583 from when the Gregorian calendar was adopted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7991ee0aa425c7d3f3afff7118c6225869810d3f" translate="yes" xml:space="preserve">
          <source>This call will setup a breakpoint that stops once. To set a breakpoint that will stop 10 times:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b325289ad4384d9c3ff3e14f0e004ec0fadc1690" translate="yes" xml:space="preserve">
          <source>This callback can be useful to control the &lt;em&gt;appearance&lt;/em&gt; of the status of the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt;. For example, it can be used to return a compact representation of the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt;'s state to avoid having large state terms printed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1327f9cbc59e218b07255d5dfd814547d5d8807b" translate="yes" xml:space="preserve">
          <source>This callback is only supported on Erlang/OTP 21+.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee5f243ca65efd502d5c4c6af5c8cd9dfd5d476c" translate="yes" xml:space="preserve">
          <source>This callback is optional.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2424dc84d136b7783611865075888a14d9c990b" translate="yes" xml:space="preserve">
          <source>This callback is optional. If one is not implemented, the received message will be logged.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="985bade6a0d966231f4d34d8934365d5ebe8193e" translate="yes" xml:space="preserve">
          <source>This callback is optional. If one is not implemented, the server will fail if a call is performed against it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f84f9f7a0fb58e5af47a01d8f797b8c62ea95537" translate="yes" xml:space="preserve">
          <source>This callback is optional. If one is not implemented, the server will fail if a cast is performed against it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a8f931c4cb12fef7b434a37af006aef2ba0d46a" translate="yes" xml:space="preserve">
          <source>This callback is optional. If one is not implemented, the server will fail if a continue instruction is used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ddfd8ff82f8cdfbfeb3d06aa0134b83f46048ef4" translate="yes" xml:space="preserve">
          <source>This can be added to any custom engine by invoking &lt;a href=&quot;#handle_assign/1&quot;&gt;&lt;code&gt;handle_assign/1&lt;/code&gt;&lt;/a&gt; with &lt;a href=&quot;https://hexdocs.pm/elixir/Macro.html#prewalk/2&quot;&gt;&lt;code&gt;Macro.prewalk/2&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a48050cb80bb5c2bc634b01accf3b4f5bd8c332" translate="yes" xml:space="preserve">
          <source>This chapter is a quick introduction to input/output mechanisms and file-system-related tasks, as well as to related modules like &lt;a href=&quot;https://hexdocs.pm/elixir/IO.html&quot;&gt;&lt;code&gt;IO&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://hexdocs.pm/elixir/File.html&quot;&gt;&lt;code&gt;File&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://hexdocs.pm/elixir/Path.html&quot;&gt;&lt;code&gt;Path&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b602041d24e676175f7fd300fe9987bf2555172" translate="yes" xml:space="preserve">
          <source>This chapter is part of the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d39494a06027e3ecee2968740895a5b78940cdae" translate="yes" xml:space="preserve">
          <source>This checks the version stored in the regular expression and recompiles the regex in case of version mismatch.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ba63be17004fe209fc861513a8577afc4eb4889" translate="yes" xml:space="preserve">
          <source>This code counts the number of files in a ZIP file:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9d6dcf55f45221cfb511f9790e81d0872563106" translate="yes" xml:space="preserve">
          <source>This code generates a warning letting you know that you are mistakenly implementing &lt;code&gt;parse/0&lt;/code&gt; instead of &lt;code&gt;parse/1&lt;/code&gt;. You can read more about &lt;code&gt;@impl&lt;/code&gt; in the &lt;a href=&quot;https://hexdocs.pm/elixir/master/Module.html#module-impl&quot;&gt;module documentation&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7461ed387e3c81526760cfc0eb288d63eeb1988f" translate="yes" xml:space="preserve">
          <source>This command deletes all build artifacts for the current project. Dependencies' sources and build files are cleaned only if the &lt;code&gt;--deps&lt;/code&gt; option is given.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f03f46afb53748c93f12e42d7a94c9567ade9ff8" translate="yes" xml:space="preserve">
          <source>This command only works inside a pry session started manually via &lt;a href=&quot;iex#pry/0&quot;&gt;&lt;code&gt;IEx.pry/0&lt;/code&gt;&lt;/a&gt; or a breakpoint set via &lt;a href=&quot;iex#break!/4&quot;&gt;&lt;code&gt;IEx.break!/4&lt;/code&gt;&lt;/a&gt;. Calling this function during a regular &lt;a href=&quot;iex&quot;&gt;&lt;code&gt;IEx&lt;/code&gt;&lt;/a&gt; session will print an error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a69791b2bccfac2d2c8e3aaab714d3c02736c70" translate="yes" xml:space="preserve">
          <source>This concludes our introduction to associative data structures in Elixir. You will find out that, given keyword lists and maps, you will always have the right tool to tackle problems that require associative data structures in Elixir.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16f934bff72f27aaf7d700d67cebd5f253fc677d" translate="yes" xml:space="preserve">
          <source>This concludes our optimization chapter. We have used ETS as a cache mechanism where reads can happen from any processes but writes are still serialized through a single process. More importantly, we have also learned that once data can be read asynchronously, we need to be aware of the race conditions it might introduce.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e537b568fbfe0eb80dc56346fdc7829c98d99600" translate="yes" xml:space="preserve">
          <source>This configuration can be read using &lt;a href=&quot;mix.project#config/0&quot;&gt;&lt;code&gt;Mix.Project.config/0&lt;/code&gt;&lt;/a&gt;. Note that &lt;a href=&quot;#config/0&quot;&gt;&lt;code&gt;config/0&lt;/code&gt;&lt;/a&gt; won't fail if a project is not defined; this allows many Mix tasks to work without a project.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6e1f3335434ce7c6c1db9f585fc250ca17087fe" translate="yes" xml:space="preserve">
          <source>This configuration is split in three categories:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50abf55bb08a41598a90aba43d936a7f680d70a0" translate="yes" xml:space="preserve">
          <source>This configures a routing table that always points to the current node. Now remove &lt;code&gt;@tag :distributed&lt;/code&gt; from the test in &lt;code&gt;test/kv_server_test.exs&lt;/code&gt; and run the suite, the test should now pass.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="300ecf84b2025cc5045f1e2f3e97de582fbc3fe7" translate="yes" xml:space="preserve">
          <source>This could be corrected by ensuring that no exception is raised, either via type checks like &lt;code&gt;is_map(val) and map_size(val) == 0&lt;/code&gt;, or by checking equality instead, like &lt;code&gt;val == %{}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c9bc7bb0b19c22166e70549a7bdc2d167883d30" translate="yes" xml:space="preserve">
          <source>This datetime can be seen as an ephemeral snapshot of a datetime at a given time zone. For such purposes, it also includes both UTC and Standard offsets, as well as the zone abbreviation field used exclusively for formatting purposes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="025523ae9891a8ad2cd843de98bd87706ff12c27" translate="yes" xml:space="preserve">
          <source>This day fraction should be in its most simplified form possible, to make comparisons fast.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99d3f98fe052dbacd8470e76a4e43e20ad18ae6f" translate="yes" xml:space="preserve">
          <source>This default can be overridden by &lt;code&gt;@tag capture_log: false&lt;/code&gt; or &lt;code&gt;@moduletag capture_log: false&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc33441b7a8711ad3ca32a6f565dfd02fa511842" translate="yes" xml:space="preserve">
          <source>This dependency refers to the latest version of Plug in the 1.x.x version series that has been pushed to Hex. This is indicated by the &lt;code&gt;~&amp;gt;&lt;/code&gt; preceding the version number. For more information on specifying version requirements, see the &lt;a href=&quot;https://hexdocs.pm/elixir/Version.html&quot;&gt;documentation for the Version module&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6c49f1989fcd795b139792169130547ab503617" translate="yes" xml:space="preserve">
          <source>This design is intentional. &lt;a href=&quot;enumerable&quot;&gt;&lt;code&gt;Enumerable&lt;/code&gt;&lt;/a&gt; was designed to support infinite collections, resources and other structures with fixed shape. For example, it doesn't make sense to insert values into a range, as it has a fixed shape where just the range limits are stored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7534091aa8dce080c878d8bf8e2b8c4a424f0e53" translate="yes" xml:space="preserve">
          <source>This difference is exclusive, so the test will fail if the difference and the delta are equal.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2dd776fd236b4c910c6f960d04bcbda080e07c54" translate="yes" xml:space="preserve">
          <source>This difference is inclusive, so the test will pass if the difference and the &lt;code&gt;delta&lt;/code&gt; are equal.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98215fb8db656d563463f8fe38acbb92d7848ad1" translate="yes" xml:space="preserve">
          <source>This distinction is important. If there are expensive actions to be done, you must consider if it will be better to perform these actions on the client or on the server. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df29062cd643c03ef91e3b2f35c7d26d81006829" translate="yes" xml:space="preserve">
          <source>This document covers all of Elixir syntax constructs as a reference and then discuss their exact AST representation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ca6dcbf01e5b678fc80bf68968384a6697f2309" translate="yes" xml:space="preserve">
          <source>This document covers operators in Elixir, how they are parsed, how they can be defined, and how they can be overridden.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76b6d6a8fc49e94c927ef5f992d5906c281ba114" translate="yes" xml:space="preserve">
          <source>This document covers some naming conventions in Elixir code, from casing to punctuation characters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e522e86f1169f55700b99174079a5a7fddfa90ed" translate="yes" xml:space="preserve">
          <source>This document defines the commonly used base 16, base 32, and base 64 encoding schemes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8780e3a54cb0fb8d842fe0203eab3683b262d16" translate="yes" xml:space="preserve">
          <source>This document outlines general guidelines, anti-patterns, and rules for those writing and publishing Elixir libraries meant to be consumed by other developers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7635e286607ededea5965d1544a7717ea9ae091d" translate="yes" xml:space="preserve">
          <source>This document provides a reference to Elixir syntax, exploring its constructs and their AST equivalents.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb11a86f08fe1f7ebc5f36609a52188a6715fc6d" translate="yes" xml:space="preserve">
          <source>This documentation refers to implementing the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Inspect&lt;/code&gt;&lt;/a&gt; protocol for your own data structures. To learn more about using inspect, see &lt;a href=&quot;kernel#inspect/2&quot;&gt;&lt;code&gt;Kernel.inspect/2&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;io#inspect/2&quot;&gt;&lt;code&gt;IO.inspect/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c15107405a954dcb039847f9ffc0e90a3a08175" translate="yes" xml:space="preserve">
          <source>This example shows how to get everything from the registry.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="370c43dc94083c1b83066d682a8c408a4aa46d4b" translate="yes" xml:space="preserve">
          <source>This feature is considered experimental and may change in future releases.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91e35a46b080fba070b1bb9706d962577f541321" translate="yes" xml:space="preserve">
          <source>This file can be compiled using &lt;code&gt;elixirc&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b21275a067c181042b1ef479348b07d28e434640" translate="yes" xml:space="preserve">
          <source>This file contains Erlang terms (written using Erlang syntax). Even though we are not familiar with Erlang, it is easy to guess this file holds our application definition. It contains our application &lt;code&gt;version&lt;/code&gt;, all the modules defined by it, as well as a list of applications we depend on, like Erlang&amp;rsquo;s &lt;code&gt;kernel&lt;/code&gt;, &lt;code&gt;elixir&lt;/code&gt; itself, and &lt;code&gt;logger&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4e5090203b164b7b8cda10cfcc22848f5f4e098" translate="yes" xml:space="preserve">
          <source>This file will be required by Mix every time before we run our tests. We can run tests with &lt;code&gt;mix test&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c84c085804b613daf8adcad4e1c5bc2c3c89312" translate="yes" xml:space="preserve">
          <source>This finishes our introduction to &lt;code&gt;try&lt;/code&gt;, &lt;code&gt;catch&lt;/code&gt;, and &lt;code&gt;rescue&lt;/code&gt;. You will find they are used less frequently in Elixir than in other languages, although they may be handy in some situations where a library or some particular code is not playing &amp;ldquo;by the rules&amp;rdquo;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e21f5a627b95129ae5af664e7fd87944d88dfd3" translate="yes" xml:space="preserve">
          <source>This finishes our introduction to pattern matching. As we will see in the next chapter, pattern matching is very common in many language constructs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a8c048ae2840f3778becb01897e7dcb0a936037" translate="yes" xml:space="preserve">
          <source>This finishes our short introduction to modules. In the next chapters, we will learn how to use named functions for recursion, explore Elixir lexical directives that can be used for importing functions from other modules and discuss module attributes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d37728bdb738ca01b9639cfc5853b77bca6e2f31" translate="yes" xml:space="preserve">
          <source>This finishes our tour of IO devices and IO related functionality. We have learned about four Elixir modules - &lt;a href=&quot;https://hexdocs.pm/elixir/IO.html&quot;&gt;&lt;code&gt;IO&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://hexdocs.pm/elixir/File.html&quot;&gt;&lt;code&gt;File&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://hexdocs.pm/elixir/Path.html&quot;&gt;&lt;code&gt;Path&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://hexdocs.pm/elixir/StringIO.html&quot;&gt;&lt;code&gt;StringIO&lt;/code&gt;&lt;/a&gt; - as well as how the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4be537303d97003eb7a277c4a7ca1256fe24cb96" translate="yes" xml:space="preserve">
          <source>This function accepts any map or struct that contains at least the same fields as a &lt;a href=&quot;naivedatetime&quot;&gt;&lt;code&gt;NaiveDateTime&lt;/code&gt;&lt;/a&gt; struct. The most common example of that is a &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt;. In this case the information about the time zone of that &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt; is completely ignored. This is the same principle as passing a &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt; to &lt;a href=&quot;date#to_iso8601/2&quot;&gt;&lt;code&gt;Date.to_iso8601/2&lt;/code&gt;&lt;/a&gt;. &lt;a href=&quot;date#to_iso8601/2&quot;&gt;&lt;code&gt;Date.to_iso8601/2&lt;/code&gt;&lt;/a&gt; extracts only the date-specific fields (calendar, year, month and day) of the given structure and ignores all others.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5bf6aff9caccdb3a64ed2f33e59b9d34b47e60ba" translate="yes" xml:space="preserve">
          <source>This function accepts the &lt;code&gt;number&lt;/code&gt; measured according to &lt;a href=&quot;calendar.iso&quot;&gt;&lt;code&gt;Calendar.ISO&lt;/code&gt;&lt;/a&gt;. The time is returned in the same calendar as it was given in.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2a89e508cd312bb2a9827f189a0607424832acb" translate="yes" xml:space="preserve">
          <source>This function accepts the following options, which are exclusive to each other (i.e., only one of them can be used in the same call):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01d34bc3e6a8b2f03537e43d3d5e42ba54d0dddb" translate="yes" xml:space="preserve">
          <source>This function also accepts a &lt;code&gt;predicate&lt;/code&gt; function as an optional argument. If passed, this function will be called with each byte in &lt;code&gt;string&lt;/code&gt; as its argument and should return a truthy value (anything other than &lt;code&gt;false&lt;/code&gt; or &lt;code&gt;nil&lt;/code&gt;) if the given byte should be left as is, or return a falsy value (&lt;code&gt;false&lt;/code&gt; or &lt;code&gt;nil&lt;/code&gt;) if the character should be escaped.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b98eb6f021aa33018c50a97a2ae82859d4b9d5d9" translate="yes" xml:space="preserve">
          <source>This function also accepts all options accepted by &lt;a href=&quot;regex#split/3&quot;&gt;&lt;code&gt;Regex.split/3&lt;/code&gt;&lt;/a&gt; if &lt;code&gt;pattern&lt;/code&gt; is a regular expression.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac6f41672cc7456ee783ae52a0830c9c41b7db86" translate="yes" xml:space="preserve">
          <source>This function also notifies the compiler a warning was printed (in case --warnings-as-errors was enabled). It returns &lt;code&gt;:ok&lt;/code&gt; if it succeeds.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f335fe1ab0a202ff3768395fb418ab92d63c45f8" translate="yes" xml:space="preserve">
          <source>This function always returns &lt;code&gt;:ok&lt;/code&gt; regardless of whether the destination &lt;code&gt;server&lt;/code&gt; (or node) exists. Therefore it is unknown whether the destination &lt;code&gt;server&lt;/code&gt; successfully handled the message.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc08e67f2fe286bbaa38c013f9a0710de372c88c" translate="yes" xml:space="preserve">
          <source>This function always returns &lt;code&gt;:ok&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="440a46241c8ccf32d2a66af8c374d6f2f268c12c" translate="yes" xml:space="preserve">
          <source>This function always returns a float. &lt;a href=&quot;kernel#trunc/1&quot;&gt;&lt;code&gt;Kernel.trunc/1&lt;/code&gt;&lt;/a&gt; may be used instead to truncate the result to an integer afterwards.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57434e8d5ce39ceeb05917e87327e9180f6a8556" translate="yes" xml:space="preserve">
          <source>This function always returns floats. &lt;a href=&quot;kernel#trunc/1&quot;&gt;&lt;code&gt;Kernel.trunc/1&lt;/code&gt;&lt;/a&gt; may be used instead to truncate the result to an integer afterwards.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0953d55a24fb80955003844da1bc3b8af51086cb" translate="yes" xml:space="preserve">
          <source>This function assumes the task's monitor is still active or the monitor's &lt;code&gt;:DOWN&lt;/code&gt; message is in the message queue. If it has been demonitored or the message already received, this function will wait for the duration of the timeout awaiting the message.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b478825975b2adf1e339715031349cd41d1d953" translate="yes" xml:space="preserve">
          <source>This function assumes the task's monitor is still active or the monitor's &lt;code&gt;:DOWN&lt;/code&gt; message is in the message queue. If it has been demonitored, or the message already received, this function will wait for the duration of the timeout awaiting the message.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12bd78dfccf68211322b54eebf7d9f19fae21105" translate="yes" xml:space="preserve">
          <source>This function can also be used to compare a DateTime without the time zone information:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6685e43cbdb2479bfe075aeca3ae08082570222e" translate="yes" xml:space="preserve">
          <source>This function can also be used to compare across more complex calendar types by considering only the date fields:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="abca05fe88ba596b97d33bdad630bb0ce33ca0d8" translate="yes" xml:space="preserve">
          <source>This function can also be used to compare across more complex calendar types by considering only the time fields:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50c88d683e6ca48ffff95675148916e0e611983e" translate="yes" xml:space="preserve">
          <source>This function can also be used to convert a DateTime to ISO 8601 without the time zone information:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41a09a6604ea410d09611cc0508b8a9905bff4c2" translate="yes" xml:space="preserve">
          <source>This function can also be used to convert a DateTime to a erl format without the time zone information:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90561437b8e4f9d3679b45a602783e2cfc785f58" translate="yes" xml:space="preserve">
          <source>This function can also be used to convert a DateTime to a string without the time zone information:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7b8cf5df777bb4d4ddd30603ec1dffb30552797" translate="yes" xml:space="preserve">
          <source>This function can be seen as a combination of &lt;a href=&quot;stream#resource/3&quot;&gt;&lt;code&gt;Stream.resource/3&lt;/code&gt;&lt;/a&gt; with &lt;a href=&quot;stream#transform/3&quot;&gt;&lt;code&gt;Stream.transform/3&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65aef6f44f45a3fc1e3176aa1c4a4acc551773fb" translate="yes" xml:space="preserve">
          <source>This function can be used to explicitly send a reply to a client that called &lt;a href=&quot;#call/3&quot;&gt;&lt;code&gt;call/3&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#multi_call/4&quot;&gt;&lt;code&gt;multi_call/4&lt;/code&gt;&lt;/a&gt; when the reply cannot be specified in the return value of &lt;a href=&quot;#c:handle_call/3&quot;&gt;&lt;code&gt;handle_call/3&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e57ccc748f6208d195990a8cc4f2ec6d283e0449" translate="yes" xml:space="preserve">
          <source>This function can only be called once for any given task. If you want to be able to check multiple times if a long-running task has finished its computation, use &lt;a href=&quot;#yield/2&quot;&gt;&lt;code&gt;yield/2&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98e8c080a62ccf76ac34e7992cc0abb94cb3247b" translate="yes" xml:space="preserve">
          <source>This function can only be used on modules that have not yet been compiled. Use &lt;a href=&quot;kernel#function_exported?/3&quot;&gt;&lt;code&gt;Kernel.function_exported?/3&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;kernel#macro_exported?/3&quot;&gt;&lt;code&gt;Kernel.macro_exported?/3&lt;/code&gt;&lt;/a&gt; to check for public functions and macros respectively in compiled modules.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b999fb0a29efbf4b7d7e63844d3c5a01d70c5786" translate="yes" xml:space="preserve">
          <source>This function can only be used on modules that have not yet been compiled. Use the &lt;a href=&quot;module#c:__info__/1&quot;&gt;&lt;code&gt;Module.__info__/1&lt;/code&gt;&lt;/a&gt; callback to get all persisted attributes, or &lt;a href=&quot;code#fetch_docs/1&quot;&gt;&lt;code&gt;Code.fetch_docs/1&lt;/code&gt;&lt;/a&gt; to retrieve all documentation related attributes in compiled modules.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8efbd3ec7525b3bf67461748ab16a84e708bda9c" translate="yes" xml:space="preserve">
          <source>This function can only be used on modules that have not yet been compiled. Use the &lt;a href=&quot;module#c:__info__/1&quot;&gt;&lt;code&gt;Module.__info__/1&lt;/code&gt;&lt;/a&gt; callback to get the public functions and macros in compiled modules.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d5f5ab7615681bbf6fd8b48511d63b244920517" translate="yes" xml:space="preserve">
          <source>This function changes the current working directory and loads the project at the given directory onto the project stack.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e3b67a18d5ef72f20a07d2887c95146e1126e8b" translate="yes" xml:space="preserve">
          <source>This function checks if &lt;code&gt;map_set1&lt;/code&gt; is a subset of &lt;code&gt;map_set2&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2d91333f4d34514a5b0456ce852915cb7c3b1bf" translate="yes" xml:space="preserve">
          <source>This function could also receive &lt;code&gt;:restart&lt;/code&gt; and &lt;code&gt;:shutdown&lt;/code&gt; as options but those two options have been deprecated and it is now preferred to give them directly to &lt;code&gt;start_child&lt;/code&gt; and &lt;code&gt;async&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff81d1869547c10033febe62aa38e4cdb8f5c51e" translate="yes" xml:space="preserve">
          <source>This function discards all formatting of the original code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc64919f284870e1f397d0b40b0bdb1f6bff9e2a" translate="yes" xml:space="preserve">
          <source>This function does not load the protocol at any point nor loads the new bytecode for the compiled module. However each implementation must be available and it will be loaded.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e9ba48e0ab714ebacb38f83050628f3e221fabd" translate="yes" xml:space="preserve">
          <source>This function does not query the file system, so it assumes no symlinks between the paths.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="352c8d36738c6dbc1f9234ecd7c20913e38da8c4" translate="yes" xml:space="preserve">
          <source>This function does not support regular expressions by design. When using regular expressions, it is often more efficient to have the regular expressions traverse the string at once than in parts, like this function does.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df30bac7bb7c4cc8e50dfd93b53e8ccc88b71e0c" translate="yes" xml:space="preserve">
          <source>This function expects a valid Elixir AST, also known as quoted expression, as argument. If you would like to &lt;code&gt;unquote&lt;/code&gt; any value, such as a map or a four-element tuple, you should call &lt;a href=&quot;macro#escape/1&quot;&gt;&lt;code&gt;Macro.escape/1&lt;/code&gt;&lt;/a&gt; before unquoting.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f41d20e5f7f0240b4127af0359d8f266f1d505e" translate="yes" xml:space="preserve">
          <source>This function expects the &lt;code&gt;id&lt;/code&gt; in the child specification. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a24e422135d3a72abf7a20c0e4887299173a50a" translate="yes" xml:space="preserve">
          <source>This function expects the file to be closed with success, which is usually the case unless the &lt;code&gt;:delayed_write&lt;/code&gt; option is given. For this reason, we do not recommend passing &lt;code&gt;:delayed_write&lt;/code&gt; to this function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="295cf4a022ae9886df00b43f0a66cd0e9487ce78" translate="yes" xml:space="preserve">
          <source>This function fails unless &lt;code&gt;enumerable&lt;/code&gt; is or can be converted into a list of tuples with &lt;em&gt;exactly&lt;/em&gt; two elements in each tuple.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b4e5979f3e77e3276f95ef316da429597fdbf6e" translate="yes" xml:space="preserve">
          <source>This function follows symbolic links, so if a symbolic link points to a directory, &lt;code&gt;true&lt;/code&gt; is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3644ab39c8ba48b5055b8839db30ad7f73881153" translate="yes" xml:space="preserve">
          <source>This function follows symbolic links, so if a symbolic link points to a regular file, &lt;code&gt;true&lt;/code&gt; is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ffa8e1b3e795c072d918d9fb7e14d1f0f556146a" translate="yes" xml:space="preserve">
          <source>This function is called after &lt;a href=&quot;#start/2&quot;&gt;&lt;code&gt;start/2&lt;/code&gt;&lt;/a&gt; finishes but before &lt;a href=&quot;application#start/2&quot;&gt;&lt;code&gt;Application.start/2&lt;/code&gt;&lt;/a&gt; returns. It will be called once for every start phase defined in the application's (and any included applications') specification, in the order they are listed in.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="324f00c4d8269119ff0a84cb2a42e9f018297cf4" translate="yes" xml:space="preserve">
          <source>This function is called after an application has been stopped, i.e., after its supervision tree has been stopped. It should do the opposite of what the &lt;a href=&quot;#c:start/2&quot;&gt;&lt;code&gt;start/2&lt;/code&gt;&lt;/a&gt; callback did, and should perform any necessary cleanup. The return value of this callback is ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1e69bba301a1e9a02d953f1b325981a44e10b03" translate="yes" xml:space="preserve">
          <source>This function is called before the top-level supervisor is terminated. It receives the state returned by &lt;a href=&quot;#c:start/2&quot;&gt;&lt;code&gt;start/2&lt;/code&gt;&lt;/a&gt;, if it did, or &lt;code&gt;[]&lt;/code&gt; otherwise. The return value is later passed to &lt;a href=&quot;#c:stop/1&quot;&gt;&lt;code&gt;stop/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82b44336c3cb3815e176b242c09b89fad73c5747" translate="yes" xml:space="preserve">
          <source>This function is called when an application is started using &lt;a href=&quot;application#start/2&quot;&gt;&lt;code&gt;Application.start/2&lt;/code&gt;&lt;/a&gt; (and functions on top of that, such as &lt;a href=&quot;application#ensure_started/2&quot;&gt;&lt;code&gt;Application.ensure_started/2&lt;/code&gt;&lt;/a&gt;). This function should start the top-level process of the application (which should be the top supervisor of the application's supervision tree if the application follows the OTP design principles around supervision).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6397213a49d0900b8102d7287a15cef482e32621" translate="yes" xml:space="preserve">
          <source>This function is commonly used on sigil implementations (like &lt;code&gt;~r&lt;/code&gt;, &lt;code&gt;~s&lt;/code&gt; and others) which receive a raw, unescaped string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1d006a8fc94dd9c7e1ba97fca6cd955efbe08aa" translate="yes" xml:space="preserve">
          <source>This function is deprecated. Code.get_docs/2 always returns nil as its outdated documentation is no longer stored on BEAM files. Use Code.fetch_docs/1 instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d817e277c636af5ee8696b4df5a417a3f80ca798" translate="yes" xml:space="preserve">
          <source>This function is deprecated. Use :unicode.characters_to_nfc_binary/1 or :unicode.characters_to_nfd_binary/1 instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d197dc51c7a88c8b078c1ba4ae70a662b56ba4a" translate="yes" xml:space="preserve">
          <source>This function is deprecated. Use File.cwd!/0 instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68131068aaa063f7af71e9caaedd8601eae221d0" translate="yes" xml:space="preserve">
          <source>This function is deprecated. Use File.cwd/0 instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9e5b31b2e69678e54278c031112af02d71d6009" translate="yes" xml:space="preserve">
          <source>This function is deprecated. Use Mix.Project.compile_path/1 instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a03218696b1f2f17e92328d8d93708ef4f7e2fab" translate="yes" xml:space="preserve">
          <source>This function is deprecated. Use maps and the Map module instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="afca0b7ebdad39b2deed844f934a667e8bfea571" translate="yes" xml:space="preserve">
          <source>This function is deprecated. Use the Map module for working with maps or the Keyword module for working with keyword lists.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a82ec0a465ee3ffdfcf230d76d58430e9467641" translate="yes" xml:space="preserve">
          <source>This function is deprecated. Use the MapSet module for working with sets.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01a53758d90cccf848faf6930295f5427dfb10e9" translate="yes" xml:space="preserve">
          <source>This function is deprecated. Use the MapSet module instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03ea43b93839fafbcde7b68af462e5f9eed5a8d0" translate="yes" xml:space="preserve">
          <source>This function is meant to be used for development and debugging purposes. Do not depend on it in production code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a44ba9065763e466dc65d136dacf651b48b4c551" translate="yes" xml:space="preserve">
          <source>This function is often used to set an &lt;code&gt;:id&lt;/code&gt; option when the same module needs to be started multiple times in the supervision tree:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b1fd4e59486849679c33280edfff500c42ca784" translate="yes" xml:space="preserve">
          <source>This function is often used with &lt;a href=&quot;#run/1&quot;&gt;&lt;code&gt;run/1&lt;/code&gt;&lt;/a&gt; since any evaluation is delayed until the stream is executed. See &lt;a href=&quot;#run/1&quot;&gt;&lt;code&gt;run/1&lt;/code&gt;&lt;/a&gt; for an example.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="35db107573e34332f733e95b887f5793867baa7f" translate="yes" xml:space="preserve">
          <source>This function is only available for modules being compiled.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6bf228951da57a994d903de6610ec9973c50adc" translate="yes" xml:space="preserve">
          <source>This function is used by &lt;a href=&quot;#container_doc/6&quot;&gt;&lt;code&gt;container_doc/6&lt;/code&gt;&lt;/a&gt; and friends to the maximum number of entries on the same line.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4934d4902c08909612efec0de002f5df60337c47" translate="yes" xml:space="preserve">
          <source>This function is useful for development and debugging when you have code that has been compiled or updated locally that you want to run on other nodes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50108ad28c85db6aa26c7746481f7a06145abb10" translate="yes" xml:space="preserve">
          <source>This function is useful for dynamically creating and updating structs, as well as for converting maps to structs; in the latter case, just inserting the appropriate &lt;code&gt;:__struct__&lt;/code&gt; field into the map may not be enough and &lt;a href=&quot;#struct/2&quot;&gt;&lt;code&gt;struct/2&lt;/code&gt;&lt;/a&gt; should be used instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5385bb3c5cc1848788f9b3bfe82e294efa3644f" translate="yes" xml:space="preserve">
          <source>This function is useful in case you have templates but you want to precompile inside a module for speed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4f1c9110eb148d436155bff7b34df88e2134afb" translate="yes" xml:space="preserve">
          <source>This function is useful in case you want to compute the value to put under &lt;code&gt;key&lt;/code&gt; only if &lt;code&gt;key&lt;/code&gt; is not already present (e.g., the value is expensive to calculate or generally difficult to setup and teardown again).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf89a2dec2302779e475a219a3cc56e86137d9f9" translate="yes" xml:space="preserve">
          <source>This function is useful when there is a need to retrieve the current value (or something calculated in function of the current value) and update it at the same time. For example, it could be used to read the current age of a user while increasing it by one in one pass:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68a1bac27fa5baaa472b5537d1c8fee1ec1e9478" translate="yes" xml:space="preserve">
          <source>This function is useful when you know the bytecode for module has been updated in the file system and you want to tell the VM to load it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80a765f43bfbc2222f8ba2acffb613f97fc1ff91" translate="yes" xml:space="preserve">
          <source>This function is usually used in compilation tasks to trigger a full recompilation whenever such configuration files change.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5161d32c18b7b4c986062d2c9d65d697f139b8ce" translate="yes" xml:space="preserve">
          <source>This function is usually used in compilation tasks to trigger a full recompilation whenever such configuration files change. For this reason, the mtime is cached to avoid file system lookups.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79351219ceeb1dfd5ceb68c4d1517bb1d53f3be9" translate="yes" xml:space="preserve">
          <source>This function keeps OTP semantics regarding error reporting. If the reason is any other than &lt;code&gt;:normal&lt;/code&gt;, &lt;code&gt;:shutdown&lt;/code&gt; or &lt;code&gt;{:shutdown, _}&lt;/code&gt;, an error report is logged.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9fb9a7593d63fc692737aa5ebbecdecf78a06b53" translate="yes" xml:space="preserve">
          <source>This function keeps OTP semantics regarding error reporting. If the reason is any other than &lt;code&gt;:normal&lt;/code&gt;, &lt;code&gt;:shutdown&lt;/code&gt; or &lt;code&gt;{:shutdown, _}&lt;/code&gt;, an error report will be logged.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78ffeed4e3d53d08c6f8c5350cc948af11ad5cb9" translate="yes" xml:space="preserve">
          <source>This function looks up an executable program given its name using the environment variable PATH on Unix and Windows. It also considers the proper executable extension for each operating system, so for Windows it will try to lookup files with &lt;code&gt;.com&lt;/code&gt;, &lt;code&gt;.cmd&lt;/code&gt; or similar extensions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03c6c18f32c36e354994adeed127bb47604a29a4" translate="yes" xml:space="preserve">
          <source>This function maps each element of the &lt;code&gt;enumerable&lt;/code&gt; using the provided &lt;code&gt;mapper&lt;/code&gt; function. The enumerable is then sorted by the mapped elements using the &lt;code&gt;sorter&lt;/code&gt; function, which defaults to &lt;a href=&quot;kernel#%253C=/2&quot;&gt;&lt;code&gt;Kernel.&amp;lt;=/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23713134a12e3df672b0e8ed70b6c1e947176852" translate="yes" xml:space="preserve">
          <source>This function may fail while copying files, in such cases, it will leave the destination directory in a dirty state, where file which have already been copied won't be removed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc53ec83419111665403d3184c5309cb3ac3114b" translate="yes" xml:space="preserve">
          <source>This function may return an error with an appropriate error tuple if the &lt;code&gt;child_id&lt;/code&gt; is not found, or if the current process is running or being restarted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ae84d6b7d02c1f5e4d3d90e843aa4994fe5afbb" translate="yes" xml:space="preserve">
          <source>This function merges two URIs as per &lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-5.2&quot;&gt;RFC 3986, section 5.2&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7249b2b7e8627d3ee0f960577e5cfe5cf5a1c42f" translate="yes" xml:space="preserve">
          <source>This function only accepts floats and always returns a float. Use &lt;a href=&quot;kernel#round/1&quot;&gt;&lt;code&gt;Kernel.round/1&lt;/code&gt;&lt;/a&gt; if you want a function that accepts both floats and integers and always returns an integer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50d8af487774d9f7e007fed31c88d7f628e11c28" translate="yes" xml:space="preserve">
          <source>This function only ever needs to store the last emitted element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="295eba0c064a53ae3a651500b18114cd09951154" translate="yes" xml:space="preserve">
          <source>This function only works if ANSI escape codes are enabled on the shell, which means this function is by default unavailable on Windows machines.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="528389cc0cdba8ed58acc495892cfb708eb725e7" translate="yes" xml:space="preserve">
          <source>This function produces the same result as the &lt;a href=&quot;kernel#++/2&quot;&gt;&lt;code&gt;Kernel.++/2&lt;/code&gt;&lt;/a&gt; operator for lists.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2bd92c0ea07d00b8bd2fd96f2a2022d49efc3e5e" translate="yes" xml:space="preserve">
          <source>This function purges all modules currently kept by the compiler, allowing old compiler module names to be reused. If there are any processes running any code from such modules, they will be terminated too.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c8f05dda04bc767a1282d611e4af5dafdcb7b8d" translate="yes" xml:space="preserve">
          <source>This function receives a list of tasks and waits for their replies in the given time interval. It returns a list of two-element tuples, with the task as the first element and the yielded result as the second. The tasks in the returned list will be in the same order as the tasks supplied in the &lt;code&gt;tasks&lt;/code&gt; input argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66ca8de099428d7febba36a7eae6660d193647fb" translate="yes" xml:space="preserve">
          <source>This function reruns the given task; to do that, it first re-enables the task and then runs it as normal.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f88acb523db6223367758a20b1546d9d8c207d7" translate="yes" xml:space="preserve">
          <source>This function returns &lt;code&gt;{:ok, owner}&lt;/code&gt; or &lt;code&gt;{:error, reason}&lt;/code&gt;. The &lt;code&gt;owner&lt;/code&gt; is the PID in the registry partition responsible for the PID. The owner is automatically linked to the caller.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="902dd92c08e25103df4b50bae4697cf10a6fc6fd" translate="yes" xml:space="preserve">
          <source>This function returns &lt;code&gt;{:ok, pid}&lt;/code&gt; in case of success, otherwise it returns &lt;code&gt;{:error, reason}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f3353899fe4360fc7c94245abd3933c4141ee40" translate="yes" xml:space="preserve">
          <source>This function returns a list of &lt;code&gt;{id, child, type, modules}&lt;/code&gt; tuples, where:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c22e6a9591d2580a185def76ec2a7822b6c5d175" translate="yes" xml:space="preserve">
          <source>This function returns a list of tuples containing:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ffb7797732e8eabda6ec4358625e5d11748d93c" translate="yes" xml:space="preserve">
          <source>This function returns a new enumerable built by appending the result of invoking &lt;code&gt;fun&lt;/code&gt; on each element of &lt;code&gt;enumerable&lt;/code&gt; together; conceptually, this is similar to a combination of &lt;a href=&quot;#map/2&quot;&gt;&lt;code&gt;map/2&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#concat/1&quot;&gt;&lt;code&gt;concat/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4c4692a1b2085c0d5c4c7060abeb21e5e80d789" translate="yes" xml:space="preserve">
          <source>This function returns a new stream built by appending the result of invoking &lt;code&gt;fun&lt;/code&gt; on each element of &lt;code&gt;enumerable&lt;/code&gt; together.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9207161e31f07b71a8de0abeb84876a37ff477ac" translate="yes" xml:space="preserve">
          <source>This function returns a timer reference, which can be read with &lt;a href=&quot;#read_timer/1&quot;&gt;&lt;code&gt;read_timer/1&lt;/code&gt;&lt;/a&gt; or canceled with &lt;a href=&quot;#cancel_timer/1&quot;&gt;&lt;code&gt;cancel_timer/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3b4424c23b3b31b7bea686c83f6fbd90413317a" translate="yes" xml:space="preserve">
          <source>This function returns a tuple containing the collected result and the command exit status.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c1572156370222a67bdcd453345528785b5b103" translate="yes" xml:space="preserve">
          <source>This function returns a tuple containing the supervisor flags and child specifications.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a236219391c9665ab6cd417a5f529892164a5643" translate="yes" xml:space="preserve">
          <source>This function returns a tuple containing the supervisor options.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f10657fb9f9d2dbe8abd5fb7b8f8b43416880ed5" translate="yes" xml:space="preserve">
          <source>This function returns an empty list when used at the root of an umbrella project because there is no compile manifest to extract the function call information from. To get the function calls of each child in an umbrella, execute the function at the root of each individual application.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6fbf0f83b2acb02bb139f54eef721ae8347767a" translate="yes" xml:space="preserve">
          <source>This function returns either &lt;code&gt;{:ok, definition, clauses}&lt;/code&gt; or &lt;code&gt;:error&lt;/code&gt;. Where &lt;code&gt;definition&lt;/code&gt; is &lt;code&gt;:def&lt;/code&gt;, &lt;code&gt;:defp&lt;/code&gt;, &lt;code&gt;:defmacro&lt;/code&gt; or &lt;code&gt;:defmacrop&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5908984f567478e4a60e81ad1b7f0e0a95ff38d7" translate="yes" xml:space="preserve">
          <source>This function returns immediately and ignores nodes that do not exist, or where the server name does not exist.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c26de55ed91737da0adcc687c60b204ef4f41f8" translate="yes" xml:space="preserve">
          <source>This function returns the breakpoint ID and will raise if there is an error setting up the breakpoint.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9031a38e543bd6739ba00dbc5fed0a5a01f11ea" translate="yes" xml:space="preserve">
          <source>This function returns the difference in seconds where seconds are measured according to &lt;a href=&quot;calendar.iso&quot;&gt;&lt;code&gt;Calendar.ISO&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef0ad46bb886f62fbf2201ba9b9f859d8daf73a5" translate="yes" xml:space="preserve">
          <source>This function returns:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc16b8c0d60d4a66a61b6088df628cb2cdbe5f10" translate="yes" xml:space="preserve">
          <source>This function should be used to convert a list of paths to a path. Note that any trailing slash is removed when joining.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f72643333bea463c7a8ea5767e80e22d1a7036bf" translate="yes" xml:space="preserve">
          <source>This function should be used to remove a specific extension which may or may not be there.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1fc59171af9c1101b367bf06403fbdf95aa428ac" translate="yes" xml:space="preserve">
          <source>This function should either return &lt;code&gt;{:ok, pid}&lt;/code&gt; or &lt;code&gt;{:ok, pid, state}&lt;/code&gt; if startup is successful. &lt;code&gt;pid&lt;/code&gt; should be the PID of the top supervisor. &lt;code&gt;state&lt;/code&gt; can be an arbitrary term, and if omitted will default to &lt;code&gt;[]&lt;/code&gt;; if the application is later stopped, &lt;code&gt;state&lt;/code&gt; is passed to the &lt;a href=&quot;#stop/1&quot;&gt;&lt;code&gt;stop/1&lt;/code&gt;&lt;/a&gt; callback (see the documentation for the &lt;a href=&quot;#c:stop/1&quot;&gt;&lt;code&gt;stop/1&lt;/code&gt;&lt;/a&gt; callback for more information).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21a65796034b404efe85bb5cf745e9599f9e6028" translate="yes" xml:space="preserve">
          <source>This function should not be used at runtime in application code (as opposed to infrastructure and build code like Mix tasks). Mix is a build tool and may not be available after the code is compiled (for example in a release).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d9efdf471f60e2ed682dd93f955c9a027ea855c" translate="yes" xml:space="preserve">
          <source>This function should not be used at runtime in application code (see &lt;a href=&quot;#env/0&quot;&gt;&lt;code&gt;env/0&lt;/code&gt;&lt;/a&gt; for more information).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf1fdd59778e871792165fd9cd597befae6dbe8a" translate="yes" xml:space="preserve">
          <source>This function should return &lt;code&gt;{:ok, value}&lt;/code&gt; where &lt;code&gt;value&lt;/code&gt; is the value under &lt;code&gt;key&lt;/code&gt; if the key exists in the term, or &lt;code&gt;:error&lt;/code&gt; if the key does not exist in the term.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e0b499c79fbb5106ff12e9b189fd33d1ca2f878" translate="yes" xml:space="preserve">
          <source>This function shouldn't be invoked directly, unless when implementing a custom &lt;code&gt;inspect_fun&lt;/code&gt; to be given to &lt;a href=&quot;inspect.opts&quot;&gt;&lt;code&gt;Inspect.Opts&lt;/code&gt;&lt;/a&gt;. Everywhere else, &lt;a href=&quot;inspect.algebra#to_doc/2&quot;&gt;&lt;code&gt;Inspect.Algebra.to_doc/2&lt;/code&gt;&lt;/a&gt; should be preferred as it handles structs and exceptions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c7b31de7bb27ac0e240dd4370dcbe439841a348" translate="yes" xml:space="preserve">
          <source>This function simply reads the configuration value for &lt;code&gt;:ansi_enabled&lt;/code&gt; in the &lt;code&gt;:elixir&lt;/code&gt; application. The value is by default &lt;code&gt;false&lt;/code&gt; unless Elixir can detect during startup that both &lt;code&gt;stdout&lt;/code&gt; and &lt;code&gt;stderr&lt;/code&gt; are terminals.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="334f3d5e4471a23891371c10f4d6629f6f864306" translate="yes" xml:space="preserve">
          <source>This function spawns a process that is linked to and monitored by the caller process. The linking part is important because it aborts the task if the parent process dies. It also guarantees the code before async/await has the same properties after you add the async call. For example, imagine you have this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c734a84fb40ac9d66210c296db69e31b0a02eadc" translate="yes" xml:space="preserve">
          <source>This function splits the given &lt;code&gt;string&lt;/code&gt; into a list of strings in a similar way to many shells.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2feb07f1ca6bdd2a159c3be3d1d2d967088b7ce0" translate="yes" xml:space="preserve">
          <source>This function uses &lt;a href=&quot;#expand_once/2&quot;&gt;&lt;code&gt;expand_once/2&lt;/code&gt;&lt;/a&gt; under the hood. Check it out for more information and examples.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e2fc530fdd36a8deb023fe2c739cc5eac5cf4d5" translate="yes" xml:space="preserve">
          <source>This function uses Erlang's &lt;a href=&quot;http://www.erlang.org/doc/man/rand.html&quot;&gt;&lt;code&gt;:rand&lt;/code&gt; module&lt;/a&gt; to calculate the random value. Check its documentation for setting a different random algorithm or a different seed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97aac23199beb8d9422f08074a16068341921614" translate="yes" xml:space="preserve">
          <source>This function uses the &lt;a href=&quot;access&quot;&gt;&lt;code&gt;Access&lt;/code&gt;&lt;/a&gt; module to traverse the structures according to the given &lt;code&gt;keys&lt;/code&gt;, unless the &lt;code&gt;key&lt;/code&gt; is a function, which is detailed in a later section.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8aa0a6bd6b734aebad750c42bf0f37171db0b991" translate="yes" xml:space="preserve">
          <source>This function uses the &lt;code&gt;ELIXIR_EDITOR&lt;/code&gt; environment variable and falls back to &lt;code&gt;EDITOR&lt;/code&gt; if the former is not available.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9cbfcbb53a61b66a747c2491e188753fa8068b44" translate="yes" xml:space="preserve">
          <source>This function uses the merge sort algorithm. The given function should compare two arguments, and return &lt;code&gt;true&lt;/code&gt; if the first argument precedes the second one.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="862ee811fb4cabde3cfb7ab7a9097a9d6c254988" translate="yes" xml:space="preserve">
          <source>This function uses the parsing regular expression as defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc3986#appendix-B&quot;&gt;RFC 3986, Appendix B&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d26051019e95731e1d7b99be08f5928a37367d27" translate="yes" xml:space="preserve">
          <source>This function was designed to camelize language identifiers/tokens, that's why it belongs to the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Macro&lt;/code&gt;&lt;/a&gt; module. Do not use it as a general mechanism for camelizing strings as it does not support Unicode or characters that are not valid in Elixir identifiers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="582211980e20afdfe93b93a25608463f5c56a8bf" translate="yes" xml:space="preserve">
          <source>This function was designed to underscore language identifiers/tokens, that's why it belongs to the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Macro&lt;/code&gt;&lt;/a&gt; module. Do not use it as a general mechanism for underscoring strings as it does not support Unicode or characters that are not valid in Elixir identifiers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ddcb598fb0ce62c01ead735edd62ec7ef5afb147" translate="yes" xml:space="preserve">
          <source>This function will instrument the given module and load a new version in memory with breakpoints at the given function and arity. If the module is recompiled, all breakpoints are lost.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b8f47c44e23aa37c7285c683f845cd5e9a96e09" translate="yes" xml:space="preserve">
          <source>This function will merge the given keyword list into the existing metadata, with the exception of setting a key to &lt;code&gt;nil&lt;/code&gt;, which will remove that key from the metadata.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11a397f1ed689beeb86c4bc32143ddefc115ba76" translate="yes" xml:space="preserve">
          <source>This function will raise &lt;a href=&quot;functionclauseerror&quot;&gt;&lt;code&gt;FunctionClauseError&lt;/code&gt;&lt;/a&gt; if the given &lt;code&gt;node&lt;/code&gt; is not alive.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6b9fdfcab204aeb9ec68e1e7116d2ac8debacde" translate="yes" xml:space="preserve">
          <source>This function will retrieve the available clauses from bytecode and evaluate them against the given arguments. The clauses are returned as a list of &lt;code&gt;{args, guards}&lt;/code&gt; pairs where each argument and each top-level condition in a guard separated by &lt;code&gt;and&lt;/code&gt;/&lt;code&gt;or&lt;/code&gt; is wrapped in a tuple with blame metadata.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="029c82ca4692615f6cc90f101026e01c3b5dc4e0" translate="yes" xml:space="preserve">
          <source>This functionality starts the &lt;code&gt;:net_kernel&lt;/code&gt; and other related processes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5c0fe11d15d66b3e64978f03cccbe68ad69f39c" translate="yes" xml:space="preserve">
          <source>This guarantees all messages sent to &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Logger&lt;/code&gt;&lt;/a&gt; prior to this call will be processed. This is useful for testing and it should not be called in production code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="931eb8597cbb84926c09fb6a3b1aa749f547e621" translate="yes" xml:space="preserve">
          <source>This guide aims to introduce the meta-programming techniques available in Elixir. The ability to represent an Elixir program by its own data structures is at the heart of meta-programming. This chapter starts by exploring those structures and the associated &lt;code&gt;quote&lt;/code&gt; and &lt;code&gt;unquote&lt;/code&gt; constructs, so we can take a look at macros in the next chapter and finally build our own domain specific language.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5849b2456045ed3a32dde6f55db3e066f023528f" translate="yes" xml:space="preserve">
          <source>This happens because the only place the formatter can introduce a new line without changing the code semantics is in the interpolation. In those scenarios, we recommend developers to directly adjust the code. Here we can use the binary concatenation operator &lt;a href=&quot;kernel#%253C%253E/2&quot;&gt;&lt;code&gt;&amp;lt;&amp;gt;/2&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ccb1f24686f9c6bcd91b3b281d116c9f04cb68f5" translate="yes" xml:space="preserve">
          <source>This helper only works when IEx is started with a Mix project, for example, &lt;code&gt;iex -S mix&lt;/code&gt;. The application is not restarted after compilation, which means any long running process may crash as any changed module will be temporarily removed and recompiled, without going through the proper code changes callback.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af9ea0d60815c82f22be854ae11982e7962bd190" translate="yes" xml:space="preserve">
          <source>This implementation also adds &lt;a href=&quot;#force_unfit/1&quot;&gt;&lt;code&gt;force_unfit/1&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#next_break_fits/2&quot;&gt;&lt;code&gt;next_break_fits/2&lt;/code&gt;&lt;/a&gt; which give more control over the document fitting.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ecf1cb6c3f0131a137b0e41a93d52ab7359f8a7c" translate="yes" xml:space="preserve">
          <source>This implementation provides two types of breaks: &lt;code&gt;:strict&lt;/code&gt; and &lt;code&gt;:flex&lt;/code&gt;. When a group does not fit, all strict breaks are treated as newlines. Flex breaks however are re-evaluated on every occurrence and may still be rendered flat. See &lt;a href=&quot;#break/1&quot;&gt;&lt;code&gt;break/1&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#flex_break/1&quot;&gt;&lt;code&gt;flex_break/1&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc54167321bb690ef67cdb4d7c3892839915a92e" translate="yes" xml:space="preserve">
          <source>This information is returned based on the code path. Here is an example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60031e59b55c11c2eb9a171c6db3ebaf52a6c050" translate="yes" xml:space="preserve">
          <source>This is Mix's default shell.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5053391a8e72e9d443f680cf9656acc6cdd0a4d5" translate="yes" xml:space="preserve">
          <source>This is a bad idea, as we don&amp;rsquo;t want the registry to crash when a bucket crashes. The proper fix is to actually not link the bucket to the registry. Instead, we will link each bucket to a special type of process called Supervisors, which are explicitly designed to handle failures and crashes. We will learn more about them in the next chapter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e5ab726c57b0fb6f6da70a28676a9b1f70f7bab" translate="yes" xml:space="preserve">
          <source>This is a hard-deprecation as it emits warnings and annotates the documentation as deprecated:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c34842432839543d617525657c5d1288600c6c0e" translate="yes" xml:space="preserve">
          <source>This is a soft-deprecation as it simply annotates the documentation as deprecated:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77df0c1b4e2776653e0c5177f9ffa6268916531c" translate="yes" xml:space="preserve">
          <source>This is actually a common pitfall when developing macros. We are assuming a particular shape in the macro. We can work around it by unquoting the variable inside the quoted expression:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0dc899362b8fa129cf65071f623d739413cc73aa" translate="yes" xml:space="preserve">
          <source>This is all good and well, but we still want to offer our users an API that allows us to hide our implementation details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7b133b5999cc2d686bfdd612eea0550282bc0a5" translate="yes" xml:space="preserve">
          <source>This is also the syntax that Elixir uses to inspect keyword lists:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="695d7b0825ac4fbdcbd163159a7fc336c49f943b" translate="yes" xml:space="preserve">
          <source>This is an anti-pattern not only because it convolutes the calculator logic but also because you put the calculator logic behind a single process that will potentially become a bottleneck in your system, especially as the number of calls grow. Instead just define the functions directly:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d1d1dd333c995d40a1c0f70de189cf4bf055fbb" translate="yes" xml:space="preserve">
          <source>This is an extension of &lt;a href=&quot;#myers_difference/2&quot;&gt;&lt;code&gt;myers_difference/2&lt;/code&gt;&lt;/a&gt; where a &lt;code&gt;diff_script&lt;/code&gt; function can be given in case it is desired to compute nested differences. The function may return a list with the inner edit script or &lt;code&gt;nil&lt;/code&gt; in case there is no such script. The returned inner edit script will be under the &lt;code&gt;:diff&lt;/code&gt; key.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c0d7fab04e5bf783756a7f428e6b36128d23270" translate="yes" xml:space="preserve">
          <source>This is an optimization for &lt;code&gt;enumerable |&amp;gt; Enum.reverse() |&amp;gt; Enum.concat(tail)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8a27bb1d6f71fa4c6c204cb8cc47805a7ed11d7" translate="yes" xml:space="preserve">
          <source>This is an option determining the prompt displayed to the user when awaiting input.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d40bb6ddf99cda982a812b8ae52262c178bb85e3" translate="yes" xml:space="preserve">
          <source>This is because the macro is expecting its arguments to be a keyword list at &lt;strong&gt;compilation&lt;/strong&gt; time. Since in the example above we are passing the representation of the variable &lt;code&gt;kv&lt;/code&gt;, our code fails.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21f107c1b12d2af11cc6fc5fce200280f5598e01" translate="yes" xml:space="preserve">
          <source>This is either a plain PID or a value representing a registered name. See the &quot;Name registration&quot; section of this document for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9679cc98b384d2fae74f5c4e147d814a3605b34" translate="yes" xml:space="preserve">
          <source>This is equivalent to &lt;code&gt;else if&lt;/code&gt; clauses in many imperative languages (although used way less frequently here).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20b3f3a29153ddca60608cf1ff19217f8f298150" translate="yes" xml:space="preserve">
          <source>This is implemented as a macro so it can be used in guard clauses.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6ca1cc005536f5b89386dac5e9eaab2c71326b3" translate="yes" xml:space="preserve">
          <source>This is in contrast to &lt;a href=&quot;#split/3&quot;&gt;&lt;code&gt;split/3&lt;/code&gt;&lt;/a&gt; which splits the entire string upfront.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6a69df7f8c6fe2ffd7e21f569ce958484e18a07" translate="yes" xml:space="preserve">
          <source>This is mainly useful in tests, allowing us to assert if given messages were received or not instead of performing checks on some captured IO. Since we need to guarantee a clean slate between tests, there is also a &lt;a href=&quot;#flush/1&quot;&gt;&lt;code&gt;flush/1&lt;/code&gt;&lt;/a&gt; function responsible for flushing all &lt;code&gt;:mix_shell&lt;/code&gt; related messages from the process inbox.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3cb696d174caaa2396a3c713ad639f81cfe5da1" translate="yes" xml:space="preserve">
          <source>This is often used to emulate configuration across environments:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58dabc93b2ce93a10dc83d366ab232e1eea3c140" translate="yes" xml:space="preserve">
          <source>This is often used to start the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt; as part of a supervision tree.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="320f2d885658e9db2171a44a753f72f41faf6056" translate="yes" xml:space="preserve">
          <source>This is often used to start the agent as part of a supervision tree.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="626d510108035955935a541c301f344a380255ad" translate="yes" xml:space="preserve">
          <source>This is often used to start the process as part of a supervision tree.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30067513715299ced12cf77d1d47bd85e8cef7ec" translate="yes" xml:space="preserve">
          <source>This is often useful when used with &lt;a href=&quot;macro#prewalk/2&quot;&gt;&lt;code&gt;Macro.prewalk/2&lt;/code&gt;&lt;/a&gt; to remove information like lines and hygienic counters from the expression for either storage or comparison.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4240cfedebaf42c2fac3f95a041f2d57c453967e" translate="yes" xml:space="preserve">
          <source>This is only used when the task is used for side-effects (i.e. no interest in the returned result) and it should not be linked to the current process.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="077e7548b6aaec650e916de489ebe79d6d5f3c44" translate="yes" xml:space="preserve">
          <source>This is pretty much all we need to implement our echo server. Let&amp;rsquo;s give it a try!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81016b61e7a2b5883ac247d4885c2d149315bdb9" translate="yes" xml:space="preserve">
          <source>This is similar to &lt;a href=&quot;#get_and_update_in/3&quot;&gt;&lt;code&gt;get_and_update_in/3&lt;/code&gt;&lt;/a&gt;, except the path is extracted via a macro rather than passing a list. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50c031832816906ca789ff0f4ad1f1b4dfcf5d4e" translate="yes" xml:space="preserve">
          <source>This is similar to &lt;a href=&quot;#pop_in/2&quot;&gt;&lt;code&gt;pop_in/2&lt;/code&gt;&lt;/a&gt;, except the path is extracted via a macro rather than passing a list. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7523a1751f43741a0a08ddae723c5c9199fa87e6" translate="yes" xml:space="preserve">
          <source>This is similar to &lt;a href=&quot;#put_in/3&quot;&gt;&lt;code&gt;put_in/3&lt;/code&gt;&lt;/a&gt;, except the path is extracted via a macro rather than passing a list. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22e8ffb1e74ab770f905747e9a80ef5c0478eb99" translate="yes" xml:space="preserve">
          <source>This is similar to &lt;a href=&quot;#update_in/3&quot;&gt;&lt;code&gt;update_in/3&lt;/code&gt;&lt;/a&gt;, except the path is extracted via a macro rather than passing a list. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08ab0b2ff940cf63760635df2e0fe23beb3cbaa7" translate="yes" xml:space="preserve">
          <source>This is similar to the mistake we made when we called &lt;code&gt;KV.Bucket.start_link/1&lt;/code&gt; straight from the registry. That meant a failure in any bucket would bring the whole registry down.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e61420057f50d9b6c715f4347be7ca8efd78730b" translate="yes" xml:space="preserve">
          <source>This is the default used by &lt;a href=&quot;uri#encode/2&quot;&gt;&lt;code&gt;URI.encode/2&lt;/code&gt;&lt;/a&gt; where both reserved and unreserved characters are kept unescaped.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0dc79651e84bb5089915ce0f6bd2c110d8036119" translate="yes" xml:space="preserve">
          <source>This is the function invoked when there is string interpolation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b687c89eb6e152da4dd73f09f730d0ddb490ab0" translate="yes" xml:space="preserve">
          <source>This is the list of directories the Erlang VM uses for finding module code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a08d7b564f58b24087fbb35fa3617eff44897de1" translate="yes" xml:space="preserve">
          <source>This is the moment, in your calendar, when the current day ends and the next day starts.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9162b52e4ae81113f3c3ee3bea2997ff399ccecc" translate="yes" xml:space="preserve">
          <source>This is the number of days including the fractional part that has passed of the last day since 0000-01-01+00:00T00:00.000000 in ISO 8601 notation (also known as midnight 1 January BC 1 of the proleptic Gregorian calendar).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="289ea50e9ca33fea490350d4d95a5411c3088228" translate="yes" xml:space="preserve">
          <source>This is the same AST as &lt;code&gt;not(left in right)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6d704491ec250974e27401b8e2b811c3f199e66" translate="yes" xml:space="preserve">
          <source>This is the same template generated by &lt;code&gt;mix new --sup&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5580fdfd5d3be89e971bd5cfbc417edd38ca5b8e" translate="yes" xml:space="preserve">
          <source>This is the special form used whenever we have a block of expressions in Elixir. This special form is private and should not be invoked directly:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac7417af7c2a4cf8300b3d4dd8d7d38b6e9711f6" translate="yes" xml:space="preserve">
          <source>This is the unescaping behaviour used by default in Elixir single- and double-quoted strings. Check &lt;a href=&quot;#unescape_string/2&quot;&gt;&lt;code&gt;unescape_string/2&lt;/code&gt;&lt;/a&gt; for information on how to customize the escaping map.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13cd7a952e7bcf9bdf6ec9068841b4aa1581c6f4" translate="yes" xml:space="preserve">
          <source>This is typically invoked at the end of the &lt;a href=&quot;#c:init/1&quot;&gt;&lt;code&gt;init/1&lt;/code&gt;&lt;/a&gt; callback of module-based supervisors. See the &quot;Module-based supervisors&quot; section in the module documentation for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c3451cd606049c68c6fdb6bd088a1087ca448fd" translate="yes" xml:space="preserve">
          <source>This is typically invoked at the end of the &lt;a href=&quot;#c:init/1&quot;&gt;&lt;code&gt;init/1&lt;/code&gt;&lt;/a&gt; callback of module-based supervisors. See the sections &quot;Module-based supervisors&quot; and &quot;start_link/2, init/2, and strategies&quot; in the module documentation for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af7248045672bdf709fa9a7434ee693bbb5b3f33" translate="yes" xml:space="preserve">
          <source>This is used by Elixir's code formatter to avoid breaking code at some specific locations. For example, consider this code:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9e62f945dfe72ca17b7bcf35230b54a13d5ce33" translate="yes" xml:space="preserve">
          <source>This is used by third-party projects, like QuickCheck, to implement macros like &lt;code&gt;property/3&lt;/code&gt; that works like &lt;code&gt;test&lt;/code&gt; but instead defines a property. See &lt;a href=&quot;#test/3&quot;&gt;&lt;code&gt;test/3&lt;/code&gt;&lt;/a&gt; implementation for an example of invoking this function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c60447d6bcf0312eb4c4e52c080f8e8aeffd1b2" translate="yes" xml:space="preserve">
          <source>This is useful for debugging a particular chunk of code when executed by a particular process. The process becomes the evaluator of IEx commands and is temporarily changed to have a custom group leader. Those values are reverted by calling &lt;a href=&quot;iex.helpers#respawn/0&quot;&gt;&lt;code&gt;IEx.Helpers.respawn/0&lt;/code&gt;&lt;/a&gt;, which starts a new IEx shell, freeing up the pried one.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aaba5c733f8e5f3a464f80421ccdf2cbfb12126e" translate="yes" xml:space="preserve">
          <source>This is useful if the default value is very expensive to calculate or generally difficult to setup and teardown again.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e90f6c096938c0c1b08fe0f1a4ed6112b1726e64" translate="yes" xml:space="preserve">
          <source>This is useful if the value is very expensive to calculate or generally difficult to setup and teardown again.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a46a616db1ce450247219cde25e3ee509bdc87d" translate="yes" xml:space="preserve">
          <source>This is useful when a stream needs to be run, for side effects, and there is no interest in its return result.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8454071c897ae3b3f6c5cf6b435c8859ed4d0efe" translate="yes" xml:space="preserve">
          <source>This is useful when a struct needs to be expanded at compilation time and the struct being expanded may or may not have been compiled. This function is even capable of expanding structs defined under the module being compiled.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5765e6f4f6c943fc2869a6d958ffb07d4ecdc95a" translate="yes" xml:space="preserve">
          <source>This is usually called by sessions started with &lt;a href=&quot;iex#pry/0&quot;&gt;&lt;code&gt;IEx.pry/0&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;iex#break!/4&quot;&gt;&lt;code&gt;IEx.break!/4&lt;/code&gt;&lt;/a&gt;. This allows the current process to execute until the next breakpoint, which will automatically yield control back to IEx without requesting permission to pry.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5c28e5992d11ab017599cfba8c0660377868c31" translate="yes" xml:space="preserve">
          <source>This is usually called by tasks that need additional functions on the project to be defined. Since such tasks usually depend on a project being defined, this function raises a &lt;a href=&quot;mix.noprojecterror&quot;&gt;&lt;code&gt;Mix.NoProjectError&lt;/code&gt;&lt;/a&gt; exception in case no project is available.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89c99ecc9ec64bbd119250b6f605dbf4510f1e46" translate="yes" xml:space="preserve">
          <source>This key is optional, only needed for applications that start a supervision tree.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29ecf7d31c543b3beaa11f8d6b32d12f2cddd50a" translate="yes" xml:space="preserve">
          <source>This lets you put imports in &lt;code&gt;.iex.exs&lt;/code&gt; files (including &lt;code&gt;~/.iex.exs&lt;/code&gt;) without getting compile errors if you open a console where the module is not available.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5847e98d18087e669daaf541b861bb0616506ae" translate="yes" xml:space="preserve">
          <source>This lets you use the module in &lt;code&gt;.iex.exs&lt;/code&gt; files (including &lt;code&gt;~/.iex.exs&lt;/code&gt;) without getting compile errors if you open a console where the module is not available.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e593f23f33013dc92ddfcd3a9c60d10f99bd1858" translate="yes" xml:space="preserve">
          <source>This linear behaviour should also be expected on operations like &lt;a href=&quot;#count/1&quot;&gt;&lt;code&gt;count/1&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#member?/2&quot;&gt;&lt;code&gt;member?/2&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#at/2&quot;&gt;&lt;code&gt;at/2&lt;/code&gt;&lt;/a&gt; and similar. While Elixir does allow data types to provide performant variants for such operations, you should not expect it to always be available, since the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Enum&lt;/code&gt;&lt;/a&gt; module is meant to work with a large variety of data types and not all data types can provide optimized behaviour.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0519fbd8b9b5639ec90e00d83250f771f4f40453" translate="yes" xml:space="preserve">
          <source>This macro addresses this issue by checking if the file exists or not in behalf of the user.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5cc6e8a94ed92b3b0f91dd0c407badd0f4cd9583" translate="yes" xml:space="preserve">
          <source>This macro defines a module with the given &lt;code&gt;alias&lt;/code&gt; as its name and with the given contents. It returns a tuple with four elements:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba5022c9c8161864d7b55a2f306a7cb1932890b2" translate="yes" xml:space="preserve">
          <source>This macro evaluates and returns the &lt;code&gt;do&lt;/code&gt; block passed in as the second argument if &lt;code&gt;condition&lt;/code&gt; evaluates to a falsy value (&lt;code&gt;false&lt;/code&gt; or &lt;code&gt;nil&lt;/code&gt;). Otherwise, it returns the value of the &lt;code&gt;else&lt;/code&gt; block if present or &lt;code&gt;nil&lt;/code&gt; if not.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="053dc4326086a38d85524369b85300ca1b5d0614" translate="yes" xml:space="preserve">
          <source>This macro expects the first argument to be a condition and the second argument to be a keyword list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7318b11fdb5ce2984ea08a62c18118bc9d28bcc" translate="yes" xml:space="preserve">
          <source>This makes your code clearer and easier to test and maintain, as you can invoke and test &lt;code&gt;do_this_that_and_that/3&lt;/code&gt; directly. It also helps you design an actual API for developers that do not want to rely on macros.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="781a3479b6ef9afbd878f1e315bbde3afc7381db" translate="yes" xml:space="preserve">
          <source>This means &lt;a href=&quot;#get_and_update_in/3&quot;&gt;&lt;code&gt;get_and_update_in/3&lt;/code&gt;&lt;/a&gt; can be extended to provide custom lookups. The downside is that functions cannot be stored as keys in the accessed data structures.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cfd9674170ea7f680e0ec4f0f9ace7b923ad6168" translate="yes" xml:space="preserve">
          <source>This means &lt;a href=&quot;#get_in/2&quot;&gt;&lt;code&gt;get_in/2&lt;/code&gt;&lt;/a&gt; can be extended to provide custom lookups. The downside is that functions cannot be stored as keys in the accessed data structures.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a04c313f02da8b2b423b92a32377c49ecdd6219" translate="yes" xml:space="preserve">
          <source>This means files can be passed between nodes and message passing guarantees they can write to the same file in a network.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e15019a33fea88c51d5e497980380e75ee3dd48" translate="yes" xml:space="preserve">
          <source>This means often there are performance costs in using the functions in this module, compared to the more low-level operations that work directly with binaries:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8571bea1bef1bde6a2d1b2d12776f78df57e4340" translate="yes" xml:space="preserve">
          <source>This means our implementation is going in the correct direction, but it doesn&amp;rsquo;t look very elegant, does it?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64cb76e001bde4ce0c23b9ae9350ed13f2f87e6d" translate="yes" xml:space="preserve">
          <source>This means reserved characters, such as &lt;code&gt;:&lt;/code&gt; and &lt;code&gt;/&lt;/code&gt;, and the so-called unreserved characters, which have the same meaning both escaped and unescaped, won't be escaped by default.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="466121cf36d188101adba56c09d86681a5f8592b" translate="yes" xml:space="preserve">
          <source>This means that when performing multiple operations with &lt;code&gt;Enum&lt;/code&gt;, each operation is going to generate an intermediate list until we reach the result:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e439478d8b723981d4581d054a8682120535699c" translate="yes" xml:space="preserve">
          <source>This means the VM no longer needs to keep the stacktrace once inside an &lt;code&gt;else&lt;/code&gt; clause and so tail recursion is possible when using a &lt;code&gt;try&lt;/code&gt; with a tail call as the final call inside an &lt;code&gt;else&lt;/code&gt; clause. The same is true for &lt;code&gt;rescue&lt;/code&gt; and &lt;code&gt;catch&lt;/code&gt; clauses.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03cbb2743a8fea6a87cdaa1b5871df611958047b" translate="yes" xml:space="preserve">
          <source>This means we can also configure our &lt;code&gt;:routing_table&lt;/code&gt; directly in the &lt;code&gt;config/config.exs&lt;/code&gt; file. However, which configuration value should we use?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d88b91b0ac64ad4e82abb4e5d0dae196f85569c8" translate="yes" xml:space="preserve">
          <source>This message was triggered by invoking the helper &lt;code&gt;h()&lt;/code&gt;, usually referred to as &lt;a href=&quot;#h/0&quot;&gt;&lt;code&gt;h/0&lt;/code&gt;&lt;/a&gt; (since it expects 0 arguments).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f38cc8ed71ef5111e6f4d0950287ab1718bd370" translate="yes" xml:space="preserve">
          <source>This module allows a developer to define a test case template to be used throughout their tests. This is useful when there are a set of functions that should be shared between tests or a set of setup callbacks.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29465ded0e12b42e58045ba6de87bf204437ce87" translate="yes" xml:space="preserve">
          <source>This module allows developers to specify a string that serves as template for log messages, for example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4305f790d0ec82e224afef341de114e73b6a1e74" translate="yes" xml:space="preserve">
          <source>This module also documents macros that return information about Elixir's compilation environment, such as (&lt;a href=&quot;#__ENV__/0&quot;&gt;&lt;code&gt;__ENV__/0&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#__MODULE__/0&quot;&gt;&lt;code&gt;__MODULE__/0&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#__DIR__/0&quot;&gt;&lt;code&gt;__DIR__/0&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#__CALLER__/0&quot;&gt;&lt;code&gt;__CALLER__/0&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8d05e55cf46fce50db35799f75e85316f97b59d" translate="yes" xml:space="preserve">
          <source>This module also includes helpers for debugging purposes, see &lt;a href=&quot;iex#break!/4&quot;&gt;&lt;code&gt;IEx.break!/4&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef6795d77de60f24997761f8faf2a5faa8a9879b" translate="yes" xml:space="preserve">
          <source>This module also provides low-level functions, such as &lt;a href=&quot;#next/2&quot;&gt;&lt;code&gt;next/2&lt;/code&gt;&lt;/a&gt;, for parsing switches manually, as well as &lt;a href=&quot;#split/1&quot;&gt;&lt;code&gt;split/1&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#to_argv/1&quot;&gt;&lt;code&gt;to_argv/1&lt;/code&gt;&lt;/a&gt; for parsing from and converting switches to strings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08818329b397b72cb93efb576183f5c8fee90efe" translate="yes" xml:space="preserve">
          <source>This module also provides many convenience functions for creating streams, like &lt;a href=&quot;stream#cycle/1&quot;&gt;&lt;code&gt;Stream.cycle/1&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;stream#unfold/2&quot;&gt;&lt;code&gt;Stream.unfold/2&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;stream#resource/3&quot;&gt;&lt;code&gt;Stream.resource/3&lt;/code&gt;&lt;/a&gt; and more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad2b3a4e9085aa555ad326d7ab4e688a30372b07" translate="yes" xml:space="preserve">
          <source>This module also provides other convenience functions like &lt;code&gt;assert_in_delta&lt;/code&gt; and &lt;code&gt;assert_raise&lt;/code&gt; to easily handle other common cases such as checking a floating-point number or handling exceptions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e2d831a828a6863612cdac8824ced54a83aa6de" translate="yes" xml:space="preserve">
          <source>This module automatically includes all callbacks defined in &lt;a href=&quot;exunit.callbacks&quot;&gt;&lt;code&gt;ExUnit.Callbacks&lt;/code&gt;&lt;/a&gt;. See that module for more information on &lt;code&gt;setup&lt;/code&gt;, &lt;code&gt;start_supervised&lt;/code&gt;, &lt;code&gt;on_exit&lt;/code&gt; and the test process lifecycle.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6257d1fd58c649338860fae4d9c7189fabdb3f2" translate="yes" xml:space="preserve">
          <source>This module complements Erlang's &lt;a href=&quot;http://www.erlang.org/doc/man/code.html&quot;&gt;&lt;code&gt;:code&lt;/code&gt; module&lt;/a&gt; to add behaviour which is specific to Elixir. Almost all of the functions in this module have global side effects on the behaviour of Elixir.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="653ac253ebf8eeb2f4ad27098db4993bb2625263" translate="yes" xml:space="preserve">
          <source>This module contains a set of assertion functions that are imported by default into your test cases.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="922f087298c98adf032ad8b0ed4a5b0046285656" translate="yes" xml:space="preserve">
          <source>This module contains functions to manipulate files.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="999b5229e2658017fe9fe551f8ab83bda85a2221" translate="yes" xml:space="preserve">
          <source>This module contains three functions for compiling and evaluating files. Here is a summary of them and their behaviour:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6edd43c8bb392184539818160b2c1a73b42dd599" translate="yes" xml:space="preserve">
          <source>This module defines a behaviour for providing time zone data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc612a9ae903e6387df477d371e55523892dcb6f" translate="yes" xml:space="preserve">
          <source>This module defines a supervisor which can be used to dynamically supervise tasks.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff54a5422bbcc14ae0339cf9003ae87e696322e7" translate="yes" xml:space="preserve">
          <source>This module defines the &lt;a href=&quot;#setup/1&quot;&gt;&lt;code&gt;setup/1&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#setup/2&quot;&gt;&lt;code&gt;setup/2&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#setup_all/1&quot;&gt;&lt;code&gt;setup_all/1&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#setup_all/2&quot;&gt;&lt;code&gt;setup_all/2&lt;/code&gt;&lt;/a&gt; callbacks, as well as the &lt;a href=&quot;#on_exit/2&quot;&gt;&lt;code&gt;on_exit/2&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#start_supervised/2&quot;&gt;&lt;code&gt;start_supervised/2&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#stop_supervised/1&quot;&gt;&lt;code&gt;stop_supervised/1&lt;/code&gt;&lt;/a&gt; functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="adca2c4f19b234afbf1c3981b55410081f195e79" translate="yes" xml:space="preserve">
          <source>This module defines the responsibilities for working with calendars, dates, times and datetimes in Elixir.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b157bc741bdfd8ba6ae8d42ded3b63cf4cd77d7" translate="yes" xml:space="preserve">
          <source>This module implements the functionality described in &lt;a href=&quot;http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.34.2200&quot;&gt;&quot;Strictly Pretty&quot; (2000) by Christian Lindig&lt;/a&gt; with small additions, like support for binary nodes and a break mode that maximises use of horizontal space.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="112202a17c89837b3a647d3e666a456f2e4b078d" translate="yes" xml:space="preserve">
          <source>This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the &lt;code&gt;when&lt;/code&gt; operator. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83714cee8828e8f9110c531415bac329978b2d35" translate="yes" xml:space="preserve">
          <source>This module is deprecated, use the &lt;a href=&quot;mapset&quot;&gt;&lt;code&gt;MapSet&lt;/code&gt;&lt;/a&gt; module instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="698253e94267be04646f8c090c390fb2cc54ab28" translate="yes" xml:space="preserve">
          <source>This module is deprecated. Instead of &lt;a href=&quot;#defcallback/1&quot;&gt;&lt;code&gt;defcallback/1&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#defmacrocallback/1&quot;&gt;&lt;code&gt;defmacrocallback/1&lt;/code&gt;&lt;/a&gt;, the &lt;code&gt;@callback&lt;/code&gt; and &lt;code&gt;@macrocallback&lt;/code&gt; module attributes can be used (respectively). See the documentation for &lt;a href=&quot;module&quot;&gt;&lt;code&gt;Module&lt;/code&gt;&lt;/a&gt; for more information on these attributes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fdf2b70f41d95f88ee9e4aeda784850c33cb6114" translate="yes" xml:space="preserve">
          <source>This module is deprecated. Use @callback and @macrocallback attributes instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21c46dbb91fb819b2c0d1361c70dbb30920cffa0" translate="yes" xml:space="preserve">
          <source>This module is deprecated. Use Map instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39e094eeeb209ce88d3bf96eb154f3cef16627e8" translate="yes" xml:space="preserve">
          <source>This module is deprecated. Use Map or Keyword modules instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45cb95722786d1fc420f1550713942a3d2a40ee4" translate="yes" xml:space="preserve">
          <source>This module is deprecated. Use MapSet instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8d2e8897e9809b530aad6556d1d82b7d911062f" translate="yes" xml:space="preserve">
          <source>This module is deprecated. Use the &lt;a href=&quot;map&quot;&gt;&lt;code&gt;Map&lt;/code&gt;&lt;/a&gt; module instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff61ace86ab234eb7df8bf6ecf37e092b5b0882a" translate="yes" xml:space="preserve">
          <source>This module is deprecated. Use the &lt;a href=&quot;mapset&quot;&gt;&lt;code&gt;MapSet&lt;/code&gt;&lt;/a&gt; module instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51805cd79a5e913405d55c2dfa613daced6e0652" translate="yes" xml:space="preserve">
          <source>This module is deprecated. Use the new child specifications outlined in the Supervisor module instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="090a0510a4b709bb729894c57c0c587dc11055ba" translate="yes" xml:space="preserve">
          <source>This module is most commonly used to define application configuration, typically in &lt;code&gt;config/config.exs&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2befac5116f60db9c19a013fd1aa9a67a87481ad" translate="yes" xml:space="preserve">
          <source>This module must be used in other modules as a way to configure and prepare them for testing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b22afa6be61052c1f9cdf8dac15ff3c336d6750" translate="yes" xml:space="preserve">
          <source>This module provides 3 main APIs for you to use:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="769d078447abaa6265ad7bb0de8a70d942cff612" translate="yes" xml:space="preserve">
          <source>This module provides a Mix shell implementation that uses the current process mailbox for communication instead of IO.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61d141fedc9a9bf97077c1d4c4dd489c9b785e1b" translate="yes" xml:space="preserve">
          <source>This module provides convenience functions for traversing other structures, like tuples and lists. These functions can be used in all the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Access&lt;/code&gt;&lt;/a&gt;-related functions and macros in &lt;a href=&quot;kernel&quot;&gt;&lt;code&gt;Kernel&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="782a5e74e17fd10ef3053ba12c4f6db6d729bfdd" translate="yes" xml:space="preserve">
          <source>This module provides conveniences for manipulating or retrieving file system paths.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da08bc2535ffa10b4ff19a553d1b9ea3a60095e8" translate="yes" xml:space="preserve">
          <source>This module provides conveniences for working with records at compilation time, where compile-time field names are used to manipulate the tuples, providing fast operations on top of the tuples' compact structure.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8865f287fbd66961e8c5ed897c4cb1e98bb7854" translate="yes" xml:space="preserve">
          <source>This module provides data encoding and decoding functions according to &lt;a href=&quot;https://tools.ietf.org/html/rfc4648&quot;&gt;RFC 4648&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="775daee9805ae8be33fdd0d2d338cd5f646e58b6" translate="yes" xml:space="preserve">
          <source>This module provides functions for working with URIs (for example, parsing URIs or encoding query strings). The functions in this module are implemented according to &lt;a href=&quot;https://tools.ietf.org/html/rfc3986&quot;&gt;RFC 3986&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="975d761a831604643250ee0022304cbf208c888f" translate="yes" xml:space="preserve">
          <source>This module relies on this behaviour to ignore such invalid characters. For example, &lt;a href=&quot;#length/1&quot;&gt;&lt;code&gt;length/1&lt;/code&gt;&lt;/a&gt; will return a correct result even if an invalid code point is fed into it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2a3fd3d8cfc91e72f80f4c370ccf8f3a32b7b9d" translate="yes" xml:space="preserve">
          <source>This module uses the byte size to compute how much space there is left. If your document contains strings, then those need to be wrapped in &lt;a href=&quot;#string/1&quot;&gt;&lt;code&gt;string/1&lt;/code&gt;&lt;/a&gt;, which then relies on &lt;a href=&quot;string#length/1&quot;&gt;&lt;code&gt;String.length/1&lt;/code&gt;&lt;/a&gt; to precompute the document size.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf6c5bbe802615e0aa5a1527fbeb868a3dd4e46f" translate="yes" xml:space="preserve">
          <source>This operation happens in constant time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0323d90aa13d0480aa31c479eb72ceeb1afc3cbd" translate="yes" xml:space="preserve">
          <source>This operation is meant to be used with &quot;raw&quot; devices that are started without an encoding. The given &lt;code&gt;iodata&lt;/code&gt; is written as is to the device, without conversion. For more information on IO data, see the &quot;IO data&quot; section in the module documentation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="caa455aca538782e938e4b888f46d0efc72ad432" translate="yes" xml:space="preserve">
          <source>This operation is not recursive.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6cf233431f4056abd018dbc95c859c52d627d1ab" translate="yes" xml:space="preserve">
          <source>This operation is potentially expensive, as it reads data from the file system, parses beam files, evaluates code and so on.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ac87cbe297ccc151c1adeb864d9d02cdda18b09" translate="yes" xml:space="preserve">
          <source>This operator (which is a macro) simply translates to a call to &lt;a href=&quot;enum#member?/2&quot;&gt;&lt;code&gt;Enum.member?/2&lt;/code&gt;&lt;/a&gt;. The example above would translate to:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="331fe094cd09d757ad66d6f225117b31c709d88f" translate="yes" xml:space="preserve">
          <source>This operator considers 1 and 1.0 to be equal. For match comparison, use &lt;a href=&quot;#!==/2&quot;&gt;&lt;code&gt;!==/2&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a93d5027785794a41da95cb35f0cd6d2acb007f9" translate="yes" xml:space="preserve">
          <source>This operator considers 1 and 1.0 to be equal. For stricter semantics, use &lt;a href=&quot;#===/2&quot;&gt;&lt;code&gt;===/2&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d9501c58df67371e18635ed16fc7a445f5df561" translate="yes" xml:space="preserve">
          <source>This operator introduces the expression on the left-hand side as the first argument to the function call on the right-hand side.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f341e422c93c5bb9c0446195cea1180bec59b5b7" translate="yes" xml:space="preserve">
          <source>This operator is used in two distinct occasions in Elixir. It is used in typespecs to specify the type of a variable, function or of a type itself:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="769404e29fd0d9c0c1b74fd982594f4931cda146" translate="yes" xml:space="preserve">
          <source>This protocol requires four functions to be implemented, &lt;a href=&quot;#reduce/3&quot;&gt;&lt;code&gt;reduce/3&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#count/1&quot;&gt;&lt;code&gt;count/1&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#member?/2&quot;&gt;&lt;code&gt;member?/2&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#slice/1&quot;&gt;&lt;code&gt;slice/1&lt;/code&gt;&lt;/a&gt;. The core of the protocol is the &lt;a href=&quot;#reduce/3&quot;&gt;&lt;code&gt;reduce/3&lt;/code&gt;&lt;/a&gt; function. All other functions exist as optimizations paths for data structures that can implement certain properties in better than linear time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb7da1dc23c1e9f315adf4ca89a991f2f576c3b4" translate="yes" xml:space="preserve">
          <source>This protocol uses tagged tuples to exchange information between the reducer function and the data type that implements the protocol. This allows enumeration of resources, such as files, to be done efficiently while also guaranteeing the resource will be closed at the end of the enumeration. This protocol also allows suspension of the enumeration, which is useful when interleaving between many enumerables is required (as in the &lt;code&gt;zip/1&lt;/code&gt; and &lt;code&gt;zip/2&lt;/code&gt; functions).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d2faccf1f4cab6a9360849e0c4b192286433613" translate="yes" xml:space="preserve">
          <source>This reads from the IO as UTF-8. Check out &lt;a href=&quot;io#binstream/2&quot;&gt;&lt;code&gt;IO.binstream/2&lt;/code&gt;&lt;/a&gt; to handle the IO as a raw binary.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb3289e1168d746e447207053b10b0f0b058ccb5" translate="yes" xml:space="preserve">
          <source>This returns true if a task is marked as recursive and it is being executed inside an umbrella project.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea9af91069aa4c9d64215d6cd9db073871191b73" translate="yes" xml:space="preserve">
          <source>This section covers built-in attributes. However, attributes can also be used by developers or extended by libraries to support custom behaviour.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd8870a170daeec23154d49d471c2dd9485fac0a" translate="yes" xml:space="preserve">
          <source>This shortcut will be extremely useful as we build our project, allowing us to quickly iterate by running a single test.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd1e1ed3f015a12c58d63db1a9d93b599be9e3dd" translate="yes" xml:space="preserve">
          <source>This structure is enough to compile our project:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5aeacadd2f95dc684bd082e5479290a732535d0b" translate="yes" xml:space="preserve">
          <source>This syntax is very convenient as it can be nested arbitrarily:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3f217bb694fd565ea5471a5519af65161e8bfcb" translate="yes" xml:space="preserve">
          <source>This syntax reflects the fact the effective size is given by multiplying the size by the unit.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d91886050dfd3b8b0ffcd36baeadec3113935150" translate="yes" xml:space="preserve">
          <source>This task also removes documentation and debugging chunks from the compiled &lt;code&gt;.beam&lt;/code&gt; files to reduce the size of the escript. If this is not desired, check the &lt;code&gt;:strip_beams&lt;/code&gt; option.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b4cda0b866fc4bd88710556e9ee176eb8201a71" translate="yes" xml:space="preserve">
          <source>This task guarantees the project and its dependencies are compiled and packages them inside an escript. Before invoking &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;mix escript.build&lt;/code&gt;&lt;/a&gt;, it is only necessary to define a &lt;code&gt;:escript&lt;/code&gt; key with a &lt;code&gt;:main_module&lt;/code&gt; option in your &lt;code&gt;mix.exs&lt;/code&gt; file:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b95bdbfd4b655866a594149ce367ef4e30f87be" translate="yes" xml:space="preserve">
          <source>This task is automatically reenabled, so it can be called multiple times to load different configs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60b7baa6b3d14e1c34ecb1ce263c22e53b326d02" translate="yes" xml:space="preserve">
          <source>This task is automatically reenabled, so it can be called multiple times with different arguments.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26dd7e67f1b7b3ef5db86ff692753739683ca6d1" translate="yes" xml:space="preserve">
          <source>This task is automatically reenabled, so it can be called multiple times.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee1da0440bde8a127669b55f6844894777d90f76" translate="yes" xml:space="preserve">
          <source>This task is automatically reenabled, so you can perform multiple cross reference checks in the same Mix invocation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59102e430969db44aa9dbab5520c01e316dd3de5" translate="yes" xml:space="preserve">
          <source>This task is automatically reenabled, so you can profile multiple times in the same Mix invocation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25ec3e34affdc5b118add6428766793ecf3c3afd" translate="yes" xml:space="preserve">
          <source>This task starts the current application, loads up &lt;code&gt;test/test_helper.exs&lt;/code&gt; and then requires all files matching the &lt;code&gt;test/**/*_test.exs&lt;/code&gt; pattern in parallel.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4d9fcf010b1211b86ea4237770d26b428fafb33" translate="yes" xml:space="preserve">
          <source>This time all tests passed and ExUnit warned us that distributed tests were being excluded. If you run tests with &lt;code&gt;$ elixir --sname foo -S mix test&lt;/code&gt;, one extra test should run and successfully pass as long as the &lt;code&gt;bar@computer-name&lt;/code&gt; node is available.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="477d833785327cf68017043ef90fe5f9da786575" translate="yes" xml:space="preserve">
          <source>This time is monotonically increasing and starts in an unspecified point in time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d29fa001afdf2d6ca161492ebf202a329eec33bb" translate="yes" xml:space="preserve">
          <source>This time let&amp;rsquo;s add a &lt;code&gt;:distributed&lt;/code&gt; tag to &lt;code&gt;test/kv/router_test.exs&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a08500e8bc91707c167cbe26d52c3bd3806ea0d" translate="yes" xml:space="preserve">
          <source>This time may be adjusted forwards or backwards in time with no limitation and is not monotonic.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d3ccee502b139d7db4ac43bc5181f6363d2dc18" translate="yes" xml:space="preserve">
          <source>This time the supervisor started a named registry, allowing us to create buckets without having to explicitly fetch the PID from the supervisor. You should also know how to make the registry crash again, without looking up its PID: give it a try.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2674a77869b19062b86e06c05052e9cdedb0c192" translate="yes" xml:space="preserve">
          <source>This time, since our test relies on global data, we have not given &lt;code&gt;async: true&lt;/code&gt; to &lt;code&gt;use ExUnit.Case&lt;/code&gt;. Furthermore, in order to guarantee our test is always in a clean state, we stop and start the &lt;code&gt;:kv&lt;/code&gt; application before each test. In fact, stopping the &lt;code&gt;:kv&lt;/code&gt; application even prints a warning on the terminal:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c22b7275344f29b83a9a0084e4877ef048fc7831" translate="yes" xml:space="preserve">
          <source>This time, we have joined two aliases, defining the final alias &lt;code&gt;Hello.World&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f412811fd9f81fa6e535feea04f5cd402448c56" translate="yes" xml:space="preserve">
          <source>This tuple follows the general quoted expression structure in Elixir, with the name as first argument, some keyword list as metadata as second, and the list of arguments as third. In this case, the arguments are the alias &lt;a href=&quot;string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; and the atom &lt;code&gt;:downcase&lt;/code&gt;. The second argument in a remote call is &lt;strong&gt;always&lt;/strong&gt; an atom.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09127719cfc463768ae7ae77dbace1cb3021f292" translate="yes" xml:space="preserve">
          <source>This way if you have a &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt; in one time zone, you can get the same wall time in another time zone. For instance if you have 2018-08-24 10:00:00 in Copenhagen and want a &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt; for 2018-08-24 10:00:00 in UTC you can do:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07671b087d75abe1588362cd61ce69e954d8e6a8" translate="yes" xml:space="preserve">
          <source>This will appear to the &lt;code&gt;node&lt;/code&gt; as if the local node has crashed. This function is mainly used in the Erlang network authentication protocols. Returns &lt;code&gt;true&lt;/code&gt; if disconnection succeeds, otherwise &lt;code&gt;false&lt;/code&gt;. If the local node is not alive, the function returns &lt;code&gt;:ignored&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3db39e63e0c8d60956e47f7856c88ea07f5720f2" translate="yes" xml:space="preserve">
          <source>This will cause the operating system process to exit with the status given by &lt;code&gt;integer&lt;/code&gt; while signaling all linked Erlang processes to politely shut down.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="932ec01a6dc27cb0bacb799b1bb13427b2604043" translate="yes" xml:space="preserve">
          <source>This will generate a file named &lt;code&gt;Elixir.Math.beam&lt;/code&gt; containing the bytecode for the defined module. If we start &lt;code&gt;iex&lt;/code&gt; again, our module definition will be available (provided that &lt;code&gt;iex&lt;/code&gt; is started in the same directory the bytecode file is in):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e50caa68b186c476cfb0083912fddaf93761ce6" translate="yes" xml:space="preserve">
          <source>This won't work as it will rather try to invoke the local function &lt;code&gt;fun&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="988a9f0b35eb11882e7b92d107c2e4d9a3c956cd" translate="yes" xml:space="preserve">
          <source>This works because accessing anything on a &lt;code&gt;nil&lt;/code&gt; value, returns &lt;code&gt;nil&lt;/code&gt; itself:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9ae4006317b94bfaa968ed593d618d9dbca367b" translate="yes" xml:space="preserve">
          <source>This works:</source>
          <target state="translated">这个可以用。</target>
        </trans-unit>
        <trans-unit id="35b2e50e251cc0ba39a82b26384abdc7366f7bc3" translate="yes" xml:space="preserve">
          <source>This would be repetitive to write every time we need this check, so, as mentioned at the beginning of this section, we can abstract this away using a macro. Remember that defining a function that performs this check wouldn't work because we can't use custom functions in guards. Use &lt;code&gt;defguard&lt;/code&gt; and &lt;code&gt;defguardp&lt;/code&gt; to create guard macros. Here's an example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6043c141b8f19b7be4caf31617881f52b255da5" translate="yes" xml:space="preserve">
          <source>This would be the equivalent of getting all of the file contents and packing it all into a single line in IEx and executing it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ff1d4baf9340ffd06f6ffb996d0e212cbfa8737" translate="yes" xml:space="preserve">
          <source>Those are all protocols that ship with Elixir and they are being consolidated. Because a protocol can dispatch to any data type, the protocol must check on every call if an implementation for the given type exists. This may be expensive.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20eb63dea1b46358d700b88edabba7314d37424c" translate="yes" xml:space="preserve">
          <source>Those constructs exist only at the syntax level. All of the examples above are represented as their underlying integers in the AST.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a23b257e1a8396bae8e624da37c5fa4a14cd69d" translate="yes" xml:space="preserve">
          <source>Those files are compiled in parallel and can automatically detect dependencies between them. Once a dependency is found, the current file stops being compiled until the dependency is resolved.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e697466781be26b9795959553f68c3100b1e1fc6" translate="yes" xml:space="preserve">
          <source>Those functions are optimized to deal with common epochs, such as the Unix Epoch above or the Gregorian Epoch (0000-01-01 00:00:00).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4de8ddc259e007e8ba142a7f915e7b9f301d071" translate="yes" xml:space="preserve">
          <source>Those functions are optimized to deal with common epochs, such as the Unix Epoch above or the Gregorian Epoch (0000-01-01).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="394d2aacfa0d4e93088c549af6bbb4449e2dc409" translate="yes" xml:space="preserve">
          <source>Those functions will be explicitly marked in their docs as &quot;inlined by the compiler&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63c1f7abeafa00aa21caec35b0a45a7d4562b860" translate="yes" xml:space="preserve">
          <source>Those options are shared across all modes:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7600e9dc66e9f49a5eef98b40a90050ef4b71a9b" translate="yes" xml:space="preserve">
          <source>Those options can be configured in your project configuration file or globally by calling &lt;a href=&quot;iex#configure/1&quot;&gt;&lt;code&gt;IEx.configure/1&lt;/code&gt;&lt;/a&gt; from your &lt;code&gt;~/.iex.exs&lt;/code&gt; file. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74a14ac9f70e4b2f7b26991bd0d257ac84bd9ed1" translate="yes" xml:space="preserve">
          <source>Those options mean all dependencies will be checked out to &lt;code&gt;kv_umbrella/deps&lt;/code&gt;, and they will share the same build, config and lock files. We haven&amp;rsquo;t talked about configuration yet, but from here we can build the intuition that all configuration and dependencies are shared across all projects in an umbrella, and it is not per application.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff34978b55b28c6dbd12a23ca68d40a4861e6f90" translate="yes" xml:space="preserve">
          <source>Those performance characteristics dictate the usage of those data structures. One very common use case for tuples is to use them to return extra information from a function. For example, &lt;code&gt;File.read/1&lt;/code&gt; is a function that can be used to read file contents. It returns a tuple:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4f3c9a9eefe9427c2dedc41fe39d6f07ee20806" translate="yes" xml:space="preserve">
          <source>Those situations are quite uncommon in practice except when interfacing with libraries that do not provide a proper API. For example, let&amp;rsquo;s imagine the &lt;code&gt;Enum&lt;/code&gt; module did not provide any API for finding a value and that we needed to find the first multiple of 13 in a list of numbers:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aad090c769c6e03a992f9e5138ceea80922ae0f4" translate="yes" xml:space="preserve">
          <source>Throughout the guide, we have built a very simple distributed key-value store as an opportunity to explore many constructs like generic servers, supervisors, tasks, agents, applications and more. Not only that, we have written tests for the whole application, got familiar with ExUnit, and learned how to use the Mix build tool to accomplish a wide range of tasks.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3b0d5df9824877f9b29731225c4ba90e068aada" translate="yes" xml:space="preserve">
          <source>Throughout the tutorial, we will talk a lot about the head and tail of a list. The head is the first element of a list and the tail is the remainder of the list. They can be retrieved with the functions &lt;code&gt;hd/1&lt;/code&gt; and &lt;code&gt;tl/1&lt;/code&gt;. Let&amp;rsquo;s assign a list to a variable and retrieve its head and tail:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="090c252d7880a95a839fb25bf07e4aad923532bf" translate="yes" xml:space="preserve">
          <source>Throughout this tutorial, we have been using the notation &lt;code&gt;name/arity&lt;/code&gt; to refer to functions. It happens that this notation can actually be used to retrieve a named function as a function type. Start &lt;code&gt;iex&lt;/code&gt;, running the &lt;code&gt;math.exs&lt;/code&gt; file defined above:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9f4b0f30b3f06e61b21febef173645d29891305" translate="yes" xml:space="preserve">
          <source>Throws</source>
          <target state="translated">Throws</target>
        </trans-unit>
        <trans-unit id="6c82e6dd86807ee3db07e3c82bec1ae1ce00b08b" translate="yes" xml:space="preserve">
          <source>Time</source>
          <target state="translated">Time</target>
        </trans-unit>
        <trans-unit id="4dc17499006fce61c64e8dfd0c8c4c038df992f0" translate="yes" xml:space="preserve">
          <source>Time representations with reduced accuracy are not supported.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9452a856dc424a6f92632b47f9b6540703986d72" translate="yes" xml:space="preserve">
          <source>Time zone database</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dad962fdacc68e64400f9f34e93f5814f862947c" translate="yes" xml:space="preserve">
          <source>Time zone offset may be included in the string but they will be simply discarded as such information is not included in naive date times.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55ded65dce8b65205b0b4f7c820bffa416a68f37" translate="yes" xml:space="preserve">
          <source>Time zone offset may be included in the string but they will be simply discarded as such information is not included in times.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f905b9189d8d13ac7a8491eceeb00e40cf5247c7" translate="yes" xml:space="preserve">
          <source>Time zone period for a point in time in UTC for a specific time zone.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ca2fde51c11eb446c9f4471c5d166e6cd917c52" translate="yes" xml:space="preserve">
          <source>Timeout is set to 0, so there is no waiting time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27a4f2c5a6aa7d957af2668e0ec53e32944aba26" translate="yes" xml:space="preserve">
          <source>Timeouts</source>
          <target state="translated">Timeouts</target>
        </trans-unit>
        <trans-unit id="f1b3091799895b01e6aa24802a8c476d47d3c391" translate="yes" xml:space="preserve">
          <source>To act according to the Unicode Standard, many functions in this module run in linear time, as they need to traverse the whole string considering the proper Unicode code points.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="916b5fa900a6f384af0597e7d8f402a05c3c1c1f" translate="yes" xml:space="preserve">
          <source>To aid in the correct implementation of behaviours, you may optionally declare &lt;code&gt;@impl&lt;/code&gt; for implemented callbacks of a behaviour. This makes callbacks explicit and can help you to catch errors in your code. The compiler will warn in these cases:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="688d49bd28e977f5619e4299defc87b3580ff416" translate="yes" xml:space="preserve">
          <source>To assert exits from linked processes started from the test, trap exits with &lt;a href=&quot;https://hexdocs.pm/elixir/Process.html#flag/2&quot;&gt;&lt;code&gt;Process.flag/2&lt;/code&gt;&lt;/a&gt; and assert the exit message with &lt;a href=&quot;#assert_received/2&quot;&gt;&lt;code&gt;assert_received/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60dda8ca6a65152c1c53235c6221b24d765a7234" translate="yes" xml:space="preserve">
          <source>To avoid printing log messages during tests, ExUnit provides a neat feature called &lt;code&gt;:capture_log&lt;/code&gt;. By setting &lt;code&gt;@tag :capture_log&lt;/code&gt; before each test or &lt;code&gt;@moduletag :capture_log&lt;/code&gt; for the whole test case, ExUnit will automatically capture anything that is logged while the test runs. In case our test fails, the captured logs will be printed alongside the ExUnit report.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f974b60e8a8ca0fdff2c240dbeb8be96e5b7e1d4" translate="yes" xml:space="preserve">
          <source>To avoid that late answers (after the timeout) pollute the caller's message queue, a middleman process is used to do the actual calls. Late answers will then be discarded when they arrive to a terminated process.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="915324fb4db3a9cfde09b72fdeb57083f3b6ada4" translate="yes" xml:space="preserve">
          <source>To be converted to a string, a list must either be empty or only contain the following elements:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc7a4b67b1cf2b13d1bec5831057b11f1a8ac991" translate="yes" xml:space="preserve">
          <source>To check the Unicode version of your current Elixir installation, run &lt;code&gt;String.Unicode.version()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32741725588800279ae172b79b44e5964f47f63a" translate="yes" xml:space="preserve">
          <source>To convert maps into keywords and vice-versa, use the &lt;code&gt;new&lt;/code&gt; function in the respective modules.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90fe397a356898d27888dc41d52d7983ef57d2b2" translate="yes" xml:space="preserve">
          <source>To create a custom sigil, define a function with the name &lt;code&gt;sigil_{identifier}&lt;/code&gt; that takes two arguments. The first argument will be the string, the second will be a charlist containing any modifiers. If the sigil is lower case (such as &lt;code&gt;sigil_x&lt;/code&gt;) then the string argument will allow interpolation. If the sigil is upper case (such as &lt;code&gt;sigil_X&lt;/code&gt;) then the string will not be interpolated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb585bff51bf0b0752f3b9643ada939cb21bacf2" translate="yes" xml:space="preserve">
          <source>To define a behaviour module, it's enough to define one or more callbacks in that module. To define callbacks, the &lt;code&gt;@callback&lt;/code&gt; and &lt;code&gt;@macrocallback&lt;/code&gt; module attributes can be used (for function callbacks and macro callbacks respectively).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="748c36f2db63d3a03dc4e6fadef52aac3b262d3c" translate="yes" xml:space="preserve">
          <source>To define a struct, a developer must define both &lt;code&gt;__struct__/0&lt;/code&gt; and &lt;code&gt;__struct__/1&lt;/code&gt; functions. &lt;a href=&quot;#defstruct/1&quot;&gt;&lt;code&gt;defstruct/1&lt;/code&gt;&lt;/a&gt; is a convenience macro which defines such functions with some conveniences.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e46e68069cc59aab3678e72e8671077b9e1f5c1" translate="yes" xml:space="preserve">
          <source>To define a struct, the &lt;code&gt;defstruct&lt;/code&gt; construct is used:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15c7a0bd6bb05c83760ad9659631936c1f603b9d" translate="yes" xml:space="preserve">
          <source>To define an operator, you can use the usual &lt;code&gt;def*&lt;/code&gt; constructs (&lt;code&gt;def&lt;/code&gt;, &lt;code&gt;defp&lt;/code&gt;, &lt;code&gt;defmacro&lt;/code&gt;, and so on) but with a syntax similar to how the operator is used:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1416bbc268b001f44ff03e41dd657568db375a9" translate="yes" xml:space="preserve">
          <source>To determine how many seconds the &lt;code&gt;:native&lt;/code&gt; unit represents in your current runtime, you can can call this function to convert 1 second to the &lt;code&gt;:native&lt;/code&gt; time unit: &lt;code&gt;System.convert_time_unit(1, :second, :native)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb35bc4715abc885d6ad16dcca4ef00591e6ce0e" translate="yes" xml:space="preserve">
          <source>To differentiate the program behavior depending on the environment, it is recommended to use application environment through &lt;a href=&quot;https://hexdocs.pm/elixir/Application.html#get_env/3&quot;&gt;&lt;code&gt;Application.get_env/3&lt;/code&gt;&lt;/a&gt;. Proper configuration can be set in config files, often per-environment (see the &lt;a href=&quot;https://hexdocs.pm/elixir/Config.html&quot;&gt;&lt;code&gt;Config&lt;/code&gt;&lt;/a&gt; module for more information).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ade0297c81614f897441b308bffb7079cbf4b959" translate="yes" xml:space="preserve">
          <source>To discover a module's public functions or other modules, type the module name followed by a dot, then press tab to trigger autocomplete. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f350e9537ca99b19347d61d7b15f4ba1b815fe4" translate="yes" xml:space="preserve">
          <source>To display &quot;What is your name?&quot; as a prompt and await user input:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9392c58481cde14e24d585ca66473875cbcb0d13" translate="yes" xml:space="preserve">
          <source>To drive the point home, imagine you want to validate a certain attribute only if a given condition is met. We could easily achieve it with the first solution, by manipulating the data structure accordingly, or with the second solution by using conditionals (if/else) before invoking the function. However, it is impossible to do so with the macros approach unless its DSL is augmented.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="842501ce37fce5610a16f26dd98d6da220a3b08e" translate="yes" xml:space="preserve">
          <source>To exit a breakpoint, the developer can either invoke &lt;code&gt;continue()&lt;/code&gt;, which will block the shell until the next breakpoint is found or the process terminates, or invoke &lt;code&gt;respawn()&lt;/code&gt;, which starts a new IEx shell, freeing up the pried one.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3c693fb70a5169722986ac65b4c67dfb305f68f" translate="yes" xml:space="preserve">
          <source>To fix the failure we need to make &lt;code&gt;KV.Registry.create/2&lt;/code&gt; synchronous by using &lt;code&gt;call/2&lt;/code&gt; rather than &lt;code&gt;cast/2&lt;/code&gt;. This will guarantee that the client will only continue after changes have been made to the table. Let&amp;rsquo;s change the function and its callback as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d939e666619b837bbfc72a19c0edb64540f7b914" translate="yes" xml:space="preserve">
          <source>To give the formatter a try, change a file in the &lt;code&gt;lib&lt;/code&gt; or &lt;code&gt;test&lt;/code&gt; directories to include extra spaces or extra newlines, such as &lt;code&gt;def  hello  do&lt;/code&gt;, and then run &lt;code&gt;mix format&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a15120dae8d76afe9639289d60fb9093810c397a" translate="yes" xml:space="preserve">
          <source>To help developers remember the differences between call, cast and info, the supported return values and more, we have a tiny &lt;a href=&quot;https://elixir-lang.org/cheatsheets/gen-server.pdf&quot;&gt;GenServer cheat sheet&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="555a879eb773cd3d2dff7da0f2a52cb90ca0b876" translate="yes" xml:space="preserve">
          <source>To implement the &lt;code&gt;Application&lt;/code&gt; behaviour, we have to &lt;code&gt;use Application&lt;/code&gt; and define a &lt;code&gt;start/2&lt;/code&gt; function. The goal of &lt;code&gt;start/2&lt;/code&gt; is to start a supervisor, which will then start any child services or execute any other code our application may need. Let&amp;rsquo;s use this opportunity to start the &lt;code&gt;KV.Supervisor&lt;/code&gt; we have implemented earlier in this chapter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee64280d1fb25258cd437b5d0c77efe55acbd252" translate="yes" xml:space="preserve">
          <source>To learn more about IEx as a whole, type &lt;code&gt;h(IEx)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="699ef2c862a7af01ce3ea7b060fc68320ed60961" translate="yes" xml:space="preserve">
          <source>To learn more about floating-point arithmetic visit:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="101e8672c7193137af23129687e2ed29b0030ea4" translate="yes" xml:space="preserve">
          <source>To learn more about specific optimizations and performance considerations, check out &lt;a href=&quot;http://www.erlang.org/doc/efficiency_guide/binaryhandling.html&quot;&gt;Erlang's Efficiency Guide on handling binaries&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a32f6bfbd0a46a1fe8412990dabfb9a92464fbb" translate="yes" xml:space="preserve">
          <source>To list all IEx helpers available, which is effectively all exports (functions and macros) in the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;IEx.Helpers&lt;/code&gt;&lt;/a&gt; module:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34f6e4a2bb843898b6a1a63430d9ad523188262e" translate="yes" xml:space="preserve">
          <source>To profile the code, you can use syntax similar to the &lt;a href=&quot;mix.tasks.run&quot;&gt;&lt;code&gt;mix run&lt;/code&gt;&lt;/a&gt; task:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b90e482b9b75d2e1ab9c0ff8e4d1e0e5aecc5f06" translate="yes" xml:space="preserve">
          <source>To quote &lt;a href=&quot;https://elixir-lang.org/getting-started/meta/macros.html&quot;&gt;the official guide on Macros&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5139cf2a16e17732e5bda38b6b67324152e536b" translate="yes" xml:space="preserve">
          <source>To reply after returning from the callback because the response is not yet available.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="716f6562922e06c13563ae83ce61a300e8352363" translate="yes" xml:space="preserve">
          <source>To reply before returning from the callback because the response is known before calling a slow function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e57aadf0943d8ee32b1daf18536595cdf4b85435" translate="yes" xml:space="preserve">
          <source>To reply from another process, such as a task.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa09c7d0058c95fdae6640e10ab83ae7e2c7d29c" translate="yes" xml:space="preserve">
          <source>To retrieve the stacktrace of the current process, use &lt;code&gt;Process.info(self(), :current_stacktrace)&lt;/code&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9be81917be7c5a65d20c56cce5430337e7437a2" translate="yes" xml:space="preserve">
          <source>To run our doctests, we&amp;rsquo;ll create a file at &lt;code&gt;test/kv_server/command_test.exs&lt;/code&gt; and call &lt;code&gt;doctest KVServer.Command&lt;/code&gt; in the test case:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c550ca70984ac8e2f646e72f7f0c9faa1dd704b7" translate="yes" xml:space="preserve">
          <source>To run the tests above, run the file using &lt;code&gt;elixir&lt;/code&gt; from the command line. Assuming you named the file &lt;code&gt;assertion_test.exs&lt;/code&gt;, you can run it as:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f88b35a6396b6373f09d679595715d5f894666f2" translate="yes" xml:space="preserve">
          <source>To see documentation for each specific compiler, you must invoke &lt;code&gt;help&lt;/code&gt; directly for the compiler command:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7fcc2e5f60178276dfc7759916301cae9d1d546f" translate="yes" xml:space="preserve">
          <source>To show all entries, configure the limit to &lt;code&gt;:infinity&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b50964644227148ad32fc703cd3d520d71c70f6b" translate="yes" xml:space="preserve">
          <source>To show how the protocol can be implemented, we can take again a look at the implementation for &lt;a href=&quot;mapset&quot;&gt;&lt;code&gt;MapSet&lt;/code&gt;&lt;/a&gt;. In this implementation &quot;collecting&quot; elements simply means inserting them in the set through &lt;a href=&quot;mapset#put/2&quot;&gt;&lt;code&gt;MapSet.put/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6baefde74a3b1948259d37f28d66b2da3cc95503" translate="yes" xml:space="preserve">
          <source>To show how to manually use the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Collectable&lt;/code&gt;&lt;/a&gt; protocol, let's play with its implementation for &lt;a href=&quot;mapset&quot;&gt;&lt;code&gt;MapSet&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5683b1948dc754efdfed9ba11dc087a421c0449e" translate="yes" xml:space="preserve">
          <source>To specify that a module implements a given behaviour, the &lt;code&gt;@behaviour&lt;/code&gt; attribute must be used:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0fee1e5263eb41b6e360a95cfaf76805e6190b5" translate="yes" xml:space="preserve">
          <source>To start the supervisor, the &lt;a href=&quot;#c:init/1&quot;&gt;&lt;code&gt;init/1&lt;/code&gt;&lt;/a&gt; callback will be invoked in the given &lt;code&gt;module&lt;/code&gt;, with &lt;code&gt;arg&lt;/code&gt; as its argument. The &lt;a href=&quot;#c:init/1&quot;&gt;&lt;code&gt;init/1&lt;/code&gt;&lt;/a&gt; callback must return a supervisor specification which can be created with the help of the &lt;a href=&quot;#init/1&quot;&gt;&lt;code&gt;init/1&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="340467355095ab2102cf53f317a261f28f43cfa1" translate="yes" xml:space="preserve">
          <source>To start the supervisor, the &lt;a href=&quot;#c:init/1&quot;&gt;&lt;code&gt;init/1&lt;/code&gt;&lt;/a&gt; callback will be invoked in the given &lt;code&gt;module&lt;/code&gt;, with &lt;code&gt;init_arg&lt;/code&gt; as its argument. The &lt;a href=&quot;#c:init/1&quot;&gt;&lt;code&gt;init/1&lt;/code&gt;&lt;/a&gt; callback must return a supervisor specification which can be created with the help of the &lt;a href=&quot;#init/2&quot;&gt;&lt;code&gt;init/2&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6bd659c0fd4a88cb66bdff02f16f40278b81dd1f" translate="yes" xml:space="preserve">
          <source>To sum it up: since the formatter cannot change the semantics of your code, sometimes it is necessary to tweak or refactor the code to get optimal formatting. To help better understand how to control the formatter, we describe in the next sections the cases where the formatter keeps the user encoding and how to control multiline expressions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc5e717b9aecb2c9e25ade231bba83d35b0f1df7" translate="yes" xml:space="preserve">
          <source>To this point, we have been starting &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Registry&lt;/code&gt;&lt;/a&gt; using &lt;a href=&quot;#start_link/1&quot;&gt;&lt;code&gt;start_link/1&lt;/code&gt;&lt;/a&gt;. Typically the registry is started as part of a supervision tree though:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f69493266441ce87de2c6a579e769590bf4ddfcf" translate="yes" xml:space="preserve">
          <source>To track the relationship between your code and the task, we use the &lt;code&gt;$callers&lt;/code&gt; key in the process dictionary. Therefore, assuming the &lt;a href=&quot;task.supervisor&quot;&gt;&lt;code&gt;Task.Supervisor&lt;/code&gt;&lt;/a&gt; call above, we have:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97175bd03b3eda9bcbde862759fc67493bd67482" translate="yes" xml:space="preserve">
          <source>To use &lt;a href=&quot;iex#break!/4&quot;&gt;&lt;code&gt;IEx.break!/4&lt;/code&gt;&lt;/a&gt; during tests, you need to run &lt;code&gt;mix&lt;/code&gt; inside the &lt;code&gt;iex&lt;/code&gt; command and pass the &lt;code&gt;--trace&lt;/code&gt; to &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Test.html&quot;&gt;&lt;code&gt;mix test&lt;/code&gt;&lt;/a&gt; to avoid running into timeouts:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad497a0e7b4707958b2bbdf25658f61ced2eef66" translate="yes" xml:space="preserve">
          <source>To use &lt;a href=&quot;iex#pry/0&quot;&gt;&lt;code&gt;IEx.pry/0&lt;/code&gt;&lt;/a&gt; during tests, you need to run &lt;code&gt;mix&lt;/code&gt; inside the &lt;code&gt;iex&lt;/code&gt; command and pass the &lt;code&gt;--trace&lt;/code&gt; to &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Test.html&quot;&gt;&lt;code&gt;mix test&lt;/code&gt;&lt;/a&gt; to avoid running into timeouts:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="525e76db8eaa15a02d475c0b25c1748678200a4e" translate="yes" xml:space="preserve">
          <source>To use &lt;code&gt;:keep&lt;/code&gt; with a type other than &lt;code&gt;:string&lt;/code&gt;, use a list as the type for the switch. For example: &lt;code&gt;[foo: [:integer, :keep]]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b67f756b7a47a192314501d13fc2788976f1a9c" translate="yes" xml:space="preserve">
          <source>To use the newly defined operators, we &lt;strong&gt;have to&lt;/strong&gt; import the module that defines them:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4e084ee0583dab5cdb8f2aaa6336b9ae8900f06" translate="yes" xml:space="preserve">
          <source>To work around this error, redefine the field with your own &amp;amp;M.f/a function, like so:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="123be2f9bdd25b0f49703cfe940d72bfca8fdce4" translate="yes" xml:space="preserve">
          <source>TokenMissingError</source>
          <target state="translated">TokenMissingError</target>
        </trans-unit>
        <trans-unit id="42d5db27696210e57467dc675285521f0930aa67" translate="yes" xml:space="preserve">
          <source>TokenMissingError &lt;small&gt;exception&lt;/small&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4fc60ef5d69079c451ea67854c51808d9ec41c01" translate="yes" xml:space="preserve">
          <source>Tooling</source>
          <target state="translated">Tooling</target>
        </trans-unit>
        <trans-unit id="cd770bf19fa776a62cbc130cb90d8f5cd6a0b438" translate="yes" xml:space="preserve">
          <source>Tools like Mix may use this information to ensure the module is recompiled in case any of the external resources change.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77431b38c8bb01a363da5bccdb519bd75745358b" translate="yes" xml:space="preserve">
          <source>Trailing bang (&lt;code&gt;foo!&lt;/code&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff6cffeaff58c52204a5122da57dc4b26f381da0" translate="yes" xml:space="preserve">
          <source>Trailing question mark (&lt;code&gt;foo?&lt;/code&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7a933d6378a29d15a7b6795f6516bd8c8f0c0ab" translate="yes" xml:space="preserve">
          <source>Transforms an existing stream with function-based start and finish.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0183630f154b045739040c0a476db00c0d8d8489" translate="yes" xml:space="preserve">
          <source>Transforms an existing stream.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0bf22bc28c174dfbe4750edd483edd80c1c1f1c" translate="yes" xml:space="preserve">
          <source>Translates to:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac26a7a94ea2e66490f932b6415a09ef6f2a913c" translate="yes" xml:space="preserve">
          <source>Translation</source>
          <target state="translated">Translation</target>
        </trans-unit>
        <trans-unit id="eb726f366153f5273c287e7afe4de066bacf45f4" translate="yes" xml:space="preserve">
          <source>Traverses paths according to the given &lt;code&gt;glob&lt;/code&gt; expression and returns a list of matches.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b9bae059da0df068a9a43bf70813a2cc0165c80" translate="yes" xml:space="preserve">
          <source>Tries to create the directory &lt;code&gt;path&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1274a0f5d2ed4698598c860012ff8d0e34e7aeca" translate="yes" xml:space="preserve">
          <source>Tries to delete the dir at &lt;code&gt;path&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79494b7d121b41ed702af12c8820f16d4b440ca4" translate="yes" xml:space="preserve">
          <source>Tries to delete the file &lt;code&gt;path&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7267f3b3b246e3958379e99f6b106bc8021e929a" translate="yes" xml:space="preserve">
          <source>Tries to set up a connection to node.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="836d86c6c848f493d3ff2e48bb6f5f308c9c411f" translate="yes" xml:space="preserve">
          <source>Truthy and falsy values</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0d62e00a429e56556bf1455c0175bc4654fbf2a" translate="yes" xml:space="preserve">
          <source>Truthy values:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ccf6e0cd6e8c63d5ae42d6c2569741d54c61f4d5" translate="yes" xml:space="preserve">
          <source>Try to connect two telnet clients at the same time. When you do so, you will notice that the second client doesn&amp;rsquo;t echo:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="965b5b1e76f73cc1dd48f82e36854d491ebbe607" translate="yes" xml:space="preserve">
          <source>TryClauseError</source>
          <target state="translated">TryClauseError</target>
        </trans-unit>
        <trans-unit id="bb04413eca53d9d4f9ada422b12b458b1a19dc69" translate="yes" xml:space="preserve">
          <source>TryClauseError &lt;small&gt;exception&lt;/small&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3d6d3a96a93234d43a687b1131b3901f142d46c" translate="yes" xml:space="preserve">
          <source>Trying to access an attribute that was not defined will print a warning:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c41a2be51027c17da2914785c19c9af65da7231f" translate="yes" xml:space="preserve">
          <source>Tuple</source>
          <target state="translated">Tuple</target>
        </trans-unit>
        <trans-unit id="dc4f3a01c46fc5525a4e91e907b957d6688cd48a" translate="yes" xml:space="preserve">
          <source>Tuple describing the client of a call request.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb4abd3a92bef73903da00d10d474ba4501f6bab" translate="yes" xml:space="preserve">
          <source>Tuple-based HashDict implementation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91c1b6c09400f880e21ca1e3d43c7f7b3443b423" translate="yes" xml:space="preserve">
          <source>Tuple-based HashSet implementation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="538a8ce3fbdcaee00a14353bd57bcf3600c6e0d0" translate="yes" xml:space="preserve">
          <source>Tuples</source>
          <target state="translated">Tuples</target>
        </trans-unit>
        <trans-unit id="793259df3cfbea29ea94e801a3dc852ba0481364" translate="yes" xml:space="preserve">
          <source>Tuples are compared by size, then element by element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cbb1dd7716c923dc57835e6545295dd3e5141a82" translate="yes" xml:space="preserve">
          <source>Tuples are denoted with curly braces:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9d295b48169d12e8a4a885f2969f7ebb5f288bf" translate="yes" xml:space="preserve">
          <source>Tuples are intended as fixed-size containers for multiple elements. To manipulate a collection of elements, use a list instead. &lt;a href=&quot;enum&quot;&gt;&lt;code&gt;Enum&lt;/code&gt;&lt;/a&gt; functions do not work on tuples.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6007daf5620486dbca1cb7e87969100af322cc9f" translate="yes" xml:space="preserve">
          <source>Tuples are typically used either when a function has multiple return values or for error handling. &lt;a href=&quot;file#read/1&quot;&gt;&lt;code&gt;File.read/1&lt;/code&gt;&lt;/a&gt; returns &lt;code&gt;{:ok, contents}&lt;/code&gt; if reading the given file is successful, or else &lt;code&gt;{:error, reason}&lt;/code&gt; such as when the file does not exist.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db66b3f610de5841b308865fc05862649e3b269d" translate="yes" xml:space="preserve">
          <source>Tuples have their own representation, except for two-element tuples, which are represented as themselves:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d23bff74f82a432abab310b02bda096c901d05c" translate="yes" xml:space="preserve">
          <source>Tuples store elements contiguously in memory. This means accessing a tuple element by index or getting the tuple size is a fast operation. Indexes start from zero:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4827be384e5b92dfa89593fd34e759c469d83f68" translate="yes" xml:space="preserve">
          <source>Tuples, on the other hand, are stored contiguously in memory. This means getting the tuple size or accessing an element by index is fast. However, updating or adding elements to tuples is expensive because it requires creating a new tuple in memory:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4eeec2166369454fe72d485310480999d9e41ff" translate="yes" xml:space="preserve">
          <source>Turns a distributed node into a non-distributed node.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78cb13dab8abb15c4418dcf574cee609f60fff10" translate="yes" xml:space="preserve">
          <source>Turns a non-distributed node into a distributed node.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d200b5cca6122d2ea47ef95bc1ae207e6bed360" translate="yes" xml:space="preserve">
          <source>Two keywords are considered to be equal if they contain the same keys and those keys contain the same values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fddf4faa5ad6ac7c7817431eda4bde5737ecc7a7" translate="yes" xml:space="preserve">
          <source>Two lists can be concatenated and subtracted using the &lt;a href=&quot;kernel#++/2&quot;&gt;&lt;code&gt;Kernel.++/2&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;kernel#--/2&quot;&gt;&lt;code&gt;Kernel.--/2&lt;/code&gt;&lt;/a&gt; operators:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6eb24ea9f355df425e35046856649369306137b" translate="yes" xml:space="preserve">
          <source>Two lists can be concatenated or subtracted using the &lt;code&gt;++/2&lt;/code&gt; and &lt;code&gt;--/2&lt;/code&gt; operators respectively:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28dd04de329219b61258e459b05052b6d195ed8c" translate="yes" xml:space="preserve">
          <source>Two maps are considered to be equal if they contain the same keys and those keys contain the same values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3deb7456519697ecf4eefc455516c969a3681bae" translate="yes" xml:space="preserve">
          <source>Type</source>
          <target state="translated">Type</target>
        </trans-unit>
        <trans-unit id="130c35a2878e328189066b98bf54e31f721289db" translate="yes" xml:space="preserve">
          <source>Type &amp;ldquo;hello&amp;rdquo;, press enter, and you will get &amp;ldquo;hello&amp;rdquo; back. Excellent!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e252ef20859612096fbf35e99f3db43d0d903502" translate="yes" xml:space="preserve">
          <source>Type checks and other boolean checks that are allowed in guard clauses are named with an &lt;code&gt;is_&lt;/code&gt; prefix.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce1a99d47d96ec4a8d262432fdeeb24d34842d1c" translate="yes" xml:space="preserve">
          <source>Type specifications (sometimes referred to as &lt;em&gt;typespecs&lt;/em&gt;) are defined in different contexts using the following attributes:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6f295ce9af290691ba77bd28066b72b6d97e560" translate="yes" xml:space="preserve">
          <source>Type variables with no restriction can also be defined using &lt;code&gt;var&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93b9e289e2842469d001eccf7ad5d79f3c302dc9" translate="yes" xml:space="preserve">
          <source>Types</source>
          <target state="translated">Types</target>
        </trans-unit>
        <trans-unit id="9c292c75a9bfb2deb75a816df8b4fa93d8b86cdf" translate="yes" xml:space="preserve">
          <source>Types and specs</source>
          <target state="new"/>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
