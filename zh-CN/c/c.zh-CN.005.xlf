<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="c">
    <body>
      <group id="c">
        <trans-unit id="30b4e85b5e57a5e2350b1dc089bac21b6bb3bef1" translate="yes" xml:space="preserve">
          <source>F.9.3.13 The scalbn functions (p: 460)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="823c8200c7b53ce2ccd8c3288a0a3a49fad5c22c" translate="yes" xml:space="preserve">
          <source>F.9.3.2 The exp2 functions (p: 458)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d366ad2627dd4333d06e173d585adb24b52f19a" translate="yes" xml:space="preserve">
          <source>F.9.3.3 The expm1 functions (p: 458)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9993bc3ba1519eec52259e286419159d469fe90d" translate="yes" xml:space="preserve">
          <source>F.9.3.4 The frexp functions (p: 458)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9e61e62cb68745b75b0ed3ce171a6a9e5162df8" translate="yes" xml:space="preserve">
          <source>F.9.3.5 The ilogb functions (p: 458)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4726c76fee2a471a2931693701495170c5d8163" translate="yes" xml:space="preserve">
          <source>F.9.3.6 The ldexp functions (p: 459)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6092518ebd2f95991e460724ebab3f88acec5168" translate="yes" xml:space="preserve">
          <source>F.9.3.7 The log functions (p: 459)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c0b8c3a7302a2e8487ec23c4264320fa6a1efbe" translate="yes" xml:space="preserve">
          <source>F.9.3.8 The log10 functions (p: 459)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18b53619814f88666c327ab91b69281ea797e78f" translate="yes" xml:space="preserve">
          <source>F.9.3.9 The log1p functions (p: 459)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dbd538d32f5d9018cd3832c0cbc80455793a7355" translate="yes" xml:space="preserve">
          <source>F.9.4.1 The cbrt functions (p: 460)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0cc25736dc89057cfdb7af63fd9fd70852b7e3f" translate="yes" xml:space="preserve">
          <source>F.9.4.3 The hypot functions (p: 461)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9972873a11b4a3f3db9e100bb220f6102dbac9da" translate="yes" xml:space="preserve">
          <source>F.9.4.4 The pow functions (p: 461)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38a093976c4b1a21fdfcc5a1efbc81ca4cf9fcd1" translate="yes" xml:space="preserve">
          <source>F.9.4.5 The sqrt functions (p: 462)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1c90503cb107f559d8240f46591b669f6510753" translate="yes" xml:space="preserve">
          <source>F.9.5.1 The erf functions (p: 462)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2df3873ca6b99a5a39094498e253092b49188f4" translate="yes" xml:space="preserve">
          <source>F.9.5.2 The erfc functions (p: 462)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8cea05cad5774c2508871da587382f5db7d720a3" translate="yes" xml:space="preserve">
          <source>F.9.5.3 The lgamma functions (p: 462)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b0a22ab47007053f34baaa081ba36dae847052b" translate="yes" xml:space="preserve">
          <source>F.9.5.4 The tgamma functions (p: 462)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="934d552354a34e2b8673e4eb4339546c60ae6dd8" translate="yes" xml:space="preserve">
          <source>F.9.6.1 The ceil functions (p: 462-463)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5b93daaadda04a0163cf636e455a8bd1dff63ae" translate="yes" xml:space="preserve">
          <source>F.9.6.2 The floor functions (p: 463)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57ffbbecbe61484e26935ad7f144629bd00f8d53" translate="yes" xml:space="preserve">
          <source>F.9.6.3 The nearbyint functions (p: 463)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34e0626ef8f9a6bbac018a9e206f3071affd5bc0" translate="yes" xml:space="preserve">
          <source>F.9.6.4 The rint functions (p: 463)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2e2f1d0870aa390943575793ec108e425c96385" translate="yes" xml:space="preserve">
          <source>F.9.6.5 The lrint and llrint functions (p: 463)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0342b704124b697670da2d3c1f79734dea851992" translate="yes" xml:space="preserve">
          <source>F.9.6.6 The round functions (p: 464)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7cb6f5767de3d5739b9c33a7634dcdfe44990115" translate="yes" xml:space="preserve">
          <source>F.9.6.7 The lround and llround functions (p: 464)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c3fd1541169517fa1d4961b9344e08aa532fa7e" translate="yes" xml:space="preserve">
          <source>F.9.6.8 The trunc functions (p: 464)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="064b3111988ac7df6eecb785faed345d9297dfab" translate="yes" xml:space="preserve">
          <source>F.9.7.1 The fmod functions (p: 465)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc9103dded7338c4021b51c548c533e322ab900e" translate="yes" xml:space="preserve">
          <source>F.9.7.2 The remainder functions (p: 465)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39bef4f56a96498b3da50bdb7c35031638849d6f" translate="yes" xml:space="preserve">
          <source>F.9.7.3 The remquo functions (p: 465)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e56cc91507b7efd53ba57b94c982642c7f60363e" translate="yes" xml:space="preserve">
          <source>F.9.8.1 The copysign functions (p: 465)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef3323270c431d43becee3540920bfc7eeedaff7" translate="yes" xml:space="preserve">
          <source>F.9.8.3 The nextafter functions (p: 466)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0631e56775b8a532eaeb5137b6f22ed4997abbe6" translate="yes" xml:space="preserve">
          <source>F.9.8.4 The nexttoward functions (p: 466)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ddb4e2e3c5c7d60866cef35561923279073eee3" translate="yes" xml:space="preserve">
          <source>F.9.9.1 The fdim functions (p: 466)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c525d7d0c4839cf25cbfd016306a740d2d9d279e" translate="yes" xml:space="preserve">
          <source>F.9.9.2 The fmax functions (p: 466)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc6bba334be6df0602bebd86ae84aeb7c0f91030" translate="yes" xml:space="preserve">
          <source>F.9.9.3 The fmin functions (p: 466)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95554e5d8706eb3f7b6807f8f074535fb13990c9" translate="yes" xml:space="preserve">
          <source>F.9/11/13 NAN (p: 455)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58e99712449f37bee19b236a76781708e1c1501e" translate="yes" xml:space="preserve">
          <source>F.9/2 HUGE_VAL, HUGE_VALF, HUGE_VALL (p: 454)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29ea08511bd74c4f3ae31a09c3ec12f4f35a942e" translate="yes" xml:space="preserve">
          <source>F.9/4 MATH_ERREXCEPT, math_errhandling&amp;gt; (p: 454)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c061bc777cddf822c848be8c51b3f6a8a14f19f4" translate="yes" xml:space="preserve">
          <source>FE_ALL_EXCEPTFE_DIVBYZEROFE_INEXACTFE_INVALIDFE_OVERFLOWFE_UNDERFLOW</source>
          <target state="translated">FE_ALL_EXCEPTFE_DIVBYZEROFE_INEXACTFE_INVALIDFE_OVERFLOWFE_UNDERFLOW</target>
        </trans-unit>
        <trans-unit id="b1c364462df93e13ffc864f5e34d434d3e0896f1" translate="yes" xml:space="preserve">
          <source>FE_DFL_ENV</source>
          <target state="translated">FE_DFL_ENV</target>
        </trans-unit>
        <trans-unit id="afc46bada59e52921ca04acfa3e557f4d34949db" translate="yes" xml:space="preserve">
          <source>FE_DOWNWARDFE_TONEARESTFE_TOWARDZEROFE_UPWARD</source>
          <target state="translated">FE_DOWNWARDFE_TONEARESTFE_TOWARDZEROFE_UPWARD</target>
        </trans-unit>
        <trans-unit id="f17f59f8bb1aa4aa1c2a8be48c8b3cc395132a95" translate="yes" xml:space="preserve">
          <source>FE_UNDERFLOW</source>
          <target state="translated">FE_UNDERFLOW</target>
        </trans-unit>
        <trans-unit id="5fc0e01507a5cabdda26a6538ed27cbe059c94c7" translate="yes" xml:space="preserve">
          <source>FE_UPWARD</source>
          <target state="translated">FE_UPWARD</target>
        </trans-unit>
        <trans-unit id="6c8821a037c125e39dc3cb69a201a2174bd7c0f8" translate="yes" xml:space="preserve">
          <source>FILENAME_MAX</source>
          <target state="translated">FILENAME_MAX</target>
        </trans-unit>
        <trans-unit id="0d4216abe2ddd91a8caf8ec8f946faac3d09cdb4" translate="yes" xml:space="preserve">
          <source>FInally, the &lt;code&gt;thrd_exit&lt;/code&gt; function terminates execution of the calling thread and sets its result code to &lt;code&gt;res&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec0e6a828868888b35d7b88c45bc8ec8ded65b4c" translate="yes" xml:space="preserve">
          <source>FLT_DECIMAL_DIGDBL_DECIMAL_DIGLDBL_DECIMAL_DIG</source>
          <target state="translated">FLT_DECIMAL_DIGDBL_DECIMAL_DIGLDBL_DECIMAL_DIG</target>
        </trans-unit>
        <trans-unit id="7afcf0013539d05e408bc6855b9ff9c33961ba4a" translate="yes" xml:space="preserve">
          <source>FLT_DIGDBL_DIGLDBL_DIG</source>
          <target state="translated">FLT_DIGDBL_DIGLDBL_DIG</target>
        </trans-unit>
        <trans-unit id="fb4b82dd7a09ae0e4cd4ec26fae3ace2a1f492b3" translate="yes" xml:space="preserve">
          <source>FLT_EPSILONDBL_EPSILONLDBL_EPSILON</source>
          <target state="translated">FLT_EPSILONDBL_EPSILONLDBL_EPSILON</target>
        </trans-unit>
        <trans-unit id="19a80ddd685588eb2c01ceaa6c67ca15a9d3cd90" translate="yes" xml:space="preserve">
          <source>FLT_EVAL_METHOD</source>
          <target state="translated">FLT_EVAL_METHOD</target>
        </trans-unit>
        <trans-unit id="27b085fe54adba08fa4a2911aa54c2928531a994" translate="yes" xml:space="preserve">
          <source>FLT_HAS_SUBNORMDBL_HAS_SUBNORMLDBL_HAS_SUBNORM</source>
          <target state="translated">FLT_HAS_SUBNORMDBL_HAS_SUBNORMLDBL_HAS_SUBNORM</target>
        </trans-unit>
        <trans-unit id="d23e1d93b48a70a6b3008660a10922fc69e91714" translate="yes" xml:space="preserve">
          <source>FLT_MANT_DIGDBL_MANT_DIGLDBL_MANT_DIG</source>
          <target state="translated">FLT_MANT_DIGDBL_MANT_DIGLDBL_MANT_DIG</target>
        </trans-unit>
        <trans-unit id="14a1a55c6769f2d618f216dd4e1926c937963a81" translate="yes" xml:space="preserve">
          <source>FLT_MAXDBL_MAXLDBL_MAX</source>
          <target state="translated">FLT_MAXDBL_MAXLDBL_MAX</target>
        </trans-unit>
        <trans-unit id="1a43181bc7c68633c0d3a314ceb823229a88ee19" translate="yes" xml:space="preserve">
          <source>FLT_MAX_10_EXPDBL_MAX_10_EXPLDBL_MAX_10_EXP</source>
          <target state="translated">FLT_MAX_10_EXPDBL_MAX_10_EXPLDBL_MAX_10_EXP</target>
        </trans-unit>
        <trans-unit id="ed2d991f061e360c893c5a713ef996b38ebffdc9" translate="yes" xml:space="preserve">
          <source>FLT_MAX_EXPDBL_MAX_EXPLDBL_MAX_EXP</source>
          <target state="translated">FLT_MAX_EXPDBL_MAX_EXPLDBL_MAX_EXP</target>
        </trans-unit>
        <trans-unit id="24b8072d7962d75d2c508ff42b7b1b1555e6bb66" translate="yes" xml:space="preserve">
          <source>FLT_MINDBL_MINLDBL_MIN</source>
          <target state="translated">FLT_MINDBL_MINLDBL_MIN</target>
        </trans-unit>
        <trans-unit id="6869500f7b0f9c2b39432ab1b4dcf3e3690ba2a4" translate="yes" xml:space="preserve">
          <source>FLT_MIN_10_EXPDBL_MIN_10_EXPLDBL_MIN_10_EXP</source>
          <target state="translated">FLT_MIN_10_EXPDBL_MIN_10_EXPLDBL_MIN_10_EXP</target>
        </trans-unit>
        <trans-unit id="d64b48614536e2d9f3fd84e0b2d0f3339ef6dae1" translate="yes" xml:space="preserve">
          <source>FLT_MIN_EXPDBL_MIN_EXPLDBL_MIN_EXP</source>
          <target state="translated">FLT_MIN_EXPDBL_MIN_EXPLDBL_MIN_EXP</target>
        </trans-unit>
        <trans-unit id="3d8d38284d7c48984126ae4544c8465c506ee097" translate="yes" xml:space="preserve">
          <source>FLT_RADIX</source>
          <target state="translated">FLT_RADIX</target>
        </trans-unit>
        <trans-unit id="234dca4e2a0e92e5608ec0464e330e76723ea1d3" translate="yes" xml:space="preserve">
          <source>FLT_ROUNDS</source>
          <target state="translated">FLT_ROUNDS</target>
        </trans-unit>
        <trans-unit id="7e6cd06ba47da57a942743f790919ca173fb6d20" translate="yes" xml:space="preserve">
          <source>FLT_TRUE_MINDBL_TRUE_MINLDBL_TRUE_MIN</source>
          <target state="translated">FLT_TRUE_MINDBL_TRUE_MINLDBL_TRUE_MIN</target>
        </trans-unit>
        <trans-unit id="60945a4b9de8b69d4d5468fc065e520c99d43f40" translate="yes" xml:space="preserve">
          <source>FOPEN_MAX</source>
          <target state="translated">FOPEN_MAX</target>
        </trans-unit>
        <trans-unit id="a5566821049b545a4daaafb3ffc216f6475d4a02" translate="yes" xml:space="preserve">
          <source>FP_FAST_FMAFFP_FAST_FMAFP_FAST_FMAL</source>
          <target state="translated">FP_FAST_FMAFFP_FAST_FMAFP_FAST_FMAL</target>
        </trans-unit>
        <trans-unit id="7813d7fff2e30597969481d9be57e5c18202cb8d" translate="yes" xml:space="preserve">
          <source>FP_ILOGB0FP_ILOGBNAN</source>
          <target state="translated">FP_ILOGB0FP_ILOGBNAN</target>
        </trans-unit>
        <trans-unit id="052dbc6bd1e79a500f50639c055da0a0bddfcda6" translate="yes" xml:space="preserve">
          <source>FP_NORMAL, FP_SUBNORMAL, FP_ZERO, FP_INFINITE, FP_NAN</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b390f17b3415cc66503253a8e943ae6869cbbbb" translate="yes" xml:space="preserve">
          <source>FP_NORMALFP_SUBNORMALFP_ZEROFP_INFINITEFP_NAN</source>
          <target state="translated">FP_NORMALFP_SUBNORMALFP_ZEROFP_INFINITEFP_NAN</target>
        </trans-unit>
        <trans-unit id="13ad13aaa89439dd8522b85f083a14ec539c93e9" translate="yes" xml:space="preserve">
          <source>FP_ZERO</source>
          <target state="translated">FP_ZERO</target>
        </trans-unit>
        <trans-unit id="a1369155ac8ee1937c5466bde76ab0bbbcbba45c" translate="yes" xml:space="preserve">
          <source>File access</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d794a847bb4e5ceadb9c12ac7ab0786d739025aa" translate="yes" xml:space="preserve">
          <source>File access mode flag &lt;code&gt;&quot;b&quot;&lt;/code&gt; can optionally be specified to open a file in binary mode. This flag has no effect on POSIX systems, but on Windows it disables special handling of &lt;code&gt;'\n'&lt;/code&gt; and &lt;code&gt;'\x1A'&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6849f814ac623848f85944a7a942fbf7e9bcb81e" translate="yes" xml:space="preserve">
          <source>File access mode flag &lt;code&gt;&quot;x&quot;&lt;/code&gt; can optionally be appended to &quot;w&quot; or &quot;w+&quot; specifiers. This flag forces the function to fail if the file exists, instead of overwriting it. (C11)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f30e2ebee0e504d4fec6132b2058150d91b77510" translate="yes" xml:space="preserve">
          <source>File input/output</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d853d71d751d53b2d709b880a89265afee92eb91" translate="yes" xml:space="preserve">
          <source>File position indicator on success or &lt;code&gt;&lt;a href=&quot;../io&quot;&gt;EOF&lt;/a&gt;&lt;/code&gt; if failure occurs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a494399ad447f56f41d7522c5db08562d3c24708" translate="yes" xml:space="preserve">
          <source>File positioning</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36cd96e05c782cee5791cf21bde1893978c5c077" translate="yes" xml:space="preserve">
          <source>File scope</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a9cdc70afa5e782250a989c51574a43f1d0f25b" translate="yes" xml:space="preserve">
          <source>File scope restricted pointers are useful in providing access to dynamically allocated global arrays; the restrict semantics make it possible to optimize references through this pointer as effectively as references to a static array through its declared name:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc8284a593a8a291982c4c67910dd38a5e502924" translate="yes" xml:space="preserve">
          <source>File-scope identifiers have &lt;a href=&quot;storage_duration&quot;&gt;external linkage&lt;/a&gt; and &lt;a href=&quot;storage_duration&quot;&gt;static storage duration&lt;/a&gt; by default.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fae255f2995d1f907f01cf7594e8462316da5be7" translate="yes" xml:space="preserve">
          <source>Filename and line information</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a02ae1c73392d3f6a41d7039bf6f66883821f319" translate="yes" xml:space="preserve">
          <source>Finds the first character in wide string pointed to by &lt;code&gt;dest&lt;/code&gt;, that is also in wide string pointed to by &lt;code&gt;str&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6fd83627e8c7b32c0144a6c435a8efcc4874610" translate="yes" xml:space="preserve">
          <source>Finds the first occurrence of &lt;code&gt;ch&lt;/code&gt; (after conversion to &lt;code&gt;char&lt;/code&gt; as if by &lt;code&gt;(char)ch&lt;/code&gt;) in the null-terminated byte string pointed to by &lt;code&gt;str&lt;/code&gt; (each character interpreted as &lt;code&gt;unsigned char&lt;/code&gt;). The terminating null character is considered to be a part of the string and can be found when searching for &lt;code&gt;'\0'&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="156983c4936a90f64d8bde0b4e792911d718b0b0" translate="yes" xml:space="preserve">
          <source>Finds the first occurrence of &lt;code&gt;ch&lt;/code&gt; (after conversion to &lt;code&gt;unsigned char&lt;/code&gt; as if by &lt;code&gt;(unsigned char)ch&lt;/code&gt;) in the initial &lt;code&gt;count&lt;/code&gt; characters (each interpreted as &lt;code&gt;unsigned char&lt;/code&gt;) of the object pointed to by &lt;code&gt;ptr&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f073bd8d629a1976216a0fa2bb49ebd6dc19c4b" translate="yes" xml:space="preserve">
          <source>Finds the first occurrence of the null-terminated byte string pointed to by &lt;code&gt;substr&lt;/code&gt; in the null-terminated byte string pointed to by &lt;code&gt;str&lt;/code&gt;. The terminating null characters are not compared.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9388d73210fb9a6adcc18de249cc87e2da6d4106" translate="yes" xml:space="preserve">
          <source>Finds the first occurrence of the wide character &lt;code&gt;ch&lt;/code&gt; in the wide string pointed to by &lt;code&gt;str&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60954d9dde97ea95b47805de626af5f9bb89a11c" translate="yes" xml:space="preserve">
          <source>Finds the first occurrence of the wide string &lt;code&gt;src&lt;/code&gt; in the wide string pointed to by &lt;code&gt;dest&lt;/code&gt;. The terminating null characters are not compared.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4df137c6700e2d26ec6d629f5fa312ab93f754d7" translate="yes" xml:space="preserve">
          <source>Finds the last occurrence of &lt;code&gt;ch&lt;/code&gt; (after conversion to &lt;code&gt;char&lt;/code&gt; as if by &lt;code&gt;(char)ch&lt;/code&gt;) in the null-terminated byte string pointed to by &lt;code&gt;str&lt;/code&gt; (each character interpreted as &lt;code&gt;unsigned char&lt;/code&gt;). The terminating null character is considered to be a part of the string and can be found if searching for &lt;code&gt;'\0'&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="abb2c2feff5f0426d0ef85cddeeca9860311e3e9" translate="yes" xml:space="preserve">
          <source>Finds the last occurrence of the wide character &lt;code&gt;ch&lt;/code&gt; in the wide string pointed to by &lt;code&gt;str&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd043634a6f2aac8236e977d8fdb5f1580bfb40c" translate="yes" xml:space="preserve">
          <source>First, &lt;a href=&quot;conversion&quot;&gt;integer promotions&lt;/a&gt; are performed, individually, on each operand (Note: this is unlike other binary arithmetic operators, which all perform usual arithmetic conversions). The type of the result is the type of lhs after promotion.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="010a9580b64f6a29762d659e4b63ee2c420030ea" translate="yes" xml:space="preserve">
          <source>First, at &lt;a href=&quot;translation_phases&quot;&gt;translation phase 6&lt;/a&gt; (after macro expansion), the adjacent string literals (that is, string literals separated by whitespace only) are concatenated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3c3d2f054364788d43e5a8d2b30730a8de2382a" translate="yes" xml:space="preserve">
          <source>First, for every thread-specific storage key which was created with a non-null destructor and for which the associated value is non-null (see &lt;code&gt;&lt;a href=&quot;tss_create&quot;&gt;tss_create&lt;/a&gt;&lt;/code&gt;), &lt;code&gt;thrd_exit&lt;/code&gt; sets the value associated with the key to &lt;code&gt;&lt;a href=&quot;../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt; and then invokes the destructor with the previous value of the key. The order in which the destructors are invoked is unspecified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24650e9936b440df3b35e77cd0d75063b1ba7c02" translate="yes" xml:space="preserve">
          <source>First, operators &amp;amp;, ^, and | perform &lt;a href=&quot;conversion#Usual_arithmetic_conversions&quot;&gt;usual arithmetic conversions&lt;/a&gt; on both operands and the operator ~ performs &lt;a href=&quot;conversion#Integer_promotions&quot;&gt;integer promotions&lt;/a&gt; on its only operand.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3892a9441dac662eadf3bbde79b34566a2a5b8a" translate="yes" xml:space="preserve">
          <source>First, remembers the currently raised floating-point exceptions, then restores the floating-point environment from the object pointed to by &lt;code&gt;envp&lt;/code&gt; (similar to &lt;code&gt;&lt;a href=&quot;feenv&quot;&gt;fesetenv&lt;/a&gt;&lt;/code&gt;), then raises the floating-point exceptions that were saved.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5af17ffdb58456bdb2dce4da5ffca99076cb7ee3" translate="yes" xml:space="preserve">
          <source>First, saves the current floating-point environment to the object pointed to by &lt;code&gt;envp&lt;/code&gt; (similar to &lt;code&gt;&lt;a href=&quot;feenv&quot;&gt;fegetenv&lt;/a&gt;&lt;/code&gt;), then clears all floating-point status flags, and then installs the non-stop mode: future floating-point exceptions will not interrupt execution (will not trap), until the floating-point environment is restored by &lt;code&gt;&lt;a href=&quot;feupdateenv&quot;&gt;feupdateenv&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;feenv&quot;&gt;fesetenv&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a0d1a196542aeb51294a3761ccccdf5a2185f41" translate="yes" xml:space="preserve">
          <source>First, the left operand, lhs, is evaluated and its result value is discarded.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f7c8db9e6faaf3d94c8b437cf0d16523b93fd3b" translate="yes" xml:space="preserve">
          <source>First, the type of controlling-expression undergoes &lt;a href=&quot;conversion#Lvalue_conversions&quot;&gt;lvalue conversions&lt;/a&gt;. The conversion is performed in type domain only: it discards the top-level cvr-qualifiers and atomicity and applies array-to-pointer/function-to-pointer transformations to the type of the controlling expression, without initiating any side-effects or calculating any values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27e98ae5f197207336755cc33861b5d103faad58" translate="yes" xml:space="preserve">
          <source>Fixed width integer types</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76a08caa99c505ae8032d07c4012057a86cf1d36" translate="yes" xml:space="preserve">
          <source>Fixed width integer types (since C99)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="840ee99ab9aff1bac4213d391ce03692c895404a" translate="yes" xml:space="preserve">
          <source>Fixed-width integer types</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="663059496ccabb871dffdce9e54cfe1c54e105ee" translate="yes" xml:space="preserve">
          <source>Floating constants</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5679c54758fee21d770fd6c545d0c43032628157" translate="yes" xml:space="preserve">
          <source>Floating point value corresponding to the contents of &lt;code&gt;str&lt;/code&gt; on success. If the converted value falls out of range of corresponding return type, range error occurs and &lt;code&gt;&lt;a href=&quot;../../numeric/math/huge_val&quot;&gt;HUGE_VAL&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../../numeric/math/huge_val&quot;&gt;HUGE_VALF&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../../numeric/math/huge_val&quot;&gt;HUGE_VALL&lt;/a&gt;&lt;/code&gt; is returned. If no conversion can be performed, &lt;code&gt;​0​&lt;/code&gt; is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc58d2a49355b39280fe2f52213175ca7b8fd25a" translate="yes" xml:space="preserve">
          <source>Floating-point constant expressions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="187a207ab4dc1668e42fee15564f93f815a577ae" translate="yes" xml:space="preserve">
          <source>Floating-point constants may convert to more range and precision than is indicated by their type, if indicated by &lt;code&gt;&lt;a href=&quot;../types/limits/flt_eval_method&quot;&gt;FLT_EVAL_METHOD&lt;/a&gt;&lt;/code&gt;. For example, the constant &lt;code&gt;0.1f&lt;/code&gt; may act as if it were &lt;code&gt;0.1L&lt;/code&gt; in an expression.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe4d2e99025a6ead51e9b2e632c32efaa3c94a25" translate="yes" xml:space="preserve">
          <source>Floating-point contraction</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="037c72279324a50181c71503f07e7e0083f1c23d" translate="yes" xml:space="preserve">
          <source>Floating-point environment</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac15e30a03ce45c5cd8e83acd0b5ab29417f912b" translate="yes" xml:space="preserve">
          <source>Floating-point expressions may also be</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c833758c552d43ff6fc0b2c2a0891b29187adbbf" translate="yes" xml:space="preserve">
          <source>Floating-point expressions may have greater range and precision than indicated by their types, see &lt;code&gt;&lt;a href=&quot;../types/limits/flt_eval_method&quot;&gt;FLT_EVAL_METHOD&lt;/a&gt;&lt;/code&gt;. &lt;a href=&quot;operator_assignment&quot;&gt;Assignment&lt;/a&gt;, &lt;a href=&quot;return&quot;&gt;return&lt;/a&gt;, and &lt;a href=&quot;cast&quot;&gt;cast&lt;/a&gt; force the range and precision to the one associated with the declared type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b332b36c83932ce6597945ab99c760510235ccb" translate="yes" xml:space="preserve">
          <source>Floating-point expressions may raise exceptions and report errors as specified in &lt;a href=&quot;../numeric/math/math_errhandling&quot;&gt;math_errhandling&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab903d16590f471723cce0610a9cdcd6209bde69" translate="yes" xml:space="preserve">
          <source>Floating-point manipulation functions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e9ec2743b8311d312a967d346f2be786a835e07" translate="yes" xml:space="preserve">
          <source>Floating-point types may support special values:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06aab856bd9476c0b4dbb7ee054ad78329c4c1ec" translate="yes" xml:space="preserve">
          <source>Floating-point value corresponding to the contents of &lt;code&gt;str&lt;/code&gt; on success. If the converted value falls out of range of corresponding return type, range error occurs and &lt;code&gt;&lt;a href=&quot;../../numeric/math/huge_val&quot;&gt;HUGE_VAL&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../../numeric/math/huge_val&quot;&gt;HUGE_VALF&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../../numeric/math/huge_val&quot;&gt;HUGE_VALL&lt;/a&gt;&lt;/code&gt; is returned. If no conversion can be performed, &lt;code&gt;​0​&lt;/code&gt; is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec0c3b76630fd745381cc215a284820af75a683a" translate="yes" xml:space="preserve">
          <source>Footnotes</source>
          <target state="translated">Footnotes</target>
        </trans-unit>
        <trans-unit id="a6d068410c3d5d5e1e66f214a4705f1da0744b99" translate="yes" xml:space="preserve">
          <source>For &lt;a href=&quot;do&quot;&gt;do-while&lt;/a&gt; loop, it acts as:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a82766f871cb4b85056c582e325e120d94af630" translate="yes" xml:space="preserve">
          <source>For &lt;a href=&quot;for&quot;&gt;for&lt;/a&gt; loop, it acts as:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25aa007ea092cdda566de6d64234cfa5cc3924d2" translate="yes" xml:space="preserve">
          <source>For &lt;a href=&quot;struct&quot;&gt;structs&lt;/a&gt; and &lt;a href=&quot;union&quot;&gt;unions&lt;/a&gt;, declarations that specify the list of members are definitions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67db5ac16c817d0aad978db1daa9912c166fac6a" translate="yes" xml:space="preserve">
          <source>For &lt;a href=&quot;while&quot;&gt;while&lt;/a&gt; loop, it acts as.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10084651562c27997fbdae459a7c23083c2c8a43" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;lrint&lt;/code&gt; and &lt;code&gt;llrint&lt;/code&gt; functions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a21e404fbb1009207c801f3014228685c0a1839d" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;lround&lt;/code&gt; and &lt;code&gt;llround&lt;/code&gt; families of functions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab727ef011ac32b32b71004213c9062e03c40ca6" translate="yes" xml:space="preserve">
          <source>For IEEE-compatible type &lt;code&gt;double&lt;/code&gt;, overflow happens if &lt;code&gt;0 &amp;lt; x &amp;lt; 1/DBL_MAX&lt;/code&gt; or if &lt;code&gt;x &amp;gt; 171.7&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="308485408ad23c9a6a581efd5af8112d70a5819e" translate="yes" xml:space="preserve">
          <source>For IEEE-compatible type &lt;code&gt;double&lt;/code&gt;, overflow is guaranteed if 709.8 &amp;lt; arg, and underflow is guaranteed if arg &amp;lt; -708.4.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ebd607b970e88332eac8b1adf8c8066c0dd8e42" translate="yes" xml:space="preserve">
          <source>For IEEE-compatible type &lt;code&gt;double&lt;/code&gt;, overflow is guaranteed if 709.8 &amp;lt; arg.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4e888a145f1992272e7918f8fc284c6a7e06ad4" translate="yes" xml:space="preserve">
          <source>For a</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5961fe12a3117fa1b2454e762062290b637aa259" translate="yes" xml:space="preserve">
          <source>For a pair of atomic modifications of M called A and B, B occurs after A in M's modification order if.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e336f737f267c22ea911366e2522a1b5935e0af" translate="yes" xml:space="preserve">
          <source>For a pair of atomic operations on M called A and B, where A writes and B reads M's value, if there are two &lt;code&gt;memory_order_seq_cst&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;atomic_thread_fence&quot;&gt;atomic_thread_fence&lt;/a&gt;&lt;/code&gt;s X and Y, and if A is</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d3977eef880647bc052245b337d4dbacc336a33" translate="yes" xml:space="preserve">
          <source>For all complex number functions that do not have real counterparts, a type-generic macro &lt;code&gt;cXXX&lt;/code&gt; exists, which calls either of the variants of a complex function:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6730f4960c4b4de31dd3c96b5509a3c383272937" translate="yes" xml:space="preserve">
          <source>For all functions that do not have complex counterparts, with the exception of &lt;code&gt;modf&lt;/code&gt;, a type-generic macro &lt;code&gt;XXX&lt;/code&gt; exists, which calls either of the variants of a real function:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04997ae64209c733be2a01335fce8eadf79cc061" translate="yes" xml:space="preserve">
          <source>For all functions that have both real and complex counterparts, a type-generic macro &lt;code&gt;XXX&lt;/code&gt; exists, which calls either of:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55501a14e5efa2511e7fc929d66bd9f716e4906e" translate="yes" xml:space="preserve">
          <source>For an identifier with internal or external &lt;a href=&quot;storage_duration&quot;&gt;linkage&lt;/a&gt; declared in a scope in which a prior declaration of that identifier is visible, if the prior declaration specifies internal or external linkage, the type of the identifier at the later declaration becomes the composite type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b64b2293698ec3d176c65a39c39ccccae3114de3" translate="yes" xml:space="preserve">
          <source>For any complex variable &lt;code&gt;z&lt;/code&gt;, &lt;code&gt;z == &lt;a href=&quot;creal&quot;&gt;creal&lt;/a&gt;(z) + I*cimag(z)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a924e7dda6f158c58b3ecd7cd7208221fc267986" translate="yes" xml:space="preserve">
          <source>For any complex variable &lt;code&gt;z&lt;/code&gt;, &lt;code&gt;z == creal(z) + I*&lt;a href=&quot;cimag&quot;&gt;cimag&lt;/a&gt;(z)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a543b26c60ebb052f7bcd4171fdf90efeeb5fc1c" translate="yes" xml:space="preserve">
          <source>For any struct or union declared with a storage-class specifier, the storage duration (but not linkage) applies to their members, recursively.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="587d19dece0a5e657eee4b9c6dab7110d60627cf" translate="yes" xml:space="preserve">
          <source>For any z, acos(z) = &amp;pi; - acos(-z).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21aee1213fe266997611327508955de0364192e9" translate="yes" xml:space="preserve">
          <source>For any z, atanh(z) =</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="688d572612ce95b5162d08e797cd89fdb4d407c3" translate="yes" xml:space="preserve">
          <source>For char arrays shorter than &lt;code&gt;&lt;a href=&quot;limits&quot;&gt;PTRDIFF_MAX&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;ptrdiff_t&lt;/code&gt; acts as the signed counterpart of &lt;code&gt;&lt;a href=&quot;size_t&quot;&gt;size_t&lt;/a&gt;&lt;/code&gt;: it can store the size of the array of any type and is, on most platforms, synonymous with &lt;code&gt;&lt;a href=&quot;integer&quot;&gt;intptr_t&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42dd9f0ffdcfcdcd8c3a5d50abb1358aac15a314" translate="yes" xml:space="preserve">
          <source>For decimal floating constants, the exponent part is optional. If it is omitted, the period is not optional, and either the whole-number or the fraction must be present.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f184cc4c10f89fe313321f740ea02baedf5fc6c" translate="yes" xml:space="preserve">
          <source>For each &lt;a href=&quot;declarations&quot;&gt;declarator&lt;/a&gt;, the initializer, if not omitted, may be one of the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bfeeb8ceed62e73a2f3bd0d30fa50cfae0463352" translate="yes" xml:space="preserve">
          <source>For each macro, the parameters whose corresponding real type in the unsuffixed math.h function is &lt;code&gt;double&lt;/code&gt; are known as</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6a1bb30012f8a1244f1eb8a6420656d9d6e09c6" translate="yes" xml:space="preserve">
          <source>For every conversion specifier other than &lt;code&gt;n&lt;/code&gt;, the longest sequence of input characters which does not exceed any speciﬁed ﬁeld width and which either is exactly what the conversion specifier expects or is a prefix of a sequence it would expect, is what's consumed from the stream. The ﬁrst character, if any, after this consumed sequence remains unread. If the consumed sequence has length zero or if the consumed sequence cannot be converted as specified above, the matching failure occurs unless end-of-ﬁle, an encoding error, or a read error prevented input from the stream, in which case it is an input failure.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83d7a4b53e554acfb54c7ee5d69c5549aa81f75b" translate="yes" xml:space="preserve">
          <source>For every type listed above several qualified versions of its type may exist, corresponding to the combinations of one, two, or all three of the &lt;a href=&quot;const&quot;&gt;const&lt;/a&gt;, &lt;a href=&quot;volatile&quot;&gt;volatile&lt;/a&gt;, and &lt;a href=&quot;restrict&quot;&gt;restrict&lt;/a&gt; qualifiers (where allowed by the qualifier's semantics).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6db6725e9e7d5c088630e348048d1e73fc7657d3" translate="yes" xml:space="preserve">
          <source>For example,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d4b3358e1df9f2bea37a27eaa5e14ffa2bc6778" translate="yes" xml:space="preserve">
          <source>For example, with &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; initially zero,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3af091a84c4312052c5526d63f3a9497407d3111" translate="yes" xml:space="preserve">
          <source>For functions, a declaration that includes the function body is a &lt;a href=&quot;function_definition&quot;&gt;function definition&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75995ccba23b0db3ef2d567077ba1d25c7f8d7cd" translate="yes" xml:space="preserve">
          <source>For hexadecimal floating constants, the exponent is not optional to avoid ambiguity resulting from an f suffix being mistaken as a hexadecimal digit.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec3905377a1c94d495d985035e68f7411ea9980d" translate="yes" xml:space="preserve">
          <source>For input streams (and for update streams on which the last operation was input), the behavior is undefined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3263d60841f8b602b9cc58bd2747c0e72fde62e4" translate="yes" xml:space="preserve">
          <source>For integer &lt;code&gt;arg&lt;/code&gt;, the binary logarithm can be interpreted as the zero-based index of the most significant 1 bit in the input.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="560ed07ef6832b220e08d54f59f5d6efc3edfa88" translate="yes" xml:space="preserve">
          <source>For integer atomic types, the compound assignment &lt;code&gt;@=&lt;/code&gt; is equivalent to:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="536dc8c314b296f6f261eb306e04e8cffb32d705" translate="yes" xml:space="preserve">
          <source>For most &lt;code&gt;z&lt;/code&gt;, &lt;code&gt;cproj(z)==z&lt;/code&gt;, but all complex infinities, even the numbers where one component is infinite and the other is NaN, become positive real infinity, &lt;code&gt;INFINITY+0.0*I&lt;/code&gt; or &lt;code&gt;INFINITY-0.0*I&lt;/code&gt;. The sign of the imaginary (zero) component is the sign of &lt;code&gt;&lt;a href=&quot;cimag&quot;&gt;cimag&lt;/a&gt;(z)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69a061f40ae84751c0047ebb6b42628283ef685f" translate="yes" xml:space="preserve">
          <source>For objects, a declaration that allocates storage (&lt;a href=&quot;storage_duration&quot;&gt;automatic or static&lt;/a&gt;, but not extern) is a definition, while a declaration that does not allocate storage (&lt;a href=&quot;extern&quot;&gt;external declaration&lt;/a&gt;) is not.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f63d9afe770e3006ba3c31bb680ec6934c94657" translate="yes" xml:space="preserve">
          <source>For output streams (and for update streams on which the last operation was output), writes any unwritten data from the &lt;code&gt;stream&lt;/code&gt;'s buffer to the associated output device.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68c6725395fe6fb1de1c0a20e8316ae564ff30cb" translate="yes" xml:space="preserve">
          <source>For relational = and &amp;ne; respectively</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef442ef93a7d1fa17196f13ed58dd573c463f6d6" translate="yes" xml:space="preserve">
          <source>For relational operators &amp;gt; and &amp;ge; respectively</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b60290890a2917bb2e0cc3c4c8b8aa425f9bd30" translate="yes" xml:space="preserve">
          <source>For relational operators &amp;lt; and &amp;le; respectively</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="879eb9efaaa4654c8cf8c35b00408e67b8bf1832" translate="yes" xml:space="preserve">
          <source>For signed integer types, arithmetic is defined to use two&amp;rsquo;s complement representation. There are no undefined results. For pointer types, the result may be an undefined address, but the operations otherwise have no undefined behavior.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80e4c346fe02c1a18878d7d91ddce96980e8a1f4" translate="yes" xml:space="preserve">
          <source>For text streams, the only valid values of &lt;code&gt;offset&lt;/code&gt; are &lt;code&gt;​0​&lt;/code&gt; (applicable to any &lt;code&gt;origin&lt;/code&gt;) and a value returned by an earlier call to &lt;code&gt;&lt;a href=&quot;ftell&quot;&gt;ftell&lt;/a&gt;&lt;/code&gt; (only applicable to &lt;code&gt;SEEK_SET&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c8bc61f784489c1be269b98b2a834b94911c08f" translate="yes" xml:space="preserve">
          <source>For the &lt;code&gt;A&lt;/code&gt; conversion style</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2ae91f5c3692945d40532e2d71ac0a4386bf89f" translate="yes" xml:space="preserve">
          <source>For the &lt;code&gt;E&lt;/code&gt; conversion style</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ebb3f8b2a8fff5b3415e1098f326b2c10a1d27f2" translate="yes" xml:space="preserve">
          <source>For the &lt;code&gt;G&lt;/code&gt; conversion style conversion with style &lt;code&gt;E&lt;/code&gt; or &lt;code&gt;F&lt;/code&gt; will be performed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a1ff43b4f3925bee54ad2942ba18ef8a4606c5a" translate="yes" xml:space="preserve">
          <source>For the &lt;code&gt;X&lt;/code&gt; conversion letters &lt;code&gt;ABCDEF&lt;/code&gt; are used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57890cceddb7efc24f01d52d8cf7f7dcc8bbc9c7" translate="yes" xml:space="preserve">
          <source>For the &lt;code&gt;a&lt;/code&gt; conversion style</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41f7d301edd4649ecc9cc5e4ae27295bc06e8657" translate="yes" xml:space="preserve">
          <source>For the &lt;code&gt;e&lt;/code&gt; conversion style</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a793f4315aaf80e04799e8d39a2f905e34a3d0ea" translate="yes" xml:space="preserve">
          <source>For the &lt;code&gt;g&lt;/code&gt; conversion style conversion with style &lt;code&gt;e&lt;/code&gt; or &lt;code&gt;f&lt;/code&gt; will be performed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="807d09a568c3d3ab555b52969a3cc98de7806c36" translate="yes" xml:space="preserve">
          <source>For the &lt;code&gt;x&lt;/code&gt; conversion letters &lt;code&gt;abcdef&lt;/code&gt; are used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="964c75b68c3b67fa44944f427366e59ff71c8628" translate="yes" xml:space="preserve">
          <source>For the IEEE-compatible type &lt;code&gt;double&lt;/code&gt;, if |arg| &amp;gt; 710.5, then &lt;code&gt;cosh(arg)&lt;/code&gt; overflows.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc98bc92461ef84f63213928d7e0dd4bec2a4ac3" translate="yes" xml:space="preserve">
          <source>For the IEEE-compatible type &lt;code&gt;double&lt;/code&gt;, underflow is guaranteed if &lt;code&gt;arg&lt;/code&gt; &amp;gt; 26.55.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a1e05ff972bb1fabc13e5a58a87f80191cc1553" translate="yes" xml:space="preserve">
          <source>For the objects of type char, signed char, and unsigned char, every bit of the object representation is required to participate in the value representation and each possible bit pattern represents a distinct value (no padding, trap bits, or multiple representations allowed).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73df8e10bbeffa07fc22138e0b70d965b3e4a35b" translate="yes" xml:space="preserve">
          <source>For the objects that are declared with automatic, static, and thread storage duration, lifetime equals their &lt;a href=&quot;storage_duration&quot;&gt;storage duration&lt;/a&gt; (note the difference between non-VLA and VLA automatic storage duration).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc128730b3badfe5698c4b1f3a2f185e2ed4fea5" translate="yes" xml:space="preserve">
          <source>For the objects with allocated storage duration, the lifetime begins when the allocation function returns (including the return from &lt;code&gt;&lt;a href=&quot;../memory/realloc&quot;&gt;realloc&lt;/a&gt;&lt;/code&gt;) and ends when the &lt;code&gt;&lt;a href=&quot;../memory/realloc&quot;&gt;realloc&lt;/a&gt;&lt;/code&gt; or deallocation function is called. Note that since allocated objects have no &lt;a href=&quot;object&quot;&gt;declared type&lt;/a&gt;, the type of the lvalue expression first used to access this object becomes its &lt;a href=&quot;object&quot;&gt;effective type&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85282601413e96349836f3981d64d53720f214c0" translate="yes" xml:space="preserve">
          <source>For the purpose of pointer arithmetic, a pointer to an object that is not an element of any array is treated as a pointer to the first element of an array of size 1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e385562c47760adbc54c3ba96ba6ba291ce3d32e" translate="yes" xml:space="preserve">
          <source>For unsigned lhs and for signed lhs with nonnegative values, the value of &lt;code&gt;LHS &amp;gt;&amp;gt; RHS&lt;/code&gt; is the integer part of LHS / 2RHS</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b78e8d26fc84b75eb18e29ba68eb6707882c4aea" translate="yes" xml:space="preserve">
          <source>For unsigned lhs, the value of &lt;code&gt;LHS &amp;lt;&amp;lt; RHS&lt;/code&gt; is the value of LHS * 2RHS</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bccf9c84234fd9e53ce6ea6772d91da3ac9147fd" translate="yes" xml:space="preserve">
          <source>For use of bytes to representation values of other fundamental types (including big-endian and little-endian memory layouts), see &lt;a href=&quot;object#Object_representation&quot;&gt;object representation&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3bfb55cdc85542de2eeac7c01ac22e44b5143662" translate="yes" xml:space="preserve">
          <source>Formally,</source>
          <target state="translated">Formally,</target>
        </trans-unit>
        <trans-unit id="3e6350defe07d4e2839cc6eb5191b1da5190bee4" translate="yes" xml:space="preserve">
          <source>Formally, the unbiased exponent is the integral part of log</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91dd56eddc735a099ddc37f2c2b8d705630baadf" translate="yes" xml:space="preserve">
          <source>Formally, the unbiased exponent is the signed integral part of log</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="041a5dec481d6bf0724caeaa84bc135d7d9062d4" translate="yes" xml:space="preserve">
          <source>Format</source>
          <target state="translated">Format</target>
        </trans-unit>
        <trans-unit id="375f5594c659e5ff8bd611de411cc215c9d6fb94" translate="yes" xml:space="preserve">
          <source>Format constants for the &lt;code&gt;&lt;a href=&quot;../io/fprintf&quot;&gt;fprintf&lt;/a&gt;&lt;/code&gt; family of functions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46ffb8548d52b3ad3fbe1f297d1fca34ee39282c" translate="yes" xml:space="preserve">
          <source>Format constants for the &lt;code&gt;&lt;a href=&quot;../io/fscanf&quot;&gt;fscanf&lt;/a&gt;&lt;/code&gt; family of functions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a28652e2e23cf314a85ef17df4e8261414955885" translate="yes" xml:space="preserve">
          <source>Format conversion of integer types</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b8afd05c64332502d3616cc67779e98de2c7168" translate="yes" xml:space="preserve">
          <source>Format conversions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7175d023e27abe317865a491022a09c5f080a380" translate="yes" xml:space="preserve">
          <source>Format macro constants</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee59b03a5ff5c727bd5ce0a27fd2bc91e970bc1f" translate="yes" xml:space="preserve">
          <source>Formatted input/output</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82ea89ab75987595e45620e5e795108b1b6e0406" translate="yes" xml:space="preserve">
          <source>Forward declaration</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f91dbf7a513677af10fb3592a515c7e6904306f" translate="yes" xml:space="preserve">
          <source>Full type name</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f14045db7fd843c69383648cf94f75fb3d176a15" translate="yes" xml:space="preserve">
          <source>Function call</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c89b9bb41c4c13c872e30f5eb0bb250a5c580801" translate="yes" xml:space="preserve">
          <source>Function declaration</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="301ffb948f7d729015635b11db6553b40624b34f" translate="yes" xml:space="preserve">
          <source>Function declarations</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6bcd818ad8d35fa4ac158274d99b7201a135a1f" translate="yes" xml:space="preserve">
          <source>Function declarations at block scope can use &lt;code&gt;extern&lt;/code&gt; or none at all. Function declarations at file scope can use &lt;code&gt;extern&lt;/code&gt; or &lt;code&gt;static&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e44d37020289cf4e22446e56d29f9f3a5cb0dd6" translate="yes" xml:space="preserve">
          <source>Function declarators can be combined with other declarators as long as they can share their type specifiers and qualifiers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5f8af75bc5ad30466ed317152a310aba07e877e" translate="yes" xml:space="preserve">
          <source>Function definition</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6845f6242d31b642f35208f093f8e9aba102be9" translate="yes" xml:space="preserve">
          <source>Function definitions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0004b660206eedce99e85c5907656101eed2ba97" translate="yes" xml:space="preserve">
          <source>Function designator expression</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56247e3ce0cb2812a9cd7b40705c577d342f4d79" translate="yes" xml:space="preserve">
          <source>Function discards any whitespace characters (as determined by &lt;code&gt;std::&lt;a href=&quot;isspace&quot;&gt;isspace&lt;/a&gt;()&lt;/code&gt;) until first non-whitespace character is found. Then it takes as many characters as possible to form a valid floating-point representation and converts them to a floating-point value. The valid floating-point value can be one of the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ac61bae440a3f41b35363be03410015a24d97cd" translate="yes" xml:space="preserve">
          <source>Function discards any whitespace characters (as determined by &lt;code&gt;std::&lt;a href=&quot;iswspace&quot;&gt;iswspace&lt;/a&gt;()&lt;/code&gt;) until first non-whitespace character is found. Then it takes as many characters as possible to form a valid floating-point representation and converts them to a floating-point value. The valid floating-point value can be one of the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60be48a55b3f6bfe81f126777640e7116a702836" translate="yes" xml:space="preserve">
          <source>Function macros for minimum-width integer constants</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8611a2a8a66243d802deec0150be8ab29d36d93c" translate="yes" xml:space="preserve">
          <source>Function names, type names, and enumeration constants that begin with either &lt;code&gt;cnd_&lt;/code&gt;, &lt;code&gt;mtx_&lt;/code&gt;, &lt;code&gt;thrd_&lt;/code&gt;, or &lt;code&gt;tss_&lt;/code&gt;, and a lowercase letter may be added to the declarations in the &lt;code&gt;&amp;lt;threads.h&amp;gt;&lt;/code&gt; header in future revisions of the C standard, and portable programs should not use those identifiers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d302435048821cd6e2c77c400cdc613a006798f" translate="yes" xml:space="preserve">
          <source>Function parameter</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="897bc01f0c788bf99ba1e506b918d0c6dc003db3" translate="yes" xml:space="preserve">
          <source>Function parameters cannot use any storage-class specifiers other than &lt;code&gt;register&lt;/code&gt;. Note that &lt;code&gt;static&lt;/code&gt; has special meaning in function parameters of array type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65b1ee7db3df5d96f4d481571269021a7e58f345" translate="yes" xml:space="preserve">
          <source>Function prototype scope</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14644346bcc70a878c3eb265226005a7304bec16" translate="yes" xml:space="preserve">
          <source>Function scope</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc0c3a9a39538ad721a8a34b1652f79fa1c98697" translate="yes" xml:space="preserve">
          <source>Function to pointer conversion</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e3030f5a7f048cef8382d50828336e71bb753d2" translate="yes" xml:space="preserve">
          <source>Function-like macros</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1db43149fb17967937b95803eca5c9dd022b9456" translate="yes" xml:space="preserve">
          <source>Function-like macros replace each occurrence of a defined identifier with replacement-list, additionally taking a number of arguments, which then replace corresponding occurrences of any of the parameters in the replacement-list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b961dea1dc0c60ddf9a2c8e9d090f6f7d082483" translate="yes" xml:space="preserve">
          <source>Functions</source>
          <target state="translated">Functions</target>
        </trans-unit>
        <trans-unit id="b739266e3c6aeb113a3693680f16c996224db99c" translate="yes" xml:space="preserve">
          <source>Functions may accept zero or more</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1788789dd164ce9b4d0f6beaa43826240bc2b04a" translate="yes" xml:space="preserve">
          <source>Functions passed to &lt;code&gt;&lt;a href=&quot;at_quick_exit&quot;&gt;at_quick_exit()&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;atexit&quot;&gt;atexit()&lt;/a&gt;&lt;/code&gt; are not called. Whether open streams with unwritten buffered data are flushed, open streams are closed, or temporary files are removed is implementation-defined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="093b58a5c37c2b165378562c2473a310e08a10ac" translate="yes" xml:space="preserve">
          <source>Functions passed to &lt;code&gt;&lt;a href=&quot;at_quick_exit&quot;&gt;at_quick_exit&lt;/a&gt;&lt;/code&gt; are called in reverse order of their registration. After calling the registered functions, calls &lt;code&gt;&lt;a href=&quot;_exit&quot;&gt;_Exit&lt;/a&gt;(exit_code)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6eaa62088da9f4aaace239ef18473787adba2624" translate="yes" xml:space="preserve">
          <source>Functions passed to &lt;code&gt;&lt;a href=&quot;atexit&quot;&gt;atexit()&lt;/a&gt;&lt;/code&gt; are not called. Whether open resources such as files are closed is implementation defined. An implementation defined status is returned to the host environment that indicates unsuccessful execution.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c38cb46c4c3dc86adeece732ff02d4d810f5334b" translate="yes" xml:space="preserve">
          <source>Functions that ignore unused arguments, such as &lt;code&gt;&lt;a href=&quot;../io/fprintf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt;, must be called with a prototype in scope (the prototype of such functions necessarily uses the &lt;a href=&quot;variadic&quot;&gt;trailing ellipsis&lt;/a&gt; parameter) to avoid invoking undefined behavior.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="987a9735f7910a78415404d390c2c2321b297df5" translate="yes" xml:space="preserve">
          <source>Functions to determine the type contained in character data</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56333d40b9d13a5dd6765448f63eb5888129f41c" translate="yes" xml:space="preserve">
          <source>Functions to determine the type contained in wide character data</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9ccc0fa4eefc3fc4fbd603adf877686e0fcb107" translate="yes" xml:space="preserve">
          <source>Fundamental types defined by the language</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b40e0801f27d530d95fd36fa896a9bc2b6b5bae8" translate="yes" xml:space="preserve">
          <source>G.1/1 __STDC_IEC_559_COMPLEX__ (p: 467)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26bf5fe88c328fbc6e45a59d6ad8c3338b8f81d3" translate="yes" xml:space="preserve">
          <source>G.1/1 __STDC_IEC_559_COMPLEX__ (p: 532)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95c12bcd2220cd7ce08b8f2049d3ec8c11b89bc0" translate="yes" xml:space="preserve">
          <source>G.5 Common extensions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6cfe6dbfae9b4bae4ad5072108c7d017fc8beae5" translate="yes" xml:space="preserve">
          <source>G.6.1.1 The cacos functions (p: 474)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28cd3a62fe8f1c7d66de5b67bae415419d002420" translate="yes" xml:space="preserve">
          <source>G.6.1.1 The cacos functions (p: 539)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d6828ca5fb97ca1d1f2d7c68567b2a005ebd2dc" translate="yes" xml:space="preserve">
          <source>G.6.2.1 The cacosh functions (p: 474-475)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5563291e3a61ef1c53c5a28c3172a343b28df495" translate="yes" xml:space="preserve">
          <source>G.6.2.1 The cacosh functions (p: 539-540)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15c4239db1623508b82ef247489b388de1f145aa" translate="yes" xml:space="preserve">
          <source>G.6.2.2 The casinh functions (p: 475)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d95db88fd7fa78e9816bf9ac2e9ac27bc72cdaef" translate="yes" xml:space="preserve">
          <source>G.6.2.2 The casinh functions (p: 540)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d126febe0f09e9c82a643bf277ca8d4fe4e04945" translate="yes" xml:space="preserve">
          <source>G.6.2.3 The catanh functions (p: 475-476)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9df4d1c541d6a2988fd893d1e22aa72d9155e65" translate="yes" xml:space="preserve">
          <source>G.6.2.3 The catanh functions (p: 540-541)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="151135301ba799fb81ac54ff917a64f55b3d87b2" translate="yes" xml:space="preserve">
          <source>G.6.2.4 The ccosh functions (p: 476)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="efb2b4b5712cfe1e5839fb21e5627757b0aab87b" translate="yes" xml:space="preserve">
          <source>G.6.2.4 The ccosh functions (p: 541)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="694daeb728fce58d77bf0d8e64905eea2b21ad5f" translate="yes" xml:space="preserve">
          <source>G.6.2.5 The csinh functions (p: 476-477)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59eab894944e803c504dd7168fa4266717e78383" translate="yes" xml:space="preserve">
          <source>G.6.2.5 The csinh functions (p: 541-542)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2df7c85c1d43e348f139a6b045dc1d5b8012c06" translate="yes" xml:space="preserve">
          <source>G.6.2.6 The ctanh functions (p: 477)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9eb1944f14793485c1748feed122919547f89b9" translate="yes" xml:space="preserve">
          <source>G.6.2.6 The ctanh functions (p: 542)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11bf1336a1baab07ae8854d62d4f99e7b6ec203d" translate="yes" xml:space="preserve">
          <source>G.6.3.1 The cexp functions (p: 478)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e149ca4beb9e25b6bda49409bda5f10206e086b7" translate="yes" xml:space="preserve">
          <source>G.6.3.1 The cexp functions (p: 543)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9c93804224051a50630d62c4ed8220690a9bfa6" translate="yes" xml:space="preserve">
          <source>G.6.3.2 The clog functions (p: 478-479)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b973293eede2ecb3bd41d6f371cc4d1697571cd1" translate="yes" xml:space="preserve">
          <source>G.6.3.2 The clog functions (p: 543-544)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c92214d3d5a8fbcf280afad86e034a21ce259174" translate="yes" xml:space="preserve">
          <source>G.6.4.1 The cpow functions (p: 479)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de2003697457272aa833f7982055194cc6b7115f" translate="yes" xml:space="preserve">
          <source>G.6.4.1 The cpow functions (p: 544)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e40ff81ce8c3267d1bf703062d6a64cc98b1f38c" translate="yes" xml:space="preserve">
          <source>G.6.4.2 The csqrt functions (p: 479)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05f7734e308beb0fedfb7893ef3fa7e54af7b545" translate="yes" xml:space="preserve">
          <source>G.6.4.2 The csqrt functions (p: 544)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c20fd542256174a6393b0316152fcef6e7b39622" translate="yes" xml:space="preserve">
          <source>G.6/1 I (p: 472)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e76143abbf8e87829cf91c7d518a52e7300d298b" translate="yes" xml:space="preserve">
          <source>G.6/1 I (p: 537)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2e6820b346f1cb99f63ee321c682a377db511b9" translate="yes" xml:space="preserve">
          <source>G.6/1 _Imaginary_I (p: 472)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ccf37492c7533141e934c40b558afd151233311" translate="yes" xml:space="preserve">
          <source>G.6/1 _Imaginary_I (p: 537)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="208724c83318d0110acbd3f15de4edddbcd6efdf" translate="yes" xml:space="preserve">
          <source>G.6/1 imaginary (p: 472)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf45a995bfaea360a6835fd54d30380487b0f7e5" translate="yes" xml:space="preserve">
          <source>G.6/1 imaginary (p: 537)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50662b8108e397a8cf830e58874d9ce4fe937eaf" translate="yes" xml:space="preserve">
          <source>G.7 Type-generic math &amp;lt;tgmath.h&amp;gt; (p: 480)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f44e0122fc6c4e13b2e4136b84f00a56924a452" translate="yes" xml:space="preserve">
          <source>G.7 Type-generic math &amp;lt;tgmath.h&amp;gt; (p: 545)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac2bfb22c6d1b00526db5c04d7d3f16f7a772c12" translate="yes" xml:space="preserve">
          <source>GCC provides a non-portable extension that allows imaginary constants to be specified with the suffix &lt;code&gt;i&lt;/code&gt; on integer literals: &lt;code&gt;1.0fi&lt;/code&gt;, &lt;code&gt;1.0i&lt;/code&gt;, and &lt;code&gt;1.0li&lt;/code&gt; are imaginary units in GNU C. A similar approach is part of standard C++ as of C++14 (&lt;code&gt;1.0if&lt;/code&gt;, &lt;code&gt;1.0i&lt;/code&gt;, and &lt;code&gt;1.0il&lt;/code&gt; are the imaginary units in C++).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9239ee2cda84eca4c3440e2a7b50148af67da3d4" translate="yes" xml:space="preserve">
          <source>General</source>
          <target state="translated">General</target>
        </trans-unit>
        <trans-unit id="10dd377e783f3967d6438e53ce8a2f7f5022cc8a" translate="yes" xml:space="preserve">
          <source>General utilities: &lt;a href=&quot;memory&quot;&gt;memory management&lt;/a&gt;, &lt;a href=&quot;program&quot;&gt;program utilities&lt;/a&gt;, &lt;a href=&quot;string&quot;&gt;string conversions&lt;/a&gt;, &lt;a href=&quot;numeric/random&quot;&gt;random numbers&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e408e1f43fa73d535c56f0c1a60024c29bed6a6f" translate="yes" xml:space="preserve">
          <source>Generally speaking, the pseudo-random number generator should only be seeded once, before any calls to &lt;code&gt;rand()&lt;/code&gt;, and the start of the program. It should not be repeatedly seeded, or reseeded every time you wish to generate a new batch of pseudo-random numbers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12eb72d3243c15b2d7666b7ae7d45ad3f7dad95a" translate="yes" xml:space="preserve">
          <source>Generic selection</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4f8b78ea64ed83627d292f81c40574ae35f827f" translate="yes" xml:space="preserve">
          <source>Generic selection is similar to overloading in C++ (where one of several functions is chosen at compile time based on the types of the arguments), except that it makes the selection between arbitrary expressions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f82dd9e5af6da2aa72552c81bdb59e03bf15b8e1" translate="yes" xml:space="preserve">
          <source>Given an object with</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c10602e998b8cfe65e56c43becd8d2b538c79d91" translate="yes" xml:space="preserve">
          <source>HP aCC compiler pragmas</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="498203d3437361cd8d2965b93c0eb3f8af84971a" translate="yes" xml:space="preserve">
          <source>HUGE_VALF, HUGE_VAL, HUGE_VALL</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ff054331f849fe26ab715fa596bf0d6c1b9b49c" translate="yes" xml:space="preserve">
          <source>HUGE_VALFHUGE_VALHUGE_VALL</source>
          <target state="translated">HUGE_VALFHUGE_VALHUGE_VALL</target>
        </trans-unit>
        <trans-unit id="b38181b2101d3ec22f60111fb7da75e6dc9d72e8" translate="yes" xml:space="preserve">
          <source>HUGE_VALL</source>
          <target state="translated">HUGE_VALL</target>
        </trans-unit>
        <trans-unit id="f786495fe9ea368b774d5544cbb82c7ec30035c0" translate="yes" xml:space="preserve">
          <source>Header name preprocessing tokens are only formed within a &lt;code&gt;#include&lt;/code&gt; directive and in implementation-defined locations within a &lt;code&gt;#pragma&lt;/code&gt; directive.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8559345b43a025d30613b072a1f7f0d697cc5027" translate="yes" xml:space="preserve">
          <source>Hexadecimal escape sequences have no length limit and terminate at the first character that is not a valid hexadecimal digit. If the value represented by a single hexadecimal escape sequence does not fit the range of values represented by the character type used in this string literal or character constant (&lt;code&gt;char&lt;/code&gt;, &lt;code&gt;char16_t&lt;/code&gt;, &lt;code&gt;char32_t&lt;/code&gt;, or &lt;code&gt;wchar_t&lt;/code&gt;), the result is unspecified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9323be5c110b5aa5f2d228930349fa184bfe2fd" translate="yes" xml:space="preserve">
          <source>History of C</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96e08c08807a48c02c8a25b2e222a3aa87859604" translate="yes" xml:space="preserve">
          <source>Hour, minute, second</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f15adf7bfe70ef5a75b3b7c3331bdfc66a4acaf1" translate="yes" xml:space="preserve">
          <source>However, when an initializer begins with a left open brace, its</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dff18122d5fc3679e0217a5ccca9f25c585e46ac" translate="yes" xml:space="preserve">
          <source>Hyperbolic cosine is an entire function in the complex plane and has no branch cuts. It is periodic with respect to the imaginary component, with period 2&amp;pi;i.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3ed3aadb3c9adb061d870e136cd1453348e8c73" translate="yes" xml:space="preserve">
          <source>Hyperbolic functions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a05dc25b96449633c73f65c5aa0e18f13e31788b" translate="yes" xml:space="preserve">
          <source>Hyperbolic sine is an entire function in the complex plane and has no branch cuts. It is periodic with respect to the imaginary component, with period 2&amp;pi;i.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="413dc47c587aa42c078941a669410916c5e97bcf" translate="yes" xml:space="preserve">
          <source>Hyperbolic tangent is an analytical function on the complex plane and has no branch cuts. It is periodic with respect to the imaginary component, with period &amp;pi;i, and has poles of the first order along the imaginary line, at coordinates (0, &amp;pi;(1/2 + n)). However no common floating-point representation is able to represent &amp;pi;/2 exactly, thus there is no value of the argument for which a pole error occurs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca73ab65568cd125c2d27a22bbd9e863c10b675d" translate="yes" xml:space="preserve">
          <source>I</source>
          <target state="translated">I</target>
        </trans-unit>
        <trans-unit id="b35c4b7a4582b768650003b92551d670cc72067a" translate="yes" xml:space="preserve">
          <source>I/O streams are objects of type &lt;code&gt;FILE&lt;/code&gt; that can only be accessed and manipulated through pointers of type &lt;code&gt;FILE*&lt;/code&gt; (Note: while it may be possible to create a local object of type &lt;code&gt;FILE&lt;/code&gt; by dereferencing and copying a valid &lt;code&gt;FILE*&lt;/code&gt;, using the address of such copy in the I/O functions is undefined behavior). Each stream is associated with an external physical device (file, standard input stream, printer, serial port, etc).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c237a26303d9ce6c44278fc659b5347852badd06" translate="yes" xml:space="preserve">
          <source>I/O streams can be used for both unformatted and formatted input and output. They are locale-sensitive and may perform wide/multibyte conversions as necessary. All streams access the same locale object: the one most recently installed with &lt;code&gt;&lt;a href=&quot;locale/setlocale&quot;&gt;setlocale&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03c599d26b9f4c8b751cead1f324b345be4d7ceb" translate="yes" xml:space="preserve">
          <source>IEC 60559 recommends that &lt;code&gt;from&lt;/code&gt; is returned whenever &lt;code&gt;from==to&lt;/code&gt;. These functions return &lt;code&gt;to&lt;/code&gt; instead, which makes the behavior around zero consistent: &lt;code&gt;nextafter(-0.0, +0.0)&lt;/code&gt; returns &lt;code&gt;+0.0&lt;/code&gt; and &lt;code&gt;nextafter(+0.0, -0.0)&lt;/code&gt; returns &lt;code&gt;&amp;ndash;0.0&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d95a8939f16c4020223847e17e36720cebf2bb9" translate="yes" xml:space="preserve">
          <source>IEEE-754</source>
          <target state="translated">IEEE-754</target>
        </trans-unit>
        <trans-unit id="42d5d0fd7522f477e6c48c8cc234d0d9ab04dea9" translate="yes" xml:space="preserve">
          <source>ILP32</source>
          <target state="translated">ILP32</target>
        </trans-unit>
        <trans-unit id="bb6e7841dba2c83d7f4685d9f749f0a969927ab9" translate="yes" xml:space="preserve">
          <source>INFINITY</source>
          <target state="translated">INFINITY</target>
        </trans-unit>
        <trans-unit id="0c47ba7d876463299943e6f3c404bf80428ff851" translate="yes" xml:space="preserve">
          <source>INT8_CINT16_CINT32_CINT64_C</source>
          <target state="translated">INT8_CINT16_CINT32_CINT64_C</target>
        </trans-unit>
        <trans-unit id="9ea288f9428eb0424cc8044a5b63c8eac0420d9a" translate="yes" xml:space="preserve">
          <source>INT8_MAXINT16_MAXINT32_MAXINT64_MAX</source>
          <target state="translated">INT8_MAXINT16_MAXINT32_MAXINT64_MAX</target>
        </trans-unit>
        <trans-unit id="bc5a628cd596773389eaaf98a83bf94ceac150f9" translate="yes" xml:space="preserve">
          <source>INT8_MININT16_MININT32_MININT64_MIN</source>
          <target state="translated">INT8_MININT16_MININT32_MININT64_MIN</target>
        </trans-unit>
        <trans-unit id="f9102afc9b1d8d90bfec23471f9597ad0cf050e9" translate="yes" xml:space="preserve">
          <source>INTMAX_C</source>
          <target state="translated">INTMAX_C</target>
        </trans-unit>
        <trans-unit id="aefed58e7c3b20f7462bf747350723518bd7f3f5" translate="yes" xml:space="preserve">
          <source>INTMAX_MAX</source>
          <target state="translated">INTMAX_MAX</target>
        </trans-unit>
        <trans-unit id="a349d125102eeb5388d505c737ca6ccb840fc470" translate="yes" xml:space="preserve">
          <source>INTMAX_MIN</source>
          <target state="translated">INTMAX_MIN</target>
        </trans-unit>
        <trans-unit id="a8b82d9c693483b9795a47d286279f7fe077830a" translate="yes" xml:space="preserve">
          <source>INTPTR_MAX</source>
          <target state="translated">INTPTR_MAX</target>
        </trans-unit>
        <trans-unit id="ea1e73a8ba1358e9d441c380ac5a64aadd6313f9" translate="yes" xml:space="preserve">
          <source>INTPTR_MIN</source>
          <target state="translated">INTPTR_MIN</target>
        </trans-unit>
        <trans-unit id="cb3002d9d4b8d1bb4ad6b3fb3f8ee0eb1cd9e1b9" translate="yes" xml:space="preserve">
          <source>INT_FAST8_MAXINT_FAST16_MAXINT_FAST32_MAXINT_FAST64_MAX</source>
          <target state="translated">INT_FAST8_MAXINT_FAST16_MAXINT_FAST32_MAXINT_FAST64_MAX</target>
        </trans-unit>
        <trans-unit id="5c002bd42be6d97da6ee9fd6a8de846f49b7760c" translate="yes" xml:space="preserve">
          <source>INT_FAST8_MININT_FAST16_MININT_FAST32_MININT_FAST64_MIN</source>
          <target state="translated">INT_FAST8_MININT_FAST16_MININT_FAST32_MININT_FAST64_MIN</target>
        </trans-unit>
        <trans-unit id="81b4c2799073b036b71feb59eff38c668d0be8e4" translate="yes" xml:space="preserve">
          <source>INT_LEAST8_MAXINT_LEAST16_MAXINT_LEAST32_MAXINT_LEAST64_MAX</source>
          <target state="translated">INT_LEAST8_MAXINT_LEAST16_MAXINT_LEAST32_MAXINT_LEAST64_MAX</target>
        </trans-unit>
        <trans-unit id="303ab3b780f2f436597e803172a659d338cb695a" translate="yes" xml:space="preserve">
          <source>INT_LEAST8_MININT_LEAST16_MININT_LEAST32_MININT_LEAST64_MIN</source>
          <target state="translated">INT_LEAST8_MININT_LEAST16_MININT_LEAST32_MININT_LEAST64_MIN</target>
        </trans-unit>
        <trans-unit id="b7d04a533ba2785a0158159ad98ad6ef6b754b06" translate="yes" xml:space="preserve">
          <source>ISO 30112 defines POSIX control characters as Unicode characters U+0000..U+001F, U+007F..U+009F, U+2028, and U+2029 (Unicode classes Cc, Zl, and Zp).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fff375c325eb5a33dd2e39fc8434af17d533adb3" translate="yes" xml:space="preserve">
          <source>ISO 30112 defines POSIX space characters as Unicode characters U+0009..U+000D, U+0020, U+1680, U+180E, U+2000..U+2006, U+2008..U+200A, U+2028, U+2029, U+205F, and U+3000.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06b6ace8ca3f18249e8ba4ea9090c0f34564ce1c" translate="yes" xml:space="preserve">
          <source>Identifier</source>
          <target state="translated">Identifier</target>
        </trans-unit>
        <trans-unit id="5df5db83d291a84e8693ec1784228be5a9d8a9a4" translate="yes" xml:space="preserve">
          <source>Identifiers a, b, f, and g have file scope.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2672ebe977d252cfae360252c5fb4f4f69527b64" translate="yes" xml:space="preserve">
          <source>Identifiers can denote the following types of entities:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a53835700ea021acf4e404661a96971fd56c8741" translate="yes" xml:space="preserve">
          <source>Identifiers for thread states and errors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="012e30d5ff7b0eca7096ca0ef0422f1cf1ad5ef5" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;../preprocessor/impl&quot;&gt;&lt;code&gt; #pragma STDC FENV_ACCESS&lt;/code&gt;&lt;/a&gt; is set to &lt;code&gt;ON&lt;/code&gt;, all floating-point arithmetic operators obey the current floating-point &lt;a href=&quot;../numeric/fenv/fe_round&quot;&gt;rounding direction&lt;/a&gt; and report floating-point arithmetic errors as specified in &lt;a href=&quot;../numeric/math/math_errhandling&quot;&gt;&lt;code&gt;math_errhandling&lt;/code&gt;&lt;/a&gt; unless part of a &lt;a href=&quot;initialization&quot;&gt;static initializer&lt;/a&gt; (in which case floating-point exceptions are not raised and the rounding mode is to nearest).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0287f0c686ba01cad63a0be3dc59fccc6064694" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;../../types/limits&quot;&gt;FLT_RADIX&lt;/a&gt;&lt;/code&gt; is 2 (or a power of 2), the returned value is exact, &lt;a href=&quot;../fenv/fe_round&quot;&gt;the current rounding mode&lt;/a&gt; is ignored</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31d86a702dd47847a66399b1dc80f0da0b7cfa5e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;../io&quot;&gt;BUFSIZ&lt;/a&gt;&lt;/code&gt; is not the appropriate buffer size, &lt;code&gt;&lt;a href=&quot;setvbuf&quot;&gt;setvbuf&lt;/a&gt;&lt;/code&gt; can be used to change it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89b79b5672025a2dcd4c160d18058bb72dde7976" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;NDEBUG&lt;/code&gt; is defined as a macro name at the point in the source code where &lt;code&gt;&amp;lt;assert.h&amp;gt;&lt;/code&gt; is included, then &lt;code&gt;assert&lt;/code&gt; does nothing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb4be0b9f283d05e7e78bb3a582406ff9af784e1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;NDEBUG&lt;/code&gt; is not defined, then &lt;code&gt;assert&lt;/code&gt; checks if its argument (which must have scalar type) compares equal to zero. If it does, &lt;code&gt;assert&lt;/code&gt; outputs implementation-specific diagnostic information on the standard error output and calls &lt;code&gt;&lt;a href=&quot;../program/abort&quot;&gt;abort&lt;/a&gt;()&lt;/code&gt;. The diagnostic information is required to include the text of &lt;code&gt;expression&lt;/code&gt;, as well as the values of the &lt;a href=&quot;../preprocessor/replace&quot;&gt;standard macros&lt;/a&gt;&lt;code&gt;__FILE__&lt;/code&gt;, &lt;code&gt;__LINE__&lt;/code&gt;, and the &lt;a href=&quot;../language/function_definition&quot;&gt;predefined variable&lt;/a&gt;&lt;code&gt;__func__&lt;/code&gt;.(since C99).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3db10378a1cc105c0a22a4f2c0f99f5d34c39bd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arg&lt;/code&gt; is &amp;plusmn;&amp;infin;, &amp;plusmn;0 is returned, and &amp;plusmn;&amp;infin; is stored in &lt;code&gt;*iptr&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39035be25eaa7a5daa7ee9badf8db195c8f6f1c2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arg&lt;/code&gt; is &amp;plusmn;&amp;infin;, +&amp;infin; is returned</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc64028dd5e1343ad289a2a638ecad4eabe7dfc5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arg&lt;/code&gt; is &amp;plusmn;&amp;infin;, &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; is raised and an implementation-defined value is returned</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2c40c9472f7e29a79351555cd2feb2e0f4bf69b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arg&lt;/code&gt; is &amp;plusmn;&amp;infin;, it is returned, and an unspecified value is stored in &lt;code&gt;*&lt;a href=&quot;exp&quot;&gt;exp&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2926296a9d3ae122af29b30e2bff2458387535b0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arg&lt;/code&gt; is &amp;plusmn;&amp;infin;, it is returned, unmodified</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dcb585953813ddfd53495aac0adc0c6028656a9c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arg&lt;/code&gt; is &amp;plusmn;0, &amp;plusmn;&amp;infin;, or NaN, &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; is raised.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52141cb14b3833d9514aee0d11bc6396482017af" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arg&lt;/code&gt; is &amp;plusmn;0, &amp;plusmn;0 is returned, and &amp;plusmn;0 is stored in &lt;code&gt;*iptr&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97a7ce4796bb66aaa2d696b735ad8ca62a0d506b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arg&lt;/code&gt; is &amp;plusmn;0, -&amp;infin; is returned and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_DIVBYZERO&lt;/a&gt;&lt;/code&gt; is raised.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c925fdb14d37c5af0412f43389d6420fcbebc31" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arg&lt;/code&gt; is &amp;plusmn;0, it is returned, unmodified</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5dc17fdaf08e8797e56099a677398b82af4d0180" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arg&lt;/code&gt; is &amp;plusmn;0, it is returned, unmodified, and &lt;code&gt;0&lt;/code&gt; is stored in &lt;code&gt;*&lt;a href=&quot;exp&quot;&gt;exp&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f109ac78880a8e0fd5ca3edc07d2d1bf947af61" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arg&lt;/code&gt; is NaN, &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; is raised and an implementation-defined value is returned</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40f86add69087dfb700cacff3b1846927488c73a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arg&lt;/code&gt; is NaN, NaN is returned</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae52bceff3b02f7b3ee9b3972972ded1fb86990a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arg&lt;/code&gt; is NaN, NaN is returned, and NaN is stored in &lt;code&gt;*iptr&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1cb41b693b54309d8cd057ea727f5c2a44b70a0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arg&lt;/code&gt; is NaN, NaN is returned, and an unspecified value is stored in &lt;code&gt;*&lt;a href=&quot;exp&quot;&gt;exp&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b0e2c569c27377f09ed2aa7f3f01ddd8ab82ed0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arg&lt;/code&gt; is NaN, NaN is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b47b8c75e53c96b45595a288fa682cfb71c94c2d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arg&lt;/code&gt; is a NaN, &lt;code&gt;FP_ILOGBNAN&lt;/code&gt; is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85329a9a82100a9c1a2cd29c7eed89e508e44736" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arg&lt;/code&gt; is a natural number, &lt;code&gt;lgamma(arg)&lt;/code&gt; is the logarithm of the factorial of &lt;code&gt;arg-1&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fbec8bd424bd1d802c57ea8f26b821ec16976114" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arg&lt;/code&gt; is a natural number, &lt;code&gt;tgamma(arg)&lt;/code&gt; is the factorial of &lt;code&gt;arg-1&lt;/code&gt;. Many implementations calculate the exact integer-domain factorial if the argument is a sufficiently small integer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b16a546b06c9d95257ded195bd4035d23e04e06b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arg&lt;/code&gt; is infinite, &lt;code&gt;&lt;a href=&quot;../../types/limits&quot;&gt;INT_MAX&lt;/a&gt;&lt;/code&gt; is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e168df92098d4104c20f40ff2c56e9cb3e43970" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arg&lt;/code&gt; is not a floating-point number, the behavior is unspecified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32ff62b6889ca3482df7c46498edc6f6674221b7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arg&lt;/code&gt; is not zero, infinite, or NaN, the value returned is exactly equivalent to &lt;code&gt;(int)&lt;a href=&quot;logb&quot;&gt;logb&lt;/a&gt;(arg)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="210d2992bbf2bb7d542ddc01b1a18747c781302a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arg&lt;/code&gt; is zero or is an integer less than zero, a pole error may occur.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05dafa4d596b7b6f157f2afaee02072f8d977259" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arg&lt;/code&gt; is zero or is an integer less than zero, a pole error or a domain error may occur.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c39db051a1df2187c97bcf9b3a8feca13bc7aae3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arg&lt;/code&gt; is zero, &lt;code&gt;FP_ILOGB0&lt;/code&gt; is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4481c06a081e138b96375d6a39a2024c3db3720a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arg&lt;/code&gt; is zero, returns zero and stores zero in &lt;code&gt;*exp&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc2ce27f23e51347316eec1df499f96102e63b30" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;base&lt;/code&gt; is &lt;code&gt;TIME_UTC&lt;/code&gt;, then.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88b08a2ca4f793bfaeabfcb3e0137c1037ec815c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;base&lt;/code&gt; is finite and negative and &lt;code&gt;exponent&lt;/code&gt; is finite and non-integer, a domain error occurs and a range error may occur.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc0d6604e049ef0469b7407b8700ef87f4c2b1cf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;base&lt;/code&gt; is zero and &lt;code&gt;exponent&lt;/code&gt; is negative, a domain error or a pole error may occur.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe1f81b4cf62dfd261b43cdf1631e95df10c22e6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;base&lt;/code&gt; is zero and &lt;code&gt;exponent&lt;/code&gt; is zero, a domain error may occur.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="701f5d02367a24c659b0e907a89da5f3ee588ad7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;buffer&lt;/code&gt; is a null pointer, resizes the internal buffer to &lt;code&gt;size&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a41f3aeda56216d76a85bf549142c566dd8345e0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;buffer&lt;/code&gt; is not a null pointer, instructs the stream to use the user-provided buffer of size &lt;code&gt;size&lt;/code&gt; beginning at &lt;code&gt;buffer&lt;/code&gt;. The stream must be closed (with &lt;code&gt;&lt;a href=&quot;fclose&quot;&gt;fclose&lt;/a&gt;&lt;/code&gt;) before the &lt;a href=&quot;../language/lifetime&quot;&gt;lifetime&lt;/a&gt; of the array pointed to by &lt;code&gt;buffer&lt;/code&gt; ends. The contents of the array after a successful call to &lt;code&gt;setvbuf&lt;/code&gt; are indeterminate and any attempt to use it is undefined behavior.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8933681edb25a289169d034aa0994de4b7ca1688" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;buffer&lt;/code&gt; is not null, equivalent to &lt;code&gt;&lt;a href=&quot;setvbuf&quot;&gt;setvbuf&lt;/a&gt;(stream, buffer, &lt;a href=&quot;../io&quot;&gt;_IOFBF&lt;/a&gt;, &lt;a href=&quot;../io&quot;&gt;BUFSIZ&lt;/a&gt;)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3bace9448279b193681afb8262a65ef1da2317ef" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;buffer&lt;/code&gt; is null, equivalent to &lt;code&gt;&lt;a href=&quot;setvbuf&quot;&gt;setvbuf&lt;/a&gt;(stream, &lt;a href=&quot;../types/null&quot;&gt;NULL&lt;/a&gt;, &lt;a href=&quot;../io&quot;&gt;_IONBF&lt;/a&gt;, 0)&lt;/code&gt;, which turns off buffering.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4dd6d32ffac07b48320fad08007c3cbc378f1ccf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;c16&lt;/code&gt; is not the final code unit in a 16-bit representation of a wide character, it does not write to the array pointed to by &lt;code&gt;s&lt;/code&gt;, only &lt;code&gt;*ps&lt;/code&gt; is updated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5cd0616388c6486a36bee07efdbd316f0b1b2c96" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;c16&lt;/code&gt; is the null wide character &lt;code&gt;u'\0'&lt;/code&gt;, a null byte is stored, preceded by any shift sequence necessary to restore the initial shift state and the conversion state parameter &lt;code&gt;*ps&lt;/code&gt; is updated to represent the initial shift state.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cee38660c6cd74cd32407f813278c336fe952e78" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;c32&lt;/code&gt; is the null wide character &lt;code&gt;U'\0'&lt;/code&gt;, a null byte is stored, preceded by any shift sequence necessary to restore the initial shift state and the conversion state parameter &lt;code&gt;*ps&lt;/code&gt; is updated to represent the initial shift state.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b61b6f5b84317e677153362beb836a78c61619c2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ch&lt;/code&gt; does not equal &lt;code&gt;&lt;a href=&quot;../io&quot;&gt;EOF&lt;/a&gt;&lt;/code&gt;, pushes the character &lt;code&gt;ch&lt;/code&gt; (reinterpreted as &lt;code&gt;unsigned char&lt;/code&gt;) into the input buffer associated with the stream &lt;code&gt;stream&lt;/code&gt; in such a manner that subsequent read operation from &lt;code&gt;stream&lt;/code&gt; will retrieve that character. The external device associated with the stream is not modified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a57c34ec42bd9be0ad89adc1a923520e0077144a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ch&lt;/code&gt; does not equal &lt;code&gt;WEOF&lt;/code&gt;, pushes the wide character &lt;code&gt;ch&lt;/code&gt; into the input buffer associated with the stream &lt;code&gt;stream&lt;/code&gt; in such a manner that subsequent read operation from &lt;code&gt;stream&lt;/code&gt; will retrieve that wide character. The external device associated with the stream is not modified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c14f42bfaf455713c73850a9b738e4d8564279fc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ch&lt;/code&gt; equals &lt;code&gt;&lt;a href=&quot;../io&quot;&gt;EOF&lt;/a&gt;&lt;/code&gt;, the operation fails and the stream is not affected.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a114914a7e8a31a9eee7e4f7ac5bc1b503807f4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ch&lt;/code&gt; equals &lt;code&gt;WEOF&lt;/code&gt;, the operation fails and the stream is not affected.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b6ed2df20ac94130f4229b9b625f3c25374a619" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;comp&lt;/code&gt; indicates two elements as equivalent, their order in the resulting sorted array is unspecified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18daaf9d57908b8b11d5a5ce74779de8f547638e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;count&lt;/code&gt; is &lt;code&gt;​0​&lt;/code&gt;, then &lt;code&gt;dest&lt;/code&gt; is allowed to be a null pointer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c4f638ff595d6b56790ce243921af64efe6390b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;count&lt;/code&gt; is reached before the entire array &lt;code&gt;src&lt;/code&gt; was copied, the resulting character array is not null-terminated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3896321b9a85e601977b36e1c20e47272d800cfd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;count&lt;/code&gt; is reached before the entire string &lt;code&gt;src&lt;/code&gt; was copied, the resulting wide character array is not null-terminated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f2e6aaeeb8e09e4e7d2914ab4ee68da289d48f4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;count&lt;/code&gt; is zero, the function does nothing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ad8eda07b3297819cd8064cc3589079cc052fd8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;count&lt;/code&gt; is zero, the function returns a null pointer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a5b5a3d18a2f383eebd17f1e0c87ef7de0762b4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;destructor&lt;/code&gt; is not a null pointer, then also associates the destructor which is called when the storage is released by &lt;code&gt;&lt;a href=&quot;thrd_exit&quot;&gt;thrd_exit&lt;/a&gt;&lt;/code&gt; (but not by &lt;code&gt;&lt;a href=&quot;tss_delete&quot;&gt;tss_delete&lt;/a&gt;&lt;/code&gt; and not at program termination by &lt;code&gt;&lt;a href=&quot;../program/exit&quot;&gt;exit&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="007bad278d6b4bc6d719829636a93a4a9c5a31b7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;exit_code&lt;/code&gt; is &lt;code&gt;0&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;exit_status&quot;&gt;EXIT_SUCCESS&lt;/a&gt;&lt;/code&gt;, an implementation-defined status indicating successful termination is returned to the host environment. If &lt;code&gt;exit_code&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;exit_status&quot;&gt;EXIT_FAILURE&lt;/a&gt;&lt;/code&gt;, an implementation-defined status, indicating</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd356ac95b78ee8d3316f54756261230b7ae7603" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;exp&lt;/code&gt; is 0, then &lt;code&gt;arg&lt;/code&gt; is returned, unmodified</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa8dc7735d619a4734d97c476943c7b150c788b8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;goto&lt;/code&gt; leaves the scope of a VLA, it is deallocated (and may be reallocated if its initialization is executed again):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f139378ae3c47e672c41f256a64675e51a89c67" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ignore_handler_s&lt;/code&gt; is used as a the runtime constraints handler, the violations may be detected by examining the results of the bounds-checked function calls, which may be different for different functions (non-zero &lt;code&gt;errno_t&lt;/code&gt;, null character written to the first byte of the output string, etc).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8220b5231500449270383f2d363e2887e1748889" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;int&lt;/code&gt; can represent the entire range of values of the original type (or the range of values of the original bit field), the value is converted to type &lt;code&gt;int&lt;/code&gt;. Otherwise the value is converted to &lt;code&gt;unsigned int&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d1622661fe017f321ee25a4e9cf6aa32ff070ac" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;islower&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;, it is guaranteed that &lt;code&gt;&lt;a href=&quot;iscntrl&quot;&gt;iscntrl&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;isdigit&quot;&gt;isdigit&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;ispunct&quot;&gt;ispunct&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;isspace&quot;&gt;isspace&lt;/a&gt;&lt;/code&gt; return &lt;code&gt;false&lt;/code&gt; for the same character in the same C locale.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="228f41e20ec18c0190146297fd816d5d17c54d3b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;isupper&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;, it is guaranteed that &lt;code&gt;&lt;a href=&quot;iscntrl&quot;&gt;iscntrl&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;isdigit&quot;&gt;isdigit&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;ispunct&quot;&gt;ispunct&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;isspace&quot;&gt;isspace&lt;/a&gt;&lt;/code&gt; return &lt;code&gt;false&lt;/code&gt; for the same character in the same C locale.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d629e4399641b9530158823e61e45ef4cbd7a6cc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;mode &amp;gt; 0&lt;/code&gt;, attempts to make &lt;code&gt;stream&lt;/code&gt; wide-oriented. If &lt;code&gt;mode &amp;lt; 0&lt;/code&gt;, attempts to make &lt;code&gt;stream&lt;/code&gt; byte-oriented. If &lt;code&gt;mode==0&lt;/code&gt;, only queries the current orientation of the stream.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf95be7cd7ebf5692c3135c92a75c10543f6e749" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;new_filename&lt;/code&gt; exists, the behavior is implementation-defined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b3b81128b53cdb9103f95cb1f65dbf81829d30a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;new_size&lt;/code&gt; is zero, the behavior is implementation defined (null pointer may be returned (in which case the old memory block may or may not be freed), or some non-null pointer may be returned that may not be used to access storage).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2592ff70a55671e630f52a0701fe807ca7a4a63" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;parmN&lt;/code&gt; is declared with &lt;code&gt;register&lt;/code&gt; storage class specifier, with an array type, with a function type, or with a type not compatible with the type that results from default argument promotions, the behavior is undefined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44d20c46f9c198ea9c123c08f055544cf1af5b22" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ps&lt;/code&gt; is not a null pointer, the &lt;code&gt;mbsinit&lt;/code&gt; function determines whether the pointed-to &lt;code&gt;&lt;a href=&quot;mbstate_t&quot;&gt;mbstate_t&lt;/a&gt;&lt;/code&gt; object describes the initial conversion state.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e4c54f508180ce2bca52d72bedefa0048c957d2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ptr&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt;, the behavior is the same as calling &lt;code&gt;&lt;a href=&quot;malloc&quot;&gt;malloc&lt;/a&gt;&lt;/code&gt;(&lt;code&gt;new_size&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75ce63992e734876e2a939cc380b004ef361f5a4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ptr&lt;/code&gt; is a null pointer, the function does nothing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="775fd3976f21369f6410f6f3d50cc92d417bb684" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;rand()&lt;/code&gt; is used before any calls to &lt;code&gt;srand()&lt;/code&gt;, &lt;code&gt;rand()&lt;/code&gt; behaves as if it was seeded with &lt;code&gt;srand(1)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16def2206ddfe3e5010ae4e26c38ffb1e3b7ca4b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;res&lt;/code&gt; is not a null pointer, the result code of the thread is put to the location pointed to by &lt;code&gt;res&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1972341d22f77196bc1af118f58697bce937d0f6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; is a null pointer, resets its internal conversion state to represent the initial shift state and returns &lt;code&gt;​0​&lt;/code&gt; if the current multibyte encoding is not state-dependent (does not use shift sequences) or a non-zero value if the current multibyte encoding is state-dependent (uses shift sequences).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8491ba73b16514468214be4e5a74445c09461000" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; is a null pointer, resets the global conversion state and determined whether shift sequences are used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c39632bb99f5cb18b879a3b49462f93b75999d15" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; is a null pointer, resets the global conversion state and determines whether shift sequences are used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22997fcdc6a5389460254717d711c2bcf3fcf982" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; is a null pointer, the call is equivalent to &lt;code&gt;c16rtomb(buf, u'\0', ps)&lt;/code&gt; for some internal buffer &lt;code&gt;buf&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b392d0883d44d42834c77d825af0cdb02a8bba76" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; is a null pointer, the call is equivalent to &lt;code&gt;c32rtomb(buf, U'\0', ps)&lt;/code&gt; for some internal buffer &lt;code&gt;buf&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9936b790fa012acb444bd08bba8ed35bc9704d67" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; is a null pointer, the call is equivalent to &lt;code&gt;wcrtomb(buf, L'\0', ps)&lt;/code&gt; for some internal buffer &lt;code&gt;buf&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="581dbdb5a92a86f454eccb897e8676bace822faa" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; is a null pointer, the values of &lt;code&gt;n&lt;/code&gt; and &lt;code&gt;pc16&lt;/code&gt; are ignored and the call is equivalent to &lt;code&gt;mbrtoc16(&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;, &quot;&quot;, 1, ps)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3107e31c74f5584cf473c16caa6df8b08a9926d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; is a null pointer, the values of &lt;code&gt;n&lt;/code&gt; and &lt;code&gt;pc32&lt;/code&gt; are ignored and the call is equivalent to &lt;code&gt;mbrtoc32(&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;, &quot;&quot;, 1, ps)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eebec10c747613d7bb1cfc16cb61d08d39558b92" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; is a null pointer, the values of &lt;code&gt;n&lt;/code&gt; and &lt;code&gt;pwc&lt;/code&gt; are ignored and call is equivalent to &lt;code&gt;mbrtowc(&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;, &quot;&quot;, 1, ps)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c87ab8512786d6dbdf059aba7190daa196aa4acb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; is a null pointer, this function resets the global conversion state and determines whether shift sequences are used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="387220b12d5b9da678e75cc38f39c0d62fd87341" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; is not a null pointer and &lt;code&gt;c16&lt;/code&gt; is the last 16-bit code unit in a valid variable-length encoding of a code point, the function determines the number of bytes necessary to store the multibyte character representation of that code point (including any shift sequences, and taking into account the current multibyte conversion state &lt;code&gt;*ps&lt;/code&gt;), and stores the multibyte character representation in the character array whose first element is pointed to by &lt;code&gt;s&lt;/code&gt;, updating &lt;code&gt;*ps&lt;/code&gt; as necessary. At most &lt;code&gt;MB_CUR_MAX&lt;/code&gt; bytes can be written by this function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16a04e8a10e56b364fb1a793bc4d4d83c9dcfc50" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; is not a null pointer, inspects at most &lt;code&gt;n&lt;/code&gt; bytes of the multibyte character string, beginning with the byte pointed to by &lt;code&gt;s&lt;/code&gt; to determine the number of bytes necessary to complete the next multibyte character (including any shift sequences, and taking into account the current multibyte conversion state &lt;code&gt;*ps&lt;/code&gt;). If the function determines that the next multibyte character in &lt;code&gt;s&lt;/code&gt; is complete and valid, converts it to the corresponding 16-bit wide character and stores it in &lt;code&gt;*pc16&lt;/code&gt; (if &lt;code&gt;pc16&lt;/code&gt; is not null).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0aea06044e65d8d79268c25c358b2052ee0b773" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; is not a null pointer, inspects at most &lt;code&gt;n&lt;/code&gt; bytes of the multibyte character string, beginning with the byte pointed to by &lt;code&gt;s&lt;/code&gt; to determine the number of bytes necessary to complete the next multibyte character (including any shift sequences, and taking into account the current multibyte conversion state &lt;code&gt;*ps&lt;/code&gt;). If the function determines that the next multibyte character in &lt;code&gt;s&lt;/code&gt; is complete and valid, converts it to the corresponding 32-bit wide character and stores it in &lt;code&gt;*pc32&lt;/code&gt; (if &lt;code&gt;pc32&lt;/code&gt; is not null).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00b1537658058f473db5bc680537ac6616352ddf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; is not a null pointer, inspects at most &lt;code&gt;n&lt;/code&gt; bytes of the multibyte character string, beginning with the byte pointed to by &lt;code&gt;s&lt;/code&gt; to determine the number of bytes necessary to complete the next multibyte character (including any shift sequences, and taking into account the current multibyte conversion state &lt;code&gt;*ps&lt;/code&gt;). If the function determines that the next multibyte character in &lt;code&gt;s&lt;/code&gt; is complete and valid, converts it to the corresponding wide character and stores it in &lt;code&gt;*pwc&lt;/code&gt; (if &lt;code&gt;pwc&lt;/code&gt; is not null).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f4c68687ec93f7e26b9a23cfefd0d3cb05dc64c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; is not a null pointer, returns the number of bytes that are contained in the multibyte character or &lt;code&gt;-1&lt;/code&gt; if the first bytes pointed to by &lt;code&gt;s&lt;/code&gt; do not form a valid multibyte character or &lt;code&gt;​0​&lt;/code&gt; if &lt;code&gt;s&lt;/code&gt; is pointing at the null charcter &lt;code&gt;'\0'&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d6df3a6410ecce9d2acc8ffd84bf56f540ac991" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; is not a null pointer, the function determines the number of bytes necessary to store the multibyte character representation of &lt;code&gt;c32&lt;/code&gt; (including any shift sequences, and taking into account the current multibyte conversion state &lt;code&gt;*ps&lt;/code&gt;), and stores the multibyte character representation in the character array whose first element is pointed to by &lt;code&gt;s&lt;/code&gt;, updating &lt;code&gt;*ps&lt;/code&gt; as necessary. At most &lt;code&gt;MB_CUR_MAX&lt;/code&gt; bytes can be written by this function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2906f9cd10055ce52ea5a2e8f571a7dfc437ffba" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;set_constraint_handler_s&lt;/code&gt; is never called, the default handler is implementation-defined: it may be &lt;code&gt;abort_handler_s&lt;/code&gt;, &lt;code&gt;ignore_handler_s&lt;/code&gt;, or some other implementation-defined handler.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97df7a8676e7983f9c071569882f22876fa4078d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;set_constraint_handler_s&lt;/code&gt; is never called, the default handler is implementation-defined: it may be &lt;code&gt;abort_handler_s&lt;/code&gt;, &lt;code&gt;ignore_handler_s&lt;/code&gt;, or some other implementation-defined handler.  As with all bounds-checked functions, &lt;code&gt;set_constraint_handler_s&lt;/code&gt; and &lt;code&gt;constraint_handler_t&lt;/code&gt; are only guaranteed to be available if &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; is defined by the implementation and if the user defines &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; to the integer constant &lt;code&gt;1&lt;/code&gt; before including &lt;code&gt;&amp;lt;stdlib.h&amp;gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7823afdead8eb41af529747e83ce1e0afbe2e6fb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;setjmp&lt;/code&gt; appears in any other context, the behavior is undefined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a6ee964cf02ec47b4f466324fac4fa5368b4c54" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;size&lt;/code&gt; is zero, the behavior is implementation defined (null pointer may be returned, or some non-null pointer may be returned that may not be used to access storage).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1fe40c255f79e2b4f905649c83c54e72b4fe88db" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;size&lt;/code&gt; is zero, the behavior is implementation defined (null pointer may be returned, or some non-null pointer may be returned that may not be used to access storage, but has to be passed to &lt;code&gt;&lt;a href=&quot;free&quot;&gt;free&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fece348a8ee3d70f7e3352f3e69bf03a082365cd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;size&lt;/code&gt; or &lt;code&gt;count&lt;/code&gt; is zero, &lt;code&gt;fread&lt;/code&gt; returns zero and performs no other action.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a444353fd5b9d3848488fa96c9629f1e576c66a5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;size&lt;/code&gt; or &lt;code&gt;count&lt;/code&gt; is zero, &lt;code&gt;fwrite&lt;/code&gt; returns zero and performs no other action.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9e1e400de47a1ed0b5cd2d6e227768319577ed9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;src&lt;/code&gt; and &lt;code&gt;dst&lt;/code&gt; overlap, the behavior is undefined</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d273f0263e60be8e604763a8afeb86df4bc79e3d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;src&lt;/code&gt; and &lt;code&gt;dst&lt;/code&gt; overlap, the behavior is unspecified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="919d8cd3a8b53f2e18bf07280d97eede84dc299d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;str != &lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt;, the call is treated as the first call to &lt;code&gt;strtok&lt;/code&gt; for this particular string. The function searches for the first character which is</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="452491e0b2ce1dbe11298bd37bb75407d3d3ddf8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;str != &lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt;, the call is treated as the first call to &lt;code&gt;wcstok&lt;/code&gt; for this particular wide string. The function searches for the first wide character which is</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95b4b4bb5cc3b17be9977eef6a95107d1dfe2f33" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;str == &lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt;, the call is treated as a subsequent call to &lt;code&gt;wcstok&lt;/code&gt;: the function continues from where it left in the previous invocation with the same &lt;code&gt;*ptr&lt;/code&gt;. The behavior is the same as if the pointer to the wide character that follows the last detected token is passed as &lt;code&gt;str&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66ec70311bf6aedd6bdb60bbe9f819c870804830" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;str == &lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt;, the call is treated as a subsequent calls to &lt;code&gt;strtok&lt;/code&gt;: the function continues from where it left in previous invocation. The behavior is the same as if the previously stored pointer is passed as &lt;code&gt;str&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4dee41190e5faa1ca923bd889668d6289ee307f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;stream&lt;/code&gt; is a null pointer, all open output streams are flushed, including the ones manipulated within library packages or otherwise not directly accessible to the program.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eaa4ac73f07ef7f30a93d67313ff9cb94c76ac34" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;tss_delete&lt;/code&gt; is called while another thread is executing destructors for &lt;code&gt;tss_id&lt;/code&gt;, it's unspecified whether this changes the number of invocations to the associated destructor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="399122524172ec8fa3e995c00fbab797727aa863" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;tss_delete&lt;/code&gt; is called while the calling thread is executing destructors, then the destructor associated with &lt;code&gt;tss_id&lt;/code&gt; will not be executed again on this thread.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c8bc9e007e9eab3e896a3aaff472ee164636be8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ungetc&lt;/code&gt; is called more than once without an intervening read or repositioning, it may fail (in other words, a pushback buffer of size 1 is guaranteed, but any larger buffer is implementation-defined). If multiple successful &lt;code&gt;ungetc&lt;/code&gt; were performed, read operations retrieve the pushed-back characters in reverse order of &lt;code&gt;ungetc&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b93c880a13d41dd5f02146648e0bcdb941ad4432" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ungetwc&lt;/code&gt; is called more than once without an intervening read or repositioning, it may fail (in other words, a pushback buffer of size 1 is guaranteed, but any larger buffer is implementation-defined). If multiple successful &lt;code&gt;ungetwc&lt;/code&gt; were performed, read operations retrieve the pushed-back wide characters in reverse order of &lt;code&gt;ungetwc&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75a090849c6c030efd853b2c4e1bec200144bf8e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;va_arg&lt;/code&gt; is called when there are no more arguments in &lt;code&gt;ap&lt;/code&gt;, the behavior is undefined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a2e019de572732991114a4b9ac83594fefd4e00" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;wc&lt;/code&gt; is the null character, the null byte is written to &lt;code&gt;s&lt;/code&gt;, preceded by any shift sequences necessary to restore the initial shift state.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9292e4a3413eb133a7f76bc6e4fe74a238c5b8bf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are both zero, domain error</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a5e321969b66fbefa9cdd24eacf386b98fffc2b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are both zero, range error does not occur either</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a0e37c7feac7db699e4130a50b199ceedd910f7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is &amp;plusmn;&amp;infin; and &lt;code&gt;y&lt;/code&gt; is not NaN, NaN is returned and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; is raised</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d517d0ca1b88b420f9a711836c289f554f6f27a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is &amp;plusmn;0 and &lt;code&gt;y&lt;/code&gt; is not zero, &amp;plusmn;0 is returned</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f41dcbd3d46c8769c4b2fb80c374a0e5c0d62c23" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is &lt;code&gt;&amp;plusmn;0&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; is negative, &lt;code&gt;-&amp;pi;/2&lt;/code&gt; is returned</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6968a9e1c046845040fc68d63a376b5e6b8b85a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is &lt;code&gt;&amp;plusmn;0&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; is positive, &lt;code&gt;+&amp;pi;/2&lt;/code&gt; is returned</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="742021246f19681537f6e140bb629b64b21e4348" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is &lt;code&gt;+&amp;infin;&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; is finite and negative, &lt;code&gt;-0&lt;/code&gt; is returned</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="854f55847c1c8f45111c844b75fe0c4c049cc744" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is &lt;code&gt;+&amp;infin;&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; is finite and positive, &lt;code&gt;+0&lt;/code&gt; is returned</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70312266975b00e8f11c41c1477d3626e83ccaa9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is &lt;code&gt;-&amp;infin;&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; is finite and negative, &lt;code&gt;-&amp;pi;&lt;/code&gt; is returned</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="adfdc77216731e53faa0611a28dda473ddae36f7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is &lt;code&gt;-&amp;infin;&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; is finite and positive, &lt;code&gt;+&amp;pi;&lt;/code&gt; is returned</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86712aaf103771c2d7819baa87af27b031d94ae1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is NaN, then NaN with the sign of &lt;code&gt;y&lt;/code&gt; is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e48634bd82e2df6f62aec245642cb59777238384" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;y&lt;/code&gt; is &amp;plusmn;&amp;infin; and &lt;code&gt;x&lt;/code&gt; is finite, &lt;code&gt;x&lt;/code&gt; is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2ddc1042c63e353212b7799d89a1b092aed734a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;y&lt;/code&gt; is &amp;plusmn;0 and &lt;code&gt;x&lt;/code&gt; is not NaN, NaN is returned and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; is raised</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c4d4232381ec31f82701b3b12b902639c119342" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;y&lt;/code&gt; is -0, the result is only negative if the implementation supports the signed zero consistently in arithmetic operations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb77d357b03480982a5cb3af7fe4d1a54b4629b1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;y&lt;/code&gt; is &lt;code&gt;&amp;plusmn;&amp;infin;&lt;/code&gt; and &lt;code&gt;x&lt;/code&gt; is &lt;code&gt;+&amp;infin;&lt;/code&gt;, &lt;code&gt;&amp;plusmn;&amp;pi;/4&lt;/code&gt; is returned</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c32d4c116dec5e5a3f5f016622351bfcdbb1d9a6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;y&lt;/code&gt; is &lt;code&gt;&amp;plusmn;&amp;infin;&lt;/code&gt; and &lt;code&gt;x&lt;/code&gt; is &lt;code&gt;-&amp;infin;&lt;/code&gt;, &lt;code&gt;&amp;plusmn;3&amp;pi;/4&lt;/code&gt; is returned</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2d2be60f0f9dee6ef4e60532e876177666a7509" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;y&lt;/code&gt; is &lt;code&gt;&amp;plusmn;&amp;infin;&lt;/code&gt; and &lt;code&gt;x&lt;/code&gt; is finite, &lt;code&gt;&amp;plusmn;&amp;pi;/2&lt;/code&gt; is returned</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04ca9c751f9bab309085f696c5ce7e061eb53bf7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;y&lt;/code&gt; is &lt;code&gt;&amp;plusmn;0&lt;/code&gt; and &lt;code&gt;x&lt;/code&gt; is negative or &lt;code&gt;-0&lt;/code&gt;, &lt;code&gt;&amp;plusmn;&amp;pi;&lt;/code&gt; is returned</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c2e024aa12ac316eec5865ba0f65ada4018df50" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;y&lt;/code&gt; is &lt;code&gt;&amp;plusmn;0&lt;/code&gt; and &lt;code&gt;x&lt;/code&gt; is positive or &lt;code&gt;+0&lt;/code&gt;, &lt;code&gt;&amp;plusmn;0&lt;/code&gt; is returned</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db8ff25a6b35fd58c6e2ad1d8257aa1fdbbc1afa" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;y&lt;/code&gt; is zero, but the domain error does not occur, zero is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="934c80b3e977f6c9efabb47ff6836e6a1d4145a6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;y&lt;/code&gt; is zero, pole error does not occur</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5af0b5b04311e67b5c965ddebdd4dcbe743ea19" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;y&lt;/code&gt; is zero, the value stored in &lt;code&gt;*quo&lt;/code&gt; is unspecified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="625acef687f1e557bbb80eaf5f5e753fb2ddb33d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;&amp;plusmn;&amp;infin;+NaNi&lt;/code&gt;, the result is &lt;code&gt;+&amp;infin;+NaNi&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e776bd162170c11d73af44ef8772342340ecd190" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;&amp;plusmn;&amp;infin;+NaNi&lt;/code&gt;, the result is &lt;code&gt;NaN&amp;plusmn;&amp;infin;i&lt;/code&gt; (the sign of the imaginary part is unspecified)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d3e426e20516e7376a050aee0403fe0d2b10ec1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;&amp;plusmn;0+0i&lt;/code&gt;, the result is &lt;code&gt;&amp;pi;/2-0i&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f825bdeaf14c7f605beb396872b9bf8796ebfd9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;&amp;plusmn;0+0i&lt;/code&gt;, the result is &lt;code&gt;+0+0i&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6b60f1baa934eced059da43d7d291e2febe8bd6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;&amp;plusmn;0+0i&lt;/code&gt;, the result is &lt;code&gt;+0+i&amp;pi;/2&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59a945b0d7d5f0cbeadecb2c1a035dcb5ca27324" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;&amp;plusmn;0+0i&lt;/code&gt;, the result is &lt;code&gt;1+0i&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="999d915d02ed97295faafb81922e3c2b06d67050" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;&amp;plusmn;0+NaNi&lt;/code&gt;, the result is &lt;code&gt;&amp;pi;/2+NaNi&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c56b753fbf612891e276ecb3035b809c59bf33a4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;+&amp;infin;+&amp;infin;i&lt;/code&gt;, the result is &lt;code&gt;&amp;pi;/4-&amp;infin;i&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="deb39fe3ef692828d5403bc4bf6425bc5dff8537" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;+&amp;infin;+&amp;infin;i&lt;/code&gt;, the result is &lt;code&gt;&amp;plusmn;&amp;infin;+NaNi&lt;/code&gt; (the sign of the real part is unspecified) and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; is raised</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1cd5723428b77280491731f17b9a43dcf568e7ab" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;+&amp;infin;+&amp;infin;i&lt;/code&gt;, the result is &lt;code&gt;&amp;plusmn;&amp;infin;+NaNi&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; is raised (the sign of the real part is unspecified)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af6cc33ffa514f0fb416ba084c782fa9d65fe603" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;+&amp;infin;+&amp;infin;i&lt;/code&gt;, the result is &lt;code&gt;+&amp;infin;+&amp;pi;i/4&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fdd17d4f5bc34ca9a9f286bf72b81e05e7ec8b82" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;+&amp;infin;+&amp;infin;i&lt;/code&gt;, the result is &lt;code&gt;+&amp;infin;+i&amp;pi;/4&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58b7336602437e7b3e1e2fd464b50015fba38ed0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;+&amp;infin;+&amp;infin;i&lt;/code&gt;, the result is &lt;code&gt;+0+i&amp;pi;/2&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9fb5e54ed45d0a2da9d34fcf5eebc061ed69ef3e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;+&amp;infin;+&amp;infin;i&lt;/code&gt;, the result is &lt;code&gt;1&amp;plusmn;0i&lt;/code&gt; (the sign of the imaginary part is unspecified)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bbc9947aa4794f3a678fa9974f0b8face529b478" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;+&amp;infin;+0i&lt;/code&gt;, the result is &lt;code&gt;+&amp;infin;+0i&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57d2b3b7c507184bec2b467227a5ef3e66fb09dc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;+&amp;infin;+NaN&lt;/code&gt;, the result is &lt;code&gt;+&amp;infin;+NaN&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="074653f1bcfd78e2c6b8261d6288ce30b3f409ac" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;+&amp;infin;+NaNi&lt;/code&gt;, the result is &lt;code&gt;&amp;plusmn;&amp;infin;+NaNi&lt;/code&gt; (the sign of the real part is unspecified)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36a15e9914952a3e127c1857dfb1656f43e91982" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;+&amp;infin;+NaNi&lt;/code&gt;, the result is &lt;code&gt;+&amp;infin;+NaNi&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b8208a3b53853e24adab139e12b16bb55e09c49" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;+&amp;infin;+NaNi&lt;/code&gt;, the result is &lt;code&gt;+0+NaNi&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7d8ce12350273a97cbf0883260795a1b23dea52" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;+&amp;infin;+NaNi&lt;/code&gt;, the result is &lt;code&gt;1&amp;plusmn;0i&lt;/code&gt; (the sign of the imaginary part is unspecified)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4e8cef24833eac8da6eb2c3e75a7fe324ade08a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;+&amp;infin;+yi&lt;/code&gt; (for any finite non-zero y), the result is &lt;code&gt;+&amp;infin;cis(y)&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9bdf7c1f65251420ffa8f16429794ca31be5b14e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;+&amp;infin;+yi&lt;/code&gt; (for any finite nonzero y), the result is &lt;code&gt;+&amp;infin;cis(y)&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7910e66fb37842a583e14d09b105ade30be68803" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;+&amp;infin;+yi&lt;/code&gt; (for any finite positive y), the result is &lt;code&gt;+&amp;infin;+0i&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6768e1ec6df6a95e6a4c726fc892acad121e7985" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;+&amp;infin;+yi&lt;/code&gt; (for any finite positive y), the result is &lt;code&gt;+0+i&amp;pi;/2&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f62e4cdc201996da16b1502058a6c1e9023d551" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;+&amp;infin;+yi&lt;/code&gt; (for any finite positive y), the result is &lt;code&gt;1+0i&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0ce2d0c3f9d0861e47b4abf10a45e3583833a5e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;+&amp;infin;+yi&lt;/code&gt; (for any positive finite y), the result is &lt;code&gt;+&amp;infin;+0i&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="832b62b259002df797cd0148545bc70005eba32b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;+&amp;infin;+yi&lt;/code&gt; (for any positive finite y), the result is &lt;code&gt;+&amp;infin;cis(y)&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20a620da3de056d824da46c1301b06a1653505bc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;+&amp;infin;+yi&lt;/code&gt;, the result is &lt;code&gt;+&amp;infin;+0i)&lt;/code&gt; for finite positive y</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="796b4ff0d96367997b18b6f7414bc04e2ed54548" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;+0+&amp;infin;i&lt;/code&gt;, the result is &lt;code&gt;&amp;plusmn;0+NaNi&lt;/code&gt; (the sign of the real part is unspecified) and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; is raised</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5309daa1a2a52ddd69bab7388c31c22811693301" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;+0+&amp;infin;i&lt;/code&gt;, the result is &lt;code&gt;NaN&amp;plusmn;0i&lt;/code&gt; (the sign of the imaginary part is unspecified) and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; is raised</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5377d46789b608eb83cab1fd971c8e1fdc08ef07" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;+0+0i&lt;/code&gt;, the result is &lt;code&gt;+0+0i&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9921811f368934b33ab588a74bfc469573b9542" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;+0+0i&lt;/code&gt;, the result is &lt;code&gt;-&amp;infin;+0i&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_DIVBYZERO&lt;/a&gt;&lt;/code&gt; is raised</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30d6b4e4a6916b3f5bf139a7a8056a1e67f1365b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;+0+0i&lt;/code&gt;, the result is &lt;code&gt;1+0i&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a93099e5fafc600b431649dde73f501ee2c62f0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;+0+NaNi&lt;/code&gt;, the result is &lt;code&gt;&amp;plusmn;0+NaNi&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="babb8188b54877f4defa5fdcad7f2801cb860adf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;+0+NaNi&lt;/code&gt;, the result is &lt;code&gt;+0+NaNi&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05f532d9487bdac748e6ace19ea8e53c7305f1fb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;+0+NaNi&lt;/code&gt;, the result is &lt;code&gt;NaN&amp;plusmn;0i&lt;/code&gt; (the sign of the imaginary part is unspecified)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf4db554760a0604e00615063e66764d7bf313aa" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;+1+0i&lt;/code&gt;, the result is &lt;code&gt;+&amp;infin;+0i&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_DIVBYZERO&lt;/a&gt;&lt;/code&gt; is raised</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38d56aaf8eaff18904a766fcf455f56b6ddac179" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;+x+&amp;infin;i&lt;/code&gt; (for any finite x), the result is &lt;code&gt;+&amp;infin;+i&amp;pi;/2&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89bbfd524374559a9938d77e51791857f87d786c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;+x+NaNi&lt;/code&gt; (for non-zero finite x), the result is &lt;code&gt;NaN+NaNi&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; may be raised.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1aede927aad834a1785eca9ec8164efbce2fd01" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;-&amp;infin;+&amp;infin;i&lt;/code&gt;, the result is &lt;code&gt;&amp;plusmn;0&amp;plusmn;0i&lt;/code&gt; (signs are unspecified)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11925823f1f8e4ae67f97e30d8d10beacc784a6a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;-&amp;infin;+&amp;infin;i&lt;/code&gt;, the result is &lt;code&gt;+&amp;infin;+3&amp;pi;i/4&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5629437abcfb214e3e73d687e87c0bbfd484294d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;-&amp;infin;+&amp;infin;i&lt;/code&gt;, the result is &lt;code&gt;+&amp;infin;+3i&amp;pi;/4&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b23078b80b2d0a20adc1047ee85085ec345a4c08" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;-&amp;infin;+&amp;infin;i&lt;/code&gt;, the result is &lt;code&gt;3&amp;pi;/4-&amp;infin;i&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0916960961bb0b2dad526b5d8175c9cde4d8b004" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;-&amp;infin;+NaNi&lt;/code&gt;, the result is &lt;code&gt;&amp;plusmn;0&amp;plusmn;0i&lt;/code&gt; (signs are unspecified)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d23cff457c96232415905ac78b0b18a88e49ee49" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;-&amp;infin;+NaNi&lt;/code&gt;, the result is &lt;code&gt;NaN&amp;plusmn;&amp;infin;i&lt;/code&gt; (sign of imaginary part unspecified)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="588e8fab7757a98088b599ad32219a88f43e15b9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;-&amp;infin;+yi&lt;/code&gt; (for any finite positive y), the result is &lt;code&gt;+&amp;infin;+&amp;pi;i&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed0586d452079c8db876de069dd932b883bdbc41" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;-&amp;infin;+yi&lt;/code&gt; (for any finite y), the result is &lt;code&gt;+0cis(y)&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97bb419bd6dda05c2487d6ebabe98e61e56454e2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;-&amp;infin;+yi&lt;/code&gt; (for any positive finite y), the result is &lt;code&gt;&amp;pi;-&amp;infin;i&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73be861cb7403dc831de7a0eb3583bbe00513c7d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;-&amp;infin;+yi&lt;/code&gt; (for any positive finite y), the result is &lt;code&gt;+&amp;infin;+i&amp;pi;&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e9a39eb36afdfaf9c77e1b226686fcfff50f0ef" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;-&amp;infin;+yi&lt;/code&gt; (for any positive finite y), the result is &lt;code&gt;+0-&amp;infin;i&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="851d57b9d8335c6dfc8e20c92f1e808393d81024" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;-&amp;infin;+yi&lt;/code&gt;, the result is &lt;code&gt;+0+&amp;infin;i&lt;/code&gt; for finite positive y</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0896ff44ed61681eeb9cda5e2db468c4dcb7345" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;-0+0i&lt;/code&gt;, the result is &lt;code&gt;-&amp;infin;+&amp;pi;i&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_DIVBYZERO&lt;/a&gt;&lt;/code&gt; is raised</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da9605b8e9e71096e7d152ca980d6f5c93bba805" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;0+NaNi&lt;/code&gt;, the result is &lt;code&gt;NaN&amp;plusmn;i&amp;pi;/2&lt;/code&gt;, where the sign of the imaginary part is unspecified</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98b8e6ca75c33aacc22f25140d2d52982edd58fb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;NaN+&amp;infin;i&lt;/code&gt;, the result is &lt;code&gt;&amp;plusmn;&amp;infin;+NaNi&lt;/code&gt; (the sign of the real part is unspecified)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04e920d0768c071b159f8cf0ccb4766fc1f81e20" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;NaN+&amp;infin;i&lt;/code&gt;, the result is &lt;code&gt;&amp;plusmn;0+i&amp;pi;/2&lt;/code&gt; (the sign of the real part is unspecified)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="638dd3af4879e274f2753dd13affb32f54d0c427" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;NaN+&amp;infin;i&lt;/code&gt;, the result is &lt;code&gt;+&amp;infin;+NaNi&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="daba330e5a0bc591c3819affe8ac2668be2332bb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;NaN+&amp;infin;i&lt;/code&gt;, the result is &lt;code&gt;NaN-&amp;infin;i&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93fd1cf9bded1c643f4be838021974ff52d04574" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;NaN+0i&lt;/code&gt;, the result is &lt;code&gt;NaN&amp;plusmn;0i&lt;/code&gt; (the sign of the imaginary part is unspecified)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be162870b1adbbfcdab4d44246254add068c4d3d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;NaN+0i&lt;/code&gt;, the result is &lt;code&gt;NaN+0i&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed140ac051f22ec49ba422cfe0adb820c792ce97" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;NaN+NaNi&lt;/code&gt;, the result is &lt;code&gt;NaN+NaNi&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0832a5cb369dc40bbf17d380253648fec2eafd26" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;NaN+yi&lt;/code&gt; (for any finite non-zero y), the result is &lt;code&gt;NaN+NaNi&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; may be raised</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="237a9a25ce4abe535bbf2f26c139e1578e0f57db" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;NaN+yi&lt;/code&gt; (for any finite nonzero y), the result is &lt;code&gt;NaN+NaNi&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; may be raised</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9bd4c1293771f3563ff364c43498200c3c13cb97" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;NaN+yi&lt;/code&gt; (for any finite y), the result is &lt;code&gt;NaN+NaNi&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; may be raised</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="543c12f39bc3f311b75307271197b544025035ec" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;NaN+yi&lt;/code&gt; (for any finite y), the result is &lt;code&gt;NaN+NaNi&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; may be raised.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d493aac97dda0447051a4e0d2c6f5ec9e2060421" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;NaN+yi&lt;/code&gt; (for any non-zero y), the result is &lt;code&gt;NaN+NaNi&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; may be raised</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc20f772fb2e9b1f8a5f485718315fa6f70c07b7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;NaN+yi&lt;/code&gt; (for any nonzero y), the result is &lt;code&gt;NaN+NaNi&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; may be raised</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d3bec2c00936b0677791908a2e4bac6c5da3a16" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;NaN+yi&lt;/code&gt;, the result is &lt;code&gt;NaN+NaNi&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; may be raised</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a37c90aa215aa60d649f207f9c5229f362419dc3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;x+&amp;infin;i&lt;/code&gt; (for any finite non-zero x), the result is &lt;code&gt;NaN+NaNi&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; is raised</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1bb3d1a016313313a6b48c627b3a72353646af38" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;x+&amp;infin;i&lt;/code&gt; (for any finite positive x), the result is &lt;code&gt;+0+i&amp;pi;/2&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b73c524a1f7cdc97af1ed115b7f7b4545582b048" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;x+&amp;infin;i&lt;/code&gt; (for any finite x), the result is &lt;code&gt;&amp;pi;/2-&amp;infin;i&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="387a32ebb5732e31a734be8cc4d5825b907d56f4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;x+&amp;infin;i&lt;/code&gt; (for any finite x), the result is &lt;code&gt;+&amp;infin;+&amp;pi;i/2&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e21f01f7c3c4ba8563c2060a845c0a391233d504" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;x+&amp;infin;i&lt;/code&gt; (for any finite x), the result is &lt;code&gt;NaN+NaNi&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; is raised.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="656ce31f57bb568a13e9ac94e493eeccd6c0fa10" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;x+&amp;infin;i&lt;/code&gt; (for any positive finite x), the result is &lt;code&gt;+&amp;infin;+&amp;pi;/2&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b18b6f6cea921f44fce092288d49e81492a7d80" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;x+&amp;infin;i&lt;/code&gt; (for any positive finite x), the result is &lt;code&gt;NaN+NaNi&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; is raised</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="460b063ec1b13ac13ca6654ed1024e7cd0950fc4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;x+&amp;infin;i&lt;/code&gt; (for any&lt;sup id=&quot;cite_ref-1&quot;&gt;&lt;a href=&quot;ctanh#cite_note-1&quot;&gt;[1]&lt;/a&gt;&lt;/sup&gt; finite x), the result is &lt;code&gt;NaN+NaNi&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; is raised</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63489bf316b1d8539e0fca94a25ca124b0a8a98c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;x+&amp;infin;i&lt;/code&gt;, the result is &lt;code&gt;+&amp;infin;+&amp;infin;i&lt;/code&gt; even if x is NaN</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f69761b498632a762c370417fd0122db567041cb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;x+NaN&lt;/code&gt; (for any&lt;sup id=&quot;cite_ref-2&quot;&gt;&lt;a href=&quot;ctanh#cite_note-2&quot;&gt;[2]&lt;/a&gt;&lt;/sup&gt; finite x), the result is &lt;code&gt;NaN+NaNi&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; may be raised</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54c6ea5aaa627daf3c1ae805242b58ce8d207848" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;x+NaNi&lt;/code&gt; (for any finite non-zero x), the result is &lt;code&gt;NaN+NaNi&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; may be raised</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b93caab68fa73ccda5d1b17498c4229840dbee54" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;x+NaNi&lt;/code&gt; (for any finite nonzero x), the result is &lt;code&gt;NaN+NaNi&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; may be raised</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f565c2557a5ee30de01f8e30a13b63363ded1dd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;x+NaNi&lt;/code&gt; (for any finite x), the result is &lt;code&gt;NaN+NaNi&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; may be raised</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5dfecd44688d670800ff223095156659b894fc93" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;x+NaNi&lt;/code&gt; (for any finite x), the result is &lt;code&gt;NaN+NaNi&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; may be raised.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73d6ef277884ef031696f2e39fb8437e61e455ae" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;x+NaNi&lt;/code&gt; (for any nonzero finite x), the result is &lt;code&gt;NaN+NaNi&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; may be raised.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06474f38558e726376291b2fee6434dae49fb720" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;x+NaNi&lt;/code&gt; (for any positive finite x), the result is &lt;code&gt;NaN+NaNi&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; may be raised</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5b921b4a4b89a2b78c2d734ce1603b4cd5809c6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;x+NaNi&lt;/code&gt;, the result is &lt;code&gt;NaN+NaNi&lt;/code&gt; (unless x is &amp;plusmn;&amp;infin;) and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; may be raised</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="494c7fa954556372ffde67c8fcd8b5c440f15d85" translate="yes" xml:space="preserve">
          <source>If A is not sequenced before B and B is not sequenced before A, then two possibilities exist:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e909e2416c8dd4d8004abde79eee57ee706ae1a0" translate="yes" xml:space="preserve">
          <source>If A is not sequenced before B and B is sequenced before A, then evaluation of B will be complete before evaluation of A begins.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b3dcdb9c0e0e848fd114ab741ff0ec9dafbada5" translate="yes" xml:space="preserve">
          <source>If a &lt;a href=&quot;declarations&quot;&gt;declaration&lt;/a&gt; uses &lt;code&gt;typedef&lt;/code&gt; as storage-class specifier, every declarator in it defines an identifier as an alias to the type specified. Since only one storage-class specifier is permitted in a declaration, typedef declaration cannot be &lt;a href=&quot;storage_duration&quot;&gt;static or extern&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28f44931b69cf3f9c6318eccefe0feba2cd026ec" translate="yes" xml:space="preserve">
          <source>If a &lt;a href=&quot;https://en.wikipedia.org/wiki/Sequence_point&quot;&gt;&lt;i&gt;sequence point&lt;/i&gt;&lt;/a&gt; is present between the subexpressions E1 and E2, then both value computation and side effects of E1 are</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54d68e95d2eaee0fc5d16e87451670896b8f13a1" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;va_list&lt;/code&gt; instance is created, passed to another function, and used via &lt;code&gt;va_arg&lt;/code&gt; in that function, then any subsequent use in the calling function should be preceded by a call to &lt;code&gt;va_end&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41728f960e83107e165631fae30f77c98f34499a" translate="yes" xml:space="preserve">
          <source>If a VLA or another identifier with variably-modified type has a &lt;code&gt;case:&lt;/code&gt; or a &lt;code&gt;default:&lt;/code&gt; label within its scope, the entire switch statement must be in its scope (in other words, a VLA must be declared either before the entire switch or after the last label):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a62eb301fbc04938195faede31c45cafa349ad46" translate="yes" xml:space="preserve">
          <source>If a conversion specification is invalid, the behavior is undefined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5790fe10d0a55b84da0323b97076fc148d33b344" translate="yes" xml:space="preserve">
          <source>If a data race occurs, the behavior of the program is undefined.  (in particular, &lt;code&gt;&lt;a href=&quot;../thread/mtx_unlock&quot;&gt;mtx_unlock&lt;/a&gt;&lt;/code&gt; is.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b53fae349713df5efc757fb7b33531c67e72c29" translate="yes" xml:space="preserve">
          <source>If a domain error occurs, an implementation-defined value (NaN where supported) is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="daaa304029da34d0537dff7e88f32d7146eac438" translate="yes" xml:space="preserve">
          <source>If a domain error occurs, an implementation-defined value is returned (NaN where supported).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a2b2a5d22410f7c139500bf2d1ad8bd3daffb21" translate="yes" xml:space="preserve">
          <source>If a domain error occurs, an implementation-defined value is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2882768bd45c3b2d9f2505ac60769f87322f2c3b" translate="yes" xml:space="preserve">
          <source>If a function declaration appears outside of any function, the identifier it introduces has &lt;a href=&quot;scope&quot;&gt;file scope&lt;/a&gt; and &lt;a href=&quot;storage_duration&quot;&gt;external linkage&lt;/a&gt;, unless &lt;code&gt;static&lt;/code&gt; is used or an earlier static declaration is visible. If the declaration occurs inside another function, the identifier has block scope (and also either internal or external linkage).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f3d7d32f7511db7ae1b5863171bfef6106dcf6d" translate="yes" xml:space="preserve">
          <source>If a function is declared &lt;code&gt;inline&lt;/code&gt; in some translation units, it does not need to be declared inline everywhere: at most one translation unit may also provide a regular, non-inline non-static function, or a function declared &lt;code&gt;extern inline&lt;/code&gt;. This one translation unit is said to provide the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55e8d6db1875ea64570ead516bceb34179f77c5b" translate="yes" xml:space="preserve">
          <source>If a non-static function is declared &lt;code&gt;inline&lt;/code&gt;, then it must be defined in the same translation unit. The inline definition that does not use &lt;code&gt;extern&lt;/code&gt; is not externally visible and does not prevent other translation units from defining the same function. This makes the &lt;code&gt;inline&lt;/code&gt; keyword an alternative to &lt;code&gt;static&lt;/code&gt; for defining functions inside header files, which may be included in multiple translation units of the same program.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a2baf22c2e3d7ee45e7b76a25868e011a385fd4" translate="yes" xml:space="preserve">
          <source>If a pointer to object is converted to a pointer to void and back, its value compares equal to the original pointer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95fa4aab00b2248a193df0012ce51bbbfdcb0a2a" translate="yes" xml:space="preserve">
          <source>If a pole error occurs, &lt;code&gt;&amp;plusmn;HUGE_VAL&lt;/code&gt;, &lt;code&gt;&amp;plusmn;HUGE_VALF&lt;/code&gt;, or &lt;code&gt;&amp;plusmn;HUGE_VALL&lt;/code&gt; is returned (with the correct sign).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88c1375fb3e07154fab82fd39487a150f20a7acc" translate="yes" xml:space="preserve">
          <source>If a pole error occurs, &lt;code&gt;&amp;plusmn;HUGE_VAL&lt;/code&gt;, &lt;code&gt;&amp;plusmn;HUGE_VALF&lt;/code&gt;, or &lt;code&gt;&amp;plusmn;HUGE_VALL&lt;/code&gt; is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83547df0814e730591b9f631b39a107992bddaca" translate="yes" xml:space="preserve">
          <source>If a pole error occurs, &lt;code&gt;+HUGE_VAL&lt;/code&gt;, &lt;code&gt;+HUGE_VALF&lt;/code&gt;, or &lt;code&gt;+HUGE_VALL&lt;/code&gt; is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55c8a2c8fff5d682aefd99723282ecf86b260cc3" translate="yes" xml:space="preserve">
          <source>If a pole error occurs, &lt;code&gt;-HUGE_VAL&lt;/code&gt;, &lt;code&gt;-HUGE_VALF&lt;/code&gt;, or &lt;code&gt;-HUGE_VALL&lt;/code&gt; is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1aad32c287435bd724b2b2cd991a06c95727932d" translate="yes" xml:space="preserve">
          <source>If a pole error or a range error due to overflow occurs, &lt;code&gt;&amp;plusmn;HUGE_VAL&lt;/code&gt;, &lt;code&gt;&amp;plusmn;HUGE_VALF&lt;/code&gt;, or &lt;code&gt;&amp;plusmn;HUGE_VALL&lt;/code&gt; is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c9db649e4e6e4c38883de06799ee045378481d1" translate="yes" xml:space="preserve">
          <source>If a range error due to overflow occurs, &lt;code&gt;&amp;plusmn;HUGE_VAL&lt;/code&gt;, &lt;code&gt;&amp;plusmn;HUGE_VALF&lt;/code&gt;, or &lt;code&gt;&amp;plusmn;HUGE_VALL&lt;/code&gt; is returned (with the same sign as &lt;code&gt;from&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9842b2827c672e6e4b846cc1f4ef41186aaaf5f3" translate="yes" xml:space="preserve">
          <source>If a range error due to overflow occurs, &lt;code&gt;&amp;plusmn;HUGE_VAL&lt;/code&gt;, &lt;code&gt;&amp;plusmn;HUGE_VALF&lt;/code&gt;, or &lt;code&gt;&amp;plusmn;HUGE_VALL&lt;/code&gt; is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e1bf2f0df7137552a9579d23123773adeb14193" translate="yes" xml:space="preserve">
          <source>If a range error due to overflow occurs, &lt;code&gt;+HUGE_VAL&lt;/code&gt;, &lt;code&gt;+HUGE_VALF&lt;/code&gt;, or &lt;code&gt;+HUGE_VALL&lt;/code&gt; is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55d9e5e2db658de793b6612e1c8dc0adb82837dc" translate="yes" xml:space="preserve">
          <source>If a range error due to underflow occurs, the correct result (after rounding) is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="144f2afda2da10823b65a9e4c24a0b3bb37c9913" translate="yes" xml:space="preserve">
          <source>If a range error due to underflow occurs, the correct value (after rounding) is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="949156f77460641cf432a3cc1721f1ed036f3731" translate="yes" xml:space="preserve">
          <source>If a range error occurs due to underflow, the correct result (after rounding) is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bea570ee8fcad0dd93ebf596f86eddc89718e8ce" translate="yes" xml:space="preserve">
          <source>If a range error occurs due to underflow, the correct result is returned if subnormals are supported.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4771fa50f8d7229b07b35621538a1aac36cd67a9" translate="yes" xml:space="preserve">
          <source>If a range error occurs due to underflow, the correct result is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ce932a742aa1c52c8241cbf55e0ac1bce6e8b12" translate="yes" xml:space="preserve">
          <source>If a read or write error occurs, the error indicator (&lt;code&gt;&lt;a href=&quot;ferror&quot;&gt;ferror&lt;/a&gt;&lt;/code&gt;) for the stream is set.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="324e8a46a69b9f9f1395e3fb9228dc24af457e88" translate="yes" xml:space="preserve">
          <source>If a read or write error occurs, the error indicator for the stream (&lt;code&gt;&lt;a href=&quot;ferror&quot;&gt;ferror&lt;/a&gt;&lt;/code&gt;) is set and the file position is unaffected.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f0552ab1ad9171053eb62c701cf4a288607a3e9" translate="yes" xml:space="preserve">
          <source>If a struct defines at least one named member, it is allowed to additionally declare its last member with incomplete array type. When an element of the flexible array member is accessed (in an expression that uses operator &lt;code&gt;.&lt;/code&gt; or &lt;code&gt;-&amp;gt;&lt;/code&gt; with the flexible array member's name as the right-hand-side operand), then the struct behaves as if the array member had the longest size fitting in the memory allocated for this object. If no additional storage was allocated, it behaves as if an array with 1 element, except that the behavior is undefined if that element is accessed or a pointer one past that element is produced. Initialization, &lt;code&gt;sizeof&lt;/code&gt;, and the assignment operator ignore the flexible array member. Structures with flexible array members (or unions who have a recursive-possibly structure member with flexible array member) cannot appear as array elements or as members of other structures.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eed39e59199bcc4446f53b7637371743e6a55284" translate="yes" xml:space="preserve">
          <source>If a valid hex digit follows a hex escape in a string literal, it would fail to compile as an invalid escape sequence, but string concatenation can be used as a workaround:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4f25c0ec9b3244cc6b75eca052c2b903d4a3faa" translate="yes" xml:space="preserve">
          <source>If a width specifier is used, matches exactly</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5226fd58b879032cf6f8d13e08547a5ed7497ff7" translate="yes" xml:space="preserve">
          <source>If allocation succeeds, returns a pointer to the lowest (first) byte in the allocated memory block that is suitably aligned for any object type with &lt;a href=&quot;../language/object#Alignment&quot;&gt;fundamental alignment&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10b291b7c1e1eda28b0d49719b46140dae50f0df" translate="yes" xml:space="preserve">
          <source>If allocation succeeds, returns a pointer to the lowest (first) byte in the allocated memory block that is suitably aligned for any object type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55b167df42e8335a72f97731fb365e554992c1c1" translate="yes" xml:space="preserve">
          <source>If an array is so large (greater than &lt;code&gt;&lt;a href=&quot;limits&quot;&gt;PTRDIFF_MAX&lt;/a&gt;&lt;/code&gt; elements, but less than &lt;code&gt;&lt;a href=&quot;limits&quot;&gt;SIZE_MAX&lt;/a&gt;&lt;/code&gt; bytes), that the difference between two pointers may not be representable as &lt;code&gt;ptrdiff_t&lt;/code&gt;, the result of subtracting two such pointers is undefined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9beeb85ee5a960fd0d5fcc0adf11aa6910156337" translate="yes" xml:space="preserve">
          <source>If an array type is declared with a &lt;a href=&quot;const&quot;&gt;const&lt;/a&gt;, &lt;a href=&quot;volatile&quot;&gt;volatile&lt;/a&gt;, &lt;a href=&quot;restrict&quot;&gt;restrict&lt;/a&gt;(since C99), or &lt;a href=&quot;atomic&quot;&gt;_Atomic&lt;/a&gt;(since C11) qualifier (which is possible through the use of &lt;a href=&quot;typedef&quot;&gt;typedef&lt;/a&gt;), the array type is not qualified, but its element type is:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="efcc6d70fe043c8b98938e05a3396705b54776f5" translate="yes" xml:space="preserve">
          <source>If an array type is declared with the const type qualifier (through the use of &lt;a href=&quot;typedef&quot;&gt;typedef&lt;/a&gt;), the array type is not const-qualified, but its element type is. If a function type is declared with the const type qualifier (through the use of &lt;a href=&quot;typedef&quot;&gt;typedef&lt;/a&gt;), the behavior is undefined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55e10804f659caae0ae85fbc681a3dc12898bf81" translate="yes" xml:space="preserve">
          <source>If an array type is declared with the restrict type qualifier (through the use of &lt;a href=&quot;typedef&quot;&gt;typedef&lt;/a&gt;), the array type is not restrict-qualified, but its element type is:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05be40a7233aa73625c4b48d04ab3ca25d2b7f9f" translate="yes" xml:space="preserve">
          <source>If an array type is declared with the volatile type qualifier (through the use of &lt;a href=&quot;typedef&quot;&gt;typedef&lt;/a&gt;), the array type is not volatile-qualified, but its element type is. If a function type is declared with the volatile type qualified (through the use of &lt;a href=&quot;typedef&quot;&gt;typedef&lt;/a&gt;), the behavior is undefined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="940fbe62d35554fccc76640b50d6adbc0079900c" translate="yes" xml:space="preserve">
          <source>If an atomic store in thread A is tagged &lt;code&gt;memory_order_release&lt;/code&gt; and an atomic load in thread B from the same variable is tagged &lt;code&gt;memory_order_acquire&lt;/code&gt;, all memory writes (non-atomic and relaxed atomic) that</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf29cb2a4f015597bd5e89b82f0e88a7976c2e6a" translate="yes" xml:space="preserve">
          <source>If an atomic store in thread A is tagged &lt;code&gt;memory_order_release&lt;/code&gt; and an atomic load in thread B from the same variable is tagged &lt;code&gt;memory_order_consume&lt;/code&gt;, all memory writes (non-atomic and relaxed atomic) that are</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2795e8b6307a4d1e54bc6184732434401b4ea962" translate="yes" xml:space="preserve">
          <source>If an encoding error occurred, additionally sets &lt;code&gt;&lt;a href=&quot;../error/errno&quot;&gt;errno&lt;/a&gt;&lt;/code&gt; to &lt;code&gt;EILSEQ&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6911b84a61e5b6d4a44d583d9d016bd32e93add2" translate="yes" xml:space="preserve">
          <source>If an error occurs, the resulting value of the file position indicator for the stream is indeterminate. If a partial element is read, its value is indeterminate.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc208d62518be5c688131bdd43fff494483d3612" translate="yes" xml:space="preserve">
          <source>If an expression evaluates to a value that is not representable by its type, it cannot be used as a constant expression.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19ed04f0c056df4f3d246b0a488a18fc4f9a7010" translate="yes" xml:space="preserve">
          <source>If an identifier with external linkage is used in any expression other than a non-VLA(since C99), &lt;a href=&quot;sizeof&quot;&gt;sizeof&lt;/a&gt;, or &lt;a href=&quot;alignof&quot;&gt;alignof&lt;/a&gt;(since C11), there must be one and only one external definition for that identifier somewhere in the entire program.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61c715d29fbc4afeba0153113b895f922bbc534a" translate="yes" xml:space="preserve">
          <source>If an identifier with internal linkage is used in any expression other than a non-VLA(since C99), &lt;a href=&quot;sizeof&quot;&gt;sizeof&lt;/a&gt;, or &lt;a href=&quot;alignof&quot;&gt;alignof&lt;/a&gt;(since C11), there must be one and only one external definition for that identifier in the translation unit.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7f9754da6fc6b81f29f5b6d3b428b27d61fc3ed" translate="yes" xml:space="preserve">
          <source>If an indeterminate value is used as an argument to any standard library call, the behavior is undefined. Otherwise, the result of any expression involving indeterminate values is an indeterminate value (e.g. &lt;code&gt;int n;&lt;/code&gt;, &lt;code&gt;n&lt;/code&gt; may not compare equal to itself and it may appear to change its value on subsequent reads).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2595c0e9c8f0a0375a7da8475c597d0f3be5bd12" translate="yes" xml:space="preserve">
          <source>If an initializer is not provided:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12e7ba75c8d971362a518ba45e96ae10c7050f8c" translate="yes" xml:space="preserve">
          <source>If an initializer is provided, see.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="737ef6d3c730778e5c94a6b40c35f5020e3cd40a" translate="yes" xml:space="preserve">
          <source>If an lvalue expression is used in any context other than &lt;a href=&quot;sizeof&quot;&gt;sizeof&lt;/a&gt;, &lt;a href=&quot;alignof&quot;&gt;_Alignof&lt;/a&gt;, or the operators listed above, non-array lvalues of any complete type undergo &lt;a href=&quot;conversion&quot;&gt;lvalue conversion&lt;/a&gt;, which models the memory load of the value of the object from its location. Similarly, array lvalues undergo &lt;a href=&quot;conversion&quot;&gt;array-to-pointer conversion&lt;/a&gt; when used in any context other than &lt;code&gt;sizeof&lt;/code&gt;, &lt;code&gt;_Alignof&lt;/code&gt;, address-of operator, or array initialization from a string literal.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d8c9bcb6d816c1a8ecd0a37069f05536bd2ec31" translate="yes" xml:space="preserve">
          <source>If an object representation does not represent any value of the object type, it is known as</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c820dc8c26d3db1ef814640861c6f3807e6c1ba5" translate="yes" xml:space="preserve">
          <source>If an object's alignment is made stricter (larger) than &lt;code&gt;&lt;a href=&quot;../types/max_align_t&quot;&gt;max_align_t&lt;/a&gt;&lt;/code&gt; using &lt;a href=&quot;alignas&quot;&gt;alignas&lt;/a&gt;, it has</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="acd0f2effed8427de550d8d6b990c3718b9b3c16" translate="yes" xml:space="preserve">
          <source>If any of the arguments for the generic parameters is &lt;code&gt;long double&lt;/code&gt;, then the &lt;code&gt;long double&lt;/code&gt; variant is called. Otherwise, if any of the arguments for the generic parameters is &lt;code&gt;double&lt;/code&gt;, then the &lt;code&gt;double&lt;/code&gt; variant is called. Otherwise, &lt;code&gt;float&lt;/code&gt; variant is called.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="562e239709bc35b2b379032b89448978ab95efc0" translate="yes" xml:space="preserve">
          <source>If any of the arguments for the generic parameters is &lt;code&gt;long double&lt;/code&gt;, then the &lt;code&gt;long double&lt;/code&gt; variant is called. Otherwise, if any of the parameters is &lt;code&gt;double&lt;/code&gt; or integer, then the &lt;code&gt;double&lt;/code&gt; variant is called. Otherwise, &lt;code&gt;float&lt;/code&gt; variant is called.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec78132e6099d16c4819b148849342ed77f805bd" translate="yes" xml:space="preserve">
          <source>If any of the arguments for the generic parameters is complex, then the complex function is called, otherwise the real function is called.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79b55232ba96a3bd42fd8dd7103363973985e2a1" translate="yes" xml:space="preserve">
          <source>If any of the arguments for the generic parameters is imaginary, the behavior is specified on each function reference page individually (in particular, sin, cos, tag, cosh, sinh, tanh, asin, atan, asinh, and atanh call</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f56fd154648f3d8467222c29490c068976fd45a" translate="yes" xml:space="preserve">
          <source>If any of the arguments for the generic parameters is real, complex, or imaginary, then the appropriate complex function is called.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9059699e445e938e899ba841bbdc2815187e8516" translate="yes" xml:space="preserve">
          <source>If any part of a declarator is a &lt;a href=&quot;array&quot;&gt;VLA array&lt;/a&gt; declarator, the entire declarator's type is known as &quot;variably-modified type&quot;. Types defined from variably-modified types are also variably modified (VM).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41cd76f0d575b7b9cd5e0fd684bb28b73c4dd854" translate="yes" xml:space="preserve">
          <source>If any subobject is explicitly initialized twice (which may happen when designators are used), the initializer that appears later in the list is the one used (the earlier initializer may not be evaluated):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08759afad939001ce25641ffda80dd6d474e5c10" translate="yes" xml:space="preserve">
          <source>If arg is NaN, NaN is returned</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d7eda972ce3fcd7bac7edeebd6987d2d5448884" translate="yes" xml:space="preserve">
          <source>If both operands have &lt;a href=&quot;arithmetic_types&quot;&gt;arithmetic types&lt;/a&gt;, then.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65568841562f35d225fc26d418379905f6cfe94d" translate="yes" xml:space="preserve">
          <source>If both the converted value and the precision are &lt;code&gt;​0​&lt;/code&gt; the conversion results in no characters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa56eddeecaa652e74ddca2ef43579a7b00a26ad" translate="yes" xml:space="preserve">
          <source>If both the remainder and the quotient can be represented as objects of the corresponding type (int, long, long long, imaxdiv_t, respectively), returns both as an object of type &lt;code&gt;div_t&lt;/code&gt;, &lt;code&gt;ldiv_t&lt;/code&gt;, &lt;code&gt;lldiv_t&lt;/code&gt;, &lt;code&gt;imaxdiv_t&lt;/code&gt; defined as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="504c354c4217916940c16491f303887d6d786f1c" translate="yes" xml:space="preserve">
          <source>If both types are array types, the following rules are applied:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9300681f14311ef1308fff428de5207f181878fe" translate="yes" xml:space="preserve">
          <source>If both types are function types with parameter type lists, the type of each parameter in the composite parameter type list is the composite type of the corresponding parameters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a9f1e1eed77a46edb55388fc632deb4ed555ebd" translate="yes" xml:space="preserve">
          <source>If command is a null pointer, checks if the host environment has a command processor and returns a nonzero value if and only if the command processor exists.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28cefa0e9741f616b6f6233c4b91926613432287" translate="yes" xml:space="preserve">
          <source>If control over &lt;code&gt;&lt;a href=&quot;../numeric/fenv/fe_exceptions&quot;&gt;FE_INEXACT&lt;/a&gt;&lt;/code&gt; is needed in floating-to-integer conversions, &lt;code&gt;&lt;a href=&quot;../numeric/math/rint&quot;&gt;rint&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../numeric/math/nearbyint&quot;&gt;nearbyint&lt;/a&gt;&lt;/code&gt; may be used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="192b44dddfe8a0edbf403637b9dc082e8fcbccab" translate="yes" xml:space="preserve">
          <source>If either &lt;code&gt;x&lt;/code&gt; is NaN or &lt;code&gt;y&lt;/code&gt; is NaN, NaN is returned</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5798cb4e0bd7a6d21c2a60a89c9c101a7f709c34" translate="yes" xml:space="preserve">
          <source>If either &lt;code&gt;x&lt;/code&gt; or &lt;code&gt;y&lt;/code&gt; is NaN, NaN is returned</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1b8d9bd67fa1ccf8414b0062f383f3be7b83851" translate="yes" xml:space="preserve">
          <source>If either argument is NaN, NaN is returned</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4facc3a3dde5ddbefb08336856d6b20eb05ed6dc" translate="yes" xml:space="preserve">
          <source>If either the remainder or the quotient cannot be represented, the behavior is undefined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fdb29cf682870c157ecc255b61896ebcf0dd8877" translate="yes" xml:space="preserve">
          <source>If enumerator is followed by = constant-expression, its value is the value of that constant expression. If enumerator is not followed by = constant-expression, its value is the value one greater than the value of the previous enumerator in the same enumeration. The value of the first enumerator (if it does not use = constant-expression) is zero.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1a30ffdb8b054f4f5efa04e804183bab7b8f87d" translate="yes" xml:space="preserve">
          <source>If evaluation A is sequenced before evaluation B, then evaluation of A will be complete before evaluation of B begins.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="360528c544120ebe32f7b7cd67e035fb9e4b4a51" translate="yes" xml:space="preserve">
          <source>If expression compares not equal to the integer zero, statement_true is executed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fbb388918567059a7ef91b0bac2e600518001881" translate="yes" xml:space="preserve">
          <source>If expression evaluates to a value that doesn't match any of the &lt;code&gt;case:&lt;/code&gt; labels, and the &lt;code&gt;default:&lt;/code&gt; label is not present, none of the switch body is executed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa83991d8493cfe779ea779356df33a31e5bb405" translate="yes" xml:space="preserve">
          <source>If expression evaluates to a value that doesn't match any of the &lt;code&gt;case:&lt;/code&gt; labels, and the &lt;code&gt;default:&lt;/code&gt; label is present, control is transferred to the statement labeled with the &lt;code&gt;default:&lt;/code&gt; label.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6faa6fc85532e8604df80b963c664490b88079fd" translate="yes" xml:space="preserve">
          <source>If expression evaluates to the value that is equal to the value of one of constant_expressions after conversion to the promoted type of expression, then control is transferred to the statement that is labeled with that constant_expression.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="334783c8d779e32d80f5e33d41aa548e3861ef1e" translate="yes" xml:space="preserve">
          <source>If expression evaluates to zero, this specifier has no effect.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="812257c713ec48ffa717a1e22cfeb0579763c024" translate="yes" xml:space="preserve">
          <source>If expression in an array declarator is an &lt;a href=&quot;constant_expression#Integer_constant_expression&quot;&gt;integer constant expression&lt;/a&gt; with a value greater than zero and the element type is a type with a known constant size (that is, elements are not VLA)(since C99), then the declarator declares an array of constant known size:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ba6da87ee9a243a839b16d19baf884836288808" translate="yes" xml:space="preserve">
          <source>If expression in an array declarator is omitted, it declares an array of unknown size. Except in function parameter lists (where such arrays are transformed to pointers) and when an &lt;a href=&quot;array_initialization&quot;&gt;initializer&lt;/a&gt; is available, such type is an &lt;a href=&quot;compatible_type#Incomplete_types&quot;&gt;incomplete type&lt;/a&gt; (note that VLA of unspecified size, declared with &lt;code&gt;*&lt;/code&gt; as the size, is a complete type)(since C99):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fdf07733d3563d8385b8f445a3649648c5f3b8c5" translate="yes" xml:space="preserve">
          <source>If expression is not an &lt;a href=&quot;constant_expression#Integer_constant_expression&quot;&gt;integer constant expression&lt;/a&gt;, the declarator is for an array of variable size.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2a210c65a0f6c3811043fd43a33ea0aeafeba4c" translate="yes" xml:space="preserve">
          <source>If it is an expression, it is evaluated once, before the first evaluation of cond_expression and its result is discarded.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1527a6f74ffff1d191859da84a0b12635390d9d" translate="yes" xml:space="preserve">
          <source>If lhs and rhs are expressions of any &lt;a href=&quot;types&quot;&gt;real type&lt;/a&gt;, then.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dab84ea7417a8449e8e53aefe0bfd270462902ff" translate="yes" xml:space="preserve">
          <source>If lhs and rhs are expressions of pointer type, they must be both pointers to objects of &lt;a href=&quot;types#Compatible_types&quot;&gt;compatible types&lt;/a&gt;, except that qualifications of the pointed-to objects are ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7bb0fe233a8db1c5731305199a741e53a04ba01b" translate="yes" xml:space="preserve">
          <source>If lhs has &lt;a href=&quot;atomic&quot;&gt;atomic&lt;/a&gt; type, the operation behaves as a single atomic read-modify-write operation with memory order &lt;code&gt;&lt;a href=&quot;../atomic/memory_order&quot;&gt;memory_order_seq_cst&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc7031518acd1f816f49dabf6745ea7fa65d3428" translate="yes" xml:space="preserve">
          <source>If lineno is 0 or greater than 32767(until C99)2147483647(since C99), the behavior is undefined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="edd868dcc474e443c25a49132bd6419f1abf7cca" translate="yes" xml:space="preserve">
          <source>If no conversion can be performed, &lt;code&gt;​0​&lt;/code&gt; is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="530f889d2ad8b60ee918f8e2702b7883b29fb175" translate="yes" xml:space="preserve">
          <source>If no errors occur earg</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4b69264dcfdc184105c0c5fcdc54a8a79767399" translate="yes" xml:space="preserve">
          <source>If no errors occur ln(1+arg) is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3037fe820d838daa891fb3539a8329f215061a7" translate="yes" xml:space="preserve">
          <source>If no errors occur,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="602f32de7c64c4861f4c15f4a272e41e4cf03cae" translate="yes" xml:space="preserve">
          <source>If no errors occur, &lt;code&gt;arg&lt;/code&gt; multiplied by 2 to the power of &lt;code&gt;exp&lt;/code&gt; (arg&amp;times;2exp</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd6ab22732d33f90243d40ac0149ac1bffd11661" translate="yes" xml:space="preserve">
          <source>If no errors occur, &lt;code&gt;arg&lt;/code&gt; multiplied by &lt;code&gt;&lt;a href=&quot;../../types/limits&quot;&gt;FLT_RADIX&lt;/a&gt;&lt;/code&gt; to the power of &lt;code&gt;exp&lt;/code&gt; (arg&amp;times;FLT_RADIXexp</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05313ea76fba59eae28768bcd1ded7d73640a2b9" translate="yes" xml:space="preserve">
          <source>If no errors occur, &lt;code&gt;base&lt;/code&gt; raised to the power of &lt;code&gt;exponent&lt;/code&gt; (baseexponent</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43e9fba55e5f456a3880c2a5f09b14d52ee81371" translate="yes" xml:space="preserve">
          <source>If no errors occur, complex arc cosine of &lt;code&gt;z&lt;/code&gt; is returned, in the range [0 ; &amp;infin;) along the real axis and in the range [&amp;minus;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ba083c7eab3d055b75951c25f225f73acff4188" translate="yes" xml:space="preserve">
          <source>If no errors occur, complex arc sine of &lt;code&gt;z&lt;/code&gt; is returned, in the range of a strip unbounded along the imaginary axis and in the interval [&amp;minus;&amp;pi;/2; +&amp;pi;/2] along the real axis.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e58f6c458633d11255df6ec72e17d6e0e307082c" translate="yes" xml:space="preserve">
          <source>If no errors occur, complex arc tangent of &lt;code&gt;z&lt;/code&gt; is returned, in the range of a strip unbounded along the imaginary axis and in the interval [&amp;minus;&amp;pi;/2; +&amp;pi;/2] along the real axis.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50a8713f4c4c617bedaa7a390ea195b3329dac1c" translate="yes" xml:space="preserve">
          <source>If no errors occur, complex hyperbolic cosine of &lt;code&gt;z&lt;/code&gt; is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8e6619163d1ca9fedc0a2bfd79d4c047fbeb277" translate="yes" xml:space="preserve">
          <source>If no errors occur, complex hyperbolic sine of &lt;code&gt;z&lt;/code&gt; is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0204a9004641a330efb33cc1c10a2eb5fe8c95c2" translate="yes" xml:space="preserve">
          <source>If no errors occur, complex hyperbolic tangent of &lt;code&gt;z&lt;/code&gt; is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6bbf046061401d16d535bc081cfe13e7549ef1e" translate="yes" xml:space="preserve">
          <source>If no errors occur, returns the absolute value (norm, magnitude) of &lt;code&gt;z&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7f248bc9527b22f78b886ecb63cf4c8a2bd9c60" translate="yes" xml:space="preserve">
          <source>If no errors occur, returns the fractional part of &lt;code&gt;x&lt;/code&gt; with the same sign as &lt;code&gt;x&lt;/code&gt;. The integral part is put into the value pointed to by &lt;code&gt;iptr&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dcbbfc79f2b5b688deb79fcd4d7c358c461e6459" translate="yes" xml:space="preserve">
          <source>If no errors occur, returns the phase angle of &lt;code&gt;z&lt;/code&gt; in the interval [&amp;minus;&amp;pi;; &amp;pi;].</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af3231d18a9dbafc82193c163f7f7ec4e37b28f7" translate="yes" xml:space="preserve">
          <source>If no errors occur, returns the square root of &lt;code&gt;z&lt;/code&gt;, in the range of the right half-plane, including the imaginary axis ([0; +&amp;infin;) along the real axis and (&amp;minus;&amp;infin;; +&amp;infin;) along the imaginary axis.).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee22b5df48ca25af069416a0b6aead9e8cfe0766" translate="yes" xml:space="preserve">
          <source>If no errors occur, square root of &lt;code&gt;arg&lt;/code&gt; (&amp;radic;arg), is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a9c8867b079f9f036564e75c55c95fbeddad36f" translate="yes" xml:space="preserve">
          <source>If no errors occur, the arc cosine of &lt;code&gt;arg&lt;/code&gt; (arccos(arg)) in the range [0 ; &amp;pi;], is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="039d32b1f2e5bfee4ca5736c63a4206e5274388e" translate="yes" xml:space="preserve">
          <source>If no errors occur, the arc sine of &lt;code&gt;arg&lt;/code&gt; (arcsin(arg)) in the range [-</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b32613c8b978beac62c696ce2bd93a54bd237edb" translate="yes" xml:space="preserve">
          <source>If no errors occur, the arc tangent of &lt;code&gt;arg&lt;/code&gt; (arctan(arg)) in the range [-</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c938da3a42fe0590b15c6f8539ff408d3a3b97dd" translate="yes" xml:space="preserve">
          <source>If no errors occur, the arc tangent of &lt;code&gt;y/x&lt;/code&gt; (arctan(</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d5986c54dce11e1cd1599414757016de12c5f01" translate="yes" xml:space="preserve">
          <source>If no errors occur, the base-</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be331ea28ae7c2d7b9acf97860d316fce4b87723" translate="yes" xml:space="preserve">
          <source>If no errors occur, the common (base-</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05909577ff3329b64c179e57f5f18c51d7427016" translate="yes" xml:space="preserve">
          <source>If no errors occur, the complex arc hyperbolic sine of &lt;code&gt;z&lt;/code&gt; is returned, in the range of a strip mathematically unbounded along the real axis and in the interval [&amp;minus;i&amp;pi;/2; +i&amp;pi;/2] along the imaginary axis.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e1faa126d0291e9222a13afce04bd8eb0c0cbd7" translate="yes" xml:space="preserve">
          <source>If no errors occur, the complex arc hyperbolic tangent of &lt;code&gt;z&lt;/code&gt; is returned, in the range of a half-strip mathematically unbounded along the real axis and in the interval [&amp;minus;i&amp;pi;/2; +i&amp;pi;/2] along the imaginary axis.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b951e541cea44c28eafdd9c54b7c32c1392530f6" translate="yes" xml:space="preserve">
          <source>If no errors occur, the complex cosine of &lt;code&gt;z&lt;/code&gt; is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0170daad51b40b50ab797fcf5f22cc95ede3feb" translate="yes" xml:space="preserve">
          <source>If no errors occur, the complex natural logarithm of &lt;code&gt;z&lt;/code&gt; is returned, in the range of a strip in the interval [&amp;minus;i&amp;pi;, +i&amp;pi;] along the imaginary axis and mathematically unbounded along the real axis.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e80a11cce80b4f8332e379e29bcd184e31b6ff47" translate="yes" xml:space="preserve">
          <source>If no errors occur, the complex power xy</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a78d2dc104a241c9b7f8248a90bd60175e723dc" translate="yes" xml:space="preserve">
          <source>If no errors occur, the complex sine of &lt;code&gt;z&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f171b9589d9359bfb44bdfa881b4ee93ea77d0c" translate="yes" xml:space="preserve">
          <source>If no errors occur, the complex tangent of &lt;code&gt;z&lt;/code&gt; is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="35bd7abdcb7f0220128fd880299baf801952dc19" translate="yes" xml:space="preserve">
          <source>If no errors occur, the cosine of &lt;code&gt;arg&lt;/code&gt; (cos(arg)) in the range [-1 ; +1], is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff16f514ad4d462d31d6524ed4ea84f4f6bcb390" translate="yes" xml:space="preserve">
          <source>If no errors occur, the cubic root of &lt;code&gt;arg&lt;/code&gt; (3&amp;radic;arg), is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e33cd84b874596d38519b6f05a2e60c9accef6b" translate="yes" xml:space="preserve">
          <source>If no errors occur, the floating point value with the magnitude of &lt;code&gt;x&lt;/code&gt; and the sign of &lt;code&gt;y&lt;/code&gt; is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29635dc5075be505f22d8b338419ce3b116238e5" translate="yes" xml:space="preserve">
          <source>If no errors occur, the hyperbolic cosine of &lt;code&gt;arg&lt;/code&gt; (cosh(arg), or</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="084419061d5d22eb194084f72eb3bc99faee2d80" translate="yes" xml:space="preserve">
          <source>If no errors occur, the hyperbolic sine of &lt;code&gt;arg&lt;/code&gt; (sinh(arg), or</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fde1a5cab1da9385208df6463481d983b8d198b8" translate="yes" xml:space="preserve">
          <source>If no errors occur, the hyperbolic tangent of &lt;code&gt;arg&lt;/code&gt; (tanh(arg), or</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="146d272bae4916411520863aa03f483db24f1cd9" translate="yes" xml:space="preserve">
          <source>If no errors occur, the hypotenuse of a right-angled triangle, &amp;radic;x2</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3870fee396c73bbc1aab8cee4f9a85c1179be025" translate="yes" xml:space="preserve">
          <source>If no errors occur, the inverse hyperbolic cosine of &lt;code&gt;arg&lt;/code&gt; (cosh-1</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5db26fbae61f4e34cf5287ffaa5a9d47e53259d" translate="yes" xml:space="preserve">
          <source>If no errors occur, the inverse hyperbolic sine of &lt;code&gt;arg&lt;/code&gt; (sinh-1</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f93099d7063e1d7a83038ac66c3c5233ba5f6ece" translate="yes" xml:space="preserve">
          <source>If no errors occur, the inverse hyperbolic tangent of &lt;code&gt;arg&lt;/code&gt; (tanh-1</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4744dace8417a9d2afa9a3795c780e70495855c" translate="yes" xml:space="preserve">
          <source>If no errors occur, the largest integer value not greater than &lt;code&gt;arg&lt;/code&gt;, that is &amp;lfloor;arg&amp;rfloor;, is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3007ffc0d3f619ed4878713babc6bf385e75ed5b" translate="yes" xml:space="preserve">
          <source>If no errors occur, the natural (base-</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f127780bac10fbde3e943c6286123dc5c825a17d" translate="yes" xml:space="preserve">
          <source>If no errors occur, the nearest integer value not greater in magnitude than &lt;code&gt;arg&lt;/code&gt; (in other words, &lt;code&gt;arg&lt;/code&gt; rounded towards zero), is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f769b27b09219929833064428bef0734a24648aa" translate="yes" xml:space="preserve">
          <source>If no errors occur, the nearest integer value to &lt;code&gt;arg&lt;/code&gt;, according to the &lt;a href=&quot;../fenv/fe_round&quot;&gt;current rounding mode&lt;/a&gt;, is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0256d4c5a80036d6bc9fdb716345ed55c66ea11" translate="yes" xml:space="preserve">
          <source>If no errors occur, the nearest integer value to &lt;code&gt;arg&lt;/code&gt;, rounding halfway cases away from zero, is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="695de1cc17da5f42bb05163df84a4d86f843cb06" translate="yes" xml:space="preserve">
          <source>If no errors occur, the next representable value of &lt;code&gt;from&lt;/code&gt; in the direction of &lt;code&gt;to&lt;/code&gt;. is returned. If &lt;code&gt;from&lt;/code&gt; equals &lt;code&gt;to&lt;/code&gt;, then &lt;code&gt;to&lt;/code&gt; is returned, converted to the type of the function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0a7b391baa86594c7d0448266a28acb2668a4e8" translate="yes" xml:space="preserve">
          <source>If no errors occur, the sine of &lt;code&gt;arg&lt;/code&gt; (sin(arg)) in the range [-1 ; +1], is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3fa7223cf61583336068c9d91991b4f9bedf8c7c" translate="yes" xml:space="preserve">
          <source>If no errors occur, the smallest integer value not less than &lt;code&gt;arg&lt;/code&gt;, that is &amp;lceil;arg&amp;rceil;, is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="941693082c1c679c39e6797e593c1a748bca9744" translate="yes" xml:space="preserve">
          <source>If no errors occur, the tangent of &lt;code&gt;arg&lt;/code&gt; (tan(arg)) is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e15bc85bb52009c88f5c69e56b9a2471d950454" translate="yes" xml:space="preserve">
          <source>If no errors occur, the unbiased exponent of &lt;code&gt;arg&lt;/code&gt; is returned as a signed floating-point value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="026d1df8b0b132c32fe387fe762cb8d1ea884358" translate="yes" xml:space="preserve">
          <source>If no errors occur, the unbiased exponent of &lt;code&gt;arg&lt;/code&gt; is returned as a signed int value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ea26e0ca3f1790b6251b6744a4aeb9155a7a728" translate="yes" xml:space="preserve">
          <source>If no errors occur, the value of the gamma function of &lt;code&gt;arg&lt;/code&gt;, that is &amp;int;&amp;infin;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17f4ff9a3637589c23bfc0b873e96c8630ea5296" translate="yes" xml:space="preserve">
          <source>If no errors occur, the value of the logarithm of the gamma function of &lt;code&gt;arg&lt;/code&gt;, that is log</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f29a8300bf4d8be194d411485092bca1cff89a5" translate="yes" xml:space="preserve">
          <source>If no errors occur, value of the complementary error function of &lt;code&gt;arg&lt;/code&gt;, that is</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0658bf24f8b1dde223e35183fc409335d58b1a45" translate="yes" xml:space="preserve">
          <source>If no errors occur, value of the error function of &lt;code&gt;arg&lt;/code&gt;, that is</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f33a26f2411f41973ee89bb92c9912299b6bf3fb" translate="yes" xml:space="preserve">
          <source>If no side effects are produced by an expression and the compiler can determine that the value is not used, the expression &lt;a href=&quot;https://en.cppreference.com/mwiki/index.php?title=c/language/as-if&amp;amp;action=edit&amp;amp;redlink=1&quot;&gt;may not be evaluated&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24607f8eda85840327155f9c5dd479383c4c0709" translate="yes" xml:space="preserve">
          <source>If no storage-class specifier is provided, the defaults are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4dfeb978fa33ed93ba2c224367f2086d951f30e" translate="yes" xml:space="preserve">
          <source>If no such character was found, &lt;code&gt;str&lt;/code&gt; has only one token, and future calls to &lt;code&gt;strtok&lt;/code&gt; will return a null pointer</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0e3f85b21f0603ccfad7c7630e2e6165f6efad1" translate="yes" xml:space="preserve">
          <source>If no such character was found, there are no tokens in &lt;code&gt;str&lt;/code&gt; at all, and the function returns a null pointer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a104ff8f617c8217bce63f3debd82c29c77289d" translate="yes" xml:space="preserve">
          <source>If no such wide character was found, &lt;code&gt;str&lt;/code&gt; has only one token, and future calls to &lt;code&gt;wcstok&lt;/code&gt; will return a null pointer</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9fb4aef6036de9d69cd4d033e352d979c405074" translate="yes" xml:space="preserve">
          <source>If no such wide character was found, there are no tokens in &lt;code&gt;str&lt;/code&gt; at all, and the function returns a null pointer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e40d2715cf1b46b20775d0bb380629a3585cd758" translate="yes" xml:space="preserve">
          <source>If none of the type-names are compatible with the type of the controlling-expression, and the &lt;code&gt;default&lt;/code&gt; association is provided, then the type, value, and value category of the generic selection are the type, value, and value category of the expression after the &lt;code&gt;default&amp;nbsp;:&lt;/code&gt; label.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9c017ecb96c59470d6de6c8da38e2d13318a236" translate="yes" xml:space="preserve">
          <source>If one literal is unprefixed, the resulting string literal has the width/encoding specified by the prefixed literal. If the two string literals have different encoding prefixes, concatenation is implementation-defined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5394cec101ec494404d07198530eec4ab37c59ad" translate="yes" xml:space="preserve">
          <source>If one of the two arguments is NaN, the value of the other argument is returned</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="deb9997a39b957e2b1d0f67225814173635bd3be" translate="yes" xml:space="preserve">
          <source>If one type is an array of known constant size, the composite type is an array of that size.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff00bc804bf5de0ca28e5fa9b87c6ef3300ee482" translate="yes" xml:space="preserve">
          <source>If only one type is a function type with a parameter type list (a function prototype), the composite type is a function prototype with the parameter type list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ddc5ecaabd07bdd4041442caa75864db6c6d691" translate="yes" xml:space="preserve">
          <source>If overflow occurs, the behavior is undefined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90421d9a10ca2ecc53b3233d830634266328f1bb" translate="yes" xml:space="preserve">
          <source>If pointer-expression is a pointer to function, the result of the dereference operator is a function designator for that function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fabe0dc46a4e415f07e60b3d1fe73b90609b5485" translate="yes" xml:space="preserve">
          <source>If pointer-expression is a pointer to object, the result is an &lt;a href=&quot;value_category&quot;&gt;lvalue expression&lt;/a&gt; that designates the pointed-to object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd3c561c327326fa9c43dffa8ca731c59ab3fba8" translate="yes" xml:space="preserve">
          <source>If qualifiers are present, they qualify the pointer type to which the array parameter type is transformed:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="086dd4d618100274bfcb461ebcb6308c19d4ae3c" translate="yes" xml:space="preserve">
          <source>If rhs and lhs overlap in memory (e.g. they are members of the same union), the behavior is undefined unless the overlap is exact and the types are &lt;a href=&quot;compatible_type#Compatible_types&quot;&gt;compatible&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c28f503fd3f5fe3462baacb1c7312e58c942c2f" translate="yes" xml:space="preserve">
          <source>If some atomic is store-released and several other threads perform read-modify-write operations on that atomic, a &quot;release sequence&quot; is formed: all threads that perform the read-modify-writes to the same atomic synchronize with the first thread and each other even if they have no &lt;code&gt;memory_order_release&lt;/code&gt; semantics. This makes single producer - multiple consumers situations possible without imposing unnecessary synchronization between individual consumer threads.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e82df7dfa926848bf252cb2decabe5aa7f78e1a2" translate="yes" xml:space="preserve">
          <source>If statement_true is entered through a &lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt;, statement_false is not executed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="834b8d6940f6e20e10043e602b81088e525449aa" translate="yes" xml:space="preserve">
          <source>If successful, an integer value corresponding to the contents of &lt;code&gt;str&lt;/code&gt; is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5632ad995e8027aefc150ef8436b23c84c4578ae" translate="yes" xml:space="preserve">
          <source>If successful, returns the IEEE floating-point remainder of the division &lt;code&gt;x/y&lt;/code&gt; as defined above.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ba7ac810951fe3d89eb854fd7520e591880a573" translate="yes" xml:space="preserve">
          <source>If successful, returns the absolute value of &lt;code&gt;arg&lt;/code&gt; (&lt;code&gt;|arg|&lt;/code&gt;). The value returned is exact and does not depend on any rounding modes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a595b23fd21a8f04c669747846486d0e27d71af0" translate="yes" xml:space="preserve">
          <source>If successful, returns the floating-point remainder of the division &lt;code&gt;x/y&lt;/code&gt; as defined above.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dbd29a9c437f2e9ad0ed1aab2d3cb7e1e77881c8" translate="yes" xml:space="preserve">
          <source>If successful, returns the floating-point remainder of the division &lt;code&gt;x/y&lt;/code&gt; as defined in &lt;code&gt;&lt;a href=&quot;remainder&quot;&gt;remainder&lt;/a&gt;&lt;/code&gt;, and stores, in &lt;code&gt;*quo&lt;/code&gt;, the sign and at least three of the least significant bits of &lt;code&gt;x/y&lt;/code&gt; (formally, stores a value whose sign is the sign of &lt;code&gt;x/y&lt;/code&gt; and whose magnitude is congruent modulo 2n</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea98bbdcb76a97fab4ef9d6ca9c32eecbe479081" translate="yes" xml:space="preserve">
          <source>If successful, returns the larger of two floating point values. The value returned is exact and does not depend on any rounding modes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9423b4432f6a645ec2473ed82b459b6686deb60f" translate="yes" xml:space="preserve">
          <source>If successful, returns the positive difference between x and y.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46138f9b406992b59d0f9492f2e64a28cf85480b" translate="yes" xml:space="preserve">
          <source>If successful, returns the smaller of two floating point values. The value returned is exact and does not depend on any rounding modes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ca1e3a726f6c442c2b326f76a16b023bb9441ee" translate="yes" xml:space="preserve">
          <source>If successful, returns the value of &lt;code&gt;(x*y) + z&lt;/code&gt; as if calculated to infinite precision and rounded once to fit the result type (or, alternatively, calculated as a single ternary floating-point operation).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="950601c730121915fb8df6b19b5705a6edc03c0a" translate="yes" xml:space="preserve">
          <source>If successful, the object pointed to by &lt;code&gt;thr&lt;/code&gt; is set to the identifier of the new thread.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18c5e1768b43942789912ab8899675cb0c8b4274" translate="yes" xml:space="preserve">
          <source>If such character was found, it is</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d422a20479abe70ce78b9c52445ed1bd990bbc6" translate="yes" xml:space="preserve">
          <source>If such character was found, it is the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="781a8af57a4e00c05cd18f270856d6e17bfee700" translate="yes" xml:space="preserve">
          <source>If such wide character was found, it is</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc7116ca6f31d674f4a72c2589a0d09f652f8823" translate="yes" xml:space="preserve">
          <source>If such wide character was found, it is the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8d2bb8f6756f60946f65b57441b2965955c0d87" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;&lt;a href=&quot;tm&quot;&gt;struct tm&lt;/a&gt;&lt;/code&gt; object was obtained from POSIX &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/009695399/functions/strptime.html&quot;&gt;strptime&lt;/a&gt; or equivalent function, the value of &lt;code&gt;tm_isdst&lt;/code&gt; is indeterminate, and needs to be set explicitly before calling &lt;code&gt;mktime&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aba2a61809646633728f0c300cb4a04fd0fdd0e8" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;nptr&lt;/code&gt; is empty or does not have the expected form, no conversion is performed, and (if &lt;code&gt;enptr&lt;/code&gt; is not &lt;code&gt;&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt;) the value of &lt;code&gt;nptr&lt;/code&gt; is stored in the object pointed to by &lt;code&gt;endptr&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1881ec1b9072afac208ff470251f98ed10178f8" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;str&lt;/code&gt; is empty or does not have the expected form, no conversion is performed, and (if &lt;code&gt;str_end&lt;/code&gt; is not &lt;code&gt;&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt;) the value of &lt;code&gt;str&lt;/code&gt; is stored in the object pointed to by &lt;code&gt;str_end&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ee4a33ed19255d1a25cca13eefd41adeef44b2e" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;stream&lt;/code&gt; is open in binary mode, the new position is exactly &lt;code&gt;offset&lt;/code&gt; bytes measured from the beginning of the file if &lt;code&gt;origin&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../io&quot;&gt;SEEK_SET&lt;/a&gt;&lt;/code&gt;, from the current file position if &lt;code&gt;origin&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../io&quot;&gt;SEEK_CUR&lt;/a&gt;&lt;/code&gt;, and from the end of the file if &lt;code&gt;origin&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../io&quot;&gt;SEEK_END&lt;/a&gt;&lt;/code&gt;. Binary streams are not required to support &lt;code&gt;&lt;a href=&quot;../io&quot;&gt;SEEK_END&lt;/a&gt;&lt;/code&gt;, in particular if additional null bytes are output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6116bff33763f686cb5185e7645c348dd0166f73" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;stream&lt;/code&gt; is open in text mode, the only supported values for &lt;code&gt;offset&lt;/code&gt; are zero (which works with any &lt;code&gt;origin&lt;/code&gt;) and a value returned by an earlier call to &lt;code&gt;&lt;a href=&quot;ftell&quot;&gt;ftell&lt;/a&gt;&lt;/code&gt; on a stream associated with the same file (which only works with &lt;code&gt;origin&lt;/code&gt; of &lt;code&gt;&lt;a href=&quot;../io&quot;&gt;SEEK_SET&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c9015050df160ef6325c9f3da2b730ab6368bcf" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;stream&lt;/code&gt; is wide-oriented, the restrictions of both text and binary streams apply (result of &lt;code&gt;&lt;a href=&quot;ftell&quot;&gt;ftell&lt;/a&gt;&lt;/code&gt; is allowed with SEEK_SET and zero offset is allowed from SEEK_SET and SEEK_CUR, but not SEEK_END).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2619199639dd0dfe77e10f7ea0d17382af754c82" translate="yes" xml:space="preserve">
          <source>If the argument is &amp;plusmn;&amp;infin;, &amp;plusmn;1 is returned</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9eeedbf12ee3261a62193ec2f7bf409d740fd6e" translate="yes" xml:space="preserve">
          <source>If the argument is &amp;plusmn;&amp;infin;, +&amp;infin; is returned</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc0e32230b86eab8904c3236eac37ff6f8e3e5b9" translate="yes" xml:space="preserve">
          <source>If the argument is &amp;plusmn;&amp;infin;, +&amp;infin; is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70915638207ef43ec09152008a5ac4da1c3e101e" translate="yes" xml:space="preserve">
          <source>If the argument is &amp;plusmn;0, &amp;plusmn;&amp;infin; is returned and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_DIVBYZERO&lt;/a&gt;&lt;/code&gt; is raised</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4bcd3cf56514ebcbadf81a91fe745d514dda05b5" translate="yes" xml:space="preserve">
          <source>If the argument is &amp;plusmn;0, &amp;plusmn;0 is returned</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79c9397babcc1b0c97ddd36d4f6dacccb4dbab7b" translate="yes" xml:space="preserve">
          <source>If the argument is &amp;plusmn;0, +&amp;infin; is returned and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_DIVBYZERO&lt;/a&gt;&lt;/code&gt; is raised</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97d561db29f01535350a0e816707f41c9ebbceeb" translate="yes" xml:space="preserve">
          <source>If the argument is &amp;plusmn;0, +0 is returned</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="310b79d192c0fa5a1ce6ca3877e2deb499d9d5f3" translate="yes" xml:space="preserve">
          <source>If the argument is &amp;plusmn;0, -&amp;infin; is returned and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_DIVBYZERO&lt;/a&gt;&lt;/code&gt; is raised.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e20d184a4efd311faacd5da72518930f348cac5a" translate="yes" xml:space="preserve">
          <source>If the argument is &amp;plusmn;0, 1 is returned</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3f53d74b0dca3908c99b1e364989b3591808e1e" translate="yes" xml:space="preserve">
          <source>If the argument is &amp;plusmn;0, it is returned unmodified</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ccd73690fa7a557641f2fe90d1fb0da76c7573ad" translate="yes" xml:space="preserve">
          <source>If the argument is &amp;plusmn;0, it is returned, unmodified</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="666ec3240c22502f1099c8da74484f25ff980d70" translate="yes" xml:space="preserve">
          <source>If the argument is &amp;plusmn;1, a pole error occurs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16671d13b546303a8dbbbb41028ae78cbf067eb9" translate="yes" xml:space="preserve">
          <source>If the argument is +&amp;infin; or &amp;plusmn;0, it is returned, unmodified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54b0607c64e592ab2e8d7944a7583de099ef78bc" translate="yes" xml:space="preserve">
          <source>If the argument is +&amp;infin;, +&amp;infin; is returned</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa21d5b0bb57bf219f506cda16da2521284b89b4" translate="yes" xml:space="preserve">
          <source>If the argument is +&amp;infin;, +&amp;infin; is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="540557a8bd62a5b0f36f5bd102aec659ebb950db" translate="yes" xml:space="preserve">
          <source>If the argument is +&amp;infin;, +&amp;pi;/2 is returned</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7199243658fb47291089c2b185fa5cf8110be042" translate="yes" xml:space="preserve">
          <source>If the argument is +&amp;infin;, +0 is returned</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4be25ee19a8f2e9c79ffae1bfa98e41cff590c7" translate="yes" xml:space="preserve">
          <source>If the argument is +1, the value &lt;code&gt;+0&lt;/code&gt; is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09765a27421db439d2ceef1decf36c6c5400ca31" translate="yes" xml:space="preserve">
          <source>If the argument is -&amp;infin;, +0 is returned</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab67da2ac08a598b0aeee9a84a5ea4203889b128" translate="yes" xml:space="preserve">
          <source>If the argument is -&amp;infin;, -&amp;pi;/2 is returned</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c52a07d7a9cd046aa4f61618e846c887cf3ca1d0" translate="yes" xml:space="preserve">
          <source>If the argument is -&amp;infin;, -1 is returned</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3cb7272c20346f5eded435e9a2ce5990a13f544b" translate="yes" xml:space="preserve">
          <source>If the argument is -&amp;infin;, 2 is returned</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b59bb47bb4f9b237288770872fa9592f179ad22" translate="yes" xml:space="preserve">
          <source>If the argument is -&amp;infin;, NaN is returned and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; is raised</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2728e75a63954aabe83e882896db0bf09fd9c3f9" translate="yes" xml:space="preserve">
          <source>If the argument is -1, -&amp;infin; is returned and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_DIVBYZERO&lt;/a&gt;&lt;/code&gt; is raised.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dad9f0dbcbb32af831ea87c9b1abd3643a5b7b20" translate="yes" xml:space="preserve">
          <source>If the argument is 1, +0 is returned</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="290ee1b584ad39adb2720da091bea3742f568b9f" translate="yes" xml:space="preserve">
          <source>If the argument is 2, +0 is returned</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f6074320a813a4e58ce3f8235a3e40354fe9d12" translate="yes" xml:space="preserve">
          <source>If the argument is NaN, NaN is returned</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f630be49c2abd923603f430a83802a576f8d8a5b" translate="yes" xml:space="preserve">
          <source>If the argument is a negative integer, +&amp;infin; is returned and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_DIVBYZERO&lt;/a&gt;&lt;/code&gt; is raised</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3cb5a23f7100fda931d00bdcf1949dd71d061ad" translate="yes" xml:space="preserve">
          <source>If the argument is a negative integer, NaN is returned and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; is raised</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20646ae3669e13c85917f45de5026134f970fd91" translate="yes" xml:space="preserve">
          <source>If the argument is less than -0, &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; is raised and NaN is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d60f1479d7ad633bb20dc263baae8366ce50fe47" translate="yes" xml:space="preserve">
          <source>If the argument is less than -1, NaN is returned and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; is raised.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82e61b5e3d8efb3126389ca46e457ed7c53253b6" translate="yes" xml:space="preserve">
          <source>If the argument is less than 1, a domain error occurs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ca2273cafe3374e2295b541c384fca2773d84f3" translate="yes" xml:space="preserve">
          <source>If the argument is negative, NaN is returned and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; is raised.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ce877c1c558f9ec930d2aac72c101f35a2f7812" translate="yes" xml:space="preserve">
          <source>If the argument is not on the interval [-1, +1], a range error occurs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2199aba2bc9bf0df1d73b9c3777d78213c53216a" translate="yes" xml:space="preserve">
          <source>If the array contains several elements that &lt;code&gt;comp&lt;/code&gt; would indicate as equal to the element searched for, then it is unspecified which element the function will return as the result.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7a938d361647e59fdfb270dd850072137c9ecac" translate="yes" xml:space="preserve">
          <source>If the array was declared &lt;a href=&quot;storage_duration&quot;&gt;register&lt;/a&gt;, the behavior is undefined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c828d39720091190e6dcd291852f42239651509b" translate="yes" xml:space="preserve">
          <source>If the array was declared &lt;a href=&quot;storage_duration&quot;&gt;register&lt;/a&gt;, the behavior of the program that attempts such conversion is undefined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6074bc08a4061ed8b2bf04b357ba914834dcf0c1" translate="yes" xml:space="preserve">
          <source>If the comma operator has to be used in such context, it must be parenthesized:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36aec2ae635c40cb65f7125374328a3bd9489d46" translate="yes" xml:space="preserve">
          <source>If the compiler defines the macro constant &lt;code&gt;__STDC_NO_VLA__&lt;/code&gt; to integer constant &lt;code&gt;1&lt;/code&gt;, then VLA and VM types are not supported.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0102b5739cc3bf6169af43e213ce8f4a4202795a" translate="yes" xml:space="preserve">
          <source>If the compiler performs function inlining, it replaces a call of that function with its body, avoiding the overhead of a function call (placing data on stack and retrieving the result), which may result in a larger executable as the code for the function has to be repeated multiple times. The result is similar to &lt;a href=&quot;../preprocessor/replace&quot;&gt;function-like macros&lt;/a&gt;, except that identifiers and macros used in the function refer to the definitions visible at the point of definition, not at the point of call.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d89aa9b9998e409f83a89bb9d2cdac3e91f09898" translate="yes" xml:space="preserve">
          <source>If the compiler supports analyzability, any language or library construct whose behavior is undefined is further classified between</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59ee7a8220ba62d01c495a46ec65cf3fc585bffb" translate="yes" xml:space="preserve">
          <source>If the conversion to &lt;code&gt;time_t&lt;/code&gt; is successful, the &lt;code&gt;time&lt;/code&gt; object is modified. All fields of &lt;code&gt;time&lt;/code&gt; are updated to fit their proper ranges. &lt;code&gt;time-&amp;gt;tm_wday&lt;/code&gt; and &lt;code&gt;time-&amp;gt;tm_yday&lt;/code&gt; are recalculated using information available in other fields.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6192b4cbcd6b133ff7698ce09fce768219ba252e" translate="yes" xml:space="preserve">
          <source>If the converted value falls out of range of corresponding return type, a range error occurs (setting &lt;code&gt;&lt;a href=&quot;../../error/errno&quot;&gt;errno&lt;/a&gt;&lt;/code&gt; to &lt;code&gt;&lt;a href=&quot;../../error/errno_macros&quot;&gt;ERANGE&lt;/a&gt;&lt;/code&gt;) and &lt;code&gt;&lt;a href=&quot;../../types/integer&quot;&gt;INTMAX_MAX&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../../types/integer&quot;&gt;INTMAX_MIN&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../../types/integer&quot;&gt;UINTMAX_MAX&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;​0​&lt;/code&gt; is returned, as appropriate.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63ccc0cb218c965f911fab62a19044ef04c5af35" translate="yes" xml:space="preserve">
          <source>If the converted value falls out of range of corresponding return type, a range error occurs (setting &lt;code&gt;&lt;a href=&quot;../../error/errno&quot;&gt;errno&lt;/a&gt;&lt;/code&gt; to &lt;code&gt;&lt;a href=&quot;../../error/errno_macros&quot;&gt;ERANGE&lt;/a&gt;&lt;/code&gt;) and &lt;code&gt;&lt;a href=&quot;../../types/limits&quot;&gt;LONG_MAX&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../../types/limits&quot;&gt;LONG_MIN&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../../types/limits&quot;&gt;LLONG_MAX&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../../types/limits&quot;&gt;LLONG_MIN&lt;/a&gt;&lt;/code&gt; is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca46624d6b0c110c8fee9d6430d211ff036c4ba4" translate="yes" xml:space="preserve">
          <source>If the correct result is greater than &lt;code&gt;&lt;a href=&quot;../../types/limits&quot;&gt;INT_MAX&lt;/a&gt;&lt;/code&gt; or smaller than &lt;code&gt;&lt;a href=&quot;../../types/limits&quot;&gt;INT_MIN&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; is raised.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c7f3d1a2ebc058a3464f5e25a82d02e716648fa" translate="yes" xml:space="preserve">
          <source>If the correct result is greater than &lt;code&gt;&lt;a href=&quot;../../types/limits&quot;&gt;INT_MAX&lt;/a&gt;&lt;/code&gt; or smaller than &lt;code&gt;&lt;a href=&quot;../../types/limits&quot;&gt;INT_MIN&lt;/a&gt;&lt;/code&gt;, a domain error or a range error may occur.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="191fa266d736718757385767dd6a59cc886d46d0" translate="yes" xml:space="preserve">
          <source>If the correct result is greater than &lt;code&gt;&lt;a href=&quot;../../types/limits&quot;&gt;INT_MAX&lt;/a&gt;&lt;/code&gt; or smaller than &lt;code&gt;&lt;a href=&quot;../../types/limits&quot;&gt;INT_MIN&lt;/a&gt;&lt;/code&gt;, the return value is unspecified and a domain error or range error may occur.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a6cae9283a2623af917462111836ee3e70aa764" translate="yes" xml:space="preserve">
          <source>If the current rounding mode is &lt;code&gt;&lt;a href=&quot;../fenv/fe_round&quot;&gt;FE_TONEAREST&lt;/a&gt;&lt;/code&gt;, this function rounds to even in halfway cases (like &lt;code&gt;&lt;a href=&quot;rint&quot;&gt;rint&lt;/a&gt;&lt;/code&gt;, but unlike &lt;code&gt;&lt;a href=&quot;round&quot;&gt;round&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2333eb5beb6ae4621087ed67aea4b57771b1571" translate="yes" xml:space="preserve">
          <source>If the current rounding mode is...</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97a0aa7f8fe1a9bd6dbbecffec65b2ca11d005be" translate="yes" xml:space="preserve">
          <source>If the declarator or type specifier that declares the identifier appears outside of any block or list of parameters, the identifier has file scope, which terminates at the end of the translation unit.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="253bb460db1572bc8ca06ca717632f07e694bb79" translate="yes" xml:space="preserve">
          <source>If the elements of an array are arrays, structs, or unions, the corresponding initializers in the brace-enclosed list of initializers are any initializers that are valid for those members, except that their braces may be omitted as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc06f1d466f19d96e2bb2f450cc3e5f9c16ffbc6" translate="yes" xml:space="preserve">
          <source>If the environment macro &lt;code&gt;__STDC_ISO_10646__&lt;/code&gt; is defined, the values of type &lt;code&gt;wchar_t&lt;/code&gt; are the same as the short identifiers of the characters in the Unicode required set (typically UTF-32 encoding); otherwise, it is implementation-defined. In any case, the multibyte character encoding used by this function is specified by the currently active C locale.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1127060a7a07a58c7bb8e11a04aa886b4480ab05" translate="yes" xml:space="preserve">
          <source>If the execution of the loop needs to be continued at the end of the loop body, &lt;a href=&quot;continue&quot;&gt; continue statement&lt;/a&gt; can be used as a shortcut.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ee3147a9a7672459eeee8081c98eac6e3e82425" translate="yes" xml:space="preserve">
          <source>If the execution of the loop needs to be terminated at some point, &lt;a href=&quot;break&quot;&gt; break statement&lt;/a&gt; can be used as a terminating statement.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94e3914e819b4e9c6f38a7c7d3a8f66bfec35d72" translate="yes" xml:space="preserve">
          <source>If the execution of the loop needs to be terminated at some point, &lt;a href=&quot;break&quot;&gt; break statement&lt;/a&gt; can be used as terminating statement.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82682fec524d889a1cf2cfe1b3e0b122ffe26584" translate="yes" xml:space="preserve">
          <source>If the execution of the loop needs to be terminated at some point, a &lt;a href=&quot;break&quot;&gt; break statement&lt;/a&gt; can be used anywhere within the loop_statement.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8bb904e3ab541e5036d8b9cca126affda663bc33" translate="yes" xml:space="preserve">
          <source>If the exponent is present and fractional part is not used, the decimal separator may be omitted:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a165ff8440c9b7e05a409264009f6217873d188b" translate="yes" xml:space="preserve">
          <source>If the external definition exists in the program, the address of the function is always the address of the external function, but when this address is used to make a function call, it's unspecified whether the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2b1b61632e47d98b991cfabb43ddaa1fc1c9b3b" translate="yes" xml:space="preserve">
          <source>If the failure has been caused by end of file condition, additionally sets the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90c9cca36bdb9f6f7d9748c18430b538e7979538" translate="yes" xml:space="preserve">
          <source>If the failure has been caused by end-of-file condition, additionally sets the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="994d9bf8337b9cacbb5385430d81add1cb5bd997" translate="yes" xml:space="preserve">
          <source>If the failure has been caused by some other error, sets the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="830435d4a1387d881331880059f8a2aaf6456533" translate="yes" xml:space="preserve">
          <source>If the file is currently open by this or another process, the behavior of this function is implementation-defined (in particular, POSIX systems unlink the file name although the file system space is not reclaimed until the last running process closes the file; Windows does not allow the file to be deleted).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6020291574132d5834e014d6c7f58d404fb0a67b" translate="yes" xml:space="preserve">
          <source>If the first character of the set is &lt;code&gt;^&lt;/code&gt;, then all characters not in the set are matched. If the set begins with &lt;code&gt;]&lt;/code&gt; or &lt;code&gt;^]&lt;/code&gt; then the &lt;code&gt;]&lt;/code&gt; character is also included into the set. It is implementation-defined whether the character &lt;code&gt;-&lt;/code&gt; in the non-initial position in the scanset may be indicating a range, as in &lt;code&gt;[0-9]&lt;/code&gt;. If width specifier is used, matches only up to</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d64e081a56bac75f7eaed846b2b99e805513c5d7" translate="yes" xml:space="preserve">
          <source>If the function that called &lt;code&gt;&lt;a href=&quot;setjmp&quot;&gt;setjmp&lt;/a&gt;&lt;/code&gt; has exited (whether by return or by a different &lt;code&gt;longjmp&lt;/code&gt; higher up the stack), the behavior is undefined. In other words, only long jumps up the call stack are allowed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1269621bdc65581d6c1d260b7209ad814afbd640" translate="yes" xml:space="preserve">
          <source>If the host environment cannot supply both lowercase and uppercase letters, the command line arguments are converted to lowercase.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d83c11796c2c1e3f318ffcc89e81bbd5f8b11e8" translate="yes" xml:space="preserve">
          <source>If the implementation does not support floating-point infinities, the macro &lt;code&gt;INFINITY&lt;/code&gt; expands to a positive value that is guaranteed to overflow a &lt;code&gt;float&lt;/code&gt; at compile time, and the use of this macro generates a compiler warning.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19ffe219703efe6527e00547f4a8cca5d22a9042" translate="yes" xml:space="preserve">
          <source>If the implementation supports IEEE floating-point arithmetic (IEC 60559),</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="699c67e4aaf9791f00393d5529c1c7e718fbd3d8" translate="yes" xml:space="preserve">
          <source>If the implementation supports IEEE floating-point arithmetic (IEC 60559),   For the &lt;code&gt;rint&lt;/code&gt; function:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe61740055acdc39bc5f3b3cf183ae13ff9c59a6" translate="yes" xml:space="preserve">
          <source>If the implementation supports IEEE floating-point arithmetic (IEC 60559),   For the &lt;code&gt;round&lt;/code&gt;, &lt;code&gt;roundf&lt;/code&gt;, and &lt;code&gt;roundl&lt;/code&gt; function:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7685e11635ec992c012cd0e03140bd9ce1479a3" translate="yes" xml:space="preserve">
          <source>If the implementation supports IEEE floating-point arithmetic (IEC 60559), &lt;code&gt;math_errhandling &amp;amp; MATH_ERREXCEPT&lt;/code&gt; is required to be non-zero.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="452d571ea8f52d84cf9e46de2bbbf6be56c3970a" translate="yes" xml:space="preserve">
          <source>If the implementation supports IEEE floating-point arithmetic,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7392bc849012f8a7b52172fc01358b19f1c644b0" translate="yes" xml:space="preserve">
          <source>If the implementation supports floating-point infinities, the macro &lt;code&gt;INFINITY&lt;/code&gt; expands to constant expression of type &lt;code&gt;float&lt;/code&gt; which evaluates to positive or unsigned infinity.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6346069140ef89aa4a40fbb67316690947509e3" translate="yes" xml:space="preserve">
          <source>If the input has been parsed into preprocessing tokens up to a given character, the next preprocessing token is generally taken to be the longest sequence of characters that could constitute a preprocessing token, even if that would cause subsequent analysis to fail. This is commonly known as</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b0cfd9b08932b3884431c92475183560f1d46ce" translate="yes" xml:space="preserve">
          <source>If the last thread in the program is terminated with &lt;code&gt;thrd_exit&lt;/code&gt;, the entire program terminates as if by calling &lt;code&gt;&lt;a href=&quot;../program/exit&quot;&gt;exit&lt;/a&gt;&lt;/code&gt; with &lt;code&gt;&lt;a href=&quot;../program/exit_status&quot;&gt;EXIT_SUCCESS&lt;/a&gt;&lt;/code&gt; as the argument (so the functions registered by &lt;code&gt;&lt;a href=&quot;../program/atexit&quot;&gt;atexit&lt;/a&gt;&lt;/code&gt; are executed in the context of that last thread).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0092ff30ced4b5b7eeebddab8461805c98ccc03" translate="yes" xml:space="preserve">
          <source>If the left operand is &lt;a href=&quot;const&quot;&gt;const&lt;/a&gt; or &lt;a href=&quot;volatile&quot;&gt;volatile&lt;/a&gt; qualified, the result is also qualified. If the left operand is &lt;a href=&quot;atomic&quot;&gt;atomic&lt;/a&gt;, the behavior is undefined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc3d85ef243667631214a89b35ad48243e455197" translate="yes" xml:space="preserve">
          <source>If the length specifier &lt;code&gt;l&lt;/code&gt; is not used, the conversion specifiers &lt;code&gt;c&lt;/code&gt;, &lt;code&gt;s&lt;/code&gt;, and &lt;code&gt;[&lt;/code&gt; perform wide-to-multibyte character conversion as if by calling &lt;a href=&quot;../string/multibyte/wcrtomb&quot;&gt;&lt;code&gt;wcrtomb()&lt;/code&gt;&lt;/a&gt; with an &lt;a href=&quot;../string/multibyte/mbstate_t&quot;&gt;&lt;code&gt;mbstate_t&lt;/code&gt;&lt;/a&gt; object initialized to zero before the first character is converted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eca68afe6b8894fe105ba600b6be6acbcaded6f7" translate="yes" xml:space="preserve">
          <source>If the lvalue designates an object of automatic storage duration whose address was never taken and if that object was uninitialized (not declared with an initializer and no assignment to it has been performed prior to use), the behavior is undefined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6c5c610adf8c7fe59ee2c1e9abdf35cbc323127" translate="yes" xml:space="preserve">
          <source>If the lvalue has incomplete type, the behavior is undefined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01cf236a859f8973431548739aa1a2bd6773cac2" translate="yes" xml:space="preserve">
          <source>If the macro &lt;code&gt;__STDC_UTF_16__&lt;/code&gt; is defined, the 16-bit encoding used by this function is UTF-16; otherwise, it is implementation-defined. In any case, the multibyte character encoding used by this function is specified by the currently active C locale.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9aa2e0435d88c88dcdb4fbdbb133c8a127f19150" translate="yes" xml:space="preserve">
          <source>If the macro &lt;code&gt;__STDC_UTF_32__&lt;/code&gt; is defined, the 32-bit encoding used by this function is UTF-32; otherwise, it is implementation-defined. In any case, the multibyte character encoding used by this function is specified by the currently active C locale.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="651db3f0d9f9ede3dcfc008c0798405a073761da" translate="yes" xml:space="preserve">
          <source>If the macro constant &lt;code&gt;__STDC_NO_ATOMICS__&lt;/code&gt;(C11) is defined by the compiler, the header &lt;code&gt;&amp;lt;stdatomic.h&amp;gt;&lt;/code&gt;, the keyword &lt;code&gt;_Atomic&lt;/code&gt;, and all of the names listed here are not provided.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="549a81d60d09906925c9492d7b11e76f4c974fe0" translate="yes" xml:space="preserve">
          <source>If the macro constant &lt;code&gt;__STDC_NO_ATOMICS__&lt;/code&gt;(C11) is defined by the compiler, the keyword &lt;code&gt;_Atomic&lt;/code&gt; as well as the header &lt;code&gt;&amp;lt;stdatomic.h&amp;gt;&lt;/code&gt;, is not provided.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54c6fb244ea5ef05e85ae5bec7afb39dca30e410" translate="yes" xml:space="preserve">
          <source>If the macro constant &lt;code&gt;__STDC_NO_COMPLEX__&lt;/code&gt; is defined by the implementation, the complex types, the header &lt;code&gt;&amp;lt;complex.h&amp;gt;&lt;/code&gt; and all of the names listed here are not provided.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3b81b34a2269058d8e0301809518279ee9143b0" translate="yes" xml:space="preserve">
          <source>If the macro constant &lt;code&gt;__STDC_NO_COMPLEX__&lt;/code&gt;(C11) is defined by the implementation, the complex types (as well as the library header &lt;code&gt;&amp;lt;complex.h&amp;gt;&lt;/code&gt;) are not provided.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1231e4ddd7fa2aa6ee9ba3a4d709933bfbf0374c" translate="yes" xml:space="preserve">
          <source>If the macro constant &lt;code&gt;__STDC_NO_THREADS__&lt;/code&gt;(C11) is defined by the compiler, the header &lt;code&gt;&amp;lt;threads.h&amp;gt;&lt;/code&gt; and all of the names listed here are not provided.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51f37b450edb52b954b68e62d69c5c0202f834d2" translate="yes" xml:space="preserve">
          <source>If the main function executes a &lt;code&gt;return&lt;/code&gt; that specifies no value or, which is the same, reaches the terminating &lt;code&gt;}&lt;/code&gt; without executing a &lt;code&gt;return&lt;/code&gt;, the termination status returned to the host environment is undefined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9dd09fa95e725157b1639c229069abbb48976b07" translate="yes" xml:space="preserve">
          <source>If the member used to access the contents of a union is not the same as the member last used to store a value, the object representation of the value that was stored is reinterpreted as an object representation of the new type (this is known as</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b562f8affe8bf1ade0fe85a6dfe88e871afc3d0" translate="yes" xml:space="preserve">
          <source>If the members of the struct or union are arrays, structs, or unions, the corresponding initializers in the brace-enclosed list of initializers are any initializers that are valid for those members, except that their braces may be omitted as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df9b6d81c45a06a726423ecec58eacc4756ca95f" translate="yes" xml:space="preserve">
          <source>If the minus sign was part of the input sequence, the numeric value calculated from the sequence of digits is negated as if by &lt;a href=&quot;../../language/operator_arithmetic#Unary_arithmetic&quot;&gt;unary minus&lt;/a&gt; in the result type, which applies unsigned integer wraparound rules.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d8c026dab9455903edcd7b942a6e7d2b308ef69" translate="yes" xml:space="preserve">
          <source>If the minus sign was part of the input sequence, the numeric value calculated from the sequence of digits is negated as if by &lt;a href=&quot;../../language/operator_arithmetic#Unary_arithmetic&quot;&gt;unary minus&lt;/a&gt; in the result type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="312e4e4f74f5b82f6bd25b87461c9b4fbde989e6" translate="yes" xml:space="preserve">
          <source>If the multibyte character in &lt;code&gt;*s&lt;/code&gt; corresponds to a multi-char16_t sequence (e.g. a surrogate pair in UTF-16), then after the first call to this function, &lt;code&gt;*ps&lt;/code&gt; is updated in such a way that the next call to &lt;code&gt;mbrtoc16&lt;/code&gt; will write out the additional char16_t, without considering &lt;code&gt;*s&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bcb6afe2a5acb943ad2fdd6f475921c6ce71ebf8" translate="yes" xml:space="preserve">
          <source>If the multibyte character in &lt;code&gt;*s&lt;/code&gt; corresponds to a multi-char32_t sequence (not possible with UTF-32), then after the first call to this function, &lt;code&gt;*ps&lt;/code&gt; is updated in such a way that the next calls to &lt;code&gt;mbrtoc32&lt;/code&gt; will write out the additional char32_t, without considering &lt;code&gt;*s&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="304955bf3a45b6b20b8586f86759d6a1a4e81f15" translate="yes" xml:space="preserve">
          <source>If the nested initializer begins with an opening brace, the entire nested initializer up to its closing brace initializes the corresponding array element:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="933c4fa6a66cfd77beaa3fe517c80ce5e0abfbb6" translate="yes" xml:space="preserve">
          <source>If the nested initializer begins with an opening brace, the entire nested initializer up to its closing brace initializes the corresponding member object. Each left opening brace establishes a new</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="151921afc39167d8205cd587ad8ad524dd37f8ab" translate="yes" xml:space="preserve">
          <source>If the nested initializer does not begin with an opening brace, only enough initializers from the list are taken to account for the elements or members of the member array, struct or union; any remaining initializers are left to initialize the next struct member:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d36da4c4053cda43da536fac84e436ea42130de" translate="yes" xml:space="preserve">
          <source>If the nested initializer does not begin with an opening brace, only enough initializers from the list are taken to account for the elements or members of the sub-array, struct or union; any remaining initializers are left to initialize the next array element:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80732b9a6ea0bd32db8b85caa6c27f1714c901e0" translate="yes" xml:space="preserve">
          <source>If the object is never modified, it may be aliased and accessed through different restrict-qualified pointers (note that if the objects pointed to by aliased restrict-qualified pointers are, in turn, pointers, this aliasing can inhibit optimization).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e99470df4e3d3e9a6241b3fc568484134bda99cc" translate="yes" xml:space="preserve">
          <source>If the object was created by a &lt;a href=&quot;declarations&quot;&gt;declaration&lt;/a&gt;, the declared type of that object is the object's</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21dde2db6c5eec120e8008d864b1ea6006fc747f" translate="yes" xml:space="preserve">
          <source>If the object was created by an &lt;a href=&quot;../memory&quot;&gt;allocation function&lt;/a&gt; (including &lt;code&gt;&lt;a href=&quot;../memory/realloc&quot;&gt;realloc&lt;/a&gt;&lt;/code&gt;), it has no declared type. Such object acquires an effective type as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07637ee8af1e302a0a5a769400ebcb2f44a92f13" translate="yes" xml:space="preserve">
          <source>If the operand is an array index expression, no action is taken other than the array-to-pointer conversion and the addition, so &amp;amp;a[N] is valid for an array of size N (obtaining a pointer one past the end is okay, dereferencing it is not, but dereference cancels out in this expression).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="880e10035a2f45d57c976bf239aeb18adfa8e76c" translate="yes" xml:space="preserve">
          <source>If the operand is the dereference operator, no action is taken (so it's okay to apply &amp;amp;* to a null pointer), except that the result is not an lvalue.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b113388f82173776cc247c5cef46e3268d0b48fb" translate="yes" xml:space="preserve">
          <source>If the orientation of the stream has already been decided (by executing output or by an earlier call to fwide), this function does nothing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d599043942f481f6b0419f90b76a322525485e59" translate="yes" xml:space="preserve">
          <source>If the pointer &lt;code&gt;P1&lt;/code&gt; points at an element of an array with index &lt;code&gt;I&lt;/code&gt; (or one past the end) and &lt;code&gt;P2&lt;/code&gt; points at an element of the same array with index &lt;code&gt;J&lt;/code&gt; (or one past the end), then</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cdb9c5ce8b4b941a74dbd485a5daa17a5fa7a8b0" translate="yes" xml:space="preserve">
          <source>If the pointer &lt;code&gt;P&lt;/code&gt; points at an element of an array with index &lt;code&gt;I&lt;/code&gt;, then</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c7b266d1b59c8d3597834929777fbdb4b7e7282" translate="yes" xml:space="preserve">
          <source>If the quotient &lt;code&gt;a/b&lt;/code&gt; is not representable in the result type, the behavior of both &lt;code&gt;a/b&lt;/code&gt; and &lt;code&gt;a%b&lt;/code&gt; is undefined (that means &lt;code&gt;INT_MIN%-1&lt;/code&gt; is undefined on 2's complement systems).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ffc31d0b868412a85aac63a2d15275575b7998d" translate="yes" xml:space="preserve">
          <source>If the result of &lt;code&gt;lrint&lt;/code&gt; or &lt;code&gt;llrint&lt;/code&gt; is outside the range representable by the return type, a domain error or a range error may occur.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="622ba0546ebe6337384487d2c74de396ef013e92" translate="yes" xml:space="preserve">
          <source>If the result of &lt;code&gt;lround&lt;/code&gt; or &lt;code&gt;llround&lt;/code&gt; is outside the range representable by the return type, a domain error or a range error may occur.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8eeeae32aeed1e098fc91dd8bd921c86fb200e23" translate="yes" xml:space="preserve">
          <source>If the result of the rounding is outside the range of the return type, &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; is raised and an implementation-defined value is returned</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="028eee91596148e2d553d9c0585e4796bc1e1860" translate="yes" xml:space="preserve">
          <source>If the resulting value can be represented by the target type, that value is used</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e979bc95923b9d4b1835c4ad27806c96fcb36b2c" translate="yes" xml:space="preserve">
          <source>If the return statement is used, the return value is used as the argument to the implicit call to &lt;code&gt;&lt;a href=&quot;../program/exit&quot;&gt;exit()&lt;/a&gt;&lt;/code&gt; (see below for details). The values zero and &lt;code&gt;&lt;a href=&quot;../program/exit_status&quot;&gt;EXIT_SUCCESS&lt;/a&gt;&lt;/code&gt; indicate successful termination, the value &lt;code&gt;&lt;a href=&quot;../program/exit_status&quot;&gt;EXIT_FAILURE&lt;/a&gt;&lt;/code&gt; indicates unsuccessful termination.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e166793b1a3e247cb1aa8707ba705ca2a49e53a0" translate="yes" xml:space="preserve">
          <source>If the return type is a real floating type, the result may be represented in &lt;a href=&quot;../types/limits/flt_eval_method&quot;&gt;greater range and precision&lt;/a&gt; than implied by the new type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc834aece2679899b19365c0e96b6a9287c774b2" translate="yes" xml:space="preserve">
          <source>If the return type of the main function is not &lt;a href=&quot;compatible_type#Compatible_types&quot;&gt;compatible&lt;/a&gt; with &lt;code&gt;int&lt;/code&gt; (e.g. &lt;code&gt;void main(void)&lt;/code&gt;), the value returned to the host environment is unspecified. If the returned type is compatible with int and control reaches the terminating &lt;code&gt;}&lt;/code&gt;, the value returned to the environment is the same as if executing &lt;code&gt;return 0;&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55096951d03276844009d4ac6ef2f86a40234649" translate="yes" xml:space="preserve">
          <source>If the returned value is &lt;code&gt;0&lt;/code&gt;, it will have the same sign as &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c0d5f1db5857afe2a215a274d4b5151e584e7b1" translate="yes" xml:space="preserve">
          <source>If the same identifier appears with both internal and external linkage in the same translation unit, the behavior is undefined. This is possible when &lt;a href=&quot;extern&quot;&gt;tentative definitions&lt;/a&gt; are used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a404b81bd183a04af684a1dd83adbe457b397df0" translate="yes" xml:space="preserve">
          <source>If the second operand is zero, the behavior is undefined, except that if the IEEE floating-point arithmetic is supported, and the floating-point division is taking place, then.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87cda6e927c8b4be84e09f295f15129ed6308632" translate="yes" xml:space="preserve">
          <source>If the second operand is zero, the behavior is undefined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bfc275cb73a90eef9664528239ab4998157ab970" translate="yes" xml:space="preserve">
          <source>If the signal handler is called NOT as a result of &lt;code&gt;&lt;a href=&quot;abort&quot;&gt;abort&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;raise&quot;&gt;raise&lt;/a&gt;&lt;/code&gt; (in other words, the signal handler is</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88071f1c5c0e1b4839dab6e032d8012686be4323" translate="yes" xml:space="preserve">
          <source>If the signal handler is called as a result of &lt;code&gt;&lt;a href=&quot;abort&quot;&gt;abort&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;raise&quot;&gt;raise&lt;/a&gt;&lt;/code&gt;, the behavior is undefined if the signal handler calls &lt;code&gt;&lt;a href=&quot;raise&quot;&gt;raise&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da5426c0f7f65abd2bcb02b6bd8cb6318ab19838" translate="yes" xml:space="preserve">
          <source>If the significand begins with the character sequence &lt;code&gt;0x&lt;/code&gt; or &lt;code&gt;0X&lt;/code&gt;, the floating constant is a</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7d0de34374ff61db0aaf9670764de6bb336cc95" translate="yes" xml:space="preserve">
          <source>If the size expression of a VLA has side effects, they are guaranteed to be produced except when it is a part of a sizeof expression whose result doesn't depend on it:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5d5fbe264df8096d3f2dc04126bdd49bd7491ca" translate="yes" xml:space="preserve">
          <source>If the size is &lt;code&gt;*&lt;/code&gt;, the declaration is for a VLA of unspecified size. Such declaration may only appear in a function prototype scope, and declares an array of a complete type. In fact, all VLA declarators in function prototype scope are treated as if expression were replaced by &lt;code&gt;*&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5177cdc4e2a0570675a3bb78ff34b15988072e1" translate="yes" xml:space="preserve">
          <source>If the size of the array is known, it may be one less than the size of the string literal, in which case the terminating null character is ignored:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="721f1a0ff5ac2a85a4aec48dc758c5efa06cf129" translate="yes" xml:space="preserve">
          <source>If the stream is open in binary mode, the value obtained by this function is the number of bytes from the beginning of the file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fcf8e63ecc85a80b64f92483949ed9fe9401f63f" translate="yes" xml:space="preserve">
          <source>If the stream is open in text mode, the value returned by this function is unspecified and is only meaningful as the input to &lt;code&gt;&lt;a href=&quot;fseek&quot;&gt;fseek()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b376b7c229a7bc07ebacea949f846a78b0d1782c" translate="yes" xml:space="preserve">
          <source>If the strings overlap, the behavior is undefined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3737cc31b2abcb3a56ec3dc6ed19f293aa85246e" translate="yes" xml:space="preserve">
          <source>If the type is &lt;a href=&quot;compatible_type#Compatible_types&quot;&gt;compatible&lt;/a&gt; with the type-name of one of the associations, then the type, value, and &lt;a href=&quot;value_category&quot;&gt;value category&lt;/a&gt; of the generic selection are the type, value, and value category of the expression that appears after the colon for that type-name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1bc5654858ffa7d0d01ecee82edcb9b073576512" translate="yes" xml:space="preserve">
          <source>If the type of expression is a &lt;a href=&quot;array&quot;&gt;variable-length array&lt;/a&gt; type, expression is evaluated and the size of the array it evaluates to is calculated at run time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12f6e191f6df5a1a3c1898e9217cac07ed6c3fc9" translate="yes" xml:space="preserve">
          <source>If the type of the expression is different from the return type of the function, its value is &lt;a href=&quot;conversion&quot;&gt;converted&lt;/a&gt; as if by assignment to an object whose type is the return type of the function, except that overlap between object representations is permitted:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51577fdf94f044af450cebe5474487f90f5669ab" translate="yes" xml:space="preserve">
          <source>If the type of the next argument in &lt;code&gt;ap&lt;/code&gt; (after promotions) is not compatible with &lt;code&gt;T&lt;/code&gt;, the behavior is undefined, unless:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6bd916ae26104ecdafe1a0e5b920d8734a873e18" translate="yes" xml:space="preserve">
          <source>If the type pointed to by the left operand is &lt;a href=&quot;const&quot;&gt;const&lt;/a&gt; or &lt;a href=&quot;volatile&quot;&gt;volatile&lt;/a&gt; qualified, the result is also qualified. If the type pointed to by the left operand is &lt;a href=&quot;atomic&quot;&gt;atomic&lt;/a&gt;, the behavior is undefined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e5a8e1c4de47df9c049e89509b9c8c93ba2202d" translate="yes" xml:space="preserve">
          <source>If the types after promotion are the same, that type is the common type</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c7f76fec0807385297b756f7fec7a2af0fab97f" translate="yes" xml:space="preserve">
          <source>If the user defined function returns when handling &lt;code&gt;&lt;a href=&quot;sig_types&quot;&gt;SIGFPE&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;sig_types&quot;&gt;SIGILL&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;sig_types&quot;&gt;SIGSEGV&lt;/a&gt;&lt;/code&gt;, the behavior is undefined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a38ca87a09a320d9b2a80a0bbdbced081dc9f136" translate="yes" xml:space="preserve">
          <source>If the user-defined signal handling strategy is not set using &lt;code&gt;&lt;a href=&quot;signal&quot;&gt;signal()&lt;/a&gt;&lt;/code&gt; yet, it is implementation-defined whether the signal will be ignored or default handler will be invoked.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec13f6251a6825cdac88c61231a28276817e1093" translate="yes" xml:space="preserve">
          <source>If the value can be represented by the target type exactly, it is unchanged</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95ab164f16af6b727b63cdf344a7e218377e5641" translate="yes" xml:space="preserve">
          <source>If the value of base is &lt;code&gt;​0​&lt;/code&gt;, the numeric base is auto-detected: if the prefix is &lt;code&gt;0&lt;/code&gt;, the base is octal, if the prefix is &lt;code&gt;0x&lt;/code&gt; or &lt;code&gt;0X&lt;/code&gt;, the base is hexadecimal, otherwise the base is decimal.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7334be53a3a6aead6e653493f846debd16efe6cb" translate="yes" xml:space="preserve">
          <source>If the value of the integer constant is too big to fit in any of the types allowed by suffix/base combination and the compiler supports extended integer types (such as &lt;code&gt;__int128&lt;/code&gt;), the constant may be given the extended integer type; otherwise, the program is ill-formed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8c33ee241a255a63ad79ee3a3348d39830a7425" translate="yes" xml:space="preserve">
          <source>If the value to be stored in &lt;code&gt;*exp&lt;/code&gt; is outside the range of &lt;code&gt;int&lt;/code&gt;, the behavior is unspecified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb75958a443f6e86954852258d39617127eed64b" translate="yes" xml:space="preserve">
          <source>If the wide character produced is the null character, the conversion state &lt;code&gt;*ps&lt;/code&gt; represents the initial shift state.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24382f133af9ec92a179262afb80b489903f3a55" translate="yes" xml:space="preserve">
          <source>If the wide character produced is the null character, the conversion state stored in &lt;code&gt;*ps&lt;/code&gt; is the initial shift state.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed6eb838a4bf569f0ac9d8a6b0442beca067eff8" translate="yes" xml:space="preserve">
          <source>If there are no definitions in the same translation unit, then the tentative definition acts as an actual definition with the initializer &lt;code&gt;= 0&lt;/code&gt; (or, for array, structure, and union types, &lt;code&gt;= {0}&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ad5bb4cb8a4c8fd94ac2c60706e21c574d83a99" translate="yes" xml:space="preserve">
          <source>If there are threads waiting on &lt;code&gt;cond&lt;/code&gt;, the behavior is undefined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88ca6553aa1a0106ab7a752d78d47abe8b72c1f7" translate="yes" xml:space="preserve">
          <source>If there are threads waiting on &lt;code&gt;mutex&lt;/code&gt;, the behavior is undefined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61d2beb5e2bdfe94bb416348038a9626b5e9e8b4" translate="yes" xml:space="preserve">
          <source>If there is no corresponding call to &lt;code&gt;va_start&lt;/code&gt; or &lt;code&gt;va_copy&lt;/code&gt;, or if &lt;code&gt;va_end&lt;/code&gt; is not called before a function that calls &lt;code&gt;va_start&lt;/code&gt; or &lt;code&gt;va_copy&lt;/code&gt; returns, the behavior is undefined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08e7e744ae0e0c5037802c6defe497d81baa4ef8" translate="yes" xml:space="preserve">
          <source>If there is not enough memory, the old memory block is not freed and null pointer is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee7516e91d5c31a3de2564cfd0a851bd2bacc6e3" translate="yes" xml:space="preserve">
          <source>If there was a &lt;code&gt;memory_order_seq_cst&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;atomic_thread_fence&quot;&gt;atomic_thread_fence&lt;/a&gt;&lt;/code&gt; operation X</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="841f871b77e90b3c2ebee1d6abab2424892ee08b" translate="yes" xml:space="preserve">
          <source>If two declarations refer to the same object or function and do not use compatible types, the behavior of the program is undefined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="223e129549fa6e80a770c99896328737e1358c03" translate="yes" xml:space="preserve">
          <source>If two different entities named by the same identifier are in scope at the same time, and they belong to the same &lt;a href=&quot;name_space&quot;&gt;name space&lt;/a&gt;, the scopes are nested (no other form of scope overlap is allowed), and the declaration that appears in the inner scope hides the declaration that appears in the outer scope:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9555605dc10e8d1cfa1ba2ec453aef90da3623dc" translate="yes" xml:space="preserve">
          <source>If two objects have the same object representation, they compare equal (except if they are floating-point NaNs). The opposite is not true: two objects that compare equal may have different object representations because not every bit of the object representation needs to participate in the value. Such bits may be used for padding to satisfy alignment requirement, for parity checks, to indicate trap representations, etc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98ae7c89c9a1f0579125868580a2c5d0580d1b22" translate="yes" xml:space="preserve">
          <source>If type is a &lt;a href=&quot;array&quot;&gt;VLA&lt;/a&gt; type and changing the value of its size expression would not affect the result of sizeof, it is unspecified whether or not the size expression is evaluated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="daf8fb6ff7350d1f9d6d831812256477f230a799" translate="yes" xml:space="preserve">
          <source>If type is a &lt;a href=&quot;array&quot;&gt;VLA&lt;/a&gt; type, its size expression is not evaluated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45544c60e34e062c2ebe20cb821c8b11c8086f96" translate="yes" xml:space="preserve">
          <source>If type-name is &lt;code&gt;void&lt;/code&gt;, then expression is evaluated for its side-effects and its returned value is discarded, same as when expression is used on its own, as an &lt;a href=&quot;statements#Expression_statements&quot;&gt;expression statement&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f66ab74451a3db452059ec3845f07a89e06bbf3" translate="yes" xml:space="preserve">
          <source>If wc is the null wide character &lt;code&gt;L'\0'&lt;/code&gt;, a null byte is stored, preceded by any shift sequence necessary to restore the initial shift state and the conversion state parameter &lt;code&gt;*ps&lt;/code&gt; is updated to represent the initial shift state.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d7984b921742f401d05ed8114115076c505fbda" translate="yes" xml:space="preserve">
          <source>If when &lt;code&gt;&lt;a href=&quot;setjmp&quot;&gt;setjmp&lt;/a&gt;&lt;/code&gt; was called, a &lt;a href=&quot;../language/array&quot;&gt;VLA&lt;/a&gt; or another &lt;a href=&quot;../language/declarations&quot;&gt;variably-modified type&lt;/a&gt; variable was in scope and control left that scope, &lt;code&gt;longjmp&lt;/code&gt; to that &lt;code&gt;setjmp&lt;/code&gt; invokes undefined behavior even if control remained within the function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32c015539aa6def36ac45f02ee69383d444c9a17" translate="yes" xml:space="preserve">
          <source>If width specifier is used, matches up to</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80643aeb5f10297c8773a32774b36761e19c9f6e" translate="yes" xml:space="preserve">
          <source>If x is zero and y is infinite or if x is infinite and y is zero, and z is a NaN, then NaN is returned and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; may be raised</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="217b0f1a492e46dd9c7d22b89fac1d204972e19f" translate="yes" xml:space="preserve">
          <source>If x is zero and y is infinite or if x is infinite and y is zero, and z is not a NaN, then NaN is returned and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; is raised</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46f35d1f1e835536b48c1d1451cead305f826b6a" translate="yes" xml:space="preserve">
          <source>If x or y are NaN, NaN is returned</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="448389c4ec48e9adff6b8542b1d7d5e0005baf1b" translate="yes" xml:space="preserve">
          <source>If x*y is an exact infinity and z is an infinity with the opposite sign, NaN is returned and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; is raised</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dee1d062b9bd3ef2ac4463366425592d8bf6079d" translate="yes" xml:space="preserve">
          <source>If z is NaN, and x*y aren't 0*Inf or Inf*0, then NaN is returned (without FE_INVALID)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fede8b50b6882e5d3ce2a02e4778a6b33e6bfd1e" translate="yes" xml:space="preserve">
          <source>If |arg| &amp;gt; 1, a domain error occurs and NaN is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24d2b4c0d32e555ffdf12e4f24627c557a463748" translate="yes" xml:space="preserve">
          <source>If, after copying the terminating null character from &lt;code&gt;src&lt;/code&gt;, &lt;code&gt;count&lt;/code&gt; is not reached, additional null characters are written to &lt;code&gt;dest&lt;/code&gt; until the total of &lt;code&gt;count&lt;/code&gt; characters have been written.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6321b986a2eb461234e0b8b628d35dcf35b6aeb" translate="yes" xml:space="preserve">
          <source>If, after copying the terminating null wide character from &lt;code&gt;src&lt;/code&gt;, &lt;code&gt;count&lt;/code&gt; is not reached, additional null wide characters are written to &lt;code&gt;dest&lt;/code&gt; until the total of &lt;code&gt;count&lt;/code&gt; characters have been written.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80a00e268ece0e7d2466a182844868cebe8b45a3" translate="yes" xml:space="preserve">
          <source>If, after this, there remain keys with both non-null destructors and values (e.g. if a destructor executed &lt;code&gt;&lt;a href=&quot;tss_set&quot;&gt;tss_set&lt;/a&gt;&lt;/code&gt;), the process is repeated up to &lt;code&gt;&lt;a href=&quot;tss_dtor_iterations&quot;&gt;TSS_DTOR_ITERATIONS&lt;/a&gt;&lt;/code&gt; times.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e769494ea641bd01735c8978b12dae80bc631fc2" translate="yes" xml:space="preserve">
          <source>Illegal byte sequence</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cbd90c1ef775b6befeb73f8b124d85864e006bb9" translate="yes" xml:space="preserve">
          <source>Imaginary floating types</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d30ec43fa429c9d0766e648d3f7f8e3ad1d4ed4" translate="yes" xml:space="preserve">
          <source>Imaginary floating types model the mathematical &lt;a href=&quot;https://en.wikipedia.org/wiki/Imaginary_number&quot;&gt;imaginary numbers&lt;/a&gt;, that is numbers that can be written as a real number multiplied by the imaginary unit: bi The three imaginary types are.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1d3e8b209c294bf41ce4e3c74295f5bddf2df6e" translate="yes" xml:space="preserve">
          <source>Imaginary numbers are supported if &lt;code&gt;__STDC_IEC_559_COMPLEX__&lt;/code&gt; is defined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ac24adafbd8260df30bab34514422a754478f65" translate="yes" xml:space="preserve">
          <source>Imaginary numbers may be used with &lt;a href=&quot;operator_arithmetic&quot;&gt;arithmetic operators&lt;/a&gt; + - * and /, possibly mixed with complex and real numbers. There are many mathematical functions defined for imaginary numbers in &lt;a href=&quot;../numeric/complex&quot;&gt;complex.h&lt;/a&gt;. Both built-in operators and library functions may raise floating-point exceptions and set &lt;code&gt;&lt;a href=&quot;../error/errno&quot;&gt;errno&lt;/a&gt;&lt;/code&gt; as described in &lt;a href=&quot;../numeric/math/math_errhandling&quot;&gt;&lt;code&gt;math_errhandling&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="071df3b35cc3962c55cc856d63ca45738b9079cf" translate="yes" xml:space="preserve">
          <source>Imaginary type conversions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1671e6d41c5fac09c8aefb864f138445a7d1a21" translate="yes" xml:space="preserve">
          <source>Imaginary types also simplify implementations; multiplication of an imaginary by a complex can be implemented straightforwardly with two multiplications if the imaginary types are supported, instead of four multiplications and two additions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1bec87acbedb55cac0fd8887b67c78afe18b54a1" translate="yes" xml:space="preserve">
          <source>Implementation defined behavior control</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd1e3f977c02056ea472998c02c487e2316720f9" translate="yes" xml:space="preserve">
          <source>Implementation defined behavior is controlled by &lt;code&gt;#pragma&lt;/code&gt; directive.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="667c8eda998c1c080db13b731500db6f8a8c9f3c" translate="yes" xml:space="preserve">
          <source>Implementation-defined value. If &lt;code&gt;command&lt;/code&gt; is a null pointer, returns a nonzero value if and only if the command processor exists.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45a8270c1f150f433969e0be81b809f633b9a469" translate="yes" xml:space="preserve">
          <source>Implementations usually guarantee precision of less than 1 ulp (units in the last place): &lt;a href=&quot;http://sourceware.org/git/?p=glibc.git;a=blob_plain;f=sysdeps/ieee754/dbl-64/e_hypot.c&quot;&gt;GNU&lt;/a&gt;, &lt;a href=&quot;http://www.freebsd.org/cgi/cvsweb.cgi/src/lib/msun/src/e_hypot.c?rev=1.13.4.2;content-type=text%2Fplain&quot;&gt;BSD&lt;/a&gt;, &lt;a href=&quot;http://www.open64.net/doc/d5/d3f/hypot_8c-source.html&quot;&gt;Open64&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f38913e8ddeb1738019c4e8b2862059b04b95a9" translate="yes" xml:space="preserve">
          <source>Implicit conversion semantics</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f8e035635a982fad59fd7e5400a816066289eb5" translate="yes" xml:space="preserve">
          <source>Implicit conversion, whether</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a454cb8b77503090cbd9a357441f356bcc77421b" translate="yes" xml:space="preserve">
          <source>Implicit conversions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bfcc4d9c93f1e4e027da44f6460a88f24fa14bab" translate="yes" xml:space="preserve">
          <source>Implicit initialization</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27328a2eb2f15815a68b1653d19575045b8cf992" translate="yes" xml:space="preserve">
          <source>In 2's complement systems, the absolute value of the most-negative value is out of range, e.g. for 32-bit 2's complement type int, INT_MIN is -2147483648, but the would-be result 2147483648 is greater than INT_MAX, which is 2147483647.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00e7a8610b1ed817d9eb7670aae30608024360a9" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;scalar_initialization&quot;&gt;scalar initialization&lt;/a&gt;, the value of the initializer expression is converted to the unqualified type of the object being initialized</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07197e53e1c1900f95e26e0b0ed8484511ced3aa" translate="yes" xml:space="preserve">
          <source>In C++, assignment operators are lvalue expressions, not so in C.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e1eee7ba9e6a0e28c2ac33889b5015519c15749" translate="yes" xml:space="preserve">
          <source>In C++, ordinary character constants have type &lt;code&gt;char&lt;/code&gt;, rather than &lt;code&gt;int&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f90570f1ba0f2c22b611733a6dce8d3bfd3291e7" translate="yes" xml:space="preserve">
          <source>In C++, the &lt;code&gt;alignas&lt;/code&gt; specifier may also be applied to the declarations of class/struct/union types and enumerations. This is not supported in C, but the alignment of a struct type can be controlled by using alignas in a member declaration (as of DR 444).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16b073c98afd277d979d0d1b7c6ad0620c603d70" translate="yes" xml:space="preserve">
          <source>In C++, the conditional operator has the same precedence as assignment operators, and prefix &lt;code&gt;++&lt;/code&gt; and &lt;code&gt;--&lt;/code&gt; and assignment operators don't have the restrictions about their operands.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be29bb247378721617bd09a6c37e9883befb6d2c" translate="yes" xml:space="preserve">
          <source>In C++, unary operator + can also be used with other built-in types such as arrays and functions, not so in C.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="888861ed244a4e6c1b00d2e50051a54c4e1bec80" translate="yes" xml:space="preserve">
          <source>In C, the braced list of an initializer cannot be empty. C++ allows empty list:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="753a99a5b8f4f54ed3b2aae026243d00a9149dad" translate="yes" xml:space="preserve">
          <source>In C, the braced list of initializers cannot be empty (note that C++ allows empty lists, and also note that a &lt;a href=&quot;struct&quot;&gt;struct&lt;/a&gt; in C cannot be empty):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4df80b3a143adc8cece1ace5ccec2ef9426cb010" translate="yes" xml:space="preserve">
          <source>In C11 as published, unlike &lt;code&gt;&lt;a href=&quot;mbrtoc16&quot;&gt;mbrtoc16&lt;/a&gt;&lt;/code&gt;, which converts variable-width multibyte (such as UTF-8) to variable-width 16-bit (such as UTF-16) encoding, this function can only convert single-unit 16-bit encoding, meaning it cannot convert UTF-16 to UTF-8 despite that being the original intent of this function. This was corrected by the post-C11 defect report &lt;a href=&quot;http://www.open-std.org/jtc1/sc22/WG14/www/docs/summary.htm#dr_488&quot;&gt;DR488&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bfa2fd46abee60000979a7c0d0195215fe83ddb7" translate="yes" xml:space="preserve">
          <source>In C89, declarations within any &lt;a href=&quot;statements#Compound_statements&quot;&gt;compound statement&lt;/a&gt; (block scope) must appear in the beginning of the block, before any &lt;a href=&quot;statements&quot;&gt;statements&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5afc6f0bbafec1d95aa424d9ab7eafe8f8a41cd" translate="yes" xml:space="preserve">
          <source>In C89, specifiers-and-qualifiers was optional, and if omitted, the return type of the function defaulted to &lt;code&gt;int&lt;/code&gt; (possibly amended by the declarator).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c59c494dc7b28d6f1ae3f3e1fba28d7c33f040e5" translate="yes" xml:space="preserve">
          <source>In IS0 8601 weeks begin with Monday and the first week of the year must satisfy the following requirements:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b5f53a8b39a3373273d1bd5448850b45c7282a2" translate="yes" xml:space="preserve">
          <source>In a &lt;a href=&quot;operator_other&quot;&gt;function-call expression&lt;/a&gt;, to a function that has a prototype, the value of each argument expression is converted to the type of the unqualified declared types of the corresponding parameter</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e543016c2da1dbc421ea862e63a18dfd16a6409d" translate="yes" xml:space="preserve">
          <source>In a &lt;a href=&quot;operator_other#Function_call&quot;&gt;function call expression&lt;/a&gt; when the call is made to.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3db14f2b46d8b0aa95c66919fa6a6c2e01549c3" translate="yes" xml:space="preserve">
          <source>In a &lt;a href=&quot;return&quot;&gt;return statement&lt;/a&gt;, the value of the operand of &lt;code&gt;return&lt;/code&gt; is converted to an object having the return type of the function</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1afbd501ff06c0957f44b840912fccdb54dcc9f" translate="yes" xml:space="preserve">
          <source>In a C program, the declarations referring to the same object or function in</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dcb8b0b9734c917ca0765e9a7a94eaa46af9b402" translate="yes" xml:space="preserve">
          <source>In a function declaration, the keyword &lt;code&gt;const&lt;/code&gt; may appear inside the square brackets that are used to declare an array type of a function parameter. It qualifies the pointer type to which the array type is transformed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b54013284053a729eab7abaa9d5a083da83f62f" translate="yes" xml:space="preserve">
          <source>In a function declaration, the keyword &lt;code&gt;restrict&lt;/code&gt; may appear inside the square brackets that are used to declare an array type of a function parameter. It qualifies the pointer type to which the array type is transformed:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91f77fb9039b1b47cdb217206e779839523dbb48" translate="yes" xml:space="preserve">
          <source>In a function declaration, the keyword &lt;code&gt;volatile&lt;/code&gt; may appear inside the square brackets that are used to declare an array type of a function parameter. It qualifies the pointer type to which the array type is transformed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="661f71b2988adf25d44185c62a4b846d68c48b5c" translate="yes" xml:space="preserve">
          <source>In addition to changing the file position indicator, &lt;code&gt;fseek&lt;/code&gt; undoes the effects of &lt;code&gt;&lt;a href=&quot;ungetc&quot;&gt;ungetc&lt;/a&gt;&lt;/code&gt; and clears the end-of-file status, if applicable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b35dbcc1e0f0f5cd4a002df2770d4491982f6eca" translate="yes" xml:space="preserve">
          <source>In addition to the complex types, the three imaginary types may be supported: &lt;code&gt;double _Imaginary&lt;/code&gt;, &lt;code&gt;float _Imaginary&lt;/code&gt;, and &lt;code&gt;long double _Imaginary&lt;/code&gt; (see &lt;a href=&quot;../keyword/_imaginary&quot;&gt;_Imaginary&lt;/a&gt;). When the header &lt;code&gt;&amp;lt;complex.h&amp;gt;&lt;/code&gt; is included, the three imaginary types are also accessible as &lt;code&gt;double imaginary&lt;/code&gt;, &lt;code&gt;float imaginary&lt;/code&gt;, and &lt;code&gt;long double imaginary&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96d044a1b0cd5e52efeec3c718c75e91fa8170ae" translate="yes" xml:space="preserve">
          <source>In addition to the implicit conversions, the following conversions are allowed:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55f680af8a4672d6d70c077e3b55562b152fd0d3" translate="yes" xml:space="preserve">
          <source>In addition, old-style definition didn't require a declaration for every parameter in declaration-list. Any parameter whose declaration was missing had type &lt;code&gt;int&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33a1d90854c6b62d20682a431d3deb3e352e1570" translate="yes" xml:space="preserve">
          <source>In addition, volatile accesses are not atomic (concurrent read and write is a &lt;a href=&quot;../language/memory_model&quot;&gt;data race&lt;/a&gt;) and do not order memory (non-volatile memory accesses may be freely reordered around the volatile access).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e58e6d192ec64176fdc1379f81dba51aa0d986c8" translate="yes" xml:space="preserve">
          <source>In all other cases, the result is exact (&lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INEXACT&lt;/a&gt;&lt;/code&gt; is never raised) and &lt;a href=&quot;../fenv/fe_round&quot;&gt;the current rounding mode&lt;/a&gt; is ignored</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2caa1bc25941d7d072a18d3a94ff53e51be29ee7" translate="yes" xml:space="preserve">
          <source>In any case (both when executing an implicit conversion and in the same-type cast), if expression and type-name are floating types and expression is represented with greater range and precision than its type indicates (see &lt;code&gt;&lt;a href=&quot;../types/limits/flt_eval_method&quot;&gt;FLT_EVAL_METHOD&lt;/a&gt;&lt;/code&gt;, the range and precision are stripped off to match the target type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="922077a331c0fe9a078f343032d119067ea97aa1" translate="yes" xml:space="preserve">
          <source>In any case, &lt;code&gt;gets_s&lt;/code&gt; first finishes reading and discarding the characters from &lt;code&gt;&lt;a href=&quot;../io&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt; until new-line character, end-of-file condition, or read error before calling the constraint handler.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1fd722202cbcd28513d3d1f6696d6cc82e484b7" translate="yes" xml:space="preserve">
          <source>In any case, the behavior is undefined if rhs is negative or is greater or equal the number of bits in the promoted lhs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d317d4e7fe2ec42ae19ec71757d499c2504a3bd1" translate="yes" xml:space="preserve">
          <source>In contrast to &lt;code&gt;&lt;a href=&quot;fmod&quot;&gt;fmod()&lt;/a&gt;&lt;/code&gt;, the returned value is not guaranteed to have the same sign as &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7448c71f37984dda228a612a7fe2cff9d0abde9" translate="yes" xml:space="preserve">
          <source>In each &lt;a href=&quot;operator_other#Function_call&quot;&gt;function call&lt;/a&gt; to a function where a parameter of array type uses the keyword &lt;code&gt;static&lt;/code&gt; between &lt;code&gt;[&lt;/code&gt; and &lt;code&gt;]&lt;/code&gt;, the value of the actual parameter must be a valid pointer to the first element of an array with at least as many elements as specified by expression:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c2dc65fa3365dda17e8625d8d61e8a47bb9b9f7" translate="yes" xml:space="preserve">
          <source>In function parameter lists, additional syntax elements are allowed within the array declarators: the keyword &lt;code&gt;static&lt;/code&gt; and qualifiers, which may appear in any order before the size expression (they may also appear even when the size expression is omitted).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db2370d3e7ba69273bdb62a10e047b42c0843bf1" translate="yes" xml:space="preserve">
          <source>In function-like macros, a &lt;code&gt;#&lt;/code&gt; operator before an identifier in the replacement-list runs the identifier through parameter replacement and encloses the result in quotes, effectively creating a string literal. In addition, the preprocessor adds backslashes to escape the quotes surrounding embedded string literals, if any, and doubles the backslashes within the string as necessary. All leading and trailing whitespace is removed, and any sequence of whitespace in the middle of the text (but not inside embedded string literals) is collapsed to a single space. This operation is called &quot;stringification&quot;. If the result of stringification is not a valid string literal, the behavior is undefined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0dfc6aa82ba3fea48c1670a0af39cb7ef3825072" translate="yes" xml:space="preserve">
          <source>In general, it is best to explicitly annotate all non-aliasing pointers in a function's prototype with &lt;code&gt;restrict&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62ceb0117e9441fc64ed53290699d0b67f04e8ec" translate="yes" xml:space="preserve">
          <source>In locales other than &lt;code&gt;&quot;C&quot;&lt;/code&gt;, an alphabetic character is a character for which &lt;code&gt;&lt;a href=&quot;isupper&quot;&gt;isupper()&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;islower&quot;&gt;islower()&lt;/a&gt;&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt; or any other character considered alphabetic by the locale. In any case, &lt;code&gt;&lt;a href=&quot;iscntrl&quot;&gt;iscntrl()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;isdigit&quot;&gt;isdigit()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;ispunct&quot;&gt;ispunct()&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;isspace&quot;&gt;isspace()&lt;/a&gt;&lt;/code&gt; will return &lt;code&gt;false&lt;/code&gt; for this character.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21197e17c12cb14335ae7b60ed08fcc011dd80c7" translate="yes" xml:space="preserve">
          <source>In most implementations, &lt;code&gt;mbstowcs&lt;/code&gt; updates a global static object of type &lt;code&gt;&lt;a href=&quot;mbstate_t&quot;&gt;mbstate_t&lt;/a&gt;&lt;/code&gt; as it processes through the string, and cannot be called simultaneously by two threads, &lt;code&gt;&lt;a href=&quot;mbsrtowcs&quot;&gt;mbsrtowcs&lt;/a&gt;&lt;/code&gt; should be used in such cases.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa210a80b121c6a39599abbc8fbfc9c320d9bc24" translate="yes" xml:space="preserve">
          <source>In most implementations, &lt;code&gt;wcstombs&lt;/code&gt; updates a global static object of type &lt;code&gt;&lt;a href=&quot;mbstate_t&quot;&gt;mbstate_t&lt;/a&gt;&lt;/code&gt; as it processes through the string, and cannot be called simultaneously by two threads, &lt;code&gt;&lt;a href=&quot;wcsrtombs&quot;&gt;wcsrtombs&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;wcstombs_s&lt;/code&gt; should be used in such cases.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3cfb207d137efe07d54c5a87d7de6e2d7e3aeedc" translate="yes" xml:space="preserve">
          <source>In order to satisfy alignment requirements of all members of a struct, padding may be inserted after some of its members.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9475e6740d71cf18882ad4ded3421afd3ec16ba4" translate="yes" xml:space="preserve">
          <source>In order to support the one-infinity model of complex number arithmetic, C regards any complex value with at least one infinite part as an infinity even if its other part is a NaN, guarantees that all operators and functions honor basic properties of inifinities and provides &lt;code&gt;&lt;a href=&quot;../numeric/complex/cproj&quot;&gt;cproj&lt;/a&gt;&lt;/code&gt; to map all infinities to the canonical one (see &lt;a href=&quot;operator_arithmetic&quot;&gt;arithmetic operators&lt;/a&gt; for the exact rules).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76e64f99329b8a6a167edfe1e65c3955c2a72145" translate="yes" xml:space="preserve">
          <source>In some multibyte encodings, any given multibyte character sequence may represent different characters depending on the previous byte sequences, known as &quot;shift sequences&quot;. Such encodings are known as state-dependent: knowledge of the current shift state is required to interpret each character. An NTMBS is only valid if it begins and ends in the initial shift state: if a shift sequence was used, the corresponding unshift sequence has to be present before the terminating null character. Examples of such encodings are BOCU-1 and &lt;a href=&quot;http://www.unicode.org/reports/tr6&quot;&gt;SCSU&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="923c56b33566854301ad01db35301650d917bde7" translate="yes" xml:space="preserve">
          <source>In the &lt;a href=&quot;declarations&quot;&gt;declaration grammar&lt;/a&gt; of a function declaration, the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c6915549e0ea7f2ed3d86650796bfe49408367b" translate="yes" xml:space="preserve">
          <source>In the &lt;a href=&quot;declarations&quot;&gt;declaration grammar&lt;/a&gt; of a pointer declaration, the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5208b652452c725f5ac915c0c967fc1e2b74e39b" translate="yes" xml:space="preserve">
          <source>In the &lt;a href=&quot;declarations&quot;&gt;declaration grammar&lt;/a&gt; of an array declaration, the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="113533a0b69ca7bb102b7ddcf07a25f608ef6a71" translate="yes" xml:space="preserve">
          <source>In the &lt;a href=&quot;operator_assignment&quot;&gt;assignment&lt;/a&gt; operator, the value of the right-hand operand is converted to the unqualified type of the left-hand operand.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f26b71cad718a75aa0f6d4d4ddf1273333394594" translate="yes" xml:space="preserve">
          <source>In the C++ programming language, the width of a bit field can exceed the width of the underlying type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="975e4fe6f239aebda10cf0cf1e080b0c6fa23395" translate="yes" xml:space="preserve">
          <source>In the case the file is not found, the program is ill-formed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2371f6402972bc45972f3f09d5d022fcbd00df0" translate="yes" xml:space="preserve">
          <source>In the default &quot;C&quot; locale, the following lowercase letters &lt;code&gt;abcdefghijklmnopqrstuvwxyz&lt;/code&gt; are replaced with respective uppercase letters &lt;code&gt;ABCDEFGHIJKLMNOPQRSTUVWXYZ&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f82450bef11bed620bb59a03e863ef7afabcdad8" translate="yes" xml:space="preserve">
          <source>In the default &quot;C&quot; locale, the following uppercase letters &lt;code&gt;ABCDEFGHIJKLMNOPQRSTUVWXYZ&lt;/code&gt; are replaced with respective lowercase letters &lt;code&gt;abcdefghijklmnopqrstuvwxyz&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69d5da7e7c8f4ddf2ba06176a0324f7f725a9426" translate="yes" xml:space="preserve">
          <source>In the following contexts, the comma operator cannot appear at the top level of an expression because the comma has a different meaning:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc33863a538f837ccafd624f0573864c0519ef07" translate="yes" xml:space="preserve">
          <source>In the following example, the compiler may infer that there is no aliasing of modified objects, and so optimize the loop aggressively. Upon entry to f, the restricted pointer a must provide exclusive access to its associated array. In particular, within f neither b nor c may point into the array associated with a, because neither is assigned a pointer value based on a. For b, this is evident from the const-qualifier in its declaration, but for c, an inspection of the body of f is required:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d658bebea04040340fda6a99bf9ac52ca6b05755" translate="yes" xml:space="preserve">
          <source>In the form (2), if expression compares equal to the integer zero, statement_false is executed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="044aceb384f674b4556f403f792d0db3bee99f91" translate="yes" xml:space="preserve">
          <source>In this example there is a system call of the unix command &lt;b&gt;date +%A&lt;/b&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0d690c603a9d7a62cca51dfee4caa9018dac758" translate="yes" xml:space="preserve">
          <source>In typical usage, &lt;code&gt;count&lt;/code&gt; is the number of elements in the destination array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="666e665b91e221551332cdb922f39d26d34652a4" translate="yes" xml:space="preserve">
          <source>In typical usage, input stream processing stops on any error; &lt;code&gt;feof&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ferror&quot;&gt;ferror&lt;/a&gt;&lt;/code&gt; are then used to distinguish between different error conditions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7499c4ef48e0f11187d8d33c914d276969727d9" translate="yes" xml:space="preserve">
          <source>In update mode ('+'), both input and output may be performed, but output cannot be followed by input without an intervening call to &lt;code&gt;&lt;a href=&quot;fflush&quot;&gt;fflush&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;fseek&quot;&gt;fseek&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;fsetpos&quot;&gt;fsetpos&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;rewind&quot;&gt;rewind&lt;/a&gt;&lt;/code&gt;, and input cannot be followed by output without an intervening call to &lt;code&gt;&lt;a href=&quot;fseek&quot;&gt;fseek&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;fsetpos&quot;&gt;fsetpos&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;rewind&quot;&gt;rewind&lt;/a&gt;&lt;/code&gt;, unless the input operation encountered end of file. In update mode, implementations are permitted to use binary mode even when text mode is specified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8705867aeef60bcf6e033673dc025bf70ea7c829" translate="yes" xml:space="preserve">
          <source>Includes January 4</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="363fb406f419e21cfcda27deb409f2bd35c7c245" translate="yes" xml:space="preserve">
          <source>Includes another source file into the current source file at the line immediately after the directive.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e25648908297ca3a4ff1a029bba15e376074f7a" translate="yes" xml:space="preserve">
          <source>Includes first Thursday of the year</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d416e56359c061d5140399f02320d85b725a461e" translate="yes" xml:space="preserve">
          <source>Includes source file, identified by filename, into the current source file at the line immediately after the directive.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49c0d7b0937da9c9ff367feeb084c4412b31121a" translate="yes" xml:space="preserve">
          <source>Incomplete types</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9f510244f4c40d947308a6a3b552dcfe82f8745" translate="yes" xml:space="preserve">
          <source>Increment and Decrement</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5bc342f191d90350a10c27aa563d30c6fa0efd4e" translate="yes" xml:space="preserve">
          <source>Increment and decrement are not defined for complex types.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d451f27858a586b045ef8704174c2c47a9677b6d" translate="yes" xml:space="preserve">
          <source>Increment and decrement are not defined for imaginary types  &lt;a href=&quot;conversion&quot;&gt;Implicit conversions&lt;/a&gt; are defined between imaginary types and other arithmetic types.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4cab5961dc19e11a59ed503482594c2617dde8e5" translate="yes" xml:space="preserve">
          <source>Increment operators initiate the side-effect of adding the value &lt;code&gt;1&lt;/code&gt; of appropriate type to the operand. Decrement operators initiate the side-effect of subtracting the value &lt;code&gt;1&lt;/code&gt; of appropriate type from the operand. As with any other side-effects, these operations complete at or before the next &lt;a href=&quot;eval_order&quot;&gt;sequence point&lt;/a&gt;. &lt;code&gt;int a = 1; int b = a++; // stores 1+a (which is 2) to a // returns the value of a (which is 1) // After this line, b == 1 and a == 2 a = 1; int c = ++a; // stores 1+a (which is 2) to a // returns 1+a (which is 2) // after this line, c == 2 and a == 2&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f17d70be0f16733c0dc8c67eabfb624d43b60216" translate="yes" xml:space="preserve">
          <source>Increment/decrement operators</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40b0713cd16ef48a40d29fc9dad27332939e997e" translate="yes" xml:space="preserve">
          <source>Increment/decrement operators are not defined for complex or imaginary types: the usual definition of adding/subtracting the real number 1 would have no effect on imaginary types, and making it add/subtract &lt;code&gt;i&lt;/code&gt; for imaginaries but &lt;code&gt;1&lt;/code&gt; for complex numbers would have made it handle &lt;code&gt;0+yi&lt;/code&gt; different from &lt;code&gt;yi&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56e7713f236304a71ab92bc24bb388cf6138cc73" translate="yes" xml:space="preserve">
          <source>Increment/decrement operators are unary operators that increment/decrement the value of a variable by 1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1df30318ddb5ee41156f6bf21f1a90f429ea6a75" translate="yes" xml:space="preserve">
          <source>Indirection (dereference)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5f6e97cd4faf7045970097d59a8c5be90de03ff" translate="yes" xml:space="preserve">
          <source>Inexact result</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98df9b88a5e801dd458f9dea0b5eb524b074282a" translate="yes" xml:space="preserve">
          <source>Infinite loop without side-effects</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3b3d9c9386379e588661aaa74e30dea9732f4b8" translate="yes" xml:space="preserve">
          <source>Informs the compiler that the dependency tree started by an &lt;code&gt;&lt;a href=&quot;memory_order&quot;&gt;memory_order_consume&lt;/a&gt;&lt;/code&gt; atomic load operation does not extend past the return value of &lt;code&gt;kill_dependency&lt;/code&gt;; that is, the argument does not carry a dependency into the return value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68fa16ffd48f366e4fa8d57fea78ff03fcab0191" translate="yes" xml:space="preserve">
          <source>Initialization</source>
          <target state="translated">Initialization</target>
        </trans-unit>
        <trans-unit id="bda194cf9cabbb80afe8fa11968d57f4d61e8056" translate="yes" xml:space="preserve">
          <source>Initialization from brace-enclosed lists</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="809dbf840669bbee858fa37fe2063537d8ea1dc8" translate="yes" xml:space="preserve">
          <source>Initialization from strings</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49fb3cd233b01d2f3fca6d231ff8868b279e8d64" translate="yes" xml:space="preserve">
          <source>Initialization to all bits zero does not guarantee that a floating-point or a pointer would be initialized to 0.0 and the null pointer value, respectively (although that is true on all common platforms).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dcd64bec39ad6d832e7fd656dfbaa3b5fb1da8e8" translate="yes" xml:space="preserve">
          <source>Initializers cannot be used in declarations of objects of incomplete type, VLAs, and block-scope objects with linkage.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af07b8353132a535b78017dad8822a72315ba75e" translate="yes" xml:space="preserve">
          <source>Initializes new condition variable. The object pointed to by &lt;code&gt;cond&lt;/code&gt; will be set to value that identifies the condition variable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8d332dbed9d2af60e29bd52e5cde6a80c7ad53b" translate="yes" xml:space="preserve">
          <source>Initializes the default-constructed atomic object &lt;code&gt;obj&lt;/code&gt; with the value &lt;code&gt;desired&lt;/code&gt;. The function is not atomic: concurrent access from another thread, even through an atomic operation, is a data race.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7bb9ce0cdba5a821d492b917cf5fb720a0f90bd9" translate="yes" xml:space="preserve">
          <source>Inline assembly</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="249f397392db7fe682a1d1ecc1a52c8e40ceb983" translate="yes" xml:space="preserve">
          <source>Input/output</source>
          <target state="translated">Input/output</target>
        </trans-unit>
        <trans-unit id="3b91932c5604be98b02beecc9f3294548420aed4" translate="yes" xml:space="preserve">
          <source>Integer arithmetic in &lt;code&gt;#if&lt;/code&gt;-expressions is performed using the semantics of &lt;code&gt;&lt;a href=&quot;../types/integer&quot;&gt;intmax_t&lt;/a&gt;&lt;/code&gt; for signed types and &lt;code&gt;&lt;a href=&quot;../types/integer&quot;&gt;uintmax_t&lt;/a&gt;&lt;/code&gt; for unsigned types.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00fca0cb45c563b4aca1c728dcaf7bb27ee388bc" translate="yes" xml:space="preserve">
          <source>Integer constant expression</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bac8890b103516222490d7d9d18bdba5cbf90f36" translate="yes" xml:space="preserve">
          <source>Integer constant expressions are evaluated at compile time. The following contexts require expressions that are known as</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d17a9e0dc1e0be7fcf770a93ca094014147b164" translate="yes" xml:space="preserve">
          <source>Integer constants</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb8a7869f4f02b2ddb556d447ca9969842e11b2b" translate="yes" xml:space="preserve">
          <source>Integer constants may be used in &lt;a href=&quot;constant_expression&quot;&gt;integer constant expressions&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f01db8c35bcc24ed074568092a7ec4baacf74ca" translate="yes" xml:space="preserve">
          <source>Integer conversions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="566c223f31851f66caf3368111c90cc6e99a86cf" translate="yes" xml:space="preserve">
          <source>Integer promotion is the implicit conversion of a value of any integer type with</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b32622daf07fbe0a8ed0fe3f161a8d872f055bce" translate="yes" xml:space="preserve">
          <source>Integer promotions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14fa9d849ba5cc455c138e12e0153e7279624dff" translate="yes" xml:space="preserve">
          <source>Integer promotions preserve the value, including the sign:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d364bae64d134436bc38477b2370e7d602b048e" translate="yes" xml:space="preserve">
          <source>Integer to pointer implicit &lt;a href=&quot;conversion&quot;&gt;conversion&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="876569ad85ebaf17d9149dea5706aba22e882fe8" translate="yes" xml:space="preserve">
          <source>Integer types</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c8b2db07fe3fe6b10f79300cc2e4c847fac9fa0" translate="yes" xml:space="preserve">
          <source>Integer value corresponding to the contents of &lt;code&gt;str&lt;/code&gt; on success. If the converted value falls out of range of corresponding return type, range error occurs (&lt;code&gt;&lt;a href=&quot;../../error/errno&quot;&gt;errno&lt;/a&gt;&lt;/code&gt; is set to &lt;code&gt;ERANGE&lt;/code&gt;) and &lt;code&gt;&lt;a href=&quot;../../types/limits&quot;&gt;ULONG_MAX&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../../types/limits&quot;&gt;ULLONG_MAX&lt;/a&gt;&lt;/code&gt; is returned. If no conversion can be performed, &lt;code&gt;​0​&lt;/code&gt; is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52e4539e8037f8f852f5856d00606b776679d442" translate="yes" xml:space="preserve">
          <source>Integer value corresponding to the contents of &lt;code&gt;str&lt;/code&gt; on success. If the converted value falls out of range of corresponding return type, range error occurs and &lt;code&gt;&lt;a href=&quot;../../types/integer&quot;&gt;INTMAX_MAX&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../../types/integer&quot;&gt;INTMAX_MIN&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../../types/integer&quot;&gt;UINTMAX_MAX&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;​0​&lt;/code&gt; is returned, as appropriate. If no conversion can be performed, &lt;code&gt;​0​&lt;/code&gt; is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="037211edd9f543a6e3e5973c9289bff663b3846a" translate="yes" xml:space="preserve">
          <source>Integer value corresponding to the contents of &lt;code&gt;str&lt;/code&gt; on success. If the converted value falls out of range of corresponding return type, range error occurs and &lt;code&gt;&lt;a href=&quot;../../types/limits&quot;&gt;LONG_MAX&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../../types/limits&quot;&gt;LONG_MIN&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../../types/limits&quot;&gt;LLONG_MAX&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../../types/limits&quot;&gt;LLONG_MIN&lt;/a&gt;&lt;/code&gt; is returned. If no conversion can be performed, &lt;code&gt;​0​&lt;/code&gt; is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30a62fa780cc981f83f6721bd337ae1c720db4eb" translate="yes" xml:space="preserve">
          <source>Integer value corresponding to the contents of &lt;code&gt;str&lt;/code&gt; on success. If the converted value falls out of range of corresponding return type, range error occurs and &lt;code&gt;&lt;a href=&quot;../../types/limits&quot;&gt;ULONG_MAX&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../../types/limits&quot;&gt;ULLONG_MAX&lt;/a&gt;&lt;/code&gt; is returned. If no conversion can be performed, &lt;code&gt;​0​&lt;/code&gt; is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21098bb738833ee0f4f792151a59d559da8ec6b0" translate="yes" xml:space="preserve">
          <source>Integer value corresponding to the contents of &lt;code&gt;str&lt;/code&gt; on success. If the converted value falls out of range of corresponding return type, the return value is undefined. If no conversion can be performed, &lt;code&gt;​0​&lt;/code&gt; is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94bb86dba8d80a53634463b836c1b46d98acd2a7" translate="yes" xml:space="preserve">
          <source>Intel C++ compiler pragmas</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9dac1e92729539ac11d8cad38e7bddd13ef84d39" translate="yes" xml:space="preserve">
          <source>Internally, the character is converted to &lt;code&gt;unsigned char&lt;/code&gt; just before being written.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4000ac517f025eca6a922c089403bb09186f8d96" translate="yes" xml:space="preserve">
          <source>International monetary numeric formatting parameters</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc48cbadb6a84efbed23317d93156122ffd8c740" translate="yes" xml:space="preserve">
          <source>Interprets a floating point value in a wide string pointed to by &lt;code&gt;str&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd73986f45b4bdd6cb8af7f9c50d2ce721e60cf8" translate="yes" xml:space="preserve">
          <source>Interprets a floating-point value in a byte string pointed to by &lt;code&gt;str&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a608036eb59f94001912ca3733a0c15c944b183" translate="yes" xml:space="preserve">
          <source>Interprets an integer value in a byte string pointed to by &lt;code&gt;nptr&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="566cf8ed0ac571b4f2aa3ca75d488875487baeb4" translate="yes" xml:space="preserve">
          <source>Interprets an integer value in a byte string pointed to by &lt;code&gt;str&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc2bd5d023e90da3e1640fc0f66845e22f6c8508" translate="yes" xml:space="preserve">
          <source>Interprets an integer value in a wide string pointed to by &lt;code&gt;str&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="042a224facaad3cdf57ba7458290bd20ddbab9ab" translate="yes" xml:space="preserve">
          <source>Interprets an unsigned integer value in a byte string pointed to by &lt;code&gt;str&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65b433c8b60cb3b8c5443581467dc0f6ae5b6523" translate="yes" xml:space="preserve">
          <source>Interprets an unsigned integer value in a wide string pointed to by &lt;code&gt;nptr&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="148c33b3cec53bcad46f4795046e389f68465431" translate="yes" xml:space="preserve">
          <source>Interprets an unsigned integer value in a wide string pointed to by &lt;code&gt;str&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86c96ba7411037b346432868bfdb3e867290952c" translate="yes" xml:space="preserve">
          <source>Invalid scalar</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bccd99d2661a6df322f59fa784d4f94059ba4e6f" translate="yes" xml:space="preserve">
          <source>Inverse cosine (or arc cosine) is a multivalued function and requires a branch cut on the complex plane. The branch cut is conventially placed at the line segments (-&amp;infin;,-1) and (1,&amp;infin;) of the real axis.  The mathematical definition of the principal value of arc cosine is acos z =</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92db73712a1ea6cdea29021a66a4e0d10b6b003b" translate="yes" xml:space="preserve">
          <source>Inverse hyperbolic cosine is a multivalued function and requires a branch cut on the complex plane. The branch cut is conventionally placed at the line segment (-&amp;infin;,+1) of the real axis.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ff0648a78636309b1cc12a67a5c7841a27e8966" translate="yes" xml:space="preserve">
          <source>Inverse hyperbolic sine is a multivalued function and requires a branch cut on the complex plane. The branch cut is conventionally placed at the line segments (-</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60cf8f72dc186c6f4b4743734e8e8ed4cb1bd30a" translate="yes" xml:space="preserve">
          <source>Inverse hyperbolic tangent is a multivalued function and requires a branch cut on the complex plane. The branch cut is conventionally placed at the line segmentd (-&amp;infin;,-1] and [+1,+&amp;infin;) of the real axis.  The mathematical definition of the principal value of the inverse hyperbolic tangent is atanh z =</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff28b3449f26b28c2a2ed73fffb64ba03b0e2959" translate="yes" xml:space="preserve">
          <source>Inverse sine (or arc sine) is a multivalued function and requires a branch cut on the complex plane. The branch cut is conventionally placed at the line segments (-&amp;infin;,-1) and (1,&amp;infin;) of the real axis.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a394149a1f48f15fcf530168253dbecfeb4322f" translate="yes" xml:space="preserve">
          <source>Inverse tangent (or arc tangent) is a multivalued function and requires a branch cut on the complex plane. The branch cut is conventionally placed at the line segments (-&amp;infin;i,-i) and (+i,+&amp;infin;i) of the imaginary axis.  The mathematical definition of the principal value of inverse tangent is atan z = -</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d2f6d91d5420dae435a1c0f90119203f0e61055" translate="yes" xml:space="preserve">
          <source>It is common practice to inject struct/union/enum names into the name space of the ordinary identifiers using a &lt;a href=&quot;typedef&quot;&gt;typedef&lt;/a&gt; declaration:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7405702ee0f652067444964a064505a6d91ce3db" translate="yes" xml:space="preserve">
          <source>It is implementation-defined if raw (not escaped) Unicode characters are allowed in identifiers:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e89c6edc67ab990f4dbf2f94411a54a2785ae48a" translate="yes" xml:space="preserve">
          <source>It is legal to pass a pointer to a &lt;code&gt;va_list&lt;/code&gt; object to another function and then use that object after the function returns.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7926a28072d957347e3960952bdef8d080b0e6ed" translate="yes" xml:space="preserve">
          <source>It is neither required nor forbidden for identical string literals to refer to the same location in memory. Moreover, overlapping string literals or string literals that are substrings of other string literals may be combined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9123df49710433ab83af6575b94f8d3abd5f45a3" translate="yes" xml:space="preserve">
          <source>It is possible to enter the body of a loop using &lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt;. In this case, init_clause and cond_expression are not executed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08e37acb4a8f5bf8f0ffdb9adceda2446f63dbb9" translate="yes" xml:space="preserve">
          <source>It is possible to indicate to a function that accesses objects through pointers that those pointers do not alias. See &lt;a href=&quot;restrict&quot;&gt;restrict&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e55a74fe870b5dea0eb9ccaa43f967ab9bc4994" translate="yes" xml:space="preserve">
          <source>It's an error to provide more initializers than elements when initializing an array of known size (except when initializing character arrays from string literals).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cbb15437c0942623655a62fecca4d13fffedba42" translate="yes" xml:space="preserve">
          <source>It's an error to provide more initializers than members.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eaad30c6c7239ee4988afc79198142d6357df99b" translate="yes" xml:space="preserve">
          <source>Iteration statements</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61862142943cd7265805fbc767319ff613c724a6" translate="yes" xml:space="preserve">
          <source>J.5 Common extensions (p: 511-513)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9953eaba16e228c2e6d58120372e40175bf2ca4" translate="yes" xml:space="preserve">
          <source>J.5 Common extensions (p: 579-581)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bdfb777e0387993e2e3d113ac36512201456491d" translate="yes" xml:space="preserve">
          <source>Jump statements</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dab4841e25b37627c71f4a9a4019a02fa5866eef" translate="yes" xml:space="preserve">
          <source>Jumping across threads (if the function that called &lt;code&gt;setjmp&lt;/code&gt; was executed by another thread) is also undefined behavior.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0cb0c0046b3f02e116b5c2149dc3ab7668bc12b6" translate="yes" xml:space="preserve">
          <source>K.3.1.2 Reserved identifiers (p: 584)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6864fef737e995e1d1cd295e0023b9e2ebe3a4c4" translate="yes" xml:space="preserve">
          <source>K.3.1.3 Use of errno (p: 584)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27a66ec6494371162942d093a56fa8a2e184d943" translate="yes" xml:space="preserve">
          <source>K.3.2 Errors &amp;lt;errno.h&amp;gt; (p: 585)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="708d246a6ea637ca582a2667b7221a12320e5a98" translate="yes" xml:space="preserve">
          <source>K.3.2/2 errno_t (p: 585)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e58be13bd900d0cee367c094a9ec614488caeee" translate="yes" xml:space="preserve">
          <source>K.3.3 Common definitions &amp;lt;stddef.h&amp;gt; (p: 585)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f138276c2fee1981c3ae61a15d64e3a9856c9815" translate="yes" xml:space="preserve">
          <source>K.3.3/2 rsize_t (p: 585)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4c50e76ee617672247b3a8d01a8c4ec472aa6f7" translate="yes" xml:space="preserve">
          <source>K.3.4/2 RSIZE_MAX (p: 585)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a80d328f4964ca1bf3e74f6f2ccc8b333f67c7e" translate="yes" xml:space="preserve">
          <source>K.3.5 Input/output &amp;lt;stdio.h&amp;gt; (p: 586-603)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="369c2239cc2d2c85678b66dc84de6c39138dad3f" translate="yes" xml:space="preserve">
          <source>K.3.5.1.1 The tmpfile_s function (p: 586-587)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50d2ab4ca7b8cc8a1730d227f9641def28a24680" translate="yes" xml:space="preserve">
          <source>K.3.5.1.2 The tmpnam_s function (p: 587-588)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a485d9c7022335c9e640bfc39b6d728070f42cd" translate="yes" xml:space="preserve">
          <source>K.3.5.2.1 The fopen_s function (p: 588-590)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab2a574649a5da149b2aad34fd3642efffe3e957" translate="yes" xml:space="preserve">
          <source>K.3.5.2.2 The freopen_s function (p: 590)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9150e311f698b9b2d0020a5314030a25443c9953" translate="yes" xml:space="preserve">
          <source>K.3.5.3.1 The fprintf_s function (p: 591)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23d19bd7432258b33166d9a55544eb85969c4f0b" translate="yes" xml:space="preserve">
          <source>K.3.5.3.10 The vprintf_s function (p: 598-599)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9041652eb11ab1a0d7ccbc42db6d18962320c4d" translate="yes" xml:space="preserve">
          <source>K.3.5.3.11 The vscanf_s function (p: 599)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b661ee960e7f0fae6141e96c9cc1b4fd57185d64" translate="yes" xml:space="preserve">
          <source>K.3.5.3.12 The vsnprintf_s function (p: 600)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9a1acd40ff4721c31e464bdc74e240db45f114e" translate="yes" xml:space="preserve">
          <source>K.3.5.3.13 The vsprintf_s function (p: 601)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="013f52d5fe2e678b389f07e69c114c6413950586" translate="yes" xml:space="preserve">
          <source>K.3.5.3.14 The vsscanf_s function (p: 602)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="684c3b4d0155dab92ccb5157d61e57be7187e268" translate="yes" xml:space="preserve">
          <source>K.3.5.3.2 The fscanf_s function (p: 592-593)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85e026b41cb6fb14b9397ba5d5c295a20b084a8c" translate="yes" xml:space="preserve">
          <source>K.3.5.3.3 The printf_s function (p: 593-594)</source>
          <target state="new"/>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
