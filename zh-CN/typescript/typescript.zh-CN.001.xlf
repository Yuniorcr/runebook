<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="typescript">
    <body>
      <group id="typescript">
        <trans-unit id="07f99178b48153ac4d4332687d20d728a7c8bfd4" translate="yes" xml:space="preserve">
          <source>&amp;copy; 2012-2019 Microsoft</source>
          <target state="translated">&amp;copy; 2012-2019 Microsoft</target>
        </trans-unit>
        <trans-unit id="3eb191ccf7512349b3d99757bc9535f48ae81c17" translate="yes" xml:space="preserve">
          <source>&amp;ldquo;Defaulted declarations&amp;rdquo; allow initializers that reference the declared name in the left side of a logical or:</source>
          <target state="translated">&amp;ldquo;Defaulted declarations&amp;rdquo; allow initializers that reference the declared name in the left side of a logical or:</target>
        </trans-unit>
        <trans-unit id="f1fdafe04dd11ea1809cd2cc0c324b66f3a11b35" translate="yes" xml:space="preserve">
          <source>&amp;ldquo;Do&amp;rdquo;s and &amp;ldquo;Don&amp;rsquo;t&amp;rdquo;s</source>
          <target state="translated">&amp;ldquo;Do&amp;rdquo;s and &amp;ldquo;Don&amp;rsquo;t&amp;rdquo;s</target>
        </trans-unit>
        <trans-unit id="73d479e429a32f573b7b23a67a8995da08eed47d" translate="yes" xml:space="preserve">
          <source>&amp;lsquo;classic&amp;rsquo; - module resolution rules used by pre 1.6 TypeScript compiler</source>
          <target state="translated">&amp;lsquo;classic&amp;rsquo; - module resolution rules used by pre 1.6 TypeScript compiler</target>
        </trans-unit>
        <trans-unit id="61c51288c27e2cc818fba1bd491d412143391547" translate="yes" xml:space="preserve">
          <source>&amp;lsquo;node&amp;rsquo; - node-like module resolution</source>
          <target state="translated">&amp;lsquo;node&amp;rsquo; - node-like module resolution</target>
        </trans-unit>
        <trans-unit id="4547d63b41d1c75d2e1b5085da19d735e8dc595e" translate="yes" xml:space="preserve">
          <source>&amp;lsquo;package.json&amp;rsquo; has &lt;strong&gt;&amp;lsquo;types&amp;rsquo;&lt;/strong&gt; field &amp;lsquo;./lib/typescript.d.ts&amp;rsquo; that references &amp;lsquo;node_modules/typescript/lib/typescript.d.ts&amp;rsquo;.</source>
          <target state="translated">&amp;lsquo;package.json&amp;rsquo; has &lt;strong&gt;&amp;lsquo;types&amp;rsquo;&lt;/strong&gt; field &amp;lsquo;./lib/typescript.d.ts&amp;rsquo; that references &amp;lsquo;node_modules/typescript/lib/typescript.d.ts&amp;rsquo;.</target>
        </trans-unit>
        <trans-unit id="ee44c32e65bc4a9d7773f18d0e20e44810833a3f" translate="yes" xml:space="preserve">
          <source>&amp;lt;amd-dependency /&amp;gt;</source>
          <target state="translated">&amp;lt;amd-dependency /&amp;gt;</target>
        </trans-unit>
        <trans-unit id="934f0cd8be7ed1f9b7b8079909795f738f732556" translate="yes" xml:space="preserve">
          <source>&amp;lt;amd-module /&amp;gt;</source>
          <target state="translated">&amp;lt;amd-module /&amp;gt;</target>
        </trans-unit>
        <trans-unit id="cd4898dc828f34abf0dca9dabec02736d522eceb" translate="yes" xml:space="preserve">
          <source>&amp;lt;reference lib=&amp;quot;...&amp;quot; /&amp;gt;</source>
          <target state="translated">&amp;lt;reference lib=&amp;quot;...&amp;quot; /&amp;gt;</target>
        </trans-unit>
        <trans-unit id="62141bcfe5cfcd51fc1a320d36520899bc9edd5f" translate="yes" xml:space="preserve">
          <source>&amp;lt;reference no-default-lib=&amp;quot;true&amp;quot;/&amp;gt;</source>
          <target state="translated">&amp;lt;reference no-default-lib=&amp;quot;true&amp;quot;/&amp;gt;</target>
        </trans-unit>
        <trans-unit id="21029c886af7dc459626422aa0c5b6ca11e413cb" translate="yes" xml:space="preserve">
          <source>&amp;lt;reference path=&amp;quot;...&amp;quot; /&amp;gt;</source>
          <target state="translated">&amp;lt;reference path=&amp;quot;...&amp;quot; /&amp;gt;</target>
        </trans-unit>
        <trans-unit id="120613f8d21d190c622bf610b91d69083361e489" translate="yes" xml:space="preserve">
          <source>&amp;lt;reference types=&amp;quot;...&amp;quot; /&amp;gt;</source>
          <target state="translated">&amp;lt;reference types=&amp;quot;...&amp;quot; /&amp;gt;</target>
        </trans-unit>
        <trans-unit id="105733a69ca97c742b5246c8891283fb75ef628c" translate="yes" xml:space="preserve">
          <source>&amp;lt;reference&amp;gt;-ing a module</source>
          <target state="translated">&amp;lt;reference&amp;gt;-ing a module</target>
        </trans-unit>
        <trans-unit id="ccfac08210ff156925b259cf9224a7d62ab98fc8" translate="yes" xml:space="preserve">
          <source>(More) Recursive Type Aliases</source>
          <target state="translated">(More) Recursive Type Aliases</target>
        </trans-unit>
        <trans-unit id="32b244b1f4cdc07410d73db6d8271fb3aede63b0" translate="yes" xml:space="preserve">
          <source>*Note: You can specify the JSX factory function to use when targeting react JSX emit with &lt;code&gt;--jsxFactory&lt;/code&gt; option (defaults to &lt;code&gt;React.createElement&lt;/code&gt;)</source>
          <target state="translated">*Note: You can specify the JSX factory function to use when targeting react JSX emit with &lt;code&gt;--jsxFactory&lt;/code&gt; option (defaults to &lt;code&gt;React.createElement&lt;/code&gt;)</target>
        </trans-unit>
        <trans-unit id="bcac7464521b8c19a2372c739f6dc9e9ab7dfc80" translate="yes" xml:space="preserve">
          <source>.babelrc</source>
          <target state="translated">.babelrc</target>
        </trans-unit>
        <trans-unit id="bdbc9a553b902daccdcb974134663c5cbb048999" translate="yes" xml:space="preserve">
          <source>1 - greeting: Mandatory string</source>
          <target state="translated">1-问候语。必需的字符串</target>
        </trans-unit>
        <trans-unit id="13d790ef091c0d678928628f711d3a342ed79fdc" translate="yes" xml:space="preserve">
          <source>2 - duration: Optional length of time (in milliseconds)</source>
          <target state="translated">2-持续时间。可选时间长度(毫秒)</target>
        </trans-unit>
        <trans-unit id="ecb356c6c25d42fb0b2006e35569ce371868ed08" translate="yes" xml:space="preserve">
          <source>3 - color: Optional string, e.g. &amp;lsquo;#ff00ff&amp;rsquo;</source>
          <target state="translated">3-color：可选字符串，例如'＃ff00ff'</target>
        </trans-unit>
        <trans-unit id="dd1f243849fa29b29355c96a02e0cba354d5a774" translate="yes" xml:space="preserve">
          <source>3.7 API Changes</source>
          <target state="translated">3.7 API的变化</target>
        </trans-unit>
        <trans-unit id="c2dbed9bb17a5c2fdd2db0b9dd5844f947a20c89" translate="yes" xml:space="preserve">
          <source>3.7 Breaking Changes</source>
          <target state="translated">3.7 打破变化</target>
        </trans-unit>
        <trans-unit id="f9d8d7d93cd113005d851de63f1e7f8b91e504d4" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#the-usedefineforclassfields-flag-and-the-declare-property-modifier&quot;&gt;As mentioned above&lt;/a&gt;, TypeScript 3.7 emits &lt;code&gt;get&lt;/code&gt;/&lt;code&gt;set&lt;/code&gt; accessors in &lt;code&gt;.d.ts&lt;/code&gt; files which can cause breaking changes for consumers on older versions of TypeScript like 3.5 and prior. TypeScript 3.6 users will not be impacted, since that version was future-proofed for this feature.</source>
          <target state="translated">&lt;a href=&quot;#the-usedefineforclassfields-flag-and-the-declare-property-modifier&quot;&gt;如上所述&lt;/a&gt;，TypeScript 3.7 在 &lt;code&gt;.d.ts&lt;/code&gt; 文件中发出 &lt;code&gt;get&lt;/code&gt; / &lt;code&gt;set&lt;/code&gt; 访问器，这可能导致使用方TypeScript（如3.5及更早版本）的使用者发生重大更改。TypeScript 3.6用户将不会受到影响，因为该功能已针对该版本进行了过时验证。</target>
        </trans-unit>
        <trans-unit id="1b4fbbd23ecf68cc6d9a635cad72158cb53c80a0" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://www.ecma-international.org/ecma-262/6.0/#sec-generatorfunction-objects&quot;&gt;ES2015 also introduced &amp;ldquo;Generators&amp;rdquo;&lt;/a&gt;, which are functions that can be used to yield partial computation results via the &lt;code&gt;Iterator&lt;/code&gt; interface and the &lt;code&gt;yield&lt;/code&gt; keyword. Generators can also internally delegate calls to another iterable through &lt;code&gt;yield *&lt;/code&gt;. For example:</source>
          <target state="translated">&lt;a href=&quot;http://www.ecma-international.org/ecma-262/6.0/#sec-generatorfunction-objects&quot;&gt;ES2015还引入了&amp;ldquo;生成器&amp;rdquo;&lt;/a&gt;，这些函数可用于通过 &lt;code&gt;Iterator&lt;/code&gt; 接口和 &lt;code&gt;yield&lt;/code&gt; 关键字产生部分计算结果。生成器还可以通过 &lt;code&gt;yield *&lt;/code&gt; 在内部将调用委派给另一个可迭代的对象。例如：</target>
        </trans-unit>
        <trans-unit id="55463e892e31113c861aadf5f93e77a57de6240a" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://www.ecma-international.org/ecma-262/6.0/#sec-iteration&quot;&gt;ES2015 introduced &lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt;, which is an object that exposes three methods, &lt;code&gt;next&lt;/code&gt;, &lt;code&gt;return&lt;/code&gt;, and &lt;code&gt;throw&lt;/code&gt;, as per the following interface:</source>
          <target state="translated">&lt;a href=&quot;http://www.ecma-international.org/ecma-262/6.0/#sec-iteration&quot;&gt;ES2015引入了 &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt;，该对象根据以下接口公开了 &lt;code&gt;next&lt;/code&gt; ， &lt;code&gt;return&lt;/code&gt; 和 &lt;code&gt;throw&lt;/code&gt; 三种方法：</target>
        </trans-unit>
        <trans-unit id="12aa33cea9b5a79c35ec84291696eb4b59f9da1e" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://facebook.github.io/jsx/&quot;&gt;JSX&lt;/a&gt; is an embeddable XML-like syntax. It is meant to be transformed into valid JavaScript, though the semantics of that transformation are implementation-specific. JSX rose to popularity with the &lt;a href=&quot;https://reactjs.org/&quot;&gt;React&lt;/a&gt; framework, but has since seen other implementations as well. TypeScript supports embedding, type checking, and compiling JSX directly to JavaScript.</source>
          <target state="translated">&lt;a href=&quot;https://facebook.github.io/jsx/&quot;&gt;JSX&lt;/a&gt;是一种可嵌入的类似XML的语法。尽管该转换的语义是特定于实现的，但它应该转换为有效的JavaScript。JSX在&lt;a href=&quot;https://reactjs.org/&quot;&gt;React&lt;/a&gt;框架中开始流行，但此后也看到了其他实现。TypeScript支持嵌入，类型检查以及将JSX直接编译为JavaScript。</target>
        </trans-unit>
        <trans-unit id="4ef2642d51385f769ab651c082c9dff225d74fc2" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/33627&quot;&gt;Types in &lt;code&gt;lib.dom.d.ts&lt;/code&gt; have been updated&lt;/a&gt;. These changes are largely correctness changes related to nullability, but impact will ultimately depend on your codebase.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/33627&quot;&gt; &lt;code&gt;lib.dom.d.ts&lt;/code&gt; 中的类型已更新&lt;/a&gt;。这些更改很大程度上是与可空性相关的正确性更改，但是影响最终取决于您的代码库。</target>
        </trans-unit>
        <trans-unit id="0495fdef653ac880036cca0814e7297d71236b4d" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/umdjs/umd&quot;&gt;UMD modules&lt;/a&gt; check for the existence of a module loader environment. This is an easy-to-spot pattern that looks something like this:</source>
          <target state="translated">&lt;a href=&quot;https://github.com/umdjs/umd&quot;&gt;UMD模块&lt;/a&gt;检查是否存在模块加载器环境。这是一个易于发现的模式，看起来像这样：</target>
        </trans-unit>
        <trans-unit id="6fd7f9a4260cf4f7a8c5026d67e5c95d711d16e5" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a href=&quot;#table-of-contents&quot;&gt;↥ back to top&lt;/a&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;&lt;a href=&quot;#table-of-contents&quot;&gt;↥ back to top&lt;/a&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="fdbdf4e1369a70ccce916824139e46a9847d97a3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&quot;*&quot;&lt;/code&gt;: meaning the same name unchanged, so map &lt;code&gt;&amp;lt;moduleName&amp;gt;&lt;/code&gt; =&amp;gt; &lt;code&gt;&amp;lt;baseUrl&amp;gt;/&amp;lt;moduleName&amp;gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&quot;*&quot;&lt;/code&gt;: meaning the same name unchanged, so map &lt;code&gt;&amp;lt;moduleName&amp;gt;&lt;/code&gt; =&amp;gt; &lt;code&gt;&amp;lt;baseUrl&amp;gt;/&amp;lt;moduleName&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c73a6525d7eaa4824134e5210d19e488e565b563" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&quot;generated/*&quot;&lt;/code&gt; meaning the module name with an appended prefix &amp;ldquo;generated&amp;rdquo;, so map &lt;code&gt;&amp;lt;moduleName&amp;gt;&lt;/code&gt; =&amp;gt; &lt;code&gt;&amp;lt;baseUrl&amp;gt;/generated/&amp;lt;moduleName&amp;gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&quot;generated/*&quot;&lt;/code&gt; meaning the module name with an appended prefix &amp;ldquo;generated&amp;rdquo;, so map &lt;code&gt;&amp;lt;moduleName&amp;gt;&lt;/code&gt; =&amp;gt; &lt;code&gt;&amp;lt;baseUrl&amp;gt;/generated/&amp;lt;moduleName&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9c85a37d09c2e1af4c5f31661b285d4d1e16f641" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&quot;noImplicitAny&quot;&lt;/code&gt; is good idea whenever you&amp;rsquo;re writing new code &amp;mdash; you can make sure that you don&amp;rsquo;t write any untyped code by mistake. &lt;code&gt;&quot;compileOnSave&quot;&lt;/code&gt; makes it easy to update your code in a running web app.</source>
          <target state="translated">&lt;code&gt;&quot;noImplicitAny&quot;&lt;/code&gt; is good idea whenever you&amp;rsquo;re writing new code &amp;mdash; you can make sure that you don&amp;rsquo;t write any untyped code by mistake. &lt;code&gt;&quot;compileOnSave&quot;&lt;/code&gt; makes it easy to update your code in a running web app.</target>
        </trans-unit>
        <trans-unit id="fe58c3912d521e0998db0d63686a8a2d31499624" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&quot;rootDirs&quot;&lt;/code&gt; specify a list of &lt;em&gt;roots&lt;/em&gt; whose contents are expected to merge at run-time. So following our example, the &lt;code&gt;tsconfig.json&lt;/code&gt; file should look like:</source>
          <target state="translated">&lt;code&gt;&quot;rootDirs&quot;&lt;/code&gt; specify a list of &lt;em&gt;roots&lt;/em&gt; whose contents are expected to merge at run-time. So following our example, the &lt;code&gt;tsconfig.json&lt;/code&gt; file should look like:</target>
        </trans-unit>
        <trans-unit id="c7c3c22aa0fd78209c6c0e383e2528e7c6b4250d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;**/&lt;/code&gt; recursively matches any subdirectory</source>
          <target state="translated">&lt;code&gt;**/&lt;/code&gt; recursively matches any subdirectory</target>
        </trans-unit>
        <trans-unit id="5ff5a342935b5b9c3dc600fb9b3b727885179683" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;*&lt;/code&gt; matches zero or more characters (excluding directory separators)</source>
          <target state="translated">&lt;code&gt;*&lt;/code&gt; matches zero or more characters (excluding directory separators)</target>
        </trans-unit>
        <trans-unit id="8eb69c784cbac9dae7012fa8bd2d7bd07b8c923b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;+&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, &lt;code&gt;/&lt;/code&gt;, &lt;code&gt;%&lt;/code&gt;, &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;amp;&lt;/code&gt;, &lt;code&gt;|&lt;/code&gt;, &lt;code&gt;^&lt;/code&gt; binary operators with constant enum expressions as operands</source>
          <target state="translated">&lt;code&gt;+&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, &lt;code&gt;/&lt;/code&gt;, &lt;code&gt;%&lt;/code&gt;, &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;amp;&lt;/code&gt;, &lt;code&gt;|&lt;/code&gt;, &lt;code&gt;^&lt;/code&gt; binary operators with constant enum expressions as operands</target>
        </trans-unit>
        <trans-unit id="7bc75f886336759e26741a1a438d89e2625db989" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;--clean&lt;/code&gt;: Deletes the outputs of the specified projects (may be combined with &lt;code&gt;--dry&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;--clean&lt;/code&gt;: Deletes the outputs of the specified projects (may be combined with &lt;code&gt;--dry&lt;/code&gt;)</target>
        </trans-unit>
        <trans-unit id="d48e3154b28f82f1a4769c7208b3f989fff9e7b5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;--declaration&lt;/code&gt; and &lt;code&gt;--allowJs&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;--declaration&lt;/code&gt; and &lt;code&gt;--allowJs&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fed49d4e6bfaaf71c24b3551301b4023896fbba9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;--declarationDir&lt;/code&gt; allows for generating declaration files in a different location than JavaScript files.</source>
          <target state="translated">&lt;code&gt;--declarationDir&lt;/code&gt; allows for generating declaration files in a different location than JavaScript files.</target>
        </trans-unit>
        <trans-unit id="3a925ebadad3dc034212a013d96a8d028eec0d77" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;--dry&lt;/code&gt;: Shows what would be done but doesn&amp;rsquo;t actually build anything</source>
          <target state="translated">&lt;code&gt;--dry&lt;/code&gt;: Shows what would be done but doesn&amp;rsquo;t actually build anything</target>
        </trans-unit>
        <trans-unit id="391e7b99672708dcc5a82b9ab142640e75686d43" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;--emitDeclarationOnly&lt;/code&gt; allows for &lt;em&gt;only&lt;/em&gt; generating declaration files; &lt;code&gt;.js&lt;/code&gt;/&lt;code&gt;.jsx&lt;/code&gt; output generation will be skipped with this flag. The flag is useful when the &lt;code&gt;.js&lt;/code&gt; output generation is handled by a different transpiler like Babel.</source>
          <target state="translated">&lt;code&gt;--emitDeclarationOnly&lt;/code&gt; allows for &lt;em&gt;only&lt;/em&gt; generating declaration files; &lt;code&gt;.js&lt;/code&gt;/&lt;code&gt;.jsx&lt;/code&gt; output generation will be skipped with this flag. The flag is useful when the &lt;code&gt;.js&lt;/code&gt; output generation is handled by a different transpiler like Babel.</target>
        </trans-unit>
        <trans-unit id="e68274530cc65ca1af4f49f4f5cff04720ac0248" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;--emitDecoratorMetadata&lt;/code&gt;&lt;sup&gt;[1]&lt;/sup&gt;</source>
          <target state="translated">&lt;code&gt;--emitDecoratorMetadata&lt;/code&gt;&lt;sup&gt;[1]&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="9fb3da74ef87ed6a6c5cc462731d82c9d0c65e88" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;--experimentalDecorators&lt;/code&gt;&lt;sup&gt;[1]&lt;/sup&gt;</source>
          <target state="translated">&lt;code&gt;--experimentalDecorators&lt;/code&gt;&lt;sup&gt;[1]&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="d5a457b35b9491157c629e0302940182ccb5e23a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;--force&lt;/code&gt;: Act as if all projects are out of date</source>
          <target state="translated">&lt;code&gt;--force&lt;/code&gt;: Act as if all projects are out of date</target>
        </trans-unit>
        <trans-unit id="89e0256ea12246cd1a53115a0051e97b7166b303" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;--incremental&lt;/code&gt; improvements</source>
          <target state="translated">&lt;code&gt;--incremental&lt;/code&gt; improvements</target>
        </trans-unit>
        <trans-unit id="e2680bfd978e11406b01f962d148789dcac08317" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;--init&lt;/code&gt; command line option</source>
          <target state="translated">&lt;code&gt;--init&lt;/code&gt; command line option</target>
        </trans-unit>
        <trans-unit id="99720ca96a5b0e0056f6395f275543d0ff913fad" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;--inlineSourceMap&lt;/code&gt; and &lt;code&gt;inlineSources&lt;/code&gt; command line options</source>
          <target state="translated">&lt;code&gt;--inlineSourceMap&lt;/code&gt; and &lt;code&gt;inlineSources&lt;/code&gt; command line options</target>
        </trans-unit>
        <trans-unit id="3c3e1a02d6406f9e0f2c99dcba3493dd92f9d8a1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;--inlineSourceMap&lt;/code&gt; causes source map files to be written inline in the generated &lt;code&gt;.js&lt;/code&gt; files instead of in a independent &lt;code&gt;.js.map&lt;/code&gt; file. &lt;code&gt;--inlineSources&lt;/code&gt; allows for additionally inlining the source &lt;code&gt;.ts&lt;/code&gt; file into the &lt;code&gt;.js&lt;/code&gt; file.</source>
          <target state="translated">&lt;code&gt;--inlineSourceMap&lt;/code&gt; causes source map files to be written inline in the generated &lt;code&gt;.js&lt;/code&gt; files instead of in a independent &lt;code&gt;.js.map&lt;/code&gt; file. &lt;code&gt;--inlineSources&lt;/code&gt; allows for additionally inlining the source &lt;code&gt;.ts&lt;/code&gt; file into the &lt;code&gt;.js&lt;/code&gt; file.</target>
        </trans-unit>
        <trans-unit id="b5f213a09ff50e9dce71ecec1b24aff3aec8683c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;--newLine&lt;/code&gt; command line option</source>
          <target state="translated">&lt;code&gt;--newLine&lt;/code&gt; command line option</target>
        </trans-unit>
        <trans-unit id="458f3a7228c6223004510906f46ddc5c2a2fd92d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;--noEmitHelpers&lt;/code&gt; command line option</source>
          <target state="translated">&lt;code&gt;--noEmitHelpers&lt;/code&gt; command line option</target>
        </trans-unit>
        <trans-unit id="0312bee1e756b333574619a9dfc0a5e51d922e3b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;--pretty&lt;/code&gt; output by default</source>
          <target state="translated">&lt;code&gt;--pretty&lt;/code&gt; output by default</target>
        </trans-unit>
        <trans-unit id="4cacd6ae5c910b5d011312b91818b43c8dbca3da" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;--rootDir&lt;/code&gt; command line option</source>
          <target state="translated">&lt;code&gt;--rootDir&lt;/code&gt; command line option</target>
        </trans-unit>
        <trans-unit id="ed17502152114f93d8a25c9ca4ba3c08cc11bea3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;--rootDir&lt;/code&gt; specifies the input directory to be mirrored in output instead of computing it.</source>
          <target state="translated">&lt;code&gt;--rootDir&lt;/code&gt; specifies the input directory to be mirrored in output instead of computing it.</target>
        </trans-unit>
        <trans-unit id="ce69107c4ebefc8f6c4b27a523e9c10b6bac6045" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;--strictNullChecks&lt;/code&gt; switches to a new strict null checking mode.</source>
          <target state="translated">&lt;code&gt;--strictNullChecks&lt;/code&gt; switches to a new strict null checking mode.</target>
        </trans-unit>
        <trans-unit id="0e169771b2b9f04c32856782076ccdc93237e692" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;--target ESNext&lt;/code&gt; targets latest supported &lt;a href=&quot;https://github.com/tc39/proposals&quot;&gt;ES proposed features&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;--target ESNext&lt;/code&gt; targets latest supported &lt;a href=&quot;https://github.com/tc39/proposals&quot;&gt;ES proposed features&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="77f5b91bdc31f6e92780c04a56ba964c398b7284" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;--traceResolution&lt;/code&gt; offers a handy way to understand how modules have been resolved by the compiler.</source>
          <target state="translated">&lt;code&gt;--traceResolution&lt;/code&gt; offers a handy way to understand how modules have been resolved by the compiler.</target>
        </trans-unit>
        <trans-unit id="73f407030ac0547dfee747a39b87fbd94ad60948" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;--verbose&lt;/code&gt;: Prints out verbose logging to explain what&amp;rsquo;s going on (may be combined with any other flag)</source>
          <target state="translated">&lt;code&gt;--verbose&lt;/code&gt;: Prints out verbose logging to explain what&amp;rsquo;s going on (may be combined with any other flag)</target>
        </trans-unit>
        <trans-unit id="51fc8c433aeda1db44c3bcf0bd26afcf1442b203" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;--watch&lt;/code&gt; implementation of the compiler relies on &lt;code&gt;fs.watch&lt;/code&gt; and &lt;code&gt;fs.watchFile&lt;/code&gt; provided by node, both of these methods have pros and cons.</source>
          <target state="translated">&lt;code&gt;--watch&lt;/code&gt; implementation of the compiler relies on &lt;code&gt;fs.watch&lt;/code&gt; and &lt;code&gt;fs.watchFile&lt;/code&gt; provided by node, both of these methods have pros and cons.</target>
        </trans-unit>
        <trans-unit id="38362bf60068a8fc03024f53bf3a560d68cb7a68" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;--watch&lt;/code&gt;: Watch mode (may not be combined with any flag except &lt;code&gt;--verbose&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;--watch&lt;/code&gt;: Watch mode (may not be combined with any flag except &lt;code&gt;--verbose&lt;/code&gt;)</target>
        </trans-unit>
        <trans-unit id="e3f3b3fa6bf342d93e8863e2d8e9e6b14addae36" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;-noEmitOnError&lt;/code&gt; commandline option</source>
          <target state="translated">&lt;code&gt;-noEmitOnError&lt;/code&gt; commandline option</target>
        </trans-unit>
        <trans-unit id="327baae57d533178e63d7b713f4cf4788b983059" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;.js&lt;/code&gt; files are now allowed as input to &lt;code&gt;tsc&lt;/code&gt;. The TypeScript compiler checks the input &lt;code&gt;.js&lt;/code&gt; files for syntax errors, and emits valid output based on the &lt;code&gt;--target&lt;/code&gt; and &lt;code&gt;--module&lt;/code&gt; flags. The output can be combined with other &lt;code&gt;.ts&lt;/code&gt; files as well. Source maps are still generated for &lt;code&gt;.js&lt;/code&gt; files just like with &lt;code&gt;.ts&lt;/code&gt; files.</source>
          <target state="translated">&lt;code&gt;.js&lt;/code&gt; files are now allowed as input to &lt;code&gt;tsc&lt;/code&gt;. The TypeScript compiler checks the input &lt;code&gt;.js&lt;/code&gt; files for syntax errors, and emits valid output based on the &lt;code&gt;--target&lt;/code&gt; and &lt;code&gt;--module&lt;/code&gt; flags. The output can be combined with other &lt;code&gt;.ts&lt;/code&gt; files as well. Source maps are still generated for &lt;code&gt;.js&lt;/code&gt; files just like with &lt;code&gt;.ts&lt;/code&gt; files.</target>
        </trans-unit>
        <trans-unit id="03a3fca2c804aa362f9ea852d9bc2750659b10c6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;.js&lt;/code&gt; files are still checked to ensure that they only include standard ECMAScript features; type annotations are only allowed in &lt;code&gt;.ts&lt;/code&gt; files and are flagged as errors in &lt;code&gt;.js&lt;/code&gt; files. JSDoc comments can be used to add some type information to your JavaScript code, see &lt;a href=&quot;https://github.com/Microsoft/TypeScript/wiki/JSDoc-support-in-JavaScript&quot;&gt;JSDoc Support documentation&lt;/a&gt; for more details about the supported JSDoc constructs.</source>
          <target state="translated">&lt;code&gt;.js&lt;/code&gt; files are still checked to ensure that they only include standard ECMAScript features; type annotations are only allowed in &lt;code&gt;.ts&lt;/code&gt; files and are flagged as errors in &lt;code&gt;.js&lt;/code&gt; files. JSDoc comments can be used to add some type information to your JavaScript code, see &lt;a href=&quot;https://github.com/Microsoft/TypeScript/wiki/JSDoc-support-in-JavaScript&quot;&gt;JSDoc Support documentation&lt;/a&gt; for more details about the supported JSDoc constructs.</target>
        </trans-unit>
        <trans-unit id="90ab280d51b93fdaebf109f5c00c1bac5af53c79" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;// @ts-nocheck&lt;/code&gt; in TypeScript Files</source>
          <target state="translated">&lt;code&gt;// @ts-nocheck&lt;/code&gt; in TypeScript Files</target>
        </trans-unit>
        <trans-unit id="ccc749b3637aaa4c3979a2d33edcfc503506cc3f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;/// &amp;lt;amd-dependency path=&quot;x&quot; /&amp;gt;&lt;/code&gt; informs the compiler about a non-TS module dependency that needs to be injected in the resulting module&amp;rsquo;s require call.</source>
          <target state="translated">&lt;code&gt;/// &amp;lt;amd-dependency path=&quot;x&quot; /&amp;gt;&lt;/code&gt; informs the compiler about a non-TS module dependency that needs to be injected in the resulting module&amp;rsquo;s require call.</target>
        </trans-unit>
        <trans-unit id="7288e5b9a9753f562fe49deb813afdbf0087fb3d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;/// &amp;lt;amd-dependency path=&quot;x&quot; /&amp;gt;&lt;/code&gt; informs the compiler about a non-TS module dependency that needs to be injected in the resulting module&amp;rsquo;s require call; however, there was no way to consume this module in the TS code.</source>
          <target state="translated">&lt;code&gt;/// &amp;lt;amd-dependency path=&quot;x&quot; /&amp;gt;&lt;/code&gt; informs the compiler about a non-TS module dependency that needs to be injected in the resulting module&amp;rsquo;s require call; however, there was no way to consume this module in the TS code.</target>
        </trans-unit>
        <trans-unit id="9eece5866a10ade200011770d30646176a0b7c17" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;/// &amp;lt;reference lib=&quot;...&quot; /&amp;gt;&lt;/code&gt; reference directives</source>
          <target state="translated">&lt;code&gt;/// &amp;lt;reference lib=&quot;...&quot; /&amp;gt;&lt;/code&gt; reference directives</target>
        </trans-unit>
        <trans-unit id="68be6d84b0a2fdf1d5f2d8454eb02fa9cc63bc19" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;/// &amp;lt;reference&amp;gt;&lt;/code&gt;-ing a module</source>
          <target state="translated">&lt;code&gt;/// &amp;lt;reference&amp;gt;&lt;/code&gt;-ing a module</target>
        </trans-unit>
        <trans-unit id="091d09657c7b31c654b189dcd1f225f1a0ec984a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;/node_modules/moduleB/package.json&lt;/code&gt; (if it specifies a &lt;code&gt;&quot;main&quot;&lt;/code&gt; property)</source>
          <target state="translated">&lt;code&gt;/node_modules/moduleB/package.json&lt;/code&gt; (if it specifies a &lt;code&gt;&quot;main&quot;&lt;/code&gt; property)</target>
        </trans-unit>
        <trans-unit id="20ea10290a23b3740565e936d91702057ff37372" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;/node_modules/moduleB/package.json&lt;/code&gt; (if it specifies a &lt;code&gt;&quot;types&quot;&lt;/code&gt; property)</source>
          <target state="translated">&lt;code&gt;/node_modules/moduleB/package.json&lt;/code&gt; (if it specifies a &lt;code&gt;&quot;types&quot;&lt;/code&gt; property)</target>
        </trans-unit>
        <trans-unit id="9df7b034b6621c779b27d7c4dc7f558da205013a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;/root/node_modules/moduleB/package.json&lt;/code&gt; (if it specifies a &lt;code&gt;&quot;main&quot;&lt;/code&gt; property)</source>
          <target state="translated">&lt;code&gt;/root/node_modules/moduleB/package.json&lt;/code&gt; (if it specifies a &lt;code&gt;&quot;main&quot;&lt;/code&gt; property)</target>
        </trans-unit>
        <trans-unit id="4296e7cb4bf2356c30d2093a8e9404e55c92de63" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;/root/node_modules/moduleB/package.json&lt;/code&gt; (if it specifies a &lt;code&gt;&quot;types&quot;&lt;/code&gt; property)</source>
          <target state="translated">&lt;code&gt;/root/node_modules/moduleB/package.json&lt;/code&gt; (if it specifies a &lt;code&gt;&quot;types&quot;&lt;/code&gt; property)</target>
        </trans-unit>
        <trans-unit id="ef30e25aeff39df1c13b00397846be84602cf411" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;/root/src/moduleB/package.json&lt;/code&gt; (if it specifies a &lt;code&gt;&quot;types&quot;&lt;/code&gt; property)</source>
          <target state="translated">&lt;code&gt;/root/src/moduleB/package.json&lt;/code&gt; (if it specifies a &lt;code&gt;&quot;types&quot;&lt;/code&gt; property)</target>
        </trans-unit>
        <trans-unit id="98c853cb66dcb5dc8bcd3d05b08df126aa012e02" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;/root/src/node_modules/moduleB/package.json&lt;/code&gt; (if it specifies a &lt;code&gt;&quot;main&quot;&lt;/code&gt; property)</source>
          <target state="translated">&lt;code&gt;/root/src/node_modules/moduleB/package.json&lt;/code&gt; (if it specifies a &lt;code&gt;&quot;main&quot;&lt;/code&gt; property)</target>
        </trans-unit>
        <trans-unit id="5253ab85bf2484b7491317cdace822fde2760762" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;/root/src/node_modules/moduleB/package.json&lt;/code&gt; (if it specifies a &lt;code&gt;&quot;types&quot;&lt;/code&gt; property)</source>
          <target state="translated">&lt;code&gt;/root/src/node_modules/moduleB/package.json&lt;/code&gt; (if it specifies a &lt;code&gt;&quot;types&quot;&lt;/code&gt; property)</target>
        </trans-unit>
        <trans-unit id="69dd5451af8cbefbfd16c53fcdb71cc3040ab929" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;?&lt;/code&gt; matches any one character (excluding directory separators)</source>
          <target state="translated">&lt;code&gt;?&lt;/code&gt; matches any one character (excluding directory separators)</target>
        </trans-unit>
        <trans-unit id="510d9eec82bb462d81447db0531174b45f1b80bc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;@callback&lt;/code&gt; is similar to &lt;code&gt;@typedef&lt;/code&gt;, but it specifies a function type instead of an object type:</source>
          <target state="translated">&lt;code&gt;@callback&lt;/code&gt; is similar to &lt;code&gt;@typedef&lt;/code&gt;, but it specifies a function type instead of an object type:</target>
        </trans-unit>
        <trans-unit id="15e4ec66e698eca8fcacc4aef3b4a8740b21ad83" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;@class&lt;/code&gt; (or &lt;code&gt;@constructor&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;@class&lt;/code&gt; (or &lt;code&gt;@constructor&lt;/code&gt;)</target>
        </trans-unit>
        <trans-unit id="a9cd9b641abd25c6590bb4318e0d96edab2387c0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;@extends&lt;/code&gt; (or &lt;code&gt;@augments&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;@extends&lt;/code&gt; (or &lt;code&gt;@augments&lt;/code&gt;)</target>
        </trans-unit>
        <trans-unit id="1b149f9a357b0a3ec024cce9f5c3dc2328ec70cc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;@param&lt;/code&gt; (or &lt;code&gt;@arg&lt;/code&gt; or &lt;code&gt;@argument&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;@param&lt;/code&gt; (or &lt;code&gt;@arg&lt;/code&gt; or &lt;code&gt;@argument&lt;/code&gt;)</target>
        </trans-unit>
        <trans-unit id="f17c616498694e2538a5c3a14034458ed215aaf0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;@param&lt;/code&gt; allows a similar syntax for one-off type specifications. Note that the nested property names must be prefixed with the name of the parameter:</source>
          <target state="translated">&lt;code&gt;@param&lt;/code&gt; allows a similar syntax for one-off type specifications. Note that the nested property names must be prefixed with the name of the parameter:</target>
        </trans-unit>
        <trans-unit id="dd0e55fe627686baab0559a9cdef55576fc8bd55" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;@param&lt;/code&gt; and &lt;code&gt;@returns&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;@param&lt;/code&gt; and &lt;code&gt;@returns&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e7336752ac090f78d34c3d11b1ab23f55bc10fd2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;@param&lt;/code&gt; uses the same type syntax as &lt;code&gt;@type&lt;/code&gt;, but adds a parameter name. The parameter may also be declared optional by surrounding the name with square brackets:</source>
          <target state="translated">&lt;code&gt;@param&lt;/code&gt; uses the same type syntax as &lt;code&gt;@type&lt;/code&gt;, but adds a parameter name. The parameter may also be declared optional by surrounding the name with square brackets:</target>
        </trans-unit>
        <trans-unit id="58bf6cf80df0aa9192ae7829c488911d16a03ac6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;@returns&lt;/code&gt; (or &lt;code&gt;@return&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;@returns&lt;/code&gt; (or &lt;code&gt;@return&lt;/code&gt;)</target>
        </trans-unit>
        <trans-unit id="e9b067c8654340c958784799626e7b4c6447e4ff" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;@type&lt;/code&gt; can specify a union type &amp;mdash; for example, something can be either a string or a boolean.</source>
          <target state="translated">&lt;code&gt;@type&lt;/code&gt; can specify a union type &amp;mdash; for example, something can be either a string or a boolean.</target>
        </trans-unit>
        <trans-unit id="6370c9d00688eca8044b474975739ec7c282690c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;@typedef&lt;/code&gt; may be used to define complex types. Similar syntax works with &lt;code&gt;@param&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;@typedef&lt;/code&gt; may be used to define complex types. Similar syntax works with &lt;code&gt;@param&lt;/code&gt;.</target>
        </trans-unit>
        <trans-unit id="5d98ac31d277f8f7a055ef6892de9b33cd522d19" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;@typedef&lt;/code&gt;, &lt;code&gt;@callback&lt;/code&gt;, and &lt;code&gt;@param&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;@typedef&lt;/code&gt;, &lt;code&gt;@callback&lt;/code&gt;, and &lt;code&gt;@param&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4ea9a050b838e7b222925bd33fe2491686e61638" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;@types&lt;/code&gt;, &lt;code&gt;typeRoots&lt;/code&gt; and &lt;code&gt;types&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;@types&lt;/code&gt;, &lt;code&gt;typeRoots&lt;/code&gt; and &lt;code&gt;types&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="50cd5cdee6eaf1adbc6e1a7075eb9ed268b7c53d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;AMD&lt;/code&gt;, &lt;code&gt;CommonJs&lt;/code&gt;, &lt;code&gt;UMD&lt;/code&gt;, &lt;code&gt;System&lt;/code&gt; or &lt;code&gt;ES6&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;AMD&lt;/code&gt; ， &lt;code&gt;CommonJs&lt;/code&gt; ， &lt;code&gt;UMD&lt;/code&gt; ， &lt;code&gt;System&lt;/code&gt; 或 &lt;code&gt;ES6&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0dd47ffe31f15f736868359790118558f4c90d54" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;CRLF&lt;/code&gt; or &lt;code&gt;LF&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;CRLF&lt;/code&gt; 或 &lt;code&gt;LF&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3e18a27ec845bd07bc4bd92bd5a9491158c764b4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Classic&lt;/code&gt; or &lt;code&gt;Node&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Classic&lt;/code&gt; 或 &lt;code&gt;Node&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a55b3dc1847df4cc22875b738b3f0488ec130264" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ES3&lt;/code&gt;, &lt;code&gt;ES5&lt;/code&gt;, or &lt;code&gt;ES6&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;ES3&lt;/code&gt; ， &lt;code&gt;ES5&lt;/code&gt; 或 &lt;code&gt;ES6&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a1c84b65c2899e07c2577094ba71268f82bb4348" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Exclude&amp;lt;T, U&amp;gt;&lt;/code&gt; &amp;ndash; Exclude from &lt;code&gt;T&lt;/code&gt; those types that are assignable to &lt;code&gt;U&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Exclude&amp;lt;T, U&amp;gt;&lt;/code&gt; &amp;ndash;从 &lt;code&gt;T&lt;/code&gt; 中排除可分配给 &lt;code&gt;U&lt;/code&gt; 的那些类型。</target>
        </trans-unit>
        <trans-unit id="37b118234127720a534c99dc56aab386dafc6292" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Extract&amp;lt;T, U&amp;gt;&lt;/code&gt; &amp;ndash; Extract from &lt;code&gt;T&lt;/code&gt; those types that are assignable to &lt;code&gt;U&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Extract&amp;lt;T, U&amp;gt;&lt;/code&gt; &amp;ndash;从 &lt;code&gt;T&lt;/code&gt; 中提取可分配给 &lt;code&gt;U&lt;/code&gt; 的那些类型。</target>
        </trans-unit>
        <trans-unit id="731cd2078eec18fd1721cd773e8793bd578bbbb1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;InstanceType&amp;lt;T&amp;gt;&lt;/code&gt; &amp;ndash; Obtain the instance type of a constructor function type.</source>
          <target state="translated">&lt;code&gt;InstanceType&amp;lt;T&amp;gt;&lt;/code&gt; &amp;ndash;获取构造函数类型的实例类型。</target>
        </trans-unit>
        <trans-unit id="9f4f46cf1c3e00a0668406b1af262c9ac954f250" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MapToPromise&lt;/code&gt; takes a type &lt;code&gt;T&lt;/code&gt;, and when that type is a tuple like &lt;code&gt;Coordinate&lt;/code&gt;, only the numeric properties are converted. In &lt;code&gt;[number, number]&lt;/code&gt;, there are two numerically named properties: &lt;code&gt;0&lt;/code&gt; and &lt;code&gt;1&lt;/code&gt;. When given a tuple like that, &lt;code&gt;MapToPromise&lt;/code&gt; will create a new tuple where the &lt;code&gt;0&lt;/code&gt; and &lt;code&gt;1&lt;/code&gt; properties are &lt;code&gt;Promise&lt;/code&gt;s of the original type. So the resulting type &lt;code&gt;PromiseCoordinate&lt;/code&gt; ends up with the type &lt;code&gt;[Promise&amp;lt;number&amp;gt;, Promise&amp;lt;number&amp;gt;]&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;MapToPromise&lt;/code&gt; 的类型为 &lt;code&gt;T&lt;/code&gt; ，并且当该类型为类似 &lt;code&gt;Coordinate&lt;/code&gt; 的元组时，仅转换数字属性。在 &lt;code&gt;[number, number]&lt;/code&gt; ，有两个数字命名的属性： &lt;code&gt;0&lt;/code&gt; 和 &lt;code&gt;1&lt;/code&gt; 。当给定这样的元组时， &lt;code&gt;MapToPromise&lt;/code&gt; 将创建一个新的元组，其中 &lt;code&gt;0&lt;/code&gt; 和 &lt;code&gt;1&lt;/code&gt; 属性是原始类型的 &lt;code&gt;Promise&lt;/code&gt; 。因此，生成的 &lt;code&gt;PromiseCoordinate&lt;/code&gt; 类型最终以 &lt;code&gt;[Promise&amp;lt;number&amp;gt;, Promise&amp;lt;number&amp;gt;]&lt;/code&gt; 类型结束。</target>
        </trans-unit>
        <trans-unit id="3876e328c2a892ca260659a39ae1af62fabdd14a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Microsoft.TypeScript.Compiler&lt;/code&gt;: Tools only (&lt;code&gt;tsc.exe&lt;/code&gt;, &lt;code&gt;lib.d.ts&lt;/code&gt;, etc.) .</source>
          <target state="translated">&lt;code&gt;Microsoft.TypeScript.Compiler&lt;/code&gt; ：仅工具（ &lt;code&gt;tsc.exe&lt;/code&gt; ， &lt;code&gt;lib.d.ts&lt;/code&gt; 等）。</target>
        </trans-unit>
        <trans-unit id="50b10a71485a17634b805b9bf6d4a114d9b8719e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Microsoft.TypeScript.MSBuild&lt;/code&gt;: Tools as above, as well as MSBuild tasks and targets (&lt;code&gt;Microsoft.TypeScript.targets&lt;/code&gt;, &lt;code&gt;Microsoft.TypeScript.Default.props&lt;/code&gt;, etc.)</source>
          <target state="translated">&lt;code&gt;Microsoft.TypeScript.MSBuild&lt;/code&gt; ：上述工具以及MSBuild任务和目标（ &lt;code&gt;Microsoft.TypeScript.targets&lt;/code&gt; ， &lt;code&gt;Microsoft.TypeScript.Default.props&lt;/code&gt; 等）</target>
        </trans-unit>
        <trans-unit id="754f9ca6c2a9d6b75591a792a94899f3972d0dcd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;NonNullable&amp;lt;T&amp;gt;&lt;/code&gt; &amp;ndash; Exclude &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt; from &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;NonNullable&amp;lt;T&amp;gt;&lt;/code&gt; &amp;ndash; 从 &lt;code&gt;T&lt;/code&gt; 中排除 &lt;code&gt;null&lt;/code&gt; 和 &lt;code&gt;undefined&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bcae45288d3d0341f00e5f0a0c1e04f55875a283" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Number&lt;/code&gt;, &lt;code&gt;String&lt;/code&gt;, &lt;code&gt;Boolean&lt;/code&gt;, &lt;code&gt;Symbol&lt;/code&gt; and &lt;code&gt;Object&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Number&lt;/code&gt; ， &lt;code&gt;String&lt;/code&gt; ， &lt;code&gt;Boolean&lt;/code&gt; ， &lt;code&gt;Symbol&lt;/code&gt; 和 &lt;code&gt;Object&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e7ab4b2b1efc56a0da6b2f789333b4eeca92f504" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Object.defineProperty&lt;/code&gt; declarations in JavaScript</source>
          <target state="translated">&lt;code&gt;Object.defineProperty&lt;/code&gt; JavaScript中的Object.defineProperty声明</target>
        </trans-unit>
        <trans-unit id="516acae2c43a860256900e06b27f3de21816c8f7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Partial&lt;/code&gt; and &lt;code&gt;Readonly&lt;/code&gt;, as described earlier, are very useful constructs. You can use them to describe some common JS routines like:</source>
          <target state="translated">&lt;code&gt;Partial&lt;/code&gt; 如前所述，Partial和 &lt;code&gt;Readonly&lt;/code&gt; 是非常有用的构造。您可以使用它们来描述一些常见的JS例程，例如：</target>
        </trans-unit>
        <trans-unit id="8c5fb5be503d3cc99bc3891aa2f666671d256ce9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Partial&lt;/code&gt;, &lt;code&gt;Readonly&lt;/code&gt;, &lt;code&gt;Record&lt;/code&gt;, and &lt;code&gt;Pick&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Partial&lt;/code&gt; ， &lt;code&gt;Readonly&lt;/code&gt; ， &lt;code&gt;Record&lt;/code&gt; 和 &lt;code&gt;Pick&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1b9dce20c8a5593c22349b662be93f751022e541" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Readonly&lt;/code&gt;, &lt;code&gt;Partial&lt;/code&gt; and &lt;code&gt;Pick&lt;/code&gt; are homomorphic whereas &lt;code&gt;Record&lt;/code&gt; is not. One clue that &lt;code&gt;Record&lt;/code&gt; is not homomorphic is that it doesn&amp;rsquo;t take an input type to copy properties from:</source>
          <target state="translated">&lt;code&gt;Readonly&lt;/code&gt; ， &lt;code&gt;Partial&lt;/code&gt; 和 &lt;code&gt;Pick&lt;/code&gt; 是同态的，而 &lt;code&gt;Record&lt;/code&gt; 不是同态的。 &lt;code&gt;Record&lt;/code&gt; 不是同态的一个线索是它不需要输入类型来复制以下属性：</target>
        </trans-unit>
        <trans-unit id="e7f09457e713627cb3ff92a240363946a791f063" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ReturnType&amp;lt;T&amp;gt;&lt;/code&gt; &amp;ndash; Obtain the return type of a function type.</source>
          <target state="translated">&lt;code&gt;ReturnType&amp;lt;T&amp;gt;&lt;/code&gt; &amp;ndash;获取函数类型的返回类型。</target>
        </trans-unit>
        <trans-unit id="77a86605355daf9f91784a6e95367936d4e082b6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;abstract&lt;/code&gt; classes and methods</source>
          <target state="translated">&lt;code&gt;abstract&lt;/code&gt; 类和方法</target>
        </trans-unit>
        <trans-unit id="6b9f50e030bc7a5ce9cb5b43dfb74328d401c7c3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;any&lt;/code&gt;, &lt;code&gt;Object&lt;/code&gt;, and &lt;code&gt;{}&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;any&lt;/code&gt; ， &lt;code&gt;Object&lt;/code&gt; 和 &lt;code&gt;{}&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a7ed5d892c6e6d7a97395e1de27bc299c07f918b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;asserts condition&lt;/code&gt; says that whatever gets passed into the &lt;code&gt;condition&lt;/code&gt; parameter must be true if the &lt;code&gt;assert&lt;/code&gt; returns (because otherwise it would throw an error). That means that for the rest of the scope, that condition must be truthy. As an example, using this assertion function means we &lt;em&gt;do&lt;/em&gt; catch our original &lt;code&gt;yell&lt;/code&gt; example.</source>
          <target state="translated">&lt;code&gt;asserts condition&lt;/code&gt; 表示，如果 &lt;code&gt;assert&lt;/code&gt; 返回，则传递给 &lt;code&gt;condition&lt;/code&gt; 参数的任何内容都必须为true （因为否则会引发错误）。这意味着对于其余范围，该条件必须是真实的。举个例子，使用这个断言函数意味着我们&lt;em&gt;确实&lt;/em&gt;抓住了我们原来的 &lt;code&gt;yell&lt;/code&gt; 例子。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="4d81ac1481d5d350948454eb43f231d3dccd6195" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;async&lt;/code&gt;/&lt;code&gt;await&lt;/code&gt; support in ES6 targets (Node v4+)</source>
          <target state="translated">&lt;code&gt;async&lt;/code&gt; ES6目标（节点v4 +）中的异步 / &lt;code&gt;await&lt;/code&gt; 支持</target>
        </trans-unit>
        <trans-unit id="05b0a7f614edcf50ca6da583f1bb124c1000c419" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;compose&lt;/code&gt; takes two other functions:</source>
          <target state="translated">&lt;code&gt;compose&lt;/code&gt; 具有其他两个功能：</target>
        </trans-unit>
        <trans-unit id="a6f6815f367db078217340961910eed3f0c7f8e8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;compose&lt;/code&gt; then returns a function which feeds its argument through &lt;code&gt;f&lt;/code&gt; and then &lt;code&gt;g&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;compose&lt;/code&gt; 然后compose返回一个函数，该函数将其参数依次传递给 &lt;code&gt;f&lt;/code&gt; 和 &lt;code&gt;g&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cb41a6e05b71eb6e7a7f237a3f9d9323ff52b694" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;configs/base.json&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;configs/base.json&lt;/code&gt;:</target>
        </trans-unit>
        <trans-unit id="f321739617311f53c301a43c80e999c6085eb60a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;const enum&lt;/code&gt; (completely inlined enums)</source>
          <target state="translated">&lt;code&gt;const enum&lt;/code&gt; （完全内联的枚举）</target>
        </trans-unit>
        <trans-unit id="7e3ba5db3958314705ea44cd88cec272faaabfcb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;const&lt;/code&gt; assertions</source>
          <target state="translated">&lt;code&gt;const&lt;/code&gt; 断言</target>
        </trans-unit>
        <trans-unit id="012e49b5b90ab3812ce5d5459abd13d8a1d9c849" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;const&lt;/code&gt; declarations</source>
          <target state="translated">&lt;code&gt;const&lt;/code&gt; 声明</target>
        </trans-unit>
        <trans-unit id="fe167491a7d42fefa52129b16e1e621a2c31788a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;const&lt;/code&gt; declarations are another way of declaring variables.</source>
          <target state="translated">&lt;code&gt;const&lt;/code&gt; 声明是声明变量的另一种方法。</target>
        </trans-unit>
        <trans-unit id="f88c4d09927f47dc36c60e05f8c607beb8cd93c2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;const&lt;/code&gt; enums</source>
          <target state="translated">&lt;code&gt;const&lt;/code&gt; 枚举</target>
        </trans-unit>
        <trans-unit id="70efaa5f183560f377cb84a1789fe0834b27d50e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;const&lt;/code&gt; is only available when targeting ECMAScript 6 (&lt;code&gt;--target ES6&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;const&lt;/code&gt; 仅在定位ECMAScript 6（-- &lt;code&gt;--target ES6&lt;/code&gt; ）时可用。</target>
        </trans-unit>
        <trans-unit id="01ad1e1356fede9b7c214d93508aae720dfa9cb1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;declaration&lt;/code&gt; must be turned on</source>
          <target state="translated">&lt;code&gt;declaration&lt;/code&gt; 必须打开</target>
        </trans-unit>
        <trans-unit id="1401dfdf98b767d48685797471067283cd20a8d6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;declarationMap&lt;/code&gt;s</source>
          <target state="translated">&lt;code&gt;declarationMap&lt;/code&gt;s</target>
        </trans-unit>
        <trans-unit id="70f1caf45465e3b2f9b33169a10a4b2656de7399" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;default&lt;/code&gt; exports are really handy. For instance, a library like jQuery might have a default export of &lt;code&gt;jQuery&lt;/code&gt; or &lt;code&gt;$&lt;/code&gt;, which we&amp;rsquo;d probably also import under the name &lt;code&gt;$&lt;/code&gt; or &lt;code&gt;jQuery&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;default&lt;/code&gt; 出口真的很方便。例如，像jQuery之类的库可能具有 &lt;code&gt;jQuery&lt;/code&gt; 或 &lt;code&gt;$&lt;/code&gt; 的默认导出，我们也可能以 &lt;code&gt;$&lt;/code&gt; 或 &lt;code&gt;jQuery&lt;/code&gt; 的名称导入。</target>
        </trans-unit>
        <trans-unit id="30f55dfa5aca95ffd4b7a09bd7b9cc8eb2fadbc9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;default&lt;/code&gt; exports can also be just values:</source>
          <target state="translated">&lt;code&gt;default&lt;/code&gt; 导出也可以只是值：</target>
        </trans-unit>
        <trans-unit id="fc8b5fd9f825e6be680dd3514510f69b4616113c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;exclude&lt;/code&gt; property support in tsconfig.json</source>
          <target state="translated">&lt;code&gt;exclude&lt;/code&gt; 在tsconfig.json中排除属性支持</target>
        </trans-unit>
        <trans-unit id="4c9db716df5a416c78cae480a101fb21ea1e7a5c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;export *&lt;/code&gt; can be used to re-export all exports of another module. This is useful for creating modules that aggregate the exports of several other modules.</source>
          <target state="translated">&lt;code&gt;export *&lt;/code&gt; 可用于重新导出另一个模块的所有导出。这对于创建汇总其他几个模块的导出的模块很有用。</target>
        </trans-unit>
        <trans-unit id="6e636e798459cbffd9da7324b94596ca1840bafd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;export =&lt;/code&gt; and &lt;code&gt;import = require()&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;export =&lt;/code&gt; 和 &lt;code&gt;import = require()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3d288a4c439ec79c9f01ed90667a909f760945ab" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;extends&lt;/code&gt; is a new top-level property in &lt;code&gt;tsconfig.json&lt;/code&gt; (alongside &lt;code&gt;compilerOptions&lt;/code&gt;, &lt;code&gt;files&lt;/code&gt;, &lt;code&gt;include&lt;/code&gt;, and &lt;code&gt;exclude&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;extends&lt;/code&gt; 是一个新的顶级物业 &lt;code&gt;tsconfig.json&lt;/code&gt; （旁边 &lt;code&gt;compilerOptions&lt;/code&gt; ， &lt;code&gt;files&lt;/code&gt; ， &lt;code&gt;include&lt;/code&gt; 和 &lt;code&gt;exclude&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="9840158488dc62fdaa3cb62b51c0e8858b5791cd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;f&lt;/code&gt; which takes some argument (of type &lt;code&gt;A&lt;/code&gt;) and returns a value of type &lt;code&gt;B&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;f&lt;/code&gt; 接受某个参数（类型 &lt;code&gt;A&lt;/code&gt; ）并返回类型 &lt;code&gt;B&lt;/code&gt; 的值</target>
        </trans-unit>
        <trans-unit id="f44df04333c301a58f9a4eb14df232200a4137e3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;files&lt;/code&gt;, &lt;code&gt;include&lt;/code&gt; and &lt;code&gt;exclude&lt;/code&gt; from the inheriting config file &lt;em&gt;overwrite&lt;/em&gt; those from the base config file.</source>
          <target state="translated">&lt;code&gt;files&lt;/code&gt; 在继承的配置文件中 &lt;code&gt;include&lt;/code&gt; 和 &lt;code&gt;exclude&lt;/code&gt; 文件，将&lt;em&gt;覆盖&lt;/em&gt;基本配置文件中的文件。</target>
        </trans-unit>
        <trans-unit id="dbea6b2144138c02935bdf65a3a5978cc7d89931" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;for..of&lt;/code&gt; loops over an iterable object, invoking the &lt;code&gt;Symbol.iterator&lt;/code&gt; property on the object. Here is a simple &lt;code&gt;for..of&lt;/code&gt; loop on an array:</source>
          <target state="translated">&lt;code&gt;for..of&lt;/code&gt; 循环访问可迭代对象，并在该对象上调用 &lt;code&gt;Symbol.iterator&lt;/code&gt; 属性。这是数组上的一个简单的 &lt;code&gt;for..of&lt;/code&gt; 循环：</target>
        </trans-unit>
        <trans-unit id="e95fe318c23178a301fc252f057ad04a9fae6f4e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;for..of&lt;/code&gt; statements</source>
          <target state="translated">&lt;code&gt;for..of&lt;/code&gt; 语句</target>
        </trans-unit>
        <trans-unit id="12a8de33c0d1e331511a9ec2641ee2219e3cc903" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;for..of&lt;/code&gt; statements, Array Destructuring, and Spread elements in Array, Call, and New expressions support &lt;code&gt;Symbol.iterator&lt;/code&gt; in ES5/E3 if available when using &lt;code&gt;--downlevelIteration&lt;/code&gt;, but can be used on an Array even if it does not define &lt;code&gt;Symbol.iterator&lt;/code&gt; at run time or design time.</source>
          <target state="translated">&lt;code&gt;for..of&lt;/code&gt; 语句，数组解构以及在数组，调用和新表达式中的散布元素在ES5 / E3中支持 &lt;code&gt;Symbol.iterator&lt;/code&gt; （如果使用 &lt;code&gt;--downlevelIteration&lt;/code&gt; 时可用），但是即使未定义 &lt;code&gt;Symbol.iterator&lt;/code&gt; 也可以在数组上使用.iterator在运行时或设计时。</target>
        </trans-unit>
        <trans-unit id="8fb526d1bc7349c8b0a3895b057b40322758bab4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;for..of&lt;/code&gt; vs. &lt;code&gt;for..in&lt;/code&gt; statements</source>
          <target state="translated">&lt;code&gt;for..of&lt;/code&gt; 与 &lt;code&gt;for..in&lt;/code&gt; 语句</target>
        </trans-unit>
        <trans-unit id="8cf252545f201f3e3088e9c25cd8f91ad011a692" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;fs.watch&lt;/code&gt; uses file system events to notify the changes in the file/directory. But this is OS dependent and the notification is not completely reliable and does not work as expected on many OS. Also there could be limit on number of watches that can be created, eg. linux and we could exhaust it pretty quickly with programs that include large number of files. But because this uses file system events, there is not much CPU cycle involved. Compiler typically uses &lt;code&gt;fs.watch&lt;/code&gt; to watch directories (eg. source directories included by config file, directories in which module resolution failed etc) These can handle the missing precision in notifying about the changes. But recursive watching is supported on only Windows and OSX. That means we need something to replace the recursive nature on other OS.</source>
          <target state="translated">&lt;code&gt;fs.watch&lt;/code&gt; 使用文件系统事件来通知文件/目录中的更改。但这取决于操作系统，并且通知并不完全可靠，并且无法在许多操作系统上正常工作。另外，可以创建的手表数量可能会受到限制。 linux，我们可以使用包含大量文件的程序来快速耗尽它。但是因为这使用文件系统事件，所以不会涉及太多的CPU周期。编译器通常使用 &lt;code&gt;fs.watch&lt;/code&gt; 监视目录（例如，配置文件中包含的源目录，模块解析失败的目录等），这些可以处理通知更改时丢失的精度。但是仅Windows和OSX支持递归监视。这意味着我们需要一些东西来替代其他操作系统上的递归特性。</target>
        </trans-unit>
        <trans-unit id="ea889051fa717ee536ad67479b6a78c0ea9610ad" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;fs.watchFile&lt;/code&gt; uses polling and thus involves CPU cycles. But this is the most reliable mechanism to get the update on the status of file/directory. Compiler typically uses &lt;code&gt;fs.watchFile&lt;/code&gt; to watch source files, config files and missing files (missing file references) that means the CPU usage depends on number of files in the program.</source>
          <target state="translated">&lt;code&gt;fs.watchFile&lt;/code&gt; 使用轮询，因此涉及CPU周期。但这是获取文件/目录状态更新的最可靠的机制。编译器通常使用 &lt;code&gt;fs.watchFile&lt;/code&gt; 来监视源文件，配置文件和丢失的文件（缺少文件引用），这意味着CPU使用率取决于程序中文件的数量。</target>
        </trans-unit>
        <trans-unit id="d942c2a8b235d3c8b1abcc6b3de3eb5cad957fd4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;g&lt;/code&gt; which takes an argument of type &lt;code&gt;B&lt;/code&gt; (the type &lt;code&gt;f&lt;/code&gt; returned), and returns a value of type &lt;code&gt;C&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;g&lt;/code&gt; ，它接受 &lt;code&gt;B&lt;/code&gt; 类型的参数（返回的 &lt;code&gt;f&lt;/code&gt; 类型），并返回 &lt;code&gt;C&lt;/code&gt; 类型的值</target>
        </trans-unit>
        <trans-unit id="6ff0b88d92dd631bb6081ce9db31f440e26b7928" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;get&lt;/code&gt; and &lt;code&gt;set&lt;/code&gt; Accessors Are Allowed in Ambient Contexts</source>
          <target state="translated">&lt;code&gt;get&lt;/code&gt; 和 &lt;code&gt;set&lt;/code&gt; 访问者在环境中是允许的</target>
        </trans-unit>
        <trans-unit id="e49e1b432c62fc73ee50890c56c8ca86ec135992" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;import.meta&lt;/code&gt; Support in SystemJS</source>
          <target state="translated">&lt;code&gt;import.meta&lt;/code&gt; SystemJS中的import.meta支持</target>
        </trans-unit>
        <trans-unit id="0481e74e61bd0bd88c8e2325d45f8276eb589abf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;import.meta&lt;/code&gt; is only allowed when targeting &lt;code&gt;ESNext&lt;/code&gt; modules and ECMAScript targets.</source>
          <target state="translated">&lt;code&gt;import.meta&lt;/code&gt; 仅在将 &lt;code&gt;ESNext&lt;/code&gt; 模块和ECMAScript目标作为目标时才允许import.meta。</target>
        </trans-unit>
        <trans-unit id="24678ed6edc307f778f38669f8a75994d68cb176" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;import&lt;/code&gt; types</source>
          <target state="translated">&lt;code&gt;import&lt;/code&gt; 类型</target>
        </trans-unit>
        <trans-unit id="2bfe1d5b2564298c1ad9951a1d511481192d2cc8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;instanceof&lt;/code&gt; type guards</source>
          <target state="translated">&lt;code&gt;instanceof&lt;/code&gt; 类型守卫实例</target>
        </trans-unit>
        <trans-unit id="e96fbdf33bebac7a069682e69d1fd6d5b58e1236" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;keyof Car&lt;/code&gt; is completely interchangeable with &lt;code&gt;'manufacturer' | 'model' | 'year'&lt;/code&gt;. The difference is that if you add another property to &lt;code&gt;Car&lt;/code&gt;, say &lt;code&gt;ownersAddress: string&lt;/code&gt;, then &lt;code&gt;keyof Car&lt;/code&gt; will automatically update to be &lt;code&gt;'manufacturer' | 'model' | 'year' | 'ownersAddress'&lt;/code&gt;. And you can use &lt;code&gt;keyof&lt;/code&gt; in generic contexts like &lt;code&gt;pluck&lt;/code&gt;, where you can&amp;rsquo;t possibly know the property names ahead of time. That means the compiler will check that you pass the right set of property names to &lt;code&gt;pluck&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;keyof Car&lt;/code&gt; 可以与 &lt;code&gt;'manufacturer' | 'model' | 'year'&lt;/code&gt; 完全互换| '模型'| '年份'。区别在于，如果您向 &lt;code&gt;Car&lt;/code&gt; 添加另一个属性，比如 &lt;code&gt;ownersAddress: string&lt;/code&gt; ，那么 &lt;code&gt;keyof Car&lt;/code&gt; 将自动更新为 &lt;code&gt;'manufacturer' | 'model' | 'year' | 'ownersAddress'&lt;/code&gt; 。您还可以使用 &lt;code&gt;keyof&lt;/code&gt; 在一般环境中像 &lt;code&gt;pluck&lt;/code&gt; ，你不可能提前知道时间的属性名称。这意味着，编译器会检查你传递正确的一组属性名称 &lt;code&gt;pluck&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="1987a917ef43df8bddaa16f892f8677d58abfb2b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;keyof X&lt;/code&gt; is a union of the literal types representing string-like, number-like, and symbol-like properties.</source>
          <target state="translated">&lt;code&gt;keyof X&lt;/code&gt; 是文字类型的并集，它们代表类似字符串，类似数字和类似符号的属性。</target>
        </trans-unit>
        <trans-unit id="07209544abdfdc296d7eca721bd91539c66f16c9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;keyof&lt;/code&gt; and &lt;code&gt;T[K]&lt;/code&gt; interact with index signatures. An index signature parameter type must be &amp;lsquo;string&amp;rsquo; or &amp;lsquo;number&amp;rsquo;. If you have a type with a string index signature, &lt;code&gt;keyof T&lt;/code&gt; will be &lt;code&gt;string | number&lt;/code&gt; (and not just &lt;code&gt;string&lt;/code&gt;, since in JavaScript you can access an object property either by using strings (&lt;code&gt;object['42'&lt;/code&gt;]) or numbers (&lt;code&gt;object[42]&lt;/code&gt;)). And &lt;code&gt;T[string]&lt;/code&gt; is just the type of the index signature:</source>
          <target state="translated">&lt;code&gt;keyof&lt;/code&gt; 和 &lt;code&gt;T[K]&lt;/code&gt; 与索引签名交互。索引签名参数类型必须为&amp;ldquo;字符串&amp;rdquo;或&amp;ldquo;数字&amp;rdquo;。如果您的类型具有字符串索引签名，则 &lt;code&gt;keyof T&lt;/code&gt; 将为 &lt;code&gt;string | number&lt;/code&gt; （而不仅仅是 &lt;code&gt;string&lt;/code&gt; ，因为在JavaScript中，您可以使用字符串（ &lt;code&gt;object['42'&lt;/code&gt; ]）或数字（ &lt;code&gt;object[42]&lt;/code&gt; ）来访问对象属性。和 &lt;code&gt;T[string]&lt;/code&gt; 仅仅是指数的签名类型：</target>
        </trans-unit>
        <trans-unit id="23a74989aac5ff67841f237ba8439fe200c4f59e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;keyof&lt;/code&gt; and Lookup Types</source>
          <target state="translated">&lt;code&gt;keyof&lt;/code&gt; 和查找类型</target>
        </trans-unit>
        <trans-unit id="7587ea139b16cb3066fc1193552ad0a697db99ff" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;let&lt;/code&gt; and &lt;code&gt;const&lt;/code&gt; are two relatively new types of variable declarations in JavaScript. &lt;a href=&quot;basic-types#a-note-about-let&quot;&gt;As we mentioned earlier&lt;/a&gt;, &lt;code&gt;let&lt;/code&gt; is similar to &lt;code&gt;var&lt;/code&gt; in some respects, but allows users to avoid some of the common &amp;ldquo;gotchas&amp;rdquo; that users run into in JavaScript. &lt;code&gt;const&lt;/code&gt; is an augmentation of &lt;code&gt;let&lt;/code&gt; in that it prevents re-assignment to a variable.</source>
          <target state="translated">&lt;code&gt;let&lt;/code&gt; 和 &lt;code&gt;const&lt;/code&gt; 是JavaScript中两种相对较新的变量声明类型。&lt;a href=&quot;basic-types#a-note-about-let&quot;&gt;正如我们前面提到的&lt;/a&gt;， &lt;code&gt;let&lt;/code&gt; 在某些方面类似于 &lt;code&gt;var&lt;/code&gt; ，但是允许用户避免用户在JavaScript中遇到的一些常见&amp;ldquo;陷阱&amp;rdquo;。 &lt;code&gt;const&lt;/code&gt; 是 &lt;code&gt;let&lt;/code&gt; 的增强，因为它可以防止重新分配给变量。</target>
        </trans-unit>
        <trans-unit id="578f076915b9987c6c3b4ff784a24189b7365213" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;let&lt;/code&gt; and &lt;code&gt;const&lt;/code&gt; support</source>
          <target state="translated">&lt;code&gt;let&lt;/code&gt; 和 &lt;code&gt;const&lt;/code&gt; 支持</target>
        </trans-unit>
        <trans-unit id="6b776172d356ffcb9dd1ee020b2f44b56c7785dd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;let&lt;/code&gt; declarations</source>
          <target state="translated">&lt;code&gt;let&lt;/code&gt; 声明</target>
        </trans-unit>
        <trans-unit id="644591ecf7a7ac1044c0183c3798f150809bbe15" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;let&lt;/code&gt; declarations have drastically different behavior when declared as part of a loop. Rather than just introducing a new environment to the loop itself, these declarations sort of create a new scope &lt;em&gt;per iteration&lt;/em&gt;. Since this is what we were doing anyway with our IIFE, we can change our old &lt;code&gt;setTimeout&lt;/code&gt; example to just use a &lt;code&gt;let&lt;/code&gt; declaration.</source>
          <target state="translated">&lt;code&gt;let&lt;/code&gt; 当声明为循环的一部分时，let声明的行为将大不相同。这些声明不仅为循环本身引入了新的环境，还为&lt;em&gt;每次迭代&lt;/em&gt;创建了一个新的作用域。由于无论如何我们都是通过IIFE进行此操作，因此我们可以将旧的 &lt;code&gt;setTimeout&lt;/code&gt; 示例更改为仅使用 &lt;code&gt;let&lt;/code&gt; 声明。</target>
        </trans-unit>
        <trans-unit id="9f152c0c11e8b4f18e296dd980a05bfe53992b15" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;let&lt;/code&gt; is only available when targeting ECMAScript 6 (&lt;code&gt;--target ES6&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;let&lt;/code&gt; 仅在定位ECMAScript 6（-- &lt;code&gt;--target ES6&lt;/code&gt; ）时可用。</target>
        </trans-unit>
        <trans-unit id="2604695bf1219c913e9ce6e43a919233bb300fd4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;let&lt;/code&gt; vs. &lt;code&gt;const&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;let&lt;/code&gt; vs. &lt;code&gt;const&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="47597d61bef00139bb68777625c718cfe83c7a37" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;let&lt;/code&gt;, &lt;code&gt;const&lt;/code&gt;, and &lt;code&gt;var&lt;/code&gt; declarations</source>
          <target state="translated">&lt;code&gt;let&lt;/code&gt; ， &lt;code&gt;const&lt;/code&gt; 和 &lt;code&gt;var&lt;/code&gt; 声明</target>
        </trans-unit>
        <trans-unit id="a829bf2451c18e9c8300170bf81a48d5c7a14e26" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;module === &quot;system&quot;&lt;/code&gt; or &lt;code&gt;--esModuleInterop&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;module === &quot;system&quot;&lt;/code&gt; 或 &lt;code&gt;--esModuleInterop&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8aedd5acf8ab96c5aa7b3783ab936c10a1ae4b90" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;namespace&lt;/code&gt; keyword</source>
          <target state="translated">&lt;code&gt;namespace&lt;/code&gt; 关键字</target>
        </trans-unit>
        <trans-unit id="3757c64ba702c0e95ec29c43f6b3bcbac2dfaf79" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;never&lt;/code&gt; is a subtype of and assignable to every type.</source>
          <target state="translated">&lt;code&gt;never&lt;/code&gt; 是每种类型的子类型，并且可以分配给每种类型。</target>
        </trans-unit>
        <trans-unit id="dbf0fffc126fe6f7ef6fe8bd69ac432fc59ec7cf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;new.target&lt;/code&gt; also comes in handy for writing constructable functions, for example:</source>
          <target state="translated">&lt;code&gt;new.target&lt;/code&gt; 在编写可构造函数时也很方便，例如：</target>
        </trans-unit>
        <trans-unit id="38f8af0872a567ae1498db2400c8725c6f67981a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;new.target&lt;/code&gt; comes in handy when &lt;code&gt;Object.setPrototypeOf&lt;/code&gt; or &lt;code&gt;__proto__&lt;/code&gt; needs to be set in a class constructor. One such use case is inheriting from &lt;code&gt;Error&lt;/code&gt; in NodeJS v4 and higher.</source>
          <target state="translated">&lt;code&gt;new.target&lt;/code&gt; 当需要在类构造函数中设置 &lt;code&gt;Object.setPrototypeOf&lt;/code&gt; 或 &lt;code&gt;__proto__&lt;/code&gt; 时，new.target会派上用场。一种这样的用例是从NodeJS v4和更高版本中的 &lt;code&gt;Error&lt;/code&gt; 继承的。</target>
        </trans-unit>
        <trans-unit id="c23e511cadd633529e9b1516004a6ec203d2f65d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;noFallthroughCasesInSwitch&lt;/code&gt; which is helpful if you never want to forget a &lt;code&gt;break&lt;/code&gt; statement between &lt;code&gt;case&lt;/code&gt;s in a &lt;code&gt;switch&lt;/code&gt; block.</source>
          <target state="translated">&lt;code&gt;noFallthroughCasesInSwitch&lt;/code&gt; ，如果您永远不想忘记 &lt;code&gt;switch&lt;/code&gt; 块中 &lt;code&gt;case&lt;/code&gt; s 之间的 &lt;code&gt;break&lt;/code&gt; 语句，则很有用。</target>
        </trans-unit>
        <trans-unit id="17b5ef3461c6310cbfb2829b36fa9f54629275f7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;noImplicitAny&lt;/code&gt; : Raise error on expressions and declarations with an implied &lt;code&gt;any&lt;/code&gt; type.</source>
          <target state="translated">&lt;code&gt;noImplicitAny&lt;/code&gt; ：在隐含 &lt;code&gt;any&lt;/code&gt; 类型的表达式和声明上引发错误。</target>
        </trans-unit>
        <trans-unit id="8b684ebe24425d0ae00fe5f4dd392279dd756e18" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;noImplicitReturns&lt;/code&gt; which prevents you from forgetting to return at the end of a function.</source>
          <target state="translated">&lt;code&gt;noImplicitReturns&lt;/code&gt; 防止您忘记在函数末尾返回。</target>
        </trans-unit>
        <trans-unit id="e88ad4b11b76f0b52388960f7fb144596753b33f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;object&lt;/code&gt; is a type that represents the non-primitive type, i.e. anything that is not &lt;code&gt;number&lt;/code&gt;, &lt;code&gt;string&lt;/code&gt;, &lt;code&gt;boolean&lt;/code&gt;, &lt;code&gt;bigint&lt;/code&gt;, &lt;code&gt;symbol&lt;/code&gt;, &lt;code&gt;null&lt;/code&gt;, or &lt;code&gt;undefined&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;object&lt;/code&gt; 是代表非基本类型的类型，即不是 &lt;code&gt;number&lt;/code&gt; ， &lt;code&gt;string&lt;/code&gt; ， &lt;code&gt;boolean&lt;/code&gt; ， &lt;code&gt;bigint&lt;/code&gt; ， &lt;code&gt;symbol&lt;/code&gt; ， &lt;code&gt;null&lt;/code&gt; 或 &lt;code&gt;undefined&lt;/code&gt; 的任何类型。</target>
        </trans-unit>
        <trans-unit id="26b459667b63171c9a2bfca987e324fd67266a33" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;object&lt;/code&gt; type</source>
          <target state="translated">&lt;code&gt;object&lt;/code&gt; 类型</target>
        </trans-unit>
        <trans-unit id="a1c2b17b7aa15d4b6c554df6d3c6079bd7ea6b62" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;onEmitOnError&lt;/code&gt; : Do not emit outputs if any errors were reported.</source>
          <target state="translated">&lt;code&gt;onEmitOnError&lt;/code&gt; ：如果报告了任何错误，则不发出输出。</target>
        </trans-unit>
        <trans-unit id="d36f089a00eed6e2a38161e562ca2eadbc3a0ba3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;paths&lt;/code&gt;&lt;sup&gt;[2]&lt;/sup&gt;</source>
          <target state="translated">&lt;code&gt;paths&lt;/code&gt;&lt;sup&gt;[2]&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="7271647d356fdf53e4881a83f2b3d24088d1ce22" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pet is Fish&lt;/code&gt; is our type predicate in this example. A predicate takes the form &lt;code&gt;parameterName is Type&lt;/code&gt;, where &lt;code&gt;parameterName&lt;/code&gt; must be the name of a parameter from the current function signature.</source>
          <target state="translated">&lt;code&gt;pet is Fish&lt;/code&gt; 在此示例中，pet is Fish是我们的类型谓词。谓词的形式为 &lt;code&gt;parameterName is Type&lt;/code&gt; ，其中 &lt;code&gt;parameterName&lt;/code&gt; 必须是当前函数签名中参数的名称。</target>
        </trans-unit>
        <trans-unit id="d591a35ea43b09e97945e00e88029db5bb27c2b9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;prepend&lt;/code&gt; with &lt;code&gt;outFile&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;prepend&lt;/code&gt; 与 &lt;code&gt;outFile&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f48ad12a1bd9b139a251683c44c9c037d0781daa" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;react&lt;/code&gt;, &lt;code&gt;react-native&lt;/code&gt;, &lt;code&gt;preserve&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;react&lt;/code&gt; ， &lt;code&gt;react-native&lt;/code&gt; ， &lt;code&gt;preserve&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="265f731b05abd126578741df3ef1317127023ebd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;readonly&lt;/code&gt; mapped type modifiers and &lt;code&gt;readonly&lt;/code&gt; arrays</source>
          <target state="translated">&lt;code&gt;readonly&lt;/code&gt; 映射的类型修饰符和 &lt;code&gt;readonly&lt;/code&gt; 数组</target>
        </trans-unit>
        <trans-unit id="0a72bebc41b3c89da2f3cb186861c5375dc8d827" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;readonly&lt;/code&gt; tuples</source>
          <target state="translated">&lt;code&gt;readonly&lt;/code&gt; 元组</target>
        </trans-unit>
        <trans-unit id="8f3d715459a937e9292de095a19bf986d41e03e3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;readonly&lt;/code&gt; vs &lt;code&gt;const&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;readonly&lt;/code&gt; vs &lt;code&gt;const&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="204249cb0d243afb180412fa55d150953da5fecd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rootDirs&lt;/code&gt;&lt;sup&gt;[2]&lt;/sup&gt;</source>
          <target state="translated">&lt;code&gt;rootDirs&lt;/code&gt;&lt;sup&gt;[2]&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="4c4934c028db6c4d82b88f32de53708b229fb87e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sourceMap&lt;/code&gt; : Generates corresponding &lt;code&gt;.map&lt;/code&gt; file.</source>
          <target state="translated">&lt;code&gt;sourceMap&lt;/code&gt; ：生成相应的 &lt;code&gt;.map&lt;/code&gt; 文件。</target>
        </trans-unit>
        <trans-unit id="d0b7403357a0651ddeff1c1122a8b2bb08ffe8e1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;strictNullChecks&lt;/code&gt; is disabled</source>
          <target state="translated">&lt;code&gt;strictNullChecks&lt;/code&gt; 已禁用</target>
        </trans-unit>
        <trans-unit id="8dbbf233507908fb7d0aaad278a5681b3a14a678" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;symbol&lt;/code&gt; values are created by calling the &lt;code&gt;Symbol&lt;/code&gt; constructor.</source>
          <target state="translated">&lt;code&gt;symbol&lt;/code&gt; 值是通过调用 &lt;code&gt;Symbol&lt;/code&gt; 构造函数创建的。</target>
        </trans-unit>
        <trans-unit id="df548ecfe43e1bd5edc74f5f9d9e11e7c489fabb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;target&lt;/code&gt; : Specify ECMAScript target version.</source>
          <target state="translated">&lt;code&gt;target&lt;/code&gt; ：指定ECMAScript目标版本。</target>
        </trans-unit>
        <trans-unit id="41807fdfe0d78a471df79e23ac828c29a48b1df2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;this is T&lt;/code&gt; is now valid return type annotation for methods in classes and interfaces. When used in a type narowing position (e.g. &lt;code&gt;if&lt;/code&gt; statement), the type of the call expression target object would be narrowed to &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;this is T&lt;/code&gt; ，现在是类和接口中方法的有效返回类型注释。当在型narowing位置使用（例如 &lt;code&gt;if&lt;/code&gt; 语句）中，呼叫目标表达对象的类型将被缩小到 &lt;code&gt;T&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a25fe4991728ca46519e506de1d8f666a6c8b7fb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;this: void&lt;/code&gt; means that &lt;code&gt;addClickListener&lt;/code&gt; expects &lt;code&gt;onclick&lt;/code&gt; to be a function that does not require a &lt;code&gt;this&lt;/code&gt; type.</source>
          <target state="translated">&lt;code&gt;this: void&lt;/code&gt; 表示 &lt;code&gt;addClickListener&lt;/code&gt; 期望 &lt;code&gt;onclick&lt;/code&gt; 是不需要 &lt;code&gt;this&lt;/code&gt; 类型的函数。</target>
        </trans-unit>
        <trans-unit id="a9953e41bed91beb356ec58e55940c473593811e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;this: void&lt;/code&gt; means that &lt;code&gt;addClickListener&lt;/code&gt; expects &lt;code&gt;onclick&lt;/code&gt; to be a function that does not require a &lt;code&gt;this&lt;/code&gt; type. Second, annotate your calling code with &lt;code&gt;this&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;this: void&lt;/code&gt; 表示 &lt;code&gt;addClickListener&lt;/code&gt; 期望 &lt;code&gt;onclick&lt;/code&gt; 是不需要 &lt;code&gt;this&lt;/code&gt; 类型的函数。其次，随着注解你调用代码 &lt;code&gt;this&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="239502a5db9c22853dabbf84a0a02ea54ae32760" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;this&lt;/code&gt; and arrow functions</source>
          <target state="translated">&lt;code&gt;this&lt;/code&gt; 和箭头功能</target>
        </trans-unit>
        <trans-unit id="f6b4a05163d3be8c272019de111de564106390bb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;this&lt;/code&gt; parameters</source>
          <target state="translated">&lt;code&gt;this&lt;/code&gt; 参数</target>
        </trans-unit>
        <trans-unit id="9ba826b0f4b51964bc2dcb2689ad5e6718b4d812" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;this&lt;/code&gt; parameters in callbacks</source>
          <target state="translated">&lt;code&gt;this&lt;/code&gt; 回调中的此参数</target>
        </trans-unit>
        <trans-unit id="76a17c6a78a4a91182cb755f2d1f82d0e8352047" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;this&lt;/code&gt;-based type guards</source>
          <target state="translated">&lt;code&gt;this&lt;/code&gt; 基于此的类型防护</target>
        </trans-unit>
        <trans-unit id="80d7365686580943b61bcc0680fdd9fefd9bb9d0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;this&lt;/code&gt;-typing</source>
          <target state="translated">&lt;code&gt;this&lt;/code&gt;-typing</target>
        </trans-unit>
        <trans-unit id="a5626b5c92a5a1772a40e47f83129a6cdaba494c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if &lt;code&gt;composite&lt;/code&gt; is on, &lt;code&gt;false&lt;/code&gt; otherwise</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; 如果启用 &lt;code&gt;composite&lt;/code&gt; 则为true，否则为 &lt;code&gt;false&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="15a6e88c2494ea9288969156547c6f6523ee7397" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; unless piping to another program or redirecting output to a file</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; 除非传递到另一个程序或将输出重定向到文件，否则为true</target>
        </trans-unit>
        <trans-unit id="5827602d127a01fcf210389ba5b4073a09f73f65" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;tsc -b&lt;/code&gt; Commandline</source>
          <target state="translated">&lt;code&gt;tsc -b&lt;/code&gt; 命令行</target>
        </trans-unit>
        <trans-unit id="5fbf7438323e3bbf152cf8686704d6a9b92eda48" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;tsc -w&lt;/code&gt; can&amp;rsquo;t run on multiple config files at once</source>
          <target state="translated">&lt;code&gt;tsc -w&lt;/code&gt; 不能一次在多个配置文件上运行</target>
        </trans-unit>
        <trans-unit id="147a626c1d03568f0d86b81b12aca475f5e24705" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;tsc&lt;/code&gt; will only ever use existing files on disk to do this process, so it&amp;rsquo;s possible to create a project where a correct output file can&amp;rsquo;t be generated because some project&amp;rsquo;s output would be present more than once in the resulting file. For example:</source>
          <target state="translated">&lt;code&gt;tsc&lt;/code&gt; 只会使用磁盘上的现有文件来执行此过程，因此可以创建一个无法生成正确输出文件的项目，因为某些项目的输出会在结果文件中多次出现。例如：</target>
        </trans-unit>
        <trans-unit id="98564db040acf2bf7b395e1d0a36df38b4a8402f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;tsc&lt;/code&gt;, the TypeScript compiler, supports a new flag called &lt;code&gt;--showConfig&lt;/code&gt;. When running &lt;code&gt;tsc --showConfig&lt;/code&gt;, TypeScript will calculate the effective &lt;code&gt;tsconfig.json&lt;/code&gt; (after calculating options inherited from the &lt;code&gt;extends&lt;/code&gt; field) and print that out. This can be useful for diagnosing configuration issues in general.</source>
          <target state="translated">&lt;code&gt;tsc&lt;/code&gt; 是TypeScript编译器，它支持一个名为 &lt;code&gt;--showConfig&lt;/code&gt; 的新标志。当运行 &lt;code&gt;tsc --showConfig&lt;/code&gt; 时，TypeScript将计算有效的 &lt;code&gt;tsconfig.json&lt;/code&gt; （在计算从 &lt;code&gt;extends&lt;/code&gt; 字段继承的选项之后）并打印出来。通常，这对于诊断配置问题很有用。</target>
        </trans-unit>
        <trans-unit id="54a7f5e8734c14fa7d0a8d6777c5b5ac6fa8ca44" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;tsconfig.json&lt;/code&gt; files have a new top-level property, &lt;code&gt;references&lt;/code&gt;. It&amp;rsquo;s an array of objects that specifies projects to reference:</source>
          <target state="translated">&lt;code&gt;tsconfig.json&lt;/code&gt; 文件具有一个新的顶级属性 &lt;code&gt;references&lt;/code&gt; 。它是一个对象数组，用于指定要引用的项目：</target>
        </trans-unit>
        <trans-unit id="c8d62e6e595e456c5e9270cc34e832ead6a38881" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;tsconfig.json&lt;/code&gt; inheritance via Node.js packages</source>
          <target state="translated">&lt;code&gt;tsconfig.json&lt;/code&gt; 通过Node.js包的继承</target>
        </trans-unit>
        <trans-unit id="e2d6ff9ec9b1c03f6c4865dd1b1475c13329c97c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;tsconfig.json&lt;/code&gt; turns a folder into a &amp;ldquo;project&amp;rdquo;. Without specifying any &lt;code&gt;&amp;ldquo;exclude&amp;rdquo;&lt;/code&gt; or &lt;code&gt;&amp;ldquo;files&amp;rdquo;&lt;/code&gt; entries, all files in the folder containing the &lt;code&gt;tsconfig.json&lt;/code&gt; and all its sub-directories are included in your compilation. If you want to exclude some of the files use &lt;code&gt;&amp;ldquo;exclude&amp;rdquo;&lt;/code&gt;, if you would rather specify all the files instead of letting the compiler look them up, use &lt;code&gt;&amp;ldquo;files&amp;rdquo;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;tsconfig.json&lt;/code&gt; 将文件夹变成&amp;ldquo;项目&amp;rdquo;。在不指定任何 &lt;code&gt;&amp;ldquo;exclude&amp;rdquo;&lt;/code&gt; 或 &lt;code&gt;&amp;ldquo;files&amp;rdquo;&lt;/code&gt; 条目的情况下，包含 &lt;code&gt;tsconfig.json&lt;/code&gt; 及其所有子目录的文件夹中的所有文件都包含在编译中。如果要排除某些文件，请使用 &lt;code&gt;&amp;ldquo;exclude&amp;rdquo;&lt;/code&gt; ，如果要指定所有文件而不是让编译器查找它们，请使用 &lt;code&gt;&amp;ldquo;files&amp;rdquo;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="44461f86b394f4690605fa32353147f0c499cba8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;tsconfig.json&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;tsconfig.json&lt;/code&gt;:</target>
        </trans-unit>
        <trans-unit id="dce89073ea61332463e4bc7ffcd226cfebb38fb7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;tsconfig.nostrictnull.json&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;tsconfig.nostrictnull.json&lt;/code&gt;:</target>
        </trans-unit>
        <trans-unit id="802c612cac10d8e06122f662232f3d40cbb16c55" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;typeof&lt;/code&gt; type guards</source>
          <target state="translated">&lt;code&gt;typeof&lt;/code&gt; 运算型后卫</target>
        </trans-unit>
        <trans-unit id="ba1416688590a42ec8a707493a8a76f4bafb32ca" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;typesVersions&lt;/code&gt; can support multiple fields where each field name is specified by the range to match on.</source>
          <target state="translated">&lt;code&gt;typesVersions&lt;/code&gt; 可以支持多个字段，其中每个字段名称均由要匹配的范围指定。</target>
        </trans-unit>
        <trans-unit id="16c59fd04173482af55d5dc102886aa00a3441e8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;var&lt;/code&gt; declarations</source>
          <target state="translated">&lt;code&gt;var&lt;/code&gt; 声明</target>
        </trans-unit>
        <trans-unit id="ab9085fb15ab9e328c2c89a7b70fa880194687cc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;var&lt;/code&gt; declarations have some odd scoping rules for those used to other languages. Take the following example:</source>
          <target state="translated">&lt;code&gt;var&lt;/code&gt; 声明对于其他语言使用的规则具有一些奇怪的作用域规则。请看以下示例：</target>
        </trans-unit>
        <trans-unit id="e6f91793a72a6bf2a9f9865634b43e9fe9ffea71" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;void&lt;/code&gt; is a little like the opposite of &lt;code&gt;any&lt;/code&gt;: the absence of having any type at all. You may commonly see this as the return type of functions that do not return a value:</source>
          <target state="translated">&lt;code&gt;void&lt;/code&gt; 有点像 &lt;code&gt;any&lt;/code&gt; 的相反：根本没有任何类型。您可能通常将其视为不返回值的函数的返回类型：</target>
        </trans-unit>
        <trans-unit id="5162ce142c852c721ea4c2f90dcd96e468cd2c12" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;y&lt;/code&gt; would have the type &lt;code&gt;any&lt;/code&gt;. This meant the program would type-check, but you could technically do anything with &lt;code&gt;y&lt;/code&gt;, such as the following:</source>
          <target state="translated">&lt;code&gt;y&lt;/code&gt; 的类型为 &lt;code&gt;any&lt;/code&gt; 。这意味着程序将进行类型检查，但是从技术上讲，您可以使用 &lt;code&gt;y&lt;/code&gt; 进行任何操作，例如：</target>
        </trans-unit>
        <trans-unit id="27cc4133a65e863977268415e96540e32efacbaa" translate="yes" xml:space="preserve">
          <source>&lt;del&gt;&lt;code&gt;--out&lt;/code&gt;&lt;/del&gt;</source>
          <target state="translated">&lt;del&gt;&lt;code&gt;--out&lt;/code&gt;&lt;/del&gt;</target>
        </trans-unit>
        <trans-unit id="c1b2e33284cd8b33b99364f12379b80c308e775f" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;(common root directory is computed from the list of input files)&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;(common root directory is computed from the list of input files)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="67f8a82845ea83174fddc0273791def9f3791ba2" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;(platform specific)&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;(platform specific)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="bcd153da1f3527d871cddfa9877fa2d91c2500ea" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;&lt;code&gt;instanceof&lt;/code&gt; type guards&lt;/em&gt; are a way of narrowing types using their constructor function. For instance, let&amp;rsquo;s borrow our industrial string-padder example from earlier:</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;instanceof&lt;/code&gt; 类型防护&lt;/em&gt;是使用其构造函数缩小类型的一种方法。例如，让我们借用前面的工业字符串填充器示例：</target>
        </trans-unit>
        <trans-unit id="5c97a851324ff9563ea3a21efd2d3c3c258c8c52" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Any compiler option&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;任何编译器选项&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6848663f06841c4836ef827c8d46d2b7df3d9e2e" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Class Decorators&lt;/em&gt; are applied for the class.</source>
          <target state="translated">&lt;em&gt;类装饰器&lt;/em&gt;应用于该类。</target>
        </trans-unit>
        <trans-unit id="46261c91e2d02cefcc599506ebcf0fdd9241cca2" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Code&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Code&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b095cf5579d916d24a5da3d12744c26e407ebcb8" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Configure the TypeScript compiler&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;配置TypeScript编译器&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="116f39d7e603ae15f6176b14608384bdd2f4ccc5" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Declaration&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Declaration&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="3144417886ddc6e09e0cb50372c04d88ab6ff96c" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Do&lt;/em&gt; depend on the npm type declaration package if it doesn&amp;rsquo;t package its declaration files.</source>
          <target state="translated">&lt;em&gt;&lt;/em&gt;如果不打包其声明文件，请&lt;em&gt;务必&lt;/em&gt;依赖npm类型声明包。</target>
        </trans-unit>
        <trans-unit id="a89db8b7cceca187803f1966f48b0b78dc6807c5" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Do&lt;/em&gt; sort overloads by putting the more general signatures after more specific signatures:</source>
          <target state="translated">&lt;em&gt;不要&lt;/em&gt;通过将更多的普通签名后更具体的签名排序重载：</target>
        </trans-unit>
        <trans-unit id="74d4dbaa7a29534baf764d9d7745b59ff457b95c" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Do&lt;/em&gt; use &lt;code&gt;/// &amp;lt;reference types=&quot;...&quot; /&amp;gt;&lt;/code&gt; instead.</source>
          <target state="translated">&lt;em&gt;请&lt;/em&gt;改用 &lt;code&gt;/// &amp;lt;reference types=&quot;...&quot; /&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a8abf42191e985fd38d25cbfd61b4478044adfc0" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Do&lt;/em&gt; use optional parameters whenever possible:</source>
          <target state="translated">&lt;em&gt;请&lt;/em&gt;尽可能使用可选参数：</target>
        </trans-unit>
        <trans-unit id="e34280b76cbb108a56a72b557e087d65bbfca383" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Do&lt;/em&gt; use the return type &lt;code&gt;void&lt;/code&gt; for callbacks whose value will be ignored:</source>
          <target state="translated">&lt;em&gt;不要&lt;/em&gt;使用返回类型 &lt;code&gt;void&lt;/code&gt; 回调，其价值将被忽略：</target>
        </trans-unit>
        <trans-unit id="c2582d04d57e5a9ca2606283a30a617ee529f638" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Do&lt;/em&gt; use the types &lt;code&gt;number&lt;/code&gt;, &lt;code&gt;string&lt;/code&gt;, &lt;code&gt;boolean&lt;/code&gt;, and &lt;code&gt;symbol&lt;/code&gt;.</source>
          <target state="translated">&lt;em&gt;请&lt;/em&gt;使用 &lt;code&gt;number&lt;/code&gt; ， &lt;code&gt;string&lt;/code&gt; ， &lt;code&gt;boolean&lt;/code&gt; 和 &lt;code&gt;symbol&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="03ab3ac84230901f9c46e90452077394873671fb" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Do&lt;/em&gt; use union types whenever possible:</source>
          <target state="translated">&lt;em&gt;不要&lt;/em&gt;使用联合类型时参考：</target>
        </trans-unit>
        <trans-unit id="be31bfe1264c4f25766db39e5b90a9fb18fca142" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Do&lt;/em&gt; write a single overload using the maximum arity:</source>
          <target state="translated">&lt;em&gt;请&lt;/em&gt;使用最大Arity编写单个重载：</target>
        </trans-unit>
        <trans-unit id="c1a8d257a217b5e0fad55b648d1b6493b9aaa989" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Do&lt;/em&gt; write callback parameters as non-optional:</source>
          <target state="translated">&lt;em&gt;不要&lt;/em&gt;写回调参数非可选：</target>
        </trans-unit>
        <trans-unit id="2abc499e9803a9aa8309f8b0e08bf314ad4f3e5a" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Documentation&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Documentation&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="cb8f02b3c9fe34b16e4d7281860a58ffb5f1258c" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Don&amp;rsquo;t&lt;/em&gt; combine it with yours, keep each in their own file.</source>
          <target state="translated">&lt;em&gt;不要&lt;/em&gt;将其与您的文件合并，将每个文件保存在自己的文件中。</target>
        </trans-unit>
        <trans-unit id="55046e05caf1c72e4c96a87b22fa2202c7225227" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Don&amp;rsquo;t&lt;/em&gt; copy the declarations in your package either.</source>
          <target state="translated">&lt;em&gt;也不要&lt;/em&gt;复制包中的声明。</target>
        </trans-unit>
        <trans-unit id="f2dfadd00649442a356417e47981d6fcfedbf53f" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Don&amp;rsquo;t&lt;/em&gt; ever have a generic type which doesn&amp;rsquo;t use its type parameter. See more details in &lt;a href=&quot;https://github.com/Microsoft/TypeScript/wiki/FAQ#why-doesnt-type-inference-work-on-this-interface-interface-foot---&quot;&gt;TypeScript FAQ page&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;别&lt;/em&gt;以往任何时候都具有不使用它的类型参数泛型类型。在&lt;a href=&quot;https://github.com/Microsoft/TypeScript/wiki/FAQ#why-doesnt-type-inference-work-on-this-interface-interface-foot---&quot;&gt;TypeScript FAQ页面中&lt;/a&gt;查看更多详细信息。</target>
        </trans-unit>
        <trans-unit id="aab2c6da00dd5473019faeda9ef13e58ed031a8a" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Don&amp;rsquo;t&lt;/em&gt; ever use the types &lt;code&gt;Number&lt;/code&gt;, &lt;code&gt;String&lt;/code&gt;, &lt;code&gt;Boolean&lt;/code&gt;, &lt;code&gt;Symbol&lt;/code&gt;, or &lt;code&gt;Object&lt;/code&gt; These types refer to non-primitive boxed objects that are almost never used appropriately in JavaScript code.</source>
          <target state="translated">&lt;em&gt;&lt;/em&gt;永远&lt;em&gt;不要&lt;/em&gt;使用 &lt;code&gt;Number&lt;/code&gt; ， &lt;code&gt;String&lt;/code&gt; ， &lt;code&gt;Boolean&lt;/code&gt; ， &lt;code&gt;Symbol&lt;/code&gt; 或 &lt;code&gt;Object&lt;/code&gt; 类型这些类型指的是非原始盒装对象，这些对象几乎从未在JavaScript代码中正确使用。</target>
        </trans-unit>
        <trans-unit id="9fe264f4ba7251b442af48a3b5b9c4e1b135dfc4" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Don&amp;rsquo;t&lt;/em&gt; put more general overloads before more specific overloads:</source>
          <target state="translated">&lt;em&gt;不要&lt;/em&gt;将更一般的重载放在更具体的重载之前：</target>
        </trans-unit>
        <trans-unit id="a603d4de241274517e1f16e58ef6ec739c4ebf0c" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Don&amp;rsquo;t&lt;/em&gt; use &lt;code&gt;/// &amp;lt;reference path=&quot;...&quot; /&amp;gt;&lt;/code&gt; in your declaration files.</source>
          <target state="translated">&lt;em&gt;不要&lt;/em&gt;在声明文件中使用 &lt;code&gt;/// &amp;lt;reference path=&quot;...&quot; /&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1399216a9d6759d0027db5ae960ecaf5e803541f" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Don&amp;rsquo;t&lt;/em&gt; use optional parameters in callbacks unless you really mean it:</source>
          <target state="translated">&lt;em&gt;&lt;/em&gt;除非您是真的意思，否则&lt;em&gt;不要&lt;/em&gt;在回调中使用可选参数：</target>
        </trans-unit>
        <trans-unit id="9d00344d385328c471e2760c0b3a980265f52fa1" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Don&amp;rsquo;t&lt;/em&gt; use the return type &lt;code&gt;any&lt;/code&gt; for callbacks whose value will be ignored:</source>
          <target state="translated">&lt;em&gt;不要&lt;/em&gt;对返回值将被忽略的返回类型使用 &lt;code&gt;any&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="7e23e9a1b88c2a712c6058479b769bb4d1ec3dfd" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Don&amp;rsquo;t&lt;/em&gt; write overloads that differ by type in only one argument position:</source>
          <target state="translated">&lt;em&gt;不要&lt;/em&gt;只在一个参数位置编写因类型而异的重载：</target>
        </trans-unit>
        <trans-unit id="c0e439fdd1e71a139adb43b822a3f2aaba28d521" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Don&amp;rsquo;t&lt;/em&gt; write separate overloads that differ only on callback arity:</source>
          <target state="translated">&lt;em&gt;不要&lt;/em&gt;编写仅在回调函数上有所不同的单独重载：</target>
        </trans-unit>
        <trans-unit id="247c5c1a979d3fed5d8cc62a706484f0933fae19" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Don&amp;rsquo;t&lt;/em&gt; write several overloads that differ only in trailing parameters:</source>
          <target state="translated">&lt;em&gt;不要&lt;/em&gt;编写仅在尾随参数上有所不同的几个重载：</target>
        </trans-unit>
        <trans-unit id="7a458b0d98bbea39bc5c4fb3afb6e88d1dfd11e4" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;First some ES2016 terminology:&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;首先介绍一些ES2016术语：&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e33a7ce58f99afe193351513fce2adb5fa23fa05" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Global Plugin&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;全局插件&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="42b74d2886feeb2bcc628ab0ed5f0f2c95a4fcba" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Global-modifying Modules&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;全局修改模块&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="3dcead9d078d5e6cb9c2a8d1954d8f1acb7bcdd9" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;MSBuild only option&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;仅MSBuild选项&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5859e547903805656a797e0b51e85d7408c824b7" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Module Plugin&lt;/em&gt; or &lt;em&gt;UMD Plugin&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;模块插件&lt;/em&gt;或&lt;em&gt;UMD插件&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d05eb70e7bf87cec96374f03c7bbd7c1a2dc4450" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Module resolution&lt;/em&gt; is the process the compiler uses to figure out what an import refers to. Consider an import statement like &lt;code&gt;import { a } from &quot;moduleA&quot;&lt;/code&gt;; in order to check any use of &lt;code&gt;a&lt;/code&gt;, the compiler needs to know exactly what it represents, and will need to check its definition &lt;code&gt;moduleA&lt;/code&gt;.</source>
          <target state="translated">&lt;em&gt;模块解析&lt;/em&gt;是编译器用来确定导入所指内容的过程。考虑一个类似 &lt;code&gt;import { a } from &quot;moduleA&quot;&lt;/code&gt; 的import语句；为了检查任何使用 &lt;code&gt;a&lt;/code&gt; ，编译器需要确切地知道究竟意味着什么，以及需要检查它的定义 &lt;code&gt;moduleA&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="58e6a2ccb2d8f44ed1c3e778056f2950ed113c53" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Not supported in MSBuild&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;MSBuild不支持&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9dac7371112f6ec5085b3b87e625a9052b4ee6a7" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note: Currently TypeScript support in jspm is in 0.16beta&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;注意：目前jspm中的TypeScript支持在0.16beta中&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d8cb755d2229785263aed32055f1123709bd7654" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Parameter Decorators&lt;/em&gt; are applied for the constructor.</source>
          <target state="translated">&lt;em&gt;参数修饰符&lt;/em&gt;应用于构造函数。</target>
        </trans-unit>
        <trans-unit id="796db20a306e9b2dd3935de4aee308956682ef88" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Parameter Decorators&lt;/em&gt;, followed by &lt;em&gt;Method&lt;/em&gt;, &lt;em&gt;Accessor&lt;/em&gt;, or &lt;em&gt;Property Decorators&lt;/em&gt; are applied for each instance member.</source>
          <target state="translated">&lt;em&gt;参数修饰符&lt;/em&gt;，后跟&lt;em&gt;Method&lt;/em&gt;，&lt;em&gt;Accessor&lt;/em&gt;或&lt;em&gt;Property Decorators&lt;/em&gt;应用于每个实例成员。</target>
        </trans-unit>
        <trans-unit id="5479469c16116549f61eeafcc9902b8ba05b63e1" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Parameter Decorators&lt;/em&gt;, followed by &lt;em&gt;Method&lt;/em&gt;, &lt;em&gt;Accessor&lt;/em&gt;, or &lt;em&gt;Property Decorators&lt;/em&gt; are applied for each static member.</source>
          <target state="translated">&lt;em&gt;参数修饰符&lt;/em&gt;，后跟&lt;em&gt;Method&lt;/em&gt;，&lt;em&gt;Accessor&lt;/em&gt;或&lt;em&gt;Property Decorators&lt;/em&gt;应用于每个静态成员。</target>
        </trans-unit>
        <trans-unit id="5e31e103a79ad520b2c48fac19a5feaa38b4da57" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Rest parameters&lt;/em&gt; are treated as a boundless number of optional parameters. When passing arguments for a rest parameter, you can use as many as you want; you can even pass none. The compiler will build an array of the arguments passed in with the name given after the ellipsis (&lt;code&gt;...&lt;/code&gt;), allowing you to use it in your function.</source>
          <target state="translated">&lt;em&gt;其余参数&lt;/em&gt;被视为无数可选参数。在为rest参数传递参数时，可以使用任意数量的参数。你甚至都不能通过。编译器将构建一个传入的参数数组，并使用省略号（ &lt;code&gt;...&lt;/code&gt; ）后的名称进行传递，从而允许您在函数中使用它。</target>
        </trans-unit>
        <trans-unit id="384a6b578c237d923ecb9829216306571810a612" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Set up NPM&lt;/em&gt; #</source>
          <target state="translated">&lt;em&gt;设置NPM&lt;/em&gt;＃</target>
        </trans-unit>
        <trans-unit id="00ac1e66f3bd63d151ee5473a7360afdc8a5dfb6" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Set up gulp&lt;/em&gt; #</source>
          <target state="translated">&lt;em&gt;设置gulp&lt;/em&gt;＃</target>
        </trans-unit>
        <trans-unit id="04dd4e00bd479a6cea3c982c3959ab8a78ce6226" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Type assertions&lt;/em&gt; are a way to tell the compiler &amp;ldquo;trust me, I know what I&amp;rsquo;m doing.&amp;rdquo; A type assertion is like a type cast in other languages, but performs no special checking or restructuring of data. It has no runtime impact, and is used purely by the compiler. TypeScript assumes that you, the programmer, have performed any special checks that you need.</source>
          <target state="translated">&lt;em&gt;类型断言&lt;/em&gt;是一种告诉编译器&amp;ldquo;相信我，我知道我在做什么&amp;rdquo;的方法。类型断言就像其他语言中的类型转换一样，但是不执行数据的特殊检查或重组。它对运行时间没有影响，仅由编译器使用。TypeScript假定您（程序员）已经执行了所需的任何特殊检查。</target>
        </trans-unit>
        <trans-unit id="9b530738f60a429e40a0da7cd4905304cf2dcd24" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;UMD&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;UMD&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="55ac475adb38e0b57582081a72d1746f55ded573" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Why&lt;/em&gt;: It&amp;rsquo;s always legal for a callback to disregard a parameter, so there&amp;rsquo;s no need for the shorter overload. Providing a shorter callback first allows incorrectly-typed functions to be passed in because they match the first overload.</source>
          <target state="translated">&lt;em&gt;原因&lt;/em&gt;：忽略参数的回调总是合法的，因此不需要较短的重载。首先提供一个较短的回调允许输入错误类型的函数，因为它们与第一个重载匹配。</target>
        </trans-unit>
        <trans-unit id="bba95ff529a6d0256d8f93bf5b1f76f42a078259" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Why&lt;/em&gt;: This is important for people who are &amp;ldquo;passing through&amp;rdquo; a value to your function:</source>
          <target state="translated">&lt;em&gt;原因&lt;/em&gt;：这对于&amp;ldquo;传递&amp;rdquo;功能价值的人员很重要：</target>
        </trans-unit>
        <trans-unit id="049ec47dfa02534ad24ffb14e28f3f5229781764" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Why&lt;/em&gt;: This is important for two reasons.</source>
          <target state="translated">&lt;em&gt;原因&lt;/em&gt;：这很重要，原因有两个。</target>
        </trans-unit>
        <trans-unit id="62327515a94c59f6d707eb154b79f5e5dbfb2a4f" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Why&lt;/em&gt;: TypeScript chooses the &lt;em&gt;first matching overload&lt;/em&gt; when resolving function calls. When an earlier overload is &amp;ldquo;more general&amp;rdquo; than a later one, the later one is effectively hidden and cannot be called.</source>
          <target state="translated">&lt;em&gt;原因&lt;/em&gt;：TypeScript 在解决函数调用时选择第&lt;em&gt;一个匹配的重载&lt;/em&gt;。当较早的过载比较晚的过载&amp;ldquo;更普遍&amp;rdquo;时，较后的过载实际上被隐藏了，无法调用。</target>
        </trans-unit>
        <trans-unit id="22083a1e79f664f58fd53b8457712dc488debc77" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Why&lt;/em&gt;: Using &lt;code&gt;void&lt;/code&gt; is safer because it prevents you from accidentally using the return value of &lt;code&gt;x&lt;/code&gt; in an unchecked way:</source>
          <target state="translated">&lt;em&gt;原因&lt;/em&gt;：使用 &lt;code&gt;void&lt;/code&gt; 更安全，因为它可以防止您以未经检查的方式意外使用 &lt;code&gt;x&lt;/code&gt; 的返回值：</target>
        </trans-unit>
        <trans-unit id="eb00c2127ec65942b8f8eaef0ef31ccfcc660872" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;automatic&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;automatic&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b6df984511379d608600ad56856c6b7c90da664d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;A note about terminology:&lt;/strong&gt; It&amp;rsquo;s important to note that in TypeScript 1.5, the nomenclature has changed. &amp;ldquo;Internal modules&amp;rdquo; are now &amp;ldquo;namespaces&amp;rdquo;. &amp;ldquo;External modules&amp;rdquo; are now simply &amp;ldquo;modules&amp;rdquo;, as to align with &lt;a href=&quot;http://www.ecma-international.org/ecma-262/6.0/&quot;&gt;ECMAScript 2015&lt;/a&gt;&amp;rsquo;s terminology, (namely that &lt;code&gt;module X {&lt;/code&gt; is equivalent to the now-preferred &lt;code&gt;namespace X {&lt;/code&gt;).</source>
          <target state="translated">&lt;strong&gt;关于术语的注释：&lt;/strong&gt;必须注意，在TypeScript 1.5中，术语已更改。&amp;ldquo;内部模块&amp;rdquo;现在是&amp;ldquo;命名空间&amp;rdquo;。为了与&lt;a href=&quot;http://www.ecma-international.org/ecma-262/6.0/&quot;&gt;ECMAScript 2015&lt;/a&gt;的术语保持一致，&amp;ldquo;外部模块&amp;rdquo;现在简称为&amp;ldquo;模块&amp;rdquo; （即， &lt;code&gt;module X {&lt;/code&gt; 等同于现在首选的 &lt;code&gt;namespace X {&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="cb823f67a7cbb8600c4f0350f1c2ad73fe2d021a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;After&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;After&lt;/strong&gt;:</target>
        </trans-unit>
        <trans-unit id="156a1437d0d6c924eb6ca12562027ff2587f6045" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Before&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;Before&lt;/strong&gt;:</target>
        </trans-unit>
        <trans-unit id="83af59348af09abe07910fb748be25518e341a5c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Command Line&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;命令行&lt;/strong&gt;：</target>
        </trans-unit>
        <trans-unit id="2dd8a1d40fc5fe437da8ffe7085dd47f6e01c64d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: this directive has been deprecated. Use &lt;code&gt;import &quot;moduleName&quot;;&lt;/code&gt; statements instead.</source>
          <target state="translated">&lt;strong&gt;注意&lt;/strong&gt;：此指令已被弃用。使用 &lt;code&gt;import &quot;moduleName&quot;;&lt;/code&gt; 语句代替。</target>
        </trans-unit>
        <trans-unit id="98dca272af4b4983e9681bcffd62a12fd4abd3d3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Usage&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;Usage&lt;/strong&gt;:</target>
        </trans-unit>
        <trans-unit id="87244e77c6f80d6ca60d4ab90f5e3a2c23bfbfb5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;tsconfig.json&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;tsconfig.json&lt;/strong&gt;:</target>
        </trans-unit>
        <trans-unit id="a30a3cb060aed8b038da2f590d07d1fab7bd3b38" translate="yes" xml:space="preserve">
          <source>&lt;sup id=&quot;ts-3-1-only-homomorphic&quot;&gt;[1]&lt;/sup&gt; More specifically, homomorphic mapped types like in the above form.</source>
          <target state="translated">&lt;sup id=&quot;ts-3-1-only-homomorphic&quot;&gt;[1]&lt;/sup&gt; More specifically, homomorphic mapped types like in the above form.</target>
        </trans-unit>
        <trans-unit id="18ae02156418abf2a28f0ac9092105d374823167" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;[1]&lt;/sup&gt; These options are experimental.</source>
          <target state="translated">&lt;sup&gt;[1]&lt;/sup&gt; These options are experimental.</target>
        </trans-unit>
        <trans-unit id="fa0447115a5c58a31c601fe3ecaf85a07da3a091" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;[2]&lt;/sup&gt; These options are only allowed in &lt;code&gt;tsconfig.json&lt;/code&gt;, and not through command-line switches.</source>
          <target state="translated">&lt;sup&gt;[2]&lt;/sup&gt; These options are only allowed in &lt;code&gt;tsconfig.json&lt;/code&gt;, and not through command-line switches.</target>
        </trans-unit>
        <trans-unit id="e1e2f277649e29a892f6243a1e9f85f91b903aeb" translate="yes" xml:space="preserve">
          <source>======== Module name &amp;lsquo;typescript&amp;rsquo; was &lt;strong&gt;successfully resolved&lt;/strong&gt; to &amp;lsquo;node_modules/typescript/lib/typescript.d.ts&amp;rsquo;. ========</source>
          <target state="translated">======== Module name &amp;lsquo;typescript&amp;rsquo; was &lt;strong&gt;successfully resolved&lt;/strong&gt; to &amp;lsquo;node_modules/typescript/lib/typescript.d.ts&amp;rsquo;. ========</target>
        </trans-unit>
        <trans-unit id="54948ed17588662885addef180b7ef879ed0c37c" translate="yes" xml:space="preserve">
          <source>======== Resolving module &lt;strong&gt;&amp;lsquo;typescript&amp;rsquo;&lt;/strong&gt; from &lt;strong&gt;&amp;lsquo;src/app.ts&amp;rsquo;&lt;/strong&gt;. ========</source>
          <target state="translated">======== Resolving module &lt;strong&gt;&amp;lsquo;typescript&amp;rsquo;&lt;/strong&gt; from &lt;strong&gt;&amp;lsquo;src/app.ts&amp;rsquo;&lt;/strong&gt;. ========</target>
        </trans-unit>
        <trans-unit id="d49ecc37e0ee034f2827da1fd607d32080808c90" translate="yes" xml:space="preserve">
          <source>@constructor</source>
          <target state="translated">@constructor</target>
        </trans-unit>
        <trans-unit id="1730f10972219035ab2f682b1ce4cece7df226d6" translate="yes" xml:space="preserve">
          <source>@extends</source>
          <target state="translated">@extends</target>
        </trans-unit>
        <trans-unit id="105f935c3c4b1ccfdad76f831916ed4a4587adbf" translate="yes" xml:space="preserve">
          <source>@param and @returns</source>
          <target state="translated">@param and @returns</target>
        </trans-unit>
        <trans-unit id="8ebf6ae3de6f1ca37540e2051a2b384cfa72a27f" translate="yes" xml:space="preserve">
          <source>@template</source>
          <target state="translated">@template</target>
        </trans-unit>
        <trans-unit id="ea9188bc22500c51ab1af4eb545fa93a9a0c4799" translate="yes" xml:space="preserve">
          <source>A &amp;ldquo;bare import&amp;rdquo; can be used to import a module only for its side-effects.</source>
          <target state="translated">&amp;ldquo;裸导入&amp;rdquo;仅可用于其副作用而用于导入模块。</target>
        </trans-unit>
        <trans-unit id="6ab96675e2c97989bb0f021cb50b90f4796d5235" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;// @ts-ignore&lt;/code&gt; comment suppresses all errors that originate on the following line. It is recommended practice to have the remainder of the comment following &lt;code&gt;@ts-ignore&lt;/code&gt; explain which error is being suppressed.</source>
          <target state="translated">一 &lt;code&gt;// @ts-ignore&lt;/code&gt; 评论抑制了以下行发起的所有错误。建议的做法是在 &lt;code&gt;@ts-ignore&lt;/code&gt; 解释其余注释，以解释抑制了哪个错误。</target>
        </trans-unit>
        <trans-unit id="6e0e525ad905e4c93bcdef14ca8854c2dbd392a9" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;class&lt;/code&gt; declaration</source>
          <target state="translated">一 &lt;code&gt;class&lt;/code&gt; 声明</target>
        </trans-unit>
        <trans-unit id="9321961f59ed7aa165b175642715594e39b66e6f" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;function&lt;/code&gt; declaration</source>
          <target state="translated">一个 &lt;code&gt;function&lt;/code&gt; 声明</target>
        </trans-unit>
        <trans-unit id="cc5d6828693e8c2d48344e83137c9a8290909b26" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;namespace&lt;/code&gt; declaration can be used to add new types, values, and namespaces in any way which does not create a conflict.</source>
          <target state="translated">一个 &lt;code&gt;namespace&lt;/code&gt; 声明可以被用来在不产生冲突的任何方式增加新的类型，值和命名空间。</target>
        </trans-unit>
        <trans-unit id="4dffc5c56bad813471caa1b06219f7ff387e0027" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;namespace&lt;/code&gt; or &lt;code&gt;module&lt;/code&gt; declaration which contains a value</source>
          <target state="translated">甲 &lt;code&gt;namespace&lt;/code&gt; 或 &lt;code&gt;module&lt;/code&gt; 声明它包含一个值</target>
        </trans-unit>
        <trans-unit id="6f40f5525adb3d03f58f4422b7d66754c7565a18" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;tsconfig.json&lt;/code&gt; file can inherit configurations from another file using the &lt;code&gt;extends&lt;/code&gt; property.</source>
          <target state="translated">一个 &lt;code&gt;tsconfig.json&lt;/code&gt; 文件可以从另一个文件中使用继承配置 &lt;code&gt;extends&lt;/code&gt; 属性。</target>
        </trans-unit>
        <trans-unit id="bac130cd7375d2fa70c0cad6b27e7077fed8791a" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;tsconfig.json&lt;/code&gt; file is permitted to be completely empty, which compiles all files included by default (as described above) with the default compiler options.</source>
          <target state="translated">甲 &lt;code&gt;tsconfig.json&lt;/code&gt; 文件被允许是完全空的，其编译默认包含的所有文件与所述默认的编译选项（如上所述）。</target>
        </trans-unit>
        <trans-unit id="2f15ae1c31705135e881325aff5e8a346aec850a" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;Class Decorator&lt;/em&gt; is declared just before a class declaration. The class decorator is applied to the constructor of the class and can be used to observe, modify, or replace a class definition. A class decorator cannot be used in a declaration file, or in any other ambient context (such as on a &lt;code&gt;declare&lt;/code&gt; class).</source>
          <target state="translated">在&lt;em&gt;类&lt;/em&gt;声明之前声明一个&lt;em&gt;类装饰器&lt;/em&gt;。类装饰器应用于类的构造函数，可用于观察，修改或替换类定义。类修饰符不能在声明文件或任何其他环境上下文（例如， &lt;code&gt;declare&lt;/code&gt; 类）中使用。</target>
        </trans-unit>
        <trans-unit id="739e90613eeebc5ddc5aad4956b450c569d06044" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;Decorator&lt;/em&gt; is a special kind of declaration that can be attached to a &lt;a href=&quot;#class-decorators&quot;&gt;class declaration&lt;/a&gt;, &lt;a href=&quot;#method-decorators&quot;&gt;method&lt;/a&gt;, &lt;a href=&quot;#accessor-decorators&quot;&gt;accessor&lt;/a&gt;, &lt;a href=&quot;#property-decorators&quot;&gt;property&lt;/a&gt;, or &lt;a href=&quot;#parameter-decorators&quot;&gt;parameter&lt;/a&gt;. Decorators use the form &lt;code&gt;@expression&lt;/code&gt;, where &lt;code&gt;expression&lt;/code&gt; must evaluate to a function that will be called at runtime with information about the decorated declaration.</source>
          <target state="translated">甲&lt;em&gt;装饰&lt;/em&gt;是一种特殊种类的声明可被附连到一个&lt;a href=&quot;#class-decorators&quot;&gt;类声明&lt;/a&gt;，&lt;a href=&quot;#method-decorators&quot;&gt;方法&lt;/a&gt;，&lt;a href=&quot;#accessor-decorators&quot;&gt;访问器&lt;/a&gt;，&lt;a href=&quot;#property-decorators&quot;&gt;属性&lt;/a&gt;，或&lt;a href=&quot;#parameter-decorators&quot;&gt;参数&lt;/a&gt;。装饰器使用 &lt;code&gt;@expression&lt;/code&gt; 形式，其中 &lt;code&gt;expression&lt;/code&gt; 必须计算为一个函数，该函数将在运行时使用有关修饰声明的信息进行调用。</target>
        </trans-unit>
        <trans-unit id="9d56f6c32829ea8275bf6ee5b435cef5ea1f700d" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;Method Decorator&lt;/em&gt; is declared just before a method declaration. The decorator is applied to the &lt;em&gt;Property Descriptor&lt;/em&gt; for the method, and can be used to observe, modify, or replace a method definition. A method decorator cannot be used in a declaration file, on an overload, or in any other ambient context (such as in a &lt;code&gt;declare&lt;/code&gt; class).</source>
          <target state="translated">在&lt;em&gt;方法&lt;/em&gt;声明之前声明&lt;em&gt;方法装饰器&lt;/em&gt;。装饰器将应用于方法的&lt;em&gt;属性描述符&lt;/em&gt;，并可以用于观察，修改或替换方法定义。方法装饰器不能在声明文件，重载或任何其他环境上下文（例如， &lt;code&gt;declare&lt;/code&gt; 类）中使用。</target>
        </trans-unit>
        <trans-unit id="fccf751dfd4d98326bc686f6800698c46d17f29f" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;Parameter Decorator&lt;/em&gt; is declared just before a parameter declaration. The parameter decorator is applied to the function for a class constructor or method declaration. A parameter decorator cannot be used in a declaration file, an overload, or in any other ambient context (such as in a &lt;code&gt;declare&lt;/code&gt; class).</source>
          <target state="translated">在&lt;em&gt;参数&lt;/em&gt;声明之前就声明了一个&lt;em&gt;参数装饰器&lt;/em&gt;。参数装饰器应用于类构造函数或方法声明的函数。参数修饰符不能在声明文件，重载或任何其他环境上下文（例如， &lt;code&gt;declare&lt;/code&gt; 类）中使用。</target>
        </trans-unit>
        <trans-unit id="9d07f771fa09284a877bbd7b7a8c2200cc1db787" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;Property Decorator&lt;/em&gt; is declared just before a property declaration. A property decorator cannot be used in a declaration file, or in any other ambient context (such as in a &lt;code&gt;declare&lt;/code&gt; class).</source>
          <target state="translated">一个&lt;em&gt;物业装饰&lt;/em&gt;只是属性声明之前声明。不能在声明文件或任何其他环境上下文（例如， &lt;code&gt;declare&lt;/code&gt; 类）中使用属性装饰器。</target>
        </trans-unit>
        <trans-unit id="5f6b5887333ec599f15cdbb7f6b7e41fb24767d5" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;UMD&lt;/em&gt; module is one that can &lt;em&gt;either&lt;/em&gt; be used as module (through an import), or as a global (when run in an environment without a module loader). Many popular libraries, such as &lt;a href=&quot;http://momentjs.com/&quot;&gt;Moment.js&lt;/a&gt;, are written this way. For example, in Node.js or using RequireJS, you would write:</source>
          <target state="translated">甲&lt;em&gt;UMD&lt;/em&gt;模块是一个可以&lt;em&gt;或者&lt;/em&gt;被用作模块（通过一个进口），或作为一个全局（当在环境中时不带模块加载程序运行）。许多流行的库，例如&lt;a href=&quot;http://momentjs.com/&quot;&gt;Moment.js&lt;/a&gt;都是以这种方式编写的。例如，在Node.js或使用RequireJS中，您将编写：</target>
        </trans-unit>
        <trans-unit id="2e831c596f2ba69b8fe1db558042cf1c087c1093" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;discriminant property type guard&lt;/em&gt; is an expression of the form &lt;code&gt;x.p == v&lt;/code&gt;, &lt;code&gt;x.p === v&lt;/code&gt;, &lt;code&gt;x.p != v&lt;/code&gt;, or &lt;code&gt;x.p !== v&lt;/code&gt;, where &lt;code&gt;p&lt;/code&gt; and &lt;code&gt;v&lt;/code&gt; are a property and an expression of a string literal type or a union of string literal types. The discriminant property type guard narrows the type of &lt;code&gt;x&lt;/code&gt; to those constituent types of &lt;code&gt;x&lt;/code&gt; that have a discriminant property &lt;code&gt;p&lt;/code&gt; with one of the possible values of &lt;code&gt;v&lt;/code&gt;.</source>
          <target state="translated">甲&lt;em&gt;判别属性型保护&lt;/em&gt;是如下形式的表达 &lt;code&gt;x.p == v&lt;/code&gt; ， &lt;code&gt;x.p === v&lt;/code&gt; ， &lt;code&gt;x.p != v&lt;/code&gt; ，或 &lt;code&gt;x.p !== v&lt;/code&gt; ，其中 &lt;code&gt;p&lt;/code&gt; 和 &lt;code&gt;v&lt;/code&gt; 是一个属性和一个字符串文字类型的表达式或字符串文字类型的并集。判别属性类型保护器将 &lt;code&gt;x&lt;/code&gt; 的类型缩小为具有x可能值为 &lt;code&gt;v&lt;/code&gt; 的判别属性 &lt;code&gt;p&lt;/code&gt; 的那些构成类型的 &lt;code&gt;x&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5af1a45bc532371f09945859192093e4e8e7412f" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;global plugin&lt;/em&gt; is global code that changes the shape of some global. As with &lt;em&gt;global-modifying modules&lt;/em&gt;, these raise the possibility of runtime conflict.</source>
          <target state="translated">一个&lt;em&gt;全球性的插件&lt;/em&gt;是全球性的代码，改变一些全球性的形状。与&lt;em&gt;全局修改模块一样&lt;/em&gt;，这些&lt;em&gt;模块&lt;/em&gt;增加了运行时冲突的可能性。</target>
        </trans-unit>
        <trans-unit id="2cc8c7dc8fcaba1930b06da38f845e8f6f69fa81" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;global-modifying module&lt;/em&gt; alters existing values in the global scope when they are imported. For example, there might exist a library which adds new members to &lt;code&gt;String.prototype&lt;/code&gt; when imported. This pattern is somewhat dangerous due to the possibility of runtime conflicts, but we can still write a declaration file for it.</source>
          <target state="translated">甲&lt;em&gt;全局修改模块&lt;/em&gt;现有值在全局范围内涂改当它们被导入。例如，可能存在一个库，该库在导入时将新成员添加到 &lt;code&gt;String.prototype&lt;/code&gt; 。由于存在运行时冲突的可能性，这种模式有些危险，但是我们仍然可以为其编写声明文件。</target>
        </trans-unit>
        <trans-unit id="feba008bb2bcd964cfc399bbc4dcc4618c8ee5e2" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;global&lt;/em&gt; library is one that can be accessed from the global scope (i.e. without using any form of &lt;code&gt;import&lt;/code&gt;). Many libraries simply expose one or more global variables for use. For example, if you were using &lt;a href=&quot;https://jquery.com/&quot;&gt;jQuery&lt;/a&gt;, the &lt;code&gt;$&lt;/code&gt; variable can be used by simply referring to it:</source>
          <target state="translated">甲&lt;em&gt;全球&lt;/em&gt;库是一个可以从全球范围内被访问（即不使用任何形式的 &lt;code&gt;import&lt;/code&gt; ）。许多库只是公开一个或多个全局变量供使用。例如，如果您使用的是&lt;a href=&quot;https://jquery.com/&quot;&gt;jQuery&lt;/a&gt;，则只需引用 &lt;code&gt;$&lt;/code&gt; 变量即可使用它：</target>
        </trans-unit>
        <trans-unit id="d2289bfc724a5518dc15e4cf5caddd6815845abb" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;module plugin&lt;/em&gt; changes the shape of another module (either UMD or module). For example, in Moment.js, &lt;code&gt;moment-range&lt;/code&gt; adds a new &lt;code&gt;range&lt;/code&gt; method to the &lt;code&gt;moment&lt;/code&gt; object.</source>
          <target state="translated">一个&lt;em&gt;模块插件会&lt;/em&gt;更改另一个模块（UMD或模块）的形状。例如，在Moment.js中， &lt;code&gt;moment-range&lt;/code&gt; 将新的 &lt;code&gt;range&lt;/code&gt; 方法添加到 &lt;code&gt;moment&lt;/code&gt; 对象。</target>
        </trans-unit>
        <trans-unit id="36ef51072168e8fd07bcbf75e20f6fc4027a24cd" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;relative import&lt;/em&gt; is one that starts with &lt;code&gt;/&lt;/code&gt;, &lt;code&gt;./&lt;/code&gt; or &lt;code&gt;../&lt;/code&gt;. Some examples include:</source>
          <target state="translated">一个&lt;em&gt;相对进口&lt;/em&gt;是一个开头 &lt;code&gt;/&lt;/code&gt; ， &lt;code&gt;./&lt;/code&gt; 或 &lt;code&gt;../&lt;/code&gt; 。一些示例包括：</target>
        </trans-unit>
        <trans-unit id="8b0f2d1642b6ff9d5026c5e25f91e02a415f34ce" translate="yes" xml:space="preserve">
          <source>A &lt;strong&gt;mixin class&lt;/strong&gt; is a class declaration or expression that &lt;code&gt;extends&lt;/code&gt; an expression of a type parameter type. The following rules apply to mixin class declarations:</source>
          <target state="translated">甲&lt;strong&gt;混合类&lt;/strong&gt;是一类声明或表达式 &lt;code&gt;extends&lt;/code&gt; 类型参数类型的表达式。以下规则适用于mixin类声明：</target>
        </trans-unit>
        <trans-unit id="bc78810f3bf6a5a9528d8023bc05c6167ef7eaf5" translate="yes" xml:space="preserve">
          <source>A &lt;strong&gt;mixin constructor type&lt;/strong&gt; refers to a type that has a single construct signature with a single rest argument of type &lt;code&gt;any[]&lt;/code&gt; and an object-like return type. For example, given an object-like type &lt;code&gt;X&lt;/code&gt;, &lt;code&gt;new (...args: any[]) =&amp;gt; X&lt;/code&gt; is a mixin constructor type with an instance type &lt;code&gt;X&lt;/code&gt;.</source>
          <target state="translated">甲&lt;strong&gt;混入构造型&lt;/strong&gt;是指具有与类型的单个参数其余的单个构建签名类型 &lt;code&gt;any[]&lt;/code&gt; 和对象类的返回类型。例如，给定类似对象的类型 &lt;code&gt;X&lt;/code&gt; ， &lt;code&gt;new (...args: any[]) =&amp;gt; X&lt;/code&gt; 是具有实例类型 &lt;code&gt;X&lt;/code&gt; 的mixin构造函数类型。</target>
        </trans-unit>
        <trans-unit id="2e3913101a43966f2ccebcc4061aa10428b79384" translate="yes" xml:space="preserve">
          <source>A Boolean value indicating that an object should be flattened to its array elements by Array.prototype.concat.</source>
          <target state="translated">一个布尔值,表示一个对象应该被Array.prototype.concat扁平化为数组元素。</target>
        </trans-unit>
        <trans-unit id="b6e0c2d8bf86efa81f30b4c26580fc67ebbeb4fa" translate="yes" xml:space="preserve">
          <source>A Note on Soundness</source>
          <target state="translated">关于健全性的说明</target>
        </trans-unit>
        <trans-unit id="1fed6c2698af466cd828f08e21a3d01c917783df" translate="yes" xml:space="preserve">
          <source>A String value that is used in the creation of the default string description of an object. Called by the built-in method &lt;code&gt;Object.prototype.toString&lt;/code&gt;.</source>
          <target state="translated">创建对象的默认字符串描述时使用的String值。由内置方法 &lt;code&gt;Object.prototype.toString&lt;/code&gt; 调用。</target>
        </trans-unit>
        <trans-unit id="7ef0b6dff4f7313a8976b0f0d521140ee41e223c" translate="yes" xml:space="preserve">
          <source>A build step will copy the files in &lt;code&gt;/src/views&lt;/code&gt; and &lt;code&gt;/generated/templates/views&lt;/code&gt; to the same directory in the output. At run-time, a view can expect its template to exist next to it, and thus should import it using a relative name as &lt;code&gt;&quot;./template&quot;&lt;/code&gt;.</source>
          <target state="translated">构建步骤将把 &lt;code&gt;/src/views&lt;/code&gt; 和 &lt;code&gt;/generated/templates/views&lt;/code&gt; 的文件复制到输出中的同一目录。在运行时，视图可以期望其模板位于其旁边，因此应使用相对名称 &lt;code&gt;&quot;./template&quot;&lt;/code&gt; 来导入它。</target>
        </trans-unit>
        <trans-unit id="5e30e8a952193f7d1df77a0d6d1fd7f212ffd28d" translate="yes" xml:space="preserve">
          <source>A call to a generic function uses the arguments to infer the type parameters. Sometimes this process fails to infer any types, mainly because of lack of inference sources; in these cases, the type parameters will default to &lt;code&gt;any&lt;/code&gt;. For example:</source>
          <target state="translated">对泛型函数的调用使用参数来推断类型参数。有时，此过程无法推断任何类型，主要是由于缺乏推断源；在这些情况下，类型参数将默认为 &lt;code&gt;any&lt;/code&gt; 。例如：</target>
        </trans-unit>
        <trans-unit id="8884cee9c569ba73051b4c3340106f32892db818" translate="yes" xml:space="preserve">
          <source>A class constructor may be marked &lt;code&gt;private&lt;/code&gt; or &lt;code&gt;protected&lt;/code&gt;. A class with private constructor cannot be instantiated outside the class body, and cannot be extended. A class with protected constructor cannot be instantiated outside the class body, but can be extended.</source>
          <target state="translated">类构造函数可以标记为 &lt;code&gt;private&lt;/code&gt; 或 &lt;code&gt;protected&lt;/code&gt; 。具有私有构造函数的类不能在类主体外部实例化，也不能扩展。具有受保护构造函数的类不能在类主体外部实例化，但可以扩展。</target>
        </trans-unit>
        <trans-unit id="714c30cc5bf310cba2527f465ba3e4937c25903e" translate="yes" xml:space="preserve">
          <source>A class declaration (&lt;code&gt;class C { }&lt;/code&gt;)</source>
          <target state="translated">类声明（ &lt;code&gt;class C { }&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="1596db92a712b48a7d481d2882462ab7d550ed38" translate="yes" xml:space="preserve">
          <source>A class or interface declaration that merges with an existing class or interface declaration may introduce a default for an existing type parameter.</source>
          <target state="translated">与现有的类或接口声明合并的类或接口声明可以为现有的类型参数引入一个默认值。</target>
        </trans-unit>
        <trans-unit id="fe8ffa4d7e2dafe57b8f8b2aa2642caf1ac898fd" translate="yes" xml:space="preserve">
          <source>A class or interface declaration that merges with an existing class or interface declaration may introduce a new type parameter as long as it specifies a default.</source>
          <target state="translated">与现有的类或接口声明合并的类或接口声明可以引入一个新的类型参数,只要它指定了一个默认值。</target>
        </trans-unit>
        <trans-unit id="e50811af3fd1732eb86ab44223050144ba8d75bb" translate="yes" xml:space="preserve">
          <source>A common and dangerous error is to forget to invoke a function, especially if the function has zero arguments or is named in a way that implies it might be a property rather than a function.</source>
          <target state="translated">一个常见且危险的错误是忘记调用一个函数,尤其是当函数的参数为零或命名方式暗示它可能是一个属性而不是函数时,更是如此。</target>
        </trans-unit>
        <trans-unit id="804ef8425f60cc16494a3ecb8868620fc1d13254" translate="yes" xml:space="preserve">
          <source>A common mistake is to try to use the &lt;code&gt;/// &amp;lt;reference ... /&amp;gt;&lt;/code&gt; syntax to refer to a module file, rather than using an &lt;code&gt;import&lt;/code&gt; statement. To understand the distinction, we first need to understand how the compiler can locate the type information for a module based on the path of an &lt;code&gt;import&lt;/code&gt; (e.g. the &lt;code&gt;...&lt;/code&gt; in &lt;code&gt;import x from &quot;...&quot;;&lt;/code&gt;, &lt;code&gt;import x = require(&quot;...&quot;);&lt;/code&gt;, etc.) path.</source>
          <target state="translated">一个常见的错误是尝试使用 &lt;code&gt;/// &amp;lt;reference ... /&amp;gt;&lt;/code&gt; 语法来引用模块文件，而不是使用 &lt;code&gt;import&lt;/code&gt; 语句。要理解的区别，我们首先需要了解编译器如何能找到一个基于路径上的模块类型的信息 &lt;code&gt;import&lt;/code&gt; （例如 &lt;code&gt;...&lt;/code&gt; 在 &lt;code&gt;import x from &quot;...&quot;;&lt;/code&gt; ， &lt;code&gt;import x = require(&quot;...&quot;);&lt;/code&gt; 等）路径。</target>
        </trans-unit>
        <trans-unit id="dd6d372643d97ce6592522ce945c126f9d03b1c9" translate="yes" xml:space="preserve">
          <source>A common pattern in JavaScript is to use &lt;code&gt;typeof&lt;/code&gt; or &lt;code&gt;instanceof&lt;/code&gt; to examine the type of an expression at runtime. TypeScript now understands these conditions and will change type inference accordingly when used in an &lt;code&gt;if&lt;/code&gt; block.</source>
          <target state="translated">JavaScript中的一种常见模式是使用 &lt;code&gt;typeof&lt;/code&gt; 或 &lt;code&gt;instanceof&lt;/code&gt; 在运行时检查表达式的类型。TypeScript现在可以理解这些条件，并且在 &lt;code&gt;if&lt;/code&gt; 块中使用时将相应地更改类型推断。</target>
        </trans-unit>
        <trans-unit id="7d4ced30fbc2cc726d8b092795387c4127143776" translate="yes" xml:space="preserve">
          <source>A common task is to take an existing type and make each of its properties optional:</source>
          <target state="translated">一个常见的任务是取一个现有的类型,并使其每个属性都是可选的。</target>
        </trans-unit>
        <trans-unit id="f3a0349d4a486bbf82efbf586f7757d0e2680533" translate="yes" xml:space="preserve">
          <source>A common work around is to use an IIFE - an Immediately Invoked Function Expression - to capture &lt;code&gt;i&lt;/code&gt; at each iteration:</source>
          <target state="translated">常见的解决方法是使用IIFE（立即调用函数表达式）在每次迭代中捕获 &lt;code&gt;i&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="80959b7998a3c5a6f92da1dbaffb14e14087102c" translate="yes" xml:space="preserve">
          <source>A conditional type &lt;code&gt;T extends U ? X : Y&lt;/code&gt; is either &lt;em&gt;resolved&lt;/em&gt; to &lt;code&gt;X&lt;/code&gt; or &lt;code&gt;Y&lt;/code&gt;, or &lt;em&gt;deferred&lt;/em&gt; because the condition depends on one or more type variables. When &lt;code&gt;T&lt;/code&gt; or &lt;code&gt;U&lt;/code&gt; contains type variables, whether to resolve to &lt;code&gt;X&lt;/code&gt; or &lt;code&gt;Y&lt;/code&gt;, or to defer, is determined by whether or not the type system has enough information to conclude that &lt;code&gt;T&lt;/code&gt; is always assignable to &lt;code&gt;U&lt;/code&gt;.</source>
          <target state="translated">条件类型 &lt;code&gt;T extends U ? X : Y&lt;/code&gt; 被&lt;em&gt;解析&lt;/em&gt;为 &lt;code&gt;X&lt;/code&gt; 或 &lt;code&gt;Y&lt;/code&gt; ，或者被&lt;em&gt;推迟，&lt;/em&gt;因为条件取决于一个或多个类型变量。当 &lt;code&gt;T&lt;/code&gt; 或 &lt;code&gt;U&lt;/code&gt; 包含类型变量时，由类型系统是否具有足够的信息来推断 &lt;code&gt;T&lt;/code&gt; 始终可分配给 &lt;code&gt;U&lt;/code&gt; 来确定是解析为 &lt;code&gt;X&lt;/code&gt; 还是 &lt;code&gt;Y&lt;/code&gt; 还是延迟。</target>
        </trans-unit>
        <trans-unit id="a3ca32ef30629a0ef6871441758cc40ce1b420bb" translate="yes" xml:space="preserve">
          <source>A conditional type &lt;code&gt;T extends U ? X : Y&lt;/code&gt; is either &lt;em&gt;resolved&lt;/em&gt; to &lt;code&gt;X&lt;/code&gt; or &lt;code&gt;Y&lt;/code&gt;, or &lt;em&gt;deferred&lt;/em&gt; because the condition depends on one or more type variables. Whether to resolve or defer is determined as follows:</source>
          <target state="translated">条件类型 &lt;code&gt;T extends U ? X : Y&lt;/code&gt; 被&lt;em&gt;解析&lt;/em&gt;为 &lt;code&gt;X&lt;/code&gt; 或 &lt;code&gt;Y&lt;/code&gt; ，或者被&lt;em&gt;推迟，&lt;/em&gt;因为条件取决于一个或多个类型变量。决定解决还是推迟如下：</target>
        </trans-unit>
        <trans-unit id="dcd55e1e2d504c4f5bd31948eb3ce7aa0ce3cb13" translate="yes" xml:space="preserve">
          <source>A constructor may also be marked &lt;code&gt;protected&lt;/code&gt;. This means that the class cannot be instantiated outside of its containing class, but can be extended. For example,</source>
          <target state="translated">构造函数也可能被标记为 &lt;code&gt;protected&lt;/code&gt; 。这意味着该类不能在其包含的类之外实例化，但可以扩展。例如，</target>
        </trans-unit>
        <trans-unit id="cadb83f444b2961a4d934d5f3d490b70e4dd1268" translate="yes" xml:space="preserve">
          <source>A couple of limitations</source>
          <target state="translated">有几个限制</target>
        </trans-unit>
        <trans-unit id="a24cf92f2108f7fc6dfb574930ec5df83db3eb0b" translate="yes" xml:space="preserve">
          <source>A couple of things to note about accessors:</source>
          <target state="translated">关于门禁的几件事要注意。</target>
        </trans-unit>
        <trans-unit id="e092fc815a872b9563a100f8c02b2d0d350825ab" translate="yes" xml:space="preserve">
          <source>A decorator is:</source>
          <target state="translated">装修人员是。</target>
        </trans-unit>
        <trans-unit id="4f1b6da91369927675bbf031b2ce4d5a731e97d7" translate="yes" xml:space="preserve">
          <source>A destructuring declaration introduces one or more named variables and initializes them with values extracted from properties of an object or elements of an array.</source>
          <target state="translated">解构声明引入一个或多个命名的变量,并用从对象的属性或数组元素中提取的值来初始化它们。</target>
        </trans-unit>
        <trans-unit id="bba8a48bfe00ec663b6ebb1eceade9d3fff1e679" translate="yes" xml:space="preserve">
          <source>A file whose only top-level declaration is &lt;code&gt;export namespace Foo { ... }&lt;/code&gt; (remove &lt;code&gt;Foo&lt;/code&gt; and move everything &amp;lsquo;up&amp;rsquo; a level)</source>
          <target state="translated">一个文件的唯一顶级声明是 &lt;code&gt;export namespace Foo { ... }&lt;/code&gt; （删除 &lt;code&gt;Foo&lt;/code&gt; 并将所有内容&amp;ldquo;上&amp;rdquo;移到一个级别）</target>
        </trans-unit>
        <trans-unit id="1dc68bdd4f9a61f11fcf8696eedfc299f303d8bd" translate="yes" xml:space="preserve">
          <source>A function valued property that is the constructor function that is used to create derived objects.</source>
          <target state="translated">一个函数值属性,是用来创建派生对象的构造函数。</target>
        </trans-unit>
        <trans-unit id="83ddd76ccda8c0cc52ac61d7fddcd8fcbe5f3cba" translate="yes" xml:space="preserve">
          <source>A function whose body has a reference to the &lt;code&gt;arguments&lt;/code&gt; reference is implicitly considered to have a var-arg parameter (i.e. &lt;code&gt;(...arg: any[]) =&amp;gt; any&lt;/code&gt;). Use JSDoc var-arg syntax to specify the type of the arguments.</source>
          <target state="translated">主体具有对 &lt;code&gt;arguments&lt;/code&gt; 引用的引用的函数被隐式地认为具有var-arg参数（即 &lt;code&gt;(...arg: any[]) =&amp;gt; any&lt;/code&gt; ）。使用JSDoc var-arg语法指定参数的类型。</target>
        </trans-unit>
        <trans-unit id="0ea0b4e5327f594259519fd62a19b6890ab37c08" translate="yes" xml:space="preserve">
          <source>A function&amp;rsquo;s type has the same two parts: the type of the arguments and the return type. When writing out the whole function type, both parts are required. We write out the parameter types just like a parameter list, giving each parameter a name and a type. This name is just to help with readability. We could have instead written:</source>
          <target state="translated">函数的类型具有两个相同的部分：参数的类型和返回类型。写出整个函数类型时，两个部分都是必需的。我们像参数列表一样写出参数类型，为每个参数指定名称和类型。该名称只是为了提高可读性。相反，我们可以这样写：</target>
        </trans-unit>
        <trans-unit id="6091230201a03184d43d1bf3ecad6c4e357aa7e8" translate="yes" xml:space="preserve">
          <source>A generator function can have a return type annotation, just like a function. The annotation represents the type of the generator returned by the function. Here is an example:</source>
          <target state="translated">一个生成器函数可以有一个返回类型注释,就像函数一样。注释代表了函数返回的生成器类型。下面是一个例子。</target>
        </trans-unit>
        <trans-unit id="3058f8f1fd4d84d69ca0c3d8c31e05fc06865a11" translate="yes" xml:space="preserve">
          <source>A generator function with no type annotation can have the type annotation inferred. So in the following case, the type will be inferred from the yield statements:</source>
          <target state="translated">一个没有类型注释的生成器函数可以有类型注释的推断。因此,在下面的情况下,将从 yield 语句中推断出类型。</target>
        </trans-unit>
        <trans-unit id="c6e63dbd0af2ae2aa5dc876191453fa9346622e3" translate="yes" xml:space="preserve">
          <source>A generic class has a similar shape to a generic interface. Generic classes have a generic type parameter list in angle brackets (&lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt;) following the name of the class.</source>
          <target state="translated">通用类具有与通用接口相似的形状。泛型类在类名称后的尖括号（ &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; ）中具有泛型类型参数列表。</target>
        </trans-unit>
        <trans-unit id="96453b7ccf72e8b01e41461635fa60edbe83b5ea" translate="yes" xml:space="preserve">
          <source>A generic parameter default follows the following rules:</source>
          <target state="translated">通用参数默认遵循以下规则:</target>
        </trans-unit>
        <trans-unit id="d6264a6174402b53e580cc927dfee79a2d86c4b7" translate="yes" xml:space="preserve">
          <source>A handy feature of enums is that you can also go from a numeric value to the name of that value in the enum. For example, if we had the value &lt;code&gt;2&lt;/code&gt; but weren&amp;rsquo;t sure what that mapped to in the &lt;code&gt;Color&lt;/code&gt; enum above, we could look up the corresponding name:</source>
          <target state="translated">枚举的一个方便功能是，您也可以在枚举中从数字值转到该值的名称。例如，如果我们具有值 &lt;code&gt;2&lt;/code&gt; ,但不确定上面的 &lt;code&gt;Color&lt;/code&gt; 枚举中映射到的值，我们可以查找对应的名称：</target>
        </trans-unit>
        <trans-unit id="2a3d8efbbf391dd508c0f59ddc90ddfd5e9cb8ce" translate="yes" xml:space="preserve">
          <source>A helpful addition to the standard set of datatypes from JavaScript is the &lt;code&gt;enum&lt;/code&gt;. As in languages like C#, an enum is a way of giving more friendly names to sets of numeric values.</source>
          <target state="translated">&lt;code&gt;enum&lt;/code&gt; 是JavaScript的标准数据类型集的一个有益补充。与C＃等语言一样，枚举是一种为数字值集赋予更友好名称的方法。</target>
        </trans-unit>
        <trans-unit id="ae627315bc177e68b8b178eb3fe934f925ae5a99" translate="yes" xml:space="preserve">
          <source>A key feature of modules in TypeScript is that two different modules will never contribute names to the same scope. Because the consumer of a module decides what name to assign it, there&amp;rsquo;s no need to proactively wrap up the exported symbols in a namespace.</source>
          <target state="translated">TypeScript中模块的主要功能是两个不同的模块永远不会在同一作用域中提供名称。由于模块的使用者决定要为其分配的名称，因此无需主动将导出的符号包装在名称空间中。</target>
        </trans-unit>
        <trans-unit id="10dfd449e653eb5c28991f082b6ab993db0f38fc" translate="yes" xml:space="preserve">
          <source>A library can consist of multiple modules, such as</source>
          <target state="translated">一个库可以由多个模块组成,如</target>
        </trans-unit>
        <trans-unit id="408eb52ef9fae5ded272c34e2fb8532daf7f4ceb" translate="yes" xml:space="preserve">
          <source>A long-awaited feature is smart incremental builds for TypeScript projects. In 3.0 you can use the &lt;code&gt;--build&lt;/code&gt; flag with &lt;code&gt;tsc&lt;/code&gt;. This is effectively a new entry point for &lt;code&gt;tsc&lt;/code&gt; that behaves more like a build orchestrator than a simple compiler.</source>
          <target state="translated">期待已久的功能是用于TypeScript项目的智能增量构建。在3.0中，可以将 &lt;code&gt;--build&lt;/code&gt; 标志与 &lt;code&gt;tsc&lt;/code&gt; 一起使用。实际上，这是 &lt;code&gt;tsc&lt;/code&gt; 的新入口点，其行为更像是构建协调器，而不是简单的编译器。</target>
        </trans-unit>
        <trans-unit id="bf50654387dec069aed329536e7230529d81996c" translate="yes" xml:space="preserve">
          <source>A major part of software engineering is building components that not only have well-defined and consistent APIs, but are also reusable. Components that are capable of working on the data of today as well as the data of tomorrow will give you the most flexible capabilities for building up large software systems.</source>
          <target state="translated">软件工程的一个重要部分就是构建组件,这些组件不仅要有明确的、一致的API,而且要有可重用性。能够在今天的数据和未来的数据上工作的组件,将为你构建大型软件系统提供最灵活的能力。</target>
        </trans-unit>
        <trans-unit id="d9bcb6811c5b2878897a2775d961f00651e45117" translate="yes" xml:space="preserve">
          <source>A mapped type &lt;code&gt;{ [P in K]: XXX }&lt;/code&gt; permits any &lt;code&gt;K&lt;/code&gt; assignable to &lt;code&gt;string | number | symbol&lt;/code&gt;.</source>
          <target state="translated">映射类型 &lt;code&gt;{ [P in K]: XXX }&lt;/code&gt; 允许将任何 &lt;code&gt;K&lt;/code&gt; 分配给 &lt;code&gt;string | number | symbol&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="29451e8b78ccc3f4b9ac772135d8ff18632a054a" translate="yes" xml:space="preserve">
          <source>A method that converts an object to a corresponding primitive value. Called by the &lt;code&gt;ToPrimitive&lt;/code&gt; abstract operation.</source>
          <target state="translated">一种将对象转换为相应原始值的方法。由 &lt;code&gt;ToPrimitive&lt;/code&gt; 抽象操作调用。</target>
        </trans-unit>
        <trans-unit id="116f6b876af45833882c2bd0e4ed75e7920c3f86" translate="yes" xml:space="preserve">
          <source>A method that determines if a constructor object recognizes an object as one of the constructor&amp;rsquo;s instances. Called by the semantics of the instanceof operator.</source>
          <target state="translated">一种确定构造函数对象是否将对象识别为构造函数实例之一的方法。由instanceof运算符的语义调用。</target>
        </trans-unit>
        <trans-unit id="790df4f5d480d1c7b853c049c80823994596880d" translate="yes" xml:space="preserve">
          <source>A method that returns the default iterator for an object. Called by the semantics of the for-of statement.</source>
          <target state="translated">返回一个对象的默认迭代器的方法。由for-of语句的语义调用。</target>
        </trans-unit>
        <trans-unit id="db447b4ab93c0844fc4e212f82c10b11c2a634ec" translate="yes" xml:space="preserve">
          <source>A modifier with no &lt;code&gt;+&lt;/code&gt; or &lt;code&gt;-&lt;/code&gt; prefix is the same as a modifier with a &lt;code&gt;+&lt;/code&gt; prefix. So, the &lt;code&gt;ReadonlyPartial&amp;lt;T&amp;gt;&lt;/code&gt; type above corresponds to</source>
          <target state="translated">不带 &lt;code&gt;+&lt;/code&gt; 或 &lt;code&gt;-&lt;/code&gt; 前缀的修饰符与带 &lt;code&gt;+&lt;/code&gt; 前缀的修饰符相同。因此，上面的 &lt;code&gt;ReadonlyPartial&amp;lt;T&amp;gt;&lt;/code&gt; 类型对应于</target>
        </trans-unit>
        <trans-unit id="3dbeca90d263824170468112465310c954b28b6b" translate="yes" xml:space="preserve">
          <source>A module name will be computed for each module based on its relative location to &lt;code&gt;rootDir&lt;/code&gt;.</source>
          <target state="translated">将根据每个模块相对于 &lt;code&gt;rootDir&lt;/code&gt; 的相对位置来计算模块名称。</target>
        </trans-unit>
        <trans-unit id="8fcfc7285f1ba3d870a6928e1733a7273fde019a" translate="yes" xml:space="preserve">
          <source>A more advanced example uses the prototype property to infer and constrain relationships between the constructor function and the instance side of class types.</source>
          <target state="translated">一个更高级的例子是利用原型属性来推断和约束类类型的构造函数与实例侧的关系。</target>
        </trans-unit>
        <trans-unit id="51dd9695c995c08645a93f5859af50c64ef61af8" translate="yes" xml:space="preserve">
          <source>A more common error that this feature catches is adding a newline after a &lt;code&gt;return&lt;/code&gt; statement:</source>
          <target state="translated">此功能捕获的一个更常见的错误是在 &lt;code&gt;return&lt;/code&gt; 语句后添加换行符：</target>
        </trans-unit>
        <trans-unit id="02309890136fe9803436c2b1bde34201107f663d" translate="yes" xml:space="preserve">
          <source>A namespace &lt;code&gt;X&lt;/code&gt; (because the &lt;code&gt;namespace&lt;/code&gt; declaration contains a type, &lt;code&gt;Y&lt;/code&gt;)</source>
          <target state="translated">命名空间 &lt;code&gt;X&lt;/code&gt; （因为 &lt;code&gt;namespace&lt;/code&gt; 声明包含类型 &lt;code&gt;Y&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="7ae465077e189312db19e43d1c7bdbb04e391e9f" translate="yes" xml:space="preserve">
          <source>A namespace &lt;code&gt;Z&lt;/code&gt;</source>
          <target state="translated">命名空间 &lt;code&gt;Z&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="77bbec5ff2f5cfc37ba667daafc8343e4c27cc4d" translate="yes" xml:space="preserve">
          <source>A namespace import (i.e. &lt;code&gt;import * as foo from &quot;foo&quot;&lt;/code&gt;) is now correctly flagged as uncallable. Calling it will result in an error.</source>
          <target state="translated">现在将名称空间导入（即 &lt;code&gt;import * as foo from &quot;foo&quot;&lt;/code&gt; ）正确标记为不可调用。调用它将导致错误。</target>
        </trans-unit>
        <trans-unit id="2830a5f5ce7dd5eaff83de00bb84188237d5ac6f" translate="yes" xml:space="preserve">
          <source>A new &lt;code&gt;!&lt;/code&gt; post-fix expression operator may be used to assert that its operand is non-null and non-undefined in contexts where the type checker is unable to conclude that fact. Specifically, the operation &lt;code&gt;x!&lt;/code&gt; produces a value of the type of &lt;code&gt;x&lt;/code&gt; with &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt; excluded. Similar to type assertions of the forms &lt;code&gt;&amp;lt;T&amp;gt;x&lt;/code&gt; and &lt;code&gt;x as T&lt;/code&gt;, the &lt;code&gt;!&lt;/code&gt; non-null assertion operator is simply removed in the emitted JavaScript code.</source>
          <target state="translated">一个新的 &lt;code&gt;!&lt;/code&gt; 在类型检查器无法得出结论的情况下，可以使用后缀表达式运算符来断言其操作数是非null且未定义的。具体来说，就是操作 &lt;code&gt;x!&lt;/code&gt; 生成 &lt;code&gt;x&lt;/code&gt; 类型的值，其中排除了 &lt;code&gt;null&lt;/code&gt; 和 &lt;code&gt;undefined&lt;/code&gt; 。的形式类似于键入断言 &lt;code&gt;&amp;lt;T&amp;gt;x&lt;/code&gt; 和 &lt;code&gt;x as T&lt;/code&gt; ，则 &lt;code&gt;!&lt;/code&gt; 只需在发出的JavaScript代码中删除非null断言运算符即可。</target>
        </trans-unit>
        <trans-unit id="2655be7a46ceb733d0fd15d66bae85ebe5cb1eb1" translate="yes" xml:space="preserve">
          <source>A new flag is also added in TypeScript 2.0 to flag all uses of &lt;code&gt;this&lt;/code&gt; in functions without an explicit type annotation.</source>
          <target state="translated">在TypeScript 2.0中还添加了一个新标志，以在没有显式类型注释的情况下标记函数中 &lt;code&gt;this&lt;/code&gt; 功能的所有使用。</target>
        </trans-unit>
        <trans-unit id="9ce3e808c856b4c4b90bbc578b4afa30e7e8a218" translate="yes" xml:space="preserve">
          <source>A new syntax for &lt;code&gt;ReadonlyArray&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;ReadonlyArray&lt;/code&gt; 的新语法</target>
        </trans-unit>
        <trans-unit id="4571ad9d84c9c7959037752a1b8faca40bbe10a7" translate="yes" xml:space="preserve">
          <source>A nightly build from the &lt;a href=&quot;https://github.com/Microsoft/TypeScript/tree/master&quot;&gt;TypeScript&amp;rsquo;s &lt;code&gt;master&lt;/code&gt;&lt;/a&gt; branch is published by midnight PST to NPM and NuGet. Here is how you can get it and use it with your tools.</source>
          <target state="translated">太平洋标准时间（PST）午夜从&lt;a href=&quot;https://github.com/Microsoft/TypeScript/tree/master&quot;&gt;TypeScript的 &lt;code&gt;master&lt;/code&gt; &lt;/a&gt;分支发布的夜间版本发布到NPM和NuGet。这是获取和与工具一起使用的方法。</target>
        </trans-unit>
        <trans-unit id="03a025aabca041d8656b9b41a0f1be5a93ff1fe1" translate="yes" xml:space="preserve">
          <source>A non-relative import can be resolved relative to &lt;code&gt;baseUrl&lt;/code&gt;, or through path mapping, which we&amp;rsquo;ll cover below. They can also resolve to &lt;a href=&quot;modules#ambient-modules&quot;&gt;ambient module declarations&lt;/a&gt;. Use non-relative paths when importing any of your external dependencies.</source>
          <target state="translated">可以相对于 &lt;code&gt;baseUrl&lt;/code&gt; 解析非相对导入，也可以通过路径映射来解决，我们将在下面介绍。他们还可以解析为&lt;a href=&quot;modules#ambient-modules&quot;&gt;环境模块声明&lt;/a&gt;。导入任何外部依赖项时，请使用非相对路径。</target>
        </trans-unit>
        <trans-unit id="036c7405ac8596f3f842074ad7095463b1af061e" translate="yes" xml:space="preserve">
          <source>A non-relative import to &lt;code&gt;moduleB&lt;/code&gt; such as &lt;code&gt;import { b } from &quot;moduleB&quot;&lt;/code&gt;, in a source file &lt;code&gt;/root/src/folder/A.ts&lt;/code&gt;, would result in attempting the following locations for locating &lt;code&gt;&quot;moduleB&quot;&lt;/code&gt;:</source>
          <target state="translated">源文件 &lt;code&gt;/root/src/folder/A.ts&lt;/code&gt; 中对 &lt;code&gt;moduleB&lt;/code&gt; 的非相对导入（例如 &lt;code&gt;import { b } from &quot;moduleB&quot;&lt;/code&gt; ，将导致尝试以下位置来定位 &lt;code&gt;&quot;moduleB&quot;&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="908464f8d4f6e5d96a7983c65456609769299d87" translate="yes" xml:space="preserve">
          <source>A note about &amp;lsquo;let&amp;rsquo;</source>
          <target state="translated">关于&amp;ldquo;让&amp;rdquo;的注释</target>
        </trans-unit>
        <trans-unit id="bfe7c80c1a11cfefa188943b94c8dce4cafd7212" translate="yes" xml:space="preserve">
          <source>A note about &lt;code&gt;let&lt;/code&gt;</source>
          <target state="translated">关于 &lt;code&gt;let&lt;/code&gt; 的说明</target>
        </trans-unit>
        <trans-unit id="34d8d6a247e4459c0dd02162269341b98212407d" translate="yes" xml:space="preserve">
          <source>A partial version of it would be:</source>
          <target state="translated">部分的版本应该是:</target>
        </trans-unit>
        <trans-unit id="0dc358ce5550ca2f28f0b4972670dc958c4e4327" translate="yes" xml:space="preserve">
          <source>A polymorphic &lt;code&gt;this&lt;/code&gt; type represents a type that is the &lt;em&gt;subtype&lt;/em&gt; of the containing class or interface. This is called &lt;em&gt;F&lt;/em&gt;-bounded polymorphism. This makes hierarchical fluent interfaces much easier to express, for example. Take a simple calculator that returns &lt;code&gt;this&lt;/code&gt; after each operation:</source>
          <target state="translated">&lt;code&gt;this&lt;/code&gt; 类型的多态表示一个类型，它是包含的类或接口的&lt;em&gt;子类型&lt;/em&gt;。这称为&lt;em&gt;F&lt;/em&gt;界多态性。例如，这使得分层流利的接口更易于表达。使用一个简单的计算器， &lt;code&gt;this&lt;/code&gt; 计算器在每次操作后都会返回此值：</target>
        </trans-unit>
        <trans-unit id="4bfc09c2ed20b76aa6a3b9cc810f2a50f0733568" translate="yes" xml:space="preserve">
          <source>A project source layout sometimes does not match that of the output. Usually a set of build steps result in generating the final output. These include compiling &lt;code&gt;.ts&lt;/code&gt; files into &lt;code&gt;.js&lt;/code&gt;, and copying dependencies from different source locations to a single output location. The net result is that modules at runtime may have different names than the source files containing their definitions. Or module paths in the final output may not match their corresponding source file paths at compile time.</source>
          <target state="translated">项目源布局有时与输出的布局不匹配。通常，一组构建步骤会导致生成最终输出。其中包括将 &lt;code&gt;.ts&lt;/code&gt; 文件编译为 &lt;code&gt;.js&lt;/code&gt; ，并将依赖关系从不同的源位置复制到单个输出位置。最终结果是，模块在运行时的名称可能不同于包含其定义的源文件的名称。否则最终输出中的模块路径在编译时可能与它们相应的源文件路径不匹配。</target>
        </trans-unit>
        <trans-unit id="282c27706098563c877f1ff268884923d740e395" translate="yes" xml:space="preserve">
          <source>A property access or a function call produces a compile-time error if the object or function is of a type that includes &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt;. However, type guards are extended to support non-null and non-undefined checks.</source>
          <target state="translated">如果对象或函数的类型包括 &lt;code&gt;null&lt;/code&gt; 或 &lt;code&gt;undefined&lt;/code&gt; ，则属性访问或函数调用会产生编译时错误。但是，类型防护措施已扩展为支持非null和非不确定检查。</target>
        </trans-unit>
        <trans-unit id="59344ab2361c175ea781e369233d17a3ef1173a2" translate="yes" xml:space="preserve">
          <source>A property declared with a &lt;code&gt;get&lt;/code&gt; accessor and no &lt;code&gt;set&lt;/code&gt; accessor is considered read-only.</source>
          <target state="translated">使用 &lt;code&gt;get&lt;/code&gt; 访问器声明且没有 &lt;code&gt;set&lt;/code&gt; 访问器声明的属性被视为只读。</target>
        </trans-unit>
        <trans-unit id="b689c46a292974d609ea79412658e0ee92a02aed" translate="yes" xml:space="preserve">
          <source>A property or index signature can now be declared with the &lt;code&gt;readonly&lt;/code&gt; modifier is considered read-only.</source>
          <target state="translated">现在可以使用 &lt;code&gt;readonly&lt;/code&gt; 修饰符声明属性或索引签名，将其视为只读。</target>
        </trans-unit>
        <trans-unit id="3d52bcb9c5e9671606eed7fffb194263c9890a7a" translate="yes" xml:space="preserve">
          <source>A regular expression method that matches the regular expression against a string. Called by the &lt;code&gt;String.prototype.match&lt;/code&gt; method.</source>
          <target state="translated">将正则表达式与字符串匹配的正则表达式方法。由 &lt;code&gt;String.prototype.match&lt;/code&gt; 方法调用。</target>
        </trans-unit>
        <trans-unit id="9cd6edb9d65460dc36b50f0399530c31b1e87d57" translate="yes" xml:space="preserve">
          <source>A regular expression method that replaces matched substrings of a string. Called by the &lt;code&gt;String.prototype.replace&lt;/code&gt; method.</source>
          <target state="translated">一个正则表达式方法，用于替换字符串的匹配子字符串。由 &lt;code&gt;String.prototype.replace&lt;/code&gt; 方法调用。</target>
        </trans-unit>
        <trans-unit id="58d5cbe9a0d4a216822033b575ab84161f890fd4" translate="yes" xml:space="preserve">
          <source>A regular expression method that returns the index within a string that matches the regular expression. Called by the &lt;code&gt;String.prototype.search&lt;/code&gt; method.</source>
          <target state="translated">返回与正则表达式匹配的字符串中的索引的正则表达式方法。由 &lt;code&gt;String.prototype.search&lt;/code&gt; 方法调用。</target>
        </trans-unit>
        <trans-unit id="38d40fad27af50b9cfc4c1b7935edd018faa338e" translate="yes" xml:space="preserve">
          <source>A regular expression method that splits a string at the indices that match the regular expression. Called by the &lt;code&gt;String.prototype.split&lt;/code&gt; method.</source>
          <target state="translated">一个正则表达式方法，该方法在与正则表达式匹配的索引处拆分字符串。由 &lt;code&gt;String.prototype.split&lt;/code&gt; 方法调用。</target>
        </trans-unit>
        <trans-unit id="fc17888ce2ecd41d7b6b0d5fb3a3670f069072bf" translate="yes" xml:space="preserve">
          <source>A relative import is resolved relative to the importing file and &lt;em&gt;cannot&lt;/em&gt; resolve to an ambient module declaration. You should use relative imports for your own modules that are guaranteed to maintain their relative location at runtime.</source>
          <target state="translated">相对导入相对于导入文件已解析，并且&lt;em&gt;无法&lt;/em&gt;解析为环境模块声明。您应该对自己的模块使用相对导入，以确保在运行时保持它们的相对位置。</target>
        </trans-unit>
        <trans-unit id="28de4947ee9f22a7989c024ed424c3f367678816" translate="yes" xml:space="preserve">
          <source>A relative import will be resolved relative to the importing file. So &lt;code&gt;import { b } from &quot;./moduleB&quot;&lt;/code&gt; in source file &lt;code&gt;/root/src/folder/A.ts&lt;/code&gt; would result in the following lookups:</source>
          <target state="translated">相对导入将相对于导入文件解决。因此， &lt;code&gt;import { b } from &quot;./moduleB&quot;&lt;/code&gt; 源文件 &lt;code&gt;/root/src/folder/A.ts&lt;/code&gt; 中的&amp;ldquo; ./moduleB&amp;rdquo;导入{b}将导致以下查找：</target>
        </trans-unit>
        <trans-unit id="d9edb5186e2748078674706a60a9cf32f84d1333" translate="yes" xml:space="preserve">
          <source>A rest parameter is permitted to have a generic type that is constrained to an array type, and type inference can infer tuple types for such generic rest parameters. This enables higher-order capturing and spreading of partial parameter lists:</source>
          <target state="translated">允许一个休息参数有一个约束于数组类型的通用类型,而类型推理可以为这种通用休息参数推理出元组类型。这使得部分参数列表的高阶捕获和传播成为可能。</target>
        </trans-unit>
        <trans-unit id="cf7553b7e9850da0e4309ead9e8788fc38bf0c98" translate="yes" xml:space="preserve">
          <source>A simple rule to follow is to only declare types &lt;em&gt;namespaced&lt;/em&gt; by whatever global variable the library defines. For example, if the library defines the global value &amp;lsquo;cats&amp;rsquo;, you should write</source>
          <target state="translated">一个简单的规则是仅声明由库定义的任何全局变量&lt;em&gt;命名&lt;/em&gt;的类型。例如，如果库定义了全局值&amp;ldquo; cats&amp;rdquo;，则应编写</target>
        </trans-unit>
        <trans-unit id="70f69678357ce810ac7be6d3a7871e410f98bb81" translate="yes" xml:space="preserve">
          <source>A triple-slash reference path is resolved relative to the containing file, if unrooted.</source>
          <target state="translated">三斜线引用路径是相对于包含的文件进行解析的,如果没有根的话。</target>
        </trans-unit>
        <trans-unit id="353474e46afb00c48588800a3c6d0c5342041035" translate="yes" xml:space="preserve">
          <source>A tsconfig.json file that doesn&amp;rsquo;t specify a files property (and therefore implicitly references all *.ts files in all subdirectories) can now contain an exclude property that specifies a list of files and/or directories to exclude from the compilation. The exclude property must be an array of strings that each specify a file or folder name relative to the location of the tsconfig.json file. For example:</source>
          <target state="translated">未指定files属性的tsconfig.json文件（因此隐式引用了所有子目录中的所有* .ts文件）现在可以包含exclude属性，该属性指定要从编译中排除的文件和/或目录的列表。exclude属性必须是一个字符串数组，每个字符串都指定相对于tsconfig.json文件位置的文件或文件夹名称。例如：</target>
        </trans-unit>
        <trans-unit id="df0d20ca9dd32bdd7425a8bf1f2869e727193b73" translate="yes" xml:space="preserve">
          <source>A tuple type permits an element to be omitted if it has a postfix &lt;code&gt;?&lt;/code&gt; modifier on its type and all elements to the right of it also have &lt;code&gt;?&lt;/code&gt; modifiers.</source>
          <target state="translated">元组类型允许后缀为 &lt;code&gt;?&lt;/code&gt; 的元素被省略。它的类型上的修饰符以及它右边的所有元素也都有 &lt;code&gt;?&lt;/code&gt; 修饰符。</target>
        </trans-unit>
        <trans-unit id="c0fda59c87a9ce8c6218af973a8a318d8c48726a" translate="yes" xml:space="preserve">
          <source>A type &lt;code&gt;C&lt;/code&gt; in the &lt;code&gt;X.Z&lt;/code&gt; namespace</source>
          <target state="translated">A型 &lt;code&gt;C&lt;/code&gt; 在 &lt;code&gt;X.Z&lt;/code&gt; 命名空间</target>
        </trans-unit>
        <trans-unit id="8b8cb0beae34b84268f8712bb01776f705387774" translate="yes" xml:space="preserve">
          <source>A type &lt;code&gt;X&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;X&lt;/code&gt; 型</target>
        </trans-unit>
        <trans-unit id="882188abb4f22a21291e791a69d7bc7153c6ea49" translate="yes" xml:space="preserve">
          <source>A type &lt;code&gt;Y&lt;/code&gt; in the &lt;code&gt;X&lt;/code&gt; namespace</source>
          <target state="translated">A型 &lt;code&gt;Y&lt;/code&gt; 在 &lt;code&gt;X&lt;/code&gt; 的命名空间</target>
        </trans-unit>
        <trans-unit id="74378f84a7232e7c818036a1aa4f8e790357dad0" translate="yes" xml:space="preserve">
          <source>A type &lt;code&gt;Z&lt;/code&gt; in the &lt;code&gt;X&lt;/code&gt; namespace (the instance shape of the class)</source>
          <target state="translated">&lt;code&gt;X&lt;/code&gt; 名称空间中的类型 &lt;code&gt;Z&lt;/code&gt; （类的实例形状）</target>
        </trans-unit>
        <trans-unit id="c1687cc1f239d5cbfef8dd21147b9dd24d76a0c8" translate="yes" xml:space="preserve">
          <source>A type alias declaration (&lt;code&gt;type sn = number | string;&lt;/code&gt;)</source>
          <target state="translated">类型别名声明（ &lt;code&gt;type sn = number | string;&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="bf4c2689d169ce1d458db13d7d40fdbf2f6b6244" translate="yes" xml:space="preserve">
          <source>A type alias that takes the union of those types &amp;mdash; the &lt;em&gt;union&lt;/em&gt;.</source>
          <target state="translated">类型别名，采用这些类型的&lt;em&gt;并集-union&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="5f2efd539d70b51bc5ae0611e5b848813a9078c1" translate="yes" xml:space="preserve">
          <source>A type can include an index signature to explicitly indicate that excess properties are permitted:</source>
          <target state="translated">一个类型可以包含一个索引签名,明确表示允许超量属性。</target>
        </trans-unit>
        <trans-unit id="22c383b7f56821c1f9a53cd7d2c78316dfd7e93b" translate="yes" xml:space="preserve">
          <source>A type guard for a dotted name has no effect following an assignment to any part of the dotted name. For example, a type guard for &lt;code&gt;x.y.z&lt;/code&gt; will have no effect following an assignment to &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;x.y&lt;/code&gt;, or &lt;code&gt;x.y.z&lt;/code&gt;.</source>
          <target state="translated">分配给点名的任何部分后，带点名的类型防护将无效。例如，在分配给 &lt;code&gt;x&lt;/code&gt; ， &lt;code&gt;x.y&lt;/code&gt; 或 &lt;code&gt;x.y.z&lt;/code&gt; 之后， &lt;code&gt;x.y.z&lt;/code&gt; 的类型保护将无效。</target>
        </trans-unit>
        <trans-unit id="3a377432dffa8ea7066844e2455d6987bca2958f" translate="yes" xml:space="preserve">
          <source>A type parameter is deemed optional if it has a default.</source>
          <target state="translated">如果一个类型参数有默认值,则被认为是可选的。</target>
        </trans-unit>
        <trans-unit id="0d14b0d6b21fc7288313f91b187510fabde9b646" translate="yes" xml:space="preserve">
          <source>A types package is a folder with a file called &lt;code&gt;index.d.ts&lt;/code&gt; or a folder with a &lt;code&gt;package.json&lt;/code&gt; that has a &lt;code&gt;types&lt;/code&gt; field.</source>
          <target state="translated">类型包是具有名为 &lt;code&gt;index.d.ts&lt;/code&gt; 的文件的文件夹或具有 &lt;code&gt;types&lt;/code&gt; 字段的具有 &lt;code&gt;package.json&lt;/code&gt; 的文件夹。</target>
        </trans-unit>
        <trans-unit id="14d41e9733c26726f7735bdd4c4e805ad6e0b738" translate="yes" xml:space="preserve">
          <source>A union type describes a value that can be one of several types. We use the vertical bar (&lt;code&gt;|&lt;/code&gt;) to separate each type, so &lt;code&gt;number | string | boolean&lt;/code&gt; is the type of a value that can be a &lt;code&gt;number&lt;/code&gt;, a &lt;code&gt;string&lt;/code&gt;, or a &lt;code&gt;boolean&lt;/code&gt;.</source>
          <target state="translated">联合类型描述的值可以是几种类型之一。我们使用竖线（ &lt;code&gt;|&lt;/code&gt; ）分隔每种类型，因此 &lt;code&gt;number | string | boolean&lt;/code&gt; 是值的类型，可以是 &lt;code&gt;number&lt;/code&gt; ， &lt;code&gt;string&lt;/code&gt; 或 &lt;code&gt;boolean&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="77032b55ce2cb4248190b5e5184e5e0b38ee393b" translate="yes" xml:space="preserve">
          <source>A user could express &lt;code&gt;2 * 5 + 1&lt;/code&gt; as</source>
          <target state="translated">用户可以将 &lt;code&gt;2 * 5 + 1&lt;/code&gt; 表示为</target>
        </trans-unit>
        <trans-unit id="199d562e0a71e63f245aa31f49c36513d849c222" translate="yes" xml:space="preserve">
          <source>A value &lt;code&gt;C&lt;/code&gt; that is a property of the &lt;code&gt;X.Z&lt;/code&gt; value</source>
          <target state="translated">作为 &lt;code&gt;X.Z&lt;/code&gt; 值属性的值 &lt;code&gt;C&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="21e079e6071fdb5e16a79cbbbac36f7c59e77e29" translate="yes" xml:space="preserve">
          <source>A value &lt;code&gt;X&lt;/code&gt; (because the &lt;code&gt;namespace&lt;/code&gt; declaration contains a value, &lt;code&gt;Z&lt;/code&gt;)</source>
          <target state="translated">值 &lt;code&gt;X&lt;/code&gt; （因为 &lt;code&gt;namespace&lt;/code&gt; 声明包含值 &lt;code&gt;Z&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="72326d369b07efe650b4c687b18320a6555b7a1a" translate="yes" xml:space="preserve">
          <source>A value &lt;code&gt;Y&lt;/code&gt; (of type &lt;code&gt;number&lt;/code&gt;) that is a property of the &lt;code&gt;X&lt;/code&gt; value</source>
          <target state="translated">&lt;code&gt;Y&lt;/code&gt; 值（类型 &lt;code&gt;number&lt;/code&gt; ），它是 &lt;code&gt;X&lt;/code&gt; 值的属性</target>
        </trans-unit>
        <trans-unit id="2db8707fec6d748cc12ab97735dc5f33a19182c2" translate="yes" xml:space="preserve">
          <source>A value &lt;code&gt;Z&lt;/code&gt; that is a property of the &lt;code&gt;X&lt;/code&gt; value</source>
          <target state="translated">作为 &lt;code&gt;X&lt;/code&gt; 值属性的值 &lt;code&gt;Z&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="03ce9a077fea19a3768255595563e3f325b99287" translate="yes" xml:space="preserve">
          <source>A value &lt;code&gt;Z&lt;/code&gt; that is a property of the &lt;code&gt;X&lt;/code&gt; value (the constructor function of the class)</source>
          <target state="translated">作为 &lt;code&gt;X&lt;/code&gt; 值的属性的值 &lt;code&gt;Z&lt;/code&gt; （类的构造函数）</target>
        </trans-unit>
        <trans-unit id="2ac5e8f9f24c7489cdb9a76f63355463e38d2ed2" translate="yes" xml:space="preserve">
          <source>A variable declared with no type annotation and an initial value of &lt;code&gt;[]&lt;/code&gt; is considered an implicit &lt;code&gt;any[]&lt;/code&gt; variable. However, each subsequent &lt;code&gt;x.push(value)&lt;/code&gt;, &lt;code&gt;x.unshift(value)&lt;/code&gt; or &lt;code&gt;x[n] = value&lt;/code&gt; operation &lt;em&gt;evolves&lt;/em&gt; the type of the variable in accordance with what elements are added to it.</source>
          <target state="translated">一种可变没有类型注释和的初始值声明 &lt;code&gt;[]&lt;/code&gt; 被认为是隐式的 &lt;code&gt;any[]&lt;/code&gt; 变量。但是，随后的每个 &lt;code&gt;x.push(value)&lt;/code&gt; ， &lt;code&gt;x.unshift(value)&lt;/code&gt; 或 &lt;code&gt;x[n] = value&lt;/code&gt; 操作都会根据添加到变量中的元素来&lt;em&gt;演化&lt;/em&gt;变量的类型。</target>
        </trans-unit>
        <trans-unit id="70d19e4c7a5fa9d0f738254cc159113f3fd200b2" translate="yes" xml:space="preserve">
          <source>AMD / RequireJS SimpleModule.js</source>
          <target state="translated">AMD/RequireJS SimpleModule.js</target>
        </trans-unit>
        <trans-unit id="d64764987e4f302df4936aa982040ba263c5581e" translate="yes" xml:space="preserve">
          <source>AMD Module names</source>
          <target state="translated">AMD 模块名称</target>
        </trans-unit>
        <trans-unit id="b4e985e77edef4f93404d5e6768643dd9e768f9b" translate="yes" xml:space="preserve">
          <source>AMD-dependency optional names</source>
          <target state="translated">AMD依赖性的可选名称</target>
        </trans-unit>
        <trans-unit id="62845d0d9af23cbc1eec333eb2ecfd163d55a726" translate="yes" xml:space="preserve">
          <source>API Changes</source>
          <target state="translated">API的变化</target>
        </trans-unit>
        <trans-unit id="512a3dad0b0ce90df79e253450f20d82200891c0" translate="yes" xml:space="preserve">
          <source>APIs to Support &lt;code&gt;--build&lt;/code&gt; and &lt;code&gt;--incremental&lt;/code&gt;</source>
          <target state="translated">支持 &lt;code&gt;--build&lt;/code&gt; 和 &lt;code&gt;--incremental&lt;/code&gt; 的 API</target>
        </trans-unit>
        <trans-unit id="f34de1e75f36d287ab4c87ba0a5a432c79f048d4" translate="yes" xml:space="preserve">
          <source>ASP.NET Core</source>
          <target state="translated">ASP.NET核心</target>
        </trans-unit>
        <trans-unit id="366e9dcb2473f425157fef0b4dc8e68450d4a527" translate="yes" xml:space="preserve">
          <source>ASP.NET Core + TypeScript</source>
          <target state="translated">ASP.NET内核+TypeScript</target>
        </trans-unit>
        <trans-unit id="fd2bfb743d58034cf4f2ef0407bda4991e6e266a" translate="yes" xml:space="preserve">
          <source>ASP.NET Core: Add TypeScript</source>
          <target state="translated">ASP.NET Core:添加TypeScript</target>
        </trans-unit>
        <trans-unit id="26ca92c515719697094cd865e18cbd056f86e90b" translate="yes" xml:space="preserve">
          <source>ASP.NET Core: Setup</source>
          <target state="translated">ASP.NET内核:设置</target>
        </trans-unit>
        <trans-unit id="8462d6e971391c5728bd5c55cd114f6c45225c83" translate="yes" xml:space="preserve">
          <source>Above, all inferences for &lt;code&gt;T&lt;/code&gt; originate in contravariant positions, and we therefore infer the &lt;em&gt;best common subtype&lt;/em&gt; for &lt;code&gt;T&lt;/code&gt;. This contrasts with inferences from covariant positions, where we infer the &lt;em&gt;best common supertype&lt;/em&gt;.</source>
          <target state="translated">以上，所有的推论 &lt;code&gt;T&lt;/code&gt; 起源于逆变位置，因此，我们推断出&lt;em&gt;最好的常见的亚型&lt;/em&gt;的 &lt;code&gt;T&lt;/code&gt; 。这与协变位置的推论相反，在协变位置我们推论出&lt;em&gt;最佳的共同超类型&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="d99c638eab09eef692bca448341109f58d65928f" translate="yes" xml:space="preserve">
          <source>Above, we have a &lt;code&gt;StringArray&lt;/code&gt; interface that has an index signature. This index signature states that when a &lt;code&gt;StringArray&lt;/code&gt; is indexed with a &lt;code&gt;number&lt;/code&gt;, it will return a &lt;code&gt;string&lt;/code&gt;.</source>
          <target state="translated">上面，我们有一个带有索引签名的 &lt;code&gt;StringArray&lt;/code&gt; 接口。此索引签名指出，当用 &lt;code&gt;number&lt;/code&gt; 对 &lt;code&gt;StringArray&lt;/code&gt; 进行索引时，它将返回一个 &lt;code&gt;string&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="29268223f69d326a5adbf22aa200f48337d3383a" translate="yes" xml:space="preserve">
          <source>Above, we have a numeric enum where &lt;code&gt;Up&lt;/code&gt; is initialized with &lt;code&gt;1&lt;/code&gt;. All of the following members are auto-incremented from that point on. In other words, &lt;code&gt;Direction.Up&lt;/code&gt; has the value &lt;code&gt;1&lt;/code&gt;, &lt;code&gt;Down&lt;/code&gt; has &lt;code&gt;2&lt;/code&gt;, &lt;code&gt;Left&lt;/code&gt; has &lt;code&gt;3&lt;/code&gt;, and &lt;code&gt;Right&lt;/code&gt; has &lt;code&gt;4&lt;/code&gt;.</source>
          <target state="translated">上面是一个数字枚举，其中 &lt;code&gt;Up&lt;/code&gt; 初始化为 &lt;code&gt;1&lt;/code&gt; 。从那时起，以下所有成员都会自动增加。换句话说， &lt;code&gt;Direction.Up&lt;/code&gt; 具有值 &lt;code&gt;1&lt;/code&gt; ， &lt;code&gt;Down&lt;/code&gt; 具有 &lt;code&gt;2&lt;/code&gt; ， &lt;code&gt;Left&lt;/code&gt; 具有 &lt;code&gt;3&lt;/code&gt; ，和 &lt;code&gt;Right&lt;/code&gt; 具有 &lt;code&gt;4&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="af4c6101610761ea26e2cfbf041a94da323abdcc" translate="yes" xml:space="preserve">
          <source>Abstract Classes</source>
          <target state="translated">摘要类</target>
        </trans-unit>
        <trans-unit id="92d2d55c032fde11e5fb12992c8af2dbab612b6c" translate="yes" xml:space="preserve">
          <source>Abstract classes are base classes from which other classes may be derived. They may not be instantiated directly. Unlike an interface, an abstract class may contain implementation details for its members. The &lt;code&gt;abstract&lt;/code&gt; keyword is used to define abstract classes as well as abstract methods within an abstract class.</source>
          <target state="translated">抽象类是可以从中派生其他类的基类。它们可能无法直接实例化。与接口不同，抽象类可能包含其成员的实现详细信息。所述 &lt;code&gt;abstract&lt;/code&gt; 关键字用于抽象类中定义抽象类以及抽象方法。</target>
        </trans-unit>
        <trans-unit id="90c7ee5a4b4ef6e67fa95b9c12e51b21561cd41f" translate="yes" xml:space="preserve">
          <source>Abstract properties and accessors</source>
          <target state="translated">抽象属性和访问器</target>
        </trans-unit>
        <trans-unit id="bc1eac0b05aa68bdf95d2d14137e5c9213052598" translate="yes" xml:space="preserve">
          <source>Accept JavaScript files as inputs (with &lt;code&gt;allowJs&lt;/code&gt;).</source>
          <target state="translated">接受JavaScript文件作为输入（带有 &lt;code&gt;allowJs&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="f52e0a010fa39d93f5775a9f132d6deb5746c842" translate="yes" xml:space="preserve">
          <source>Accessing an element outside the set of known indices fails with an error:</source>
          <target state="translated">访问已知索引集之外的元素,会出现错误。</target>
        </trans-unit>
        <trans-unit id="9211673b68532807a6d2c852f45d3d0a3786afaf" translate="yes" xml:space="preserve">
          <source>Accessor Decorators</source>
          <target state="translated">安居客装饰公司</target>
        </trans-unit>
        <trans-unit id="f5b0e226ed894764db92e76b6c1f1203c0b805bb" translate="yes" xml:space="preserve">
          <source>Accessors</source>
          <target state="translated">Accessors</target>
        </trans-unit>
        <trans-unit id="ba917141f6a1280321df068fb903677e998c5655" translate="yes" xml:space="preserve">
          <source>Add TypeScript</source>
          <target state="translated">添加TypeScript</target>
        </trans-unit>
        <trans-unit id="03f2f0c4f330f17bca1624a3a414eba729371bb6" translate="yes" xml:space="preserve">
          <source>Add TypeScript code</source>
          <target state="translated">添加TypeScript代码</target>
        </trans-unit>
        <trans-unit id="2826bcb0cd82d31aa891fcd966fb1d7028f4f052" translate="yes" xml:space="preserve">
          <source>Add a TypeScript configuration file</source>
          <target state="translated">添加一个TypeScript配置文件</target>
        </trans-unit>
        <trans-unit id="d15c277560e45ee3069031db7b1443def54bf1e5" translate="yes" xml:space="preserve">
          <source>Add an index signature to the weak type (i.e. &lt;code&gt;[propName: string]: {}&lt;/code&gt;).</source>
          <target state="translated">将索引签名添加到弱类型（即 &lt;code&gt;[propName: string]: {}&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="d86f6887abf355322f84124fc796c5eca75b3b63" translate="yes" xml:space="preserve">
          <source>Add example code</source>
          <target state="translated">添加示例代码</target>
        </trans-unit>
        <trans-unit id="030eb6eab9d9ce5260b44edf17a0969d1e22a783" translate="yes" xml:space="preserve">
          <source>Add modules to the code</source>
          <target state="translated">在代码中添加模块</target>
        </trans-unit>
        <trans-unit id="0897ccd0a932866daaf546a1ee6c09bc49494aa1" translate="yes" xml:space="preserve">
          <source>Add the following code to the &lt;code&gt;app.ts&lt;/code&gt; file.</source>
          <target state="translated">将以下代码添加到 &lt;code&gt;app.ts&lt;/code&gt; 文件。</target>
        </trans-unit>
        <trans-unit id="3d2583d632f0a677d9ba11848beebe77e200bfeb" translate="yes" xml:space="preserve">
          <source>Adding a &lt;code&gt;tsconfig.json&lt;/code&gt; file in a directory indicates that the directory is the root of a TypeScript project. The tsconfig.json file specifies the root files and the compiler options required to compile the project. A project is compiled in one of the following ways:</source>
          <target state="translated">在目录中添加 &lt;code&gt;tsconfig.json&lt;/code&gt; 文件表示该目录是TypeScript项目的根目录。tsconfig.json文件指定了根文件和编译项目所需的编译器选项。通过以下方式之一编译项目：</target>
        </trans-unit>
        <trans-unit id="7dbea2ea77887f1c86da0aa25a3f25ac23ead618" translate="yes" xml:space="preserve">
          <source>Adding using a &lt;code&gt;namespace&lt;/code&gt;</source>
          <target state="translated">使用 &lt;code&gt;namespace&lt;/code&gt; 添加</target>
        </trans-unit>
        <trans-unit id="51ec7e9fd3e27aeb0e50a50e1368f25d547f3a58" translate="yes" xml:space="preserve">
          <source>Adding using an &lt;code&gt;interface&lt;/code&gt;</source>
          <target state="translated">使用 &lt;code&gt;interface&lt;/code&gt; 添加</target>
        </trans-unit>
        <trans-unit id="b365969c1cff42268e57d78eee550841c3962e45" translate="yes" xml:space="preserve">
          <source>Additional module resolution flags</source>
          <target state="translated">额外的模块分辨率标志</target>
        </trans-unit>
        <trans-unit id="5bc0373dbdf9447ae6c7d80c2c34b8dc3091badc" translate="yes" xml:space="preserve">
          <source>Additionally, &lt;a href=&quot;https://github.com/Microsoft/TypeScript/pull/27028#issuecomment-429334450&quot;&gt;another caveat&lt;/a&gt; of this new functionality is that due to certain limitations, &lt;code&gt;bind&lt;/code&gt;, &lt;code&gt;call&lt;/code&gt;, and &lt;code&gt;apply&lt;/code&gt; can&amp;rsquo;t yet fully model generic functions or functions that have overloads. When using these methods on a generic function, type parameters will be substituted with the empty object type (&lt;code&gt;{}&lt;/code&gt;), and when used on a function with overloads, only the last overload will ever be modeled.</source>
          <target state="translated">此外，此新功能的&lt;a href=&quot;https://github.com/Microsoft/TypeScript/pull/27028#issuecomment-429334450&quot;&gt;另一个警告&lt;/a&gt;是，由于某些限制， &lt;code&gt;bind&lt;/code&gt; ， &lt;code&gt;call&lt;/code&gt; 和 &lt;code&gt;apply&lt;/code&gt; 无法完全建模通用函数或具有重载的函数。在泛型函数上使用这些方法时，类型参数将替换为空对象类型（ &lt;code&gt;{}&lt;/code&gt; ），并且在具有重载的函数上使用时，将仅对最后一个重载进行建模。</target>
        </trans-unit>
        <trans-unit id="c8c07f0e3695aef1b4eb4f9692657a313d0394be" translate="yes" xml:space="preserve">
          <source>Additionally, generators just assumed the type of &lt;code&gt;yield&lt;/code&gt; was always &lt;code&gt;any&lt;/code&gt;.</source>
          <target state="translated">此外，生成器只是假设 &lt;code&gt;yield&lt;/code&gt; 的类型始终是 &lt;code&gt;any&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9897d524bc1adaf827ec23a4f3fb80edccd67b36" translate="yes" xml:space="preserve">
          <source>Additionally, the &lt;code&gt;JSX.IntrinsicAttributes&lt;/code&gt; interface can be used to specify extra properties used by the JSX framework which are not generally used by the components&amp;rsquo; props or arguments - for instance &lt;code&gt;key&lt;/code&gt; in React. Specializing further, the generic &lt;code&gt;JSX.IntrinsicClassAttributes&amp;lt;T&amp;gt;&lt;/code&gt; type may also be used to specify the same kind of extra attributes just for class components (and not Function Components). In this type, the generic parameter corresponds to the class instance type. In React, this is used to allow the &lt;code&gt;ref&lt;/code&gt; attribute of type &lt;code&gt;Ref&amp;lt;T&amp;gt;&lt;/code&gt;. Generally speaking, all of the properties on these interfaces should be optional, unless you intend that users of your JSX framework need to provide some attribute on every tag.</source>
          <target state="translated">另外， &lt;code&gt;JSX.IntrinsicAttributes&lt;/code&gt; 接口可用于指定JSX框架使用的额外属性，这些属性通常不被组件的props或参数使用-例如React中的 &lt;code&gt;key&lt;/code&gt; 。进一步专门化，通用 &lt;code&gt;JSX.IntrinsicClassAttributes&amp;lt;T&amp;gt;&lt;/code&gt; 类型也可用于仅为类组件（而非功能组件）指定相同类型的额外属性。在这种类型中，泛型参数对应于类实例类型。在React中，这用于允许 &lt;code&gt;Ref&amp;lt;T&amp;gt;&lt;/code&gt; 类型的 &lt;code&gt;ref&lt;/code&gt; 属性。通常，除非您打算让JSX框架的用户需要在每个标签上提供一些属性，否则这些接口上的所有属性都应该是可选的。</target>
        </trans-unit>
        <trans-unit id="b91aefeee6c1829819327d9dfe82ea027b26c097" translate="yes" xml:space="preserve">
          <source>Additionally, to preserve compatibility with existing build workflows, &lt;code&gt;tsc&lt;/code&gt; will &lt;em&gt;not&lt;/em&gt; automatically build dependencies unless invoked with the &lt;code&gt;--build&lt;/code&gt; switch. Let&amp;rsquo;s learn more about &lt;code&gt;--build&lt;/code&gt;.</source>
          <target state="translated">此外，为了保持与现有的构建工作流的兼容性， &lt;code&gt;tsc&lt;/code&gt; 将&lt;em&gt;不会&lt;/em&gt;自动除非与调用编译依赖 &lt;code&gt;--build&lt;/code&gt; 开关。让我们更多地了解 &lt;code&gt;--build&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="aeb5aba76318fd8538ec6382a2c356952caebc47" translate="yes" xml:space="preserve">
          <source>Adjustments in module resolution logic</source>
          <target state="translated">模块解析逻辑中的调整</target>
        </trans-unit>
        <trans-unit id="051f9a673eec5b48c922324c96f3a02ca352b664" translate="yes" xml:space="preserve">
          <source>Advanced Combinations</source>
          <target state="translated">高级组合</target>
        </trans-unit>
        <trans-unit id="af1b06d1c8791683bf16e52630b903baefea447c" translate="yes" xml:space="preserve">
          <source>Advanced Techniques</source>
          <target state="translated">高级技术</target>
        </trans-unit>
        <trans-unit id="0d7049ed333121f6ad65eac902c5a2d1cec948e8" translate="yes" xml:space="preserve">
          <source>Advanced Topics</source>
          <target state="translated">高级主题</target>
        </trans-unit>
        <trans-unit id="ae95896c3a125d9a5e8ed95928ac9721dd8d3752" translate="yes" xml:space="preserve">
          <source>Advanced Types</source>
          <target state="translated">高级类型</target>
        </trans-unit>
        <trans-unit id="54113ef438de5a4b862decfc768acf29d440c666" translate="yes" xml:space="preserve">
          <source>After calling &lt;code&gt;bundle&lt;/code&gt; we use &lt;code&gt;source&lt;/code&gt; (our alias for vinyl-source-stream) to name our output bundle &lt;code&gt;bundle.js&lt;/code&gt;.</source>
          <target state="translated">调用 &lt;code&gt;bundle&lt;/code&gt; 之后,我们使用 &lt;code&gt;source&lt;/code&gt; （我们的乙烯基 &lt;code&gt;bundle.js&lt;/code&gt; -stream的别名）来命名我们的输出bundle bundle.js。</target>
        </trans-unit>
        <trans-unit id="90f00e5874f2361b655fbe3423460af4e2465d08" translate="yes" xml:space="preserve">
          <source>After that, you&amp;rsquo;ll be able to import lodash with no issues, and get accurate completions.</source>
          <target state="translated">之后，您将可以毫无问题地导入lodash，并获得准确的完成内容。</target>
        </trans-unit>
        <trans-unit id="06c3fc331ac388b23fddf0085ca5e76cb6b8d9ba" translate="yes" xml:space="preserve">
          <source>After you should see an &lt;code&gt;npm&lt;/code&gt; folder in your solution explorer</source>
          <target state="translated">之后，您应该在解决方案资源管理器中看到一个 &lt;code&gt;npm&lt;/code&gt; 文件夹</target>
        </trans-unit>
        <trans-unit id="b4510f26185d545e1f9aaebb5b614087f1eb1769" translate="yes" xml:space="preserve">
          <source>Again, being explicit, the following things create values:</source>
          <target state="translated">再次,明确的是,下面的东西创造价值。</target>
        </trans-unit>
        <trans-unit id="5eae1c48b28511e25caa33f05cb9d4dfab638b20" translate="yes" xml:space="preserve">
          <source>Again, the above code is equivalent to the following.</source>
          <target state="translated">还是那句话,上面的代码相当于下面这句话。</target>
        </trans-unit>
        <trans-unit id="1bf3fd22ac6a36d88878ca8d53a1d82c01a94dc2" translate="yes" xml:space="preserve">
          <source>Again, we&amp;rsquo;ve used &lt;code&gt;Bar&lt;/code&gt; as both a type and a value here. Note that we didn&amp;rsquo;t have to declare the &lt;code&gt;Bar&lt;/code&gt; value as being of the &lt;code&gt;Bar&lt;/code&gt; type &amp;ndash; they&amp;rsquo;re independent.</source>
          <target state="translated">再次，我们在这里使用 &lt;code&gt;Bar&lt;/code&gt; 作为类型和值。请注意，我们不必将 &lt;code&gt;Bar&lt;/code&gt; 值声明为 &lt;code&gt;Bar&lt;/code&gt; 类型-它们是独立的。</target>
        </trans-unit>
        <trans-unit id="6a8b49f23c0c2e66b347773e3a4bb453ff1fb91c" translate="yes" xml:space="preserve">
          <source>Aliases</source>
          <target state="translated">Aliases</target>
        </trans-unit>
        <trans-unit id="3cb27e3d6bbfd0f085fdbe02b42dec5e1744a340" translate="yes" xml:space="preserve">
          <source>Aliasing doesn&amp;rsquo;t actually create a new type - it creates a new &lt;em&gt;name&lt;/em&gt; to refer to that type. Aliasing a primitive is not terribly useful, though it can be used as a form of documentation.</source>
          <target state="translated">别名实际上并不会创建新类型-它会创建一个新&lt;em&gt;名称&lt;/em&gt;来引用该类型。虽然可以将原语用作文档的一种形式，但它并不是非常有用。</target>
        </trans-unit>
        <trans-unit id="9d6c399afd60c09e251a03e83d9bc9a1c384d822" translate="yes" xml:space="preserve">
          <source>All dependencies are managed by npm. Make sure all the declaration packages you depend on are marked appropriately in the &lt;code&gt;&quot;dependencies&quot;&lt;/code&gt; section in your &lt;code&gt;package.json&lt;/code&gt;. For example, imagine we authored a package that used Browserify and TypeScript.</source>
          <target state="translated">所有依赖项均由npm管理。确保在 &lt;code&gt;package.json&lt;/code&gt; 的 &lt;code&gt;&quot;dependencies&quot;&lt;/code&gt; 部分中正确标记了您依赖的所有声明包。例如，假设我们编写了一个使用Browserify和TypeScript的软件包。</target>
        </trans-unit>
        <trans-unit id="45d806df121ff13261ffaf919876e11a01813f29" translate="yes" xml:space="preserve">
          <source>All implementation files must be matched by an &lt;code&gt;include&lt;/code&gt; pattern or listed in the &lt;code&gt;files&lt;/code&gt; array. If this constraint is violated, &lt;code&gt;tsc&lt;/code&gt; will inform you which files weren&amp;rsquo;t specified</source>
          <target state="translated">所有实现文件都必须通过 &lt;code&gt;include&lt;/code&gt; 模式进行匹配或在 &lt;code&gt;files&lt;/code&gt; 数组中列出。如果违反了此约束，则 &lt;code&gt;tsc&lt;/code&gt; 将通知您未指定哪些文件</target>
        </trans-unit>
        <trans-unit id="1cd3b6e7826e2d43235c94e25c6703e5515d96cd" translate="yes" xml:space="preserve">
          <source>All imports from a shorthand module will have the &lt;code&gt;any&lt;/code&gt; type.</source>
          <target state="translated">速记模块中的所有导入将具有 &lt;code&gt;any&lt;/code&gt; 类型。</target>
        </trans-unit>
        <trans-unit id="1a0df7a5916e9a8c72882caaac651848e0eeba01" translate="yes" xml:space="preserve">
          <source>All imports from a shorthand module will have the any type.</source>
          <target state="translated">所有从速记模块中导入的东西都会有任意类型。</target>
        </trans-unit>
        <trans-unit id="fee6f3b1a8be543040dd1ce13fd64e1e346a330f" translate="yes" xml:space="preserve">
          <source>All imports to any module under &lt;code&gt;myLibrary&lt;/code&gt; would be considered to have the type &lt;code&gt;any&lt;/code&gt; by the compiler; thus, shutting down any checking on the shapes or types of these modules.</source>
          <target state="translated">编译器将所有导入到 &lt;code&gt;myLibrary&lt;/code&gt; 下任何模块的输入都视为具有 &lt;code&gt;any&lt;/code&gt; 类型；因此，请停止检查这些模块的形状或类型。</target>
        </trans-unit>
        <trans-unit id="f57b961e5b675a38b262426fe4a67078aecb1477" translate="yes" xml:space="preserve">
          <source>All of the following are red flags for module structuring. Double-check that you&amp;rsquo;re not trying to namespace your external modules if any of these apply to your files:</source>
          <target state="translated">以下所有都是用于模块结构的危险信号。仔细检查您是否不想为外部模块命名空间，如果以下任何一种适用于您的文件：</target>
        </trans-unit>
        <trans-unit id="5f48504d51c20fbd89324cd74339cdb9e81a6c89" translate="yes" xml:space="preserve">
          <source>All relative paths found in the configuration file will be resolved relative to the configuration file they originated in.</source>
          <target state="translated">在配置文件中找到的所有相对路径都将被解析为相对于它们起源于配置文件。</target>
        </trans-unit>
        <trans-unit id="315057eae22d62b0d6ed2f001a47c88ccf49ba08" translate="yes" xml:space="preserve">
          <source>All the strictness flags (including just &lt;code&gt;strict&lt;/code&gt;)</source>
          <target state="translated">所有严格性标志（包括 &lt;code&gt;strict&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="11378de3ed9317ae1cc9f1d37c886e6088970d68" translate="yes" xml:space="preserve">
          <source>AllValidators.ts</source>
          <target state="translated">AllValidators.ts</target>
        </trans-unit>
        <trans-unit id="a20b06e157c57d9a78b57caf9d2b542ef2e984fd" translate="yes" xml:space="preserve">
          <source>Allow JavaScript files to be compiled.</source>
          <target state="translated">允许对JavaScript文件进行编译。</target>
        </trans-unit>
        <trans-unit id="817e523690a2903bd65bba96f5e1a75cd990d338" translate="yes" xml:space="preserve">
          <source>Allow accessing UMD globals from modules.</source>
          <target state="translated">允许从模块中访问UMD globals。</target>
        </trans-unit>
        <trans-unit id="fe8c273574466d1f1e8e48a9866bca1049e958da" translate="yes" xml:space="preserve">
          <source>Allow captured &lt;code&gt;let&lt;/code&gt;/&lt;code&gt;const&lt;/code&gt; in loops</source>
          <target state="translated">允许在循环中捕获 &lt;code&gt;let&lt;/code&gt; / &lt;code&gt;const&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0313de72619ba05b9f37beba9bc65ea42f27f39d" translate="yes" xml:space="preserve">
          <source>Allow comments in tsconfig.json</source>
          <target state="translated">允许在tsconfig.json中添加注释</target>
        </trans-unit>
        <trans-unit id="243a0709c425e1dcc854b129a4e90d01a36f16eb" translate="yes" xml:space="preserve">
          <source>Allow default imports from modules with no default export. This does not affect code emit, just typechecking.</source>
          <target state="translated">允许从没有默认导出的模块中默认导入。这并不影响代码发射,只是类型检查。</target>
        </trans-unit>
        <trans-unit id="2fe77e2c3c1c895a9de9714c2ee0a698b6a26f2c" translate="yes" xml:space="preserve">
          <source>Allow duplicate identifiers across declarations</source>
          <target state="translated">允许跨声明的标识符重复</target>
        </trans-unit>
        <trans-unit id="c3d79af7df869c57746cb28085bd6d2457c5fb38" translate="yes" xml:space="preserve">
          <source>Allowed Values</source>
          <target state="translated">允许值</target>
        </trans-unit>
        <trans-unit id="13463866162e9452fc9466d99aed31c7a984ccdc" translate="yes" xml:space="preserve">
          <source>Along with setting &lt;code&gt;--strict&lt;/code&gt; on by default, &lt;code&gt;tsc --init&lt;/code&gt; has an enhanced output. Default &lt;code&gt;tsconfig.json&lt;/code&gt; files generated by &lt;code&gt;tsc --init&lt;/code&gt; now include a set of the common compiler options along with their descriptions commented out. Just un-comment the configuration you like to set to get the desired behavior; we hope the new output simplifies the setting up new projects and keeps configuration files readable as projects grow.</source>
          <target state="translated">与默认情况下设置 &lt;code&gt;--strict&lt;/code&gt; 一起， &lt;code&gt;tsc --init&lt;/code&gt; 具有增强的输出。现在，由 &lt;code&gt;tsc --init&lt;/code&gt; 生成的默认 &lt;code&gt;tsconfig.json&lt;/code&gt; 文件包括一组常用的编译器选项以及注释掉的描述。只需取消注释您想要设置的配置即可获得所需的行为。我们希望新的输出可以简化新项目的设置，并随着项目的增长保持配置文件的可读性。</target>
        </trans-unit>
        <trans-unit id="000392e9a54edfab5429407c52d48703930eb447" translate="yes" xml:space="preserve">
          <source>Along with traditional OO hierarchies, another popular way of building up classes from reusable components is to build them by combining simpler partial classes. You may be familiar with the idea of mixins or traits for languages like Scala, and the pattern has also reached some popularity in the JavaScript community.</source>
          <target state="translated">除了传统的OO层次结构之外,另一种从可重用组件中构建类的流行方式是通过组合更简单的部分类来构建类。你可能对Scala等语言的混合类或traits的想法很熟悉,这种模式在JavaScript社区中也达到了一定的流行程度。</target>
        </trans-unit>
        <trans-unit id="d76c0268868384341c5ebe547b3dfcde453c7e8e" translate="yes" xml:space="preserve">
          <source>Also functions that are only called within their own bodies are considered unused.</source>
          <target state="translated">另外,只在自己体内调用的功能也被视为未使用。</target>
        </trans-unit>
        <trans-unit id="540904303a257559b0aeb7e9b92f1cd1b53941db" translate="yes" xml:space="preserve">
          <source>Also important to note is that &lt;code&gt;bigint&lt;/code&gt;s produce a new string when using the &lt;code&gt;typeof&lt;/code&gt; operator: the string &lt;code&gt;&quot;bigint&quot;&lt;/code&gt;. Thus, TypeScript correctly narrows using &lt;code&gt;typeof&lt;/code&gt; as you&amp;rsquo;d expect.</source>
          <target state="translated">还要注意的重要一点是， &lt;code&gt;bigint&lt;/code&gt; 在使用 &lt;code&gt;typeof&lt;/code&gt; 运算符时会产生一个新字符串：字符串 &lt;code&gt;&quot;bigint&quot;&lt;/code&gt; 。因此，TypeScript可以像您期望的那样使用 &lt;code&gt;typeof&lt;/code&gt; 正确缩小范围。</target>
        </trans-unit>
        <trans-unit id="fdd80e664a9b3ce76fb4d4f379a35bae6ecbe4f1" translate="yes" xml:space="preserve">
          <source>Also note that if your main declaration file is named &lt;code&gt;index.d.ts&lt;/code&gt; and lives at the root of the package (next to &lt;code&gt;index.js&lt;/code&gt;) you do not need to mark the &lt;code&gt;&quot;types&quot;&lt;/code&gt; property, though it is advisable to do so.</source>
          <target state="translated">还要注意，如果您的主声明文件名为 &lt;code&gt;index.d.ts&lt;/code&gt; ,并且位于包的根目录（位于 &lt;code&gt;index.js&lt;/code&gt; 的旁边），则尽管需要这样做，但无需标记 &lt;code&gt;&quot;types&quot;&lt;/code&gt; 属性。</target>
        </trans-unit>
        <trans-unit id="1b4972f01952c5c6e56d36346995929543d00951" translate="yes" xml:space="preserve">
          <source>Also note that when passing &lt;code&gt;--skipDefaultLibCheck&lt;/code&gt;, the compiler will only skip checking files with &lt;code&gt;/// &amp;lt;reference no-default-lib=&quot;true&quot;/&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">还要注意，当传递 &lt;code&gt;--skipDefaultLibCheck&lt;/code&gt; 时，编译器将只跳过 &lt;code&gt;/// &amp;lt;reference no-default-lib=&quot;true&quot;/&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6107d072614a65187bd05ede831a6df1fe3accb4" translate="yes" xml:space="preserve">
          <source>Also of note, the use of &lt;code&gt;public&lt;/code&gt; on arguments to the constructor is a shorthand that allows us to automatically create properties with that name.</source>
          <target state="translated">还要注意的是，在构造函数的参数上使用 &lt;code&gt;public&lt;/code&gt; 是一种快捷方式，它使我们能够自动使用该名称创建属性。</target>
        </trans-unit>
        <trans-unit id="cffaed40200024bd111a6ac8089de97648f831c1" translate="yes" xml:space="preserve">
          <source>Also see our wiki page on &lt;a href=&quot;https://github.com/Microsoft/TypeScript/wiki/Dev-Mode-in-Visual-Studio#using-a-custom-language-service-file&quot;&gt;using a custom language service file&lt;/a&gt;.</source>
          <target state="translated">另请参阅有关&lt;a href=&quot;https://github.com/Microsoft/TypeScript/wiki/Dev-Mode-in-Visual-Studio#using-a-custom-language-service-file&quot;&gt;使用自定义语言服务文件的&lt;/a&gt; Wiki页面。</target>
        </trans-unit>
        <trans-unit id="776519898394bb463eff6e30826aacacc1c3da0d" translate="yes" xml:space="preserve">
          <source>Also, a nightly NuGet package to match the &lt;a href=&quot;http://blogs.msdn.com/b/typescript/archive/2015/07/27/introducing-typescript-nightlies.aspx&quot;&gt;nightly npm package&lt;/a&gt; is available on &lt;a href=&quot;https://myget.org&quot;&gt;myget&lt;/a&gt;:</source>
          <target state="translated">另外，可以在&lt;a href=&quot;https://myget.org&quot;&gt;myget&lt;/a&gt;上获得与&lt;a href=&quot;http://blogs.msdn.com/b/typescript/archive/2015/07/27/introducing-typescript-nightlies.aspx&quot;&gt;夜间npm软件包&lt;/a&gt;匹配的夜间NuGet软件包：</target>
        </trans-unit>
        <trans-unit id="92083d2d24448d6d4118e25e1f3cea32d46ea66c" translate="yes" xml:space="preserve">
          <source>Alternatively, we can use per-file compilation (the default) to emit one JavaScript file for each input file. If multiple JS files get produced, we&amp;rsquo;ll need to use &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; tags on our webpage to load each emitted file in the appropriate order, for example:</source>
          <target state="translated">另外，我们可以使用按文件编译（默认）为每个输入文件发出一个JavaScript文件。如果产生了多个JS文件，则需要在网页上使用 &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; 标记以适当的顺序加载每个发出的文件，例如：</target>
        </trans-unit>
        <trans-unit id="d4887b96a506ca1d0dee1e635003357f0a6d33ea" translate="yes" xml:space="preserve">
          <source>Alternatively, you can just say &lt;code&gt;options&lt;/code&gt; has the type &lt;code&gt;any&lt;/code&gt; which is the easiest thing to do, but which will benefit you the least.</source>
          <target state="translated">另外，您可以说 &lt;code&gt;options&lt;/code&gt; 的类型为 &lt;code&gt;any&lt;/code&gt; ，这是最容易做到的，但对您的好处却最小。</target>
        </trans-unit>
        <trans-unit id="43606c68a4c7cf72a0b682885c31d5f52ead2334" translate="yes" xml:space="preserve">
          <source>Alternatives:</source>
          <target state="translated">Alternatives:</target>
        </trans-unit>
        <trans-unit id="8b0c73776c390d3a5733d04f89fdf034e34ec53e" translate="yes" xml:space="preserve">
          <source>Although JavaScript modules do not support merging, you can patch existing objects by importing and then updating them. Let&amp;rsquo;s look at a toy Observable example:</source>
          <target state="translated">尽管JavaScript模块不支持合并，但是您可以通过导入然后更新它们来修补现有对象。让我们看一个玩具可观察的例子：</target>
        </trans-unit>
        <trans-unit id="dee099122cb78c5739b4f82dcc4924480f635a80" translate="yes" xml:space="preserve">
          <source>Ambient Classes and Functions Can Merge</source>
          <target state="translated">环境类和函数可以合并</target>
        </trans-unit>
        <trans-unit id="6b6f848cded8d022fa12717b22d3680a848ad354" translate="yes" xml:space="preserve">
          <source>Ambient Modules</source>
          <target state="translated">环境模块</target>
        </trans-unit>
        <trans-unit id="4a2667f9b3defd3ff5b3a3b96ac30b540f477156" translate="yes" xml:space="preserve">
          <source>Ambient Namespaces</source>
          <target state="translated">环境名称空间</target>
        </trans-unit>
        <trans-unit id="072993bc8b201bfe9df293be81dcb3aa09bada66" translate="yes" xml:space="preserve">
          <source>Ambient enums</source>
          <target state="translated">周围环境名词表</target>
        </trans-unit>
        <trans-unit id="13d6b6f06f272969887a807bdfd8080d800b8ed3" translate="yes" xml:space="preserve">
          <source>Ambient enums are used to describe the shape of already existing enum types.</source>
          <target state="translated">Ambient enums是用来描述已经存在的enum类型的形状。</target>
        </trans-unit>
        <trans-unit id="66df472a2808c10e6e2267da8ee23d33589aa345" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;enum&lt;/code&gt; declaration</source>
          <target state="translated">一个 &lt;code&gt;enum&lt;/code&gt; 声明</target>
        </trans-unit>
        <trans-unit id="96131132b1fece4018da08fbe5ae8cdc0f0bbe7c" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;import&lt;/code&gt; declaration which refers to a type</source>
          <target state="translated">引用类型的 &lt;code&gt;import&lt;/code&gt; 声明</target>
        </trans-unit>
        <trans-unit id="9e546120c9b08c182111a543340edaa52f8faa73" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;import&lt;/code&gt; declaration which refers to a value</source>
          <target state="translated">引用值的 &lt;code&gt;import&lt;/code&gt; 声明</target>
        </trans-unit>
        <trans-unit id="9c85d60a22bfc72f8be52c9d3473a14b494ef936" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;Accessor Decorator&lt;/em&gt; is declared just before an accessor declaration. The accessor decorator is applied to the &lt;em&gt;Property Descriptor&lt;/em&gt; for the accessor and can be used to observe, modify, or replace an accessor&amp;rsquo;s definitions. An accessor decorator cannot be used in a declaration file, or in any other ambient context (such as in a &lt;code&gt;declare&lt;/code&gt; class).</source>
          <target state="translated">访问&lt;em&gt;器装饰器&lt;/em&gt;在访问器声明之前被声明。访问器修饰符应用于访问器的&lt;em&gt;属性描述符&lt;/em&gt;，可用于观察，修改或替换访问器的定义。访问器修饰符不能在声明文件或任何其他环境上下文（例如， &lt;code&gt;declare&lt;/code&gt; 类）中使用。</target>
        </trans-unit>
        <trans-unit id="637fccf99e1ca3360a8e160638d580b112623960" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;async function&lt;/em&gt; is a function or method that has been prefixed with the &lt;code&gt;async&lt;/code&gt; modifier. This modifier informs the compiler that function body transposition is required, and that the keyword &lt;code&gt;await&lt;/code&gt; should be treated as a unary expression instead of an identifier. An &lt;em&gt;Async Function&lt;/em&gt; must provide a return type annotation that points to a compatible &lt;code&gt;Promise&lt;/code&gt; type. Return type inference can only be used if there is a globally defined, compatible &lt;code&gt;Promise&lt;/code&gt; type.</source>
          <target state="translated">一个&lt;em&gt;异步函数&lt;/em&gt;是已前缀的函数或方法 &lt;code&gt;async&lt;/code&gt; 改性剂。该修饰符通知编译器需要进行函数体转换，并且关键字 &lt;code&gt;await&lt;/code&gt; 应该被视为一元表达式而不是标识符。一个&lt;em&gt;异步函数&lt;/em&gt;必须提供一个返回类型注解点到兼容的 &lt;code&gt;Promise&lt;/code&gt; 类型。仅当存在全局定义的兼容 &lt;code&gt;Promise&lt;/code&gt; 类型时，才可以使用返回类型推断。</target>
        </trans-unit>
        <trans-unit id="e0c5ee8216b1102dc214045b20531cb28dca3422" translate="yes" xml:space="preserve">
          <source>An Example Project</source>
          <target state="translated">项目实例</target>
        </trans-unit>
        <trans-unit id="08a8a8bcfbc30a10a37d2f8c0745492817b04bd8" translate="yes" xml:space="preserve">
          <source>An IIFE returning a function, class or empty object literal, is also recognized as a namespace:</source>
          <target state="translated">返回函数、类或空对象的IIFE也被认为是一个命名空间。</target>
        </trans-unit>
        <trans-unit id="4b482032e9b848d1769fffddba6728c3f513e97d" translate="yes" xml:space="preserve">
          <source>An Object whose own property names are property names that are excluded from the &amp;lsquo;with&amp;rsquo; environment bindings of the associated objects.</source>
          <target state="translated">一个对象，其自身的属性名称是从关联对象的&amp;ldquo; with&amp;rdquo;环境绑定中排除的属性名称。</target>
        </trans-unit>
        <trans-unit id="9346f4c4433fdb2ea0b41faaa1f055ba9e22c515" translate="yes" xml:space="preserve">
          <source>An abstract class can declare abstract properties and/or accessors. Any sub class will need to declare the abstract properties or be marked as abstract. Abstract properties cannot have an initializer. Abstract accessors cannot have bodies.</source>
          <target state="translated">一个抽象类可以声明抽象属性和/或访问器。任何子类都需要声明抽象属性或被标记为抽象。抽象属性不能有初始化器。抽象访问器不能有body。</target>
        </trans-unit>
        <trans-unit id="c01bf8fd95c1254c73cd6a7e1bf75eab586904fa" translate="yes" xml:space="preserve">
          <source>An entity accessed through an ES2015 namespace import is considered read-only (e.g. &lt;code&gt;foo.x&lt;/code&gt; is read-only when &lt;code&gt;foo&lt;/code&gt; is declared as &lt;code&gt;import * as foo from &quot;foo&quot;&lt;/code&gt;).</source>
          <target state="translated">通过ES2015名称空间导入访问的实体被视为只读（例如，当 &lt;code&gt;foo&lt;/code&gt; 被声明为 &lt;code&gt;import * as foo from &quot;foo&quot;&lt;/code&gt; 时， &lt;code&gt;foo.x&lt;/code&gt; 是只读的）。</target>
        </trans-unit>
        <trans-unit id="42ee76cce09b6dda0af497e582271e9daeb1fa9e" translate="yes" xml:space="preserve">
          <source>An entity declared in an &lt;code&gt;import&lt;/code&gt; statement is considered read-only.</source>
          <target state="translated">在 &lt;code&gt;import&lt;/code&gt; 语句中声明的实体被视为只读。</target>
        </trans-unit>
        <trans-unit id="010036a4ed3e6887f0a662f6e45e32f749a00f87" translate="yes" xml:space="preserve">
          <source>An enum declaration (&lt;code&gt;enum E { A, B, C }&lt;/code&gt;)</source>
          <target state="translated">枚举声明（ &lt;code&gt;enum E { A, B, C }&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="3a85dd24cd070fb5512fd0ef92b9518fceb29e8c" translate="yes" xml:space="preserve">
          <source>An export default declaration specifies an expression that becomes the default export of a module:</source>
          <target state="translated">一个导出默认声明指定一个表达式,它将成为模块的默认导出。</target>
        </trans-unit>
        <trans-unit id="1dbd631e886efac25134c1822d5fc8c0a3f82701" translate="yes" xml:space="preserve">
          <source>An import to a module with no declaration file will still be flagged as an error under &lt;code&gt;--noImplicitAny&lt;/code&gt;.</source>
          <target state="translated">在 &lt;code&gt;--noImplicitAny&lt;/code&gt; 下，导入到没有声明文件的模块仍将标记为错误。</target>
        </trans-unit>
        <trans-unit id="4089846541ea3f66ca0b3aa8324eb27446bfa87c" translate="yes" xml:space="preserve">
          <source>An important rule is that &lt;code&gt;export&lt;/code&gt; and &lt;code&gt;import&lt;/code&gt; declarations export or import &lt;em&gt;all meanings&lt;/em&gt; of their targets.</source>
          <target state="translated">重要规则是， &lt;code&gt;export&lt;/code&gt; 和 &lt;code&gt;import&lt;/code&gt; 声明导出或导入目标对象的&lt;em&gt;所有含义&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="9829bd2aaefcc0a918548bdfb97be8f7716b574b" translate="yes" xml:space="preserve">
          <source>An index type &lt;code&gt;keyof T&lt;/code&gt; for some type &lt;code&gt;T&lt;/code&gt; is a subtype of &lt;code&gt;string | number | symbol&lt;/code&gt;.</source>
          <target state="translated">对于某些类型 &lt;code&gt;T&lt;/code&gt; ,索引类型 &lt;code&gt;keyof T&lt;/code&gt; 的索引类型是 &lt;code&gt;string | number | symbol&lt;/code&gt; 的子类型。编号 符号。</target>
        </trans-unit>
        <trans-unit id="bd3dee51effab23215f94b19b5e6ce849dbbb11b" translate="yes" xml:space="preserve">
          <source>An interface can extend multiple interfaces, creating a combination of all of the interfaces.</source>
          <target state="translated">一个接口可以扩展多个接口,形成所有接口的组合。</target>
        </trans-unit>
        <trans-unit id="8dfb2cf00eea3daab08c8ac76409915d529976bc" translate="yes" xml:space="preserve">
          <source>An interface declaration (&lt;code&gt;interface I { x: number[]; }&lt;/code&gt;)</source>
          <target state="translated">接口声明（ &lt;code&gt;interface I { x: number[]; }&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="051272f0126c6f4c635d623e56a437da25ba082a" translate="yes" xml:space="preserve">
          <source>An intersection type combines multiple types into one. This allows you to add together existing types to get a single type that has all the features you need. For example, &lt;code&gt;Person &amp;amp; Serializable &amp;amp; Loggable&lt;/code&gt; is a &lt;code&gt;Person&lt;/code&gt;&lt;em&gt;and&lt;/em&gt;&lt;code&gt;Serializable&lt;/code&gt;&lt;em&gt;and&lt;/em&gt;&lt;code&gt;Loggable&lt;/code&gt;. That means an object of this type will have all members of all three types.</source>
          <target state="translated">相交类型将多种类型组合为一种。这使您可以将现有类型加在一起，以获得具有所需所有功能的单个类型。例如， &lt;code&gt;Person &amp;amp; Serializable &amp;amp; Loggable&lt;/code&gt; 是 &lt;code&gt;Person&lt;/code&gt; &lt;em&gt;和&lt;/em&gt; &lt;code&gt;Serializable&lt;/code&gt; &lt;em&gt;and &lt;/em&gt; &lt;code&gt;Loggable&lt;/code&gt; 。这意味着此类型的对象将具有所有三种类型的所有成员。</target>
        </trans-unit>
        <trans-unit id="99cc1cc22b07e8cafd4c0a4ab5a6f60816a8100b" translate="yes" xml:space="preserve">
          <source>An object is deemed iterable if it has an implementation for the &lt;a href=&quot;symbols#symboliterator&quot;&gt;&lt;code&gt;Symbol.iterator&lt;/code&gt;&lt;/a&gt; property. Some built-in types like &lt;code&gt;Array&lt;/code&gt;, &lt;code&gt;Map&lt;/code&gt;, &lt;code&gt;Set&lt;/code&gt;, &lt;code&gt;String&lt;/code&gt;, &lt;code&gt;Int32Array&lt;/code&gt;, &lt;code&gt;Uint32Array&lt;/code&gt;, etc. have their &lt;code&gt;Symbol.iterator&lt;/code&gt; property already implemented. &lt;code&gt;Symbol.iterator&lt;/code&gt; function on an object is responsible for returning the list of values to iterate on.</source>
          <target state="translated">如果对象具有&lt;a href=&quot;symbols#symboliterator&quot;&gt; &lt;code&gt;Symbol.iterator&lt;/code&gt; &lt;/a&gt;属性的实现，则认为该对象是可迭代的。一些内置类型，例如 &lt;code&gt;Array&lt;/code&gt; ， &lt;code&gt;Map&lt;/code&gt; ， &lt;code&gt;Set&lt;/code&gt; ， &lt;code&gt;String&lt;/code&gt; ， &lt;code&gt;Int32Array&lt;/code&gt; ， &lt;code&gt;Uint32Array&lt;/code&gt; 等，已经实现了 &lt;code&gt;Symbol.iterator&lt;/code&gt; 属性。对象上的 &lt;code&gt;Symbol.iterator&lt;/code&gt; 函数负责返回要迭代的值列表。</target>
        </trans-unit>
        <trans-unit id="8f02b61e8ec8b6f2bec26f2bedf23c11ecf77a29" translate="yes" xml:space="preserve">
          <source>An object literal type is now assignable to a type with an index signature if all known properties in the object literal are assignable to that index signature. This makes it possible to pass a variable that was initialized with an object literal as parameter to a function that expects a map or dictionary:</source>
          <target state="translated">如果对象字面符号中的所有已知属性都可以被分配给一个具有索引签名的类型,那么现在一个对象字面符号类型可以被分配给一个具有索引签名的类型。这使得我们可以将一个用对象字面符号初始化的变量作为参数传递给一个期望映射或字典的函数。</target>
        </trans-unit>
        <trans-unit id="8cb8cf874c7b3539ef5e517ffab6e8f6b9569d43" translate="yes" xml:space="preserve">
          <source>An object that supports async iteration is said to be &amp;ldquo;iterable&amp;rdquo; if it has a &lt;code&gt;Symbol.asyncIterator&lt;/code&gt; method that returns an &lt;code&gt;AsyncIterator&lt;/code&gt; object.</source>
          <target state="translated">如果支持异步迭代的对象具有返回 &lt;code&gt;AsyncIterator&lt;/code&gt; 对象的 &lt;code&gt;Symbol.asyncIterator&lt;/code&gt; 方法，则该对象被称为&amp;ldquo;可迭代&amp;rdquo; 。</target>
        </trans-unit>
        <trans-unit id="a8447e71f06bf05be69e3922802bfe818075f229" translate="yes" xml:space="preserve">
          <source>An operand is considered nullable if the type of the operand is &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt; or a union type that includes &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt;. Note that the union type case only only occurs in &lt;code&gt;--strictNullChecks&lt;/code&gt; mode because &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt; disappear from unions in classic type checking mode.</source>
          <target state="translated">如果操作数的类型为 &lt;code&gt;null&lt;/code&gt; 或 &lt;code&gt;undefined&lt;/code&gt; 或包含 &lt;code&gt;null&lt;/code&gt; 或 &lt;code&gt;undefined&lt;/code&gt; 的联合类型，则该操作数被视为可为空。请注意，联合类型仅在 &lt;code&gt;--strictNullChecks&lt;/code&gt; 模式下发生，因为 &lt;code&gt;null&lt;/code&gt; 和 &lt;code&gt;undefined&lt;/code&gt; 在经典类型检查模式下会从联合中消失。</target>
        </trans-unit>
        <trans-unit id="e1d5ca7f2497f214678abf18ecf2b51c0278100b" translate="yes" xml:space="preserve">
          <source>An unspecified type argument in JSDoc defaults to any:</source>
          <target state="translated">JSDoc中的非指定类型参数默认为任意。</target>
        </trans-unit>
        <trans-unit id="9add44f9c257c0dbb7eebf6fe551aa600ac3c7bf" translate="yes" xml:space="preserve">
          <source>And help in Japanese:</source>
          <target state="translated">并在日语方面提供帮助。</target>
        </trans-unit>
        <trans-unit id="44c2dac2f30e99536de68e97cb2b18f2d5db2533" translate="yes" xml:space="preserve">
          <source>And just like type predicate signatures, these assertion signatures are incredibly expressive. We can express some fairly sophisticated ideas with these.</source>
          <target state="translated">就像类型谓词签名一样,这些断言签名也是非常有表现力的。我们可以用这些签名来表达一些相当复杂的想法。</target>
        </trans-unit>
        <trans-unit id="e5f7abc94bd4652b1940c01f38e4cdba6a7de10d" translate="yes" xml:space="preserve">
          <source>And results in</source>
          <target state="translated">而结果是</target>
        </trans-unit>
        <trans-unit id="524218ceeaedc01c8daaf35729b043a8754e652f" translate="yes" xml:space="preserve">
          <source>And the other is the &lt;code&gt;as&lt;/code&gt;-syntax:</source>
          <target state="translated">另一个是 &lt;code&gt;as&lt;/code&gt; -syntax：</target>
        </trans-unit>
        <trans-unit id="7683ba2ccf1b61a19dd6dd9bbbf3a532801e3252" translate="yes" xml:space="preserve">
          <source>And to use it:</source>
          <target state="translated">而要使用它。</target>
        </trans-unit>
        <trans-unit id="a379f1e77206b5fa5615fc791f830626638ff5b9" translate="yes" xml:space="preserve">
          <source>And usage would be:</source>
          <target state="translated">和用途将是:</target>
        </trans-unit>
        <trans-unit id="955c6169edfe74a318e323004916b98e713d7add" translate="yes" xml:space="preserve">
          <source>And with parameters to a function:</source>
          <target state="translated">并与参数到一个函数。</target>
        </trans-unit>
        <trans-unit id="cce043e3a6fddbda09013e27b4641adddde08990" translate="yes" xml:space="preserve">
          <source>And, for pre-ES2015 code, it can be used to simulate static methods:</source>
          <target state="translated">而且,对于ES2015之前的代码,可以用它来模拟静态方法。</target>
        </trans-unit>
        <trans-unit id="6e0355996ea2c36fc48cd0c3c40221f8808eb765" translate="yes" xml:space="preserve">
          <source>Another ECMAScript 2015 feature that TypeScript has is destructuring. For a complete reference, see &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment&quot;&gt;the article on the Mozilla Developer Network&lt;/a&gt;. In this section, we&amp;rsquo;ll give a short overview.</source>
          <target state="translated">TypeScript具有的另一个ECMAScript 2015功能正在分解。有关完整的参考，请参见&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment&quot;&gt;Mozilla开发人员网络上的文章&lt;/a&gt;。在本节中，我们将简要概述。</target>
        </trans-unit>
        <trans-unit id="f1a7f2f6380d7122bad959764252b9e24c79240a" translate="yes" xml:space="preserve">
          <source>Another distinction is that &lt;code&gt;for..in&lt;/code&gt; operates on any object; it serves as a way to inspect properties on this object. &lt;code&gt;for..of&lt;/code&gt; on the other hand, is mainly interested in values of iterable objects. Built-in objects like &lt;code&gt;Map&lt;/code&gt; and &lt;code&gt;Set&lt;/code&gt; implement &lt;code&gt;Symbol.iterator&lt;/code&gt; property allowing access to stored values.</source>
          <target state="translated">另一个区别是 &lt;code&gt;for..in&lt;/code&gt; 可对任何对象进行操作；它用作检查此对象属性的一种方法。另一方面， &lt;code&gt;for..of&lt;/code&gt; 主要关注可迭代对象的值。诸如 &lt;code&gt;Map&lt;/code&gt; 和 &lt;code&gt;Set&lt;/code&gt; 之类的内置对象实现了 &lt;code&gt;Symbol.iterator&lt;/code&gt; 属性，从而可以访问存储的值。</target>
        </trans-unit>
        <trans-unit id="80278db3392e36b25471320c2c5c53b5cfd9afc0" translate="yes" xml:space="preserve">
          <source>Another example would be the &lt;code&gt;TypeName&lt;/code&gt; type alias, which uses nested conditional types:</source>
          <target state="translated">另一个示例是 &lt;code&gt;TypeName&lt;/code&gt; 类型别名，该别名使用嵌套的条件类型：</target>
        </trans-unit>
        <trans-unit id="59923c5b5918e19407ea7e824fe9454f6b96dd6d" translate="yes" xml:space="preserve">
          <source>Another fundamental part of creating programs in JavaScript for webpages and servers alike is working with textual data. As in other languages, we use the type &lt;code&gt;string&lt;/code&gt; to refer to these textual datatypes. Just like JavaScript, TypeScript also uses double quotes (&lt;code&gt;&quot;&lt;/code&gt;) or single quotes (&lt;code&gt;'&lt;/code&gt;) to surround string data.</source>
          <target state="translated">使用JavaScript为网页和服务器创建程序的另一个基本部分是使用文本数据。与其他语言一样，我们使用类型 &lt;code&gt;string&lt;/code&gt; 来引用这些文本数据类型。与JavaScript一样，TypeScript也使用双引号（ &lt;code&gt;&quot;&lt;/code&gt; ）或单引号（ &lt;code&gt;'&lt;/code&gt; ）包围字符串数据。</target>
        </trans-unit>
        <trans-unit id="e22e08f461a07d2394e4b0372b16fbe2608c33ae" translate="yes" xml:space="preserve">
          <source>Another good practice is to have a &amp;ldquo;solution&amp;rdquo; &lt;code&gt;tsconfig.json&lt;/code&gt; file that simply has &lt;code&gt;references&lt;/code&gt; to all of your leaf-node projects and sets &lt;code&gt;files&lt;/code&gt; to an empty array (otherwise the solution file will cause double compilation of files). Note that starting with 3.0, it is no longer an error to have an empty &lt;code&gt;files&lt;/code&gt; array if you have at least one &lt;code&gt;reference&lt;/code&gt; in a &lt;code&gt;tsconfig.json&lt;/code&gt; file.</source>
          <target state="translated">另一个好的做法是拥有一个&amp;ldquo;解决方案&amp;rdquo; &lt;code&gt;tsconfig.json&lt;/code&gt; 文件，该文件仅 &lt;code&gt;references&lt;/code&gt; 了所有叶节点项目，并将 &lt;code&gt;files&lt;/code&gt; 设置为空数组（否则解决方案文件将导致文件的双重编译）。请注意，从3.0开始，如果您在 &lt;code&gt;tsconfig.json&lt;/code&gt; 文件中至少有一个 &lt;code&gt;reference&lt;/code&gt; ，则拥有一个空 &lt;code&gt;files&lt;/code&gt; 数组不再是一个错误。</target>
        </trans-unit>
        <trans-unit id="bd3ed357192d33940721ba58d1e4e4f234af944b" translate="yes" xml:space="preserve">
          <source>Another property of block-scoped variables is that they can&amp;rsquo;t be read or written to before they&amp;rsquo;re actually declared. While these variables are &amp;ldquo;present&amp;rdquo; throughout their scope, all points up until their declaration are part of their &lt;em&gt;temporal dead zone&lt;/em&gt;. This is just a sophisticated way of saying you can&amp;rsquo;t access them before the &lt;code&gt;let&lt;/code&gt; statement, and luckily TypeScript will let you know that.</source>
          <target state="translated">块范围变量的另一个特性是，在实际声明它们之前，不能对其进行读写。尽管这些变量在其整个范围内都&amp;ldquo;存在&amp;rdquo;，但直到声明它们之前的所有点都是其&lt;em&gt;时间盲区的&lt;/em&gt;一部分。这只是一种复杂的说法，就是说您不能在 &lt;code&gt;let&lt;/code&gt; 语句之前访问它们，幸运的是TypeScript会让您知道。</target>
        </trans-unit>
        <trans-unit id="6536ca406ade59e49db35f06a2bc4ae98274b219" translate="yes" xml:space="preserve">
          <source>Another simple way is to use class expressions:</source>
          <target state="translated">另一个简单的方法是使用类表达式。</target>
        </trans-unit>
        <trans-unit id="eb0433a2f2345ca65e0ca8af5f86b17a73375f6b" translate="yes" xml:space="preserve">
          <source>Another thing to keep in mind is that &lt;code&gt;const&lt;/code&gt; contexts don&amp;rsquo;t immediately convert an expression to be fully immutable.</source>
          <target state="translated">要记住的另一件事是， &lt;code&gt;const&lt;/code&gt; 上下文不会立即将表达式转换为完全不可变的。</target>
        </trans-unit>
        <trans-unit id="a0272d130e56f355222a749eeba841dae92661ec" translate="yes" xml:space="preserve">
          <source>Another way that you can simplify working with namespaces is to use &lt;code&gt;import q = x.y.z&lt;/code&gt; to create shorter names for commonly-used objects. Not to be confused with the &lt;code&gt;import x = require(&quot;name&quot;)&lt;/code&gt; syntax used to load modules, this syntax simply creates an alias for the specified symbol. You can use these sorts of imports (commonly referred to as aliases) for any kind of identifier, including objects created from module imports.</source>
          <target state="translated">您可以简化使用名称空间的另一种方法是使用 &lt;code&gt;import q = x.y.z&lt;/code&gt; 为常用对象创建较短的名称。不要与用于加载模块的 &lt;code&gt;import x = require(&quot;name&quot;)&lt;/code&gt; 语法混淆，该语法只是为指定符号创建别名。您可以将这些类型的导入（通常称为别名）用于任何种类的标识符，包括从模块导入创建的对象。</target>
        </trans-unit>
        <trans-unit id="ad06f386aa38881eb01e3e498f2167a151b8b1e6" translate="yes" xml:space="preserve">
          <source>Another way to describe the example is that the type &lt;code&gt;(x: T) =&amp;gt; void&lt;/code&gt; is &lt;em&gt;bivariant&lt;/em&gt; (i.e. covariant &lt;em&gt;or&lt;/em&gt; contravariant) for &lt;code&gt;T&lt;/code&gt; in default type checking mode, but &lt;em&gt;contravariant&lt;/em&gt; for &lt;code&gt;T&lt;/code&gt; in strict function types mode.</source>
          <target state="translated">来描述该示例的另一种方法是，式 &lt;code&gt;(x: T) =&amp;gt; void&lt;/code&gt; 是&lt;em&gt;双变&lt;/em&gt;（即协变&lt;em&gt;或&lt;/em&gt;用于逆变） &lt;code&gt;T&lt;/code&gt; 在默认类型检查模式，但是&lt;em&gt;逆变&lt;/em&gt;为 &lt;code&gt;T&lt;/code&gt; 严格函数类型模式。</target>
        </trans-unit>
        <trans-unit id="322444d3bb52c341f429ca0454f292dc242f315b" translate="yes" xml:space="preserve">
          <source>Any</source>
          <target state="translated">Any</target>
        </trans-unit>
        <trans-unit id="5d5c745343bd6b12cb5e63f20e6477505f1a8f8f" translate="yes" xml:space="preserve">
          <source>Any declaration (such as a variable, function, class, type alias, or interface) can be exported by adding the &lt;code&gt;export&lt;/code&gt; keyword.</source>
          <target state="translated">可以通过添加 &lt;code&gt;export&lt;/code&gt; 关键字来导出任何声明（例如变量，函数，类，类型别名或接口）。</target>
        </trans-unit>
        <trans-unit id="874ba9764ea4968c93711ccd48458d3687016ab7" translate="yes" xml:space="preserve">
          <source>Any files that are referenced by files included via the &lt;code&gt;&quot;files&quot;&lt;/code&gt; or &lt;code&gt;&quot;include&quot;&lt;/code&gt; properties are also included. Similarly, if a file &lt;code&gt;B.ts&lt;/code&gt; is referenced by another file &lt;code&gt;A.ts&lt;/code&gt;, then &lt;code&gt;B.ts&lt;/code&gt; cannot be excluded unless the referencing file &lt;code&gt;A.ts&lt;/code&gt; is also specified in the &lt;code&gt;&quot;exclude&quot;&lt;/code&gt; list.</source>
          <target state="translated">还包括通过 &lt;code&gt;&quot;files&quot;&lt;/code&gt; 或 &lt;code&gt;&quot;include&quot;&lt;/code&gt; 属性包含的文件引用的所有文件。同样，如果一个文件 &lt;code&gt;B.ts&lt;/code&gt; 被另一个文件引用 &lt;code&gt;A.ts&lt;/code&gt; ，然后 &lt;code&gt;B.ts&lt;/code&gt; 不能排除，除非引用文件 &lt;code&gt;A.ts&lt;/code&gt; 中还指定了 &lt;code&gt;&quot;exclude&quot;&lt;/code&gt; 列表中。</target>
        </trans-unit>
        <trans-unit id="58d3fbb8847e7adc33f00a67766bcf84d23be884" translate="yes" xml:space="preserve">
          <source>Any optional parameters must follow required parameters. Had we wanted to make the first name optional, rather than the last name, we would need to change the order of parameters in the function, putting the first name last in the list.</source>
          <target state="translated">任何可选参数必须跟在所需参数之后。如果我们想让名字是可选的,而不是姓氏,那么我们就需要改变函数中的参数顺序,把第一个名字放在最后。</target>
        </trans-unit>
        <trans-unit id="71f5a252552c3c04d4828a9b0a56671420fcd2c6" translate="yes" xml:space="preserve">
          <source>Any other import is considered &lt;strong&gt;non-relative&lt;/strong&gt;. Some examples include:</source>
          <target state="translated">其他任何导入均被视为&lt;strong&gt;非相对&lt;/strong&gt;导入。一些示例包括：</target>
        </trans-unit>
        <trans-unit id="f54cc3c33db9d0cc0052e3d3a5370d1f5fb94ee9" translate="yes" xml:space="preserve">
          <source>Any time &lt;code&gt;isFish&lt;/code&gt; is called with some variable, TypeScript will &lt;em&gt;narrow&lt;/em&gt; that variable to that specific type if the original type is compatible.</source>
          <target state="translated">每当使用某些变量调用 &lt;code&gt;isFish&lt;/code&gt; 时，如果原始类型兼容，TypeScript就会将该变量&lt;em&gt;缩小&lt;/em&gt;为该特定类型。</target>
        </trans-unit>
        <trans-unit id="3bab2aa131866dfb42803d6fff4f7d0f0c52622a" translate="yes" xml:space="preserve">
          <source>Any variable, parameter or property that is initialized with null or undefined will have type any, even if strict null checks is turned on. Any variable, parameter or property that is initialized with [] will have type any[], even if strict null checks is turned on. The only exception is for properties that have multiple initializers as described above.</source>
          <target state="translated">任何初始化为null或未定义的变量、参数或属性都将具有any类型,即使严格的null校验被打开。任何以[]初始化的变量、参数或属性都将具有any[]类型,即使严格的null校验被打开。唯一的例外是有多个初始化器的属性,如上文所述。</target>
        </trans-unit>
        <trans-unit id="2e2c98bb415f3297c0331ba25fa80d4c29b187e3" translate="yes" xml:space="preserve">
          <source>Anywhere a greeting is expected, you can provide a &lt;code&gt;string&lt;/code&gt;, a function returning a &lt;code&gt;string&lt;/code&gt;, or a &lt;code&gt;Greeter&lt;/code&gt; instance.</source>
          <target state="translated">在需要问候的任何地方，都可以提供 &lt;code&gt;string&lt;/code&gt; ，返回 &lt;code&gt;string&lt;/code&gt; 的函数或 &lt;code&gt;Greeter&lt;/code&gt; 实例。</target>
        </trans-unit>
        <trans-unit id="a2721bd2d72a316000ef90a03336789e7221fe00" translate="yes" xml:space="preserve">
          <source>Apache Cordova Apps still have the existing limitation of a single &lt;code&gt;tsconfig.json&lt;/code&gt; file, which must be in either the root or the &lt;code&gt;scripts&lt;/code&gt; folder.</source>
          <target state="translated">Apache Cordova Apps仍然具有单个 &lt;code&gt;tsconfig.json&lt;/code&gt; 文件的现有限制，该文件必须位于根文件夹或 &lt;code&gt;scripts&lt;/code&gt; 文件夹中。</target>
        </trans-unit>
        <trans-unit id="a72aa9f35599ef319f4bdce587da34e4ef96d8ee" translate="yes" xml:space="preserve">
          <source>App.ts</source>
          <target state="translated">App.ts</target>
        </trans-unit>
        <trans-unit id="f6775dc00da9c4ef2c019649d89650724f0bc81f" translate="yes" xml:space="preserve">
          <source>Applying the &lt;a href=&quot;https://en.wikipedia.org/wiki/Principle_of_least_privilege&quot;&gt;principle of least privilege&lt;/a&gt;, all declarations other than those you plan to modify should use &lt;code&gt;const&lt;/code&gt;. The rationale is that if a variable didn&amp;rsquo;t need to get written to, others working on the same codebase shouldn&amp;rsquo;t automatically be able to write to the object, and will need to consider whether they really need to reassign to the variable. Using &lt;code&gt;const&lt;/code&gt; also makes code more predictable when reasoning about flow of data.</source>
          <target state="translated">运用&lt;a href=&quot;https://en.wikipedia.org/wiki/Principle_of_least_privilege&quot;&gt;最小权限原则&lt;/a&gt;，比其他所有声明你打算修改应该使用 &lt;code&gt;const&lt;/code&gt; 。理由是，如果不需要写入变量，则在同一代码库上工作的其他人不应自动能够写入该对象，并且需要考虑它们是否确实需要重新分配给该变量。使用 &lt;code&gt;const&lt;/code&gt; 还可以在推理数据流时使代码更可预测。</target>
        </trans-unit>
        <trans-unit id="107004472b7ba4e5e31f3082ee1fb5a1239eec61" translate="yes" xml:space="preserve">
          <source>Array</source>
          <target state="translated">Array</target>
        </trans-unit>
        <trans-unit id="5b19a51e973f07fb33a1f0b3290dd21625155468" translate="yes" xml:space="preserve">
          <source>Array destructuring</source>
          <target state="translated">阵列破坏</target>
        </trans-unit>
        <trans-unit id="f5851b2384facd082dae02e6048cf9a0298dc5eb" translate="yes" xml:space="preserve">
          <source>As a heads up, when using &lt;code&gt;strictNullChecks&lt;/code&gt;, your dependencies may need to be updated to use &lt;code&gt;strictNullChecks&lt;/code&gt; as well.</source>
          <target state="translated">请注意，在使用 &lt;code&gt;strictNullChecks&lt;/code&gt; 时，可能还需要更新依赖项以使用 &lt;code&gt;strictNullChecks&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8d3e12e810f587516dce0ec17be3db602fa8d496" translate="yes" xml:space="preserve">
          <source>As a nice bonus, this can also reduce the memory and runtime footprint of the compiler and language service by avoiding loading &lt;code&gt;.d.ts&lt;/code&gt; files from duplicate packages.</source>
          <target state="translated">不错的好处是，通过避免从重复的程序包中加载 &lt;code&gt;.d.ts&lt;/code&gt; 文件，这还可以减少编译器和语言服务的内存和运行时占用空间。</target>
        </trans-unit>
        <trans-unit id="ba3d749ddb3000672893220ada4f38c622aabbb5" translate="yes" xml:space="preserve">
          <source>As a note: we encourage the use of &lt;code&gt;--strictNullChecks&lt;/code&gt; when possible, but for the purposes of this handbook, we will assume it is turned off.</source>
          <target state="translated">注意：我们鼓励在可能的情况下使用 &lt;code&gt;--strictNullChecks&lt;/code&gt; ，但是出于本手册的目的，我们将假定它已关闭。</target>
        </trans-unit>
        <trans-unit id="977dbb0a6075f870e0e4b082c7e83acf8cacfabb" translate="yes" xml:space="preserve">
          <source>As a result, TypeScript 3.2 considers the &lt;code&gt;error&lt;/code&gt; property in the following example to be a discriminant, whereas before it wouldn&amp;rsquo;t since &lt;code&gt;Error&lt;/code&gt; isn&amp;rsquo;t a singleton type. Thanks to this, narrowing works correctly in the body of the &lt;code&gt;unwrap&lt;/code&gt; function.</source>
          <target state="translated">结果，TypeScript 3.2 在下面的示例中将 &lt;code&gt;error&lt;/code&gt; 属性视为一个判别式，而在此之前，由于 &lt;code&gt;Error&lt;/code&gt; 不是单例类型，因此不会。因此，缩小功能在 &lt;code&gt;unwrap&lt;/code&gt; 功能的主体中正常工作。</target>
        </trans-unit>
        <trans-unit id="368d21349de8cec5ff1bdfc7896830a65df05b5c" translate="yes" xml:space="preserve">
          <source>As a result, users can write getters and setters in ambient contexts in TypeScript 3.6.</source>
          <target state="translated">因此,用户可以在TypeScript 3.6中的环境上下文中编写getter和setter。</target>
        </trans-unit>
        <trans-unit id="7895ee4a93d7fa1bb09b06ce0af1d11a32158318" translate="yes" xml:space="preserve">
          <source>As an alternative to individual imports, a namespace import can be used to import an entire module:</source>
          <target state="translated">作为单独导入的替代方案,命名空间导入可以用来导入整个模块。</target>
        </trans-unit>
        <trans-unit id="9fa46177b5c4d16d6b6bc058d8b30ad17e80456e" translate="yes" xml:space="preserve">
          <source>As an example of new errors you might spot as a result:</source>
          <target state="translated">作为一个新的错误的例子,你可能会发现新的错误作为结果。</target>
        </trans-unit>
        <trans-unit id="a43f82802df7af1b9c148a7744a7e8b03aeeec58" translate="yes" xml:space="preserve">
          <source>As an example of some types that are immediately resolved, we can take a look at the following example:</source>
          <target state="translated">作为一些类型立即解决的例子,我们可以看一下下面的例子。</target>
        </trans-unit>
        <trans-unit id="d5d1fff48d37907013a550ea65a80338a2731aa0" translate="yes" xml:space="preserve">
          <source>As an example, consider the need to escape a string that contains the character &amp;lsquo;𠮷&amp;rsquo;. In UTF-16/UCS2, &amp;lsquo;𠮷&amp;rsquo; is represented as a surrogate pair, meaning that it&amp;rsquo;s encoded using a pair of 16-bit code units of values, specifically &lt;code&gt;0xD842&lt;/code&gt; and &lt;code&gt;0xDFB7&lt;/code&gt;. Previously this meant that you&amp;rsquo;d have to escape the codepoint as &lt;code&gt;&quot;\uD842\uDFB7&quot;&lt;/code&gt;. This has the major downside that it&amp;rsquo;s difficult to discern two independent characters from a surrogate pair.</source>
          <target state="translated">例如，考虑是否需要转义包含字符&amp;ldquo;𠮷&amp;rdquo;的字符串。在UTF-16 / UCS2中，&amp;ldquo;𠮷&amp;rdquo;表示为代理对，这意味着它使用一对值的16位代码单元（特别是 &lt;code&gt;0xD842&lt;/code&gt; 和 &lt;code&gt;0xDFB7&lt;/code&gt; )进行编码。以前，这意味着您必须将代码点转义为 &lt;code&gt;&quot;\uD842\uDFB7&quot;&lt;/code&gt; 。这样做的主要缺点是很难从一个代理对中识别出两个独立的字符。</target>
        </trans-unit>
        <trans-unit id="7cef5c14af957c7ec054d83d89e6e1099bf750eb" translate="yes" xml:space="preserve">
          <source>As an example, getting the declarations for a library like lodash takes nothing more than the following command</source>
          <target state="translated">作为一个例子,获取像 lodash 这样的库的声明只需要以下命令就可以了</target>
        </trans-unit>
        <trans-unit id="57cdcd63d828e3b22ca9083f5b988b61d9d275fa" translate="yes" xml:space="preserve">
          <source>As an example, on many Unix-like systems, the standard output stream is accessible by the file &lt;code&gt;/dev/stdout&lt;/code&gt;.</source>
          <target state="translated">例如，在许多类Unix系统上，标准输出流可通过文件 &lt;code&gt;/dev/stdout&lt;/code&gt; 访问。</target>
        </trans-unit>
        <trans-unit id="04db06e8634e811fc030ab034631e6269dc8b211" translate="yes" xml:space="preserve">
          <source>As an example, the following code snippet</source>
          <target state="translated">作为一个例子,下面的代码片段如下</target>
        </trans-unit>
        <trans-unit id="5b7043bfc26c1ba1d57755926f65d96698dcbdc6" translate="yes" xml:space="preserve">
          <source>As an example, we can pipe our emitted JavaScript into a pretty printer like &lt;a href=&quot;https://www.npmjs.com/package/pretty-js&quot;&gt;pretty-js&lt;/a&gt;:</source>
          <target state="translated">举例来说，我们可以将发出的JavaScript传递给漂亮的打印机，例如&lt;a href=&quot;https://www.npmjs.com/package/pretty-js&quot;&gt;pretty-js&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="6acab1badefe292ebd417e66a3c779d99e6f3970" translate="yes" xml:space="preserve">
          <source>As discussed earlier, the compiler can visit files outside the current folder when resolving a module. This can be hard when diagnosing why a module is not resolved, or is resolved to an incorrect definition. Enabling the compiler module resolution tracing using &lt;code&gt;--traceResolution&lt;/code&gt; provides insight in what happened during the module resolution process.</source>
          <target state="translated">如前所述，解析模块时，编译器可以访问当前文件夹之外的文件。在诊断为什么模块未解析或解析为错误定义时，这可能很难。使用 &lt;code&gt;--traceResolution&lt;/code&gt; 启用编译器模块分辨率跟踪，可以洞悉模块解析过程中发生的情况。</target>
        </trans-unit>
        <trans-unit id="5fd062263fc01b5e1d46bab04d2fc86323793b16" translate="yes" xml:space="preserve">
          <source>As in JavaScript, all numbers in TypeScript are floating point values. These floating point numbers get the type &lt;code&gt;number&lt;/code&gt;. In addition to hexadecimal and decimal literals, TypeScript also supports binary and octal literals introduced in ECMAScript 2015.</source>
          <target state="translated">与JavaScript中一样，TypeScript中的所有数字都是浮点值。这些浮点数获得类型 &lt;code&gt;number&lt;/code&gt; 。除了十六进制和十进制文字，TypeScript还支持ECMAScript 2015中引入的二进制和八进制文字。</target>
        </trans-unit>
        <trans-unit id="1bd66e26a872b778f91b4e166644723ee3f84de0" translate="yes" xml:space="preserve">
          <source>As long as the parameter types line up, it&amp;rsquo;s considered a valid type for the function, regardless of the names you give the parameters in the function type.</source>
          <target state="translated">只要将参数类型排列在一起，就将其视为函数的有效类型，无论您在函数类型中为参数指定什么名称。</target>
        </trans-unit>
        <trans-unit id="840af689a0703390b87203932fb9e888f4976db7" translate="yes" xml:space="preserve">
          <source>As mentioned above, TypeScript now errors when functions appear to be uncalled within &lt;code&gt;if&lt;/code&gt; statement conditions. An error is issued when a function type is checked in &lt;code&gt;if&lt;/code&gt; conditions unless any of the following apply:</source>
          <target state="translated">如上所述，当在 &lt;code&gt;if&lt;/code&gt; 语句条件下似乎未调用函数时，TypeScript现在会出错。当一个函数类型检查发出一个错误 &lt;code&gt;if&lt;/code&gt; 条件，除非以下任一应用：</target>
        </trans-unit>
        <trans-unit id="2a5c086b08f5e14213b1e066b50db36d669f8f91" translate="yes" xml:space="preserve">
          <source>As mentioned in &lt;a href=&quot;enums#union-enums-and-enum-member-types&quot;&gt;our section on enums&lt;/a&gt;, enum members have types when every member is literal-initialized.</source>
          <target state="translated">正如&lt;a href=&quot;enums#union-enums-and-enum-member-types&quot;&gt;我们在枚举部分中&lt;/a&gt;提到的，当每个成员都被文字初始化时，枚举成员具有类型。</target>
        </trans-unit>
        <trans-unit id="ef133c43f210eb19ff5fbc570648cdd98a773f66" translate="yes" xml:space="preserve">
          <source>As our application grows, we&amp;rsquo;ll want to split the code across multiple files to make it easier to maintain.</source>
          <target state="translated">随着应用程序的增长，我们希望将代码拆分到多个文件中，以使其易于维护。</target>
        </trans-unit>
        <trans-unit id="a1bb7cf0157b073ec01dbb6472be74930da9d121" translate="yes" xml:space="preserve">
          <source>As part of the work for assertion signatures, TypeScript needed to encode more about where and which functions were being called. This gave us the opportunity to expand support for another class of functions: functions that return &lt;code&gt;never&lt;/code&gt;.</source>
          <target state="translated">作为断言签名工作的一部分，TypeScript需要对调用位置和调用函数进行更多编码。这使我们有机会扩展对另一类功能的支持： &lt;code&gt;never&lt;/code&gt; 返回的功能。</target>
        </trans-unit>
        <trans-unit id="390fe60664424f4e52cb8b9bdf97c3dba17b9a17" translate="yes" xml:space="preserve">
          <source>As specified in ECMAScript, mixing &lt;code&gt;number&lt;/code&gt;s and &lt;code&gt;bigint&lt;/code&gt;s in arithmetic operations is an error. You&amp;rsquo;ll have to explicitly convert values to &lt;code&gt;BigInt&lt;/code&gt;s.</source>
          <target state="translated">如ECMAScript中所指定，算术运算中将 &lt;code&gt;number&lt;/code&gt; s和 &lt;code&gt;bigint&lt;/code&gt; 混合在一起是错误的。您必须将值显式转换为 &lt;code&gt;BigInt&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6b12aa1f9da2310999311b7475d8a9700fd525f1" translate="yes" xml:space="preserve">
          <source>As such, the following steps are performed when evaluating multiple decorators on a single declaration in TypeScript:</source>
          <target state="translated">因此,当在TypeScript中对单个声明中的多个装饰符进行评估时,会执行以下步骤。</target>
        </trans-unit>
        <trans-unit id="7c6bf56e61f5837d2d137d88d1a894bdddcce94e" translate="yes" xml:space="preserve">
          <source>As the name suggests, the component is defined as a JavaScript function where its first argument is a &lt;code&gt;props&lt;/code&gt; object. TS enforces that its return type must be assignable to &lt;code&gt;JSX.Element&lt;/code&gt;.</source>
          <target state="translated">顾名思义，该组件被定义为JavaScript函数，其第一个参数是 &lt;code&gt;props&lt;/code&gt; 对象。TS强制要求其返回类型必须可分配给 &lt;code&gt;JSX.Element&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f3ca06e4caafd2fed96f322e77c268ce050caf98" translate="yes" xml:space="preserve">
          <source>As we add more validators, we&amp;rsquo;re going to want to have some kind of organization scheme so that we can keep track of our types and not worry about name collisions with other objects. Instead of putting lots of different names into the global namespace, let&amp;rsquo;s wrap up our objects into a namespace.</source>
          <target state="translated">随着我们添加更多的验证器，我们将需要一种某种组织方案，以便我们可以跟踪我们的类型，而不必担心与其他对象的名称冲突。与其将大量不同的名称放入全局名称空间，不如将对象包装到名称空间中。</target>
        </trans-unit>
        <trans-unit id="f8a201a25fd7790f05a2ecb442c622ccca689a7b" translate="yes" xml:space="preserve">
          <source>As we covered in &lt;a href=&quot;classes&quot;&gt;our section on classes&lt;/a&gt;, a class has two sides to its type: the static side and the instance side. Generic classes are only generic over their instance side rather than their static side, so when working with classes, static members can not use the class&amp;rsquo;s type parameter.</source>
          <target state="translated">正如我们&lt;a href=&quot;classes&quot;&gt;在类&lt;/a&gt;一节中介绍的那样，类的类型有两个方面：静态方面和实例方面。泛型类仅在其实例方面是泛型，而在其静态方面是泛型，因此在使用类时，静态成员不能使用该类的type参数。</target>
        </trans-unit>
        <trans-unit id="e39977ca24b8e7d4979279054a3ddcd2072307e9" translate="yes" xml:space="preserve">
          <source>As we improve the playground and the website, &lt;a href=&quot;https://github.com/microsoft/TypeScript-Website/&quot;&gt;we welcome feedback and pull requests on GitHub&lt;/a&gt;!</source>
          <target state="translated">随着我们改善游乐场和网站的发展，&lt;a href=&quot;https://github.com/microsoft/TypeScript-Website/&quot;&gt;我们欢迎反馈并在GitHub上提出请求&lt;/a&gt;！</target>
        </trans-unit>
        <trans-unit id="5e0926e0c8d61335ab6e159abc80a290ccf182a2" translate="yes" xml:space="preserve">
          <source>As we mentioned earlier, interfaces can describe the rich types present in real world JavaScript. Because of JavaScript&amp;rsquo;s dynamic and flexible nature, you may occasionally encounter an object that works as a combination of some of the types described above.</source>
          <target state="translated">如前所述，接口可以描述现实世界JavaScript中存在的丰富类型。由于JavaScript具有动态和灵活的性质，因此您有时可能会遇到一个对象，该对象可以作为上述某些类型的组合使用。</target>
        </trans-unit>
        <trans-unit id="e667d5c6d0aea6aea249141e0079b9aabfe0e442" translate="yes" xml:space="preserve">
          <source>As we mentioned, BigInt support is only available for the &lt;code&gt;esnext&lt;/code&gt; target. It may not be obvious, but because BigInts have different behavior for mathematical operators like &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, etc., providing functionality for older targets where the feature doesn&amp;rsquo;t exist (like &lt;code&gt;es2017&lt;/code&gt; and below) would involve rewriting each of these operations. TypeScript would need to dispatch to the correct behavior depending on the type, and so every addition, string concatenation, multiplication, etc. would involve a function call.</source>
          <target state="translated">如前所述，BigInt支持仅适用于 &lt;code&gt;esnext&lt;/code&gt; 目标。可能并不明显，但是由于BigInts对于数学运算符（如 &lt;code&gt;+&lt;/code&gt; ， &lt;code&gt;-&lt;/code&gt; ， &lt;code&gt;*&lt;/code&gt; 等）具有不同的行为，因此为不存在该功能的较早目标（如 &lt;code&gt;es2017&lt;/code&gt; 及更低版本）提供功能将涉及重写这些操作中的每一个。 TypeScript将需要根据类型分派正确的行为，因此每个加法，字符串连接，乘法等都将涉及一个函数调用。</target>
        </trans-unit>
        <trans-unit id="0bec2ed7fb7091a8ef64c32bc287724bfc0cce55" translate="yes" xml:space="preserve">
          <source>As we mentioned, type aliases can act sort of like interfaces; however, there are some subtle differences.</source>
          <target state="translated">正如我们所提到的,类型别名的作用有点像接口;但是,有一些微妙的区别。</target>
        </trans-unit>
        <trans-unit id="c55f71cd30e6435a112a945f64ecb9e401e4684b" translate="yes" xml:space="preserve">
          <source>As we said in the previous section, a class declaration creates two things: a type representing instances of the class and a constructor function. Because classes create types, you can use them in the same places you would be able to use interfaces.</source>
          <target state="translated">正如我们在上一节中所说的,一个类声明会创建两样东西:一个代表类的实例的类型和一个构造函数。因为类创建了类型,所以你可以把它们用在和接口一样的地方。</target>
        </trans-unit>
        <trans-unit id="eca7c3fc0aeea895ca68482e3282da249688fb4f" translate="yes" xml:space="preserve">
          <source>As with Generators, Async Generators can only be function declarations, function expressions, or methods of classes or object literals. Arrow functions cannot be Async Generators. Async Generators require a valid, global &lt;code&gt;Promise&lt;/code&gt; implementation (either native or an ES2015-compatible polyfill), in addition to a valid &lt;code&gt;Symbol.asyncIterator&lt;/code&gt; reference (either a native symbol or a shim).</source>
          <target state="translated">与生成器一样，异步生成器只能是函数声明，函数表达式或类或对象文字的方法。箭头函数不能是异步生成器。除了有效的 &lt;code&gt;Symbol.asyncIterator&lt;/code&gt; 引用（本机符号或填充程序）之外，异步生成器还需要有效的全局 &lt;code&gt;Promise&lt;/code&gt; 实现（本机或与ES2015兼容的polyfill ）。</target>
        </trans-unit>
        <trans-unit id="e4960adc215b4ac881e5c35568584f22fd6212eb" translate="yes" xml:space="preserve">
          <source>As with arrays, you can destructure the rest of the tuple with &lt;code&gt;...&lt;/code&gt;, to get a shorter tuple:</source>
          <target state="translated">与数组一样，您可以使用 &lt;code&gt;...&lt;/code&gt; 来分解其余的元组，以获得较短的元组：</target>
        </trans-unit>
        <trans-unit id="1c88c0ca9b6b6b4f95fa0f5e0a3945111347bb7f" translate="yes" xml:space="preserve">
          <source>As with assertion functions, you can &lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/32695&quot;&gt;read up more at the same pull request&lt;/a&gt;.</source>
          <target state="translated">与断言函数一样，您可以&lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/32695&quot;&gt;在相同的pull request中阅读更多内容&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="40ebe0449790b742a22a4412bec079981f0005a3" translate="yes" xml:space="preserve">
          <source>As with global modules, you might see these examples in the documentation of a UMD module, so be sure to check the code or documentation.</source>
          <target state="translated">与全局模块一样,你可能会在UMD模块的文档中看到这些例子,所以一定要检查代码或文档。</target>
        </trans-unit>
        <trans-unit id="0705018bf7b343a8a49c9a07104949e0fe3a4e7a" translate="yes" xml:space="preserve">
          <source>As with types, you probably already understand what a value is. Values are runtime names that we can reference in expressions. For example &lt;code&gt;let x = 5;&lt;/code&gt; creates a value called &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">与类型一样，您可能已经了解了什么是值。值是我们可以在表达式中引用的运行时名称。例如， &lt;code&gt;let x = 5;&lt;/code&gt; 创建一个名为 &lt;code&gt;x&lt;/code&gt; 的值。</target>
        </trans-unit>
        <trans-unit id="e1a48f4680185d0a1c25499af1056b570588fb64" translate="yes" xml:space="preserve">
          <source>As you might&amp;rsquo;ve figured out, we just declared a variable named &lt;code&gt;a&lt;/code&gt; with the value &lt;code&gt;10&lt;/code&gt;.</source>
          <target state="translated">您可能已经知道，我们刚刚声明了一个名为 &lt;code&gt;a&lt;/code&gt; 的变量，其值为 &lt;code&gt;10&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="72457daa6f50ff48a819ba7cfab041aeb483b454" translate="yes" xml:space="preserve">
          <source>As you type on the boxes you should see the message appear/change!</source>
          <target state="translated">当你在盒子上打字的时候,你应该会看到信息出现/改变!</target>
        </trans-unit>
        <trans-unit id="bc4a6547aa8a5fff93868acf4c855dc352b78b55" translate="yes" xml:space="preserve">
          <source>Ask the file named &lt;code&gt;/root/src/moduleB.js&lt;/code&gt;, if it exists.</source>
          <target state="translated">询问名为 &lt;code&gt;/root/src/moduleB.js&lt;/code&gt; 的文件（如果存在）。</target>
        </trans-unit>
        <trans-unit id="ae145f96f9923e53fbb6e9f3f9610452236976e4" translate="yes" xml:space="preserve">
          <source>Ask the folder &lt;code&gt;/root/src/moduleB&lt;/code&gt; if it contains a file named &lt;code&gt;index.js&lt;/code&gt;. That file is implicitly considered that folder&amp;rsquo;s &amp;ldquo;main&amp;rdquo; module.</source>
          <target state="translated">询问 &lt;code&gt;/root/src/moduleB&lt;/code&gt; 文件夹是否包含名为 &lt;code&gt;index.js&lt;/code&gt; 的文件。该文件被隐式视为该文件夹的&amp;ldquo;主&amp;rdquo;模块。</target>
        </trans-unit>
        <trans-unit id="8b89fe51a739705208f8a298ea55bb588950f3b6" translate="yes" xml:space="preserve">
          <source>Ask the folder &lt;code&gt;/root/src/moduleB&lt;/code&gt; if it contains a file named &lt;code&gt;package.json&lt;/code&gt; that specifies a &lt;code&gt;&quot;main&quot;&lt;/code&gt; module. In our example, if Node.js found the file &lt;code&gt;/root/src/moduleB/package.json&lt;/code&gt; containing &lt;code&gt;{ &quot;main&quot;: &quot;lib/mainModule.js&quot; }&lt;/code&gt;, then Node.js will refer to &lt;code&gt;/root/src/moduleB/lib/mainModule.js&lt;/code&gt;.</source>
          <target state="translated">询问文件夹 &lt;code&gt;/root/src/moduleB&lt;/code&gt; 是否包含名为 &lt;code&gt;package.json&lt;/code&gt; 的文件，该文件指定 &lt;code&gt;&quot;main&quot;&lt;/code&gt; 模块。在我们的示例中，如果Node.js找到了包含 &lt;code&gt;{ &quot;main&quot;: &quot;lib/mainModule.js&quot; }&lt;/code&gt; 的文件 &lt;code&gt;/root/src/moduleB/package.json&lt;/code&gt; ，则Node.js将引用 &lt;code&gt;/root/src/moduleB/lib/mainModule.js&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b89f9c9a7b547e368f3dab7225883398658593d9" translate="yes" xml:space="preserve">
          <source>Assertion Functions</source>
          <target state="translated">斷言功能</target>
        </trans-unit>
        <trans-unit id="98c46e5ab2ffec3f635dbcdf5bc83e5353066495" translate="yes" xml:space="preserve">
          <source>Assertions in JavaScript are often used to guard against improper types being passed in. For example,</source>
          <target state="translated">JavaScript中的断言经常被用来防止不正确的类型被传递进来。比如说。</target>
        </trans-unit>
        <trans-unit id="d8da00b586664722cbf919d60c3a4ea73823442f" translate="yes" xml:space="preserve">
          <source>Assigned-before-use checking</source>
          <target state="translated">使用前的分配检查</target>
        </trans-unit>
        <trans-unit id="3a3dd9c1b7f42e306408c3dfe2c8989c03230b2e" translate="yes" xml:space="preserve">
          <source>Assignment to union types works very intuitively &amp;ndash; anything you could assign to one of the union type&amp;rsquo;s members is assignable to the union:</source>
          <target state="translated">分配给联合类型非常直观-您可以分配给任何一个联合类型成员的内容都可以分配给该联合：</target>
        </trans-unit>
        <trans-unit id="057d58c74d80136578cabbeee1b89206c3250bd4" translate="yes" xml:space="preserve">
          <source>Assignments</source>
          <target state="translated">Assignments</target>
        </trans-unit>
        <trans-unit id="f204f370193bea63fc30347377344ab8d15db4a7" translate="yes" xml:space="preserve">
          <source>Assignments at the top-level should behave the same way; in other words, a &lt;code&gt;var&lt;/code&gt; or &lt;code&gt;const&lt;/code&gt; declaration is not required.</source>
          <target state="translated">顶层分配的行为应相同。换句话说，不需要 &lt;code&gt;var&lt;/code&gt; 或 &lt;code&gt;const&lt;/code&gt; 声明。</target>
        </trans-unit>
        <trans-unit id="62de5df53249972bb9af1fc4eb134121b22de084" translate="yes" xml:space="preserve">
          <source>Assignments to &lt;code&gt;exports&lt;/code&gt; or &lt;code&gt;module.exports&lt;/code&gt;</source>
          <target state="translated">分配 &lt;code&gt;exports&lt;/code&gt; 或 &lt;code&gt;module.exports&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f7a3538682165ab749b99e78129248b3c38f0d9b" translate="yes" xml:space="preserve">
          <source>Assignments to properties of &lt;code&gt;window&lt;/code&gt; or &lt;code&gt;global&lt;/code&gt;</source>
          <target state="translated">分配 &lt;code&gt;window&lt;/code&gt; 或 &lt;code&gt;global&lt;/code&gt; 属性</target>
        </trans-unit>
        <trans-unit id="58799777e41ae1e8d930adcb89c0780ba66e38d5" translate="yes" xml:space="preserve">
          <source>Assume that each of these modules exports an array of strings. For example &lt;code&gt;./zh/messages&lt;/code&gt; might contain:</source>
          <target state="translated">假设这些模块中的每个模块都导出一个字符串数组。例如，./ &lt;code&gt;./zh/messages&lt;/code&gt; 可能包含：</target>
        </trans-unit>
        <trans-unit id="e528328da4f68ed5eb912249e43e3e2e00accde0" translate="yes" xml:space="preserve">
          <source>Assuming that &lt;code&gt;__dirname&lt;/code&gt; is always available on &lt;code&gt;import.meta&lt;/code&gt;, the declaration would be done through reopening &lt;code&gt;ImportMeta&lt;/code&gt; interface:</source>
          <target state="translated">假设 &lt;code&gt;__dirname&lt;/code&gt; 在 &lt;code&gt;import.meta&lt;/code&gt; 上始终可用，则将通过重新打开 &lt;code&gt;ImportMeta&lt;/code&gt; 接口来完成声明：</target>
        </trans-unit>
        <trans-unit id="63c86e37952421654714f44ff0a3e0b511f5f15f" translate="yes" xml:space="preserve">
          <source>Assumptions that DOM primitives like &lt;code&gt;document&lt;/code&gt; or &lt;code&gt;window&lt;/code&gt; exist</source>
          <target state="translated">假设存在诸如 &lt;code&gt;document&lt;/code&gt; 或 &lt;code&gt;window&lt;/code&gt; 类的DOM原语</target>
        </trans-unit>
        <trans-unit id="4fb1a430a57e52b71176eabf0a0a52ccef1c8fac" translate="yes" xml:space="preserve">
          <source>Astute readers will notice that, for example, &lt;code&gt;class&lt;/code&gt; appeared in both the &lt;em&gt;type&lt;/em&gt; and &lt;em&gt;value&lt;/em&gt; lists. The declaration &lt;code&gt;class C { }&lt;/code&gt; creates two things: a &lt;em&gt;type&lt;/em&gt;&lt;code&gt;C&lt;/code&gt; which refers to the instance shape of the class, and a &lt;em&gt;value&lt;/em&gt;&lt;code&gt;C&lt;/code&gt; which refers to the constructor function of the class. Enum declarations behave similarly.</source>
          <target state="translated">精明的读者会注意到，例如， &lt;code&gt;class&lt;/code&gt; 出现在&lt;em&gt;类型&lt;/em&gt;和&lt;em&gt;值&lt;/em&gt;列表中。声明 &lt;code&gt;class C { }&lt;/code&gt; 创建了两件事：&lt;em&gt;类型&lt;/em&gt; &lt;code&gt;C&lt;/code&gt; 引用类的实例形状，&lt;em&gt;值&lt;/em&gt; &lt;code&gt;C&lt;/code&gt; 引用类的构造函数。枚举声明的行为类似。</target>
        </trans-unit>
        <trans-unit id="6bd2a8a7dd2324b3dfc1a250fed0f9daa6541f3a" translate="yes" xml:space="preserve">
          <source>Async Generators</source>
          <target state="translated">异步生成器</target>
        </trans-unit>
        <trans-unit id="3c1b53675cb58d1ec8542ffe7447c2dc8ed8d373" translate="yes" xml:space="preserve">
          <source>Async Iteration</source>
          <target state="translated">异步迭代</target>
        </trans-unit>
        <trans-unit id="fec7372c392b06a860ac46991a72a2226276fba1" translate="yes" xml:space="preserve">
          <source>Async iterators</source>
          <target state="translated">异步迭代器</target>
        </trans-unit>
        <trans-unit id="5bec73a232efba048470ae0342c82f3228e1af2d" translate="yes" xml:space="preserve">
          <source>At its core, optional chaining lets us write code where TypeScript can immediately stop running some expressions if we run into a &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt;. The star of the show in optional chaining is the new &lt;code&gt;?.&lt;/code&gt; operator for &lt;em&gt;optional property accesses&lt;/em&gt;. When we write code like</source>
          <target state="translated">从本质上讲，可选链使我们可以编写代码，如果遇到 &lt;code&gt;null&lt;/code&gt; 或 &lt;code&gt;undefined&lt;/code&gt; ，TypeScript可以立即停止运行某些表达式。可选链接中的节目明星是新的 &lt;code&gt;?.&lt;/code&gt; 用于&lt;em&gt;可选属性访问的&lt;/em&gt;运算符。当我们写像</target>
        </trans-unit>
        <trans-unit id="d1167ef7e58858fe2a166efd826d59d4d9cd2ba5" translate="yes" xml:space="preserve">
          <source>At the command line, run the TypeScript compiler:</source>
          <target state="translated">在命令行中,运行TypeScript编译器。</target>
        </trans-unit>
        <trans-unit id="e78da82abc219a055bfa736ddf690eb4d03a6708" translate="yes" xml:space="preserve">
          <source>At this point, if you try running &lt;code&gt;tsc&lt;/code&gt; at the root of your project, you should see output files in the &lt;code&gt;built&lt;/code&gt; directory. The layout of files in &lt;code&gt;built&lt;/code&gt; should look identical to the layout of &lt;code&gt;src&lt;/code&gt;. You should now have TypeScript working with your project.</source>
          <target state="translated">此时，如果你尝试运行 &lt;code&gt;tsc&lt;/code&gt; 在你的项目的根，你应该看到在输出文件 &lt;code&gt;built&lt;/code&gt; 目录。 &lt;code&gt;built&lt;/code&gt; 文件的布局应与 &lt;code&gt;src&lt;/code&gt; 的布局相同。现在，您应该使TypeScript与您的项目一起使用。</target>
        </trans-unit>
        <trans-unit id="378f484fcf34a8ed1dd8027e59916eb7638d8ea5" translate="yes" xml:space="preserve">
          <source>At this point, the compiler will ask &amp;ldquo;what&amp;rsquo;s the shape of &lt;code&gt;moduleA&lt;/code&gt;?&amp;rdquo; While this sounds straightforward, &lt;code&gt;moduleA&lt;/code&gt; could be defined in one of your own &lt;code&gt;.ts&lt;/code&gt;/&lt;code&gt;.tsx&lt;/code&gt; files, or in a &lt;code&gt;.d.ts&lt;/code&gt; that your code depends on.</source>
          <target state="translated">此时，编译器将询问&amp;ldquo; &lt;code&gt;moduleA&lt;/code&gt; 的形状是什么？&amp;rdquo; 尽管这听起来很简单， &lt;code&gt;moduleA&lt;/code&gt; 可以在您自己的 &lt;code&gt;.ts&lt;/code&gt; / &lt;code&gt;.tsx&lt;/code&gt; 文件之一中或在您的代码所依赖的.d.ts文件中 &lt;code&gt;.d.ts&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ed32a39d243798f06b391e5f95f8515b64a1895b" translate="yes" xml:space="preserve">
          <source>At this point, you&amp;rsquo;re probably ready to start using TypeScript files. The first step is to rename one of your &lt;code&gt;.js&lt;/code&gt; files to &lt;code&gt;.ts&lt;/code&gt;. If your file uses JSX, you&amp;rsquo;ll need to rename it to &lt;code&gt;.tsx&lt;/code&gt;.</source>
          <target state="translated">此时，您可能已经准备好开始使用TypeScript文件。第一步是将一个 &lt;code&gt;.js&lt;/code&gt; 文件重命名为 &lt;code&gt;.ts&lt;/code&gt; 。如果文件使用JSX，则需要将其重命名为 &lt;code&gt;.tsx&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6e7ccc595171e95a7eb1f834393506196fbc0ea1" translate="yes" xml:space="preserve">
          <source>Attribute type checking</source>
          <target state="translated">属性类型检查</target>
        </trans-unit>
        <trans-unit id="1cfeae50596a1c82d93481a9895a732d259c70b1" translate="yes" xml:space="preserve">
          <source>Augmenting global/module scope from modules</source>
          <target state="translated">从模块中扩充全局/模块范围</target>
        </trans-unit>
        <trans-unit id="78d9210af9045d4fe60bdb145dcc8d78ae6da80c" translate="yes" xml:space="preserve">
          <source>Automatically set to PreferredUILang value</source>
          <target state="translated">自动设置为PreferredUILang值</target>
        </trans-unit>
        <trans-unit id="f3bf8dee016caf43ae3970fbea5f976d54898ed9" translate="yes" xml:space="preserve">
          <source>Babel</source>
          <target state="translated">Babel</target>
        </trans-unit>
        <trans-unit id="adcde08c76f527a1993685af5dc553eeaf5a112d" translate="yes" xml:space="preserve">
          <source>Babel is a hugely flexible compiler that converts ES2015 and beyond into ES5 and ES3. This lets you add extensive and customized transformations that TypeScript doesn&amp;rsquo;t support.</source>
          <target state="translated">Babel是一款非常灵活的编译器，可将ES2015及更高版本转换为ES5和ES3。这使您可以添加TypeScript不支持的广泛且自定义的转换。</target>
        </trans-unit>
        <trans-unit id="aca918fb61ddb9faae466290b72a8013b7e396e6" translate="yes" xml:space="preserve">
          <source>Babel&amp;rsquo;s ES5 output should be very similar to TypeScript&amp;rsquo;s output for such a simple script.</source>
          <target state="translated">对于这样一个简单的脚本，Babel的ES5输出应该与TypeScript的输出非常相似。</target>
        </trans-unit>
        <trans-unit id="5ad5cf24690d2882eba4d3f2b0e0a8bf277990a5" translate="yes" xml:space="preserve">
          <source>Back when TypeScript implemented public class fields, we assumed to the best of our abilities that the following code</source>
          <target state="translated">在TypeScript实现公共类字段的时候,我们尽可能地假设以下代码是由以下代码组成的</target>
        </trans-unit>
        <trans-unit id="64dd60fe1a049fe6db3eb1369dec2e42bf428e21" translate="yes" xml:space="preserve">
          <source>Background</source>
          <target state="translated">Background</target>
        </trans-unit>
        <trans-unit id="c2fd3a989facf50da271d674c14207aa8ad92548" translate="yes" xml:space="preserve">
          <source>Bare Import</source>
          <target state="translated">裸进口</target>
        </trans-unit>
        <trans-unit id="1dbd61f556fe3f920e0c1bc1a21ce34dd73099d6" translate="yes" xml:space="preserve">
          <source>Base URL</source>
          <target state="translated">基本URL</target>
        </trans-unit>
        <trans-unit id="172793b0e3b408efe74b0d9f46aaf934fcd5496f" translate="yes" xml:space="preserve">
          <source>Base directory to resolve non-relative module names. See &lt;a href=&quot;module-resolution#base-url&quot;&gt;Module Resolution documentation&lt;/a&gt; for more details.</source>
          <target state="translated">基本目录，用于解析非相对模块名称。有关更多详细信息，请参见&lt;a href=&quot;module-resolution#base-url&quot;&gt;模块分辨率文档&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="30c8a7205576c1623baf3a7cfcb0a92c99932a66" translate="yes" xml:space="preserve">
          <source>Based on the fact that the above function is being assigned to &lt;code&gt;Window.onscroll&lt;/code&gt;, Typescript knows that &lt;code&gt;uiEvent&lt;/code&gt; is a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/UIEvent&quot;&gt;UIEvent&lt;/a&gt;, and not a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent&quot;&gt;MouseEvent&lt;/a&gt; like the previous example. &lt;code&gt;UIEvent&lt;/code&gt; objects contain no &lt;code&gt;button&lt;/code&gt; property, and so Typescript will throw an error.</source>
          <target state="translated">基于这样的事实，上述功能被分配到 &lt;code&gt;Window.onscroll&lt;/code&gt; ，打字稿知道 &lt;code&gt;uiEvent&lt;/code&gt; 是&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/UIEvent&quot;&gt;的UIEvent&lt;/a&gt;，而不是一个&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent&quot;&gt;的MouseEvent&lt;/a&gt;像前面的例子。 &lt;code&gt;UIEvent&lt;/code&gt; 对象不包含 &lt;code&gt;button&lt;/code&gt; 属性，因此Typescript将引发错误。</target>
        </trans-unit>
        <trans-unit id="5eab8fc3ffa32aa796174a77104a420884806a36" translate="yes" xml:space="preserve">
          <source>Basic Concepts</source>
          <target state="translated">基本概念</target>
        </trans-unit>
        <trans-unit id="7519044f052a17daead9b75e1d213e160e8c8476" translate="yes" xml:space="preserve">
          <source>Basic Gruntfile.js</source>
          <target state="translated">Basic Gruntfile.js</target>
        </trans-unit>
        <trans-unit id="0683d71248dcbb6ef209d3946391b3451983e5b6" translate="yes" xml:space="preserve">
          <source>Basic Types</source>
          <target state="translated">基本类型</target>
        </trans-unit>
        <trans-unit id="bf61ba3f6509ba114cc8faf2b40e8e71ed35a95e" translate="yes" xml:space="preserve">
          <source>Basic Types: Any</source>
          <target state="translated">基本类型。任何类型</target>
        </trans-unit>
        <trans-unit id="d61d7e43d7dc9242055a885bc7b2bde15bb723db" translate="yes" xml:space="preserve">
          <source>Basic Types: Array</source>
          <target state="translated">基本类型。阵列</target>
        </trans-unit>
        <trans-unit id="ed07881f050cc30ef0327d36d1271fbb6c104615" translate="yes" xml:space="preserve">
          <source>Basic Types: Enum</source>
          <target state="translated">基本类型。基本类型:Enum</target>
        </trans-unit>
        <trans-unit id="243307eb146b441d38c323662afa7897483a957d" translate="yes" xml:space="preserve">
          <source>Basic Types: Never</source>
          <target state="translated">基本类型。从不</target>
        </trans-unit>
        <trans-unit id="682c83570d93e651a69c5cc3c77d360b30490fae" translate="yes" xml:space="preserve">
          <source>Basic Types: Tuple</source>
          <target state="translated">基本类型。Tuple</target>
        </trans-unit>
        <trans-unit id="58a2993e94f23073b254c35171c856f14023d41f" translate="yes" xml:space="preserve">
          <source>Basic Types: Void</source>
          <target state="translated">基本类型。无效</target>
        </trans-unit>
        <trans-unit id="b20cbc384159fd820ed034fd3615298ec09f5902" translate="yes" xml:space="preserve">
          <source>Basic Usage</source>
          <target state="translated">基本用法</target>
        </trans-unit>
        <trans-unit id="61d56735d306d59953f3983c85541271068dbd2d" translate="yes" xml:space="preserve">
          <source>Basic gulpfile.js</source>
          <target state="translated">基本的gulpfile.js</target>
        </trans-unit>
        <trans-unit id="cb3a8802da5b3164771a468d78ff7995a249f08a" translate="yes" xml:space="preserve">
          <source>Basic usage</source>
          <target state="translated">基本用法</target>
        </trans-unit>
        <trans-unit id="412b5f9fcb13b09d7c79dbb054f0b03a03299e53" translate="yes" xml:space="preserve">
          <source>Basic webpack.config.js when using Webpack 1</source>
          <target state="translated">使用Webpack 1时的基本webpack.config.js</target>
        </trans-unit>
        <trans-unit id="4eb989b59b1f0bb11bab44b3981ea2961cb73436" translate="yes" xml:space="preserve">
          <source>Basic webpack.config.js when using Webpack 2</source>
          <target state="translated">使用Webpack 2时的基本webpack.config.js</target>
        </trans-unit>
        <trans-unit id="5fcebeefad3cdbbf8733aa928160dec7dc90c1a1" translate="yes" xml:space="preserve">
          <source>Basics</source>
          <target state="translated">Basics</target>
        </trans-unit>
        <trans-unit id="74f706e43bf557f0281375454415863443ab6f79" translate="yes" xml:space="preserve">
          <source>Be sure to read the &lt;a href=&quot;#the-impact-of-es6-on-module-plugins&quot;&gt;footnote &amp;ldquo;The Impact of ES6 on Module Call Signatures&amp;rdquo;&lt;/a&gt;</source>
          <target state="translated">请务必阅读&lt;a href=&quot;#the-impact-of-es6-on-module-plugins&quot;&gt;脚注&amp;ldquo; ES6对模块调用签名的影响&amp;rdquo;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9079f4cebe690d974b574d363d2382dfc53aa88d" translate="yes" xml:space="preserve">
          <source>Because &lt;a href=&quot;https://en.wikipedia.org/wiki/Open/closed_principle&quot;&gt;an ideal property of software is being open to extension&lt;/a&gt;, you should always use an interface over a type alias if possible.</source>
          <target state="translated">因为&lt;a href=&quot;https://en.wikipedia.org/wiki/Open/closed_principle&quot;&gt;软件的理想属性正在向扩展开放&lt;/a&gt;，所以如果可能，应该始终在类型别名上使用接口。</target>
        </trans-unit>
        <trans-unit id="5334136ac4ebd83a783dcba6f8148dc9c2a1da75" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;Dog&lt;/code&gt; extends the functionality from &lt;code&gt;Animal&lt;/code&gt;, we were able to create an instance of &lt;code&gt;Dog&lt;/code&gt; that could both &lt;code&gt;bark()&lt;/code&gt; and &lt;code&gt;move()&lt;/code&gt;.</source>
          <target state="translated">因为 &lt;code&gt;Dog&lt;/code&gt; 扩展了 &lt;code&gt;Animal&lt;/code&gt; 的功能，所以我们能够创建一个可以同时发出 &lt;code&gt;bark()&lt;/code&gt; 和 &lt;code&gt;move()&lt;/code&gt; 的 &lt;code&gt;Dog&lt;/code&gt; 实例。</target>
        </trans-unit>
        <trans-unit id="d60995ae598e05ed025f86ab90ffdb0762aef9f1" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;createClock&lt;/code&gt;&amp;rsquo;s first parameter is of type &lt;code&gt;ClockConstructor&lt;/code&gt;, in &lt;code&gt;createClock(AnalogClock, 7, 32)&lt;/code&gt;, it checks that &lt;code&gt;AnalogClock&lt;/code&gt; has the correct constructor signature.</source>
          <target state="translated">由于 &lt;code&gt;createClock&lt;/code&gt; 的第一个参数的类型为 &lt;code&gt;ClockConstructor&lt;/code&gt; ，因此在 &lt;code&gt;createClock(AnalogClock, 7, 32)&lt;/code&gt; ，它将检查 &lt;code&gt;AnalogClock&lt;/code&gt; 是否具有正确的构造函数签名。</target>
        </trans-unit>
        <trans-unit id="fc9360e6a9694db19840df20dcd21ab49ff88f74" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;haveMuscles&lt;/code&gt; is not exported, only the &lt;code&gt;animalsHaveMuscles&lt;/code&gt; function that shares the same un-merged namespace can see the symbol. The &lt;code&gt;doAnimalsHaveMuscles&lt;/code&gt; function, even though it&amp;rsquo;s part of the merged &lt;code&gt;Animal&lt;/code&gt; namespace can not see this un-exported member.</source>
          <target state="translated">因为 &lt;code&gt;haveMuscles&lt;/code&gt; 不会导出，所以只有共享相同未合并名称空间的 &lt;code&gt;animalsHaveMuscles&lt;/code&gt; 函数才能看到该符号。该 &lt;code&gt;doAnimalsHaveMuscles&lt;/code&gt; 功能时，即使它的部分合并 &lt;code&gt;Animal&lt;/code&gt; 命名空间无法看到这个未导出的成员。</target>
        </trans-unit>
        <trans-unit id="889f24f65391ea32e9fe866488efa3356b72acf4" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;never&lt;/code&gt; is a subtype of every type, it is always omitted from union types and it is ignored in function return type inference as long as there are other types being returned.</source>
          <target state="translated">因为 &lt;code&gt;never&lt;/code&gt; 每种类型的子类型，所以只要返回其他类型，就总是从联合类型中将其忽略，并且在函数返回类型推论中将其忽略。</target>
        </trans-unit>
        <trans-unit id="b3b5c5e8091b38c11351f7ff855704d831cd693e" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;never&lt;/code&gt; is assignable to every type, a function returning &lt;code&gt;never&lt;/code&gt; can be used when a callback returning a more specific type is required:</source>
          <target state="translated">因为 &lt;code&gt;never&lt;/code&gt; 不能分配给每种类型，所以当需要返回更具体类型的回调时，可以使用 &lt;code&gt;never&lt;/code&gt; 返回的函数：</target>
        </trans-unit>
        <trans-unit id="860ec81e43c9b6e92f6dbbf8cdf9b9d2197d4f6a" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;onClickGood&lt;/code&gt; specifies its &lt;code&gt;this&lt;/code&gt; type as &lt;code&gt;void&lt;/code&gt;, it is legal to pass to &lt;code&gt;addClickListener&lt;/code&gt;. Of course, this also means that it can&amp;rsquo;t use &lt;code&gt;this.info&lt;/code&gt;. If you want both then you&amp;rsquo;ll have to use an arrow function:</source>
          <target state="translated">因为 &lt;code&gt;onClickGood&lt;/code&gt; &lt;code&gt;this&lt;/code&gt; 类型指定为 &lt;code&gt;void&lt;/code&gt; ，所以将其传递给 &lt;code&gt;addClickListener&lt;/code&gt; 是合法的。当然，这也意味着它不能使用 &lt;code&gt;this.info&lt;/code&gt; 。如果两者都需要，则必须使用箭头功能：</target>
        </trans-unit>
        <trans-unit id="153757f182ba0912b5361e2742146aeb4241a619" translate="yes" xml:space="preserve">
          <source>Because TypeScript is a structural type system, type parameters only affect the resulting type when consumed as part of the type of a member. For example,</source>
          <target state="translated">因为 TypeScript 是一个结构化的类型系统,所以类型参数只有在作为成员类型的一部分被消耗时才会影响到结果类型。比如说。</target>
        </trans-unit>
        <trans-unit id="a031100a59ee4b651a08813917a85230e2c2bcaf" translate="yes" xml:space="preserve">
          <source>Because TypeScript used to infer the type &lt;code&gt;BasicCalculator&lt;/code&gt; for each method in &lt;code&gt;BasicCalculator&lt;/code&gt; that returned &lt;code&gt;this&lt;/code&gt;, the type system would forget that it had &lt;code&gt;ScientificCalculator&lt;/code&gt; whenever using a &lt;code&gt;BasicCalculator&lt;/code&gt; method.</source>
          <target state="translated">由于打字稿用来推断类型 &lt;code&gt;BasicCalculator&lt;/code&gt; 在每个方法 &lt;code&gt;BasicCalculator&lt;/code&gt; 即返回 &lt;code&gt;this&lt;/code&gt; ，类型系统会忘记它有 &lt;code&gt;ScientificCalculator&lt;/code&gt; 每当使用 &lt;code&gt;BasicCalculator&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="b3b1d39859ec43b815d699d91662781b5301f06b" translate="yes" xml:space="preserve">
          <source>Because a Function Component is simply a JavaScript function, function overloads may be used here as well:</source>
          <target state="translated">因为函数组件只是一个简单的JavaScript函数,所以这里也可以使用函数重载。</target>
        </trans-unit>
        <trans-unit id="346e805975d898d144111246435e10f969746b37" translate="yes" xml:space="preserve">
          <source>Because dependent projects make use of &lt;code&gt;.d.ts&lt;/code&gt; files that are built from their dependencies, you&amp;rsquo;ll either have to check in certain build outputs &lt;em&gt;or&lt;/em&gt; build a project after cloning it before you can navigate the project in an editor without seeing spurious errors. We&amp;rsquo;re working on a behind-the-scenes .d.ts generation process that should be able to mitigate this, but for now we recommend informing developers that they should build after cloning.</source>
          <target state="translated">由于依赖项目使用从其依赖关系构建的 &lt;code&gt;.d.ts&lt;/code&gt; 文件，因此您必须检入某些构建输出&lt;em&gt;或&lt;/em&gt;在克隆后构建项目，然后才能在编辑器中浏览该项目而不会看到虚假错误。我们正在努力开发一种幕后.d.ts生成过程，该过程应能够缓解这种情况，但是目前，我们建议告知开发人员克隆后应该进行构建。</target>
        </trans-unit>
        <trans-unit id="83ecbcc6afccbb397b118fab2ee6414e3c837482" translate="yes" xml:space="preserve">
          <source>Because each &lt;code&gt;unique symbol&lt;/code&gt; has a completely separate identity, no two &lt;code&gt;unique symbol&lt;/code&gt; types are assignable or comparable to each other.</source>
          <target state="translated">因为每个 &lt;code&gt;unique symbol&lt;/code&gt; 都具有完全独立的标识，所以没有两个 &lt;code&gt;unique symbol&lt;/code&gt; 类型可分配或彼此可比。</target>
        </trans-unit>
        <trans-unit id="ce7c5c8de643b44139d21f506a256a1fa4c079dd" translate="yes" xml:space="preserve">
          <source>Because interfaces (and other object types) introduce a level of indirection and their full structure doesn&amp;rsquo;t need to be eagerly built out, TypeScript has no problem working with this structure.</source>
          <target state="translated">因为接口（和其他对象类型）引入了一个间接级别，并且不需要急切地构建它们的完整结构，所以TypeScript在使用这种结构时没有问题。</target>
        </trans-unit>
        <trans-unit id="f30f185f6397eb98d238c4bebb2ebc5adf9430be" translate="yes" xml:space="preserve">
          <source>Because it&amp;rsquo;s usually easy to turn a global library into a UMD library, very few popular libraries are still written in the global style. However, libraries that are small and require the DOM (or have &lt;em&gt;no&lt;/em&gt; dependencies) may still be global.</source>
          <target state="translated">因为将全局库转换为UMD库通常很容易，所以仍然很少有流行的库以全局样式编写。但是，较小且需要DOM（或&lt;em&gt;没有&lt;/em&gt;依赖性）的库可能仍是全局的。</target>
        </trans-unit>
        <trans-unit id="8323beb09423cac98a2130445e161c576b080307" translate="yes" xml:space="preserve">
          <source>Because of that, they are now included by default in the standard library.</source>
          <target state="translated">正因为如此,它们现在被默认包含在标准库中。</target>
        </trans-unit>
        <trans-unit id="78c12007f3b8d8a541217ea17e828d1c39d86708" translate="yes" xml:space="preserve">
          <source>Because the &lt;code&gt;switch&lt;/code&gt; is no longer exhaustive, TypeScript is aware that the function could sometimes return &lt;code&gt;undefined&lt;/code&gt;. If you have an explicit return type &lt;code&gt;number&lt;/code&gt;, then you will get an error that the return type is actually &lt;code&gt;number | undefined&lt;/code&gt;. However, this method is quite subtle and, besides, &lt;code&gt;--strictNullChecks&lt;/code&gt; does not always work with old code.</source>
          <target state="translated">因为 &lt;code&gt;switch&lt;/code&gt; 不再详尽，所以TypeScript知道该函数有时可能返回 &lt;code&gt;undefined&lt;/code&gt; 。如果您有一个明确的返回类型 &lt;code&gt;number&lt;/code&gt; ，那么您将收到一个错误，指出返回类型实际上是 &lt;code&gt;number | undefined&lt;/code&gt; 。但是，此方法非常微妙，而且 &lt;code&gt;--strictNullChecks&lt;/code&gt; 并不总是与旧代码一起使用。</target>
        </trans-unit>
        <trans-unit id="cef956693dc6ba68c2dd1bf8874b51293ed083ef" translate="yes" xml:space="preserve">
          <source>Because the best common type has to be chosen from the provided candidate types, there are some cases where types share a common structure, but no one type is the super type of all candidate types. For example:</source>
          <target state="translated">因为必须从提供的候选类型中选择最佳的共性类型,所以在某些情况下,有的类型具有共同的结构,但没有一个类型是所有候选类型的超级类型。比如说。</target>
        </trans-unit>
        <trans-unit id="61eeffa792a60ab404349a9470da23f0926e8080" translate="yes" xml:space="preserve">
          <source>Because the generic function is now constrained, it will no longer work over any and all types:</source>
          <target state="translated">因为通用函数现在受到了约束,它将不再对任何类型和所有类型进行工作。</target>
        </trans-unit>
        <trans-unit id="2aaed882fdf6dc6a4a05e269679bc56b985060ef" translate="yes" xml:space="preserve">
          <source>Because these two types of value-based elements are indistinguishable from each other in a JSX expression, first TS tries to resolve the expression as a Function Component using overload resolution. If the process succeeds, then TS finishes resolving the expression to its declaration. If the value fails to resolve as a Function Component, TS will then try to resolve it as a class component. If that fails, TS will report an error.</source>
          <target state="translated">由于这两类基于值的元素在JSX表达式中是无法区分的,所以首先TS尝试使用过载解析将表达式解析为函数组件。如果这个过程成功了,那么TS就完成了将表达式解析为其声明。如果该值不能作为函数组件解析,那么TS将尝试将其作为类组件解析。如果失败,TS将报告一个错误。</target>
        </trans-unit>
        <trans-unit id="1803d91fbdbc9a61174b895ce63bd9e9db8a1a69" translate="yes" xml:space="preserve">
          <source>Because we&amp;rsquo;ve captured &lt;code&gt;city&lt;/code&gt; from within its environment, we&amp;rsquo;re still able to access it despite the fact that the &lt;code&gt;if&lt;/code&gt; block finished executing.</source>
          <target state="translated">因为我们已经从环境中捕获了 &lt;code&gt;city&lt;/code&gt; ，所以尽管 &lt;code&gt;if&lt;/code&gt; 块已完成执行，我们仍然可以访问它。</target>
        </trans-unit>
        <trans-unit id="d29eaff4a22709cf598b50d66101efbf59839265" translate="yes" xml:space="preserve">
          <source>Before ES2015, Javascript used constructor functions instead of classes. The compiler supports this pattern and understands constructor functions as equivalent to ES2015 classes. The property inference rules described above work exactly the same way.</source>
          <target state="translated">在ES2015之前,Javascript使用构造函数而不是类。编译器支持这种模式,并将构造函数理解为等同于ES2015类。上面描述的属性推理规则的工作方式完全相同。</target>
        </trans-unit>
        <trans-unit id="5da503870a40cc51e10eea3a3855e0636fb12368" translate="yes" xml:space="preserve">
          <source>Before TypeScript 2.0, a module identifier was always assumed to be extension-less; for instance, given an import as &lt;code&gt;import d from &quot;./moduleA.js&quot;&lt;/code&gt;, the compiler looked up the definition of &lt;code&gt;&quot;moduleA.js&quot;&lt;/code&gt; in &lt;code&gt;./moduleA.js.ts&lt;/code&gt; or &lt;code&gt;./moduleA.js.d.ts&lt;/code&gt;. This made it hard to use bundling/loading tools like &lt;a href=&quot;https://github.com/systemjs/systemjs&quot;&gt;SystemJS&lt;/a&gt; that expect URI&amp;rsquo;s in their module identifier.</source>
          <target state="translated">在TypeScript 2.0之前，始终将模块标识符假定为无扩展名。例如，假设 &lt;code&gt;import d from &quot;./moduleA.js&quot;&lt;/code&gt; 导入了import d，则编译器会在 &lt;code&gt;./moduleA.js.ts&lt;/code&gt; 或 &lt;code&gt;./moduleA.js.d.ts&lt;/code&gt; 中查找 &lt;code&gt;&quot;moduleA.js&quot;&lt;/code&gt; 的定义。这使得很难使用像&lt;a href=&quot;https://github.com/systemjs/systemjs&quot;&gt;SystemJS&lt;/a&gt;这样的捆绑/加载工具，而这些工具期望模块标识符中包含URI。</target>
        </trans-unit>
        <trans-unit id="7118581b77027e58723abfe83ca47073c2beca97" translate="yes" xml:space="preserve">
          <source>Before we get to Browserify, let&amp;rsquo;s build our code out and add modules to the mix. This is the structure you&amp;rsquo;re more likely to use for a real app.</source>
          <target state="translated">在进入Browserify之前，让我们构建代码并将模块添加到组合中。这是您更可能用于真实应用程序的结构。</target>
        </trans-unit>
        <trans-unit id="d3fafb80e647f5908678c0a1365fa6a9b3b25a53" translate="yes" xml:space="preserve">
          <source>Bellow both &lt;code&gt;n&lt;/code&gt; and &lt;code&gt;m&lt;/code&gt; will be marked as unused, because their values are never &lt;em&gt;read&lt;/em&gt;. Previously TypeScript would only check whether their values were &lt;em&gt;referenced&lt;/em&gt;.</source>
          <target state="translated">在下面， &lt;code&gt;n&lt;/code&gt; 和 &lt;code&gt;m&lt;/code&gt; 都将标记为未使用，因为它们的值永远不会被&lt;em&gt;读取&lt;/em&gt;。以前，TypeScript仅检查其值是否被&lt;em&gt;引用&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="b1593ec79184963de3c26cd55f6cd6ff5fde3164" translate="yes" xml:space="preserve">
          <source>Below, we&amp;rsquo;ve consolidated the Validator implementations used in previous examples to only export a single named export from each module.</source>
          <target state="translated">下面，我们合并了先前示例中使用的Validator实现，以仅从每个模块中导出单个命名的export。</target>
        </trans-unit>
        <trans-unit id="23b1b090e17cb993e2e92ba109a6404125e1c084" translate="yes" xml:space="preserve">
          <source>Best common type</source>
          <target state="translated">最佳常见类型</target>
        </trans-unit>
        <trans-unit id="73f4d62437edf5f4e4d12a007397acc1aef2efe1" translate="yes" xml:space="preserve">
          <source>Better Module Visibility Rules</source>
          <target state="translated">更好的模块可见性规则</target>
        </trans-unit>
        <trans-unit id="24fe9a5afd90b3567ffa5a70e33cace7ce8a2cd6" translate="yes" xml:space="preserve">
          <source>Better Support for &lt;code&gt;never&lt;/code&gt;-Returning Functions</source>
          <target state="translated">更好地支持 &lt;code&gt;never&lt;/code&gt; 返回的功能</target>
        </trans-unit>
        <trans-unit id="21657adf3906ba19a9fc0bf5880e4ab0670a6b78" translate="yes" xml:space="preserve">
          <source>Better Type Inference</source>
          <target state="translated">更好的类型推理</target>
        </trans-unit>
        <trans-unit id="7d2959d47c022c161218042546a51da5d892926e" translate="yes" xml:space="preserve">
          <source>Better Unicode Support for Identifiers</source>
          <target state="translated">更好的Unicode标识符支持</target>
        </trans-unit>
        <trans-unit id="9a0ba3945bacbf9283dac7172d7a127f0967cb4d" translate="yes" xml:space="preserve">
          <source>Better checking for &lt;code&gt;null&lt;/code&gt;/&lt;code&gt;undefined&lt;/code&gt; in operands of expressions</source>
          <target state="translated">更好地检查表达式的操作数是否为 &lt;code&gt;null&lt;/code&gt; / &lt;code&gt;undefined&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1edbfa311bc15bdb82e37657789378148ae24f62" translate="yes" xml:space="preserve">
          <source>Better handling for namespace patterns in &lt;code&gt;.js&lt;/code&gt; files</source>
          <target state="translated">更好地处理 &lt;code&gt;.js&lt;/code&gt; 文件中的名称空间模式</target>
        </trans-unit>
        <trans-unit id="1459fb8ee8a9e746ee1ec8bc34a675600de96aa9" translate="yes" xml:space="preserve">
          <source>Better inference for literal types</source>
          <target state="translated">更好的字面类型推理</target>
        </trans-unit>
        <trans-unit id="948f70e8d9053f46439ba57d043632fa6e5a5de4" translate="yes" xml:space="preserve">
          <source>BigInt</source>
          <target state="translated">BigInt</target>
        </trans-unit>
        <trans-unit id="288d51c5150441fed0b9e86f5152123e527ee75c" translate="yes" xml:space="preserve">
          <source>BigInt support in TypeScript introduces a new primitive type called the &lt;code&gt;bigint&lt;/code&gt; (all lowercase). You can get a &lt;code&gt;bigint&lt;/code&gt; by calling the &lt;code&gt;BigInt()&lt;/code&gt; function or by writing out a BigInt literal by adding an &lt;code&gt;n&lt;/code&gt; to the end of any integer numeric literal:</source>
          <target state="translated">TypeScript对BigInt的支持引入了一种新的原始类型，称为 &lt;code&gt;bigint&lt;/code&gt; （全部小写）。您可以通过调用 &lt;code&gt;BigInt()&lt;/code&gt; 函数或通过在任何整数数字文字的末尾添加 &lt;code&gt;n&lt;/code&gt; 来写出BigInt文字来获取 &lt;code&gt;bigint&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="554ca025eac7b2c84da4d87e6d9f6fd09932aeac" translate="yes" xml:space="preserve">
          <source>BigInts are part of an upcoming proposal in ECMAScript that allow us to model theoretically arbitrarily large integers. TypeScript 3.2 brings type-checking for BigInts, as well as support for emitting BigInt literals when targeting &lt;code&gt;esnext&lt;/code&gt;.</source>
          <target state="translated">BigInts是ECMAScript中即将提出的提案的一部分，该提案使我们能够为理论上任意大的整数建模。TypeScript 3.2带来了对BigInts的类型检查，并支持在定位 &lt;code&gt;esnext&lt;/code&gt; 时发出BigInt文字。</target>
        </trans-unit>
        <trans-unit id="680e45e0d9641fb72fe09a5f60291f49ec52f51b" translate="yes" xml:space="preserve">
          <source>Block scoped</source>
          <target state="translated">块状的范围</target>
        </trans-unit>
        <trans-unit id="6a8c3370d98498723b46771881ba81defd0dc40c" translate="yes" xml:space="preserve">
          <source>Block-scoped variable capturing</source>
          <target state="translated">块状变量捕获</target>
        </trans-unit>
        <trans-unit id="a849fb31e66cbf4e00c81e17be0f996cdee6ecbd" translate="yes" xml:space="preserve">
          <source>Block-scoping</source>
          <target state="translated">Block-scoping</target>
        </trans-unit>
        <trans-unit id="b76ff4906f33c2dd97ddd929b9662ba8cac6174c" translate="yes" xml:space="preserve">
          <source>Boolean</source>
          <target state="translated">Boolean</target>
        </trans-unit>
        <trans-unit id="a34e54cea707257c0130f46138224a1c1962a392" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;for..of&lt;/code&gt; and &lt;code&gt;for..in&lt;/code&gt; statements iterate over lists; the values iterated on are different though, &lt;code&gt;for..in&lt;/code&gt; returns a list of &lt;em&gt;keys&lt;/em&gt; on the object being iterated, whereas &lt;code&gt;for..of&lt;/code&gt; returns a list of &lt;em&gt;values&lt;/em&gt; of the numeric properties of the object being iterated.</source>
          <target state="translated">无论 &lt;code&gt;for..of&lt;/code&gt; 和 &lt;code&gt;for..in&lt;/code&gt; 语句遍历列表; 但是，迭代的值是不同的， &lt;code&gt;for..in&lt;/code&gt; 返回要迭代的对象上的&lt;em&gt;键&lt;/em&gt;的列表，而 &lt;code&gt;for..of&lt;/code&gt; 返回要迭代的对象的数字属性的&lt;em&gt;值&lt;/em&gt;的列表。</target>
        </trans-unit>
        <trans-unit id="883409a532b5058d1cc5b8f4b490cb78e4d78575" translate="yes" xml:space="preserve">
          <source>Both CommonJS and AMD generally have the concept of an &lt;code&gt;exports&lt;/code&gt; object which contains all exports from a module.</source>
          <target state="translated">CommonJS和AMD通常都具有 &lt;code&gt;exports&lt;/code&gt; 对象的概念，其中包含模块中的所有导出。</target>
        </trans-unit>
        <trans-unit id="e51d223984b330914b72e271341f74aef8d2cd0b" translate="yes" xml:space="preserve">
          <source>Both of these dependencies will let TypeScript and webpack play well together. ts-loader helps Webpack compile your TypeScript code using the TypeScript&amp;rsquo;s standard configuration file named &lt;code&gt;tsconfig.json&lt;/code&gt;. source-map-loader uses any sourcemap outputs from TypeScript to inform webpack when generating &lt;em&gt;its own&lt;/em&gt; sourcemaps. This will allow you to debug your final output file as if you were debugging your original TypeScript source code.</source>
          <target state="translated">这两个依赖关系将使TypeScript和webpack一起很好地发挥作用。 ts-loader使用名为 &lt;code&gt;tsconfig.json&lt;/code&gt; 的TypeScript的标准配置文件帮助Webpack编译您的TypeScript代码。 source-map-loader会在生成&lt;em&gt;自己的&lt;/em&gt;源地图时使用TypeScript的任何源地图输出来通知webpack。这将允许您调试最终的输出文件，就像调试原始TypeScript源代码一样。</target>
        </trans-unit>
        <trans-unit id="8f6f50fe6a684e36f2680d1b1f0d995148104f1b" translate="yes" xml:space="preserve">
          <source>Breaking Changes</source>
          <target state="translated">打破性的变化</target>
        </trans-unit>
        <trans-unit id="b27e195ce4797e99f5340bc74096020036597226" translate="yes" xml:space="preserve">
          <source>Broadly speaking, the way you &lt;em&gt;structure&lt;/em&gt; your declaration file depends on how the library is consumed. There are many ways of offering a library for consumption in JavaScript, and you&amp;rsquo;ll need to write your declaration file to match it. This guide covers how to identify common library patterns, and how to write declaration files which correspond to that pattern.</source>
          <target state="translated">广义上讲，&lt;em&gt;构造&lt;/em&gt;声明文件的方式取决于使用库的方式。提供使用JavaScript使用的库的方法有很多种，您需要编写声明文件来匹配它。本指南介绍了如何识别常见的库模式，以及如何编写与该模式相对应的声明文件。</target>
        </trans-unit>
        <trans-unit id="ed81754147c265a661af47b5f96c56bae653c0d7" translate="yes" xml:space="preserve">
          <source>Browserify</source>
          <target state="translated">Browserify</target>
        </trans-unit>
        <trans-unit id="edcb28a656230c4acfe867a59a63fd0995d0aef6" translate="yes" xml:space="preserve">
          <source>Build Mode for TypeScript</source>
          <target state="translated">TypeScript的构建模式</target>
        </trans-unit>
        <trans-unit id="97e7d70d841f68a4ff5d6072efb212e8b37ee112" translate="yes" xml:space="preserve">
          <source>Build mode (see below) will automatically build the referenced project if needed</source>
          <target state="translated">构建模式(见下文),如果需要的话,会自动构建参考项目。</target>
        </trans-unit>
        <trans-unit id="9a92faaf499ddda5acb18453d8927f47fed81460" translate="yes" xml:space="preserve">
          <source>Build out-of-date projects in the correct order</source>
          <target state="translated">按照正确的顺序建立过时的项目</target>
        </trans-unit>
        <trans-unit id="2764e7dc64a6afa8f6572a70be9cc2ef88d207b2" translate="yes" xml:space="preserve">
          <source>Build tools</source>
          <target state="translated">构建工具</target>
        </trans-unit>
        <trans-unit id="75ec9400efe849c1db62787034008d1f92c2c91f" translate="yes" xml:space="preserve">
          <source>Build-Free Editing with Project References</source>
          <target state="translated">构建自由编辑与项目引用</target>
        </trans-unit>
        <trans-unit id="4af30b251537bff0e947429ed6b58b4a863bc66d" translate="yes" xml:space="preserve">
          <source>Building on that work, the new &lt;code&gt;Generator&lt;/code&gt; type is an &lt;code&gt;Iterator&lt;/code&gt; that always has both the &lt;code&gt;return&lt;/code&gt; and &lt;code&gt;throw&lt;/code&gt; methods present, and is also iterable.</source>
          <target state="translated">在此工作的基础上，新的 &lt;code&gt;Generator&lt;/code&gt; 类型是一个 &lt;code&gt;Iterator&lt;/code&gt; ，它总是同时存在 &lt;code&gt;return&lt;/code&gt; 和 &lt;code&gt;throw&lt;/code&gt; 方法，并且也是可迭代的。</target>
        </trans-unit>
        <trans-unit id="7a2e862f607c464ec5aa4c11cde1137378e9c2a2" translate="yes" xml:space="preserve">
          <source>Building your first TypeScript file</source>
          <target state="translated">建立你的第一个TypeScript文件</target>
        </trans-unit>
        <trans-unit id="03b24ded4facb2cf945d4c05f6eb1ab851a39a94" translate="yes" xml:space="preserve">
          <source>Builds this project and all of its dependencies specified by &lt;a href=&quot;project-references&quot;&gt;Project References&lt;/a&gt;. Note that this flag is not compatible with others on this page. See more &lt;a href=&quot;project-references&quot;&gt;here&lt;/a&gt;</source>
          <target state="translated">生成此项目及其由&lt;a href=&quot;project-references&quot;&gt;Project References&lt;/a&gt;指定的所有依赖项。请注意，此标志与此页面上的其他标志不兼容。&lt;a href=&quot;project-references&quot;&gt;在这里&lt;/a&gt;查看更多</target>
        </trans-unit>
        <trans-unit id="343555e3e4e0ac83e26882ec6baa2142ba94e980" translate="yes" xml:space="preserve">
          <source>Built-in &lt;em&gt;lib&lt;/em&gt; files are referenced in the same fashion as the &lt;code&gt;&quot;lib&quot;&lt;/code&gt; compiler option in &lt;em&gt;tsconfig.json&lt;/em&gt; (e.g. use &lt;code&gt;lib=&quot;es2015&quot;&lt;/code&gt; and not &lt;code&gt;lib=&quot;lib.es2015.d.ts&quot;&lt;/code&gt;, etc.).</source>
          <target state="translated">内置的&lt;em&gt;lib&lt;/em&gt;文件的引用方式与&lt;em&gt;tsconfig.json中&lt;/em&gt;的 &lt;code&gt;&quot;lib&quot;&lt;/code&gt; 编译器选项&lt;em&gt;相同&lt;/em&gt;（例如，使用 &lt;code&gt;lib=&quot;es2015&quot;&lt;/code&gt; 而不是 &lt;code&gt;lib=&quot;lib.es2015.d.ts&quot;&lt;/code&gt; 等）。</target>
        </trans-unit>
        <trans-unit id="baf48ef674c1f3f27e6a46bcb471b4b64069504c" translate="yes" xml:space="preserve">
          <source>Built-in Combinations</source>
          <target state="translated">内置组合</target>
        </trans-unit>
        <trans-unit id="f915eb393ecd85cb63e15dffe8826e1553f8b829" translate="yes" xml:space="preserve">
          <source>But &lt;em&gt;not&lt;/em&gt;</source>
          <target state="translated">但&lt;em&gt;不是&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1b2b6d682a32e9471d3d56044de293812fad6102" translate="yes" xml:space="preserve">
          <source>But as an example of a place where conditional types are deferred - where they stick around instead of picking a branch - would be in the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7399465efb16f2292f334ce116d2782df394ded" translate="yes" xml:space="preserve">
          <source>But it&amp;rsquo;s more useful to have a general version.</source>
          <target state="translated">但是拥有通用版本会更有用。</target>
        </trans-unit>
        <trans-unit id="52aa7f7d640381262f44bf2422e0184ae5802614" translate="yes" xml:space="preserve">
          <source>But specifying defaults is more common for parameters, and getting defaults right with destructuring can be tricky. First of all, you need to remember to put the pattern before the default value.</source>
          <target state="translated">但是指定默认值是比较常见的参数,用解构法把默认值弄好是比较麻烦的。首先,你需要记得把模式放在默认值之前。</target>
        </trans-unit>
        <trans-unit id="5085629431a212a779f2b5de79ca5c3f88994593" translate="yes" xml:space="preserve">
          <source>But workaround of introducing the interface wasn&amp;rsquo;t intuitive for users. And in principle there really wasn&amp;rsquo;t anything wrong with the original version of &lt;code&gt;ValueOrArray&lt;/code&gt; that used &lt;code&gt;Array&lt;/code&gt; directly. If the compiler was a little bit &amp;ldquo;lazier&amp;rdquo; and only calculated the type arguments to &lt;code&gt;Array&lt;/code&gt; when necessary, then TypeScript could express these correctly.</source>
          <target state="translated">但是，对于用户而言，引入界面的解决方法并不直观。原则上，直接使用 &lt;code&gt;Array&lt;/code&gt; 的 &lt;code&gt;ValueOrArray&lt;/code&gt; 的原始版本确实没有任何问题。如果编译器有点&amp;ldquo;懒惰&amp;rdquo;，并且仅在必要时才计算 &lt;code&gt;Array&lt;/code&gt; 的类型参数，则TypeScript可以正确表达这些参数。</target>
        </trans-unit>
        <trans-unit id="4960285f41cfd516633e4d60d8fcdf547d96a1af" translate="yes" xml:space="preserve">
          <source>By Example</source>
          <target state="translated">通过举例说明</target>
        </trans-unit>
        <trans-unit id="56013fe0821df629b3c4ad53f4b6924be246e572" translate="yes" xml:space="preserve">
          <source>By Example: Classes</source>
          <target state="translated">通过实例。类</target>
        </trans-unit>
        <trans-unit id="6b36dc2d84d25fdd51b964cd61bedec7d9e60902" translate="yes" xml:space="preserve">
          <source>By Example: Global Functions</source>
          <target state="translated">通过示例。全局函数</target>
        </trans-unit>
        <trans-unit id="3744ba63d2d3cc6574aaf71d98c1674b39508a8a" translate="yes" xml:space="preserve">
          <source>By Example: Global Variables</source>
          <target state="translated">通过示例。全局变量</target>
        </trans-unit>
        <trans-unit id="eea9b1c9ef5abea178ee5d4cd53163ad4f035d14" translate="yes" xml:space="preserve">
          <source>By Example: Objects with Properties</source>
          <target state="translated">通过示例。具有属性的对象</target>
        </trans-unit>
        <trans-unit id="74283c34f93d05517451768bcffe2038c4e7a212" translate="yes" xml:space="preserve">
          <source>By Example: Organizing Types</source>
          <target state="translated">通过实例。组织类型</target>
        </trans-unit>
        <trans-unit id="786404ba943c8314507c329a9d6f9d54f3179127" translate="yes" xml:space="preserve">
          <source>By Example: Overloaded Functions</source>
          <target state="translated">通过示例。过载函数</target>
        </trans-unit>
        <trans-unit id="c20e92aa75ef55f57a42b723ab0f280766d7b7fe" translate="yes" xml:space="preserve">
          <source>By Example: Reusable Types (Interfaces)</source>
          <target state="translated">通过示例。可重复使用的类型(接口)</target>
        </trans-unit>
        <trans-unit id="7a1f49420a7b27a3ee7b0e838fa3b2dbec6f81a8" translate="yes" xml:space="preserve">
          <source>By Example: Reusable Types (Type Aliases)</source>
          <target state="translated">通过示例。可重复使用的类型(类型别名)</target>
        </trans-unit>
        <trans-unit id="a082a066e7a09d6b1c6e75f3176d5a38819ca5b2" translate="yes" xml:space="preserve">
          <source>By default &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt; are subtypes of all other types. That means you can assign &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt; to something like &lt;code&gt;number&lt;/code&gt;.</source>
          <target state="translated">默认情况下， &lt;code&gt;null&lt;/code&gt; 和 &lt;code&gt;undefined&lt;/code&gt; 是所有其他类型的子类型。这意味着你可以指定 &lt;code&gt;null&lt;/code&gt; 和 &lt;code&gt;undefined&lt;/code&gt; 的东西像 &lt;code&gt;number&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="88529c44919e2de860ade6d72375e6a6ee709e4e" translate="yes" xml:space="preserve">
          <source>By default AMD modules are generated anonymous. This can lead to problems when other tools are used to process the resulting modules like a bundlers (e.g. &lt;code&gt;r.js&lt;/code&gt;).</source>
          <target state="translated">默认情况下，AMD模块是匿名生成的。当使用其他工具来处理生成的模块（例如 &lt;code&gt;r.js&lt;/code&gt; ）（例如r.js）时，这可能会导致问题。</target>
        </trans-unit>
        <trans-unit id="4c715e4fe44b99c0302712a9e167af08e84c2d13" translate="yes" xml:space="preserve">
          <source>By default AMD modules are generated anonymous. This can lead to problems when other tools are used to process the resulting modules, such as bundlers (e.g. &lt;code&gt;r.js&lt;/code&gt;).</source>
          <target state="translated">默认情况下，AMD模块是匿名生成的。当使用其他工具来处理生成的模块时，例如 &lt;code&gt;r.js&lt;/code&gt; （例如r.js），这可能会导致问题。</target>
        </trans-unit>
        <trans-unit id="f4d87e4e57028fc486e676c2ecdd8c6471f91d0c" translate="yes" xml:space="preserve">
          <source>By default all &lt;em&gt;visible&lt;/em&gt; &amp;ldquo;&lt;code&gt;@types&lt;/code&gt;&amp;rdquo; packages are included in your compilation. Packages in &lt;code&gt;node_modules/@types&lt;/code&gt; of any enclosing folder are considered &lt;em&gt;visible&lt;/em&gt;; specifically, that means packages within &lt;code&gt;./node_modules/@types/&lt;/code&gt;, &lt;code&gt;../node_modules/@types/&lt;/code&gt;, &lt;code&gt;../../node_modules/@types/&lt;/code&gt;, and so on.</source>
          <target state="translated">默认情况下，所有&lt;em&gt;可见的&lt;/em&gt; &amp;ldquo; &lt;code&gt;@types&lt;/code&gt; &amp;rdquo;包都包含在您的编译中。任何封闭文件夹的 &lt;code&gt;node_modules/@types&lt;/code&gt; 的软件包都被视为&lt;em&gt;可见&lt;/em&gt;；具体而言，这意味着包装内 &lt;code&gt;./node_modules/@types/&lt;/code&gt; ， &lt;code&gt;../node_modules/@types/&lt;/code&gt; ， &lt;code&gt;../../node_modules/@types/&lt;/code&gt; ，等等。</target>
        </trans-unit>
        <trans-unit id="e369ee47538940ad2b625bd062454fb84b462ef8" translate="yes" xml:space="preserve">
          <source>By default the TypeScript compiler does not report any errors in .js files including using &lt;code&gt;--allowJs&lt;/code&gt;. With TypeScript 2.3 type-checking errors can also be reported in &lt;code&gt;.js&lt;/code&gt; files with &lt;code&gt;--checkJs&lt;/code&gt;.</source>
          <target state="translated">默认情况下，TypeScript编译器不会报告.js文件中的任何错误，包括使用 &lt;code&gt;--allowJs&lt;/code&gt; 。使用TypeScript 2.3时，也可以使用 &lt;code&gt;--checkJs&lt;/code&gt; 在 &lt;code&gt;.js&lt;/code&gt; 文件中报告类型检查错误。</target>
        </trans-unit>
        <trans-unit id="e4e6fef05048e1036967e644248934ab3290242b" translate="yes" xml:space="preserve">
          <source>By default the output new line character is &lt;code&gt;\r\n&lt;/code&gt; on Windows based systems and &lt;code&gt;\n&lt;/code&gt; on *nix based systems. &lt;code&gt;--newLine&lt;/code&gt; command line flag allows overriding this behavior and specifying the new line character to be used in generated output files.</source>
          <target state="translated">默认情况下，在基于Windows的系统上输出换行符为 &lt;code&gt;\r\n&lt;/code&gt; 在基于* nix的系统上输出 &lt;code&gt;\n&lt;/code&gt; 。 &lt;code&gt;--newLine&lt;/code&gt; 命令行标志允许重写此行为，并指定在生成的输出文件中使用的换行符。</target>
        </trans-unit>
        <trans-unit id="2b8dc7f5bdcc1f900ed0076c9443382574f8ede2" translate="yes" xml:space="preserve">
          <source>By default the result of a JSX expression is typed as &lt;code&gt;any&lt;/code&gt;. You can customize the type by specifying the &lt;code&gt;JSX.Element&lt;/code&gt; interface. However, it is not possible to retrieve type information about the element, attributes or children of the JSX from this interface. It is a black box.</source>
          <target state="translated">默认情况下，JSX表达式的结果键入为 &lt;code&gt;any&lt;/code&gt; 。您可以通过指定 &lt;code&gt;JSX.Element&lt;/code&gt; 接口来自定义类型。但是，无法从此接口检索有关JSX的元素，属性或子级的类型信息。这是一个黑匣子。</target>
        </trans-unit>
        <trans-unit id="ab2b32ff0e315d45d6fc02e2a6cbedac511ef9df" translate="yes" xml:space="preserve">
          <source>By default the type of &lt;code&gt;this&lt;/code&gt; inside a function is &lt;code&gt;any&lt;/code&gt;. Starting with TypeScript 2.0, you can provide an explicit &lt;code&gt;this&lt;/code&gt; parameter. &lt;code&gt;this&lt;/code&gt; parameters are fake parameters that come first in the parameter list of a function:</source>
          <target state="translated">默认情况下，类型 &lt;code&gt;this&lt;/code&gt; 函数里面 &lt;code&gt;any&lt;/code&gt; 。从TypeScript 2.0开始，您可以提供一个明确的 &lt;code&gt;this&lt;/code&gt; 参数。 &lt;code&gt;this&lt;/code&gt; 参数是伪造的参数，它们首先出现在函数的参数列表中：</target>
        </trans-unit>
        <trans-unit id="b1b20c9a3a0cc7d25cfbb8affbd8cc2de8f4531f" translate="yes" xml:space="preserve">
          <source>By default with these settings, when we run &lt;code&gt;tsc&lt;/code&gt;, TypeScript will look for a file called &lt;code&gt;.tsbuildinfo&lt;/code&gt; in the output directory (&lt;code&gt;./lib&lt;/code&gt;). If &lt;code&gt;./lib/.tsbuildinfo&lt;/code&gt; doesn&amp;rsquo;t exist, it&amp;rsquo;ll be generated. But if it does, &lt;code&gt;tsc&lt;/code&gt; will try to use that file to incrementally type-check and update our output files.</source>
          <target state="translated">默认情况下，使用这些设置，当我们运行 &lt;code&gt;tsc&lt;/code&gt; 时，TypeScript将在输出目录（ &lt;code&gt;./lib&lt;/code&gt; ）中查找名为 &lt;code&gt;.tsbuildinfo&lt;/code&gt; 的文件。如果 &lt;code&gt;./lib/.tsbuildinfo&lt;/code&gt; 不存在，它将生成。但是，如果这样做， &lt;code&gt;tsc&lt;/code&gt; 将尝试使用该文件进行增量类型检查并更新我们的输出文件。</target>
        </trans-unit>
        <trans-unit id="978c0bcb7dd8270885bef9e6f191062a2f183d1b" translate="yes" xml:space="preserve">
          <source>By default, TypeScript assumes that &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt; are in the domain of every type. That means anything declared with the type &lt;code&gt;number&lt;/code&gt; could be &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt;. Since &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt; are such a frequent source of bugs in JavaScript and TypeScript, TypeScript has the &lt;code&gt;strictNullChecks&lt;/code&gt; option to spare you the stress of worrying about these issues.</source>
          <target state="translated">默认情况下，TypeScript假定 &lt;code&gt;null&lt;/code&gt; 和 &lt;code&gt;undefined&lt;/code&gt; 在每种类型的域中。这意味着用类型 &lt;code&gt;number&lt;/code&gt; 声明的任何内容都可以为 &lt;code&gt;null&lt;/code&gt; 或 &lt;code&gt;undefined&lt;/code&gt; 。由于 &lt;code&gt;null&lt;/code&gt; 和 &lt;code&gt;undefined&lt;/code&gt; 是JavaScript和TypeScript中经常出现的错误来源，因此TypeScript具有 &lt;code&gt;strictNullChecks&lt;/code&gt; 选项，以免您担心这些问题。</target>
        </trans-unit>
        <trans-unit id="d2a8ae67117a0b9e1048859af200beff97bdb1a4" translate="yes" xml:space="preserve">
          <source>By default, enums begin numbering their members starting at &lt;code&gt;0&lt;/code&gt;. You can change this by manually setting the value of one of its members. For example, we can start the previous example at &lt;code&gt;1&lt;/code&gt; instead of &lt;code&gt;0&lt;/code&gt;:</source>
          <target state="translated">默认情况下，枚举从 &lt;code&gt;0&lt;/code&gt; 开始对其成员编号。您可以通过手动设置其成员之一的值来更改它。例如，我们可以从 &lt;code&gt;1&lt;/code&gt; 而不是 &lt;code&gt;0&lt;/code&gt; 开始上一个示例：</target>
        </trans-unit>
        <trans-unit id="132e01557f70ffea3b32aeb9180827e17d27b06d" translate="yes" xml:space="preserve">
          <source>By doing this, you can greatly improve build times, enforce logical separation between components, and organize your code in new and better ways.</source>
          <target state="translated">通过这样做,你可以大大改善构建时间,强制执行组件之间的逻辑分离,并以新的更好的方式组织你的代码。</target>
        </trans-unit>
        <trans-unit id="692f9bb4646bcb36f65c5f7ab233f8f2764f0cb4" translate="yes" xml:space="preserve">
          <source>By installing TypeScript&amp;rsquo;s Visual Studio plugins</source>
          <target state="translated">通过安装TypeScript的Visual Studio插件</target>
        </trans-unit>
        <trans-unit id="86eb4b62601e3e81ff1dca5cc4e6dbdc4a89a2c0" translate="yes" xml:space="preserve">
          <source>By invoking tsc with no input files and a -project (or just -p) command line option that specifies the path of a directory containing a tsconfig.json file.</source>
          <target state="translated">通过在没有输入文件的情况下调用 tsc,并在命令行选项-project (或只是-p)中指定一个包含 tsconfig.json 文件的目录路径。</target>
        </trans-unit>
        <trans-unit id="ad9887b67e7c7119b9c0b607afc13f555d0df339" translate="yes" xml:space="preserve">
          <source>By invoking tsc with no input files and a &lt;code&gt;--project&lt;/code&gt; (or just &lt;code&gt;-p&lt;/code&gt;) command line option that specifies the path of a directory containing a &lt;code&gt;tsconfig.json&lt;/code&gt; file, or a path to a valid &lt;code&gt;.json&lt;/code&gt; file containing the configurations.</source>
          <target state="translated">通过与没有输入的文件和一个调用TSC &lt;code&gt;--project&lt;/code&gt; （或只是 &lt;code&gt;-p&lt;/code&gt; ）的命令行选项指定包含一个目录的路径 &lt;code&gt;tsconfig.json&lt;/code&gt; 文件，或为一个有效的路径 &lt;code&gt;.json&lt;/code&gt; 包含的配置文件。</target>
        </trans-unit>
        <trans-unit id="3c63c6b34aecd8a89f4657217a7bc97d993bf39e" translate="yes" xml:space="preserve">
          <source>By invoking tsc with no input files, in which case the compiler searches for the &lt;code&gt;tsconfig.json&lt;/code&gt; file starting in the current directory and continuing up the parent directory chain.</source>
          <target state="translated">通过不使用任何输入文件的情况下调用tsc，在这种情况下，编译器将搜索从当前目录开始并沿父目录链向上的 &lt;code&gt;tsconfig.json&lt;/code&gt; 文件。</target>
        </trans-unit>
        <trans-unit id="e89553a08b737777f431dc9d9801f1465f3a4fb2" translate="yes" xml:space="preserve">
          <source>By invoking tsc with no input files, in which case the compiler searches for the tsconfig.json file starting in the current directory and continuing up the parent directory chain.</source>
          <target state="translated">通过在没有输入文件的情况下调用 tsc,在这种情况下,编译器会从当前目录开始搜索 tsconfig.json 文件,并沿着父目录链继续向上搜索。</target>
        </trans-unit>
        <trans-unit id="79537a92f4047372fecdfd37460ca2a8188a29b0" translate="yes" xml:space="preserve">
          <source>By just passing the &lt;code&gt;--pretty&lt;/code&gt; command line option, TypeScript gives more colorful output with context about where things are going wrong.</source>
          <target state="translated">通过仅传递 &lt;code&gt;--pretty&lt;/code&gt; 命令行选项，TypeScript可以提供有关问题出处的上下文的更多彩色输出。</target>
        </trans-unit>
        <trans-unit id="e52ec44ebc49650e959b28d0b5dbe4cdf8ee0312" translate="yes" xml:space="preserve">
          <source>By leveraging &lt;code&gt;rootDirs&lt;/code&gt; we can inform the compiler of this mapping and thereby allow it to safely resolve &lt;code&gt;./#{locale}/messages&lt;/code&gt;, even though the directory will never exist. For example, with the following &lt;code&gt;tsconfig.json&lt;/code&gt;:</source>
          <target state="translated">通过利用 &lt;code&gt;rootDirs&lt;/code&gt; ,我们可以将此映射通知编译器，从而使它可以安全地解析 &lt;code&gt;./#{locale}/messages&lt;/code&gt; ，即使该目录将永远不存在。例如，使用以下 &lt;code&gt;tsconfig.json&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="7a6554ec42c2340c5fe50c2d315a5a222a594fab" translate="yes" xml:space="preserve">
          <source>By now you&amp;rsquo;ve figured out that &lt;code&gt;var&lt;/code&gt; has some problems, which is precisely why &lt;code&gt;let&lt;/code&gt; statements were introduced. Apart from the keyword used, &lt;code&gt;let&lt;/code&gt; statements are written the same way &lt;code&gt;var&lt;/code&gt; statements are.</source>
          <target state="translated">到目前为止，您已经发现 &lt;code&gt;var&lt;/code&gt; 存在一些问题，这就是为什么引入 &lt;code&gt;let&lt;/code&gt; 语句的原因。除了使用关键字之外， &lt;code&gt;let&lt;/code&gt; 语句的编写方式与 &lt;code&gt;var&lt;/code&gt; 语句的编写方式相同。</target>
        </trans-unit>
        <trans-unit id="a8cb72c1385357bc15ce05b98a7efaf15553d757" translate="yes" xml:space="preserve">
          <source>By reading this guide, you&amp;rsquo;ll have the tools to write complex definition files that expose a friendly API surface. This guide focuses on module (or UMD) libraries because the options here are more varied.</source>
          <target state="translated">通过阅读本指南，您将拥有编写复杂定义文件的工具，这些文件暴露了友好的API表面。本指南重点介绍模块（或UMD）库，因为此处的选项更加多样。</target>
        </trans-unit>
        <trans-unit id="411c4003c83ae27481aabc4631e018c37321d319" translate="yes" xml:space="preserve">
          <source>By separating into multiple projects, you can greatly improve the speed of typechecking and compiling, reduce memory usage when using an editor, and improve enforcement of the logical groupings of your program.</source>
          <target state="translated">通过分离成多个项目,可以大大提高类型检查和编译的速度,减少使用编辑器时的内存占用,提高程序逻辑分组的执行力。</target>
        </trans-unit>
        <trans-unit id="3214b1c0cea1d0e9f41edbd469679a29258a29b8" translate="yes" xml:space="preserve">
          <source>By the way, note that whereas some languages (e.g. C# and Scala) require variance annotations (&lt;code&gt;out&lt;/code&gt;/&lt;code&gt;in&lt;/code&gt; or &lt;code&gt;+&lt;/code&gt;/&lt;code&gt;-&lt;/code&gt;), variance emerges naturally from the actual use of a type parameter within a generic type due to TypeScript&amp;rsquo;s structural type system.</source>
          <target state="translated">顺便说一句，请注意，尽管某些语言（例如C＃和Scala）需要差异注释（ &lt;code&gt;out&lt;/code&gt; / &lt;code&gt;in&lt;/code&gt; 或 &lt;code&gt;+&lt;/code&gt; / &lt;code&gt;-&lt;/code&gt; ），但是由于TypeScript的结构类型系统，在通用类型中实际使用类型参数自然会产生差异。</target>
        </trans-unit>
        <trans-unit id="ff2ff01863822bd01179d80d30eb7f560237e6bf" translate="yes" xml:space="preserve">
          <source>Cache tagged template objects in modules</source>
          <target state="translated">缓存模块中标记的模板对象</target>
        </trans-unit>
        <trans-unit id="3ca09b900f387b256b85a63942148d4d37afb51a" translate="yes" xml:space="preserve">
          <source>Calculator.ts</source>
          <target state="translated">Calculator.ts</target>
        </trans-unit>
        <trans-unit id="401d915f4e82bf6c954f6cd72e5e9f45a0aa5cb6" translate="yes" xml:space="preserve">
          <source>Callback Types</source>
          <target state="translated">回调类型</target>
        </trans-unit>
        <trans-unit id="fafd26147b30637f1273073910f82f95e1d409ec" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;showHello&lt;/code&gt; calls &lt;code&gt;sayHello&lt;/code&gt; to change the paragraph&amp;rsquo;s text. Now change your gulpfile to the following:</source>
          <target state="translated">调用 &lt;code&gt;showHello&lt;/code&gt; 会调用 &lt;code&gt;sayHello&lt;/code&gt; 来更改段落的文本。现在将您的gulpfile更改为以下内容：</target>
        </trans-unit>
        <trans-unit id="b5a615e5088a07823ba43f480f4662c6c1a80354" translate="yes" xml:space="preserve">
          <source>Calls to &lt;code&gt;define(...)&lt;/code&gt;</source>
          <target state="translated">调用 &lt;code&gt;define(...)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="54ab62e91bddb3f6354c13e8b487593b38248ac3" translate="yes" xml:space="preserve">
          <source>Can be used in a non-module file &lt;code&gt;global-script.ts&lt;/code&gt;:</source>
          <target state="translated">可以在非模块文件 &lt;code&gt;global-script.ts&lt;/code&gt; 中使用：</target>
        </trans-unit>
        <trans-unit id="4380ba68d466c9670378cbd5fc0514cb1373ac15" translate="yes" xml:space="preserve">
          <source>Case clause fall-throughs</source>
          <target state="translated">案件条款的穿插</target>
        </trans-unit>
        <trans-unit id="e7500c883cdd17fa4172ea83911ebf91a32625de" translate="yes" xml:space="preserve">
          <source>Casts</source>
          <target state="translated">Casts</target>
        </trans-unit>
        <trans-unit id="bcaa33a7ae44bd5042c37a9cdbea7f843b1cf7c8" translate="yes" xml:space="preserve">
          <source>Caveats</source>
          <target state="translated">Caveats</target>
        </trans-unit>
        <trans-unit id="3b3bc5f42ea5021b780ab4b12ba77a349aaacc40" translate="yes" xml:space="preserve">
          <source>Caveats for Project References</source>
          <target state="translated">项目参考资料的注意事项</target>
        </trans-unit>
        <trans-unit id="1c2ce6c0623a19e14dbf0dfa2aff6c6b8a60ed59" translate="yes" xml:space="preserve">
          <source>Certain targets may include a polyfill or BigInt-like runtime object. For those purposes you may want to add &lt;code&gt;esnext.bigint&lt;/code&gt; to the &lt;code&gt;lib&lt;/code&gt; setting in your compiler options.</source>
          <target state="translated">某些目标可能包括polyfill或类似BigInt的运行时对象。为此，您可能需要将 &lt;code&gt;esnext.bigint&lt;/code&gt; 添加到编译器选项中的 &lt;code&gt;lib&lt;/code&gt; 设置中。</target>
        </trans-unit>
        <trans-unit id="0d793fe93a13b689ec59340423e9412ead64313c" translate="yes" xml:space="preserve">
          <source>Changes include:</source>
          <target state="translated">变化包括:</target>
        </trans-unit>
        <trans-unit id="c3e20420d40f382739b91cf88de0439e6594790f" translate="yes" xml:space="preserve">
          <source>Changes to &lt;code&gt;@types/React&lt;/code&gt;</source>
          <target state="translated">对 &lt;code&gt;@types/React&lt;/code&gt; 更改</target>
        </trans-unit>
        <trans-unit id="8221b7b528304e76abf18d987bda46c6ee653964" translate="yes" xml:space="preserve">
          <source>Changing just the &lt;em&gt;internals&lt;/em&gt; in the implementation files required &lt;em&gt;typechecking&lt;/em&gt; the tests again, even though this wouldn&amp;rsquo;t ever cause new errors</source>
          <target state="translated">改变只是&lt;em&gt;内部&lt;/em&gt;在执行文件所需&lt;em&gt;类型检查&lt;/em&gt;再次测试，尽管这不会造成过新的错误</target>
        </trans-unit>
        <trans-unit id="e5d9c66f05e816b7f1607245dc26fd6d3d736699" translate="yes" xml:space="preserve">
          <source>Changing just the tests required typechecking the implementation again, even if nothing changed</source>
          <target state="translated">即使没有任何改变,只改变测试,也需要再次对实现进行类型检查,即使没有任何改变。</target>
        </trans-unit>
        <trans-unit id="2d270f4e0779e7abe44cf1c7ade9171d4da1e226" translate="yes" xml:space="preserve">
          <source>Checks for, or usage of, module loaders like &lt;code&gt;require&lt;/code&gt; or &lt;code&gt;define&lt;/code&gt;</source>
          <target state="translated">检查或使用模块加载器，例如 &lt;code&gt;require&lt;/code&gt; 或 &lt;code&gt;define&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e9de74e418fac1f9142ff12fe9c9f76d1ed611d6" translate="yes" xml:space="preserve">
          <source>Children Type Checking</source>
          <target state="translated">儿童类型检查</target>
        </trans-unit>
        <trans-unit id="2afdd953eb19ed2481028f5c1801be583a951e01" translate="yes" xml:space="preserve">
          <source>Choose &lt;strong&gt;File&lt;/strong&gt;</source>
          <target state="translated">选择&lt;strong&gt;档案&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a7a0d9877ea63ee92b17d066ea8709fa9a3bb445" translate="yes" xml:space="preserve">
          <source>Choose &lt;strong&gt;New Project&lt;/strong&gt; (Ctrl + Shift + N)</source>
          <target state="translated">选择&lt;strong&gt;新项目&lt;/strong&gt;（Ctrl + Shift + N）</target>
        </trans-unit>
        <trans-unit id="1fd5281fc9dbfe31531daf20b8c332f350b4edfb" translate="yes" xml:space="preserve">
          <source>Choosing a value of &amp;ldquo;insert&amp;rdquo; or &amp;ldquo;remove&amp;rdquo; also affects the format of auto-imports, extracted types, and other generated code provided by TypeScript services. Leaving the setting on its default value of &amp;ldquo;ignore&amp;rdquo; makes generated code match the semicolon preference detected in the current file.</source>
          <target state="translated">选择&amp;ldquo;插入&amp;rdquo;或&amp;ldquo;删除&amp;rdquo;的值还会影响自动导入的格式，提取的类型以及TypeScript服务提供的其他生成的代码。将设置保留为默认值&amp;ldquo; ignore&amp;rdquo;会使生成的代码与当前文件中检测到的分号首选项相匹配。</target>
        </trans-unit>
        <trans-unit id="78bc86498e55d8a5d31b0d503b4da787d8e95ab6" translate="yes" xml:space="preserve">
          <source>Circularity between configuration files is not allowed.</source>
          <target state="translated">配置文件之间不允许循环使用。</target>
        </trans-unit>
        <trans-unit id="41ff354b2b330bd1f8a0587675e43cb32a731f33" translate="yes" xml:space="preserve">
          <source>Class</source>
          <target state="translated">Class</target>
        </trans-unit>
        <trans-unit id="c0951e6f10fd3da585b65324801b21d429796cf4" translate="yes" xml:space="preserve">
          <source>Class Component</source>
          <target state="translated">类组件</target>
        </trans-unit>
        <trans-unit id="ed903b055db990734f20c5294ee8b8fe9164b593" translate="yes" xml:space="preserve">
          <source>Class Decorators</source>
          <target state="translated">班级装饰公司</target>
        </trans-unit>
        <trans-unit id="114686c97766613a29d4825a44b3554d85c66bb1" translate="yes" xml:space="preserve">
          <source>Class Field Mitigations</source>
          <target state="translated">班级的实地缓解措施</target>
        </trans-unit>
        <trans-unit id="970423396db9a5db3ab146030f36eab03c9bccf9" translate="yes" xml:space="preserve">
          <source>Class Types</source>
          <target state="translated">类别类型</target>
        </trans-unit>
        <trans-unit id="17339556e7ad7709847a75274febd591296e07e1" translate="yes" xml:space="preserve">
          <source>Class expressions</source>
          <target state="translated">类表达式</target>
        </trans-unit>
        <trans-unit id="ed1846afee3be21521286932b99e2aeae9e6414a" translate="yes" xml:space="preserve">
          <source>Classes</source>
          <target state="translated">Classes</target>
        </trans-unit>
        <trans-unit id="a84d6a1a8b04f068d6de8792f2128d31b00ac8e8" translate="yes" xml:space="preserve">
          <source>Classes and function declarations can be authored directly as default exports. Default export class and function declaration names are optional.</source>
          <target state="translated">类和函数声明可以直接作为默认的导出类和函数声明进行编写。默认的导出类和函数声明名称是可选的。</target>
        </trans-unit>
        <trans-unit id="d45b7fb00541f6a8767f301189945313b46aa644" translate="yes" xml:space="preserve">
          <source>Classes are namespaces in &lt;code&gt;.js&lt;/code&gt; files. This can be used to nest classes, for example:</source>
          <target state="translated">类是 &lt;code&gt;.js&lt;/code&gt; 文件中的名称空间。这可以用于嵌套类，例如：</target>
        </trans-unit>
        <trans-unit id="8b983fc3a70e6b758f289e140144ef55d05f6582" translate="yes" xml:space="preserve">
          <source>Classes work similarly to object literal types and interfaces with one exception: they have both a static and an instance type. When comparing two objects of a class type, only members of the instance are compared. Static members and constructors do not affect compatibility.</source>
          <target state="translated">类的工作原理与对象字面意义类型和接口类似,但有一个例外:它们有一个静态类型和一个实例类型。当比较一个类类型的两个对象时,只比较实例的成员。静态成员和构造函数不影响兼容性。</target>
        </trans-unit>
        <trans-unit id="eb3e378460b98ee4b6e31c2d2b4b1e98ab972d3c" translate="yes" xml:space="preserve">
          <source>Classes, functions, and object literals are namespaces</source>
          <target state="translated">类、函数和对象字形是命名空间</target>
        </trans-unit>
        <trans-unit id="130cd7fe33343e419f107596f21d6c9f9d976849" translate="yes" xml:space="preserve">
          <source>Classic</source>
          <target state="translated">Classic</target>
        </trans-unit>
        <trans-unit id="f6c75e6aaeff53723e2a1e6793923cd37ed98551" translate="yes" xml:space="preserve">
          <source>Cleaner output in &lt;code&gt;--watch&lt;/code&gt; mode</source>
          <target state="translated">在 &lt;code&gt;--watch&lt;/code&gt; 模式下更干净的输出</target>
        </trans-unit>
        <trans-unit id="33f49daf62d5f581a04097acf72f7a587d200db2" translate="yes" xml:space="preserve">
          <source>Code Generation for Modules</source>
          <target state="translated">模块的代码生成</target>
        </trans-unit>
        <trans-unit id="5aef28f388cc2b6d39bbacf158f6b9e94711ece9" translate="yes" xml:space="preserve">
          <source>Code generation</source>
          <target state="translated">代码生成</target>
        </trans-unit>
        <trans-unit id="87b36e1c52e858cb2c770a584f49971497c4d447" translate="yes" xml:space="preserve">
          <source>Code that&amp;rsquo;s impacted by the class fields change can get around the issue by converting field initializers to assignments in constructor bodies.</source>
          <target state="translated">受类字段更改影响的代码可以通过将字段初始化程序转换为构造函数主体中的分配来解决此问题。</target>
        </trans-unit>
        <trans-unit id="8d618575aa117c6b80915c9311258252626feb94" translate="yes" xml:space="preserve">
          <source>Colorization of JSX code in VS 2015</source>
          <target state="translated">VS 2015中JSX代码的色彩化</target>
        </trans-unit>
        <trans-unit id="fb53519c43ebafe25dcbd0027128dc98a8b8ab12" translate="yes" xml:space="preserve">
          <source>Comma-separated list of strings</source>
          <target state="translated">以逗号分隔的字符串列表</target>
        </trans-unit>
        <trans-unit id="1f955b144e5934e2a13c8a6e25bf74ab9af19e8c" translate="yes" xml:space="preserve">
          <source>Common Questions</source>
          <target state="translated">常见的问题</target>
        </trans-unit>
        <trans-unit id="095e91de81638c9fb4d8559305b99b20bbe45f1b" translate="yes" xml:space="preserve">
          <source>CommonJS / Node SimpleModule.js</source>
          <target state="translated">CommonJS/Node SimpleModule.js</target>
        </trans-unit>
        <trans-unit id="bda542b3ab64c958c7a9092f48843c2d942bdc34" translate="yes" xml:space="preserve">
          <source>CommonJS modules are supported</source>
          <target state="translated">支持通用JS模块</target>
        </trans-unit>
        <trans-unit id="49c7d204d4bf5859f005b121118317373b38a4db" translate="yes" xml:space="preserve">
          <source>CommonJS/Node.js-style imports of the form &lt;code&gt;var fs = require(&quot;fs&quot;);&lt;/code&gt;</source>
          <target state="translated">形式为 &lt;code&gt;var fs = require(&quot;fs&quot;);&lt;/code&gt; CommonJS / Node.js样式的导入；</target>
        </trans-unit>
        <trans-unit id="fcf7acb84f79d901460975c5fdc7458a15a93f19" translate="yes" xml:space="preserve">
          <source>Comparing two functions</source>
          <target state="translated">两种功能的比较</target>
        </trans-unit>
        <trans-unit id="5d60c7dd62fdcf4abcc61a6a7d335b7117968b4d" translate="yes" xml:space="preserve">
          <source>Compatibility</source>
          <target state="translated">Compatibility</target>
        </trans-unit>
        <trans-unit id="d6b8ebf2c598d92ddec51164751b02621841cd23" translate="yes" xml:space="preserve">
          <source>Compile a project given a valid configuration file.</source>
          <target state="translated">编译一个项目,给定一个有效的配置文件。</target>
        </trans-unit>
        <trans-unit id="bc74f0ec68df0086c27ed702abf06db93a06c411" translate="yes" xml:space="preserve">
          <source>Compiled with:</source>
          <target state="translated">汇编的是:</target>
        </trans-unit>
        <trans-unit id="34dce96703c9facc673665ace0f6e41d2baf12d1" translate="yes" xml:space="preserve">
          <source>Compiler Option</source>
          <target state="translated">编译器选项</target>
        </trans-unit>
        <trans-unit id="f05a88eb5583088cfb5f3af23ae435a9c43d6850" translate="yes" xml:space="preserve">
          <source>Compiler Options</source>
          <target state="translated">编译器选项</target>
        </trans-unit>
        <trans-unit id="819847cb3aeaa240fbb932fa94d563cc19eec903" translate="yes" xml:space="preserve">
          <source>Compiler Options in MSBuild</source>
          <target state="translated">MSBuild中的编译器选项</target>
        </trans-unit>
        <trans-unit id="e90bb90e5e03ec7e90a57bd240d9219ac649a200" translate="yes" xml:space="preserve">
          <source>Compiler Options in MSBuild: Mappings</source>
          <target state="translated">MSBuild中的编译器选项。Mappings</target>
        </trans-unit>
        <trans-unit id="4e625c081c57011a6a742bfd97d6371d46e1c009" translate="yes" xml:space="preserve">
          <source>Compiler Options in MSBuild: ToolsVersion</source>
          <target state="translated">MSBuild中的编译器选项。ToolsVersion</target>
        </trans-unit>
        <trans-unit id="c90111a236cc10e2295d1a4cb78fc2a7200d0283" translate="yes" xml:space="preserve">
          <source>Compiler Options in MSBuild: TypeScriptCompileBlocked</source>
          <target state="translated">MSBuild中的编译器选项。TypeScriptCompileBlocked</target>
        </trans-unit>
        <trans-unit id="630ca760deb5ffc09b9902125668d2e2290de0ec" translate="yes" xml:space="preserve">
          <source>Compiler options can be specified using MSBuild properties within an MSBuild project.</source>
          <target state="translated">编译器选项可以在MSBuild项目中使用MSBuild属性指定。</target>
        </trans-unit>
        <trans-unit id="93e477a43886859b1bbfebb3d31cc0e1afe3973d" translate="yes" xml:space="preserve">
          <source>Compiler options specified on the command line override those specified in the &lt;code&gt;tsconfig.json&lt;/code&gt; file.</source>
          <target state="translated">在命令行上指定的编译器选项将覆盖 &lt;code&gt;tsconfig.json&lt;/code&gt; 文件中指定的那些选项。</target>
        </trans-unit>
        <trans-unit id="121ebc6937d17411ed69a6c37b96c6c30daba6d8" translate="yes" xml:space="preserve">
          <source>Compiler supports configuring how to watch files and directories using the environment variables.</source>
          <target state="translated">编译器支持配置如何使用环境变量来观察文件和目录。</target>
        </trans-unit>
        <trans-unit id="25e701e70295cdeed377c2a897dc9eb65d813980" translate="yes" xml:space="preserve">
          <source>Compiles to exactly:</source>
          <target state="translated">编纂到完全。</target>
        </trans-unit>
        <trans-unit id="e358939ee8802319ad1e9d8583fade153122cd2d" translate="yes" xml:space="preserve">
          <source>Compiling &lt;code&gt;app.ts&lt;/code&gt; using &lt;code&gt;--noResolve&lt;/code&gt; should result in:</source>
          <target state="translated">使用 &lt;code&gt;--noResolve&lt;/code&gt; 编译 &lt;code&gt;app.ts&lt;/code&gt; 应该导致：</target>
        </trans-unit>
        <trans-unit id="f9f6b87f27d7b70599485207ca9ad09ebb893c0b" translate="yes" xml:space="preserve">
          <source>Compiling and running the output should result in the correct behavior on an ES3/ES5 engine.</source>
          <target state="translated">在ES3/ES5引擎上,编译和运行输出应该会产生正确的行为。</target>
        </trans-unit>
        <trans-unit id="45ad9c5360eb345b6e3abac1b97c83060143ba82" translate="yes" xml:space="preserve">
          <source>Compiling your code</source>
          <target state="translated">编译你的代码</target>
        </trans-unit>
        <trans-unit id="3049a2659da50c034aba15cbcd7a9e1060cf134b" translate="yes" xml:space="preserve">
          <source>Composite projects</source>
          <target state="translated">综合项目</target>
        </trans-unit>
        <trans-unit id="ca5e00120498b815c12de59fd45e93f8086a8bfc" translate="yes" xml:space="preserve">
          <source>Composition</source>
          <target state="translated">Composition</target>
        </trans-unit>
        <trans-unit id="83cafe53ded70f2997ef3800657948653907c039" translate="yes" xml:space="preserve">
          <source>Computed and constant members</source>
          <target state="translated">计算成员和常数成员</target>
        </trans-unit>
        <trans-unit id="38e65524c92dd7a22334161d17dd8cd47bc733c7" translate="yes" xml:space="preserve">
          <source>Computed properties</source>
          <target state="translated">计算出的属性</target>
        </trans-unit>
        <trans-unit id="9428f1236d3847420fd8cb9cd0a04ad850ff601f" translate="yes" xml:space="preserve">
          <source>Concatenate &lt;code&gt;AMD&lt;/code&gt; and &lt;code&gt;System&lt;/code&gt; modules with &lt;code&gt;--outFile&lt;/code&gt;</source>
          <target state="translated">用 &lt;code&gt;--outFile&lt;/code&gt; 连接 &lt;code&gt;AMD&lt;/code&gt; 和 &lt;code&gt;System&lt;/code&gt; 模块</target>
        </trans-unit>
        <trans-unit id="3b5e0753cd9e20392bcaed52137c783d4a9ddd51" translate="yes" xml:space="preserve">
          <source>Concatenate and emit output to single file. The order of concatenation is determined by the list of files passed to the compiler on the command line along with triple-slash references and imports. See &lt;a href=&quot;https://github.com/Microsoft/TypeScript/wiki/FAQ#how-do-i-control-file-ordering-in-combined-output---out-&quot;&gt;output file order documentation&lt;/a&gt; for more details.</source>
          <target state="translated">连接并输出到单个文件。串联顺序由命令行上传递给编译器的文件列表以及三斜杠引用和导入确定。有关更多详细信息，请参见&lt;a href=&quot;https://github.com/Microsoft/TypeScript/wiki/FAQ#how-do-i-control-file-ordering-in-combined-output---out-&quot;&gt;输出文件顺序文档&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8d387732801bd4a6ea409c7bad5379547b3bde5c" translate="yes" xml:space="preserve">
          <source>Conceptually, you might consider the type &lt;code&gt;[number, string]&lt;/code&gt; to be equivalent to the following declaration of &lt;code&gt;NumStrTuple&lt;/code&gt;:</source>
          <target state="translated">从概念上讲，您可能认为 &lt;code&gt;[number, string]&lt;/code&gt; 类型等效于以下 &lt;code&gt;NumStrTuple&lt;/code&gt; 声明：</target>
        </trans-unit>
        <trans-unit id="cc5885783b19275de55be53a8442d9638f3760ca" translate="yes" xml:space="preserve">
          <source>Conditional Types</source>
          <target state="translated">有条件的类型</target>
        </trans-unit>
        <trans-unit id="18754d6645b008e9cccf73f1f4d972ff5e83d7ff" translate="yes" xml:space="preserve">
          <source>Conditional types are particularly useful when combined with mapped types:</source>
          <target state="translated">条件类型在与映射类型相结合时特别有用。</target>
        </trans-unit>
        <trans-unit id="a91f85c89a26e57f7343ae39715ed71a281561e2" translate="yes" xml:space="preserve">
          <source>Conditional types can be nested to form a sequence of pattern matches that are evaluated in order:</source>
          <target state="translated">条件类型可以嵌套形成一个模式匹配序列,并按顺序进行评价。</target>
        </trans-unit>
        <trans-unit id="a8e0afa63b781a425483833f9aa183ceaf9ab905" translate="yes" xml:space="preserve">
          <source>Conditional types in which the checked type is a naked type parameter are called &lt;em&gt;distributive conditional types&lt;/em&gt;. Distributive conditional types are automatically distributed over union types during instantiation. For example, an instantiation of &lt;code&gt;T extends U ? X : Y&lt;/code&gt; with the type argument &lt;code&gt;A | B | C&lt;/code&gt; for &lt;code&gt;T&lt;/code&gt; is resolved as &lt;code&gt;(A extends U ? X : Y) | (B extends U ? X : Y) | (C extends U ? X : Y)&lt;/code&gt;.</source>
          <target state="translated">其中选中的类型为裸类型参数的&lt;em&gt;条件类型&lt;/em&gt;称为&lt;em&gt;分布式条件类型&lt;/em&gt;。实例化期间，分布条件类型自动在联合类型上分布。例如， &lt;code&gt;T extends U ? X : Y&lt;/code&gt; 的实例扩展了U？X：Y，类型参数为 &lt;code&gt;A | B | C&lt;/code&gt; 为 &lt;code&gt;T&lt;/code&gt; 被解析为 &lt;code&gt;(A extends U ? X : Y) | (B extends U ? X : Y) | (C extends U ? X : Y)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d0df65b2f0f0c2d6eb36f5ad9bffffc45bb73cf7" translate="yes" xml:space="preserve">
          <source>Configuration inheritance</source>
          <target state="translated">配置继承</target>
        </trans-unit>
        <trans-unit id="0cf99561f068c66c86d1639cb9577f23d61bf6ef" translate="yes" xml:space="preserve">
          <source>Configuration inheritance with &lt;code&gt;extends&lt;/code&gt;</source>
          <target state="translated">具有 &lt;code&gt;extends&lt;/code&gt; 配置继承</target>
        </trans-unit>
        <trans-unit id="ced1a4e9ff8bc70735fabd8ba078581258e51943" translate="yes" xml:space="preserve">
          <source>Configuring Watch</source>
          <target state="translated">配置手表</target>
        </trans-unit>
        <trans-unit id="1dc951f746dfbc3c750c7470abaf09a1940d201f" translate="yes" xml:space="preserve">
          <source>Configuring Watch: Background</source>
          <target state="translated">配置手表。背景</target>
        </trans-unit>
        <trans-unit id="cfdfb6d0adf0c6f64224be19c2696050ea66bf86" translate="yes" xml:space="preserve">
          <source>Configuring directory watching using environment variable &lt;code&gt;TSC_WATCHDIRECTORY&lt;/code&gt;</source>
          <target state="translated">使用环境变量 &lt;code&gt;TSC_WATCHDIRECTORY&lt;/code&gt; 配置目录监视</target>
        </trans-unit>
        <trans-unit id="f22e46f20a3414bdd5ff21017ac41439569be928" translate="yes" xml:space="preserve">
          <source>Configuring file watching using environment variable &lt;code&gt;TSC_WATCHFILE&lt;/code&gt;</source>
          <target state="translated">使用环境变量 &lt;code&gt;TSC_WATCHFILE&lt;/code&gt; 配置文件监视</target>
        </trans-unit>
        <trans-unit id="17d698cd217deceb13be84ca6f6626fed1b6ab6f" translate="yes" xml:space="preserve">
          <source>Confusingly, the colon here does &lt;em&gt;not&lt;/em&gt; indicate the type. The type, if you specify it, still needs to be written after the entire destructuring:</source>
          <target state="translated">令人困惑的是，这里的冒号&lt;em&gt;没有&lt;/em&gt;指出类型。如果指定了类型，则在整个解构之后仍需要编写类型：</target>
        </trans-unit>
        <trans-unit id="89f0f2bf53179367a5dd94383df864d838cb31c8" translate="yes" xml:space="preserve">
          <source>Congrats you&amp;rsquo;ve built your own .NET Core project with a TypeScript frontend.</source>
          <target state="translated">恭喜，您已经使用TypeScript前端构建了自己的.NET Core项目。</target>
        </trans-unit>
        <trans-unit id="941a22f7b9c2d7277c983fd34ff491234fe4dbe8" translate="yes" xml:space="preserve">
          <source>Consider a function that creates a new &lt;code&gt;HTMLElement&lt;/code&gt;, calling it with no arguments generates a &lt;code&gt;Div&lt;/code&gt;; you can optionally pass a list of children as well. Previously you would have to define it as:</source>
          <target state="translated">考虑一个创建新 &lt;code&gt;HTMLElement&lt;/code&gt; 的函数，不带任何参数的调用将生成一个 &lt;code&gt;Div&lt;/code&gt; ；您也可以选择传递孩子列表。以前，您必须将其定义为：</target>
        </trans-unit>
        <trans-unit id="9a93950d7261d2e851d7f697ab5cb3ac7485af4e" translate="yes" xml:space="preserve">
          <source>Consider a simple calculator implementation defined in module &lt;code&gt;Calculator.ts&lt;/code&gt;. The module also exports a helper function to test the calculator functionality by passing a list of input strings and writing the result at the end.</source>
          <target state="translated">考虑在模块 &lt;code&gt;Calculator.ts&lt;/code&gt; 中定义的简单计算器实现。该模块还通过传递输入字符串列表并在最后写入结果，导出一个辅助函数来测试计算器功能。</target>
        </trans-unit>
        <trans-unit id="64b47866222baeccb4c64149b4ef01b8e0a587f3" translate="yes" xml:space="preserve">
          <source>Consider an internationalization scenario where a build tool automatically generates locale specific bundles by interpolating a special path token, say &lt;code&gt;#{locale}&lt;/code&gt;, as part of a relative module path such as &lt;code&gt;./#{locale}/messages&lt;/code&gt;. In this hypothetical setup the tool enumerates supported locales, mapping the abstracted path into &lt;code&gt;./zh/messages&lt;/code&gt;, &lt;code&gt;./de/messages&lt;/code&gt;, and so forth.</source>
          <target state="translated">考虑一个国际化方案，在该方案中，构建工具通过内插特殊路径标记（例如 &lt;code&gt;#{locale}&lt;/code&gt; ）作为相对模块路径（例如 &lt;code&gt;./#{locale}/messages&lt;/code&gt; )的一部分，自动生成特定于区域设置的包。在这个假设的设置工具枚举支持的语言环境，绘制抽象路径进入 &lt;code&gt;./zh/messages&lt;/code&gt; ， &lt;code&gt;./de/messages&lt;/code&gt; ，等等。</target>
        </trans-unit>
        <trans-unit id="e51d52c45ed3cf02e41cacc5bac70bcc7582c3f8" translate="yes" xml:space="preserve">
          <source>Consider the following example in which &lt;code&gt;Animal&lt;/code&gt; is the supertype of &lt;code&gt;Dog&lt;/code&gt; and &lt;code&gt;Cat&lt;/code&gt;:</source>
          <target state="translated">考虑下面的示例，其中 &lt;code&gt;Animal&lt;/code&gt; 是 &lt;code&gt;Dog&lt;/code&gt; 和 &lt;code&gt;Cat&lt;/code&gt; 的超类型：</target>
        </trans-unit>
        <trans-unit id="75e291169a2ebb63c935a5de7382990c0513d618" translate="yes" xml:space="preserve">
          <source>Consider:</source>
          <target state="translated">Consider:</target>
        </trans-unit>
        <trans-unit id="56d0232c998d778ef55ad35e83c8072f0d14ad7f" translate="yes" xml:space="preserve">
          <source>Const</source>
          <target state="translated">Const</target>
        </trans-unit>
        <trans-unit id="3a99b4ee5816a7cb6e3ef98324d960dc2e81d981" translate="yes" xml:space="preserve">
          <source>Const enums can only use constant enum expressions and unlike regular enums they are completely removed during compilation. Const enum members are inlined at use sites. This is possible since const enums cannot have computed members.</source>
          <target state="translated">Const enums只能使用常量enum表达式,与普通enum不同的是,它们在编译过程中会被完全删除。Const enum成员在使用站点中是内联的。这是可能的,因为 const enums 不能有计算成员。</target>
        </trans-unit>
        <trans-unit id="fb4e962186bdd37258f8b448774e2dcc2ffcf28a" translate="yes" xml:space="preserve">
          <source>Constant-named properties</source>
          <target state="translated">常量命名的属性</target>
        </trans-unit>
        <trans-unit id="52e68a873a2be3470675b9ee933b98d781ae7fef" translate="yes" xml:space="preserve">
          <source>Constraints</source>
          <target state="translated">Constraints</target>
        </trans-unit>
        <trans-unit id="d14be1865dab7ff31185f4ebfd1097f17695a8ad" translate="yes" xml:space="preserve">
          <source>Constructor functions</source>
          <target state="translated">构造函数</target>
        </trans-unit>
        <trans-unit id="b457798406732b22f251fa45881744c1f45d717e" translate="yes" xml:space="preserve">
          <source>Constructor functions are equivalent to classes</source>
          <target state="translated">构造函数等同于类</target>
        </trans-unit>
        <trans-unit id="b78d1b6cb187422161c01ee1e5d55ae78d30cf52" translate="yes" xml:space="preserve">
          <source>ConstructorParameters&amp;lt;T&amp;gt;</source>
          <target state="translated">ConstructorParameters&amp;lt;T&amp;gt;</target>
        </trans-unit>
        <trans-unit id="da51e1fa96b8ea9420b5fa91983ad6d946a019bc" translate="yes" xml:space="preserve">
          <source>Constructs a tuple type of the types of the parameters of a function type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">构造函数类型 &lt;code&gt;T&lt;/code&gt; 的参数类型的元组类型。</target>
        </trans-unit>
        <trans-unit id="d79c41aef449a13b15632406dd45cb3296e79353" translate="yes" xml:space="preserve">
          <source>Constructs a type by excluding &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt; from &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">通过从 &lt;code&gt;T&lt;/code&gt; 中排除 &lt;code&gt;null&lt;/code&gt; 和 &lt;code&gt;undefined&lt;/code&gt; 来构造类型。</target>
        </trans-unit>
        <trans-unit id="8d9a660daa90148f4ac3004bd45d9aa896dbca1c" translate="yes" xml:space="preserve">
          <source>Constructs a type by excluding from &lt;code&gt;T&lt;/code&gt; all properties that are assignable to &lt;code&gt;U&lt;/code&gt;.</source>
          <target state="translated">通过从 &lt;code&gt;T&lt;/code&gt; 排除所有可分配给 &lt;code&gt;U&lt;/code&gt; 的属性来构造类型。</target>
        </trans-unit>
        <trans-unit id="534a3be9726f529289895ca42ccc7f72d9c3024c" translate="yes" xml:space="preserve">
          <source>Constructs a type by extracting from &lt;code&gt;T&lt;/code&gt; all properties that are assignable to &lt;code&gt;U&lt;/code&gt;.</source>
          <target state="translated">通过从 &lt;code&gt;T&lt;/code&gt; 中提取可分配给 &lt;code&gt;U&lt;/code&gt; 的所有属性来构造类型。</target>
        </trans-unit>
        <trans-unit id="3e405f5b40b51987ceb9ba1254eee89e3f48777c" translate="yes" xml:space="preserve">
          <source>Constructs a type by picking all properties from &lt;code&gt;T&lt;/code&gt; and then removing &lt;code&gt;K&lt;/code&gt;.</source>
          <target state="translated">通过从 &lt;code&gt;T&lt;/code&gt; 选取所有属性然后删除 &lt;code&gt;K&lt;/code&gt; 来构造一个类型。</target>
        </trans-unit>
        <trans-unit id="13581efb3c161daf55efaa641c95a2937e6fa92d" translate="yes" xml:space="preserve">
          <source>Constructs a type by picking the set of properties &lt;code&gt;K&lt;/code&gt; from &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">通过从 &lt;code&gt;T&lt;/code&gt; 拾取属性 &lt;code&gt;K&lt;/code&gt; 的集合来构造类型。</target>
        </trans-unit>
        <trans-unit id="9fa9c5cf9d32c720825d39df29969f2f2dfdb044" translate="yes" xml:space="preserve">
          <source>Constructs a type consisting of all properties of &lt;code&gt;T&lt;/code&gt; set to required.</source>
          <target state="translated">构造一个由 &lt;code&gt;T&lt;/code&gt; 的所有属性设置为required的类型。</target>
        </trans-unit>
        <trans-unit id="8af78f1563236125ebb587f0510bfdfbb33bcfd1" translate="yes" xml:space="preserve">
          <source>Constructs a type consisting of the instance type of a constructor function type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">构造一个由构造函数 &lt;code&gt;T&lt;/code&gt; 的实例类型组成的类型。</target>
        </trans-unit>
        <trans-unit id="67178f246747dfdb076d24fd6fe244d35eea9de7" translate="yes" xml:space="preserve">
          <source>Constructs a type consisting of the return type of function &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">构造一个由函数 &lt;code&gt;T&lt;/code&gt; 的返回类型组成的类型。</target>
        </trans-unit>
        <trans-unit id="b92a41e86aee02470adc5b04c55124c13aaff3f2" translate="yes" xml:space="preserve">
          <source>Constructs a type with a set of properties &lt;code&gt;K&lt;/code&gt; of type &lt;code&gt;T&lt;/code&gt;. This utility can be used to map the properties of a type to another type.</source>
          <target state="translated">构造一个类型为 &lt;code&gt;T&lt;/code&gt; 的属性 &lt;code&gt;K&lt;/code&gt; 的类型。该实用程序可用于将一个类型的属性映射到另一个类型。</target>
        </trans-unit>
        <trans-unit id="87140e5d46947bf6adcacabd45f115a7d1fa950d" translate="yes" xml:space="preserve">
          <source>Constructs a type with all properties of &lt;code&gt;T&lt;/code&gt; set to &lt;code&gt;readonly&lt;/code&gt;, meaning the properties of the constructed type cannot be reassigned.</source>
          <target state="translated">构造一个 &lt;code&gt;T&lt;/code&gt; 的所有属性都设置为 &lt;code&gt;readonly&lt;/code&gt; 的类型，这意味着无法重新分配所构造类型的属性。</target>
        </trans-unit>
        <trans-unit id="6638ebe736931ecdde61f721cb96423f589cf127" translate="yes" xml:space="preserve">
          <source>Constructs a type with all properties of &lt;code&gt;T&lt;/code&gt; set to optional. This utility will return a type that represents all subsets of a given type.</source>
          <target state="translated">构造一个类型，将 &lt;code&gt;T&lt;/code&gt; 的所有属性设置为可选。该实用程序将返回一个表示给定类型的所有子集的类型。</target>
        </trans-unit>
        <trans-unit id="0cd2ae0ee1c90002e81a2a4c5b16f430d5eb5d5d" translate="yes" xml:space="preserve">
          <source>Consumer.ts</source>
          <target state="translated">Consumer.ts</target>
        </trans-unit>
        <trans-unit id="19643388856c2476ec9508c66a7a7a22828effd3" translate="yes" xml:space="preserve">
          <source>Consumers of your module should have as little friction as possible when using things that you export. Adding too many levels of nesting tends to be cumbersome, so think carefully about how you want to structure things.</source>
          <target state="translated">你的模块的消费者在使用你导出的东西时,应该尽可能地减少摩擦。添加太多层次的嵌套往往会很繁琐,所以要仔细思考你想要的东西的结构方式。</target>
        </trans-unit>
        <trans-unit id="9e33338e8781d70a603018c5dde7772e8b7ed456" translate="yes" xml:space="preserve">
          <source>Consuming</source>
          <target state="translated">Consuming</target>
        </trans-unit>
        <trans-unit id="1e2af544c5c4ac1500ff8f4ed22cff22ab2d98d9" translate="yes" xml:space="preserve">
          <source>Consuming Dependencies</source>
          <target state="translated">消耗性依存关系</target>
        </trans-unit>
        <trans-unit id="47a106946fb54af2e98e522133b69f05659ad46a" translate="yes" xml:space="preserve">
          <source>Consumption</source>
          <target state="translated">Consumption</target>
        </trans-unit>
        <trans-unit id="43d406bfbbaf7c88699230d3aef03ec04c451529" translate="yes" xml:space="preserve">
          <source>Consumption: Consuming</source>
          <target state="translated">消费。消耗量:消耗量</target>
        </trans-unit>
        <trans-unit id="a38855f0870542b992b5fff7c96208a8884a3edf" translate="yes" xml:space="preserve">
          <source>Consumption: Downloading</source>
          <target state="translated">消费。下载</target>
        </trans-unit>
        <trans-unit id="83a031c3bd99a755d80e5f7da09ef9648fc64a91" translate="yes" xml:space="preserve">
          <source>Consumption: Searching</source>
          <target state="translated">消费。搜索</target>
        </trans-unit>
        <trans-unit id="345009d8692863e53f52a509ffa69fac9f8c1193" translate="yes" xml:space="preserve">
          <source>Contextual Typing</source>
          <target state="translated">情境打字</target>
        </trans-unit>
        <trans-unit id="3890ff4bf80a096d2b98096a8e255fb1438bedf3" translate="yes" xml:space="preserve">
          <source>Contextual typing applies in many cases. Common cases include arguments to function calls, right hand sides of assignments, type assertions, members of object and array literals, and return statements. The contextual type also acts as a candidate type in best common type. For example:</source>
          <target state="translated">上下文类型化适用于许多情况。常见的情况包括函数调用的参数、任务的右边、类型断言、类型断言、对象和数组的成员和返回语句。上下文类型也作为最佳通用类型中的候选类型。例如。</target>
        </trans-unit>
        <trans-unit id="8991bf4cd6fcd903e6d8843735f575800e222a1b" translate="yes" xml:space="preserve">
          <source>Control flow analysis errors</source>
          <target state="translated">控制流程分析误差</target>
        </trans-unit>
        <trans-unit id="26b790f356c8f06689edb0506cd42e89fdf6a448" translate="yes" xml:space="preserve">
          <source>Control flow based type analysis</source>
          <target state="translated">基于控制流程的类型分析</target>
        </trans-unit>
        <trans-unit id="5608c55cda3285cb7a6c58d2a3953e2990e12df3" translate="yes" xml:space="preserve">
          <source>Control flow based type analysis is particularly relevant in &lt;code&gt;--strictNullChecks&lt;/code&gt; mode because nullable types are represented using union types:</source>
          <target state="translated">在 &lt;code&gt;--strictNullChecks&lt;/code&gt; 模式下，基于控制流的类型分析特别重要，因为可空类型使用联合类型表示：</target>
        </trans-unit>
        <trans-unit id="676622699467dc4bbf4104746ce06f96c9893b26" translate="yes" xml:space="preserve">
          <source>Conversely when importing:</source>
          <target state="translated">反之,在进口时。</target>
        </trans-unit>
        <trans-unit id="19762d1065d05ceddeccf92411a8f237f298697e" translate="yes" xml:space="preserve">
          <source>Correctly finding &lt;code&gt;moduleA&lt;/code&gt; as it was passed on the command-line.</source>
          <target state="translated">正确找到在命令行上传递的 &lt;code&gt;moduleA&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cebcad9c0d7aa9b4035b16adbfe6b459f9f243ec" translate="yes" xml:space="preserve">
          <source>Corresponding changes to add &lt;code&gt;LibraryManagedAttributes&lt;/code&gt; definition to the &lt;code&gt;JSX&lt;/code&gt; namespace in &lt;code&gt;@types/React&lt;/code&gt; are still needed. Keep in mind that there are some limitations.</source>
          <target state="translated">仍需要进行相应的更改以将 &lt;code&gt;LibraryManagedAttributes&lt;/code&gt; 定义添加到 &lt;code&gt;@types/React&lt;/code&gt; 中的 &lt;code&gt;JSX&lt;/code&gt; 名称空间。请记住，有一些限制。</target>
        </trans-unit>
        <trans-unit id="d4152f39c03c0eb9e811b3dbb568be8c9505d1aa" translate="yes" xml:space="preserve">
          <source>Create a &lt;code&gt;gulpfile.js&lt;/code&gt;</source>
          <target state="translated">创建一个 &lt;code&gt;gulpfile.js&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3021179bd177130f09b3a8316daec30a4b2b93d6" translate="yes" xml:space="preserve">
          <source>Create a &lt;code&gt;webpack.config.js&lt;/code&gt; file at the root of the project directory.</source>
          <target state="translated">在项目目录的根目录下创建一个 &lt;code&gt;webpack.config.js&lt;/code&gt; 文件。</target>
        </trans-unit>
        <trans-unit id="03be7fc935f815567fa5a4bac79cc78db732e8e0" translate="yes" xml:space="preserve">
          <source>Create a file called &lt;code&gt;src/greet.ts&lt;/code&gt;:</source>
          <target state="translated">创建一个名为 &lt;code&gt;src/greet.ts&lt;/code&gt; 的文件：</target>
        </trans-unit>
        <trans-unit id="a9ff776f31b78475f53c7d5b1e090dd761e922f3" translate="yes" xml:space="preserve">
          <source>Create a file in &lt;code&gt;src&lt;/code&gt; named &lt;code&gt;index.html&lt;/code&gt;:</source>
          <target state="translated">在 &lt;code&gt;src&lt;/code&gt; 中创建一个名为 &lt;code&gt;index.html&lt;/code&gt; 的文件：</target>
        </trans-unit>
        <trans-unit id="325cf797263cfffdce479b5e173823121f9d4d73" translate="yes" xml:space="preserve">
          <source>Create a new project</source>
          <target state="translated">创建一个新项目</target>
        </trans-unit>
        <trans-unit id="79b403f57bb09e035ae3515269845b15ce38bd27" translate="yes" xml:space="preserve">
          <source>Create a page</source>
          <target state="translated">创建一个页面</target>
        </trans-unit>
        <trans-unit id="647abbb31ccf904ba3c2c45c79357305334edf70" translate="yes" xml:space="preserve">
          <source>Create a webpack configuration file</source>
          <target state="translated">创建一个webpack配置文件</target>
        </trans-unit>
        <trans-unit id="2f4329f654175ad323032c9448bb383b6b11a42c" translate="yes" xml:space="preserve">
          <source>Currently &lt;code&gt;useDefineForClassFields&lt;/code&gt; is only available when targeting ES5 and upwards, since &lt;code&gt;Object.defineProperty&lt;/code&gt; doesn&amp;rsquo;t exist in ES3. To achieve similar checking for issues, you can create a seperate project that targets ES5 and uses &lt;code&gt;--noEmit&lt;/code&gt; to avoid a full build.</source>
          <target state="translated">当前 &lt;code&gt;useDefineForClassFields&lt;/code&gt; 仅在面向ES5及更高版本时可用，因为 &lt;code&gt;Object.defineProperty&lt;/code&gt; 中不存在Object.defineProperty。要实现类似的问题检查，您可以创建一个针对ES5的单独项目，并使用 &lt;code&gt;--noEmit&lt;/code&gt; 避免进行完整构建。</target>
        </trans-unit>
        <trans-unit id="e9cd15468b55ecfe136f817794b0238725c3ba6b" translate="yes" xml:space="preserve">
          <source>Custom JSX factories using &lt;code&gt;--reactNamespace&lt;/code&gt;</source>
          <target state="translated">使用 &lt;code&gt;--reactNamespace&lt;/code&gt; 的定制JSX工厂</target>
        </trans-unit>
        <trans-unit id="13be717a73cc5b208ba90837f91718dbedc0e5c7" translate="yes" xml:space="preserve">
          <source>D3.d.ts (simplified excerpt)</source>
          <target state="translated">D3.d.ts(简化节选)</target>
        </trans-unit>
        <trans-unit id="6be0205f470d4c7a15a776fec93f63444a3c1da3" translate="yes" xml:space="preserve">
          <source>DEPRECATED. Use &lt;code&gt;--jsxFactory&lt;/code&gt; instead.</source>
          <target state="translated">已淘汰。使用 &lt;code&gt;--jsxFactory&lt;/code&gt; 代替。</target>
        </trans-unit>
        <trans-unit id="5799536cf1759401f5d741ea6f17c63a6dec9bbc" translate="yes" xml:space="preserve">
          <source>DEPRECATED. Use &lt;code&gt;--outFile&lt;/code&gt; instead.</source>
          <target state="translated">已淘汰。请改用 &lt;code&gt;--outFile&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="59b53d5c8edc70418359a1b34ceac44b0e0760de" translate="yes" xml:space="preserve">
          <source>DEPRECATED. Use &lt;code&gt;--skipLibCheck&lt;/code&gt; instead.</source>
          <target state="translated">已淘汰。请改用 &lt;code&gt;--skipLibCheck&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4c8569d62477c3f3a8139ad175f1b65dec4c78eb" translate="yes" xml:space="preserve">
          <source>DOM Changes</source>
          <target state="translated">DOM的变化</target>
        </trans-unit>
        <trans-unit id="bd604d99e75e45d38bc7ac8fc714cde0097d901f" translate="yes" xml:space="preserve">
          <source>Debug</source>
          <target state="translated">Debug</target>
        </trans-unit>
        <trans-unit id="2f52e43b6882a3466f1d969c1cb1001473303ede" translate="yes" xml:space="preserve">
          <source>Declaration Files</source>
          <target state="translated">申报文件</target>
        </trans-unit>
        <trans-unit id="dddf315bf8c952c79983330b50ceb284d3027070" translate="yes" xml:space="preserve">
          <source>Declaration Merging</source>
          <target state="translated">声明合并</target>
        </trans-unit>
        <trans-unit id="2b8121a4da07765109d3a1ebd4396566febe4c31" translate="yes" xml:space="preserve">
          <source>Declaration Type</source>
          <target state="translated">声明类型</target>
        </trans-unit>
        <trans-unit id="b9b846963186dedc9a34aab11fab9a0a092e2d1b" translate="yes" xml:space="preserve">
          <source>Declarations</source>
          <target state="translated">Declarations</target>
        </trans-unit>
        <trans-unit id="dc141dc5502f9e0e32e0ce70ae020fbf031bce6e" translate="yes" xml:space="preserve">
          <source>Declarations are &lt;em&gt;always&lt;/em&gt; initialized to &lt;code&gt;undefined&lt;/code&gt;, even if they have no initializer.</source>
          <target state="translated">即使声明没有初始化程序，也&lt;em&gt;始终&lt;/em&gt;将其初始化为 &lt;code&gt;undefined&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f41d762770bc6126d4d1fc990ef90759d58eb809" translate="yes" xml:space="preserve">
          <source>Declarations are initialized with &lt;code&gt;Object.defineProperty&lt;/code&gt;.</source>
          <target state="translated">声明使用 &lt;code&gt;Object.defineProperty&lt;/code&gt; 初始化。</target>
        </trans-unit>
        <trans-unit id="6fcdb4b2cc50995c39a00cc184737f3ebc0aa6de" translate="yes" xml:space="preserve">
          <source>Declarations like &lt;code&gt;import * as a from 'b';&lt;/code&gt; or &lt;code&gt;export c;&lt;/code&gt;</source>
          <target state="translated">声明 &lt;code&gt;import * as a from 'b';&lt;/code&gt; 或 &lt;code&gt;export c;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="347802d3a4b4ece7d3a20faf11435d4ac3181083" translate="yes" xml:space="preserve">
          <source>Declare the properties if they really do exist.</source>
          <target state="translated">申报属性,如果属性真的存在的话。</target>
        </trans-unit>
        <trans-unit id="0d6cb4979eadd458a450c7ab965139630dc251e6" translate="yes" xml:space="preserve">
          <source>Declaring a variable in JavaScript has always traditionally been done with the &lt;code&gt;var&lt;/code&gt; keyword.</source>
          <target state="translated">传统上，在JavaScript中声明变量始终是使用 &lt;code&gt;var&lt;/code&gt; 关键字完成的。</target>
        </trans-unit>
        <trans-unit id="45c3eb65b36120d75303dd4d19ce72e6c44591cc" translate="yes" xml:space="preserve">
          <source>Declaring variables of type &lt;code&gt;void&lt;/code&gt; is not useful because you can only assign &lt;code&gt;null&lt;/code&gt; (only if &lt;code&gt;--strictNullChecks&lt;/code&gt; is not specified, see next section) or &lt;code&gt;undefined&lt;/code&gt; to them:</source>
          <target state="translated">声明类型为 &lt;code&gt;void&lt;/code&gt; 的变量没有用，因为您只能将 &lt;code&gt;null&lt;/code&gt; 赋值（仅在未指定 &lt;code&gt;--strictNullChecks&lt;/code&gt; 的情况下，请参阅下一节）或 &lt;code&gt;undefined&lt;/code&gt; 它们：</target>
        </trans-unit>
        <trans-unit id="c9d80403b6c6762d3135cc4b0364ef0ded8f2e39" translate="yes" xml:space="preserve">
          <source>Decorator Composition</source>
          <target state="translated">装修人员组成</target>
        </trans-unit>
        <trans-unit id="94dcd3c584c6cd82aa44ce93304239e663bb5afb" translate="yes" xml:space="preserve">
          <source>Decorator Evaluation</source>
          <target state="translated">装饰师评价</target>
        </trans-unit>
        <trans-unit id="bc8d0308046fee6336b61acda5e70c000a657952" translate="yes" xml:space="preserve">
          <source>Decorator Factories</source>
          <target state="translated">装修厂</target>
        </trans-unit>
        <trans-unit id="a2e23b650a15e5c693ca1445133d5ee60d9d20b4" translate="yes" xml:space="preserve">
          <source>Decorators</source>
          <target state="translated">Decorators</target>
        </trans-unit>
        <trans-unit id="ef21caee016081351dbb5463efe6ee7af49ce158" translate="yes" xml:space="preserve">
          <source>Decorators &lt;code&gt;readonly&lt;/code&gt; and &lt;code&gt;enumerable(false)&lt;/code&gt; will be applied to the property &lt;code&gt;method&lt;/code&gt; before it is installed on class &lt;code&gt;C&lt;/code&gt;. This allows the decorator to change the implementation, and in this case, augment the descriptor to be writable: false and enumerable: false.</source>
          <target state="translated">装饰器 &lt;code&gt;readonly&lt;/code&gt; 和 &lt;code&gt;enumerable(false)&lt;/code&gt; 将在属性 &lt;code&gt;method&lt;/code&gt; 安装到类 &lt;code&gt;C&lt;/code&gt; 之前应用到该方法。这允许装饰器更改实现，并且在这种情况下，将描述符扩展为可写：false和可枚举：false。</target>
        </trans-unit>
        <trans-unit id="8a0adc2fcd71ed541d9efa8c14c5ad593144b45d" translate="yes" xml:space="preserve">
          <source>Decorators are now allowed when targeting ES3. TypeScript 1.7 removes the ES5-specific use of &lt;code&gt;reduceRight&lt;/code&gt; from the &lt;code&gt;__decorate&lt;/code&gt; helper. The changes also inline calls &lt;code&gt;Object.getOwnPropertyDescriptor&lt;/code&gt; and &lt;code&gt;Object.defineProperty&lt;/code&gt; in a backwards-compatible fashion that allows for a to clean up the emit for ES5 and later by removing various repetitive calls to the aforementioned &lt;code&gt;Object&lt;/code&gt; methods.</source>
          <target state="translated">现在，在定位ES3时允许使用装饰器。打字稿1.7去除ES5专有使用的 &lt;code&gt;reduceRight&lt;/code&gt; 从 &lt;code&gt;__decorate&lt;/code&gt; 帮手。这些更改还以向后兼容的方式内联调用 &lt;code&gt;Object.getOwnPropertyDescriptor&lt;/code&gt; 和 &lt;code&gt;Object.defineProperty&lt;/code&gt; ，从而允许a清理ES5的发射，随后通过删除对上述 &lt;code&gt;Object&lt;/code&gt; 方法的各种重复调用来进行清理。</target>
        </trans-unit>
        <trans-unit id="ab1c2fe01ec5b2e45d64dd5c8c5b343bff75cd10" translate="yes" xml:space="preserve">
          <source>Deduplicated and redirected packages</source>
          <target state="translated">被重复和重定向的软件包</target>
        </trans-unit>
        <trans-unit id="c34129b088d5dff9241ab7abdee9bb553051e041" translate="yes" xml:space="preserve">
          <source>Deep Dive</source>
          <target state="translated">深度潜水</target>
        </trans-unit>
        <trans-unit id="8f606bc9715586c081faee92e0f2cbb0b58c9865" translate="yes" xml:space="preserve">
          <source>Deep Dive: Advanced Combinations</source>
          <target state="translated">深度潜水。高级组合</target>
        </trans-unit>
        <trans-unit id="8dce9edac26c50b7afe597930a0e4d53c87e0151" translate="yes" xml:space="preserve">
          <source>Deep Dive: Definition File Theory: A Deep Dive</source>
          <target state="translated">深度潜水。定义文件理论。深度潜水:定义文件理论:深度潜水</target>
        </trans-unit>
        <trans-unit id="df3520f4ddd89ba26396acae5290727ff5fa15a2" translate="yes" xml:space="preserve">
          <source>Deep Dive: Using with export = or import</source>
          <target state="translated">深度潜水。使用 export=或 import</target>
        </trans-unit>
        <trans-unit id="808d7dca8a74d84af27a2d6602c3d786de45fe1e" translate="yes" xml:space="preserve">
          <source>Default</source>
          <target state="translated">Default</target>
        </trans-unit>
        <trans-unit id="1dcd95e322dde1a1ed9488f1a9be1d85f6302d4a" translate="yes" xml:space="preserve">
          <source>Default Export</source>
          <target state="translated">默认出口</target>
        </trans-unit>
        <trans-unit id="967dd37853ad5171b91867584cc350ce812dd723" translate="yes" xml:space="preserve">
          <source>Default exports</source>
          <target state="translated">默认出口</target>
        </trans-unit>
        <trans-unit id="6c547e1ab7ad80d7eb94ac89b9475cb2f4ad47cf" translate="yes" xml:space="preserve">
          <source>Default exports also cannot be augmented, only named exports (since you need to augment an export by its exported name, and &lt;code&gt;default&lt;/code&gt; is a reserved word - see &lt;a href=&quot;https://github.com/Microsoft/TypeScript/issues/14080&quot;&gt;#14080&lt;/a&gt; for details)</source>
          <target state="translated">默认导出也不能被扩展，只能命名导出（因为您需要通过导出名称来扩展导出，并且 &lt;code&gt;default&lt;/code&gt; 是保留字- 有关详细信息，请参见&lt;a href=&quot;https://github.com/Microsoft/TypeScript/issues/14080&quot;&gt;＃14080&lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="aaafa95b77c94d35023aa4c831339a5f6888b4bd" translate="yes" xml:space="preserve">
          <source>Default imports to CommonJS/AMD/UMD are now allowed (e.g. &lt;code&gt;import fs from &quot;fs&quot;&lt;/code&gt;), and should work as expected.</source>
          <target state="translated">现在允许默认导入CommonJS / AMD / UMD（例如， &lt;code&gt;import fs from &quot;fs&quot;&lt;/code&gt; ），并且应能按预期工作。</target>
        </trans-unit>
        <trans-unit id="ca5a7e29bf0dd24fa5da97c8a78bd7b6478ae9da" translate="yes" xml:space="preserve">
          <source>Default types for a type parameter must satisfy the constraint for the type parameter, if it exists.</source>
          <target state="translated">一个类型参数的默认类型必须满足该类型参数的约束,如果存在的话。</target>
        </trans-unit>
        <trans-unit id="e034cbbe2b8762f796d4892d08bbfed1145d3ef8" translate="yes" xml:space="preserve">
          <source>Default values</source>
          <target state="translated">默认值</target>
        </trans-unit>
        <trans-unit id="373c6cd274b89a3c2582c933d56ada3fedbd82e3" translate="yes" xml:space="preserve">
          <source>Default values let you specify a default value in case a property is undefined:</source>
          <target state="translated">默认值允许你指定一个默认值,以防属性未被定义。</target>
        </trans-unit>
        <trans-unit id="b1bceef18898234e393aee21da6ed7ad228f35ee" translate="yes" xml:space="preserve">
          <source>Default-initialized parameters that come after all required parameters are treated as optional, and just like optional parameters, can be omitted when calling their respective function. This means optional parameters and trailing default parameters will share commonality in their types, so both</source>
          <target state="translated">在所有需要的参数之后出现的默认初始化参数被视为可选参数,和可选参数一样,在调用各自的函数时可以省略。这意味着可选参数和尾随的默认参数在类型上有共性,所以这两个</target>
        </trans-unit>
        <trans-unit id="fd59cfb04075f034cef59cd0fa42daf1eb79992e" translate="yes" xml:space="preserve">
          <source>Defaulted declarations</source>
          <target state="translated">缺省声明</target>
        </trans-unit>
        <trans-unit id="abc6fc711e9d8d97a334f473c6d8d10ccc6870a3" translate="yes" xml:space="preserve">
          <source>Definite Assignment Assertions</source>
          <target state="translated">确定性的任务断言</target>
        </trans-unit>
        <trans-unit id="4cf6455d1dfb8e1b31ee9a23f39f86c7d9682067" translate="yes" xml:space="preserve">
          <source>Definition File Theory: A Deep Dive</source>
          <target state="translated">定义文件理论。深入研究</target>
        </trans-unit>
        <trans-unit id="0562f32dc56f5c702810cbe010068ddd38dbd69a" translate="yes" xml:space="preserve">
          <source>Dependencies</source>
          <target state="translated">Dependencies</target>
        </trans-unit>
        <trans-unit id="a5295ab13650a7fc6f7e3962a265606df1d7d936" translate="yes" xml:space="preserve">
          <source>Dependencies on Global Libraries</source>
          <target state="translated">对全球图书馆的依赖性</target>
        </trans-unit>
        <trans-unit id="6067defa2476905bfad8665adf2145c0c736a17f" translate="yes" xml:space="preserve">
          <source>Dependencies on Modules</source>
          <target state="translated">对模块的依赖性</target>
        </trans-unit>
        <trans-unit id="30e045eae2e7599477b456a7f9a5428b685bf5aa" translate="yes" xml:space="preserve">
          <source>Dependencies on UMD libraries</source>
          <target state="translated">对UMD图书馆的依赖性</target>
        </trans-unit>
        <trans-unit id="b6e13e2a33f9902dfc93501c0d9a6a0bb02f3d22" translate="yes" xml:space="preserve">
          <source>Depending on the module target specified during compilation, the compiler will generate appropriate code for Node.js (&lt;a href=&quot;http://wiki.commonjs.org/wiki/CommonJS&quot;&gt;CommonJS&lt;/a&gt;), require.js (&lt;a href=&quot;https://github.com/amdjs/amdjs-api/wiki/AMD&quot;&gt;AMD&lt;/a&gt;), &lt;a href=&quot;https://github.com/umdjs/umd&quot;&gt;UMD&lt;/a&gt;, &lt;a href=&quot;https://github.com/systemjs/systemjs&quot;&gt;SystemJS&lt;/a&gt;, or &lt;a href=&quot;http://www.ecma-international.org/ecma-262/6.0/#sec-modules&quot;&gt;ECMAScript 2015 native modules&lt;/a&gt; (ES6) module-loading systems. For more information on what the &lt;code&gt;define&lt;/code&gt;, &lt;code&gt;require&lt;/code&gt; and &lt;code&gt;register&lt;/code&gt; calls in the generated code do, consult the documentation for each module loader.</source>
          <target state="translated">根据编译期间指定的模块目标，编译器将为Node.js（&lt;a href=&quot;http://wiki.commonjs.org/wiki/CommonJS&quot;&gt;CommonJS&lt;/a&gt;），require.js（&lt;a href=&quot;https://github.com/amdjs/amdjs-api/wiki/AMD&quot;&gt;AMD&lt;/a&gt;），&lt;a href=&quot;https://github.com/umdjs/umd&quot;&gt;UMD&lt;/a&gt;，&lt;a href=&quot;https://github.com/systemjs/systemjs&quot;&gt;SystemJS&lt;/a&gt;或&lt;a href=&quot;http://www.ecma-international.org/ecma-262/6.0/#sec-modules&quot;&gt;ECMAScript 2015本机模块&lt;/a&gt;（ES6）模块加载系统生成适当的代码。有关在生成的代码中 &lt;code&gt;define&lt;/code&gt; ， &lt;code&gt;require&lt;/code&gt; 和 &lt;code&gt;register&lt;/code&gt; 调用的作用的更多信息，请查阅每个模块加载器的文档。</target>
        </trans-unit>
        <trans-unit id="55f8ebc805e65b5b71ddafdae390e3be2bcd69af" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">Description</target>
        </trans-unit>
        <trans-unit id="3e9c954b8528b960f8219e88a4099c898d44449d" translate="yes" xml:space="preserve">
          <source>Despite its appearance, the &lt;code&gt;readonly&lt;/code&gt; type modifier can only be used for syntax on array types and tuple types. It is not a general-purpose type operator.</source>
          <target state="translated">尽管有外观，但 &lt;code&gt;readonly&lt;/code&gt; 类型修饰符只能用于数组类型和元组类型的语法。它不是通用类型的运算符。</target>
        </trans-unit>
        <trans-unit id="077ef6bb7e9ca7a81dc6c9028d61cccdb0c255dd" translate="yes" xml:space="preserve">
          <source>Destructuring</source>
          <target state="translated">Destructuring</target>
        </trans-unit>
        <trans-unit id="b44f48048febb0c759b20a351a087cf970585895" translate="yes" xml:space="preserve">
          <source>Destructuring also works in function declarations. For simple cases this is straightforward:</source>
          <target state="translated">解构也可以在函数声明中使用。对于简单的情况,这很直接。</target>
        </trans-unit>
        <trans-unit id="c10db471f87802e009d06682868c12eb36cc956b" translate="yes" xml:space="preserve">
          <source>Destructuring declarations also works for extracting values from arrays:</source>
          <target state="translated">解构声明也适用于从数组中提取值。</target>
        </trans-unit>
        <trans-unit id="aae36bb7ef10a1d27e89e1a1e5cab353c1f39861" translate="yes" xml:space="preserve">
          <source>Destructuring in declarations and assignments</source>
          <target state="translated">申报和转让中的结构调整</target>
        </trans-unit>
        <trans-unit id="30ec4f69e7cfb0ff17a5b214356b9461fa3e35ea" translate="yes" xml:space="preserve">
          <source>Destructuring patterns can also be used in regular assignment expressions. For instance, swapping two variables can be written as a single destructuring assignment:</source>
          <target state="translated">解构模式也可以用在正则赋值表达式中。例如,交换两个变量可以写成一个解构赋值。</target>
        </trans-unit>
        <trans-unit id="b42315aeb1e4c4a5777df9a8f177e68cf09a45e0" translate="yes" xml:space="preserve">
          <source>Destructuring works with already-declared variables as well:</source>
          <target state="translated">解构也可以使用已经声明的变量。</target>
        </trans-unit>
        <trans-unit id="dc3decbb93847518f1a049dcf49d0d7c6560bcc6" translate="yes" xml:space="preserve">
          <source>Details</source>
          <target state="translated">Details</target>
        </trans-unit>
        <trans-unit id="93207507957b31ebda343db069ec516064c2e248" translate="yes" xml:space="preserve">
          <source>Detect if they are up-to-date</source>
          <target state="translated">检测它们是否是最新的</target>
        </trans-unit>
        <trans-unit id="bec760709f148364d8b2d7249cf252878131b36c" translate="yes" xml:space="preserve">
          <source>Determine how modules get resolved. Either &lt;code&gt;&quot;Node&quot;&lt;/code&gt; for Node.js/io.js style resolution, or &lt;code&gt;&quot;Classic&quot;&lt;/code&gt;. See &lt;a href=&quot;module-resolution&quot;&gt;Module Resolution documentation&lt;/a&gt; for more details.</source>
          <target state="translated">确定如何解决模块。无论是 &lt;code&gt;&quot;Node&quot;&lt;/code&gt; 于Node.js / io.js风格的分辨率，或 &lt;code&gt;&quot;Classic&quot;&lt;/code&gt; 。有关更多详细信息，请参见&lt;a href=&quot;module-resolution&quot;&gt;模块分辨率文档&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f4dff229f34e808acb097e68696d3c3718ad33a9" translate="yes" xml:space="preserve">
          <source>Difference between the static and instance sides of classes</source>
          <target state="translated">类的静态方和实例方的区别</target>
        </trans-unit>
        <trans-unit id="369d22e8ba9dcb70fad4ac90845eb7df1bdf8234" translate="yes" xml:space="preserve">
          <source>Different places in the language use one of the two compatibility mechanisms, depending on the situation. For practical purposes, type compatibility is dictated by assignment compatibility, even in the cases of the &lt;code&gt;implements&lt;/code&gt; and &lt;code&gt;extends&lt;/code&gt; clauses.</source>
          <target state="translated">语言中的不同位置会根据情况使用两种兼容机制之一。出于实际目的，即使在 &lt;code&gt;implements&lt;/code&gt; 和 &lt;code&gt;extends&lt;/code&gt; 子句的情况下，类型兼容性也由赋值兼容性决定。</target>
        </trans-unit>
        <trans-unit id="e3bd0e1c1cd621e6fbcc274e9d250ab1db3c03d9" translate="yes" xml:space="preserve">
          <source>Disable bivariant parameter checking for function types.</source>
          <target state="translated">禁用函数类型的二元参数检查。</target>
        </trans-unit>
        <trans-unit id="0d5492f8c219bc96eb3e1f985831cc36749273fc" translate="yes" xml:space="preserve">
          <source>Disable size limitation on JavaScript project.</source>
          <target state="translated">关闭对JavaScript项目的大小限制。</target>
        </trans-unit>
        <trans-unit id="c0d6cff3c670100d6c4947847436586c9f909a0c" translate="yes" xml:space="preserve">
          <source>Disable strict checking of generic signatures in function types.</source>
          <target state="translated">禁止严格检查函数类型中的通用签名。</target>
        </trans-unit>
        <trans-unit id="fc94ad5a04140e86aa8535c4085feefac81708ef" translate="yes" xml:space="preserve">
          <source>Disallow inconsistently-cased references to the same file.</source>
          <target state="translated">不允许不一致地引用同一文件。</target>
        </trans-unit>
        <trans-unit id="ca07b6b5d34354414804d10f0627d23afc021014" translate="yes" xml:space="preserve">
          <source>Disallowed Merges</source>
          <target state="translated">不允许合并</target>
        </trans-unit>
        <trans-unit id="6e50354a241d00dc8de3bce0c769ecd4f5445e88" translate="yes" xml:space="preserve">
          <source>Discriminated Unions</source>
          <target state="translated">受歧视的工会</target>
        </trans-unit>
        <trans-unit id="8f4eecd214b9b9b6bc1adea133960de053499fa9" translate="yes" xml:space="preserve">
          <source>Distributive conditional types</source>
          <target state="translated">分布式条件类型</target>
        </trans-unit>
        <trans-unit id="5528e62826cea5c6ba5ef36621e1eb9d42697e3e" translate="yes" xml:space="preserve">
          <source>Do &lt;em&gt;not&lt;/em&gt; use a &lt;code&gt;/// &amp;lt;reference&lt;/code&gt; directive to declare a dependency to a UMD library!</source>
          <target state="translated">千万&lt;em&gt;不能&lt;/em&gt;使用 &lt;code&gt;/// &amp;lt;reference&lt;/code&gt; 指令声明依赖于UMD库！</target>
        </trans-unit>
        <trans-unit id="008b4d242c76d59d51967dc8ca342e5c9c0171f2" translate="yes" xml:space="preserve">
          <source>Do not add triple-slash references or module import targets to the list of compiled files.</source>
          <target state="translated">不要在编译文件列表中添加三条斜线引用或模块导入目标。</target>
        </trans-unit>
        <trans-unit id="bbda7eadbbdea2540dfa2471e3343bfd9af51dfa" translate="yes" xml:space="preserve">
          <source>Do not emit &lt;code&gt;&quot;use strict&quot;&lt;/code&gt; directives in module output.</source>
          <target state="translated">不要在模块输出中发出 &lt;code&gt;&quot;use strict&quot;&lt;/code&gt; 指令。</target>
        </trans-unit>
        <trans-unit id="f59925b0be84543d3516bc127648bdda000f9a36" translate="yes" xml:space="preserve">
          <source>Do not emit outputs if any errors were reported.</source>
          <target state="translated">如果报告有任何错误,请勿发射输出。</target>
        </trans-unit>
        <trans-unit id="8813a3a637738cb30116f3e3de2e596160d664a4" translate="yes" xml:space="preserve">
          <source>Do not emit outputs.</source>
          <target state="translated">不要发射输出。</target>
        </trans-unit>
        <trans-unit id="2b4aecc96dbac4010750a03d9cdf681cad5a2782" translate="yes" xml:space="preserve">
          <source>Do not erase const enum declarations in generated code. See &lt;a href=&quot;https://github.com/Microsoft/TypeScript/blob/master/doc/spec.html#94-constant-enum-declarations&quot;&gt;const enums documentation&lt;/a&gt; for more details.</source>
          <target state="translated">不要在生成的代码中擦除const枚举声明。有关更多详细信息，请参见&lt;a href=&quot;https://github.com/Microsoft/TypeScript/blob/master/doc/spec.html#94-constant-enum-declarations&quot;&gt;const枚举文档&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3ca81886d5434cef3d191c1781471a917134a9cf" translate="yes" xml:space="preserve">
          <source>Do not generate custom helper functions like &lt;code&gt;__extends&lt;/code&gt; in compiled output.</source>
          <target state="translated">不要在编译输出中生成诸如 &lt;code&gt;__extends&lt;/code&gt; 之类的自定义帮助函数。</target>
        </trans-unit>
        <trans-unit id="f47ae1f25d416955ab5b35ad58b6d952ed341297" translate="yes" xml:space="preserve">
          <source>Do not include the default library file (&lt;code&gt;lib.d.ts&lt;/code&gt;).</source>
          <target state="translated">不包括默认库文件（ &lt;code&gt;lib.d.ts&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="0d8700379392a841b4a989a2aedc6ee39cc22535" translate="yes" xml:space="preserve">
          <source>Do not report errors on unreachable code.</source>
          <target state="translated">不要在无法到达的代码上报错。</target>
        </trans-unit>
        <trans-unit id="e15fbdc059493fca2d963af5c43ecf0c0d7a9902" translate="yes" xml:space="preserve">
          <source>Do not report errors on unused labels.</source>
          <target state="translated">未使用的标签不要报错。</target>
        </trans-unit>
        <trans-unit id="566fc4907f5c0c600bf0a19df75cc66685e5a833" translate="yes" xml:space="preserve">
          <source>Do not resolve symlinks to their real path; treat a symlinked file like a real one.</source>
          <target state="translated">不要将symlinks解析为真实路径;将symlinked文件视为真实路径。</target>
        </trans-unit>
        <trans-unit id="f7c490d4d3e51d3eaf23f688f0c04328a2f1e119" translate="yes" xml:space="preserve">
          <source>Do not truncate error messages.</source>
          <target state="translated">不要截断错误信息。</target>
        </trans-unit>
        <trans-unit id="de81d23a68639d446e1d87128f4ef58b96239449" translate="yes" xml:space="preserve">
          <source>Do not use namespaces in modules</source>
          <target state="translated">不要在模块中使用命名空间</target>
        </trans-unit>
        <trans-unit id="9c1bd4c5b18a5e7128a31d98a66a29dfc33c9ab2" translate="yes" xml:space="preserve">
          <source>Do&amp;#x27;s &amp;amp; Don&amp;#x27;ts</source>
          <target state="translated">做与不做</target>
        </trans-unit>
        <trans-unit id="719ef97fc832b36afac23fa78d5c08cea2bf6141" translate="yes" xml:space="preserve">
          <source>Do&amp;#x27;s &amp;amp; Don&amp;#x27;ts: Generics</source>
          <target state="translated">注意事项：泛型</target>
        </trans-unit>
        <trans-unit id="a51c5dd50f698ff95f77e37efad482a71ac91486" translate="yes" xml:space="preserve">
          <source>Do&amp;#x27;s &amp;amp; Don&amp;#x27;ts: Optional Parameters in Callbacks</source>
          <target state="translated">注意事项：回调中的可选参数</target>
        </trans-unit>
        <trans-unit id="2db0d779491e142ea96422450aabb72ea9596eb7" translate="yes" xml:space="preserve">
          <source>Do&amp;#x27;s &amp;amp; Don&amp;#x27;ts: Ordering</source>
          <target state="translated">注意事项：订购</target>
        </trans-unit>
        <trans-unit id="7d768f81a860ccede1d11160fcbc58466d96e618" translate="yes" xml:space="preserve">
          <source>Do&amp;#x27;s &amp;amp; Don&amp;#x27;ts: Overloads and Callbacks</source>
          <target state="translated">注意事项：重载和回调</target>
        </trans-unit>
        <trans-unit id="7b5ad4c0d887c26ae55bb8c0b3d5849755f0038c" translate="yes" xml:space="preserve">
          <source>Do&amp;#x27;s &amp;amp; Don&amp;#x27;ts: Return Types of Callbacks</source>
          <target state="translated">注意事项：返回回调类型</target>
        </trans-unit>
        <trans-unit id="77f700abeac2aeb953e0842c2152d024b8f203e3" translate="yes" xml:space="preserve">
          <source>Do&amp;#x27;s &amp;amp; Don&amp;#x27;ts: Use Optional Parameters</source>
          <target state="translated">注意事项：使用可选参数</target>
        </trans-unit>
        <trans-unit id="ade57914de371d49ae2e67dcf398d7ca7cd0c7e5" translate="yes" xml:space="preserve">
          <source>Do&amp;#x27;s &amp;amp; Don&amp;#x27;ts: Use Union Types</source>
          <target state="translated">注意事项：使用联合类型</target>
        </trans-unit>
        <trans-unit id="bbfd2cbcdd441b33e2a5bbad3336a20b3defd13a" translate="yes" xml:space="preserve">
          <source>Do's and Don'ts</source>
          <target state="translated">应该做的和不应该做的</target>
        </trans-unit>
        <trans-unit id="acc9e9cd405cd7ed7a8fcb091e91a562cac25433" translate="yes" xml:space="preserve">
          <source>Documentation describing how to &lt;code&gt;require&lt;/code&gt; or import the library</source>
          <target state="translated">说明如何 &lt;code&gt;require&lt;/code&gt; 或导入库的文档</target>
        </trans-unit>
        <trans-unit id="3bbfdc360214d58c7cb91ac8521019e85f36e4d8" translate="yes" xml:space="preserve">
          <source>Documentation for UMD libraries will also often demonstrate a &amp;ldquo;Using in Node.js&amp;rdquo; example showing &lt;code&gt;require&lt;/code&gt;, and a &amp;ldquo;Using in the browser&amp;rdquo; example showing using a &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; tag to load the script.</source>
          <target state="translated">UMD库的文档也经常会展示一个显示 &lt;code&gt;require&lt;/code&gt; 的&amp;ldquo;在Node.js中使用&amp;rdquo;的示例，以及一个使用 &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; 标记加载该脚本的&amp;ldquo;在浏览器中使用&amp;rdquo;的示例。</target>
        </trans-unit>
        <trans-unit id="24a9672278fb4d7400c1863d3b7c6f36d8ac8ae1" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t be intimidated by the number of steps here - TypeScript is still only jumping up directories twice at steps (9) and (17). This is really no more complex than what Node.js itself is doing.</source>
          <target state="translated">不要被这里的步骤数量所吓倒-TypeScript在步骤（9）和（17）仍然只跳两次目录。实际上，这并不比Node.js本身复杂。</target>
        </trans-unit>
        <trans-unit id="1c8722b1128de0f74ea224044ed5056ae0d0f337" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t worry about ordering the files you pass on the commandline - &lt;code&gt;tsc&lt;/code&gt; will re-order them if needed so that dependencies are always built first.</source>
          <target state="translated">不必担心对在命令行上传递的文件进行排序- 如果需要， &lt;code&gt;tsc&lt;/code&gt; 将对它们进行重新排序，以便始终先构建依赖项。</target>
        </trans-unit>
        <trans-unit id="c119e0650ca90fa2b62e09ff44c7b5ae64f45581" translate="yes" xml:space="preserve">
          <source>Dotted names in type guards</source>
          <target state="translated">字型护卫中的点名</target>
        </trans-unit>
        <trans-unit id="ccdea752338ea9ee00074218ee9537a9bfdb03c3" translate="yes" xml:space="preserve">
          <source>Dotted property for types with string index signatures</source>
          <target state="translated">带字符串索引签名的类型的虚点属性</target>
        </trans-unit>
        <trans-unit id="e035b7411ed359c6cdcd7655c199afa4eea32876" translate="yes" xml:space="preserve">
          <source>Downlevel Async Functions</source>
          <target state="translated">下级异步功能</target>
        </trans-unit>
        <trans-unit id="d5cabcaa6a9d5f4be82b1397ad3c7fd26169c044" translate="yes" xml:space="preserve">
          <source>Download the &lt;a href=&quot;https://github.com/Microsoft/TypeScript/blob/master/scripts/VSDevMode.ps1&quot;&gt;VSDevMode.ps1&lt;/a&gt; script.</source>
          <target state="translated">下载&lt;a href=&quot;https://github.com/Microsoft/TypeScript/blob/master/scripts/VSDevMode.ps1&quot;&gt;VSDevMode.ps1&lt;/a&gt;脚本。</target>
        </trans-unit>
        <trans-unit id="9b4592f9ae45a647155e857c8bbbe5e38c83f01e" translate="yes" xml:space="preserve">
          <source>Downloading</source>
          <target state="translated">Downloading</target>
        </trans-unit>
        <trans-unit id="984d20c7f5194c7c76c4882260c3e8e0fde40023" translate="yes" xml:space="preserve">
          <source>Due to a bug, the following construct was previously allowed in TypeScript:</source>
          <target state="translated">由于一个bug,在TypeScript中之前允许以下构造。</target>
        </trans-unit>
        <trans-unit id="3c5d9cd03387fb41a856eb94a3f12c1e7c45d2c1" translate="yes" xml:space="preserve">
          <source>Duo</source>
          <target state="translated">Duo</target>
        </trans-unit>
        <trans-unit id="39a8e581f6169ec0a9b5700af7954883b503baa0" translate="yes" xml:space="preserve">
          <source>During type argument inference in TypeScript 3.4, for a call to a generic function that returns a function type, TypeScript &lt;em&gt;will&lt;/em&gt;, as appropriate, propagate type parameters from generic function arguments onto the resulting function type.</source>
          <target state="translated">在TypeScript 3.4中进行类型参数推断期间，对于调用返回函数类型的泛型函数的调用，TypeScript &lt;em&gt;将&lt;/em&gt;在适当的情况下将类型参数从泛型函数参数传播到生成的函数类型上。</target>
        </trans-unit>
        <trans-unit id="d9d2b88aa61f766d2be10ae43782a97a76b6067a" translate="yes" xml:space="preserve">
          <source>Dynamic &lt;code&gt;import&lt;/code&gt; expressions are a new feature and part of ECMAScript that allows users to asynchronously request a module at any arbitrary point in your program.</source>
          <target state="translated">动态 &lt;code&gt;import&lt;/code&gt; 表达式是ECMAScript的新功能，它是ECMAScript的一部分，它允许用户在程序的任意位置异步请求模块。</target>
        </trans-unit>
        <trans-unit id="d3eb3dff1f243ca444cd0f21c8fa73f06b676b18" translate="yes" xml:space="preserve">
          <source>Dynamic Import Expressions</source>
          <target state="translated">动态导入表达式</target>
        </trans-unit>
        <trans-unit id="65d07d2547264048b907ca688317344223d5a0bb" translate="yes" xml:space="preserve">
          <source>Dynamic Module Loading in Node.js</source>
          <target state="translated">Node.js中的动态模块加载</target>
        </trans-unit>
        <trans-unit id="728508cddb478117297b77baabcf7bb4bfc6cd00" translate="yes" xml:space="preserve">
          <source>ECMAScript 2015 (also known as ES2015, ECMAScript 6, and ES6), CommonJS, and RequireJS have similar notions of &lt;em&gt;importing&lt;/em&gt; a &lt;em&gt;module&lt;/em&gt;. In JavaScript CommonJS (Node.js), for example, you would write</source>
          <target state="translated">ECMAScript的2015（也称为ES2015，ECMAScript的6和ES6），CommonJS的，和RequireJS具有类似概念&lt;em&gt;导入&lt;/em&gt;一个&lt;em&gt;模块&lt;/em&gt;。例如，在JavaScript CommonJS（Node.js）中，您将编写</target>
        </trans-unit>
        <trans-unit id="f85cdebb2ea7d4e839607ea71d7d48e0db5d1567" translate="yes" xml:space="preserve">
          <source>ES2015 does not have a means for declaring properties on classes. Properties are dynamically assigned, just like object literals.</source>
          <target state="translated">ES2015没有在类上声明属性的方法。属性是动态分配的,就像对象字面意义一样。</target>
        </trans-unit>
        <trans-unit id="8f11e274662541f2c8e0e3cb8196626ffc1b7d1e" translate="yes" xml:space="preserve">
          <source>ES6 &lt;code&gt;let&lt;/code&gt; and &lt;code&gt;const&lt;/code&gt; declarations are now supported when targeting ES3 and ES5.</source>
          <target state="translated">现在，在定位ES3和ES5时支持ES6 &lt;code&gt;let&lt;/code&gt; 和 &lt;code&gt;const&lt;/code&gt; 声明。</target>
        </trans-unit>
        <trans-unit id="f9d8a7611370241de60b894de016326924a7a9e7" translate="yes" xml:space="preserve">
          <source>ES6 Modules</source>
          <target state="translated">ES6模块</target>
        </trans-unit>
        <trans-unit id="e2acc8bb5a67f66241c722af8d11c013fb591c49" translate="yes" xml:space="preserve">
          <source>ES6 generators</source>
          <target state="translated">ES6发电机</target>
        </trans-unit>
        <trans-unit id="ed61ecf2ad6576a5906a380e425433052f29a51a" translate="yes" xml:space="preserve">
          <source>ES6 introduces escapes that allow users to represent a Unicode codepoint using just a single escape.</source>
          <target state="translated">ES6引入了转义符,允许用户只用一个转义符来表示一个Unicode代码点。</target>
        </trans-unit>
        <trans-unit id="facf2ab431b3ab3e7ec6da17f65766fba3092531" translate="yes" xml:space="preserve">
          <source>ES7 exponentiation operator</source>
          <target state="translated">ES7指数运算器</target>
        </trans-unit>
        <trans-unit id="df1c0c4164faa864b6980e867e23ee2da1e921b7" translate="yes" xml:space="preserve">
          <source>Each enum member has a value associated with it which can be either &lt;em&gt;constant&lt;/em&gt; or &lt;em&gt;computed&lt;/em&gt;. An enum member is considered constant if:</source>
          <target state="translated">每个枚举构件都具有与其相关联的值，其可以是&lt;em&gt;恒定的&lt;/em&gt;或&lt;em&gt;计算的&lt;/em&gt;。枚举成员被视为常量，如果：</target>
        </trans-unit>
        <trans-unit id="5e4c52e3c0a22643b225662844bb284bc77facc8" translate="yes" xml:space="preserve">
          <source>Each module can optionally export a &lt;code&gt;default&lt;/code&gt; export. Default exports are marked with the keyword &lt;code&gt;default&lt;/code&gt;; and there can only be one &lt;code&gt;default&lt;/code&gt; export per module. &lt;code&gt;default&lt;/code&gt; exports are imported using a different import form.</source>
          <target state="translated">每个模块都可以选择导出 &lt;code&gt;default&lt;/code&gt; 导出。默认出口用关键字 &lt;code&gt;default&lt;/code&gt; 标记; 每个模块只能有一个 &lt;code&gt;default&lt;/code&gt; 导出。 &lt;code&gt;default&lt;/code&gt; 导出使用其他导入形式导入。</target>
        </trans-unit>
        <trans-unit id="1854fec7a183b17dc9b4b01211c91e48aea1794a" translate="yes" xml:space="preserve">
          <source>Each of these declaration forms creates a new type name.</source>
          <target state="translated">这些声明表格中的每一个都会创建一个新的类型名称。</target>
        </trans-unit>
        <trans-unit id="b86f360c4781ee31be3d35dcc610cf923afd132b" translate="yes" xml:space="preserve">
          <source>Each type of major library structuring pattern has a corresponding file in the &lt;a href=&quot;templates&quot;&gt;Templates&lt;/a&gt; section. You can start with these templates to help you get going faster.</source>
          <target state="translated">每种类型的主要库结构模式在&amp;ldquo; &lt;a href=&quot;templates&quot;&gt;模板&amp;rdquo;&lt;/a&gt;部分中都有一个对应的文件。您可以从这些模板开始，以帮助您更快地进行开发。</target>
        </trans-unit>
        <trans-unit id="2e038538a33dfc2af3364ce4ef765b965c2e718a" translate="yes" xml:space="preserve">
          <source>Early Benefits</source>
          <target state="translated">早期福利</target>
        </trans-unit>
        <trans-unit id="ffd303c2b780c5345fb91f72058772c5f0edd26f" translate="yes" xml:space="preserve">
          <source>Editors like Visual Studio and Visual Studio Code can automatically apply quick fixes, refactorings, and other transformations like automatically importing values from other modules. These transformations are powered by TypeScript, and older versions of TypeScript unconditionally added semicolons to the end of every statement; unfortunately, this disagreed with many users&amp;rsquo; style guidelines, and many users were displeased with the editor inserting semicolons.</source>
          <target state="translated">像Visual Studio和Visual Studio Code这样的编辑器可以自动应用快速修复，重构和其他转换，例如自动从其他模块导入值。这些转换由TypeScript驱动，而旧版本的TypeScript无条件地在每个语句的末尾添加了分号。不幸的是，这与许多用户的样式准则不一致，并且许多用户对编辑器插入分号不满意。</target>
        </trans-unit>
        <trans-unit id="ab2fc66180c7c3d32691e8c42f8df3300e931653" translate="yes" xml:space="preserve">
          <source>Either the constructor function of the class for a static member, or the prototype of the class for an instance member.</source>
          <target state="translated">要么是类的构造函数为静态成员的构造函数,要么是类的原型为实例成员的构造函数。</target>
        </trans-unit>
        <trans-unit id="0871854bfc9d5eb95db51d532c4a4da986a587e1" translate="yes" xml:space="preserve">
          <source>Elements in the array binding pattern that have no match in the array literal are required to have a default value in the array binding pattern and are automatically added to the array literal type.</source>
          <target state="translated">在数组绑定模式中没有匹配的元素,需要在数组绑定模式中设置一个默认值,并自动添加到数组字面符号类型中。</target>
        </trans-unit>
        <trans-unit id="d77d85d60ae04f1f62d384d542f348cbe2876ff0" translate="yes" xml:space="preserve">
          <source>Embedding Expressions</source>
          <target state="translated">嵌入表达式</target>
        </trans-unit>
        <trans-unit id="596bc3c5e7f94b3b0596259252b4462615ba5b98" translate="yes" xml:space="preserve">
          <source>Emit &lt;code&gt;__importStar&lt;/code&gt; and &lt;code&gt;__importDefault&lt;/code&gt; helpers for runtime babel ecosystem compatibility and enable &lt;code&gt;--allowSyntheticDefaultImports&lt;/code&gt; for typesystem compatibility.</source>
          <target state="translated">发出 &lt;code&gt;__importStar&lt;/code&gt; 和 &lt;code&gt;__importDefault&lt;/code&gt; 帮助程序以实现运行时babel生态系统兼容性，并启用 &lt;code&gt;--allowSyntheticDefaultImports&lt;/code&gt; 以实现类型系统兼容性。</target>
        </trans-unit>
        <trans-unit id="10fd7d2a0af6ba17c8a5d6662cb400314be7d895" translate="yes" xml:space="preserve">
          <source>Emit a UTF-8 Byte Order Mark (BOM) in the beginning of output files.</source>
          <target state="translated">在输出文件的开头发送一个UTF-8字节顺序标记(BOM)。</target>
        </trans-unit>
        <trans-unit id="53b14d1fa9901ab52b3d302030734ec92bfda008" translate="yes" xml:space="preserve">
          <source>Emit a single file with source maps instead of having a separate file.</source>
          <target state="translated">发出带有源地图的单一文件,而不是有一个单独的文件。</target>
        </trans-unit>
        <trans-unit id="87aee0db862567627436ed01449478f0361912f7" translate="yes" xml:space="preserve">
          <source>Emit all of the output files in &lt;code&gt;built&lt;/code&gt; (with &lt;code&gt;outDir&lt;/code&gt;).</source>
          <target state="translated">发出所有 &lt;code&gt;built&lt;/code&gt; 的输出文件（带有 &lt;code&gt;outDir&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="6ac823149db4776d1721774a8881dd70ce3fbb97" translate="yes" xml:space="preserve">
          <source>Emit class fields with ECMAScript-standard semantics.</source>
          <target state="translated">用ECMAScript标准的语义表达类字段。</target>
        </trans-unit>
        <trans-unit id="41ad8902099d4f51e2a118572dcabdcda9aa3360" translate="yes" xml:space="preserve">
          <source>Emit design-type metadata for decorated declarations in source. See &lt;a href=&quot;https://github.com/Microsoft/TypeScript/issues/2577&quot;&gt;issue #2577&lt;/a&gt; for details.</source>
          <target state="translated">发出设计类型的元数据，以在源代码中进行修饰的声明。有关详细信息，请参见&lt;a href=&quot;https://github.com/Microsoft/TypeScript/issues/2577&quot;&gt;问题2577&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ca3085fd048897dd750ce3fb153c2e815abe1acf" translate="yes" xml:space="preserve">
          <source>Emit the source alongside the sourcemaps within a single file; requires &lt;code&gt;--inlineSourceMap&lt;/code&gt; or &lt;code&gt;--sourceMap&lt;/code&gt; to be set.</source>
          <target state="translated">在单个文件中将源代码与源映射一起发射；需要设置 &lt;code&gt;--inlineSourceMap&lt;/code&gt; 或 &lt;code&gt;--sourceMap&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="07885f70bcc0b163283a8d21b81002971b80cbe8" translate="yes" xml:space="preserve">
          <source>Enable all strict type checking options.</source>
          <target state="translated">启用所有严格的类型检查选项。</target>
        </trans-unit>
        <trans-unit id="f3f87c2518fb86141f76c027d8adadd8fdd9cf78" translate="yes" xml:space="preserve">
          <source>Enable incremental compilation by reading/writing information from prior compilations to a file on disk. This file is controlled by the &lt;code&gt;--tsBuildInfoFile&lt;/code&gt; flag.</source>
          <target state="translated">通过将先前编译中的信息读/写到磁盘上的文件来启用增量编译。该文件由 &lt;code&gt;--tsBuildInfoFile&lt;/code&gt; 标志控制。</target>
        </trans-unit>
        <trans-unit id="29470d5b922e340851c6d198cc824890a7ae92da" translate="yes" xml:space="preserve">
          <source>Enable stricter checking of the &lt;code&gt;bind&lt;/code&gt;, &lt;code&gt;call&lt;/code&gt;, and &lt;code&gt;apply&lt;/code&gt; methods on functions.</source>
          <target state="translated">启用对 &lt;code&gt;bind&lt;/code&gt; ， &lt;code&gt;call&lt;/code&gt; 和对函数的 &lt;code&gt;apply&lt;/code&gt; 方法的更严格检查。</target>
        </trans-unit>
        <trans-unit id="91f7049440bfb40ca1c47e9547370380c5c3f2e9" translate="yes" xml:space="preserve">
          <source>Enable the &lt;code&gt;jsx&lt;/code&gt; option</source>
          <target state="translated">启用 &lt;code&gt;jsx&lt;/code&gt; 选项</target>
        </trans-unit>
        <trans-unit id="da566f675009da0e991b7854614c23e919fa5b97" translate="yes" xml:space="preserve">
          <source>Enables experimental support for ES decorators.</source>
          <target state="translated">实现了对ES装饰器的实验性支持。</target>
        </trans-unit>
        <trans-unit id="c4ba38450ee027bba050ddc6f6958b0dc5a751f2" translate="yes" xml:space="preserve">
          <source>Enabling &lt;code&gt;--declarationMap&lt;/code&gt; alongside &lt;code&gt;--declaration&lt;/code&gt; causes the compiler to emit &lt;code&gt;.d.ts.map&lt;/code&gt; files alongside the output &lt;code&gt;.d.ts&lt;/code&gt; files. Language Services can also now understand these map files, and uses them to map declaration-file based definition locations to their original source, when available.</source>
          <target state="translated">启用 &lt;code&gt;--declarationMap&lt;/code&gt; 一起 &lt;code&gt;--declaration&lt;/code&gt; 导致编译器发出 &lt;code&gt;.d.ts.map&lt;/code&gt; 文件旁边的输出 &lt;code&gt;.d.ts&lt;/code&gt; 文件。语言服务现在还可以理解这些映射文件，并使用它们将基于声明文件的定义位置映射到其原始源（如果有）。</target>
        </trans-unit>
        <trans-unit id="72c9407930092256221610ac7ab395e789b77dfa" translate="yes" xml:space="preserve">
          <source>Enabling &lt;code&gt;--strict&lt;/code&gt; enables &lt;code&gt;--noImplicitAny&lt;/code&gt;, &lt;code&gt;--noImplicitThis&lt;/code&gt;, &lt;code&gt;--alwaysStrict&lt;/code&gt;, &lt;code&gt;--strictBindCallApply&lt;/code&gt;, &lt;code&gt;--strictNullChecks&lt;/code&gt;, &lt;code&gt;--strictFunctionTypes&lt;/code&gt; and &lt;code&gt;--strictPropertyInitialization&lt;/code&gt;.</source>
          <target state="translated">启用 &lt;code&gt;--strict&lt;/code&gt; 使 &lt;code&gt;--noImplicitAny&lt;/code&gt; ， &lt;code&gt;--noImplicitThis&lt;/code&gt; ， &lt;code&gt;--alwaysStrict&lt;/code&gt; ， &lt;code&gt;--strictBindCallApply&lt;/code&gt; ， &lt;code&gt;--strictNullChecks&lt;/code&gt; ， &lt;code&gt;--strictFunctionTypes&lt;/code&gt; 和 &lt;code&gt;--strictPropertyInitialization&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0c09f58749451934cce8c0be5ef42b0d3dbd75b5" translate="yes" xml:space="preserve">
          <source>Enhanced &lt;code&gt;--init&lt;/code&gt; output</source>
          <target state="translated">增强的 &lt;code&gt;--init&lt;/code&gt; 输出</target>
        </trans-unit>
        <trans-unit id="c5a806eb89f7dea65ab700be49a0d4d559514188" translate="yes" xml:space="preserve">
          <source>Ensure TypeScript can determine where to find the outputs of the referenced project to compile project.</source>
          <target state="translated">确保TypeScript可以确定在哪里找到引用项目的输出,以编译项目。</target>
        </trans-unit>
        <trans-unit id="90ebaa427f44ae4c263b34e0e48d73b34fd5b03c" translate="yes" xml:space="preserve">
          <source>Ensure non-undefined class properties are initialized in the constructor. This option requires &lt;code&gt;--strictNullChecks&lt;/code&gt; be enabled in order to take effect.</source>
          <target state="translated">确保在构造函数中初始化未定义的类属性。此选项要求启用 &lt;code&gt;--strictNullChecks&lt;/code&gt; 才能生效。</target>
        </trans-unit>
        <trans-unit id="63b63149cd444d6b9da7fe416ce289557f10a9e7" translate="yes" xml:space="preserve">
          <source>Enter Index Type Query or &lt;code&gt;keyof&lt;/code&gt;; An indexed type query &lt;code&gt;keyof T&lt;/code&gt; yields the type of permitted property names for &lt;code&gt;T&lt;/code&gt;. A &lt;code&gt;keyof T&lt;/code&gt; type is considered a subtype of &lt;code&gt;string&lt;/code&gt;.</source>
          <target state="translated">输入索引类型查询或 &lt;code&gt;keyof&lt;/code&gt; ; 索引类型的查询 &lt;code&gt;keyof T&lt;/code&gt; 得到了允许的属性名称的类型 &lt;code&gt;T&lt;/code&gt; 。 &lt;code&gt;keyof T&lt;/code&gt; 类型的key被认为是 &lt;code&gt;string&lt;/code&gt; 的子类型。</target>
        </trans-unit>
        <trans-unit id="20588ae8e5c269292d35f9dfffa8f2eb3fd3c259" translate="yes" xml:space="preserve">
          <source>Enum</source>
          <target state="translated">Enum</target>
        </trans-unit>
        <trans-unit id="04dd4dbb8815c963d82df0161b050d4d9dafeb1d" translate="yes" xml:space="preserve">
          <source>Enum Member Types</source>
          <target state="translated">成员类型</target>
        </trans-unit>
        <trans-unit id="f3104dd45718e6d1ac6a03b91ae67193ae8361f0" translate="yes" xml:space="preserve">
          <source>Enums</source>
          <target state="translated">Enums</target>
        </trans-unit>
        <trans-unit id="f0e0e96cf6626f01df64dec457720adc8996018c" translate="yes" xml:space="preserve">
          <source>Enums allow us to define a set of named constants. Using enums can make it easier to document intent, or create a set of distinct cases. TypeScript provides both numeric and string-based enums.</source>
          <target state="translated">枚举允许我们定义一组命名的常量。使用 enums 可以使我们更容易记录意图,或者创建一组不同的情况。TypeScript 提供了基于数字和字符串的赋值。</target>
        </trans-unit>
        <trans-unit id="446bd29a002c17497b41b96657fcf40bf1d514a6" translate="yes" xml:space="preserve">
          <source>Enums are compatible with numbers, and numbers are compatible with enums. Enum values from different enum types are considered incompatible. For example,</source>
          <target state="translated">枚举值与数字兼容,数字与枚举值兼容。不同类型的 enum 值被认为是不兼容的。比如说。</target>
        </trans-unit>
        <trans-unit id="9611d38688bf1d99ca887b354676cea9ac16e83d" translate="yes" xml:space="preserve">
          <source>Enums are real objects that exist at runtime. For example, the following enum</source>
          <target state="translated">enums是在运行时存在的真实对象。例如,下面的enum</target>
        </trans-unit>
        <trans-unit id="aa2b9875683168f991703bdf2407bc70e31110ed" translate="yes" xml:space="preserve">
          <source>Enums are very useful, but some programs don&amp;rsquo;t actually need the generated code and would benefit from simply inlining all instances of enum members with their numeric equivalents. The new &lt;code&gt;const enum&lt;/code&gt; declaration works just like a regular &lt;code&gt;enum&lt;/code&gt; for type safety, but erases completely at compile time.</source>
          <target state="translated">枚举非常有用，但是某些程序实际上不需要生成的代码，并且可以通过简单地将枚举成员的所有实例与其数值等效值内联来受益。新的 &lt;code&gt;const enum&lt;/code&gt; 声明的工作方式与用于类型安全性的常规 &lt;code&gt;enum&lt;/code&gt; 一样，但是在编译时会完全删除。</target>
        </trans-unit>
        <trans-unit id="1efbfb0dab275f1ef5a349fd19a692fb55ff662d" translate="yes" xml:space="preserve">
          <source>Enums at compile time</source>
          <target state="translated">编译时的Enums</target>
        </trans-unit>
        <trans-unit id="91ebfc95d6553fab6dcdd9b37826083250ec08fa" translate="yes" xml:space="preserve">
          <source>Enums at runtime</source>
          <target state="translated">运行时的Enums</target>
        </trans-unit>
        <trans-unit id="d12be1b5b741cc430eaddee58fc5792da5e03257" translate="yes" xml:space="preserve">
          <source>Error for not finding &lt;code&gt;moduleB&lt;/code&gt; as it was not passed.</source>
          <target state="translated">找不到 &lt;code&gt;moduleB&lt;/code&gt; 错误，因为未传递。</target>
        </trans-unit>
        <trans-unit id="5dbdd5b8b6b60bfdc1de358cfd5636ff3b41ecfd" translate="yes" xml:space="preserve">
          <source>Error messages in Russian:</source>
          <target state="translated">俄文的错误信息。</target>
        </trans-unit>
        <trans-unit id="805e86a8cbf628e38e4c45612c005a504009e79a" translate="yes" xml:space="preserve">
          <source>Errors</source>
          <target state="translated">Errors</target>
        </trans-unit>
        <trans-unit id="6f19afca75f8b76cf43de3568bc8609dc8d889e8" translate="yes" xml:space="preserve">
          <source>Errors in .js files with &lt;code&gt;--checkJs&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;--checkJs&lt;/code&gt; 文件中的.js文件中的错误</target>
        </trans-unit>
        <trans-unit id="ff7513853508e7c6e3aa07908df2a450a026eb88" translate="yes" xml:space="preserve">
          <source>Evaluation</source>
          <target state="translated">Evaluation</target>
        </trans-unit>
        <trans-unit id="c4995d18bbd28ef5b42bb49d1ba1191de1d44e61" translate="yes" xml:space="preserve">
          <source>Even at this point you can get some great benefits from TypeScript understanding your project. If you open up an editor like &lt;a href=&quot;https://code.visualstudio.com&quot;&gt;VS Code&lt;/a&gt; or &lt;a href=&quot;https://visualstudio.com&quot;&gt;Visual Studio&lt;/a&gt;, you&amp;rsquo;ll see that you can often get some tooling support like completion. You can also catch certain bugs with options like:</source>
          <target state="translated">即使到了这一点，您也可以从TypeScript了解项目中获得很多好处。如果打开诸如&lt;a href=&quot;https://code.visualstudio.com&quot;&gt;VS Code&lt;/a&gt;或&lt;a href=&quot;https://visualstudio.com&quot;&gt;Visual Studio之&lt;/a&gt;类的编辑器，您会发现您通常会获得一些工具支持，例如完成。您还可以使用以下选项捕获某些错误：</target>
        </trans-unit>
        <trans-unit id="30bbcbc5524ea12d314a912290ed9ada676d698e" translate="yes" xml:space="preserve">
          <source>Even better, TypeScript will warn you when you make this mistake if you pass the &lt;code&gt;--noImplicitThis&lt;/code&gt; flag to the compiler. It will point out that &lt;code&gt;this&lt;/code&gt; in &lt;code&gt;this.suits[pickedSuit]&lt;/code&gt; is of type &lt;code&gt;any&lt;/code&gt;.</source>
          <target state="translated">更好的是，如果将 &lt;code&gt;--noImplicitThis&lt;/code&gt; 标志传递给编译器，当您犯此错误时，TypeScript会警告您。它会指出， &lt;code&gt;this&lt;/code&gt; 在 &lt;code&gt;this.suits[pickedSuit]&lt;/code&gt; 是类型的 &lt;code&gt;any&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="173ad8610f22a569603ffb0f1d0d6365bdf43e93" translate="yes" xml:space="preserve">
          <source>Even though Enums are real objects that exist at runtime, the &lt;code&gt;keyof&lt;/code&gt; keyword works differently than you might expect for typical objects. Instead, use &lt;code&gt;keyof typeof&lt;/code&gt; to get a Type that represents all Enum keys as strings.</source>
          <target state="translated">尽管枚举是在运行时存在的真实对象，但 &lt;code&gt;keyof&lt;/code&gt; 关键字的工作原理与您对典型对象的预期不同。而是使用 &lt;code&gt;keyof typeof&lt;/code&gt; 获取一个Type，该Type将所有Enum键表示为字符串。</target>
        </trans-unit>
        <trans-unit id="fce516d03ed65b851ebf38e0525aa5bb18cc7fca" translate="yes" xml:space="preserve">
          <source>Every time the compiler sees a relative module import in a subfolder of one of the &lt;code&gt;rootDirs&lt;/code&gt;, it will attempt to look for this import in each of the entries of &lt;code&gt;rootDirs&lt;/code&gt;.</source>
          <target state="translated">每一个编译器看到一个相对模块导入于一体的子文件夹时 &lt;code&gt;rootDirs&lt;/code&gt; ，它会试图寻找这个进口在每个条目的 &lt;code&gt;rootDirs&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0f01ed56a1e32a05e5ef96e4d779f34784af9a96" translate="yes" xml:space="preserve">
          <source>Example</source>
          <target state="translated">Example</target>
        </trans-unit>
        <trans-unit id="7db0747c7372815c3b79f00827a669c7a4dff2d2" translate="yes" xml:space="preserve">
          <source>Example &lt;code&gt;tsconfig.json&lt;/code&gt; files:</source>
          <target state="translated">&lt;code&gt;tsconfig.json&lt;/code&gt; 文件示例：</target>
        </trans-unit>
        <trans-unit id="eb01bf04c9a0e8a71c45816513df424f1c7ffedb" translate="yes" xml:space="preserve">
          <source>Examples</source>
          <target state="translated">Examples</target>
        </trans-unit>
        <trans-unit id="d90ae2c05a80c11c94b6d08fd48a89595af4e49d" translate="yes" xml:space="preserve">
          <source>Examples of Global Libraries</source>
          <target state="translated">全球图书馆的例子</target>
        </trans-unit>
        <trans-unit id="816ee629d75640df7d32cc7a04c198a2ba361b71" translate="yes" xml:space="preserve">
          <source>Examples of Modular Libraries</source>
          <target state="translated">模块化图书馆的例子</target>
        </trans-unit>
        <trans-unit id="d278e672973bdd09840c8aa311736e998691e0d6" translate="yes" xml:space="preserve">
          <source>Examples of UMD libraries</source>
          <target state="translated">UMD图书馆的例子</target>
        </trans-unit>
        <trans-unit id="713425259fb0fd114e02f534a62ae30601cda2b7" translate="yes" xml:space="preserve">
          <source>Excess Property Checks</source>
          <target state="translated">多余财产支票</target>
        </trans-unit>
        <trans-unit id="547cac401b8bdafefb3c93432b560b402f27bd52" translate="yes" xml:space="preserve">
          <source>Exclude&amp;lt;T,U&amp;gt;</source>
          <target state="translated">Exclude&amp;lt;T,U&amp;gt;</target>
        </trans-unit>
        <trans-unit id="e6d793aeaefda145ae379cd867a6553a054c4ae4" translate="yes" xml:space="preserve">
          <source>Execute Babel from the command line</source>
          <target state="translated">在命令行中执行Babel</target>
        </trans-unit>
        <trans-unit id="36e4946cdd24644aa9627cc6ffbfecf2fb7124a0" translate="yes" xml:space="preserve">
          <source>Exhaustiveness checking</source>
          <target state="translated">疲惫度检查</target>
        </trans-unit>
        <trans-unit id="be111b001bea1086e5ed60f0def95e565522aa10" translate="yes" xml:space="preserve">
          <source>Expansion of rest parameters with tuple types into discrete parameters.</source>
          <target state="translated">将带元组类型的休息参数扩展为离散参数。</target>
        </trans-unit>
        <trans-unit id="0f747d8df97d89385abfc342525e23104fc53d2b" translate="yes" xml:space="preserve">
          <source>Expansion of spread expressions with tuple types into discrete arguments.</source>
          <target state="translated">将具有元组类型的散布表达式扩展为离散参数。</target>
        </trans-unit>
        <trans-unit id="eb541c0761ac733bf3e3daebf487a743c08ec49f" translate="yes" xml:space="preserve">
          <source>Experimental support for &lt;code&gt;async&lt;/code&gt; functions</source>
          <target state="translated">实验性支持 &lt;code&gt;async&lt;/code&gt; 功能</target>
        </trans-unit>
        <trans-unit id="c2368c03d9c425fa5b1b554196b18d9b35543814" translate="yes" xml:space="preserve">
          <source>Explicit types on &lt;code&gt;defaultProps&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;defaultProps&lt;/code&gt; 上的显式类型</target>
        </trans-unit>
        <trans-unit id="7038922b5a5d6db45da593914421a491587b2f7f" translate="yes" xml:space="preserve">
          <source>Explicitly list imported names</source>
          <target state="translated">明确列出进口名称</target>
        </trans-unit>
        <trans-unit id="f3e4fadb9e370a1e2c0c622c01fc8c77daf93a2c" translate="yes" xml:space="preserve">
          <source>Export</source>
          <target state="translated">Export</target>
        </trans-unit>
        <trans-unit id="ee287a51eb5e0d85cc359b2e80f44c061f51aae0" translate="yes" xml:space="preserve">
          <source>Export Declarations</source>
          <target state="translated">出口报关单</target>
        </trans-unit>
        <trans-unit id="3eb5fdc5e694d39f19fe4b7038742fba0274b196" translate="yes" xml:space="preserve">
          <source>Export as close to top-level as possible</source>
          <target state="translated">尽可能接近顶层导出</target>
        </trans-unit>
        <trans-unit id="d426e470cf0b8e87df60e791d67c0cc7797da09b" translate="yes" xml:space="preserve">
          <source>Export statements</source>
          <target state="translated">出口报表</target>
        </trans-unit>
        <trans-unit id="b321b13d568f9f33b7a4846fbc6a9d7e3b9d6029" translate="yes" xml:space="preserve">
          <source>Export statements are handy when exports need to be renamed for consumers, so the above example can be written as:</source>
          <target state="translated">当出口报表需要为消费者重命名时,出口报表就很方便,所以上面的例子可以写成。</target>
        </trans-unit>
        <trans-unit id="f3b534c8bf9a0c462bc4987c3561321862fa8572" translate="yes" xml:space="preserve">
          <source>Exporting a declaration</source>
          <target state="translated">出口申报</target>
        </trans-unit>
        <trans-unit id="20ed777374ec9c640b886c9f9410bc59fc7a8afa" translate="yes" xml:space="preserve">
          <source>Exporting a namespace from your module is an example of adding too many layers of nesting. While namespaces sometime have their uses, they add an extra level of indirection when using modules. This can quickly become a pain point for users, and is usually unnecessary.</source>
          <target state="translated">从你的模块中导出命名空间就是一个例子,它增加了太多的嵌套层。虽然命名空间有时也有其用途,但在使用模块时,它们会增加额外的隐含层。这很快就会成为用户的痛点,而且通常是不必要的。</target>
        </trans-unit>
        <trans-unit id="33b0e248cae60e2ac77c9d292f495d69dfef3e27" translate="yes" xml:space="preserve">
          <source>Exporting from Modules</source>
          <target state="translated">从模块导出</target>
        </trans-unit>
        <trans-unit id="79421f7ea94b7e0cba104ffc2178605b08987de2" translate="yes" xml:space="preserve">
          <source>Expression operators</source>
          <target state="translated">表达式运算符</target>
        </trans-unit>
        <trans-unit id="e03a0c147ab3a0e6973bff36e8c810e9858d8a41" translate="yes" xml:space="preserve">
          <source>Expression operators permit operand types to include &lt;code&gt;null&lt;/code&gt; and/or &lt;code&gt;undefined&lt;/code&gt; but always produce values of non-null and non-undefined types.</source>
          <target state="translated">表达式运算符允许操作数类型包括 &lt;code&gt;null&lt;/code&gt; 和/或 &lt;code&gt;undefined&lt;/code&gt; ,但始终会产生非null和non-undefined类型的值。</target>
        </trans-unit>
        <trans-unit id="dcabbc390e17d15f91473972556065a69ff821df" translate="yes" xml:space="preserve">
          <source>Extending Classes</source>
          <target state="translated">延伸班级</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
