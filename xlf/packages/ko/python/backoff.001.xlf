<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://pypi.org/project/backoff/">
    <body>
      <group id="backoff">
        <trans-unit id="5c10b5b2cd673a0616d529aa5234b12ee7153808" translate="yes" xml:space="preserve">
          <source>,</source>
          <target state="translated">,</target>
        </trans-unit>
        <trans-unit id="8278d2adba7612cf98a492d21a4ac4c78acb1202" translate="yes" xml:space="preserve">
          <source>, and</source>
          <target state="translated">,</target>
        </trans-unit>
        <trans-unit id="90a63bb31aecf55896978f3194d63221fe93d0a2" translate="yes" xml:space="preserve">
          <source>-decorated function may still
need to do exception handling.</source>
          <target state="translated">-decorated 함수는 여전히 예외 처리를 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="a6d58f8e0d971a68c4771edeac2cfab69fba4c32" translate="yes" xml:space="preserve">
          <source>.
This may be useful in reporting statistics or performing other custom
logging.</source>
          <target state="translated">. 이는 통계를보고하거나 다른 사용자 지정 로깅을 수행하는 데 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3a09fbc2ff44e8016d69b15fa437310bb10dcff6" translate="yes" xml:space="preserve">
          <source>. In this case, if desired alternative logging behavior
could be defined by using custom event handlers.</source>
          <target state="translated">. 이 경우 원하는 경우 사용자 지정 이벤트 처리기를 사용하여 대체 로깅 동작을 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2a7e2a74a560968937568ed386fd9142cf5f3863" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;args&lt;/em&gt;: positional arguments to func</source>
          <target state="translated">&lt;em&gt;args&lt;/em&gt; : func에 대한 위치 인수</target>
        </trans-unit>
        <trans-unit id="dfd78ba066a3c318e641052d78abcb8e5ad065a4" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;elapsed&lt;/em&gt;: elapsed time in seconds so far</source>
          <target state="translated">&lt;em&gt;elapsed&lt;/em&gt; : 지금까지 경과 된 시간 (초)</target>
        </trans-unit>
        <trans-unit id="8c0545d4e42723b26dcb92c68343caae530e9a0a" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;kwargs&lt;/em&gt;: keyword arguments to func</source>
          <target state="translated">&lt;em&gt;kwargs&lt;/em&gt; : func에 대한 키워드 인수</target>
        </trans-unit>
        <trans-unit id="ec9983c683159943965e22e9c62c9d055800eead" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;target&lt;/em&gt;: reference to the function or method being invoked</source>
          <target state="translated">&lt;em&gt;target&lt;/em&gt; : 호출되는 함수 또는 메서드에 대한 참조</target>
        </trans-unit>
        <trans-unit id="6931b64be2d37f300eb3637508eda4da20e2af71" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;tries&lt;/em&gt;: number of invocation tries so far</source>
          <target state="translated">&lt;em&gt;시도&lt;/em&gt; : 지금까지 호출 시도 횟수</target>
        </trans-unit>
        <trans-unit id="aebaa6b421e0ff2326c27b851c4dc7c6ba7364da" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;value&lt;/em&gt;: value triggering backoff (</source>
          <target state="translated">&lt;em&gt;값&lt;/em&gt; : 백 오프를 트리거하는 값 (</target>
        </trans-unit>
        <trans-unit id="83b1dafd7c9209d5683ef291b071c278304ff758" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;wait&lt;/em&gt;: seconds to wait (</source>
          <target state="translated">&lt;em&gt;대기&lt;/em&gt; : 대기 시간 (</target>
        </trans-unit>
        <trans-unit id="87a129cdd8433d8a00a59922804e9dda99247d90" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Function decoration for backoff and retry&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;백 오프 및 재 시도를위한 함수 장식&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0e848b69f3e2892e6d444eacdfcf5251eff104fc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Getting exception info&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;예외 정보 얻기&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f6c2dbf107d639fc63d7d67033a0478bc24fbf94" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Give Up Conditions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;조건 포기&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="551add8f4ac65448bbdfec7c19be5ad7f030053a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Multiple handlers per event type&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;이벤트 유형 당 여러 핸들러&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0bde41f87792462eb2be877227d62bf8946cac2f" translate="yes" xml:space="preserve">
          <source>@backoff.on_exception</source>
          <target state="translated">@ backoff.on_exception</target>
        </trans-unit>
        <trans-unit id="6d7aa7ea26009f5a2800c97462928d4bd9e3ec91" translate="yes" xml:space="preserve">
          <source>@backoff.on_predicate</source>
          <target state="translated">@ backoff.on_predicate</target>
        </trans-unit>
        <trans-unit id="e6fd916cad4f34468ccb8375f1369d2c69c12915" translate="yes" xml:space="preserve">
          <source>A handler which prints the details of the backoff event could be
implemented like so:</source>
          <target state="translated">백 오프 이벤트의 세부 사항을 인쇄하는 핸들러는 다음과 같이 구현 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dc6449749fd52d6298e19e3f00c9556d8a7f3f9f" translate="yes" xml:space="preserve">
          <source>A jitter algorithm can be supplied with the</source>
          <target state="translated">지터 알고리즘은</target>
        </trans-unit>
        <trans-unit id="6dde8d34c3e26e04943ea485778d45adae228647" translate="yes" xml:space="preserve">
          <source>As of version 1.2, the default jitter function</source>
          <target state="translated">버전 1.2부터 기본 지터 기능</target>
        </trans-unit>
        <trans-unit id="8277629acfcb602df77bf7b16003d8441fce8ee5" translate="yes" xml:space="preserve">
          <source>Asynchronous code</source>
          <target state="translated">비동기 코드</target>
        </trans-unit>
        <trans-unit id="96265d2c05b9f5357f6954c89577ab90fb7ac4d8" translate="yes" xml:space="preserve">
          <source>Backoff supports asynchronous execution in Python 3.5 and above.</source>
          <target state="translated">Backoff는 Python 3.5 이상에서 비동기 실행을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="4bfd87a6a68b461a2365a6c1d22a3d4bc1f19c8b" translate="yes" xml:space="preserve">
          <source>Both backoff decorators optionally accept event handler functions
using the keyword arguments</source>
          <target state="translated">두 백 오프 데코레이터 모두 키워드 인수를 사용하여 선택적으로 이벤트 핸들러 함수를 허용합니다.</target>
        </trans-unit>
        <trans-unit id="318c75c311e8e14cf5c0dbc86ee333f34b9c24d2" translate="yes" xml:space="preserve">
          <source>By default, backoff and retry attempts are logged to the &amp;lsquo;backoff&amp;rsquo;
logger. By default, this logger is configured with a NullHandler, so
there will be nothing output unless you configure a handler.
Programmatically, this might be accomplished with something as simple
as:</source>
          <target state="translated">기본적으로 백 오프 및 재시도 시도는 '백 오프'로거에 기록됩니다. 기본적으로이 로거는 NullHandler로 구성되므로 처리기를 구성하지 않으면 출력이 없습니다. 프로그래밍 방식으로 다음과 같이 간단한 방법으로 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ef7e401c25dd6ae87144a52fa5d0354d8586c594" translate="yes" xml:space="preserve">
          <source>Decorators support both regular functions for synchronous code and
&lt;a href=&quot;https://docs.python.org/3/library/asyncio.html&quot;&gt;asyncio&lt;/a&gt;&amp;rsquo;s coroutines
for asynchronous code.</source>
          <target state="translated">데코레이터는 동기 코드를위한 일반 함수와 비동기 코드를위한 &lt;a href=&quot;https://docs.python.org/3/library/asyncio.html&quot;&gt;asyncio&lt;/a&gt; 코 루틴을 모두 지원합니다 .</target>
        </trans-unit>
        <trans-unit id="4bb99e856dea0b88518519339118a3c5d0fa7c7c" translate="yes" xml:space="preserve">
          <source>Default logging can be disabled all together by specifying</source>
          <target state="translated">기본 로깅은 다음을 지정하여 모두 비활성화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1d0a0bc46dabda5a6dbcf0a2f18e3e9acbc27ae7" translate="yes" xml:space="preserve">
          <source>Event handlers</source>
          <target state="translated">이벤트 핸들러</target>
        </trans-unit>
        <trans-unit id="eb01bf04c9a0e8a71c45816513df424f1c7ffedb" translate="yes" xml:space="preserve">
          <source>Examples</source>
          <target state="translated">예</target>
        </trans-unit>
        <trans-unit id="8548c32df11b47436b77713ee1818090b42adb4a" translate="yes" xml:space="preserve">
          <source>Extra keyword arguments are passed when initializing the
wait generator, so the</source>
          <target state="translated">대기 생성기를 초기화 할 때 추가 키워드 인수가 전달되므로</target>
        </trans-unit>
        <trans-unit id="842f406064f2a8940c26bb023caa19a7d5cfbc65" translate="yes" xml:space="preserve">
          <source>Function decoration for backoff and retry</source>
          <target state="translated">백 오프 및 재 시도를위한 함수 장식</target>
        </trans-unit>
        <trans-unit id="965ca5a5200702e7e2c17a9d1e689e2a85aaa0a2" translate="yes" xml:space="preserve">
          <source>Handlers must be callables with a unary signature accepting a dict
argument. This dict contains the details of the invocation. Valid keys
include:</source>
          <target state="translated">핸들러는 dict 인수를 허용하는 단항 서명이있는 콜 러블이어야합니다. 이 dict에는 호출 세부 사항이 포함되어 있습니다. 유효한 키는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="976ba0b3f3d1500e284893871e638c8e6ef54068" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s an example which uses a fibonacci sequence backoff when the
return value of the target function is the empty list:</source>
          <target state="translated">다음은 대상 함수의 반환 값이 빈 목록 일 때 피보나치 시퀀스 백 오프를 사용하는 예입니다.</target>
        </trans-unit>
        <trans-unit id="4e3e3b622a1d30df4cdbe5caf8b7e03c55b57bac" translate="yes" xml:space="preserve">
          <source>In all cases, iterables of handler functions are also accepted, which
are called in turn. For example, you might provide a simple list of
handler functions as the value of the</source>
          <target state="translated">모든 경우에 핸들러 함수의 이터 러블도 허용되며 차례로 호출됩니다. 예를 들어, 간단한 핸들러 함수 목록을</target>
        </trans-unit>
        <trans-unit id="1003d9c9fc0ab02f7e70c56589df98f30061835a" translate="yes" xml:space="preserve">
          <source>In some cases the raised exception instance itself may need to be
inspected in order to determine if it is a retryable condition. The</source>
          <target state="translated">어떤 경우에는 발생한 예외 인스턴스 자체를 검사하여 재시도 가능한 조건인지 확인해야 할 수도 있습니다. 그만큼</target>
        </trans-unit>
        <trans-unit id="7ed84ab6b5608ec53c300dfeca86893cb101cd3d" translate="yes" xml:space="preserve">
          <source>In the case of the</source>
          <target state="translated">의 경우</target>
        </trans-unit>
        <trans-unit id="b010576ebc543abd3692e57f27392f714005c646" translate="yes" xml:space="preserve">
          <source>It is also possible to specify an alternate logger with the</source>
          <target state="translated">다음을 사용하여 대체 로거를 지정할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="b15f24c3efa82c27eb813106ed5b08a8ae7a0d32" translate="yes" xml:space="preserve">
          <source>It is also supported to specify a Logger (or LoggerAdapter) object
directly.</source>
          <target state="translated">Logger (또는 LoggerAdapter) 개체를 직접 지정하는 것도 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="70a5b3c8eeaa674ea3790971e290d22205948eed" translate="yes" xml:space="preserve">
          <source>Jitter</source>
          <target state="translated">지터</target>
        </trans-unit>
        <trans-unit id="9aaa1a381dcc0e6e8917fc93ec91556612a58ab9" translate="yes" xml:space="preserve">
          <source>Keyword argument</source>
          <target state="translated">키워드 인수</target>
        </trans-unit>
        <trans-unit id="2ebee8b95304d6f2641fb64aa8296a4b89bfa1d6" translate="yes" xml:space="preserve">
          <source>Logging configuration</source>
          <target state="translated">로깅 구성</target>
        </trans-unit>
        <trans-unit id="fb264b08d8e7d7ca99131988c482768cfbbdad2e" translate="yes" xml:space="preserve">
          <source>More simply, a function which continues polling every second until it
gets a non-falsey result could be defined like like this:</source>
          <target state="translated">더 간단하게, 거짓이 아닌 결과를 얻을 때까지 매초마다 계속 폴링하는 함수는 다음과 같이 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7074c51adff5fe8077a44fc37dfe15c3d888a94d" translate="yes" xml:space="preserve">
          <source>Optional keyword arguments can specify conditions under which to give
up.</source>
          <target state="translated">선택적 키워드 인수는 포기할 조건을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="130cfc058c7d998616e2eec552a73c41bac6d39a" translate="yes" xml:space="preserve">
          <source>Previous versions of backoff defaulted to adding some random number of
milliseconds (up to 1s) to the raw sleep value. If desired, this
behavior is now available as</source>
          <target state="translated">이전 버전의 백 오프는 기본적으로 원시 절전 값에 임의의 밀리 초 (최대 1 초)를 추가했습니다. 원하는 경우이 동작은 이제 다음과 같이 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="222cad2bd37e45b5f33d5d967590f4b613622bfd" translate="yes" xml:space="preserve">
          <source>Runtime Configuration</source>
          <target state="translated">런타임 구성</target>
        </trans-unit>
        <trans-unit id="80311937e5f169e8775775b4cb00be4bad3ff41b" translate="yes" xml:space="preserve">
          <source>Since Kenneth Reitz&amp;rsquo;s &lt;a href=&quot;http://python-requests.org&quot;&gt;requests&lt;/a&gt; module
has become a defacto standard for synchronous HTTP clients in Python,
networking examples below are written using it, but it is in no way required
by the backoff module.</source>
          <target state="translated">Kenneth Reitz의 &lt;a href=&quot;http://python-requests.org&quot;&gt;요청&lt;/a&gt; 모듈이 Python의 동기식 HTTP 클라이언트에 대한 사실상의 표준이 되었기 때문에 아래의 네트워킹 예제가이를 사용하여 작성되었지만 백 오프 모듈에 필요한 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="93ef0dd827103681fcee453b78be2ff14e1a261d" translate="yes" xml:space="preserve">
          <source>The</source>
          <target state="translated">그만큼</target>
        </trans-unit>
        <trans-unit id="a1300be1037211dd17daeea4a61bd04c4b3d348d" translate="yes" xml:space="preserve">
          <source>The backoff decorators may also be combined to specify different
backoff behavior for different cases:</source>
          <target state="translated">백 오프 데코레이터를 결합하여 다른 경우에 다른 백 오프 동작을 지정할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="6808d8b00d91ba9be9ceb865b10b088f93f09fba" translate="yes" xml:space="preserve">
          <source>The decorator functions</source>
          <target state="translated">데코레이터 기능</target>
        </trans-unit>
        <trans-unit id="4fd61cdc0f9215a43f3229ce364ff4b43d81daf9" translate="yes" xml:space="preserve">
          <source>The decorator will also accept a tuple of exceptions for cases where
the same backoff behavior is desired for more than one exception type:</source>
          <target state="translated">데코레이터는 또한 둘 이상의 예외 유형에 대해 동일한 백 오프 동작이 필요한 경우 예외 튜플을 허용합니다.</target>
        </trans-unit>
        <trans-unit id="4ffe89f92aa1721f1cf4ca5d509ab4e24b6b9c8d" translate="yes" xml:space="preserve">
          <source>The default logging level is INFO, which corresponds to logging
anytime a retry event occurs. If you would instead like to log
only when a giveup event occurs, set the logger level to ERROR.</source>
          <target state="translated">기본 로깅 수준은 INFO이며 재시도 이벤트가 발생할 때마다 로깅에 해당합니다. 대신 포기 이벤트가 발생할 때만 기록하려면 로거 수준을 ERROR로 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="9b748d80f0f4f4eca1bdac9cac21ea2760233073" translate="yes" xml:space="preserve">
          <source>The following examples use &lt;a href=&quot;https://aiohttp.readthedocs.io/&quot;&gt;aiohttp&lt;/a&gt;
asynchronous HTTP client/server library.</source>
          <target state="translated">다음 예제는 &lt;a href=&quot;https://aiohttp.readthedocs.io/&quot;&gt;aiohttp&lt;/a&gt; 비동기 HTTP 클라이언트 / 서버 라이브러리를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="8babceca3345543f64ae1f6dc816baed9fc6b6cb" translate="yes" xml:space="preserve">
          <source>The keyword argument</source>
          <target state="translated">키워드 인수</target>
        </trans-unit>
        <trans-unit id="4ea583cb63d3b492dc8bdb9071ca2a85ad974b45" translate="yes" xml:space="preserve">
          <source>This module provides function decorators which can be used to wrap a
function such that it will be retried until some condition is met. It
is meant to be of use when accessing unreliable resources with the
potential for intermittent failures i.e. network resources and external
APIs. Somewhat more generally, it may also be of use for dynamically
polling resources for externally generated content.</source>
          <target state="translated">이 모듈은 일부 조건이 충족 될 때까지 다시 시도되도록 함수를 래핑하는 데 사용할 수있는 함수 데코레이터를 제공합니다. 간헐적 인 오류 (예 : 네트워크 리소스 및 외부 API)의 가능성이있는 신뢰할 수없는 리소스에 액세스 할 때 사용하기위한 것입니다. 좀 더 일반적으로 외부에서 생성 된 콘텐츠에 대한 리소스를 동적으로 폴링하는데도 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5b62c692188e74042ed4ac3596b109553329f5f6" translate="yes" xml:space="preserve">
          <source>To use backoff in asynchronous code based on
&lt;a href=&quot;https://docs.python.org/3/library/asyncio.html&quot;&gt;asyncio&lt;/a&gt;
you simply need to apply</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/library/asyncio.html&quot;&gt;asyncio&lt;/a&gt; 기반 비동기 코드에서 백 오프를 사용하려면 간단히 적용하면됩니다.</target>
        </trans-unit>
        <trans-unit id="1e89e75f9a3b03d5875f7198d0b26223e016d739" translate="yes" xml:space="preserve">
          <source>Using multiple decorators</source>
          <target state="translated">여러 데코레이터 사용</target>
        </trans-unit>
        <trans-unit id="db476ea02bfda997c6f84abede63f9e1fa009fe6" translate="yes" xml:space="preserve">
          <source>When a give up event occurs, the exception in question is reraised
and so code calling an</source>
          <target state="translated">포기 이벤트가 발생하면 해당 예외가 다시 발생하므로 코드를 호출하여</target>
        </trans-unit>
        <trans-unit id="e0ff4106a7634bdf197aab35ef83d93777bbb8be" translate="yes" xml:space="preserve">
          <source>When not specified, the predicate param defaults to the falsey test,
so the above can more concisely be written:</source>
          <target state="translated">지정되지 않은 경우 술어 매개 변수는 기본적으로 거짓 테스트로 설정되므로 위의 내용을 더 간결하게 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cffa50a32cb13a240d705317bcec65dd1f31b6ad" translate="yes" xml:space="preserve">
          <source>and</source>
          <target state="translated">과</target>
        </trans-unit>
        <trans-unit id="54ab597856e732f26d81ef11672f12bd22d8bd79" translate="yes" xml:space="preserve">
          <source>are
generally evaluated at import time. This is fine when the keyword args
are passed as constant values, but suppose we want to consult a
dictionary with configuration options that only become available at
runtime. The relevant values are not available at import time. Instead,
decorator functions can be passed callables which are evaluated at
runtime to obtain the value:</source>
          <target state="translated">일반적으로 가져올 때 평가됩니다. 키워드 args가 상수 값으로 전달되는 경우에는 문제가 없지만 런타임에만 사용할 수있는 구성 옵션이있는 사전을 참조하려고한다고 가정합니다. 가져올 때 관련 값을 사용할 수 없습니다. 대신, 데코레이터 함수는 값을 얻기 위해 런타임에 평가되는 콜 러블을 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="33992bda86ce5e398daa20c60a44384d076932f7" translate="yes" xml:space="preserve">
          <source>backoff</source>
          <target state="translated">물러나 다</target>
        </trans-unit>
        <trans-unit id="883fbad72cde00d78793e0adb7ebce26785fd48c" translate="yes" xml:space="preserve">
          <source>backoff.full_jitter</source>
          <target state="translated">backoff.full_jitter</target>
        </trans-unit>
        <trans-unit id="6d209351faf6cd160018566e5d6291773f86d57a" translate="yes" xml:space="preserve">
          <source>backoff.on_exception</source>
          <target state="translated">backoff.on_exception</target>
        </trans-unit>
        <trans-unit id="76213c773d1d4c253faab360ccfbd56db2974d83" translate="yes" xml:space="preserve">
          <source>backoff.on_predicate</source>
          <target state="translated">backoff.on_predicate</target>
        </trans-unit>
        <trans-unit id="dd2c9c3da740e6fcbb8aa485a4a2c4ba85f69a82" translate="yes" xml:space="preserve">
          <source>backoff.random_jitter</source>
          <target state="translated">backoff.random_jitter</target>
        </trans-unit>
        <trans-unit id="6302daa274d5f40479278fadea5058fece41bdf2" translate="yes" xml:space="preserve">
          <source>decorator is used to retry when a particular
condition is true of the return value of the target function.  This may
be useful when polling a resource for externally generated content.</source>
          <target state="translated">데코레이터는 대상 함수의 반환 값에 대해 특정 조건이 참일 때 재 시도하는 데 사용됩니다. 이는 외부에서 생성 된 콘텐츠에 대한 리소스를 폴링 할 때 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2dcdbddeb8e5af4e252faa32ba58ef1a93e84077" translate="yes" xml:space="preserve">
          <source>decorator is used to retry when a specified exception
is raised. Here&amp;rsquo;s an example using exponential backoff when any</source>
          <target state="translated">데코레이터는 지정된 예외가 발생할 때 재 시도하는 데 사용됩니다. 다음은 지수 백 오프를 사용하는 예입니다.</target>
        </trans-unit>
        <trans-unit id="d8fd4ed07c5bcf64ff34124afba87df495b2dade" translate="yes" xml:space="preserve">
          <source>decorator only)</source>
          <target state="translated">데코레이터 만 해당)</target>
        </trans-unit>
        <trans-unit id="dc0ba2e25de0a6ceb23ceec1ba6543a1b3193aaf" translate="yes" xml:space="preserve">
          <source>decorator, all</source>
          <target state="translated">데코레이터, 모두</target>
        </trans-unit>
        <trans-unit id="c583e253674b8faed4ea3b06d969d80f8bf28fe4" translate="yes" xml:space="preserve">
          <source>event handlers, with the interface otherwise being identical.</source>
          <target state="translated">인터페이스가 동일하지 않은 이벤트 핸들러.</target>
        </trans-unit>
        <trans-unit id="3362aa4886a690e2310ba2f4ccf246fd533d38e5" translate="yes" xml:space="preserve">
          <source>exception is raised:</source>
          <target state="translated">예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="c1908a2cba1e490ae68d447210006357a26b91da" translate="yes" xml:space="preserve">
          <source>giveup</source>
          <target state="translated">포기</target>
        </trans-unit>
        <trans-unit id="02a6f585713df2740f3ac6113f0755bb7067356a" translate="yes" xml:space="preserve">
          <source>handler only)</source>
          <target state="translated">핸들러 만)</target>
        </trans-unit>
        <trans-unit id="1ef6fcc7985aa5b73889100f791ba5b0e2c79b11" translate="yes" xml:space="preserve">
          <source>handlers are called from within the except block for the
exception being handled. Therefore exception info is available to the
handler functions via the python standard library, specifically</source>
          <target state="translated">처리중인 예외에 대해 except 블록 내에서 핸들러가 호출됩니다. 따라서 예외 정보는 특히 파이썬 표준 라이브러리를 통해 핸들러 함수에서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cd97bcc8f09050b324c9e8f060d8bbd9742ba0a0" translate="yes" xml:space="preserve">
          <source>implements the &amp;lsquo;Full Jitter&amp;rsquo; algorithm as defined in the AWS
Architecture Blog&amp;rsquo;s &lt;a href=&quot;https://www.awsarchitectureblog.com/2015/03/backoff.html&quot;&gt;Exponential Backoff And Jitter&lt;/a&gt; post.
Note that with this algorithm, the time yielded by the wait generator
is actually the &lt;em&gt;maximum&lt;/em&gt; amount of time to wait.</source>
          <target state="translated">AWS 아키텍처 블로그의 &lt;a href=&quot;https://www.awsarchitectureblog.com/2015/03/backoff.html&quot;&gt;지수 백 오프 및 지터&lt;/a&gt; 게시물에 정의 된대로 '전체 지터'알고리즘을 구현합니다 . 이 알고리즘을 사용하면 대기 생성기가 생성 한 시간이 실제로 대기 할 &lt;em&gt;최대&lt;/em&gt; 시간입니다.</target>
        </trans-unit>
        <trans-unit id="dd70fee7318e50e2fc644c67e5e0149e17e005de" translate="yes" xml:space="preserve">
          <source>jitter</source>
          <target state="translated">지터</target>
        </trans-unit>
        <trans-unit id="23cd92941bb91f11acce7147fe5d5f0df91a6f28" translate="yes" xml:space="preserve">
          <source>keyword arg can be used to specify a function which accepts
the exception and returns a truthy value if the exception should not
be retried:</source>
          <target state="translated">키워드 arg는 예외를 받아들이고 예외를 재 시도해서는 안되는 경우 진실 된 값을 반환하는 함수를 지정하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fd25e57f1179439e43e9176b29603a8e4daf6c01" translate="yes" xml:space="preserve">
          <source>keyword arg to
either of the backoff decorators. This argument should be a function
accepting the original unadulterated backoff value and returning it&amp;rsquo;s
jittered counterpart.</source>
          <target state="translated">백 오프 데코레이터 중 하나에 키워드 arg. 이 인수는 원래의 완전한 백 오프 값을 받아들이고 지터가있는 상대 값을 반환하는 함수 여야합니다.</target>
        </trans-unit>
        <trans-unit id="8902082efd7d95ef030b2725ddaa341e9abb259a" translate="yes" xml:space="preserve">
          <source>keyword arg:</source>
          <target state="translated">키워드 인수 :</target>
        </trans-unit>
        <trans-unit id="734b09307197ce7ee36d76fa36ac8ba6c869d00d" translate="yes" xml:space="preserve">
          <source>keyword argument.  If a string value is specified the logger will be
looked up by name.</source>
          <target state="translated">키워드 인수. 문자열 값이 지정되면 로거는 이름으로 조회됩니다.</target>
        </trans-unit>
        <trans-unit id="16cc54fff246b441f70de548a07315312e912e1b" translate="yes" xml:space="preserve">
          <source>logger</source>
          <target state="translated">나무꾼</target>
        </trans-unit>
        <trans-unit id="ca17dd53223e9c38ef8f4de47aefda840d75b77a" translate="yes" xml:space="preserve">
          <source>logger=None</source>
          <target state="translated">logger = 없음</target>
        </trans-unit>
        <trans-unit id="99cfebf41aabaab987d279328c13aa572af56d72" translate="yes" xml:space="preserve">
          <source>max_time</source>
          <target state="translated">max_time</target>
        </trans-unit>
        <trans-unit id="b34a389b4430eaf8437f3b1eff0165353d3d90b9" translate="yes" xml:space="preserve">
          <source>max_tries</source>
          <target state="translated">max_tries</target>
        </trans-unit>
        <trans-unit id="444da5b0eb3c62d0024a8c8fbc551f62d0962a84" translate="yes" xml:space="preserve">
          <source>max_value</source>
          <target state="translated">최대 _ 값</target>
        </trans-unit>
        <trans-unit id="a21867509c883fff7a024de5f5d5839d06e9f445" translate="yes" xml:space="preserve">
          <source>module.</source>
          <target state="translated">기준 치수.</target>
        </trans-unit>
        <trans-unit id="53f1da882133377426e903990a9b646cdb58c26c" translate="yes" xml:space="preserve">
          <source>on_backoff</source>
          <target state="translated">on_backoff</target>
        </trans-unit>
        <trans-unit id="86a7062cb7f642e0f803cb0a235ead0ed02fd061" translate="yes" xml:space="preserve">
          <source>on_exception</source>
          <target state="translated">on_exception</target>
        </trans-unit>
        <trans-unit id="9fa3f957808be6e115183e4eb3da38a710f3d645" translate="yes" xml:space="preserve">
          <source>on_giveup</source>
          <target state="translated">포기할 때</target>
        </trans-unit>
        <trans-unit id="4ccc9a3f9a447f10b552d03cab8572bb09b0e946" translate="yes" xml:space="preserve">
          <source>on_predicate</source>
          <target state="translated">on_predicate</target>
        </trans-unit>
        <trans-unit id="cbbb521981be089fc497be6f4d6939d3b2d48351" translate="yes" xml:space="preserve">
          <source>on_success</source>
          <target state="translated">on_success</target>
        </trans-unit>
        <trans-unit id="1758356db21759f7c5a0da9b4dd1db8fd6feab3f" translate="yes" xml:space="preserve">
          <source>or</source>
          <target state="translated">또는</target>
        </trans-unit>
        <trans-unit id="6f0b2ce24add914e491c80aacf6014cb9e1b7f98" translate="yes" xml:space="preserve">
          <source>or the</source>
          <target state="translated">아니면 그</target>
        </trans-unit>
        <trans-unit id="392a1ae1ace3f90b99c6a1b593e3a896950d0a10" translate="yes" xml:space="preserve">
          <source>param above is passed as a keyword
arg when initializing the fibo generator.</source>
          <target state="translated">위의 param은 fibo 생성기를 초기화 할 때 키워드 arg로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="54faec366d11efdac0f9d2da560e273f92288c2a" translate="yes" xml:space="preserve">
          <source>requests</source>
          <target state="translated">요청</target>
        </trans-unit>
        <trans-unit id="8c3ffb6a96195a147c7dde1f03492d5e0cdff303" translate="yes" xml:space="preserve">
          <source>specifies the maximum amount
of total time in seconds that can elapse before giving up.</source>
          <target state="translated">포기하기 전에 경과 할 수있는 최대 총 시간 (초)을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="2e07abea61bef93a94f8fb642448b9b6c5d7d8be" translate="yes" xml:space="preserve">
          <source>specifies the maximum number of calls
to make to the target function before giving up.</source>
          <target state="translated">포기하기 전에 대상 함수에 대한 최대 호출 수를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="268327991ab40460122814287fd515d2ebb9b960" translate="yes" xml:space="preserve">
          <source>sys.exc_info()</source>
          <target state="translated">sys.exc_info ()</target>
        </trans-unit>
        <trans-unit id="8bdf48221c79cdff6f82682481fb3aac85a04a04" translate="yes" xml:space="preserve">
          <source>to coroutines.
You can also use coroutines for the</source>
          <target state="translated">코 루틴에. 코 루틴을 사용하여</target>
        </trans-unit>
        <trans-unit id="efac37b56b3a17b838dbca790f381ac20a5f457c" translate="yes" xml:space="preserve">
          <source>traceback</source>
          <target state="translated">역 추적</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
