<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://pypi.org/project/asyncscope/">
    <body>
      <group id="asyncscope">
        <trans-unit id="80e2beb36491b20581dbcedf302120f4e7151f17" translate="yes" xml:space="preserve">
          <source>&amp;ldquo;Clean termination&amp;rdquo; means that the scope&amp;rsquo;s call to</source>
          <target state="translated">&quot;깨끗한 종료&quot;는 스코프가</target>
        </trans-unit>
        <trans-unit id="a77cb6b5652c4005532755d55df9906e50c68b74" translate="yes" xml:space="preserve">
          <source>&amp;rsquo;s global</source>
          <target state="translated">의 글로벌</target>
        </trans-unit>
        <trans-unit id="947cab548ff029f91ef570a175d1383baf0a5828" translate="yes" xml:space="preserve">
          <source>(subordinate task) or wait for SIGTERM (daemon main task)
or terminate (main task&amp;rsquo;s job is done)</source>
          <target state="translated">(하위 작업) 또는 SIGTERM (데몬 기본 작업)을 기다리거나 종료 (기본 작업의 작업이 완료 됨)</target>
        </trans-unit>
        <trans-unit id="3a52ce780950d4d969792a2559cd519d7ee8c727" translate="yes" xml:space="preserve">
          <source>.</source>
          <target state="translated">.</target>
        </trans-unit>
        <trans-unit id="9e3edd5906a2460bab23ca2086bbd93812e1625e" translate="yes" xml:space="preserve">
          <source>. This function returns the new tasks&amp;rsquo;s cancel scope so that you
can cancel the new task if you need to. All tasks started that way are
auto-cancelled when your main code exits.</source>
          <target state="translated">. 이 함수는 필요한 경우 새 작업을 취소 할 수 있도록 새 작업의 취소 범위를 반환합니다. 그런 식으로 시작된 모든 작업은 기본 코드가 종료되면 자동 취소됩니다.</target>
        </trans-unit>
        <trans-unit id="b54ad0f09fdbeb343c772bec07e2001d8693d217" translate="yes" xml:space="preserve">
          <source>A scope&amp;rsquo;s main code typically looks like this:</source>
          <target state="translated">범위의 기본 코드는 일반적으로 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6f7fcc06f5a43a47848f403f55c311da91fec7d8" translate="yes" xml:space="preserve">
          <source>Alternately, if the service is created by an async context manager:</source>
          <target state="translated">또는 서비스가 비동기 컨텍스트 관리자에 의해 생성 된 경우 :</target>
        </trans-unit>
        <trans-unit id="d3a30a245e5eb40f2058c501aadf106d3644b773" translate="yes" xml:space="preserve">
          <source>Another part of your program also needs the error handler database
connections and loading a handler are expensive, so you want to re-use
them.</source>
          <target state="translated">프로그램의 또 다른 부분에는 오류 처리기 데이터베이스 연결이 필요하며 처리기를로드하는 데 비용이 많이 들기 때문에 다시 사용하고 싶습니다.</target>
        </trans-unit>
        <trans-unit id="1264ac5499d19a2dc2fda3977b57eb2f7ced1f68" translate="yes" xml:space="preserve">
          <source>AsyncScope can help you.</source>
          <target state="translated">AsyncScope가 도움이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="096c62d357c259f713d3671465a274cf7b4ecf8e" translate="yes" xml:space="preserve">
          <source>AsyncScope keeps track of your program&amp;rsquo;s building blocks. It remembers
which parts depend on which other parts, prevents cyclic dependencies,
and terminates a scope as soon as nobody uses it any more.</source>
          <target state="translated">AsyncScope는 프로그램의 빌딩 블록을 추적합니다. 어떤 부분이 다른 부분에 의존하는지 기억하고 순환 종속성을 방지하며 아무도 더 이상 사용하지 않는 즉시 범위를 종료합니다.</target>
        </trans-unit>
        <trans-unit id="59b0482bdded1133e8a5fead2d8afd30f974346d" translate="yes" xml:space="preserve">
          <source>Cancellation semantics</source>
          <target state="translated">취소 의미론</target>
        </trans-unit>
        <trans-unit id="c6a3981c0605028beccb698a3439ee4282147add" translate="yes" xml:space="preserve">
          <source>Code structure</source>
          <target state="translated">코드 구조</target>
        </trans-unit>
        <trans-unit id="aeaea4443a2ba13db76c47382325d4718b4ff08c" translate="yes" xml:space="preserve">
          <source>Every scope has a separate taskgroup which you can access by calling</source>
          <target state="translated">모든 범위에는 다음을 호출하여 액세스 할 수있는 별도의 작업 그룹이 있습니다.</target>
        </trans-unit>
        <trans-unit id="751c68a3471b1c791efaee0a8e7c24ea0c266efd" translate="yes" xml:space="preserve">
          <source>If</source>
          <target state="translated">만약</target>
        </trans-unit>
        <trans-unit id="e6f0de840ad4353a783325b26597620059fe57d4" translate="yes" xml:space="preserve">
          <source>Large programs often consist of building blocks which depend on each other.
Those dependencies may be non-trivial, aren&amp;rsquo;t always linear, and generally
form some sort of directed acyclic graph instead of a nice linear or
hierarchical set of relationships.</source>
          <target state="translated">대형 프로그램은 종종 서로 의존하는 빌딩 블록으로 구성됩니다. 이러한 종속성은 사소하지 않을 수 있으며 항상 선형이 아니며 일반적으로 멋진 선형 또는 계층 적 관계 집합 대신 일종의 방향성 비순환 그래프를 형성합니다.</target>
        </trans-unit>
        <trans-unit id="dc6898c4cf754556aa24ff98774c9a7b8b48737e" translate="yes" xml:space="preserve">
          <source>Later the admin code terminates. It can&amp;rsquo;t unload the error handler because
that other code still needs it.</source>
          <target state="translated">나중에 관리자 코드가 종료됩니다. 다른 코드에 여전히 필요하기 때문에 오류 처리기를 언로드 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="2826b3b8d53942e914dd917cc08e57bfef8efe4d" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s invent an example.</source>
          <target state="translated">예를 만들어 봅시다.</target>
        </trans-unit>
        <trans-unit id="4835fbb132d02a0d1324d266ab9d295c5a2c2a3b" translate="yes" xml:space="preserve">
          <source>Now your error handler stays around exactly as long as you need it, your
database connection won&amp;rsquo;t die while the error handler (or any other code,
for that matter) requires it, your error gets logged correctly, and you
find the problem easily.</source>
          <target state="translated">이제 오류 처리기가 필요한만큼 정확하게 유지되고, 오류 처리기 (또는 다른 코드)가 필요로하는 동안 데이터베이스 연결이 중단되지 않고 오류가 올바르게 기록되고 문제를 쉽게 찾을 수 있습니다. .</target>
        </trans-unit>
        <trans-unit id="98365abf7a35b55e3b549f20aa17daee9fe3c995" translate="yes" xml:space="preserve">
          <source>Rationale</source>
          <target state="translated">이론적 해석</target>
        </trans-unit>
        <trans-unit id="7e42e371e1139786764c46314b85ef21b7a750d7" translate="yes" xml:space="preserve">
          <source>Scopes typically don&amp;rsquo;t need to access its own scope object. It&amp;rsquo;s stored in
a contextvar and can be retrieved via</source>
          <target state="translated">일반적으로 범위는 자체 범위 개체에 액세스 할 필요가 없습니다. contextvar에 저장되며 다음을 통해 검색 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2507c2b55d5db39a9f83e01f96320bf24ea1b23a" translate="yes" xml:space="preserve">
          <source>Start a service task (i.e. something you depend on) with</source>
          <target state="translated">서비스 작업 (즉, 의존하는 것)을 시작합니다.</target>
        </trans-unit>
        <trans-unit id="674c454ba310e310a32c1322e2e45801d1bb9239" translate="yes" xml:space="preserve">
          <source>TODO: write a service which your code can use to keep another service alive
for a bit.</source>
          <target state="translated">TODO : 다른 서비스를 잠시 유지하는 데 사용할 수있는 서비스를 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="6c1e956d40870f2b75767e81f9483d9dda74fe72" translate="yes" xml:space="preserve">
          <source>Task scopes for AnyIO</source>
          <target state="translated">AnyIO의 작업 범위</target>
        </trans-unit>
        <trans-unit id="93ef0dd827103681fcee453b78be2ff14e1a261d" translate="yes" xml:space="preserve">
          <source>The</source>
          <target state="translated">그만큼</target>
        </trans-unit>
        <trans-unit id="36e03547626d68a092132496f04f21d59aeb8d83" translate="yes" xml:space="preserve">
          <source>The current scope is available as the</source>
          <target state="translated">현재 범위는</target>
        </trans-unit>
        <trans-unit id="125c5e78921cb603c94d4f0c951d3ab16641dddf" translate="yes" xml:space="preserve">
          <source>The service&amp;rsquo;s setup code typically looks like this:</source>
          <target state="translated">서비스의 설정 코드는 일반적으로 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="641fa6952b7f92fe6e90337e9bdda258ee4ff9af" translate="yes" xml:space="preserve">
          <source>This also happens when a scope&amp;rsquo;s main task ends.</source>
          <target state="translated">이는 범위의 기본 작업이 종료 될 때도 발생합니다.</target>
        </trans-unit>
        <trans-unit id="8a3cc2e8c196435d99f13f9317c2637176c56fc5" translate="yes" xml:space="preserve">
          <source>This is a problem because you like to use Structured Programming
principles. Thus you need to jump through interesting hoops getting all of
this connected up and keeping track of each module&amp;rsquo;s users.</source>
          <target state="translated">구조적 프로그래밍 원칙을 사용하기 때문에 이것은 문제입니다. 따라서이 모든 것을 연결하고 각 모듈의 사용자를 추적하는 흥미로운 농구를 통과해야합니다.</target>
        </trans-unit>
        <trans-unit id="85c3cae45815aa53d8bdc35b0cd38e9e00c3fae1" translate="yes" xml:space="preserve">
          <source>This library implements scoped taskgroups / nurseries.</source>
          <target state="translated">이 라이브러리는 범위가 지정된 작업 그룹 / nurseries를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="0bb18642b70b9f8a9c12ccf39487328f306b8e19" translate="yes" xml:space="preserve">
          <source>Usage</source>
          <target state="translated">용법</target>
        </trans-unit>
        <trans-unit id="711e7706d1362390d17b75a0e39f6c52a84dafe5" translate="yes" xml:space="preserve">
          <source>When a scope exits (either cleanly or when it raises an error that escapes
its taskgroup), all scopes depending on it are cancelled immediately, in
parallel. Then those it itself depends on are terminated cleanly and
in-order.</source>
          <target state="translated">범위가 종료되면 (완전히 또는 작업 그룹을 벗어나는 오류가 발생하는 경우) 이에 종속 된 모든 범위가 병렬로 즉시 취소됩니다. 그런 다음 그 자체가 의존하는 것은 깨끗하고 순서대로 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="88d45e6a980f0df68d27ce165ed197e0a5665884" translate="yes" xml:space="preserve">
          <source>Worse, assume that your code dies with a fatal exception. The exception
typically propagates through your code and cancels the database connection
before the error handler has a chance to log the problem. This happens
randomly, depending on which cancelled task runs first, so you have a lot
of fun trying to reproduce the problem and debug all of this.</source>
          <target state="translated">더 나쁜 것은 코드가 치명적인 예외와 함께 죽는다고 가정하는 것입니다. 예외는 일반적으로 코드를 통해 전파되고 오류 처리기가 문제를 기록하기 전에 데이터베이스 연결을 취소합니다. 이것은 어떤 취소 된 작업이 먼저 실행되는지에 따라 무작위로 발생하므로 문제를 재현하고이 모든 것을 디버그하는 데 많은 재미가 있습니다.</target>
        </trans-unit>
        <trans-unit id="a2268d48cac5e24ed6c2d566336bdb20614f616f" translate="yes" xml:space="preserve">
          <source>Wrap your main code in</source>
          <target state="translated">메인 코드를</target>
        </trans-unit>
        <trans-unit id="0d518b326eb1f8e7dd14bb6dacd324e99b66610e" translate="yes" xml:space="preserve">
          <source>Your main code runs some admin module, which requires a support library,
which connects to a database. Halfway through it encounters an error, thus
loads an error handler, which also uses the database.</source>
          <target state="translated">기본 코드는 데이터베이스에 연결하는 지원 라이브러리가 필요한 일부 관리 모듈을 실행합니다. 중간에 오류가 발생하여 데이터베이스를 사용하는 오류 처리기를로드합니다.</target>
        </trans-unit>
        <trans-unit id="1119e4e9e700cfa21cbdc86bfd28782fd00e25c5" translate="yes" xml:space="preserve">
          <source>Your service &lt;strong&gt;must&lt;/strong&gt; call</source>
          <target state="translated">귀하의 서비스가 &lt;strong&gt;있어야&lt;/strong&gt; 전화</target>
        </trans-unit>
        <trans-unit id="3a717f099d0f0afdd183e5fe1e60a3b2d4be0eb4" translate="yes" xml:space="preserve">
          <source>async with main_scope(): ...</source>
          <target state="translated">main_scope ()와 비동기 : ...</target>
        </trans-unit>
        <trans-unit id="b72db8dc97d16fc439c9e88e0ec58e8077ef01ab" translate="yes" xml:space="preserve">
          <source>asyncscope</source>
          <target state="translated">asyncscope</target>
        </trans-unit>
        <trans-unit id="20a233212a0283598b8ad388f4dfb864f5ebd77c" translate="yes" xml:space="preserve">
          <source>await no_more_dependents()</source>
          <target state="translated">no_more_dependents ()를 기다립니다.</target>
        </trans-unit>
        <trans-unit id="aa2798085d2c659cfb598dd371714e356971dc0f" translate="yes" xml:space="preserve">
          <source>call &amp;ldquo;register(serice_object)&amp;rdquo;</source>
          <target state="translated">&quot;register (serice_object)&quot;호출</target>
        </trans-unit>
        <trans-unit id="c0720160b6469d73b573d17b9baa627ef8a4dbda" translate="yes" xml:space="preserve">
          <source>cleanly stop itself</source>
          <target state="translated">깨끗이 멈추다</target>
        </trans-unit>
        <trans-unit id="24594bf61f7292e625c39f9e5b1f6322ddfa99f4" translate="yes" xml:space="preserve">
          <source>context variable.</source>
          <target state="translated">컨텍스트 변수.</target>
        </trans-unit>
        <trans-unit id="bc884f7b9dec3f520e2cec89e0cb4fab48854777" translate="yes" xml:space="preserve">
          <source>directory contains some sample code.</source>
          <target state="translated">디렉토리에는 몇 가지 샘플 코드가 있습니다.</target>
        </trans-unit>
        <trans-unit id="0377f9ae43f8abfdfef3cb8a30fc7ffb76e6c7e1" translate="yes" xml:space="preserve">
          <source>exactly once,
otherwise the scopes waiting for it to start will wait forever. (They&amp;rsquo;ll
get cancelled if your scope&amp;rsquo;s main task exits before doing so.)</source>
          <target state="translated">정확히 한 번, 그렇지 않으면 시작을 기다리는 범위가 영원히 기다립니다. (스코프의 기본 작업이 종료되기 전에 종료되면 취소됩니다.)</target>
        </trans-unit>
        <trans-unit id="99345ce680cd3e48acdb9ab4212e4bd9bf9358b7" translate="yes" xml:space="preserve">
          <source>examples</source>
          <target state="translated">예</target>
        </trans-unit>
        <trans-unit id="18cec78ad75ad5bc21fe0afbd305a42d810df378" translate="yes" xml:space="preserve">
          <source>if you need it.
For most uses, however,</source>
          <target state="translated">필요한 경우. 그러나 대부분의 경우</target>
        </trans-unit>
        <trans-unit id="ddc0b76895c74c93ff932eab9b3a373a77695d03" translate="yes" xml:space="preserve">
          <source>is not used, the scope will be cancelled.</source>
          <target state="translated">사용되지 않으면 범위가 취소됩니다.</target>
        </trans-unit>
        <trans-unit id="dde037b9ca7ec60bc5542d1cd1dfcf993a27956c" translate="yes" xml:space="preserve">
          <source>is whatever object the service
intends you to use.</source>
          <target state="translated">서비스가 사용하려는 모든 객체입니다.</target>
        </trans-unit>
        <trans-unit id="8e8d640d4780daa9d1e2d50f79d823d1725ac844" translate="yes" xml:space="preserve">
          <source>no_more_dependents</source>
          <target state="translated">no_more_dependents</target>
        </trans-unit>
        <trans-unit id="b28688d24af9e039e2c7a373b5e70a234fd7bff1" translate="yes" xml:space="preserve">
          <source>no_more_dependents()</source>
          <target state="translated">no_more_dependents ()</target>
        </trans-unit>
        <trans-unit id="1b8609b64802c1e1e712fe0688541bad04cde071" translate="yes" xml:space="preserve">
          <source>object accesses
the current scope transparently.</source>
          <target state="translated">개체는 현재 범위에 투명하게 액세스합니다.</target>
        </trans-unit>
        <trans-unit id="a34d3973aa4a92dce9223ea3cbe7510703eadfdf" translate="yes" xml:space="preserve">
          <source>returns. If there is no such call, the scope&amp;rsquo;s tasks are cancelled.</source>
          <target state="translated">보고. 그러한 호출이 없으면 범위의 작업이 취소됩니다.</target>
        </trans-unit>
        <trans-unit id="aacd3103f3f1fcab0248f041a315ab6816c8a0e9" translate="yes" xml:space="preserve">
          <source>scope</source>
          <target state="translated">범위</target>
        </trans-unit>
        <trans-unit id="de4060842e9f284d70298a268fbe7633a8243e81" translate="yes" xml:space="preserve">
          <source>scope.get()</source>
          <target state="translated">scope.get ()</target>
        </trans-unit>
        <trans-unit id="1591ae4b198edf6f9620668e97f994bf4cae30d6" translate="yes" xml:space="preserve">
          <source>scope.register()</source>
          <target state="translated">scope.register ()</target>
        </trans-unit>
        <trans-unit id="365abe542cc145e8760e0e0900dae32083ca97bd" translate="yes" xml:space="preserve">
          <source>setup: start other services,</source>
          <target state="translated">설정 : 다른 서비스 시작,</target>
        </trans-unit>
        <trans-unit id="9d0be451884e0a33ad114f81a23f503cd1b10777" translate="yes" xml:space="preserve">
          <source>spawn()</source>
          <target state="translated">알()</target>
        </trans-unit>
        <trans-unit id="2e0c9f4b78d08d11496b33a2fc91d961531be91b" translate="yes" xml:space="preserve">
          <source>srv</source>
          <target state="translated">srv</target>
        </trans-unit>
        <trans-unit id="bff8141be3b6c225d8136650e66758e745231248" translate="yes" xml:space="preserve">
          <source>srv = await
service(name, some_service, *params)</source>
          <target state="translated">srv = await service (name, some_service, * params)</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
