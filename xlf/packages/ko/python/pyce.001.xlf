<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://pypi.org/project/pyce/">
    <body>
      <group id="pyce">
        <trans-unit id="7220d61e61d9e2652e2e8c73eaa03a6d2791500d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pyce&lt;/code&gt; enables the creation of a Trusted Computing Python environment by
ensuring each deployed file is precisely what the developer intended by
enforcing end-to-end encryption.  Execution halts if even a single bit of an
imported Python file is modified.</source>
          <target state="translated">&lt;code&gt;pyce&lt;/code&gt; 를 사용하면 배포 된 각 파일이 종단 간 암호화를 적용하여 개발자가 의도 한 것과 정확히 일치하도록함으로써 신뢰할 수있는 컴퓨팅 Python 환경을 만들 수 있습니다. 가져온 Python 파일의 한 비트라도 수정되면 실행이 중지됩니다.</target>
        </trans-unit>
        <trans-unit id="5b570989f30f2c44d1bf228f9676441765e87bf9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pyce&lt;/code&gt; expects files to be pre-compiled Python bytecode, using a command
similar to &lt;code&gt;python3 -mcompileall -b&lt;/code&gt; where &lt;code&gt;-b&lt;/code&gt; does an in place compilation.</source>
          <target state="translated">&lt;code&gt;pyce&lt;/code&gt; 는 &lt;code&gt;python3 -mcompileall -b&lt;/code&gt; 와 유사한 명령을 사용하여 파일이 사전 컴파일 된 Python 바이트 코드 일 것으로 예상합니다. 여기서 &lt;code&gt;-b&lt;/code&gt; 는 내부 컴파일을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="40d8a7e89611ab4ff3927c3a37dc0215fd1c68fa" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pyce&lt;/code&gt; is a library to work with encrypted Python bytecode.  It adds
functionality to a Python runtime by extending the way the builtin keyword
&lt;code&gt;import&lt;/code&gt; works.  Currently, it assumes that convergent encryption will be used,
but the library can be extended.  For example, functionality could be added to
decrypt files via &lt;a href=&quot;https://www.vaultproject.io/&quot;&gt;Hashicorp's Vault&lt;/a&gt; (which also
supports convergent encryption as a mode of operation).</source>
          <target state="translated">&lt;code&gt;pyce&lt;/code&gt; 는 암호화 된 Python 바이트 코드와 함께 작동하는 라이브러리입니다. 내장 키워드 &lt;code&gt;import&lt;/code&gt; 작동 하는 방식을 확장하여 Python 런타임에 기능을 추가 합니다. 현재 수렴 암호화를 사용한다고 가정하지만 라이브러리를 확장 할 수 있습니다. 예를 들어 &lt;a href=&quot;https://www.vaultproject.io/&quot;&gt;Hashicorp의 Vault&lt;/a&gt; 를 통해 파일을 복호화하는 기능을 추가 할 수 있습니다 (작업 모드로 수렴 암호화도 지원함).</target>
        </trans-unit>
        <trans-unit id="f2e1bbf38f99446fb650d8b305e2e4b0cefb6b79" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;At-rest Code Protection:&lt;/strong&gt; You could just protect code at rest by integrating
on-the-fly decryption with an IDE or other software.  This would be more of a
DIY project at this point in time, but &lt;code&gt;pyce&lt;/code&gt; gives you all the building blocks
you need!</source>
          <target state="translated">&lt;strong&gt;미사용 코드 보호 :&lt;/strong&gt; IDE 또는 기타 소프트웨어와 실시간 암호 해독을 통합하여 미사용 코드를 보호 할 수 있습니다. 이 시점에서 이것은 DIY 프로젝트에 &lt;code&gt;pyce&lt;/code&gt; 는 필요한 모든 빌딩 블록을 제공합니다!</target>
        </trans-unit>
        <trans-unit id="7e54ad43a87b672fcb045309a94aeff66fe24495" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;File Integrity Monitoring:&lt;/strong&gt; You could protect your production code running
on application servers by adding in automatic cryptographic checks of imports.</source>
          <target state="translated">&lt;strong&gt;파일 무결성 모니터링 :&lt;/strong&gt; 가져 오기의 자동 암호화 검사를 추가하여 애플리케이션 서버에서 실행되는 프로덕션 코드를 보호 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a4ff274c4c6f778a2747ce2f475183f6000f5f8b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Licensing:&lt;/strong&gt; You could publish encrypted modules to PyPI and only release
decryption keys to certain organizations, people, or others!  You could publish
such modules anywhere!</source>
          <target state="translated">&lt;strong&gt;라이선싱 :&lt;/strong&gt; 암호화 된 모듈을 PyPI에 게시하고 특정 조직, 사람 또는 다른 사람에게만 해독 키를 릴리스 할 수 있습니다! 이러한 모듈은 어디서나 게시 할 수 있습니다!</target>
        </trans-unit>
        <trans-unit id="d73cba4cd29d390c2e73cb25a75dfa70c74e76c7" translate="yes" xml:space="preserve">
          <source>All of this code is released under the &lt;a href=&quot;https://www.apache.org/licenses/LICENSE-2.0&quot;&gt;Apache v2.0
License&lt;/a&gt;.</source>
          <target state="translated">이 모든 코드는 &lt;a href=&quot;https://www.apache.org/licenses/LICENSE-2.0&quot;&gt;Apache v2.0 라이선스에&lt;/a&gt; 따라 릴리스됩니다 .</target>
        </trans-unit>
        <trans-unit id="4dcc292d2fb7b4058ad3d38bd0f91c85daef1f51" translate="yes" xml:space="preserve">
          <source>Execute encrypted Python bytecode.</source>
          <target state="translated">암호화 된 Python 바이트 코드를 실행합니다.</target>
        </trans-unit>
        <trans-unit id="6b522d4892272ac439a1152cd99727373df352f6" translate="yes" xml:space="preserve">
          <source>First, you'll want to encrypt a module or package.  &lt;strong&gt;Note: this is a
destructive action.&lt;/strong&gt;  Do not run this on a codebase that is not saved
elsewhere.  This can recursively operate on folders, and supports exclusion
lists (to not encrypt certain files).</source>
          <target state="translated">먼저 모듈 또는 패키지를 암호화하려고합니다. &lt;strong&gt;참고 : 이것은 파괴적인 작업입니다. &lt;/strong&gt;다른 곳에 저장되지 않은 코드베이스에서는 실행하지 마십시오. 이는 폴더에서 재귀 적으로 작동 할 수 있으며 제외 목록을 지원합니다 (특정 파일을 암호화하지 않음).</target>
        </trans-unit>
        <trans-unit id="b05b322d83bfb47db730d9d1707bae561b692314" translate="yes" xml:space="preserve">
          <source>How do I use it?</source>
          <target state="translated">어떻게 사용합니까?</target>
        </trans-unit>
        <trans-unit id="7044cdd9d6418ed93041c3eebc069f6785386acc" translate="yes" xml:space="preserve">
          <source>Key distribution is outside the scope of this project.  You will need to
maintain keys typically by using a networked key server such as &lt;a href=&quot;https://www.vaultproject.io/&quot;&gt;Hashicorp's
Vault&lt;/a&gt;.  You could pass keys by environment
variable, &lt;code&gt;stdin&lt;/code&gt;, or some other mechanism.</source>
          <target state="translated">키 배포는이 프로젝트의 범위를 벗어납니다. 일반적으로 &lt;a href=&quot;https://www.vaultproject.io/&quot;&gt;Hashicorp의 Vault&lt;/a&gt; 와 같은 네트워크로 연결된 키 서버를 사용하여 키를 유지 관리해야합니다 . 환경 변수, &lt;code&gt;stdin&lt;/code&gt; 또는 기타 메커니즘으로 키를 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3229609e15436ec51bcf00818a69a84dbc58a0c2" translate="yes" xml:space="preserve">
          <source>License</source>
          <target state="translated">특허</target>
        </trans-unit>
        <trans-unit id="6a65edd353c5c3cd5039e413ffc77c8ff386b9b8" translate="yes" xml:space="preserve">
          <source>PYCE</source>
          <target state="translated">PYCE</target>
        </trans-unit>
        <trans-unit id="1c0b9ef46dd4b9fbb52c53cd6c10bf1330b4a8e0" translate="yes" xml:space="preserve">
          <source>Second, register your keys and try importing from the encrypted module or
package:</source>
          <target state="translated">둘째, 키를 등록하고 암호화 된 모듈 또는 패키지에서 가져 오기를 시도합니다.</target>
        </trans-unit>
        <trans-unit id="6200e73c15ad9ab26f9436c0155499b816dcd3b5" translate="yes" xml:space="preserve">
          <source>Typically, you will leave (exclude) a stub file that is designed to just hook
Python's import path parsers, setup the keys, and then execute your code.</source>
          <target state="translated">일반적으로 Python의 가져 오기 경로 파서를 연결하고 키를 설정 한 다음 코드를 실행하도록 설계된 스텁 파일을 남겨 둡니다 (제외).</target>
        </trans-unit>
        <trans-unit id="356b951caf7cbe2df0adf165183ef4a7d86e7c13" translate="yes" xml:space="preserve">
          <source>What can I do with it?</source>
          <target state="translated">그것으로 무엇을 할 수 있습니까?</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
