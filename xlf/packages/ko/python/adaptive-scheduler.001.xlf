<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://pypi.org/project/adaptive-scheduler/">
    <body>
      <group id="adaptive-scheduler">
        <trans-unit id="ae6e563675bb267063adaad14299f480079e2e41" translate="yes" xml:space="preserve">
          <source>(like in the section above).
Then a &amp;ldquo;job manager&amp;rdquo; writes and submits</source>
          <target state="translated">(위 섹션에서와 같이). 그런 다음 &quot;작업 관리자&quot;가 작성하고 제출합니다.</target>
        </trans-unit>
        <trans-unit id="7b2138614d3b0c749f6158f0d6aa23a97b567088" translate="yes" xml:space="preserve">
          <source>(re)submits job scripts</source>
          <target state="translated">(재) 작업 스크립트 제출</target>
        </trans-unit>
        <trans-unit id="12479829422730ef87a79c8f38f1fc22e68c0736" translate="yes" xml:space="preserve">
          <source>) or 1 core for 1 job (</source>
          <target state="translated">) 또는 1 개의 작업을위한 1 개의 코어 (</target>
        </trans-unit>
        <trans-unit id="4195feab30b89c94b65d8b99012c8b1334700032" translate="yes" xml:space="preserve">
          <source>) while scheduling hundreds of jobs.</source>
          <target state="translated">) 수백 개의 작업을 예약합니다.</target>
        </trans-unit>
        <trans-unit id="5c10b5b2cd673a0616d529aa5234b12ee7153808" translate="yes" xml:space="preserve">
          <source>,</source>
          <target state="translated">,</target>
        </trans-unit>
        <trans-unit id="b366d1a229ec84d93ba42e7ecafb33db5b7b9b39" translate="yes" xml:space="preserve">
          <source>, or</source>
          <target state="translated">또는</target>
        </trans-unit>
        <trans-unit id="cb5f9be6acf23b2604c1efbc1fc3724da89efff3" translate="yes" xml:space="preserve">
          <source>.
The job script starts a Python file</source>
          <target state="translated">. 작업 스크립트는 Python 파일을 시작합니다.</target>
        </trans-unit>
        <trans-unit id="5f19d042d217e3c21adacc024da8fb9b4a967741" translate="yes" xml:space="preserve">
          <source>. The creation and running of these jobs are managed by</source>
          <target state="translated">. 이러한 작업의 생성 및 실행은</target>
        </trans-unit>
        <trans-unit id="1ad1c08df74c2c30b83674d2a4de267c1f0070b8" translate="yes" xml:space="preserve">
          <source>. This means that your calculation will definitely run, even though the cluster might be fully occupied at the moment. Because of this approach, there is almost no limit to how many cores you want to use. You can either use 10 nodes for 1 job (</source>
          <target state="translated">. 즉, 현재 클러스터가 완전히 채워져 있어도 계산이 확실히 실행됩니다. 이 접근 방식으로 인해 사용하려는 코어 수에 거의 제한이 없습니다. 1 개의 작업에 10 개의 노드를 사용할 수 있습니다 (</target>
        </trans-unit>
        <trans-unit id="934d75754d2a089d441b206cf610a72472fb414f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;WARNING:&lt;/strong&gt; This is still the pre-alpha development stage.</source>
          <target state="translated">&lt;strong&gt;경고 :&lt;/strong&gt; 이것은 아직 사전 알파 개발 단계입니다.</target>
        </trans-unit>
        <trans-unit id="1c8333472f9b68268b798e09f3ce5bbde25bc7dd" translate="yes" xml:space="preserve">
          <source>And use</source>
          <target state="translated">그리고 사용</target>
        </trans-unit>
        <trans-unit id="8d3df588853849c28bf775cd2b8ffaf9171935a7" translate="yes" xml:space="preserve">
          <source>But how does it &lt;em&gt;really&lt;/em&gt; work?</source>
          <target state="translated">하지만 &lt;em&gt;실제로&lt;/em&gt; 어떻게 작동합니까?</target>
        </trans-unit>
        <trans-unit id="46d6291587f63012ec0ce0921ebf35bdb66ddffe" translate="yes" xml:space="preserve">
          <source>Design goals</source>
          <target state="translated">디자인 목표</target>
        </trans-unit>
        <trans-unit id="4c17aadf5117487aab7bc50cbf056caf3977cc31" translate="yes" xml:space="preserve">
          <source>Development</source>
          <target state="translated">개발</target>
        </trans-unit>
        <trans-unit id="cf16722c59fe4c2fb3b542f05a87efb4fc0ffb80" translate="yes" xml:space="preserve">
          <source>Everything is written such that the computation is maximally local. This means that is one of the jobs crashes, there is no problem and it will automatically schedule a new one and continue the calculation where it left off (because of Adaptive&amp;rsquo;s periodic saving functionality). Even if the central &amp;ldquo;job manager&amp;rdquo; dies, the jobs will continue to run (although no new jobs will be scheduled.)</source>
          <target state="translated">계산이 최대한 로컬이되도록 모든 것이 작성됩니다. 즉, 작업 중 하나가 충돌하고 문제가 없으며 자동으로 새 작업을 예약하고 중단 된 지점에서 계산을 계속합니다 (Adaptive의 주기적 저장 기능으로 인해). 중앙 &quot;작업 관리자&quot;가 죽더라도 작업은 계속 실행됩니다 (새 작업이 예약되지는 않음).</target>
        </trans-unit>
        <trans-unit id="20dcf8424db2ba99721bbe5dfb9fbd32bb1337ab" translate="yes" xml:space="preserve">
          <source>Handles random crashes (or node evictions) with minimal data loss</source>
          <target state="translated">최소한의 데이터 손실로 무작위 충돌 (또는 노드 제거)을 처리합니다.</target>
        </trans-unit>
        <trans-unit id="e21860bf37328b97ebb0ddd904694c78e4a7b382" translate="yes" xml:space="preserve">
          <source>How does it work?</source>
          <target state="translated">어떻게 작동합니까?</target>
        </trans-unit>
        <trans-unit id="2f35640566dc90ff77af08ddabaaff2f31a973e6" translate="yes" xml:space="preserve">
          <source>In a Jupyter notebook we can start the &amp;ldquo;job manager&amp;rdquo; and the &amp;ldquo;database manager&amp;rdquo;, and create the</source>
          <target state="translated">Jupyter 노트북에서 &quot;작업 관리자&quot;와 &quot;데이터베이스 관리자&quot;를 시작하고</target>
        </trans-unit>
        <trans-unit id="1c04cc7ac5c32af03d6ff5716df884f3d26ac668" translate="yes" xml:space="preserve">
          <source>In order to not pollute the history with the output of the notebooks, please setup the git filter by executing</source>
          <target state="translated">노트북의 출력으로 히스토리를 오염시키지 않으려면 다음을 실행하여 git 필터를 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="d8729567b23ba3e328f1fe1416facc26f01221c7" translate="yes" xml:space="preserve">
          <source>Install the &lt;strong&gt;latest stable&lt;/strong&gt; version from conda with (recommended)</source>
          <target state="translated">conda에서 &lt;strong&gt;최신 안정&lt;/strong&gt; 버전 설치 (권장)</target>
        </trans-unit>
        <trans-unit id="c81b79df3c6448eae7c4f80428b54cd5692a17d7" translate="yes" xml:space="preserve">
          <source>Installation</source>
          <target state="translated">설치</target>
        </trans-unit>
        <trans-unit id="ed1f06801eaa6a6bce2de35b7a1f6a945b41bad8" translate="yes" xml:space="preserve">
          <source>Jupyter notebook example</source>
          <target state="translated">Jupyter 노트북 예</target>
        </trans-unit>
        <trans-unit id="a7c04c64ed3f2a9374590c76c50d3b7f1b18e3da" translate="yes" xml:space="preserve">
          <source>Limitations</source>
          <target state="translated">한계</target>
        </trans-unit>
        <trans-unit id="3c43fe4f55023fd421246b6cc375e61637a391b7" translate="yes" xml:space="preserve">
          <source>Maximizes computation locality, jobs continue to run when the main process dies</source>
          <target state="translated">계산 지역성을 최대화하고 기본 프로세스가 종료 될 때 작업이 계속 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="bcc731ab94cc0a3318685f107618fdf809a3c00c" translate="yes" xml:space="preserve">
          <source>Minimal load on the file system</source>
          <target state="translated">파일 시스템에 대한 최소로드</target>
        </trans-unit>
        <trans-unit id="b51a60734da64be0e618bacbea2865a8a7dcd669" translate="yes" xml:space="preserve">
          <source>N</source>
          <target state="translated">엔</target>
        </trans-unit>
        <trans-unit id="50eb76b48ab70224e1627019dfa77e4adc26843c" translate="yes" xml:space="preserve">
          <source>Needs to be able to run on efficiently &amp;gt;30k cores</source>
          <target state="translated">30k 이상의 코어에서 효율적으로 실행할 수 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="3805b15887be42a6e7fbd3288054b90c8209c7b5" translate="yes" xml:space="preserve">
          <source>Our approach is to schedule a different job for each</source>
          <target state="translated">우리의 접근 방식은 각각 다른 작업을 예약하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="86c96179988a250937c61901da3e0eae3b865d98" translate="yes" xml:space="preserve">
          <source>Preserves Python kernel and variables inside a job (in contrast to submitting jobs for every parameter)</source>
          <target state="translated">작업 내에서 Python 커널 및 변수를 보존합니다 (모든 매개 변수에 대해 작업을 제출하는 것과는 대조적으로)</target>
        </trans-unit>
        <trans-unit id="91ed9e732a11890c72778c4e4a9b8c14faaaa309" translate="yes" xml:space="preserve">
          <source>Removes all boilerplate of working with a scheduler</source>
          <target state="translated">스케줄러 작업의 모든 상용구를 제거합니다.</target>
        </trans-unit>
        <trans-unit id="afc65daa8ffad844d01f355781d6c688d425c409" translate="yes" xml:space="preserve">
          <source>Right now</source>
          <target state="translated">지금</target>
        </trans-unit>
        <trans-unit id="dfc3f5c9afea0c7e5cb3f1a8d0643a153d37452f" translate="yes" xml:space="preserve">
          <source>Run many</source>
          <target state="translated">많이 실행</target>
        </trans-unit>
        <trans-unit id="aed0bd3f7f5b6e837bcca23af5501d480757cc15" translate="yes" xml:space="preserve">
          <source>Run many `adaptive.Learner`s on many cores (&gt;10k) using `mpi4py.futures`, `ipyparallel`, `dask-mpi`, or `process-pool`.</source>
          <target state="translated">`mpi4py.futures`,`ipyparallel`,`dask-mpi` 또는`process-pool`을 사용하여 많은 코어 (&amp;gt; 10k)에서 많은`adaptive.Learner`를 실행합니다.</target>
        </trans-unit>
        <trans-unit id="c0718d3c85db8d914b33fd7b6df9b02ba97979f3" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://github.com/basnijholt/adaptive-scheduler/blob/master/example.ipynb&quot;&gt;example.ipynb&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/basnijholt/adaptive-scheduler/blob/master/example.ipynb&quot;&gt;example.ipynb를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="155cd9ae5a0d63f9f2580afb2b33079fc7beee21" translate="yes" xml:space="preserve">
          <source>Separates the simulation definition code from the code that runs the simulation</source>
          <target state="translated">시뮬레이션을 실행하는 코드에서 시뮬레이션 정의 코드를 분리합니다.</target>
        </trans-unit>
        <trans-unit id="61ad21a88b932530cbf3e00cd36786b3f97ce7dc" translate="yes" xml:space="preserve">
          <source>That&amp;rsquo;s it! You can run</source>
          <target state="translated">그게 다야! 당신은 실행할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="93ef0dd827103681fcee453b78be2ff14e1a261d" translate="yes" xml:space="preserve">
          <source>The</source>
          <target state="translated">그만큼</target>
        </trans-unit>
        <trans-unit id="f4fed6dfec9004fdbd1a0fec8efc20f6da3f2f5a" translate="yes" xml:space="preserve">
          <source>The Adaptive scheduler solves the following problem, you need to run more learners than you can run with a single runner and/or can use &amp;gt;1k cores.</source>
          <target state="translated">적응 형 스케줄러는 다음 문제를 해결합니다. 단일 러너로 실행할 수있는 것보다 더 많은 학습자를 실행해야하거나 1k 이상의 코어를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="613f99dd7ad7903195f2c82b548e65c12f04e798" translate="yes" xml:space="preserve">
          <source>Then when the job have been running for a while you can check</source>
          <target state="translated">그런 다음 작업이 잠시 실행되었을 때 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a3bd293efdcc07ed96caeed2b5799b27c0072447" translate="yes" xml:space="preserve">
          <source>Then you start a process that creates and submits as many job-scripts as there are learners. Like:</source>
          <target state="translated">그런 다음 학습자 수만큼 작업 스크립트를 작성하고 제출하는 프로세스를 시작합니다. 처럼:</target>
        </trans-unit>
        <trans-unit id="9d7a8347ffbebb037305e6b4fef55c0514f296d4" translate="yes" xml:space="preserve">
          <source>We also use &lt;a href=&quot;https://pre-commit.com&quot;&gt;pre-commit&lt;/a&gt;, so</source>
          <target state="translated">또한 &lt;a href=&quot;https://pre-commit.com&quot;&gt;pre-commit을&lt;/a&gt; 사용 하므로</target>
        </trans-unit>
        <trans-unit id="dd8082be77e9211f033a55131c1a6360f12b0e1d" translate="yes" xml:space="preserve">
          <source>What is this?</source>
          <target state="translated">이게 뭐야?</target>
        </trans-unit>
        <trans-unit id="196795bf54feec10366fca9f7d7b7ee7d474687a" translate="yes" xml:space="preserve">
          <source>Works seamlessly with the Adaptive package</source>
          <target state="translated">Adaptive 패키지와 원활하게 작동</target>
        </trans-unit>
        <trans-unit id="f4c33b7c591e37531b9c5db958cde9313d0dd1ab" translate="yes" xml:space="preserve">
          <source>You create a bunch of</source>
          <target state="translated">당신은 무리를 만듭니다</target>
        </trans-unit>
        <trans-unit id="e59b8376c79669883a149c56f79bb74df8150fb8" translate="yes" xml:space="preserve">
          <source>You don&amp;rsquo;t actually ever have to leave the Jupter notebook, take a look at the &lt;a href=&quot;https://github.com/basnijholt/adaptive-scheduler/blob/master/example.ipynb&quot;&gt;example notebook&lt;/a&gt;.</source>
          <target state="translated">실제로 Jupter 노트북을 떠날 필요가 없습니다 . &lt;a href=&quot;https://github.com/basnijholt/adaptive-scheduler/blob/master/example.ipynb&quot;&gt;예제 노트북을&lt;/a&gt; 살펴보세요 .</target>
        </trans-unit>
        <trans-unit id="42f11fbf6bb238199436a9ab2a266d37c5b5046b" translate="yes" xml:space="preserve">
          <source>adaptive-scheduler</source>
          <target state="translated">적응 형 스케줄러</target>
        </trans-unit>
        <trans-unit id="a0ad50e4d3860fb26e274ceebc0556369f92f54d" translate="yes" xml:space="preserve">
          <source>adaptive.Learner</source>
          <target state="translated">적응 형 학습자</target>
        </trans-unit>
        <trans-unit id="592a8ffe43587d33281e6fee72690224bd7b94ab" translate="yes" xml:space="preserve">
          <source>adaptive_scheduler</source>
          <target state="translated">adaptive_scheduler</target>
        </trans-unit>
        <trans-unit id="cffa50a32cb13a240d705317bcec65dd1f31b6ad" translate="yes" xml:space="preserve">
          <source>and</source>
          <target state="translated">과</target>
        </trans-unit>
        <trans-unit id="2d6f5c92c5a06a3c1dc66886c46326ef03881f42" translate="yes" xml:space="preserve">
          <source>and corresponding</source>
          <target state="translated">및 해당</target>
        </trans-unit>
        <trans-unit id="2ae26256c38fcedf84aeeafcd8ec9bb67c2eb2fd" translate="yes" xml:space="preserve">
          <source>and run</source>
          <target state="translated">그리고 실행</target>
        </trans-unit>
        <trans-unit id="86a7b349d6240c4f483a2b3290735745a87b2dfd" translate="yes" xml:space="preserve">
          <source>basically does the following.
So, &lt;em&gt;you&lt;/em&gt; need to create</source>
          <target state="translated">기본적으로 다음을 수행합니다. 그래서, &lt;em&gt;당신은&lt;/em&gt; 만들 필요가</target>
        </trans-unit>
        <trans-unit id="c575f3e383df5c81fb057f50806caf1436554d70" translate="yes" xml:space="preserve">
          <source>distributed</source>
          <target state="translated">분산</target>
        </trans-unit>
        <trans-unit id="a06fb158f0293a387f48c3d6b1cfeae7d2d4abf0" translate="yes" xml:space="preserve">
          <source>fnames</source>
          <target state="translated">fnames</target>
        </trans-unit>
        <trans-unit id="b87f1e6f8826a0733bd184a2650d881229eec28d" translate="yes" xml:space="preserve">
          <source>in the repository.</source>
          <target state="translated">저장소에서.</target>
        </trans-unit>
        <trans-unit id="13455a853cd0f6056b5c34fb786d66aaace73a5c" translate="yes" xml:space="preserve">
          <source>in which the learner is run.</source>
          <target state="translated">학습자가 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="f1dd74b87206370f96a26355e556d7424a412bcf" translate="yes" xml:space="preserve">
          <source>ipyparallel</source>
          <target state="translated">ipyparallel</target>
        </trans-unit>
        <trans-unit id="8967d44f688f26c995e4f0ced6da0aae5f0a18e6" translate="yes" xml:space="preserve">
          <source>ipywidget</source>
          <target state="translated">ipywidget</target>
        </trans-unit>
        <trans-unit id="01f1bb72030158cf13fa51cb5c2bd5e549387944" translate="yes" xml:space="preserve">
          <source>is only working for SLURM and PBS, however only a class like &lt;a href=&quot;https://github.com/basnijholt/adaptive-scheduler/blob/master/adaptive_scheduler/scheduler.py#L471&quot;&gt;adaptive_scheduler/scheduler.py&lt;/a&gt; would have to be implemented for another type of scheduler.
Also there are &lt;strong&gt;no tests&lt;/strong&gt; at all!</source>
          <target state="translated">SLURM 및 PBS에서만 작동하지만 &lt;a href=&quot;https://github.com/basnijholt/adaptive-scheduler/blob/master/adaptive_scheduler/scheduler.py#L471&quot;&gt;adaptive_scheduler / scheduler.py&lt;/a&gt; 와 같은 클래스 만 다른 유형의 스케줄러에 대해 구현되어야합니다. 또한 &lt;strong&gt;전혀 테스트&lt;/strong&gt; 가 &lt;strong&gt;없습니다&lt;/strong&gt; !</target>
        </trans-unit>
        <trans-unit id="016b9db189f5963ea48a73206b3b3c76976c7d02" translate="yes" xml:space="preserve">
          <source>job scripts but &lt;em&gt;doesn&amp;rsquo;t know&lt;/em&gt; which learner it is going to run!
This is the responsibility of the &amp;ldquo;database manager&amp;rdquo;, which keeps a database of</source>
          <target state="translated">작업 스크립트가 실행되지만 어떤 학습자를 실행 &lt;em&gt;할지 모릅니다&lt;/em&gt; ! 이것은 데이터베이스를 유지하는 &quot;데이터베이스 관리자&quot;의 책임입니다.</target>
        </trans-unit>
        <trans-unit id="ea79263435a3b239da922e5ff7466ca00999c5ac" translate="yes" xml:space="preserve">
          <source>job_id &amp;lt;--&amp;gt; learner</source>
          <target state="translated">job_id &amp;lt;-&amp;gt; 학습자</target>
        </trans-unit>
        <trans-unit id="b879c6e092ce6406eb1f806bf3757e49981974a7" translate="yes" xml:space="preserve">
          <source>learner</source>
          <target state="translated">학습자</target>
        </trans-unit>
        <trans-unit id="990f844c2df963f8e8337f6d5ca9df9dd3d663d5" translate="yes" xml:space="preserve">
          <source>learners</source>
          <target state="translated">학습자</target>
        </trans-unit>
        <trans-unit id="cd2319020a2b38ce7a3b190fef323960e0cf432f" translate="yes" xml:space="preserve">
          <source>like:</source>
          <target state="translated">처럼:</target>
        </trans-unit>
        <trans-unit id="b69d91753ecfb4cc41ee49626fc3776520e9d25d" translate="yes" xml:space="preserve">
          <source>max(N, max_simultaneous_jobs)</source>
          <target state="translated">max (N, max_simultaneous_jobs)</target>
        </trans-unit>
        <trans-unit id="18325797c9a04f60d170c797a1030656a0c6866b" translate="yes" xml:space="preserve">
          <source>mpi4py.futures</source>
          <target state="translated">mpi4py.futures</target>
        </trans-unit>
        <trans-unit id="5321ba3a1f7ce97ae9eaea169b5d226e46683719" translate="yes" xml:space="preserve">
          <source>or clone the repository and do a dev install (recommended for dev)</source>
          <target state="translated">또는 저장소를 복제하고 dev 설치를 수행합니다 (dev에 권장 됨).</target>
        </trans-unit>
        <trans-unit id="86440b5a1f8c105a10fcde1fb216993fe04b6781" translate="yes" xml:space="preserve">
          <source>or from PyPI with</source>
          <target state="translated">또는 PyPI에서</target>
        </trans-unit>
        <trans-unit id="ddc4925dd2259bc19ec964a6d6305512efa128e9" translate="yes" xml:space="preserve">
          <source>or install &lt;strong&gt;master&lt;/strong&gt; with</source>
          <target state="translated">또는 설치 &lt;strong&gt;마스터&lt;/strong&gt; 와 함께</target>
        </trans-unit>
        <trans-unit id="aa3a0cb7b884ee13443f4f0ea683ac08cdb7facf" translate="yes" xml:space="preserve">
          <source>pip install pre_commit</source>
          <target state="translated">pip install pre_commit</target>
        </trans-unit>
        <trans-unit id="7a3dbc2c4ead37ce907f172c43a8ea5110046217" translate="yes" xml:space="preserve">
          <source>provide very powerful engines for interactive sessions. However, when you want to connect to &amp;gt;1k cores it starts to struggle. Besides that, on a shared cluster there is often the problem of starting an interactive session with ample space available.</source>
          <target state="translated">대화 형 세션을위한 매우 강력한 엔진을 제공합니다. 그러나 1k 이상의 코어에 연결하려면 어려움을 겪기 시작합니다. 그 외에도 공유 클러스터에서는 충분한 공간이있는 대화 형 세션을 시작하는 문제가 종종 발생합니다.</target>
        </trans-unit>
        <trans-unit id="d35d2bf40028fa339148e1086653d8523c227f69" translate="yes" xml:space="preserve">
          <source>run_learner.py</source>
          <target state="translated">run_learner.py</target>
        </trans-unit>
        <trans-unit id="030fad67135b396c451df9a57a719d3d635f7f0b" translate="yes" xml:space="preserve">
          <source>run_manager.info()</source>
          <target state="translated">run_manager.info ()</target>
        </trans-unit>
        <trans-unit id="8f634ebeaf8e41f7dd4af94ab6716fc30bbbac75" translate="yes" xml:space="preserve">
          <source>s on many cores (&amp;gt;10k) using</source>
          <target state="translated">많은 코어 (&amp;gt; 10k)에서</target>
        </trans-unit>
        <trans-unit id="c90170579edbae64d864266b29d9fa069732505b" translate="yes" xml:space="preserve">
          <source>scheduler.cancel(job_names)</source>
          <target state="translated">scheduler.cancel (작업 _ 이름)</target>
        </trans-unit>
        <trans-unit id="36d4c061790f8214dc1663889b8597667be9f62e" translate="yes" xml:space="preserve">
          <source>server_support.parse_log_files(job_names, database_manager, scheduler)</source>
          <target state="translated">server_support.parse_log_files (작업 _ 이름, 데이터베이스 _ 관리자, 스케줄러)</target>
        </trans-unit>
        <trans-unit id="74470b92cfb1ff23edcce042e27c3fe5fe77c414" translate="yes" xml:space="preserve">
          <source>such that they can be loaded, like:</source>
          <target state="translated">다음과 같이로드 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="07bb259b1faf419cbe8fb6957d9227a08a146f44" translate="yes" xml:space="preserve">
          <source>that shows the amount of running, pending, and finished jobs, buttons to cancel your job, and other useful information.</source>
          <target state="translated">실행 중, 보류 중 및 완료된 작업의 양, 작업 취소 버튼 및 기타 유용한 정보를 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="6e0fe1a6e0a4960f591237c26b48ad4598378be0" translate="yes" xml:space="preserve">
          <source>to cancel the jobs.</source>
          <target state="translated">작업을 취소합니다.</target>
        </trans-unit>
        <trans-unit id="734274a79897d59fd2455d3f9b6540c0eeea5254" translate="yes" xml:space="preserve">
          <source>which will display an interactive</source>
          <target state="translated">인터랙티브</target>
        </trans-unit>
        <trans-unit id="6199cacd4d83b7cc5dca766cb586d127cb09cca1" translate="yes" xml:space="preserve">
          <source>writes job script</source>
          <target state="translated">작업 스크립트 작성</target>
        </trans-unit>
        <trans-unit id="43c5e8646330700988c81455c75a696e47ecec8c" translate="yes" xml:space="preserve">
          <source>~adaptive_scheduler.server_support.RunManager</source>
          <target state="translated">~ adaptive_scheduler.server_support.RunManager</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
