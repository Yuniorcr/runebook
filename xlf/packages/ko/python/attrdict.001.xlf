<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://pypi.org/project/attrdict/">
    <body>
      <group id="attrdict">
        <trans-unit id="35177623fd7781a2664a3d3aa7fa30447ed667fa" translate="yes" xml:space="preserve">
          <source>(e.g., lists, tuples) will automatically be converted to tuples, with any
mappings converted to Attrs:</source>
          <target state="translated">(예 : 목록, 튜플)은 자동으로 튜플로 변환되며 모든 매핑은 Attrs로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="5c10b5b2cd673a0616d529aa5234b12ee7153808" translate="yes" xml:space="preserve">
          <source>,</source>
          <target state="translated">,</target>
        </trans-unit>
        <trans-unit id="8278d2adba7612cf98a492d21a4ac4c78acb1202" translate="yes" xml:space="preserve">
          <source>, and</source>
          <target state="translated">,</target>
        </trans-unit>
        <trans-unit id="4ec42912ea5168fc100706cb26d27ba42c6f7b8d" translate="yes" xml:space="preserve">
          <source>, consider using</source>
          <target state="translated">, 사용 고려</target>
        </trans-unit>
        <trans-unit id="b366d1a229ec84d93ba42e7ecafb33db5b7b9b39" translate="yes" xml:space="preserve">
          <source>, or</source>
          <target state="translated">또는</target>
        </trans-unit>
        <trans-unit id="03167baa1adaf511453a138943d542f9ca8991fd" translate="yes" xml:space="preserve">
          <source>. They are all fairly similar, as they all are MutableMappings (
read: dictionaries) that allow creating, accessing, and deleting key-value
pairs as attributes.</source>
          <target state="translated">. 키-값 쌍을 속성으로 생성, 액세스 및 삭제할 수있는 MutableMapping (읽기 : 사전)이므로 모두 상당히 유사합니다.</target>
        </trans-unit>
        <trans-unit id="17fd68ccb03b7b09f7ae7b600547bd46717d26d9" translate="yes" xml:space="preserve">
          <source>. This allows on-the-fly,
automatic key creation:</source>
          <target state="translated">. 이를 통해 즉시 자동 키 생성이 가능합니다.</target>
        </trans-unit>
        <trans-unit id="edb81bfb0504a5c51414b30faee233682ff1586c" translate="yes" xml:space="preserve">
          <source>. While this is probably the class you
want to use, there are a few caveats that follow from this being a</source>
          <target state="translated">. 이것은 아마도 당신이 사용하고자하는 클래스 일 수 있지만, 이로부터 따르는 몇 가지주의 사항이 있습니다.</target>
        </trans-unit>
        <trans-unit id="c84dcf9dadcc7e66f5e3007f0cd3deacfaffd669" translate="yes" xml:space="preserve">
          <source>. You should be able to use this
absolutely anywhere you can use a</source>
          <target state="translated">. 당신이 사용할 수있는 모든 곳에서 이것을 절대적으로 사용할 수 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="e7f36d14ee5e1f6d131d0fcabe098d27f86aad7d" translate="yes" xml:space="preserve">
          <source>A dict with attribute-style access</source>
          <target state="translated">속성 스타일 액세스가있는 dict</target>
        </trans-unit>
        <trans-unit id="388a951440518f6d73c198361e0518b929a2cd1a" translate="yes" xml:space="preserve">
          <source>All three Attr classes can be merged with eachother or other Mappings using the</source>
          <target state="translated">세 가지 Attr 클래스는 모두 다음을 사용하여 서로 또는 다른 매핑과 병합 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="80cfc66f597ad1a9a7a74a2569f032e8ed192826" translate="yes" xml:space="preserve">
          <source>An Attr object that subclasses</source>
          <target state="translated">서브 클래 싱하는 Attr 객체</target>
        </trans-unit>
        <trans-unit id="3d777f94e6c2538c81bbeca36c71defbfa75a07e" translate="yes" xml:space="preserve">
          <source>Any key can be used as an attribute as long as:</source>
          <target state="translated">다음과 같은 경우 모든 키를 속성으로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="866b536688e92b28271400dd183fd9ffd9a0f52a" translate="yes" xml:space="preserve">
          <source>Assignment as keys will still work:</source>
          <target state="translated">키 할당은 계속 작동합니다.</target>
        </trans-unit>
        <trans-unit id="fc04a24097921ddaa01e14ab8bcf63fd87f05c1b" translate="yes" xml:space="preserve">
          <source>At Attr object that behaves like a</source>
          <target state="translated">Attr 객체는</target>
        </trans-unit>
        <trans-unit id="b861b0ae4a7bca3fd5304fa2e10f363cbda3deb7" translate="yes" xml:space="preserve">
          <source>AttrDefault</source>
          <target state="translated">AttrDefault</target>
        </trans-unit>
        <trans-unit id="de7cd9086777ba676dc66efc06dbabff4f8b2b23" translate="yes" xml:space="preserve">
          <source>AttrDefault also has a</source>
          <target state="translated">AttrDefault에는 또한</target>
        </trans-unit>
        <trans-unit id="563a42155c5bb513cebfd27a686d7f5c3c9450a4" translate="yes" xml:space="preserve">
          <source>AttrDict</source>
          <target state="translated">AttrDict</target>
        </trans-unit>
        <trans-unit id="e1e02581e9da83c6e107d134a2e4da1edf5f9ee7" translate="yes" xml:space="preserve">
          <source>AttrDict comes with three different classes,</source>
          <target state="translated">AttrDict에는 세 가지 클래스가 있습니다.</target>
        </trans-unit>
        <trans-unit id="b7acc9c2fa3145e01bcb1735a96320082d5d4d4f" translate="yes" xml:space="preserve">
          <source>AttrDict comes with three different objects,</source>
          <target state="translated">AttrDict에는 세 가지 개체가 있습니다.</target>
        </trans-unit>
        <trans-unit id="97cad167761ce8e174d2547443223671eb18025d" translate="yes" xml:space="preserve">
          <source>AttrDict is an MIT-licensed library that provides mapping objects that allow
their elements to be accessed both as keys and as attributes:</source>
          <target state="translated">AttrDict는 요소를 키와 속성으로 모두 액세스 할 수있는 매핑 개체를 제공하는 MIT 라이선스 라이브러리입니다.</target>
        </trans-unit>
        <trans-unit id="d2f69ecd892fc3e419fbe280247fba45a9af46f2" translate="yes" xml:space="preserve">
          <source>AttrDict is in PyPI, so it can be installed directly using:</source>
          <target state="translated">AttrDict는 PyPI에 있으므로 다음을 사용하여 직접 설치할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ea6f44c5f7d2ba1d492f7dfe3527126e847d80da" translate="yes" xml:space="preserve">
          <source>AttrDict is released under a MIT license.</source>
          <target state="translated">AttrDict는 MIT 라이선스로 출시되었습니다.</target>
        </trans-unit>
        <trans-unit id="7d16f63f233c884b88c024beef93ef4869894f31" translate="yes" xml:space="preserve">
          <source>AttrMap</source>
          <target state="translated">AttrMap</target>
        </trans-unit>
        <trans-unit id="cb565fb6cdf158e9ebf3f2242d07987e99755a44" translate="yes" xml:space="preserve">
          <source>Attribute access makes it easy to create convenient, hierarchical settings
objects:</source>
          <target state="translated">속성 액세스를 사용하면 편리한 계층 적 설정 개체를 쉽게 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="de07dccdfb62e16b05d0e3c001fe5f755934aee3" translate="yes" xml:space="preserve">
          <source>Attributes vs. Keys</source>
          <target state="translated">속성 대 키</target>
        </trans-unit>
        <trans-unit id="b20cbc384159fd820ed034fd3615298ec09f5902" translate="yes" xml:space="preserve">
          <source>Basic Usage</source>
          <target state="translated">기본 사용법</target>
        </trans-unit>
        <trans-unit id="c0b86a828bc5ced4f5e696be4d306284c36e5926" translate="yes" xml:space="preserve">
          <source>By default, items in non-string Sequences (e.g. lists, tuples) will be
converted to AttrDicts:</source>
          <target state="translated">기본적으로 문자열이 아닌 시퀀스 (예 : 목록, 튜플)의 항목은 AttrDict로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="ed1846afee3be21521286932b99e2aeae9e6414a" translate="yes" xml:space="preserve">
          <source>Classes</source>
          <target state="translated">클래스</target>
        </trans-unit>
        <trans-unit id="97cdbdc7feff827efb082a6b6dd2727237cd49fd" translate="yes" xml:space="preserve">
          <source>False</source>
          <target state="translated">그릇된</target>
        </trans-unit>
        <trans-unit id="be9ae17642442049ac4c2ef919fd9c28a90f1087" translate="yes" xml:space="preserve">
          <source>If either of these caveats are deal-breakers, or you don&amp;rsquo;t need your object to
be a</source>
          <target state="translated">이러한 경고 중 하나가 거래를 방해하는 경우 또는 개체가 될 필요가없는 경우</target>
        </trans-unit>
        <trans-unit id="c81b79df3c6448eae7c4f80428b54cd5692a17d7" translate="yes" xml:space="preserve">
          <source>Installation</source>
          <target state="translated">설치</target>
        </trans-unit>
        <trans-unit id="3229609e15436ec51bcf00818a69a84dbc58a0c2" translate="yes" xml:space="preserve">
          <source>License</source>
          <target state="translated">특허</target>
        </trans-unit>
        <trans-unit id="40de0d4de887a374168bf79e72c7aa0fa4594d6e" translate="yes" xml:space="preserve">
          <source>Merging</source>
          <target state="translated">병합</target>
        </trans-unit>
        <trans-unit id="304995ed252b737012b035215aa311a2b98a2c54" translate="yes" xml:space="preserve">
          <source>NOTE: AttrDict&amp;rsquo;s add is not commutative,</source>
          <target state="translated">참고 : AttrDict의 추가는 교환이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="07c24fa219fba84d32880ece6fdadce59ecadb6b" translate="yes" xml:space="preserve">
          <source>Or from Github:</source>
          <target state="translated">또는 Github에서 :</target>
        </trans-unit>
        <trans-unit id="68d52809828fe7472e5716c4dff1ef72595a17cb" translate="yes" xml:space="preserve">
          <source>Recursive attribute access results in a shallow copy, so recursive assignment
will fail (as you will be writing to a copy of that dictionary):</source>
          <target state="translated">재귀 속성 액세스로 인해 얕은 복사가 발생하므로 재귀 할당이 실패합니다 (해당 사전의 사본에 기록 할 것임).</target>
        </trans-unit>
        <trans-unit id="ae6e1ecc353f021830966b6e7c9d88505471ce64" translate="yes" xml:space="preserve">
          <source>Relatedly, by default, sequence types that aren&amp;rsquo;t</source>
          <target state="translated">이와 관련하여 기본적으로</target>
        </trans-unit>
        <trans-unit id="b5fb636023abb67d347041d398442118f79ea091" translate="yes" xml:space="preserve">
          <source>Sequences</source>
          <target state="translated">시퀀스</target>
        </trans-unit>
        <trans-unit id="93ef0dd827103681fcee453b78be2ff14e1a261d" translate="yes" xml:space="preserve">
          <source>The</source>
          <target state="translated">그만큼</target>
        </trans-unit>
        <trans-unit id="ae8ddde88faa73f8ba66cdf8e427cb20f61236ab" translate="yes" xml:space="preserve">
          <source>The key does not shadow a class attribute (e.g., get).</source>
          <target state="translated">키는 클래스 속성 (예 : get)을 숨기지 않습니다.</target>
        </trans-unit>
        <trans-unit id="60650cfe0ce8c828561272ae234237ead311df69" translate="yes" xml:space="preserve">
          <source>The key represents a public attribute (i.e., it doesn&amp;rsquo;t start with an
underscore). This is done (in part) so that implementation changes between
minor and micro versions don&amp;rsquo;t force major version changes.</source>
          <target state="translated">키는 공개 속성을 나타냅니다 (즉, 밑줄로 시작하지 않음). 이는 부분적으로 수행되므로 부 버전과 마이크로 버전 간의 구현 변경으로 인해 주 버전이 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f071eaca5e568c54b292f6a4ba70ed1cbdd2a92d" translate="yes" xml:space="preserve">
          <source>The key represents a valid attribute (i.e., it is a string comprised only of
alphanumeric characters and underscores that doesn&amp;rsquo;t start with a number)</source>
          <target state="translated">키는 유효한 속성을 나타냅니다 (즉, 숫자로 시작하지 않는 영숫자와 밑줄로만 구성된 문자열).</target>
        </trans-unit>
        <trans-unit id="03e297e14a6beaf56419f226a304a42c4da6cc1e" translate="yes" xml:space="preserve">
          <source>The most basic implementation. Use this if you want to limit the number of
invalid keys, or otherwise cannot use</source>
          <target state="translated">가장 기본적인 구현입니다. 유효하지 않은 키의 수를 제한하거나 사용할 수없는 경우에 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="83caa4896bb23997dea2bd3cae2ad3e62fe16ea3" translate="yes" xml:space="preserve">
          <source>There is a minor difference between accessing a value as an attribute vs.
accessing it as a key, is that when a dict is accessed as an attribute, it will
automatically be converted to an Attr object. This allows you to recursively
access keys:</source>
          <target state="translated">속성으로 값에 액세스하는 것과 키로 액세스하는 것 사이에는 사소한 차이가 있습니다. 딕셔너리가 속성으로 액세스되면 자동으로 Attr 객체로 변환된다는 것입니다. 이를 통해 재귀 적으로 키에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2760e3308bbbc670c560af3f04349f3bf82f07de" translate="yes" xml:space="preserve">
          <source>This will not occur if you access the AttrDict as a dictionary:</source>
          <target state="translated">AttrDict에 사전으로 액세스하는 경우에는 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="fcda2a058c36d257277b667fccf603ffcf587ffa" translate="yes" xml:space="preserve">
          <source>To disable this behavior globally, pass the attribute</source>
          <target state="translated">이 동작을 전역 적으로 비활성화하려면 속성을 전달하십시오.</target>
        </trans-unit>
        <trans-unit id="b4c6da101d3a4b1594ec988563f47f1f60e85748" translate="yes" xml:space="preserve">
          <source>To get this recursive functionality for keys that cannot be used as attributes,
you can replicate the behavior by calling the Attr object:</source>
          <target state="translated">속성으로 사용할 수없는 키에 대해이 재귀 기능을 얻으려면 Attr 객체를 호출하여 동작을 복제 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d488cb468296278b27f92e9fea26cec2d90b1a00" translate="yes" xml:space="preserve">
          <source>Valid Names</source>
          <target state="translated">유효한 이름</target>
        </trans-unit>
        <trans-unit id="7b0db9c5d2d41e5d824e05f9241184027edcdf1e" translate="yes" xml:space="preserve">
          <source>When merging an AttrDict with another mapping, this behavior will be disabled
if at least one of the merged items is an AttrDict that has set</source>
          <target state="translated">AttrDict를 다른 매핑과 병합 할 때 병합 된 항목 중 하나 이상이 설정된 AttrDict 인 경우이 동작이 비활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="c91ac9b9df178938cde8e690cc6951a4ead06690" translate="yes" xml:space="preserve">
          <source>a + b != b + a</source>
          <target state="translated">a + b! = b + a</target>
        </trans-unit>
        <trans-unit id="daf529a73101c2be626b99fc6938163e7a27620b" translate="yes" xml:space="preserve">
          <source>bytes</source>
          <target state="translated">바이트</target>
        </trans-unit>
        <trans-unit id="f84e2e2dadd87384fb55f25886926b777e8378f1" translate="yes" xml:space="preserve">
          <source>copy</source>
          <target state="translated">부</target>
        </trans-unit>
        <trans-unit id="0fa494c647221d96036c09dd3917bd470e3aa168" translate="yes" xml:space="preserve">
          <source>default_factory</source>
          <target state="translated">default_factory</target>
        </trans-unit>
        <trans-unit id="f90aef983629a7d310fd034c80bf7a15787a6479" translate="yes" xml:space="preserve">
          <source>defaultdict</source>
          <target state="translated">defaultdict</target>
        </trans-unit>
        <trans-unit id="76e94348139b788d21edc7b9cd011af238d0de03" translate="yes" xml:space="preserve">
          <source>dict</source>
          <target state="translated">dict</target>
        </trans-unit>
        <trans-unit id="dcecaa58d8e4bf0eb155a96557f2e868a53aa3df" translate="yes" xml:space="preserve">
          <source>instead of an</source>
          <target state="translated">대신</target>
        </trans-unit>
        <trans-unit id="6568964b0e39083c6acb94093d9e6cd117dbe508" translate="yes" xml:space="preserve">
          <source>instead.</source>
          <target state="translated">대신.</target>
        </trans-unit>
        <trans-unit id="5f9ca3ec02bdc0f84434f55d6b4157c56df643ef" translate="yes" xml:space="preserve">
          <source>method (which returns a shallow copy of the mapping) returns a</source>
          <target state="translated">메서드 (매핑의 얕은 복사본을 반환)은</target>
        </trans-unit>
        <trans-unit id="350430ff75db011e0220198b8bb2f73a4c7a4a03" translate="yes" xml:space="preserve">
          <source>operator. For conflicting keys, the right dict&amp;rsquo;s value will be
preferred, but in the case of two dictionary values, they will be
recursively merged:</source>
          <target state="translated">운영자. 충돌하는 키의 경우 오른쪽 dict의 값이 선호되지만 두 사전 값의 경우 재귀 적으로 병합됩니다.</target>
        </trans-unit>
        <trans-unit id="56f5df31bd18359684e05cffd9194742f875d381" translate="yes" xml:space="preserve">
          <source>option that passes the supplied key to the</source>
          <target state="translated">제공된 키를</target>
        </trans-unit>
        <trans-unit id="18d1939e4fcb64d387808676e5e665321397115a" translate="yes" xml:space="preserve">
          <source>pass_key</source>
          <target state="translated">곁쇠</target>
        </trans-unit>
        <trans-unit id="594a4346defb3386cfbe1790c0232c2bf0dd0137" translate="yes" xml:space="preserve">
          <source>recursive</source>
          <target state="translated">재귀</target>
        </trans-unit>
        <trans-unit id="d1be42a7594e592e9e6a87ff56e92dbef4ae0c72" translate="yes" xml:space="preserve">
          <source>recursive=False</source>
          <target state="translated">recursive = 거짓</target>
        </trans-unit>
        <trans-unit id="3442496b96dd01591a8cd44b1eec1368ab728aba" translate="yes" xml:space="preserve">
          <source>str</source>
          <target state="translated">str</target>
        </trans-unit>
        <trans-unit id="4374aaee247fb237ce6c97d5c8d64bbe474d16de" translate="yes" xml:space="preserve">
          <source>to</source>
          <target state="translated">에</target>
        </trans-unit>
        <trans-unit id="eefb40ba442d03ca50c1f1cf284208d3a89c7abe" translate="yes" xml:space="preserve">
          <source>to
the constructor:</source>
          <target state="translated">생성자에게 :</target>
        </trans-unit>
        <trans-unit id="96c6908f66b1b7d0e5248f7ae9e4039ca1564e60" translate="yes" xml:space="preserve">
          <source>under
the hood.</source>
          <target state="translated">후드.</target>
        </trans-unit>
        <trans-unit id="1d1e8914a3d46b4097dec7a7370a1cc102848137" translate="yes" xml:space="preserve">
          <source>unicode</source>
          <target state="translated">유니 코드</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
