<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://pypi.org/project/cl4py/">
    <body>
      <group id="cl4py">
        <trans-unit id="5c10b5b2cd673a0616d529aa5234b12ee7153808" translate="yes" xml:space="preserve">
          <source>,</source>
          <target state="translated">,</target>
        </trans-unit>
        <trans-unit id="dfc68394d92d28ed14e74422c938a34492324fd4" translate="yes" xml:space="preserve">
          <source>.  This
means, that the Lisp process will ignore any user initialization files,
including the Quicklisp setup.  However, we provide an extra option for
installing and loading Quicklisp automatically:</source>
          <target state="translated">. 즉, Lisp 프로세스는 Quicklisp 설정을 포함하여 모든 사용자 초기화 파일을 무시합니다. 그러나 Quicklisp를 자동으로 설치하고로드하기위한 추가 옵션을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="4911a208b464e3c88a14296c202fff997a17499d" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://docs.hylang.org/en/stable/&quot;&gt;Hy&lt;/a&gt;
- Python, but with Lisp syntax. This project is certainly a great way to
get started with Lisp. It allows you to study the advantages of Lisp&amp;rsquo;s
seemingly weird syntax, without leaving the comfortable Python
ecosystem. Once you understand the advantages of Lisp, you will doubly
appreciate cl4py for your projects.</source>
          <target state="translated">&lt;a href=&quot;http://docs.hylang.org/en/stable/&quot;&gt;Hy&lt;/a&gt; -Python이지만 Lisp 구문이 있습니다. 이 프로젝트는 확실히 Lisp를 시작하는 좋은 방법입니다. 편안한 Python 생태계를 벗어나지 않고도 Lisp의 이상한 구문의 장점을 연구 할 수 있습니다. Lisp의 장점을 이해하면 프로젝트에 대한 cl4py를 두 배로 높이 평가할 것입니다.</target>
        </trans-unit>
        <trans-unit id="1d1057ed26fcf9d9d5910c3b2d1101ee4ec6fc0e" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/bendudson/py4cl&quot;&gt;py4cl&lt;/a&gt;
- A library that allows Common Lisp code to access Python libraries.  It
is basically the inverse of cl4py.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/bendudson/py4cl&quot;&gt;py4cl&lt;/a&gt; -Common Lisp 코드가 Python 라이브러리에 액세스 할 수 있도록하는 라이브러리입니다. 기본적으로 cl4py의 반대입니다.</target>
        </trans-unit>
        <trans-unit id="8b891ac4c97379c150d0ecd3d198ae5a95776353" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/metawilm/cl-python&quot;&gt;cl-python&lt;/a&gt;
- A much heavier solution than cl4py &amp;mdash; let&amp;rsquo;s simply implement Python
in Lisp! An amazing project. However, cl-python cannot access foreign
libraries, e.g., NumPy. And people are probably hesitant to migrate away
from CPython.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/metawilm/cl-python&quot;&gt;cl-python-&lt;/a&gt; cl4py보다 훨씬 무거운 솔루션 &amp;mdash; Lisp에서 Python을 구현해 보겠습니다! 놀라운 프로젝트입니다. 그러나 cl-python은 NumPy와 같은 외부 라이브러리에 액세스 할 수 없습니다. 그리고 사람들은 아마도 CPython에서 이주하는 것을 주저 할 것입니다.</target>
        </trans-unit>
        <trans-unit id="a6cac227b0e0cfeba9b90f7681aca51b3fa2ed22" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/pinterface/burgled-batteries&quot;&gt;burgled-batteries&lt;/a&gt;
- A bridge between Python and Lisp. The goal is that Lisp programs can
use Python libraries, which is in some sense the opposite of
cl4py. Furthermore it relies on the less portable mechanism of FFI
calls.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/pinterface/burgled-batteries&quot;&gt;burgled-batteries-&lt;/a&gt; Python과 Lisp 사이의 다리. 목표는 Lisp 프로그램이 어떤 의미에서는 cl4py와 반대 인 Python 라이브러리를 사용할 수 있다는 것입니다. 또한 휴대 성이 떨어지는 FFI 호출 메커니즘에 의존합니다.</target>
        </trans-unit>
        <trans-unit id="50d835c00486b111eca88683714097e58a1abbfb" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://www.nicklevine.org/claude/&quot;&gt;CLAUDE&lt;/a&gt;
- An earlier attempt to access Lisp libraries from Python. The key
difference is that cl4py does not run Lisp directly in the host
process. This makes cl4py more portable, but complicates the exchange of
data.</source>
          <target state="translated">&lt;a href=&quot;https://www.nicklevine.org/claude/&quot;&gt;CLAUDE&lt;/a&gt; -Python에서 Lisp 라이브러리에 액세스하려는 이전 시도. 주요 차이점은 cl4py가 호스트 프로세스에서 직접 Lisp를 실행하지 않는다는 것입니다. 이것은 cl4py를 더 이식 가능하게 만들지 만 데이터 교환을 복잡하게 만듭니다.</target>
        </trans-unit>
        <trans-unit id="4bbc2bad866e068f7a83235c65224f8f43ca8e4f" translate="yes" xml:space="preserve">
          <source>By default, cl4py starts a Lisp subprocess with</source>
          <target state="translated">기본적으로 cl4py는 다음을 사용하여 Lisp 하위 프로세스를 시작합니다.</target>
        </trans-unit>
        <trans-unit id="b820f44f707e2d2bfda8a73e7deeb8deb276083f" translate="yes" xml:space="preserve">
          <source>Common Lisp for Python</source>
          <target state="translated">Python 용 Common Lisp</target>
        </trans-unit>
        <trans-unit id="148b514079c970f00202742b91f589dab000adac" translate="yes" xml:space="preserve">
          <source>Frequently Asked Problems</source>
          <target state="translated">자주 묻는 문제</target>
        </trans-unit>
        <trans-unit id="fce92a58d4a009a80c62759514bdc0f104880ceb" translate="yes" xml:space="preserve">
          <source>It soon becomes clumsy to look up individual Lisp functions by name.
Instead, it is usually better to convert entire Lisp packages to Python
modules, like this:</source>
          <target state="translated">곧 개별 Lisp 함수를 이름으로 찾는 것이 어색해집니다. 대신, 일반적으로 전체 Lisp 패키지를 다음과 같이 Python 모듈로 변환하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="d6a06199cc127e571d3588aef63c79108675eabc" translate="yes" xml:space="preserve">
          <source>Motivation</source>
          <target state="translated">자극</target>
        </trans-unit>
        <trans-unit id="7fac72fa371151361d1c539c6461c22eccaa90fe" translate="yes" xml:space="preserve">
          <source>Of course, this requires you have some Lisp installed. If not, use
something like</source>
          <target state="translated">물론 Lisp가 설치되어 있어야합니다. 그렇지 않은 경우 다음과 같이 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="15fcd561f77dbd0c514f2391d3c7596df9294341" translate="yes" xml:space="preserve">
          <source>Package QL does not exist</source>
          <target state="translated">패키지 QL이 없습니다.</target>
        </trans-unit>
        <trans-unit id="5080ebd78aaa8f3e4acd6d4cd153e6b28156a27a" translate="yes" xml:space="preserve">
          <source>Related Projects</source>
          <target state="translated">관련 프로젝트</target>
        </trans-unit>
        <trans-unit id="c2496758451190079c5ff46ed234f6bf876783e3" translate="yes" xml:space="preserve">
          <source>Some Lisp data structures have no direct equivalent in Python, most
notably, cons cells.  The cl4py module provides a suitable Cons class and
converts List conses to instances of cl4py.Cons.</source>
          <target state="translated">일부 Lisp 데이터 구조는 Python, 특히 단점 셀에서 직접적으로 동등하지 않습니다. cl4py 모듈은 적합한 Cons 클래스를 제공하고 List conses를 cl4py.Cons의 인스턴스로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="40102a7557c7125cb544b98b57257f65d209dd20" translate="yes" xml:space="preserve">
          <source>The library cl4py (pronounce as &lt;em&gt;clappy&lt;/em&gt;) allows Python programs to call
Common Lisp libraries.  Its official mascot is the cl4py-bird:</source>
          <target state="translated">cl4py 라이브러리 ( &lt;em&gt;clappy&lt;/em&gt; 로 발음 )를 사용하면 Python 프로그램이 Common Lisp 라이브러리를 호출 할 수 있습니다. 공식 마스코트는 cl4py-bird입니다.</target>
        </trans-unit>
        <trans-unit id="2701a94c0eb55cbd958a87dff3e959673ff1bf53" translate="yes" xml:space="preserve">
          <source>Tutorial</source>
          <target state="translated">지도 시간</target>
        </trans-unit>
        <trans-unit id="d1fd463e2211f716e42a7d42d60ef7a504f5676a" translate="yes" xml:space="preserve">
          <source>Why does my Lisp subprocess complain about</source>
          <target state="translated">Lisp 하위 프로세스가 왜 불평합니까?</target>
        </trans-unit>
        <trans-unit id="e2a9f255c2065c6cb3cc36379ae5c9bb470b0b5b" translate="yes" xml:space="preserve">
          <source>You are a Python programmer, but you want access to some of the powerful
features of Lisp, for example to compile code at run time?  Or you want to
use some &lt;a href=&quot;http://codys.club/awesome-cl/&quot;&gt;awesome Lisp libraries&lt;/a&gt;?  Or
you are a Lisp programmer and want to show your work to your Python
friends.  In all these cases, cl4py is here to help you.</source>
          <target state="translated">Python 프로그래머이지만 Lisp의 강력한 기능 중 일부에 액세스하고 싶습니까? 예를 들어 런타임에 코드를 컴파일하고 싶습니까? 아니면 &lt;a href=&quot;http://codys.club/awesome-cl/&quot;&gt;멋진 Lisp 라이브러리&lt;/a&gt; 를 사용하고 싶 습니까? 또는 Lisp 프로그래머이고 Python 친구들에게 작업을 보여주고 싶습니다. 이 모든 경우에 cl4py가 도움을드립니다.</target>
        </trans-unit>
        <trans-unit id="a1829fa02283e0a82ccbadc9abe55eff92b9688f" translate="yes" xml:space="preserve">
          <source>You can start any number of Lisp subprocesses within Python, like this:</source>
          <target state="translated">다음과 같이 Python 내에서 Lisp 하위 프로세스를 얼마든지 시작할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2ca175d569e3bddb9bd42186937f3d9a19474282" translate="yes" xml:space="preserve">
          <source>apt install sbcl</source>
          <target state="translated">적절한 설치 sbcl</target>
        </trans-unit>
        <trans-unit id="a0d6591fa77e0813e270cc0b321c6f1da9640f76" translate="yes" xml:space="preserve">
          <source>brew install
sbcl</source>
          <target state="translated">양조 설치 sbcl</target>
        </trans-unit>
        <trans-unit id="1758356db21759f7c5a0da9b4dd1db8fd6feab3f" translate="yes" xml:space="preserve">
          <source>or</source>
          <target state="translated">또는</target>
        </trans-unit>
        <trans-unit id="84122cdb9e98b2fdddcd6d887b4d74a136bd5068" translate="yes" xml:space="preserve">
          <source>pacman -S sbcl</source>
          <target state="translated">팩맨 -S sbcl</target>
        </trans-unit>
        <trans-unit id="8f2ed9f246f7ff0643d359045e9252655a4fb598" translate="yes" xml:space="preserve">
          <source>quicklisp=True</source>
          <target state="translated">quicklisp = 참</target>
        </trans-unit>
        <trans-unit id="e5afdbd708aea1d57f803c59648c0871a0966485" translate="yes" xml:space="preserve">
          <source>sbcl --script</source>
          <target state="translated">sbcl-스크립트</target>
        </trans-unit>
        <trans-unit id="b519792eff2865136af2e654208db187c51b185b" translate="yes" xml:space="preserve">
          <source>to correct this deficiency.  Once you have a running Lisp process,
you can execute Lisp code on it:</source>
          <target state="translated">이 결함을 바로 잡기 위해. Lisp 프로세스를 실행하면 Lisp 코드를 실행할 수 있습니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
