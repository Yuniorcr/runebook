<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://pypi.org/project/interruptingcow/">
    <body>
      <group id="interruptingcow">
        <trans-unit id="6bc1590dfcbdb301bd3fc694482e905c002fbff9" translate="yes" xml:space="preserve">
          <source>. This is especially useful if you need to use timeouts inside
a loop:</source>
          <target state="translated">. 루프 내에서 타임 아웃을 사용해야하는 경우 특히 유용합니다.</target>
        </trans-unit>
        <trans-unit id="91ed72b09d86323b770db27b4f560729a7904c06" translate="yes" xml:space="preserve">
          <source>A single quota instance can also be shared across all calls to</source>
          <target state="translated">단일 할당량 인스턴스는</target>
        </trans-unit>
        <trans-unit id="91ab6de67140382715a706c6b86487130dfc26a7" translate="yes" xml:space="preserve">
          <source>A watchdog that interrupts long running code.</source>
          <target state="translated">장기 실행 코드를 방해하는 감시 장치입니다.</target>
        </trans-unit>
        <trans-unit id="bcaa33a7ae44bd5042c37a9cdbea7f843b1cf7c8" translate="yes" xml:space="preserve">
          <source>Caveats</source>
          <target state="translated">주의 사항</target>
        </trans-unit>
        <trans-unit id="f9bc84905cba827e95b5956427d9ad40017c389c" translate="yes" xml:space="preserve">
          <source>Function Decorators</source>
          <target state="translated">함수 데코레이터</target>
        </trans-unit>
        <trans-unit id="90ccbc0f73f833ba4a7dc419dfecd654a29ac167" translate="yes" xml:space="preserve">
          <source>Here the first iterations of the loop will be able to perform the expensive
operation, until the shared quota of 1 second runs out and then the remaining
iterations will perform the cheaper alternative.</source>
          <target state="translated">여기에서 루프의 첫 번째 반복은 1 초의 공유 할당량이 소진 될 때까지 값 비싼 작업을 수행 할 수 있으며 나머지 반복은 더 저렴한 대안을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="c81b79df3c6448eae7c4f80428b54cd5692a17d7" translate="yes" xml:space="preserve">
          <source>Installation</source>
          <target state="translated">설치</target>
        </trans-unit>
        <trans-unit id="01f66e58c5c7ca4131c491df9a126bb3c41e02c4" translate="yes" xml:space="preserve">
          <source>Interruptingcow can be used both as inline with-statements, as shown in the
above examples, as well as function decorator:</source>
          <target state="translated">Interruptingcow는 위의 예에서 볼 수 있듯이 인라인 with 문과 함수 데코레이터로 모두 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="40c7589064e2922e00957a1ad49c0c5896d4a32f" translate="yes" xml:space="preserve">
          <source>Interruptingcow is a generic utility that can relatively gracefully interrupt
your Python code when it doesn&amp;rsquo;t execute within a specific number of seconds:</source>
          <target state="translated">Interruptingcow는 특정 시간 (초) 내에 실행되지 않을 때 Python 코드를 비교적 정상적으로 중단 할 수있는 일반 유틸리티입니다.</target>
        </trans-unit>
        <trans-unit id="e472f27291a09ff43bd87651c2868e6dc36ff1fa" translate="yes" xml:space="preserve">
          <source>Interruptingcow is fully reentrant, which means that you can have nested
timeouts:</source>
          <target state="translated">Interruptingcow는 완전히 재진입 할 ​​수 있습니다. 즉, 중첩 된 시간 제한이있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9b6a50a43fd6a20daef13c2515986257a7041490" translate="yes" xml:space="preserve">
          <source>Interruptingcow uses</source>
          <target state="translated">Interruptingcow 사용</target>
        </trans-unit>
        <trans-unit id="be0c48cfd3ef20a8264b9227cd931f846cf6e1ef" translate="yes" xml:space="preserve">
          <source>Nested timeouts allow a large outer timeout to contain smaller timeouts. If the
inner timeout is larger than the outer timeout, it is treated as a no-op.</source>
          <target state="translated">중첩 된 제한 시간을 사용하면 큰 외부 제한 시간에 더 작은 제한 시간을 포함 할 수 있습니다. 내부 제한 시간이 외부 제한 시간보다 크면 작동하지 않는 것으로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="12e8487c89310d95b953a86f6ff4e4d5a5ae8952" translate="yes" xml:space="preserve">
          <source>Python signal handlers only apply to the main thread, so you cannot use this
from other threads</source>
          <target state="translated">Python 시그널 핸들러는 메인 스레드에만 적용되므로 다른 스레드에서는 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="34ed58657019e0ff061ea2eef787a27a97813fe2" translate="yes" xml:space="preserve">
          <source>Quotas</source>
          <target state="translated">할당량</target>
        </trans-unit>
        <trans-unit id="c6c7c207248bceb6cac7b700949f9600500cf95d" translate="yes" xml:space="preserve">
          <source>Reentrant</source>
          <target state="translated">요각</target>
        </trans-unit>
        <trans-unit id="612d258ad3979828ff77ec263e19302d53bbcebf" translate="yes" xml:space="preserve">
          <source>SIGALRM</source>
          <target state="translated">SIGALRM</target>
        </trans-unit>
        <trans-unit id="3a0c19395e7f7b280f19eacaf987ff80595a5af0" translate="yes" xml:space="preserve">
          <source>Timeouts are specified in seconds (as floats with theoretical microsecond
precision).</source>
          <target state="translated">시간 초과는 초 단위로 지정됩니다 (이론적 인 마이크로 초 정밀도의 부동 소수점으로).</target>
        </trans-unit>
        <trans-unit id="f87d93ca86e0d02536f0b0048a8e22ba92836133" translate="yes" xml:space="preserve">
          <source>You can allocate a quota of time and then share it across multiple invocations
to</source>
          <target state="translated">시간 할당량을 할당 한 다음 여러 호출에서 공유 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="42cdda99c5dd687c864135113e949f5e1279bc26" translate="yes" xml:space="preserve">
          <source>You must not use this in a program that uses</source>
          <target state="translated">다음을 사용하는 프로그램에서 이것을 사용해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="4102e794e1cfda05bf881af2fb79c64e55767e91" translate="yes" xml:space="preserve">
          <source>itself (this
includes certain profilers)</source>
          <target state="translated">자체 (특정 프로파일 러 포함)</target>
        </trans-unit>
        <trans-unit id="475550261e270acc4ea4ab219b2f675454cfe35e" translate="yes" xml:space="preserve">
          <source>signal(SIGALRM)</source>
          <target state="translated">신호 (SIGALRM)</target>
        </trans-unit>
        <trans-unit id="9d016b3866e9919a7d47d575df231372a071a433" translate="yes" xml:space="preserve">
          <source>timeout()</source>
          <target state="translated">타임 아웃 ()</target>
        </trans-unit>
        <trans-unit id="68a15c96c33ece93562a8ffe226b914ff803ecae" translate="yes" xml:space="preserve">
          <source>to let the operating system interrupt
program execution. This has the following limitations:</source>
          <target state="translated">운영 체제가 프로그램 실행을 중단하도록합니다. 여기에는 다음과 같은 제한이 있습니다.</target>
        </trans-unit>
        <trans-unit id="e91ccf7694c627ebf4aac81318f5e0aab360c750" translate="yes" xml:space="preserve">
          <source>you have.</source>
          <target state="translated">당신은 가지고 있습니다.</target>
        </trans-unit>
        <trans-unit id="1f200e2f0297af6daa029907fda834d1e310b887" translate="yes" xml:space="preserve">
          <source>your application makes (including nested calls), to give place an upper bound
on the total runtime, regardless of how many calls to</source>
          <target state="translated">응용 프로그램은 (중첩 된 호출 포함) 호출 횟수에 관계없이 총 런타임에 상한선을 제공합니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
