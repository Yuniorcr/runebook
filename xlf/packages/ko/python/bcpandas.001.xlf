<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://pypi.org/project/bcpandas/">
    <body>
      <group id="bcpandas">
        <trans-unit id="2b84ff96244431fc59487bc112f83689f35d35f4" translate="yes" xml:space="preserve">
          <source>(continuing example above)</source>
          <target state="translated">(위의 계속되는 예)</target>
        </trans-unit>
        <trans-unit id="b89a64dfe77728c2429687df2f1e767d89d04235" translate="yes" xml:space="preserve">
          <source>:white_check_mark:</source>
          <target state="translated">: white_check_mark :</target>
        </trans-unit>
        <trans-unit id="76e3d5524e143855957921563877ecc340a8f38d" translate="yes" xml:space="preserve">
          <source>:x:</source>
          <target state="translated">:엑스:</target>
        </trans-unit>
        <trans-unit id="4836865bbd25774ba0868873e41dc65975fb0b06" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.microsoft.com/en-us/sql/tools/bcp-utility&quot;&gt;BCP&lt;/a&gt; Utility</source>
          <target state="translated">&lt;a href=&quot;https://docs.microsoft.com/en-us/sql/tools/bcp-utility&quot;&gt;BCP&lt;/a&gt; 유틸리티</target>
        </trans-unit>
        <trans-unit id="581cf8b96b273994f1a0d32ae2f89feaeb9924f9" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/titan550/bcpy&quot;&gt;bcpy&lt;/a&gt; has several flaws:</source>
          <target state="translated">&lt;a href=&quot;https://github.com/titan550/bcpy&quot;&gt;bcpy&lt;/a&gt; 에는 몇 가지 결함이 있습니다.</target>
        </trans-unit>
        <trans-unit id="eb1a5258765bef87dcfb5a45d1928686e8a6cf66" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;numpy.NaN&lt;/code&gt;, &lt;code&gt;None&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;numpy.NaN&lt;/code&gt; , &lt;code&gt;None&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ffae9028254c446fd16cb7e3ef77614349ed5c61" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;numpy.inf&lt;/code&gt; (fails, as expected)</source>
          <target state="translated">&lt;code&gt;numpy.inf&lt;/code&gt; (예상대로 실패)</target>
        </trans-unit>
        <trans-unit id="12224a99522728ff06bc19e04f22478701fd4838" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pandas&lt;/code&gt; &amp;gt;= 0.19</source>
          <target state="translated">&lt;code&gt;pandas&lt;/code&gt; &amp;gt; = 0.19</target>
        </trans-unit>
        <trans-unit id="4d8d5146c6e6d799c74cb3a5840b3bdfa3b1762d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pyodbc&lt;/code&gt; as the &lt;a href=&quot;https://docs.sqlalchemy.org/en/13/dialects/mssql.html#module-sqlalchemy.dialects.mssql.pyodbc&quot;&gt;supported DBAPI&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;pyodbc&lt;/code&gt; &lt;a href=&quot;https://docs.sqlalchemy.org/en/13/dialects/mssql.html#module-sqlalchemy.dialects.mssql.pyodbc&quot;&gt;지원되는 DBAPI&lt;/a&gt; 로 pyodbc</target>
        </trans-unit>
        <trans-unit id="cd74a966d207661429813a8a660a3e30d9f23cc0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pytest-cov&lt;/code&gt; (which uses &lt;code&gt;coverage.py&lt;/code&gt; under the hood) is used to measure code coverage. This is then uploaded to &lt;a href=&quot;https://codecov.io/gh/yehoshuadimarsky/bcpandas&quot;&gt;codecov.io&lt;/a&gt; as part of the CI/CD process (see below).</source>
          <target state="translated">&lt;code&gt;pytest-cov&lt;/code&gt; (내부에서 &lt;code&gt;coverage.py&lt;/code&gt; 사용)는 코드 커버리지를 측정하는 데 사용됩니다. 그런 다음 CI / CD 프로세스의 일부로 &lt;a href=&quot;https://codecov.io/gh/yehoshuadimarsky/bcpandas&quot;&gt;codecov.io에&lt;/a&gt; 업로드됩니다 (아래 참조).</target>
        </trans-unit>
        <trans-unit id="8bb5f287cc1e42d12a5d8ba03efe21e809edff80" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sqlalchemy&lt;/code&gt; &amp;gt;= 1.1.4</source>
          <target state="translated">&lt;code&gt;sqlalchemy&lt;/code&gt; &amp;gt; = 1.1.4</target>
        </trans-unit>
        <trans-unit id="78255068df60a5f13b5c2f02554a2d1bfd983874" translate="yes" xml:space="preserve">
          <source>&lt;del&gt;If there is a NaN/Null in the last column of the dataframe it will throw an error. This is due to a BCP issue. See my issue with Microsoft about this &lt;a href=&quot;https://github.com/MicrosoftDocs/sql-docs/issues/2689&quot;&gt;here&lt;/a&gt;.&lt;/del&gt; This doesn't seem to be a problem based on the tests.</source>
          <target state="translated">&lt;del&gt;데이터 프레임의 마지막 열에 NaN / Null이 있으면 오류가 발생합니다. 이것은 BCP 문제 때문입니다. &lt;a href=&quot;https://github.com/MicrosoftDocs/sql-docs/issues/2689&quot;&gt;여기&lt;/a&gt; 에서 Microsoft에 대한 내 문제를 참조 하십시오 .&lt;/del&gt; 이것은 테스트에 따르면 문제가되지 않는 것 같습니다.</target>
        </trans-unit>
        <trans-unit id="5443a8fe489f4b2a5e21a2be54853312785f5021" translate="yes" xml:space="preserve">
          <source>A convoluted, overly class-based internal design</source>
          <target state="translated">복잡하고 지나치게 클래스 기반의 내부 디자인</target>
        </trans-unit>
        <trans-unit id="8136ea47893bb6bb3bdd2662707167d1e50ba885" translate="yes" xml:space="preserve">
          <source>An empty string (&lt;code&gt;&quot;&quot;&lt;/code&gt;) in the dataframe becomes &lt;code&gt;NULL&lt;/code&gt; in the SQL database instead of remaining an empty string.</source>
          <target state="translated">데이터 프레임 의 빈 문자열 ( &lt;code&gt;&quot;&quot;&lt;/code&gt; ) 은 빈 문자열이 아닌 SQL 데이터베이스에서 &lt;code&gt;NULL&lt;/code&gt; 이 됩니다 .</target>
        </trans-unit>
        <trans-unit id="812ab620f478475a5ebda099456721c6c7e0043d" translate="yes" xml:space="preserve">
          <source>Any version of Microsoft SQL Server. Can be installed on-prem, in the cloud, on a VM, or one of the Azure versions.</source>
          <target state="translated">모든 버전의 Microsoft SQL Server. 온-프레미스, 클라우드, VM 또는 Azure 버전 중 하나에 설치할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="14148fbce0183b3e58b829b94ac9721f58af64ec" translate="yes" xml:space="preserve">
          <source>As you can see, pandas native clearly wins here</source>
          <target state="translated">보시다시피 판다 원주민이 분명히 이깁니다.</target>
        </trans-unit>
        <trans-unit id="b3ec344f6d5bb6015e30100abb1ebc72a7d36b1b" translate="yes" xml:space="preserve">
          <source>BCPandas</source>
          <target state="translated">BCPandas</target>
        </trans-unit>
        <trans-unit id="64dd60fe1a049fe6db3eb1369dec2e42bf428e21" translate="yes" xml:space="preserve">
          <source>Background</source>
          <target state="translated">배경</target>
        </trans-unit>
        <trans-unit id="7850ad1fb073003cae12f25032a05442a117f1f5" translate="yes" xml:space="preserve">
          <source>Bcpandas has been tested with all ASCII characters 32-127. Unicode characters beyond that range have not been tested.</source>
          <target state="translated">Bcpandas는 모든 ASCII 문자 32-127로 테스트되었습니다. 해당 범위를 벗어난 유니 코드 문자는 테스트되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="145a0a84fd6f860c424ac5c3d09d21d33d00f5fa" translate="yes" xml:space="preserve">
          <source>Bcpandas requires a &lt;code&gt;bcpandas.SqlCreds&lt;/code&gt; object in order to use it, and also a &lt;code&gt;sqlalchemy.Engine&lt;/code&gt;. The user has 2 options when constructing it.</source>
          <target state="translated">Bcpandas를 사용하려면 &lt;code&gt;bcpandas.SqlCreds&lt;/code&gt; 객체와 &lt;code&gt;sqlalchemy.Engine&lt;/code&gt; 이 필요 합니다. 사용자는 그것을 구성 할 때 두 가지 옵션이 있습니다.</target>
        </trans-unit>
        <trans-unit id="3508d1816f504c4af81ecdd0323b15ea7c25b474" translate="yes" xml:space="preserve">
          <source>Because bcpandas first outputs to CSV, it needs to use several specific characters to create the CSV, including a &lt;em&gt;delimiter&lt;/em&gt; and a &lt;em&gt;quote character&lt;/em&gt;. Bcpandas attempts to use  characters that are not present in the dataframe for this, going through the possilbe delimiters and quote characters specified in &lt;code&gt;constants.py&lt;/code&gt;. If all possible characters are present in the dataframe and bcpandas cannot find both a delimiter and quote character to use, it will throw an error.</source>
          <target state="translated">bcpandas는 먼저 CSV로 출력하기 때문에 CSV를 만들려면 &lt;em&gt;구분 기호&lt;/em&gt; 와 &lt;em&gt;따옴표 문자를&lt;/em&gt; 포함하여 여러 특정 문자를 사용해야 &lt;em&gt;합니다&lt;/em&gt; . 시도는이에 대한 dataframe에 존재하지 않는에 지정된 possilbe 구분 기호와 인용 부호를 거치지 문자를 사용하는 Bcpandas &lt;code&gt;constants.py&lt;/code&gt; 을 . 가능한 모든 문자가 데이터 프레임에 있고 bcpandas가 사용할 구분 기호와 따옴표 문자를 모두 찾을 수없는 경우 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="db706274a149e8745c23ef55afb14dbd27aa7f2e" translate="yes" xml:space="preserve">
          <source>Because it is still much slower</source>
          <target state="translated">여전히 훨씬 느리기 때문에</target>
        </trans-unit>
        <trans-unit id="8eb442ba9fc29343f2fcc7b8c56d33281f7d96dc" translate="yes" xml:space="preserve">
          <source>Because you are forced to set the &lt;code&gt;chunksize&lt;/code&gt; parameter to a very small number for it to work - generally a bit less then &lt;code&gt;2100/&amp;lt;number of columns&amp;gt;&lt;/code&gt;. This is because SQL Server can only accept up to 2100 parameters in a query. See &lt;a href=&quot;https://stackoverflow.com/questions/50689082/to-sql-pyodbc-count-field-incorrect-or-syntax-error&quot;&gt;here&lt;/a&gt; and &lt;a href=&quot;https://github.com/mkleehammer/pyodbc/issues/217&quot;&gt;here&lt;/a&gt; for more discussion on this, and the recommendation to use a bulk insert tool such as BCP. It seems that SQL Server simply didn't design the regular &lt;code&gt;INSERT&lt;/code&gt; statement to support huge amounts of data.</source>
          <target state="translated">작동하려면 &lt;code&gt;chunksize&lt;/code&gt; 매개 변수를 매우 작은 수로 설정해야하므로 일반적으로 &lt;code&gt;2100/&amp;lt;number of columns&amp;gt;&lt;/code&gt; 보다 약간 작습니다 . 이는 SQL Server가 쿼리에서 최대 2100 개의 매개 변수 만 받아 들일 수 있기 때문입니다. 이에 대한 자세한 내용과 BCP와 같은 대량 삽입 도구를 사용하기위한 권장 사항 은 &lt;a href=&quot;https://stackoverflow.com/questions/50689082/to-sql-pyodbc-count-field-incorrect-or-syntax-error&quot;&gt;여기&lt;/a&gt; 와 &lt;a href=&quot;https://github.com/mkleehammer/pyodbc/issues/217&quot;&gt;여기&lt;/a&gt; 를 참조 하십시오 . SQL Server는 엄청난 양의 데이터를 지원하기 위해 일반 &lt;code&gt;INSERT&lt;/code&gt; 문을 디자인하지 않은 것 같습니다 .</target>
        </trans-unit>
        <trans-unit id="4f46ac72b3634f96c6860b1ed26d9d4cd71d21aa" translate="yes" xml:space="preserve">
          <source>Benchmarks</source>
          <target state="translated">벤치 마크</target>
        </trans-unit>
        <trans-unit id="25ef1b4378fab2acfcb4bfaec56de16f3a8c47fd" translate="yes" xml:space="preserve">
          <source>CI/CD</source>
          <target state="translated">CI / CD</target>
        </trans-unit>
        <trans-unit id="8901895fb1b1d4c4ea2fec368c25176bf73e2f7e" translate="yes" xml:space="preserve">
          <source>Command</source>
          <target state="translated">명령</target>
        </trans-unit>
        <trans-unit id="ecf2e3b26ea2414a35178b19b8880b296c3d6d18" translate="yes" xml:space="preserve">
          <source>Conda</source>
          <target state="translated">콘다</target>
        </trans-unit>
        <trans-unit id="2d82a4b27a4b305690d5ac612046a955778a9fa5" translate="yes" xml:space="preserve">
          <source>Contributing</source>
          <target state="translated">기여</target>
        </trans-unit>
        <trans-unit id="041c9624ae9bde19cfe1b3aef4bcbfd516a3e4f2" translate="yes" xml:space="preserve">
          <source>Create creds (see next section)</source>
          <target state="translated">자격 증명 만들기 (다음 섹션 참조)</target>
        </trans-unit>
        <trans-unit id="d2277c2470dce46d0446e41643b36dc157685d59" translate="yes" xml:space="preserve">
          <source>Create the bcpandas &lt;code&gt;SqlCreds&lt;/code&gt; object with just the minimum attributes needed (server, database, username, password), and bcpandas will create a full &lt;code&gt;Engine&lt;/code&gt; object from this. It will use &lt;code&gt;pyodbc&lt;/code&gt;, &lt;code&gt;sqlalchemy&lt;/code&gt;, and the Microsoft ODBC Driver for SQL Server, and will store it in the &lt;code&gt;.engine&lt;/code&gt; attribute.</source>
          <target state="translated">필요한 최소한의 속성 (서버, 데이터베이스, 사용자 이름, 암호) 만 사용 하여 bcpandas &lt;code&gt;SqlCreds&lt;/code&gt; 개체를 만들고 bcpandas는 여기에서 전체 &lt;code&gt;Engine&lt;/code&gt; 개체를 만듭니다 . 그것은 사용 &lt;code&gt;pyodbc&lt;/code&gt; , &lt;code&gt;sqlalchemy&lt;/code&gt; , 및 SQL Server 용 Microsoft ODBC 드라이버 및에 저장됩니다 &lt;code&gt;.engine&lt;/code&gt; 속성.</target>
        </trans-unit>
        <trans-unit id="0f9a3d3c77a3e5189127aec138f272b3273064f5" translate="yes" xml:space="preserve">
          <source>Credential/Connection object</source>
          <target state="translated">자격 증명 / 연결 개체</target>
        </trans-unit>
        <trans-unit id="d023b329fe7007e5bb9557b9d934149be38715d5" translate="yes" xml:space="preserve">
          <source>Data types: All ASCII characters 32-127 (using the Hypothesis library, see below). Unicode characters beyond that range have not been tested.</source>
          <target state="translated">데이터 유형 : 모든 ASCII 문자 32-127 (가설 라이브러리 사용, 아래 참조). 해당 범위를 벗어난 유니 코드 문자는 테스트되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="61074f1c958d6cdd32dad889b3d58a2d0704cbe3" translate="yes" xml:space="preserve">
          <source>Database</source>
          <target state="translated">데이터 베이스</target>
        </trans-unit>
        <trans-unit id="691ce6b53b50d3f885d4222772e2a70799907e08" translate="yes" xml:space="preserve">
          <source>Database columns that are missing from the dataframe, are out of order, or both (passes)</source>
          <target state="translated">데이터 프레임에서 누락되거나 순서가 맞지 않거나 둘 다 (통과) 된 데이터베이스 열</target>
        </trans-unit>
        <trans-unit id="76f28351a7d0c8876ec4cf3dc017b25e19d1c043" translate="yes" xml:space="preserve">
          <source>Design and Scope</source>
          <target state="translated">디자인 및 범위</target>
        </trans-unit>
        <trans-unit id="7307d0d41237bcfa9b4164065b4ae1c16c5070f9" translate="yes" xml:space="preserve">
          <source>Docker Desktop installed, either of the Linux or Windows runtimes, doesn't matter</source>
          <target state="translated">Linux 또는 Windows 런타임 중 하나에 설치된 Docker Desktop은 중요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="80a466f377e6463c788fa476b5d058155e687809" translate="yes" xml:space="preserve">
          <source>Duplicate column names (raises error)</source>
          <target state="translated">중복 된 열 이름 (오류 발생)</target>
        </trans-unit>
        <trans-unit id="64ccda66e16a44cbba57a4db2b57a9a05bc450f4" translate="yes" xml:space="preserve">
          <source>Empty dataframe (nothing happens, database not modified)</source>
          <target state="translated">빈 데이터 프레임 (아무것도 발생하지 않음, 데이터베이스가 수정되지 않음)</target>
        </trans-unit>
        <trans-unit id="a9ae32d0b39095733ff905d0f13fb3f93e4a75f1" translate="yes" xml:space="preserve">
          <source>Existing Solutions</source>
          <target state="translated">기존 솔루션</target>
        </trans-unit>
        <trans-unit id="76284d7bc7ed062672bc5972bdb127a08e71fcd9" translate="yes" xml:space="preserve">
          <source>Extra dataframe columns that aren't in database, when &lt;code&gt;if_exists=&quot;append&quot;&lt;/code&gt; specified (fails)</source>
          <target state="translated">&lt;code&gt;if_exists=&quot;append&quot;&lt;/code&gt; 가 지정된 경우 (실패) 데이터베이스에없는 추가 데이터 프레임 열</target>
        </trans-unit>
        <trans-unit id="ad565d9d01d0e0bf91fd6a8532f6d81613338901" translate="yes" xml:space="preserve">
          <source>Feature</source>
          <target state="translated">특색</target>
        </trans-unit>
        <trans-unit id="3acb1702b49c155fe6302829070e992486dcd322" translate="yes" xml:space="preserve">
          <source>For now, we are using the non-XML BCP format file type. In the future, XML format files may be added.</source>
          <target state="translated">지금은 비 XML BCP 형식 파일 유형을 사용하고 있습니다. 앞으로 XML 형식 파일이 추가 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="81b1231bbf8b818b98726cdc0006bb44b7de1bd4" translate="yes" xml:space="preserve">
          <source>Github Actions is used for CI/CD, although it is still somewhat a work in progress.</source>
          <target state="translated">Github Actions는 CI / CD에 사용되지만 아직 진행중인 작업입니다.</target>
        </trans-unit>
        <trans-unit id="52a99797ae5b7e3cfb129ed2df62557a2d94f55c" translate="yes" xml:space="preserve">
          <source>Good for simple data types like numbers and dates</source>
          <target state="translated">숫자 및 날짜와 같은 간단한 데이터 유형에 적합</target>
        </trans-unit>
        <trans-unit id="dabf30b579c8c0bd6e23af5eb7b139345fa4df0e" translate="yes" xml:space="preserve">
          <source>Handle messy string data</source>
          <target state="translated">지저분한 문자열 데이터 처리</target>
        </trans-unit>
        <trans-unit id="547b7980a4a464c718de4e7055baf94c4675407f" translate="yes" xml:space="preserve">
          <source>Here are some caveats and limitations of bcpandas.</source>
          <target state="translated">다음은 bcpandas의 몇 가지주의 사항과 제한 사항입니다.</target>
        </trans-unit>
        <trans-unit id="d5aae98f14872303c91c9d73ac64438923bdc2f6" translate="yes" xml:space="preserve">
          <source>High-level wrapper around BCP for high performance data transfers between pandas and SQL Server. No knowledge of BCP required!!</source>
          <target state="translated">Pandas와 SQL Server 간의 고성능 데이터 전송을위한 BCP 주변의 고급 래퍼입니다. BCP에 대한 지식이 필요하지 않습니다 !!</target>
        </trans-unit>
        <trans-unit id="9db61721b3c0b0accb2d62591aa7f2898fa5e0e0" translate="yes" xml:space="preserve">
          <source>High-level wrapper around BCP for high performance data transfers between pandas and SQL Server. No knowledge of BCP required!! (pronounced &lt;em&gt;BEE-CEE-Pandas&lt;/em&gt;)</source>
          <target state="translated">Pandas와 SQL Server 간의 고성능 데이터 전송을위한 BCP 주변의 고급 래퍼입니다. BCP에 대한 지식이 필요하지 않습니다 !! ( &lt;em&gt;BEE-CEE-Pandas&lt;/em&gt; 로 발음 )</target>
        </trans-unit>
        <trans-unit id="fa8278b8ef8905e7f0a40631d946ff53074c850c" translate="yes" xml:space="preserve">
          <source>I didn't bother including the pandas non-&lt;code&gt;multiinsert&lt;/code&gt; version here because it just takes way too long</source>
          <target state="translated">너무 오래 걸리기 때문에 여기에 pandas non- &lt;code&gt;multiinsert&lt;/code&gt; 버전을 포함하지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="3d407a0ff2b36881d9fc324af8fcaebf8e0992a5" translate="yes" xml:space="preserve">
          <source>I will attempt to use the &lt;code&gt;pandas&lt;/code&gt; docstring style as detailed &lt;a href=&quot;https://pandas.pydata.org/pandas-docs/stable/development/contributing_docstring.html&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://pandas.pydata.org/pandas-docs/stable/development/contributing_docstring.html&quot;&gt;여기에&lt;/a&gt; 설명 된대로 &lt;code&gt;pandas&lt;/code&gt; 독 스트링 스타일 을 사용하려고합니다 .</target>
        </trans-unit>
        <trans-unit id="c3fab8786779f3e61b8f68a7ac126fed43557a2d" translate="yes" xml:space="preserve">
          <source>IMPORTANT - Read vs. Write</source>
          <target state="translated">중요-읽기 대 쓰기</target>
        </trans-unit>
        <trans-unit id="21a587ecb595cbd02b92ebe158e13eff7c106f26" translate="yes" xml:space="preserve">
          <source>In order to spin up a local SQL Server during testing, we use Docker. Specifically, we run one of the images that Microsoft provides that already have SQL Server fully installed, all we have to do is use the image to run a container. Here are the links to the &lt;a href=&quot;https://hub.docker.com/_/microsoft-mssql-server&quot;&gt;Linux versions&lt;/a&gt; and the Windows versions - &lt;a href=&quot;https://hub.docker.com/r/microsoft/mssql-server-windows-express/&quot;&gt;Express&lt;/a&gt; and &lt;a href=&quot;https://hub.docker.com/r/microsoft/mssql-server-windows-developer&quot;&gt;Developer&lt;/a&gt;.</source>
          <target state="translated">테스트 중에 로컬 SQL Server를 가동하기 위해 Docker를 사용합니다. 특히, Microsoft가 이미 SQL Server가 완전히 설치된 이미지 중 하나를 실행합니다. 이미지를 사용하여 컨테이너를 실행하기 만하면됩니다. 다음은 &lt;a href=&quot;https://hub.docker.com/_/microsoft-mssql-server&quot;&gt;Linux 버전&lt;/a&gt; 과 Windows 버전 ( &lt;a href=&quot;https://hub.docker.com/r/microsoft/mssql-server-windows-express/&quot;&gt;Express&lt;/a&gt; 및 &lt;a href=&quot;https://hub.docker.com/r/microsoft/mssql-server-windows-developer&quot;&gt;Developer)에&lt;/a&gt; 대한 링크 입니다.</target>
        </trans-unit>
        <trans-unit id="c81b79df3c6448eae7c4f80428b54cd5692a17d7" translate="yes" xml:space="preserve">
          <source>Installation</source>
          <target state="translated">설치</target>
        </trans-unit>
        <trans-unit id="3e1d61d3b4e30cc9a0f56244235c036c9bf428e1" translate="yes" xml:space="preserve">
          <source>Instead of using the &lt;code&gt;subprocess&lt;/code&gt; library to control Docker manually, we use the elegant &lt;code&gt;docker-py&lt;/code&gt; library which works very nicely. A &lt;code&gt;DockerDB&lt;/code&gt; Python class is defined in &lt;code&gt;bcpandas/tests/utils.py&lt;/code&gt; and it wraps up all the Docker commands and functionality needed to use SQL Server into one class. This class is used in &lt;code&gt;conftest.py&lt;/code&gt; in the core bcpandas tests, and in the &lt;code&gt;benchmarks/&lt;/code&gt; directory for both the benchmarks code as well as the legacy tests for &lt;code&gt;read_sql&lt;/code&gt;.</source>
          <target state="translated">Docker를 수동으로 제어하기 위해 &lt;code&gt;subprocess&lt;/code&gt; 라이브러리를 사용하는 대신 매우 훌륭하게 작동 하는 우아한 &lt;code&gt;docker-py&lt;/code&gt; 라이브러리를 사용합니다. &lt;code&gt;DockerDB&lt;/code&gt; 파이썬 클래스에 정의되어 &lt;code&gt;bcpandas/tests/utils.py&lt;/code&gt; 그것은 하나 개의 클래스에 SQL Server를 사용하는 데 필요한 모든 도커 명령과 기능을 래핑합니다. 이 클래스에서 사용되는 &lt;code&gt;conftest.py&lt;/code&gt; 시험 bcpandas 핵심으로하고있는 &lt;code&gt;benchmarks/&lt;/code&gt; 벤치 마크 코드뿐만 아니라에 대한 기존의 시험을 모두 디렉토리 &lt;code&gt;read_sql&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a66dd1dbbcdaed8372df35dfee9c244c4fe29ad0" translate="yes" xml:space="preserve">
          <source>JSON file of the benchmark data</source>
          <target state="translated">벤치 마크 데이터의 JSON 파일</target>
        </trans-unit>
        <trans-unit id="c356804ddce0f7e1a9765716af7555229e0ea654" translate="yes" xml:space="preserve">
          <source>JSON file with the environment details of the machine that was used to generate it</source>
          <target state="translated">생성에 사용 된 머신의 환경 세부 사항이 포함 된 JSON 파일</target>
        </trans-unit>
        <trans-unit id="f5025143a89e9b224781aa62468c0e2c91c66496" translate="yes" xml:space="preserve">
          <source>Known Issues</source>
          <target state="translated">알려진 문제</target>
        </trans-unit>
        <trans-unit id="bc167ac3f0e18206129211c7f3fa357e48c5c4b5" translate="yes" xml:space="preserve">
          <source>Microsoft ODBC Driver &lt;strong&gt;11, 13, 13.1, or 17&lt;/strong&gt; for SQL Server. See the &lt;a href=&quot;https://github.com/mkleehammer/pyodbc/wiki/Connecting-to-SQL-Server-from-Windows&quot;&gt;pyodbc docs&lt;/a&gt; for details.</source>
          <target state="translated">SQL Server 용 Microsoft ODBC Driver &lt;strong&gt;11, 13, 13.1 또는 17&lt;/strong&gt; . 자세한 내용은 &lt;a href=&quot;https://github.com/mkleehammer/pyodbc/wiki/Connecting-to-SQL-Server-from-Windows&quot;&gt;pyodbc 문서&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="6df0fe186d7f4fe3db9e445dc14466665fdbbe28" translate="yes" xml:space="preserve">
          <source>Much credit is due to &lt;code&gt;bcpy&lt;/code&gt; for the original idea and for some of the code that was adopted and changed.</source>
          <target state="translated">많은 신용 예정이다 &lt;code&gt;bcpy&lt;/code&gt; 원래의 아이디어를 채택하고 변경된 코드의 일부.</target>
        </trans-unit>
        <trans-unit id="d4b2a1e43166e35dafcdfee719b641412d2a1787" translate="yes" xml:space="preserve">
          <source>No support for reading from SQL, only writing to SQL</source>
          <target state="translated">SQL 읽기 지원 없음, SQL 쓰기 만 지원</target>
        </trans-unit>
        <trans-unit id="3d45dc15d4aa32921a6bd5174281815bac463550" translate="yes" xml:space="preserve">
          <source>PNG image of the graph</source>
          <target state="translated">그래프의 PNG 이미지</target>
        </trans-unit>
        <trans-unit id="26f36cc3e752dabfb46d93d28cf67ca7e0964af6" translate="yes" xml:space="preserve">
          <source>Pandas native</source>
          <target state="translated">팬더 네이티브</target>
        </trans-unit>
        <trans-unit id="c0896b5a24266a7f891c8679df9cf1580202d0f3" translate="yes" xml:space="preserve">
          <source>Pass a full &lt;code&gt;Engine&lt;/code&gt; object to the bcpandas &lt;code&gt;SqlCreds&lt;/code&gt; object, and bcpandas will attempt to parse out the server, database, username, and password to pass to the command line utilities. If a DSN is used, this will fail.</source>
          <target state="translated">전체 &lt;code&gt;Engine&lt;/code&gt; 개체를 bcpandas &lt;code&gt;SqlCreds&lt;/code&gt; 개체에 전달하면 bcpandas는 서버, 데이터베이스, 사용자 이름 및 암호를 구문 분석하여 명령 줄 유틸리티에 전달합니다. DSN을 사용하면 실패합니다.</target>
        </trans-unit>
        <trans-unit id="c45012d793434c12de12f6b04ab7092f9aae5e61" translate="yes" xml:space="preserve">
          <source>Please, all contributions are very welcome!</source>
          <target state="translated">모든 기부를 환영합니다!</target>
        </trans-unit>
        <trans-unit id="33e72da85f21769ca9a8ee3181ea9def0321f98f" translate="yes" xml:space="preserve">
          <source>PyPI</source>
          <target state="translated">PyPI</target>
        </trans-unit>
        <trans-unit id="c32b6c1ab053aa1b803595ba447bebbb8760c137" translate="yes" xml:space="preserve">
          <source>Python &amp;gt;= 3.6</source>
          <target state="translated">Python&amp;gt; = 3.6</target>
        </trans-unit>
        <trans-unit id="164100a124690d40ea0f689d3e939d9e9bbbf9c5" translate="yes" xml:space="preserve">
          <source>Python User</source>
          <target state="translated">Python 사용자</target>
        </trans-unit>
        <trans-unit id="d07133c8504b6a0e98371a1b9afe2ca2855a7270" translate="yes" xml:space="preserve">
          <source>Quickstart</source>
          <target state="translated">빠른 시작</target>
        </trans-unit>
        <trans-unit id="c33ebb18aa7c683e58237addbd590da420348847" translate="yes" xml:space="preserve">
          <source>Recommended Usage</source>
          <target state="translated">권장 사용법</target>
        </trans-unit>
        <trans-unit id="08d9bc6898acc588635443ca8df6948b4af9793e" translate="yes" xml:space="preserve">
          <source>Replace any &lt;code&gt;df.to_sql(...)&lt;/code&gt; in your code with &lt;code&gt;bcpandas.to_sql(df, ...)&lt;/code&gt;</source>
          <target state="translated">어떤 교체 &lt;code&gt;df.to_sql(...)&lt;/code&gt; 사용하여 코드에서 &lt;code&gt;bcpandas.to_sql(df, ...)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="09a428f93ec07a73d726f8bd037ecacfaaf8b044" translate="yes" xml:space="preserve">
          <source>Requirements</source>
          <target state="translated">요구 사항</target>
        </trans-unit>
        <trans-unit id="71d4a739c996a8252e5b9838680b099447f11563" translate="yes" xml:space="preserve">
          <source>Running this will output</source>
          <target state="translated">이것을 실행하면 출력됩니다</target>
        </trans-unit>
        <trans-unit id="4c3581a4d5355beb88ad0bea14ac93c6dc4c9163" translate="yes" xml:space="preserve">
          <source>Scope a bit too broad - deals with pandas as well as flat files
This repository aims to fix and improve on &lt;code&gt;bcpy&lt;/code&gt; and the above issues by making the design choices described earlier.</source>
          <target state="translated">범위가 너무 넓습니다. 플랫 파일뿐만 아니라 팬더도 다룹니다.이 저장소는 앞에서 설명한 디자인 선택을 통해 &lt;code&gt;bcpy&lt;/code&gt; 및 위의 문제 를 수정하고 개선하는 것을 목표로 합니다.</target>
        </trans-unit>
        <trans-unit id="a3a612f92d3ceff5a3d5ae1a7a9f30fdf9233090" translate="yes" xml:space="preserve">
          <source>See figures below. All code is in the &lt;code&gt;/benchmarks&lt;/code&gt; directory. To run the benchmarks, from the root directory of this repository, run &lt;code&gt;python benchmarks/benchmark.py main --help&lt;/code&gt; and fill in the command line options that are presented.</source>
          <target state="translated">아래 그림을 참조하십시오. 모든 코드는 &lt;code&gt;/benchmarks&lt;/code&gt; 디렉토리에 있습니다. 벤치 마크를 실행하려면이 저장소의 루트 디렉토리에서 &lt;code&gt;python benchmarks/benchmark.py main --help&lt;/code&gt; 를 실행 하고 표시되는 명령 줄 옵션을 입력합니다.</target>
        </trans-unit>
        <trans-unit id="6da13addb000b67d42a6d66391713819e634149f" translate="yes" xml:space="preserve">
          <source>Source</source>
          <target state="translated">출처</target>
        </trans-unit>
        <trans-unit id="4a5d769ec38e509a2cc0d034cbf395fa726c2163" translate="yes" xml:space="preserve">
          <source>Super speed</source>
          <target state="translated">초고속</target>
        </trans-unit>
        <trans-unit id="0820b32b206b7352858e8903a838ed14319acdfd" translate="yes" xml:space="preserve">
          <source>Testing</source>
          <target state="translated">테스팅</target>
        </trans-unit>
        <trans-unit id="72f6ac91015e7ff555be46a691c5d5439b6a006f" translate="yes" xml:space="preserve">
          <source>Testing Implementation</source>
          <target state="translated">테스트 구현</target>
        </trans-unit>
        <trans-unit id="fdabde9e2546d302d5577b7817f77c38b8ea8095" translate="yes" xml:space="preserve">
          <source>Testing Requirements</source>
          <target state="translated">테스트 요구 사항</target>
        </trans-unit>
        <trans-unit id="7e187957ecf95e1b7c04491211d99d11fb5d46b7" translate="yes" xml:space="preserve">
          <source>Testing uses &lt;code&gt;pytest&lt;/code&gt;.</source>
          <target state="translated">테스트는 &lt;code&gt;pytest&lt;/code&gt; 를 사용 합니다 .</target>
        </trans-unit>
        <trans-unit id="e93f4cf2c16977aa0828b84202ee64df60519c65" translate="yes" xml:space="preserve">
          <source>That's it!</source>
          <target state="translated">그게 다야!</target>
        </trans-unit>
        <trans-unit id="cf8b8e72a0f0d39a93c59901416904bc1ebcbf95" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;strong&gt;only&lt;/strong&gt;&lt;/em&gt; scope of &lt;code&gt;bcpandas&lt;/code&gt; is to read and write between a pandas DataFrame and a Microsoft SQL Server database. That's it. We do &lt;em&gt;&lt;strong&gt;not&lt;/strong&gt;&lt;/em&gt; concern ourselves with reading existing flat files to/from SQL - that introduces &lt;em&gt;way&lt;/em&gt; to much complexity in trying to parse and decode the various parts of the file, like delimiters, quote characters, and line endings. Instead, to read/write an exiting flat file, just import it via pandas into a DataFrame, and then use &lt;code&gt;bcpandas&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;bcpandas&lt;/code&gt; 의 &lt;em&gt;&lt;strong&gt;유일한&lt;/strong&gt;&lt;/em&gt; 범위는 Pandas DataFrame과 Microsoft SQL Server 데이터베이스 사이에서 읽고 쓰는 것입니다. 그게 다야. 우리는 할 수 &lt;em&gt;&lt;strong&gt;없는&lt;/strong&gt;&lt;/em&gt; SQL에서 / 기존 플랫 파일을 읽는 우려 자신을 - 그 소개의 &lt;em&gt;방법으로&lt;/em&gt; 구분, 인용 부호 및 선 엔딩처럼, 구문 분석하고 파일의 여러 부분을 디코딩하는 노력에 많은 복잡성이. 대신 기존 플랫 파일을 읽고 쓰려면 pandas를 통해 DataFrame으로 가져온 다음 &lt;code&gt;bcpandas&lt;/code&gt; 를 사용 하면 됩니다.</target>
        </trans-unit>
        <trans-unit id="935ef7ea006a968f0e6aa05f8b21d0ef6b501136" translate="yes" xml:space="preserve">
          <source>The BCP utility does &lt;strong&gt;not&lt;/strong&gt; ignore delimiter characters when surrounded by quotes, unlike CSVs - see &lt;a href=&quot;https://docs.microsoft.com/en-us/sql/relational-databases/import-export/specify-field-and-row-terminators-sql-server#characters-supported-as-terminators&quot;&gt;here&lt;/a&gt; in the Microsoft docs.</source>
          <target state="translated">BCP 유틸리티 는 CSV와 달리 따옴표로 묶인 구분 문자를 무시 하지 &lt;strong&gt;않습니다&lt;/strong&gt; . Microsoft 문서의 &lt;a href=&quot;https://docs.microsoft.com/en-us/sql/relational-databases/import-export/specify-field-and-row-terminators-sql-server#characters-supported-as-terminators&quot;&gt;여기&lt;/a&gt; 를 참조 하세요 .</target>
        </trans-unit>
        <trans-unit id="dd16e25205e87e71f6f85d75be7cb12d82640bdc" translate="yes" xml:space="preserve">
          <source>The big benefit of this is that we get to precicely control all the finicky parts of the text file when we write/read it to a local file and then in the BCP utility. This lets us set library-wide defaults (maybe configurable in the future) and work with those.</source>
          <target state="translated">이것의 큰 이점은 텍스트 파일을 로컬 파일에 쓰거나 읽을 때 BCP 유틸리티에서 텍스트 파일의 모든 까다로운 부분을 정밀하게 제어 할 수 있다는 것입니다. 이를 통해 라이브러리 전체의 기본값 (향후 구성 가능)을 설정하고이를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c2fed85ad249e75421b950e6e4ef07685f5a9825" translate="yes" xml:space="preserve">
          <source>The big speedup benefit of bcpandas is in the &lt;code&gt;to_sql&lt;/code&gt; function, as the benchmarks below show. However, the bcpandas &lt;code&gt;read_sql&lt;/code&gt; function actually performs &lt;strong&gt;slower&lt;/strong&gt; than the pandas equivalent. Therefore, the bcpandas &lt;code&gt;read_sql&lt;/code&gt; function was deprecated in v5.0 and has now been removed in v6.0+. To read data &lt;strong&gt;from&lt;/strong&gt; SQL to pandas, use the native pandas method &lt;code&gt;pd.read_sql_table&lt;/code&gt; or &lt;code&gt;pd.read_sql_query&lt;/code&gt;.</source>
          <target state="translated">bcpandas의 큰 속도 향상 장점은에 &lt;code&gt;to_sql&lt;/code&gt; 의 쇼 아래의 벤치 마크로서 기능. 그러나 bcpandas &lt;code&gt;read_sql&lt;/code&gt; 함수는 실제로 pandas에 해당하는 것보다 &lt;strong&gt;느리게&lt;/strong&gt; 수행 됩니다. 따라서 bcpandas &lt;code&gt;read_sql&lt;/code&gt; 함수는 v5.0에서 더 이상 사용되지 않으며 이제 v6.0 이상에서 제거되었습니다. 데이터를 읽으려면 &lt;strong&gt;에서&lt;/strong&gt; 팬더에 SQL을 기본 팬더 방법 사용 &lt;code&gt;pd.read_sql_table&lt;/code&gt; 또는 &lt;code&gt;pd.read_sql_query&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="f26a925ed89f7dc927bccea30da0e63653a37df0" translate="yes" xml:space="preserve">
          <source>This package is a wrapper for seamlessly using the bcp utility from Python using a pandas DataFrame. Despite the IO hits, the fastest option by far is saving the data to a CSV file in the file system and using the bcp utility to transfer the CSV file to SQL Server. &lt;strong&gt;Best of all, you don't need to know anything about using BCP at all!&lt;/strong&gt;</source>
          <target state="translated">이 패키지는 pandas DataFrame을 사용하여 Python의 bcp 유틸리티를 원활하게 사용하기위한 래퍼입니다. IO 히트에도 불구하고 가장 빠른 옵션은 파일 시스템의 CSV 파일에 데이터를 저장하고 bcp 유틸리티를 사용하여 CSV 파일을 SQL Server로 전송하는 것입니다. &lt;strong&gt;무엇보다도 BCP 사용에 대해 전혀 알 필요가 없습니다!&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c9c47aa7f6032f05875deb0226f3f944ec08fc09" translate="yes" xml:space="preserve">
          <source>To test for all possible data types, we use the &lt;code&gt;hypothesis&lt;/code&gt; library, instead of trying to come up with every single case on our own.</source>
          <target state="translated">가능한 모든 데이터 유형을 테스트하기 위해 우리 는 모든 단일 사례를 자체적으로 제시하는 대신 &lt;code&gt;hypothesis&lt;/code&gt; 라이브러리를 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="0bb18642b70b9f8a9c12ccf39487328f306b8e19" translate="yes" xml:space="preserve">
          <source>Usage</source>
          <target state="translated">용법</target>
        </trans-unit>
        <trans-unit id="d792e208dd4288df221b3b3ede563a86487fd15f" translate="yes" xml:space="preserve">
          <source>We take testing very seriously here. In order to rely on a library like this in production, it &lt;strong&gt;MUST&lt;/strong&gt; be ruthlessly tested, which thankfully it is.
Here is a partial list of what has been tested so far. Pull Requests welcome!</source>
          <target state="translated">우리는 여기서 테스트를 매우 진지하게 받아들입니다. 프로덕션에서 이와 같은 라이브러리에 의존하려면 무자비하게 테스트 &lt;strong&gt;해야&lt;/strong&gt; 합니다. 고맙게도 그렇습니다. 다음은 지금까지 테스트 된 내용의 일부 목록입니다. 풀 리퀘스트 환영합니다!</target>
        </trans-unit>
        <trans-unit id="d619ad7cc694d2eb378d8abe6f951f3c088fe61c" translate="yes" xml:space="preserve">
          <source>What Is Tested?</source>
          <target state="translated">무엇을 테스트합니까?</target>
        </trans-unit>
        <trans-unit id="4a6a9ea1c387d614a4dfcfd6ea6fd479e5eda7c0" translate="yes" xml:space="preserve">
          <source>When running the tests, we can specify a specific Docker image to use, by invoking the custom command line option called &lt;code&gt;--mssql-docker-image&lt;/code&gt;. For example:</source>
          <target state="translated">테스트를 실행할 때 &lt;code&gt;--mssql-docker-image&lt;/code&gt; 라는 사용자 지정 명령 줄 옵션을 호출하여 사용할 특정 Docker 이미지를 지정할 수 있습니다 . 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="ce4b3ce57d73ee84b7d96666566ccb18a60d24d9" translate="yes" xml:space="preserve">
          <source>Why not just use the new pandas &lt;a href=&quot;https://pandas.pydata.org/pandas-docs/stable/user_guide/io.html#io-sql-method&quot;&gt;&lt;code&gt;method='multi'&lt;/code&gt;&lt;/a&gt;?</source>
          <target state="translated">왜 새로운 pandas &lt;a href=&quot;https://pandas.pydata.org/pandas-docs/stable/user_guide/io.html#io-sql-method&quot;&gt; &lt;code&gt;method='multi'&lt;/code&gt; 를 사용하지&lt;/a&gt; 않습니까?</target>
        </trans-unit>
        <trans-unit id="6b792efb0e17c873405d7c3bd52c451ffd50a79f" translate="yes" xml:space="preserve">
          <source>Writing data from pandas DataFrames to a SQL database is very slow using the built-in &lt;code&gt;to_sql&lt;/code&gt; method, even with the newly introduced &lt;a href=&quot;https://pandas.pydata.org/pandas-docs/stable/user_guide/io.html#io-sql-method&quot;&gt;&lt;code&gt;execute_many&lt;/code&gt;&lt;/a&gt; option. For Microsoft SQL Server, a far far faster method is to use the BCP utility provided by Microsoft. This utility is a command line tool that transfers data to/from the database and flat text files.</source>
          <target state="translated">pandas DataFrames에서 SQL 데이터베이스로 데이터를 쓰는 것은 새로 도입 된 &lt;a href=&quot;https://pandas.pydata.org/pandas-docs/stable/user_guide/io.html#io-sql-method&quot;&gt; &lt;code&gt;execute_many&lt;/code&gt; &lt;/a&gt; 옵션을 사용하더라도 내장 &lt;code&gt;to_sql&lt;/code&gt; 메소드를 사용하여 매우 느립니다 . Microsoft SQL Server의 경우 훨씬 빠른 방법은 Microsoft에서 제공하는 BCP 유틸리티를 사용하는 것입니다. 이 유틸리티는 데이터베이스 및 플랫 텍스트 파일간에 데이터를 전송하는 명령 줄 도구입니다.</target>
        </trans-unit>
        <trans-unit id="89c5a8e81022b57de232291b5f23612984386cbc" translate="yes" xml:space="preserve">
          <source>bcpandas</source>
          <target state="translated">기원전</target>
        </trans-unit>
        <trans-unit id="48363b6d6c5d2b3eb4bf1623a23a5ada58598b5a" translate="yes" xml:space="preserve">
          <source>bcpy</source>
          <target state="translated">bcpy</target>
        </trans-unit>
        <trans-unit id="e19cc09f0d7a61b0d1fb50cd0869a44f3809c507" translate="yes" xml:space="preserve">
          <source>built with the help of &lt;a href=&quot;https://www.tablesgenerator.com/markdown_tables#&quot;&gt;https://www.tablesgenerator.com/markdown_tables#&lt;/a&gt; and &lt;a href=&quot;https://gist.github.com/rxaviers/7360908&quot;&gt;https://gist.github.com/rxaviers/7360908&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://www.tablesgenerator.com/markdown_tables#&quot;&gt;https://www.tablesgenerator.com/markdown_tables#&lt;/a&gt; 및 &lt;a href=&quot;https://gist.github.com/rxaviers/7360908&quot;&gt;https://gist.github.com/rxaviers/7360908&lt;/a&gt; 의 도움으로 구축</target>
        </trans-unit>
        <trans-unit id="fc32cc01476fe016f2f60d0a6131db73c31b390a" translate="yes" xml:space="preserve">
          <source>docker-py (for controlling Docker)</source>
          <target state="translated">docker-py (Docker 제어용)</target>
        </trans-unit>
        <trans-unit id="ed4b436c75459c858b3198e9e021f32cfa7ec531" translate="yes" xml:space="preserve">
          <source>hypothesis</source>
          <target state="translated">가설</target>
        </trans-unit>
        <trans-unit id="0eaa389e1fdb3a1917c0f987514bd561be5718ee" translate="yes" xml:space="preserve">
          <source>pytest</source>
          <target state="translated">pytest</target>
        </trans-unit>
        <trans-unit id="f15272625459b266aacc0426b2b7f797e3be63a1" translate="yes" xml:space="preserve">
          <source>pytest-cov (coverage.py)</source>
          <target state="translated">pytest-cov (coverage.py)</target>
        </trans-unit>
        <trans-unit id="929dea4a610a279ad1a08fffdfd589f668b86b08" translate="yes" xml:space="preserve">
          <source>read_sql</source>
          <target state="translated">read_sql</target>
        </trans-unit>
        <trans-unit id="49379e60d7f0b5a617ba8fe350d92995b4818b1f" translate="yes" xml:space="preserve">
          <source>to_sql</source>
          <target state="translated">to_sql</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
