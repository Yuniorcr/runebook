<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://pypi.org/project/dm-zodb-asynchronous/">
    <body>
      <group id="dm-zodb-asynchronous">
        <trans-unit id="6edda85377c6af613a717201ee78c816906e0e87" translate="yes" xml:space="preserve">
          <source>&amp;ndash; even though,</source>
          <target state="translated">-그래도</target>
        </trans-unit>
        <trans-unit id="66a041fc1ab1d77988df149573a6bb908db19f00" translate="yes" xml:space="preserve">
          <source>(&amp;gt;= 3.8) or</source>
          <target state="translated">(&amp;gt; = 3.8) 또는</target>
        </trans-unit>
        <trans-unit id="8fc9eea31fe7bad141be356fc4f90d34086e62f7" translate="yes" xml:space="preserve">
          <source>(&amp;gt;= 5.0)).</source>
          <target state="translated">(&amp;gt; = 5.0)).</target>
        </trans-unit>
        <trans-unit id="4953dc3b4187660e6e9b0f7cbd363b931409e677" translate="yes" xml:space="preserve">
          <source>(and derived</source>
          <target state="translated">(및 파생</target>
        </trans-unit>
        <trans-unit id="3422f2444d87d217aa1ccdd69c1cf73b70c28d3c" translate="yes" xml:space="preserve">
          <source>(and other instances of</source>
          <target state="translated">(및 기타 인스턴스</target>
        </trans-unit>
        <trans-unit id="ede645a65e8a43f17a61920cd414f93f09390f44" translate="yes" xml:space="preserve">
          <source>(in our trivial exemple, there
will be no exception). Note that a failing asynchronous operation
does not mean that the current request has failed. The purpose of the
current request is to inform us about the fate of the asynchronous
operation, not to perform this operation. Therefore, a failure
of the asynchronous operation usually should result in the success
of the current request (no exception) &amp;ndash; with appropriate information
that the asynchronous operation has failed.
In our exemple, we have decorated</source>
          <target state="translated">(우리의 사소한 예에서는 예외가 없습니다). 비동기 작업이 실패한다고해서 현재 요청이 실패한 것은 아닙니다. 현재 요청의 목적은이 작업을 수행하는 것이 아니라 비동기 작업의 운명에 대해 알려주는 것입니다. 따라서 비동기 작업의 실패는 일반적으로 현재 요청 (예외 없음)의 성공을 가져와야하며 비동기 작업이 실패했다는 적절한 정보가 있어야합니다. 우리의 예에서 우리는</target>
        </trans-unit>
        <trans-unit id="cb8eb51d09b09a87c869edc0fe34094d43a9a619" translate="yes" xml:space="preserve">
          <source>(not just</source>
          <target state="translated">(뿐만 아니라</target>
        </trans-unit>
        <trans-unit id="75b477119f28a9b58d1504a428b66757b5b27763" translate="yes" xml:space="preserve">
          <source>(usually
done via an utility). Somehow, the followup request has learned
of the schedule id (from the user session or via a request parameter).
With this information, it can check the fate of the asynchronous
operation, process the result and commit.</source>
          <target state="translated">(일반적으로 유틸리티를 통해 수행됨). 어쨌든 후속 요청은 (사용자 세션 또는 요청 매개 변수를 통해) 일정 ID를 알게되었습니다. 이 정보를 통해 비동기 작업의 운명을 확인하고 결과를 처리하고 커밋 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bd4e1f49b5bf81c8d1c5862c7656f16aa653ebc9" translate="yes" xml:space="preserve">
          <source>)
and a simple function (</source>
          <target state="translated">) 및 간단한 기능 (</target>
        </trans-unit>
        <trans-unit id="382c73b1f08357983b804e99b19cc37d2ba95420" translate="yes" xml:space="preserve">
          <source>)
and abort hooks (provided by</source>
          <target state="translated">) 및 중단 후크 (제공</target>
        </trans-unit>
        <trans-unit id="b4878465cc2e3eeddd831bd41e348af2e98290c2" translate="yes" xml:space="preserve">
          <source>)
have effect only at the top level, as the ZODB does not support fully
nested transactions (it can, however, partially emulated
nested transactions by so called &amp;ldquo;savepoint&amp;rdquo;s).
Nested calls (inside the same transaction) simply
call the decorated function/method. The decorators recognize only
their own transaction management: if the transaction is managed on higher
level, this is not recognized and control is taken over.</source>
          <target state="translated">) ZODB는 완전히 중첩 된 트랜잭션을 지원하지 않기 때문에 최상위 수준에서만 효과가 있습니다 (그러나 소위 &quot;savepoint&quot;에 의해 부분적으로 중첩 된 트랜잭션을 에뮬레이트 할 수 있음). 중첩 된 호출 (동일한 트랜잭션 내)은 단순히 데코 레이팅 된 함수 / 메서드를 호출합니다. 데코레이터는 자신의 트랜잭션 관리 만 인식합니다. 트랜잭션이 더 높은 수준에서 관리되는 경우 이는 인식되지 않고 제어가 인계됩니다.</target>
        </trans-unit>
        <trans-unit id="5c2be6ee913f761d8e9e66ad064ee0d3a6f7a290" translate="yes" xml:space="preserve">
          <source>)
with prints something and returns something so that we can monitor
when it is called.</source>
          <target state="translated">) with는 무언가를 인쇄하고 무언가를 반환하므로 호출 될 때 모니터링 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c8878b8439034bb25725c66abcc4ed0111091139" translate="yes" xml:space="preserve">
          <source>) declare a function or method to
be transactional: before the function is called, a new transaction
is begun (a potentially pending transaction aborted), metadata is registered
for the transaction
and when the function returns the transaction is either committed (no exception)
or aborted (exception). If the exception was a</source>
          <target state="translated">) 함수 또는 메서드를 트랜잭션으로 선언 : 함수가 호출되기 전에 새 트랜잭션이 시작되고 (잠재적으로 보류중인 트랜잭션이 중단됨) 메타 데이터가 트랜잭션에 등록되고 함수가 반환 할 때 트랜잭션이 커밋되거나 (예외 없음) 중단됨 (예외). 예외가</target>
        </trans-unit>
        <trans-unit id="e34247b30304a5d24002edc5b66555fe2b5a6f5e" translate="yes" xml:space="preserve">
          <source>) is used and what it does.</source>
          <target state="translated">)이 사용되며 그 역할을합니다.</target>
        </trans-unit>
        <trans-unit id="17d5325d4c798c7fdb145723fd7149ac3eb23962" translate="yes" xml:space="preserve">
          <source>).
With them, we define the auxiliary function</source>
          <target state="translated">). 그들과 함께 우리는 보조 기능을 정의합니다</target>
        </trans-unit>
        <trans-unit id="5c10b5b2cd673a0616d529aa5234b12ee7153808" translate="yes" xml:space="preserve">
          <source>,</source>
          <target state="translated">,</target>
        </trans-unit>
        <trans-unit id="2e3cbcc474d5bfa91c5ebf032b7346538c04fc7b" translate="yes" xml:space="preserve">
          <source>, a function which raises an exception.</source>
          <target state="translated">, 예외를 발생시키는 함수.</target>
        </trans-unit>
        <trans-unit id="d0847450729e07b30fd36c6ac1cfab939f41d9ba" translate="yes" xml:space="preserve">
          <source>, a particular
instance of the class</source>
          <target state="translated">, 클래스의 특정 인스턴스</target>
        </trans-unit>
        <trans-unit id="79af8cac2b1f0da72b096678ea73803837e562bd" translate="yes" xml:space="preserve">
          <source>, for demonstrational
purposes. In real life, the scheduler would probably be global,
e.g. provided by a so called &amp;ldquo;utility&amp;rdquo;.</source>
          <target state="translated">, 데모 용입니다. 실생활에서 스케줄러는 아마도 &quot;유틸리티&quot;라고 불리는 글로벌 한 것입니다.</target>
        </trans-unit>
        <trans-unit id="a641771ada1088e95b13f2f702b12e642123bd02" translate="yes" xml:space="preserve">
          <source>, subscription is used to access the
persistent objects; an integer index accesses positional arguments, an</source>
          <target state="translated">, 구독은 영구 개체에 액세스하는 데 사용됩니다. 정수 인덱스는 위치 인수에 액세스합니다.</target>
        </trans-unit>
        <trans-unit id="1f06f1dee3ec6e8ed1118c136af0718d8aebcdd7" translate="yes" xml:space="preserve">
          <source>, the
call is retried up to a configurable number of times after configurable delays.</source>
          <target state="translated">, 구성 가능한 지연 후 구성 가능한 횟수까지 호출이 재 시도됩니다.</target>
        </trans-unit>
        <trans-unit id="4c6d1ad82f8b09adbdf058579359ebc4dd6d882c" translate="yes" xml:space="preserve">
          <source>, the call is automatically retried
(in a new transaction). Retrial may be repeated (how often is
controlled by a</source>
          <target state="translated">, 호출이 자동으로 재 시도됩니다 (새 트랜잭션에서). 재심은 반복 될 수 있습니다 (얼마나 자주</target>
        </trans-unit>
        <trans-unit id="7ea7a2abc4b1e12ad746a935c15342e99166ab02" translate="yes" xml:space="preserve">
          <source>, the package can be used in
(e.g.) a Zope 2 environment when some operation takes too much time
to be performed inline (in the same request). In this case,
one can execute it in a separate thread and look for its results
in a following (new) request. We present now a simple example.</source>
          <target state="translated">, 패키지는 (예) Zope 2 환경에서 인라인으로 수행하는 데 너무 많은 시간이 걸리는 경우 (동일한 요청에서) 사용할 수 있습니다. 이 경우 별도의 스레드에서 실행하고 다음 (새) 요청에서 결과를 찾을 수 있습니다. 이제 간단한 예를 제시합니다.</target>
        </trans-unit>
        <trans-unit id="8baa5de13999060bf01cc7249c8f62c5b489d33e" translate="yes" xml:space="preserve">
          <source>, the schedule is unknown
(probably lost);</source>
          <target state="translated">, 일정을 알 수 없습니다 (아마 손실되었을 수 있음).</target>
        </trans-unit>
        <trans-unit id="3a52ce780950d4d969792a2559cd519d7ee8c727" translate="yes" xml:space="preserve">
          <source>.</source>
          <target state="translated">.</target>
        </trans-unit>
        <trans-unit id="7fc2333138b085b91830aef95d742acd31aced70" translate="yes" xml:space="preserve">
          <source>.
If set it specifies a function to call (without arguments)
before the transaction is aborted in an exception case.
The typical use is to enter a debugger in order to analyse modifications
to persistent objects before those modifications are undone
by the abort.</source>
          <target state="translated">. 설정된 경우 예외 상황에서 트랜잭션이 중단되기 전에 호출 할 함수 (인수없이)를 지정합니다. 일반적인 사용은 중단에 의해 수정이 취소되기 전에 영구 개체에 대한 수정을 분석하기 위해 디버거를 입력하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="9cb2e0ead42209df5756e8f04ccd3500eed1a31a" translate="yes" xml:space="preserve">
          <source>.
Inside</source>
          <target state="translated">. 내부</target>
        </trans-unit>
        <trans-unit id="5fc8e66423e192adb2159209593cecf771df3393" translate="yes" xml:space="preserve">
          <source>. In the former
case, the schedule will be removed and</source>
          <target state="translated">. 전자의 경우 일정이 삭제되고</target>
        </trans-unit>
        <trans-unit id="b9749ecbc769f18871cfa3c4002513b348b38462" translate="yes" xml:space="preserve">
          <source>. It can be used
to pass persistent objects from one (thread) context to another one.
As described in the</source>
          <target state="translated">. 하나의 (스레드) 컨텍스트에서 다른 컨텍스트로 영구 개체를 전달하는 데 사용할 수 있습니다. 에 설명 된대로</target>
        </trans-unit>
        <trans-unit id="e7d5a9c87ec2d1a64911136b7756a699672664c3" translate="yes" xml:space="preserve">
          <source>. This way, it handles transaction management correctly
in case of errors (the transaction gets aborted when the
asynchronous operation should fail).</source>
          <target state="translated">. 이러한 방식으로 오류가 발생한 경우 트랜잭션 관리를 올바르게 처리합니다 (비동기 작업이 실패해야 할 때 트랜잭션이 중단됨).</target>
        </trans-unit>
        <trans-unit id="17fb28f162e5c9f9f75226defb303126294a70bd" translate="yes" xml:space="preserve">
          <source>. We set up logging, a scheduler (</source>
          <target state="translated">. 로깅, 스케줄러 (</target>
        </trans-unit>
        <trans-unit id="61ae379167c5b6a3d5171464980da55005ccc726" translate="yes" xml:space="preserve">
          <source>1.x</source>
          <target state="translated">1.x</target>
        </trans-unit>
        <trans-unit id="7441a76e19392ddf06b8e9891a8a6b9063ec95f6" translate="yes" xml:space="preserve">
          <source>A transaction abort deletes the schedule.</source>
          <target state="translated">트랜잭션 중단은 일정을 삭제합니다.</target>
        </trans-unit>
        <trans-unit id="221c558696339f78bcb7b8f3b29a4aa3e761414c" translate="yes" xml:space="preserve">
          <source>After a new schedule, the schedule is known but not yet complete.</source>
          <target state="translated">새 일정 이후 일정이 알려졌지만 아직 완료되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="85577a9d21900efa00e28ad153e052634ab7dd94" translate="yes" xml:space="preserve">
          <source>After the completion,</source>
          <target state="translated">완료 후</target>
        </trans-unit>
        <trans-unit id="eff7e4977c4081189e52d057a0f4d209071aaac7" translate="yes" xml:space="preserve">
          <source>Again,</source>
          <target state="translated">다시,</target>
        </trans-unit>
        <trans-unit id="d6b0f7a12ad3c32d4e532e7bf66eb8c4727a3f34" translate="yes" xml:space="preserve">
          <source>An example is shown in the section &amp;ldquo;Typical Usage Example&amp;rdquo;.</source>
          <target state="translated">예는 &quot;일반적인 사용 예&quot;섹션에 나와 있습니다.</target>
        </trans-unit>
        <trans-unit id="414c148e24273e407fb086cba2d795906efda721" translate="yes" xml:space="preserve">
          <source>As an alternative, this module defines the class</source>
          <target state="translated">대안으로이 모듈은 클래스를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="80b89acd76a94e9897a2f504f73b668bc9448981" translate="yes" xml:space="preserve">
          <source>As mentioned in section</source>
          <target state="translated">섹션에서 언급했듯이</target>
        </trans-unit>
        <trans-unit id="557a6908a96df3fdc6f41cfa27455165469296ef" translate="yes" xml:space="preserve">
          <source>At the end of the initial request, there will be either
a</source>
          <target state="translated">초기 요청이 끝날 때</target>
        </trans-unit>
        <trans-unit id="23919cd584f3327e6016f69d1e8fc2edb810b552" translate="yes" xml:space="preserve">
          <source>ConflictError</source>
          <target state="translated">ConflictError</target>
        </trans-unit>
        <trans-unit id="da9229bda89a128e984d87cb0ba92ecc65cac36d" translate="yes" xml:space="preserve">
          <source>Debugging support:</source>
          <target state="translated">디버깅 지원 :</target>
        </trans-unit>
        <trans-unit id="0562f32dc56f5c702810cbe010068ddd38dbd69a" translate="yes" xml:space="preserve">
          <source>Dependencies</source>
          <target state="translated">의존성</target>
        </trans-unit>
        <trans-unit id="04a8a4fd06a006bfd4d62555ac6944122f7f01af" translate="yes" xml:space="preserve">
          <source>Detailed information can be found in the source via docstrings.</source>
          <target state="translated">자세한 정보는 독 스트링을 통해 소스에서 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="597f8b4431a4aac7d398f75c8e4dcaec0801cbb2" translate="yes" xml:space="preserve">
          <source>Easy dependencies are declared, complex ones not.</source>
          <target state="translated">쉬운 종속성은 선언되고 복잡한 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="0f01ed56a1e32a05e5ef96e4d779f34784af9a96" translate="yes" xml:space="preserve">
          <source>Example</source>
          <target state="translated">예</target>
        </trans-unit>
        <trans-unit id="97cdbdc7feff827efb082a6b6dd2727237cd49fd" translate="yes" xml:space="preserve">
          <source>False</source>
          <target state="translated">그릇된</target>
        </trans-unit>
        <trans-unit id="dbd8de6e7601890ae6f7b889ad7439901792764a" translate="yes" xml:space="preserve">
          <source>For demonstrational purposes, we define
a class for with the first call raises</source>
          <target state="translated">데모 목적으로 첫 번째 호출이 발생하는 클래스를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="f5aec1058d3968a6b39fda844927cfaceefb47d2" translate="yes" xml:space="preserve">
          <source>For the sake of Python 2/Python 3 compatibility, we activate
the future</source>
          <target state="translated">Python 2 / Python 3 호환성을 위해 미래를 활성화합니다.</target>
        </trans-unit>
        <trans-unit id="90ccd6497400b5576aeca1bd94af74aae1e0a250" translate="yes" xml:space="preserve">
          <source>History</source>
          <target state="translated">역사</target>
        </trans-unit>
        <trans-unit id="1f78a72da4564683245a3f6ef183d0f6a69c227c" translate="yes" xml:space="preserve">
          <source>If the transaction is commited, the scheduled operation is
called.</source>
          <target state="translated">트랜잭션이 커밋되면 예약 된 작업이 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="c3849bbe060f4c2856b3be0b6141ddbd2f261cee" translate="yes" xml:space="preserve">
          <source>In case of a</source>
          <target state="translated">의 경우</target>
        </trans-unit>
        <trans-unit id="a2b5cc8531829f54bc644c29226e4b3b78fe8014" translate="yes" xml:space="preserve">
          <source>In this section, we set up a simple example that demonstrates
how</source>
          <target state="translated">이 섹션에서는 방법을 보여주는 간단한 예를 설정합니다.</target>
        </trans-unit>
        <trans-unit id="072d85367c5b2f6eb7301862eb6808e038d1a010" translate="yes" xml:space="preserve">
          <source>Its main content is the decorator</source>
          <target state="translated">주요 내용은 데코레이터입니다.</target>
        </trans-unit>
        <trans-unit id="37214505c4ac4e17eb8146e5d00f0c8284d16ae2" translate="yes" xml:space="preserve">
          <source>Made Python3/ZODB4+/Zope4+ compatible.</source>
          <target state="translated">Python3 / ZODB4 + / Zope4 +와 호환됩니다.</target>
        </trans-unit>
        <trans-unit id="04e9462c0ff02bb9032b92abd45881a3c7e15fb7" translate="yes" xml:space="preserve">
          <source>Modules</source>
          <target state="translated">모듈</target>
        </trans-unit>
        <trans-unit id="6403f2b7eb2aaafe6de34cbf2a029b01afebc512" translate="yes" xml:space="preserve">
          <source>New</source>
          <target state="translated">새로운</target>
        </trans-unit>
        <trans-unit id="6eef6648406c333a4035cd5e60d0bf2ecf2606d7" translate="yes" xml:space="preserve">
          <source>None</source>
          <target state="translated">없음</target>
        </trans-unit>
        <trans-unit id="83423c198b6099edba08f185f940042d5dba3b79" translate="yes" xml:space="preserve">
          <source>Note:</source>
          <target state="translated">노트 :</target>
        </trans-unit>
        <trans-unit id="46fd9261586f89a9f669a46fe8d1d5513eaa5902" translate="yes" xml:space="preserve">
          <source>Note: The output above comes from the logging; the</source>
          <target state="translated">참고 : 위의 출력은 로깅에서 나옵니다. 그만큼</target>
        </trans-unit>
        <trans-unit id="71cf42f91e52109143fbf953707a3adc686b86c5" translate="yes" xml:space="preserve">
          <source>PersistantContext</source>
          <target state="translated">PersistantContext</target>
        </trans-unit>
        <trans-unit id="4f0bd294bcdafcbdaf221fe45cae49021abd60ac" translate="yes" xml:space="preserve">
          <source>PersistentContext</source>
          <target state="translated">PersistentContext</target>
        </trans-unit>
        <trans-unit id="430164f7a0d13a705535167c1f31666add919ef8" translate="yes" xml:space="preserve">
          <source>PersistentTransactionalScheduler</source>
          <target state="translated">PersistentTransactionalScheduler</target>
        </trans-unit>
        <trans-unit id="99665ec9a7706711e2aad33b849d3b5b9f197010" translate="yes" xml:space="preserve">
          <source>See the module docstrings for details, especially
about the restrictions and risks.</source>
          <target state="translated">특히 제한 및 위험에 대한 자세한 내용은 모듈 독 스트링을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="49de18eacbb98ae12b94214d6cb9440e397cba0f" translate="yes" xml:space="preserve">
          <source>Should a transactional method raise an exception, the transaction
is aborted and the exception is propagated:</source>
          <target state="translated">트랜잭션 메서드에서 예외가 발생하면 트랜잭션이 중단되고 예외가 전파됩니다.</target>
        </trans-unit>
        <trans-unit id="01df7da68f738eeca06c3cabaed7946358a20764" translate="yes" xml:space="preserve">
          <source>Targeting Python2/ZODB3/Zope2.10+</source>
          <target state="translated">Python2 / ZODB3 / Zope2.10 + 타겟팅</target>
        </trans-unit>
        <trans-unit id="e80e59c33d91a6795b134826493dc6cc8e7a241c" translate="yes" xml:space="preserve">
          <source>The ZODB is a mostly easy to use object oriented database &amp;ndash; especially,
when used within a framework which provides transaction management (such
as Zope). Nice features are the almost transparent persistency (modified
objects are automatically stored when the transaction is committed)
and the absence of locking requirements (due to an optimistic
concurrency control). However, the ZODB becomes a bit difficult when
operations need to be performed asynchronously, i.e. in a separate thread.</source>
          <target state="translated">ZODB는 특히 트랜잭션 관리 (예 : Zope)를 제공하는 프레임 워크 내에서 사용되는 경우 사용하기 가장 쉬운 객체 지향 데이터베이스입니다. 좋은 기능은 거의 투명한 지속성 (트랜잭션이 커밋 될 때 수정 된 개체가 자동으로 저장 됨)과 잠금 요구 사항 (낙관적 동시성 제어로 인해)이 없다는 것입니다. 그러나 ZODB는 작업이 비동기 적으로, 즉 별도의 스레드에서 수행되어야하는 경우 약간 어려워집니다.</target>
        </trans-unit>
        <trans-unit id="b5f92bcaf25651de073acdb7405a0e1ec73ef716" translate="yes" xml:space="preserve">
          <source>The code snippet above has an extended comment about exception
handling from</source>
          <target state="translated">위의 코드 조각에는 예외 처리에 대한 확장 주석이 있습니다.</target>
        </trans-unit>
        <trans-unit id="5efb3525b7bee0a874ab16e0d4bcb5474ebe7f6d" translate="yes" xml:space="preserve">
          <source>The function becomes nontrivial when the operation must access the ZODB.
The ZODB forbids a thread to access persistent objects loaded in
a separate thread. Therefore, persistent objects accessed asynchronously
must be reloaded from the ZODB via a new thread specific connection.
Without special measures, the asynchronous operation may not see modifications
to persistent objects performed by the context which has scheduled
the asynchonous operation (as they become available only after the
transaction has committed).</source>
          <target state="translated">작업이 ZODB에 액세스해야 할 때 기능은 중요하지 않습니다. ZODB는 스레드가 별도의 스레드에로드 된 영구 객체에 액세스하는 것을 금지합니다. 따라서 비동기 적으로 액세스 된 영구 객체는 새 스레드 특정 연결을 통해 ZODB에서 다시로드되어야합니다. 특별한 조치가 없으면 비동기 작업이 비동기 작업을 예약 한 컨텍스트에 의해 수행 된 영구 개체에 대한 수정을 보지 못할 수 있습니다 (트랜잭션이 커밋 된 후에 만 ​​사용 가능하게 됨).</target>
        </trans-unit>
        <trans-unit id="0352bb5a3b8f31b184acb2198b2f0a8dadca45f8" translate="yes" xml:space="preserve">
          <source>The initial schedule returns an identifier which can later be used
to check for and access results.</source>
          <target state="translated">초기 일정은 나중에 결과를 확인하고 액세스하는 데 사용할 수있는 식별자를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="3a53357f11465725d38d814ff941d393401ed024" translate="yes" xml:space="preserve">
          <source>The module</source>
          <target state="translated">모듈</target>
        </trans-unit>
        <trans-unit id="5477d67cc864bac7bbea32f72a35de24ac29d35b" translate="yes" xml:space="preserve">
          <source>The output tells us, that transaction commit hooks have been
called. This means that some transaction has been commited.
In addition, the</source>
          <target state="translated">출력은 트랜잭션 커밋 후크가 호출되었음을 알려줍니다. 이것은 일부 트랜잭션이 커밋되었음을 의미합니다. 또한</target>
        </trans-unit>
        <trans-unit id="f98d5cc6bc1f8f4e070f8fe4d8ff56a9e799bf98" translate="yes" xml:space="preserve">
          <source>The package consists of modules</source>
          <target state="translated">패키지는 모듈로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="315e52939ecda0a0f71590f221aa9675af84dc1c" translate="yes" xml:space="preserve">
          <source>The package depends on</source>
          <target state="translated">패키지는</target>
        </trans-unit>
        <trans-unit id="8887d8304eb6d6298fece2df22ff593ef65b1f6c" translate="yes" xml:space="preserve">
          <source>The scheduling returns an id which (in real life) would somehow be
stored (e.g. in the user session or (better) be incorporated inside
the generated response and be used as parameter of a followup request).
The assignment to</source>
          <target state="translated">스케줄링은 (실제에서) 어떻게 든 저장 될 ID를 반환합니다 (예 : 사용자 세션에 저장되거나 생성 된 응답에 통합되어 후속 요청의 매개 변수로 사용됨). 할당</target>
        </trans-unit>
        <trans-unit id="e5205b01eba5eeedf4f34723b3c2fbd1f18355b1" translate="yes" xml:space="preserve">
          <source>The scheduling returns an id which can be used to learn about
the operation&amp;rsquo;s fate via a</source>
          <target state="translated">스케줄링은 a를 통해 작업의 운명에 대해 배우는 데 사용할 수있는 ID를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="7a8bdaef1e2f6ee7d6428ae5f5a7d6518f86d1aa" translate="yes" xml:space="preserve">
          <source>This example demonstrates the working of the</source>
          <target state="translated">이 예는</target>
        </trans-unit>
        <trans-unit id="0e70fce31159296a0414f111cd179f8b4e65277a" translate="yes" xml:space="preserve">
          <source>This module contains adaptations of facilities defined in the other
modules to a Zope2 environment. For example, there is
an adapted</source>
          <target state="translated">이 모듈에는 Zope2 환경에 대한 다른 모듈에 정의 된 시설의 적응이 포함됩니다. 예를 들어, 적응 된</target>
        </trans-unit>
        <trans-unit id="20dd10a38c8487a3739f45f2b56549d928559a6a" translate="yes" xml:space="preserve">
          <source>This module defines the class</source>
          <target state="translated">이 모듈은 클래스를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="19204290f724f905745883429f3f28eb0709edd0" translate="yes" xml:space="preserve">
          <source>This package contains some utilities to make it easier to implement
asynchronous access to the ZODB. Some of those can be helpful, too,
in a synchronous environment.</source>
          <target state="translated">이 패키지에는 ZODB에 대한 비동기 액세스를 쉽게 구현할 수있는 몇 가지 유틸리티가 포함되어 있습니다. 이들 중 일부는 동기식 환경에서도 도움이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a32c9d8489ffeb5a3b2d645d564916dfaf4a2858" translate="yes" xml:space="preserve">
          <source>TransactionManager</source>
          <target state="translated">TransactionManager</target>
        </trans-unit>
        <trans-unit id="a82fd12e6ab5efb755ed78def7574d392ea6c72f" translate="yes" xml:space="preserve">
          <source>TransactionManager.begin</source>
          <target state="translated">TransactionManager.begin</target>
        </trans-unit>
        <trans-unit id="3e9c24eb488f1eb9a47c3c35e108d9f8540b8cb4" translate="yes" xml:space="preserve">
          <source>TransactionScheduler</source>
          <target state="translated">TransactionScheduler</target>
        </trans-unit>
        <trans-unit id="ea75caa0001c4bc194e170a251cd23e00862d143" translate="yes" xml:space="preserve">
          <source>TransactionalScheduler</source>
          <target state="translated">TransactionalScheduler</target>
        </trans-unit>
        <trans-unit id="afc6b3aeebf29c32dae936b4a9c3d1465380a2de" translate="yes" xml:space="preserve">
          <source>Typical Usage Example</source>
          <target state="translated">일반적인 사용 예</target>
        </trans-unit>
        <trans-unit id="036f6d3fdbbee78abb7d0eba165802fe53ff18e5" translate="yes" xml:space="preserve">
          <source>Utilities to implement asynchronous operations accessing the ZODB</source>
          <target state="translated">ZODB에 액세스하는 비동기 작업을 구현하는 유틸리티</target>
        </trans-unit>
        <trans-unit id="caa6f04a601751406bb09171a2944e2d3a79104b" translate="yes" xml:space="preserve">
          <source>We define a simple</source>
          <target state="translated">우리는 간단한</target>
        </trans-unit>
        <trans-unit id="b437cf513a449ae0566992f4b0f88cb6391ca434" translate="yes" xml:space="preserve">
          <source>We look now at the followup request. Things must somehow have
been set up that it can access the same</source>
          <target state="translated">이제 후속 요청을 살펴 봅니다. 어떻게 든 동일한 항목에 액세스 할 수 있도록 설정되어 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="9cdaf92fcbcb1e32e3e9a81bea55bdbbcc84a1ad" translate="yes" xml:space="preserve">
          <source>We now define two simple transactional functions</source>
          <target state="translated">이제 두 개의 간단한 트랜잭션 함수를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="3484e11270f9153a73cba62d1b5eacc6f0901346" translate="yes" xml:space="preserve">
          <source>We now schedule</source>
          <target state="translated">우리는 이제 일정을</target>
        </trans-unit>
        <trans-unit id="d501fa177ce17097d3df6bf33aba70db202092ba" translate="yes" xml:space="preserve">
          <source>We simulate now a request which schedules</source>
          <target state="translated">이제 일정을 예약하는 요청을 시뮬레이션합니다.</target>
        </trans-unit>
        <trans-unit id="42089d72ea462368b0787fb29704effd57ebf72c" translate="yes" xml:space="preserve">
          <source>When the result of an asynchronous operation is fetched, its deletion
is automatically scheduled at transaction commit. A deletion timeout
controls deletion of results which got &amp;ldquo;forgotten&amp;rdquo;.</source>
          <target state="translated">비동기 작업의 결과를 가져 오면 트랜잭션 커밋시 삭제가 자동으로 예약됩니다. 삭제 시간 초과는 &quot;잊혀진&quot;결과의 삭제를 제어합니다.</target>
        </trans-unit>
        <trans-unit id="48cf13177db6e55882c7bf7964bfab0f3c57aad9" translate="yes" xml:space="preserve">
          <source>ZODB</source>
          <target state="translated">ZODB</target>
        </trans-unit>
        <trans-unit id="6c2ada2b88bb107629fc962d24fa1eed82c9f5c8" translate="yes" xml:space="preserve">
          <source>ZODB3</source>
          <target state="translated">ZODB3</target>
        </trans-unit>
        <trans-unit id="be6a181712a417a864e0039d82caa4c01da7a5c8" translate="yes" xml:space="preserve">
          <source>a transactional function can now internally
abort/commit the transaction.
Note however, that this disables the detection of calls
to nested transactional functions.
Use the class method</source>
          <target state="translated">트랜잭션 함수는 이제 내부적으로 트랜잭션을 중단 / 커밋 할 수 있습니다. 그러나 이렇게하면 중첩 된 트랜잭션 함수에 대한 호출 감지가 비활성화됩니다. 클래스 방법 사용</target>
        </trans-unit>
        <trans-unit id="7bc2938e2f4df397e134f04b605d80d63241424e" translate="yes" xml:space="preserve">
          <source>abort/commit</source>
          <target state="translated">중단 / 커밋</target>
        </trans-unit>
        <trans-unit id="1064674887312d5dc98f740152fd7afb4c220952" translate="yes" xml:space="preserve">
          <source>after the</source>
          <target state="translated">후</target>
        </trans-unit>
        <trans-unit id="39b15dde419bab28a422039d527e2dc9124ba793" translate="yes" xml:space="preserve">
          <source>after-commit</source>
          <target state="translated">커밋 후</target>
        </trans-unit>
        <trans-unit id="cffa50a32cb13a240d705317bcec65dd1f31b6ad" translate="yes" xml:space="preserve">
          <source>and</source>
          <target state="translated">과</target>
        </trans-unit>
        <trans-unit id="93d661160e08fcc7dd15c6bbb3b9198a7f7c753e" translate="yes" xml:space="preserve">
          <source>and (</source>
          <target state="translated">및 (</target>
        </trans-unit>
        <trans-unit id="471e86afe447e524b76cb3eb8c6d2e5c4f4ded63" translate="yes" xml:space="preserve">
          <source>and allows it to access the</source>
          <target state="translated">액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7360e98844fa91459ed512a23cd22f019af31d44" translate="yes" xml:space="preserve">
          <source>and the second
call succeeds. Therefore, the first retrial succeeds and the example
will not show further retrials.</source>
          <target state="translated">두 번째 호출이 성공합니다. 따라서 첫 번째 재 시도가 성공하고 예제는 더 이상 재 시도를 표시하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="610e2bb45077bf6d24db04adfde5265d04b48aa3" translate="yes" xml:space="preserve">
          <source>and then call</source>
          <target state="translated">그리고 전화</target>
        </trans-unit>
        <trans-unit id="7d1043473d55bfa90e8530d35801d4e381bc69f0" translate="yes" xml:space="preserve">
          <source>app</source>
          <target state="translated">앱</target>
        </trans-unit>
        <trans-unit id="1a549473169661670d89885483fb3a94e7527e70" translate="yes" xml:space="preserve">
          <source>app.x</source>
          <target state="translated">app.x</target>
        </trans-unit>
        <trans-unit id="53f30fd26ace6c299573d1ef29e92dbe573389b2" translate="yes" xml:space="preserve">
          <source>asynchronous_operation</source>
          <target state="translated">비동기 작업</target>
        </trans-unit>
        <trans-unit id="0b68623156bf8816e62e2d7b79a220a1325aca68" translate="yes" xml:space="preserve">
          <source>asynchronous_request</source>
          <target state="translated">비동기 요청</target>
        </trans-unit>
        <trans-unit id="311355180359ffe0e3342d32c66b88fe1082f7dd" translate="yes" xml:space="preserve">
          <source>attribute) with increasing
randomly chosen delays between retries (also controlled
by</source>
          <target state="translated">속성) 재시도 사이에 무작위로 선택된 지연이 증가합니다 (또한</target>
        </trans-unit>
        <trans-unit id="9a217dd2f69c2cd09f0f21f68ef6ba069b05e847" translate="yes" xml:space="preserve">
          <source>attributes).</source>
          <target state="translated">속성).</target>
        </trans-unit>
        <trans-unit id="c69774177a10d0bf792b3df02f0931f9ea2ab345" translate="yes" xml:space="preserve">
          <source>both positional as well as via the keyword</source>
          <target state="translated">위치 및 키워드를 통해</target>
        </trans-unit>
        <trans-unit id="2b2df26e9fd00579f59f6e9992e87d74f98a63f1" translate="yes" xml:space="preserve">
          <source>call but at the end of the</source>
          <target state="translated">전화하지만 끝에</target>
        </trans-unit>
        <trans-unit id="5f48572281a9bf9d0fb8323f8c38f8ad80f1f8e1" translate="yes" xml:space="preserve">
          <source>call has not introduced its own transaction
level but participates on that of</source>
          <target state="translated">호출은 자체 트랜잭션 수준을 도입하지 않았지만</target>
        </trans-unit>
        <trans-unit id="57d1f60c47e1854ea5d73d8b98f96e6e8e2e5f74" translate="yes" xml:space="preserve">
          <source>call.
If</source>
          <target state="translated">요구. 만약</target>
        </trans-unit>
        <trans-unit id="71fd90ef7c36aec19381855ee70e8d8325a88e22" translate="yes" xml:space="preserve">
          <source>call.
This means that the</source>
          <target state="translated">요구. 이것은</target>
        </trans-unit>
        <trans-unit id="eed986797fe67a1e83c1e024acde670770b95ccf" translate="yes" xml:space="preserve">
          <source>calling</source>
          <target state="translated">부름</target>
        </trans-unit>
        <trans-unit id="00a5090f52430ad3971238532225fad09cc74890" translate="yes" xml:space="preserve">
          <source>calls must arrive at the same web application process as the former
request which called the</source>
          <target state="translated">호출은 호출 한 이전 요청과 동일한 웹 애플리케이션 프로세스에 도착해야합니다.</target>
        </trans-unit>
        <trans-unit id="a36ee3a3949478bbf043a97eaa52c793caf60e6b" translate="yes" xml:space="preserve">
          <source>changes:</source>
          <target state="translated">변경 사항 :</target>
        </trans-unit>
        <trans-unit id="4015b57a143aec5156fd1444a017a32137a3fd0f" translate="yes" xml:space="preserve">
          <source>commit</source>
          <target state="translated">범하다</target>
        </trans-unit>
        <trans-unit id="7a44b99edc8a3ce5f20207d4c222a2714db425cf" translate="yes" xml:space="preserve">
          <source>contains decorators which provide transaction management
in environments where this is not provided by the framework.
They can be useful even in a synchronous environment (e.g. a script
environment). The transaction management comprises automatic retry
after concurrency problems (which the ZODB indicates by a so
called</source>
          <target state="translated">프레임 워크에서 제공하지 않는 환경에서 트랜잭션 관리를 제공하는 데코레이터를 포함합니다. 동기식 환경 (예 : 스크립트 환경)에서도 유용 할 수 있습니다. 트랜잭션 관리는 동시성 문제 후 자동 재 시도를 포함합니다 (ZODB는 소위</target>
        </trans-unit>
        <trans-unit id="ec2727b3b71f07635f726026bef44352ec89e452" translate="yes" xml:space="preserve">
          <source>context</source>
          <target state="translated">문맥</target>
        </trans-unit>
        <trans-unit id="32faaecac742100f7753f0c1d0aa0add01b4046b" translate="yes" xml:space="preserve">
          <source>debug</source>
          <target state="translated">디버그</target>
        </trans-unit>
        <trans-unit id="ee329fb660d413c67e1d067f80ee172e6e8b17ed" translate="yes" xml:space="preserve">
          <source>decorator</source>
          <target state="translated">장식 자</target>
        </trans-unit>
        <trans-unit id="aafd6d49238e1793a9d655c19db3a183ff3bfb10" translate="yes" xml:space="preserve">
          <source>decorator) which provides transaction metadata in the way typical
for the Zope 2 framework. There are also</source>
          <target state="translated">decorator)는 Zope 2 프레임 워크에 일반적인 방식으로 트랜잭션 메타 데이터를 제공합니다. 또한 있습니다</target>
        </trans-unit>
        <trans-unit id="dba180f69b68430f8a102a10de7dc482cb867fbb" translate="yes" xml:space="preserve">
          <source>def exc(): raise Exception()
&amp;hellip;
&amp;gt;&amp;gt;&amp;gt; sid = s.schedule(exc)
&amp;gt;&amp;gt;&amp;gt; commit()
&amp;gt;&amp;gt;&amp;gt; ERROR:dm.zodb.asynchronous.scheduler:exception in call of &amp;lt;function exc at 0xb687fb54&amp;gt;
Traceback (most recent call last):
&amp;hellip;
Exception</source>
          <target state="translated">def exc () : raise Exception ()&amp;hellip; &amp;gt;&amp;gt;&amp;gt; sid = s.schedule (exc) &amp;gt;&amp;gt;&amp;gt; commit () &amp;gt;&amp;gt;&amp;gt; ERROR : dm.zodb.asynchronous.scheduler : &amp;lt;function exc at 0xb687fb54&amp;gt; 호출시 예외 역 추적 (가장 최근 호출 마지막) :&amp;hellip; 예외</target>
        </trans-unit>
        <trans-unit id="008f09ae730745a7541692dc06b6df76aaedc751" translate="yes" xml:space="preserve">
          <source>depends on Zope 2 (&amp;gt;= 2.10) or Zope (&amp;gt;= 4.0b7).</source>
          <target state="translated">Zope 2 (&amp;gt; = 2.10) 또는 Zope (&amp;gt; = 4.0b7)에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="ee755a26be89bb47992841ce2e842985a39bced7" translate="yes" xml:space="preserve">
          <source>directly, we see that
in this case, it gets its own transaction control.</source>
          <target state="translated">직접적으로이 경우 자체 트랜잭션 제어 권한을 얻습니다.</target>
        </trans-unit>
        <trans-unit id="82b2055c35f1990482328c3bff777aec106e07a0" translate="yes" xml:space="preserve">
          <source>dm.transaction.aborthook</source>
          <target state="translated">dm.transaction.aborthook</target>
        </trans-unit>
        <trans-unit id="e3d95f544b13de8a7a0d213a4bd51261e095de98" translate="yes" xml:space="preserve">
          <source>does
not output anything by itself.</source>
          <target state="translated">자체적으로 아무것도 출력하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="168052cb2998d4d860ce1349a124ae7289115c28" translate="yes" xml:space="preserve">
          <source>does not retain any acquisition context.
This means (among others) that the Zope2 security mechanism will fail
and that the target thread will not have access to the request object
(a good thing as it gets closed asynchronously). Thus, there are
still severe limitations of what you can do in an asynchronous operation.</source>
          <target state="translated">획득 컨텍스트를 유지하지 않습니다. 이것은 (무엇보다도) Zope2 보안 메커니즘이 실패하고 대상 스레드가 요청 객체에 액세스 할 수 없다는 것을 의미합니다 (비동기 적으로 닫히기 때문에 좋은 점입니다). 따라서 비동기 작업에서 수행 할 수있는 작업에는 여전히 심각한 제한이 있습니다.</target>
        </trans-unit>
        <trans-unit id="778865dc050890ddaafc8bb11ca8ae6a8f431b94" translate="yes" xml:space="preserve">
          <source>exc</source>
          <target state="translated">exc</target>
        </trans-unit>
        <trans-unit id="4a0a19218e082a343a1b17e5333409af9d98f0f5" translate="yes" xml:space="preserve">
          <source>f</source>
          <target state="translated">에프</target>
        </trans-unit>
        <trans-unit id="54fd1711209fb1c0781092374132c66e79e2241b" translate="yes" xml:space="preserve">
          <source>g</source>
          <target state="translated">지</target>
        </trans-unit>
        <trans-unit id="34f7f08aa727c9fd2d26185c9787cb7df332d0cd" translate="yes" xml:space="preserve">
          <source>get_result</source>
          <target state="translated">get_result</target>
        </trans-unit>
        <trans-unit id="07a9de91358f976534119be7b26d01c7b734daba" translate="yes" xml:space="preserve">
          <source>gets a new attribute</source>
          <target state="translated">새로운 속성을 얻습니다</target>
        </trans-unit>
        <trans-unit id="d4ddedbc42ba27f904e4844751e84b084ca12179" translate="yes" xml:space="preserve">
          <source>has
be declared transactional. When we call</source>
          <target state="translated">트랜잭션으로 선언되었습니다. 우리가 전화 할 때</target>
        </trans-unit>
        <trans-unit id="fa330633d094525aeb45eec925a3350a7bbc2f96" translate="yes" xml:space="preserve">
          <source>hook of ZODB transactions to start the asynchronous
operation ensuring that modifications are seen.</source>
          <target state="translated">ZODB 트랜잭션의 후크를 사용하여 비동기 작업을 시작하여 수정 사항을 확인합니다.</target>
        </trans-unit>
        <trans-unit id="6101f55699d0d0901998fbd547b36a75d02ad025" translate="yes" xml:space="preserve">
          <source>implementations
which automatically determines the root database using Zope 2 implementation
details.</source>
          <target state="translated">Zope 2 구현 세부 정보를 사용하여 루트 데이터베이스를 자동으로 결정하는 구현.</target>
        </trans-unit>
        <trans-unit id="e2944f374426b6951a00f86c314a94ac72e1ab68" translate="yes" xml:space="preserve">
          <source>index the keyword arguments.</source>
          <target state="translated">키워드 인수를 인덱싱합니다.</target>
        </trans-unit>
        <trans-unit id="d22e05cc75396d6607e458441cfd263a9fc32c28" translate="yes" xml:space="preserve">
          <source>is used to demonstrate that</source>
          <target state="translated">증명하는 데 사용됩니다</target>
        </trans-unit>
        <trans-unit id="d8860219f70138580a2c5b845ddfe3d5b520355b" translate="yes" xml:space="preserve">
          <source>maintains its schedules in RAM. It is therefore
important that the</source>
          <target state="translated">일정을 RAM에 유지합니다. 따라서</target>
        </trans-unit>
        <trans-unit id="3d526cfa081f5d02c9cdb7f711552f243c25e790" translate="yes" xml:space="preserve">
          <source>manages transactions. Therefore, it is
useful to be able to monitor transaction management.
We use after commit hooks (directly provided by</source>
          <target state="translated">거래를 관리합니다. 따라서 트랜잭션 관리를 모니터링 할 수 있으면 유용합니다. 커밋 후 후크 (직접 제공)를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="4b20742f682d77af031ec25d58c940c26d4edefb" translate="yes" xml:space="preserve">
          <source>may return a tuple &lt;em&gt;return-value&lt;/em&gt;, &lt;em&gt;exception&lt;/em&gt;.</source>
          <target state="translated">tuple &lt;em&gt;return-value&lt;/em&gt; , &lt;em&gt;exception을 &lt;/em&gt;&lt;em&gt;반환&lt;/em&gt; 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="994bdf6bcba3e09aa5e16c189be8d0200da0ea82" translate="yes" xml:space="preserve">
          <source>means known but not yet complete.
Finally,</source>
          <target state="translated">알려졌지만 아직 완전하지는 않음을 의미합니다. 드디어,</target>
        </trans-unit>
        <trans-unit id="32ee0605f8658c63315f2f006e0870fa2b702d82" translate="yes" xml:space="preserve">
          <source>methods are
called in the same process (such that they see the same RAM content).
As a conseqeunce,
in a replicated web application context the requests with</source>
          <target state="translated">메소드는 동일한 프로세스에서 호출됩니다 (동일한 RAM 내용을 볼 수 있도록). 결론적으로, 복제 된 웹 애플리케이션 컨텍스트에서 요청은</target>
        </trans-unit>
        <trans-unit id="acf8e8723c099b38c8ff6264a693c9a17a5d8d63" translate="yes" xml:space="preserve">
          <source>not
started. In the latter case,</source>
          <target state="translated">시작되지 않았습니다. 후자의 경우에,</target>
        </trans-unit>
        <trans-unit id="c86c07000b09931301cd9abd19dd8d62a9922614" translate="yes" xml:space="preserve">
          <source>object (the Zope2 root object)
via</source>
          <target state="translated">개체 (Zope2 루트 개체)를 통해</target>
        </trans-unit>
        <trans-unit id="3927572c45dc7a8d20da56759afcb9b30937e4d2" translate="yes" xml:space="preserve">
          <source>or a</source>
          <target state="translated">또는</target>
        </trans-unit>
        <trans-unit id="df06651788c884556a0b4b290fb40475ec9a45ba" translate="yes" xml:space="preserve">
          <source>param</source>
          <target state="translated">매개 변수</target>
        </trans-unit>
        <trans-unit id="e89ca48276b1f20d7cb4df910966f0be39716805" translate="yes" xml:space="preserve">
          <source>print_function</source>
          <target state="translated">print_function</target>
        </trans-unit>
        <trans-unit id="a46622a9ffcb3cad7cd903241ed5ec03b139fa55" translate="yes" xml:space="preserve">
          <source>provides information about the result.</source>
          <target state="translated">결과에 대한 정보를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="34c32622805b48427ec0e60f2bae3dfe76b429f5" translate="yes" xml:space="preserve">
          <source>records the databases and oids associated with the persistent objects
and facilitates the reloading inside the target.</source>
          <target state="translated">영구 개체와 관련된 데이터베이스 및 OID를 기록하고 대상 내부에서 재로드를 용이하게합니다.</target>
        </trans-unit>
        <trans-unit id="9460e1bf60a359c4e283d7e565d70db702791e0e" translate="yes" xml:space="preserve">
          <source>register_hooks</source>
          <target state="translated">register_hooks</target>
        </trans-unit>
        <trans-unit id="24806bfb1a51919b90d0db7f2aca11b69b4dbb93" translate="yes" xml:space="preserve">
          <source>retries now for all</source>
          <target state="translated">모두를 위해 지금 재시도</target>
        </trans-unit>
        <trans-unit id="414e681ebabcd2f23de1f32468992b9c81c5f909" translate="yes" xml:space="preserve">
          <source>returns</source>
          <target state="translated">보고</target>
        </trans-unit>
        <trans-unit id="3043f63c35efa3a1092b6de1f2f3dae36a2be506" translate="yes" xml:space="preserve">
          <source>returns its result.
A transaction abort does not delete the result. However, a commit
will.</source>
          <target state="translated">결과를 반환합니다. 트랜잭션 중단은 결과를 삭제하지 않습니다. 그러나 커밋은 할 것입니다.</target>
        </trans-unit>
        <trans-unit id="a0f1490a20d0211c997b44bc357e1972deab8ae3" translate="yes" xml:space="preserve">
          <source>s</source>
          <target state="translated">에스</target>
        </trans-unit>
        <trans-unit id="11e9ba26c91a2db7452a5ef9ff7051e19b6b377a" translate="yes" xml:space="preserve">
          <source>schedule</source>
          <target state="translated">시간표</target>
        </trans-unit>
        <trans-unit id="142f817c3ec0586de0f960c1c0483043b61a0d06" translate="yes" xml:space="preserve">
          <source>scheduler</source>
          <target state="translated">스케줄러</target>
        </trans-unit>
        <trans-unit id="8c704db814a8441d6b4494bcbde7d49f25114ee9" translate="yes" xml:space="preserve">
          <source>section, persistent objects cannot
simply be passed on: instead the target context must reload them
from a (new) connection associated with the target.</source>
          <target state="translated">섹션에서 영구 객체는 단순히 전달 될 수 없습니다. 대신 대상 컨텍스트는 대상과 연관된 (새) 연결에서이를 다시로드해야합니다.</target>
        </trans-unit>
        <trans-unit id="b536802786d62d0dda6bcc0501f60be6a091bee0" translate="yes" xml:space="preserve">
          <source>sees modifications performed in the
original request (even when they happen after the scheduling).</source>
          <target state="translated">원래 요청에서 수행 된 수정 사항을 확인합니다 (일정 이후에 발생한 경우에도 해당).</target>
        </trans-unit>
        <trans-unit id="9fb29051f2217270a7b253a39f820310d85a78f0" translate="yes" xml:space="preserve">
          <source>show</source>
          <target state="translated">보여 주다</target>
        </trans-unit>
        <trans-unit id="3442496b96dd01591a8cd44b1eec1368ab728aba" translate="yes" xml:space="preserve">
          <source>str</source>
          <target state="translated">str</target>
        </trans-unit>
        <trans-unit id="3d6721211612672de2eec047489a5ac6f4cabe9e" translate="yes" xml:space="preserve">
          <source>supports both positional
as well as keyword parameters. For demonstational purposes, we
pass</source>
          <target state="translated">위치 및 키워드 매개 변수를 모두 지원합니다. 악마의 목적을 위해 우리는</target>
        </trans-unit>
        <trans-unit id="da483ee31f41665243ea040a300231dc98471e94" translate="yes" xml:space="preserve">
          <source>to reenable the detection.</source>
          <target state="translated">감지를 다시 활성화합니다.</target>
        </trans-unit>
        <trans-unit id="41c48b55fa9164e123cc73b1157459e840be5d24" translate="yes" xml:space="preserve">
          <source>transaction</source>
          <target state="translated">트랜잭션</target>
        </trans-unit>
        <trans-unit id="2280679a7fbee6d6a45021477004d4850744a033" translate="yes" xml:space="preserve">
          <source>transaction commit hook was not called at
the end of the</source>
          <target state="translated">트랜잭션 커밋 후크가 마지막에 호출되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="9738e1563828eac6e8a92f5f95c7a573be2ccd74" translate="yes" xml:space="preserve">
          <source>transaction.abort()</source>
          <target state="translated">transaction.abort ()</target>
        </trans-unit>
        <trans-unit id="dfff9135e05ee8d8d751f1d04769a37b7297e9c5" translate="yes" xml:space="preserve">
          <source>transaction.commit()</source>
          <target state="translated">transaction.commit ()</target>
        </trans-unit>
        <trans-unit id="f5d675dad1bf5fba4c4989286c05d5f3f45fbede" translate="yes" xml:space="preserve">
          <source>transactional</source>
          <target state="translated">거래</target>
        </trans-unit>
        <trans-unit id="a20e8889322e87bf69dc6fc6b74eb6964238974e" translate="yes" xml:space="preserve">
          <source>transactional.interfaces.TransientError</source>
          <target state="translated">transactional.interfaces.TransientError</target>
        </trans-unit>
        <trans-unit id="ffde8c83ca53790bab138e077612ee355fcf8c5a" translate="yes" xml:space="preserve">
          <source>uses the</source>
          <target state="translated">사용</target>
        </trans-unit>
        <trans-unit id="d9721c2cbfdc86a2cbf83d1c07879ccef4743428" translate="yes" xml:space="preserve">
          <source>which
will monitor transaction aborts and commits. We also set up logging
to see logging messages.</source>
          <target state="translated">트랜잭션 중단 및 커밋을 모니터링합니다. 또한 로깅 메시지를보기 위해 로깅을 설정했습니다.</target>
        </trans-unit>
        <trans-unit id="e28e7ee7f0a52804945ce3d4ebb2980e05a1c2fb" translate="yes" xml:space="preserve">
          <source>which supports
the following use case: some context starts an operation in a separate
thread and then terminates; a different context later checks whether
the operation has completed and if so processes the results.
The use case arises for example in a web application (such as Zope) for
long running operations which should be processed asynchronously
(in a separate thread) rather than inline (in the originating request)
to provide useful partial results or feedback immediately. Later results
are fetched and presented e.g. via dynamic (AJAX, Web 2) techniques.</source>
          <target state="translated">다음 사용 사례를 지원합니다. 일부 컨텍스트는 별도의 스레드에서 작업을 시작한 다음 종료됩니다. 다른 컨텍스트는 나중에 작업이 완료되었는지 여부를 확인하고 완료되면 결과를 처리합니다. 예를 들어 웹 애플리케이션 (예 : Zope)에서 유용한 부분 결과 또는 피드백을 즉시 제공하기 위해 인라인 (원래 요청에서)이 아닌 비동기 적으로 (별도의 스레드에서) 처리되어야하는 웹 애플리케이션 (예 : Zope)에서 발생합니다. 나중에 결과를 가져 와서 동적 (AJAX, Web 2) 기술을 통해 제공합니다.</target>
        </trans-unit>
        <trans-unit id="b523f052484795efe4737ff5a499130f938c70e7" translate="yes" xml:space="preserve">
          <source>whose instances store the schedules
in itself and thereby in the ZODB. For details, read its docstring.</source>
          <target state="translated">그 인스턴스가 일정을 자체적으로 저장하므로 ZODB에 저장됩니다. 자세한 내용은 독 스트링을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="e627ba12abeaaad9ae3f251b28ff9fcd994017da" translate="yes" xml:space="preserve">
          <source>will start.</source>
          <target state="translated">시작할 것이다.</target>
        </trans-unit>
        <trans-unit id="8fcd25a39d2037183044a8897e9a5333d727fded" translate="yes" xml:space="preserve">
          <source>with</source>
          <target state="translated">와</target>
        </trans-unit>
        <trans-unit id="58f0c140ca8c36c7271afa2428a8c169111fe1f9" translate="yes" xml:space="preserve">
          <source>zope2</source>
          <target state="translated">zope2</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
