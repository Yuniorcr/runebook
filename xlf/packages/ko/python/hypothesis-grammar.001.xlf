<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://pypi.org/project/hypothesis-grammar/">
    <body>
      <group id="hypothesis-grammar">
        <trans-unit id="06e715f999c1e8bb74d0ef668de5467dbc5404e8" translate="yes" xml:space="preserve">
          <source>'Rules' must be named all-lowercase, e.g. &lt;code&gt;np&lt;/code&gt;</source>
          <target state="translated">'규칙'은 모두 소문자로 지정해야합니다 (예 : &lt;code&gt;np&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="065e98511a3f896062d78116f1f4a79818a9d74c" translate="yes" xml:space="preserve">
          <source>'Terminals' must be named all-caps (terminals only reference literals, not other rules), e.g. &lt;code&gt;DET&lt;/code&gt;</source>
          <target state="translated">'터미널'은 모두 대문자로 지정해야합니다 (터미널은 다른 규칙이 아닌 리터럴 만 참조), 예 : &lt;code&gt;DET&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0e4306aaec34e61c0ed5b8039ff9c6bd77e8c070" translate="yes" xml:space="preserve">
          <source>(But if you're generating action sequences for tests then probably you should check out Hypothesis' &lt;a href=&quot;https://hypothesis.readthedocs.io/en/latest/stateful.html&quot;&gt;stateful testing&lt;/a&gt; features first)</source>
          <target state="translated">(그러나 테스트를위한 작업 시퀀스를 생성하는 경우 먼저 가설의 &lt;a href=&quot;https://hypothesis.readthedocs.io/en/latest/stateful.html&quot;&gt;상태 저장 테스트&lt;/a&gt; 기능을 확인해야합니다. )</target>
        </trans-unit>
        <trans-unit id="7da59d650a4228de748a0d71280684a68d5ad441" translate="yes" xml:space="preserve">
          <source>(If you are looking to generate text from a grammar for purposes other than testing with Hypothesis then this lib can still be useful, but I stongly recommend looking at the &lt;a href=&quot;http://www.nltk.org/howto/generate.html&quot;&gt;tools provided with NLTK&lt;/a&gt; instead.)</source>
          <target state="translated">(가설로 테스트하는 것 이외의 목적으로 문법에서 텍스트를 생성하려는 경우이 lib가 여전히 유용 할 수 있지만 대신 &lt;a href=&quot;http://www.nltk.org/howto/generate.html&quot;&gt;NLTK와 함께 제공&lt;/a&gt; 되는 도구를 살펴 보는 것이 좋습니다 .)</target>
        </trans-unit>
        <trans-unit id="f79e28061ca25a0dae68cd9212d7c2ddaf953658" translate="yes" xml:space="preserve">
          <source>(pre-alpha... the stuff I've tried all works, not well tested yet though)</source>
          <target state="translated">(사전 알파 ... 모든 작업을 시도했지만 아직 잘 테스트되지는 않았습니다)</target>
        </trans-unit>
        <trans-unit id="34ef5ca7249f5ce6a9b2a03376eb3bd60d72a35b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;(&lt;/code&gt; and &lt;code&gt;)&lt;/code&gt; are for grouping, the group can be quantified using any of the modifiers above.</source>
          <target state="translated">&lt;code&gt;(&lt;/code&gt; 및 &lt;code&gt;)&lt;/code&gt; 는 그룹화를위한 것이며 위의 수정 자 중 하나를 사용하여 그룹을 정량화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="69d0a0282362c3d1a791adf8f0b422ad59bbc4f7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;*&lt;/code&gt; i.e. &lt;code&gt;&quot;in&quot;*&lt;/code&gt; means &lt;code&gt;&quot;in&quot;&lt;/code&gt; is expected zero-or-many times.</source>
          <target state="translated">&lt;code&gt;*&lt;/code&gt; 즉 &lt;code&gt;&quot;in&quot;*&lt;/code&gt; 은 &lt;code&gt;&quot;in&quot;&lt;/code&gt; 이 0 번 또는 여러 번 예상 됨을 의미 합니다.</target>
        </trans-unit>
        <trans-unit id="594929d4a73449a1758113e6a81964a0eed29be9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;+&lt;/code&gt; i.e. &lt;code&gt;&quot;in&quot;+&lt;/code&gt; means &lt;code&gt;&quot;in&quot;&lt;/code&gt; is expected one-or-many times.</source>
          <target state="translated">&lt;code&gt;+&lt;/code&gt; 즉 &lt;code&gt;&quot;in&quot;+&lt;/code&gt; 는 &lt;code&gt;&quot;in&quot;&lt;/code&gt; 이 한 번 또는 여러 번 예상 됨을 의미 합니다.</target>
        </trans-unit>
        <trans-unit id="acfb5e63bd26caad67b133356629e859d7e8040b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;?&lt;/code&gt; means optional, i.e. &lt;code&gt;&quot;in&quot;?&lt;/code&gt; means &lt;code&gt;&quot;in&quot;&lt;/code&gt; is expected zero-or-one time.</source>
          <target state="translated">&lt;code&gt;?&lt;/code&gt; 선택 사항, 즉 &lt;code&gt;&quot;in&quot;?&lt;/code&gt; &lt;code&gt;&quot;in&quot;&lt;/code&gt; 은 0 또는 1 회 예상 됨을 의미 합니다.</target>
        </trans-unit>
        <trans-unit id="65c66d8b9aad8e761dd0438f1755afc753cb14b7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;start=&quot;s&quot;&lt;/code&gt; tells the parser that the start rule is &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;start=&quot;s&quot;&lt;/code&gt; 는 시작 규칙이 &lt;code&gt;s&lt;/code&gt; 임을 파서에 알립니다 .</target>
        </trans-unit>
        <trans-unit id="ffba1884ae5cdd5a0572dae34fed56976c21cf0d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;|&lt;/code&gt; is alternation, so &lt;code&gt;&quot;in&quot; | &quot;with&quot;&lt;/code&gt; means one-of &lt;code&gt;&quot;in&quot;&lt;/code&gt; or &lt;code&gt;&quot;with&quot;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;|&lt;/code&gt; 교대로 &lt;code&gt;&quot;in&quot; | &quot;with&quot;&lt;/code&gt; 는 &lt;code&gt;&quot;in&quot;&lt;/code&gt; 또는 &lt;code&gt;&quot;with&quot;&lt;/code&gt; 중 하나를 의미합니다.</target>
        </trans-unit>
        <trans-unit id="53f6efc5cdcf9f3a22526511d7745bdb7b12979b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;~ &amp;lt;min&amp;gt;..&amp;lt;max&amp;gt;&lt;/code&gt; is a range, expected between-&amp;lt;min&amp;gt;-and-&amp;lt;max&amp;gt; times.</source>
          <target state="translated">&lt;code&gt;~ &amp;lt;min&amp;gt;..&amp;lt;max&amp;gt;&lt;/code&gt; 는-&amp;lt;min&amp;gt; -and- &amp;lt;max&amp;gt; 시간 사이에 예상되는 범위입니다.</target>
        </trans-unit>
        <trans-unit id="8175495afd0f99be24db86f956abbc7435b000f3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;~ &amp;lt;num&amp;gt;&lt;/code&gt; means exactly-&amp;lt;num&amp;gt; times.</source>
          <target state="translated">&lt;code&gt;~ &amp;lt;num&amp;gt;&lt;/code&gt; 은 정확히 &amp;lt;num&amp;gt; 번을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="6fc2a5bf81a73fe237a154328c768027afa67a3c" translate="yes" xml:space="preserve">
          <source>A reverse-parser as a Hypotheses strategy: generate examples from an EBNF grammar</source>
          <target state="translated">가설 전략으로서의 역 파서 : EBNF 문법에서 예제 생성</target>
        </trans-unit>
        <trans-unit id="b11f8183e944886fa59148cbb5189e20f31848dd" translate="yes" xml:space="preserve">
          <source>Adjacent tokens are concatenated, i.e. &lt;code&gt;DET N&lt;/code&gt; means a &lt;code&gt;DET&lt;/code&gt; followed by a &lt;code&gt;N&lt;/code&gt;.</source>
          <target state="translated">인접한 토큰이 연결됩니다. 즉, &lt;code&gt;DET N&lt;/code&gt; 은 &lt;code&gt;DET&lt;/code&gt; 다음에 &lt;code&gt;N&lt;/code&gt; 이 오는 것을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="fc800738edcebd003994663a677ad7f8e3341029" translate="yes" xml:space="preserve">
          <source>As you can see, we have produced a Hypothesis strategy which is able to generate examples which match the grammar (in this case, short sentences which sometimes makes sense).</source>
          <target state="translated">보시다시피, 우리는 문법과 일치하는 예를 생성 할 수있는 가설 전략을 만들었습니다 (이 경우에는 때때로 의미가있는 짧은 문장).</target>
        </trans-unit>
        <trans-unit id="4c34dcc622b1da6b7f78e159b817ba5ba1108fcb" translate="yes" xml:space="preserve">
          <source>But the grammar doesn't have to describe text, it might represent a sequence of actions for example. In that case you might want to convert your result tokens into object instances, which could be done via a lookup table.</source>
          <target state="translated">그러나 문법은 텍스트를 설명 할 필요가 없습니다. 예를 들어 일련의 동작을 나타낼 수 있습니다. 이 경우 검색 테이블을 통해 수행 할 수있는 개체 인스턴스로 결과 토큰을 변환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dc9401e01d92475f18b6c76f30c9f4b07ca762e8" translate="yes" xml:space="preserve">
          <source>First you need a grammar. Our grammar format is based on that used by the &lt;a href=&quot;https://lark-parser.readthedocs.io/en/latest/grammar/&quot;&gt;Lark parser&lt;/a&gt; library.  You can see our grammar-parsing grammar &lt;a href=&quot;hypothesis_grammar/grammar.lark&quot;&gt;here&lt;/a&gt;. More details of our grammar format &lt;a href=&quot;#grammar-details&quot;&gt;below&lt;/a&gt;.</source>
          <target state="translated">먼저 문법이 필요합니다. 우리의 문법 형식은 &lt;a href=&quot;https://lark-parser.readthedocs.io/en/latest/grammar/&quot;&gt;Lark 파서&lt;/a&gt; 라이브러리 에서 사용하는 형식을 기반으로합니다 . &lt;a href=&quot;hypothesis_grammar/grammar.lark&quot;&gt;여기에서&lt;/a&gt; 문법 구문 분석 문법을 볼 수 있습니다 . 문법 형식에 대한 자세한 내용은 &lt;a href=&quot;#grammar-details&quot;&gt;아래에서 확인하세요&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f2784e07adcbc7db90051cd83d24796138debae1" translate="yes" xml:space="preserve">
          <source>Grammar details</source>
          <target state="translated">문법 세부 사항</target>
        </trans-unit>
        <trans-unit id="c7530a6dc53e039db1fa76c609ca7579225d1de7" translate="yes" xml:space="preserve">
          <source>Here is an example of using Hypothesis-Grammar:</source>
          <target state="translated">다음은 Hypothesis-Grammar를 사용하는 예입니다.</target>
        </trans-unit>
        <trans-unit id="334513e51b766e5689a61997385d87079b5771e1" translate="yes" xml:space="preserve">
          <source>Hypothesis-Grammar</source>
          <target state="translated">가설-문법</target>
        </trans-unit>
        <trans-unit id="d23367f26b61f8267251a6d0cd014c1bfc25fe30" translate="yes" xml:space="preserve">
          <source>Hypothesis-Grammar is a &quot;reverse parser&quot; - given a grammar it will generate examples of that grammar.</source>
          <target state="translated">Hypothesis-Grammar는 &quot;역 파서&quot;입니다. 주어진 문법은 그 문법의 예를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="8512397b4e5d55cc7988da53f1e53707a6b4cd51" translate="yes" xml:space="preserve">
          <source>It is implemented as a &lt;a href=&quot;https://hypothesis.readthedocs.io/&quot;&gt;Hypothesis&lt;/a&gt; strategy.</source>
          <target state="translated">&lt;a href=&quot;https://hypothesis.readthedocs.io/&quot;&gt;가설&lt;/a&gt; 전략으로 구현됩니다 .</target>
        </trans-unit>
        <trans-unit id="1e8128625511f78e7f6a98221108be4105cd8796" translate="yes" xml:space="preserve">
          <source>LHS (name) and RHS are separated by &lt;code&gt;:&lt;/code&gt;</source>
          <target state="translated">LHS (이름) 및 RHS는 다음으로 구분됩니다 &lt;code&gt;:&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3fe993dc8d00fe8d1dcd9fd70305c2ef4e2c9d81" translate="yes" xml:space="preserve">
          <source>So, how does this look?</source>
          <target state="translated">그래서, 이것은 어떻게 생겼습니까?</target>
        </trans-unit>
        <trans-unit id="4bdde3ae857cfb158e4e4b54e3b745c97059108f" translate="yes" xml:space="preserve">
          <source>String literals must be quoted with double-quotes e.g. &lt;code&gt;&quot;man&quot;&lt;/code&gt;</source>
          <target state="translated">문자열 리터럴은 큰 따옴표로 묶어야합니다 (예 : &lt;code&gt;&quot;man&quot;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="e9fdfd1e154ac05cf9c3cf579648d547828051f8" translate="yes" xml:space="preserve">
          <source>The grammar is taken from an example in the NLTK docs and converted into our &quot;simplified Lark&quot; format.</source>
          <target state="translated">문법은 NLTK 문서의 예제에서 가져와 &quot;간단한 Lark&quot;형식으로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="7e17a3d7bd0d9cde371729a97139671e37c46125" translate="yes" xml:space="preserve">
          <source>The output will always be a flat list of token strings. If you want a sentence you can just &lt;code&gt;&quot; &quot;.join(example)&lt;/code&gt;.</source>
          <target state="translated">출력은 항상 토큰 문자열의 단순 목록입니다. 문장을 원하시면 &lt;code&gt;&quot; &quot;.join(example)&lt;/code&gt; 하세요.</target>
        </trans-unit>
        <trans-unit id="0bb18642b70b9f8a9c12ccf39487328f306b8e19" translate="yes" xml:space="preserve">
          <source>Usage</source>
          <target state="translated">용법</target>
        </trans-unit>
        <trans-unit id="89511a76c8cbc174d6fe0018b08443f894e18a4b" translate="yes" xml:space="preserve">
          <source>What is it?</source>
          <target state="translated">무엇입니까?</target>
        </trans-unit>
        <trans-unit id="5f5f8cd4a78f6cd933cbf9fff486ee98721bee8a" translate="yes" xml:space="preserve">
          <source>Whitespace is ignored</source>
          <target state="translated">공백은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="f440fc0b5a8ed2198e0c8ff92108351e7b09573a" translate="yes" xml:space="preserve">
          <source>You can also use regex literals, they are delimited with forward-slash, e.g. &lt;code&gt;/the[a-z]{0,2}/&lt;/code&gt;. Content for the regex token is generated using Hypothesis' &lt;a href=&quot;https://hypothesis.readthedocs.io/en/latest/data.html#hypothesis.strategies.from_regex&quot;&gt;&lt;code&gt;from_regex&lt;/code&gt;&lt;/a&gt; strategy, with &lt;code&gt;fullmatch=True&lt;/code&gt;.</source>
          <target state="translated">정규식 리터럴을 사용할 수도 있으며 슬래시로 구분됩니다 (예 : &lt;code&gt;/the[a-z]{0,2}/&lt;/code&gt; . 정규식 토큰에 대한 콘텐츠는 &lt;code&gt;fullmatch=True&lt;/code&gt; 인 Hypothesis의 &lt;a href=&quot;https://hypothesis.readthedocs.io/en/latest/data.html#hypothesis.strategies.from_regex&quot;&gt; &lt;code&gt;from_regex&lt;/code&gt; &lt;/a&gt; 전략을 사용하여 생성됩니다 .</target>
        </trans-unit>
        <trans-unit id="63a91052414204f961faae0fbe524fde2183273f" translate="yes" xml:space="preserve">
          <source>or as a test...</source>
          <target state="translated">또는 테스트로 ...</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
