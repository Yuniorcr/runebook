<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://pypi.org/project/cachier/">
    <body>
      <group id="cachier">
        <trans-unit id="28ed3a797da3c48c309a4ef792147f3c56cfec40" translate="yes" xml:space="preserve">
          <source>(</source>
          <target state="translated">(</target>
        </trans-unit>
        <trans-unit id="f1c23d557df7c67b96eb73c14595d021fedefade" translate="yes" xml:space="preserve">
          <source>A simple interface.</source>
          <target state="translated">간단한 인터페이스.</target>
        </trans-unit>
        <trans-unit id="a3f8605b79d02776fe60576c8b6cbd1b37077b75" translate="yes" xml:space="preserve">
          <source>Adding documentation</source>
          <target state="translated">문서 추가</target>
        </trans-unit>
        <trans-unit id="9e4d50dd58881047e7f1c60fdae31281ca7fe1cf" translate="yes" xml:space="preserve">
          <source>As mentioned above, the positional and keyword arguments to the wrapped function must be hashable (i.e. Python&amp;rsquo;s immutable built-in objects, not mutable containers). To get around this limitation the</source>
          <target state="translated">위에서 언급했듯이 래핑 된 함수에 대한 위치 및 키워드 인수는 해시 가능해야합니다 (즉, 변경 가능한 컨테이너가 아닌 Python의 변경 불가능한 내장 객체). 이 제한을 극복하려면</target>
        </trans-unit>
        <trans-unit id="885c324b71008672d23faa36b63495e5c68708bf" translate="yes" xml:space="preserve">
          <source>Cache Shelf Life</source>
          <target state="translated">캐시 유효 기간</target>
        </trans-unit>
        <trans-unit id="192fde71881059b33be37320e825e6a9ce660d38" translate="yes" xml:space="preserve">
          <source>Cache replacement policies</source>
          <target state="translated">캐시 교체 정책</target>
        </trans-unit>
        <trans-unit id="8cca54fb45f77abb6f995eeb317c162e2b2df076" translate="yes" xml:space="preserve">
          <source>Cachier Cores</source>
          <target state="translated">Cachier 코어</target>
        </trans-unit>
        <trans-unit id="e40e1be9a5b3993dc1b0cc890ba160f49bf4dd90" translate="yes" xml:space="preserve">
          <source>Cachier also accepts several keyword arguments in the calls of the function it wraps rather than in the decorator call, allowing you to modify its behaviour for a specific function call.</source>
          <target state="translated">Cachier는 또한 데코레이터 호출이 아닌 래핑하는 함수 호출에서 여러 키워드 인수를 허용하므로 특정 함수 호출에 대한 동작을 수정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bd0e46db3073a89e733cfb41ee671964f5e98b57" translate="yes" xml:space="preserve">
          <source>Cachier is &lt;strong&gt;NOT&lt;/strong&gt;:</source>
          <target state="translated">Cachier는 &lt;strong&gt;아닙니다&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="19c18795128ee395941c4ad9aa8df542b8fabbf2" translate="yes" xml:space="preserve">
          <source>Cachier provides a decorator which you can wrap around your functions to give them a persistent cache. The positional and keyword arguments to the wrapped function must be hashable (i.e. Python&amp;rsquo;s immutable built-in objects, not mutable containers). Also, notice that since objects which are instances of user-defined classes are hashable but all compare unequal (their hash value is their id), equal objects across different sessions will not yield identical keys.</source>
          <target state="translated">Cachier는 함수를 감싸서 영구 캐시를 제공 할 수있는 데코레이터를 제공합니다. 래핑 된 함수에 대한 위치 및 키워드 인수는 해시 가능해야합니다 (즉, 변경 가능한 컨테이너가 아닌 Python의 변경 불가능한 내장 객체). 또한 사용자 정의 클래스의 인스턴스 인 개체는 해시 할 수 있지만 모두 비교가 같지 않기 때문에 (해시 값이 해당 ID) 다른 세션에서 동일한 개체는 동일한 키를 생성하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="89f17d8a59bed1ec95801a6d2e10b5cbf72f502e" translate="yes" xml:space="preserve">
          <source>Clone:</source>
          <target state="translated">복제 :</target>
        </trans-unit>
        <trans-unit id="17658d26a87b890ac602476949f222675089531a" translate="yes" xml:space="preserve">
          <source>Compatible with Python 3.5+ (and Python 2.7 up until version 1.2.8).</source>
          <target state="translated">Python 3.5 이상 (버전 1.2.8까지 Python 2.7)과 호환됩니다.</target>
        </trans-unit>
        <trans-unit id="f5cbdf6bfb51439be085b5c6b7460a7c91eabc3c" translate="yes" xml:space="preserve">
          <source>Contents</source>
          <target state="translated">내용</target>
        </trans-unit>
        <trans-unit id="2d82a4b27a4b305690d5ac612046a955778a9fa5" translate="yes" xml:space="preserve">
          <source>Contributing</source>
          <target state="translated">기여</target>
        </trans-unit>
        <trans-unit id="8cff37c62de016b4fbf7dc9191fc5f06950c29c6" translate="yes" xml:space="preserve">
          <source>Created by Shay Palachy (&lt;a href=&quot;mailto:shay.palachy%40gmail.com&quot;&gt;shay.palachy@gmail.com&lt;/a&gt;).</source>
          <target state="translated">Shay Palachy ( &lt;a href=&quot;mailto:shay.palachy%40gmail.com&quot;&gt;shay.palachy@gmail.com&lt;/a&gt; )가 작성했습니다 .</target>
        </trans-unit>
        <trans-unit id="bfac50d6424b5166c3ee2808c85ae7c139b5182f" translate="yes" xml:space="preserve">
          <source>Credits</source>
          <target state="translated">크레딧</target>
        </trans-unit>
        <trans-unit id="39294e5b7f716b740934bb27a6f8acc167bfc163" translate="yes" xml:space="preserve">
          <source>Cross-machine caching using MongoDB.</source>
          <target state="translated">MongoDB를 사용한 크로스 머신 캐싱.</target>
        </trans-unit>
        <trans-unit id="9288ecf1c8a1acb108a4bc56ae642257e5bbf1ed" translate="yes" xml:space="preserve">
          <source>Defining &amp;ldquo;shelf life&amp;rdquo; for cached values.</source>
          <target state="translated">캐시 된 값의 &quot;수명&quot;정의.</target>
        </trans-unit>
        <trans-unit id="ab9a3c6274e8d3a19a1d8aec9bd7a0f61345d9f2" translate="yes" xml:space="preserve">
          <source>Especially fast. It is meant to replace function calls that take more than&amp;hellip; a second, say (overhead is around 1 millisecond).</source>
          <target state="translated">특히 빠릅니다. 1 초 이상 걸리는 함수 호출을 대체하기위한 것입니다 (예 : 오버 헤드는 약 1 밀리 초).</target>
        </trans-unit>
        <trans-unit id="fc338f87a058158eb824b53705961801516a9460" translate="yes" xml:space="preserve">
          <source>Features</source>
          <target state="translated">풍모</target>
        </trans-unit>
        <trans-unit id="96a6679755240f287f1aa5700cdcb0c8cfbe3952" translate="yes" xml:space="preserve">
          <source>For the latest version supporting Python 2.7 please use:</source>
          <target state="translated">Python 2.7을 지원하는 최신 버전의 경우 다음을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="c18b32d9c12477f0203d28c4b2014879a5ec64e5" translate="yes" xml:space="preserve">
          <source>Further function calls made while the calculation is being performed will not trigger redundant calculations.</source>
          <target state="translated">계산이 수행되는 동안 추가 함수 호출은 중복 계산을 트리거하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4295171aefeb231d8cc32c01f6f51fb25f299f9b" translate="yes" xml:space="preserve">
          <source>Future features</source>
          <target state="translated">향후 기능</target>
        </trans-unit>
        <trans-unit id="d8181a1860e0fdbdf8f3878c274e8d48da124399" translate="yes" xml:space="preserve">
          <source>Fuzzy Shelf Life</source>
          <target state="translated">퍼지 유통 기한</target>
        </trans-unit>
        <trans-unit id="86398fcb1018b8bf6a11f1d567004e5148604845" translate="yes" xml:space="preserve">
          <source>Ignore Cache</source>
          <target state="translated">캐시 무시</target>
        </trans-unit>
        <trans-unit id="fd6c3ebf7befca9f8208f86c76e4d4180303745c" translate="yes" xml:space="preserve">
          <source>Install</source>
          <target state="translated">설치</target>
        </trans-unit>
        <trans-unit id="0c9ff54110ec464917f5d6fb06d076add82a30b7" translate="yes" xml:space="preserve">
          <source>Install in development mode with test dependencies:</source>
          <target state="translated">테스트 종속성이있는 개발 모드에서 설치 :</target>
        </trans-unit>
        <trans-unit id="c81b79df3c6448eae7c4f80428b54cd5692a17d7" translate="yes" xml:space="preserve">
          <source>Installation</source>
          <target state="translated">설치</target>
        </trans-unit>
        <trans-unit id="d2ea71ee1c3628e8909d3b842a53a04949e266aa" translate="yes" xml:space="preserve">
          <source>Installing for development</source>
          <target state="translated">개발 용 설치</target>
        </trans-unit>
        <trans-unit id="d8932cc0951902dc760a2ff0f7b07139c2b684a4" translate="yes" xml:space="preserve">
          <source>Local caching using pickle files.</source>
          <target state="translated">피클 파일을 사용한 로컬 캐싱.</target>
        </trans-unit>
        <trans-unit id="d6ac3db979e659a31315ee4ae733e293e34e23c9" translate="yes" xml:space="preserve">
          <source>Meant as a transient cache. Python&amp;rsquo;s @lru_cache is better.</source>
          <target state="translated">일시적인 캐시를 의미합니다. Python의 @lru_cache가 더 좋습니다.</target>
        </trans-unit>
        <trans-unit id="76047f09fd28fa2d64394e9a9822cdd1a519966f" translate="yes" xml:space="preserve">
          <source>MongoDB Core</source>
          <target state="translated">MongoDB 코어</target>
        </trans-unit>
        <trans-unit id="d0fedd0053b0cef9060cffb1a1493b815eaa4108" translate="yes" xml:space="preserve">
          <source>Multi-core caching.</source>
          <target state="translated">멀티 코어 캐싱.</target>
        </trans-unit>
        <trans-unit id="6eff13a1ed6bcf9aa7db3a60759e6af3639de287" translate="yes" xml:space="preserve">
          <source>Now when a cached value matching the given arguments is found the time of its calculation is checked; if more than</source>
          <target state="translated">이제 주어진 인수와 일치하는 캐시 된 값이 발견되면 계산 시간이 확인됩니다. 이상이면</target>
        </trans-unit>
        <trans-unit id="b48da51eecc56d03a5f0135e841b1cfec0121383" translate="yes" xml:space="preserve">
          <source>Overwrite Cache</source>
          <target state="translated">캐시 덮어 쓰기</target>
        </trans-unit>
        <trans-unit id="95127e27db8a9c0984185792cf0b5bce6c066cce" translate="yes" xml:space="preserve">
          <source>Package author and current maintainer is Shay Palachy (&lt;a href=&quot;mailto:shay.palachy%40gmail.com&quot;&gt;shay.palachy@gmail.com&lt;/a&gt;); You are more than welcome to approach him for help. Contributions are very welcomed.</source>
          <target state="translated">패키지 작성자이자 현재 관리자는 Shay Palachy ( &lt;a href=&quot;mailto:shay.palachy%40gmail.com&quot;&gt;shay.palachy@gmail.com&lt;/a&gt; )입니다. 그에게 도움을 청하는 것을 환영합니다. 기부는 매우 환영합니다.</target>
        </trans-unit>
        <trans-unit id="2d05a26ce14bd4c58f533ef1558842b5c115caa5" translate="yes" xml:space="preserve">
          <source>Per-function call arguments</source>
          <target state="translated">함수 별 호출 인수</target>
        </trans-unit>
        <trans-unit id="5cb651f2803235ed309df22a1f8f93a687150833" translate="yes" xml:space="preserve">
          <source>Persistent, stale-free, local and cross-machine caching for Python functions.</source>
          <target state="translated">Python 함수를위한 지속적이고 부실없는 로컬 및 교차 시스템 캐싱.</target>
        </trans-unit>
        <trans-unit id="9b13f3a908629efbc78f59451c69b50d919a13ab" translate="yes" xml:space="preserve">
          <source>Pickle Core</source>
          <target state="translated">피클 코어</target>
        </trans-unit>
        <trans-unit id="8e099f9f7cae947c5ff0ef7a5271190cf4b7cfc7" translate="yes" xml:space="preserve">
          <source>Pure Python.</source>
          <target state="translated">순수 파이썬.</target>
        </trans-unit>
        <trans-unit id="ea753bdc0936e4500b4b92850d42c242fb09c1c1" translate="yes" xml:space="preserve">
          <source>Resetting a Cache</source>
          <target state="translated">캐시 재설정</target>
        </trans-unit>
        <trans-unit id="1e0883db26345cee9aa196cedada38c2dbef49be" translate="yes" xml:space="preserve">
          <source>Running the tests</source>
          <target state="translated">테스트 실행</target>
        </trans-unit>
        <trans-unit id="38f21c43b8c6057044eef13d4363cb5cd3f535d7" translate="yes" xml:space="preserve">
          <source>S3 core.</source>
          <target state="translated">S3 코어.</target>
        </trans-unit>
        <trans-unit id="4ed4ba175074eb0a0278b3104c426821fcf38307" translate="yes" xml:space="preserve">
          <source>Setting Shelf Life</source>
          <target state="translated">유통 기한 설정</target>
        </trans-unit>
        <trans-unit id="73e56e67c864ba412812dd644b749d0c5ee7860d" translate="yes" xml:space="preserve">
          <source>Setting up a Cache</source>
          <target state="translated">캐시 설정</target>
        </trans-unit>
        <trans-unit id="9acf535b8cd991fba143356c2b422f9281f1e208" translate="yes" xml:space="preserve">
          <source>Sometimes you may want your function to trigger a calculation when it encounters a stale result, but still not wait on it if it&amp;rsquo;s not that critical. In that case, you can set</source>
          <target state="translated">때로는 함수가 오래된 결과를 발견 할 때 계산을 트리거하도록 할 수 있지만 그다지 중요하지 않은 경우에는 기다리지 않습니다. 이 경우 다음을 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="85e9fa7ad0cb402508c319030793dbc3af865082" translate="yes" xml:space="preserve">
          <source>Supported and &lt;a href=&quot;https://travis-ci.org/shaypal5/cachier&quot;&gt;tested on Linux, OS X and Windows&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://travis-ci.org/shaypal5/cachier&quot;&gt;Linux, OS X 및 Windows에서&lt;/a&gt; 지원 및 테스트되었습니다 .</target>
        </trans-unit>
        <trans-unit id="ffd4cd1d4ffaab2140ba8fb47783028157d679ee" translate="yes" xml:space="preserve">
          <source>The Cachier wrapper adds a</source>
          <target state="translated">Cachier 래퍼는</target>
        </trans-unit>
        <trans-unit id="0ba3fff411a237ed1b36fea7ff07c946935aee7f" translate="yes" xml:space="preserve">
          <source>The default core for Cachier is pickle based, meaning each function will store its cache is a separate pickle file in the</source>
          <target state="translated">Cachier의 기본 코어는 피클 기반입니다. 즉, 각 함수는 캐시를 별도의 피클 파일에 저장합니다.</target>
        </trans-unit>
        <trans-unit id="d5f515c4318635d6885b07dd1e4efdad57820fb7" translate="yes" xml:space="preserve">
          <source>This allows you to have a cross-machine, albeit slower, cache. This functionality requires that the installation of the</source>
          <target state="translated">이를 통해 속도는 느리지 만 시스템 간 캐시를 사용할 수 있습니다. 이 기능을 사용하려면</target>
        </trans-unit>
        <trans-unit id="38bf05017bdec1ae480537a91ba873e819f6ca67" translate="yes" xml:space="preserve">
          <source>This is useful for lengthy calculations that depend on a dynamic data source.</source>
          <target state="translated">이는 동적 데이터 소스에 의존하는 긴 계산에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="5e3a9f91b15e29dd03dbbaa3f14fa9c0ea902d2b" translate="yes" xml:space="preserve">
          <source>This project is documented using the &lt;a href=&quot;https://github.com/numpy/numpy/blob/master/doc/HOWTO_DOCUMENT.rst.txt&quot;&gt;numpy docstring conventions&lt;/a&gt;, which were chosen as they are perhaps the most widely-spread conventions that are both supported by common tools such as Sphinx and result in human-readable docstrings (in my personal opinion, of course). When documenting code you add to this project, please follow &lt;a href=&quot;https://github.com/numpy/numpy/blob/master/doc/HOWTO_DOCUMENT.rst.txt&quot;&gt;these conventions&lt;/a&gt;.</source>
          <target state="translated">이 프로젝트는 &lt;a href=&quot;https://github.com/numpy/numpy/blob/master/doc/HOWTO_DOCUMENT.rst.txt&quot;&gt;numpy 독 스트링 규칙을&lt;/a&gt; 사용하여 문서화되었습니다.이 규칙 은 Sphinx와 같은 일반적인 도구에서 지원하고 사람이 읽을 수있는 독 스트링을 생성하는 가장 널리 퍼진 규칙이기 때문에 선택되었습니다. 이 프로젝트에 추가하는 코드를 문서화 할 때 &lt;a href=&quot;https://github.com/numpy/numpy/blob/master/doc/HOWTO_DOCUMENT.rst.txt&quot;&gt;다음 규칙을&lt;/a&gt; 따르십시오 .</target>
        </trans-unit>
        <trans-unit id="d6ed9424b0bf428af630a45ef086f454c9751dbd" translate="yes" xml:space="preserve">
          <source>This will prevent reading the cache file on each cache read, speeding things up a bit, while also nullifying inter-thread functionality (the code is still thread safe, but different threads will have different versions of the cache at times, and will sometime make unnecessary function calls).</source>
          <target state="translated">이렇게하면 각 캐시 읽기에서 캐시 파일을 읽는 것을 방지하고 작업 속도를 높이는 동시에 스레드 간 기능을 무효화 할 수 있습니다 (코드는 여전히 스레드 안전하지만 다른 스레드는 때때로 다른 버전의 캐시를 가지며 언젠가는 불필요한 함수 호출).</target>
        </trans-unit>
        <trans-unit id="7184dc6d1888a8cd5f95d77fe614c2d5cbdae377" translate="yes" xml:space="preserve">
          <source>Thread-safety.</source>
          <target state="translated">스레드 안전성.</target>
        </trans-unit>
        <trans-unit id="85075d46e62374545f38d529e1ce2894579848b7" translate="yes" xml:space="preserve">
          <source>To run the tests, use:</source>
          <target state="translated">테스트를 실행하려면 다음을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="88b33e4e12f75ac8bf792aebde41f1a090f3a612" translate="yes" xml:space="preserve">
          <source>True</source>
          <target state="translated">진실</target>
        </trans-unit>
        <trans-unit id="1d4d43cc6f3a833e0340a0d1794b6d7b9958657e" translate="yes" xml:space="preserve">
          <source>Use</source>
          <target state="translated">사용하다</target>
        </trans-unit>
        <trans-unit id="ec523f870ffe73c6cb867d15120b990291d7a1aa" translate="yes" xml:space="preserve">
          <source>Verbose Cache Call</source>
          <target state="translated">Verbose Cache Call</target>
        </trans-unit>
        <trans-unit id="ecadf77c167c3456c2abfee388ba27a2408c5d16" translate="yes" xml:space="preserve">
          <source>Working with unhashable arguments</source>
          <target state="translated">해시 할 수없는 인수 작업</target>
        </trans-unit>
        <trans-unit id="6be0f5c4c27d575412c88c047bbaf395ae6a9c0e" translate="yes" xml:space="preserve">
          <source>You can add a default, pickle-based, persistent cache to your function - meaning it will last across different Python kernels calling the wrapped function - by decorating it with the</source>
          <target state="translated">함수에 기본, 피클 기반의 영구 캐시를 추가 할 수 있습니다. 즉, 래핑 된 함수를 호출하는 여러 Python 커널에서 지속됩니다.</target>
        </trans-unit>
        <trans-unit id="49fddf8851061f1494f32053795e5506592e53bd" translate="yes" xml:space="preserve">
          <source>You can configure</source>
          <target state="translated">구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b7e239658d29aa242a3a03e14e0d55e96a101faf" translate="yes" xml:space="preserve">
          <source>You can get the fully qualified path to the directory of cache files used by</source>
          <target state="translated">에서 사용하는 캐시 파일의 디렉토리에 대한 완전한 경로를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a09c32f46d01d7b214108f5d34f668cf41814456" translate="yes" xml:space="preserve">
          <source>You can have</source>
          <target state="translated">당신은 가질 수 있습니다</target>
        </trans-unit>
        <trans-unit id="37da9562f95c42d49b6dc50a001f288e2462da25" translate="yes" xml:space="preserve">
          <source>You can set a MongoDB-based cache by assigning</source>
          <target state="translated">MongoDB 기반 캐시를 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="69b8bcc418bf42924034a6e6027e3298ef1cd351" translate="yes" xml:space="preserve">
          <source>You can set any duration as the shelf life of cached return values of a function by providing a corresponding</source>
          <target state="translated">해당 기간을 제공하여 함수의 캐시 된 반환 값의 유효 기간을 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ea2253517fd9a1942a64d5fbdc7cb65b351a8275" translate="yes" xml:space="preserve">
          <source>You can slightly optimise pickle-based caching if you know your code will only be used in a single thread environment by setting:</source>
          <target state="translated">다음을 설정하여 코드가 단일 스레드 환경에서만 사용된다는 것을 알고 있다면 피클 기반 캐싱을 약간 최적화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="17f9f9ea6a8cabefa26354ebaf84c1cb7a0e669d" translate="yes" xml:space="preserve">
          <source>by default) by calling the</source>
          <target state="translated">기본적으로)</target>
        </trans-unit>
        <trans-unit id="943fd08e21be8c211effe5646ae93d24b4953a34" translate="yes" xml:space="preserve">
          <source>cache_dir</source>
          <target state="translated">cache_dir</target>
        </trans-unit>
        <trans-unit id="fc04b41d746aade203f2f1116ae46531d9b0ccbf" translate="yes" xml:space="preserve">
          <source>cache_dpath()</source>
          <target state="translated">cache_dpath ()</target>
        </trans-unit>
        <trans-unit id="4fbf98b670de0e87ed74da8f425dd1a2bf2c5f15" translate="yes" xml:space="preserve">
          <source>cachier</source>
          <target state="translated">Cachier</target>
        </trans-unit>
        <trans-unit id="6405eb3aa0bf918bef6ccd2c7a59a6d517d7fdca" translate="yes" xml:space="preserve">
          <source>clear_cache()</source>
          <target state="translated">clear_cache ()</target>
        </trans-unit>
        <trans-unit id="268ac1088e9156a29d90bd406f07973cf2d4ead1" translate="yes" xml:space="preserve">
          <source>decorator (notice the</source>
          <target state="translated">데코레이터 (</target>
        </trans-unit>
        <trans-unit id="5cb8118a19c4bcf707996d44256a04d527479ace" translate="yes" xml:space="preserve">
          <source>decorator can be provided with a callable that gets the args and kwargs from the decorated function and returns a hash key for them.</source>
          <target state="translated">데코레이터는 데코 레이팅 된 함수에서 인수와 kwargs를 가져와 해시 키를 반환하는 콜 러블과 함께 제공 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="692619d762ccc0152433ecf7042819426be553da" translate="yes" xml:space="preserve">
          <source>directory. Naturally, this kind of cache is both machine-specific and user-specific.</source>
          <target state="translated">예배 규칙서. 당연히 이러한 종류의 캐시는 시스템마다 다르며 사용자마다 다릅니다.</target>
        </trans-unit>
        <trans-unit id="d828b1ef4a3fc648615997943a705cfcd5f1a45d" translate="yes" xml:space="preserve">
          <source>function to each wrapped function. To reset the cache of the wrapped function simply call this method:</source>
          <target state="translated">각 래핑 된 함수에 함수. 래핑 된 함수의 캐시를 재설정하려면 다음 메서드를 호출하면됩니다.</target>
        </trans-unit>
        <trans-unit id="1dfae75987ab2c547d85f2eedd53692b234672e0" translate="yes" xml:space="preserve">
          <source>function:</source>
          <target state="translated">함수:</target>
        </trans-unit>
        <trans-unit id="39ef1df9f3c2574b9f5b17ea97aaf727f95378b5" translate="yes" xml:space="preserve">
          <source>hash_params</source>
          <target state="translated">hash_params</target>
        </trans-unit>
        <trans-unit id="4f96136e69b99e31e1103d170617cab2880f5569" translate="yes" xml:space="preserve">
          <source>ignore any existing cache for a specific function call by passing</source>
          <target state="translated">전달하여 특정 함수 호출에 대한 기존 캐시를 무시합니다.</target>
        </trans-unit>
        <trans-unit id="0bcf6f5c751e824b70527ad40a64cfe08ab0b2d3" translate="yes" xml:space="preserve">
          <source>ignore_cache=True</source>
          <target state="translated">ignore_cache = 참</target>
        </trans-unit>
        <trans-unit id="43fd6eeb2ca43fb4d39fab01758a9cdfad59d46e" translate="yes" xml:space="preserve">
          <source>mongetter</source>
          <target state="translated">몽 게터</target>
        </trans-unit>
        <trans-unit id="071cbb0d73f35caada63d23592aa40a90a99be1f" translate="yes" xml:space="preserve">
          <source>next_time</source>
          <target state="translated">next_time</target>
        </trans-unit>
        <trans-unit id="cb37b70cbef5a43f1b34b6de71c6690065f8a6bf" translate="yes" xml:space="preserve">
          <source>object to the</source>
          <target state="translated">에 반대하다</target>
        </trans-unit>
        <trans-unit id="83f217d33dd3b2bef4ecbaad0fcdd9a4bee43f9c" translate="yes" xml:space="preserve">
          <source>object with writing permissions:</source>
          <target state="translated">쓰기 권한이있는 개체 :</target>
        </trans-unit>
        <trans-unit id="1bc618bef32305253848df2dfab299ca0775b15d" translate="yes" xml:space="preserve">
          <source>overwrite an existing cache entry - if one exists - for a specific function call by passing</source>
          <target state="translated">전달하여 특정 함수 호출에 대해 기존 캐시 항목 (있는 경우)을 덮어 씁니다.</target>
        </trans-unit>
        <trans-unit id="1cf41e8f669824d9c3412a34c25923c4450856dc" translate="yes" xml:space="preserve">
          <source>overwrite_cache=True</source>
          <target state="translated">overwrite_cache = 참</target>
        </trans-unit>
        <trans-unit id="43e5c7eecb2d3f1deb9e4618471ef5eb22af1ee5" translate="yes" xml:space="preserve">
          <source>parameter of the</source>
          <target state="translated">매개 변수</target>
        </trans-unit>
        <trans-unit id="9ef2f8ace50c9e18d95ea57b385e20d9d73e70a4" translate="yes" xml:space="preserve">
          <source>parameter with the path to that directory:</source>
          <target state="translated">해당 디렉토리 경로가있는 매개 변수 :</target>
        </trans-unit>
        <trans-unit id="bd2a0f5ff9872c4fb53012a32fc945714cec69e7" translate="yes" xml:space="preserve">
          <source>parameter:</source>
          <target state="translated">매개 변수 :</target>
        </trans-unit>
        <trans-unit id="9af3a2dc436aaf0e87970b9d0d357a87ee073312" translate="yes" xml:space="preserve">
          <source>print out a detailed explanation of the logic of a specific call by passing</source>
          <target state="translated">전달하여 특정 호출의 논리에 대한 자세한 설명을 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="2fb96b514a8ad2cc749969aeeb375de53ee188e7" translate="yes" xml:space="preserve">
          <source>pymongo</source>
          <target state="translated">피 몬고</target>
        </trans-unit>
        <trans-unit id="e33c5e100375494f1c86202478ee15788119e6ac" translate="yes" xml:space="preserve">
          <source>pymongo.Collection</source>
          <target state="translated">pymongo.Collection</target>
        </trans-unit>
        <trans-unit id="b0dbd8e9151f3fd900cdc9e5a53f37ef18a112f9" translate="yes" xml:space="preserve">
          <source>python package.</source>
          <target state="translated">파이썬 패키지.</target>
        </trans-unit>
        <trans-unit id="34505a8098e5fcb0582b1c9db55fc7851e039497" translate="yes" xml:space="preserve">
          <source>stale_after</source>
          <target state="translated">stale_after</target>
        </trans-unit>
        <trans-unit id="c1f72fbadf2daff20c945f18078ad8f6d5b5b223" translate="yes" xml:space="preserve">
          <source>time has since passed, the function will be run again for the same arguments and the new value will be cached and returned.</source>
          <target state="translated">시간이 지나면 동일한 인수에 대해 함수가 다시 실행되고 새 값이 캐시되고 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="74962d37bf1cb045da5386cecce96f2b7b6bc2e6" translate="yes" xml:space="preserve">
          <source>timedelta</source>
          <target state="translated">timedelta</target>
        </trans-unit>
        <trans-unit id="4374aaee247fb237ce6c97d5c8d64bbe474d16de" translate="yes" xml:space="preserve">
          <source>to</source>
          <target state="translated">에</target>
        </trans-unit>
        <trans-unit id="15bf9f4122b7e8ba17a99a2a08538b63e1d6205e" translate="yes" xml:space="preserve">
          <source>to have your function trigger a recalculation &lt;strong&gt;in a separate thread&lt;/strong&gt;, but return the currently cached stale value:</source>
          <target state="translated">함수 &lt;strong&gt;가 별도의 스레드에서&lt;/strong&gt; 재 계산 &lt;strong&gt;을&lt;/strong&gt; 트리거하도록 하지만 현재 캐시 된 부실 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="fbde8376553198493927b83cefcaa52320217062" translate="yes" xml:space="preserve">
          <source>to the function call. The cache will neither be checked nor updated with the new return value.</source>
          <target state="translated">함수 호출에. 캐시는 새 반환 값으로 확인되거나 업데이트되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="bacf89622bfe072162c0a9036069a8a8784b8f6b" translate="yes" xml:space="preserve">
          <source>to the function call. The cache will not be checked but will be updated with the new return value.</source>
          <target state="translated">함수 호출에. 캐시는 확인되지 않지만 새 반환 값으로 업데이트됩니다.</target>
        </trans-unit>
        <trans-unit id="5d5d2f650a33457708e1991c324e2d188789f923" translate="yes" xml:space="preserve">
          <source>to the function call. This can be useful if you are not sure why a certain function result is, or is not, returned.</source>
          <target state="translated">함수 호출에. 특정 함수 결과가 반환되거나 반환되지 않는 이유를 모르는 경우 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="87ba19b359dd9b96802bdeac2d8fed68133e74ba" translate="yes" xml:space="preserve">
          <source>to use another directory by providing the</source>
          <target state="translated">제공하여 다른 디렉토리를 사용하려면</target>
        </trans-unit>
        <trans-unit id="8ffb4c66d744bf0b095062777f02a26f7280acfb" translate="yes" xml:space="preserve">
          <source>verbose_cache=True</source>
          <target state="translated">verbose_cache = 참</target>
        </trans-unit>
        <trans-unit id="908448b98001f4a2c7b2a90b25ac220c1bf6ce5d" translate="yes" xml:space="preserve">
          <source>with a callable that returns a</source>
          <target state="translated">반환하는 콜 러블과 함께</target>
        </trans-unit>
        <trans-unit id="52e0612303b39c0691e807b9c7a297fa35003367" translate="yes" xml:space="preserve">
          <source>with:</source>
          <target state="translated">와:</target>
        </trans-unit>
        <trans-unit id="27f5343120ff3f20919d9f0a2bf9b73cb6fd9cde" translate="yes" xml:space="preserve">
          <source>~/.cachier</source>
          <target state="translated">~ / .cachier</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
