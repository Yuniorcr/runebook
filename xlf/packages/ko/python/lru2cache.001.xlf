<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://pypi.org/project/lru2cache/">
    <body>
      <group id="lru2cache">
        <trans-unit id="6d6173d566ffb20c8641ba2752b927248f8ab6c3" translate="yes" xml:space="preserve">
          <source>, function arguments of different types will be
cached separately. For example, f(3) and f(3.0) will be treated as distinct
calls with distinct results.</source>
          <target state="translated">, 다른 유형의 함수 인수는 별도로 캐시됩니다. 예를 들어, f (3) 및 f (3.0)은 고유 한 결과가있는 고유 한 호출로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="7207846477fc222c6dd0427e85462ac564927fea" translate="yes" xml:space="preserve">
          <source>, the LRU feature is disabled and the L1 cache
can grow without bound. The LRU feature performs best when maxsize is a power-of-two.</source>
          <target state="translated">, LRU 기능이 비활성화되고 L1 캐시가 제한없이 커질 수 있습니다. LRU 기능은 maxsize가 2의 거듭 제곱 일 때 가장 잘 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="d99d3502cdad96aa76d33d37c0cc8a9682cf6459" translate="yes" xml:space="preserve">
          <source>. These stats are stored within an instance, and therefore
are specific to that instance. Cumulative statistics for the shared cache would
need to be obtained from the shared cache.</source>
          <target state="translated">. 이러한 통계는 인스턴스 내에 저장되므로 해당 인스턴스에 고유합니다. 공유 캐시에 대한 누적 통계는 공유 캐시에서 얻어야합니다.</target>
        </trans-unit>
        <trans-unit id="2be5d9e9d6ec5fbbfff0627d5ceb897a4d377376" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Local and Shared Cache&lt;/strong&gt; - Combining both types of cache is much more
effective than either used on it&amp;rsquo;s own.  The local cache eliminates the
latency of calls to a shared cache, while the shared cache eliminates
the expense of returning the result</source>
          <target state="translated">&lt;strong&gt;로컬 및 공유 캐시&lt;/strong&gt; -두 유형의 캐시를 결합하는 것이 자체적으로 사용하는 것보다 훨씬 효과적입니다. 로컬 캐시는 공유 캐시에 대한 호출 대기 시간을 제거하고 공유 캐시는 결과 반환 비용을 제거합니다.</target>
        </trans-unit>
        <trans-unit id="3a61811019e173a17190bff6fd9ad90f453f5c97" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The Ability to Not Cache None Results&lt;/strong&gt; - This may seem like a minor thing
but in our environment it has greatly reduced the frequency of cache
invalidations.</source>
          <target state="translated">&lt;strong&gt;캐시하지 않는 기능 없음 결과&lt;/strong&gt; -이것은 사소한 것처럼 보일 수 있지만 우리 환경에서는 캐시 무효화 빈도를 크게 줄였습니다.</target>
        </trans-unit>
        <trans-unit id="4d15addbdae92bf79453914d11dea5bbd5322f8d" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;http://en.wikipedia.org/wiki/Cache_algorithms#Least_Recently_Used&quot;&gt;least recently used (LRU)&lt;/a&gt;
2 layer caching mechanism based in part on the Python 2.7 back-port of</source>
          <target state="translated">&lt;a href=&quot;http://en.wikipedia.org/wiki/Cache_algorithms#Least_Recently_Used&quot;&gt;최근 최소 사용 (LRU)&lt;/a&gt; 2 층 캐싱 메커니즘의 파이썬 2.7 후면 포트에 부분적으로 기초</target>
        </trans-unit>
        <trans-unit id="3efcd57fb6b3d75f3484be9e543fff6a457c01c9" translate="yes" xml:space="preserve">
          <source>A least recently used (LRU) 2 layer caching mechanism based in part on the Python 2.7 back-port of lru_cache</source>
          <target state="translated">lru_cache의 Python 2.7 백 포트를 부분적으로 기반으로하는 가장 최근에 사용 된 (LRU) 2 계층 캐싱 메커니즘</target>
        </trans-unit>
        <trans-unit id="32e4be867670ced87f1b50b35d669b04ce0f3a8b" translate="yes" xml:space="preserve">
          <source>A shared cache can easily be cleared with the following:</source>
          <target state="translated">공유 캐시는 다음과 같이 쉽게 지울 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b6ad70fe8987a492b217f1d3fdc6bc56a8799161" translate="yes" xml:space="preserve">
          <source>Accessing the Function without Cache</source>
          <target state="translated">캐시없이 함수에 액세스</target>
        </trans-unit>
        <trans-unit id="37e1c7c46791ba8b13b32bdb24bd8673a2f3fe3e" translate="yes" xml:space="preserve">
          <source>As a starting point I incorporated most of the tests for</source>
          <target state="translated">시작점으로 나는 대부분의 테스트를 통합했습니다.</target>
        </trans-unit>
        <trans-unit id="3938496e65e6dd032b899a42196062cb85acaa7a" translate="yes" xml:space="preserve">
          <source>As with lru_cache, one can view the cache statistics via a named tuple
(l1_hits, l1_misses, l2_hits, l2_misses, l1_maxsize, l1_currsize), with</source>
          <target state="translated">lru_cache와 마찬가지로 명명 된 튜플 (l1_hits, l1_misses, l2_hits, l2_misses, l1_maxsize, l1_currsize)을 통해 캐시 통계를 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6bbdf159e71b2fcdfa75bfaf3c0ec17a80b21b52" translate="yes" xml:space="preserve">
          <source>At &lt;a href=&quot;http://www.3top.com/&quot;&gt;3Top&lt;/a&gt; We needed a way to improve performance of
slow queries, not just those using the Django ORM, but also for queries to
other data stores and services.  We started off with a simpler centralized
caching solution using Memcached, but even those queries, when called frequently,
can start to cause delays.  Therefore we sought a means of caching at two layers.</source>
          <target state="translated">에서 &lt;a href=&quot;http://www.3top.com/&quot;&gt;3Top&lt;/a&gt; 우리는 단지 장고 ORM을 사용하는 사람들뿐만 아니라 다른 데이터 저장소 및 서비스에 대한 쿼리 속도가 느린 쿼리의 성능을 향상시킬 수있는 방법이 필요했습니다. 우리는 Memcached를 사용하는 더 간단한 중앙 집중식 캐싱 솔루션으로 시작했지만 자주 호출되는 쿼리조차도 지연을 유발할 수 있습니다. 따라서 우리는 두 계층에서 캐싱하는 방법을 찾았습니다.</target>
        </trans-unit>
        <trans-unit id="aeaf0e85f848b550a565ca5901e53d4306577d16" translate="yes" xml:space="preserve">
          <source>Background and Development</source>
          <target state="translated">배경 및 개발</target>
        </trans-unit>
        <trans-unit id="a086c0543fd27c08b64c003ddb4513c6845eb29a" translate="yes" xml:space="preserve">
          <source>Benefits Over functools.lru_cache</source>
          <target state="translated">functools.lru_cache에 대한 이점</target>
        </trans-unit>
        <trans-unit id="d2469c2aa14798195f6bc3ae16fcf004712ca85e" translate="yes" xml:space="preserve">
          <source>Cache Management</source>
          <target state="translated">캐시 관리</target>
        </trans-unit>
        <trans-unit id="35242c52a20b0f631fccc4a7c16ed23a76be06bd" translate="yes" xml:space="preserve">
          <source>Cache Statistics</source>
          <target state="translated">캐시 통계</target>
        </trans-unit>
        <trans-unit id="53a0d2b5765f8ae251aea63864f78dac2259b0d7" translate="yes" xml:space="preserve">
          <source>Clearing Instance Cache</source>
          <target state="translated">인스턴스 캐시 지우기</target>
        </trans-unit>
        <trans-unit id="bf5dec3573c5a5d21ca6a1425613a8510bf9f271" translate="yes" xml:space="preserve">
          <source>Clearing Shared Cache</source>
          <target state="translated">공유 캐시 지우기</target>
        </trans-unit>
        <trans-unit id="751c68a3471b1c791efaee0a8e7c24ea0c266efd" translate="yes" xml:space="preserve">
          <source>If</source>
          <target state="translated">만약</target>
        </trans-unit>
        <trans-unit id="95f76da19cad315076ccc2afaa0e41daf973ca96" translate="yes" xml:space="preserve">
          <source>If available this package will use SpookyHash V2 as a hashing mechanism.
Spooky is a good fast hashing algorithm that should be suitable for most uses.
If it is not available the package will fall back to SHA-256 from the standard
hashlib.  Because SHA-256 is a proper cryptographic hash it requires more
computation than Spooky.  To install spooky use pip:</source>
          <target state="translated">가능한 경우이 패키지는 SpookyHash V2를 해싱 메커니즘으로 사용합니다. Spooky는 대부분의 용도에 적합해야하는 좋은 빠른 해싱 알고리즘입니다. 사용할 수없는 경우 패키지는 표준 hashlib에서 SHA-256으로 대체됩니다. SHA-256은 적절한 암호화 해시이기 때문에 Spooky보다 더 많은 계산이 필요합니다. 유령을 설치하려면 pip를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="bd872a8af71a679a7a57ab648b7308f8099f311d" translate="yes" xml:space="preserve">
          <source>If you do not want to use either</source>
          <target state="translated">둘 중 하나를 사용하지 않으려면</target>
        </trans-unit>
        <trans-unit id="f20cd38b0f0d290cf5aa2dda99bb5da47f90a908" translate="yes" xml:space="preserve">
          <source>Initially we looked at the possibility of using two different mechanisms but
we quickly saw the advantage of maintaining the same set of keys for both
caches and decided to create our own mechanism.</source>
          <target state="translated">처음에 우리는 두 가지 다른 메커니즘을 사용할 수있는 가능성을 살펴 보았지만 두 캐시에 대해 동일한 키 세트를 유지하는 이점을 빠르게 확인하고 자체 메커니즘을 만들기로 결정했습니다.</target>
        </trans-unit>
        <trans-unit id="debd19f419480deae2e24d7b2b4c8018a365b90e" translate="yes" xml:space="preserve">
          <source>Installation &amp;amp; Configuration</source>
          <target state="translated">설치 및 구성</target>
        </trans-unit>
        <trans-unit id="cc1093a96d4b2482bcaf84ac72db0fe4a89cb2c3" translate="yes" xml:space="preserve">
          <source>Invalidating Cached Results</source>
          <target state="translated">캐시 된 결과 무효화</target>
        </trans-unit>
        <trans-unit id="6eef6648406c333a4035cd5e60d0bf2ecf2606d7" translate="yes" xml:space="preserve">
          <source>None</source>
          <target state="translated">없음</target>
        </trans-unit>
        <trans-unit id="5cfe5bbe5ae1dcb900a59525d853591e69656103" translate="yes" xml:space="preserve">
          <source>Once lru2cache is installed you will need to configure a shared cache as an
l2 cache.  If you are using Django your settings file will contain something
similar to the following in the settings file:</source>
          <target state="translated">lru2cache가 설치되면 공유 캐시를 l2 캐시로 구성해야합니다. Django를 사용하는 경우 설정 파일에 다음과 유사한 내용이 설정 파일에 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="5da6bc6ba91b6bc6224f81e28bb845e36941f36f" translate="yes" xml:space="preserve">
          <source>Refreshing the Cache</source>
          <target state="translated">캐시 새로 고침</target>
        </trans-unit>
        <trans-unit id="3fc5f2545bc12aba6c4ecc7066bfa0304189551b" translate="yes" xml:space="preserve">
          <source>Since the lru2cache decorator does not provide a timeout for its cache although
it provides other mechanisms for programatically managing the cache.</source>
          <target state="translated">lru2cache 데코레이터는 캐시를 프로그래밍 방식으로 관리하기위한 다른 메커니즘을 제공하지만 캐시에 대한 시간 초과를 제공하지 않기 때문에.</target>
        </trans-unit>
        <trans-unit id="39fdec1194d94212b871a28b2aa04a73cd40fce1" translate="yes" xml:space="preserve">
          <source>Tests</source>
          <target state="translated">테스트</target>
        </trans-unit>
        <trans-unit id="1d0165a592656f6dd286443745686b0cd7caff47" translate="yes" xml:space="preserve">
          <source>The easiest and best way to install this is with pip:</source>
          <target state="translated">이것을 설치하는 가장 쉽고 가장 좋은 방법은 pip를 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="b4358f486357d25333aa98b7ac1dc2af818fc3e0" translate="yes" xml:space="preserve">
          <source>The first layer of caching is stored in a callable that wraps the function or
method.  As with &amp;lsquo;functools.lru_cache&amp;rsquo; a dict is used to store the cached
results, therefore positional and keyword arguments must be hashable. Each
instance stores up to</source>
          <target state="translated">캐싱의 첫 번째 계층은 함수 또는 메서드를 래핑하는 콜 러블에 저장됩니다. 'functools.lru_cache'와 마찬가지로 dict는 캐시 된 결과를 저장하는 데 사용되므로 위치 및 키워드 인수는 해시 가능해야합니다. 각 인스턴스는 최대</target>
        </trans-unit>
        <trans-unit id="0ea4401b5713b542a1e261e03fdcbec558a8d19b" translate="yes" xml:space="preserve">
          <source>The second layer of caching requires a shared cache that can make use of
Django&amp;rsquo;s cache framework.  In this case it is assumed that any LRU mechanism
is handled by the shared cache backend.</source>
          <target state="translated">두 번째 캐싱 계층에는 Django의 캐시 프레임 워크를 사용할 수있는 공유 캐시가 필요합니다. 이 경우 모든 LRU 메커니즘은 공유 캐시 백엔드에서 처리한다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="176ea28590869923dcfef77790d0be6e85b0bc24" translate="yes" xml:space="preserve">
          <source>The un-cached underlying function can always be accessed with</source>
          <target state="translated">캐시되지 않은 기본 함수는 항상 다음을 사용하여 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d8e2dde7858b0f625a6bbfb5559beee48b1cb949" translate="yes" xml:space="preserve">
          <source>This arrangement allows a process that accesses a function multiple times to
retrieve the value without the expense of requesting it from a shared cache,
while still allowing different processes to access the result from the shared
cache.</source>
          <target state="translated">이러한 배열을 통해 함수에 여러 번 액세스하는 프로세스는 공유 캐시에서 값을 요청하지 않고도 값을 검색 할 수있는 동시에 다른 프로세스가 공유 캐시의 결과에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="75b9de2bd29cbf6751c7a36363a0fd751ecacea2" translate="yes" xml:space="preserve">
          <source>This is not yet implemented as a function but can be accomplished by first calling
invalidate and then calling the function</source>
          <target state="translated">이것은 아직 함수로 구현되지 않았지만 먼저 invalidate를 호출 한 다음 함수를 호출하여 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6c5e4c3c083a750c34b9adaef009aac85d3924c6" translate="yes" xml:space="preserve">
          <source>This was developed by &lt;a href=&quot;http://www.3top.com/team&quot;&gt;3Top, Inc.&lt;/a&gt; for use with
our ranking and recommendation platform, &lt;a href=&quot;http://www.3top.com&quot;&gt;http://www.3top.com&lt;/a&gt;.</source>
          <target state="translated">이것은 &lt;a href=&quot;http://www.3top.com/team&quot;&gt;3Top, Inc.&lt;/a&gt; 에서 순위 및 추천 플랫폼 인 &lt;a href=&quot;http://www.3top.com&quot;&gt;http://www.3top.com&lt;/a&gt; 과 함께 사용하기 위해 개발했습니다 .</target>
        </trans-unit>
        <trans-unit id="fde1a31e15e42e88afb165e49cb21121fae29131" translate="yes" xml:space="preserve">
          <source>To invalidate the cache for a specific set of arguments, including the instance
one can pass the same arguments to invalidate the both L1 and L2 caches:</source>
          <target state="translated">인스턴스를 포함하여 특정 인수 집합에 대한 캐시를 무효화하려면 동일한 인수를 전달하여 L1 및 L2 캐시를 모두 무효화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="88b33e4e12f75ac8bf792aebde41f1a090f3a612" translate="yes" xml:space="preserve">
          <source>True</source>
          <target state="translated">진실</target>
        </trans-unit>
        <trans-unit id="0bb18642b70b9f8a9c12ccf39487328f306b8e19" translate="yes" xml:space="preserve">
          <source>Usage</source>
          <target state="translated">용법</target>
        </trans-unit>
        <trans-unit id="3b2cb96142ae431c2df3de4bb6b9a4cbca498afc" translate="yes" xml:space="preserve">
          <source>Usage is as simple as adding the decorator to a function or method as seen in
the below examples from our test cases:</source>
          <target state="translated">사용은 테스트 사례의 아래 예제에서 볼 수있는 것처럼 함수 나 메서드에 데코레이터를 추가하는 것만 큼 간단합니다.</target>
        </trans-unit>
        <trans-unit id="b8b4346e8782d546f582feeaec684daca029da8b" translate="yes" xml:space="preserve">
          <source>We used a backport python 3</source>
          <target state="translated">백 포트 파이썬 3을 사용했습니다.</target>
        </trans-unit>
        <trans-unit id="235811c1759d45111475d5266bc6a107245df52d" translate="yes" xml:space="preserve">
          <source>and if not found fall back to</source>
          <target state="translated">발견되지 않으면 다시</target>
        </trans-unit>
        <trans-unit id="b204bca289d16df380a96f6adc203c95eff37534" translate="yes" xml:space="preserve">
          <source>decorator as a starting
point for developing an in instance cache with LRU capabilities.  However we
needed to ensure the keys would also be unique enough to use with a shared
cache. We leverage Django&amp;rsquo;s excellent cache framework for managing the layer 2
cache. This allows the use of any shared cache supported by Django.</source>
          <target state="translated">데코레이터를 LRU 기능이있는 인스턴스 캐시를 개발하기위한 시작점으로 사용합니다. 그러나 키가 공유 캐시와 함께 사용할 수있을만큼 고유한지 확인해야했습니다. 우리는 레이어 2 캐시를 관리하기 위해 Django의 뛰어난 캐시 프레임 워크를 활용합니다. 이를 통해 Django에서 지원하는 모든 공유 캐시를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7505d64a54e061b7acd54ccd58b49dc43500b635" translate="yes" xml:space="preserve">
          <source>default</source>
          <target state="translated">기본</target>
        </trans-unit>
        <trans-unit id="778b425edf8ec003eb2a0a2d8a7a2a3d54043356" translate="yes" xml:space="preserve">
          <source>f.__wrapped__</source>
          <target state="translated">f .__ wrapped__</target>
        </trans-unit>
        <trans-unit id="cf8c707a6006ea42369c462118f8380268597325" translate="yes" xml:space="preserve">
          <source>f.cache_info()</source>
          <target state="translated">f.cache_info ()</target>
        </trans-unit>
        <trans-unit id="54800f8bd035a18cec9a83721a2f0d9901a88020" translate="yes" xml:space="preserve">
          <source>functools.lru_cache</source>
          <target state="translated">functools.lru_cache</target>
        </trans-unit>
        <trans-unit id="dcfadac569c49917e69f513a3e245fd1d6b2c92c" translate="yes" xml:space="preserve">
          <source>functools.lru_cache()</source>
          <target state="translated">functools.lru_cache ()</target>
        </trans-unit>
        <trans-unit id="c589e370d15354bfa1c43ff28cafcd54ca93fbb2" translate="yes" xml:space="preserve">
          <source>however if it is not you will
need to specify what attribute should be used.</source>
          <target state="translated">그러나 그렇지 않은 경우 어떤 속성을 사용해야하는지 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="87ea5dfc8b8e384d848979496e706390b497e547" translate="yes" xml:space="preserve">
          <source>id</source>
          <target state="translated">신분증</target>
        </trans-unit>
        <trans-unit id="958f57f57d72a30f329ee5538f21b0257a49a46e" translate="yes" xml:space="preserve">
          <source>if</source>
          <target state="translated">만약</target>
        </trans-unit>
        <trans-unit id="894f317b9160e13f41fd9889fbe20573a6a2fa51" translate="yes" xml:space="preserve">
          <source>in the case of a method you do need to explicitly pass the instance as in the
following:</source>
          <target state="translated">메서드의 경우 다음과 같이 명시 적으로 인스턴스를 전달해야합니다.</target>
        </trans-unit>
        <trans-unit id="99578a0572cb4666f7da4c6317812a1795e90db6" translate="yes" xml:space="preserve">
          <source>inst_attr</source>
          <target state="translated">inst_attr</target>
        </trans-unit>
        <trans-unit id="b47f363e2b430c0647f14deea3eced9b0ef300ce" translate="yes" xml:space="preserve">
          <source>is</source>
          <target state="translated">이다</target>
        </trans-unit>
        <trans-unit id="04aea98291c14f68c64d647870dcc66791bebff3" translate="yes" xml:space="preserve">
          <source>is set to</source>
          <target state="translated">로 설정</target>
        </trans-unit>
        <trans-unit id="203a495a6685bc90041befff86795808f8e82182" translate="yes" xml:space="preserve">
          <source>is specified it will be used as the shared cache.  Otherwise
it will attempt to use a cache named</source>
          <target state="translated">지정되면 공유 캐시로 사용됩니다. 그렇지 않으면 다음과 같은 캐시를 사용하려고 시도합니다.</target>
        </trans-unit>
        <trans-unit id="f6d6ab6f2a5f07bb043396b6eddd6c513b490bbb" translate="yes" xml:space="preserve">
          <source>is the attribute used to uniquely identify an object when wrapping
a method.  In Django this will typically be</source>
          <target state="translated">메서드를 래핑 할 때 개체를 고유하게 식별하는 데 사용되는 속성입니다. 장고에서 이것은 일반적으로</target>
        </trans-unit>
        <trans-unit id="4e35854b464fbca3f62f573e0ebc966a5c2346df" translate="yes" xml:space="preserve">
          <source>l1_maxsize</source>
          <target state="translated">l1_maxsize</target>
        </trans-unit>
        <trans-unit id="24239dc31cf7b79a3dd81e391ffb9cf6b8f43413" translate="yes" xml:space="preserve">
          <source>l2cache</source>
          <target state="translated">l2cache</target>
        </trans-unit>
        <trans-unit id="d25a4bf33e3adbcb4faa3349bda74f43c379251e" translate="yes" xml:space="preserve">
          <source>l2cache_name</source>
          <target state="translated">l2cache_name</target>
        </trans-unit>
        <trans-unit id="67962b5f93ab7e7aee26271b6434367efdebeb0c" translate="yes" xml:space="preserve">
          <source>lru2cache is a decorator that can be used with any user function or method to
cache the most recent results in a local cache and using the django cache
framework to cache results in a shared cache.</source>
          <target state="translated">lru2cache는 모든 사용자 함수 또는 메서드와 함께 사용하여 로컬 캐시에 최신 결과를 캐시하고 django 캐시 프레임 워크를 사용하여 공유 캐시에 결과를 캐시 할 수있는 데코레이터입니다.</target>
        </trans-unit>
        <trans-unit id="a0b82c9aec209c2aeba44c98d6e0f5ac1eeb0366" translate="yes" xml:space="preserve">
          <source>none_cache</source>
          <target state="translated">none_cache</target>
        </trans-unit>
        <trans-unit id="1758356db21759f7c5a0da9b4dd1db8fd6feab3f" translate="yes" xml:space="preserve">
          <source>or</source>
          <target state="translated">또는</target>
        </trans-unit>
        <trans-unit id="7bb544dbb5a0825498324c9261119887b51048a7" translate="yes" xml:space="preserve">
          <source>results that vary on the arguments. The
discarding of the LRU cached values is handled by the decorator.</source>
          <target state="translated">인수에 따라 다른 결과. LRU 캐시 된 값의 폐기는 데코레이터에 의해 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="32800976dbaf3bf9a9490995b0c0f0b6bbb55857" translate="yes" xml:space="preserve">
          <source>results will be cached, otherwise they
will not.</source>
          <target state="translated">결과는 캐시되고 그렇지 않으면 캐시되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d820aa5f8750fdde33200083b0702a32578a6c95" translate="yes" xml:space="preserve">
          <source>than</source>
          <target state="translated">보다</target>
        </trans-unit>
        <trans-unit id="80df4a04d26c83f618293af30f0535e20afd7329" translate="yes" xml:space="preserve">
          <source>the cache and statistics associated with a function or method can be cleared with:</source>
          <target state="translated">함수 또는 메서드와 관련된 캐시 및 통계는 다음을 사용하여 지울 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bda4b1c3ce007842c38ded3638ca7730d8a8aae7" translate="yes" xml:space="preserve">
          <source>typed</source>
          <target state="translated">입력</target>
        </trans-unit>
        <trans-unit id="dcfac732a9fac915f0831ba3d8ab666199413e95" translate="yes" xml:space="preserve">
          <source>with minor changes to make them work with python 2.7
and incorporated the l2_cache stats. We will continue to add tests to validate
the additional functionality provided by this decorator.</source>
          <target state="translated">python 2.7에서 작동하도록 약간 변경하고 l2_cache 통계를 통합했습니다. 이 데코레이터가 제공하는 추가 기능을 검증하기위한 테스트를 계속 추가 할 것입니다.</target>
        </trans-unit>
        <trans-unit id="290239353d61d53048fdeae4868e219f2dd57e54" translate="yes" xml:space="preserve">
          <source>you will need to
specify the name of the cache.</source>
          <target state="translated">캐시 이름을 지정해야합니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
