<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://pypi.org/project/aiodnsresolver/">
    <body>
      <group id="aiodnsresolver">
        <trans-unit id="5271bccbbe941ae52abb53cc0fecaec4be011917" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://nvd.nist.gov/vuln/detail/CVE-2017-2909&quot;&gt;Pointer loops&lt;/a&gt; are detected.</source>
          <target state="translated">&lt;a href=&quot;https://nvd.nist.gov/vuln/detail/CVE-2017-2909&quot;&gt;포인터 루프&lt;/a&gt; 가 감지됩니다.</target>
        </trans-unit>
        <trans-unit id="929dca150227ac071b7a3bc11408a076f3f42dcd" translate="yes" xml:space="preserve">
          <source>A cache is part of each &lt;code&gt;Resolver()&lt;/code&gt;, expiring records automatically according to their TTL.</source>
          <target state="translated">캐시는 각 &lt;code&gt;Resolver()&lt;/code&gt; 일부이며 TTL에 따라 자동으로 레코드가 만료됩니다.</target>
        </trans-unit>
        <trans-unit id="211b06c40eb506400c76ecdf544257469ed37a5b" translate="yes" xml:space="preserve">
          <source>A higher risk assumption is that many tests use the, otherwise private, &lt;code&gt;pack&lt;/code&gt; and &lt;code&gt;parse&lt;/code&gt; functions as part of the built-in DNS server that is used by the tests. These are the core functions used by the production code used to pack and parse DNS messages. While asserting that the resolver can communicate to the built-in nameserver, all the tests do is assert that &lt;code&gt;pack&lt;/code&gt; and &lt;code&gt;parse&lt;/code&gt; are consistent with each other: it is an assumption that other nameservers have equivalent behaviour.</source>
          <target state="translated">더 높은 위험 가정은 많은 테스트가 테스트에서 사용 되는 기본 제공 DNS 서버의 일부로 비공개, &lt;code&gt;pack&lt;/code&gt; 및 &lt;code&gt;parse&lt;/code&gt; 기능을 사용한다는 것입니다. 이는 DNS 메시지를 압축하고 구문 분석하는 데 사용되는 프로덕션 코드에서 사용하는 핵심 기능입니다. 리졸버가 내장 네임 서버와 통신 할 수 있다고 주장하는 동안, 모든 테스트는 &lt;code&gt;pack&lt;/code&gt; 과 &lt;code&gt;parse&lt;/code&gt; 가 서로 일관성이 있다고 주장하는 것입니다. 다른 네임 서버가 동일한 동작을한다는 가정입니다.</target>
        </trans-unit>
        <trans-unit id="5e187dda81d772797388202838eb2eeeac356582" translate="yes" xml:space="preserve">
          <source>A maximum of two messages per DNS query are logged at &lt;code&gt;INFO&lt;/code&gt;. If a nameserver fails, a &lt;code&gt;WARNING&lt;/code&gt; is issued [although an exception will be raised if no nameservers succeed], and the remainder of messages are logged at &lt;code&gt;DEBUG&lt;/code&gt;. No &lt;code&gt;ERROR&lt;/code&gt; or &lt;code&gt;CRITICAL&lt;/code&gt; messages are issued when exceptions are raised: it is the responsiblity of client code to log these if desired.</source>
          <target state="translated">DNS 쿼리 당 최대 2 개의 메시지가 &lt;code&gt;INFO&lt;/code&gt; 에 기록됩니다 . 네임 서버가 실패하면 &lt;code&gt;WARNING&lt;/code&gt; 이 발행되고 [네임 서버가 성공하지 않으면 예외가 발생하지만] 나머지 메시지는 &lt;code&gt;DEBUG&lt;/code&gt; 에 기록됩니다 . 예외가 발생할 때 &lt;code&gt;ERROR&lt;/code&gt; 또는 &lt;code&gt;CRITICAL&lt;/code&gt; 메시지가 발행 되지 않습니다 . 원하는 경우이를 기록하는 것은 클라이언트 코드의 책임입니다.</target>
        </trans-unit>
        <trans-unit id="51f7f0ed3e00a224445ea9af92863e69074b3f06" translate="yes" xml:space="preserve">
          <source>A new socket, and so a new random local port, is used for each query.</source>
          <target state="translated">새로운 소켓과 새로운 임의의 로컬 포트가 각 쿼리에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="9100aca195719601490d3778547d5c3de3ae9465" translate="yes" xml:space="preserve">
          <source>Also, to migitate the risk of evil responses/configuration</source>
          <target state="translated">또한 악의적 인 응답 / 구성의 위험을 완화하기 위해</target>
        </trans-unit>
        <trans-unit id="52e9f6aaf6e7b4bf71883e35141db1b9fcfd8250" translate="yes" xml:space="preserve">
          <source>Asyncio Python DNS resolver. Pure Python, with no dependencies other than the standard library, threads are not used, no additional tasks are created, and all code is in a single module. The nameservers to query are taken from &lt;code&gt;/etc/resolv.conf&lt;/code&gt;, and treats hosts in &lt;code&gt;/etc/hosts&lt;/code&gt; as A or AAAA records with a TTL of 0.</source>
          <target state="translated">Asyncio Python DNS 해석기. 표준 라이브러리 이외의 종속성이없는 순수 Python은 스레드가 사용되지 않고 추가 작업이 생성되지 않으며 모든 코드가 단일 모듈에 있습니다. 쿼리 할 네임 서버는 &lt;code&gt;/etc/resolv.conf&lt;/code&gt; 에서 가져 오며 &lt;code&gt;/etc/hosts&lt;/code&gt; 의 호스트 를 TTL이 0 인 A 또는 AAAA 레코드로 처리합니다.</target>
        </trans-unit>
        <trans-unit id="61a84ef6505fac2720810c22f65c1971715da98b" translate="yes" xml:space="preserve">
          <source>By default each domain name is encoded with &lt;a href=&quot;https://astrolavos.gatech.edu/articles/increased_dns_resistance.pdf&quot;&gt;0x20-bit encoding&lt;/a&gt; before being sent to the nameservers. However, some nameservers, such as Docker's built-in, do not support this. So, to control or disable the encoding, you can pass a custom &lt;code&gt;transform_fqdn&lt;/code&gt; coroutine to Resolver that does not perform any additional encoding.</source>
          <target state="translated">기본적으로 각 도메인 이름은 네임 서버로 전송되기 전에 &lt;a href=&quot;https://astrolavos.gatech.edu/articles/increased_dns_resistance.pdf&quot;&gt;0x20 비트 인코딩으로 인코딩&lt;/a&gt; 됩니다. 그러나 Docker의 내장과 같은 일부 네임 서버는이를 지원하지 않습니다. 따라서 인코딩을 제어하거나 비활성화하려면 사용자 정의 &lt;code&gt;transform_fqdn&lt;/code&gt; 코 루틴을 추가 인코딩을 수행하지 않는 Resolver에 전달할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e4c00516cc8b5ef50215908476d463b79c1132af" translate="yes" xml:space="preserve">
          <source>By default each domain name is encoded with &lt;a href=&quot;https://astrolavos.gatech.edu/articles/increased_dns_resistance.pdf&quot;&gt;0x20-bit encoding&lt;/a&gt;, which is checked against any response.</source>
          <target state="translated">기본적으로 각 도메인 이름은 &lt;a href=&quot;https://astrolavos.gatech.edu/articles/increased_dns_resistance.pdf&quot;&gt;0x20 비트 인코딩으로 인코딩&lt;/a&gt; 되며 모든 응답에 대해 확인됩니다.</target>
        </trans-unit>
        <trans-unit id="503d0636b431f0d0a6b8edd31c135f4675377d16" translate="yes" xml:space="preserve">
          <source>By default logging is through the &lt;code&gt;Logger&lt;/code&gt; named &lt;code&gt;aiodnsresolver&lt;/code&gt;, and all messages are prefixed with &lt;code&gt;[dns]&lt;/code&gt; or &lt;code&gt;[dns:&amp;lt;fqdn&amp;gt;,&amp;lt;query-type&amp;gt;]&lt;/code&gt; through a &lt;code&gt;LoggerAdapter&lt;/code&gt;. Each function accepts &lt;code&gt;get_logger_adapter&lt;/code&gt;: the default of which results in this behaviour, and can be overridden to set either the &lt;code&gt;Logger&lt;/code&gt; or the &lt;code&gt;LoggerAdapter&lt;/code&gt;.</source>
          <target state="translated">기본적으로 로깅 통해 &lt;code&gt;Logger&lt;/code&gt; 라는 &lt;code&gt;aiodnsresolver&lt;/code&gt; 모든 메시지는 접두어 &lt;code&gt;[dns]&lt;/code&gt; 또는 &lt;code&gt;[dns:&amp;lt;fqdn&amp;gt;,&amp;lt;query-type&amp;gt;]&lt;/code&gt; 관통 &lt;code&gt;LoggerAdapter&lt;/code&gt; . 각 함수는 &lt;code&gt;get_logger_adapter&lt;/code&gt; 를 허용 합니다 . 기본값은이 동작을 초래하며 &lt;code&gt;Logger&lt;/code&gt; 또는 &lt;code&gt;LoggerAdapter&lt;/code&gt; 를 설정하도록 재정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="83abfbe2bfed3c1a456c2d7e47463ba5e76f0bf5" translate="yes" xml:space="preserve">
          <source>CNAME chains have a maximum length.</source>
          <target state="translated">CNAME 체인에는 최대 길이가 있습니다.</target>
        </trans-unit>
        <trans-unit id="73ab091294665e57efeb4610bc88824653477946" translate="yes" xml:space="preserve">
          <source>CNAME records are followed transparently. The &lt;code&gt;expires_at&lt;/code&gt; of IP addresses found via intermediate CNAME(s) is determined by using the minimum &lt;code&gt;expires_at&lt;/code&gt; of all the records involved in determining those IP addresses.</source>
          <target state="translated">CNAME 레코드는 투명하게 추적됩니다. 중간 CNAME을 통해 발견 된 IP 주소 의 &lt;code&gt;expires_at&lt;/code&gt; 는 해당 IP 주소를 결정하는 데 관련된 모든 레코드 의 최소 &lt;code&gt;expires_at&lt;/code&gt; 를 사용하여 결정됩니다 .</target>
        </trans-unit>
        <trans-unit id="86ce9e2117503436712e78317ab8f9b96432ceac" translate="yes" xml:space="preserve">
          <source>CNAMEs</source>
          <target state="translated">CNAME</target>
        </trans-unit>
        <trans-unit id="50338b3b242845e21a0ace9ae9684283d945fb52" translate="yes" xml:space="preserve">
          <source>Cache</source>
          <target state="translated">은닉처</target>
        </trans-unit>
        <trans-unit id="2061cc2c0ce561bb4de9ddce9e6148ae313ff804" translate="yes" xml:space="preserve">
          <source>Chaining logging adapters</source>
          <target state="translated">로깅 어댑터 연결</target>
        </trans-unit>
        <trans-unit id="8c053f773becf89e1d9c570970fcb6dea5254931" translate="yes" xml:space="preserve">
          <source>Custom hosts</source>
          <target state="translated">커스텀 호스트</target>
        </trans-unit>
        <trans-unit id="95f255134c54184a554be6e3edb813828ba95cc9" translate="yes" xml:space="preserve">
          <source>Custom nameservers and timeouts</source>
          <target state="translated">커스텀 네임 서버 및 타임 아웃</target>
        </trans-unit>
        <trans-unit id="4331f6e2659b79348247b80b3a69e3c78192b683" translate="yes" xml:space="preserve">
          <source>Designed for highly concurrent/HA situations. Based on &lt;a href=&quot;https://github.com/gera2ld/async_dns&quot;&gt;https://github.com/gera2ld/async_dns&lt;/a&gt;.</source>
          <target state="translated">동시성 / HA 상황에 맞게 설계되었습니다. &lt;a href=&quot;https://github.com/gera2ld/async_dns&quot;&gt;https://github.com/gera2ld/async_dns&lt;/a&gt; 기반 .</target>
        </trans-unit>
        <trans-unit id="7d4318283b3f106b523e323d9909c77fc9121b46" translate="yes" xml:space="preserve">
          <source>Disable 0x20-bit encoding</source>
          <target state="translated">0x20 비트 인코딩 비활성화</target>
        </trans-unit>
        <trans-unit id="325543124cab344013bc013d35cbe2a615311047" translate="yes" xml:space="preserve">
          <source>Each query is given a random ID, which is checked against any response.</source>
          <target state="translated">각 쿼리에는 응답에 대해 확인되는 임의의 ID가 부여됩니다.</target>
        </trans-unit>
        <trans-unit id="8d63cc4af916c7b99a241bad8b0d502181c245e4" translate="yes" xml:space="preserve">
          <source>Event loop, tasks, and yielding</source>
          <target state="translated">이벤트 루프, 작업 및 양보</target>
        </trans-unit>
        <trans-unit id="8f118b077e6a503af07b266e698154147805e76c" translate="yes" xml:space="preserve">
          <source>Example: aiohttp</source>
          <target state="translated">예 : aiohttp</target>
        </trans-unit>
        <trans-unit id="db74fe5b20374d125b242d991f69908b127e41ce" translate="yes" xml:space="preserve">
          <source>Example: lowhaio</source>
          <target state="translated">예 : lowhaio</target>
        </trans-unit>
        <trans-unit id="daa475826a7caf2c8d6e1edf8f9fcbc611880db5" translate="yes" xml:space="preserve">
          <source>Example: tornado</source>
          <target state="translated">예 : 토네이도</target>
        </trans-unit>
        <trans-unit id="cd3dfbe79fda3a9d92de67b1bd4f1dc9f60ab723" translate="yes" xml:space="preserve">
          <source>Exceptions</source>
          <target state="translated">예외</target>
        </trans-unit>
        <trans-unit id="5e214e6879427a717b554f7c20bad14ac9ba6048" translate="yes" xml:space="preserve">
          <source>Exceptions are subclasses of &lt;code&gt;DnsError&lt;/code&gt;, and are raised if a record does not exist, on socket errors, timeouts, message parsing errors, or other errors returned from the nameserver.</source>
          <target state="translated">예외는 &lt;code&gt;DnsError&lt;/code&gt; 의 하위 클래스이며 , 레코드가 존재하지 않는 경우 소켓 오류, 시간 초과, 메시지 구문 분석 오류 또는 네임 서버에서 반환 된 기타 오류에 대해 발생합니다.</target>
        </trans-unit>
        <trans-unit id="5481c7b8170c168b824c771b6718a3b6d2901efe" translate="yes" xml:space="preserve">
          <source>For CNAME chains, the event loop is yielded during each communication for non-cached parts of the chain.</source>
          <target state="translated">CNAME 체인의 경우, 체인의 캐시되지 않은 부분에 대한 각 통신 중에 이벤트 루프가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="d1ce204dbf3ac8a86a74a6e0f2ade815849b3dd0" translate="yes" xml:space="preserve">
          <source>For complex or highly concurrent applications, it may be desirable that logging adapters be chained to output log messages that incorporate a parent context. So the default ouput of</source>
          <target state="translated">복잡하거나 동시성이 높은 응용 프로그램의 경우 로깅 어댑터를 연결하여 상위 컨텍스트를 통합하는 로그 메시지를 출력하는 것이 바람직 할 수 있습니다. 따라서 기본 출력은</target>
        </trans-unit>
        <trans-unit id="37b6d39ee4f6fbd194c7fcc66f1205f74e971cac" translate="yes" xml:space="preserve">
          <source>If a lower-level exception caused the &lt;code&gt;DnsError&lt;/code&gt;, it will be in the &lt;code&gt;__cause__&lt;/code&gt; attribute of the exception.</source>
          <target state="translated">하위 수준 예외로 인해 &lt;code&gt;DnsError&lt;/code&gt; 가 발생하면 예외 의 &lt;code&gt;__cause__&lt;/code&gt; 속성에 있습니다.</target>
        </trans-unit>
        <trans-unit id="c81b79df3c6448eae7c4f80428b54cd5692a17d7" translate="yes" xml:space="preserve">
          <source>Installation</source>
          <target state="translated">설치</target>
        </trans-unit>
        <trans-unit id="98c528a0f6bb272f1be116323214c541e9884abd" translate="yes" xml:space="preserve">
          <source>It is possible to query nameservers other than those in &lt;code&gt;/etc/resolv.conf&lt;/code&gt;, and for each to specify a timeout in seconds to wait for a reply before querying the next.</source>
          <target state="translated">&lt;code&gt;/etc/resolv.conf&lt;/code&gt; 에 있는 것 이외의 이름 서버를 쿼리 하고 각각에 대해 다음을 쿼리하기 전에 응답을 기다리는 시간 제한 (초)을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="15c9db7d7fff447ccf33673477c532475866aef0" translate="yes" xml:space="preserve">
          <source>It is technically possible that in the case of extremely high numbers of A or AAAA records for a domain, they would not fit in a single UDP message. However, this is extremely unlikely, and in this unlikely case, extremely unlikely to affect target applications in any meaningful way. If a truncated message is received, a warning is logged.</source>
          <target state="translated">기술적으로 도메인에 대한 A 또는 AAAA 레코드 수가 매우 많은 경우 단일 UDP 메시지에 맞지 않을 수 있습니다. 그러나 이는 매우 드물고,이 경우에는 의미있는 방식으로 대상 응용 프로그램에 영향을 미칠 가능성이 매우 낮습니다. 잘린 메시지가 수신되면 경고가 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="24c4c96f064c57e2f915eb36267d9c1af72b39d9" translate="yes" xml:space="preserve">
          <source>It's possible to specify hosts without editing the &lt;code&gt;/etc/hosts&lt;/code&gt; file.</source>
          <target state="translated">&lt;code&gt;/etc/hosts&lt;/code&gt; 파일 을 편집하지 않고 호스트를 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="81abd20921dba1c2e53084d841b924ad28377ed3" translate="yes" xml:space="preserve">
          <source>Log levels</source>
          <target state="translated">로그 수준</target>
        </trans-unit>
        <trans-unit id="57003616863fe634c645e342ee9080681e419c5f" translate="yes" xml:space="preserve">
          <source>Logging</source>
          <target state="translated">벌채 반출</target>
        </trans-unit>
        <trans-unit id="bf89335514117c4e318f57395975d95081d6e290" translate="yes" xml:space="preserve">
          <source>Many tests assume that timeouts are controlled by &lt;code&gt;asyncio.sleep&lt;/code&gt;, &lt;code&gt;loop.call_later&lt;/code&gt; or &lt;code&gt;loop.call_at&lt;/code&gt;. This is to allow time to be fast-forwarded through cache invalidation using &lt;a href=&quot;https://github.com/michalc/aiofastforward&quot;&gt;aiofastforward&lt;/a&gt; without actually having to wait the corresponding time in the tests. Also, many tests assume &lt;code&gt;open&lt;/code&gt; is used to access files, and patch it to allow assertions on what the code would do with different contents of &lt;code&gt;/etc/resolv.conf&lt;/code&gt; or &lt;code&gt;/etc/hosts&lt;/code&gt;.</source>
          <target state="translated">많은 테스트에서는 시간 초과가 &lt;code&gt;asyncio.sleep&lt;/code&gt; , &lt;code&gt;loop.call_later&lt;/code&gt; 또는 &lt;code&gt;loop.call_at&lt;/code&gt; 에 의해 제어된다고 가정합니다 . 이것은 실제로 테스트에서 해당 시간을 기다릴 필요없이 &lt;a href=&quot;https://github.com/michalc/aiofastforward&quot;&gt;aiofastforward&lt;/a&gt; 를 사용하여 캐시 무효화를 통해 시간을 빨리 감을 수 있도록하기 위함 입니다. 또한 많은 테스트에서는 &lt;code&gt;open&lt;/code&gt; 이 파일에 액세스하는 데 사용 된다고 가정 하고 패치를 패치하여 코드가 &lt;code&gt;/etc/resolv.conf&lt;/code&gt; 또는 &lt;code&gt;/etc/hosts&lt;/code&gt; 의 다른 내용으로 수행 할 작업에 대한 주장을 허용 합니다 .</target>
        </trans-unit>
        <trans-unit id="47e6cc73f64a548366be4705e275679eeccea863" translate="yes" xml:space="preserve">
          <source>No extra code is needed to use aiodnsresolver with &lt;a href=&quot;https://github.com/michalc/lowhaio&quot;&gt;lowhaio&lt;/a&gt;: it is used by default.</source>
          <target state="translated">lowhaio와 함께 &lt;a href=&quot;https://github.com/michalc/lowhaio&quot;&gt;aiodnsresolver&lt;/a&gt; 를 사용하는 데 추가 코드가 필요하지 않습니다 . 기본적으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="0dd8a289d527539de842bf7f512ddc6f16bab278" translate="yes" xml:space="preserve">
          <source>No tasks are created, and the event loop is only yielded to during socket communication. Because fetching results from the cache involves no socket communication, this means that cached results are fetched without yielding. This introduces a small inconsistency between fetching cached and non-cached results, and so clients should be written to not depend on the presence or lack of a yield during resolution. This is a typically recommended process however: it should be expected that coroutines might yield.</source>
          <target state="translated">작업이 생성되지 않으며 이벤트 루프는 소켓 통신 중에 만 발생합니다. 캐시에서 결과를 가져 오는 것은 소켓 통신을 포함하지 않기 때문에 이는 캐시 된 결과를 양보하지 않고 가져옴을 의미합니다. 이로 인해 캐시 된 결과와 캐시되지 않은 결과를 가져 오는 것 사이에 약간의 불일치가 발생하므로 클라이언트는 확인하는 동안 수율의 존재 또는 부족에 의존하지 않도록 작성해야합니다. 그러나 이것은 일반적으로 권장되는 프로세스입니다. 코 루틴이 생성 될 수 있음을 예상해야합니다.</target>
        </trans-unit>
        <trans-unit id="13af06a45ae2e367e0503ca4e7145d79f1f7d234" translate="yes" xml:space="preserve">
          <source>Parallel requests to multiple nameservers are also possible, where the first response from each set of requests is used.</source>
          <target state="translated">각 요청 집합의 첫 번째 응답이 사용되는 여러 네임 서버에 대한 병렬 요청도 가능합니다.</target>
        </trans-unit>
        <trans-unit id="7fd5bb751b3ce87db39b88c5e968bcfa48b440a4" translate="yes" xml:space="preserve">
          <source>Pure asyncio Python DNS resolver</source>
          <target state="translated">순수 asyncio Python DNS 해석기</target>
        </trans-unit>
        <trans-unit id="bef2a4699d00603b20da781b86d5845c0046fb44" translate="yes" xml:space="preserve">
          <source>Requests made for a domain while there is an in-flight query for that domain, wait for the the in-flight query to finish, and use its result.</source>
          <target state="translated">해당 도메인에 대한 진행중인 쿼리가있는 동안 도메인에 대한 요청은 진행중인 쿼리가 완료 될 때까지 기다린 다음 그 결과를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="c1ada94ed2819eb16c6fe64f64fb6e10147a7afd" translate="yes" xml:space="preserve">
          <source>Returned are tuples of subclasses of &lt;a href=&quot;https://docs.python.org/3/library/ipaddress.html#ipaddress.IPv4Address&quot;&gt;IPv4Address&lt;/a&gt; or &lt;a href=&quot;https://docs.python.org/3/library/ipaddress.html#ipaddress.IPv6Address&quot;&gt;IPv6Address&lt;/a&gt;. Both support conversion to their usual string form by passing them to &lt;code&gt;str&lt;/code&gt;.</source>
          <target state="translated">반환되는 것은 &lt;a href=&quot;https://docs.python.org/3/library/ipaddress.html#ipaddress.IPv4Address&quot;&gt;IPv4Address&lt;/a&gt; 또는 &lt;a href=&quot;https://docs.python.org/3/library/ipaddress.html#ipaddress.IPv6Address&quot;&gt;IPv6Address&lt;/a&gt; 하위 클래스의 튜플입니다 . 둘 다 &lt;code&gt;str&lt;/code&gt; 에 전달하여 일반적인 문자열 형식으로의 변환을 지원합니다 .</target>
        </trans-unit>
        <trans-unit id="4651a34e4df9619783ad372f905d6d3b84e9d76d" translate="yes" xml:space="preserve">
          <source>Scope</source>
          <target state="translated">범위</target>
        </trans-unit>
        <trans-unit id="2931d5d3232f2248933a3926c6bcfde0392f4223" translate="yes" xml:space="preserve">
          <source>Security considerations</source>
          <target state="translated">보안 고려 사항</target>
        </trans-unit>
        <trans-unit id="d4bcd58ee108472a46cd86b218d9752854fdfe5c" translate="yes" xml:space="preserve">
          <source>Specifically, if a record is determined to not exist, &lt;code&gt;DnsRecordDoesNotExist&lt;/code&gt; is raised.</source>
          <target state="translated">특히 레코드가 존재하지 않는 것으로 확인되면 &lt;code&gt;DnsRecordDoesNotExist&lt;/code&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="fd95ae54dec0b2580591259365e6f9ec1bc37a56" translate="yes" xml:space="preserve">
          <source>TTL / Record expiry</source>
          <target state="translated">TTL / 레코드 만료</target>
        </trans-unit>
        <trans-unit id="d84c76a661a2d9eed7c499c29179e4493a22dfb7" translate="yes" xml:space="preserve">
          <source>Testing strategy</source>
          <target state="translated">테스트 전략</target>
        </trans-unit>
        <trans-unit id="724d10488fa0d7f2fcdb5593b3ca64e996ef7b86" translate="yes" xml:space="preserve">
          <source>Tests attempt to closly match real-world use, and assert on how input translate to output, i.e. the &lt;em&gt;public&lt;/em&gt; behaviour of the resolver. Therefore the tests avoid assumptions on implementation details.</source>
          <target state="translated">테스트는 실제 사용과 밀접하게 일치하고 입력이 출력으로 변환되는 방식, 즉 리졸버 의 &lt;em&gt;공개&lt;/em&gt; 동작을 주장합니다 . 따라서 테스트는 구현 세부 사항에 대한 가정을 피합니다.</target>
        </trans-unit>
        <trans-unit id="8c7516866aa18f7d36f81b46de3023d136af8722" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;LoggerAdapter&lt;/code&gt; used by &lt;code&gt;resolve&lt;/code&gt; and &lt;code&gt;clear_cache&lt;/code&gt; defaults to the one passed to &lt;code&gt;Resolver&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;LoggerAdapter&lt;/code&gt; 은 에 의해 사용되는 &lt;code&gt;resolve&lt;/code&gt; 및 &lt;code&gt;clear_cache&lt;/code&gt; 에 전달 된 하나에 기본적으로 &lt;code&gt;Resolver&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="466b71a3cf44833cb3278ebc0b07a27c257d9e55" translate="yes" xml:space="preserve">
          <source>The address objects each have an extra property, &lt;code&gt;expires_at&lt;/code&gt;, that returns the expiry time of the address, according to the &lt;code&gt;loop.time()&lt;/code&gt; clock, and the TTL of the records involved to find that address.</source>
          <target state="translated">주소 객체는 각각 &lt;code&gt;loop.time()&lt;/code&gt; 시계 에 따라 주소의 만료 시간을 반환 하는 추가 속성 인 &lt;code&gt;expires_at&lt;/code&gt; 와 해당 주소를 찾는 데 관련된 레코드의 TTL을 가지고 있습니다.</target>
        </trans-unit>
        <trans-unit id="9e9f8b0ae56b3bb4ce43ae4f8e3ab8863677bbde" translate="yes" xml:space="preserve">
          <source>The cache for each record starts on the &lt;em&gt;start&lt;/em&gt; of each request, so duplicate concurrent requests for the same record are not made.</source>
          <target state="translated">각 레코드의 캐시 는 각 요청 이 &lt;em&gt;시작될&lt;/em&gt; 때 &lt;em&gt;시작&lt;/em&gt; 되므로 동일한 레코드에 대한 중복 동시 요청이 만들어지지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a30c90204c5ee38410b23c24343172c003f232be" translate="yes" xml:space="preserve">
          <source>The resolver is a &lt;em&gt;stub&lt;/em&gt; resolver: it delegates the responsibility of recursion to the nameserver(s) it queries. In the vast majority of envisioned use cases this is acceptable, since the nameservers in &lt;code&gt;/etc/resolv.conf&lt;/code&gt; will be recursive.</source>
          <target state="translated">리졸버는 &lt;em&gt;스텁&lt;/em&gt; 리졸버입니다. 재귀의 책임을 쿼리하는 네임 서버에 위임합니다. &lt;code&gt;/etc/resolv.conf&lt;/code&gt; 의 네임 서버 가 재귀 적이기 때문에 구상 된 대부분의 사용 사례에서 이것은 허용 됩니다.</target>
        </trans-unit>
        <trans-unit id="ad52e794eb4fcc06ecc4985810a0f8022f6a02b9" translate="yes" xml:space="preserve">
          <source>The scope of this project is deliberately restricted to operations that are used to resolve A or AAAA records: to resolve a domain name to its IP addresses so that IP connections can be made, and have similar responsibilities to &lt;code&gt;gethostbyname&lt;/code&gt;. Some limited extra behaviour is present/may be added, but great care is taken to prevent scope creep, especially to not add complexity that isn't required to resolve A or AAAA records.</source>
          <target state="translated">이 프로젝트의 범위는 의도적으로 A 또는 AAAA 레코드를 확인하는 데 사용되는 작업으로 제한됩니다. 즉, 도메인 이름을 IP 주소로 확인하여 IP 연결을 만들 수 있고 &lt;code&gt;gethostbyname&lt;/code&gt; 과 유사한 책임을 갖습니다 . 일부 제한적인 추가 동작이 존재하거나 추가 될 수 있지만 범위 이동을 방지하기 위해 특히 A 또는 AAAA 레코드를 확인하는 데 필요하지 않은 복잡성을 추가하지 않도록 세심한주의를 기울입니다.</target>
        </trans-unit>
        <trans-unit id="57e4103bc66f1c02c2c9e171ff330eee6102ce2e" translate="yes" xml:space="preserve">
          <source>The trade-off for this inconsistency is that cached results are fetched slightly faster than if resolving were to yield in all cases.</source>
          <target state="translated">이 불일치에 대한 절충점은 모든 경우에 해결이 산출되는 경우보다 캐시 된 결과를 약간 더 빠르게 가져 오는 것입니다.</target>
        </trans-unit>
        <trans-unit id="568b9215249186337b28f4ddd655addeb1beaa3b" translate="yes" xml:space="preserve">
          <source>There are however exceptions.</source>
          <target state="translated">그러나 예외가 있습니다.</target>
        </trans-unit>
        <trans-unit id="b70f278fda8094a172d4312fe7f6e058f3578c19" translate="yes" xml:space="preserve">
          <source>This can be used as part of a HA system: if a nameserver isn't contactable, this pattern avoids waiting for its timeout before querying another nameserver.</source>
          <target state="translated">이것은 HA 시스템의 일부로 사용할 수 있습니다. 이름 서버에 연결할 수없는 경우이 패턴은 다른 이름 서버를 쿼리하기 전에 시간 초과를 기다리는 것을 방지합니다.</target>
        </trans-unit>
        <trans-unit id="cbcd6514ef7beea9d2b0457fb1fbbe2b4b520b8e" translate="yes" xml:space="preserve">
          <source>This can be used in HA situations to assist failovers. The timer for &lt;code&gt;expires_at&lt;/code&gt; starts just &lt;em&gt;before&lt;/em&gt; the request to the nameserver is made.</source>
          <target state="translated">HA 상황에서 장애 조치를 지원하는 데 사용할 수 있습니다. 대한 타이머 &lt;code&gt;expires_at&lt;/code&gt; 은 단지 시작 &lt;em&gt;하기 전에&lt;/em&gt; 네임 서버에 대한 요청이됩니다.</target>
        </trans-unit>
        <trans-unit id="69758f85250db2d85cf4c9bb890236bb8f46f07d" translate="yes" xml:space="preserve">
          <source>To do this, set &lt;code&gt;get_logger_adapter&lt;/code&gt; as a function that chains multiple &lt;code&gt;LoggerAdapter&lt;/code&gt;.</source>
          <target state="translated">이렇게하려면 &lt;code&gt;get_logger_adapter&lt;/code&gt; 를 여러 &lt;code&gt;LoggerAdapter&lt;/code&gt; 를 연결하는 함수로 설정 합니다.</target>
        </trans-unit>
        <trans-unit id="e5453419f7808d077e72a0951df66da4d335a1ef" translate="yes" xml:space="preserve">
          <source>To migitate spoofing, several techniques are used.</source>
          <target state="translated">스푸핑을 완화하기 위해 몇 가지 기술이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="fdac2c4c6b417e4e42de66d3df4d768bdf14bb25" translate="yes" xml:space="preserve">
          <source>To mitigate the risks that these assumptions bring, some &quot;end to end&quot;-style tests are included, which use whatever nameservers are in &lt;code&gt;/etc/resolv.conf&lt;/code&gt;, and asserting on globally available DNS results. While not going through every possible case of input, they do validate that core behaviour is consistent with one other implementation of the protocol.</source>
          <target state="translated">이러한 가정이 가져 오는 위험을 완화하기 위해 &lt;code&gt;/etc/resolv.conf&lt;/code&gt; 에있는 이름 서버를 사용 하고 전역 적으로 사용 가능한 DNS 결과에 대해 주장하는 일부 &quot;종단 간&quot;스타일 테스트가 포함 됩니다. 가능한 모든 입력 사례를 거치지는 않지만 핵심 동작이 프로토콜의 다른 구현과 일치하는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="ee99461aee3846058cc1f0f7023e131f12d74143" translate="yes" xml:space="preserve">
          <source>UDP queries are made, but not TCP. DNS servers must support UDP, and it's impossible for a single A and AAAA record to not fit into the maximum size of a UDP DNS response, 512 bytes. There may be other data that the DNS server would return in TCP connections, but this isn't required to resolve a domain name to a single IP address.</source>
          <target state="translated">UDP 쿼리는 작성되지만 TCP는 작성되지 않습니다. DNS 서버는 UDP를 지원해야하며 단일 A 및 AAAA 레코드가 UDP DNS 응답의 최대 크기 인 512 바이트에 맞지 않는 것은 불가능합니다. DNS 서버가 TCP 연결에서 반환하는 다른 데이터가있을 수 있지만 이는 도메인 이름을 단일 IP 주소로 확인하는 데 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0bb18642b70b9f8a9c12ccf39487328f306b8e19" translate="yes" xml:space="preserve">
          <source>Usage</source>
          <target state="translated">용법</target>
        </trans-unit>
        <trans-unit id="e3eb7e120df55fe0ce4ae5e02b1795d6bc597530" translate="yes" xml:space="preserve">
          <source>While both being assumptions, they are both unlikely to change, and in the case that they are changed, this would much more likely result in tests failing incorrectly rather than passing incorrectly. Therefore these are low-risk assumptions.</source>
          <target state="translated">둘 다 가정이지만 둘 다 변경 될 가능성이 낮으며 변경된 경우 테스트가 잘못 통과하지 않고 잘못 실패 할 가능성이 훨씬 더 높습니다. 따라서 이것은 위험이 낮은 가정입니다.</target>
        </trans-unit>
        <trans-unit id="f7cccc0372b47247d5fc2e3825d4126fb7823822" translate="yes" xml:space="preserve">
          <source>aiodnsresolver</source>
          <target state="translated">aiodnsresolver</target>
        </trans-unit>
        <trans-unit id="08aea82c41d0ad520a61ea165d592487b6c577fe" translate="yes" xml:space="preserve">
          <source>or performs it conditionally</source>
          <target state="translated">또는 조건부로 수행</target>
        </trans-unit>
        <trans-unit id="e329b5389944db05ea8909e826a45be38a49022b" translate="yes" xml:space="preserve">
          <source>would be prefixed with a &lt;em&gt;parent&lt;/em&gt; context to output something like</source>
          <target state="translated">다음과 같은 출력 을 위해 &lt;em&gt;부모&lt;/em&gt; 컨텍스트 가 접두사로 붙습니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
