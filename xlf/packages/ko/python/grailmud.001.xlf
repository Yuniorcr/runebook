<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://pypi.org/project/grailmud/">
    <body>
      <group id="grailmud">
        <trans-unit id="35a20710a67ce1d93ad224463fb892934456cb89" translate="yes" xml:space="preserve">
          <source>&amp;rsquo;s code and add the goblin
logic in there.</source>
          <target state="translated">의 코드를 입력하고 거기에 고블린 로직을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="69f1a772a103f106040e1e5fc7bdb6ed21c404c8" translate="yes" xml:space="preserve">
          <source>A Python MUD server</source>
          <target state="translated">Python MUD 서버</target>
        </trans-unit>
        <trans-unit id="f660583deb8d9a1fc5042fb8a1c14a8a4d2e2c65" translate="yes" xml:space="preserve">
          <source>Decoupling object logic and object state results in promoting &amp;lsquo;controllers&amp;rsquo;
(or as they ended up being called in the codebase, &lt;em&gt;delegates&lt;/em&gt;, in the Self
tradition) to first-class objects which can be added or removed from objects
at will. So if you want a staff to suddenly start acting like a goblin chief,
it becomes as simple as this:</source>
          <target state="translated">객체 로직과 객체 상태를 분리하면 '컨트롤러'(또는 Self 전통에서 코드베이스에서 호출되는 &lt;em&gt;위임자&lt;/em&gt; )를 원하는대로 객체에서 추가하거나 제거 할 수있는 일급 객체 로 승격 시킵니다. 따라서 직원이 갑자기 고블린 족장처럼 행동하기 시작하려면 다음과 같이 간단 해집니다.</target>
        </trans-unit>
        <trans-unit id="2f580c18380983d909ab8ed0e762474eba7adc85" translate="yes" xml:space="preserve">
          <source>One result of the decoupling of display and game logic is that the difference
between player avatars and NPCs becomes the &amp;lsquo;controller&amp;rsquo; (the object that
receives the object&amp;rsquo;s events and acts upon them) for players is linked to a
socket (via the bowels of Twisted) and a few extra instance variables and
methods on the player (eg, the player&amp;rsquo;s password hash, and the method to take
a line of input and dispatch it to the appropriate command). In more tightly
coupled implementations, players and NPCs are different beasts entirely,
possibly resulting in ridiculous duplication like different &amp;lsquo;take away &lt;em&gt;X&lt;/em&gt;
hitpoints&amp;rsquo; routines for each type, which should reside in a common base class.</source>
          <target state="translated">디스플레이와 게임 로직이 분리 된 결과 중 하나는 플레이어 아바타와 NPC 간의 차이가 플레이어의 '컨트롤러'(객체의 이벤트를 수신하고 이에 따라 행동하는 객체)가 소켓에 연결된다는 것입니다 (Twisted의 창자를 통해 ) 및 플레이어의 몇 가지 추가 인스턴스 변수 및 메서드 (예 : 플레이어의 암호 해시 및 입력 한 줄을 가져와 적절한 명령에 전달하는 메서드). 더 밀접하게 결합 된 구현에서 플레이어와 NPC는 완전히 다른 야수이므로 공통 기본 클래스에 있어야하는 각 유형에 대해 서로 다른 ' &lt;em&gt;X&lt;/em&gt; 체력 제거'루틴 과 같은 우스꽝스러운 중복이 발생할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5bdee608fa661c1b5b42d8036a9e58c876a2a097" translate="yes" xml:space="preserve">
          <source>StaffObject</source>
          <target state="translated">StaffObject</target>
        </trans-unit>
        <trans-unit id="796ef8afc2a04895ef9d3c38e51c25c6880b0cc3" translate="yes" xml:space="preserve">
          <source>These points make grailmud different from other (aspiring-to-be)
production-ready MUD servers in this area (ie, MUDs written in Python).
PythonMOO, POO, et al, have used a custom scripting language for programming
game logic in, wheras grailmud uses Python for this task. Buyasta, wordplay,
et al, have a tighter coupling between display and game logic. nakedmud
reimplements a -lot- of stuff in C (ick!) which is already done in some
library, or which can be done painlessly in Python. There are many, many
hackish little MUD servers written (I wrote 2 or 3 of them before I got the
design more-or-less Right), but none of these are really suitable to build a
whole game in.</source>
          <target state="translated">이러한 점은 grailmud를이 영역의 다른 (예상) 프로덕션 준비 MUD 서버 (즉, Python으로 작성된 MUD)와 다르게 만듭니다. PythonMOO, POO 등은 게임 로직 프로그래밍을 위해 커스텀 스크립팅 언어를 사용했으며 grailmud는이 작업에 Python을 사용합니다. Buyasta, wordplay 등은 디스플레이와 게임 로직 사이에 더 긴밀한 결합을 가지고 있습니다. nakedmud는 이미 일부 라이브러리에서 수행되었거나 Python에서 쉽게 수행 할 수있는 C (ick!)로 많은 것을 다시 구현합니다. 많은 해커 쉬 한 작은 MUD 서버가 작성되었지만 (저는 디자인이 다소간 맞기 전에 2 개 또는 3 개를 작성했습니다), 이들 중 어느 것도 전체 게임을 빌드하는 데 실제로 적합하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7a8942901e61a4f168cd3a280ed469807aa28ce8" translate="yes" xml:space="preserve">
          <source>grailmud is a MUD server written entirely in Python (though optimising
bottlenecks in C, and a more restricted language for builders and untrusted
coders to work in are options which will be considered in the future) with a
loosely coupled design between the game logic and the display logic for
players, as well as a more loose than is traditional coupling between object
logic and object state. grailmud also leverages Twisted, pyparsing and durus,
so a bare minimum of low-level (networking|parsing|serialisation) code has to
be written.</source>
          <target state="translated">grailmud는 완전히 Python으로 작성된 MUD 서버입니다 (C에서 병목 현상을 최적화하고 빌더와 신뢰할 수없는 코더가 작업 할 수있는보다 제한된 언어는 향후 고려 될 옵션 임). 플레이어를위한 디스플레이 로직은 물론, 오브젝트 로직과 오브젝트 상태 간의 기존 결합보다 더 느슨합니다. grailmud는 또한 Twisted, pyparsing 및 durus를 활용하므로 최소한의 저수준 (networking | parsing | serialization) 코드를 작성해야합니다.</target>
        </trans-unit>
        <trans-unit id="7996c3f3750c7adbd6240d4b253cc9cff31940d3" translate="yes" xml:space="preserve">
          <source>rather than having to delve into the</source>
          <target state="translated">탐구하지 않고</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
