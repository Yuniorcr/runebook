<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://pypi.org/project/moz-sql-parser/">
    <body>
      <group id="moz-sql-parser">
        <trans-unit id="4e28d29be344385ea302dcef3fbb66860d416f31" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://pypi.python.org/pypi/sqlparse&quot;&gt;sqlparse&lt;/a&gt; does not provide a tree, rather a list of tokens.</source>
          <target state="translated">&lt;a href=&quot;https://pypi.python.org/pypi/sqlparse&quot;&gt;sqlparse&lt;/a&gt; 는 트리가 아니라 토큰 목록을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="94a7af134274f802f7d6f8c671505a6104b37384" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;WARNING!&lt;/strong&gt; There is a recursion limit of &lt;code&gt;1500&lt;/code&gt;. This prevents parsing of complex expressions or deeply nested nested queries. You can increase the recursion limit &lt;em&gt;after&lt;/em&gt; you have imported &lt;code&gt;moz_sql_parser&lt;/code&gt;, and before you &lt;code&gt;parse&lt;/code&gt;:</source>
          <target state="translated">&lt;strong&gt;경고! &lt;/strong&gt;재귀 제한은 &lt;code&gt;1500&lt;/code&gt; 입니다. 이렇게하면 복잡한 식이나 중첩 된 쿼리의 구문 분석을 방지 할 수 있습니다. &lt;code&gt;moz_sql_parser&lt;/code&gt; 를 가져온 &lt;em&gt;후 &lt;/em&gt; &lt;code&gt;parse&lt;/code&gt; 하기 전에 재귀 제한 &lt;em&gt;을&lt;/em&gt; 늘릴 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1627510b242fdd96752b823f80c1c2b488d0747b" translate="yes" xml:space="preserve">
          <source>Branch</source>
          <target state="translated">분기</target>
        </trans-unit>
        <trans-unit id="2d82a4b27a4b305690d5ac612046a955778a9fa5" translate="yes" xml:space="preserve">
          <source>Contributing</source>
          <target state="translated">기여</target>
        </trans-unit>
        <trans-unit id="f965a3acfa3282329fed41fc1e47392daa396d54" translate="yes" xml:space="preserve">
          <source>Each SQL query is parsed to an object: Each clause is assigned to an object property of the same name.</source>
          <target state="translated">각 SQL 쿼리는 객체로 구문 분석됩니다. 각 절은 동일한 이름의 객체 속성에 할당됩니다.</target>
        </trans-unit>
        <trans-unit id="966c089e2169b8a55bd60dc592b73c2aca57fcde" translate="yes" xml:space="preserve">
          <source>Expressions are also objects, but with only one property: The name of the operation, and the value holding (an array of) parameters for that operation.</source>
          <target state="translated">표현식도 객체이지만 작업의 이름과 해당 작업에 대한 매개 변수 (배열)를 보유하는 값이 하나뿐입니다.</target>
        </trans-unit>
        <trans-unit id="0a4eefe2ba9d52aae17ac211d2c4b4029e262334" translate="yes" xml:space="preserve">
          <source>Extract Parse Tree from SQL</source>
          <target state="translated">SQL에서 구문 분석 트리 추출</target>
        </trans-unit>
        <trans-unit id="2663443ee624833850c1162ce7a9bfaf9816461b" translate="yes" xml:space="preserve">
          <source>Generating SQL</source>
          <target state="translated">SQL 생성</target>
        </trans-unit>
        <trans-unit id="832bd26971dbce25436004fb6f78071d58d6e3ea" translate="yes" xml:space="preserve">
          <source>In the event that the parser is not working for you, you can help make this better but simply pasting your sql (or JSON) into a new issue. Extra points if you describe the problem. Even more points if you submit a PR with a test.  If you also submit a fix, then you also have my gratitude.</source>
          <target state="translated">파서가 작동하지 않는 경우이를 개선하는 데 도움을 줄 수 있지만 단순히 SQL (또는 JSON)을 새 문제에 붙여 넣을 수 있습니다. 문제를 설명하면 추가 점수. 테스트와 함께 PR을 제출하면 더 많은 포인트를 얻을 수 있습니다. 수정 사항도 제출하면 감사합니다.</target>
        </trans-unit>
        <trans-unit id="fd6c3ebf7befca9f8208f86c76e4d4180303745c" translate="yes" xml:space="preserve">
          <source>Install</source>
          <target state="translated">설치</target>
        </trans-unit>
        <trans-unit id="6b4d04f9f8fa44794465762f162279a868429354" translate="yes" xml:space="preserve">
          <source>Let's make a SQL parser so we can provide a familiar interface to non-sql datastores!</source>
          <target state="translated">SQL이 아닌 데이터 저장소에 익숙한 인터페이스를 제공 할 수 있도록 SQL 파서를 만들어 보겠습니다!</target>
        </trans-unit>
        <trans-unit id="010bc6c086848dea1af62fc5ce30971d49859381" translate="yes" xml:space="preserve">
          <source>More about implementation</source>
          <target state="translated">구현에 대한 추가 정보</target>
        </trans-unit>
        <trans-unit id="c61d361e892493c40018ce5123358566c5a83225" translate="yes" xml:space="preserve">
          <source>Moz SQL Parser</source>
          <target state="translated">Moz SQL 파서</target>
        </trans-unit>
        <trans-unit id="33a39b12e43bde0be5e98a7db5de429002890c78" translate="yes" xml:space="preserve">
          <source>No plans to expand the language to all of SQL:2011</source>
          <target state="translated">모든 SQL : 2011로 언어를 확장 할 계획 없음</target>
        </trans-unit>
        <trans-unit id="75e617f9065f00ca469e2f4802d0bfcf90a09902" translate="yes" xml:space="preserve">
          <source>No plans to provide data access tools</source>
          <target state="translated">데이터 액세스 도구를 제공 할 계획 없음</target>
        </trans-unit>
        <trans-unit id="a81ece075d0edfc6b929bf939e6e5b5f43e31326" translate="yes" xml:space="preserve">
          <source>No plans to provide update statements, like &lt;code&gt;update&lt;/code&gt; or &lt;code&gt;insert&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;update&lt;/code&gt; 또는 &lt;code&gt;insert&lt;/code&gt; 과 같은 업데이트 문을 제공 할 계획이 없습니다.</target>
        </trans-unit>
        <trans-unit id="4f9f5a604eaaa999d173a12f209a86773406674b" translate="yes" xml:space="preserve">
          <source>Non-Objectives</source>
          <target state="translated">비 목표</target>
        </trans-unit>
        <trans-unit id="70440046a3dc2e079f23ee1c57dfa76669b732aa" translate="yes" xml:space="preserve">
          <source>Notes</source>
          <target state="translated">노트</target>
        </trans-unit>
        <trans-unit id="24d50592b70a997e82a3839de9c69ef0c75660a9" translate="yes" xml:space="preserve">
          <source>Objectives</source>
          <target state="translated">목표</target>
        </trans-unit>
        <trans-unit id="fe57dbf747e895148349c1fa9634e51dbecd7517" translate="yes" xml:space="preserve">
          <source>Parsing SQL</source>
          <target state="translated">SQL 구문 분석</target>
        </trans-unit>
        <trans-unit id="fa172cf233798ad6b9a563a7017eabd723d0e92e" translate="yes" xml:space="preserve">
          <source>Problem Statement</source>
          <target state="translated">문제 설명</target>
        </trans-unit>
        <trans-unit id="1cb0bee5478facc7715136ce6ca34b0fe11136cb" translate="yes" xml:space="preserve">
          <source>Project Status</source>
          <target state="translated">프로젝트 상태</target>
        </trans-unit>
        <trans-unit id="5217fc37ffff1ea7636afe621cf814248a879901" translate="yes" xml:space="preserve">
          <source>Recursion Limit</source>
          <target state="translated">재귀 제한</target>
        </trans-unit>
        <trans-unit id="40e0369df9d75435b2e7be5903874c57c9829e0d" translate="yes" xml:space="preserve">
          <source>Run Tests</source>
          <target state="translated">테스트 실행</target>
        </trans-unit>
        <trans-unit id="f1e002404e674984e90046729044367c19480e51" translate="yes" xml:space="preserve">
          <source>SQL is a familiar language used to access databases. Although, each database vendor has its quirky implementation, the average developer does not know enough SQL to be concerned with those quirks. This familiar core SQL (lowest common denominator, if you will) is useful enough to explore data in primitive ways. It is hoped that, once programmers have reviewed a datastore with basic SQL queries, and they see the value of that data, they will be motivated to use the datastore's native query format.</source>
          <target state="translated">SQL은 데이터베이스에 액세스하는 데 사용되는 익숙한 언어입니다. 각 데이터베이스 공급 업체는 기발한 구현을 가지고 있지만 일반 개발자는 이러한 기발한 점을 고려할만큼 SQL을 충분히 알지 못합니다. 이 익숙한 핵심 SQL (최소 공통 분모)은 원시적 인 방식으로 데이터를 탐색하기에 충분히 유용합니다. 프로그래머가 기본 SQL 쿼리를 사용하여 데이터 저장소를 검토하고 해당 데이터의 가치를 확인한 후 데이터 저장소의 기본 쿼리 형식을 사용하도록 동기를 부여하기를 바랍니다.</target>
        </trans-unit>
        <trans-unit id="2e605a358b5ec3cecdbd821c273f7059f717c064" translate="yes" xml:space="preserve">
          <source>SQL queries are translated to JSON objects: Each clause is assigned to an object property of the same name.</source>
          <target state="translated">SQL 쿼리는 JSON 개체로 변환됩니다. 각 절은 동일한 이름의 개체 속성에 할당됩니다.</target>
        </trans-unit>
        <trans-unit id="d275310c79fc97ae9e1fcfef4efbead08afa37a4" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://github.com/mozilla/moz-sql-parser/tree/dev/tests&quot;&gt;the tests directory&lt;/a&gt; for instructions running tests, or writing new ones.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/mozilla/moz-sql-parser/tree/dev/tests&quot;&gt;테스트&lt;/a&gt; 를 실행하거나 새로 작성하는 방법 은 tests 디렉토리 를 참조하세요 .</target>
        </trans-unit>
        <trans-unit id="bae7d5be70820ed56467bd9a63744e23b47bd711" translate="yes" xml:space="preserve">
          <source>Status</source>
          <target state="translated">상태</target>
        </trans-unit>
        <trans-unit id="c62c75e18bbe6c1877bcf42feca5efb923577207" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SELECT&lt;/code&gt; clause is an array of objects containing &lt;code&gt;name&lt;/code&gt; and &lt;code&gt;value&lt;/code&gt; properties.</source>
          <target state="translated">&lt;code&gt;SELECT&lt;/code&gt; 절을 포함하는 객체들의 어레이이다 &lt;code&gt;name&lt;/code&gt; 및 &lt;code&gt;value&lt;/code&gt; 속성.</target>
        </trans-unit>
        <trans-unit id="f4f8178674aaff567ed07f488140adbfbfe94dce" translate="yes" xml:space="preserve">
          <source>The primary objective of this library is to convert some subset of &lt;a href=&quot;https://en.wikipedia.org/wiki/SQL-92&quot;&gt;SQL-92&lt;/a&gt; queries to JSON-izable parse trees. A big enough subset to provide superficial data access via SQL, but not so much as we must deal with the document-relational impedance mismatch.</source>
          <target state="translated">이 라이브러리의 주요 목적은 &lt;a href=&quot;https://en.wikipedia.org/wiki/SQL-92&quot;&gt;SQL-92&lt;/a&gt; 쿼리 의 일부 하위 집합 을 JSON 가능 구문 분석 트리로 변환하는 것입니다. SQL을 통해 피상적 인 데이터 액세스를 제공 할만큼 충분히 큰 하위 집합이지만 문서 관계형 임피던스 불일치를 처리해야하는 만큼은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="5f4f8976bb3862e29b0a28428cc921697b71fec5" translate="yes" xml:space="preserve">
          <source>There are &lt;a href=&quot;https://github.com/mozilla/moz-sql-parser/tree/dev/tests&quot;&gt;over 400 tests&lt;/a&gt;. This parser is good enough for basic usage, including inner queries.</source>
          <target state="translated">가 있습니다 &lt;a href=&quot;https://github.com/mozilla/moz-sql-parser/tree/dev/tests&quot;&gt;이상 400 시험은&lt;/a&gt; . 이 파서는 내부 쿼리를 포함한 기본 사용에 충분합니다.</target>
        </trans-unit>
        <trans-unit id="189973b5cf5444d3d7004008dbae95df268cf639" translate="yes" xml:space="preserve">
          <source>Uses the glorious &lt;code&gt;pyparsing&lt;/code&gt; library (see &lt;a href=&quot;https://github.com/pyparsing/pyparsing&quot;&gt;https://github.com/pyparsing/pyparsing&lt;/a&gt;) to define the grammar, and define the shape of the tokens it generates.</source>
          <target state="translated">멋진 &lt;code&gt;pyparsing&lt;/code&gt; 라이브러리 ( &lt;a href=&quot;https://github.com/pyparsing/pyparsing&quot;&gt;https://github.com/pyparsing/pyparsing 참조&lt;/a&gt; )를 사용하여 문법을 정의하고 생성하는 토큰의 모양을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="4651977612eb15d974adfac2507a3a4205f35900" translate="yes" xml:space="preserve">
          <source>You can see the parser in action at &lt;a href=&quot;https://sql.telemetry.mozilla.org/&quot;&gt;https://sql.telemetry.mozilla.org/&lt;/a&gt; while using the ActiveData datasource</source>
          <target state="translated">ActiveData 데이터 소스를 사용하는 동안 &lt;a href=&quot;https://sql.telemetry.mozilla.org/&quot;&gt;https://sql.telemetry.mozilla.org/&lt;/a&gt; 에서 작동중인 구문 분석기를 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c2a7051d7ad2f9e606a29f9a31af46c0beb7103b" translate="yes" xml:space="preserve">
          <source>You may also generate SQL from the a given JSON document. This is done by the formatter, which is still incomplete (Jan2020).</source>
          <target state="translated">주어진 JSON 문서에서 SQL을 생성 할 수도 있습니다. 이는 아직 불완전한 포맷터에 의해 수행됩니다 (Jan2020).</target>
        </trans-unit>
        <trans-unit id="54d094d08ab3dedca2a6d6466c75b306bf10f81b" translate="yes" xml:space="preserve">
          <source>and you can see this pattern in the previous example:</source>
          <target state="translated">이전 예제에서이 패턴을 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="34c6fceca75e456f25e7e99531e2425c6c1de443" translate="yes" xml:space="preserve">
          <source>dev</source>
          <target state="translated">dev</target>
        </trans-unit>
        <trans-unit id="4f26aeafdb2367620a393c973eddbe8f8b846ebd" translate="yes" xml:space="preserve">
          <source>master</source>
          <target state="translated">석사</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
