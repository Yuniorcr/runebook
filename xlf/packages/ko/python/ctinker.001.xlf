<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://pypi.org/project/ctinker/">
    <body>
      <group id="ctinker">
        <trans-unit id="cee4558221adcab19d9848dabd5a722aaaa2ed45" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;CTinker&lt;/code&gt; is capable of getting in the middle of virtually any build process by:</source>
          <target state="translated">&lt;code&gt;CTinker&lt;/code&gt; 는 다음을 통해 거의 모든 빌드 프로세스의 중간에 들어갈 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d4be7dd37d857b4f4a77721a1fb365ec77bd3f49" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;C Tinker&lt;/strong&gt;, pronounced &lt;em&gt;see-tinker&lt;/em&gt; (or humorously &quot;stinker&quot;, as suggested by
&lt;a href=&quot;https://github.com/ocheret&quot;&gt;Chuck Ocheret&lt;/a&gt;) allows you to get in the middle of the build process of a
make/Ninja-style project and augment the compilation and linking as well as extract and redirect artifacts using
policies you can't implement otherwise even with LDFLAGS/CFLAGS magic.</source>
          <target state="translated">&lt;strong&gt;C Tinker&lt;/strong&gt; , 발음하는 &lt;em&gt;see-tinker&lt;/em&gt; (또는 &lt;a href=&quot;https://github.com/ocheret&quot;&gt;Chuck Ocheret가&lt;/a&gt; 제안한 유머러스하게 &quot;stinker&quot; )를 사용하면 make / Ninja 스타일 프로젝트의 빌드 프로세스 중간에 들어가서 컴파일 및 링크를 강화하고 추출 및 LDFLAGS / CFLAGS 마법으로도 구현할 수없는 정책을 사용하여 아티팩트를 리디렉션합니다.</target>
        </trans-unit>
        <trans-unit id="b1a8f2af082da0e64e0f6efd4f4818db6b61c01a" translate="yes" xml:space="preserve">
          <source>As a further illustration, if the original process invocation chain for a sample build is as follows:</source>
          <target state="translated">추가 설명으로 샘플 빌드의 원래 프로세스 호출 체인이 다음과 같은 경우 :</target>
        </trans-unit>
        <trans-unit id="8f7b8db04007ab4e6cb522976d9fad3475938b3f" translate="yes" xml:space="preserve">
          <source>Being invoked for each tool invocation in a &lt;code&gt;worker&lt;/code&gt; mode (based on environmental variables),
communicating with the &lt;code&gt;supervisor&lt;/code&gt;, sending command-line arguments to the &lt;code&gt;supervisor&lt;/code&gt; process and then
invoking the tool itself.</source>
          <target state="translated">&lt;code&gt;worker&lt;/code&gt; 모드 (환경 변수 기반) 에서 각 도구 호출에 대해 호출되고 , &lt;code&gt;supervisor&lt;/code&gt; 와 통신하고 , 명령 줄 인수를 &lt;code&gt;supervisor&lt;/code&gt; 프로세스에 보낸 다음 도구 자체를 호출합니다.</target>
        </trans-unit>
        <trans-unit id="45f892e57440dc6c011ce74aa8bafde4a8414521" translate="yes" xml:space="preserve">
          <source>CTinker - C/C++ Project Introspection and Augmentation Tool</source>
          <target state="translated">CTinker-C / C ++ 프로젝트 내부 검사 및 확장 도구</target>
        </trans-unit>
        <trans-unit id="7661ba55453b25e5a4a35c5bd413a649b654e8fa" translate="yes" xml:space="preserve">
          <source>CTinker is a C project introspection and augmentation tool</source>
          <target state="translated">CTinker는 C 프로젝트 인트로 스펙 션 및 증강 도구입니다.</target>
        </trans-unit>
        <trans-unit id="611f6daef3d61f0ff9fdc4a77292e4a5970e7bb8" translate="yes" xml:space="preserve">
          <source>Creating a temporary directory full of toolkit-specific (e.g. for LLVM Clang it's &lt;code&gt;clang&lt;/code&gt;, &lt;code&gt;ar&lt;/code&gt; etc)
symlinks referring back to &lt;code&gt;CTinker&lt;/code&gt; executable.</source>
          <target state="translated">&lt;code&gt;CTinker&lt;/code&gt; 실행 파일을 다시 참조 하는 툴킷 별 (예 : LLVM Clang의 경우 &lt;code&gt;clang&lt;/code&gt; , &lt;code&gt;ar&lt;/code&gt; 등) 심볼릭 링크로 가득 찬 임시 디렉토리 를 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="0f01ed56a1e32a05e5ef96e4d779f34784af9a96" translate="yes" xml:space="preserve">
          <source>Example</source>
          <target state="translated">예</target>
        </trans-unit>
        <trans-unit id="c47ae15370cfe1ed2781eedc1dc2547d12d9e972" translate="yes" xml:space="preserve">
          <source>Help</source>
          <target state="translated">도움</target>
        </trans-unit>
        <trans-unit id="e230b4612943b3fee8bed470ec510d31f987ca01" translate="yes" xml:space="preserve">
          <source>I need to get in the middle of a build process of a project I can know intimately but do not control
and that I have no intention of maintaining a fork/patches for, or for which I need to obtain runtime
dynamic control of the build process.</source>
          <target state="translated">내가 친밀하게 알 수는 있지만 제어 할 수없고 포크 / 패치를 유지할 의도가 없거나 빌드 프로세스의 런타임 동적 제어를 얻어야하는 프로젝트의 빌드 프로세스 중간에 들어가야합니다. .</target>
        </trans-unit>
        <trans-unit id="a7c7003f41154bf59e66e5ddd53746641e5a73d4" translate="yes" xml:space="preserve">
          <source>If specified, invoking &lt;code&gt;scripting&lt;/code&gt; handlers before and after the build as a whole (in the &lt;code&gt;supervisor&lt;/code&gt;)
and before and after each intercepted tool invocation (in the &lt;code&gt;worker&lt;/code&gt;).</source>
          <target state="translated">지정된 경우 전체 빌드 전후 ( &lt;code&gt;supervisor&lt;/code&gt; 에서 ), 인터셉트 된 각 도구 호출 전후 ( &lt;code&gt;worker&lt;/code&gt; 에서 ) &lt;code&gt;scripting&lt;/code&gt; 핸들러를 호출 합니다.</target>
        </trans-unit>
        <trans-unit id="e14c1358024a39bc8a17ea229eea7c677186beef" translate="yes" xml:space="preserve">
          <source>Invoking the build process as specified by the user.</source>
          <target state="translated">사용자가 지정한대로 빌드 프로세스를 호출합니다.</target>
        </trans-unit>
        <trans-unit id="4c083951aea114db79b695e69826f30d7a158cf2" translate="yes" xml:space="preserve">
          <source>It is guaranteed that &lt;code&gt;ctinker_start&lt;/code&gt; - &lt;code&gt;ctinker_finish&lt;/code&gt; and &lt;code&gt;ctinker_before_tool&lt;/code&gt; - &lt;code&gt;ctinker_after_tool&lt;/code&gt; pairs will
be executed in the same &lt;code&gt;supervisor&lt;/code&gt; and &lt;code&gt;worker&lt;/code&gt; processes &lt;em&gt;respectively&lt;/em&gt; and therefore you can pass values between
the start/finish and before/after functions (for example by a global or within the same instance of an object).</source>
          <target state="translated">보장한다 &lt;code&gt;ctinker_start&lt;/code&gt; - &lt;code&gt;ctinker_finish&lt;/code&gt; 및 &lt;code&gt;ctinker_before_tool&lt;/code&gt; - &lt;code&gt;ctinker_after_tool&lt;/code&gt; 쌍은 동일한에서 실행됩니다 &lt;code&gt;supervisor&lt;/code&gt; 및 &lt;code&gt;worker&lt;/code&gt; 프로세스 &lt;em&gt;각각&lt;/em&gt; 따라서 당신은 세계 또는 동일한 인스턴스에서 시작 / 종료 및 이전 / 기능 후 (예를 들어 사이에 값을 전달할 수 있습니다 개체의).</target>
        </trans-unit>
        <trans-unit id="b127eaa52b0044c93134cac365a89c16698e6291" translate="yes" xml:space="preserve">
          <source>More formally the problem &lt;strong&gt;CTinker&lt;/strong&gt; solves can be stated as follows:</source>
          <target state="translated">보다 공식적으로 &lt;strong&gt;CTinker가&lt;/strong&gt; 해결 하는 문제 는 다음과 같이 설명 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0efc2e6be4c23b9a513d7ce0dcff8ed80e8912e7" translate="yes" xml:space="preserve">
          <source>Overview</source>
          <target state="translated">개요</target>
        </trans-unit>
        <trans-unit id="774fec522beda5af3a1a17d19833e6b56fcc7eba" translate="yes" xml:space="preserve">
          <source>Printing to &lt;code&gt;sys.stdout&lt;/code&gt; from the &lt;code&gt;worker&lt;/code&gt; is dangerous as the stdout is often interpreted by the invoking tool
which can lead to a crash in the tool expecting certain data format. &lt;code&gt;print(&quot;debug!&quot;, file=sys.stderr)&lt;/code&gt; is generally
safe.</source>
          <target state="translated">&lt;code&gt;worker&lt;/code&gt; 에서 &lt;code&gt;sys.stdout&lt;/code&gt; 으로 인쇄하는 것은 특정 데이터 형식을 예상하는 도구에서 충돌을 일으킬 수있는 호출 도구에 의해 stdout이 해석되는 경우가 많으므로 위험합니다. &lt;code&gt;print(&quot;debug!&quot;, file=sys.stderr)&lt;/code&gt; 는 일반적으로 안전합니다.</target>
        </trans-unit>
        <trans-unit id="1baa06b4c8bc2d63f9db4d4cc86a2e2b12a7e893" translate="yes" xml:space="preserve">
          <source>Problem</source>
          <target state="translated">문제</target>
        </trans-unit>
        <trans-unit id="7522becbe814d8b8cbc378f8930c8ca68bb2b8b5" translate="yes" xml:space="preserve">
          <source>Scripting</source>
          <target state="translated">스크립팅</target>
        </trans-unit>
        <trans-unit id="91146ee3bd4bd067d3589f2d17261dcb5f0642ce" translate="yes" xml:space="preserve">
          <source>Scripting is the most powerful part of &lt;code&gt;CTinker&lt;/code&gt; that provides an ability to really change how build functions
at runtime. It is implemented via a visitor pattern, invoking functions specified in the user-supplied script:</source>
          <target state="translated">스크립팅은 런타임에 빌드 기능을 실제로 변경하는 기능을 제공하는 &lt;code&gt;CTinker&lt;/code&gt; 의 가장 강력한 부분입니다 . 사용자 제공 스크립트에 지정된 함수를 호출하는 방문자 패턴을 통해 구현됩니다.</target>
        </trans-unit>
        <trans-unit id="7d35abde352ff3e67f5295268c2e4e0d394c89ea" translate="yes" xml:space="preserve">
          <source>Setting up environ and a local socket to communicate with the &lt;code&gt;workers&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;workers&lt;/code&gt; 와 통신하기위한 환경 및 로컬 소켓 설정 .</target>
        </trans-unit>
        <trans-unit id="b4f91bdb0e1b0e40fff4debcd0fea22f1999f491" translate="yes" xml:space="preserve">
          <source>Solution</source>
          <target state="translated">해결책</target>
        </trans-unit>
        <trans-unit id="85ff3c02942ec7b1321cb3c749a4a1a25edaec6a" translate="yes" xml:space="preserve">
          <source>Starting in the &lt;code&gt;supervisor&lt;/code&gt; mode.</source>
          <target state="translated">&lt;code&gt;supervisor&lt;/code&gt; 모드 에서 시작 합니다.</target>
        </trans-unit>
        <trans-unit id="9ac8af0e3202f4f96d6c5b701dbe9563d6abd4d9" translate="yes" xml:space="preserve">
          <source>TBW</source>
          <target state="translated">TBW</target>
        </trans-unit>
        <trans-unit id="285ec850c11d78bac10f6bfa31b69a37f1b257c9" translate="yes" xml:space="preserve">
          <source>Troubleshooting</source>
          <target state="translated">문제 해결</target>
        </trans-unit>
        <trans-unit id="6b2df7574f43d9cd7f0639cc019bc85ef4fce271" translate="yes" xml:space="preserve">
          <source>ctinker =&amp;gt; make =&amp;gt; ctinker-clang =&amp;gt; clang =&amp;gt; ctinker-lld =&amp;gt; lld, =&amp;gt; make =&amp;gt; ctinker-clang =&amp;gt; clang,
=&amp;gt; ctinker-clang =&amp;gt; clang =&amp;gt; ctinker-lld =&amp;gt; lld</source>
          <target state="translated">ctinker =&amp;gt; make =&amp;gt; ctinker-clang =&amp;gt; clang =&amp;gt; ctinker-lld =&amp;gt; lld, =&amp;gt; make =&amp;gt; ctinker-clang =&amp;gt; clang, =&amp;gt; ctinker-clang =&amp;gt; clang =&amp;gt; ctinker-lld =&amp;gt; lld</target>
        </trans-unit>
        <trans-unit id="b84d7c90d27ded663b935bf795fa8a6b36c73ff0" translate="yes" xml:space="preserve">
          <source>make =&amp;gt; clang =&amp;gt; lld, =&amp;gt; make =&amp;gt; clang, =&amp;gt; clang =&amp;gt; lld</source>
          <target state="translated">make =&amp;gt; clang =&amp;gt; lld, =&amp;gt; make =&amp;gt; clang, =&amp;gt; clang =&amp;gt; lld</target>
        </trans-unit>
        <trans-unit id="57beee9c14bbf9cd52f31f78522c6d9f9f7dc20c" translate="yes" xml:space="preserve">
          <source>then the same build instrumented with CTinker will produce the following process invocation chain:</source>
          <target state="translated">그러면 CTinker로 계측 된 동일한 빌드가 다음 프로세스 호출 체인을 생성합니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
