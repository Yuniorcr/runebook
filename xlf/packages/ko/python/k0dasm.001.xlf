<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://pypi.org/project/k0dasm/">
    <body>
      <group id="k0dasm">
        <trans-unit id="a36abd240d4fced49d5e073136718ece787d8d3c" translate="yes" xml:space="preserve">
          <source>) will still need to be resolved manually.</source>
          <target state="translated">)는 수동으로 해결해야합니다.</target>
        </trans-unit>
        <trans-unit id="5fda23d62015b99fb2a9f86b38bcdf2bdf7609c8" translate="yes" xml:space="preserve">
          <source>Author</source>
          <target state="translated">저자</target>
        </trans-unit>
        <trans-unit id="92e5f3778e6f41bd90cfde8d9ba37c348715ef61" translate="yes" xml:space="preserve">
          <source>Code / Data Separation.  Starting from the vectors at the bottom of memory, k0dasm uses recursive traversal disassembly to separate code from data.  This automates much of the disassembly process but indirect jumps (</source>
          <target state="translated">코드 / 데이터 분리. 메모리 하단의 벡터에서 시작하여 k0dasm은 재귀 적 순회 디스 어셈블리를 사용하여 코드를 데이터에서 분리합니다. 이것은 분해 프로세스의 대부분을 자동화하지만 간접적 인 점프 (</target>
        </trans-unit>
        <trans-unit id="fc338f87a058158eb824b53705961801516a9460" translate="yes" xml:space="preserve">
          <source>Features</source>
          <target state="translated">풍모</target>
        </trans-unit>
        <trans-unit id="e99f3ac80b2b2350f2e51853d26bb1447dd0afda" translate="yes" xml:space="preserve">
          <source>Identical Reassembly.  The assembly language output of k0dasm will assemble to a bit-for-bit exact copy of the original binary using as78k0.  This has been tested using several real firmware binaries.</source>
          <target state="translated">동일한 재 조립. k0dasm의 어셈블리 언어 출력은 as78k0을 사용하여 원본 바이너리의 비트 단위 정확한 복사본으로 어셈블됩니다. 이것은 여러 실제 펌웨어 바이너리를 사용하여 테스트되었습니다.</target>
        </trans-unit>
        <trans-unit id="c81b79df3c6448eae7c4f80428b54cd5692a17d7" translate="yes" xml:space="preserve">
          <source>Installation</source>
          <target state="translated">설치</target>
        </trans-unit>
        <trans-unit id="ef794089d65c29260193d1171143c513c37dd853" translate="yes" xml:space="preserve">
          <source>Mike Naberezny</source>
          <target state="translated">마이크 나 베레 즈니</target>
        </trans-unit>
        <trans-unit id="0efc2e6be4c23b9a513d7ce0dcff8ed80e8912e7" translate="yes" xml:space="preserve">
          <source>Overview</source>
          <target state="translated">개요</target>
        </trans-unit>
        <trans-unit id="184aae6f77608718224c424e74717a6de967207d" translate="yes" xml:space="preserve">
          <source>Renesas (NEC) 78K0 disassembler</source>
          <target state="translated">Renesas (NEC) 78K0 분해기</target>
        </trans-unit>
        <trans-unit id="c611e7531edc5ad06854e7aa8c370fa7c7df38ae" translate="yes" xml:space="preserve">
          <source>Symbol Generation.  k0dasm tries not to write hardcoded addresses in the output when possible.  It will automatically add symbols for hardware registers and vectors, other memory locations used, and will add labels for branches and subroutines.</source>
          <target state="translated">기호 생성. k0dasm은 가능한 경우 출력에 하드 코딩 된 주소를 쓰지 않으려 고합니다. 하드웨어 레지스터 및 벡터, 사용 된 기타 메모리 위치에 대한 기호를 자동으로 추가하고 분기 및 서브 루틴에 대한 레이블을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="887bd25b814c2ea33c2020e1ae14e08e3e41ab2c" translate="yes" xml:space="preserve">
          <source>The file is assumed to be a ROM image that should be aligned to the bottom of memory.  For example, if a 32K file is given, k0dasm will assume the image should be located at 0x0000-0x7FFF.  After loading the image, the disassembler reads the vectors and starts tracing instructions from their targets.</source>
          <target state="translated">파일은 메모리 하단에 정렬되어야하는 ROM 이미지로 간주됩니다. 예를 들어, 32K 파일이 주어지면 k0dasm은 이미지가 0x0000-0x7FFF에 있어야한다고 가정합니다. 이미지를로드 한 후 디스어셈블러는 벡터를 읽고 대상에서 명령 추적을 시작합니다.</target>
        </trans-unit>
        <trans-unit id="0bb18642b70b9f8a9c12ccf39487328f306b8e19" translate="yes" xml:space="preserve">
          <source>Usage</source>
          <target state="translated">용법</target>
        </trans-unit>
        <trans-unit id="83889f5663f7f860486c3e9bfe18177eff6db2cd" translate="yes" xml:space="preserve">
          <source>br ax</source>
          <target state="translated">br 도끼</target>
        </trans-unit>
        <trans-unit id="5839dc65065f115602262aa635fbf67791899625" translate="yes" xml:space="preserve">
          <source>k0dasm</source>
          <target state="translated">k0dasm</target>
        </trans-unit>
        <trans-unit id="9e53567246f36fc5e20142d5b92badeead00b4a5" translate="yes" xml:space="preserve">
          <source>k0dasm accepts a plain binary file as input:</source>
          <target state="translated">k0dasm은 일반 바이너리 파일을 입력으로받습니다.</target>
        </trans-unit>
        <trans-unit id="adaa751be62a63905f2aad7b6a93a8813858eb2b" translate="yes" xml:space="preserve">
          <source>k0dasm is a disassembler for NEC 78K0 binaries that generates output compatible with the &lt;a href=&quot;http://shop-pdp.net/ashtml/as78k0.htm&quot;&gt;as78k0&lt;/a&gt; assembler.  It can be used to disassemble firmware for many 8-bit NEC 78K0 microcontrollers.  Note that NEC has several microcontroller families with similar names, such as 78K0S, that use different instruction sets.  These are not supported.</source>
          <target state="translated">k0dasm은 &lt;a href=&quot;http://shop-pdp.net/ashtml/as78k0.htm&quot;&gt;as78k0&lt;/a&gt; 어셈블러 와 호환되는 출력을 생성하는 NEC 78K0 바이너리 용 디스어셈블러입니다 . 많은 8 비트 NEC 78K0 마이크로 컨트롤러의 펌웨어를 분해하는 데 사용할 수 있습니다. NEC에는 78K0S와 같이 서로 다른 명령어 세트를 사용하는 유사한 이름을 가진 여러 마이크로 컨트롤러 제품군이 있습니다. 이들은 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c5d0b1d900eca0713b3f5d6e97a3ee2a22b52e92" translate="yes" xml:space="preserve">
          <source>k0dasm is written in Python and requires Python 3.4 or later.  Packages are &lt;a href=&quot;https://pypi.org/project/k0dasm/&quot;&gt;available&lt;/a&gt; on the Python Package Index (PyPI).  You can download them from there or you can use</source>
          <target state="translated">k0dasm은 Python으로 작성되었으며 Python 3.4 이상이 필요합니다. 패키지는 Python 패키지 색인 (PyPI)에서 &lt;a href=&quot;https://pypi.org/project/k0dasm/&quot;&gt;사용할 수 있습니다&lt;/a&gt; . 거기에서 다운로드하거나 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2a2a6fadee5f4ff99025989aec099e65c85077c0" translate="yes" xml:space="preserve">
          <source>k0dasm was developed to disassemble the firmware of the &lt;a href=&quot;https://github.com/mnaberez/vwradio&quot;&gt;Volkswagen Premium V&lt;/a&gt; car radios made by Delco.  These radios use the undocumented NEC &amp;micro;PD78F0831Y microcontroller, which is similar to the &lt;a href=&quot;https://web.archive.org/web/20180328161019/https://www.renesas.com/en-us/doc/DocumentServer/021/U13892EJ2V0UM00.pdf&quot;&gt;&amp;micro;PD78F0833Y&lt;/a&gt;.  A companion program, &lt;a href=&quot;https://github.com/mnaberez/k0emu&quot;&gt;k0emu&lt;/a&gt;, is a 78K0 emulator developed for the same project.</source>
          <target state="translated">k0dasm은 Delco에서 만든 &lt;a href=&quot;https://github.com/mnaberez/vwradio&quot;&gt;Volkswagen Premium V&lt;/a&gt; 자동차 라디오 의 펌웨어를 분해하기 위해 개발되었습니다 . 이 라디오는 &lt;a href=&quot;https://web.archive.org/web/20180328161019/https://www.renesas.com/en-us/doc/DocumentServer/021/U13892EJ2V0UM00.pdf&quot;&gt;&amp;micro;PD78F0833Y&lt;/a&gt; 와 유사한 문서화되지 않은 NEC &amp;micro;PD78F0831Y 마이크로 컨트롤러를 사용합니다 . 동반 프로그램 인 &lt;a href=&quot;https://github.com/mnaberez/k0emu&quot;&gt;k0emu&lt;/a&gt; 는 동일한 프로젝트를 위해 개발 된 78K0 에뮬레이터입니다.</target>
        </trans-unit>
        <trans-unit id="e1f1eb75c7bbf4dc71204486628790128a241e4f" translate="yes" xml:space="preserve">
          <source>pip</source>
          <target state="translated">씨</target>
        </trans-unit>
        <trans-unit id="4fdadaadb6acd13e89b1e933e596f13897f901f6" translate="yes" xml:space="preserve">
          <source>to automatically install or upgrade</source>
          <target state="translated">자동으로 설치 또는 업그레이드</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
