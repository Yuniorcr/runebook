<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://pypi.org/project/cpypp/">
    <body>
      <group id="cpypp">
        <trans-unit id="3bfceab7efe2a97255de38f4fd13b25e6e917dc1" translate="yes" xml:space="preserve">
          <source>&quot;__main__&quot;</source>
          <target state="translated">&quot;__본관__&quot;</target>
        </trans-unit>
        <trans-unit id="399013a7285b52d0ddad474bf4622aa5108b9f9d" translate="yes" xml:space="preserve">
          <source>#define</source>
          <target state="translated">#밝히다</target>
        </trans-unit>
        <trans-unit id="fb15726c00dbb185c41d4478ce69269e4096986c" translate="yes" xml:space="preserve">
          <source>#define identifier [expression]</source>
          <target state="translated">#define 식별자 [표현식]</target>
        </trans-unit>
        <trans-unit id="236b2c747eac9d35a39612f83a0a56e15f788066" translate="yes" xml:space="preserve">
          <source>#endif</source>
          <target state="translated">#endif</target>
        </trans-unit>
        <trans-unit id="5b50719aa17dd92a20066a693a77c1e69e97fde1" translate="yes" xml:space="preserve">
          <source>#expand</source>
          <target state="translated">#넓히다</target>
        </trans-unit>
        <trans-unit id="7f6f307ade8ffca7d89a869835eb779eb294d9c8" translate="yes" xml:space="preserve">
          <source>#if blocks</source>
          <target state="translated">#if 블록</target>
        </trans-unit>
        <trans-unit id="2b5597472ee8809bf83f3a5c629c3b938c40145a" translate="yes" xml:space="preserve">
          <source>#include</source>
          <target state="translated">#포함</target>
        </trans-unit>
        <trans-unit id="cd8fbf7c1b1feee188b6e7b5afdf8d3cc113793b" translate="yes" xml:space="preserve">
          <source>#includeident</source>
          <target state="translated">#includeident</target>
        </trans-unit>
        <trans-unit id="5cc0bef01c463bda27b54a280ffdffcbe2de7353" translate="yes" xml:space="preserve">
          <source>#undef identifier</source>
          <target state="translated">#undef 식별자</target>
        </trans-unit>
        <trans-unit id="dd74049658df1a98322337dc7dff3f0821987119" translate="yes" xml:space="preserve">
          <source>&amp;lt;filename&amp;gt;</source>
          <target state="translated">&amp;lt;파일 이름&amp;gt;</target>
        </trans-unit>
        <trans-unit id="44bcb5b6d20fe29b596b8def6c27f2b979c220f6" translate="yes" xml:space="preserve">
          <source>',r'</source>
          <target state="translated">',아르 자형'</target>
        </trans-unit>
        <trans-unit id="d3f92e9d1806016b46e3c5ad8ae5b60524230a71" translate="yes" xml:space="preserve">
          <source>',s</source>
          <target state="translated">',에스</target>
        </trans-unit>
        <trans-unit id="f2b4a3c2ef5c9acee2e2b07cd96a5f9d1e6e673d" translate="yes" xml:space="preserve">
          <source>'-c'</source>
          <target state="translated">'-씨'</target>
        </trans-unit>
        <trans-unit id="73b473d5018bb7237c64f8e04aa7c56bacf32f06" translate="yes" xml:space="preserve">
          <source>'-f'</source>
          <target state="translated">'-에프'</target>
        </trans-unit>
        <trans-unit id="f2452b928b7f075642a5aede506ccf7e092065a7" translate="yes" xml:space="preserve">
          <source>'-o'</source>
          <target state="translated">'-영형'</target>
        </trans-unit>
        <trans-unit id="4b984d895b9280fc6c6a99bd994d80216805a02d" translate="yes" xml:space="preserve">
          <source>'-o-'</source>
          <target state="translated">'-영형-'</target>
        </trans-unit>
        <trans-unit id="45e52a27d8ef3bbcb2f3e9bdd693230b8ddcda30" translate="yes" xml:space="preserve">
          <source>'-r'</source>
          <target state="translated">'-아르 자형'</target>
        </trans-unit>
        <trans-unit id="ff557485a3c79412a465b7e3e27d76977730e926" translate="yes" xml:space="preserve">
          <source>'.py'</source>
          <target state="translated">'.py'</target>
        </trans-unit>
        <trans-unit id="0e763cf8e8f0fbeb329546629fb7c87ca1f8d2e3" translate="yes" xml:space="preserve">
          <source>'.py|.pypp'</source>
          <target state="translated">'.py | .pypp'</target>
        </trans-unit>
        <trans-unit id="9a67501b22a9905639b8643c1edcd14ff72b3574" translate="yes" xml:space="preserve">
          <source>'|'</source>
          <target state="translated">'|'</target>
        </trans-unit>
        <trans-unit id="3f0df2804b7f1e7bc0a65c7ffc90f52069b3cf0e" translate="yes" xml:space="preserve">
          <source>(eval 4)</source>
          <target state="translated">(평가 4)</target>
        </trans-unit>
        <trans-unit id="5c10b5b2cd673a0616d529aa5234b12ee7153808" translate="yes" xml:space="preserve">
          <source>,</source>
          <target state="translated">,</target>
        </trans-unit>
        <trans-unit id="fc4128c62d2cb29c0aa56a17f8e2a50ac7e16c0d" translate="yes" xml:space="preserve">
          <source>, and is as simple as this. Just use</source>
          <target state="translated">, 그리고 이것만큼 간단합니다. 그냥 사용</target>
        </trans-unit>
        <trans-unit id="bde01371bc31426a17256ed4ddebb6ae44e4930f" translate="yes" xml:space="preserve">
          <source>, cpypp assumes this is a script and not an
import module. The differences are bellow:</source>
          <target state="translated">, cpypp는 이것이 가져 오기 모듈이 아니라 스크립트라고 가정합니다. 차이점은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="41681967a63926b117f1432a2fba487b6cf11c9f" translate="yes" xml:space="preserve">
          <source>, debugs and so on, or you know exactly what version of Python will execute your code and wants to
generate a final code totally compatible with it. Almost like C does with</source>
          <target state="translated">, 디버그 등을하거나 코드를 실행하는 Python 버전을 정확히 알고 있으며 완전히 호환되는 최종 코드를 생성하려고합니다. C와 거의 비슷합니다.</target>
        </trans-unit>
        <trans-unit id="636f8b9fe3dc87a827def70910418a04df34689c" translate="yes" xml:space="preserve">
          <source>, so nothing inside will
be executed with original code. The preprocessor recognizes this special logical condition, removes it
completely from final code and reident the code to it&amp;rsquo;s original position.</source>
          <target state="translated">이므로 내부의 어떤 것도 원본 코드로 실행되지 않습니다. 전처리 기는이 특별한 논리 조건을 인식하고 최종 코드에서 완전히 제거하고 코드를 원래 위치로 다시 식별합니다.</target>
        </trans-unit>
        <trans-unit id="61228a65297b325fe947519bec2484fdcd4f8194" translate="yes" xml:space="preserve">
          <source>--compileall</source>
          <target state="translated">--compileall</target>
        </trans-unit>
        <trans-unit id="e48240bfde6ac93310ae055c2eebf9ff6e622f84" translate="yes" xml:space="preserve">
          <source>-b</source>
          <target state="translated">-비</target>
        </trans-unit>
        <trans-unit id="ddbfe46d29072725b61a3ee03c6abfefa0973acd" translate="yes" xml:space="preserve">
          <source>-c</source>
          <target state="translated">-씨</target>
        </trans-unit>
        <trans-unit id="92423e5b9fe7d1e45bf27ce69094ce6b214b19f4" translate="yes" xml:space="preserve">
          <source>-c, --compileall</source>
          <target state="translated">-c, --compileall</target>
        </trans-unit>
        <trans-unit id="d5537351313df4188977a7d2a773daedb94d0b26" translate="yes" xml:space="preserve">
          <source>-d</source>
          <target state="translated">-디</target>
        </trans-unit>
        <trans-unit id="d4050801ac6bf0bd3286a63037b59427d9587abf" translate="yes" xml:space="preserve">
          <source>-d &quot;var=2+2&quot;</source>
          <target state="translated">-d &quot;var = 2 + 2&quot;</target>
        </trans-unit>
        <trans-unit id="fe8efd45f5fde0bc7a130af6369d4c2aa0468dc7" translate="yes" xml:space="preserve">
          <source>-d &lt;var&gt;name&lt;/var&gt;</source>
          <target state="translated">-d &lt;var&gt;name&lt;/var&gt;</target>
        </trans-unit>
        <trans-unit id="8adbad1e99380aa99563ee9ff2fe341fa4362035" translate="yes" xml:space="preserve">
          <source>-e &lt;var&gt;EXT&lt;/var&gt;</source>
          <target state="translated">-e &lt;var&gt;EXT&lt;/var&gt;</target>
        </trans-unit>
        <trans-unit id="0abbcbcbe6d61abda4c58f24b76e0809f7c8b425" translate="yes" xml:space="preserve">
          <source>-f</source>
          <target state="translated">-에프</target>
        </trans-unit>
        <trans-unit id="8f7ed0818d22c0fc18c0664c697d91d83576abcf" translate="yes" xml:space="preserve">
          <source>-h, --help</source>
          <target state="translated">-h, --help</target>
        </trans-unit>
        <trans-unit id="c4098177a9bbe3e12bcd36df764ca47436a28306" translate="yes" xml:space="preserve">
          <source>-i &lt;var&gt;FILE&lt;/var&gt;</source>
          <target state="translated">-i &lt;var&gt;FILE&lt;/var&gt;</target>
        </trans-unit>
        <trans-unit id="72643954492815e7bef998457745dc5c6939f550" translate="yes" xml:space="preserve">
          <source>-l &lt;var&gt;MAXLEVELS&lt;/var&gt;</source>
          <target state="translated">-l &lt;var&gt;MAXLEVELS&lt;/var&gt;</target>
        </trans-unit>
        <trans-unit id="ebe9a004e3e3e02b73ac21138437ff2208185cf3" translate="yes" xml:space="preserve">
          <source>-o &lt;var&gt;FILE&lt;/var&gt;</source>
          <target state="translated">-o &lt;var&gt;FILE&lt;/var&gt;</target>
        </trans-unit>
        <trans-unit id="218f161f5f46d85065cd68086eb15271fa74b264" translate="yes" xml:space="preserve">
          <source>-p &lt;var&gt;PATH&lt;/var&gt;</source>
          <target state="translated">-p &lt;var&gt;PATH&lt;/var&gt;</target>
        </trans-unit>
        <trans-unit id="ac33d7b02f2a5c6708f6060ad24e0c1c16b31e96" translate="yes" xml:space="preserve">
          <source>-q</source>
          <target state="translated">-큐</target>
        </trans-unit>
        <trans-unit id="c4af52236d5f8f780dbd829ea30d9fe5c461db86" translate="yes" xml:space="preserve">
          <source>-qq</source>
          <target state="translated">-qq</target>
        </trans-unit>
        <trans-unit id="90cdb7ea49538fa14a6fddf9d2eb1811417d042f" translate="yes" xml:space="preserve">
          <source>-r</source>
          <target state="translated">-아르 자형</target>
        </trans-unit>
        <trans-unit id="af57b72a9f37067605b75f2c3eed0692574b6b86" translate="yes" xml:space="preserve">
          <source>-v, --version</source>
          <target state="translated">-v, --version</target>
        </trans-unit>
        <trans-unit id="096d32b4fd8f1d8b623486a46be185b90972ab84" translate="yes" xml:space="preserve">
          <source>.
The modifiers are</source>
          <target state="translated">. 수정자는</target>
        </trans-unit>
        <trans-unit id="f863c23a93501fd973cdcb1d746f38bd8aa20cad" translate="yes" xml:space="preserve">
          <source>. If</source>
          <target state="translated">. 만약</target>
        </trans-unit>
        <trans-unit id="a1509da8d71b0a65678649dee29dfa3a36433ea9" translate="yes" xml:space="preserve">
          <source>. Like was written before, Python does not implements a preprocessor feature at compile time, so cpypp will simulate it at run time.</source>
          <target state="translated">. 이전에 작성된 것처럼 Python은 컴파일 타임에 전 처리기 기능을 구현하지 않으므로 cpypp는 런타임에이를 시뮬레이션합니다.</target>
        </trans-unit>
        <trans-unit id="c025f541841ad0b414de369a6b47aaea283857e6" translate="yes" xml:space="preserve">
          <source>. So we &lt;strong&gt;HAVE&lt;/strong&gt; to use</source>
          <target state="translated">. 우리는 그래서 &lt;strong&gt;가질&lt;/strong&gt; 사용</target>
        </trans-unit>
        <trans-unit id="0f3775dca467ff2ba7322426cb0af514cdc290a5" translate="yes" xml:space="preserve">
          <source>. The first existing file</source>
          <target state="translated">. 첫 번째 기존 파일</target>
        </trans-unit>
        <trans-unit id="6f3048ec55e037675308b85657f98455307567a3" translate="yes" xml:space="preserve">
          <source>. The first step of compiling will consider this line as a comment and will ignore it. And the
preprocessor will do its job. For example:</source>
          <target state="translated">. 컴파일의 첫 번째 단계는이 줄을 주석으로 간주하고 무시합니다. 그리고 전처리 기가 그 일을 할 것입니다. 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="d4d9377e0c7e0f205c60af0b7e810131e88fffcd" translate="yes" xml:space="preserve">
          <source>. This
will prevent this code to be executed because this condition returns always</source>
          <target state="translated">. 이 조건은 항상 반환하므로이 코드가 실행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c7b2fea527825732afaa04851fdc49faea2b40f2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;#elif&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;#elif&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="14c157798877b84ae3fec492e2bfa1112f125d8f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;#elifdef&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;#elifdef&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3784d87b1d342dca3ee01517e75a7ec23f2814fd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;#else&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;#그밖에&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="382d62c103636ea47783d3bccac35cc4f297cd70" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;#endif&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;#endif&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7978b22ed45731a352aed471e075f62e45d8cd19" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;#endifall&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;#endifall&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="53f45a3c322f2fd050990ba0653caa33159102da" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;#endifif&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;#endifif&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2036836dc6e86ab7bbacccafb94399a511b49e49" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;#endififdef&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;#endififdef&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b4b54aa6c6af032b2dc91f32d202731556df5aaa" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;#if&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;#만약&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e6244c981090273d1a37c202b82190dffff8e875" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;#ifdef&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;#ifdef&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e5af2f442da4e9fe374155f408ec1cee2f16573f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;#ifndef&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;#ifndef&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d1a238e435439f10774b0d340c45bdd597284fe9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;#include&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;#포함&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8eda2e4cc3d6fa79a1f30ac0e6537942e1b82852" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;cpypp&lt;/strong&gt; can be easily installed via common Python package managers such as pip.</source>
          <target state="translated">&lt;strong&gt;cpypp&lt;/strong&gt; 는 pip와 같은 일반적인 Python 패키지 관리자를 통해 쉽게 설치할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="46d6f90cd5d579f91399afc234a696f35e67d511" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;cpypp&lt;/strong&gt; is the implementation of a c-stype preprocessor for Python Programming Languages 2.7+</source>
          <target state="translated">&lt;strong&gt;cpypp&lt;/strong&gt; 는 Python 프로그래밍 언어 2.7 이상을위한 c-stype 전 처리기의 구현입니다.</target>
        </trans-unit>
        <trans-unit id="6fae5e85a5ad6524ab63165a1e39ed7448263e8b" translate="yes" xml:space="preserve">
          <source>A preprocessor is a program that takes a input Source Code written using some
programming language syntax and outputs an output Source Code that translate,
expand or modify original programming language.</source>
          <target state="translated">전처리 기는 일부 프로그래밍 언어 구문을 사용하여 작성된 입력 소스 코드를 가져와 원래 프로그래밍 언어를 번역, 확장 또는 수정하는 출력 소스 코드를 출력하는 프로그램입니다.</target>
        </trans-unit>
        <trans-unit id="8e591539fe6752bcd7c721ba479dab3b493d378b" translate="yes" xml:space="preserve">
          <source>Another thing that is very important:</source>
          <target state="translated">매우 중요한 또 다른 사항 :</target>
        </trans-unit>
        <trans-unit id="8a22ec7f7caada908bc4ea6315064b3243bd5859" translate="yes" xml:space="preserve">
          <source>Any references to name definitions done with</source>
          <target state="translated">로 수행 된 이름 정의에 대한 모든 참조</target>
        </trans-unit>
        <trans-unit id="d26db5ef005b837d41c46f3393441a13721ab4a3" translate="yes" xml:space="preserve">
          <source>As you remember, the original code is compiled twice, one before the preprocessor and other after.
So at both compiling steps the code must be correct and without syntax or grammar errors.</source>
          <target state="translated">아시다시피 원본 코드는 전 처리기 이전과 이후에 하나씩 두 번 컴파일됩니다. 따라서 두 컴파일 단계에서 코드는 정확해야하며 구문 또는 문법 오류가 없어야합니다.</target>
        </trans-unit>
        <trans-unit id="40d8d8999cba27e5eb1975862c0479088541abf0" translate="yes" xml:space="preserve">
          <source>Be atention to step 3.2.4. When the code is executed as a script we can stop the execution of the old code,
because we have sure that the new code was all executed stand alone. But we still have a problem. All the code
before</source>
          <target state="translated">3.2.4 단계에주의하십시오. 코드가 스크립트로 실행되면 새 코드가 모두 독립적으로 실행되었는지 확인하기 때문에 이전 코드의 실행을 중지 할 수 있습니다. 하지만 여전히 문제가 있습니다. 이전의 모든 코드</target>
        </trans-unit>
        <trans-unit id="6a667ae4f3537eaf0520f77cf351e15ab8bd20c0" translate="yes" xml:space="preserve">
          <source>But how can we do it at runtime? How can we modify a code that is compiled and running? The answer is
obvious: We can&amp;rsquo;t. We can rewrite the code and executs it again, inside itself. In other words, we will execute
the source code twice. The first version is the original version where directives are seen as comments
by compiler. This code will be compiled and executed normally. During this execution when the</source>
          <target state="translated">그러나 런타임에 어떻게 할 수 있습니까? 컴파일되고 실행되는 코드를 어떻게 수정할 수 있습니까? 대답은 분명합니다. 우리는 할 수 없습니다. 코드를 다시 작성하고 내부에서 다시 실행할 수 있습니다. 즉, 소스 코드를 두 번 실행합니다. 첫 번째 버전은 지시문이 컴파일러에 의해 주석으로 표시되는 원래 버전입니다. 이 코드는 정상적으로 컴파일되고 실행됩니다. 이 실행 중에</target>
        </trans-unit>
        <trans-unit id="c439d00a46cd7d5dcefb29627b0c367d073adf94" translate="yes" xml:space="preserve">
          <source>But, when you write open source code, a lot of</source>
          <target state="translated">하지만 오픈 소스 코드를 작성할 때 많은</target>
        </trans-unit>
        <trans-unit id="1fb7469a8dbfbdba32137d45c51454b4013f0620" translate="yes" xml:space="preserve">
          <source>Close all opened blocks no matter if they are inner or outter. Use with care.</source>
          <target state="translated">내부 또는 외부에 관계없이 열려있는 모든 블록을 닫습니다. 주의해서 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="8deb7fabcb81e9ac0bf4789ec98eaf683e946b98" translate="yes" xml:space="preserve">
          <source>Closes the last opened block of code at same level</source>
          <target state="translated">같은 수준에서 마지막으로 열린 코드 블록을 닫습니다.</target>
        </trans-unit>
        <trans-unit id="a44cdb9214e3b59062f20c0084d472389e9cec0d" translate="yes" xml:space="preserve">
          <source>Closes the last opened block of code,  opens a new block of code</source>
          <target state="translated">마지막으로 열린 코드 블록을 닫고 새 코드 블록을 엽니 다.</target>
        </trans-unit>
        <trans-unit id="8a05cf2ec55e3b838faf9f8c4e94c4ce83d07829" translate="yes" xml:space="preserve">
          <source>Code protection (#expand)</source>
          <target state="translated">코드 보호 (#expand)</target>
        </trans-unit>
        <trans-unit id="940c9aed0d99205d0b7048706f90d7fed63706ae" translate="yes" xml:space="preserve">
          <source>Command line preprocessor</source>
          <target state="translated">명령 줄 전 처리기</target>
        </trans-unit>
        <trans-unit id="21a2cf66c9d18dba1e9311aa2b52a8c6cc0ca0c1" translate="yes" xml:space="preserve">
          <source>Command line preprocessor is when you have source code files and wants to generate new preprocessed files in
batch mode. Probably you are a developer and want to insert copyright marks, or remove something from final code, like</source>
          <target state="translated">명령 줄 전처리 기는 소스 코드 파일이 있고 배치 모드에서 새로운 전처리 파일을 생성하려는 경우입니다. 아마도 당신은 개발자이고 저작권 표시를 삽입하거나 최종 코드에서 무언가를 제거하고 싶을 것입니다.</target>
        </trans-unit>
        <trans-unit id="47d020036e9cf04f0d0fc4ef13e1bed46c3f7376" translate="yes" xml:space="preserve">
          <source>Conditional inclusions (#if, #else, #endif and its variations)</source>
          <target state="translated">조건부 포함 (#if, #else, #endif 및 해당 변형)</target>
        </trans-unit>
        <trans-unit id="f5cbdf6bfb51439be085b5c6b7460a7c91eabc3c" translate="yes" xml:space="preserve">
          <source>Contents</source>
          <target state="translated">내용</target>
        </trans-unit>
        <trans-unit id="2d82a4b27a4b305690d5ac612046a955778a9fa5" translate="yes" xml:space="preserve">
          <source>Contributing</source>
          <target state="translated">기여</target>
        </trans-unit>
        <trans-unit id="c1647df5eb3be69a98116ef1f5a5eb30ca670988" translate="yes" xml:space="preserve">
          <source>Define names, or names with values that will be stored in definition dictionary.</source>
          <target state="translated">이름 또는 정의 사전에 저장 될 값으로 이름을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="c71baac6db23ae23022f07217836c43de91d4e47" translate="yes" xml:space="preserve">
          <source>Depending of your code, sometimes you want to exclude an entire block of code if some conditions are met or not
or not, or  maybe you wants that only the preprocessor executes this portion of code, but wants remove this
portion from final code. For this we have the directives &lt;strong&gt;#exclude&lt;/strong&gt; and &lt;strong&gt;#endexclude&lt;/strong&gt;. All inside this two directives will be completely exclude from final code, but will be seen by preprocessor.</source>
          <target state="translated">코드에 따라 일부 조건이 충족되거나 충족되지 않는 경우 전체 코드 블록을 제외하거나 전처리기만 코드의이 부분을 실행하지만 최종 코드에서이 부분을 제거하기를 원할 수 있습니다. 이를 위해 우리는 지시어가 &lt;strong&gt;#exclude&lt;/strong&gt; 및 &lt;strong&gt;#endexclude을&lt;/strong&gt; . 이 두 지시문 내부의 모든 것은 최종 코드에서 완전히 제외되지만 전처리기에 의해 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="28c82071e940360118b0611d5c912a71c32a0100" translate="yes" xml:space="preserve">
          <source>Directives</source>
          <target state="translated">지시어</target>
        </trans-unit>
        <trans-unit id="eb01bf04c9a0e8a71c45816513df424f1c7ffedb" translate="yes" xml:space="preserve">
          <source>Examples</source>
          <target state="translated">예</target>
        </trans-unit>
        <trans-unit id="5e450fc115a2e2636750ab550a50bc321e7a222f" translate="yes" xml:space="preserve">
          <source>Examples of Conditional inclusions</source>
          <target state="translated">조건부 포함의 예</target>
        </trans-unit>
        <trans-unit id="b55d2c620472596174331dd411896923ce80fe54" translate="yes" xml:space="preserve">
          <source>Exclusion blocks (#exclude and #endexclude)</source>
          <target state="translated">제외 블록 (#exclude 및 #endexclude)</target>
        </trans-unit>
        <trans-unit id="c3d79210e1322f48fa31e9feae1d20309d98e580" translate="yes" xml:space="preserve">
          <source>Expander</source>
          <target state="translated">확장기</target>
        </trans-unit>
        <trans-unit id="ff54ccf57fb69ceebaba360d39de46f523e9ace6" translate="yes" xml:space="preserve">
          <source>Expressions expander</source>
          <target state="translated">식 확장기</target>
        </trans-unit>
        <trans-unit id="97cdbdc7feff827efb082a6b6dd2727237cd49fd" translate="yes" xml:space="preserve">
          <source>False</source>
          <target state="translated">그릇된</target>
        </trans-unit>
        <trans-unit id="c472f3fa36ed477a11646c532691e74a9b240f06" translate="yes" xml:space="preserve">
          <source>First let&amp;rsquo;s see a graphical flow how Python and cpypp will do their job to guarantee that the preprocessor will work
properly when running a script.</source>
          <target state="translated">먼저 스크립트를 실행할 때 전처리 기가 제대로 작동하도록 Python과 cpypp가 작업을 수행하는 방법을 그래픽 흐름으로 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="bec506fe309b399e08a72b78fe4e65a4ad70538b" translate="yes" xml:space="preserve">
          <source>For example, from this:</source>
          <target state="translated">예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0daafbfc8f622fbbbf3dc05ed0fe2f79d7ba67f6" translate="yes" xml:space="preserve">
          <source>For example, the code:</source>
          <target state="translated">예를 들어 코드는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7303bf48a14262cd93889d346e8351366e37022d" translate="yes" xml:space="preserve">
          <source>For more complexes replacements there is expression expander. All text between expander begin mark</source>
          <target state="translated">더 복잡한 대체를 위해 표현식 확장기가 있습니다. 확장기 시작 표시 사이의 모든 텍스트</target>
        </trans-unit>
        <trans-unit id="2380d497ad617eb7e2e81ecccdff462db23a2d1b" translate="yes" xml:space="preserve">
          <source>Here are all the conditional inclusions directives and how they are evalueted.</source>
          <target state="translated">다음은 모든 조건부 포함 지침과 평가 방법입니다.</target>
        </trans-unit>
        <trans-unit id="9f381f33b75d1f53ccefa2484f1b0005f2df8db2" translate="yes" xml:space="preserve">
          <source>Here we have no flow. It&amp;rsquo;s just a command line tool that has some parameters and you can run it from shell.</source>
          <target state="translated">여기에는 흐름이 없습니다. 일부 매개 변수가있는 명령 줄 도구 일 뿐이며 셸에서 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="89378b16c31d72a2a6eaaa1a654dfc7dc3897653" translate="yes" xml:space="preserve">
          <source>How Python and cpypp works when source code is a module to be imported</source>
          <target state="translated">소스 코드가 가져올 모듈 일 때 Python 및 cpypp가 작동하는 방식</target>
        </trans-unit>
        <trans-unit id="6f7acfefdf9d7dcb5910019624356f4b181873b3" translate="yes" xml:space="preserve">
          <source>How Python and cpypp works when source code is a script</source>
          <target state="translated">소스 코드가 스크립트 일 때 Python과 cpypp가 작동하는 방식</target>
        </trans-unit>
        <trans-unit id="c51e13b37eaa0c53e5452016c17c0814b47c3f1a" translate="yes" xml:space="preserve">
          <source>I love to write code, and I love to keep my code clean and organized, specially when
I publish it on github for example. I love to use the latest features of a
language and I specially love debug with</source>
          <target state="translated">저는 코드 작성을 좋아하고, 특히 예를 들어 github에 게시 할 때 코드를 깨끗하고 체계적으로 유지하는 것을 좋아합니다. 저는 언어의 최신 기능을 사용하는 것을 좋아하고 특히 디버그를 좋아합니다.</target>
        </trans-unit>
        <trans-unit id="945f2bc6b605fa7fd2462098373a0488dd4a9bcf" translate="yes" xml:space="preserve">
          <source>If the file exists it will be included.</source>
          <target state="translated">파일이 있으면 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="a0cc952cae3167f49ab26bf3a445b3460dedd2db" translate="yes" xml:space="preserve">
          <source>If we check the preprocessed file we will find:</source>
          <target state="translated">전처리 된 파일을 확인하면 다음을 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c86a7763a1ddfd1423a6fd2bb6509a55058a7391" translate="yes" xml:space="preserve">
          <source>Ignore blocks (#ignore and #endignore)</source>
          <target state="translated">블록 무시 (#ignore 및 #endignore)</target>
        </trans-unit>
        <trans-unit id="e38432618ce4d39079fc324e614d4d92a2815160" translate="yes" xml:space="preserve">
          <source>Installing</source>
          <target state="translated">설치 중</target>
        </trans-unit>
        <trans-unit id="2473e96bc614a911821242119918a241a41836d6" translate="yes" xml:space="preserve">
          <source>Introduction</source>
          <target state="translated">소개</target>
        </trans-unit>
        <trans-unit id="b597d5de533fb5ff2774b6652d2cd5550e6c6f84" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s import all of then</source>
          <target state="translated">모두 가져 오자</target>
        </trans-unit>
        <trans-unit id="cc4658e13c1f74197dbe84aee61832a475b85078" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s use one of our script files</source>
          <target state="translated">스크립트 파일 중 하나를 사용하겠습니다.</target>
        </trans-unit>
        <trans-unit id="76cdb950721642b6b8596d36d5a39f7705028b99" translate="yes" xml:space="preserve">
          <source>Move</source>
          <target state="translated">움직임</target>
        </trans-unit>
        <trans-unit id="bf5014f4a712ee33f29051b6857fe8c934a3cb0d" translate="yes" xml:space="preserve">
          <source>Name definitions (#define, #undef)</source>
          <target state="translated">이름 정의 (#define, #undef)</target>
        </trans-unit>
        <trans-unit id="08232968d95dc440ee6a9bc1dc16c8090c77800b" translate="yes" xml:space="preserve">
          <source>Name definitions expander</source>
          <target state="translated">이름 정의 확장기</target>
        </trans-unit>
        <trans-unit id="2d4c16838b357bab6b2d83f3daefd32b26c9b4f1" translate="yes" xml:space="preserve">
          <source>Now let&amp;rsquo;s run</source>
          <target state="translated">이제 뛰자</target>
        </trans-unit>
        <trans-unit id="ba0927db646cfd02886bd73a8221b4d4c045843b" translate="yes" xml:space="preserve">
          <source>Now let&amp;rsquo;s see this code.</source>
          <target state="translated">이제이 코드를 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="2de7b63e160732f812e89f79cc865b666476f6ea" translate="yes" xml:space="preserve">
          <source>Now the first compiling will occur with no problem no matter what Python version is used
and the preprocessor will go on.</source>
          <target state="translated">이제 첫 번째 컴파일은 어떤 Python 버전을 사용하든 전처리 기가 계속 진행 되더라도 문제없이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="62cf3d2f74c5a26ac85006ed57545f720f13daf9" translate="yes" xml:space="preserve">
          <source>Now, let&amp;rsquo;s see a graphical flow how Python and cpypp will do their job to guarantee that the preprocessor will work
properly when importing a module</source>
          <target state="translated">이제 Python과 cpypp가 모듈을 가져올 때 전처리 기가 제대로 작동하도록 보장하기 위해 어떻게 작동하는지 그래픽 흐름을 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="b66bad3ebeda6a517239548b5e5cc2d9968169a7" translate="yes" xml:space="preserve">
          <source>Open a block of code and includes it if</source>
          <target state="translated">코드 블록을 열고 다음과 같은 경우 포함합니다.</target>
        </trans-unit>
        <trans-unit id="c0742588a3c9b7fbacede6d3b7e13a0278ed8cc2" translate="yes" xml:space="preserve">
          <source>Open a block of code and includes its content if</source>
          <target state="translated">코드 블록을 열고 해당 내용을 포함하는 경우</target>
        </trans-unit>
        <trans-unit id="426c72346dffc3a5635992cd4ab0a814aef725fa" translate="yes" xml:space="preserve">
          <source>Opens a block of code and includes its content if</source>
          <target state="translated">코드 블록을 열고 다음과 같은 경우 내용을 포함합니다.</target>
        </trans-unit>
        <trans-unit id="6bf5da9c080bee3a8142586c412aa39971137eee" translate="yes" xml:space="preserve">
          <source>Options</source>
          <target state="translated">옵션</target>
        </trans-unit>
        <trans-unit id="4ba991082665a410c3499793b5815610568afc4c" translate="yes" xml:space="preserve">
          <source>Or you can protect nothing if you code has only global, classes and defs definitions. See</source>
          <target state="translated">또는 코드에 global, classes 및 defs 정의 만있는 경우 아무것도 보호 할 수 없습니다. 보다</target>
        </trans-unit>
        <trans-unit id="ea27bf0bc2aeb489b1eb20443d8ea611ecac3072" translate="yes" xml:space="preserve">
          <source>Or you can protect the all code. See</source>
          <target state="translated">또는 모든 코드를 보호 할 수 있습니다. 보다</target>
        </trans-unit>
        <trans-unit id="b81f14811442d50ef2b4cc48e94b456e1d1cd7cb" translate="yes" xml:space="preserve">
          <source>PYPP</source>
          <target state="translated">PYPP</target>
        </trans-unit>
        <trans-unit id="eb39c630e66b76c16119fa5e85da46bdc1495ae8" translate="yes" xml:space="preserve">
          <source>PYPP.</source>
          <target state="translated">PYPP.</target>
        </trans-unit>
        <trans-unit id="7511905ed24a144c822dc72a2fea20903562bc5d" translate="yes" xml:space="preserve">
          <source>PYPP.parse (...</source>
          <target state="translated">PYPP.parse (...</target>
        </trans-unit>
        <trans-unit id="1f7fbabcd404fd8801e9bbed403dc2a0656ab395" translate="yes" xml:space="preserve">
          <source>PYPP.parse( ...</source>
          <target state="translated">PYPP.parse (...</target>
        </trans-unit>
        <trans-unit id="551767c1168de4f63d2c04d76f126955a15f1aad" translate="yes" xml:space="preserve">
          <source>PYPP.parse(...</source>
          <target state="translated">PYPP.parse (...</target>
        </trans-unit>
        <trans-unit id="d93c405b093a6de4aee20f482d59768336c5ff05" translate="yes" xml:space="preserve">
          <source>Please send an email to &lt;a href=&quot;mailto:wellrats%40gmail.com&quot;&gt;wellrats@gmail.com&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;mailto:wellrats%40gmail.com&quot;&gt;wellrats@gmail.com&lt;/a&gt; 으로 이메일을 보내주세요.</target>
        </trans-unit>
        <trans-unit id="1924a90eb0bfd4aee783d5923b2f0c3853fcf13a" translate="yes" xml:space="preserve">
          <source>Preprocessing and compiling code at once</source>
          <target state="translated">한 번에 코드 전처리 및 컴파일</target>
        </trans-unit>
        <trans-unit id="5e5b1a5fb349b00e6acf0c1f3c718a54a6d5f9a5" translate="yes" xml:space="preserve">
          <source>Realize that any references to</source>
          <target state="translated">에 대한 모든 참조는</target>
        </trans-unit>
        <trans-unit id="1e19887b8b427b60baef031bd790a2671aff1397" translate="yes" xml:space="preserve">
          <source>RunTime preprocessor is when you have the source code and wants to execute this code respecting the
preprocessor directives. Probably you are a developer and want to insert some tests or let the code be prepared
to future releases of Python, but don&amp;rsquo;t want this</source>
          <target state="translated">런타임 전처리 기는 소스 코드가 있고 전 처리기 지시문에 따라이 코드를 실행하려는 경우입니다. 아마도 당신은 개발자이고 몇 가지 테스트를 삽입하거나 Python의 향후 릴리스에 대한 코드를 준비하고 싶지만 이것을 원하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="ee43622e92d28bfc9b9d1842244e7dfd638953fb" translate="yes" xml:space="preserve">
          <source>Runtime or command line processor?</source>
          <target state="translated">런타임 또는 명령 행 프로세서?</target>
        </trans-unit>
        <trans-unit id="6cb1909f3b33a4efa9a23776d4e3e9a1b77493f5" translate="yes" xml:space="preserve">
          <source>Runtime preprocessor</source>
          <target state="translated">런타임 전 처리기</target>
        </trans-unit>
        <trans-unit id="e4885aae1873b14658a213181045deb297f47c4f" translate="yes" xml:space="preserve">
          <source>Same as &lt;strong&gt;#endif&lt;/strong&gt; + &lt;strong&gt;#if&lt;/strong&gt; but at the same line</source>
          <target state="translated">동일 &lt;strong&gt;#endif 다음&lt;/strong&gt; + &lt;strong&gt;의 #if&lt;/strong&gt; 하지만 같은 라인에서</target>
        </trans-unit>
        <trans-unit id="5aa38eeaf53a392c3b42a67f538984d8208a3aea" translate="yes" xml:space="preserve">
          <source>Same as &lt;strong&gt;#endif&lt;/strong&gt; + &lt;strong&gt;#ifdef&lt;/strong&gt; but at the same line</source>
          <target state="translated">동일 &lt;strong&gt;#endif 다음&lt;/strong&gt; + &lt;strong&gt;#ifdef와&lt;/strong&gt; 만 같은 줄에</target>
        </trans-unit>
        <trans-unit id="9faf7f1d2beb43ddaef784a2f55f095f452334c1" translate="yes" xml:space="preserve">
          <source>So the first step is instantiate a preprocessor in our source code:</source>
          <target state="translated">따라서 첫 번째 단계는 소스 코드에서 전처리기를 인스턴스화하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="52efbb47e78fe560ce2b4dd873a06a77d203b28a" translate="yes" xml:space="preserve">
          <source>So this was the motivation to get the best of both worlds (thank you for Hanna Montanna).
Create a preprocessor for Python language that could keep final code clean, stable, runnable in
any version of Python, working at run time, or used as a command line tool for batch conversion.</source>
          <target state="translated">그래서 이것은 두 세계를 최대한 활용하려는 동기였습니다 (Hanna Montanna에게 감사드립니다). 최종 코드를 깨끗하고 안정적이며 모든 버전의 Python에서 실행 가능하고 런타임에 작동하거나 일괄 변환을위한 명령 줄 도구로 사용할 수있는 Python 언어 용 전처리기를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="d8083638b937f9f8e00adb6b72fd6276e8775f0d" translate="yes" xml:space="preserve">
          <source>So, let&amp;rsquo;s run it using python 3.7</source>
          <target state="translated">자, 파이썬 3.7을 사용하여 실행 해 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="5b14fe50cd51598706b29c4fa34e38d557a0093d" translate="yes" xml:space="preserve">
          <source>So, let&amp;rsquo;s try again &amp;hellip;</source>
          <target state="translated">그러니 다시 해보 죠 ...</target>
        </trans-unit>
        <trans-unit id="d0077dd93c4f3507651346c67b7f2ba8b8cf1aa6" translate="yes" xml:space="preserve">
          <source>Sometimes we want to implement some features in our code that are not available in all Python versions,
but we need that our code compile correctly so the preprocessor can do its work. For this we have</source>
          <target state="translated">때로는 모든 Python 버전에서 사용할 수없는 일부 기능을 코드에 구현하고 싶지만 코드가 올바르게 컴파일되어 전처리 기가 작업을 수행 할 수 있어야합니다. 이를 위해 우리는</target>
        </trans-unit>
        <trans-unit id="197b64f4f60650c797fb5cdda78cfaca0a81d7c6" translate="yes" xml:space="preserve">
          <source>Source file inclusion (#include and #includeident)</source>
          <target state="translated">소스 파일 포함 (#include 및 #includeident)</target>
        </trans-unit>
        <trans-unit id="5af295c810e95d6747d6d61b3b26e4afedee8f5e" translate="yes" xml:space="preserve">
          <source>Supose that</source>
          <target state="translated">그것을 제기</target>
        </trans-unit>
        <trans-unit id="9730d4326a7b8a0d13c2be3b7fe29b80ad152bf6" translate="yes" xml:space="preserve">
          <source>Table of Contents</source>
          <target state="translated">목차</target>
        </trans-unit>
        <trans-unit id="190e807925e8c6757d86ba8cfa26a6e26e9acaca" translate="yes" xml:space="preserve">
          <source>The code above will generate a compile error if we try to run it on Python 3+, because the first</source>
          <target state="translated">위 코드는 Python 3 이상에서 실행하려고하면 컴파일 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="a5f0285219672a98a5cdc526c9b2475e495e86b4" translate="yes" xml:space="preserve">
          <source>The options to solve this issue are:</source>
          <target state="translated">이 문제를 해결하기위한 옵션은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f8d66cb6a822061ff5f75d45a14871d91cf16cb2" translate="yes" xml:space="preserve">
          <source>The reason is: When the preprocessor is doing its job, it will look for this piece of code
and some references to</source>
          <target state="translated">이유는 다음과 같습니다. 전처리 기가 작업을 수행 할 때이 코드와 일부 참조를 찾습니다.</target>
        </trans-unit>
        <trans-unit id="4514f9582fa4224c87b0a5bfc1fc93a248132f7e" translate="yes" xml:space="preserve">
          <source>The second step is write the directives in source code to give work to the preprocessor.
Directives are like coments and can be written anywhere in the code. All the directives and
its rules will be explained bellow.</source>
          <target state="translated">두 번째 단계는 소스 코드에 지시문을 작성하여 전처리기에 작업을 제공하는 것입니다. 지시문은 코드와 같으며 코드의 어느 곳에서나 작성할 수 있습니다. 모든 지침과 규칙은 아래에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="1f32995c44f22a86c480c4233bd2948349d2133f" translate="yes" xml:space="preserve">
          <source>The third step is call the preprocessor so it can do its job:</source>
          <target state="translated">세 번째 단계는 작업을 수행 할 수 있도록 전처리기를 호출하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="8a469aafa787c8a19dbdab8b41cbe21fa0a97da9" translate="yes" xml:space="preserve">
          <source>There are diferences from a script code. We have</source>
          <target state="translated">스크립트 코드와 다른 점이 있습니다. 우리는</target>
        </trans-unit>
        <trans-unit id="1f1d81668669fd3e6e80ee0e960eb0917f71dc94" translate="yes" xml:space="preserve">
          <source>There&amp;rsquo;s a little difference if original code is executed as a script or is being imported.
When the variable</source>
          <target state="translated">원본 코드를 스크립트로 실행하거나 가져 오는 경우 약간의 차이가 있습니다. 변수가</target>
        </trans-unit>
        <trans-unit id="6a7aa61c9ba773f50b4996b4ef5612322cb1c607" translate="yes" xml:space="preserve">
          <source>These directives allow to include or discard part of the original code, also called code blocks if a certain
condition is met or not.
It works the same manner that</source>
          <target state="translated">이러한 지시문은 특정 조건이 충족되거나 충족되지 않는 경우 코드 블록이라고도하는 원래 코드의 일부를 포함하거나 삭제할 수 있습니다. 동일한 방식으로 작동합니다.</target>
        </trans-unit>
        <trans-unit id="976ad551b6aaebf3e3c8c28f9c7452a81800605a" translate="yes" xml:space="preserve">
          <source>These directives do exactly what their name says. They ignore from the preprocessor an entire block of code.</source>
          <target state="translated">이 지시문은 이름이 말하는 것과 정확히 일치합니다. 그들은 전 처리기에서 전체 코드 블록을 무시합니다.</target>
        </trans-unit>
        <trans-unit id="bf08d43fd2ed5eda3cb2964572627b24911d2e02" translate="yes" xml:space="preserve">
          <source>This means that a code like:</source>
          <target state="translated">이것은 다음과 같은 코드를 의미합니다.</target>
        </trans-unit>
        <trans-unit id="efd4f48a2d6ba9a1e4cd75239db27e30263abb38" translate="yes" xml:space="preserve">
          <source>To remove an entry from definition dictionary use</source>
          <target state="translated">정의 사전에서 항목을 제거하려면</target>
        </trans-unit>
        <trans-unit id="c96d402a2f375fbc6622835969a1208a15404d85" translate="yes" xml:space="preserve">
          <source>To test your installation, cpypp come with a set of simple tutorials that can be executed once you
have deployed the packages</source>
          <target state="translated">설치를 테스트하기 위해 cpypp는 패키지를 배포 한 후 실행할 수있는 간단한 자습서 세트와 함께 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="88b33e4e12f75ac8bf792aebde41f1a090f3a612" translate="yes" xml:space="preserve">
          <source>True</source>
          <target state="translated">진실</target>
        </trans-unit>
        <trans-unit id="861a0e430ffac5e4ae6e11b7a947f2c32d388cf4" translate="yes" xml:space="preserve">
          <source>Usage:</source>
          <target state="translated">용법:</target>
        </trans-unit>
        <trans-unit id="db8054592d75bdee4fc57827bdeb21a25d0da752" translate="yes" xml:space="preserve">
          <source>Use the special logical condition</source>
          <target state="translated">특수한 논리 조건 사용</target>
        </trans-unit>
        <trans-unit id="025b52c36eadb26d2ad2aaec01e7033d6dfa75b6" translate="yes" xml:space="preserve">
          <source>Usually a preprocessor do its job at compile time, but Python don&amp;rsquo;t have this feature
so, pypy has two options do its job: at run time, when you are executing a source file as
a script or as a import module, or using a command line tool. Which to choose is up to you
and your motivations to use a preprocessor. Let&amp;rsquo;s see the diferences between then.</source>
          <target state="translated">일반적으로 전처리 기는 컴파일 시간에 작업을 수행하지만 Python에는이 기능이 없으므로 pypy에는 두 가지 옵션이 있습니다. 런타임에 소스 파일을 스크립트 또는 가져 오기 모듈로 실행하거나 명령 줄 도구. 선택하는 것은 전처리기를 사용하려는 귀하와 귀하의 동기에 달려 있습니다. 그때의 차이점을 봅시다.</target>
        </trans-unit>
        <trans-unit id="80255b951add1a01c17ff8a5d5df31cfb8e41998" translate="yes" xml:space="preserve">
          <source>We imported numpy package only at preprocessor time to get the values of these two constants and set two local
variables.</source>
          <target state="translated">이 두 상수의 값을 가져오고 두 개의 지역 변수를 설정하기 위해 전 처리기 시간에만 numpy 패키지를 가져 왔습니다.</target>
        </trans-unit>
        <trans-unit id="efdbc9e7113e42f96134d43ccf17cd51615ebd32" translate="yes" xml:space="preserve">
          <source>Welcome to repository of cpypp</source>
          <target state="translated">cpypp 저장소에 오신 것을 환영합니다.</target>
        </trans-unit>
        <trans-unit id="6cc8b737f37a405baa2775711f4a4b6f0f425f5f" translate="yes" xml:space="preserve">
          <source>Well, it didn&amp;rsquo;t work as expected  😩. The first print was executed twice. The reason was
explained earlier. All code before</source>
          <target state="translated">음, 예상대로 작동하지 않았습니다 😩. 첫 번째 인쇄는 두 번 실행되었습니다. 그 이유는 앞서 설명했습니다. 이전의 모든 코드</target>
        </trans-unit>
        <trans-unit id="e45d4520a7ab5dd81b2deac6cbe95b78dffecf4b" translate="yes" xml:space="preserve">
          <source>When filename is not specified between angle-brackes, cpypp assumes that this</source>
          <target state="translated">꺾쇠 괄호 사이에 파일 이름이 지정되지 않은 경우 cpypp는 다음과 같이 가정합니다.</target>
        </trans-unit>
        <trans-unit id="eff555b129d1bb7281a3154203d929d649a3ef3c" translate="yes" xml:space="preserve">
          <source>When filename is specified between angle-backets, cpypp looks for the</source>
          <target state="translated">angle-backet 사이에 파일 이름이 지정되면 cpypp는</target>
        </trans-unit>
        <trans-unit id="3a8bd105f2f4cbfa21d424b1c5c6a919772174eb" translate="yes" xml:space="preserve">
          <source>When the preprocessor encounters this directive, it creates an entry in its definition dictionary with name</source>
          <target state="translated">전처리 기가이 지시문을 만나면 정의 사전에 이름이있는 항목을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="99b297fb1480f869aa063fac41ec58d3c1e2eaf7" translate="yes" xml:space="preserve">
          <source>When the preprocessor finds an</source>
          <target state="translated">전처리 기가</target>
        </trans-unit>
        <trans-unit id="8a0ba0e5ce7ea94d795fce3633c5d21a72724664" translate="yes" xml:space="preserve">
          <source>With option 1 we have</source>
          <target state="translated">옵션 1을 사용하면</target>
        </trans-unit>
        <trans-unit id="e2fbeeca1ba4c81f7a9afdae03067503089e0d46" translate="yes" xml:space="preserve">
          <source>With option 2 we have</source>
          <target state="translated">옵션 2를 사용하면</target>
        </trans-unit>
        <trans-unit id="f17ba61e3f6c2c103cc8d85e74b2c11da37cd080" translate="yes" xml:space="preserve">
          <source>Yeah again😁. Here the rule is that for import modules, we have to use</source>
          <target state="translated">그래 또 😁. 여기서 규칙은 가져 오기 모듈의 경우</target>
        </trans-unit>
        <trans-unit id="a0a8374a097536a6b87b604a9e66cdbf6535c674" translate="yes" xml:space="preserve">
          <source>Yeah 😁. So the first rule of cpypp is that for scripts, we have to keep our</source>
          <target state="translated">예 😁. 따라서 cpypp의 첫 번째 규칙은 스크립트의 경우</target>
        </trans-unit>
        <trans-unit id="ab9d7be9aab4f8c03050f6431451c6a1a5009b2b" translate="yes" xml:space="preserve">
          <source>You can protect only what is relevant. See</source>
          <target state="translated">관련된 것만 보호 할 수 있습니다. 보다</target>
        </trans-unit>
        <trans-unit id="3a449c61ec05be6ece47231fed2c222a99923d19" translate="yes" xml:space="preserve">
          <source>You may also get the latest &lt;strong&gt;cpypp&lt;/strong&gt; version by grabbing the source code from Github:</source>
          <target state="translated">Github에서 소스 코드를 가져 와서 최신 &lt;strong&gt;cpypp&lt;/strong&gt; 버전을 얻을 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="abc4428089d4c2510a18da3febcc1b40c25975f6" translate="yes" xml:space="preserve">
          <source>Your bytecodes (.pyc) where generated using the preprocessed file and are ready to deploy. For more
information and usage execute</source>
          <target state="translated">사전 처리 된 파일을 사용하여 생성되고 배포 할 준비가 된 바이트 코드 (.pyc). 자세한 정보 및 사용법을 보려면</target>
        </trans-unit>
        <trans-unit id="c1dab70a8cae8ab6675cd1dd0933150036c91264" translate="yes" xml:space="preserve">
          <source>__name__</source>
          <target state="translated">__이름__</target>
        </trans-unit>
        <trans-unit id="40d47c46fbf25f794efdf1de2544c6a7f06f954c" translate="yes" xml:space="preserve">
          <source>above and at same level was not</source>
          <target state="translated">위와 같은 수준에서</target>
        </trans-unit>
        <trans-unit id="d90deeff97faa9f9a8ba7ffed97ed81323163e7f" translate="yes" xml:space="preserve">
          <source>add all the files and directories listed in FILE to the
list considered for compilation; Use</source>
          <target state="translated">FILE에 나열된 모든 파일과 디렉토리를 컴파일 대상 목록에 추가합니다. 사용하다</target>
        </trans-unit>
        <trans-unit id="a1bc5869a53344c2d3013eda1c62fe299b671145" translate="yes" xml:space="preserve">
          <source>after all references to</source>
          <target state="translated">모든 참조 후</target>
        </trans-unit>
        <trans-unit id="b0a89a660f618580d82f624044b1baaddd375168" translate="yes" xml:space="preserve">
          <source>after preprocessing will become:</source>
          <target state="translated">전처리 후 다음과 같이됩니다.</target>
        </trans-unit>
        <trans-unit id="c0ce503d7857ff983340f3139c253d474290fbb4" translate="yes" xml:space="preserve">
          <source>after preprocessing with</source>
          <target state="translated">전처리 후</target>
        </trans-unit>
        <trans-unit id="cffa50a32cb13a240d705317bcec65dd1f31b6ad" translate="yes" xml:space="preserve">
          <source>and</source>
          <target state="translated">과</target>
        </trans-unit>
        <trans-unit id="7e1f2a78e4c90fa802c5d22555c7f96eaa0fe70f" translate="yes" xml:space="preserve">
          <source>and
expander end mark</source>
          <target state="translated">확장기 끝 표시</target>
        </trans-unit>
        <trans-unit id="2d8e96da2a774597d9af107e060f0034ebe06264" translate="yes" xml:space="preserve">
          <source>and a lot of dashes</source>
          <target state="translated">그리고 많은 대시</target>
        </trans-unit>
        <trans-unit id="56d5aa5b4ce97d0113190086d512de7cd60aca8d" translate="yes" xml:space="preserve">
          <source>and after preprocessing with</source>
          <target state="translated">그리고 전처리 후</target>
        </trans-unit>
        <trans-unit id="253037a3498c76ad657b3b4a8421b9c1bba00051" translate="yes" xml:space="preserve">
          <source>and any block</source>
          <target state="translated">및 모든 블록</target>
        </trans-unit>
        <trans-unit id="18ec79e44862e1fb99b31be9a26d6501fcf200b5" translate="yes" xml:space="preserve">
          <source>and don&amp;rsquo;t remove metada to see all preprocessor work.</source>
          <target state="translated">모든 전 처리기 작업을보기 위해 metada를 제거하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="8ec17ebb44fb651d93c7ab3065329cd069018e2b" translate="yes" xml:space="preserve">
          <source>and extensions must be separated with</source>
          <target state="translated">확장자는</target>
        </trans-unit>
        <trans-unit id="2b8ced207b5cab37579d4bfcae5686c2f8e61c3e" translate="yes" xml:space="preserve">
          <source>and finally we have our</source>
          <target state="translated">마지막으로 우리는</target>
        </trans-unit>
        <trans-unit id="5d60a6f5f7cb42d0824049e954cad560ad89c660" translate="yes" xml:space="preserve">
          <source>and includes it if</source>
          <target state="translated">다음과 같은 경우 포함</target>
        </trans-unit>
        <trans-unit id="60ae6b92c4701e2898122c86fb963da9419f9c26" translate="yes" xml:space="preserve">
          <source>and includes it if any block above and at same level was not</source>
          <target state="translated">위와 같은 레벨의 블록이없는 경우 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="e99387c91aabd0eb3edacd341781ced6df7feebd" translate="yes" xml:space="preserve">
          <source>and its
variations to close opened</source>
          <target state="translated">그리고 그 변형이 열렸습니다.</target>
        </trans-unit>
        <trans-unit id="f6e67a4451eb097bdb22310c784b1b2b46b3f24d" translate="yes" xml:space="preserve">
          <source>and latest features
are not welcome. Your code has to install and run in as many Python versions and platforms it it cans, and
be kept up to date, stable and without bugs. Python 2.7 support is dropped since January 2020,
but far away from be replaced. There is a lot of stuff that keeps working on it and still
will be for a long time.  Why? Because the cost of conversion is expensive, needs
time and effort. And all this code has to be mantained, keep evolving and will need packages
updates that be compatible with then and, when they began their conversion process, it will not be at once.</source>
          <target state="translated">최신 기능은 환영하지 않습니다. 코드는 가능한 한 많은 Python 버전과 플랫폼에서 설치 및 실행되어야하며, 최신 상태로 안정적이며 버그없이 유지되어야합니다. Python 2.7 지원은 2020 년 1 월 이후 중단되었지만 대체되지는 않았습니다. 계속 작업하고 있으며 여전히 오래 지속될 것입니다. 왜? 전환 비용이 비싸기 때문에 시간과 노력이 필요합니다. 그리고이 모든 코드는 관리되어야하고 계속 진화해야하며 그때와 호환되는 패키지 업데이트가 필요하며 변환 프로세스를 시작했을 때 즉시 이루어지지 않을 것입니다.</target>
        </trans-unit>
        <trans-unit id="cc72a00bf5f82a31e19586f8d5648eeb9609f807" translate="yes" xml:space="preserve">
          <source>and so on.</source>
          <target state="translated">등등.</target>
        </trans-unit>
        <trans-unit id="168bfeea2cd6df144546a377e8b695b674d8a768" translate="yes" xml:space="preserve">
          <source>and the value with evaluation of</source>
          <target state="translated">평가와 함께 가치</target>
        </trans-unit>
        <trans-unit id="2b5b775fa1d0aa3b3a42513b8922eb6ad36fc8db" translate="yes" xml:space="preserve">
          <source>are discarded</source>
          <target state="translated">버린다</target>
        </trans-unit>
        <trans-unit id="4ea3cee220093f997018369846e272611b88660f" translate="yes" xml:space="preserve">
          <source>as you see bellow.</source>
          <target state="translated">보시다시피.</target>
        </trans-unit>
        <trans-unit id="85d13ef3224a485b849d7c196603af859467e468" translate="yes" xml:space="preserve">
          <source>at the end of our source code, so our code can be processed the way we wants.</source>
          <target state="translated">우리가 원하는 방식으로 코드를 처리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="552a9d4a73eb2dc2f33473e48478c5d292e2029a" translate="yes" xml:space="preserve">
          <source>because Python will halt and the most important, when the source file is
a module to be imported &lt;strong&gt;all the original code will be executed&lt;/strong&gt; no matter which place you write</source>
          <target state="translated">파이썬이 중지되고 가장 중요하기 때문에 소스 파일이 가져올 모듈 일 때 작성하는 위치에 관계없이 &lt;strong&gt;모든 원본 코드가 실행됩니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d840980576afe8d29cc2d84b8c9ba00c2c42649e" translate="yes" xml:space="preserve">
          <source>c-style preprocessor for Python</source>
          <target state="translated">Python 용 c 스타일 전 처리기</target>
        </trans-unit>
        <trans-unit id="8472e725f8a89895b32f2ef147e2c9bc221e2ec3" translate="yes" xml:space="preserve">
          <source>call as next from top
of code we can, or use</source>
          <target state="translated">코드 상단에서 다음으로 호출하거나</target>
        </trans-unit>
        <trans-unit id="fed25cbce27bcf4f1f4dab9bc08b49d45f6e08a9" translate="yes" xml:space="preserve">
          <source>cause we don&amp;rsquo;t have identation and there are more directives
that gives more flexibility.</source>
          <target state="translated">왜냐하면 우리는 신원이없고 더 많은 유연성을 제공하는 더 많은 지시문이 있기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="75e40d360f03b5b3d60e3513002d3e2cf1875fd0" translate="yes" xml:space="preserve">
          <source>char. Ex.</source>
          <target state="translated">숯. 전의.</target>
        </trans-unit>
        <trans-unit id="d454c534bf86d813f847979be81ccdb29cf5fb5e" translate="yes" xml:space="preserve">
          <source>code is executed,  the trick happens. All code is read again, preprocessed
and directives do their job and a brand new code is created. This new code is executed and takes place
of original code.</source>
          <target state="translated">코드가 실행되면 트릭이 발생합니다. 모든 코드를 다시 읽고 전처리하고 지시문이 작업을 수행하고 새로운 코드가 생성됩니다. 이 새 코드가 실행되고 원래 코드를 대신합니다.</target>
        </trans-unit>
        <trans-unit id="e2f51989fdddc64d2210a78cc28e2d1d2d33ba05" translate="yes" xml:space="preserve">
          <source>compile each file after preprocessing. When this option is
used, no preprocessed source file will be saved to disk and
options</source>
          <target state="translated">전처리 후 각 파일을 컴파일하십시오. 이 옵션을 사용하면 사전 처리 된 소스 파일이 디스크 및 옵션에 저장되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="fb61acfe647ad6b7699277a3c64ccf418a88cd78" translate="yes" xml:space="preserve">
          <source>cpypp</source>
          <target state="translated">cpypp</target>
        </trans-unit>
        <trans-unit id="f4948d7a058418d190548280f0a03f0d0d00ee24" translate="yes" xml:space="preserve">
          <source>cpypp can compile bytecode files (.pyc) directly from the preprocessed file without need to save the new file to
disk an execute</source>
          <target state="translated">cpypp는 새 파일을 디스크에 저장하지 않고도 전처리 된 파일에서 직접 바이트 코드 파일 (.pyc)을 컴파일 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c6fd18bf98012948a8b1ee12d6cea5eccf873ae0" translate="yes" xml:space="preserve">
          <source>cpypp comes with some examples to check it out go to cpypp install directory</source>
          <target state="translated">cpypp에는 몇 가지 예제가 함께 제공됩니다. cpypp 설치 디렉토리로 이동하십시오.</target>
        </trans-unit>
        <trans-unit id="37dbd9a0668d9579e29bec149108fa1c8b19d6c4" translate="yes" xml:space="preserve">
          <source>cpypp implements some expanders that look for names and special characters in the source code and replace then
for defined values or expressions.</source>
          <target state="translated">cpypp는 소스 코드에서 이름과 특수 문자를 찾은 다음 정의 된 값이나 표현식을 대체하는 확장기를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="6c03bb0bcaef6c071e8d345852ee80646660de7e" translate="yes" xml:space="preserve">
          <source>cpyppc [options] filename-or-directory[...]</source>
          <target state="translated">cpyppc [옵션] 파일 이름 또는 디렉토리 [...]</target>
        </trans-unit>
        <trans-unit id="13830c439c92ec5ce23b103d3e908a47005fb6c6" translate="yes" xml:space="preserve">
          <source>dashes</source>
          <target state="translated">대시</target>
        </trans-unit>
        <trans-unit id="2af3f51f9cbc93467ea8044a91befe3888bbbe05" translate="yes" xml:space="preserve">
          <source>debug or</source>
          <target state="translated">디버그 또는</target>
        </trans-unit>
        <trans-unit id="478127fd80c8eb26f9f50994e6b2ba08f2d3f036" translate="yes" xml:space="preserve">
          <source>directive it replaces it by the entire
content of the specified file. The diference between</source>
          <target state="translated">지시문은 지정된 파일의 전체 내용으로 대체합니다. 차이</target>
        </trans-unit>
        <trans-unit id="89d756212c3482d0be0bc14e2624d12886204925" translate="yes" xml:space="preserve">
          <source>directive. If you had a piece of code that is not compatible with all versions of Python you put it as parameter
of</source>
          <target state="translated">지령. 모든 버전의 Python과 호환되지 않는 코드가있는 경우이를 매개 변수로 입력합니다.</target>
        </trans-unit>
        <trans-unit id="dad019f62222b3b02e65919b55915568abd9168e" translate="yes" xml:space="preserve">
          <source>directory to prepend to file names and paths before save
processed files. The full path will be created if it does
not exists</source>
          <target state="translated">처리 된 파일을 저장하기 전에 파일 이름 및 경로 앞에 추가 할 디렉토리. 존재하지 않는 경우 전체 경로가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="ec9814396ba26fa02dc3261046ba55a3b4bb32a6" translate="yes" xml:space="preserve">
          <source>expression</source>
          <target state="translated">표현</target>
        </trans-unit>
        <trans-unit id="ef2d8f5538a1e49f79b76f4ed858c75883f2fc75" translate="yes" xml:space="preserve">
          <source>filename in all directories listed in</source>
          <target state="translated">에 나열된 모든 디렉토리의 파일 이름</target>
        </trans-unit>
        <trans-unit id="43eef9a62abb8b1e1654f8a890aae054abffa82b" translate="yes" xml:space="preserve">
          <source>for</source>
          <target state="translated">...에 대한</target>
        </trans-unit>
        <trans-unit id="0baba5255e6ae1ff70b0deff43b7c2d2cf2ad9b9" translate="yes" xml:space="preserve">
          <source>force overwrite of files when output file name has the
same name of input file name</source>
          <target state="translated">출력 파일 이름이 입력 파일 이름과 동일한 경우 파일을 강제로 덮어 씁니다.</target>
        </trans-unit>
        <trans-unit id="fad056f9152d69aaf2c7dbb85c1241e0b2dc0303" translate="yes" xml:space="preserve">
          <source>has been commented too and all code bellow was reidented.
Let&amp;rsquo;s remove metada data now.</source>
          <target state="translated">또한 주석이 달렸고 모든 코드가 다시 확인되었습니다. 이제 메타 다 데이터를 제거하겠습니다.</target>
        </trans-unit>
        <trans-unit id="97010cecd65123372959797fff097fdea2c54e00" translate="yes" xml:space="preserve">
          <source>has the following content.</source>
          <target state="translated">다음 내용이 있습니다.</target>
        </trans-unit>
        <trans-unit id="b9c3bbc1281b6b6d3ffabcf73e34f9e3a5aa29e9" translate="yes" xml:space="preserve">
          <source>has the value</source>
          <target state="translated">가치가있다</target>
        </trans-unit>
        <trans-unit id="fae9fd39301eb7e657d4dad32a828cda5d7399e5" translate="yes" xml:space="preserve">
          <source>identifier</source>
          <target state="translated">식별자</target>
        </trans-unit>
        <trans-unit id="63c353c0e6d32f3024de79d8f8d16e0c88b5d0eb" translate="yes" xml:space="preserve">
          <source>if False and False:</source>
          <target state="translated">False 및 False 인 경우 :</target>
        </trans-unit>
        <trans-unit id="4efcbd4d59cf20a6ff717ae41dd7c56c4928b38b" translate="yes" xml:space="preserve">
          <source>if PYPP.parsed():</source>
          <target state="translated">PYPP.parsed () :</target>
        </trans-unit>
        <trans-unit id="fc33ce7e0a248fcbf9814b3f6964053b68895163" translate="yes" xml:space="preserve">
          <source>if/elif/else</source>
          <target state="translated">if / elif / else</target>
        </trans-unit>
        <trans-unit id="3773c56a9cf271e09aeb0316788e1fc37bfa96e9" translate="yes" xml:space="preserve">
          <source>import your_module</source>
          <target state="translated">your_module 가져 오기</target>
        </trans-unit>
        <trans-unit id="43ddf18a27ace558a42f3c2d391eb6fc266d98e4" translate="yes" xml:space="preserve">
          <source>import4.py</source>
          <target state="translated">import4.py</target>
        </trans-unit>
        <trans-unit id="28a9b0e9c4ee8cd062e40c2d85d1f2aa14ce8057" translate="yes" xml:space="preserve">
          <source>import5.py</source>
          <target state="translated">import5.py</target>
        </trans-unit>
        <trans-unit id="0b071a006395d1398e9cf802823ee3c26bee0c44" translate="yes" xml:space="preserve">
          <source>in definition dictionary, no matter its value.</source>
          <target state="translated">그 가치에 관계없이 정의 사전에서.</target>
        </trans-unit>
        <trans-unit id="39aaf2f678941dabb7174a16ef749be8cd99aac9" translate="yes" xml:space="preserve">
          <source>in definition dictionary.</source>
          <target state="translated">정의 사전에서.</target>
        </trans-unit>
        <trans-unit id="c3ca19c78581fcb781df62dfd639ba28a8f7774d" translate="yes" xml:space="preserve">
          <source>in python. The diference is that we have</source>
          <target state="translated">파이썬에서. 차이점은 우리가</target>
        </trans-unit>
        <trans-unit id="5b88c850f32af51bb3a7d5faec2520c82afb0f20" translate="yes" xml:space="preserve">
          <source>in source code. Let&amp;rsquo;s see some pratical examples to understand better.</source>
          <target state="translated">소스 코드에서. 더 잘 이해하기 위해 몇 가지 실용적인 예를 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="1f349d4ca84912843704cf9dbac8faaed6e71995" translate="yes" xml:space="preserve">
          <source>in source file will be replaced by its</source>
          <target state="translated">소스 파일에서</target>
        </trans-unit>
        <trans-unit id="bd2ea7d29568faec240623a3115d5da95aa07c06" translate="yes" xml:space="preserve">
          <source>in your final code on GitHub or in you client, or
wants be able to generate many diferent codes from this one.
This source code can be executed as a script calling</source>
          <target state="translated">GitHub 또는 클라이언트의 최종 코드에서 또는이 코드에서 여러 다른 코드를 생성 할 수 있기를 원합니다. 이 소스 코드는 스크립트 호출로 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4bcc8363be4153ae7a6c2faecfa166b0d6bf0ec2" translate="yes" xml:space="preserve">
          <source>include files with only these extensions. default is</source>
          <target state="translated">이러한 확장자 만 가진 파일을 포함합니다. 기본값은</target>
        </trans-unit>
        <trans-unit id="bf28f57dce395faedb095b5ad169a6c68345a21f" translate="yes" xml:space="preserve">
          <source>include.py</source>
          <target state="translated">include.py</target>
        </trans-unit>
        <trans-unit id="123a2f33b4ac4ba1731bdc4ada2f7d047f0548e6" translate="yes" xml:space="preserve">
          <source>is a name</source>
          <target state="translated">이름이다</target>
        </trans-unit>
        <trans-unit id="a6c2a74910913bf047f9f970bee3708cce234fa8" translate="yes" xml:space="preserve">
          <source>is a name in definition dictionary,</source>
          <target state="translated">정의 사전에있는 이름입니다.</target>
        </trans-unit>
        <trans-unit id="33ea7cf1f04ca1709d96e39195107b4e76516bde" translate="yes" xml:space="preserve">
          <source>is an expression, evaluates it and the result as used as  absolute path of file.</source>
          <target state="translated">표현식이며, 파일의 절대 경로로 사용되는 결과와이를 평가합니다.</target>
        </trans-unit>
        <trans-unit id="0f1599bc1959c8f8f3eb4a1f7c9bfdf66fb993c5" translate="yes" xml:space="preserve">
          <source>is evaluated to</source>
          <target state="translated">평가된다</target>
        </trans-unit>
        <trans-unit id="d34576f528af8773daccbd99e9ec2c0d4127c964" translate="yes" xml:space="preserve">
          <source>is executed at original code and at
preprocessed code. To solve this we have many options. First let&amp;rsquo;s understand that this happens
only to code that starts at column 1 (usually), with exception to classes and functions declarations.
All code inside classes and funcions are executed only when called, but all the rest is executed
instantly.</source>
          <target state="translated">원본 코드와 전처리 된 코드에서 실행됩니다. 이를 해결하기 위해 많은 옵션이 있습니다. 먼저 이것은 클래스 및 함수 선언을 제외하고 열 1 (일반적으로)에서 시작하는 코드에서만 발생한다는 것을 이해합시다. 클래스와 함수 내의 모든 코드는 호출 될 때만 실행되지만 나머지는 모두 즉시 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="dc7a540d6052ad428069b08e9303d11c3262fbe2" translate="yes" xml:space="preserve">
          <source>is not a name</source>
          <target state="translated">이름이 아니다</target>
        </trans-unit>
        <trans-unit id="75b13af57ced391903f343e7fcc665511c92dd2f" translate="yes" xml:space="preserve">
          <source>is ommited,</source>
          <target state="translated">생략되었습니다.</target>
        </trans-unit>
        <trans-unit id="30b40c614d54bc82fbc21b2d5017c6234cf20df9" translate="yes" xml:space="preserve">
          <source>is that</source>
          <target state="translated">그게</target>
        </trans-unit>
        <trans-unit id="c84b8d36709fce0fca86a91da227bc754c915a87" translate="yes" xml:space="preserve">
          <source>is used</source>
          <target state="translated">사용</target>
        </trans-unit>
        <trans-unit id="a6839d76bbb7783af5dc7927fd3ea8c02821e91c" translate="yes" xml:space="preserve">
          <source>is used.</source>
          <target state="translated">사용.</target>
        </trans-unit>
        <trans-unit id="38bc58d3df11f674ec29b9e7e37c4881f0c1ed64" translate="yes" xml:space="preserve">
          <source>levels to recurse into subdirectories. Use</source>
          <target state="translated">하위 디렉터리로 재귀 할 수준. 사용하다</target>
        </trans-unit>
        <trans-unit id="572c25d3f73bcd9c2277ec76b2d44d9c02d74556" translate="yes" xml:space="preserve">
          <source>logical condition to prevent our code to be executed twice and avoid unpredictable runtime errors write</source>
          <target state="translated">코드가 두 번 실행되는 것을 방지하고 예측할 수없는 런타임 오류를 방지하기위한 논리적 조건</target>
        </trans-unit>
        <trans-unit id="e04e24f0b3d330c8f2704e6a2ad1536da9ad6d90" translate="yes" xml:space="preserve">
          <source>logical condition, &lt;strong&gt;CAN ALSO&lt;/strong&gt; be replaced by</source>
          <target state="translated">논리 상태, &lt;strong&gt;ALSO CAN&lt;/strong&gt; 으로 대체</target>
        </trans-unit>
        <trans-unit id="45ed2791eeec093a14180adaafe066140fb78ee7" translate="yes" xml:space="preserve">
          <source>logical condition, in the whole code if necessary, and write</source>
          <target state="translated">논리 조건, 필요한 경우 전체 코드에서</target>
        </trans-unit>
        <trans-unit id="a0e37d622a4426c5fd06dee1f560d1e9eb693812" translate="yes" xml:space="preserve">
          <source>logical condition, or both, so our code can be processed the way we
wants. Another very important rule is:</source>
          <target state="translated">논리 조건, 또는 둘 다. 그래서 우리가 원하는 방식으로 코드를 처리 할 수 ​​있습니다. 또 다른 매우 중요한 규칙은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5821eb27d7b71c9078000da31a5a654c97e401b9" translate="yes" xml:space="preserve">
          <source>make</source>
          <target state="translated">하다</target>
        </trans-unit>
        <trans-unit id="1ed5a560ce4c0ae3499dacec38bde63b06fa9064" translate="yes" xml:space="preserve">
          <source>next to top of code so, there is no relevant code before it, but only the
necessary to its own execution.</source>
          <target state="translated">코드 상단 옆에는 관련 코드가없고 자체 실행에 필요한 코드 만 있습니다.</target>
        </trans-unit>
        <trans-unit id="9fc5d29e63648382e9487b35d12670920f52728c" translate="yes" xml:space="preserve">
          <source>no matter its value and any block above and at same level was not</source>
          <target state="translated">그 가치와 상관없이 같은 수준의 위와 같은 블록은</target>
        </trans-unit>
        <trans-unit id="a65e1d3845cf3b10a01939410842cdd6a3d0a6de" translate="yes" xml:space="preserve">
          <source>numpy</source>
          <target state="translated">numpy</target>
        </trans-unit>
        <trans-unit id="12cb917fa6b139c69bd08293a23c4256c452e570" translate="yes" xml:space="preserve">
          <source>option.</source>
          <target state="translated">선택권.</target>
        </trans-unit>
        <trans-unit id="1758356db21759f7c5a0da9b4dd1db8fd6feab3f" translate="yes" xml:space="preserve">
          <source>or</source>
          <target state="translated">또는</target>
        </trans-unit>
        <trans-unit id="eb23546d36f0352914cc194df54788915ac0a1cc" translate="yes" xml:space="preserve">
          <source>or loaded as a module using import</source>
          <target state="translated">또는 가져 오기를 사용하여 모듈로로드</target>
        </trans-unit>
        <trans-unit id="94c471e169727e7319fc9cf9f84cbbe366b6e7b3" translate="yes" xml:space="preserve">
          <source>output file name when you are preprocessing just one file
at once. Use</source>
          <target state="translated">한 번에 하나의 파일 만 전처리 할 때 출력 파일 이름입니다. 사용하다</target>
        </trans-unit>
        <trans-unit id="eb1cdb1023cba9da0895ac7ce1696713abcda17b" translate="yes" xml:space="preserve">
          <source>output only error messages;</source>
          <target state="translated">오류 메시지 만 출력합니다.</target>
        </trans-unit>
        <trans-unit id="53288d3b8a0e43dad36c67d7ed53abee969d85e8" translate="yes" xml:space="preserve">
          <source>package don&amp;rsquo;t need to be installed where the final code will execute. Neither cpypp as
we already know.</source>
          <target state="translated">최종 코드가 실행되는 곳에 패키지를 설치할 필요가 없습니다. 우리가 이미 알고있는 cpypp도 아닙니다.</target>
        </trans-unit>
        <trans-unit id="6d0d5876e6710ebb4f309b5af01090cb97381d06" translate="yes" xml:space="preserve">
          <source>print</source>
          <target state="translated">인쇄</target>
        </trans-unit>
        <trans-unit id="7c0c10f2c3bfe4222f42358e7ccee8885e01fb3e" translate="yes" xml:space="preserve">
          <source>print cpypp version</source>
          <target state="translated">cpypp 버전 인쇄</target>
        </trans-unit>
        <trans-unit id="b024f8c2bfa6dbc6442cb571d5d5d6243c0ca744" translate="yes" xml:space="preserve">
          <source>prints</source>
          <target state="translated">인쇄물</target>
        </trans-unit>
        <trans-unit id="97e4a6bc369a71d7c658f253b3dc3e3a067d11cb" translate="yes" xml:space="preserve">
          <source>py_preprocessor</source>
          <target state="translated">py_ 전 처리기</target>
        </trans-unit>
        <trans-unit id="9f46519176132d130137926afb805ee0562cc72d" translate="yes" xml:space="preserve">
          <source>python -m compileall</source>
          <target state="translated">파이썬 -m compileall</target>
        </trans-unit>
        <trans-unit id="43be9ff263bde44dff848e9e1f5f4818900eec2a" translate="yes" xml:space="preserve">
          <source>python cpypp --help</source>
          <target state="translated">파이썬 cpypp --help</target>
        </trans-unit>
        <trans-unit id="3021d11eba5f1f29088949848b76ba071bc9182c" translate="yes" xml:space="preserve">
          <source>python yourscript.py</source>
          <target state="translated">python yourscript.py</target>
        </trans-unit>
        <trans-unit id="4ffd2d18315b914a244cca043bee7807ce3c9606" translate="yes" xml:space="preserve">
          <source>python2</source>
          <target state="translated">python2</target>
        </trans-unit>
        <trans-unit id="80dd0a3e16d05b975a9fa37f27c78d7608caf7ae" translate="yes" xml:space="preserve">
          <source>python3</source>
          <target state="translated">python3</target>
        </trans-unit>
        <trans-unit id="e2802cfee6d778d053ee533ab4b5bfbc6b95c9d5" translate="yes" xml:space="preserve">
          <source>remove meta tags and commented lines from final code</source>
          <target state="translated">최종 코드에서 메타 태그 및 주석 처리 된 줄 제거</target>
        </trans-unit>
        <trans-unit id="f644b7f7c3513bd8118b5fdb1b3b09e20b03d49e" translate="yes" xml:space="preserve">
          <source>repr()</source>
          <target state="translated">repr ()</target>
        </trans-unit>
        <trans-unit id="61fb190af4c0633f4d45206f64e386f7c202f9f8" translate="yes" xml:space="preserve">
          <source>same as #define. Ex.</source>
          <target state="translated">#define과 동일합니다. 전의.</target>
        </trans-unit>
        <trans-unit id="bba5becadd070eb78f2b2ef752cd0b34d1612309" translate="yes" xml:space="preserve">
          <source>show this help message and exit</source>
          <target state="translated">이 도움말 메시지를 표시하고 종료</target>
        </trans-unit>
        <trans-unit id="577fc3597fa372cdc456946e49c070ff1a32a037" translate="yes" xml:space="preserve">
          <source>statement
does not meet the Python 3 syntax. So the solution is to hide this code from first compiling.</source>
          <target state="translated">문이 Python 3 구문을 충족하지 않습니다. 따라서 해결책은이 코드를 첫 번째 컴파일에서 숨기는 것입니다.</target>
        </trans-unit>
        <trans-unit id="3346abc026c7e2630a0511db843d74222dbf1533" translate="yes" xml:space="preserve">
          <source>str()</source>
          <target state="translated">str ()</target>
        </trans-unit>
        <trans-unit id="227453f6d944f874a97c91663cf2668088e60611" translate="yes" xml:space="preserve">
          <source>sys.exit</source>
          <target state="translated">sys.exit</target>
        </trans-unit>
        <trans-unit id="f2700e4df8d976875eb5b1c41baa697eb3d7409c" translate="yes" xml:space="preserve">
          <source>sys.modules</source>
          <target state="translated">sys.modules</target>
        </trans-unit>
        <trans-unit id="34eb390220700dc0cf34d88553728e9f0d097c17" translate="yes" xml:space="preserve">
          <source>sys.path</source>
          <target state="translated">sys.path</target>
        </trans-unit>
        <trans-unit id="8f48d36ea36b1c42000ca1c35df84cd5afa93967" translate="yes" xml:space="preserve">
          <source>test code</source>
          <target state="translated">테스트 코드</target>
        </trans-unit>
        <trans-unit id="e3f2068c7bdd21fa0733e0e61d6d36ca4b906f08" translate="yes" xml:space="preserve">
          <source>test06_import_module.py</source>
          <target state="translated">test06_import_module.py</target>
        </trans-unit>
        <trans-unit id="406ee11981f12d85fd5a9adbd7d06589fceabb62" translate="yes" xml:space="preserve">
          <source>test_script01.py</source>
          <target state="translated">test_script01.py</target>
        </trans-unit>
        <trans-unit id="bf21102223d4ea13e2d850d0b0bcc79b9223b290" translate="yes" xml:space="preserve">
          <source>test_script02.py</source>
          <target state="translated">test_script02.py</target>
        </trans-unit>
        <trans-unit id="391dfb031314a3bc391da958524120aa5b9507de" translate="yes" xml:space="preserve">
          <source>test_script03.py</source>
          <target state="translated">test_script03.py</target>
        </trans-unit>
        <trans-unit id="d0ada0a028919096459338efdd5e599052cc269f" translate="yes" xml:space="preserve">
          <source>that has to be modified at runtime, we can&amp;rsquo;t call</source>
          <target state="translated">런타임에 수정해야합니다. 호출 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="b97596bfe47615a4cff02aed1f49c9438ec87a45" translate="yes" xml:space="preserve">
          <source>to all relevant code before</source>
          <target state="translated">이전의 모든 관련 코드에</target>
        </trans-unit>
        <trans-unit id="4945f7be8f99b05c4e67757bdfe6a4a3367f61d6" translate="yes" xml:space="preserve">
          <source>to don&amp;rsquo;t
recurse. Default is no limit</source>
          <target state="translated">재귀하지 않습니다. 기본값은 제한 없음</target>
        </trans-unit>
        <trans-unit id="57d7bd3fa988f906b79353a55e22ee2693e0fab7" translate="yes" xml:space="preserve">
          <source>to read
names from stdin</source>
          <target state="translated">stdin에서 이름을 읽으려면</target>
        </trans-unit>
        <trans-unit id="2f01c5a48c93ba40227f17f5fe0e8c06e363af5e" translate="yes" xml:space="preserve">
          <source>to stdout</source>
          <target state="translated">표준으로</target>
        </trans-unit>
        <trans-unit id="696d2e50806a26ce862201dcb798a9bd24091c45" translate="yes" xml:space="preserve">
          <source>to this if we are using Python 3+</source>
          <target state="translated">여기에 Python 3 이상을 사용하는 경우</target>
        </trans-unit>
        <trans-unit id="1a8af26493f75be14455aa971ed7f615b75463bf" translate="yes" xml:space="preserve">
          <source>use legacy (pre-PEP3147) compiled file locations. Valid
only when</source>
          <target state="translated">레거시 (PEP3147 이전) 컴파일 된 파일 위치를 사용합니다. 다음 경우에만 유효</target>
        </trans-unit>
        <trans-unit id="bd06bfbd32adff09a7502206dff6013545847a9f" translate="yes" xml:space="preserve">
          <source>value and</source>
          <target state="translated">가치와</target>
        </trans-unit>
        <trans-unit id="156298a17463d39db2cbfa748c7a13fc136320c6" translate="yes" xml:space="preserve">
          <source>value, insert a modifier at end of expression, without spaces from</source>
          <target state="translated">값, 공백없이 표현식 끝에 수정자를 삽입합니다.</target>
        </trans-unit>
        <trans-unit id="5619d8f920e72eca1784129b78c142f3eeb1a04c" translate="yes" xml:space="preserve">
          <source>value.
For example, the code:</source>
          <target state="translated">값. 예를 들어, 코드 :</target>
        </trans-unit>
        <trans-unit id="b8a45f11c1ec854d3025db2fb0db4723573850ff" translate="yes" xml:space="preserve">
          <source>value.
Note than any references means any place where definition names appears, even inside strings. To avoid this
replacement precede the name with</source>
          <target state="translated">값. 모든 참조는 문자열 내부에서도 정의 이름이 나타나는 모든 위치를 의미합니다. 이 대체를 방지하려면 이름 앞에</target>
        </trans-unit>
        <trans-unit id="0021b396bdec4e710fb1756d94670ba41ac7236d" translate="yes" xml:space="preserve">
          <source>value. If you wants
that replacement value be by its</source>
          <target state="translated">값. 대체 가치를 원하는 경우</target>
        </trans-unit>
        <trans-unit id="a487b374e7829a7bfefe9c26404bcd0864d73eae" translate="yes" xml:space="preserve">
          <source>variable so, it can be removed from final code.</source>
          <target state="translated">변수이므로 최종 코드에서 제거 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ecd3a7e8854eabd5bb7e2ce5ad7d03ab84cbb811" translate="yes" xml:space="preserve">
          <source>variable.</source>
          <target state="translated">변하기 쉬운.</target>
        </trans-unit>
        <trans-unit id="d1f38f3dac8dc2c85de6cafd5013272f0039407c" translate="yes" xml:space="preserve">
          <source>was executed twice. Right ? Yes and No. We have tools to prevent its to happen.
Let&amp;rsquo;s see an pratical example to understand better.</source>
          <target state="translated">두 번 처형되었습니다. 권리 ? 예 그리고 아니오. 우리는 그 일이 일어나지 않도록하는 도구를 가지고 있습니다. 더 잘 이해할 수있는 실용적인 예를 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="b0856cf4f8cd38ec998dca76a6fa9f7a1cbc624e" translate="yes" xml:space="preserve">
          <source>was written.
There are two ways to use #include:</source>
          <target state="translated">작성되었습니다. #include를 사용하는 두 가지 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="d7a64ef7537da1c381106c8a18848fc447af294e" translate="yes" xml:space="preserve">
          <source>were commented and the block</source>
          <target state="translated">댓글과 블록</target>
        </trans-unit>
        <trans-unit id="ae8e6d008cd97bb3130c611639ba64d14ccd056a" translate="yes" xml:space="preserve">
          <source>will
always include each line of incuded file starting at same column where</source>
          <target state="translated">항상 동일한 열에서 시작하는 각 파일 줄을 포함합니다.</target>
        </trans-unit>
        <trans-unit id="4e012d5d75e708e6f76c55f22483b43d62e51e2e" translate="yes" xml:space="preserve">
          <source>will always include each line of included file starting of column 1 and</source>
          <target state="translated">항상 1 열로 시작하는 포함 된 파일의 각 줄을 포함하고</target>
        </trans-unit>
        <trans-unit id="d4574cbc61926da80be188ce3f46793c5547d0ab" translate="yes" xml:space="preserve">
          <source>will be evaluated and replaced exactly at same place by its</source>
          <target state="translated">평가되고 정확히 같은 장소에서</target>
        </trans-unit>
        <trans-unit id="03fc07553df80b81924db019a2215e815966fd20" translate="yes" xml:space="preserve">
          <source>will be included.</source>
          <target state="translated">포함됩니다.</target>
        </trans-unit>
        <trans-unit id="75c5acef5fb2e47df2bf90c4d4c3a7831000cfcd" translate="yes" xml:space="preserve">
          <source>will become:</source>
          <target state="translated">될 것입니다:</target>
        </trans-unit>
        <trans-unit id="116de93d6c1e46dee003c0a75f8302bb736a69ab" translate="yes" xml:space="preserve">
          <source>will do
this for us.</source>
          <target state="translated">우리를 위해 이것을 할 것입니다.</target>
        </trans-unit>
        <trans-unit id="662f961d5726507f309e7100a95a43f3fff081da" translate="yes" xml:space="preserve">
          <source>will not compile in Python 3 because  second line will generate a syntax error. In these case if you can&amp;rsquo;t change the original code you can use the directive</source>
          <target state="translated">두 번째 줄은 구문 오류를 생성하기 때문에 Python 3에서 컴파일되지 않습니다. 이 경우 원래 코드를 변경할 수 없으면 지시문을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7ee29cd487f2af2a6af729147516db581dd747e5" translate="yes" xml:space="preserve">
          <source>will suppress the error
messages as well</source>
          <target state="translated">오류 메시지도 표시하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e450810618f013e94e0f50aaf722fe1ef7538032" translate="yes" xml:space="preserve">
          <source>with other little stuff as :</source>
          <target state="translated">다른 작은 것들과 함께 :</target>
        </trans-unit>
        <trans-unit id="86e3cccac0638e3df1234a2d773a020983ce48b7" translate="yes" xml:space="preserve">
          <source>❗️</source>
          <target state="translated">❗️</target>
        </trans-unit>
        <trans-unit id="51ceced53e8e5c84cf24b554724b925b563d5799" translate="yes" xml:space="preserve">
          <source>❗️ &lt;strong&gt;DON&amp;rsquo;T CHANGE&lt;/strong&gt; this line either.</source>
          <target state="translated">❗️ 이 라인도 &lt;strong&gt;변경하지 마십시오&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="9092ce9dcb7db0d59fa60f72b1e273acabd39d81" translate="yes" xml:space="preserve">
          <source>❗️ &lt;strong&gt;YOU CAN NOT&lt;/strong&gt; change this piece of code neither change</source>
          <target state="translated">❗️ 이 코드를 변경할 &lt;strong&gt;수 없습니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="55291a6dc91f8c7e8382a049d3490883c975d3ed" translate="yes" xml:space="preserve">
          <source>❗️ As you can see there is &lt;strong&gt;NO DEPENDENCY&lt;/strong&gt; in final code from cpypp.</source>
          <target state="translated">❗️ 보시다시피 cpypp의 최종 코드 에는 &lt;strong&gt;종속성&lt;/strong&gt; 이 &lt;strong&gt;없습니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="50f3921f2c9d77069a6661a0104f0893153bf9d8" translate="yes" xml:space="preserve">
          <source>❗️ The code generated is &lt;strong&gt;DIRECTLY DEPENDENT&lt;/strong&gt; from the Python version you run the command line</source>
          <target state="translated">❗️ 생성 된 코드 는 명령 줄을 실행하는 Python 버전에 &lt;strong&gt;직접&lt;/strong&gt; 의존합니다.</target>
        </trans-unit>
        <trans-unit id="370fd22df68791f5ca1d5731cf23c622cd60a1c4" translate="yes" xml:space="preserve">
          <source>❗️ Your original source code &lt;strong&gt;HAS TO BE&lt;/strong&gt; compilable in all Python versions, because this original source code has to
run so the processor can do its job.</source>
          <target state="translated">❗️ 원래 소스 코드 &lt;strong&gt;되어야&lt;/strong&gt; 이 원래의 소스 코드는 프로세서가 일을 할 수 있도록 실행하기 때문에, 모든 파이썬 버전에서 컴파일 가능한.</target>
        </trans-unit>
        <trans-unit id="ec50f6e00debadcbfbb457c1ec7e016237ee9c68" translate="yes" xml:space="preserve">
          <source>❗️ cpypp will understand this too.</source>
          <target state="translated">❗️ cpypp도 이것을 이해할 것입니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
