<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://pypi.org/project/absynthe/">
    <body>
      <group id="absynthe">
        <trans-unit id="02b011c64160798e799481cc084857488382bb41" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Anomalous&lt;/em&gt; behaviors</source>
          <target state="translated">&lt;em&gt;비정상적인&lt;/em&gt; 행동</target>
        </trans-unit>
        <trans-unit id="60027b310b5d95466e164e9b1bfc5f536be91cc0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; This tool is still in alpha stage, so backward compatibility is not
guaranteed between releases. However, inasmuch as users stick to graph builders'
&lt;code&gt;generateNewGraph()&lt;/code&gt; methods, they will stay away from compatibility problems.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 이 도구는 아직 알파 단계이므로 릴리스간에 이전 버전과의 호환성이 보장되지 않습니다. 그러나 사용자가 그래프 빌더의 &lt;code&gt;generateNewGraph()&lt;/code&gt; 메서드를 고수하는 한 호환성 문제를 피할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7d13b0e105082d251433284ac94b52e7b08baf9b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; When generating a behavior, i.e. when traversing a graph, successors
of nodes are chosen based on the probability distributions associated with those
nodes. Different nodes rely on different distributions and these nodes are
randomly assigned in the graphs that are constructed by &lt;code&gt;generateNewGraph()&lt;/code&gt;
methods, resulting in graphs with a mix of nodes.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 동작을 생성 할 때 (예 : 그래프를 순회 할 때) 노드의 후속 노드는 해당 노드와 관련된 확률 분포를 기반으로 선택됩니다. 서로 다른 노드는 서로 다른 분포에 의존하며 이러한 노드는 &lt;code&gt;generateNewGraph()&lt;/code&gt; 메서드에 의해 구성된 그래프에 무작위로 할당되어 노드가 혼합 된 그래프가됩니다.</target>
        </trans-unit>
        <trans-unit id="1ed58f177ea95bd7dab803c7ed4b233a181ba7bd" translate="yes" xml:space="preserve">
          <source>A (branching) Behaviour Synthesizer</source>
          <target state="translated">(분기) 동작 합성기</target>
        </trans-unit>
        <trans-unit id="550e6f318db294135e3d56d0fa6d7665e997ba1a" translate="yes" xml:space="preserve">
          <source>A more interesting situation arises while trying to test log analytic (and
anomaly detection) solutions for distributed applications where multiple
sources or modules emit their respective log messages in a single log queue or
stream. This means that consecutive log lines could have originated from
different, unrelated application components. Absynthe provides &lt;em&gt;ground truth&lt;/em&gt;
models to simulate such situations.</source>
          <target state="translated">여러 소스 또는 모듈이 단일 로그 큐 또는 스트림에서 각각의 로그 메시지를 내보내는 분산 애플리케이션에 대한 로그 분석 (및 이상 감지) 솔루션을 테스트하려고 할 때 더 흥미로운 상황이 발생합니다. 이는 연속적인 로그 행이 서로 관련이없는 다른 애플리케이션 구성 요소에서 생성되었을 수 있음을 의미합니다. Absynthe는 이러한 상황을 시뮬레이션하기 위한 &lt;em&gt;Ground Truth&lt;/em&gt; 모델을 제공 합니다.</target>
        </trans-unit>
        <trans-unit id="dde040f47497790c05666d2ef94baefd390e27bf" translate="yes" xml:space="preserve">
          <source>Absynthe came about in response to the need for test data for analysizing the
performance and accuracy of log analysis algorithms. Even though plenty of real
life logs are available, e.g. &lt;code&gt;/var/log/&lt;/code&gt; in unix-based laptops, they do not
serve the purpose of test data. For that, we need to understand the core
application logic that is generating these logs.</source>
          <target state="translated">Absynthe는 로그 분석 알고리즘의 성능과 정확성을 분석하기위한 테스트 데이터의 필요성에 부응하여 탄생했습니다. 유닉스 기반 랩톱에서 &lt;code&gt;/var/log/&lt;/code&gt; 와 같이 많은 실제 로그를 사용할 수 있지만 테스트 데이터의 목적에는 적합하지 않습니다. 이를 위해서는 이러한 로그를 생성하는 핵심 애플리케이션 로직을 이해해야합니다.</target>
        </trans-unit>
        <trans-unit id="68e14b2ad8538d489e4858484be43ce15b328a6b" translate="yes" xml:space="preserve">
          <source>Absynthe: A (branching) Behavior Synthesizer</source>
          <target state="translated">Absynthe : A (분기) 동작 합성기</target>
        </trans-unit>
        <trans-unit id="280cb3fd0e3d99cf59bd50b4980fc6af1bbad0d5" translate="yes" xml:space="preserve">
          <source>Added a separate utility class called &lt;code&gt;Utils&lt;/code&gt; in &lt;code&gt;absynthe.cfg.utils.py&lt;/code&gt; to
create a new &lt;code&gt;Node&lt;/code&gt; object from any of the concrete implementations of &lt;code&gt;Node&lt;/code&gt; at
random. All concrete implementations of &lt;code&gt;Node&lt;/code&gt; therefore transparently available
to graph builders (and everyone else) through this utility.</source>
          <target state="translated">라는 별도의 유틸리티 클래스 추가 &lt;code&gt;Utils&lt;/code&gt; 에 &lt;code&gt;absynthe.cfg.utils.py&lt;/code&gt; 새로운 만들 &lt;code&gt;Node&lt;/code&gt; 의 구체적인 구현의 어떤에서 개체 &lt;code&gt;Node&lt;/code&gt; 무작위로합니다. 따라서 &lt;code&gt;Node&lt;/code&gt; 의 모든 구체적인 구현은 이 유틸리티를 통해 그래프 빌더 (및 다른 모든 사람)가 투명하게 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="eb58484c96da64282a061ef0f8a9d40510285043" translate="yes" xml:space="preserve">
          <source>Added new graph builders, viz. &lt;code&gt;DAGBuilder&lt;/code&gt; and  &lt;code&gt;DCGBuilder&lt;/code&gt;, which build
CFGs with skip-level edges and loops respectively.</source>
          <target state="translated">새로운 그래프 빌더, 즉 추가. &lt;code&gt;DAGBuilder&lt;/code&gt; 및 &lt;code&gt;DCGBuilder&lt;/code&gt; - 각각 건너 뛰기 수준 가장자리 및 루프를 사용하여 CFG를 빌드합니다.</target>
        </trans-unit>
        <trans-unit id="4cbbc2fc77fc6a8ffe051dea3ddc539034d4544b" translate="yes" xml:space="preserve">
          <source>Added new node, viz. &lt;code&gt;BinomialNode&lt;/code&gt;, which exploits the binomial distribution
in order to select its successors at the time of graph traversal.</source>
          <target state="translated">새 노드 즉, 추가. &lt;code&gt;BinomialNode&lt;/code&gt; - 그래프 순회시 후속 항목을 선택하기 위해 이항 분포를 이용합니다.</target>
        </trans-unit>
        <trans-unit id="8be003c27a6c97e5b0677757afd23716aaca94ef" translate="yes" xml:space="preserve">
          <source>An example of a more complex CFG, a directed cyclic graph, is shown in the
figure below. It expands the tree-like graph illustrated above by:</source>
          <target state="translated">보다 복잡한 CFG, 방향 순환 그래프의 예가 아래 그림에 나와 있습니다. 위에 설명 된 트리 모양의 그래프를 다음과 같이 확장합니다.</target>
        </trans-unit>
        <trans-unit id="6452f7e7dc3c35274e1d081266ab3bcc9990cab8" translate="yes" xml:space="preserve">
          <source>An example of a simple, tree-like CFG generated using Absynthe is shown below.
This is like a tree since nodes are laid out in levels, and nodes at level &lt;code&gt;i&lt;/code&gt;
have outgoing edges only to nodes at level &lt;code&gt;i + 1&lt;/code&gt;.</source>
          <target state="translated">Absynthe를 사용하여 생성 된 간단한 트리 형 CFG의 예는 다음과 같습니다. 노드가 레벨에 배치되고 레벨 &lt;code&gt;i&lt;/code&gt; 의 노드는 레벨 &lt;code&gt;i + 1&lt;/code&gt; 노드에만 나가는 가장자리 가 있기 때문에 이것은 트리와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="6e925f5a187584bb93a957696eb50e796b4b787e" translate="yes" xml:space="preserve">
          <source>Coming up in future releases</source>
          <target state="translated">향후 출시 예정</target>
        </trans-unit>
        <trans-unit id="7e9b9183f4a396da21c94f732891218fafbdc7ae" translate="yes" xml:space="preserve">
          <source>Directed Cyclic CFG</source>
          <target state="translated">Directed Cyclic CFG</target>
        </trans-unit>
        <trans-unit id="7a253c500c342cfa2eda2d5a52e23d3e00a38f0f" translate="yes" xml:space="preserve">
          <source>Each &lt;em&gt;behavior&lt;/em&gt; is the sequence of nodes encountered while traversing this CFG
from a root to a leaf. Of course, a CFG might contain loops which could be
traversed multiple times before arriving at the leaf. Moreover, if there are
multiple CFGs, then Absynthe can synthesize &lt;em&gt;interleaved&lt;/em&gt; behaviors. This means
that a single sequence of nodes might contain nodes from multiple CFGs. We are
ultimately interested in this interleaving behavior, which is produced by
multiple CFGs.</source>
          <target state="translated">각 &lt;em&gt;동작&lt;/em&gt; 은이 CFG를 루트에서 리프로 이동하는 동안 발생하는 노드 시퀀스입니다. 물론 CFG에는 리프에 도착하기 전에 여러 번 통과 할 수있는 루프가 포함될 수 있습니다. 또한 여러 CFG가있는 경우 Absynthe는 &lt;em&gt;인터리브 된&lt;/em&gt; 동작을 합성 할 수 있습니다 . 이는 단일 노드 시퀀스에 여러 CFG의 노드가 포함될 수 있음을 의미합니다. 우리는 궁극적으로 여러 CFG에 의해 생성되는이 인터리빙 동작에 관심이 있습니다.</target>
        </trans-unit>
        <trans-unit id="ffc30fab83bb0c85eb6e12280e0a3b95999fd852" translate="yes" xml:space="preserve">
          <source>Each business process or compuater application is modelled as a &lt;em&gt;control flow
graph&lt;/em&gt; (or &lt;em&gt;CFG&lt;/em&gt;), which typically has one or more roots (i.e. entry) nodes and
multiple leaf (i.e. end) nodes.</source>
          <target state="translated">각 비즈니스 프로세스 또는 컴퓨터 애플리케이션은 일반적으로 하나 이상의 루트 (예 : 항목) 노드와 여러 개의 리프 (예 : 끝) 노드 를 포함하는 &lt;em&gt;제어 흐름 그래프&lt;/em&gt; (또는 &lt;em&gt;CFG&lt;/em&gt; ) 로 모델링됩니다 .</target>
        </trans-unit>
        <trans-unit id="ebf05de134c94509696d1b9731d1059221894528" translate="yes" xml:space="preserve">
          <source>For instance, consider the &lt;code&gt;basicLogGeneration&lt;/code&gt; method in
&lt;code&gt;./examples/01_generateSimpleBehavior.py&lt;/code&gt;:</source>
          <target state="translated">예를 들어 &lt;code&gt;./examples/01_generateSimpleBehavior.py&lt;/code&gt; 의 &lt;code&gt;basicLogGeneration&lt;/code&gt; 메서드를 고려 해보세요 .</target>
        </trans-unit>
        <trans-unit id="ece8a1e099471b12bc1db0091b0ab79cf8c8e183" translate="yes" xml:space="preserve">
          <source>For the latest features not yet released, clone or download the &lt;code&gt;develop&lt;/code&gt; branch
and then:</source>
          <target state="translated">아직 출시되지 않은 최신 기능의 경우 &lt;code&gt;develop&lt;/code&gt; 브랜치를 복제하거나 다운로드 한 후 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="361323255a6e418a94fe1dd6ad98403ad687499f" translate="yes" xml:space="preserve">
          <source>In order to generate behaviors from a directed cyclic CFG, create a DCG as shown
in &lt;code&gt;./examples/03_generateControlFlowDCG.py&lt;/code&gt; and then generate behaviors after
adding the DCG to a behavior object as shown in the code snippet above.</source>
          <target state="translated">방향성 순환 CFG에서 동작을 생성하려면 &lt;code&gt;./examples/03_generateControlFlowDCG.py&lt;/code&gt; 에 표시된대로 DCG 를 생성 한 다음 위의 코드 스 니펫에 표시된대로 DCG를 동작 객체에 추가 한 후 동작을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="c81b79df3c6448eae7c4f80428b54cd5692a17d7" translate="yes" xml:space="preserve">
          <source>Installation</source>
          <target state="translated">설치</target>
        </trans-unit>
        <trans-unit id="41d0bded83d8a4df22a78f1f0693f59a79719b3e" translate="yes" xml:space="preserve">
          <source>It is possible to start using Absynthe with two classes:</source>
          <target state="translated">두 가지 클래스로 Absynthe를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="019ec01ba6d724fe41e420938f721b48570940fe" translate="yes" xml:space="preserve">
          <source>Logger nodes that emit more &lt;em&gt;life like&lt;/em&gt; log messages</source>
          <target state="translated">로그 메시지 &lt;em&gt;와 같이&lt;/em&gt; 더 많은 &lt;em&gt;생명&lt;/em&gt; 을 방출하는 로거 노드</target>
        </trans-unit>
        <trans-unit id="80552c39193e5d627bacdc60f82ee17b182d6315" translate="yes" xml:space="preserve">
          <source>Major changes in v0.0.2</source>
          <target state="translated">v0.0.2의 주요 변경 사항</target>
        </trans-unit>
        <trans-unit id="d6a06199cc127e571d3588aef63c79108675eabc" translate="yes" xml:space="preserve">
          <source>Motivation</source>
          <target state="translated">자극</target>
        </trans-unit>
        <trans-unit id="0efc2e6be4c23b9a513d7ce0dcff8ed80e8912e7" translate="yes" xml:space="preserve">
          <source>Overview</source>
          <target state="translated">개요</target>
        </trans-unit>
        <trans-unit id="0ea4af908fe06688dd3fc02035189b08293c5074" translate="yes" xml:space="preserve">
          <source>Release Notes</source>
          <target state="translated">릴리즈 노트</target>
        </trans-unit>
        <trans-unit id="7137676daae9098656140de61386c7374db05941" translate="yes" xml:space="preserve">
          <source>Sophisticated interleaving behaviors</source>
          <target state="translated">정교한 인터리빙 동작</target>
        </trans-unit>
        <trans-unit id="f2903a3add32a92d3c75624c962356b7a49a5fa8" translate="yes" xml:space="preserve">
          <source>The above screenshot shows logs generated by Absynthe. Each log line starts
with a time stamp, followed by a session ID, CFG ID, and a log message. At
present, the log message is simply a random concatenation of the node ID to
which the log message corresponds. A single CFG might participate in multiple
sessions, where each session is a different traversal of the CFG. Therefore, we
maintain both session ID and CFG ID in the log line.</source>
          <target state="translated">위의 스크린 샷은 Absynthe가 생성 한 로그를 보여줍니다. 각 로그 행은 타임 스탬프로 시작하고 세션 ID, CFG ID 및 로그 메시지가 이어집니다. 현재 로그 메시지는 로그 메시지가 해당하는 노드 ID의 무작위 연결입니다. 단일 CFG가 여러 세션에 참여할 수 있으며 각 세션은 CFG의 다른 순회입니다. 따라서 로그 라인에 세션 ID와 CFG ID를 모두 유지합니다.</target>
        </trans-unit>
        <trans-unit id="f96cc45f6b319ee18988211c883578e9a4a281c7" translate="yes" xml:space="preserve">
          <source>The identifiers of nodes appearing loops are helpfully prefixed with the
identifiers of nodes where these loops start and finish. Moreover, loops could
be traversed multiple times in a single behavior, as illustrated in the figure
below.</source>
          <target state="translated">루프를 나타내는 노드의 식별자에는 이러한 루프가 시작되고 종료되는 노드의 식별자가 도움이됩니다. 또한 아래 그림과 같이 단일 동작으로 루프를 여러 번 순회 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9a674369e325bdf29f6edf8edb945b651c6ac731" translate="yes" xml:space="preserve">
          <source>The latest release is available on PyPi, simply &lt;code&gt;pip install absynthe&lt;/code&gt;. The
&lt;code&gt;master&lt;/code&gt; branch of this repository will always provide the latest release.</source>
          <target state="translated">최신 릴리스는 PyPi에서 사용할 수 있습니다 . 간단히 &lt;code&gt;pip install absynthe&lt;/code&gt; . 이 저장소 의 &lt;code&gt;master&lt;/code&gt; 브랜치는 항상 최신 릴리스를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="3cbe8139be6dadccd55954ec95da87dbf1e698b5" translate="yes" xml:space="preserve">
          <source>This package has been developed with &lt;code&gt;Python 3.6.*&lt;/code&gt; and depends on &lt;code&gt;scipy 1.2.1&lt;/code&gt;.
Things might not work with &lt;code&gt;Python 3.7.*&lt;/code&gt; or &lt;code&gt;scipy 1.3.*&lt;/code&gt;. Therefore, consider
creating a virtual environment if your default configuration differs.</source>
          <target state="translated">이 패키지는 &lt;code&gt;Python 3.6.*&lt;/code&gt; 로 개발 되었으며 &lt;code&gt;scipy 1.2.1&lt;/code&gt; 에 의존합니다 . &lt;code&gt;Python 3.7.*&lt;/code&gt; 또는 &lt;code&gt;scipy 1.3.*&lt;/code&gt; 에서는 작동하지 않을 수 있습니다 . 따라서 기본 구성이 다른 경우 가상 환경을 만드는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="0980855b93454e712e2b015cc0f5655541facb06" translate="yes" xml:space="preserve">
          <source>Tree-like CFG</source>
          <target state="translated">나무와 같은 CFG</target>
        </trans-unit>
        <trans-unit id="0bb18642b70b9f8a9c12ccf39487328f306b8e19" translate="yes" xml:space="preserve">
          <source>Usage</source>
          <target state="translated">용법</target>
        </trans-unit>
        <trans-unit id="2d75d8dd04fd465844923c80ddf7cebda12ec86a" translate="yes" xml:space="preserve">
          <source>You need Absynthe if you wish to simulate the behavior of any well defined
process -- whether it's a computer application or a business process flow.</source>
          <target state="translated">컴퓨터 애플리케이션이든 비즈니스 프로세스 흐름이든 잘 정의 된 프로세스의 동작을 시뮬레이션하려면 Absynthe가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="cfdf820be882593b466c12770bb42a1d31992322" translate="yes" xml:space="preserve">
          <source>any concrete implementation of the abstract &lt;code&gt;Behavior&lt;/code&gt; class, which
traverses the CFGs generated above and emits log messages.</source>
          <target state="translated">위에서 생성 된 CFG를 탐색하고 로그 메시지를 내보내는 추상 &lt;code&gt;Behavior&lt;/code&gt; 클래스 의 구체적인 구현 .</target>
        </trans-unit>
        <trans-unit id="f56a005cb54785defd2347c651da587bf8d12c8c" translate="yes" xml:space="preserve">
          <source>any concrete implementation of the abstract &lt;code&gt;GraphBuilder&lt;/code&gt; class, which
generates CFGs, and</source>
          <target state="translated">&lt;code&gt;GraphBuilder&lt;/code&gt; 를 생성 하는 추상 GraphBuilder 클래스 의 구체적인 구현</target>
        </trans-unit>
        <trans-unit id="1746725b3599b57f2c3c7c184a1e129a4b71bc36" translate="yes" xml:space="preserve">
          <source>attaching loops on some of the nodes,</source>
          <target state="translated">일부 노드에 루프 연결,</target>
        </trans-unit>
        <trans-unit id="8de1898ddf3eff19dd8e421cfc5bd3eabb848a8c" translate="yes" xml:space="preserve">
          <source>constructing skip-level edges, i.e. edges from a node at level &lt;code&gt;i&lt;/code&gt; to a
node at level &amp;ge;&lt;code&gt;(i + 2)&lt;/code&gt;, and</source>
          <target state="translated">스킵 레벨 에지를 구성, 즉, 레벨의 노드에서 에지 &lt;code&gt;i&lt;/code&gt; 레벨에서 노드 &amp;ge; &lt;code&gt;(i + 2)&lt;/code&gt; , 및</target>
        </trans-unit>
        <trans-unit id="e1d5d9897e5bb0bd39df7fb5b19b181ff8ea808c" translate="yes" xml:space="preserve">
          <source>optionally, upward edges (not shown here), i.e. edges from a node at
level &lt;code&gt;i&lt;/code&gt; to a node at level &amp;le;&lt;code&gt;(i - 1)&lt;/code&gt;.</source>
          <target state="translated">선택적으로 상향 에지 (여기에 표시되지 않음), 즉 레벨 &lt;code&gt;i&lt;/code&gt; 의 노드에서 레벨 &amp;le; &lt;code&gt;(i - 1)&lt;/code&gt; 의 노드까지의 에지 .</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
