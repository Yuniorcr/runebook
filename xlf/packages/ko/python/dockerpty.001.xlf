<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://pypi.org/project/dockerpty/">
    <body>
      <group id="dockerpty">
        <trans-unit id="329832f23e6e018fc57a64ad29aadec48c90fea4" translate="yes" xml:space="preserve">
          <source># Docker PTY</source>
          <target state="translated"># Docker PTY</target>
        </trans-unit>
        <trans-unit id="bdd382f45d652e70bbc591b766c688e4229602e9" translate="yes" xml:space="preserve">
          <source>## Contributors</source>
          <target state="translated">## 기여자</target>
        </trans-unit>
        <trans-unit id="c800af699d8ecd99960e1f462f9ded4811ffa1c7" translate="yes" xml:space="preserve">
          <source>## Copyright &amp;amp; Licensing</source>
          <target state="translated">## 저작권 및 라이선스</target>
        </trans-unit>
        <trans-unit id="71c93e569c5623736cd4b4b2a0728094edfdc40e" translate="yes" xml:space="preserve">
          <source>## How it works</source>
          <target state="translated">## 작동 원리</target>
        </trans-unit>
        <trans-unit id="8443b75994470372e6420193dc5c6a01b6b7e6e1" translate="yes" xml:space="preserve">
          <source>## Installation</source>
          <target state="translated">## 설치</target>
        </trans-unit>
        <trans-unit id="76789687cb575b9442bedd485731a9c3801939d4" translate="yes" xml:space="preserve">
          <source>## Tests</source>
          <target state="translated">## 테스트</target>
        </trans-unit>
        <trans-unit id="6acd5424dab7b92c7ebe61c9fc818dbcdc0ea6ea" translate="yes" xml:space="preserve">
          <source>## Usage</source>
          <target state="translated">## 사용법</target>
        </trans-unit>
        <trans-unit id="41b903a2e9ae30d8b4229880ad402c7bd04ce955" translate="yes" xml:space="preserve">
          <source>&amp;gt; **Note:** dockerpty does support attaching to non-tty containers to stream</source>
          <target state="translated">&amp;gt; ** 참고 : ** dockerpty는 tty가 아닌 컨테이너에 연결하여 스트리밍하는 것을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="d5839949f3fc47224f8caf47db1b22459dea4ae3" translate="yes" xml:space="preserve">
          <source>(https://travis-ci.org/d11wtq/dockerpty)</source>
          <target state="translated">(https://travis-ci.org/d11wtq/dockerpty)</target>
        </trans-unit>
        <trans-unit id="258bc3a8ce6f7baad050b143c9e8cb226e0d2254" translate="yes" xml:space="preserve">
          <source>* docker-py&amp;gt;=0.3.2</source>
          <target state="translated">* docker-py&amp;gt; = 0.3.2</target>
        </trans-unit>
        <trans-unit id="39645660bcff5ef13ea20073de0024fbefd2a53c" translate="yes" xml:space="preserve">
          <source>- Collaborator: [Daniel Nephin](https://github.com/dnephin)</source>
          <target state="translated">-공동 작업자 : [Daniel Nephin] (https://github.com/dnephin)</target>
        </trans-unit>
        <trans-unit id="f25e082a716592dd3603363a85edd4b1ce684865" translate="yes" xml:space="preserve">
          <source>- Contributor: [Ben Firshman](https://github.com/bfirsh)</source>
          <target state="translated">-참여자 : [Ben Firshman] (https://github.com/bfirsh)</target>
        </trans-unit>
        <trans-unit id="6987602328b262c7b806103abdf914f6c3897edd" translate="yes" xml:space="preserve">
          <source>- Contributor: [Stephen Moore](https://github.com/delfick)</source>
          <target state="translated">-참여자 : [Stephen Moore] (https://github.com/delfick)</target>
        </trans-unit>
        <trans-unit id="5e0891ddc3ede3fcccfa65fdd6e88aed20d15cb0" translate="yes" xml:space="preserve">
          <source>- Primary author: [Chris Corbyn](https://github.com/d11wtq)</source>
          <target state="translated">-주 저자 : [Chris Corbyn] (https://github.com/d11wtq)</target>
        </trans-unit>
        <trans-unit id="f710c21ddbf4d329241c564d069d41e1e47c0af9" translate="yes" xml:space="preserve">
          <source>- Travis CI build: https://travis-ci.org/d11wtq/dockerpty</source>
          <target state="translated">-Travis CI 빌드 : https://travis-ci.org/d11wtq/dockerpty</target>
        </trans-unit>
        <trans-unit id="bb175da8f35160a379e20245087bb582a54d93d2" translate="yes" xml:space="preserve">
          <source>-bash$ behave features/</source>
          <target state="translated">-bash $ 동작 기능 /</target>
        </trans-unit>
        <trans-unit id="52d7b972fb63eaf8e8333a7e01d61116ccecc093" translate="yes" xml:space="preserve">
          <source>-bash$ pip install -r requirements-dev.txt</source>
          <target state="translated">-bash $ pip install -r requirements-dev.txt</target>
        </trans-unit>
        <trans-unit id="3cc2f242b5f889385a9ad14da34e11441db7230c" translate="yes" xml:space="preserve">
          <source>-bash$ py.test tests/</source>
          <target state="translated">-bash $ py.test 테스트 /</target>
        </trans-unit>
        <trans-unit id="f53a3d4ca1adf6ff7e1c0bcd8a5ceb372bb87960" translate="yes" xml:space="preserve">
          <source>Copyright &amp;amp;copy; 2014 Chris Corbyn. See the LICENSE.txt file for details.</source>
          <target state="translated">저작권 &amp;amp; copy; 2014 Chris Corbyn. 자세한 내용은 LICENSE.txt 파일을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="52851f96722cddb464564a1572603b50c69b5540" translate="yes" xml:space="preserve">
          <source>Dependencies:</source>
          <target state="translated">종속성 :</target>
        </trans-unit>
        <trans-unit id="15458e1123f37adbc3635ebb907bc04db93da939" translate="yes" xml:space="preserve">
          <source>However, this library does not explicitly declare this dependency in PyPi for a</source>
          <target state="translated">그러나이 라이브러리는 PyPi에서이 종속성을 명시 적으로 선언하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5ba1807bd3801a437da9cb8dfc23c477df94a18b" translate="yes" xml:space="preserve">
          <source>If with access to the host system's TTY file descriptors and the container's</source>
          <target state="translated">호스트 시스템의 TTY 파일 설명자 및 컨테이너의</target>
        </trans-unit>
        <trans-unit id="164508b4e778606f64ac0d7b508f9ffb7257037b" translate="yes" xml:space="preserve">
          <source>If you press `C-p C-q`, the container's PTY will be closed, but the container</source>
          <target state="translated">`Cp Cq`를 누르면 컨테이너의 PTY가 닫히지 만 컨테이너는</target>
        </trans-unit>
        <trans-unit id="004b71b1fcb7396b419f2cc5257a75b8c866ec0e" translate="yes" xml:space="preserve">
          <source>If you want to hack on dockerpty and send a PR, you'll need to run the tests.</source>
          <target state="translated">dockerpty를 해킹하고 PR을 보내려면 테스트를 실행해야합니다.</target>
        </trans-unit>
        <trans-unit id="2a788941d6e11e223baa38f2fc7e06c8dbf2b1a0" translate="yes" xml:space="preserve">
          <source>In a terminal, the three file descriptors stdin, stdout and stderr are all</source>
          <target state="translated">터미널에서 stdin, stdout 및 stderr 세 파일 설명자는 모두</target>
        </trans-unit>
        <trans-unit id="8b7bdab3f7b783bec338fefd3b5fa2d3752d1469" translate="yes" xml:space="preserve">
          <source>In reality it's a bit more complicated than this, since care must be taken to</source>
          <target state="translated">실제로는 이것보다 조금 더 복잡합니다.</target>
        </trans-unit>
        <trans-unit id="2dd80201ee761a890b7c583b6d9746b746fc85f0" translate="yes" xml:space="preserve">
          <source>In the features/ directory, are features/user stories for how dockerpty is</source>
          <target state="translated">features / 디렉토리에는 dockerpty가 어떻게 작동하는지에 대한 기능 / 사용자 스토리가 있습니다.</target>
        </trans-unit>
        <trans-unit id="6690a85596962a503e2c585e2e4495664bc22fe7" translate="yes" xml:space="preserve">
          <source>Keyword arguments passed to `start()` will be forwarded onto the client to</source>
          <target state="translated">`start ()`에 전달 된 키워드 인수는 클라이언트로 전달되어</target>
        </trans-unit>
        <trans-unit id="2897b8a07c69ee231036ca3dcaecdf7173f15165" translate="yes" xml:space="preserve">
          <source>PTY file descriptors, it is trivial to simply 'pipe' data written to these file</source>
          <target state="translated">PTY 파일 설명자,이 파일에 기록 된 데이터를 단순히 '파이프'하는 것은 간단합니다.</target>
        </trans-unit>
        <trans-unit id="1d1c9503e69ee8ae1fec761b5ab68a05031b5d8f" translate="yes" xml:space="preserve">
          <source>Provides the functionality needed to operate the pseudo-tty (PTY) allocated to</source>
          <target state="translated">할당 된 PTY (pseudo-tty)를 작동하는 데 필요한 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="acfd6fa0a2547a9f347cfad5cd11e505871bf074" translate="yes" xml:space="preserve">
          <source>Python library to use the pseudo-tty of a docker container</source>
          <target state="translated">Docker 컨테이너의 pseudo-tty를 사용하는 Python 라이브러리</target>
        </trans-unit>
        <trans-unit id="f37f9e971256a3703c69205b045962680543c7f9" translate="yes" xml:space="preserve">
          <source>Step definitions are defined in features/steps/.</source>
          <target state="translated">단계 정의는 features / steps /에 정의되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="43d6bfbfb35bd3532657a55d4485d70355e1a01e" translate="yes" xml:space="preserve">
          <source>The docker API provides a way to access the three sockets connected to the PTY.</source>
          <target state="translated">Docker API는 PTY에 연결된 3 개의 소켓에 액세스하는 방법을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="b2c3f486d5e1ab367729465df752cb538541ccb1" translate="yes" xml:space="preserve">
          <source>The following example will run busybox in a docker container and place the user</source>
          <target state="translated">다음 예제는 docker 컨테이너에서 busybox를 실행하고 사용자를 배치합니다.</target>
        </trans-unit>
        <trans-unit id="dba04f6eba8b06d8142821de7162a7a22b4930a7" translate="yes" xml:space="preserve">
          <source>The size of a terminal cannot be controlled by sending data to stdin and can</source>
          <target state="translated">터미널의 크기는 데이터를 stdin으로 전송하여 제어 할 수 없으며</target>
        </trans-unit>
        <trans-unit id="c6ff6e431b7ca8407097eb8f362a443be7ac0f64" translate="yes" xml:space="preserve">
          <source>There are also unit tests for the parts of the code that are not inherently</source>
          <target state="translated">본질적으로 존재하지 않는 코드 부분에 대한 단위 테스트도 있습니다.</target>
        </trans-unit>
        <trans-unit id="b9bbbae474c6074856b1efd66a350aa49f963d18" translate="yes" xml:space="preserve">
          <source>This is a safe operation and all resources are restored back to their original</source>
          <target state="translated">이것은 안전한 작업이며 모든 리소스가 원래 상태로 복원됩니다.</target>
        </trans-unit>
        <trans-unit id="ca4109b1479d7c41b79adab8f1baea4f0d52ee5b" translate="yes" xml:space="preserve">
          <source>This obviously only works when run in a terminal.</source>
          <target state="translated">이것은 터미널에서 실행될 때만 작동합니다.</target>
        </trans-unit>
        <trans-unit id="0f3c6705fa2e13055f3e4dc4646de83b0dfb3445" translate="yes" xml:space="preserve">
          <source>Travis CI runs this build inside a UML kernel that is new enough to run docker.</source>
          <target state="translated">Travis CI는 docker를 실행하기에 충분히 새로운 UML 커널 내에서이 빌드를 실행합니다.</target>
        </trans-unit>
        <trans-unit id="968c00074f8b60668476e710706515403faee8cd" translate="yes" xml:space="preserve">
          <source>Via pip:</source>
          <target state="translated">pip를 통해 :</target>
        </trans-unit>
        <trans-unit id="bbcb729864978e6263377edb82a2aeb43445219b" translate="yes" xml:space="preserve">
          <source>When the dockerpty is started, control is yielded to the container's PTY until</source>
          <target state="translated">dockerpty가 시작되면 제어권은 컨테이너의 PTY에 양보됩니다.</target>
        </trans-unit>
        <trans-unit id="ff69436c33dd29c9c0e71c789c82a722e0675c25" translate="yes" xml:space="preserve">
          <source>You'll need to have docker installed and running locally. The tests use busybox</source>
          <target state="translated">Docker를 설치하고 로컬에서 실행해야합니다. 테스트는 busybox를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="399639a4550d4297a0b09d80bdf86560fb238842" translate="yes" xml:space="preserve">
          <source>Your PR will need to pass the build before I can merge it.</source>
          <target state="translated">빌드를 병합하려면 PR이 빌드를 통과해야합니다.</target>
        </trans-unit>
        <trans-unit id="81ca42bbf14826c2eb3083e91270514506871af4" translate="yes" xml:space="preserve">
          <source>[![Build Status](https://travis-ci.org/d11wtq/dockerpty.svg?branch=master)]</source>
          <target state="translated">[! [빌드 상태] (https://travis-ci.org/d11wtq/dockerpty.svg?branch=master)]</target>
        </trans-unit>
        <trans-unit id="bbc0aff80688baeb01a5a4cb720794fe808ad957" translate="yes" xml:space="preserve">
          <source>```</source>
          <target state="translated">```</target>
        </trans-unit>
        <trans-unit id="2e1d9c02fb055e52eac1a39ee99bc32807e3a952" translate="yes" xml:space="preserve">
          <source>``` python</source>
          <target state="translated">```파이썬</target>
        </trans-unit>
        <trans-unit id="12c739a8aefa3ecdb12e38bbf8ed096af078e3e9" translate="yes" xml:space="preserve">
          <source>a docker container, using the Python client.</source>
          <target state="translated">Python 클라이언트를 사용하는 Docker 컨테이너</target>
        </trans-unit>
        <trans-unit id="68da0e35221cd32c6fa7482ca2e4126ffb6b5a1a" translate="yes" xml:space="preserve">
          <source>and can re-attach with another `dockerpty.start()` call.</source>
          <target state="translated">또 다른`dockerpty.start ()`호출로 다시 연결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2aefe891408b9ae1737af39535e210efe295591e" translate="yes" xml:space="preserve">
          <source>at the shell prompt via Python.</source>
          <target state="translated">Python을 통해 쉘 프롬프트에서.</target>
        </trans-unit>
        <trans-unit id="adfbe6d694e3bd5c3f0b774817ce4a785fb4c805" translate="yes" xml:space="preserve">
          <source>call to resize the allocated PTY. A SIGWINCH handler is used to detect window</source>
          <target state="translated">할당 된 PTY의 크기를 조정하려면 호출하십시오. SIGWINCH 핸들러는 창을 감지하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="0381baac5a0dc6093020a1f96943b54b00a2845b" translate="yes" xml:space="preserve">
          <source>client = docker.Client()</source>
          <target state="translated">클라이언트 = docker.Client ()</target>
        </trans-unit>
        <trans-unit id="8bd5031f9d7b489a66dc00971a759001edb65e2b" translate="yes" xml:space="preserve">
          <source>command='/bin/sh',</source>
          <target state="translated">명령 = '/ bin / sh',</target>
        </trans-unit>
        <trans-unit id="a655b01963cd28fc402658aa781654d4e061d2c1" translate="yes" xml:space="preserve">
          <source>connected to the controlling terminal (TTY). When you pass the `tty=True` flag</source>
          <target state="translated">제어 터미널 (TTY)에 연결됩니다. `tty = True` 플래그를 전달할 때</target>
        </trans-unit>
        <trans-unit id="298caa64e4432c89496853d0a72fc156f1382caa" translate="yes" xml:space="preserve">
          <source>connected.</source>
          <target state="translated">연결되었습니다.</target>
        </trans-unit>
        <trans-unit id="61ed9add7687ef1a3ceadbbb37919ebc32a15763" translate="yes" xml:space="preserve">
          <source>container (a PTY) to which the container's stdin, stdout and stderr are all</source>
          <target state="translated">컨테이너의 stdin, stdout 및 stderr이 모두있는 컨테이너 (PTY)</target>
        </trans-unit>
        <trans-unit id="bfe110ef496a871128aee338a93abb98762160ce" translate="yes" xml:space="preserve">
          <source>container = client.create_container(</source>
          <target state="translated">컨테이너 = client.create_container (</target>
        </trans-unit>
        <trans-unit id="65113d77e902a3e18b11d174c0117459982a90f3" translate="yes" xml:space="preserve">
          <source>container as a test fixture, so are not too heavy.</source>
          <target state="translated">컨테이너를 테스트 픽스처로 사용하므로 너무 무겁지 않습니다.</target>
        </trans-unit>
        <trans-unit id="34ec67a1acf89bca3ca7f9b169a63c9929dedd0d" translate="yes" xml:space="preserve">
          <source>container if you do not allocate a pseudo-tty.</source>
          <target state="translated">의사 tty를 할당하지 않은 경우 컨테이너.</target>
        </trans-unit>
        <trans-unit id="a819d1304a18ca836535aad78317509538773584" translate="yes" xml:space="preserve">
          <source>container output, though it is obviously not possible to 'control' the</source>
          <target state="translated">컨테이너 출력을 '제어'할 수는 없지만</target>
        </trans-unit>
        <trans-unit id="994f78e091e3747ee081cc871578b9159d84fae1" translate="yes" xml:space="preserve">
          <source>container's stdout and stderr streams along with `sys.stdin` must be made</source>
          <target state="translated">컨테이너의 stdout 및 stderr 스트림을`sys.stdin`과 함께 만들어야합니다.</target>
        </trans-unit>
        <trans-unit id="c54e079690dc69089d221a7c2efb75210ccf5f64" translate="yes" xml:space="preserve">
          <source>dependent on controlling a TTY. To run those:</source>
          <target state="translated">TTY 제어에 따라 다릅니다. 실행하려면 :</target>
        </trans-unit>
        <trans-unit id="dfc236920b66a4f316a44967a7887af8fc86a35c" translate="yes" xml:space="preserve">
          <source>descriptors between the host and the container. Doing this makes the user's</source>
          <target state="translated">호스트와 컨테이너 사이의 설명자. 이렇게하면 사용자가</target>
        </trans-unit>
        <trans-unit id="2e8570243f706139b85d18ad56eeff9a8e14388b" translate="yes" xml:space="preserve">
          <source>dockerpty.start(client, container)</source>
          <target state="translated">dockerpty.start (클라이언트, 컨테이너)</target>
        </trans-unit>
        <trans-unit id="defe0e16532164727e77d434e363beb517af66a1" translate="yes" xml:space="preserve">
          <source>image='busybox:latest',</source>
          <target state="translated">image = 'busybox : latest',</target>
        </trans-unit>
        <trans-unit id="563658b0e1af1ba9bb493e97ed0e65b6e2f71223" translate="yes" xml:space="preserve">
          <source>import docker</source>
          <target state="translated">가져 오기 도커</target>
        </trans-unit>
        <trans-unit id="e37bf59dfbfc82f8365225439d0d57b09a29580a" translate="yes" xml:space="preserve">
          <source>import dockerpty</source>
          <target state="translated">수입 Dockerpty</target>
        </trans-unit>
        <trans-unit id="dec9cace911a68e15312665487833bef3a23d2a4" translate="yes" xml:space="preserve">
          <source>interpreted with any special meaning) and restore it on exit. Additionally, the</source>
          <target state="translated">특별한 의미로 해석) 종료시 복원합니다. 또한</target>
        </trans-unit>
        <trans-unit id="b235f351e81477aef240623200041c87280492fc" translate="yes" xml:space="preserve">
          <source>non-blocking so that they can be used with `select()` without blocking the main</source>
          <target state="translated">non-blocking으로 메인을 차단하지 않고`select ()`와 함께 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1b04efcc73d8fbd58a1a2a7c2a33616a36dccb8f" translate="yes" xml:space="preserve">
          <source>number of reasons. It is assumed you have it installed.</source>
          <target state="translated">이유의 수. 설치 한 것으로 가정합니다.</target>
        </trans-unit>
        <trans-unit id="1a0e40dd1886df5874af4ce7b03d19831978401a" translate="yes" xml:space="preserve">
          <source>only be controlled by the terminal program itself. Since the pseudo-terminal is</source>
          <target state="translated">터미널 프로그램 자체에 의해서만 제어됩니다. 의사 터미널은</target>
        </trans-unit>
        <trans-unit id="9441876c13237ace52d9712355083d7c1b28bbd2" translate="yes" xml:space="preserve">
          <source>pip install dockerpty</source>
          <target state="translated">pip install dockerpty</target>
        </trans-unit>
        <trans-unit id="a2cc1aee93ebd7395e7a7b283342404a40fd07b8" translate="yes" xml:space="preserve">
          <source>process. These attributes are restored on exit.</source>
          <target state="translated">방법. 이러한 속성은 종료시 복원됩니다.</target>
        </trans-unit>
        <trans-unit id="3e2754f18d5aa2618dec95a593b5dd538364c8ac" translate="yes" xml:space="preserve">
          <source>put the host terminal into raw mode (where keys such as enter are not</source>
          <target state="translated">호스트 터미널을 원시 모드로 전환합니다 (Enter와 같은 키가</target>
        </trans-unit>
        <trans-unit id="1e67083fb5d38bfa0df71fc03b250b32375aa922" translate="yes" xml:space="preserve">
          <source>running inside a real terminal, it is import that the size of the PTY be kept</source>
          <target state="translated">실제 터미널 내부에서 실행되는 경우 PTY의 크기를 유지하는 것은 가져 오기입니다.</target>
        </trans-unit>
        <trans-unit id="4a16022091545c6111c0669a0f9db421c4cb4f05" translate="yes" xml:space="preserve">
          <source>size changes and resize the pseudo-terminal as needed.</source>
          <target state="translated">크기를 변경하고 필요에 따라 의사 터미널의 크기를 조정합니다.</target>
        </trans-unit>
        <trans-unit id="3fbb93cd68a767ed1f3438953b654f82292a7562" translate="yes" xml:space="preserve">
          <source>start the container.</source>
          <target state="translated">컨테이너를 시작하십시오.</target>
        </trans-unit>
        <trans-unit id="c4d7e6ff137480fb9531465ba65476a374a2cbe5" translate="yes" xml:space="preserve">
          <source>states.</source>
          <target state="translated">상태.</target>
        </trans-unit>
        <trans-unit id="9839e340c0ffba574eedf5811f37313ee3c1b54b" translate="yes" xml:space="preserve">
          <source>stdin_open=True,</source>
          <target state="translated">stdin_open = 참,</target>
        </trans-unit>
        <trans-unit id="4cad3d2ed03314de1ea818ad56caa2caea54ec4c" translate="yes" xml:space="preserve">
          <source>supposed to work. To run them:</source>
          <target state="translated">작동해야합니다. 실행하려면 :</target>
        </trans-unit>
        <trans-unit id="3351331027c19198fbf0d48761474e6353c68be9" translate="yes" xml:space="preserve">
          <source>terminal effectively become the pseudo-terminal from inside the container.</source>
          <target state="translated">터미널은 컨테이너 내부에서 효과적으로 의사 터미널이됩니다.</target>
        </trans-unit>
        <trans-unit id="3058663e45e04fea9bafb34c474c8fdb9a919fc8" translate="yes" xml:space="preserve">
          <source>the container exits, or the container's PTY is closed.</source>
          <target state="translated">컨테이너가 종료되거나 컨테이너의 PTY가 닫힙니다.</target>
        </trans-unit>
        <trans-unit id="11af435bbc169477469f50acb850138b6a6330f9" translate="yes" xml:space="preserve">
          <source>the same as that of the presenting TTY. For this reason, docker provides an API</source>
          <target state="translated">제시하는 TTY와 동일합니다. 이러한 이유로 docker는 API를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="bec1820ee4c9bc79e0a8432feeca61a730de3a69" translate="yes" xml:space="preserve">
          <source>to docker's `create_container()`, docker allocates a fake TTY inside the</source>
          <target state="translated">도커의`create_container ()`에 도커는 내부에 가짜 TTY를 할당합니다.</target>
        </trans-unit>
        <trans-unit id="e1d7f5cf27b7889d4a5822e8a25823db2b3cc2b0" translate="yes" xml:space="preserve">
          <source>tty=True,</source>
          <target state="translated">tty = 참,</target>
        </trans-unit>
        <trans-unit id="86f1850eed31f39810694c214be186ef002bdf72" translate="yes" xml:space="preserve">
          <source>will keep running. In other words, you will have detached from the container</source>
          <target state="translated">계속 실행됩니다. 즉, 컨테이너에서 분리 된 것입니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
