<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://pypi.org/project/lektor-limit-dependencies/">
    <body>
      <group id="lektor-limit-dependencies">
        <trans-unit id="57c87362ba9f1e26cae0ef2c8570b440c07075fd" translate="yes" xml:space="preserve">
          <source>A Solution?</source>
          <target state="translated">해결책?</target>
        </trans-unit>
        <trans-unit id="d1113406dab4d805986dcd36838b9de599df25f6" translate="yes" xml:space="preserve">
          <source>Add lektor-limit-dependencies to your project from command line:</source>
          <target state="translated">명령 줄에서 프로젝트에 lektor-limit-dependencies를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="de5446a74e74314a1477b0d84ed3111a64def114" translate="yes" xml:space="preserve">
          <source>At the end, &lt;code&gt;limit_dependencies&lt;/code&gt; records one dependency on a &lt;a href=&quot;https://www.getlektor.com/docs/api/db/obj/#virtual-source-objects&quot;&gt;virtual
source object&lt;/a&gt; which depends only on the sequence of the identities
of the records in the query result.  (Lektor provides a means by which
virtual source objects can report checksums.  If they do, the
dependency tracking mechanism records those checksums, and will
trigger a rebuild should the checksum change.  &lt;code&gt;Limit_dependencies&lt;/code&gt;
generates a virtual source object whose checksum depends on the
sequence identities in the query result.)</source>
          <target state="translated">마지막으로 &lt;code&gt;limit_dependencies&lt;/code&gt; 는 쿼리 결과에서 레코드의 ID 시퀀스에만 의존 하는 &lt;a href=&quot;https://www.getlektor.com/docs/api/db/obj/#virtual-source-objects&quot;&gt;가상 소스 개체&lt;/a&gt; 에 대한 하나의 종속성을 기록합니다. (Lektor는 가상 소스 객체가 체크섬을보고 할 수있는 수단을 제공합니다.이 경우 종속성 추적 메커니즘은 체크섬을 기록하고 체크섬이 변경되면 재 구축을 트리거합니다. &lt;code&gt;Limit_dependencies&lt;/code&gt; 는 체크섬이 시퀀스 ID에 따라 달라지는 가상 소스 객체를 생성합니다 . 쿼리 결과.)</target>
        </trans-unit>
        <trans-unit id="5fda23d62015b99fb2a9f86b38bcdf2bdf7609c8" translate="yes" xml:space="preserve">
          <source>Author</source>
          <target state="translated">저자</target>
        </trans-unit>
        <trans-unit id="164b3d4809f98d0458414f1bf9cf3c9dcba16bb5" translate="yes" xml:space="preserve">
          <source>Changelog</source>
          <target state="translated">변경 로그</target>
        </trans-unit>
        <trans-unit id="e40891d544d734f645310d4547a9707f7290cd49" translate="yes" xml:space="preserve">
          <source>In the above example, this is exactly what we want.  We only want to
trigger a rebuild if the order or composition of the most-recent three
posts changes.  (Or if any of their titles change.  Note that this
gets covered, too, since when the resulting query is iterated over in
the &lt;code&gt;{% for %}&lt;/code&gt; loop, dependencies will be recorded on the three
most-recent posts.)</source>
          <target state="translated">위의 예에서 이것이 정확히 우리가 원하는 것입니다. 가장 최근에 게시 된 3 개의 게시물의 순서 또는 구성이 변경된 경우에만 재 빌드를 시작하려고합니다. (또는 제목 중 하나가 변경되는 경우에도 마찬가지입니다. 결과 쿼리가 &lt;code&gt;{% for %}&lt;/code&gt; 루프 에서 반복 될 때 종속성이 가장 최근의 게시물 3 개에 기록 되기 때문에 이것도 다룹니다 .)</target>
        </trans-unit>
        <trans-unit id="970d9459b2c3bd1aab215bea63f715a31dc6bf75" translate="yes" xml:space="preserve">
          <source>Initial release.</source>
          <target state="translated">초판.</target>
        </trans-unit>
        <trans-unit id="c81b79df3c6448eae7c4f80428b54cd5692a17d7" translate="yes" xml:space="preserve">
          <source>Installation</source>
          <target state="translated">설치</target>
        </trans-unit>
        <trans-unit id="2473e96bc614a911821242119918a241a41836d6" translate="yes" xml:space="preserve">
          <source>Introduction</source>
          <target state="translated">소개</target>
        </trans-unit>
        <trans-unit id="a80231e80e493a0843c82d046db4885620c204bd" translate="yes" xml:space="preserve">
          <source>Jeff Dairiki &lt;a href=&quot;mailto:dairiki@dairiki.org&quot;&gt;dairiki@dairiki.org&lt;/a&gt;</source>
          <target state="translated">Jeff Dairiki &lt;a href=&quot;mailto:dairiki@dairiki.org&quot;&gt;dairiki@dairiki.org&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f1c69b703e5eeee07b4e03f38b8ec2e506b4d1f6" translate="yes" xml:space="preserve">
          <source>Lektor Limit Dependencies</source>
          <target state="translated">Lektor 제한 종속성</target>
        </trans-unit>
        <trans-unit id="60cb043c992a452ab9f217a8cde4afda8f6e6de3" translate="yes" xml:space="preserve">
          <source>Lektor plugin to limit dependencies created by queries</source>
          <target state="translated">쿼리에 의해 생성 된 종속성을 제한하는 Lektor 플러그인</target>
        </trans-unit>
        <trans-unit id="a3353eaedd716dcf00a8eb537b2bf88cc7369d5c" translate="yes" xml:space="preserve">
          <source>Motivating Example</source>
          <target state="translated">동기를 부여하는 예</target>
        </trans-unit>
        <trans-unit id="4f61a37e7ab6cdf29f7199297dd3c44c0e71d984" translate="yes" xml:space="preserve">
          <source>Release 0.1a1</source>
          <target state="translated">릴리스 0.1a1</target>
        </trans-unit>
        <trans-unit id="ad8e8d940187e590f1575ebb0dee021bd4f2428c" translate="yes" xml:space="preserve">
          <source>Released May 19, 2020</source>
          <target state="translated">2020 년 5 월 19 일 출시</target>
        </trans-unit>
        <trans-unit id="8e488136e008259e15bbae5985cf0aa2665b393d" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://www.getlektor.com/docs/plugins/&quot;&gt;the Lektor plugin documentation&lt;/a&gt; for more information.</source>
          <target state="translated">자세한 내용 &lt;a href=&quot;https://www.getlektor.com/docs/plugins/&quot;&gt;은 Lektor 플러그인 문서&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="e6f3dd6a517bec9ad78a5571d8399366f8054ce9" translate="yes" xml:space="preserve">
          <source>Suppose that you would like to list the three most recent blog posts
in the sidebar of your Lektor-based site.  This can be done by adding
something like to your site base template:</source>
          <target state="translated">Lektor 기반 사이트의 사이드 바에 최신 블로그 게시물 3 개를 나열하려고한다고 가정합니다. 이것은 사이트 기본 템플릿에 다음과 같은 것을 추가하여 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ef34e67472be2550caccfd199e06b9692653f647" translate="yes" xml:space="preserve">
          <source>Technically, it is true that all pages now depend on all posts.  You
might well edit the &lt;code&gt;pub_date&lt;/code&gt; of one of your older posts, such that
it should now appear in the most-recent listing.  However, it is not
true that all pages need to be rebuilt for &lt;em&gt;any&lt;/em&gt; edit of any post.
Unfortunately, Lektor&amp;rsquo;s dependency tracking system is not elaborate
enough to be able to express details about &lt;em&gt;how&lt;/em&gt; pages are
dependendent on other pages; it only records that they &lt;em&gt;are&lt;/em&gt;
dependent, so Lektor has no option but to rebuild everything.</source>
          <target state="translated">기술적으로 모든 페이지가 이제 모든 게시물에 의존한다는 것은 사실입니다. 이전 게시물 중 하나의 &lt;code&gt;pub_date&lt;/code&gt; 를 편집하여 이제 최신 목록에 표시되도록 할 수 있습니다. 그러나, 모든 페이지가 재 구축 할 필요가 있다는 사실이 아니다 &lt;em&gt;있는&lt;/em&gt; 모든 게시물의 편집. 안타깝게도 Lektor의 종속성 추적 시스템은 페이지가 다른 페이지 에 &lt;em&gt;어떻게&lt;/em&gt; 의존 &lt;em&gt;하는지&lt;/em&gt; 에 대한 세부 정보를 표현할 수있을만큼 정교하지 않습니다 . 그것은 단지 그들이 그 기록 &lt;em&gt;입니다&lt;/em&gt; 의존, 그래서 Lektor는 어떤 옵션을 제외한 모든 재건이 없습니다.</target>
        </trans-unit>
        <trans-unit id="8fc14956143b61b5e6552b4238eb89bcdc0e3571" translate="yes" xml:space="preserve">
          <source>This is an experimental &lt;a href=&quot;https://www.getlektor.com/&quot;&gt;Lektor&lt;/a&gt; plugin which aims to provide tools (or,
at least, a tool) to help keep Lektor&amp;rsquo;s dependency tracking under
control.</source>
          <target state="translated">이것은 Lektor의 의존성 추적을 제어하는 ​​데 도움이되는 도구 (또는 최소한 도구)를 제공하는 것을 목표로 하는 실험적인 &lt;a href=&quot;https://www.getlektor.com/&quot;&gt;Lektor&lt;/a&gt; 플러그인입니다.</target>
        </trans-unit>
        <trans-unit id="79efab6a67350c7a0ceafd5d7595a06bea3c4fe0" translate="yes" xml:space="preserve">
          <source>This is not without drawbacks, however.  To sort the post query by
date, Lektor iterates through &lt;em&gt;&lt;strong&gt;all&lt;/strong&gt;&lt;/em&gt; of the blogs posts, then sorts
them.  In so doing, it records all of the blog posts as dependencies
&lt;em&gt;of every page on which this most-recent-post query is used&lt;/em&gt;.  If this
is in the sidebar of every page on your site, &lt;em&gt;now every page on your
site will be rebuilt whenever any blog post at all&lt;/em&gt; (not just one of
the three most recent posts) &lt;em&gt;is edited&lt;/em&gt;.</source>
          <target state="translated">그러나 이것은 단점이없는 것은 아닙니다. 날짜별로 게시물 쿼리를 정렬하기 위해 Lektor는 &lt;em&gt;&lt;strong&gt;모든&lt;/strong&gt;&lt;/em&gt; 블로그 게시물을 반복 한 다음 정렬합니다. 이렇게하면 &lt;em&gt;이 최신 게시물 쿼리가 사용되는 모든 페이지의&lt;/em&gt; 종속성 &lt;em&gt;으로 모든&lt;/em&gt; 블로그 게시물을 기록합니다 . 이것이 사이트의 모든 페이지의 사이드 바에있는 경우 &lt;em&gt;이제 블로그 게시물&lt;/em&gt; (가장 최근 게시물 3 개 중 하나가 아닌) &lt;em&gt;이 편집 &lt;/em&gt;&lt;em&gt;될 때마다 사이트의 모든 페이지가 다시 작성됩니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="bffd16dcab6fcb616e39b6db02118ba34204eea1" translate="yes" xml:space="preserve">
          <source>This plugin introduces a Jinja filter, &lt;code&gt;limit_dependencies&lt;/code&gt;.  It
expects, as input, a Lektor query instance.  It iterates through the
input query, and returns a new query instance which will yield the
same results.  While it is doing its iteration, it, essentially,
monkey-patches Lektor&amp;rsquo;s dependency tracking machinery to prevent it
from recording any dependencies.</source>
          <target state="translated">이 플러그인은 Jinja 필터 인 &lt;code&gt;limit_dependencies&lt;/code&gt; 를 도입합니다 . 입력으로 Lektor 쿼리 인스턴스를 예상합니다. 입력 쿼리를 반복하고 동일한 결과를 생성하는 새 쿼리 인스턴스를 반환합니다. 반복을 수행하는 동안 본질적으로 Lektor의 종속성 추적 기계를 원숭이 패치하여 종속성을 기록하지 못하도록합니다.</target>
        </trans-unit>
        <trans-unit id="6f9c48e9e181daa94845c47f890c02f187920d72" translate="yes" xml:space="preserve">
          <source>Thus, the example above, if replaced by:</source>
          <target state="translated">따라서 위의 예는 다음으로 대체됩니다.</target>
        </trans-unit>
        <trans-unit id="f0a8c31491c46af17c5e928d5a50a07d9232fb61" translate="yes" xml:space="preserve">
          <source>will work in a much more efficient and sane manner.  Pages will be
rebuilt only if there are changes in the order, composition or content
of the three most recent posts.</source>
          <target state="translated">훨씬 더 효율적이고 건전한 방식으로 작동합니다. 페이지는 가장 최근 게시물 3 개의 순서, 구성 또는 내용이 변경된 경우에만 다시 작성됩니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
