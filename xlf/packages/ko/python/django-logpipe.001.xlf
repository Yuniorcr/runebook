<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://pypi.org/project/django-logpipe/">
    <body>
      <group id="django-logpipe">
        <trans-unit id="5c10b5b2cd673a0616d529aa5234b12ee7153808" translate="yes" xml:space="preserve">
          <source>,</source>
          <target state="translated">,</target>
        </trans-unit>
        <trans-unit id="8278d2adba7612cf98a492d21a4ac4c78acb1202" translate="yes" xml:space="preserve">
          <source>, and</source>
          <target state="translated">,</target>
        </trans-unit>
        <trans-unit id="903765c186e31c456af2dd0a8b1af35e27926e69" translate="yes" xml:space="preserve">
          <source>, which allows the consumer to explicitly ignore specific message types silently. This helps to filter log noise (messages that a consumer really doesn&amp;rsquo;t care about) from actual errors (messages a consumer is skipping, but should be processing).</source>
          <target state="translated">, 소비자가 특정 메시지 유형을 자동으로 명시 적으로 무시할 수 있습니다. 이는 실제 오류 (소비자가 건너 뛰고 있지만 처리해야하는 메시지)에서 로그 노이즈 (소비자가 실제로 신경 쓰지 않는 메시지)를 필터링하는 데 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="7e0b7dff883d6861e892a62c5d13fdeee2afeb2b" translate="yes" xml:space="preserve">
          <source>.
1. Must have a</source>
          <target state="translated">. 1. 있어야합니다</target>
        </trans-unit>
        <trans-unit id="e2d7ba2bf4939b39661ef6382455724c12db2b73" translate="yes" xml:space="preserve">
          <source>. This class method will be called with message data as keyword arguments directly before instantiating the serializer. It should lookup and return the related object (if one exists) so that it can be passed to the serializer&amp;rsquo;s</source>
          <target state="translated">. 이 클래스 메서드는 serializer를 인스턴스화하기 직전에 메시지 데이터를 키워드 인수로 사용하여 호출됩니다. 관련 객체 (있는 경우)를 조회하고 반환하여 serializer의</target>
        </trans-unit>
        <trans-unit id="88ab9fedb07f1ab06d98fe20e0aa97c4fe67882d" translate="yes" xml:space="preserve">
          <source>1. Must be either a subclass of</source>
          <target state="translated">1. 다음의 하위 클래스 여야합니다.</target>
        </trans-unit>
        <trans-unit id="61cc55aa0453184734c3fa0b621eda6fa874bd83" translate="yes" xml:space="preserve">
          <source>Add</source>
          <target state="translated">더하다</target>
        </trans-unit>
        <trans-unit id="f21c4dfb46a3cd544ca1b7134542dcdc6e71187b" translate="yes" xml:space="preserve">
          <source>Add Django 2.1 to tox test suite.</source>
          <target state="translated">tox 테스트 스위트에 Django 2.1을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="2e7d120ba3320d9e3ba55ac298fb7121216ba4be" translate="yes" xml:space="preserve">
          <source>Add connection settings to your</source>
          <target state="translated">연결 설정을</target>
        </trans-unit>
        <trans-unit id="dbd3d7c17cc0b57d2980784d2b44e7de422bd091" translate="yes" xml:space="preserve">
          <source>Add new method:</source>
          <target state="translated">새 방법 추가 :</target>
        </trans-unit>
        <trans-unit id="5c9939d96ec5030765ea376c476f6394ff1b1c68" translate="yes" xml:space="preserve">
          <source>Add support for Python 3.7.</source>
          <target state="translated">Python 3.7에 대한 지원을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="144c7a6c50347e783af6e04fe897ccdc25cdeff1" translate="yes" xml:space="preserve">
          <source>Add support for python-kafka 1.4.4.</source>
          <target state="translated">python-kafka 1.4.4에 대한 지원을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="74e23423b466ccf9447a0d5a069e2d3feb919c8f" translate="yes" xml:space="preserve">
          <source>Added concept of message types.</source>
          <target state="translated">메시지 유형의 개념이 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="e7db4f6c303e2a63a9d4926308603e481bf8fb87" translate="yes" xml:space="preserve">
          <source>Added support for AWS Kinesis.</source>
          <target state="translated">AWS Kinesis에 대한 지원이 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="43ddd06cc437eac739c0896b99458abfb6684f35" translate="yes" xml:space="preserve">
          <source>After some amount of time (when you are sure no old-version messages still exist in Kafka), remove the code related to the old schema version.</source>
          <target state="translated">일정 시간이 지난 후 (Kafka에 이전 버전 메시지가 아직없는 경우) 이전 스키마 버전과 관련된 코드를 제거합니다.</target>
        </trans-unit>
        <trans-unit id="e26792af16c97fd3c5d213187b0b33cbfe98b605" translate="yes" xml:space="preserve">
          <source>Below is a sample Django model and it&amp;rsquo;s accompanying serializer.</source>
          <target state="translated">아래는 샘플 Django 모델과 함께 제공되는 시리얼 라이저입니다.</target>
        </trans-unit>
        <trans-unit id="164b3d4809f98d0458414f1bf9cf3c9dcba16bb5" translate="yes" xml:space="preserve">
          <source>Changelog</source>
          <target state="translated">변경 로그</target>
        </trans-unit>
        <trans-unit id="e38de8a0028066c885206cb0346572995a1642d3" translate="yes" xml:space="preserve">
          <source>Dealing with Schema Changes</source>
          <target state="translated">스키마 변경 처리</target>
        </trans-unit>
        <trans-unit id="9cd780126a6cbee99f4a1663a13604d9125012dd" translate="yes" xml:space="preserve">
          <source>Finally, after all the old version 1 messages have been dropped (by log compaction), the</source>
          <target state="translated">마지막으로 모든 이전 버전 1 메시지가 삭제 된 후 (로그 압축에 의해)</target>
        </trans-unit>
        <trans-unit id="627b6464f73da86d7de18686941d7b09fc58adb6" translate="yes" xml:space="preserve">
          <source>Finally, consumers can be registered and run automatically by the build in</source>
          <target state="translated">마지막으로 소비자를 등록하고 빌드에서 자동으로 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="21aa4df0e5ee730531b02a18b193bd8447274a3d" translate="yes" xml:space="preserve">
          <source>Fix compatibility issue with Django 3.0</source>
          <target state="translated">Django 3.0과의 호환성 문제 수정</target>
        </trans-unit>
        <trans-unit id="5f4d11805dd6ed2de8e4b66c76b7fb48b5493c4d" translate="yes" xml:space="preserve">
          <source>For example, if we wanted to require an email field on the</source>
          <target state="translated">예를 들어, 이메일 필드가 필요한 경우</target>
        </trans-unit>
        <trans-unit id="68edffd510af78279e051f946b30e579dd35c521" translate="yes" xml:space="preserve">
          <source>If you have multiple data-types in a single topic or stream, you can consume them all by registering multiple serializers with the consumer.</source>
          <target state="translated">단일 주제 또는 스트림에 여러 데이터 유형이있는 경우 소비자에 여러 직렬 변환기를 등록하여 모두 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="271836dc950be42ea67e7e4d2f48692567828398" translate="yes" xml:space="preserve">
          <source>If you have multiple streams or topics to watch, make a consumers for each, and watch them all simultaneously in the same process by using a MultiConsumer.</source>
          <target state="translated">시청할 스트림 또는 주제가 여러 개인 경우 각각에 대한 소비자를 만들고 MultiConsumer를 사용하여 동일한 프로세스에서 모두 동시에 시청하세요.</target>
        </trans-unit>
        <trans-unit id="124d52fb04f2c7f1db15f3ed0feaccbb45b60443" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re using AWS Kinesis instead of Kafka, it will look like this:</source>
          <target state="translated">Kafka 대신 AWS Kinesis를 사용하는 경우 다음과 같이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="1a83b2ad6d7db2286ab50ca7a435e58c25172b5b" translate="yes" xml:space="preserve">
          <source>Improve log messages and levels for invalid or unknown messages.</source>
          <target state="translated">유효하지 않거나 알 수없는 메시지에 대한 로그 메시지 및 수준을 개선합니다.</target>
        </trans-unit>
        <trans-unit id="8d977302311c1f20782e75d4f1942383b9f18b74" translate="yes" xml:space="preserve">
          <source>Improved logic for detecting the current AWS region.</source>
          <target state="translated">현재 AWS 리전을 감지하기위한 로직이 개선되었습니다.</target>
        </trans-unit>
        <trans-unit id="9a3a1734e49dbe1a6c8b63692409a3b98786a172" translate="yes" xml:space="preserve">
          <source>In KinesisOffset model, track the AWS region for a stream. This allows a single database to subscribe to multiple streams in different regions, even it they have the same name.</source>
          <target state="translated">KinesisOffset 모델에서 스트림에 대한 AWS 리전을 추적합니다. 이를 통해 단일 데이터베이스는 이름이 같은 경우에도 다른 지역의 여러 스트림을 구독 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="970d9459b2c3bd1aab215bea63f715a31dc6bf75" translate="yes" xml:space="preserve">
          <source>Initial release.</source>
          <target state="translated">초판.</target>
        </trans-unit>
        <trans-unit id="fd6c3ebf7befca9f8208f86c76e4d4180303745c" translate="yes" xml:space="preserve">
          <source>Install</source>
          <target state="translated">설치</target>
        </trans-unit>
        <trans-unit id="c81b79df3c6448eae7c4f80428b54cd5692a17d7" translate="yes" xml:space="preserve">
          <source>Installation</source>
          <target state="translated">설치</target>
        </trans-unit>
        <trans-unit id="3b755f7b857b999860755840e5f0964f6b120c4d" translate="yes" xml:space="preserve">
          <source>Internationalization</source>
          <target state="translated">국제화</target>
        </trans-unit>
        <trans-unit id="0e921845ded85f4ca71612e4983252e0fd2d93a9" translate="yes" xml:space="preserve">
          <source>KEY_FIELD</source>
          <target state="translated">KEY_FIELD</target>
        </trans-unit>
        <trans-unit id="9adf8aa78ce63d42002629004f9d8c5d6e3a24c6" translate="yes" xml:space="preserve">
          <source>MESSAGE_TYPE</source>
          <target state="translated">MESSAGE_TYPE</target>
        </trans-unit>
        <trans-unit id="4276e29a02fd8f6945c318a424eea128da500f12" translate="yes" xml:space="preserve">
          <source>More robustly handle exceptions thrown by a consumer serializer&amp;rsquo;s</source>
          <target state="translated">소비자 시리얼 라이저가 던진 예외를보다 강력하게 처리합니다.</target>
        </trans-unit>
        <trans-unit id="1b6da58d60c7bcb0b62a3c84017df86a6a8a4e4e" translate="yes" xml:space="preserve">
          <source>Move data around between Python services using Kafka and/or AWS Kinesis and Django Rest Framework serializers.</source>
          <target state="translated">Kafka 및 / 또는 AWS Kinesis 및 Django Rest Framework 직렬 변환기를 사용하여 Python 서비스간에 데이터를 이동합니다.</target>
        </trans-unit>
        <trans-unit id="9b1fcbda693f085c4d6d33acbf333e420ba23fca" translate="yes" xml:space="preserve">
          <source>No changes.</source>
          <target state="translated">변경 사항 없음.</target>
        </trans-unit>
        <trans-unit id="6eef6648406c333a4035cd5e60d0bf2ecf2606d7" translate="yes" xml:space="preserve">
          <source>None</source>
          <target state="translated">없음</target>
        </trans-unit>
        <trans-unit id="b05bfe270cc8d7c863fcaef41cec57b4a874688f" translate="yes" xml:space="preserve">
          <source>Once a serializer exists, you can send a message to Kafka by creating Producer object and calling the</source>
          <target state="translated">serializer가 있으면 Producer 개체를 만들고 다음을 호출하여 Kafka에 메시지를 보낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8c41ae88467fe5bbad09fcd488662b25c3ec5333" translate="yes" xml:space="preserve">
          <source>Person</source>
          <target state="translated">사람</target>
        </trans-unit>
        <trans-unit id="2d4de422295bafb2c7667583c219074d358b9914" translate="yes" xml:space="preserve">
          <source>PersonSerializerV1</source>
          <target state="translated">PersonSerializerV1</target>
        </trans-unit>
        <trans-unit id="4afc4c099bd08e0d44d6982b97152facf84d0c8d" translate="yes" xml:space="preserve">
          <source>Receiving Messages</source>
          <target state="translated">메시지 받기</target>
        </trans-unit>
        <trans-unit id="8611e40d1056868462071ad966dca76f00201f08" translate="yes" xml:space="preserve">
          <source>Run migrations. This will create the model used to store Kafka log position offsets.:</source>
          <target state="translated">마이그레이션을 실행하십시오. 이렇게하면 Kafka 로그 위치 오프셋을 저장하는 데 사용되는 모델이 생성됩니다. :</target>
        </trans-unit>
        <trans-unit id="6fa3703a1bdf2d255844c1967f71f224913cffac" translate="yes" xml:space="preserve">
          <source>Schema changes are handled using the</source>
          <target state="translated">스키마 변경은</target>
        </trans-unit>
        <trans-unit id="f0662ea4ce2ba05b7f07ad1199c4b10caa58025d" translate="yes" xml:space="preserve">
          <source>Sending Messages</source>
          <target state="translated">메시지 보내기</target>
        </trans-unit>
        <trans-unit id="71796031218483adb9338df6ac1fe8ad1217e178" translate="yes" xml:space="preserve">
          <source>Serializers</source>
          <target state="translated">직렬 변환기</target>
        </trans-unit>
        <trans-unit id="845c23acd2d57e4a45e5f9d2ddd30f9cfc985ce9" translate="yes" xml:space="preserve">
          <source>The above sample code would result in the following message being sent to the Kafka topic named</source>
          <target state="translated">위의 샘플 코드는 다음과 같은 메시지가 Kafka 주제로 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="ffa25f9133ff3c7db5f21fa0df07b10a5586ea06" translate="yes" xml:space="preserve">
          <source>The consumer object uses Django REST Framework&amp;rsquo;s built-in</source>
          <target state="translated">소비자 개체는 Django REST Framework의 기본 제공을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="1d106a3b7b84e0ca3d5e70cafd0526170152e47c" translate="yes" xml:space="preserve">
          <source>The consumers will now use the appropriate serializer for the message version. Second, we need to update producer code to being using schema version 2.:</source>
          <target state="translated">소비자는 이제 메시지 버전에 적절한 직렬 변환기를 사용합니다. 둘째, 스키마 버전 2를 사용하도록 생산자 코드를 업데이트해야합니다.</target>
        </trans-unit>
        <trans-unit id="b47903da5844aaf66338046865341227ddf794af" translate="yes" xml:space="preserve">
          <source>The first step in either sending or receiving messages with</source>
          <target state="translated">메시지를 보내거나받는 첫 번째 단계</target>
        </trans-unit>
        <trans-unit id="c22aa8ea3bbd87b3fdb24798299beac0d377babf" translate="yes" xml:space="preserve">
          <source>This library serves as a universal pipe for moving data around between Django applications and services. It is build on
top of &lt;a href=&quot;https://boto3.readthedocs.io/en/latest/&quot;&gt;Boto3&lt;/a&gt;, &lt;a href=&quot;https://kafka.apache.org/&quot;&gt;Apache Kafka&lt;/a&gt;, &lt;a href=&quot;https://github.com/dpkp/kafka-python&quot;&gt;kafka-python&lt;/a&gt;, and &lt;a href=&quot;http://www.django-rest-framework.org/&quot;&gt;Django REST Framework&lt;/a&gt;.</source>
          <target state="translated">이 라이브러리는 Django 애플리케이션과 서비스간에 데이터를 이동하기위한 범용 파이프 역할을합니다. &lt;a href=&quot;https://boto3.readthedocs.io/en/latest/&quot;&gt;Boto3&lt;/a&gt; , &lt;a href=&quot;https://kafka.apache.org/&quot;&gt;Apache Kafka&lt;/a&gt; , &lt;a href=&quot;https://github.com/dpkp/kafka-python&quot;&gt;kafka-python&lt;/a&gt; 및 &lt;a href=&quot;http://www.django-rest-framework.org/&quot;&gt;Django REST Framework&lt;/a&gt; 위에 빌드됩니다 .</target>
        </trans-unit>
        <trans-unit id="bee3d83cc56cf9bb415862ee5d7d2fa680b12552" translate="yes" xml:space="preserve">
          <source>To perform a backwards-incompatible schema change, the following steps should be performed.</source>
          <target state="translated">이전 버전과 호환되지 않는 스키마 변경을 수행하려면 다음 단계를 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="44a75fd9ae981e96331b4fd634c35934f291b0eb" translate="yes" xml:space="preserve">
          <source>To processing incoming messages, we can reuse the same model and serializer. We just need to instantiate a Consumer object.</source>
          <target state="translated">수신 메시지를 처리하기 위해 동일한 모델과 직렬 변환기를 재사용 할 수 있습니다. Consumer 객체를 인스턴스화하기 만하면됩니다.</target>
        </trans-unit>
        <trans-unit id="760d77319d33dd98f7de4a21a9beebd585f4f1bb" translate="yes" xml:space="preserve">
          <source>Update consumer code to have knowledge of the new schema version.</source>
          <target state="translated">새 스키마 버전을 알 수 있도록 소비자 코드를 업데이트합니다.</target>
        </trans-unit>
        <trans-unit id="e9d9bf0c4f187aed5459d99826260d2d90fbd55e" translate="yes" xml:space="preserve">
          <source>Update producer code to being sending the new schema version.</source>
          <target state="translated">새 스키마 버전을 보내도록 생산자 코드를 업데이트합니다.</target>
        </trans-unit>
        <trans-unit id="0bb18642b70b9f8a9c12ccf39487328f306b8e19" translate="yes" xml:space="preserve">
          <source>Usage</source>
          <target state="translated">용법</target>
        </trans-unit>
        <trans-unit id="340d33e2025ffe706ac456af47f78712a84bc2c1" translate="yes" xml:space="preserve">
          <source>Use the</source>
          <target state="translated">사용</target>
        </trans-unit>
        <trans-unit id="b33892fbddeffc3368077b4904ad0b3d562a7312" translate="yes" xml:space="preserve">
          <source>VERSION</source>
          <target state="translated">버전</target>
        </trans-unit>
        <trans-unit id="05d85e7d0002fe23af087c94dcb76e1cd32d04dc" translate="yes" xml:space="preserve">
          <source>You can also support multiple incompatible version of message types by defining a serializer for each message type version and registering them all with the consumer.</source>
          <target state="translated">또한 각 메시지 유형 버전에 대한 serializer를 정의하고이를 모두 소비자에 등록하여 호환되지 않는 여러 버전의 메시지 유형을 지원할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="ff69380b6a64172adf8d15c916fbc2984553e8b2" translate="yes" xml:space="preserve">
          <source>argument during initialization. If no object exists yet (the message is representing a new object), it should return</source>
          <target state="translated">초기화 중 인수. 아직 객체가 없으면 (메시지가 새 객체를 나타냄) 다음을 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="93d4e6db7d8ed0b59ae019e317a84d1c04c7b2e9" translate="yes" xml:space="preserve">
          <source>attribute defined on the class, representing the name of the field to use as the message key. The message key is used by Kafka when performing log compaction and by Kinesis as the shard partition key. The property can be omitted for topics which do not require a key.
4. If the serializer will be used for incoming-messages, it should implement class method</source>
          <target state="translated">메시지 키로 사용할 필드의 이름을 나타내는 클래스에 정의 된 속성입니다. 메시지 키는 Kafka에서 로그 압축을 수행 할 때 사용하고 Kinesis에서 샤드 파티션 키로 사용합니다. 키가 필요하지 않은 항목의 경우 속성을 생략 할 수 있습니다. 4. serializer가 수신 메시지에 사용되는 경우 클래스 메소드를 구현해야합니다.</target>
        </trans-unit>
        <trans-unit id="bd9eb1ec81cf0e354af01d5b454d18b18ba35af5" translate="yes" xml:space="preserve">
          <source>attribute defined on the class. The value should be a monotonic integer representing the schema version number.
3. Must have a</source>
          <target state="translated">클래스에 정의 된 속성. 값은 스키마 버전 번호를 나타내는 단조로운 정수 여야합니다. 3. 있어야합니다</target>
        </trans-unit>
        <trans-unit id="9af0277498ccdb7d81bd3aca08dc767cb572f99e" translate="yes" xml:space="preserve">
          <source>attribute defined on the class. The value should be a string that defines uniquely defines the data-type within it&amp;rsquo;s Topic / Stream.
2. Must have a</source>
          <target state="translated">클래스에 정의 된 속성. 값은 토픽 / 스트림 내에서 데이터 유형을 고유하게 정의하는 문자열이어야합니다. 2. 있어야합니다</target>
        </trans-unit>
        <trans-unit id="c76b77da8f80ae0f36ca4375d587a4d6e9b07cc4" translate="yes" xml:space="preserve">
          <source>attribute required on every serializer class. When sending, a producer includes the schema version number in the message data. Then, when a consumer receives a message, it looks for a register serializer with a matching version number. If no serializer is found with a matching version number, a</source>
          <target state="translated">모든 serializer 클래스에 필요한 속성입니다. 보낼 때 생산자는 메시지 데이터에 스키마 버전 번호를 포함합니다. 그런 다음 소비자가 메시지를 받으면 버전 번호가 일치하는 레지스터 직렬 변환기를 찾습니다. 버전 번호가 일치하는 serializer가 없으면</target>
        </trans-unit>
        <trans-unit id="a383ee670aa695f58764b603c943107f5067c7b4" translate="yes" xml:space="preserve">
          <source>class can be removed form the code base.</source>
          <target state="translated">클래스는 코드베이스에서 제거 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a2671e5741b7108b36c72c01251577ade8fb8620" translate="yes" xml:space="preserve">
          <source>class method and override the</source>
          <target state="translated">클래스 메서드를 재정의하고</target>
        </trans-unit>
        <trans-unit id="607607967c83fde63c7ac6218e62c8d8d8d9f82a" translate="yes" xml:space="preserve">
          <source>command to process messages for all consumers automatically in a round-robin fashion.</source>
          <target state="translated">라운드 로빈 방식으로 모든 소비자의 메시지를 자동으로 처리하는 명령입니다.</target>
        </trans-unit>
        <trans-unit id="9b7c68a918b17eb053809b198d7c9abfc142f30a" translate="yes" xml:space="preserve">
          <source>create</source>
          <target state="translated">창조하다</target>
        </trans-unit>
        <trans-unit id="0429b9e83b66b59909c053bc5a0efcfb4118df17" translate="yes" xml:space="preserve">
          <source>decorator to register as many consumers and topics as you need to work with. Then, run the</source>
          <target state="translated">데코레이터를 사용하여 작업해야하는만큼 많은 소비자와 주제를 등록합니다. 그런 다음</target>
        </trans-unit>
        <trans-unit id="6db6d22f2341a724787c19661f9a03b8af917dee" translate="yes" xml:space="preserve">
          <source>django-logpipe</source>
          <target state="translated">장고 로그 파이프</target>
        </trans-unit>
        <trans-unit id="eb5ea3e550c8a238d1064ce1bd153ab0bb463cef" translate="yes" xml:space="preserve">
          <source>exception is raised.</source>
          <target state="translated">예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="8180f2a38646a5bd778ded7f5d80b0b2cc557fdc" translate="yes" xml:space="preserve">
          <source>file. If you&amp;rsquo;re using Kafka, this will look like this:</source>
          <target state="translated">파일. Kafka를 사용하는 경우 다음과 같이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="e0146d3c2aaac8ec8c30d770f1f5ae31a3830b61" translate="yes" xml:space="preserve">
          <source>from pip.</source>
          <target state="translated">핍에서.</target>
        </trans-unit>
        <trans-unit id="2eb0d5936952bd20410363efc11f7ffc58192e78" translate="yes" xml:space="preserve">
          <source>have a few rules:</source>
          <target state="translated">몇 가지 규칙이 있습니다.</target>
        </trans-unit>
        <trans-unit id="c3bec6bcbc9b9f04e60fcb1d9c9c1a37f3e12e93" translate="yes" xml:space="preserve">
          <source>instance</source>
          <target state="translated">예</target>
        </trans-unit>
        <trans-unit id="971ec26da6739c0841ca2036050b557b38608197" translate="yes" xml:space="preserve">
          <source>is to define a serializer. Serializers for</source>
          <target state="translated">serializer를 정의하는 것입니다. 직렬 변환기</target>
        </trans-unit>
        <trans-unit id="ec62eb1162567055d7591d12606567ebabf9d45a" translate="yes" xml:space="preserve">
          <source>logpipe</source>
          <target state="translated">통나무</target>
        </trans-unit>
        <trans-unit id="68ab13c1ee3eb80843c62c83ad85e5427f1354b1" translate="yes" xml:space="preserve">
          <source>logpipe.Consumer.add_ignored_message_type</source>
          <target state="translated">logpipe.Consumer.add_ignored_message_type</target>
        </trans-unit>
        <trans-unit id="866bf7a68fd126768389e054ca0333d99f633dd6" translate="yes" xml:space="preserve">
          <source>logpipe.exceptions.UnknownMessageVersionError</source>
          <target state="translated">logpipe.exceptions.UnknownMessageVersionError</target>
        </trans-unit>
        <trans-unit id="487a129194d8bab3388b17cedad6ac2309617628" translate="yes" xml:space="preserve">
          <source>lookup_instance</source>
          <target state="translated">lookup_instance</target>
        </trans-unit>
        <trans-unit id="8f30ae503298b1630ae61f30da1f4f96ec59e5b9" translate="yes" xml:space="preserve">
          <source>lookup_instance(cls, **kwargs)</source>
          <target state="translated">lookup_instance (cls, ** kwargs)</target>
        </trans-unit>
        <trans-unit id="b162fbb03dc1aa300376a56456a17652d116706b" translate="yes" xml:space="preserve">
          <source>management command.</source>
          <target state="translated">관리 명령.</target>
        </trans-unit>
        <trans-unit id="25b2a8e1649db9eb78d5a6f63c054db6cf1d25f6" translate="yes" xml:space="preserve">
          <source>method to house your custom import logic.</source>
          <target state="translated">사용자 정의 가져 오기 로직을 ​​수용하는 방법.</target>
        </trans-unit>
        <trans-unit id="946465000bd9e24c032001a54783f3574c94142e" translate="yes" xml:space="preserve">
          <source>method.</source>
          <target state="translated">방법.</target>
        </trans-unit>
        <trans-unit id="f01c78cad73d84091232241f809db9ba41c59d1a" translate="yes" xml:space="preserve">
          <source>methods to apply the message. If your messages aren&amp;rsquo;t tied directly to a Django model, skip defining the</source>
          <target state="translated">메시지를 적용하는 방법. 메시지가 Django 모델에 직접 연결되지 않은 경우</target>
        </trans-unit>
        <trans-unit id="82d0b640d3bbd4f8ec32ced98b5ac12fe7458b06" translate="yes" xml:space="preserve">
          <source>model we defined above, the first step would be to update consumers to know about the new field.:</source>
          <target state="translated">위에서 정의한 모델에서 첫 번째 단계는 새 필드에 대해 알 수 있도록 소비자를 업데이트하는 것입니다. :</target>
        </trans-unit>
        <trans-unit id="cb018a0b6b8b13ea37b90c6cce35b1f9415e9d9a" translate="yes" xml:space="preserve">
          <source>or a class implementing an interface that mimics</source>
          <target state="translated">또는 모방하는 인터페이스를 구현하는 클래스</target>
        </trans-unit>
        <trans-unit id="ab3ccc8dba2a0cf7a1ce4d830bb8a6238ff03833" translate="yes" xml:space="preserve">
          <source>people</source>
          <target state="translated">사람들</target>
        </trans-unit>
        <trans-unit id="7d77ba9fe9d607843ffbaf91b5d5b4a99d0addc6" translate="yes" xml:space="preserve">
          <source>register_consumer</source>
          <target state="translated">register_consumer</target>
        </trans-unit>
        <trans-unit id="ee3ff40d65945658f82886ab211a89acda8f669d" translate="yes" xml:space="preserve">
          <source>rest_framework.serializers.Serializer</source>
          <target state="translated">rest_framework.serializers.Serializer</target>
        </trans-unit>
        <trans-unit id="424e9779dcf2f71f85ca2c05122581ed8e4069bb" translate="yes" xml:space="preserve">
          <source>run_kafka_consumer</source>
          <target state="translated">run_kafka_consumer</target>
        </trans-unit>
        <trans-unit id="13a4a11319d31c1b323d5774f44240a9ffc984d0" translate="yes" xml:space="preserve">
          <source>save</source>
          <target state="translated">저장</target>
        </trans-unit>
        <trans-unit id="0a29d9a6c7b1489e391f3b143cd4fbfabd7fadde" translate="yes" xml:space="preserve">
          <source>save()</source>
          <target state="translated">저장()</target>
        </trans-unit>
        <trans-unit id="37ed539c0cef13959abd980bebf30f4922f606e3" translate="yes" xml:space="preserve">
          <source>send</source>
          <target state="translated">보내다</target>
        </trans-unit>
        <trans-unit id="888c15d72e41c9f0f1882f4aea4c2d19f1a044eb" translate="yes" xml:space="preserve">
          <source>settings.py</source>
          <target state="translated">settings.py</target>
        </trans-unit>
        <trans-unit id="4efef4bb8b9ed78a7dd6d74fa9828da5c0783a1e" translate="yes" xml:space="preserve">
          <source>to your installed apps.</source>
          <target state="translated">설치된 앱에.</target>
        </trans-unit>
        <trans-unit id="0a25ba5991316bdda4a9b3abcee2106016df28a0" translate="yes" xml:space="preserve">
          <source>update</source>
          <target state="translated">최신 정보</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
