<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://pypi.org/project/miniaudio/">
    <body>
      <group id="miniaudio">
        <trans-unit id="222f0192b17749c93311d6c62eceae89b44342a2" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Requires Python 3.5 or newer.  Also works on pypy3 (because it uses cffi).&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Python 3.5 이상이 필요합니다. pypy3에서도 작동합니다 (cffi를 사용하기 때문에).&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="ebd14829f102ab6aa17a02620106962a55992006" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;class&lt;/em&gt;&lt;code&gt;CaptureDevice&lt;/code&gt;</source>
          <target state="translated">&lt;em&gt;&lt;/em&gt; &lt;code&gt;CaptureDevice&lt;/code&gt; &lt;em&gt;클래스&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6a1d24ff6561ad5024941406d5e23a3435fe3451" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;class&lt;/em&gt;&lt;code&gt;DecodeError&lt;/code&gt;</source>
          <target state="translated">&lt;em&gt;&lt;/em&gt; &lt;code&gt;DecodeError&lt;/code&gt; &lt;em&gt;클래스&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="493d2da0409561a8f842db049375e58399cbbc31" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;class&lt;/em&gt;&lt;code&gt;DecodedSoundFile&lt;/code&gt;</source>
          <target state="translated">&lt;em&gt;&lt;/em&gt; &lt;code&gt;DecodedSoundFile&lt;/code&gt; &lt;em&gt;클래스&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5f11bba5facbf44a5ac925cc2120da2c1bacd12b" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;class&lt;/em&gt;&lt;code&gt;Devices&lt;/code&gt;</source>
          <target state="translated">&lt;em&gt;클래스 &lt;/em&gt; &lt;code&gt;Devices&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ea5ba40d351330a11976ca2fd1c98f1d52fad96c" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;class&lt;/em&gt;&lt;code&gt;DuplexStream&lt;/code&gt;</source>
          <target state="translated">&lt;em&gt;&lt;/em&gt; &lt;code&gt;DuplexStream&lt;/code&gt; &lt;em&gt;클래스&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6fdc803f26299b761c09982d5b85e1a14cb1e707" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;class&lt;/em&gt;&lt;code&gt;MiniaudioError&lt;/code&gt;</source>
          <target state="translated">&lt;em&gt;&lt;/em&gt; &lt;code&gt;MiniaudioError&lt;/code&gt; &lt;em&gt;클래스&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="58d46f6f1e6ce71921a29afc632f2dbef686e5e9" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;class&lt;/em&gt;&lt;code&gt;PlaybackDevice&lt;/code&gt;</source>
          <target state="translated">&lt;em&gt;&lt;/em&gt; &lt;code&gt;PlaybackDevice&lt;/code&gt; &lt;em&gt;클래스&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e920936a1f954f4b86afd00191d011f770fcd9de" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;class&lt;/em&gt;&lt;code&gt;SoundFileInfo&lt;/code&gt;</source>
          <target state="translated">&lt;em&gt;&lt;/em&gt; &lt;code&gt;SoundFileInfo&lt;/code&gt; &lt;em&gt;클래스&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="7d8f721e9c4ea33d87bbce20be24b1cb328055a4" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;class&lt;/em&gt;&lt;code&gt;StreamableSource&lt;/code&gt;</source>
          <target state="translated">&lt;em&gt;&lt;/em&gt; &lt;code&gt;StreamableSource&lt;/code&gt; &lt;em&gt;클래스&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b0a6170982da1af0f5c114fd46a50f0056a99af2" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;class&lt;/em&gt;&lt;code&gt;WavFileReadStream&lt;/code&gt;</source>
          <target state="translated">&lt;em&gt;클래스 &lt;/em&gt; &lt;code&gt;WavFileReadStream&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ff8267bae1feb5cac35868bc0e866e8d16edba2e" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;enum class&lt;/em&gt;&lt;code&gt;Backend&lt;/code&gt;
names:  &lt;code&gt;WASAPI&lt;/code&gt;&lt;code&gt;DSOUND&lt;/code&gt;&lt;code&gt;WINMM&lt;/code&gt;&lt;code&gt;COREAUDIO&lt;/code&gt;&lt;code&gt;SNDIO&lt;/code&gt;&lt;code&gt;AUDIO4&lt;/code&gt;&lt;code&gt;OSS&lt;/code&gt;&lt;code&gt;PULSEAUDIO&lt;/code&gt;&lt;code&gt;ALSA&lt;/code&gt;&lt;code&gt;JACK&lt;/code&gt;&lt;code&gt;AAUDIO&lt;/code&gt;&lt;code&gt;OPENSL&lt;/code&gt;&lt;code&gt;WEBAUDIO&lt;/code&gt;&lt;code&gt;NULL&lt;/code&gt;</source>
          <target state="translated">&lt;em&gt;enum 클래스 &lt;/em&gt; &lt;code&gt;Backend&lt;/code&gt; 이름 : &lt;code&gt;WASAPI&lt;/code&gt; &lt;code&gt;DSOUND&lt;/code&gt; &lt;code&gt;WINMM&lt;/code&gt; &lt;code&gt;COREAUDIO&lt;/code&gt; &lt;code&gt;SNDIO&lt;/code&gt; &lt;code&gt;AUDIO4&lt;/code&gt; &lt;code&gt;OSS&lt;/code&gt; &lt;code&gt;PULSEAUDIO&lt;/code&gt; &lt;code&gt;ALSA&lt;/code&gt; &lt;code&gt;JACK&lt;/code&gt; &lt;code&gt;AAUDIO&lt;/code&gt; &lt;code&gt;OPENSL&lt;/code&gt; &lt;code&gt;WEBAUDIO&lt;/code&gt; &lt;code&gt;NULL&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="04eee8d2954c507a3d5f4f7c78026560acd66762" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;enum class&lt;/em&gt;&lt;code&gt;ChannelMixMode&lt;/code&gt;
names:  &lt;code&gt;RECTANGULAR&lt;/code&gt;&lt;code&gt;SIMPLE&lt;/code&gt;&lt;code&gt;CUSTOMWEIGHTS&lt;/code&gt;</source>
          <target state="translated">&lt;em&gt;enum 클래스 &lt;/em&gt; &lt;code&gt;ChannelMixMode&lt;/code&gt; 이름 : &lt;code&gt;RECTANGULAR&lt;/code&gt; &lt;code&gt;SIMPLE&lt;/code&gt; &lt;code&gt;CUSTOMWEIGHTS&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cf8e734fcefbf15a109424769faf04d8b7932a75" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;enum class&lt;/em&gt;&lt;code&gt;DeviceType&lt;/code&gt;
names:  &lt;code&gt;PLAYBACK&lt;/code&gt;&lt;code&gt;CAPTURE&lt;/code&gt;&lt;code&gt;DUPLEX&lt;/code&gt;</source>
          <target state="translated">&lt;em&gt;enum 클래스 &lt;/em&gt; &lt;code&gt;DeviceType&lt;/code&gt; 이름 : &lt;code&gt;PLAYBACK&lt;/code&gt; &lt;code&gt;CAPTURE&lt;/code&gt; &lt;code&gt;DUPLEX&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="bc484e13fb0d779d6baa6974b86e7351026797a2" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;enum class&lt;/em&gt;&lt;code&gt;DitherMode&lt;/code&gt;
names:  &lt;code&gt;NONE&lt;/code&gt;&lt;code&gt;RECTANGLE&lt;/code&gt;&lt;code&gt;TRIANGLE&lt;/code&gt;</source>
          <target state="translated">&lt;em&gt;열거 형 클래스 &lt;/em&gt; &lt;code&gt;DitherMode&lt;/code&gt; 이름 : &lt;code&gt;NONE&lt;/code&gt; &lt;code&gt;RECTANGLE&lt;/code&gt; &lt;code&gt;TRIANGLE&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fd9ba8c49c2a18cc85cd69201fd2e39509adb992" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;enum class&lt;/em&gt;&lt;code&gt;FileFormat&lt;/code&gt;
names:  &lt;code&gt;UNKNOWN&lt;/code&gt;&lt;code&gt;WAV&lt;/code&gt;&lt;code&gt;FLAC&lt;/code&gt;&lt;code&gt;VORBIS&lt;/code&gt;&lt;code&gt;MP3&lt;/code&gt;</source>
          <target state="translated">&lt;em&gt;enum 클래스 &lt;/em&gt; &lt;code&gt;FileFormat&lt;/code&gt; 이름 : &lt;code&gt;UNKNOWN&lt;/code&gt; &lt;code&gt;WAV&lt;/code&gt; &lt;code&gt;FLAC&lt;/code&gt; &lt;code&gt;VORBIS&lt;/code&gt; &lt;code&gt;MP3&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f2640c17b627d53a39079afb79f0d52f20c9ec6d" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;enum class&lt;/em&gt;&lt;code&gt;SampleFormat&lt;/code&gt;
names:  &lt;code&gt;UNKNOWN&lt;/code&gt;&lt;code&gt;UNSIGNED8&lt;/code&gt;&lt;code&gt;SIGNED16&lt;/code&gt;&lt;code&gt;SIGNED24&lt;/code&gt;&lt;code&gt;SIGNED32&lt;/code&gt;&lt;code&gt;FLOAT32&lt;/code&gt;</source>
          <target state="translated">&lt;em&gt;enum 클래스 &lt;/em&gt; &lt;code&gt;SampleFormat&lt;/code&gt; 이름 : &lt;code&gt;UNKNOWN&lt;/code&gt; &lt;code&gt;UNSIGNED8&lt;/code&gt; &lt;code&gt;SIGNED16&lt;/code&gt; &lt;code&gt;SIGNED24&lt;/code&gt; &lt;code&gt;SIGNED32&lt;/code&gt; &lt;code&gt;FLOAT32&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fe6df29335c1ca5577ecf2da261587678adcf50d" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;enum class&lt;/em&gt;&lt;code&gt;SeekOrigin&lt;/code&gt;
names:  &lt;code&gt;START&lt;/code&gt;&lt;code&gt;CURRENT&lt;/code&gt;</source>
          <target state="translated">&lt;em&gt;enum 클래스 &lt;/em&gt; &lt;code&gt;SeekOrigin&lt;/code&gt; 이름 : &lt;code&gt;START&lt;/code&gt; &lt;code&gt;CURRENT&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fd2732775876be844985474c957bbb62758bbb0e" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;enum class&lt;/em&gt;&lt;code&gt;ThreadPriority&lt;/code&gt;
names:  &lt;code&gt;IDLE&lt;/code&gt;&lt;code&gt;LOWEST&lt;/code&gt;&lt;code&gt;LOW&lt;/code&gt;&lt;code&gt;NORMAL&lt;/code&gt;&lt;code&gt;HIGH&lt;/code&gt;&lt;code&gt;HIGHEST&lt;/code&gt;&lt;code&gt;REALTIME&lt;/code&gt;</source>
          <target state="translated">&lt;em&gt;열거 형 클래스 &lt;/em&gt; &lt;code&gt;ThreadPriority&lt;/code&gt; 이름 : &lt;code&gt;IDLE&lt;/code&gt; &lt;code&gt;LOWEST&lt;/code&gt; &lt;code&gt;LOW&lt;/code&gt; &lt;code&gt;NORMAL&lt;/code&gt; &lt;code&gt;HIGH&lt;/code&gt; &lt;code&gt;HIGHEST&lt;/code&gt; &lt;code&gt;REALTIME&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9f3461a3c2e31478d5ab381ae7b2bedc1c9b2eff" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;function&lt;/em&gt;&lt;code&gt;convert_frames (from_fmt: miniaudio.SampleFormat, from_numchannels: int, from_samplerate: int, sourcedata: bytes, to_fmt: miniaudio.SampleFormat, to_numchannels: int, to_samplerate: int) -&amp;gt; bytearray&lt;/code&gt;</source>
          <target state="translated">&lt;em&gt;function &lt;/em&gt; &lt;code&gt;convert_frames (from_fmt: miniaudio.SampleFormat, from_numchannels: int, from_samplerate: int, sourcedata: bytes, to_fmt: miniaudio.SampleFormat, to_numchannels: int, to_samplerate: int) -&amp;gt; bytearray&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c6ca0d8942bed2885e6a50534170313b7024bd51" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;function&lt;/em&gt;&lt;code&gt;convert_sample_format (from_fmt: miniaudio.SampleFormat, sourcedata: bytes, to_fmt: miniaudio.SampleFormat, dither: miniaudio.DitherMode = &amp;lt;DitherMode.NONE: 0&amp;gt;) -&amp;gt; bytearray&lt;/code&gt;</source>
          <target state="translated">&lt;em&gt;function &lt;/em&gt; &lt;code&gt;convert_sample_format (from_fmt: miniaudio.SampleFormat, sourcedata: bytes, to_fmt: miniaudio.SampleFormat, dither: miniaudio.DitherMode = &amp;lt;DitherMode.NONE: 0&amp;gt;) -&amp;gt; bytearray&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="625edaeaac51c5e8ab28dabfa11ad90cd4a78575" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;function&lt;/em&gt;&lt;code&gt;decode (data: bytes, output_format: miniaudio.SampleFormat = &amp;lt;SampleFormat.SIGNED16: 2&amp;gt;, nchannels: int = 2, sample_rate: int = 44100, dither: miniaudio.DitherMode = &amp;lt;DitherMode.NONE: 0&amp;gt;) -&amp;gt; miniaudio.DecodedSoundFile&lt;/code&gt;</source>
          <target state="translated">&lt;em&gt;function &lt;/em&gt; &lt;code&gt;decode (data: bytes, output_format: miniaudio.SampleFormat = &amp;lt;SampleFormat.SIGNED16: 2&amp;gt;, nchannels: int = 2, sample_rate: int = 44100, dither: miniaudio.DitherMode = &amp;lt;DitherMode.NONE: 0&amp;gt;) -&amp;gt; miniaudio.DecodedSoundFile&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="09f84fe3085974d3a87efdd245569f860a8af4c5" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;function&lt;/em&gt;&lt;code&gt;decode_file (filename: str, output_format: miniaudio.SampleFormat = &amp;lt;SampleFormat.SIGNED16: 2&amp;gt;, nchannels: int = 2, sample_rate: int = 44100, dither: miniaudio.DitherMode = &amp;lt;DitherMode.NONE: 0&amp;gt;) -&amp;gt; miniaudio.DecodedSoundFile&lt;/code&gt;</source>
          <target state="translated">&lt;em&gt;function &lt;/em&gt; &lt;code&gt;decode_file (filename: str, output_format: miniaudio.SampleFormat = &amp;lt;SampleFormat.SIGNED16: 2&amp;gt;, nchannels: int = 2, sample_rate: int = 44100, dither: miniaudio.DitherMode = &amp;lt;DitherMode.NONE: 0&amp;gt;) -&amp;gt; miniaudio.DecodedSoundFile&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="21aace310cc2b1626114af0c8c2b589734f30c8c" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;function&lt;/em&gt;&lt;code&gt;flac_get_file_info (filename: str) -&amp;gt; miniaudio.SoundFileInfo&lt;/code&gt;</source>
          <target state="translated">&lt;em&gt;&lt;/em&gt; &lt;code&gt;flac_get_file_info (filename: str) -&amp;gt; miniaudio.SoundFileInfo&lt;/code&gt; &lt;em&gt;함수 &lt;/em&gt;(파일 이름 : str)-&amp;gt; miniaudio.SoundFileInfo</target>
        </trans-unit>
        <trans-unit id="4002ab4c2bdfd04c06a597bd64f40911c48c5018" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;function&lt;/em&gt;&lt;code&gt;flac_get_info (data: bytes) -&amp;gt; miniaudio.SoundFileInfo&lt;/code&gt;</source>
          <target state="translated">&lt;em&gt;&lt;/em&gt; &lt;code&gt;flac_get_info (data: bytes) -&amp;gt; miniaudio.SoundFileInfo&lt;/code&gt; &lt;em&gt;함수 &lt;/em&gt;(데이터 : 바이트)-&amp;gt; miniaudio.SoundFileInfo</target>
        </trans-unit>
        <trans-unit id="15f0b23ff2407295407c57fd83cd6ad803abaf55" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;function&lt;/em&gt;&lt;code&gt;flac_read_f32 (data: bytes) -&amp;gt; miniaudio.DecodedSoundFile&lt;/code&gt;</source>
          <target state="translated">&lt;em&gt;&lt;/em&gt; &lt;code&gt;flac_read_f32 (data: bytes) -&amp;gt; miniaudio.DecodedSoundFile&lt;/code&gt; &lt;em&gt;함수 &lt;/em&gt;(데이터 : 바이트)-&amp;gt; miniaudio.DecodedSoundFile</target>
        </trans-unit>
        <trans-unit id="ccd0dea213d7f84c6c0d5fd596f0c9ec7fac0531" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;function&lt;/em&gt;&lt;code&gt;flac_read_file_f32 (filename: str) -&amp;gt; miniaudio.DecodedSoundFile&lt;/code&gt;</source>
          <target state="translated">&lt;em&gt;function &lt;/em&gt; &lt;code&gt;flac_read_file_f32 (filename: str) -&amp;gt; miniaudio.DecodedSoundFile&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="aa097a69a261882b066c894ed93e50ac2a2a0fa6" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;function&lt;/em&gt;&lt;code&gt;flac_read_file_s16 (filename: str) -&amp;gt; miniaudio.DecodedSoundFile&lt;/code&gt;</source>
          <target state="translated">&lt;em&gt;function &lt;/em&gt; &lt;code&gt;flac_read_file_s16 (filename: str) -&amp;gt; miniaudio.DecodedSoundFile&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cd72dbdc2ab14b547fad454ab3938aceb4c6bfc8" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;function&lt;/em&gt;&lt;code&gt;flac_read_file_s32 (filename: str) -&amp;gt; miniaudio.DecodedSoundFile&lt;/code&gt;</source>
          <target state="translated">&lt;em&gt;function &lt;/em&gt; &lt;code&gt;flac_read_file_s32 (filename: str) -&amp;gt; miniaudio.DecodedSoundFile&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="99c1a59f1077689a5993b7ebf400d00bb05d5531" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;function&lt;/em&gt;&lt;code&gt;flac_read_s16 (data: bytes) -&amp;gt; miniaudio.DecodedSoundFile&lt;/code&gt;</source>
          <target state="translated">&lt;em&gt;&lt;/em&gt; &lt;code&gt;flac_read_s16 (data: bytes) -&amp;gt; miniaudio.DecodedSoundFile&lt;/code&gt; &lt;em&gt;함수 &lt;/em&gt;(데이터 : 바이트)-&amp;gt; miniaudio.DecodedSoundFile</target>
        </trans-unit>
        <trans-unit id="43e231c7ad6c785b85045708dee3d767c70e52da" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;function&lt;/em&gt;&lt;code&gt;flac_read_s32 (data: bytes) -&amp;gt; miniaudio.DecodedSoundFile&lt;/code&gt;</source>
          <target state="translated">&lt;em&gt;&lt;/em&gt; &lt;code&gt;flac_read_s32 (data: bytes) -&amp;gt; miniaudio.DecodedSoundFile&lt;/code&gt; &lt;em&gt;함수 &lt;/em&gt;(데이터 : 바이트)-&amp;gt; miniaudio.DecodedSoundFile</target>
        </trans-unit>
        <trans-unit id="7f07e582b9c7cb4911ce9d73c6ec6691adaa9d3b" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;function&lt;/em&gt;&lt;code&gt;flac_stream_file (filename: str, frames_to_read: int = 1024, seek_frame: int = 0) -&amp;gt; Generator[array.array, NoneType, NoneType]&lt;/code&gt;</source>
          <target state="translated">&lt;em&gt;function &lt;/em&gt; &lt;code&gt;flac_stream_file (filename: str, frames_to_read: int = 1024, seek_frame: int = 0) -&amp;gt; Generator[array.array, NoneType, NoneType]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f055c696711ccc03e501d26e71c6cb406a9fa96f" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;function&lt;/em&gt;&lt;code&gt;get_file_info (filename: str) -&amp;gt; miniaudio.SoundFileInfo&lt;/code&gt;</source>
          <target state="translated">&lt;em&gt;&lt;/em&gt; &lt;code&gt;get_file_info (filename: str) -&amp;gt; miniaudio.SoundFileInfo&lt;/code&gt; &lt;em&gt;함수 &lt;/em&gt;(파일 이름 : str)-&amp;gt; miniaudio.SoundFileInfo</target>
        </trans-unit>
        <trans-unit id="cef6de0b94d4e6ed12a7206cd4ffca6f6cc2c4df" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;function&lt;/em&gt;&lt;code&gt;mp3_get_file_info (filename: str) -&amp;gt; miniaudio.SoundFileInfo&lt;/code&gt;</source>
          <target state="translated">&lt;em&gt;function &lt;/em&gt; &lt;code&gt;mp3_get_file_info (filename: str) -&amp;gt; miniaudio.SoundFileInfo&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="73fa64ae0399eb8357b6b84fe10a80e5061024c3" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;function&lt;/em&gt;&lt;code&gt;mp3_get_info (data: bytes) -&amp;gt; miniaudio.SoundFileInfo&lt;/code&gt;</source>
          <target state="translated">&lt;em&gt;function &lt;/em&gt; &lt;code&gt;mp3_get_info (data: bytes) -&amp;gt; miniaudio.SoundFileInfo&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="db48b57dca9143d6403a84e6a6819598a4cae0d6" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;function&lt;/em&gt;&lt;code&gt;mp3_read_f32 (data: bytes, want_nchannels: int = 0, want_sample_rate: int = 0) -&amp;gt; miniaudio.DecodedSoundFile&lt;/code&gt;</source>
          <target state="translated">&lt;em&gt;function &lt;/em&gt; &lt;code&gt;mp3_read_f32 (data: bytes, want_nchannels: int = 0, want_sample_rate: int = 0) -&amp;gt; miniaudio.DecodedSoundFile&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6d5b10ed15cc1ebc6b67ff20f74b7eb1fbb96186" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;function&lt;/em&gt;&lt;code&gt;mp3_read_file_f32 (filename: str, want_nchannels: int = 0, want_sample_rate: int = 0) -&amp;gt; miniaudio.DecodedSoundFile&lt;/code&gt;</source>
          <target state="translated">&lt;em&gt;function &lt;/em&gt; &lt;code&gt;mp3_read_file_f32 (filename: str, want_nchannels: int = 0, want_sample_rate: int = 0) -&amp;gt; miniaudio.DecodedSoundFile&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="631749c29dc8b243095a26dbed30124fb1b60a9a" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;function&lt;/em&gt;&lt;code&gt;mp3_read_file_s16 (filename: str, want_nchannels: int = 0, want_sample_rate: int = 0) -&amp;gt; miniaudio.DecodedSoundFile&lt;/code&gt;</source>
          <target state="translated">&lt;em&gt;function &lt;/em&gt; &lt;code&gt;mp3_read_file_s16 (filename: str, want_nchannels: int = 0, want_sample_rate: int = 0) -&amp;gt; miniaudio.DecodedSoundFile&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="60bc4894a2464344a4b83a0d8971250cd06011f4" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;function&lt;/em&gt;&lt;code&gt;mp3_read_s16 (data: bytes, want_nchannels: int = 0, want_sample_rate: int = 0) -&amp;gt; miniaudio.DecodedSoundFile&lt;/code&gt;</source>
          <target state="translated">&lt;em&gt;function &lt;/em&gt; &lt;code&gt;mp3_read_s16 (data: bytes, want_nchannels: int = 0, want_sample_rate: int = 0) -&amp;gt; miniaudio.DecodedSoundFile&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="83ce34d6c46e6770464bbc82d35d7c066f9dbd16" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;function&lt;/em&gt;&lt;code&gt;mp3_stream_file (filename: str, frames_to_read: int = 1024, seek_frame: int = 0) -&amp;gt; Generator[array.array, NoneType, NoneType]&lt;/code&gt;</source>
          <target state="translated">&lt;em&gt;function &lt;/em&gt; &lt;code&gt;mp3_stream_file (filename: str, frames_to_read: int = 1024, seek_frame: int = 0) -&amp;gt; Generator[array.array, NoneType, NoneType]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4b86667b17f09d8484885d44f94900d31e4884ba" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;function&lt;/em&gt;&lt;code&gt;read_file (filename: str, convert_to_16bit: bool = False) -&amp;gt; miniaudio.DecodedSoundFile&lt;/code&gt;</source>
          <target state="translated">&lt;em&gt;function &lt;/em&gt; &lt;code&gt;read_file (filename: str, convert_to_16bit: bool = False) -&amp;gt; miniaudio.DecodedSoundFile&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="bfd0157ea09e189b84f6365e98604fe05f9585b2" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;function&lt;/em&gt;&lt;code&gt;stream_any (source: miniaudio.StreamableSource, source_format: miniaudio.FileFormat = &amp;lt;FileFormat.UNKNOWN: 0&amp;gt;, output_format: miniaudio.SampleFormat = &amp;lt;SampleFormat.SIGNED16: 2&amp;gt;, nchannels: int = 2, sample_rate: int = 44100, frames_to_read: int = 1024, dither: miniaudio.DitherMode = &amp;lt;DitherMode.NONE: 0&amp;gt;, seek_frame: int = 0) -&amp;gt; Generator[array.array, int, NoneType]&lt;/code&gt;</source>
          <target state="translated">&lt;em&gt;function &lt;/em&gt; &lt;code&gt;stream_any (source: miniaudio.StreamableSource, source_format: miniaudio.FileFormat = &amp;lt;FileFormat.UNKNOWN: 0&amp;gt;, output_format: miniaudio.SampleFormat = &amp;lt;SampleFormat.SIGNED16: 2&amp;gt;, nchannels: int = 2, sample_rate: int = 44100, frames_to_read: int = 1024, dither: miniaudio.DitherMode = &amp;lt;DitherMode.NONE: 0&amp;gt;, seek_frame: int = 0) -&amp;gt; Generator[array.array, int, NoneType]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="97531e6ad9ff94052688e5c33dc637c270690903" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;function&lt;/em&gt;&lt;code&gt;stream_file (filename: str, output_format: miniaudio.SampleFormat = &amp;lt;SampleFormat.SIGNED16: 2&amp;gt;, nchannels: int = 2, sample_rate: int = 44100, frames_to_read: int = 1024, dither: miniaudio.DitherMode = &amp;lt;DitherMode.NONE: 0&amp;gt;, seek_frame: int = 0) -&amp;gt; Generator[array.array, int, NoneType]&lt;/code&gt;</source>
          <target state="translated">&lt;em&gt;function &lt;/em&gt; &lt;code&gt;stream_file (filename: str, output_format: miniaudio.SampleFormat = &amp;lt;SampleFormat.SIGNED16: 2&amp;gt;, nchannels: int = 2, sample_rate: int = 44100, frames_to_read: int = 1024, dither: miniaudio.DitherMode = &amp;lt;DitherMode.NONE: 0&amp;gt;, seek_frame: int = 0) -&amp;gt; Generator[array.array, int, NoneType]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="733c68b515e65df9d1c8e485bfd514c48bd045ea" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;function&lt;/em&gt;&lt;code&gt;stream_memory (data: bytes, output_format: miniaudio.SampleFormat = &amp;lt;SampleFormat.SIGNED16: 2&amp;gt;, nchannels: int = 2, sample_rate: int = 44100, frames_to_read: int = 1024, dither: miniaudio.DitherMode = &amp;lt;DitherMode.NONE: 0&amp;gt;) -&amp;gt; Generator[array.array, int, NoneType]&lt;/code&gt;</source>
          <target state="translated">&lt;em&gt;function &lt;/em&gt; &lt;code&gt;stream_memory (data: bytes, output_format: miniaudio.SampleFormat = &amp;lt;SampleFormat.SIGNED16: 2&amp;gt;, nchannels: int = 2, sample_rate: int = 44100, frames_to_read: int = 1024, dither: miniaudio.DitherMode = &amp;lt;DitherMode.NONE: 0&amp;gt;) -&amp;gt; Generator[array.array, int, NoneType]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="29f63b6c1c8585c68a28025fed57dcc0d6257082" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;function&lt;/em&gt;&lt;code&gt;vorbis_get_file_info (filename: str) -&amp;gt; miniaudio.SoundFileInfo&lt;/code&gt;</source>
          <target state="translated">&lt;em&gt;function &lt;/em&gt; &lt;code&gt;vorbis_get_file_info (filename: str) -&amp;gt; miniaudio.SoundFileInfo&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="64d5bfda26028c628eaccc410e6034d78066051c" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;function&lt;/em&gt;&lt;code&gt;vorbis_get_info (data: bytes) -&amp;gt; miniaudio.SoundFileInfo&lt;/code&gt;</source>
          <target state="translated">&lt;em&gt;함수 &lt;/em&gt; &lt;code&gt;vorbis_get_info (data: bytes) -&amp;gt; miniaudio.SoundFileInfo&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e75d447aeb667024cb6bb8e7c28639d22a87b88d" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;function&lt;/em&gt;&lt;code&gt;vorbis_read (data: bytes) -&amp;gt; miniaudio.DecodedSoundFile&lt;/code&gt;</source>
          <target state="translated">&lt;em&gt;function &lt;/em&gt; &lt;code&gt;vorbis_read (data: bytes) -&amp;gt; miniaudio.DecodedSoundFile&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3b0292788fa5d3f39114a804492c2715d94aeda4" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;function&lt;/em&gt;&lt;code&gt;vorbis_read_file (filename: str) -&amp;gt; miniaudio.DecodedSoundFile&lt;/code&gt;</source>
          <target state="translated">&lt;em&gt;function &lt;/em&gt; &lt;code&gt;vorbis_read_file (filename: str) -&amp;gt; miniaudio.DecodedSoundFile&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="aca49fbd14919f0f9060f58d91fcb5ad9d398ed6" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;function&lt;/em&gt;&lt;code&gt;vorbis_stream_file (filename: str, seek_frame: int = 0) -&amp;gt; Generator[array.array, NoneType, NoneType]&lt;/code&gt;</source>
          <target state="translated">&lt;em&gt;function &lt;/em&gt; &lt;code&gt;vorbis_stream_file (filename: str, seek_frame: int = 0) -&amp;gt; Generator[array.array, NoneType, NoneType]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fe529c8f6a10a9377668c32c0e5f92aa63a6783b" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;function&lt;/em&gt;&lt;code&gt;wav_get_file_info (filename: str) -&amp;gt; miniaudio.SoundFileInfo&lt;/code&gt;</source>
          <target state="translated">&lt;em&gt;함수 &lt;/em&gt; &lt;code&gt;wav_get_file_info (filename: str) -&amp;gt; miniaudio.SoundFileInfo&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8396d71f96e099a69da12ecbbda402433667d4a3" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;function&lt;/em&gt;&lt;code&gt;wav_get_info (data: bytes) -&amp;gt; miniaudio.SoundFileInfo&lt;/code&gt;</source>
          <target state="translated">&lt;em&gt;&lt;/em&gt; &lt;code&gt;wav_get_info (data: bytes) -&amp;gt; miniaudio.SoundFileInfo&lt;/code&gt; &lt;em&gt;함수 &lt;/em&gt;(데이터 : 바이트)-&amp;gt; miniaudio.SoundFileInfo</target>
        </trans-unit>
        <trans-unit id="f571956a5d8cf77b436dc839528ecead3ae28194" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;function&lt;/em&gt;&lt;code&gt;wav_read_f32 (data: bytes) -&amp;gt; miniaudio.DecodedSoundFile&lt;/code&gt;</source>
          <target state="translated">&lt;em&gt;함수 &lt;/em&gt; &lt;code&gt;wav_read_f32 (data: bytes) -&amp;gt; miniaudio.DecodedSoundFile&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ac5e5b76f2b07e8111552c2ff283843b7b9eadac" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;function&lt;/em&gt;&lt;code&gt;wav_read_file_f32 (filename: str) -&amp;gt; miniaudio.DecodedSoundFile&lt;/code&gt;</source>
          <target state="translated">&lt;em&gt;function &lt;/em&gt; &lt;code&gt;wav_read_file_f32 (filename: str) -&amp;gt; miniaudio.DecodedSoundFile&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b3d7234713237a56b96295fd7e29d38c35528f02" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;function&lt;/em&gt;&lt;code&gt;wav_read_file_s16 (filename: str) -&amp;gt; miniaudio.DecodedSoundFile&lt;/code&gt;</source>
          <target state="translated">&lt;em&gt;function &lt;/em&gt; &lt;code&gt;wav_read_file_s16 (filename: str) -&amp;gt; miniaudio.DecodedSoundFile&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2f6b13e003ac5493bd61f66d163458af5a5caf1d" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;function&lt;/em&gt;&lt;code&gt;wav_read_file_s32 (filename: str) -&amp;gt; miniaudio.DecodedSoundFile&lt;/code&gt;</source>
          <target state="translated">&lt;em&gt;함수 &lt;/em&gt; &lt;code&gt;wav_read_file_s32 (filename: str) -&amp;gt; miniaudio.DecodedSoundFile&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6c20865557f468a9175ca5224c9092b41e6cf1a2" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;function&lt;/em&gt;&lt;code&gt;wav_read_s16 (data: bytes) -&amp;gt; miniaudio.DecodedSoundFile&lt;/code&gt;</source>
          <target state="translated">&lt;em&gt;함수 &lt;/em&gt; &lt;code&gt;wav_read_s16 (data: bytes) -&amp;gt; miniaudio.DecodedSoundFile&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="803de3783a5c1478245a3b75fd074f8c2b3a3a3b" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;function&lt;/em&gt;&lt;code&gt;wav_read_s32 (data: bytes) -&amp;gt; miniaudio.DecodedSoundFile&lt;/code&gt;</source>
          <target state="translated">&lt;em&gt;함수 &lt;/em&gt; &lt;code&gt;wav_read_s32 (data: bytes) -&amp;gt; miniaudio.DecodedSoundFile&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="61eaa464cb06f56f36c9beec95742d3735523746" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;function&lt;/em&gt;&lt;code&gt;wav_stream_file (filename: str, frames_to_read: int = 1024, seek_frame: int = 0) -&amp;gt; Generator[array.array, NoneType, NoneType]&lt;/code&gt;</source>
          <target state="translated">&lt;em&gt;function &lt;/em&gt; &lt;code&gt;wav_stream_file (filename: str, frames_to_read: int = 1024, seek_frame: int = 0) -&amp;gt; Generator[array.array, NoneType, NoneType]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7b86564b074d01e1f3d967efc21e00340643bffe" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;function&lt;/em&gt;&lt;code&gt;wav_write_file (filename: str, sound: miniaudio.DecodedSoundFile)&lt;/code&gt;</source>
          <target state="translated">&lt;em&gt;&lt;/em&gt; &lt;code&gt;wav_write_file (filename: str, sound: miniaudio.DecodedSoundFile)&lt;/code&gt; &lt;em&gt;함수 &lt;/em&gt;(파일 이름 : str, 사운드 : miniaudio.DecodedSoundFile)</target>
        </trans-unit>
        <trans-unit id="a0ebedef07c23da59b8cb901f73ce3ae64aff91a" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;method&lt;/em&gt;&lt;code&gt;close (self)&lt;/code&gt;</source>
          <target state="translated">&lt;em&gt;메소드 &lt;/em&gt; &lt;code&gt;close (self)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9a8ed5f8825a3771f5ef950ceb4c7bf320f329aa" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;method&lt;/em&gt;&lt;code&gt;get_captures (self) -&amp;gt; List[Dict[str, Any]]&lt;/code&gt;</source>
          <target state="translated">&lt;em&gt;&lt;/em&gt; &lt;code&gt;get_captures (self) -&amp;gt; List[Dict[str, Any]]&lt;/code&gt; &lt;em&gt;메소드 &lt;/em&gt;-&amp;gt; List [Dict [str, Any]]</target>
        </trans-unit>
        <trans-unit id="852f6bbecd94418066b5f3159994e6165f0eb836" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;method&lt;/em&gt;&lt;code&gt;get_playbacks (self) -&amp;gt; List[Dict[str, Any]]&lt;/code&gt;</source>
          <target state="translated">&lt;em&gt;&lt;/em&gt; &lt;code&gt;get_playbacks (self) -&amp;gt; List[Dict[str, Any]]&lt;/code&gt; &lt;em&gt;메소드 &lt;/em&gt;-&amp;gt; List [Dict [str, Any]]</target>
        </trans-unit>
        <trans-unit id="019b8833d05c2ee7c09db536ef44ad4fe9ce8f6b" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;method&lt;/em&gt;&lt;code&gt;read (self, amount: int = 9223372036854775807) -&amp;gt; Union[bytes, NoneType]&lt;/code&gt;</source>
          <target state="translated">&lt;em&gt;&lt;/em&gt; &lt;code&gt;read (self, amount: int = 9223372036854775807) -&amp;gt; Union[bytes, NoneType]&lt;/code&gt; &lt;em&gt;메소드 &lt;/em&gt;(self, amount : int = 9223372036854775807)-&amp;gt; Union [bytes, NoneType]</target>
        </trans-unit>
        <trans-unit id="78a2cf50ae902687518c9d20aeb232562439eee4" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;method&lt;/em&gt;&lt;code&gt;start (self, callback_generator: Generator[NoneType, Union[bytes, array.array], NoneType], stop_callback: Union[Callable, NoneType] = None)&lt;/code&gt;</source>
          <target state="translated">&lt;em&gt;메서드 &lt;/em&gt; &lt;code&gt;start (self, callback_generator: Generator[NoneType, Union[bytes, array.array], NoneType], stop_callback: Union[Callable, NoneType] = None)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5e4d2a5e5d473afc2e4b3fcb747ff92a1f384016" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;method&lt;/em&gt;&lt;code&gt;start (self, callback_generator: Generator[Union[bytes, array.array], Union[bytes, array.array], NoneType], stop_callback: Union[Callable, NoneType] = None)&lt;/code&gt;</source>
          <target state="translated">&lt;em&gt;메서드 &lt;/em&gt; &lt;code&gt;start (self, callback_generator: Generator[Union[bytes, array.array], Union[bytes, array.array], NoneType], stop_callback: Union[Callable, NoneType] = None)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6c45d195bc05c066bd21319de222d7409968da5b" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;method&lt;/em&gt;&lt;code&gt;start (self, callback_generator: Generator[Union[bytes, array.array], int, NoneType], stop_callback: Union[Callable, NoneType] = None)&lt;/code&gt;</source>
          <target state="translated">&lt;em&gt;메서드 &lt;/em&gt; &lt;code&gt;start (self, callback_generator: Generator[Union[bytes, array.array], int, NoneType], stop_callback: Union[Callable, NoneType] = None)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4c5020f513dae79556714e04c0f2fd6b469aae02" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;method&lt;/em&gt;&lt;code&gt;stop (self)&lt;/code&gt;</source>
          <target state="translated">&lt;em&gt;메소드 &lt;/em&gt; &lt;code&gt;stop (self)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d93d10ff0fbef1b4aa0ddc24e10e907746d3c85a" translate="yes" xml:space="preserve">
          <source>API</source>
          <target state="translated">API</target>
        </trans-unit>
        <trans-unit id="e35f42f2c9c83d3d01b06737755f163bc64ebd1f" translate="yes" xml:space="preserve">
          <source>An IO stream that reads as a .wav file, and which gets its pcm samples from the provided producer</source>
          <target state="translated">.wav 파일로 읽고 제공된 생산자로부터 pcm 샘플을 가져 오는 IO 스트림</target>
        </trans-unit>
        <trans-unit id="a96b55bc42b80ac3452926b3b4d2db0c84b42041" translate="yes" xml:space="preserve">
          <source>An audio device provided by miniaudio, for audio capture (recording).</source>
          <target state="translated">오디오 캡처 (녹음)를 위해 미니 오디오에서 제공하는 오디오 장치입니다.</target>
        </trans-unit>
        <trans-unit id="2187381720d919c285f1dc7bb60bb7242fa2271c" translate="yes" xml:space="preserve">
          <source>An audio device provided by miniaudio, for audio playback.</source>
          <target state="translated">오디오 재생을 위해 미니 오디오에서 제공하는 오디오 장치입니다.</target>
        </trans-unit>
        <trans-unit id="67617ae27f24012fc8940a4e70e106a4defc201e" translate="yes" xml:space="preserve">
          <source>Audio file format</source>
          <target state="translated">오디오 파일 형식</target>
        </trans-unit>
        <trans-unit id="67eb0fbdc9915503739957021fa93d965901ce11" translate="yes" xml:space="preserve">
          <source>Close the file</source>
          <target state="translated">파일 닫기</target>
        </trans-unit>
        <trans-unit id="5bb74c6cc926d528b1efe36584e07de893096e3b" translate="yes" xml:space="preserve">
          <source>Contains various properties and also the PCM frames of a fully decoded audio file.</source>
          <target state="translated">다양한 속성과 완전히 디코딩 된 오디오 파일의 PCM 프레임을 포함합니다.</target>
        </trans-unit>
        <trans-unit id="a725cb27e369ad13a336233973ad20749b54416c" translate="yes" xml:space="preserve">
          <source>Contains various properties of an audio file.</source>
          <target state="translated">오디오 파일의 다양한 속성을 포함합니다.</target>
        </trans-unit>
        <trans-unit id="ec68525aa97273376b12d9585f323e9a83e16f9a" translate="yes" xml:space="preserve">
          <source>Convenience function that returns a generator to decode and stream any source of encoded audio
data (such as a network stream). Stream result is chunks of raw PCM samples in the chosen format. If
you send() a number into the generator rather than just using next() on it, you'll get that given
number of frames, instead of the default configured amount. This is particularly useful to plug this
stream into an audio device callback that wants a variable number of frames per call.</source>
          <target state="translated">인코딩 된 오디오 데이터 (예 : 네트워크 스트림)의 모든 소스를 디코딩하고 스트리밍하기 위해 생성기를 반환하는 편의 함수입니다. 스트림 결과는 선택한 형식의 원시 PCM 샘플 청크입니다. next ()를 사용하지 않고 생성기에 숫자를 send ()하면 기본 구성된 양 대신 주어진 프레임 수를 얻을 수 있습니다. 이것은 호출 당 가변 프레임 수를 원하는 오디오 장치 콜백에이 스트림을 연결하는 데 특히 유용합니다.</target>
        </trans-unit>
        <trans-unit id="4170ec7ebe1621e2da337b4e90124fb014ca842c" translate="yes" xml:space="preserve">
          <source>Convenience function to decode any supported audio file in memory to raw PCM samples in your
chosen format.</source>
          <target state="translated">메모리에서 지원되는 모든 오디오 파일을 선택한 형식의 원시 PCM 샘플로 디코딩하는 편의 기능.</target>
        </trans-unit>
        <trans-unit id="cdc19fa5c41ec99df63990549d952353592715dd" translate="yes" xml:space="preserve">
          <source>Convenience function to decode any supported audio file to raw PCM samples in your chosen format.</source>
          <target state="translated">지원되는 오디오 파일을 선택한 형식의 원시 PCM 샘플로 디코딩하는 편의 기능.</target>
        </trans-unit>
        <trans-unit id="dbf8faf6a83cd855867e2857a83ee9d10cd267e9" translate="yes" xml:space="preserve">
          <source>Convenience generator function to decode and stream any supported audio file as chunks of raw PCM
samples in the chosen format. If you send() a number into the generator rather than just using
next() on it, you'll get that given number of frames, instead of the default configured amount. This
is particularly useful to plug this stream into an audio device callback that wants a variable
number of frames per call.</source>
          <target state="translated">지원되는 오디오 파일을 선택한 형식의 원시 PCM 샘플 청크로 디코딩하고 스트리밍하는 편의 생성 기능. next ()를 사용하지 않고 생성기에 숫자를 send ()하면 기본 구성된 양 대신 주어진 프레임 수를 얻을 수 있습니다. 이것은 호출 당 가변 프레임 수를 원하는 오디오 장치 콜백에이 스트림을 연결하는 데 특히 유용합니다.</target>
        </trans-unit>
        <trans-unit id="d2a5c7010c1b47ff6fd2e31d527bba28bf276d85" translate="yes" xml:space="preserve">
          <source>Convenience generator function to decode and stream any supported audio file in memory as chunks
of raw PCM samples in the chosen format. If you send() a number into the generator rather than just
using next() on it, you'll get that given number of frames, instead of the default configured
amount. This is particularly useful to plug this stream into an audio device callback that wants a
variable number of frames per call.</source>
          <target state="translated">메모리에서 지원되는 모든 오디오 파일을 선택한 형식의 원시 PCM 샘플 청크로 디코딩하고 스트리밍하는 편의 생성 기능. next ()를 사용하지 않고 생성기에 숫자를 send ()하면 기본 구성된 양 대신 주어진 프레임 수를 얻을 수 있습니다. 이것은 호출 당 가변 프레임 수를 원하는 오디오 장치 콜백에이 스트림을 연결하는 데 특히 유용합니다.</target>
        </trans-unit>
        <trans-unit id="e75b2dbffa0dcb5c724ebefda161eb865eb07f0c" translate="yes" xml:space="preserve">
          <source>Convert a raw buffer of pcm samples to another sample format. The result is returned as another
raw pcm sample buffer</source>
          <target state="translated">pcm 샘플의 원시 버퍼를 다른 샘플 형식으로 변환합니다. 결과는 다른 원시 pcm 샘플 버퍼로 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="2f648078bc3ca1dd7c22b960668a496fbac2bac8" translate="yes" xml:space="preserve">
          <source>Convert audio frames in source sample format with a certain number of channels, to another sample
format and possibly down/upmixing the number of channels as well.</source>
          <target state="translated">특정 수의 채널이있는 소스 샘플 형식의 오디오 프레임을 다른 샘플 형식으로 변환하고 채널 수를 다운 / 업 믹스 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="eb01bf04c9a0e8a71c45816513df424f1c7ffedb" translate="yes" xml:space="preserve">
          <source>Examples</source>
          <target state="translated">예</target>
        </trans-unit>
        <trans-unit id="495d3d11b082af613295e96fc2e7ac624f5ad01b" translate="yes" xml:space="preserve">
          <source>Fetch some information about the audio data (flac format).</source>
          <target state="translated">오디오 데이터 (flac 형식)에 대한 정보를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="294ed8d86f860651e60548bc652abe9b84dfc600" translate="yes" xml:space="preserve">
          <source>Fetch some information about the audio data (mp3 format).</source>
          <target state="translated">오디오 데이터 (mp3 형식)에 대한 정보를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="ced6b4c85e690d92baec62d4dfe514019f3a2a20" translate="yes" xml:space="preserve">
          <source>Fetch some information about the audio data (vorbis format).</source>
          <target state="translated">오디오 데이터 (vorbis 형식)에 대한 정보를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="0d89f8d3547aa53539b31847b65157793405af1b" translate="yes" xml:space="preserve">
          <source>Fetch some information about the audio data (wav format).</source>
          <target state="translated">오디오 데이터 (wav 형식)에 대한 정보를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="3d356649a7d770a2b0f1a0fadae14ab9ddd521a1" translate="yes" xml:space="preserve">
          <source>Fetch some information about the audio file (flac format).</source>
          <target state="translated">오디오 파일 (flac 형식)에 대한 정보를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="a8514d85a4dd55de27a3219cb278d8fb131f6bef" translate="yes" xml:space="preserve">
          <source>Fetch some information about the audio file (mp3 format).</source>
          <target state="translated">오디오 파일 (mp3 형식)에 대한 정보를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="389f188fcbfd725afd09c03372139258c03c7a24" translate="yes" xml:space="preserve">
          <source>Fetch some information about the audio file (vorbis format).</source>
          <target state="translated">오디오 파일 (vorbis 형식)에 대한 정보를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="2e4202eb9f6e6dcd4cac937c7efcafd684b6457f" translate="yes" xml:space="preserve">
          <source>Fetch some information about the audio file (wav format).</source>
          <target state="translated">오디오 파일 (wav 형식)에 대한 정보를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="186ed9dbd2bf579a770468333d387f501ffb7752" translate="yes" xml:space="preserve">
          <source>Fetch some information about the audio file.</source>
          <target state="translated">오디오 파일에 대한 정보를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="5a4f2e24777a7903f8fe536251fe32846c1b5bfd" translate="yes" xml:space="preserve">
          <source>Get a list of capture devices and some details about them</source>
          <target state="translated">캡처 장치 목록과 이에 대한 세부 정보 가져 오기</target>
        </trans-unit>
        <trans-unit id="b8b1446c96fd3f5b208188010ebf095a045ce634" translate="yes" xml:space="preserve">
          <source>Get a list of playback devices and some details about them</source>
          <target state="translated">재생 장치 목록 및 이에 대한 세부 정보 가져 오기</target>
        </trans-unit>
        <trans-unit id="99c5a58c64a0dcefab5c129eba4b7ca9bd605bf3" translate="yes" xml:space="preserve">
          <source>Halt playback or capture and close down the device. If you use the device as a context manager,
it will be closed automatically.</source>
          <target state="translated">재생을 중지하거나 장치를 캡처하고 닫습니다. 장치를 컨텍스트 관리자로 사용하면 자동으로 닫힙니다.</target>
        </trans-unit>
        <trans-unit id="c15d34de162397ab149517d1962594775571867a" translate="yes" xml:space="preserve">
          <source>Halt playback or capture.</source>
          <target state="translated">재생 또는 캡처를 중지합니다.</target>
        </trans-unit>
        <trans-unit id="0018035548eb18eed2a25b33d8f19122d0047472" translate="yes" xml:space="preserve">
          <source>How to dither when converting</source>
          <target state="translated">변환 할 때 디더링하는 방법</target>
        </trans-unit>
        <trans-unit id="a840cbed29fc932cc14b53d9d64e6d53f1b5fd33" translate="yes" xml:space="preserve">
          <source>How to mix channels when converting</source>
          <target state="translated">변환 할 때 채널을 혼합하는 방법</target>
        </trans-unit>
        <trans-unit id="347c8121bfdc03e7b053c35a87cd33a64e08bfe2" translate="yes" xml:space="preserve">
          <source>How to seek() in a source</source>
          <target state="translated">소스에서 seek ()하는 방법</target>
        </trans-unit>
        <trans-unit id="6e00d1353dec802fe52b88ea0cfeb01d6600ccf9" translate="yes" xml:space="preserve">
          <source>If you like this library you may also be interested in my &lt;a href=&quot;https://pypi.org/project/synthplayer/&quot;&gt;software FM synthesizer&lt;/a&gt;
or my &lt;a href=&quot;https://pypi.org/project/libxmplite/&quot;&gt;mod player&lt;/a&gt; which uses libxmp.</source>
          <target state="translated">이 라이브러리가 마음에 들면 내 &lt;a href=&quot;https://pypi.org/project/synthplayer/&quot;&gt;소프트웨어 FM 신디사이저&lt;/a&gt; 또는 libxmp를 사용하는 &lt;a href=&quot;https://pypi.org/project/libxmplite/&quot;&gt;모드 플레이어&lt;/a&gt; 에도 관심이있을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="457427a8f15172bc3cb2e0839b3d93b80ecf5ddd" translate="yes" xml:space="preserve">
          <source>Joins a capture device and a playback device.</source>
          <target state="translated">캡처 장치와 재생 장치를 연결합니다.</target>
        </trans-unit>
        <trans-unit id="ee1878d4f1670e6a0b9f9f82af61fc0b6b013731" translate="yes" xml:space="preserve">
          <source>Most basic audio file playback</source>
          <target state="translated">가장 기본적인 오디오 파일 재생</target>
        </trans-unit>
        <trans-unit id="dc66eb74996c944df63af7ed0de1c9b807a5d6a0" translate="yes" xml:space="preserve">
          <source>Multiplatform audio playback, recording, decoding and sample format conversion for
Linux (including Raspberri Pi), Windows, Mac and probably other systems such as BSD.</source>
          <target state="translated">Linux (Raspberri Pi 포함), Windows, Mac 및 BSD와 같은 기타 시스템을위한 다중 플랫폼 오디오 재생, 녹음, 디코딩 및 샘플 형식 변환.</target>
        </trans-unit>
        <trans-unit id="b5c91ee9d8b7bf1d7d84767669ce50d799d337d4" translate="yes" xml:space="preserve">
          <source>Operating system audio backend to use (only a subset will be available)</source>
          <target state="translated">사용할 운영 체제 오디오 백엔드 (하위 집합 만 사용할 수 있음)</target>
        </trans-unit>
        <trans-unit id="f27a9fbd653a357fc8bb8e6f4bdc410c7a2f9b61" translate="yes" xml:space="preserve">
          <source>Playback of an unsupported file format</source>
          <target state="translated">지원되지 않는 파일 형식 재생</target>
        </trans-unit>
        <trans-unit id="e591e0af6a6c6391d194bd6e12afc741ffe8406b" translate="yes" xml:space="preserve">
          <source>Python enums instead of just some integers for special values,</source>
          <target state="translated">특수 값에 대한 정수 대신 Python 열거 형,</target>
        </trans-unit>
        <trans-unit id="54793a59249c3156c861fd01e424e621b150a8dd" translate="yes" xml:space="preserve">
          <source>Python miniaudio</source>
          <target state="translated">파이썬 미니 오디오</target>
        </trans-unit>
        <trans-unit id="0d191d9847ed570b471433e142d65bb66f5e2971" translate="yes" xml:space="preserve">
          <source>Query the audio playback and record devices that miniaudio provides</source>
          <target state="translated">미니 오디오가 제공하는 오디오 재생 및 녹음 장치 쿼리</target>
        </trans-unit>
        <trans-unit id="61bab2e42a7af29d2dcce09211c38b610778bfde" translate="yes" xml:space="preserve">
          <source>Read up to the given amount of bytes from the file.</source>
          <target state="translated">파일에서 주어진 양의 바이트까지 읽습니다.</target>
        </trans-unit>
        <trans-unit id="fe56bdb333dbe0f5bddec13ce1b882cd52383449" translate="yes" xml:space="preserve">
          <source>Reads and decodes the whole audio file. Miniaudio will attempt to return the sound data in exactly
the same format as in the file. Unless you set convert_convert_to_16bit to True, then the result is
always a 16 bit sample format.</source>
          <target state="translated">전체 오디오 파일을 읽고 디코딩합니다. Miniaudio는 파일과 똑같은 형식으로 사운드 데이터를 반환하려고 시도합니다. convert_convert_to_16bit를 True로 설정하지 않는 한 결과는 항상 16 비트 샘플 형식입니다.</target>
        </trans-unit>
        <trans-unit id="0e8bdcaedb57dd617455d038c31776466941252d" translate="yes" xml:space="preserve">
          <source>Reads and decodes the whole flac audio data. Resulting sample format is 16 bits signed integer.</source>
          <target state="translated">전체 flac 오디오 데이터를 읽고 디코딩합니다. 결과 샘플 형식은 16 비트 부호있는 정수입니다.</target>
        </trans-unit>
        <trans-unit id="83e8a8e5a3ed56569d0f9be71baa6e082d7dfac5" translate="yes" xml:space="preserve">
          <source>Reads and decodes the whole flac audio data. Resulting sample format is 32 bits signed integer.</source>
          <target state="translated">전체 flac 오디오 데이터를 읽고 디코딩합니다. 결과 샘플 형식은 32 비트 부호있는 정수입니다.</target>
        </trans-unit>
        <trans-unit id="d0742dcd5ef6435f949f859ec7a58f8eaa689cb6" translate="yes" xml:space="preserve">
          <source>Reads and decodes the whole flac audio file. Resulting sample format is 16 bits signed integer.</source>
          <target state="translated">전체 flac 오디오 파일을 읽고 디코딩합니다. 결과 샘플 형식은 16 비트 부호있는 정수입니다.</target>
        </trans-unit>
        <trans-unit id="0888aba94a9ef51ae15ed2755cdb1df1991e3b15" translate="yes" xml:space="preserve">
          <source>Reads and decodes the whole flac audio file. Resulting sample format is 32 bits float.</source>
          <target state="translated">전체 flac 오디오 파일을 읽고 디코딩합니다. 결과 샘플 형식은 32 비트 부동 소수점입니다.</target>
        </trans-unit>
        <trans-unit id="d30f0ccd40b4fbb4d605c5b7d4a1a5609edd8cca" translate="yes" xml:space="preserve">
          <source>Reads and decodes the whole flac audio file. Resulting sample format is 32 bits signed integer.</source>
          <target state="translated">전체 flac 오디오 파일을 읽고 디코딩합니다. 결과 샘플 형식은 32 비트 부호있는 정수입니다.</target>
        </trans-unit>
        <trans-unit id="47063b2a70cb9b5a1a617f529035cd503b954756" translate="yes" xml:space="preserve">
          <source>Reads and decodes the whole mp3 audio data. Resulting sample format is 16 bits signed integer.</source>
          <target state="translated">전체 mp3 오디오 데이터를 읽고 디코딩합니다. 결과 샘플 형식은 16 비트 부호있는 정수입니다.</target>
        </trans-unit>
        <trans-unit id="e9b645c40de7581180539fda7f2e00a19594878d" translate="yes" xml:space="preserve">
          <source>Reads and decodes the whole mp3 audio data. Resulting sample format is 32 bits float.</source>
          <target state="translated">전체 mp3 오디오 데이터를 읽고 디코딩합니다. 결과 샘플 형식은 32 비트 부동 소수점입니다.</target>
        </trans-unit>
        <trans-unit id="b51b148ee75c39244a6d779136e490079f30261d" translate="yes" xml:space="preserve">
          <source>Reads and decodes the whole mp3 audio file. Resulting sample format is 16 bits signed integer.</source>
          <target state="translated">전체 mp3 오디오 파일을 읽고 디코딩합니다. 결과 샘플 형식은 16 비트 부호있는 정수입니다.</target>
        </trans-unit>
        <trans-unit id="14cc1382f4fb5d59ec01f663604f21ca76b87c92" translate="yes" xml:space="preserve">
          <source>Reads and decodes the whole mp3 audio file. Resulting sample format is 32 bits float.</source>
          <target state="translated">전체 mp3 오디오 파일을 읽고 디코딩합니다. 결과 샘플 형식은 32 비트 부동 소수점입니다.</target>
        </trans-unit>
        <trans-unit id="66fd98fa7dbb958e3db6fe2376534cfd2599a4fd" translate="yes" xml:space="preserve">
          <source>Reads and decodes the whole vorbis audio data. Resulting sample format is 16 bits signed integer.</source>
          <target state="translated">전체 vorbis 오디오 데이터를 읽고 디코딩합니다. 결과 샘플 형식은 16 비트 부호있는 정수입니다.</target>
        </trans-unit>
        <trans-unit id="7ce7effdcc92e574769789424af238e1f5022767" translate="yes" xml:space="preserve">
          <source>Reads and decodes the whole vorbis audio file. Resulting sample format is 16 bits signed integer.</source>
          <target state="translated">전체 vorbis 오디오 파일을 읽고 디코딩합니다. 결과 샘플 형식은 16 비트 부호있는 정수입니다.</target>
        </trans-unit>
        <trans-unit id="7bee529dbc8b35f42acc1e2d940fa7a23db13f74" translate="yes" xml:space="preserve">
          <source>Reads and decodes the whole wav audio data. Resulting sample format is 16 bits signed integer.</source>
          <target state="translated">전체 wav 오디오 데이터를 읽고 디코딩합니다. 결과 샘플 형식은 16 비트 부호있는 정수입니다.</target>
        </trans-unit>
        <trans-unit id="cd8bb367290e103b37d8e55a004d7baf5eb4b046" translate="yes" xml:space="preserve">
          <source>Reads and decodes the whole wav audio data. Resulting sample format is 32 bits float.</source>
          <target state="translated">전체 wav 오디오 데이터를 읽고 디코딩합니다. 결과 샘플 형식은 32 비트 부동 소수점입니다.</target>
        </trans-unit>
        <trans-unit id="0316c1a19af6c11394e2363a0c7a909945bfd350" translate="yes" xml:space="preserve">
          <source>Reads and decodes the whole wav audio data. Resulting sample format is 32 bits signed integer.</source>
          <target state="translated">전체 wav 오디오 데이터를 읽고 디코딩합니다. 결과 샘플 형식은 32 비트 부호있는 정수입니다.</target>
        </trans-unit>
        <trans-unit id="e06be3ec9628fe144f07b9524ee4e3afb5f98e6c" translate="yes" xml:space="preserve">
          <source>Reads and decodes the whole wav audio file. Resulting sample format is 16 bits signed integer.</source>
          <target state="translated">전체 wav 오디오 파일을 읽고 디코딩합니다. 결과 샘플 형식은 16 비트 부호있는 정수입니다.</target>
        </trans-unit>
        <trans-unit id="cf9e6ecb9c5aa6ba5d95e785c940830c651e4fe8" translate="yes" xml:space="preserve">
          <source>Reads and decodes the whole wav audio file. Resulting sample format is 32 bits float.</source>
          <target state="translated">전체 wav 오디오 파일을 읽고 디코딩합니다. 결과 샘플 형식은 32 비트 부동 소수점입니다.</target>
        </trans-unit>
        <trans-unit id="211262dda5092fe90e275b0a2fdcf7b86664fed8" translate="yes" xml:space="preserve">
          <source>Reads and decodes the whole wav audio file. Resulting sample format is 32 bits signed integer.</source>
          <target state="translated">전체 wav 오디오 파일을 읽고 디코딩합니다. 결과 샘플 형식은 32 비트 부호있는 정수입니다.</target>
        </trans-unit>
        <trans-unit id="b94764377806d47d4554064e530504fae16cbd28" translate="yes" xml:space="preserve">
          <source>Represents a source of data bytes.</source>
          <target state="translated">데이터 바이트의 소스를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="08dea8f05696619166984f7255726ff1f036dba6" translate="yes" xml:space="preserve">
          <source>Sample format in memory</source>
          <target state="translated">메모리의 샘플 형식</target>
        </trans-unit>
        <trans-unit id="1fbc24457e328192fefcfa11e3180acada1161ae" translate="yes" xml:space="preserve">
          <source>Software license for these Python bindings, miniaudio and the decoders: MIT</source>
          <target state="translated">다음 Python 바인딩, 미니 오디오 및 디코더에 대한 소프트웨어 라이선스 : MIT</target>
        </trans-unit>
        <trans-unit id="45d391119440fd7bbd319914ab435e60fa35003b" translate="yes" xml:space="preserve">
          <source>Start the audio device: capture (recording) begins. The recorded audio data is sent to the given
callback generator as raw bytes. (it should already be started before)</source>
          <target state="translated">오디오 장치 시작 : 캡처 (녹음)가 시작됩니다. 녹음 된 오디오 데이터는 원시 바이트로 지정된 콜백 생성기에 전송됩니다. (이전에 이미 시작되어 있어야 함)</target>
        </trans-unit>
        <trans-unit id="945b56ded1305142d54f39c6e7365e77951321bb" translate="yes" xml:space="preserve">
          <source>Start the audio device: playback and capture begin. The audio data for playback is provided by
the given callback generator, which is sent the recorded audio data at the same time. (it should
already be started before passing it in)</source>
          <target state="translated">오디오 장치 시작 : 재생 및 캡처가 시작됩니다. 재생을위한 오디오 데이터는 녹음 된 오디오 데이터를 동시에 전송하는 지정된 콜백 생성기에 의해 제공됩니다. (전달하기 전에 이미 시작되어 있어야합니다)</target>
        </trans-unit>
        <trans-unit id="ff2caf20fc34ab9e50df0099b5a27d767b47f447" translate="yes" xml:space="preserve">
          <source>Start the audio device: playback begins. The audio data is provided by the given callback
generator. The generator gets sent the required number of frames and should yield the sample data as
raw bytes, a memoryview, an array.array, or as a numpy array with shape (numframes, numchannels).
The generator should already be started before passing it in.</source>
          <target state="translated">오디오 장치 시작 : 재생이 시작됩니다. 오디오 데이터는 주어진 콜백 생성기에 의해 제공됩니다. 생성기는 필요한 수의 프레임을 전송하고 샘플 데이터를 원시 바이트, 메모리 뷰, array.array 또는 모양이있는 numpy 배열 (numframes, numchannels)로 생성해야합니다. 발전기는 전달하기 전에 이미 시작되어야합니다.</target>
        </trans-unit>
        <trans-unit id="76c76d79173b0b9b08e168d4486dceaa35768406" translate="yes" xml:space="preserve">
          <source>Streams the WAV audio file as interleaved 16 bit signed integer sample arrays segments. This uses
a fixed chunk size and cannot be used as a generic miniaudio decoder input stream. Consider using
stream_file() instead.</source>
          <target state="translated">WAV 오디오 파일을 인터리빙 된 16 비트 부호있는 정수 샘플 배열 세그먼트로 스트리밍합니다. 고정 된 청크 크기를 사용하며 일반 미니 오디오 디코더 입력 스트림으로 사용할 수 없습니다. 대신 stream_file () 사용을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="3738b64687d0324519ab81c368d92a787f244881" translate="yes" xml:space="preserve">
          <source>Streams the flac audio file as interleaved 16 bit signed integer sample arrays segments. This uses
a fixed chunk size and cannot be used as a generic miniaudio decoder input stream. Consider using
stream_file() instead.</source>
          <target state="translated">flac 오디오 파일을 인터리빙 된 16 비트 부호있는 정수 샘플 배열 세그먼트로 스트리밍합니다. 고정 된 청크 크기를 사용하며 일반 미니 오디오 디코더 입력 스트림으로 사용할 수 없습니다. 대신 stream_file () 사용을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="9482cf45ccd4f9efa70e90e823a12533679ea051" translate="yes" xml:space="preserve">
          <source>Streams the mp3 audio file as interleaved 16 bit signed integer sample arrays segments. This uses
a fixed chunk size and cannot be used as a generic miniaudio decoder input stream. Consider using
stream_file() instead.</source>
          <target state="translated">mp3 오디오 파일을 인터리빙 된 16 비트 부호있는 정수 샘플 배열 세그먼트로 스트리밍합니다. 고정 된 청크 크기를 사용하며 일반 미니 오디오 디코더 입력 스트림으로 사용할 수 없습니다. 대신 stream_file () 사용을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="7b5b03821afe1fe31d72644c2febc2ed586f6dbb" translate="yes" xml:space="preserve">
          <source>Streams the ogg vorbis audio file as interleaved 16 bit signed integer sample arrays segments.
This uses a variable unconfigurable chunk size and cannot be used as a generic miniaudio decoder
input stream. Consider using stream_file() instead.</source>
          <target state="translated">ogg vorbis 오디오 파일을 인터리빙 된 16 비트 부호있는 정수 샘플 배열 세그먼트로 스트리밍합니다. 구성 할 수없는 가변 청크 크기를 사용하며 일반 미니 오디오 디코더 입력 스트림으로 사용할 수 없습니다. 대신 stream_file () 사용을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="e4732f234fdca3d7bb1afb9876ff4d663409e880" translate="yes" xml:space="preserve">
          <source>Synthesizer, modplayer?</source>
          <target state="translated">신디사이저, 모드 플레이어?</target>
        </trans-unit>
        <trans-unit id="db65432ebabea4a5139d1b096c85c5fcbcaf2b57" translate="yes" xml:space="preserve">
          <source>TODO: filters</source>
          <target state="translated">TODO : 필터</target>
        </trans-unit>
        <trans-unit id="8bdf7d7031ef484465db0916ba56228b84f47b7e" translate="yes" xml:space="preserve">
          <source>TODO: waveform generators</source>
          <target state="translated">TODO : 파형 발생기</target>
        </trans-unit>
        <trans-unit id="dd6e4f4697b675457ca9ebfbfb8f624f2f8ff7de" translate="yes" xml:space="preserve">
          <source>The library is primarily distributed in source form so you need a C compiler to build and install this
(note: the setup script takes care of the actual compilation process, no need to worry about compiling things yourself).
For Linux and Mac this shouldn't be a problem. For Windows users, if the correct binary install
is not available on pypi, you'll have to get it to compile as well which may be a bit of a hassle
on this platform. You have to make sure that the required tools that allow you to compile Python extension modules
are installed (Visual Studio or the VC++ build tools).</source>
          <target state="translated">라이브러리는 주로 소스 형식으로 배포되므로이를 빌드하고 설치하려면 C 컴파일러가 필요합니다 (참고 : 설정 스크립트는 실제 컴파일 프로세스를 처리하므로 컴파일에 대해 걱정할 필요가 없습니다). Linux 및 Mac의 경우 이것은 문제가되지 않습니다. Windows 사용자의 경우 pypi에서 올바른 바이너리 설치를 사용할 수없는 경우이 플랫폼에서 약간의 번거 로움이 될 수있는 컴파일도 수행해야합니다. Python 확장 모듈을 컴파일 할 수있는 필수 도구가 설치되어 있는지 확인해야합니다 (Visual Studio 또는 VC ++ 빌드 도구).</target>
        </trans-unit>
        <trans-unit id="3ed6ea8457e732020e5e7c68ec8bc977f320c74f" translate="yes" xml:space="preserve">
          <source>The priority of the worker thread (default=HIGHEST)</source>
          <target state="translated">작업자 스레드의 우선 순위 (기본값 = HIGHEST)</target>
        </trans-unit>
        <trans-unit id="1d3f94de385ebfc9cd02ce7bb23cc8223825c59e" translate="yes" xml:space="preserve">
          <source>This example uses ffmpeg as an external tool to decode an audio file in a format
that miniaudio itself can't decode (m4a/aac in this case):</source>
          <target state="translated">이 예에서는 ffmpeg를 외부 도구로 사용하여 미니 오디오 자체가 디코딩 할 수없는 형식 (이 경우 m4a / aac)의 오디오 파일을 디코딩합니다.</target>
        </trans-unit>
        <trans-unit id="5911a575014ce2d1da77c61a88e0f76c62bfb790" translate="yes" xml:space="preserve">
          <source>This library aims to provide a Pythonic interface to the miniaudio C library.
Some of the main aspects of this are:</source>
          <target state="translated">이 라이브러리는 miniaudio C 라이브러리에 Pythonic 인터페이스를 제공하는 것을 목표로합니다. 이것의 주요 측면 중 일부는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="389d67d4e425bd22cb93a94f064798d7a90e6644" translate="yes" xml:space="preserve">
          <source>This module provides:</source>
          <target state="translated">이 모듈은 다음을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="170c5132604e95ae76726c1db966048a228bb943" translate="yes" xml:space="preserve">
          <source>Type of audio device</source>
          <target state="translated">오디오 장치 유형</target>
        </trans-unit>
        <trans-unit id="f99c32a07530d0d3059a528f698be74929fb0a01" translate="yes" xml:space="preserve">
          <source>When a miniaudio specific error occurs.</source>
          <target state="translated">미니 오디오 관련 오류가 발생하는 경우.</target>
        </trans-unit>
        <trans-unit id="93256ad3c60c2669cdc10ed669d360a02c91bcf8" translate="yes" xml:space="preserve">
          <source>When something went wrong during decoding an audio file.</source>
          <target state="translated">오디오 파일을 디코딩하는 동안 문제가 발생한 경우.</target>
        </trans-unit>
        <trans-unit id="56e07f7cf6898b2eab378ae9d1ab0421de7ae314" translate="yes" xml:space="preserve">
          <source>Writes the pcm sound to a WAV file</source>
          <target state="translated">WAV 파일에 pcm 사운드를 씁니다.</target>
        </trans-unit>
        <trans-unit id="b6dbe85a2dc821488f64260d49026ef62265acaa" translate="yes" xml:space="preserve">
          <source>audio playback</source>
          <target state="translated">오디오 재생</target>
        </trans-unit>
        <trans-unit id="d915246f9ca1345a5feba62e84a502aa445c4311" translate="yes" xml:space="preserve">
          <source>audio recording</source>
          <target state="translated">오디오 녹음</target>
        </trans-unit>
        <trans-unit id="79cd964eff1ec3f6a10c6ff422280e07044c7347" translate="yes" xml:space="preserve">
          <source>converting sample formats and frequencies</source>
          <target state="translated">샘플 형식 및 빈도 변환</target>
        </trans-unit>
        <trans-unit id="3239aa4d8ed17fa10aabaeb8f958c0cf040d0723" translate="yes" xml:space="preserve">
          <source>generators for the Audio playback and recording</source>
          <target state="translated">오디오 재생 및 녹음을위한 생성기</target>
        </trans-unit>
        <trans-unit id="9f44b27fd037879342d5e1284d5cc63359e1b680" translate="yes" xml:space="preserve">
          <source>getting audio file properties (such as duration, number of channels, sample rate)</source>
          <target state="translated">오디오 파일 속성 가져 오기 (예 : 기간, 채널 수, 샘플 속도)</target>
        </trans-unit>
        <trans-unit id="4a530d2bffe101a83fbd1521b4e5a25c9f525273" translate="yes" xml:space="preserve">
          <source>its decoders for wav, flac, vorbis and mp3</source>
          <target state="translated">wav, flac, vorbis 및 mp3 용 디코더</target>
        </trans-unit>
        <trans-unit id="6e06f5192e5c61836071c7b542573ccca6113879" translate="yes" xml:space="preserve">
          <source>python bindings for most of the functions offered in those libraries:</source>
          <target state="translated">해당 라이브러리에서 제공되는 대부분의 기능에 대한 파이썬 바인딩 :</target>
        </trans-unit>
        <trans-unit id="5691ee15da5634f86093f97c3fd972b1c2dc3add" translate="yes" xml:space="preserve">
          <source>python bindings for the miniaudio library and its decoders (mp3, flac, ogg vorbis, wav)</source>
          <target state="translated">miniaudio 라이브러리 및 디코더 (mp3, flac, ogg vorbis, wav)에 대한 파이썬 바인딩</target>
        </trans-unit>
        <trans-unit id="8a22aba5682ed6386f904e381fd0d23444b4f9e0" translate="yes" xml:space="preserve">
          <source>reading and decoding audio files</source>
          <target state="translated">오디오 파일 읽기 및 디코딩</target>
        </trans-unit>
        <trans-unit id="b564d1f2a1cbbfeddd85f762834889c6ca9bcd69" translate="yes" xml:space="preserve">
          <source>sample data is usually in the form of a Python &lt;code&gt;array&lt;/code&gt; with appropriately sized elements
depending on the sample width (rather than a raw block of bytes)</source>
          <target state="translated">샘플 데이터는 일반적으로 (원시 바이트 블록이 아닌) 샘플 너비에 따라 적절한 크기의 요소 가있는 Python &lt;code&gt;array&lt;/code&gt; 형식입니다.</target>
        </trans-unit>
        <trans-unit id="2093da2e24735be37f448f0fea1835324065015a" translate="yes" xml:space="preserve">
          <source>several classes to represent the main functions of the library,</source>
          <target state="translated">라이브러리의 주요 기능을 나타내는 여러 클래스,</target>
        </trans-unit>
        <trans-unit id="205080bba7759412ece27e6d7727faf0536b02d5" translate="yes" xml:space="preserve">
          <source>streaming large audio files</source>
          <target state="translated">대용량 오디오 파일 스트리밍</target>
        </trans-unit>
        <trans-unit id="3ddb7f59b1ed2b644f82493a1940e3ba55dd1628" translate="yes" xml:space="preserve">
          <source>the &lt;a href=&quot;https://github.com/dr-soft/miniaudio/&quot;&gt;miniaudio&lt;/a&gt; cross platform sound playback, recording and conversion library</source>
          <target state="translated">&lt;a href=&quot;https://github.com/dr-soft/miniaudio/&quot;&gt;miniaudio&lt;/a&gt; 크로스 플랫폼 사운드 재생, 녹음 및 변환 라이브러리</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
