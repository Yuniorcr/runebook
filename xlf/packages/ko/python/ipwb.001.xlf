<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://pypi.org/project/ipwb/">
    <body>
      <group id="ipwb">
        <trans-unit id="06e2345659ef91547b398c738861507f6102e187" translate="yes" xml:space="preserve">
          <source>...for example, from the root of the ipwb repository:</source>
          <target state="translated">... 예를 들어 ipwb 저장소의 루트에서 :</target>
        </trans-unit>
        <trans-unit id="2ee77b1984d30adfe92c847867331d0951e1f7d4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Peer-To-Peer Permanence of Web Archives&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;웹 아카이브의 피어 투 피어 영구성&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1e2d3bf70b8cb34a7fca9a6659848dc363edbcb8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;ipwb/indexer.py&lt;/strong&gt; - archival indexing script that takes the path to a WARC input, extracts the HTTP headers, HTTP payload (response body), and relevant parts of the WARC-response record header from the WARC specified and creates byte string representations. The indexer then pushes the byte strings into IPFS using a locally running IPFS daemon then creates a &lt;a href=&quot;https://github.com/oduwsdl/ORS/wiki/CDXJ&quot;&gt;CDXJ&lt;/a&gt; file with this metadata for replay.py.</source>
          <target state="translated">&lt;strong&gt;ipwb / indexer.py&lt;/strong&gt; -WARC 입력에 대한 경로를 가져 &lt;strong&gt;오고 지정된&lt;/strong&gt; WARC에서 HTTP 헤더, HTTP 페이로드 (응답 본문) 및 WARC 응답 레코드 헤더의 관련 부분을 추출하고 바이트 문자열 표현을 생성하는 아카이브 인덱싱 스크립트입니다. 인덱서는 로컬에서 실행중인 IPFS 데몬을 사용하여 바이트 문자열을 IPFS로 푸시 한 다음 &lt;a href=&quot;https://github.com/oduwsdl/ORS/wiki/CDXJ&quot;&gt;replay.py에&lt;/a&gt; 대한이 메타 데이터를 사용하여 CDXJ 파일 을 생성합니다 .</target>
        </trans-unit>
        <trans-unit id="be88dde89885f711e34d52ef22c677825420a1f0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;ipwb/replay.py&lt;/strong&gt; - rudimentary replay script to resolve requests for archival content contained in IPFS for replay in the browser.</source>
          <target state="translated">&lt;strong&gt;ipwb / replay.py-&lt;/strong&gt; 브라우저에서 재생하기 위해 IPFS에 포함 된 아카이브 콘텐츠에 대한 요청을 해결하는 기본적인 재생 스크립트입니다.</target>
        </trans-unit>
        <trans-unit id="b7d077dd899c7d229f99e0de196434fc49e5b60b" translate="yes" xml:space="preserve">
          <source>A pictorial representation of the ipwb indexing and replay process:</source>
          <target state="translated">ipwb 인덱싱 및 재생 프로세스의 그림 표현 :</target>
        </trans-unit>
        <trans-unit id="55bd269e3afb67bd2dfaea54fa7300aa6464fc66" translate="yes" xml:space="preserve">
          <source>A pre-built Docker image is made available that can be run as following:</source>
          <target state="translated">다음과 같이 실행할 수있는 사전 빌드 된 Docker 이미지를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="65e25ef42cdbe3ba21bab8361ce5779085964d2c" translate="yes" xml:space="preserve">
          <source>An archival replay system is also included with ipwb to re-experience the content disseminated to IPFS. A CDXJ index needs to be provided and used by the ipwb replay system by specifying the path of the index file as a parameter to the replay system:</source>
          <target state="translated">보관 재생 시스템도 ipwb에 포함되어 IPFS에 배포 된 콘텐츠를 다시 경험할 수 있습니다. CDXJ 색인은 재생 시스템에 대한 매개 변수로 색인 파일의 경로를 지정하여 ipwb 재생 시스템에서 제공하고 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="c5050f193a520cf9c7432406f6fcc4e6838a12ba" translate="yes" xml:space="preserve">
          <source>An important aspect of archival replay systems is rewriting various resource references for proper memento reconstruction so that they are dereferenced properly from the archive from around the same datetime as of the root memento and not from the live site (in which case the resource might have changed or gone missing). Many archival replay systems perform server-side rewriting, but it has its limitations when URIs are generated using JavaScript. To handle this we use &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API&quot;&gt;Service Worker&lt;/a&gt; for rerouting requests on the client-side when they are dereferenced to avoid any server-side rewiring. For this, we have implemented a separate library, &lt;a href=&quot;https://oduwsdl.github.io/Reconstructive/&quot;&gt;Reconstructive&lt;/a&gt;, which is reusable and extendable by any archival replay system.</source>
          <target state="translated">아카이브 재생 시스템의 중요한 측면은 적절한 메모 재구성을 위해 다양한 리소스 참조를 다시 작성하여 라이브 사이트가 아닌 루트 메모와 거의 동일한 날짜 시간에 아카이브에서 적절하게 역 참조되도록하는 것입니다 (이 경우 리소스가 변경되었을 수 있음). 또는 실종). 많은 아카이브 재생 시스템은 서버 측 재 작성을 수행하지만 JavaScript를 사용하여 URI를 생성 할 때 한계가 있습니다. 이를 처리하기 위해 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API&quot;&gt;서비스 워커&lt;/a&gt; 를 사용 하여 클라이언트 측에서 요청을 다시 라우팅하여 서버 측 재배 선을 방지합니다. 이를 위해 별도의 라이브러리 인 &lt;a href=&quot;https://oduwsdl.github.io/Reconstructive/&quot;&gt;Reconstructive를&lt;/a&gt; 구현했습니다.이 라이브러리 는 모든 보관 재생 시스템에서 재사용 및 확장 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="15f1ed0e14f5d5b28c49a63f8b4fd0c61ce3582b" translate="yes" xml:space="preserve">
          <source>Another important feature of archival replays is the inclusion of an archival banner in mementos. The purpose of an archival banner is to highlight that a replayed page is a memento and not a live page, to provide metadata about the memento and the archive, and to facilitate additional interactivity. Many archival banners used in different web archival replay systems are obtrusive in nature and have issues like style leakage. To eliminate both of these issues we have implemented a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Web_Components/Using_custom_elements&quot;&gt;Custom HTML Element&lt;/a&gt;, &lt;a href=&quot;https://oduwsdl.github.io/Reconstructive/docs/class/Reconstructive/reconstructive-banner.js%7EReconstructiveBanner.html&quot;&gt;&amp;lt;reconstructive-banner&amp;gt;&lt;/a&gt; as part of the &lt;a href=&quot;https://oduwsdl.github.io/Reconstructive/&quot;&gt;Reconstructive&lt;/a&gt; library and used in the ipwb.</source>
          <target state="translated">보관 리플레이의 또 다른 중요한 기능은 기념품에 보관 배너를 포함하는 것입니다. 보관 배너의 목적은 재생 된 페이지가 라이브 페이지가 아니라 기념품임을 강조하고, 기념품 및 아카이브에 대한 메타 데이터를 제공하고, 추가적인 상호 작용을 용이하게하는 것입니다. 다른 웹 보관 재생 시스템에서 사용되는 많은 보관 배너는 본질적으로 눈에 띄지 않으며 스타일 유출과 같은 문제가 있습니다. 이러한 문제를 모두 제거하기 위해 &lt;a href=&quot;https://oduwsdl.github.io/Reconstructive/&quot;&gt;Reconstructive&lt;/a&gt; 라이브러리의 일부로 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Web_Components/Using_custom_elements&quot;&gt;Custom HTML Element&lt;/a&gt; , &lt;a href=&quot;https://oduwsdl.github.io/Reconstructive/docs/class/Reconstructive/reconstructive-banner.js%7EReconstructiveBanner.html&quot;&gt;&amp;lt;reconstructive-banner&amp;gt;&lt;/a&gt; 를 구현 하고 ipwb에서 사용했습니다.</target>
        </trans-unit>
        <trans-unit id="6d7af7007f339e84fc4c2de5df5b67bacbc49164" translate="yes" xml:space="preserve">
          <source>By default, the image building process also performs tests, so it might take a while to build the image. It ensures that an image will not be created with failing tests. However, it is possible to skip tests by supplying a build-arg &lt;code&gt;--build-arg SKIPTEST=true&lt;/code&gt; as illustrated below:</source>
          <target state="translated">기본적으로 이미지 빌드 프로세스는 테스트도 수행하므로 이미지를 빌드하는 데 시간이 걸릴 수 있습니다. 실패한 테스트로 이미지가 생성되지 않도록합니다. 그러나 아래 그림과 같이 &lt;code&gt;--build-arg SKIPTEST=true&lt;/code&gt; 를 제공하여 테스트를 건너 뛸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="81c8fe621b0eccc77a08435bab3cb65dac5b3b28" translate="yes" xml:space="preserve">
          <source>Citing Project</source>
          <target state="translated">인용 프로젝트</target>
        </trans-unit>
        <trans-unit id="9ecea0dacc72c9dda1b28914a57568d8febec652" translate="yes" xml:space="preserve">
          <source>For conventional usage, the latest release of ipwb can be installed using pip:</source>
          <target state="translated">일반적인 사용의 경우 pip를 사용하여 최신 ipwb 릴리스를 설치할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c47ae15370cfe1ed2781eedc1dc2547d12d9e972" translate="yes" xml:space="preserve">
          <source>Help</source>
          <target state="translated">도움</target>
        </trans-unit>
        <trans-unit id="18cda72bbdc6519fd8818fe9fad8a2413f6c02c6" translate="yes" xml:space="preserve">
          <source>If the host folder structure is something other than &lt;code&gt;/some/path/{warc,cdxj,ipfs}&lt;/code&gt; then these volumes need to be mounted separately.</source>
          <target state="translated">호스트 폴더 구조가 &lt;code&gt;/some/path/{warc,cdxj,ipfs}&lt;/code&gt; 가 아닌 경우 이러한 볼륨을 별도로 마운트해야합니다.</target>
        </trans-unit>
        <trans-unit id="333fa6880824b1a0a04ba574a034b122afc8c90f" translate="yes" xml:space="preserve">
          <source>If you encounter a conflict with the default API port of 5001 when starting the daemon, running the following prior to launching the daemon will change the API port to access to one of your choosing (here, shown to be 5002):</source>
          <target state="translated">데몬을 시작할 때 기본 API 포트 5001과 충돌하는 경우 데몬을 시작하기 전에 다음을 실행하면 선택한 API 포트 중 하나에 액세스하도록 API 포트가 변경됩니다 (여기서는 5002로 표시됨).</target>
        </trans-unit>
        <trans-unit id="4a455c1218dcb14bbda9fd52343b4dd39b78406a" translate="yes" xml:space="preserve">
          <source>In a separate terminal session (or the same if you started the daemon in the background), instruct ipwb to push contents of a WARC file into IPFS and create an index of records:</source>
          <target state="translated">별도의 터미널 세션 (또는 백그라운드에서 데몬을 시작한 경우 동일)에서 ipwb에 WARC 파일의 내용을 IPFS로 푸시하고 레코드 색인을 생성하도록 지시합니다.</target>
        </trans-unit>
        <trans-unit id="9951861c21df18489a5872209655d6f9039b5e2a" translate="yes" xml:space="preserve">
          <source>Indexing</source>
          <target state="translated">인덱싱</target>
        </trans-unit>
        <trans-unit id="e38432618ce4d39079fc324e614d4d92a2815160" translate="yes" xml:space="preserve">
          <source>Installing</source>
          <target state="translated">설치 중</target>
        </trans-unit>
        <trans-unit id="19357182557718b1e0bf5808b04030cce9490a3b" translate="yes" xml:space="preserve">
          <source>InterPlanetary Wayback (ipwb)</source>
          <target state="translated">InterPlanetary Wayback (ipwb)</target>
        </trans-unit>
        <trans-unit id="a09fd116f6d0b1bba040a6d00e3aebf1c4153e62" translate="yes" xml:space="preserve">
          <source>InterPlanetary Wayback (ipwb) facilitates permanence and collaboration in web archives by disseminating the contents of &lt;a href=&quot;http://www.iso.org/iso/catalogue_detail.htm?csnumber=44717&quot;&gt;WARC&lt;/a&gt; files into the IPFS network. &lt;a href=&quot;https://ipfs.io/&quot;&gt;IPFS&lt;/a&gt; is a peer-to-peer content-addressable file system that inherently allows deduplication and facilitates opt-in replication. ipwb splits the header and payload of WARC response records before disseminating into IPFS to leverage the deduplication, builds a &lt;a href=&quot;https://github.com/oduwsdl/ORS/wiki/CDXJ&quot;&gt;CDXJ index&lt;/a&gt; with references to the IPFS hashes returned, and combines the header and payload from IPFS at the time of replay.</source>
          <target state="translated">InterPlanetary Wayback (ipwb)은 &lt;a href=&quot;http://www.iso.org/iso/catalogue_detail.htm?csnumber=44717&quot;&gt;WARC&lt;/a&gt; 파일 의 내용을 IPFS 네트워크 에 배포하여 웹 아카이브의 영구성과 협업을 용이하게 합니다. &lt;a href=&quot;https://ipfs.io/&quot;&gt;IPFS&lt;/a&gt; 는 본질적으로 중복 제거를 허용하고 옵트 인 복제를 용이하게하는 피어 투 피어 콘텐츠 주소 지정 파일 시스템입니다. ipwb는 중복 제거를 활용하기 위해 IPFS로 배포하기 전에 WARC 응답 레코드의 헤더와 페이로드를 분할하고, 반환 된 IPFS 해시에 대한 참조로 &lt;a href=&quot;https://github.com/oduwsdl/ORS/wiki/CDXJ&quot;&gt;CDXJ 인덱스&lt;/a&gt; 를 빌드하고 , 재생시 IPFS의 헤더와 페이로드를 결합합니다.</target>
        </trans-unit>
        <trans-unit id="7cad164ec83177b70c542f7c54b11491ad6801a6" translate="yes" xml:space="preserve">
          <source>InterPlanetary Wayback (ipwb) requires Python 3.7+. ipwb can also be used with Docker (&lt;a href=&quot;#user-content-using-docker&quot;&gt;see below&lt;/a&gt;).</source>
          <target state="translated">InterPlanetary Wayback (ipwb)에는 Python 3.7 이상이 필요합니다. ipwb는 Docker와 함께 사용할 수도 있습니다 ( &lt;a href=&quot;#user-content-using-docker&quot;&gt;아래 참조&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="c944df46aa48f9ad2f50c18c6b540f3e5f369013" translate="yes" xml:space="preserve">
          <source>InterPlanetary Wayback (ipwb): Web Archive integration with IPFS</source>
          <target state="translated">InterPlanetary Wayback (ipwb) : 웹 아카이브와 IPFS 통합</target>
        </trans-unit>
        <trans-unit id="ccb4eba544ad27b675212b67ab6f3e9dedb62fef" translate="yes" xml:space="preserve">
          <source>InterPlanetary Wayback primarily consists of two scripts:</source>
          <target state="translated">InterPlanetary Wayback은 주로 두 가지 스크립트로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="3229609e15436ec51bcf00818a69a84dbc58a0c2" translate="yes" xml:space="preserve">
          <source>License</source>
          <target state="translated">특허</target>
        </trans-unit>
        <trans-unit id="89690ac571dcf4c9c40c842efed3f11171d07b29" translate="yes" xml:space="preserve">
          <source>MIT</source>
          <target state="translated">MIT</target>
        </trans-unit>
        <trans-unit id="50ebc49c256d22e38e0443852b867f8ee5d31bc6" translate="yes" xml:space="preserve">
          <source>Mat Kelly, Sawood Alam, Michael L. Nelson, and Michele C. Weigle. &lt;strong&gt;InterPlanetary Wayback: Peer-To-Peer Permanence of Web Archives&lt;/strong&gt;. In &lt;em&gt;Proceedings of the 20th International Conference on Theory and Practice of Digital Libraries&lt;/em&gt;, pages 411&amp;ndash;416, Hamburg, Germany, June 2016.</source>
          <target state="translated">Mat Kelly, Sawood Alam, Michael L. Nelson 및 Michele C. Weigle. &lt;strong&gt;InterPlanetary Wayback : 웹 아카이브의 피어 투 피어 영구성&lt;/strong&gt; . 에서 &lt;em&gt;20 이론과 디지털 도서관의 업무에 관한 국제 학술 대회&lt;/em&gt; , 페이지 411-416, 함부르크, 독일 6 월 (2016).</target>
        </trans-unit>
        <trans-unit id="280fcb3c140ac32a4c80dc5f2e2cff8af750f0f9" translate="yes" xml:space="preserve">
          <source>Once started, the replay system's web interface can be accessed through a web browser, e.g., &lt;a href=&quot;http://localhost:5000/&quot;&gt;http://localhost:5000/&lt;/a&gt; by default.</source>
          <target state="translated">일단 시작되면 웹 브라우저 (예 &lt;a href=&quot;http://localhost:5000/&quot;&gt;:&lt;/a&gt; 기본적으로 http : // localhost : 5000 /) 를 통해 리플레이 시스템의 웹 인터페이스에 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b8442dc4d1ec0bad64eee08dd76a30bc77df4064" translate="yes" xml:space="preserve">
          <source>Project History</source>
          <target state="translated">프로젝트 역사</target>
        </trans-unit>
        <trans-unit id="4cbc9b79dabc02dd5ba1414234564bd4645b9735" translate="yes" xml:space="preserve">
          <source>Replaying</source>
          <target state="translated">재생</target>
        </trans-unit>
        <trans-unit id="cdd7bb2816b7a8f88bce0e47be39943bc369516b" translate="yes" xml:space="preserve">
          <source>Setup</source>
          <target state="translated">설정</target>
        </trans-unit>
        <trans-unit id="bd10f47230c2a9b0135b0cb7ec8955bb7d1fd138" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://fox.cs.vt.edu/wadl2016.html&quot;&gt;Web Archiving and Digital Libraries (WADL) 2016 workshop&lt;/a&gt; in Newark, NJ in June 2016.</source>
          <target state="translated">&lt;a href=&quot;http://fox.cs.vt.edu/wadl2016.html&quot;&gt;웹 보관 및 디지털 도서관 (WADL) 2016 워크숍&lt;/a&gt; 년 6 월 2016 년 뉴 어크, 뉴저지있다.</target>
        </trans-unit>
        <trans-unit id="2dcf353afbd930f92a87457f283f80190ecc6d9a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://netpreserve.org/wac2017/&quot;&gt;International Internet Preservation Consortium (IIPC) Web Archiving Conference (WAC) 2017&lt;/a&gt; in London, England in June 2017.</source>
          <target state="translated">&lt;a href=&quot;http://netpreserve.org/wac2017/&quot;&gt;국제 인터넷 보존 컨소시엄 (IIPC) 웹 보관 회의 (WAC) 2017&lt;/a&gt; 년 6 월 2017 년 영국 런던한다.</target>
        </trans-unit>
        <trans-unit id="22524760ddfa238b1e7b190816c2d288595cdca1" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://www.jcdl2016.org/&quot;&gt;Joint Conference on Digital Libraries 2016&lt;/a&gt; in Newark, NJ in June 2016.</source>
          <target state="translated">&lt;a href=&quot;http://www.jcdl2016.org/&quot;&gt;디지털 도서관 2016에 대한 공동 회의&lt;/a&gt; 년 6 월 2016 년 뉴 어크, 뉴저지있다.</target>
        </trans-unit>
        <trans-unit id="9689ff1ffcfaa553c88669971142168667abb46f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://www.tpdl2016.org/&quot;&gt;Theory and Practice on Digital Libraries (TPDL) 2016&lt;/a&gt; in Hannover, Germany in September 2016.</source>
          <target state="translated">&lt;a href=&quot;http://www.tpdl2016.org/&quot;&gt;디지털 도서관 (TPDL) 2016에 대한 이론 및 실습&lt;/a&gt; 년 9 월 2016 년 독일 하노버있다.</target>
        </trans-unit>
        <trans-unit id="de4a1718ce4cc57be02a114a4c1efd22d9a60518" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://archivesunleashed.com/call-for-participation-au4/&quot;&gt;Archives Unleashed 4.0: Web Archive Datathon&lt;/a&gt; in London, England in June 2017.</source>
          <target state="translated">The &lt;a href=&quot;https://archivesunleashed.com/call-for-participation-au4/&quot;&gt;Archives Unleashed 4.0 :&lt;/a&gt; 2017 년 6 월 영국 런던의 웹 아카이브 Datathon .</target>
        </trans-unit>
        <trans-unit id="39bd5c9fcdf6fdbe4f5e2c3bffff1bd953af7b33" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://www.decentralizedweb.net/&quot;&gt;Decentralized Web Summit 2018's&lt;/a&gt; IPFS Lab Day in San Francisco, CA in August 2018.</source>
          <target state="translated">&lt;a href=&quot;https://www.decentralizedweb.net/&quot;&gt;분산 웹 서밋 2018의&lt;/a&gt; 년 8 월 2018 년 캘리포니아 주 샌프란시스코에서 IPFS 연구소 날.</target>
        </trans-unit>
        <trans-unit id="8ea766ccac44e1cafd8e8d5427f8ed1f7fbe3887" translate="yes" xml:space="preserve">
          <source>The InterPlanetary Filesystem (ipfs) daemon must be installed and running before starting ipwb. See the &lt;a href=&quot;https://ipfs.io/docs/install/&quot;&gt;Install IPFS&lt;/a&gt; page to accomplish this. In the future, we hope to make this more automated. Once ipfs is installed, start the daemon:</source>
          <target state="translated">ipwb를 시작하기 전에 InterPlanetary Filesystem (ipfs) 데몬을 설치하고 실행해야합니다. 이를 수행 &lt;a href=&quot;https://ipfs.io/docs/install/&quot;&gt;하려면 IPFS 설치&lt;/a&gt; 페이지를 참조하십시오 . 앞으로 우리는 이것을 더 자동화하기를 희망합니다. ipfs가 설치되면 데몬을 시작합니다.</target>
        </trans-unit>
        <trans-unit id="0b0c4d17c42a40a64af9420d43d0b3a4020a42c9" translate="yes" xml:space="preserve">
          <source>The container will run an IPFS daemon, index a sample WARC file, and replay it using the newly created index. It will take a few seconds to be ready, then the replay will be accessible at &lt;a href=&quot;http://localhost:5000/&quot;&gt;http://localhost:5000/&lt;/a&gt; with a sample archived page.</source>
          <target state="translated">컨테이너는 IPFS 데몬을 실행하고 샘플 WARC 파일을 인덱싱하고 새로 생성 된 인덱스를 사용하여 재생합니다. 준비하는 데 몇 초가 걸리고 샘플 아카이브 페이지를 사용하여 &lt;a href=&quot;http://localhost:5000/&quot;&gt;http : // localhost : 5000 /&lt;/a&gt; 에서 재생에 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="303f24ccd6cd043206250bc3946f6ea7c6da15c6" translate="yes" xml:space="preserve">
          <source>The ipwb indexer partitions the WARC into WARC Records and extracts the WARC Response headers, HTTP response headers, and the HTTP response bodies (payloads). Relevant information is extracted from the WARC Response headers, temporary byte strings are created for the HTTP response headers and payload, and these two bytes strings are pushed into IPFS. The resulting CDXJ data is written to &lt;code&gt;STDOUT&lt;/code&gt; by default but can be redirected to a file, e.g.,</source>
          <target state="translated">ipwb 인덱서는 WARC를 WARC 레코드로 분할하고 WARC 응답 헤더, HTTP 응답 헤더 및 HTTP 응답 본문 (페이로드)을 추출합니다. WARC 응답 헤더에서 관련 정보가 추출되고 HTTP 응답 헤더 및 페이로드에 대한 임시 바이트 문자열이 생성되며이 두 바이트 문자열이 IPFS로 푸시됩니다. 결과 CDXJ 데이터는 기본적 으로 &lt;code&gt;STDOUT&lt;/code&gt; 에 기록 되지만 파일로 리디렉션 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="479e52e8f617f9038c9b21e771e6d3296a9bb24b" translate="yes" xml:space="preserve">
          <source>The latest development version containing changes not yet released can be installed from source:</source>
          <target state="translated">아직 출시되지 않은 변경 사항이 포함 된 최신 개발 버전은 소스에서 설치할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="627d22102b7377e70070b81ef3943caa143f921a" translate="yes" xml:space="preserve">
          <source>This repo contains the code for integrating &lt;a href=&quot;http://www.iso.org/iso/catalogue_detail.htm?csnumber=44717&quot;&gt;WARC&lt;/a&gt;s and &lt;a href=&quot;https://ipfs.io/&quot;&gt;IPFS&lt;/a&gt; as developed at the &lt;a&gt;Archives Unleashed: Web Archive Hackathon&lt;/a&gt; in Toronto, Canada in March 2016. The project was also presented at:</source>
          <target state="translated">이 저장소에는 2016 년 3 월 캐나다 토론토 의 &lt;a&gt;Archives Unleashed : Web Archive Hackathon&lt;/a&gt; 에서 개발 된 &lt;a href=&quot;http://www.iso.org/iso/catalogue_detail.htm?csnumber=44717&quot;&gt;WARC&lt;/a&gt; 및 &lt;a href=&quot;https://ipfs.io/&quot;&gt;IPFS&lt;/a&gt; 통합 코드가 포함되어 있습니다 .이 프로젝트는 다음 위치에서도 발표되었습니다.</target>
        </trans-unit>
        <trans-unit id="57c0feda619e4bd8b71a80886c53aa2ff3920eed" translate="yes" xml:space="preserve">
          <source>To build an image from the source, run the following command from the directory where the source code is checked out. The name of the locally built image could be anything, but we use &lt;code&gt;oduwsdl/ipwb&lt;/code&gt; to be consistent with the above commands.</source>
          <target state="translated">소스에서 이미지를 빌드하려면 소스 코드가 체크 아웃 된 디렉토리에서 다음 명령을 실행하십시오. 로컬로 빌드 된 이미지의 이름은 무엇이든 될 수 있지만 위의 명령과 일치 하도록 &lt;code&gt;oduwsdl/ipwb&lt;/code&gt; 를 사용 합니다.</target>
        </trans-unit>
        <trans-unit id="2d66e0a72f236d5c3e76da62ac908d47aab1cdd7" translate="yes" xml:space="preserve">
          <source>To index and replay your own WARC file, bind mount your data folders inside the container using &lt;code&gt;-v&lt;/code&gt; (or &lt;code&gt;--volume&lt;/code&gt;) flag and run commands accordingly. The provided docker image has designated &lt;code&gt;/data&lt;/code&gt; directory, inside which there are &lt;code&gt;warc&lt;/code&gt;, &lt;code&gt;cdxj&lt;/code&gt;, and &lt;code&gt;ipfs&lt;/code&gt; folders where host folders can be mounted separately or as a single mount point at the parent &lt;code&gt;/data&lt;/code&gt; directory. Assuming that the host machine has a &lt;code&gt;/path/to/data&lt;/code&gt; folder under which there are &lt;code&gt;warc&lt;/code&gt;, &lt;code&gt;cdxj&lt;/code&gt;, and &lt;code&gt;ipfs&lt;/code&gt; folders and a WARC file at &lt;code&gt;/path/to/data/warc/custom.warc.gz&lt;/code&gt;.</source>
          <target state="translated">자신의 WARC 파일을 인덱싱하고 재생하려면 &lt;code&gt;-v&lt;/code&gt; (또는 &lt;code&gt;--volume&lt;/code&gt; ) 플래그를 사용하여 컨테이너 내부에 데이터 폴더를 바인딩 하고 그에 따라 명령을 실행합니다. 제공된 docker 이미지에는 지정된 &lt;code&gt;/data&lt;/code&gt; 디렉토리가 있으며, 내부 에는 호스트 폴더를 별도로 마운트하거나 상위 &lt;code&gt;/data&lt;/code&gt; 디렉토리 의 단일 마운트 지점으로 마운트 할 수있는 &lt;code&gt;warc&lt;/code&gt; , &lt;code&gt;cdxj&lt;/code&gt; 및 &lt;code&gt;ipfs&lt;/code&gt; 폴더가 있습니다 . 호스트 시스템 에 &lt;code&gt;warc&lt;/code&gt; , &lt;code&gt;cdxj&lt;/code&gt; 및 &lt;code&gt;ipfs&lt;/code&gt; 폴더 가있는 &lt;code&gt;/path/to/data&lt;/code&gt; 폴더와 &lt;code&gt;/path/to/data/warc/custom.warc.gz&lt;/code&gt; 에 WARC 파일 이 있다고 가정합니다 .</target>
        </trans-unit>
        <trans-unit id="f6877d0f5d9b7e6b6fe72694ce71c6e26a52b6be" translate="yes" xml:space="preserve">
          <source>To run it under a domain name other than &lt;code&gt;localhost&lt;/code&gt;, the easiest approach is to use a reverse proxy that supports HTTPS. The replay system utilizes &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API&quot;&gt;Service Worker&lt;/a&gt; for URL rerouting/rewriting to prevent &lt;a href=&quot;http://ws-dl.blogspot.com/2012/10/2012-10-10-zombies-in-archives.html&quot;&gt;live leakage (zombies)&lt;/a&gt;. However, for security reason many web browsers have mandated HTTPS for the Service Worker API with only exception if the domain is &lt;code&gt;localhost&lt;/code&gt;. &lt;a href=&quot;https://caddyserver.com/&quot;&gt;Caddy Server&lt;/a&gt; and &lt;a href=&quot;https://traefik.io/&quot;&gt;Traefik&lt;/a&gt; can be used as a reverse-proxy server and are very easy to setup. They come with built-in HTTPS support and manage (install and update) TLS certificates transparently and automatically from &lt;a href=&quot;https://letsencrypt.org/&quot;&gt;Let's Encrypt&lt;/a&gt;. However, any web server proxy that has HTTPS support on the front-end will work. To make ipwb replay aware of the proxy, use &lt;code&gt;--proxy&lt;/code&gt; or &lt;code&gt;-P&lt;/code&gt; flag to supply the proxy URL. This way the replay will yield the supplied proxy URL as a prefix when generating various fully qualified domain name (FQDN) URIs or absolute URIs (for example, those in the TimeMap or Link header) instead of the default &lt;code&gt;http://localhost:5000&lt;/code&gt;. This can be necessary when the service is running in a private network or a container and only exposed via a reverse-proxy. Suppose a reverse-proxy server is running and ready to forward all traffic on the &lt;code&gt;https://ipwb.example.com&lt;/code&gt; to the ipwb replay server then the replay can be started as following:</source>
          <target state="translated">&lt;code&gt;localhost&lt;/code&gt; 이외의 도메인 이름으로 실행하려면 가장 쉬운 방법은 HTTPS를 지원하는 역방향 프록시를 사용하는 것입니다. 리플레이 시스템은 URL 재 라우팅 / 재 작성을 위해 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API&quot;&gt;Service Worker&lt;/a&gt; 를 활용하여 &lt;a href=&quot;http://ws-dl.blogspot.com/2012/10/2012-10-10-zombies-in-archives.html&quot;&gt;라이브 유출 (좀비)&lt;/a&gt; 을 방지 합니다. 그러나 보안상의 이유로 많은 웹 브라우저는 도메인이 &lt;code&gt;localhost&lt;/code&gt; 인 경우에만 예외를 제외하고 Service Worker API에 HTTPS를 의무화했습니다 . &lt;a href=&quot;https://caddyserver.com/&quot;&gt;Caddy Server&lt;/a&gt; 및 &lt;a href=&quot;https://traefik.io/&quot;&gt;Traefik&lt;/a&gt; 은 리버스 프록시 서버로 사용할 수 있으며 설정이 매우 쉽습니다. 내장 된 HTTPS 지원과 함께 제공되며 &lt;a href=&quot;https://letsencrypt.org/&quot;&gt;Let 's Encrypt&lt;/a&gt; 에서 투명하고 자동으로 TLS 인증서를 관리 (설치 및 업데이트)합니다.. 그러나 프런트 엔드에서 HTTPS를 지원하는 모든 웹 서버 프록시는 작동합니다. ipwb 재생이 프록시를 인식하도록하려면 &lt;code&gt;--proxy&lt;/code&gt; 또는 &lt;code&gt;-P&lt;/code&gt; 플래그를 사용 하여 프록시 URL을 제공하십시오. 이렇게하면 기본 &lt;code&gt;http://localhost:5000&lt;/code&gt; 대신 다양한 FQDN (정규화 된 도메인 이름) URI 또는 ​​절대 URI (예 : TimeMap 또는 링크 헤더에있는 URI)를 생성 할 때 재생에서 제공된 프록시 URL을 접두사로 생성합니다 . . 이는 서비스가 사설 네트워크 또는 컨테이너에서 실행 중이고 리버스 프록시를 통해서만 노출 될 때 필요할 수 있습니다. 리버스 프록시 서버가 실행 중이고 &lt;code&gt;https://ipwb.example.com&lt;/code&gt; 의 모든 트래픽을 ipwb 재생 서버 로 전달할 준비가 되었다고 가정하면 다음과 같이 재생을 시작할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="57ffd16df72d6eef36ddb2fae5f71afca197b424" translate="yes" xml:space="preserve">
          <source>Usage of sub-commands in ipwb can be accessed through providing the &lt;code&gt;-h&lt;/code&gt; or &lt;code&gt;--help&lt;/code&gt; flag, like any of the below.</source>
          <target state="translated">ipwb의 하위 명령 사용은 아래에서와 같이 &lt;code&gt;-h&lt;/code&gt; 또는 &lt;code&gt;--help&lt;/code&gt; 플래그 를 제공하여 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f1e887ad301db2838308801456e01403dfd27811" translate="yes" xml:space="preserve">
          <source>Using Docker</source>
          <target state="translated">도커 사용</target>
        </trans-unit>
        <trans-unit id="b6df9757d187b07028baf8d27cd4b57a78abedbe" translate="yes" xml:space="preserve">
          <source>We have numerous publications related to this project, but the most significant and primary one was published in TPDL 2016. (&lt;a href=&quot;http://www.cs.odu.edu/%7Emkelly/papers/2016_tpdl_ipwb.pdf&quot;&gt;Read the PDF&lt;/a&gt;)</source>
          <target state="translated">우리는이 프로젝트와 관련된 수많은 출판물을 가지고 있지만 가장 중요하고 주요한 출판물은 TPDL 2016에 출판되었습니다. ( &lt;a href=&quot;http://www.cs.odu.edu/%7Emkelly/papers/2016_tpdl_ipwb.pdf&quot;&gt;PDF 읽기&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="daba946216be60ed41b22da33cd78990c628860e" translate="yes" xml:space="preserve">
          <source>ipwb also supports using an IPFS hash or any HTTP location as the source of the CDXJ:</source>
          <target state="translated">ipwb는 또한 IPFS 해시 또는 모든 HTTP 위치를 CDXJ의 소스로 사용하는 것을 지원합니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
