<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://pypi.org/project/nanaimo/">
    <body>
      <group id="nanaimo">
        <trans-unit id="57b0192c90bade6200f8fe6add2bd92423f9a981" translate="yes" xml:space="preserve">
          <source>A delicious Python treat that makes on-target testing sweet and satisfying.</source>
          <target state="translated">대상 테스트를 달콤하고 만족스럽게 만드는 맛있는 Python 간식.</target>
        </trans-unit>
        <trans-unit id="7e72ab885b6eecaecfbe3c9d5d916b2e1e1ab636" translate="yes" xml:space="preserve">
          <source>Block diagram of Nanaimo&amp;rsquo;s relationship to other components of a typical software build and test pipeline.</source>
          <target state="translated">일반적인 소프트웨어 빌드 및 테스트 파이프 라인의 다른 구성 요소에 대한 Nanaimo의 관계에 대한 블록 다이어그램.</target>
        </trans-unit>
        <trans-unit id="9a5cf9c40036ab923e4b08d4bf75097ac400ff09" translate="yes" xml:space="preserve">
          <source>Example of S32K dev boards attached to Raspberry PI CI workers running the &lt;a href=&quot;https://buildkite.com&quot;&gt;Buildkite&lt;/a&gt; agent and using Nanaimo.</source>
          <target state="translated">&lt;a href=&quot;https://buildkite.com&quot;&gt;Buildkite&lt;/a&gt; 에이전트를 실행하고 Nanaimo를 사용 하는 Raspberry PI CI 작업자에 연결된 S32K 개발 보드의 예입니다 .</target>
        </trans-unit>
        <trans-unit id="e4b9878a6bb4d7ade487215e6a25d783fd1e3a1d" translate="yes" xml:space="preserve">
          <source>Example scenario using Nanaimo to test an I2C driver for a microcontroller.</source>
          <target state="translated">Nanaimo를 사용하여 마이크로 컨트롤러 용 I2C 드라이버를 테스트하는 예제 시나리오.</target>
        </trans-unit>
        <trans-unit id="74dd49bd8ec3e146e66e88c16fcdff760c7dfd12" translate="yes" xml:space="preserve">
          <source>Framework for automating tests involving hardware test fixtures.</source>
          <target state="translated">하드웨어 테스트 픽스처와 관련된 테스트 자동화를위한 프레임 워크입니다.</target>
        </trans-unit>
        <trans-unit id="b3e1ac3d545f8a410b7bcb9a5fd366c4bf888b75" translate="yes" xml:space="preserve">
          <source>Hierarchy of system testing. Nanaimo focuses on part and subassembly testing.</source>
          <target state="translated">시스템 테스트의 계층. Nanaimo는 부품 및 하위 어셈블리 테스트에 중점을 둡니다.</target>
        </trans-unit>
        <trans-unit id="e6fa936c1f8b0374bb1f00c2e7ebcab08335fa24" translate="yes" xml:space="preserve">
          <source>Nanaimo is &lt;em&gt;not&lt;/em&gt; a simulation framework and is not designed to support the complexity of a full hardware-in-the-loop platform.
Instead it&amp;rsquo;s focused on testing small integrations with a few hardware components and instruments using concepts, syntax,
and frameworks familiar to software engineers. Examples of these small integrations might include verifying a SPI driver for a
microcontroller or ensuring the upload time for a serial bootloader meets expected Key-Performance-Indicators (KPIs). To do this
Nanaimo abstractions provide async interfaces to hardware either directly using available communication protocols
(e.g. serial or IP networks) or by invoking a CLI provided by the instrument vendor. Because of this latter use case some
instruments will require additional programs be available in a test environment.</source>
          <target state="translated">나나이모는 &lt;em&gt;하지&lt;/em&gt; 시뮬레이션 프레임 워크와 전체 하드웨어 - 인 - 더 - 루프 플랫폼의 복잡성을 지원하도록 설계되지 않았습니다. 대신 소프트웨어 엔지니어에게 익숙한 개념, 구문 및 프레임 워크를 사용하여 몇 가지 하드웨어 구성 요소 및 도구로 소규모 통합을 테스트하는 데 중점을 둡니다. 이러한 소규모 통합의 예로는 마이크로 컨트롤러 용 SPI 드라이버를 확인하거나 직렬 부트 로더의 업로드 시간이 예상되는 KPI (Key-Performance-Indicators)를 충족하는지 확인하는 것이 포함될 수 있습니다. 이를 위해 Nanaimo 추상화는 사용 가능한 통신 프로토콜 (예 : 직렬 또는 IP 네트워크)을 직접 사용하거나 계측기 공급 업체에서 제공하는 CLI를 호출하여 하드웨어에 비동기 인터페이스를 제공합니다. 후자의 사용 사례로 인해 일부 계측기는 테스트 환경에서 추가 프로그램을 사용할 수 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="14c12ea446b8fb714a267f185c0390be1cf066b4" translate="yes" xml:space="preserve">
          <source>Nanaimo is a set of utilities and plugins designed to enable integration of hardware test apparatuses
with pytest. This can allow on-target tests to run as part of continuous integration pipelines like
&lt;a href=&quot;https://buildkite.com&quot;&gt;Buildkite&lt;/a&gt;, &lt;a href=&quot;https://www.atlassian.com/software/bamboo&quot;&gt;Bamboo&lt;/a&gt;, or &lt;a href=&quot;https://jenkins.io/&quot;&gt;Jenkins&lt;/a&gt;.</source>
          <target state="translated">Nanaimo는 하드웨어 테스트 장치를 pytest와 통합 할 수 있도록 설계된 유틸리티 및 플러그인 세트입니다. 이를 통해 &lt;a href=&quot;https://buildkite.com&quot;&gt;Buildkite&lt;/a&gt; , &lt;a href=&quot;https://www.atlassian.com/software/bamboo&quot;&gt;Bamboo&lt;/a&gt; 또는 &lt;a href=&quot;https://jenkins.io/&quot;&gt;Jenkins&lt;/a&gt; 와 같은 지속적인 통합 파이프 라인의 일부로 대상 테스트를 실행할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a3008905c2e9a32e2b3a3144f0ea7a8f7d1ef964" translate="yes" xml:space="preserve">
          <source>Nanaimo is alpha software and will remain so until we bump its version to 1.0.0 or greater.
We will not knowingly break compatibility within a minor revision but we will break compatibility
a few more times between minor revisions until beta is declared. Because of this you should depend
on a minor version explicitly. For example</source>
          <target state="translated">Nanaimo는 알파 소프트웨어이며 버전을 1.0.0 이상으로 올릴 때까지 그대로 유지됩니다. 우리는 부 개정판 내에서 고의로 호환성을 중단하지는 않지만 베타가 선언 될 때까지 부 개정판간에 호환성을 몇 번 더 중단 할 것입니다. 이 때문에 부 버전에 명시 적으로 의존해야합니다. 예를 들면</target>
        </trans-unit>
        <trans-unit id="9d7cd62b4cca86287dfc6d8d17a3b3d532dc71f3" translate="yes" xml:space="preserve">
          <source>Nanaimo is designed to enable testing of software-defined, physical components in isolation to
provide pre-integration verification of software interfaces and behavioral contracts. It adapts
asynchronous control and monitoring of these components to fit familiar testing idioms
(e.g. x-unit testing) using the popular python test framework, &lt;a href=&quot;https://docs.pytest.org/en/latest/&quot;&gt;pytest&lt;/a&gt;.</source>
          <target state="translated">Nanaimo는 소프트웨어 인터페이스 및 행동 계약의 사전 통합 검증을 제공하기 위해 소프트웨어 정의 물리적 구성 요소를 격리하여 테스트 할 수 있도록 설계되었습니다. 인기있는 Python 테스트 프레임 워크 인 &lt;a href=&quot;https://docs.pytest.org/en/latest/&quot;&gt;pytest를&lt;/a&gt; 사용하여 익숙한 테스트 관용구 (예 : x-unit 테스트)에 맞게 이러한 구성 요소의 비동기 제어 및 모니터링을 조정합니다 .</target>
        </trans-unit>
        <trans-unit id="ab972799d0dfd1ccd4227b35e29e69093098ded9" translate="yes" xml:space="preserve">
          <source>Nanaimo is named after &lt;a href=&quot;https://en.wikipedia.org/wiki/Nanaimo_bar&quot;&gt;Nanaimo bars&lt;/a&gt; which are about the best things humans have ever invented.</source>
          <target state="translated">Nanaimo는 인간이 발명 한 최고의 것들에 관한 &lt;a href=&quot;https://en.wikipedia.org/wiki/Nanaimo_bar&quot;&gt;Nanaimo 바의&lt;/a&gt; 이름을 따서 명명되었습니다 .</target>
        </trans-unit>
        <trans-unit id="2c924e3088204ee77ba681f72be3444357932fca" translate="yes" xml:space="preserve">
          <source>Note</source>
          <target state="translated">노트</target>
        </trans-unit>
        <trans-unit id="d03acb6e4ba3216844800c042f62673952a7e510" translate="yes" xml:space="preserve">
          <source>This design is an amalgam of the &lt;a href=&quot;https://www.youtube.com/watch?v=0BSaI117ITI&quot;&gt;TLYF&lt;/a&gt; (Test Like You Fly) methodology and the &lt;a href=&quot;https://en.wikipedia.org/wiki/Swiss_cheese_model&quot;&gt;Swiss cheese&lt;/a&gt; model of
failure analysis. Specifically; Nanaimo facilitates testing on actual or representative hardware
for the first integration of software into a part or subassembly. Traditionally software engineers were
responsible only for unit-testing and Software-In-the-Loop (SIL) simulation of their code. Nanaimo encourages
software engineers to also provide hardware integration tests by enabling Hardware-In-the-Loop
&lt;a href=&quot;https://en.wikipedia.org/wiki/Continuous_integration&quot;&gt;continuous-integration&lt;/a&gt; (HIL-CI, perhaps?).</source>
          <target state="translated">이 디자인은 &lt;a href=&quot;https://www.youtube.com/watch?v=0BSaI117ITI&quot;&gt;TLYF&lt;/a&gt; (Test Like You Fly) 방법론과 &lt;a href=&quot;https://en.wikipedia.org/wiki/Swiss_cheese_model&quot;&gt;스위스 치즈&lt;/a&gt; 고장 분석 모델의 융합 입니다. 구체적으로 특별히; Nanaimo는 소프트웨어를 부품 또는 서브 어셈블리에 처음 통합하기 위해 실제 또는 대표 하드웨어에 대한 테스트를 용이하게합니다. 전통적으로 소프트웨어 엔지니어는 코드의 단위 테스트 및 SIL (Software-In-the-Loop) 시뮬레이션 만 담당했습니다. Nanaimo는 소프트웨어 엔지니어가 Hardware-In-the-Loop &lt;a href=&quot;https://en.wikipedia.org/wiki/Continuous_integration&quot;&gt;연속 통합&lt;/a&gt; (HIL-CI, 아마도?) 을 활성화하여 하드웨어 통합 테스트를 제공하도록 권장합니다 .</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
