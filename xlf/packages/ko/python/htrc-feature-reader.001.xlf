<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://pypi.org/project/htrc-feature-reader/">
    <body>
      <group id="htrc-feature-reader">
        <trans-unit id="87bc19f00183252413e8eb82a6c9c23b4dfe8d3a" translate="yes" xml:space="preserve">
          <source>&amp;lt;/style&amp;gt;</source>
          <target state="translated">&amp;lt;/ 스타일&amp;gt;</target>
        </trans-unit>
        <trans-unit id="afede0e3a3ca5d7212bbedad27a3729080ec4b68" translate="yes" xml:space="preserve">
          <source>&amp;lt;style scoped&amp;gt;
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }</source>
          <target state="translated">&amp;lt;스타일 범위&amp;gt; .dataframe tbody tr th : only-of-type {vertical-align : middle; }</target>
        </trans-unit>
        <trans-unit id="003e8ecdac1b420ae7fd1fe995fbd5d61cb5ae0c" translate="yes" xml:space="preserve">
          <source>'s</source>
          <target state="translated">'에스</target>
        </trans-unit>
        <trans-unit id="67dacef84d9f3b80a108a5dee2618bf7f5f078f2" translate="yes" xml:space="preserve">
          <source>./■</source>
          <target state="translated">./■</target>
        </trans-unit>
        <trans-unit id="ea1507278b49bc15abff5fe005045d1868439296" translate="yes" xml:space="preserve">
          <source>306 rows &amp;times; 5 columns</source>
          <target state="translated">306 행 &amp;times; 5 열</target>
        </trans-unit>
        <trans-unit id="433fe535cd67d506a1083938b7930ef447772fe3" translate="yes" xml:space="preserve">
          <source>7224 rows &amp;times; 5 columns</source>
          <target state="translated">7224 행 &amp;times; 5 열</target>
        </trans-unit>
        <trans-unit id="c3ef007201656162e84913feecb085da6277a049" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Page.tokenlist()&lt;/code&gt; can be manipulated in various ways. You can case-fold, for example:</source>
          <target state="translated">&lt;code&gt;Page.tokenlist()&lt;/code&gt; 는 다양한 방법으로 조작 할 수 있습니다. 예를 들어 대소 문자를 접을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8d68c0128879bfb2fe79bfa8540550e110739198" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;utils&lt;/code&gt; includes an Rsyncing utility, &lt;code&gt;download_file&lt;/code&gt;. This requires Rsync to be installed on your system.</source>
          <target state="translated">&lt;code&gt;utils&lt;/code&gt; 에는 Rsyncing 유틸리티 인 &lt;code&gt;download_file&lt;/code&gt; 이 포함 됩니다. 이를 위해서는 시스템에 Rsync를 설치해야합니다.</target>
        </trans-unit>
        <trans-unit id="9b2d7376e05cc9d6c6ecbd79a73a127400a34823" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;At large-scales, using &lt;code&gt;vol.metadata&lt;/code&gt; is an impolite and inefficient amount of server pinging; there are better ways to query the API than one volume at a time. Read about the &lt;a href=&quot;https://wiki.htrc.illinois.edu/display/COM/Solr+Proxy+API+User+Guide&quot;&gt;HTRC Solr Proxy&lt;/a&gt;.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;대규모에서 &lt;code&gt;vol.metadata&lt;/code&gt; 를 사용하는 것은 무례하고 비효율적 인 서버 핑입니다. 한 번에 하나의 볼륨보다 API를 쿼리하는 더 좋은 방법이 있습니다. &lt;a href=&quot;https://wiki.htrc.illinois.edu/display/COM/Solr+Proxy+API+User+Guide&quot;&gt;HTRC Solr 프록시&lt;/a&gt; 에 대해 읽어보십시오 .&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="416bcb36ff6301d2231c9ecd303a0e9d3df50aea" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note: for new Python users, a more in-depth lesson is published by Programming Historian: &lt;a href=&quot;http://programminghistorian.org/lessons/text-mining-with-extracted-features&quot;&gt;Text Mining in Python through the HTRC Feature Reader&lt;/a&gt;. That lesson is also the official citation associated the HTRC Feature Reader library.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;참고 : Python을 처음 사용하는 경우 Programming Historian : &lt;a href=&quot;http://programminghistorian.org/lessons/text-mining-with-extracted-features&quot;&gt;Text Mining in Python이 HTRC Feature Reader를 통해&lt;/a&gt; 더 심층적 인 강의를 게시합니다 . 이 강의는 HTRC Feature Reader 라이브러리와 관련된 공식 인용이기도합니다.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="07e936c942a5ceed306232e3cec0961d2ddc9f92" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;http://hdl.handle.net/2027/hvd.32044093320364&quot;&gt;The Nautilus.&lt;/a&gt;&lt;/strong&gt; by &lt;em&gt;Delaware Museum of Natural History.&lt;/em&gt; (1904, 222 pages) - &lt;code&gt;hvd.32044093320364&lt;/code&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;http://hdl.handle.net/2027/hvd.32044093320364&quot;&gt;노틸러스. &lt;/a&gt;&lt;/strong&gt;에 의해&lt;em&gt; 자연사의 델라웨어 박물관. &lt;/em&gt;(1904, 222 페이지) &lt;code&gt;hvd.32044093320364&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c41a4659c40bd15632a7e8806e8e3ce5b388ab34" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Citation&lt;/strong&gt;:
Peter Organisciak and Boris Capitanu, &quot;Text Mining in Python through the HTRC Feature Reader,&quot; &lt;em&gt;Programming Historian&lt;/em&gt;, (22 November 2016), &lt;a href=&quot;http://programminghistorian.org/lessons/text-mining-with-extracted-features&quot;&gt;http://programminghistorian.org/lessons/text-mining-with-extracted-features&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;인용&lt;/strong&gt; : Peter Organisciak 및 Boris Capitanu, &quot;HTRC 기능 리더를 통한 Python의 텍스트 마이닝&quot;, &lt;em&gt;Programming Historian&lt;/em&gt; , (2016 년 11 월 22 일), &lt;a href=&quot;http://programminghistorian.org/lessons/text-mining-with-extracted-features&quot;&gt;http://programminghistorian.org/lessons/text-mining-with-extracted-features&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5476bb3bb13d2380e847653a9afc0e28d14a47cf" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Links&lt;/strong&gt;:
&lt;a href=&quot;http://htrc.github.io/htrc-feature-reader/htrc_features/feature_reader.m.html&quot;&gt;HTRC Feature Reader Documentation&lt;/a&gt; | &lt;a href=&quot;https://sharc.hathitrust.org/features&quot;&gt;HTRC Extracted Features Dataset&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;링크&lt;/strong&gt; : &lt;a href=&quot;http://htrc.github.io/htrc-feature-reader/htrc_features/feature_reader.m.html&quot;&gt;HTRC 기능 판독기 문서&lt;/a&gt; | &lt;a href=&quot;https://sharc.hathitrust.org/features&quot;&gt;HTRC 추출 기능 데이터 세트&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d9a3ddefe5ed3e828226208c90c4496d2ab1887f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table of Contents&lt;/strong&gt;: &lt;a href=&quot;#Installation&quot;&gt;Installation&lt;/a&gt; | &lt;a href=&quot;#Usage&quot;&gt;Usage&lt;/a&gt; |
&lt;a href=&quot;#Additional-Notes&quot;&gt;Additional Notes&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;목차&lt;/strong&gt; : &lt;a href=&quot;#Installation&quot;&gt;설치&lt;/a&gt; | &lt;a href=&quot;#Usage&quot;&gt;사용법&lt;/a&gt; | &lt;a href=&quot;#Additional-Notes&quot;&gt;추가 참고 사항&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9188873b53a0860b8d45c86992acf0ce33ebbec3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Usage:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;용법:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c851d517207a4cb44c26e047844f03c194a52184" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;http://htrc.github.io/htrc-feature-reader/htrc_features/feature_reader.m.html#htrc_features.feature_reader.Volume&quot;&gt;Volume&lt;/a&gt; contains information about the current work and access to the pages of the work. All the metadata fields from the HTRC JSON file are accessible as properties of the volume object, including &lt;em&gt;title&lt;/em&gt;, &lt;em&gt;language&lt;/em&gt;, &lt;em&gt;imprint&lt;/em&gt;, &lt;em&gt;oclc&lt;/em&gt;, &lt;em&gt;pubDate&lt;/em&gt;, and &lt;em&gt;genre&lt;/em&gt;. The main identifier &lt;em&gt;id&lt;/em&gt; and &lt;em&gt;pageCount&lt;/em&gt; are also accessible, and you can find the URL for the Full View of the text in the HathiTrust Digital Library - if it exists - with &lt;code&gt;vol.handle_url&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://htrc.github.io/htrc-feature-reader/htrc_features/feature_reader.m.html#htrc_features.feature_reader.Volume&quot;&gt;볼륨이&lt;/a&gt; 작품의 페이지에 현재 작업 및 액세스에 대한 정보가 포함되어 있습니다. HTRC JSON 파일의 모든 메타 데이터 필드는 &lt;em&gt;title&lt;/em&gt; , &lt;em&gt;language&lt;/em&gt; , &lt;em&gt;imprint&lt;/em&gt; , &lt;em&gt;oclc&lt;/em&gt; , &lt;em&gt;pubDate&lt;/em&gt; 및 &lt;em&gt;genre를&lt;/em&gt; 포함하여 볼륨 객체의 속성으로 액세스 할 수 있습니다 . 주요 식별자 &lt;em&gt;ID&lt;/em&gt; 및 &lt;em&gt;PAGECOUNT은&lt;/em&gt; 또한 액세스 할 수 있습니다, 당신은 HathiTrust 디지털 도서관에있는 텍스트의 전체보기의 URL을 찾을 수 있습니다 -이 존재하는 경우 - 함께 &lt;code&gt;vol.handle_url&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a6886107051f6296b301c835737605aa7c616a6a" translate="yes" xml:space="preserve">
          <source>Additional Notes</source>
          <target state="translated">추가 사항</target>
        </trans-unit>
        <trans-unit id="96731dbaea6a5720dd33b64dc334ff765eec736a" translate="yes" xml:space="preserve">
          <source>Advanced Features</source>
          <target state="translated">고급 기능</target>
        </trans-unit>
        <trans-unit id="7f0c23b86b79910cc63214a4b8c83c7295562cc4" translate="yes" xml:space="preserve">
          <source>Alternately, if you are using &lt;a href=&quot;https://www.continuum.io/downloads&quot;&gt;Anaconda&lt;/a&gt;, you can install with</source>
          <target state="translated">또는 &lt;a href=&quot;https://www.continuum.io/downloads&quot;&gt;Anaconda&lt;/a&gt; 를 사용하는 경우 다음을 사용하여 설치할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6eaed3cac79e1bce937e239632dd82e6b8006709" translate="yes" xml:space="preserve">
          <source>Another source of bibliographic metadata is the HathiTrust Bib API. You can access this information through the URL returned with &lt;code&gt;vol.ht_bib_url&lt;/code&gt;:</source>
          <target state="translated">서지 메타 데이터의 또 다른 소스는 HathiTrust Bib API입니다. &lt;code&gt;vol.ht_bib_url&lt;/code&gt; 로 반환 된 URL을 통해이 정보에 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="029f38c0d787134ba890f16093c2f641f6bb0bf2" translate="yes" xml:space="preserve">
          <source>As an alternative to multiprocessing in Python, my preference is to have simpler Python scripts and to use GNU Parallel on the command line. To do this, you can set up your Python script to take variable length arguments of feature file paths, and to print to stdout.</source>
          <target state="translated">Python의 다중 처리에 대한 대안으로, 필자는 더 간단한 Python 스크립트를 사용하고 명령 줄에서 GNU Parallel을 사용하는 것을 선호합니다. 이를 위해 기능 파일 경로의 가변 길이 인수를 취하고 stdout으로 인쇄하도록 Python 스크립트를 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="07306c8e3c85378f3f7ab169c6863cdf220910c0" translate="yes" xml:space="preserve">
          <source>CD</source>
          <target state="translated">CD</target>
        </trans-unit>
        <trans-unit id="e1385c29827c0421d323ac9f4284e20d06fd3c59" translate="yes" xml:space="preserve">
          <source>Chunking</source>
          <target state="translated">청킹</target>
        </trans-unit>
        <trans-unit id="f91a09d0814557a6167b7b78507532901eab44a1" translate="yes" xml:space="preserve">
          <source>DT</source>
          <target state="translated">DT</target>
        </trans-unit>
        <trans-unit id="b6efff04d7c735dcf31793d3bfabc3f0aef11663" translate="yes" xml:space="preserve">
          <source>Dask</source>
          <target state="translated">Dask</target>
        </trans-unit>
        <trans-unit id="50cfccc911dd97063a4eb00c401c036b0d2dc15d" translate="yes" xml:space="preserve">
          <source>Dask offers easy multithreading (shared resources) and multiprocessing (separate processes) in Python, and is particularly convenient because it includes a subset of Pandas DataFrames.</source>
          <target state="translated">Dask는 Python에서 손쉬운 멀티 스레딩 (공유 리소스) 및 멀티 프로세싱 (개별 프로세스)을 제공하며 Pandas DataFrames의 하위 집합을 포함하기 때문에 특히 편리합니다.</target>
        </trans-unit>
        <trans-unit id="1264015efbf29b7f67293b2dc8298b498825f377" translate="yes" xml:space="preserve">
          <source>Download file to &lt;code&gt;/tmp&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;/tmp&lt;/code&gt; 에 파일 다운로드 :</target>
        </trans-unit>
        <trans-unit id="4a9b3aea8e4b96c56e52012de11cb17a8c3187c4" translate="yes" xml:space="preserve">
          <source>Download file to current directory, keeping pairtree directory structure,
i.e. &lt;code&gt;./nyp/pairtree_root/33/43/30/42/06/88/94/33433042068894/nyp.33433042068894.json.bz2&lt;/code&gt;:</source>
          <target state="translated">현재 디렉토리에 파일 다운로드, 유지 pairtree 디렉토리 구조, 즉 &lt;code&gt;./nyp/pairtree_root/33/43/30/42/06/88/94/33433042068894/nyp.33433042068894.json.bz2&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="38235dda0ea47850c583348dd0c2bcc996cf7c7f" translate="yes" xml:space="preserve">
          <source>Download multiple files to the current directory:</source>
          <target state="translated">현재 디렉토리에 여러 파일을 다운로드합니다.</target>
        </trans-unit>
        <trans-unit id="3ed0760cf54b5819c55660a736afe99c9b913074" translate="yes" xml:space="preserve">
          <source>Download one file to the current directory:</source>
          <target state="translated">현재 디렉토리에 하나의 파일을 다운로드합니다.</target>
        </trans-unit>
        <trans-unit id="0d10d3078a5ca648cbaee5d9b0e2982369b5d2ee" translate="yes" xml:space="preserve">
          <source>Downloading files within the library</source>
          <target state="translated">라이브러리 내 파일 다운로드</target>
        </trans-unit>
        <trans-unit id="2cf2cae341b34974add298d8a60bfdfefd9bb964" translate="yes" xml:space="preserve">
          <source>For example, I have a small collection of knitting-related books at &lt;a href=&quot;https://babel.hathitrust.org/cgi/mb?a=listis&amp;amp;c=1174943610&quot;&gt;https://babel.hathitrust.org/cgi/mb?a=listis&amp;amp;c=1174943610&lt;/a&gt;. To read the feature files for those books:</source>
          <target state="translated">예를 들어, &lt;a href=&quot;https://babel.hathitrust.org/cgi/mb?a=listis&amp;amp;c=1174943610&quot;&gt;https://babel.hathitrust.org/cgi/mb?a=listis&amp;amp;c=1174943610&lt;/a&gt; 에 뜨개질 관련 책의 작은 컬렉션이 있습니다 . 해당 책의 기능 파일을 읽으려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="81a17a639598c59e5845f7b0300e0d5999c6fb94" translate="yes" xml:space="preserve">
          <source>For large jobs, you'll want to use multiprocessing or multithreading to speed up your process. This is left up to your preferred method, either within Python or by spawning multiple scripts from the command line. Here are two approaches that I like.</source>
          <target state="translated">대규모 작업의 경우 멀티 프로세싱 또는 멀티 스레딩을 사용하여 프로세스 속도를 높일 수 있습니다. 이것은 Python 내에서 또는 명령 줄에서 여러 스크립트를 생성하여 선호하는 방법에 달려 있습니다. 내가 좋아하는 두 가지 접근 방식이 있습니다.</target>
        </trans-unit>
        <trans-unit id="f21ecd5fdbaaca4a9b6ad407e43e4a149da7aa62" translate="yes" xml:space="preserve">
          <source>GNU Parallel</source>
          <target state="translated">GNU 병렬</target>
        </trans-unit>
        <trans-unit id="68f973a9feea4b5bc4dd6689c9c9ca1c92bcb67e" translate="yes" xml:space="preserve">
          <source>Given the nature of data analysis, using iPython with Jupyter notebooks for preparing your scripts interactively is a recommended convenience. Most basically, it can be installed with &lt;code&gt;pip install ipython[notebook]&lt;/code&gt; and run with &lt;code&gt;ipython notebook&lt;/code&gt; from the command line, which starts a session that you can access through your browser. If this doesn't work, consult the &lt;a href=&quot;http://ipython.readthedocs.org/&quot;&gt;iPython documentation&lt;/a&gt;.</source>
          <target state="translated">데이터 분석의 특성을 고려할 때 대화식으로 스크립트를 준비하기 위해 Jupyter 노트북과 함께 iPython을 사용하는 것이 좋습니다. 기본적으로 &lt;code&gt;pip install ipython[notebook]&lt;/code&gt; 하고 명령 줄에서 &lt;code&gt;ipython notebook&lt;/code&gt; 실행 하면 브라우저를 통해 액세스 할 수있는 세션이 시작됩니다. 그래도 작동하지 않으면 &lt;a href=&quot;http://ipython.readthedocs.org/&quot;&gt;iPython 문서를&lt;/a&gt; 참조하세요 .</target>
        </trans-unit>
        <trans-unit id="d282dbace5af388a2d1ef11a90ba64e6190ff04e" translate="yes" xml:space="preserve">
          <source>HTRC-Features</source>
          <target state="translated">HTRC 기능</target>
        </trans-unit>
        <trans-unit id="d5dd3ebaf0dcdf5fed49bcc0ae4a80bd8007e1cf" translate="yes" xml:space="preserve">
          <source>Here is a minimal example, that lazily loads token frequencies from a list of volume IDs, and counts them up by part of speech tag.</source>
          <target state="translated">다음은 볼륨 ID 목록에서 토큰 주파수를 느리게로드하고 음성 태그의 일부로 계산하는 최소한의 예입니다.</target>
        </trans-unit>
        <trans-unit id="93b10e38d636e462fe33e63b5955a8b186c681e3" translate="yes" xml:space="preserve">
          <source>Here is an example of 78 volumes being processed in 24 seconds with 31 threads:</source>
          <target state="translated">다음은 31 개의 스레드가있는 78 개의 볼륨이 24 초 내에 처리되는 예입니다.</target>
        </trans-unit>
        <trans-unit id="ca73ab65568cd125c2d27a22bbd9e863c10b675d" translate="yes" xml:space="preserve">
          <source>I</source>
          <target state="translated">나는</target>
        </trans-unit>
        <trans-unit id="6fca55ca3c828a46bfe96a10e69f572b61ce540c" translate="yes" xml:space="preserve">
          <source>IN</source>
          <target state="translated">에</target>
        </trans-unit>
        <trans-unit id="90d3dc02297a94d44de8b13e4466acb5a921f43d" translate="yes" xml:space="preserve">
          <source>If the minimal metadata included with the extracted feature files is insufficient, you can fetch HT's metadata record from the Bib API with &lt;code&gt;vol.metadata&lt;/code&gt;.
Remember that this calls the HTRC servers for each volume, so can add considerable overhead. The result is a MARC file, returned as a &lt;a href=&quot;https://github.com/edsu/pymarc&quot;&gt;pymarc&lt;/a&gt; record object. For example, to get the publisher information from field &lt;code&gt;260&lt;/code&gt;:</source>
          <target state="translated">추출 된 기능 파일에 포함 된 최소 메타 데이터가 충분하지 않은 경우 &lt;code&gt;vol.metadata&lt;/code&gt; 를 사용하여 Bib API에서 HT의 메타 데이터 레코드를 가져올 수 있습니다 . 이렇게하면 각 볼륨에 대해 HTRC 서버가 호출되므로 상당한 오버 헤드가 추가 될 수 있습니다. 결과는 &lt;a href=&quot;https://github.com/edsu/pymarc&quot;&gt;pymarc&lt;/a&gt; 레코드 객체 로 반환되는 MARC 파일 입니다. 예를 들어 필드 &lt;code&gt;260&lt;/code&gt; 에서 게시자 정보를 가져 오려면 다음을 수행하십시오 .</target>
        </trans-unit>
        <trans-unit id="eed3736c3db792fd2dfdcfa9a885cfc7b9851a99" translate="yes" xml:space="preserve">
          <source>If you are new to Pandas DataFrames, you might find it easier to learn by converting the index to columns.</source>
          <target state="translated">Pandas DataFrames를 처음 사용하는 경우 인덱스를 열로 변환하면 더 쉽게 배울 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f52774b9357f2e22de5c858d650f25851d10362c" translate="yes" xml:space="preserve">
          <source>If you find a bug, leave an issue on the issue tracker, or contact Peter Organisciak at &lt;code&gt;organisciak+htrc@gmail.com&lt;/code&gt;.</source>
          <target state="translated">버그를 발견하면 문제 추적기에 문제를 남기거나 &lt;code&gt;organisciak+htrc@gmail.com&lt;/code&gt; 으로 Peter Organisciak에게 문의하십시오 .</target>
        </trans-unit>
        <trans-unit id="04dfefec30372e6a1fbf113c7ba075013cf365bc" translate="yes" xml:space="preserve">
          <source>If you need to do fast, highly customized processing without instantiating Volumes, FeatureReader has a convenient generator for getting the raw JSON as a Python dict: &lt;code&gt;fr.jsons()&lt;/code&gt;. This simply does the file reading, optional decompression, and JSON parsing.</source>
          <target state="translated">볼륨을 인스턴스화하지 않고 빠르고 고도로 사용자 정의 된 처리를 수행해야하는 경우 FeatureReader에는 원시 JSON을 Python dict : &lt;code&gt;fr.jsons()&lt;/code&gt; 로 가져 오는 편리한 생성기가 있습니다. 이것은 단순히 파일 읽기, 선택적 압축 해제 및 JSON 구문 분석을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="c2851f9011cd17b932353240bc4e1296a5f7a1ac" translate="yes" xml:space="preserve">
          <source>If you prefer not to use Pandas, you can always convert the object, with methods like &lt;code&gt;to_dict&lt;/code&gt; and &lt;code&gt;to_csv&lt;/code&gt;).</source>
          <target state="translated">Pandas를 사용하지 않으려면 항상 &lt;code&gt;to_dict&lt;/code&gt; 및 &lt;code&gt;to_csv&lt;/code&gt; 와 같은 메서드를 사용하여 객체를 변환 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="982b90469b135de044831c080c97b62d0ae9c8bc" translate="yes" xml:space="preserve">
          <source>If you're working in an instance where you hope to have comparably sized document units, you can use 'chunking' to roll pages into chunks that aim for a specific length. e.g.</source>
          <target state="translated">비슷한 크기의 문서 단위를 원하는 인스턴스에서 작업하는 경우 '청크'를 사용하여 특정 길이를 목표로하는 청크로 페이지를 롤링 할 수 있습니다. 예 :</target>
        </trans-unit>
        <trans-unit id="0f305fb83ab49b636b8899ce09d7178858e7f081" translate="yes" xml:space="preserve">
          <source>In addition to token lists, you can also access other section features:</source>
          <target state="translated">토큰 목록 외에도 다른 섹션 기능에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="81f5e23e25fc4569e6aa5f0965cb810966dae6ec" translate="yes" xml:space="preserve">
          <source>In the beta Extracted Features release, schema 2.0, a few features were separated out to an advanced files. However, &lt;em&gt;this designation is no longer present starting with schema 3.0&lt;/em&gt;, meaning information like &lt;code&gt;beginLineChars&lt;/code&gt;, &lt;code&gt;endLineChars&lt;/code&gt;, and &lt;code&gt;capAlphaSeq&lt;/code&gt; are always available:</source>
          <target state="translated">베타 추출 된 기능 릴리스 인 스키마 2.0에서는 몇 가지 기능이 고급 파일로 분리되었습니다. 그러나 &lt;em&gt;이 지정 스키마 3.0 더 이상 존재 시작하지&lt;/em&gt; , 같은 의미 정보 &lt;code&gt;beginLineChars&lt;/code&gt; , &lt;code&gt;endLineChars&lt;/code&gt; 는 , 그리고 &lt;code&gt;capAlphaSeq&lt;/code&gt; 는 항상 사용할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="c81b79df3c6448eae7c4f80428b54cd5692a17d7" translate="yes" xml:space="preserve">
          <source>Installation</source>
          <target state="translated">설치</target>
        </trans-unit>
        <trans-unit id="c2880c0c7b9f92a492fcc9e1562593a3e93bb68d" translate="yes" xml:space="preserve">
          <source>Installing the development version</source>
          <target state="translated">개발 버전 설치</target>
        </trans-unit>
        <trans-unit id="541665228f57c1cb7675e7544c1c689d3f6fe067" translate="yes" xml:space="preserve">
          <source>Iterating through the JSON files</source>
          <target state="translated">JSON 파일 반복</target>
        </trans-unit>
        <trans-unit id="9dc9cf66ca19cda7deb2495273c2f4b273012b0b" translate="yes" xml:space="preserve">
          <source>JJ</source>
          <target state="translated">JJ</target>
        </trans-unit>
        <trans-unit id="99ea919be07e6f0a046557e510daaccf61e4bc14" translate="yes" xml:space="preserve">
          <source>Library for working with the HTRC Extracted Features dataset</source>
          <target state="translated">HTRC 추출 기능 데이터 세트 작업을위한 라이브러리</target>
        </trans-unit>
        <trans-unit id="e066dc148a3af0bb86ed9438d432a81402e778bd" translate="yes" xml:space="preserve">
          <source>MD</source>
          <target state="translated">MD</target>
        </trans-unit>
        <trans-unit id="96190b7f4720658e5967da735c93383fef2ada5b" translate="yes" xml:space="preserve">
          <source>Multiprocessing</source>
          <target state="translated">다중 처리</target>
        </trans-unit>
        <trans-unit id="8ac00a7e70abeeaf254830eb6d9428e78c8d7ef4" translate="yes" xml:space="preserve">
          <source>NN</source>
          <target state="translated">NN</target>
        </trans-unit>
        <trans-unit id="e744f9f9ccd9448f53314855064b228492f0208e" translate="yes" xml:space="preserve">
          <source>NNP</source>
          <target state="translated">NNP</target>
        </trans-unit>
        <trans-unit id="03d8bca4a3184ac195c925074c2501025bb7defc" translate="yes" xml:space="preserve">
          <source>NON-RECEIPT</source>
          <target state="translated">수령 불가</target>
        </trans-unit>
        <trans-unit id="4e6bfbc2825d868636580f961e0cdf316cfe87f3" translate="yes" xml:space="preserve">
          <source>Note that for the most part, the properties of the &lt;code&gt;Page&lt;/code&gt; and &lt;code&gt;Volume&lt;/code&gt; objects aligns with the names in the HTRC Extracted Features schema, except they are converted to follow &lt;a href=&quot;https://google.github.io/styleguide/pyguide.html?showone=Naming#Naming&quot;&gt;Python naming conventions&lt;/a&gt;: converting the &lt;code&gt;CamelCase&lt;/code&gt; of the schema to &lt;code&gt;lowercase_with_underscores&lt;/code&gt;. E.g. &lt;code&gt;beginLineChars&lt;/code&gt; from the HTRC data is accessible as &lt;code&gt;Page.begin_line_chars&lt;/code&gt;.</source>
          <target state="translated">대부분의 경우 &lt;code&gt;Page&lt;/code&gt; 및 &lt;code&gt;Volume&lt;/code&gt; 객체 의 속성은 HTRC Extracted Features 스키마의 이름과 일치합니다. 단, &lt;a href=&quot;https://google.github.io/styleguide/pyguide.html?showone=Naming#Naming&quot;&gt;Python 명명 규칙 (&lt;/a&gt; 스키마 의 &lt;code&gt;CamelCase&lt;/code&gt; 를 &lt;code&gt;lowercase_with_underscores&lt;/code&gt; 로 변환)을 따르도록 변환된다는 점이 다릅니다 . 예 &lt;code&gt;beginLineChars&lt;/code&gt; HTRC 데이터로부터는 액세스 할 수 &lt;code&gt;Page.begin_line_chars&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3ab5a3954f0a73146dbf941395929645f9ef50fb" translate="yes" xml:space="preserve">
          <source>Optional: &lt;a href=&quot;#Installing-the-development-version&quot;&gt;installing the development version&lt;/a&gt;.</source>
          <target state="translated">선택 사항 : &lt;a href=&quot;#Installing-the-development-version&quot;&gt;개발 버전 설치&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="76eea2a471064e28d641094af0136a5d2873ffbe" translate="yes" xml:space="preserve">
          <source>Or, you can combine part of speech counts into a single integer.</source>
          <target state="translated">또는 일부 품사 수를 단일 정수로 결합 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a0bf5a7de38282d432d1015168f21b2d5caf2796" translate="yes" xml:space="preserve">
          <source>Other extracted features are discussed below.</source>
          <target state="translated">추출 된 다른 기능은 아래에서 설명합니다.</target>
        </trans-unit>
        <trans-unit id="bc46ff4c45a29fd18ab5e4aa434a97ddd6b864b0" translate="yes" xml:space="preserve">
          <source>PRP</source>
          <target state="translated">PRP</target>
        </trans-unit>
        <trans-unit id="5505cf54f2c8243f4ffe570191e5f5ae033ba15a" translate="yes" xml:space="preserve">
          <source>Perhaps</source>
          <target state="translated">혹시</target>
        </trans-unit>
        <trans-unit id="4e758230baa6bec744e55b3035f865f95efb89c6" translate="yes" xml:space="preserve">
          <source>Reading feature files</source>
          <target state="translated">기능 파일 읽기</target>
        </trans-unit>
        <trans-unit id="4b0ac5b5c90e60f16137500ab314cd89de08b8a4" translate="yes" xml:space="preserve">
          <source>Remember that for large jobs, it is faster to download your dataset beforehand, using the &lt;code&gt;rsync&lt;/code&gt; method.</source>
          <target state="translated">대규모 작업의 경우 &lt;code&gt;rsync&lt;/code&gt; 메서드를 사용하여 데이터 세트를 미리 다운로드하는 것이 더 빠릅니다 .</target>
        </trans-unit>
        <trans-unit id="93493978f42f7f7e555c48b52945610a2a0231a3" translate="yes" xml:space="preserve">
          <source>Section arguments are valid here: 'header', 'body', 'footer', 'all', and 'group'</source>
          <target state="translated">섹션 인수는 'header', 'body', 'footer', 'all'및 'group'에서 유효합니다.</target>
        </trans-unit>
        <trans-unit id="941629c3c0df54f67ec83413c3aea6d60222b91e" translate="yes" xml:space="preserve">
          <source>See the &lt;a href=&quot;examples/ID_to_Rsync_Link.ipynb&quot;&gt;ID to Rsync notebook&lt;/a&gt; for more information on this format and on Rsyncing lists of urls.</source>
          <target state="translated">이 형식 및 Rsyncing url 목록에 대한 자세한 내용은 &lt;a href=&quot;examples/ID_to_Rsync_Link.ipynb&quot;&gt;Rsync 노트북&lt;/a&gt; 의 ID를 참조하세요 .</target>
        </trans-unit>
        <trans-unit id="0820b32b206b7352858e8903a838ed14319acdfd" translate="yes" xml:space="preserve">
          <source>Testing</source>
          <target state="translated">테스팅</target>
        </trans-unit>
        <trans-unit id="293f0e44e9bf4fbba89798877ba5d4999e4ac217" translate="yes" xml:space="preserve">
          <source>That's it! This library is written for Python 3.0+. For Python beginners, you'll need &lt;a href=&quot;https://pip.pypa.io/en/stable/installing/&quot;&gt;pip&lt;/a&gt;.</source>
          <target state="translated">그게 다야! 이 라이브러리는 Python 3.0 이상용으로 작성되었습니다. Python 초보자에게는 &lt;a href=&quot;https://pip.pypa.io/en/stable/installing/&quot;&gt;pip&lt;/a&gt; 가 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="93ef0dd827103681fcee453b78be2ff14e1a261d" translate="yes" xml:space="preserve">
          <source>The</source>
          <target state="translated">그만큼</target>
        </trans-unit>
        <trans-unit id="fd35bb32b8a218ad71b7087ca3d7342b2f2c8eda" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;conda&lt;/code&gt; approach is recommended, because it makes sure that some of the hard-to-install dependencies are properly installed.</source>
          <target state="translated">&lt;code&gt;conda&lt;/code&gt; 이 하드에 설치 종속성 일부가 제대로 설치되어 있는지 만들기 때문에 접근이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="896bdac9df4e39b2496892f4b69d870e16f60469" translate="yes" xml:space="preserve">
          <source>The FeatureReader can also download files at read time, by reference to a HathiTrust volume id. For example, if I want &lt;a href=&quot;https://catalog.hathitrust.org/Record/100323335&quot;&gt;both of volumes of Pride and Prejudice&lt;/a&gt;, I can see that the URLs are babel.hathitrust.org/cgi/pt?id=&lt;strong&gt;hvd.32044013656053&lt;/strong&gt; and babel.hathitrust.org/cgi/pt?id=&lt;strong&gt;hvd.32044013656061&lt;/strong&gt;. In the FeatureReader, these can be called with the &lt;code&gt;ids=[]&lt;/code&gt; argument, as follows:</source>
          <target state="translated">FeatureReader는 HathiTrust 볼륨 ID를 참조하여 읽기 시간에 파일을 다운로드 할 수도 있습니다. 예를 들어 &lt;a href=&quot;https://catalog.hathitrust.org/Record/100323335&quot;&gt;Pride와 Prejudice를 모두&lt;/a&gt; 원하는 경우 URL이 babel.hathitrust.org/cgi/pt?id= &lt;strong&gt;hvd.32044013656053&lt;/strong&gt; 및 babel.hathitrust.org/cgi/pt?id= &lt;strong&gt;hvd&lt;/strong&gt; 임을 &lt;strong&gt;알 수 있습니다. 0.32044013656061&lt;/strong&gt; . FeatureReader에서 다음과 같이 &lt;code&gt;ids=[]&lt;/code&gt; 인수를 사용하여 호출 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1ec5a7d9eb6987be863ef242349da1b0f7819d79" translate="yes" xml:space="preserve">
          <source>The MultiIndex makes it easy to slice the results, and it is althogether more memory-efficient. For example, to return just the nouns (&lt;code&gt;NN&lt;/code&gt;):</source>
          <target state="translated">MultiIndex를 사용하면 결과를 쉽게 분할 할 수 있으며 메모리 효율성이 더욱 향상됩니다. 예를 들어 명사 ( &lt;code&gt;NN&lt;/code&gt; ) 만 반환하려면 :</target>
        </trans-unit>
        <trans-unit id="e692516909d23f09aa67e1e2b96fe107effe6c5f" translate="yes" xml:space="preserve">
          <source>The easiest way to start using this library is to use the Volume interface, which takes a path to an Extracted Features file.</source>
          <target state="translated">이 라이브러리 사용을 시작하는 가장 쉬운 방법은 추출 된 기능 파일의 경로를 사용하는 볼륨 인터페이스를 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="15d1d7e3080e1c1f5a4685907d23ea107594352d" translate="yes" xml:space="preserve">
          <source>The full included metadata can be seen with &lt;code&gt;vol.parser.meta&lt;/code&gt;:</source>
          <target state="translated">포함 된 전체 메타 데이터는 &lt;code&gt;vol.parser.meta&lt;/code&gt; 에서 볼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3cd7bff8af23f6ab9cb8c70611b1c3c5657df5d9" translate="yes" xml:space="preserve">
          <source>The fun stuff: playing with token counts and character counts</source>
          <target state="translated">재미있는 것 : 토큰 수와 캐릭터 수를 가지고 놀기</target>
        </trans-unit>
        <trans-unit id="2e13755ac0e212eee6f1e55b80a480f0efce8190" translate="yes" xml:space="preserve">
          <source>The token count information is returned as a DataFrame with a MultiIndex (page, section, token, and part of speech) and one column (count).</source>
          <target state="translated">토큰 개수 정보는 MultiIndex (페이지, 섹션, 토큰 및 품사)와 하나의 열 (개수)이있는 DataFrame으로 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="740458f4a852a909783f0924ec794ea132eeb2ab" translate="yes" xml:space="preserve">
          <source>There is also a command line utility installed with the HTRC Feature Reader:</source>
          <target state="translated">HTRC Feature Reader와 함께 설치된 명령 줄 유틸리티도 있습니다.</target>
        </trans-unit>
        <trans-unit id="e6f76b5af135b5adc69f5cedeae12d528aab67ec" translate="yes" xml:space="preserve">
          <source>These fields are mapped to attributes in &lt;code&gt;Volume&lt;/code&gt;, so &lt;code&gt;vol.oclc&lt;/code&gt; will return the oclc field from that metadata. As a convenience, &lt;code&gt;Volume.year&lt;/code&gt; returns the &lt;code&gt;pub_date&lt;/code&gt; information and &lt;code&gt;Volume.author&lt;/code&gt; returns the &lt;code&gt;contributor information&lt;/code&gt;.</source>
          <target state="translated">이러한 필드는 &lt;code&gt;Volume&lt;/code&gt; 의 속성에 매핑 되므로 &lt;code&gt;vol.oclc&lt;/code&gt; 는 해당 메타 데이터에서 oclc 필드를 반환합니다. 편의상 &lt;code&gt;Volume.year&lt;/code&gt; 는 &lt;code&gt;pub_date&lt;/code&gt; 정보를 반환 하고 &lt;code&gt;Volume.author&lt;/code&gt; 는 &lt;code&gt;contributor information&lt;/code&gt; 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="79e4c70b317f6af34dc53f646d60c76f1aa3aef4" translate="yes" xml:space="preserve">
          <source>This downloads the file temporarily, using the HTRC's web-based download link (e.g. &lt;a href=&quot;https://data.analytics.hathitrust.org/features/get?download-id=%7B%7BURL%7D%7D&quot;&gt;https://data.analytics.hathitrust.org/features/get?download-id={{URL}}&lt;/a&gt;). One good pairing with this feature is the &lt;a href=&quot;https://github.com/htrc/HTRC-PythonSDK&quot;&gt;HTRC Python SDK&lt;/a&gt;'s functionality for downloading collections.</source>
          <target state="translated">그러면 HTRC의 웹 기반 다운로드 링크 (예 : &lt;a href=&quot;https://data.analytics.hathitrust.org/features/get?download-id=%7B%7BURL%7D%7D&quot;&gt;https://data.analytics.hathitrust.org/features/get?download-id={{URL}}&lt;/a&gt; )를 사용하여 파일을 임시로 다운로드합니다 . 이 기능과 잘 어울리는 한 가지는 컬렉션 다운로드를위한 &lt;a href=&quot;https://github.com/htrc/HTRC-PythonSDK&quot;&gt;HTRC Python SDK&lt;/a&gt; 의 기능입니다.</target>
        </trans-unit>
        <trans-unit id="cdc31e949b655a110b5d7d7c59834c88f7222471" translate="yes" xml:space="preserve">
          <source>This example used multithreading. Due to the nature of Python, certain functions won't parallelize well. In our case, the part where the JSON is read from the file and converted to a DataFrame (the light green parts of the graphic) won't speed up because Python dicts lock the Global Interpreter Lock (GIL). However, because Pandas releases the GIL, nearly everything you do after parsing the JSON will be very quick.</source>
          <target state="translated">이 예에서는 멀티 스레딩을 사용했습니다. Python의 특성으로 인해 특정 함수는 병렬화되지 않습니다. 이 경우 파일에서 JSON을 읽고 DataFrame (그래픽의 밝은 녹색 부분)으로 변환하는 부분은 Python dict가 GIL (Global Interpreter Lock)을 잠그기 때문에 속도가 빨라지지 않습니다. 그러나 Pandas는 GIL을 릴리스하기 때문에 JSON을 구문 분석 한 후 수행하는 거의 모든 작업이 매우 빠릅니다.</target>
        </trans-unit>
        <trans-unit id="50c25e02ce5e2bd3853698be70e156ec33211f75" translate="yes" xml:space="preserve">
          <source>This is the &lt;em&gt;Extracted Features&lt;/em&gt; dataset, so the features are easily accessible. To most popular is token counts, which are returned as a Pandas DataFrame:</source>
          <target state="translated">이것은 &lt;em&gt;추출 된 기능&lt;/em&gt; 데이터 세트이므로 기능에 쉽게 액세스 할 수 있습니다. 가장 인기있는 것은 Pandas DataFrame으로 반환되는 토큰 수입니다.</target>
        </trans-unit>
        <trans-unit id="9ada38d13736853b823fc63d7c686f328ed717e4" translate="yes" xml:space="preserve">
          <source>This library is meant to be compatible with Python 3.2+ and Python 2.7+. Tests are written for py.test and can be run with &lt;code&gt;setup.py test&lt;/code&gt;, or directly with &lt;code&gt;python -m py.test -v&lt;/code&gt;.</source>
          <target state="translated">이 라이브러리는 Python 3.2+ 및 Python 2.7+와 호환됩니다. 테스트는 py.test 용으로 작성되었으며 &lt;code&gt;setup.py test&lt;/code&gt; 로 실행 하거나 &lt;code&gt;python -m py.test -v&lt;/code&gt; 로 직접 실행할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ddf297c6fd7a38365160dce4e5f4e20eeac90c1b" translate="yes" xml:space="preserve">
          <source>This library makes heavy use of &lt;a href=&quot;pandas.pydata.org&quot;&gt;Pandas&lt;/a&gt;, returning many data representations as DataFrames. This is the leading way of dealing with structured data in Python, so this library doesn't try to reinvent the wheel. Since refactoring around Pandas, the primary benefit of using the HTRC Feature Reader is performance: reading the json structures and parsing them is generally faster than custom code. You also get convenient access to common information, such as case-folded token counts or part-of-page specific character counts. Details of the public methods provided by this library can be found in the &lt;a href=&quot;http://htrc.github.io/htrc-feature-reader/htrc_features/feature_reader.m.html&quot;&gt;HTRC Feature Reader docs&lt;/a&gt;.</source>
          <target state="translated">이 라이브러리는 &lt;a href=&quot;pandas.pydata.org&quot;&gt;Pandas&lt;/a&gt; 를 많이 사용하여 많은 데이터 표현을 DataFrames로 반환합니다. 이것은 Python에서 구조화 된 데이터를 처리하는 선도적 인 방법이므로이 라이브러리는 바퀴를 재발 명하려고하지 않습니다. Pandas를 중심으로 리팩토링하기 때문에 HTRC Feature Reader 사용의 주요 이점은 성능입니다. json 구조를 읽고 파싱하는 것이 일반적으로 사용자 지정 코드보다 빠릅니다. 또한 대 / 소문자 구분 토큰 수 또는 페이지 일부 특정 문자 수와 같은 일반적인 정보에 편리하게 액세스 할 수 있습니다. 이 라이브러리에서 제공하는 공개 메서드에 대한 자세한 내용은 &lt;a href=&quot;http://htrc.github.io/htrc-feature-reader/htrc_features/feature_reader.m.html&quot;&gt;HTRC Feature Reader 문서&lt;/a&gt; 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8ddb0db32416ddda72060717a0dbcc426eaf3ec6" translate="yes" xml:space="preserve">
          <source>This library provides a &lt;code&gt;FeatureReader&lt;/code&gt; for parsing files, which are handled as &lt;code&gt;Volume&lt;/code&gt; objects with collections of &lt;code&gt;Page&lt;/code&gt; objects. Volumes provide access to metadata (e.g. language), volume-wide feature information (e.g. token counts), and access to Pages. Pages allow you to easily parse page-level features, particularly token lists.</source>
          <target state="translated">이 라이브러리는 &lt;code&gt;Page&lt;/code&gt; 개체 모음이있는 &lt;code&gt;Volume&lt;/code&gt; 개체로 처리되는 파일 구문 분석을 위한 &lt;code&gt;FeatureReader&lt;/code&gt; 를 제공 합니다. 볼륨은 메타 데이터 (예 : 언어), 볼륨 전체 기능 정보 (예 : 토큰 수) 및 페이지에 대한 액세스를 제공합니다. 페이지를 사용하면 페이지 수준 기능, 특히 토큰 목록을 쉽게 구문 분석 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0153d273ae12a6376fadd533f487984b597d84bb" translate="yes" xml:space="preserve">
          <source>This psuedo-code shows how that you'd use parallel, where the number of parallel processes is 90% the number of cores, and 50 paths are sent to the script at a time (if you send too little at a time, the initialization time of the script can add up).</source>
          <target state="translated">이 유사 코드는 병렬을 사용하는 방법을 보여줍니다. 병렬 프로세스의 수는 코어 수의 90 %이고 한 번에 50 개의 경로가 스크립트로 전송됩니다 (한 번에 너무 적게 전송하면 초기화 스크립트 시간이 추가 될 수 있음).</target>
        </trans-unit>
        <trans-unit id="3a643ab71d39a1b4b70191cea4788509f418c302" translate="yes" xml:space="preserve">
          <source>To better understand what happens when &lt;code&gt;ddf.compute()&lt;/code&gt;, here is a graph for 4 volumes:</source>
          <target state="translated">&lt;code&gt;ddf.compute()&lt;/code&gt; 때 어떤 일이 발생하는지 더 잘 이해하기 위해 다음은 4 개 볼륨에 대한 그래프입니다.</target>
        </trans-unit>
        <trans-unit id="a5d1b71e4f045a7e0bb3f5171451cb36adf49b97" translate="yes" xml:space="preserve">
          <source>To get just the unique tokens, &lt;code&gt;Volume.tokens&lt;/code&gt; provides them as a set. Here I select a specific page for brevity and a minimum count, but you can run the method without arguments.</source>
          <target state="translated">고유 한 토큰을 얻기 위해 &lt;code&gt;Volume.tokens&lt;/code&gt; 는이를 세트로 제공합니다. 여기서는 간결함과 최소 개수를 위해 특정 페이지를 선택하지만 인수없이 메서드를 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a23988558c5b7ad28d9c2df36be23a4f0d0689a2" translate="yes" xml:space="preserve">
          <source>To install,</source>
          <target state="translated">설치하기 위해서,</target>
        </trans-unit>
        <trans-unit id="dd932d0b00715bdf036709d75645d0f230d2f4d8" translate="yes" xml:space="preserve">
          <source>Token counts are returned by &lt;code&gt;Volume.tokenlist()&lt;/code&gt; (or &lt;code&gt;Page.tokenlist()&lt;/code&gt;. By default, part-of-speech tagged, case-sensitive counts are returned for the body.</source>
          <target state="translated">토큰 개수는 &lt;code&gt;Volume.tokenlist()&lt;/code&gt; (또는 &lt;code&gt;Page.tokenlist()&lt;/code&gt; )에 의해 반환됩니다 . 기본적으로 품사 태그가 지정된 대소 문자 구분 개수가 본문에 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="01f50e5f4dabbb57286d438085019ec3b48a7096" translate="yes" xml:space="preserve">
          <source>Tools for working with the &lt;a href=&quot;https://sharc.hathitrust.org/features&quot;&gt;HTRC Extracted Features dataset&lt;/a&gt;, a dataset of page-level text features extracted from 17 million digitized works.</source>
          <target state="translated">1,700 만 개의 디지털화 된 작품에서 추출한 페이지 수준 텍스트 기능의 데이터 &lt;a href=&quot;https://sharc.hathitrust.org/features&quot;&gt;세트&lt;/a&gt; 인 HTRC Extracted Features 데이터 세트 작업을위한 도구입니다 .</target>
        </trans-unit>
        <trans-unit id="0bb18642b70b9f8a9c12ccf39487328f306b8e19" translate="yes" xml:space="preserve">
          <source>Usage</source>
          <target state="translated">용법</target>
        </trans-unit>
        <trans-unit id="6fdede7befa5cbf3bc6641cf4e8ae6b2ab7a6811" translate="yes" xml:space="preserve">
          <source>VB</source>
          <target state="translated">VB</target>
        </trans-unit>
        <trans-unit id="b76dcf7a12caa1e4d097707c7428b0fe9655f4a2" translate="yes" xml:space="preserve">
          <source>VBD</source>
          <target state="translated">VBD</target>
        </trans-unit>
        <trans-unit id="bb7b3c2dc5fceb7944a2d5247ba39109ed1e34e8" translate="yes" xml:space="preserve">
          <source>VBZ</source>
          <target state="translated">VBZ</target>
        </trans-unit>
        <trans-unit id="3b18e8e332500f3dfedb21b0aed686cfa9832cfe" translate="yes" xml:space="preserve">
          <source>Volume</source>
          <target state="translated">음량</target>
        </trans-unit>
        <trans-unit id="f807da0b25d59ebba0c76d5ad0ddbdd9b09f6cfc" translate="yes" xml:space="preserve">
          <source>Volumes also have direct access to volume-wide info of features stored in pages. For example, you can get a list of words per page through &lt;a href=&quot;http://htrc.github.io/htrc-feature-reader/htrc_features/feature_reader.m.html#htrc_features.feature_reader.Volume.tokens_per_page&quot;&gt;Volume.tokens_per_page()&lt;/a&gt;. We'll discuss these features &lt;a href=&quot;#Volume-stats-collecting&quot;&gt;below&lt;/a&gt;, after looking first at Pages.</source>
          <target state="translated">또한 볼륨은 페이지에 저장된 기능의 볼륨 전체 정보에 직접 액세스 할 수 있습니다. 예를 들어 &lt;a href=&quot;http://htrc.github.io/htrc-feature-reader/htrc_features/feature_reader.m.html#htrc_features.feature_reader.Volume.tokens_per_page&quot;&gt;Volume.tokens_per_page ()를&lt;/a&gt; 통해 페이지 당 단어 목록을 가져올 수 있습니다 . 먼저 페이지를 살펴본 후 &lt;a href=&quot;#Volume-stats-collecting&quot;&gt;아래&lt;/a&gt; 에서 이러한 기능에 대해 설명합니다 .</target>
        </trans-unit>
        <trans-unit id="a0a26f2e80cbcf753a23f7f1465f013588028bba" translate="yes" xml:space="preserve">
          <source>WP</source>
          <target state="translated">WP</target>
        </trans-unit>
        <trans-unit id="7b3b17fef18360d50f4eeffb1b5a52777fbf3ec3" translate="yes" xml:space="preserve">
          <source>You can also drop the section index altogether if you're content with the default 'body'.</source>
          <target state="translated">기본 '본문'에 만족하는 경우 섹션 색인을 모두 삭제할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="6f13d0a6d190c0ad73bd66340c7ace3eca30d02c" translate="yes" xml:space="preserve">
          <source>abode</source>
          <target state="translated">거처</target>
        </trans-unit>
        <trans-unit id="cffa50a32cb13a240d705317bcec65dd1f31b6ad" translate="yes" xml:space="preserve">
          <source>and</source>
          <target state="translated">과</target>
        </trans-unit>
        <trans-unit id="c5fe0200d1c7a5139bd18fd22268c4ca8bf45e90" translate="yes" xml:space="preserve">
          <source>any</source>
          <target state="translated">어떤</target>
        </trans-unit>
        <trans-unit id="27e90dfa57c358acfaf470860f6f72c9282ce995" translate="yes" xml:space="preserve">
          <source>at</source>
          <target state="translated">...에서</target>
        </trans-unit>
        <trans-unit id="4be03cbb728ebfa1032f15c0260a0cd35a416fec" translate="yes" xml:space="preserve">
          <source>austen</source>
          <target state="translated">오스틴</target>
        </trans-unit>
        <trans-unit id="02083f4579e08a612425c0c1a17ee47add783b94" translate="yes" xml:space="preserve">
          <source>body</source>
          <target state="translated">몸</target>
        </trans-unit>
        <trans-unit id="5dc187aecac5ccf97b06ee51288408183eeddc3e" translate="yes" xml:space="preserve">
          <source>capAlphaSeq</source>
          <target state="translated">capAlphaSeq</target>
        </trans-unit>
        <trans-unit id="78c7e5447338a9e5e7026a8b78ae41ec9a47b274" translate="yes" xml:space="preserve">
          <source>chunk</source>
          <target state="translated">큰 덩어리</target>
        </trans-unit>
        <trans-unit id="74f5cacb17fe7f0b0b7babd0407fecac0c32008c" translate="yes" xml:space="preserve">
          <source>comes</source>
          <target state="translated">온다</target>
        </trans-unit>
        <trans-unit id="ee9f38e186ba06f57b7b74d7e626b94e13ce2556" translate="yes" xml:space="preserve">
          <source>count</source>
          <target state="translated">카운트</target>
        </trans-unit>
        <trans-unit id="2867616061c752524db6cab4787da692e8dd4d3a" translate="yes" xml:space="preserve">
          <source>emptyLineCount</source>
          <target state="translated">emptyLineCount</target>
        </trans-unit>
        <trans-unit id="c33f059b0ca7725fbfd6c9ea4f2f012cc7ac5a74" translate="yes" xml:space="preserve">
          <source>family</source>
          <target state="translated">가족</target>
        </trans-unit>
        <trans-unit id="43eef9a62abb8b1e1654f8a890aae054abffa82b" translate="yes" xml:space="preserve">
          <source>for</source>
          <target state="translated">...에 대한</target>
        </trans-unit>
        <trans-unit id="1a954628a960aaef81d7b2d4521929579f3541e6" translate="yes" xml:space="preserve">
          <source>head</source>
          <target state="translated">머리</target>
        </trans-unit>
        <trans-unit id="594fd1615a341c77829e83ed988f137e1ba96231" translate="yes" xml:space="preserve">
          <source>header</source>
          <target state="translated">헤더</target>
        </trans-unit>
        <trans-unit id="8a8deed44623d4c44268c26652d80945851c4f7f" translate="yes" xml:space="preserve">
          <source>jane</source>
          <target state="translated">여자</target>
        </trans-unit>
        <trans-unit id="7da33f49740772bd4c0f244cc0fff335ffc6d639" translate="yes" xml:space="preserve">
          <source>journey</source>
          <target state="translated">여행</target>
        </trans-unit>
        <trans-unit id="c831bfbfcae79ccde743256856374683292695e2" translate="yes" xml:space="preserve">
          <source>lineCount</source>
          <target state="translated">lineCount</target>
        </trans-unit>
        <trans-unit id="171c1e65f95a4d4992c129151e673f844920649a" translate="yes" xml:space="preserve">
          <source>lowercase</source>
          <target state="translated">소문자</target>
        </trans-unit>
        <trans-unit id="5821eb27d7b71c9078000da31a5a654c97e401b9" translate="yes" xml:space="preserve">
          <source>make</source>
          <target state="translated">하다</target>
        </trans-unit>
        <trans-unit id="fce3b4d725ee5c9e018037177d09db029a60fc73" translate="yes" xml:space="preserve">
          <source>necessary</source>
          <target state="translated">필요한</target>
        </trans-unit>
        <trans-unit id="767013ce0ee0f6d7a07587912eba3104cfaabc15" translate="yes" xml:space="preserve">
          <source>page</source>
          <target state="translated">페이지</target>
        </trans-unit>
        <trans-unit id="51d1bef695972a70389ca259dbd97d9a80808d1a" translate="yes" xml:space="preserve">
          <source>pemberley</source>
          <target state="translated">Pemberley</target>
        </trans-unit>
        <trans-unit id="1478c028a16709cb32d8b1a69ccca032ca1d9ef5" translate="yes" xml:space="preserve">
          <source>pos</source>
          <target state="translated">pos</target>
        </trans-unit>
        <trans-unit id="ab2653c9da9095101835f53260828b24e8af36b3" translate="yes" xml:space="preserve">
          <source>prejudice</source>
          <target state="translated">편견</target>
        </trans-unit>
        <trans-unit id="57c46f318d70fc1e8da1867de604bea68413ea46" translate="yes" xml:space="preserve">
          <source>prejudiceJane</source>
          <target state="translated">편견 제인</target>
        </trans-unit>
        <trans-unit id="20182fbc10716eb197ea16bc03277c7d8c3730b2" translate="yes" xml:space="preserve">
          <source>section</source>
          <target state="translated">부분</target>
        </trans-unit>
        <trans-unit id="d8ed7caa2334e31286854824429a9c866a49db93" translate="yes" xml:space="preserve">
          <source>sentenceCount</source>
          <target state="translated">sentenceCount</target>
        </trans-unit>
        <trans-unit id="cd1b646ebd1f6844c60dd91951c6867e43857114" translate="yes" xml:space="preserve">
          <source>so</source>
          <target state="translated">그래서</target>
        </trans-unit>
        <trans-unit id="9b42e50fefa55151ea271e7a84c04345be532c8d" translate="yes" xml:space="preserve">
          <source>spite</source>
          <target state="translated">악의</target>
        </trans-unit>
        <trans-unit id="e78b52d7bb28ef2a2895973ad67229c5287d8683" translate="yes" xml:space="preserve">
          <source>suppose</source>
          <target state="translated">가정하다</target>
        </trans-unit>
        <trans-unit id="63e76d7b9e5059006df47479d8b6f78294c74852" translate="yes" xml:space="preserve">
          <source>surprise</source>
          <target state="translated">놀라다</target>
        </trans-unit>
        <trans-unit id="b802f384302cb24fbab0a44997e820bf2e8507bb" translate="yes" xml:space="preserve">
          <source>three</source>
          <target state="translated">세</target>
        </trans-unit>
        <trans-unit id="ee977806d7286510da8b9a7492ba58e2484c0ecc" translate="yes" xml:space="preserve">
          <source>token</source>
          <target state="translated">토큰</target>
        </trans-unit>
        <trans-unit id="cf0b6755938ace6aaac34a7490b13d556c50c152" translate="yes" xml:space="preserve">
          <source>tokenCount</source>
          <target state="translated">tokenCount</target>
        </trans-unit>
        <trans-unit id="b1b416becb29d7acd0c4004ae2f7ec84b199e9fe" translate="yes" xml:space="preserve">
          <source>took</source>
          <target state="translated">했다</target>
        </trans-unit>
        <trans-unit id="a5afc8df8baab874c14a0f776641edd16d00591f" translate="yes" xml:space="preserve">
          <source>uncle</source>
          <target state="translated">삼촌</target>
        </trans-unit>
        <trans-unit id="16a0fb48706cbd9445856412ef99589b85e5e03c" translate="yes" xml:space="preserve">
          <source>vol</source>
          <target state="translated">vol</target>
        </trans-unit>
        <trans-unit id="9262105047ec770aa16ef1ff67b37ae7fb5b626d" translate="yes" xml:space="preserve">
          <source>warmest</source>
          <target state="translated">가장 따뜻한</target>
        </trans-unit>
        <trans-unit id="a110e6b9a361653a042e3f5dfbac4c6105693789" translate="yes" xml:space="preserve">
          <source>what</source>
          <target state="translated">뭐</target>
        </trans-unit>
        <trans-unit id="48eda733f81c96587ed209509223237e151e5ce6" translate="yes" xml:space="preserve">
          <source>wife</source>
          <target state="translated">아내</target>
        </trans-unit>
        <trans-unit id="0955dd818206a40e89101bb215630d0623e506fc" translate="yes" xml:space="preserve">
          <source>would</source>
          <target state="translated">할 것이다</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
