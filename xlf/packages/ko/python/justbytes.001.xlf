<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://pypi.org/project/justbytes/">
    <body>
      <group id="justbytes">
        <trans-unit id="447b8348b9c2348111a636255e107995a2ed4367" translate="yes" xml:space="preserve">
          <source>All errors raised by justbytes operations are subtypes of the RangeError class.</source>
          <target state="translated">justbytes 작업에 의해 발생하는 모든 오류는 RangeError 클래스의 하위 유형입니다.</target>
        </trans-unit>
        <trans-unit id="3c736d39cfcbcaf284f80530e8748d5df12b2eb3" translate="yes" xml:space="preserve">
          <source>Alternative Packages</source>
          <target state="translated">대체 패키지</target>
        </trans-unit>
        <trans-unit id="1f878420017dbe53c0a2676a433496213e5811a0" translate="yes" xml:space="preserve">
          <source>Computing the Representation of a Range</source>
          <target state="translated">범위 표현 계산</target>
        </trans-unit>
        <trans-unit id="7b6af984283fa6b9adedb133907862c2f2663660" translate="yes" xml:space="preserve">
          <source>Consequently, computations such as addition of two Ranges, and conversion
between different magnitudes of bytes, i.e., from MiB to GiB, must be done
precisely. The underlying implementation must therefore use a precise
representation of the number of bytes. Floating point numbers, which are
frequently the preferred type for the representation of physical
quantities, are disallowed by this requirement.</source>
          <target state="translated">결과적으로 두 개의 범위 추가, 다른 크기의 바이트 간 변환 (예 : MiB에서 GiB로)과 같은 계산이 정확하게 수행되어야합니다. 따라서 기본 구현은 바이트 수의 정확한 표현을 사용해야합니다. 물리량을 표현하는 데 자주 선호되는 유형 인 부동 소수점 숫자는이 요구 사항에 의해 허용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3f4700f344a55dd2a413f15f371fad0a05b8a575" translate="yes" xml:space="preserve">
          <source>Constructing Ranges Programatically</source>
          <target state="translated">프로그래밍 방식으로 범위 구성</target>
        </trans-unit>
        <trans-unit id="9c6c971ced78a1f9bbe931fd59030db5c8588db9" translate="yes" xml:space="preserve">
          <source>Displaying Ranges</source>
          <target state="translated">범위 표시</target>
        </trans-unit>
        <trans-unit id="805e86a8cbf628e38e4c45612c005a504009e79a" translate="yes" xml:space="preserve">
          <source>Errors</source>
          <target state="translated">오류</target>
        </trans-unit>
        <trans-unit id="cbfba25d0250d74cb72b3ec89534cd1cbcf21211" translate="yes" xml:space="preserve">
          <source>Floating Point Numbers</source>
          <target state="translated">부동 소수점 숫자</target>
        </trans-unit>
        <trans-unit id="d6d84fa09f507b8c85bc8b38c187fe899a44a5c1" translate="yes" xml:space="preserve">
          <source>If you are interested in computing in Python with physical, rather than
logical, quantities, you should consult the pint package:
&lt;a href=&quot;http://pint.readthedocs.org&quot;&gt;http://pint.readthedocs.org&lt;/a&gt;.</source>
          <target state="translated">논리적이 아니라 물리적 인 양을 사용하여 Python으로 계산하는 데 관심이 있다면 파인트 패키지 &lt;a href=&quot;http://pint.readthedocs.org&quot;&gt;http://pint.readthedocs.org를&lt;/a&gt; 참조 하십시오 .</target>
        </trans-unit>
        <trans-unit id="8d205500c8f287783d5e6ffd528d2f8fbd78d600" translate="yes" xml:space="preserve">
          <source>It is not possible to use floating point numbers or Decimal in computations
with Ranges. Where a fractional quantity is desired, use Fraction objects.
Thus, Range(0) * 1.2 and Range(0) * Decimal(&amp;ldquo;1.2&amp;rdquo;) raise an exception, but
Range(0) * Fraction(&amp;ldquo;1.2&amp;rdquo;) is acceptable.</source>
          <target state="translated">범위가있는 계산에서 부동 소수점 숫자 또는 십진수를 사용할 수 없습니다. 소 수량이 필요한 경우 Fraction 객체를 사용합니다. 따라서 Range (0) * 1.2 및 Range (0) * Decimal ( &quot;1.2&quot;)는 예외를 발생하지만 Range (0) * Fraction ( &quot;1.2&quot;)은 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="d2fac8f190d6ba2310cd04193e6922d40dd4506a" translate="yes" xml:space="preserve">
          <source>Its sole purpose is the representation of real address ranges on real
machines. For that reason, it does not allow powers of ranges, imprecise
ranges, or non-finite ranges. In order that the
usual laws of arithmetic can be maintained, it does allow fractional ranges.</source>
          <target state="translated">유일한 목적은 실제 시스템에서 실제 주소 범위를 표현하는 것입니다. 따라서 범위의 거듭 제곱, 부정확 한 범위 또는 비 한정 범위는 허용되지 않습니다. 일반적인 산술 법칙을 유지하기 위해 분수 범위를 허용합니다.</target>
        </trans-unit>
        <trans-unit id="45882d11d2960503d0c63d16f01836831a20d4a5" translate="yes" xml:space="preserve">
          <source>Justbytes</source>
          <target state="translated">Justbytes</target>
        </trans-unit>
        <trans-unit id="fadaa413fdb8e444db665691407ee547102d51d5" translate="yes" xml:space="preserve">
          <source>Justbytes is a module for handling computation with
address ranges expressed in bytes. Its principle feature is a Range class from
which can be constructed Range objects which represent a precise and finite
address range in bytes. Various arithmetic operations are defined for Range
objects.</source>
          <target state="translated">Justbytes는 바이트로 표현 된 주소 범위로 계산을 처리하기위한 모듈입니다. 기본 기능은 정확하고 유한 한 주소 범위를 바이트 단위로 나타내는 Range 개체를 구성 할 수있는 Range 클래스입니다. Range 개체에 대해 다양한 산술 연산이 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="e3ac283515eac7e729ac10b009dc00d848c8e9ac" translate="yes" xml:space="preserve">
          <source>Memory Consumption and Bandwidth vs. Address Ranges</source>
          <target state="translated">메모리 소비 및 대역폭 대 주소 범위</target>
        </trans-unit>
        <trans-unit id="65725c5cbb6b40fb6d8721e0f58b7f2d9f219336" translate="yes" xml:space="preserve">
          <source>Memory consumption, e.g., by a process during execution on a specified
workload, is a quantity, that like address ranges, is specified in
bytes. However, memory consumption is simply a measurement of the amount of
a phsyical quantity consumed.  When bytes are used only to represent memory
consumption, computations do not generally require the special handling
supplied by this library. Generally, measurement of memory consumption can
be treated like any other physical quantity. The same reasoning applies to
bandwidth. For a physical analogy, one can imagine memory consumption to be
analogous to volume, e.g., litres, and bandwidth to be analogous to flow,
e.g., litres per minute.</source>
          <target state="translated">예를 들어, 지정된 워크로드에서 실행되는 동안 프로세스에 의한 메모리 소비는 주소 범위와 마찬가지로 바이트 단위로 지정되는 수량입니다. 그러나 메모리 소비는 단순히 소비 된 물리적 양의 양을 측정 한 것입니다. 바이트가 메모리 소비를 나타내는 데만 사용되는 경우 계산에는 일반적으로이 라이브러리에서 제공하는 특수 처리가 필요하지 않습니다. 일반적으로 메모리 사용량 측정은 다른 물리량과 같이 취급 할 수 있습니다. 대역폭에도 동일한 추론이 적용됩니다. 물리적 비유를 위해 메모리 소비는 부피 (예 : 리터)와 유사하고 대역폭은 흐름 (예 : 분당 리터)과 유사하다고 상상할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8a99d14f970e76756815cc726112e9e4f2356fee" translate="yes" xml:space="preserve">
          <source>New Range objects can be constructed from Range objects, numeric values, e.g.,
int or Fraction, or strings which represent such numeric values.
strings may be used to represent fractional quantities, e.g., &amp;ldquo;1.2&amp;rdquo;, but
floats and Decimals are disallowed.</source>
          <target state="translated">새로운 Range 개체는 Range 개체, 숫자 값 (예 : int 또는 Fraction) 또는 이러한 숫자 값을 나타내는 문자열로 구성 할 수 있습니다. &quot;1.2&quot;와 같이 소수를 나타내는 데 문자열을 사용할 수 있지만 float 및 Decimals는 허용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8e8e76e830d5d5d96809802aa0ea50ad46a0e846" translate="yes" xml:space="preserve">
          <source>Numerous computations with address ranges are nonsensical. For example, 2
raised to a power which is some address range, is a meaningless computation.
All such operations cause an error to be raised.</source>
          <target state="translated">주소 범위를 사용한 수많은 계산은 무의미합니다. 예를 들어, 주소 범위 인 2의 거듭 제곱은 의미없는 계산입니다. 이러한 모든 작업으로 인해 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="a1fdaa6b2a846c8fcf18d414bf8c61db610eda6a" translate="yes" xml:space="preserve">
          <source>Operations</source>
          <target state="translated">운영</target>
        </trans-unit>
        <trans-unit id="43aaf6f57b7c95249bd643787aad1b1255593812" translate="yes" xml:space="preserve">
          <source>Practical Computing with Address Ranges</source>
          <target state="translated">주소 범위를 사용한 실용적인 컴퓨팅</target>
        </trans-unit>
        <trans-unit id="a85446ae4efaa1d6aaa78d5db82169a15cd8c137" translate="yes" xml:space="preserve">
          <source>Representing Units</source>
          <target state="translated">단위 대표</target>
        </trans-unit>
        <trans-unit id="32508a9e120d4892b64a069406f889c0158d8e4a" translate="yes" xml:space="preserve">
          <source>Some computations with precise, finite, values may yield irrational results.
For example, while 2 is rational, its square root is an irrational number.
There is no allowed operation on Range objects which can result in an
irrational Range value. It turns out that all such operations are either
nonsensical or would result in a value with an unrepresentable type.</source>
          <target state="translated">정확하고 유한 한 값을 사용하는 일부 계산은 비합리적인 결과를 생성 할 수 있습니다. 예를 들어 2는 유리하지만 제곱근은 비이성적 인 숫자입니다. 비합리적인 범위 값을 초래할 수있는 Range 개체에 허용 된 작업이 없습니다. 그러한 모든 작업은 무의미하거나 표현할 수없는 유형의 값을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="a8b73a8356a1277aa6a8d1b69dbdb2cb2c5bcc98" translate="yes" xml:space="preserve">
          <source>The Range class also has standard methods for the representation of Range
objects as str objects.</source>
          <target state="translated">Range 클래스에는 Range 개체를 str 개체로 표현하는 표준 메서드도 있습니다.</target>
        </trans-unit>
        <trans-unit id="94d414b4b47ed43fadec12a10ba6e7313b163f7c" translate="yes" xml:space="preserve">
          <source>The constructor takes an optional units specifier, which defaults to bytes
for all numeric values, and to None for Range objects. The type of the
unit specifier is a named prefix supplied by the size module or a Range object.</source>
          <target state="translated">생성자는 모든 숫자 값의 경우 기본적으로 바이트로, Range 개체의 경우 None으로 설정되는 선택적 단위 지정자를 사용합니다. 단위 지정자의 유형은 크기 모듈 또는 Range 개체에서 제공하는 명명 된 접두사입니다.</target>
        </trans-unit>
        <trans-unit id="097c7c0496973f59f9c251a898f12945055be5c7" translate="yes" xml:space="preserve">
          <source>The representation of a Range is computed according to a specified
configuration. In the default configuration, the representation uses IEC
rather than SI units.</source>
          <target state="translated">범위 표현은 지정된 구성에 따라 계산됩니다. 기본 구성에서 표현은 SI 단위가 아닌 IEC를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="10256571c4110a674ceb91b10fbb1a84d4045c07" translate="yes" xml:space="preserve">
          <source>The representation of a Range is not a string, but a structured representation
of the precise value, as well as the relationship of the representation to
the actual value.</source>
          <target state="translated">Range의 표현은 문자열이 아니라 실제 값에 대한 표현의 관계뿐 아니라 정확한 값의 구조화 된 표현입니다.</target>
        </trans-unit>
        <trans-unit id="39a94149ce22e4db399e8e0e373611c2d8539226" translate="yes" xml:space="preserve">
          <source>The result type of operations is a Range, where appropriate, or a subtype of
Rational, where a numeric value is appropriate.</source>
          <target state="translated">연산의 결과 유형은 해당하는 경우 Range이거나 숫자 값이 적합한 경우 Rational의 하위 유형입니다.</target>
        </trans-unit>
        <trans-unit id="9ed4545ef7ef3799a6493364429d8f4f3088d609" translate="yes" xml:space="preserve">
          <source>The size module supplies a set of named prefixes for both SI and binary units,
for all non-fractional prefixes. Fractional prefixes are not defined.</source>
          <target state="translated">size 모듈은 모든 비 분수 접두사에 대해 SI 및 이진 단위 모두에 대해 명명 된 접두사 집합을 제공합니다. 분수 접두사가 정의되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="6c9670cfffbaa49a042fc163ff0b2776907074d3" translate="yes" xml:space="preserve">
          <source>The str representation can also be configured. The manipulation of the
representation to form a str object is abstracted from the rest of the source
to emphasize that clients of the package may choose to represent address ranges
in any manner they choose.</source>
          <target state="translated">str 표현도 구성 할 수 있습니다. str 객체를 형성하기위한 표현의 조작은 패키지의 클라이언트가 자신이 선택한 방식으로 주소 범위를 표현하도록 선택할 수 있음을 강조하기 위해 소스의 나머지 부분에서 추상화됩니다.</target>
        </trans-unit>
        <trans-unit id="c9d82d1c8a3f153080dfa8f031173eb4da4b8f13" translate="yes" xml:space="preserve">
          <source>This module does not accomodate multi-dimensionality of address ranges.
Consequently, multiplying one Range object by another Range object will cause
an error to be raised, since bytes^2 is not representable by the module.
For most uses any operation which would yield a multi-dimensional quantity
is not useful. There are no plans to adapt this package so that it
can accomodate multi-dimensionality of address ranges.</source>
          <target state="translated">이 모듈은 주소 범위의 다차원 성을 수용하지 않습니다. 결과적으로 하나의 Range 개체에 다른 Range 개체를 곱하면 bytes ^ 2가 모듈에서 표현할 수 없기 때문에 오류가 발생합니다. 대부분의 경우 다차원 수량을 산출하는 작업은 유용하지 않습니다. 주소 범위의 다차원 성을 수용 할 수 있도록이 패키지를 적용 할 계획은 없습니다.</target>
        </trans-unit>
        <trans-unit id="d5695091f3f7dbec419aa9a43a489657cd3cec78" translate="yes" xml:space="preserve">
          <source>This package does not handle arbitrary user input. It is expected that the
client will transform any input, from whatever source, into a number and an
optional unit specification which can be passed directly to the Range
constructor.</source>
          <target state="translated">이 패키지는 임의의 사용자 입력을 처리하지 않습니다. 클라이언트는 소스에 관계없이 모든 입력을 Range 생성자에 직접 전달할 수있는 숫자 및 선택적 단위 사양으로 변환 할 것으로 예상됩니다.</target>
        </trans-unit>
        <trans-unit id="0ad10cd434a732c22b242d2eb564844e1c3e7716" translate="yes" xml:space="preserve">
          <source>This representation is exposed to clients of the library, which may use it
in any way.</source>
          <target state="translated">이 표현은 어떤 방식 으로든 사용할 수있는 라이브러리의 클라이언트에 노출됩니다.</target>
        </trans-unit>
        <trans-unit id="0b75d4ee12567b39421e5cdafacb9fdac3567042" translate="yes" xml:space="preserve">
          <source>User Input</source>
          <target state="translated">사용자 입력</target>
        </trans-unit>
        <trans-unit id="4cfb3a9ba784840220f2270e361d47e1ff0d6f04" translate="yes" xml:space="preserve">
          <source>When computing with address ranges, the numeric value can be viewed as a
logical, rather than a physical, quantity. That is, unlike, e.g., mass or
length, which are quantities which must be measured with a measuring instrument
which has some built-in imprecision, an address range
is a quantity that is not measured, but is known precisely.
This precision arises because the number represents not as much an amount of
memory as a number of addressable, byte-size, locations in memory.</source>
          <target state="translated">주소 범위로 계산할 때 숫자 값은 물리적 수량이 아닌 논리적 수량으로 볼 수 있습니다. 즉, 부정확성이 내장 된 측정기로 측정해야하는 양인 질량이나 길이와 달리 주소 범위는 측정되지 않지만 정확하게 알려진 양입니다. 이 정밀도는 숫자가 메모리에서 주소 지정 가능한 바이트 크기의 위치 수만큼 메모리 양을 나타내지 않기 때문에 발생합니다.</target>
        </trans-unit>
        <trans-unit id="d2fff8678cd4207ea323bf9803cc0d1f80906f54" translate="yes" xml:space="preserve">
          <source>computing with and displaying bytes</source>
          <target state="translated">바이트 계산 및 표시</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
