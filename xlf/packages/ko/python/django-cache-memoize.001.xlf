<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://pypi.org/project/django-cache-memoize/">
    <body>
      <group id="django-cache-memoize">
        <trans-unit id="6ec3b6aae5a1a82f8273b1342bb46136833a7a6a" translate="yes" xml:space="preserve">
          <source>&amp;ldquo;Competition&amp;rdquo;</source>
          <target state="translated">&quot;경쟁&quot;</target>
        </trans-unit>
        <trans-unit id="195796f5339ee048530325688564a5319aced725" translate="yes" xml:space="preserve">
          <source>.
So if you have a function that returns something that can&amp;rsquo;t be pickled and
cached it won&amp;rsquo;t work.</source>
          <target state="translated">. 따라서 피클 및 캐시 할 수없는 것을 반환하는 함수가있는 경우 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="cf664adba84fbf2801d648fd52ef5acf5fa8715c" translate="yes" xml:space="preserve">
          <source>. It gets the same positional and keyword arguments
as the function you&amp;rsquo;re decorating. Here&amp;rsquo;s an example implementation:</source>
          <target state="translated">. 장식하는 함수와 동일한 위치 및 키워드 인수를 가져옵니다. 다음은 구현의 예입니다.</target>
        </trans-unit>
        <trans-unit id="d3b0fb652099658032a196e2d388abacedbef6ed" translate="yes" xml:space="preserve">
          <source>. Like this:</source>
          <target state="translated">. 이렇게 :</target>
        </trans-unit>
        <trans-unit id="fc0cfef2762bdfdf9b3175d7c76b34f1f4ce28f7" translate="yes" xml:space="preserve">
          <source>. This is equivalent to your function
returning</source>
          <target state="translated">. 이것은 반환하는 함수와 동일합니다.</target>
        </trans-unit>
        <trans-unit id="29ea70480c9828cb62a31a8baa47f907af0cbb17" translate="yes" xml:space="preserve">
          <source>.invalidate</source>
          <target state="translated">.invalidate</target>
        </trans-unit>
        <trans-unit id="c95f9ef1896d04dc31914dff53823d43f85e3b7b" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://symbols.mozilla.org&quot;&gt;Mozilla Symbol Server&lt;/a&gt; is written in Django. It&amp;rsquo;s a web service that
sits between C++ debuggers and AWS S3. It shuffles symbol files in and out of
AWS S3. Symbol files are for C++ (and other compiled languages) what
sourcemaps are for JavaScript.</source>
          <target state="translated">&lt;a href=&quot;https://symbols.mozilla.org&quot;&gt;Mozilla Symbol Server&lt;/a&gt; 는 Django로 작성되었습니다. C ++ 디버거와 AWS S3 사이에있는 웹 서비스입니다. AWS S3 안팎에서 심볼 파일을 섞습니다. 심볼 파일은 C ++ (및 기타 컴파일 된 언어) 용이며 JavaScript 용 소스 맵입니다.</target>
        </trans-unit>
        <trans-unit id="dd08610940962995d60e40413951d9f7631cb407" translate="yes" xml:space="preserve">
          <source>Ability to use as a &amp;ldquo;guard&amp;rdquo; for repeated execution when storing the function
result isn&amp;rsquo;t important or needed.</source>
          <target state="translated">함수 결과를 저장하는 것이 중요하지 않거나 필요하지 않을 때 반복 실행을위한 &quot;가드&quot;로 사용하는 기능입니다.</target>
        </trans-unit>
        <trans-unit id="ec9c1eee60a6c8d412e86494c4538774b81ce815" translate="yes" xml:space="preserve">
          <source>Advanced Usage</source>
          <target state="translated">고급 사용법</target>
        </trans-unit>
        <trans-unit id="f7c7d47fe21bd9222fc313673e59c857eab8d6dc" translate="yes" xml:space="preserve">
          <source>All code has to be formatted with &lt;a href=&quot;https://pypi.org/project/black/&quot;&gt;Black&lt;/a&gt;
and the best tool for checking this is
&lt;a href=&quot;https://pypi.org/project/therapist/&quot;&gt;therapist&lt;/a&gt; since it can help you run
all, help you fix things, and help you make sure linting is passing before
you git commit. This project also uses</source>
          <target state="translated">모든 코드는 &lt;a href=&quot;https://pypi.org/project/black/&quot;&gt;Black&lt;/a&gt; 으로 형식을 지정해야하며 이를 확인하는 가장 좋은 도구는 &lt;a href=&quot;https://pypi.org/project/therapist/&quot;&gt;치료사입니다.&lt;/a&gt; 모든 코드 를 실행하고 문제를 해결하는 데 도움이되며 git 커밋 전에 linting이 전달되는지 확인하는 데 도움이되기 때문입니다. 이 프로젝트는 또한</target>
        </trans-unit>
        <trans-unit id="58cf010477011085508d82c17f77fa7b2057c87a" translate="yes" xml:space="preserve">
          <source>An &amp;ldquo;alias&amp;rdquo; of doing the same thing is to pass a keyword argument called</source>
          <target state="translated">같은 일을하는 &quot;별칭&quot;은 다음과 같은 키워드 인자를 전달하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="86b9a89b3322904ffd98fa9a61a0cb15a4862069" translate="yes" xml:space="preserve">
          <source>And to fix all/any issues run:</source>
          <target state="translated">그리고 모든 / 모든 문제를 해결하려면 다음을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="b6ab6d4d2f8fdbf80724698cc472a96935583553" translate="yes" xml:space="preserve">
          <source>Another key difference is that</source>
          <target state="translated">또 다른 주요 차이점은</target>
        </trans-unit>
        <trans-unit id="fbb72ba5eb0ff9020b0af6414d8f3a709dbeb528" translate="yes" xml:space="preserve">
          <source>By default the prefix becomes the name of the function. Consider:</source>
          <target state="translated">기본적으로 접두사는 함수의 이름이됩니다. 중히 여기다:</target>
        </trans-unit>
        <trans-unit id="ac0b7cf2ddb0e2c3a2da80e8d13396dd6b5e7368" translate="yes" xml:space="preserve">
          <source>Cache invalidation</source>
          <target state="translated">캐시 무효화</target>
        </trans-unit>
        <trans-unit id="c8b1a972fe343f3d2f2fe444fb3a7ab3f0148ace" translate="yes" xml:space="preserve">
          <source>Check out the &lt;a href=&quot;https://github.com/peterbe/django-cache-memoize/blob/master/tox.ini&quot;&gt;tox.ini&lt;/a&gt; file for more up-to-date compatibility by
test coverage.</source>
          <target state="translated">테스트 범위 별 최신 호환성에 대해서는 &lt;a href=&quot;https://github.com/peterbe/django-cache-memoize/blob/master/tox.ini&quot;&gt;tox.ini&lt;/a&gt; 파일을 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="4463915d681f344a6328f56dad4ca5b776b764cf" translate="yes" xml:space="preserve">
          <source>Code style is all black</source>
          <target state="translated">코드 스타일은 모두 검은 색입니다.</target>
        </trans-unit>
        <trans-unit id="5d60c7dd62fdcf4abcc61a6a7d335b7117968b4d" translate="yes" xml:space="preserve">
          <source>Compatibility</source>
          <target state="translated">적합성</target>
        </trans-unit>
        <trans-unit id="4c17aadf5117487aab7bc50cbf056caf3977cc31" translate="yes" xml:space="preserve">
          <source>Development</source>
          <target state="translated">개발</target>
        </trans-unit>
        <trans-unit id="10a39b8b5ae782212eea401964ea72a478e45605" translate="yes" xml:space="preserve">
          <source>Django 1.11, 2.0, 2.1, 2.2, 3.0</source>
          <target state="translated">장고 1.11, 2.0, 2.1, 2.2, 3.0</target>
        </trans-unit>
        <trans-unit id="a57ade0e7edd103cd1d485c8463965b1ac7633a8" translate="yes" xml:space="preserve">
          <source>Django utility for a memoization decorator that uses the Django cache framework.</source>
          <target state="translated">Django 캐시 프레임 워크를 사용하는 메모 데코레이터 용 Django 유틸리티입니다.</target>
        </trans-unit>
        <trans-unit id="8f99733e60eb12c427254adc05371199f97031b9" translate="yes" xml:space="preserve">
          <source>Exact same functionality as</source>
          <target state="translated">다음과 정확히 동일한 기능</target>
        </trans-unit>
        <trans-unit id="654d7a479004b2b26e7de7b5ed9cd79a331ded80" translate="yes" xml:space="preserve">
          <source>Example Usage</source>
          <target state="translated">사용법 예</target>
        </trans-unit>
        <trans-unit id="97cdbdc7feff827efb082a6b6dd2727237cd49fd" translate="yes" xml:space="preserve">
          <source>False</source>
          <target state="translated">그릇된</target>
        </trans-unit>
        <trans-unit id="eacfb351a37f91d2ddcd1a637cc6d5b859374c16" translate="yes" xml:space="preserve">
          <source>For cases like this, Django exposes a simple, low-level cache API. You can
use this API to store objects in the cache with any level of granularity
you like. You can cache any Python object that can be pickled safely:
strings, dictionaries, lists of model objects, and so forth. (Most
common Python objects can be pickled; refer to the Python documentation
for more information about pickling.)</source>
          <target state="translated">이와 같은 경우 Django는 간단한 저수준 캐시 API를 제공합니다. 이 API를 사용하여 원하는 세분화 수준으로 캐시에 개체를 저장할 수 있습니다. 안전하게 피클 할 수있는 모든 Python 객체 (문자열, 사전, 모델 객체 목록 등)를 캐시 할 수 있습니다. (대부분의 일반적인 Python 객체는 피클 할 수 있습니다. 피클 링에 대한 자세한 내용은 Python 문서를 참조하세요.)</target>
        </trans-unit>
        <trans-unit id="c127c7a6353c9161520bb9cf466c2ad170121c8e" translate="yes" xml:space="preserve">
          <source>For versions of Python and Django, check out &lt;a href=&quot;https://github.com/peterbe/django-cache-memoize/blob/master/tox.ini&quot;&gt;the tox.ini file&lt;/a&gt;.</source>
          <target state="translated">Python 및 Django 버전의 &lt;a href=&quot;https://github.com/peterbe/django-cache-memoize/blob/master/tox.ini&quot;&gt;경우 tox.ini 파일을&lt;/a&gt; 확인하세요 .</target>
        </trans-unit>
        <trans-unit id="90ccd6497400b5576aeca1bd94af74aae1e0a250" translate="yes" xml:space="preserve">
          <source>History</source>
          <target state="translated">역사</target>
        </trans-unit>
        <trans-unit id="31eeefb0cc8def847d0cd40be77be1e18d9b669d" translate="yes" xml:space="preserve">
          <source>However, this works&amp;hellip;</source>
          <target state="translated">그러나 이것은 작동합니다&amp;hellip;</target>
        </trans-unit>
        <trans-unit id="2d1e7cecea0d3e8b3a70342e1c998a736be94364" translate="yes" xml:space="preserve">
          <source>I found</source>
          <target state="translated">나는 발견했다</target>
        </trans-unit>
        <trans-unit id="dff2aa583f28c699de8049360dc0ce52eb30bec6" translate="yes" xml:space="preserve">
          <source>If set, a function that gets called with the original argument and keyword
arguments &lt;strong&gt;if&lt;/strong&gt; the cache was able to find and return a cache hit.
For example, suppose you want to tell your</source>
          <target state="translated">설정된 &lt;strong&gt;경우&lt;/strong&gt; 캐시가 캐시 적중을 찾아 반환 할 수있는 &lt;strong&gt;경우&lt;/strong&gt; 원래 인수 및 키워드 인수로 호출되는 함수입니다 . 예를 들어,</target>
        </trans-unit>
        <trans-unit id="46f1baf59147d06cab6a248e863fac0b1b90b01a" translate="yes" xml:space="preserve">
          <source>In benchmarks running both</source>
          <target state="translated">둘 다 실행하는 벤치 마크에서</target>
        </trans-unit>
        <trans-unit id="d4bb5945ba5eb05b71622300259d5bae786c0b1f" translate="yes" xml:space="preserve">
          <source>Insight into cache hits and cache missed with a callback.</source>
          <target state="translated">콜백으로 누락 된 캐시 적중 및 캐시에 대한 통찰력.</target>
        </trans-unit>
        <trans-unit id="c81b79df3c6448eae7c4f80428b54cd5692a17d7" translate="yes" xml:space="preserve">
          <source>Installation</source>
          <target state="translated">설치</target>
        </trans-unit>
        <trans-unit id="28bb408cf6748a2669f64e5cc7fae7cc107d035b" translate="yes" xml:space="preserve">
          <source>Internally the decorator rewrites every argument and keyword argument to
the function it wraps into a concatenated string. The first thing you
might want to do is help the decorator rewrite the arguments to something
more suitable as a cache key string. For example, suppose you have instances
of a class whose</source>
          <target state="translated">내부적으로 데코레이터는 모든 인수와 키워드 인수를 연결된 문자열로 래핑하는 함수에 다시 작성합니다. 가장 먼저해야 할 일은 데코레이터가 인수를 캐시 키 문자열로 더 적합한 것으로 다시 작성하도록 돕는 것입니다. 예를 들어 다음과 같은 클래스의 인스턴스가 있다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="b678919728657ea65b442a31404d2f928488f8da" translate="yes" xml:space="preserve">
          <source>It demonstrates similarly to the above Usage example but with a little more
detail. In particular it demonstrates the difference between &lt;em&gt;not&lt;/em&gt; using</source>
          <target state="translated">위의 사용 예와 유사하지만 조금 더 자세히 설명합니다. 특히 그것은 사용 &lt;em&gt;하지 않는&lt;/em&gt; 것의 차이점을 보여줍니다</target>
        </trans-unit>
        <trans-unit id="c961da4e3b66e2f97987a7afe330011eb7cb4e36" translate="yes" xml:space="preserve">
          <source>Key Features</source>
          <target state="translated">주요 특징들</target>
        </trans-unit>
        <trans-unit id="9ee5748c28412f181c0feb7f1944a0f013fb8598" translate="yes" xml:space="preserve">
          <source>License: MPL 2.0</source>
          <target state="translated">라이센스 : MPL 2.0</target>
        </trans-unit>
        <trans-unit id="95eb537f1f43117e2efaa31432c732381cc7792a" translate="yes" xml:space="preserve">
          <source>Memoized function calls can be invalidated.</source>
          <target state="translated">메모 된 함수 호출은 무효화 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e22c1d1c10240eafae9cf8c0c19975c8915cc6fa" translate="yes" xml:space="preserve">
          <source>New uploads are arriving as zip file bundles of files, from Mozilla&amp;rsquo;s build
systems, at a rate of about 600MB every minute, each containing on average
about 100 files each. When a new upload comes in we need to quickly be able
find out if it exists in S3 and this gets cached since often the same files
are repeated in different uploads. But when a file does get uploaded into S3
we need to quickly and confidently invalidate any local caches. That way you
get to keep a really aggressive cache without any stale periods.</source>
          <target state="translated">새로운 업로드는 Mozilla의 빌드 시스템에서 분당 약 600MB의 속도로 파일의 zip 파일 번들로 도착하며 각각 평균 ​​약 100 개의 파일을 포함합니다. 새 업로드가 들어 오면 S3에 있는지 신속하게 알아낼 수 있어야하며 동일한 파일이 다른 업로드에서 반복되는 경우가 많기 때문에 캐시됩니다. 그러나 파일이 S3에 업로드되면 모든 로컬 캐시를 빠르고 확실하게 무효화해야합니다. 이렇게하면 오래된 기간없이 매우 공격적인 캐시를 유지할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f184d44b598b788adde29d493e92a5c25b0ed0b5" translate="yes" xml:space="preserve">
          <source>Prior Art</source>
          <target state="translated">선행 기술</target>
        </trans-unit>
        <trans-unit id="e1f0561decc4c7ee615ce7515e92fc9e586d4dc8" translate="yes" xml:space="preserve">
          <source>Python 3.4, 3.5, 3.6, 3.7</source>
          <target state="translated">파이썬 3.4, 3.5, 3.6, 3.7</target>
        </trans-unit>
        <trans-unit id="2cd4b406ae0bb568e7df884db51c4e2de1e96c91" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://docs.djangoproject.com/en/1.11/topics/cache/#the-low-level-cache-api&quot;&gt;documentation&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://docs.djangoproject.com/en/1.11/topics/cache/#the-low-level-cache-api&quot;&gt;설명서를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="93ef0dd827103681fcee453b78be2ff14e1a261d" translate="yes" xml:space="preserve">
          <source>The</source>
          <target state="translated">그만큼</target>
        </trans-unit>
        <trans-unit id="0fabf29b01ae976d48430cd70d46e857b0923aae" translate="yes" xml:space="preserve">
          <source>The caching uses &lt;a href=&quot;https://docs.djangoproject.com/en/1.11/topics/cache/&quot;&gt;Django&amp;rsquo;s default cache framework&lt;/a&gt;. Ultimately, it calls</source>
          <target state="translated">캐싱은 &lt;a href=&quot;https://docs.djangoproject.com/en/1.11/topics/cache/&quot;&gt;Django의 기본 캐시 프레임 워크를 사용&lt;/a&gt; 합니다. 궁극적으로</target>
        </trans-unit>
        <trans-unit id="69416aae8f6e90c66323ed064f4902f45ddb3690" translate="yes" xml:space="preserve">
          <source>The most basic thing is to clone the repo and run:</source>
          <target state="translated">가장 기본적인 것은 저장소를 복제하고 실행하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="79aca7afb5689b85853200c712230fe7c9f6f4ea" translate="yes" xml:space="preserve">
          <source>There is already &lt;a href=&quot;http://pythonhosted.org/django-memoize/&quot;&gt;django-memoize&lt;/a&gt; by &lt;a href=&quot;https://github.com/tvavrys&quot;&gt;Thomas Vavrys&lt;/a&gt;.
It too is available as a memoization decorator you use in Django. And it
uses the default cache framework as a storage. It used</source>
          <target state="translated">이미 &lt;a href=&quot;https://github.com/tvavrys&quot;&gt;Thomas Vavrys의 &lt;/a&gt;&lt;a href=&quot;http://pythonhosted.org/django-memoize/&quot;&gt;django-memoize&lt;/a&gt; 가 있습니다. Django에서 사용하는 메모 데코레이터로도 사용할 수 있습니다. 그리고 기본 캐시 프레임 워크를 저장소로 사용합니다. 사용</target>
        </trans-unit>
        <trans-unit id="e1fd32e9479a8d9629519ca06d6314d4a453b727" translate="yes" xml:space="preserve">
          <source>There is no way to clear more than one cache key. In the above example,
you had to know the &amp;ldquo;original arguments&amp;rdquo; when you wanted to invalidate
the cache. There is no method &amp;ldquo;search&amp;rdquo; for all cache keys that match a
certain pattern.</source>
          <target state="translated">둘 이상의 캐시 키를 지우는 방법은 없습니다. 위의 예에서 캐시를 무효화하려면 &quot;원래 인수&quot;를 알아야했습니다. 특정 패턴과 일치하는 모든 캐시 키를 &quot;검색&quot;하는 방법은 없습니다.</target>
        </trans-unit>
        <trans-unit id="a884f2faf6825ccf26aff0dbc9395db6b4d54129" translate="yes" xml:space="preserve">
          <source>This blog post: &lt;a href=&quot;https://www.peterbe.com/plog/how-to-use-django-cache-memoize&quot;&gt;How to use django-cache-memoize&lt;/a&gt;</source>
          <target state="translated">이 블로그 게시물 : &lt;a href=&quot;https://www.peterbe.com/plog/how-to-use-django-cache-memoize&quot;&gt;django-cache-memoize 사용 방법&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="96e8906e8784301f166709fb0c52f6fc3e25ad3a" translate="yes" xml:space="preserve">
          <source>This is a contrived example, but basically &lt;em&gt;you know&lt;/em&gt; that the</source>
          <target state="translated">이것은 인위적인 예이지만, 기본적으로 &lt;em&gt;당신은 알고&lt;/em&gt; 것을</target>
        </trans-unit>
        <trans-unit id="88b371a5aa0588701d7c4024ea93a09a38f1d07c" translate="yes" xml:space="preserve">
          <source>This is the use case</source>
          <target state="translated">이것이 유스 케이스입니다.</target>
        </trans-unit>
        <trans-unit id="8761cf1620b74a634c1f7aa4939f54f3997a2863" translate="yes" xml:space="preserve">
          <source>This is useful if you have a function you want to make sure only gets called
once per timeout expiration but you don&amp;rsquo;t actually care that much about
what the function return value was. Perhaps because you know that the
function returns something that would quickly fill up your</source>
          <target state="translated">이것은 타임 아웃 만료 당 한 번만 호출되도록하려는 함수가 있지만 실제로 함수 반환 값이 무엇인지에 대해서는 그다지 신경 쓰지 않는 경우에 유용합니다. 아마도 함수가 빠르게 채워지는 것을 반환한다는 것을 알고 있기 때문일 것입니다.</target>
        </trans-unit>
        <trans-unit id="650e69b32239f5b5255bb7d62bf3983174bc1da2" translate="yes" xml:space="preserve">
          <source>This service gets a LOT of traffic. The download traffic (proxying requests
for symbols in S3) gets about ~40 requests per second. Due to the nature
of the application most of these GETs result in a 404 Not Found but instead
of asking AWS S3 for every single file, these lookups are cached in a
highly configured &lt;a href=&quot;https://redis.io/&quot;&gt;Redis&lt;/a&gt; configuration. This Redis cache is also connected
to the part of the code that uploads new files.</source>
          <target state="translated">이 서비스는 많은 트래픽을 가져옵니다. 다운로드 트래픽 (S3의 심볼에 대한 프록시 요청)은 초당 약 40 개 요청을받습니다. 애플리케이션의 특성으로 인해 이러한 GET의 대부분은 404 Not Found가 발생하지만 모든 단일 파일에 대해 AWS S3를 요청하는 대신 이러한 조회는 고도로 구성된 &lt;a href=&quot;https://redis.io/&quot;&gt;Redis&lt;/a&gt; 구성에 캐시됩니다 . 이 Redis 캐시는 새 파일을 업로드하는 코드 부분에도 연결됩니다.</target>
        </trans-unit>
        <trans-unit id="fd6a68ad54dd35d7d49f345e65bbbe1e77795fb8" translate="yes" xml:space="preserve">
          <source>To check linting with</source>
          <target state="translated">보풀을 확인하려면</target>
        </trans-unit>
        <trans-unit id="032ef0eb8dec93b7e7afbf4e77825cceb1a68639" translate="yes" xml:space="preserve">
          <source>To install the</source>
          <target state="translated">설치하려면</target>
        </trans-unit>
        <trans-unit id="88b33e4e12f75ac8bf792aebde41f1a090f3a612" translate="yes" xml:space="preserve">
          <source>True</source>
          <target state="translated">진실</target>
        </trans-unit>
        <trans-unit id="0bb18642b70b9f8a9c12ccf39487328f306b8e19" translate="yes" xml:space="preserve">
          <source>Usage</source>
          <target state="translated">용법</target>
        </trans-unit>
        <trans-unit id="768a0f8218c09504241ccf7722807f3194fe7e32" translate="yes" xml:space="preserve">
          <source>When you run</source>
          <target state="translated">당신이 달릴 때</target>
        </trans-unit>
        <trans-unit id="4afb59a83fb8064633a4597f3c972d80ff1693b5" translate="yes" xml:space="preserve">
          <source>When you want to &amp;ldquo;undo&amp;rdquo; some caching done, you simply call the function
again with the same arguments except you add</source>
          <target state="translated">일부 캐싱을 &quot;실행 취소&quot;하려면 추가하는 것을 제외하고 동일한 인수를 사용하여 함수를 다시 호출하기 만하면됩니다.</target>
        </trans-unit>
        <trans-unit id="49b9baa2954d1440877eb4b80f37995a181297be" translate="yes" xml:space="preserve">
          <source>Works with non-trivial arguments and keyword arguments</source>
          <target state="translated">중요하지 않은 인수 및 키워드 인수와 함께 작동합니다.</target>
        </trans-unit>
        <trans-unit id="145b45cbc08ae9b05fff89019c2e31ad888355df" translate="yes" xml:space="preserve">
          <source>__str__</source>
          <target state="translated">__str__</target>
        </trans-unit>
        <trans-unit id="a4d2bac54e12a16306abedb9ee76efe7146eed42" translate="yes" xml:space="preserve">
          <source>_refresh=True</source>
          <target state="translated">_refresh = 참</target>
        </trans-unit>
        <trans-unit id="cffa50a32cb13a240d705317bcec65dd1f31b6ad" translate="yes" xml:space="preserve">
          <source>and</source>
          <target state="translated">과</target>
        </trans-unit>
        <trans-unit id="4d911ebf7913ac41fb9b9b5971ef20d0b1715324" translate="yes" xml:space="preserve">
          <source>and then adding it to your code after.</source>
          <target state="translated">그런 다음 코드에 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="075d408136da3093c1320171e98d32b766508126" translate="yes" xml:space="preserve">
          <source>args_rewrite</source>
          <target state="translated">args_rewrite</target>
        </trans-unit>
        <trans-unit id="034373531242ccb88e4a23e703c0c45f7a2b3f75" translate="yes" xml:space="preserve">
          <source>argument allows you to use a cache other than the default.</source>
          <target state="translated">인수를 사용하면 기본값 이외의 캐시를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5aa4352fe7730966ddcc032da8e484d48e33b881" translate="yes" xml:space="preserve">
          <source>cache_alias</source>
          <target state="translated">cache_alias</target>
        </trans-unit>
        <trans-unit id="ee6c0c88442fb75d05c7fae83539af81eba3bd8b" translate="yes" xml:space="preserve">
          <source>conversion of certain arguments isn&amp;rsquo;t safe. Then you can pass in a callable
called</source>
          <target state="translated">특정 인수의 변환은 안전하지 않습니다. 그런 다음 호출 가능한 호출을 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1e21c4fd0ecc353240fb4daa6918e4bc23cb5926" translate="yes" xml:space="preserve">
          <source>django-cache-memoize</source>
          <target state="translated">django-cache-memoize</target>
        </trans-unit>
        <trans-unit id="ca1bcc56b8ac1d212738fe3761c5733e7e1e5202" translate="yes" xml:space="preserve">
          <source>django-memoize</source>
          <target state="translated">django-memoize</target>
        </trans-unit>
        <trans-unit id="83655978ff4986a00479ba572a0650e7d6afeb00" translate="yes" xml:space="preserve">
          <source>django.core.cache.cache.set(cache_key, function_out, expiration)</source>
          <target state="translated">django.core.cache.cache.set (cache_key, function_out, 만료)</target>
        </trans-unit>
        <trans-unit id="d04d6b5227e45ed7d1e2b779ddb25a19563ca79f" translate="yes" xml:space="preserve">
          <source>except the obvious difference
that it gets called if it was &lt;em&gt;not&lt;/em&gt; a cache hit.</source>
          <target state="translated">캐시 적중 이 &lt;em&gt;아닌&lt;/em&gt; 경우 호출되는 명백한 차이점을 제외하고 .</target>
        </trans-unit>
        <trans-unit id="8f27e4f0b0e1fabc56425bc40b6e79fabb64c9af" translate="yes" xml:space="preserve">
          <source>flake8</source>
          <target state="translated">플레이크 8</target>
        </trans-unit>
        <trans-unit id="4bea928f978b80953a462f43c97fd0c7217b29ec" translate="yes" xml:space="preserve">
          <source>hit_callable</source>
          <target state="translated">hit_callable</target>
        </trans-unit>
        <trans-unit id="a1a2ae18fa153a52a05172a40a60c6c0848214e2" translate="yes" xml:space="preserve">
          <source>inspect</source>
          <target state="translated">검사하다</target>
        </trans-unit>
        <trans-unit id="bfc7ce912866e8975c538d814c39a3c899b0303f" translate="yes" xml:space="preserve">
          <source>is also used in &lt;a href=&quot;https://songsear.ch&quot;&gt;SongSear.ch&lt;/a&gt; to cache short
queries in the autocomplete search input. All autocomplete is done by
Elasticsearch, which is amazingly fast, but not as fast as</source>
          <target state="translated">자동 완성 검색 입력에서 짧은 쿼리를 캐시하기 위해 &lt;a href=&quot;https://songsear.ch&quot;&gt;SongSear.ch&lt;/a&gt; 에서도 사용됩니다 . 모든 자동 완성은 놀랍도록 빠르지 만 그만큼 빠르지는 않은 Elasticsearch에 의해 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="8e0a88a8f80897eab0baeaf5d470318edd276a02" translate="yes" xml:space="preserve">
          <source>it will only check the files you&amp;rsquo;ve touched.
To run it for all files use:</source>
          <target state="translated">터치 한 파일 만 확인합니다. 모든 파일에 대해 실행하려면 다음을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="ebf4a2fb4c21393bd3b0f15341b36c9367fc8350" translate="yes" xml:space="preserve">
          <source>memcached</source>
          <target state="translated">memcached</target>
        </trans-unit>
        <trans-unit id="38bdf1b7b2f334bb0e04539854077b708945e1a5" translate="yes" xml:space="preserve">
          <source>method doesn&amp;rsquo;t return a unique value. For example:</source>
          <target state="translated">메서드는 고유 한 값을 반환하지 않습니다. 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="359bf218f380faa3b508b0d52398c1d82faa4447" translate="yes" xml:space="preserve">
          <source>miss_callable</source>
          <target state="translated">miss_callable</target>
        </trans-unit>
        <trans-unit id="5913a59c742b6f7ddaff13288ca5440da9d3e641" translate="yes" xml:space="preserve">
          <source>on the
decorated function to build a cache key.</source>
          <target state="translated">장식 된 함수에 캐시 키를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="9147986e14654f718d2ca5614901f9cbb16ffedc" translate="yes" xml:space="preserve">
          <source>or
perhaps you know it returns something that can&amp;rsquo;t be pickled. Then you
can set</source>
          <target state="translated">또는 절임 할 수없는 것을 반환한다는 것을 알고있을 것입니다. 그런 다음 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3a86b4f955fdbaf12a19a6b2f43abbc097c6c857" translate="yes" xml:space="preserve">
          <source>pre-commit hook simply run:</source>
          <target state="translated">사전 커밋 후크는 다음을 실행합니다.</target>
        </trans-unit>
        <trans-unit id="b4ebfe34d0fa97f0dd2bb1234fad8f59805f4e8d" translate="yes" xml:space="preserve">
          <source>prefix</source>
          <target state="translated">접두사</target>
        </trans-unit>
        <trans-unit id="f644b7f7c3513bd8118b5fdb1b3b09e20b03d49e" translate="yes" xml:space="preserve">
          <source>repr()</source>
          <target state="translated">repr ()</target>
        </trans-unit>
        <trans-unit id="d8ce2dda7d24b72634dc662ee116a12b6f6d2a4e" translate="yes" xml:space="preserve">
          <source>server every time
there&amp;rsquo;s a cache hit.</source>
          <target state="translated">캐시 적중이 발생할 때마다 서버.</target>
        </trans-unit>
        <trans-unit id="e76c3ee222fac4befe15667056f4b2920a123b38" translate="yes" xml:space="preserve">
          <source>statsd</source>
          <target state="translated">statsd</target>
        </trans-unit>
        <trans-unit id="78002de9e5d5335e08a33a0d8d2445e4a64dccdf" translate="yes" xml:space="preserve">
          <source>store_result</source>
          <target state="translated">store_result</target>
        </trans-unit>
        <trans-unit id="3346abc026c7e2630a0511db843d74222dbf1533" translate="yes" xml:space="preserve">
          <source>str()</source>
          <target state="translated">str ()</target>
        </trans-unit>
        <trans-unit id="cbcbe46084f65e236884cc6e9855d5767ce177d9" translate="yes" xml:space="preserve">
          <source>therapist</source>
          <target state="translated">치료사</target>
        </trans-unit>
        <trans-unit id="c03b431e6d407109eb5c7098b58a51252f15fd87" translate="yes" xml:space="preserve">
          <source>therapist run</source>
          <target state="translated">치료사 실행</target>
        </trans-unit>
        <trans-unit id="4374aaee247fb237ce6c97d5c8d64bbe474d16de" translate="yes" xml:space="preserve">
          <source>to</source>
          <target state="translated">에</target>
        </trans-unit>
        <trans-unit id="310e5c24ed1c9e43d455ac90257e5431ee8150e5" translate="yes" xml:space="preserve">
          <source>to be &lt;strong&gt;~4 times faster&lt;/strong&gt; on average.</source>
          <target state="translated">수하는 &lt;strong&gt;~ 4 배 빠른&lt;/strong&gt; 평균.</target>
        </trans-unit>
        <trans-unit id="99d8e905a7d600faf9a9d9c17521371f9cee7e52" translate="yes" xml:space="preserve">
          <source>to check other things
Black can&amp;rsquo;t check.</source>
          <target state="translated">Black이 확인할 수없는 다른 것들을 확인하기 위해.</target>
        </trans-unit>
        <trans-unit id="72bfe11a92639014f0cdb9cf1c3ace8e0c5d115d" translate="yes" xml:space="preserve">
          <source>to the function.</source>
          <target state="translated">기능에.</target>
        </trans-unit>
        <trans-unit id="7bdf31978c0210720b3420242d2f1d74927c098c" translate="yes" xml:space="preserve">
          <source>tox</source>
          <target state="translated">독극물</target>
        </trans-unit>
        <trans-unit id="0d57c3cb335cbcd6be4a00d2b3759c640eb0d722" translate="yes" xml:space="preserve">
          <source>use:</source>
          <target state="translated">사용하다:</target>
        </trans-unit>
        <trans-unit id="a7e2c648dc9941f38aea4196f90df226d6e93b2b" translate="yes" xml:space="preserve">
          <source>uses</source>
          <target state="translated">용도</target>
        </trans-unit>
        <trans-unit id="9666f8671ec96151fd7bf6c20ec1ae92d1258331" translate="yes" xml:space="preserve">
          <source>was built for and tested in.
It was originally written for Python 3.6 in Django 1.11 but when
extracted, made compatible with Python 2.7 and as far back as Django 1.8.</source>
          <target state="translated">원래 Django 1.11에서 Python 3.6 용으로 작성되었지만 추출시 Python 2.7과 호환되며 Django 1.8까지 거슬러 올라갑니다.</target>
        </trans-unit>
        <trans-unit id="66696c9cfa39181b00e5ae7d2bc628b38e67ff88" translate="yes" xml:space="preserve">
          <source>which in certain cases of mutable objects
(e.g. class instances) as arguments the caching will not work. For example,
this does &lt;em&gt;not&lt;/em&gt; work in</source>
          <target state="translated">인수로 사용되는 변경 가능한 객체 (예 : 클래스 인스턴스)의 경우 캐싱이 작동하지 않습니다. 예를 들어,이 않습니다 &lt;em&gt;하지&lt;/em&gt; 에서 작동</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
