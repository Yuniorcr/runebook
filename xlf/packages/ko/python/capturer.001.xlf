<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://pypi.org/project/capturer/">
    <body>
      <group id="capturer">
        <trans-unit id="067d37005e41e9e28425c1041aba52aa775ce3db" translate="yes" xml:space="preserve">
          <source>&amp;copy; 2020 Peter Odding.</source>
          <target state="translated">&amp;copy; 2020 피터 오딩.</target>
        </trans-unit>
        <trans-unit id="96a313b29626f9c796fd0c58c93ed79675febfc2" translate="yes" xml:space="preserve">
          <source>A big thanks goes out to the &lt;a href=&quot;https://pypi.org/project/pytest&quot;&gt;pytest&lt;/a&gt; developers because pytest&amp;rsquo;s mechanism for
capturing the output of subprocesses provided inspiration for the</source>
          <target state="translated">&lt;a href=&quot;https://pypi.org/project/pytest&quot;&gt;pytest&lt;/a&gt; 개발자들 에게 큰 감사를 표합니다. pytest 의 하위 프로세스 출력 캡처 메커니즘이</target>
        </trans-unit>
        <trans-unit id="5067ec6ec3c8bc695f33d7314315ee45d6022ae2" translate="yes" xml:space="preserve">
          <source>All output captured is relayed on the &lt;a href=&quot;https://en.wikipedia.org/wiki/Standard_streams#Standard_error_.28stderr.29&quot;&gt;stderr&lt;/a&gt; stream by default, so capturing
changes the semantics of your programs. How much this matters obviously
depends on your use case. For the use cases that triggered me to create</source>
          <target state="translated">캡처 된 모든 출력은 기본적으로 &lt;a href=&quot;https://en.wikipedia.org/wiki/Standard_streams#Standard_error_.28stderr.29&quot;&gt;stderr&lt;/a&gt; 스트림에 전달 되므로 캡처하면 프로그램의 의미가 변경됩니다. 이것이 얼마나 중요한지는 사용 사례에 따라 다릅니다. 나를 만들게 한 사용 사례</target>
        </trans-unit>
        <trans-unit id="8c94fc11e4f1956615d07ca478e8a24defe94515" translate="yes" xml:space="preserve">
          <source>CaptureOutput</source>
          <target state="translated">CaptureOutput</target>
        </trans-unit>
        <trans-unit id="0173862a56b8960fa3799085a3af62407f739de2" translate="yes" xml:space="preserve">
          <source>CaptureOutput(merged=False)</source>
          <target state="translated">CaptureOutput (병합 = False)</target>
        </trans-unit>
        <trans-unit id="b37456c4530be810dc040f50da72eda09addfb0a" translate="yes" xml:space="preserve">
          <source>Contact</source>
          <target state="translated">접촉</target>
        </trans-unit>
        <trans-unit id="f26d7814fc08c5accfe0925c334424a0f5185a51" translate="yes" xml:space="preserve">
          <source>Design choices</source>
          <target state="translated">디자인 선택</target>
        </trans-unit>
        <trans-unit id="ce1ec03c06db3b1cd681378b14d3d8988481cd83" translate="yes" xml:space="preserve">
          <source>Easily capture stdout/stderr of the current process and subprocesses</source>
          <target state="translated">현재 프로세스 및 하위 프로세스의 stdout / stderr를 쉽게 캡처</target>
        </trans-unit>
        <trans-unit id="76e7a3a3f9c225fe820ba7e9cff10ea2a73b79a1" translate="yes" xml:space="preserve">
          <source>Getting started</source>
          <target state="translated">시작하기</target>
        </trans-unit>
        <trans-unit id="6d477e9f192964a9fe4e48582901c3444ead950a" translate="yes" xml:space="preserve">
          <source>I say experimental because this method of capturing can unintentionally
change the order in which captured output is emitted, in order to avoid
interleaving output emitted on the &lt;a href=&quot;https://en.wikipedia.org/wiki/Standard_streams#Standard_output_.28stdout.29&quot;&gt;stdout&lt;/a&gt; and &lt;a href=&quot;https://en.wikipedia.org/wiki/Standard_streams#Standard_error_.28stderr.29&quot;&gt;stderr&lt;/a&gt; streams (which would
most likely result in incomprehensible output). Basically output is relayed
on each stream separately after each line break. This means interactive
prompts that block on reading from standard input without emitting a line
break won&amp;rsquo;t show up (until it&amp;rsquo;s too late ;-).</source>
          <target state="translated">이 캡처 방법은 &lt;a href=&quot;https://en.wikipedia.org/wiki/Standard_streams#Standard_output_.28stdout.29&quot;&gt;stdout&lt;/a&gt; 및 &lt;a href=&quot;https://en.wikipedia.org/wiki/Standard_streams#Standard_error_.28stderr.29&quot;&gt;stderr&lt;/a&gt; 스트림 에서 방출되는 출력을 인터리빙하는 것을 피하기 위해 의도하지 않게 캡처 된 출력이 방출되는 순서를 변경할 수 있기 때문에 실험적이라고 말합니다 (이해할 수없는 출력을 초래할 가능성이 높습니다). 기본적으로 출력은 각 줄 바꿈 후에 개별적으로 각 스트림에서 릴레이됩니다. 즉, 줄 바꿈없이 표준 입력에서 읽기를 차단하는 대화 형 프롬프트가 표시되지 않습니다 (너무 늦을 때까지 ;-).</target>
        </trans-unit>
        <trans-unit id="c81b79df3c6448eae7c4f80428b54cd5692a17d7" translate="yes" xml:space="preserve">
          <source>Installation</source>
          <target state="translated">설치</target>
        </trans-unit>
        <trans-unit id="47f9a8b6f738de18de4d17340d61c56f28aa624e" translate="yes" xml:space="preserve">
          <source>Intercepts writes to low level file descriptors</source>
          <target state="translated">낮은 수준의 파일 설명자에 대한 쓰기 차단</target>
        </trans-unit>
        <trans-unit id="62de9052cf06aea7ff2b5663d068e174e3368ec8" translate="yes" xml:space="preserve">
          <source>Libraries like &lt;a href=&quot;https://pypi.org/project/capture&quot;&gt;capture&lt;/a&gt; and &lt;a href=&quot;https://pypi.org/project/iocapture&quot;&gt;iocapture&lt;/a&gt; change Python&amp;rsquo;s &lt;a href=&quot;https://docs.python.org/2/library/sys.html#sys.stdout&quot;&gt;sys.stdout&lt;/a&gt; and
&lt;a href=&quot;https://docs.python.org/2/library/sys.html#sys.stderr&quot;&gt;sys.stderr&lt;/a&gt; file objects to fake file objects (using &lt;a href=&quot;https://docs.python.org/2/library/stringio.html&quot;&gt;StringIO&lt;/a&gt;). This enables
capturing of (most) output written to the &lt;a href=&quot;https://en.wikipedia.org/wiki/Standard_streams#Standard_output_.28stdout.29&quot;&gt;stdout&lt;/a&gt; and &lt;a href=&quot;https://en.wikipedia.org/wiki/Standard_streams#Standard_error_.28stderr.29&quot;&gt;stderr&lt;/a&gt; streams from the
same Python process, however any output from subprocesses is unaffected by the
redirection and not captured.</source>
          <target state="translated">&lt;a href=&quot;https://pypi.org/project/capture&quot;&gt;capture&lt;/a&gt; 및 &lt;a href=&quot;https://pypi.org/project/iocapture&quot;&gt;iocapture&lt;/a&gt; 와 같은 라이브러리는 Python의 &lt;a href=&quot;https://docs.python.org/2/library/sys.html#sys.stdout&quot;&gt;sys.stdout&lt;/a&gt; 및 &lt;a href=&quot;https://docs.python.org/2/library/sys.html#sys.stderr&quot;&gt;sys.stderr&lt;/a&gt; 파일 객체를 가짜 파일 객체로 변경합니다 ( &lt;a href=&quot;https://docs.python.org/2/library/stringio.html&quot;&gt;StringIO&lt;/a&gt; 사용 ). 이렇게하면 동일한 Python 프로세스에서 &lt;a href=&quot;https://en.wikipedia.org/wiki/Standard_streams#Standard_output_.28stdout.29&quot;&gt;stdout&lt;/a&gt; 및 &lt;a href=&quot;https://en.wikipedia.org/wiki/Standard_streams#Standard_error_.28stderr.29&quot;&gt;stderr&lt;/a&gt; 스트림에 기록 된 (대부분의) 출력을 캡처 할 수 있지만 하위 프로세스의 모든 출력은 리디렉션의 영향을받지 않고 캡처되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3229609e15436ec51bcf00818a69a84dbc58a0c2" translate="yes" xml:space="preserve">
          <source>License</source>
          <target state="translated">특허</target>
        </trans-unit>
        <trans-unit id="73457a5e828fb3b721e39222bf814b197e899a6a" translate="yes" xml:space="preserve">
          <source>Long running operations can provide the operator with real time feedback by
emitting output on the terminal. This sounds obvious (and it is!) but it is
non-trivial to implement (an understatement :-) when you &lt;em&gt;also&lt;/em&gt; want to
capture the output.</source>
          <target state="translated">장기 실행 작업은 터미널에서 출력을 내보냄으로써 운영자에게 실시간 피드백을 제공 할 수 있습니다. 이 분명한 소리 (그것은이다!)하지만 당신은 때 (삼가을 :-) 구현이 아닌 사소한 &lt;em&gt;도&lt;/em&gt; 출력을 캡처 할.</target>
        </trans-unit>
        <trans-unit id="5c38227657096bc714717fbafdc49d643ed3e74c" translate="yes" xml:space="preserve">
          <source>Note that the first call to &lt;a href=&quot;https://capturer.readthedocs.io/en/latest/api.html#capturer.CaptureOutput.get_bytes&quot;&gt;get_bytes()&lt;/a&gt;, &lt;a href=&quot;https://capturer.readthedocs.io/en/latest/api.html#capturer.CaptureOutput.get_lines&quot;&gt;get_lines()&lt;/a&gt; or &lt;a href=&quot;https://capturer.readthedocs.io/en/latest/api.html#capturer.CaptureOutput.get_text&quot;&gt;get_text()&lt;/a&gt;
will stop the capturing of output by default. This is intended as a sane
default to prevent partial reads (which can be confusing as hell when you don&amp;rsquo;t
have experience with them). So we could have simply used</source>
          <target state="translated">&lt;a href=&quot;https://capturer.readthedocs.io/en/latest/api.html#capturer.CaptureOutput.get_bytes&quot;&gt;get_bytes ()&lt;/a&gt; , &lt;a href=&quot;https://capturer.readthedocs.io/en/latest/api.html#capturer.CaptureOutput.get_lines&quot;&gt;get_lines ()&lt;/a&gt; 또는 &lt;a href=&quot;https://capturer.readthedocs.io/en/latest/api.html#capturer.CaptureOutput.get_text&quot;&gt;get_text ()에&lt;/a&gt; 대한 첫 번째 호출 은 기본적으로 출력 캡처를 중지합니다. 이것은 부분 읽기를 방지하기위한 정상적인 기본값으로 의도 된 것입니다 (경험이 없으면 지옥처럼 혼동 될 수 있음). 그래서 우리는 단순히</target>
        </trans-unit>
        <trans-unit id="a42b6f37f68ce916c7654d2325495e2ffc917711" translate="yes" xml:space="preserve">
          <source>Programs like &lt;a href=&quot;https://en.wikipedia.org/wiki/GNU_Privacy_Guard&quot;&gt;gpg&lt;/a&gt; and &lt;a href=&quot;https://en.wikipedia.org/wiki/Secure_Shell&quot;&gt;ssh&lt;/a&gt; that use interactive password prompts will render
their password prompt on the terminal in real time. This avoids the awkward
interaction where a password prompt is silenced but the program still hangs,
waiting for input on &lt;a href=&quot;https://en.wikipedia.org/wiki/Standard_streams#Standard_input_.28stdin.29&quot;&gt;stdin&lt;/a&gt;.</source>
          <target state="translated">대화 형 암호 프롬프트를 사용하는 &lt;a href=&quot;https://en.wikipedia.org/wiki/GNU_Privacy_Guard&quot;&gt;gpg&lt;/a&gt; 및 &lt;a href=&quot;https://en.wikipedia.org/wiki/Secure_Shell&quot;&gt;ssh&lt;/a&gt; 와 같은 프로그램 은 터미널에서 실시간으로 암호 프롬프트를 렌더링합니다. 이렇게하면 암호 프롬프트가 음소거되지만 프로그램이 &lt;a href=&quot;https://en.wikipedia.org/wiki/Standard_streams#Standard_input_.28stdin.29&quot;&gt;stdin&lt;/a&gt; 입력을 기다리는 어색한 상호 작용을 방지 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d606f457b941c69624384d635c6373c9af90939d" translate="yes" xml:space="preserve">
          <source>Relays output to the terminal in real time</source>
          <target state="translated">실시간으로 터미널에 출력 릴레이</target>
        </trans-unit>
        <trans-unit id="bae7d5be70820ed56467bd9a63744e23b47bd711" translate="yes" xml:space="preserve">
          <source>Status</source>
          <target state="translated">상태</target>
        </trans-unit>
        <trans-unit id="93ef0dd827103681fcee453b78be2ff14e1a261d" translate="yes" xml:space="preserve">
          <source>The</source>
          <target state="translated">그만큼</target>
        </trans-unit>
        <trans-unit id="0091e40260b7b58d6e652641475f696d15bcd706" translate="yes" xml:space="preserve">
          <source>The capturer package makes it easy to capture the &lt;a href=&quot;https://en.wikipedia.org/wiki/Standard_streams#Standard_output_.28stdout.29&quot;&gt;stdout&lt;/a&gt; and &lt;a href=&quot;https://en.wikipedia.org/wiki/Standard_streams#Standard_error_.28stderr.29&quot;&gt;stderr&lt;/a&gt; streams
of the current process &lt;em&gt;and subprocesses&lt;/em&gt;. Output can be relayed to the
terminal in real time but is also available to the Python program for
additional processing. It&amp;rsquo;s currently tested on cPython 2.7, 3.5+ and PyPy
(2.7). It&amp;rsquo;s tested on Linux and Mac OS X and may work on other unixes but
definitely won&amp;rsquo;t work on Windows (due to the use of the platform dependent &lt;a href=&quot;https://docs.python.org/2/library/pty.html&quot;&gt;pty&lt;/a&gt;
module). For usage instructions please refer to the &lt;a href=&quot;https://capturer.readthedocs.io&quot;&gt;documentation&lt;/a&gt;.</source>
          <target state="translated">capturer 패키지를 사용 하면 현재 프로세스 &lt;em&gt;및 하위 프로세스&lt;/em&gt; 의 &lt;a href=&quot;https://en.wikipedia.org/wiki/Standard_streams#Standard_output_.28stdout.29&quot;&gt;stdout&lt;/a&gt; 및 &lt;a href=&quot;https://en.wikipedia.org/wiki/Standard_streams#Standard_error_.28stderr.29&quot;&gt;stderr&lt;/a&gt; 스트림을 쉽게 캡처 할 수 있습니다. 출력은 실시간으로 터미널에 릴레이 될 수 있지만 추가 처리를 위해 Python 프로그램에서도 사용할 수 있습니다. 현재 cPython 2.7, 3.5+ 및 PyPy (2.7)에서 테스트되었습니다. Linux 및 Mac OS X에서 테스트되었으며 다른 유닉스에서도 작동 할 수 있지만 Windows에서는 작동하지 않습니다 (플랫폼에 따른 &lt;a href=&quot;https://docs.python.org/2/library/pty.html&quot;&gt;pty&lt;/a&gt; 모듈 사용으로 인해 ). 사용 지침은 참조하시기 바랍니다 &lt;a href=&quot;https://capturer.readthedocs.io&quot;&gt;문서&lt;/a&gt; .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="467730d33ffe3b679f8d21fea344daddf7fca4fb" translate="yes" xml:space="preserve">
          <source>The easiest way to capture output is to use a context manager:</source>
          <target state="translated">출력을 캡처하는 가장 쉬운 방법은 컨텍스트 관리자를 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="4e651dc5449474dd97ef6c540edb40ca90313c55" translate="yes" xml:space="preserve">
          <source>The latest version of</source>
          <target state="translated">최신 버전</target>
        </trans-unit>
        <trans-unit id="b909d18007f17d144eb5a6414f16718e1b9f9936" translate="yes" xml:space="preserve">
          <source>The main use case of</source>
          <target state="translated">주요 사용 사례</target>
        </trans-unit>
        <trans-unit id="96f334c1550fc35ac7537f7405268afe69e0c993" translate="yes" xml:space="preserve">
          <source>The use of &lt;a href=&quot;https://docs.python.org/2/library/pty.html#pty.openpty&quot;&gt;pty.openpty()&lt;/a&gt; means you need to be running in a UNIX like
environment for</source>
          <target state="translated">의 사용 &lt;a href=&quot;https://docs.python.org/2/library/pty.html#pty.openpty&quot;&gt;pty.openpty ()는&lt;/a&gt; 당신을위한 환경 같은 UNIX에서 실행해야 의미</target>
        </trans-unit>
        <trans-unit id="29ae03f183f2d9ce11ef204b3e59748bb4ff43f7" translate="yes" xml:space="preserve">
          <source>The use of a context manager (&lt;a href=&quot;https://docs.python.org/2/reference/compound_stmts.html#the-with-statement&quot;&gt;the with statement&lt;/a&gt;) ensures that output
capturing is enabled and disabled at the appropriate time, regardless of
whether exceptions interrupt the normal flow of processing.</source>
          <target state="translated">컨텍스트 관리자 ( &lt;a href=&quot;https://docs.python.org/2/reference/compound_stmts.html#the-with-statement&quot;&gt;with 문&lt;/a&gt; )를 사용하면 예외가 정상적인 처리 흐름을 방해하는지 여부에 관계없이 적절한 시간에 출력 캡처가 활성화 및 비활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="b0b1b7db39c535f73ba96f47cf4c93cde41211e0" translate="yes" xml:space="preserve">
          <source>There are existing solutions out there to capture the &lt;a href=&quot;https://en.wikipedia.org/wiki/Standard_streams#Standard_output_.28stdout.29&quot;&gt;stdout&lt;/a&gt; and &lt;a href=&quot;https://en.wikipedia.org/wiki/Standard_streams#Standard_error_.28stderr.29&quot;&gt;stderr&lt;/a&gt;
streams of (Python) processes. The</source>
          <target state="translated">(Python) 프로세스 의 &lt;a href=&quot;https://en.wikipedia.org/wiki/Standard_streams#Standard_output_.28stdout.29&quot;&gt;stdout&lt;/a&gt; 및 &lt;a href=&quot;https://en.wikipedia.org/wiki/Standard_streams#Standard_error_.28stderr.29&quot;&gt;stderr&lt;/a&gt; 스트림 을 캡처하는 기존 솔루션이 있습니다 . 그만큼</target>
        </trans-unit>
        <trans-unit id="bf16a5a2c76cab9516867262b98d421ead9a3db9" translate="yes" xml:space="preserve">
          <source>There is experimental support for capturing &lt;a href=&quot;https://en.wikipedia.org/wiki/Standard_streams#Standard_output_.28stdout.29&quot;&gt;stdout&lt;/a&gt; and &lt;a href=&quot;https://en.wikipedia.org/wiki/Standard_streams#Standard_error_.28stderr.29&quot;&gt;stderr&lt;/a&gt; separately
and relaying captured output to the appropriate original stream. Basically
you call</source>
          <target state="translated">&lt;a href=&quot;https://en.wikipedia.org/wiki/Standard_streams#Standard_output_.28stdout.29&quot;&gt;stdout&lt;/a&gt; 및 &lt;a href=&quot;https://en.wikipedia.org/wiki/Standard_streams#Standard_error_.28stderr.29&quot;&gt;stderr을&lt;/a&gt; 개별적으로 캡처하고 캡처 된 출력을 적절한 원본 스트림으로 릴레이 하기위한 실험적인 지원이 있습니다 . 기본적으로 전화</target>
        </trans-unit>
        <trans-unit id="413e33ea01e94adb5a7994e3b126429dad6e0aa0" translate="yes" xml:space="preserve">
          <source>There&amp;rsquo;s actually a multitude of ways to install Python packages (e.g. the &lt;a href=&quot;https://www.python.org/dev/peps/pep-0370/&quot;&gt;per
user site-packages directory&lt;/a&gt;, &lt;a href=&quot;http://docs.python-guide.org/en/latest/dev/virtualenvs/&quot;&gt;virtual environments&lt;/a&gt; or just installing
system wide) and I have no intention of getting into that discussion here, so
if this intimidates you then read up on your options before returning to these
instructions ;-).</source>
          <target state="translated">실제로 Python 패키지를 설치하는 방법에는 여러 가지가 있습니다 (예 : &lt;a href=&quot;https://www.python.org/dev/peps/pep-0370/&quot;&gt;사용자 별 site-packages 디렉토리&lt;/a&gt; , &lt;a href=&quot;http://docs.python-guide.org/en/latest/dev/virtualenvs/&quot;&gt;가상 환경&lt;/a&gt; 또는 시스템 전체 설치). 여기에서 논의 할 의도가 없습니다. 따라서 이것이 위협적인 경우 다음 내용을 읽어보십시오. 이 지침으로 돌아 가기 전에 옵션 ;-).</target>
        </trans-unit>
        <trans-unit id="f27a0dc4aa2c3bb4dbe16bb6623bff3027267eb7" translate="yes" xml:space="preserve">
          <source>This software is licensed under the &lt;a href=&quot;http://en.wikipedia.org/wiki/MIT_License&quot;&gt;MIT license&lt;/a&gt;.</source>
          <target state="translated">이 소프트웨어는 &lt;a href=&quot;http://en.wikipedia.org/wiki/MIT_License&quot;&gt;MIT 라이선스에&lt;/a&gt; 따라 사용이 허가되었습니다 .</target>
        </trans-unit>
        <trans-unit id="7aa3d371321a712db54ce3177e0c62c338d94f28" translate="yes" xml:space="preserve">
          <source>Uses a pseudo terminal to emulate a real terminal</source>
          <target state="translated">의사 터미널을 사용하여 실제 터미널을 에뮬레이션</target>
        </trans-unit>
        <trans-unit id="cffa50a32cb13a240d705317bcec65dd1f31b6ad" translate="yes" xml:space="preserve">
          <source>and</source>
          <target state="translated">과</target>
        </trans-unit>
        <trans-unit id="ecf5c466c5c9de7de63a537c3e693212e007e15f" translate="yes" xml:space="preserve">
          <source>and then you use the</source>
          <target state="translated">그런 다음</target>
        </trans-unit>
        <trans-unit id="cf4966c8256316dfb7378caa6748113487e2e9e0" translate="yes" xml:space="preserve">
          <source>attributes of the</source>
          <target state="translated">의 속성</target>
        </trans-unit>
        <trans-unit id="c1364357c4c9bf705a9cee2f161afe63cf37ebc5" translate="yes" xml:space="preserve">
          <source>capturer</source>
          <target state="translated">포획 자</target>
        </trans-unit>
        <trans-unit id="280f73b29ad44c388ef792f1064b14b963b572db" translate="yes" xml:space="preserve">
          <source>is available on &lt;a href=&quot;https://pypi.org/project/capturer&quot;&gt;PyPI&lt;/a&gt; and &lt;a href=&quot;https://github.com/xolox/python-capturer&quot;&gt;GitHub&lt;/a&gt;. The
documentation is hosted on &lt;a href=&quot;https://capturer.readthedocs.io&quot;&gt;Read the Docs&lt;/a&gt; and includes a &lt;a href=&quot;https://capturer.readthedocs.io/en/latest/changelog.html&quot;&gt;changelog&lt;/a&gt;. For bug
reports please create an issue on &lt;a href=&quot;https://github.com/xolox/python-capturer&quot;&gt;GitHub&lt;/a&gt;. If you have questions, suggestions,
etc. feel free to send me an e-mail at &lt;a href=&quot;mailto:peter%40peterodding.com&quot;&gt;peter@peterodding.com&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://pypi.org/project/capturer&quot;&gt;PyPI&lt;/a&gt; 및 &lt;a href=&quot;https://github.com/xolox/python-capturer&quot;&gt;GitHub&lt;/a&gt; 에서 사용할 수 있습니다 . 문서는 &lt;a href=&quot;https://capturer.readthedocs.io&quot;&gt;Read the Docs&lt;/a&gt; 에서 호스팅되며 &lt;a href=&quot;https://capturer.readthedocs.io/en/latest/changelog.html&quot;&gt;변경 로그를&lt;/a&gt; 포함합니다 . 버그 보고서의 경우 &lt;a href=&quot;https://github.com/xolox/python-capturer&quot;&gt;GitHub에&lt;/a&gt; 문제를 생성하십시오 . 질문, 제안 등이 있으면 &lt;a href=&quot;mailto:peter%40peterodding.com&quot;&gt;peter@peterodding.com&lt;/a&gt; 으로 이메일을 보내주십시오 .</target>
        </trans-unit>
        <trans-unit id="cc328241821ec81a0bd727eb8307ec218e3aca67" translate="yes" xml:space="preserve">
          <source>is to capture all output of a snippet of Python
code (including any output by subprocesses) but also relay the output to the
terminal in real time. This has a couple of useful properties:</source>
          <target state="translated">파이썬 코드 스 니펫의 모든 출력 (하위 프로세스에 의한 출력 포함)을 캡처하고 출력을 터미널에 실시간으로 릴레이하는 것입니다. 여기에는 몇 가지 유용한 속성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="8af0779f22f7e46b85797dd52e0b3e50d1509da3" translate="yes" xml:space="preserve">
          <source>it doesn&amp;rsquo;t matter, which explains why this is the default mode.</source>
          <target state="translated">이것이 기본 모드 인 이유를 설명하는 것은 중요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="34fb25f83b43204dad2ad028bbed94e517200a0a" translate="yes" xml:space="preserve">
          <source>keyword argument
that can be used to disable this behavior (please refer to the &lt;a href=&quot;https://capturer.readthedocs.io&quot;&gt;documentation&lt;/a&gt;
for details).</source>
          <target state="translated">이 동작을 비활성화하는 데 사용할 수있는 키워드 인수 (자세한 내용은 &lt;a href=&quot;https://capturer.readthedocs.io&quot;&gt;설명서&lt;/a&gt; 를 참조하십시오).</target>
        </trans-unit>
        <trans-unit id="830979b8b59a226d370a424fcaf263da13f1ff3c" translate="yes" xml:space="preserve">
          <source>object to get at the output
captured on each stream.</source>
          <target state="translated">각 스트림에서 캡처 된 출력을 가져올 개체입니다.</target>
        </trans-unit>
        <trans-unit id="1bf789c5f353e49a156b15a628b99a02803f754f" translate="yes" xml:space="preserve">
          <source>package instead intercepts writes to low level file descriptors
(similar to and inspired by &lt;a href=&quot;https://pytest.org/latest/capture.html&quot;&gt;how pytest does it&lt;/a&gt;). This enables capturing of
output written to the standard output and error streams from the same Python
process as well as any subprocesses.</source>
          <target state="translated">대신 package는 낮은 수준의 파일 설명자에 대한 쓰기를 차단 &lt;a href=&quot;https://pytest.org/latest/capture.html&quot;&gt;합니다 (pytest가 수행하는 방식&lt;/a&gt; 과 유사하고 영감을 얻음 ). 이를 통해 동일한 Python 프로세스 및 모든 하위 프로세스에서 표준 출력 및 오류 스트림에 기록 된 출력을 캡처 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a17fb22aac4e90f542768571c3097ae532fc9bea" translate="yes" xml:space="preserve">
          <source>package is available on &lt;a href=&quot;https://pypi.org/project/capturer&quot;&gt;PyPI&lt;/a&gt; which means installation should be
as simple as:</source>
          <target state="translated">패키지는 &lt;a href=&quot;https://pypi.org/project/capturer&quot;&gt;PyPI에서&lt;/a&gt; 사용할 수 있으므로 설치가 다음과 같이 간단해야합니다.</target>
        </trans-unit>
        <trans-unit id="56dfcefbd3bce0e406f073d7929c42b9ae1edce1" translate="yes" xml:space="preserve">
          <source>package uses a pseudo terminal created using &lt;a href=&quot;https://docs.python.org/2/library/pty.html#pty.openpty&quot;&gt;pty.openpty()&lt;/a&gt; to
capture output. This means subprocesses will use ANSI escape sequences because
they think they&amp;rsquo;re connected to a terminal. In the current implementation you
can&amp;rsquo;t opt out of this, but feel free to submit a feature request to change this
:-). This does have some drawbacks:</source>
          <target state="translated">패키지는 출력을 캡처하기 위해 &lt;a href=&quot;https://docs.python.org/2/library/pty.html#pty.openpty&quot;&gt;pty.openpty ()&lt;/a&gt; 를 사용하여 생성 된 의사 터미널을 사용 합니다. 즉, 하위 프로세스는 터미널에 연결되어 있다고 생각하기 때문에 ANSI 이스케이프 시퀀스를 사용합니다. 현재 구현에서는이를 해제 할 수 없지만 변경하려면 기능 요청을 제출해 주시기 바랍니다. :-). 여기에는 몇 가지 단점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="6825c88f8c8676d5e6d8f79c1357352c45ed8741" translate="yes" xml:space="preserve">
          <source>package was created for a very
specific use case that wasn&amp;rsquo;t catered for by existing solutions (that I could
find). This section documents the design choices that guided the development of
the</source>
          <target state="translated">패키지는 기존 솔루션에서 제공하지 않는 매우 구체적인 사용 사례를 위해 생성되었습니다 (찾을 수 있음). 이 섹션에서는 개발을 안내 한 설계 선택을 문서화합니다.</target>
        </trans-unit>
        <trans-unit id="599fe20e7281222b71474c879769a9e94f602fea" translate="yes" xml:space="preserve">
          <source>package was developed as a proof of concept over the course of a
weekend, because I was curious to see if it could be done (reliably). After a
weekend of extensive testing it seems to work fairly well so I&amp;rsquo;m publishing the
initial release as version 1.0, however I still consider this a proof of
concept because I don&amp;rsquo;t have extensive &amp;ldquo;production&amp;rdquo; experience using it yet.
Here&amp;rsquo;s hoping it works as well in practice as it did during my testing :-).</source>
          <target state="translated">패키지는 주말 동안 개념 증명으로 개발되었습니다. (안정적으로) 할 수 있는지 궁금했기 때문입니다. 주말에 광범위한 테스트를 거친 후 꽤 잘 작동하는 것 같아서 초기 릴리스를 버전 1.0으로 게시하고 있지만 아직 사용하는 광범위한 &quot;프로덕션&quot;경험이 없기 때문에 여전히 개념 증명이라고 생각합니다. 내 테스트 중에했던 것처럼 실제로 잘 작동하기를 바랍니다. :-).</target>
        </trans-unit>
        <trans-unit id="af066bfb6456ec7e023df9ba903d7d0a4c65d9d5" translate="yes" xml:space="preserve">
          <source>package. No code was copied, but both projects are MIT licensed anyway, so it&amp;rsquo;s
not like it&amp;rsquo;s very relevant :-).</source>
          <target state="translated">꾸러미. 코드는 복사되지 않았지만 어쨌든 두 프로젝트 모두 MIT 라이센스가 있으므로 관련성이별로 없습니다 :-).</target>
        </trans-unit>
        <trans-unit id="feac2e72858e6aacadfda0ac55b74ac3719313cb" translate="yes" xml:space="preserve">
          <source>package:</source>
          <target state="translated">꾸러미:</target>
        </trans-unit>
        <trans-unit id="cee9d62e6df8cf072e5ddffcd07319f953cac369" translate="yes" xml:space="preserve">
          <source>partial=True</source>
          <target state="translated">partial = 참</target>
        </trans-unit>
        <trans-unit id="6d0d5876e6710ebb4f309b5af01090cb97381d06" translate="yes" xml:space="preserve">
          <source>print</source>
          <target state="translated">인쇄</target>
        </trans-unit>
        <trans-unit id="351eb7019c1640acf10c265cc31c377fd68443b5" translate="yes" xml:space="preserve">
          <source>stderr</source>
          <target state="translated">stderr</target>
        </trans-unit>
        <trans-unit id="476d9ec701e2de6a6c37ab5211117a7cb8333a27" translate="yes" xml:space="preserve">
          <source>stdout</source>
          <target state="translated">stdout</target>
        </trans-unit>
        <trans-unit id="abf2af82450fe8a25b8fd52be056c75ed0e169dd" translate="yes" xml:space="preserve">
          <source>to show
the results without causing a recursive &amp;ldquo;captured output is printed and then
captured again&amp;rdquo; loop. There&amp;rsquo;s an optional</source>
          <target state="translated">반복적 인 &quot;캡처 된 출력이 인쇄 된 다음 다시 캡처&quot;루프를 일으키지 않고 결과를 표시합니다. 선택 사항이 있습니다</target>
        </trans-unit>
        <trans-unit id="7c23946dffb55ffa0ee800ecba4e2d38b3a1d5d6" translate="yes" xml:space="preserve">
          <source>to work (Windows definitely isn&amp;rsquo;t supported).</source>
          <target state="translated">작동합니다 (Windows는 확실히 지원되지 않습니다).</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
