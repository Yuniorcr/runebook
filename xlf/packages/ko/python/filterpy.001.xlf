<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://pypi.org/project/filterpy/">
    <body>
      <group id="filterpy">
        <trans-unit id="8a8e298f9a396f054dba117cef6a17d8c2fbb635" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NOTE&lt;/strong&gt;: Imminent drop of support of Python 2.7, 3.4. See section below for details.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : Python 2.7, 3.4에 대한 지원이 곧 중단됩니다. 자세한 내용은 아래 섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="4d58a7251bc15282c41f3b3a4aa3f72641348a7f" translate="yes" xml:space="preserve">
          <source>All tests are written to work with py.test. Just type</source>
          <target state="translated">모든 테스트는 py.test와 함께 작동하도록 작성되었습니다. 그냥 입력</target>
        </trans-unit>
        <trans-unit id="c1939d3939c93a9c3ab83c20a36c6f9ccb15e5ef" translate="yes" xml:space="preserve">
          <source>And, if you want to install from the bleeding edge git version</source>
          <target state="translated">그리고 블리딩 에지 ​​git 버전에서 설치하려면</target>
        </trans-unit>
        <trans-unit id="e5a8c89ee16ef426c7761586d7e5aa3f19a032ae" translate="yes" xml:space="preserve">
          <source>As explained above, the tests are not robust. I&amp;rsquo;m still at the stage
where visual plots are the best way to see how things are working.
Apologies, but I think it is a sound choice for development. It is easy
for a filter to perform within theoretical limits (which we can write a
non-visual test for) yet be &amp;lsquo;off&amp;rsquo; in some way. The code itself contains
tests in the form of asserts and properties that ensure that arrays are
of the proper dimension, etc.</source>
          <target state="translated">위에서 설명한 것처럼 테스트는 강력하지 않습니다. 나는 여전히 시각적 플롯이 일이 어떻게 작동하는지 확인하는 가장 좋은 방법 인 단계에 있습니다. 죄송하지만 개발을위한 건전한 선택이라고 생각합니다. 필터가 이론적 한계 (비 시각적 테스트를 작성할 수 있음) 내에서 수행되지만 어떤 식 으로든 '꺼져'있는 것은 쉽습니다. 코드 자체에는 배열이 적절한 차원 등인지 확인하는 어설 션 및 속성 형식의 테스트가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="4b613f6d7285ef9f4bef8a4f0bd6a6c9681d7640" translate="yes" xml:space="preserve">
          <source>At the moment FilterPy is on version 1.x. I plan to fork the project
to version 2.0, and support only Python 3.5+. The 1.x version
will still be available, but I will not support it. If I add something
amazing to 2.0 and someone really begs, I might backport it; more
likely I would accept a pull request with the feature backported
to 1.x. But to be honest I don&amp;rsquo;t forsee this happening.</source>
          <target state="translated">현재 FilterPy는 버전 1.x에 있습니다. 프로젝트를 버전 2.0으로 포크하고 Python 3.5 이상 만 지원할 계획입니다. 1.x 버전은 계속 사용할 수 있지만 지원하지 않습니다. 내가 2.0에 놀라운 것을 추가하고 누군가가 정말로 구걸한다면 나는 그것을 백 포트 할 것이다. 1.x로 백 포트 된 기능으로 풀 요청을 수락 할 가능성이 더 큽니다. 하지만 솔직히 말해서 이런 일이 일어날 것 같지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="168929183d2470cb5fd9c8ab272eed288ccb698d" translate="yes" xml:space="preserve">
          <source>Basic use</source>
          <target state="translated">기본 사용</target>
        </trans-unit>
        <trans-unit id="968bd2b33b4162a81ec2cd8ed2df38da9b302693" translate="yes" xml:space="preserve">
          <source>Copyright (c) 2015 Roger R. Labbe Jr</source>
          <target state="translated">저작권 (c) 2015 Roger R. Labbe Jr</target>
        </trans-unit>
        <trans-unit id="3d89f90b67b082a45bef90c0d79a6ebd3711a370" translate="yes" xml:space="preserve">
          <source>FilterPy - Kalman filters and other optimal and non-optimal estimation filters in Python.</source>
          <target state="translated">FilterPy-Python의 Kalman 필터 및 기타 최적 및 비 최적 추정 필터.</target>
        </trans-unit>
        <trans-unit id="1c3fbbca97bb5d8f412fea56090f90411596cfe8" translate="yes" xml:space="preserve">
          <source>Finally, run the filter.</source>
          <target state="translated">마지막으로 필터를 실행합니다.</target>
        </trans-unit>
        <trans-unit id="ee3680252bd004d7ef4df31fbaff398d7d1a87fd" translate="yes" xml:space="preserve">
          <source>First, import the filters and helper functions.</source>
          <target state="translated">먼저 필터와 도우미 기능을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="35555ce65ba60c36f60b29bd85e767779829a60a" translate="yes" xml:space="preserve">
          <source>Full documentation is at
&lt;a href=&quot;https://filterpy.readthedocs.io/en/latest/&quot;&gt;https://filterpy.readthedocs.io/en/latest/&lt;/a&gt;</source>
          <target state="translated">전체 문서는 &lt;a href=&quot;https://filterpy.readthedocs.io/en/latest/&quot;&gt;https://filterpy.readthedocs.io/en/latest/에 있습니다.&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="816b4bbd3e420c572b205dac19fade101d072597" translate="yes" xml:space="preserve">
          <source>I am making edits to the package now in support of my book;
once those are done I&amp;rsquo;ll probably create the 2.0 branch.
I&amp;rsquo;m contemplating a SLAM addition to the book, and am not
sure if I will do this in 3.5+ only or not.</source>
          <target state="translated">내 책을 지원하기 위해 지금 패키지를 편집하고 있습니다. 완료되면 2.0 브랜치를 생성 할 것입니다. 나는 책에 SLAM 추가를 고려하고 있으며 3.5 이상에서만 이것을 할 것인지 확실하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a748886f04c2328f504cab48b8f72e609596428e" translate="yes" xml:space="preserve">
          <source>I haven&amp;rsquo;t extensively tested backwards compatibility - I use the
Anaconda distribution, and so I am on Python 3.6 and 2.7.14, along with
whatever version of NumPy, SciPy, and matplotlib they provide. But I am
using pretty basic Python - numpy.array, maybe a list comprehension in
my tests.</source>
          <target state="translated">저는 이전 버전과의 호환성을 광범위하게 테스트하지 않았습니다. Anaconda 배포판을 사용하므로 NumPy, SciPy 및 matplotlib의 모든 버전과 함께 Python 3.6 및 2.7.14를 사용하고 있습니다. 그러나 나는 꽤 기본적인 Python-numpy.array, 아마도 내 테스트에서 목록 이해력을 사용하고 있습니다.</target>
        </trans-unit>
        <trans-unit id="8e09978b025a4723b3622ef57e7d817d2a858e11" translate="yes" xml:space="preserve">
          <source>I haven&amp;rsquo;t finalized my decision on this, but NumPy is dropping
Python 2.7 support in December 2018. I will certainly drop Python
2.7 support by then; I will probably do it much sooner.</source>
          <target state="translated">이에 대한 결정은 아직 확정하지 않았지만 NumPy는 2018 년 12 월에 Python 2.7 지원을 중단 할 예정입니다. 그때까지 Python 2.7 지원을 중단 할 것입니다. 아마 훨씬 빨리 할 것입니다.</target>
        </trans-unit>
        <trans-unit id="61c05ef3006579fbdd490e4b533ee3726eb4d772" translate="yes" xml:space="preserve">
          <source>I import from &lt;strong&gt;__future__&lt;/strong&gt; to ensure the code works in Python 2 and 3.</source>
          <target state="translated">코드가 Python 2 및 3에서 작동하는지 확인하기 위해 &lt;strong&gt;__future__&lt;/strong&gt; 에서 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="7488ac725f5d27750031e40080ed22d2b9cd5291" translate="yes" xml:space="preserve">
          <source>I said three books. I also like and use Bar-Shalom&amp;rsquo;s Estimation with
Applications to Tracking and Navigation. Much more mathematical than the
previous two books, I would not recommend it as a first text unless you
already have a background in control theory or optimal estimation. Once
you have that experience, this book is a gem. Every sentence is crystal
clear, his language is precise, but each abstract mathematical statement
is followed with something like &amp;ldquo;and this means&amp;hellip;&amp;rdquo;.</source>
          <target state="translated">나는 세 권의 책을 말했다. 또한 추적 및 탐색에 대한 응용 프로그램과 함께 Bar-Shalom의 추정을 좋아하고 사용합니다. 이전 두 권의 책보다 훨씬 더 수학적이며, 이미 제어 이론이나 최적 추정에 대한 배경 지식이 없다면 첫 번째 텍스트로 권장하지 않습니다. 그 경험이 있으면이 책은 보석입니다. 모든 문장은 분명하고 그의 언어는 정확하지만, 각각의 추상적 인 수학적 진술 뒤에는&amp;ldquo;그리고 이것은 의미&amp;hellip;&amp;rdquo;와 같은 것이 뒤 따릅니다.</target>
        </trans-unit>
        <trans-unit id="2aa942fd3c88f16190a93b80a61fa11f8ebdb5a4" translate="yes" xml:space="preserve">
          <source>I use NumPy and SciPy for all of the computations. I have experimented
with Numba and it yields impressive speed ups with minimal costs, but I
am not convinced that I want to add that requirement to my project. It
is still on my list of things to figure out, however.</source>
          <target state="translated">나는 모든 계산에 NumPy와 SciPy를 사용합니다. 나는 Numba를 실험 해 보았고 최소한의 비용으로 인상적인 속도 향상을 얻었지만 그 요구 사항을 내 프로젝트에 추가하고 싶다고 확신하지 못했습니다. 그러나 그것은 여전히 ​​내 목록에 있습니다.</target>
        </trans-unit>
        <trans-unit id="ba522cc2398fca76e29351085a92280f3c143c00" translate="yes" xml:space="preserve">
          <source>I use three main texts as my refererence, though I do own the majority
of the Kalman filtering literature. First is Paul Zarchan&amp;rsquo;s
&amp;lsquo;Fundamentals of Kalman Filtering: A Practical Approach&amp;rsquo;. I think it by
far the best Kalman filtering book out there if you are interested in
practical applications more than writing a thesis. The second book I use
is Eli Brookner&amp;rsquo;s &amp;lsquo;Tracking and Kalman Filtering Made Easy&amp;rsquo;. This is an
astonishingly good book; its first chapter is actually readable by the
layperson! Brookner starts from the g-h filter, and shows how all other
filters - the Kalman filter, least squares, fading memory, etc., all
derive from the g-h filter. It greatly simplifies many aspects of
analysis and/or intuitive understanding of your problem. In contrast,
Zarchan starts from least squares, and then moves on to Kalman
filtering. I find that he downplays the predict-update aspect of the
algorithms, but he has a wealth of worked examples and comparisons
between different methods. I think both viewpoints are needed, and so I
can&amp;rsquo;t imagine discarding one book. Brookner also focuses on issues that
are ignored in other books - track initialization, detecting and
discarding noise, tracking multiple objects, an so on.</source>
          <target state="translated">나는 Kalman 필터링 문헌의 대부분을 소유하고 있지만 세 가지 주요 텍스트를 참조 자료로 사용합니다. 첫 번째는 Paul Zarchan의 '칼만 필터링 기초 : 실용적인 접근 방식'입니다. 논문을 쓰는 것보다 실용적인 응용 프로그램에 관심이 있다면 지금까지 최고의 칼만 필터링 책이라고 생각합니다. 두 번째로 사용하는 책은 Eli Brookner의 'Tracking and Kalman Filtering Made Easy'입니다. 이것은 놀랍도록 좋은 책입니다. 첫 번째 장은 실제로 평신도가 읽을 수 있습니다! Brookner는 gh 필터에서 시작하여 Kalman 필터, 최소 제곱, 페이딩 메모리 등 다른 모든 필터가 gh 필터에서 어떻게 파생되는지 보여줍니다. 분석의 여러 측면 및 / 또는 문제에 대한 직관적 인 이해를 크게 단순화합니다. 반대로 Zarchan은 최소 제곱에서 시작하여 Kalman 필터링으로 이동합니다.나는 그가 알고리즘의 업데이트 예측 측면을 경시하지만, 그는 다양한 방법들 사이에 많은 작업 예제와 비교를 가지고 있습니다. 두 가지 관점이 모두 필요하다고 생각하기 때문에 한 권의 책을 버리는 것은 상상할 수 없습니다. Brookner는 또한 트랙 초기화, 노이즈 감지 및 폐기, 여러 객체 추적 등 다른 책에서 무시되는 문제에 중점을 둡니다.</target>
        </trans-unit>
        <trans-unit id="b9067a5289890407887c107d828776b6282737e0" translate="yes" xml:space="preserve">
          <source>If you prefer to download the source yourself</source>
          <target state="translated">소스를 직접 다운로드하려면</target>
        </trans-unit>
        <trans-unit id="950ad6a6b9a6d7503133a16c0753c700fd4b6713" translate="yes" xml:space="preserve">
          <source>If you use Anaconda, you can install from the conda-forge channel. You
will need to add the conda-forge channel if you haven&amp;rsquo;t already done so:</source>
          <target state="translated">Anaconda를 사용하는 경우 conda-forge 채널에서 설치할 수 있습니다. 아직 추가하지 않은 경우 conda-forge 채널을 추가해야합니다.</target>
        </trans-unit>
        <trans-unit id="d021e768fe46c9e993b9bc26daebe1e0a7ccf5ea" translate="yes" xml:space="preserve">
          <source>Initialize the filter&amp;rsquo;s matrices.</source>
          <target state="translated">필터의 행렬을 초기화합니다.</target>
        </trans-unit>
        <trans-unit id="c81b79df3c6448eae7c4f80428b54cd5692a17d7" translate="yes" xml:space="preserve">
          <source>Installation</source>
          <target state="translated">설치</target>
        </trans-unit>
        <trans-unit id="069f6f37ff0b3b14a1e2b9c9a3ca8b9b8085a537" translate="yes" xml:space="preserve">
          <source>Kalman filtering and optimal estimation library</source>
          <target state="translated">칼만 필터링 및 최적 추정 라이브러리</target>
        </trans-unit>
        <trans-unit id="3229609e15436ec51bcf00818a69a84dbc58a0c2" translate="yes" xml:space="preserve">
          <source>License</source>
          <target state="translated">특허</target>
        </trans-unit>
        <trans-unit id="ff42cf30abec69d9cd5e9a6d51db617908be4d0b" translate="yes" xml:space="preserve">
          <source>My aim is largely pedalogical - I opt for clear code that matches the
equations in the relevant texts on a 1-to-1 basis, even when that has a
performance cost. There are places where this tradeoff is unclear - for
example, I find it somewhat clearer to write a small set of equations
using linear algebra, but numpy&amp;rsquo;s overhead on small matrices makes it
run slower than writing each equation out by hand. Furthermore, books
such Zarchan present the written out form, not the linear algebra form.
It is hard for me to choose which presentation is &amp;lsquo;clearer&amp;rsquo; - it depends
on the audience. In that case I usually opt for the faster implementation.</source>
          <target state="translated">내 목표는 대체로 현혹 적입니다. 성능 비용이 들더라도 관련 텍스트의 방정식과 일대일 기준으로 일치하는 명확한 코드를 선택합니다. 이 절충안이 명확하지 않은 곳이 있습니다. 또한 Zarchan과 같은 책은 선형 대수 형식이 아닌 작성된 형식을 제시합니다. 어떤 프레젠테이션이 '더 선명'한지 선택하기가 어렵습니다. 청중에 따라 다릅니다. 이 경우 일반적으로 더 빠른 구현을 선택합니다.</target>
        </trans-unit>
        <trans-unit id="fa8af4cb23ae77c128a4a33e6c038f3d5d3fe115" translate="yes" xml:space="preserve">
          <source>My book &lt;a href=&quot;https://github.com/rlabbe/Kalman-and-Bayesian-Filters-in-Python/&quot;&gt;https://github.com/rlabbe/Kalman-and-Bayesian-Filters-in-Python/&lt;/a&gt;
uses this library, and is the place to go if you are trying to learn
about Kalman filtering and/or this library. These two are not exactly in
sync - my normal development cycle is to add files here, test them, figure
out how to present them pedalogically, then write the appropriate section
or chapter in the book. So there is code here that is not discussed
yet in the book.</source>
          <target state="translated">내 책 &lt;a href=&quot;https://github.com/rlabbe/Kalman-and-Bayesian-Filters-in-Python/&quot;&gt;https://github.com/rlabbe/Kalman-and-Bayesian-Filters-in-Python/&lt;/a&gt; 은이 라이브러리를 사용하며 Kalman 필터링 및 / 또는이 라이브러리에 대해 배우려는 경우 갈 곳입니다. 이 두 가지는 정확히 동기화되어 있지 않습니다. 제 일반적인 개발주기는 여기에 파일을 추가하고 테스트하고 페달로 표현하는 방법을 파악한 다음 책에서 적절한 섹션이나 장을 작성하는 것입니다. 그래서 책에서 아직 논의되지 않은 코드가 있습니다.</target>
        </trans-unit>
        <trans-unit id="24162d16555bd8804ec6c655dbbca2fb05c22443" translate="yes" xml:space="preserve">
          <source>Note: I make no guarantees that everything works if you install from here.
I&amp;rsquo;m the only developer, and so I don&amp;rsquo;t worry about dev/release branches and
the like. Unless I fix a bug for you and tell you to get this version because
I haven&amp;rsquo;t made a new release yet, I strongly advise not installing from git.</source>
          <target state="translated">참고 : 여기에서 설치하면 모든 것이 작동한다는 보장은 없습니다. 나는 유일한 개발자이므로 개발 / 출시 브랜치 등에 대해 걱정하지 않습니다. 내가 버그를 수정하고 아직 새 릴리스를 만들지 않았기 때문에이 버전을 구하라고하지 않는 한, git에서 설치하지 않는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="a94bc79395b7f9e096a0e3083d5e99d870902600" translate="yes" xml:space="preserve">
          <source>Now, create the filter</source>
          <target state="translated">이제 필터를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="4428df60996dd395af6c51238f43c71d4400a7fa" translate="yes" xml:space="preserve">
          <source>Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the &amp;ldquo;Software&amp;rdquo;), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:</source>
          <target state="translated">사용, 복사, 수정, 병합 권한을 포함하되 이에 국한되지 않는 제한없이 소프트웨어를 처리 할 수있는 권한이이 소프트웨어 및 관련 문서 파일 (이하 &quot;소프트웨어&quot;)의 사본을 획득 한 모든 사람에게 무료로 부여됩니다. 다음 조건에 따라 소프트웨어 사본을, 게시, 배포, 재 라이센스 및 / 또는 판매하고 소프트웨어를 제공받은 사람이 그렇게하도록 허용합니다.</target>
        </trans-unit>
        <trans-unit id="c89209cb3cdced2b4e97399f88e4af894bfd8485" translate="yes" xml:space="preserve">
          <source>Plan for dropping Python 2.7 support</source>
          <target state="translated">Python 2.7 지원 중단 계획</target>
        </trans-unit>
        <trans-unit id="5d20d0fee3b91643dd8d272ac33d01ca95179d82" translate="yes" xml:space="preserve">
          <source>References</source>
          <target state="translated">참고 문헌</target>
        </trans-unit>
        <trans-unit id="09a428f93ec07a73d726f8bd037ecacfaaf8b044" translate="yes" xml:space="preserve">
          <source>Requirements</source>
          <target state="translated">요구 사항</target>
        </trans-unit>
        <trans-unit id="f5470597044f9881eb58bf21ebb16608cd981bed" translate="yes" xml:space="preserve">
          <source>Sorry, that is the extent of the documentation here. However, the library
is broken up into subdirectories: gh, kalman, memory, leastsq, and so on.
Each subdirectory contains python files relating to that form of filter.
The functions and methods contain pretty good docstrings on use.</source>
          <target state="translated">죄송합니다. 여기에있는 문서의 범위입니다. 그러나 라이브러리는 gh, kalman, memory, leastsq 등의 하위 디렉토리로 나뉩니다. 각 하위 디렉토리에는 해당 필터 형식과 관련된 Python 파일이 포함되어 있습니다. 함수와 메서드에는 사용시 매우 좋은 독 스트링이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="e07e66ec2ec5d10f836f2ac4a05173041f8d092a" translate="yes" xml:space="preserve">
          <source>Sphinx generated documentation lives at &lt;a href=&quot;http://filterpy.readthedocs.org/&quot;&gt;http://filterpy.readthedocs.org/&lt;/a&gt;.
Generation is triggered by git when I do a check in, so this will always
be bleeding edge development version - it will often be ahead of the
released version.</source>
          <target state="translated">Sphinx 생성 문서는 &lt;a href=&quot;http://filterpy.readthedocs.org/&quot;&gt;http://filterpy.readthedocs.org/에&lt;/a&gt; 있습니다. 체크인을 할 때 git에 의해 생성이 트리거되므로 항상 최신 개발 버전이 될 것입니다. 종종 릴리스 된 버전보다 앞서 있습니다.</target>
        </trans-unit>
        <trans-unit id="ba51f3c923b832e2cb3feca36180c8813bdbec40" translate="yes" xml:space="preserve">
          <source>THE SOFTWARE IS PROVIDED &amp;ldquo;AS IS&amp;rdquo;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.TION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</source>
          <target state="translated">소프트웨어는 상품성, 특정 목적에의 적합성 및 비 침해에 대한 보증을 포함하되 이에 국한되지 않는 어떠한 종류의 명시 적 또는 묵시적 보증없이 &quot;있는 그대로&quot;제공됩니다. 어떠한 경우에도 저자 또는 저작권 보유자는 계약, 불법 행위 또는 기타 방식으로 소프트웨어 또는 소프트웨어의 사용 또는 기타 거래와 관련하여 발생하는 모든 청구, 손해 또는 기타 책임에 대해 책임을지지 않습니다. 소프트웨어. 소프트웨어 또는 소프트웨어의 사용 또는 기타 거래와 관련하여 발생하는 계약, 불법 행위 또는 기타.</target>
        </trans-unit>
        <trans-unit id="0820b32b206b7352858e8903a838ed14319acdfd" translate="yes" xml:space="preserve">
          <source>Testing</source>
          <target state="translated">테스팅</target>
        </trans-unit>
        <trans-unit id="2770edfa17d1ba1518644752acbba767797d8840" translate="yes" xml:space="preserve">
          <source>The MIT License (MIT)</source>
          <target state="translated">MIT 라이선스 (MIT)</target>
        </trans-unit>
        <trans-unit id="abf94dbab29db68325894cd60a65f3c2a1fc56fa" translate="yes" xml:space="preserve">
          <source>The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.</source>
          <target state="translated">상기 저작권 고지 및이 허가 고지는 소프트웨어의 모든 사본 또는 상당 부분에 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="ab40192173a47c8e5ce7406412a220e2a474ada7" translate="yes" xml:space="preserve">
          <source>The most general installation is just to use pip, which should come with
any modern Python distribution.</source>
          <target state="translated">가장 일반적인 설치는 최신 Python 배포판과 함께 제공되는 pip를 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="24d855a043cf9286f92b9e45c2eac0cf512060ff" translate="yes" xml:space="preserve">
          <source>This is code I am developing in conjunction with my book Kalman and
Bayesian Filter in Python, which you can read/download at
&lt;a href=&quot;https://github.com/rlabbe/Kalman-and-Bayesian-Filters-in-Python/&quot;&gt;https://github.com/rlabbe/Kalman-and-Bayesian-Filters-in-Python/&lt;/a&gt;</source>
          <target state="translated">이것은 제 책 Kalman and Bayesian Filter in Python과 함께 개발하고있는 코드입니다. &lt;a href=&quot;https://github.com/rlabbe/Kalman-and-Bayesian-Filters-in-Python/&quot;&gt;https://github.com/rlabbe/Kalman-and-Bayesian-Filters-in-Python/&lt;/a&gt; 에서 읽고 다운로드 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5b2920fd5055a135502dd8014d61c32dbbe26640" translate="yes" xml:space="preserve">
          <source>This library provides Kalman filtering and various related optimal and
non-optimal filtering software written in Python. It contains Kalman
filters, Extended Kalman filters, Unscented Kalman filters, Kalman
smoothers, Least Squares filters, fading memory filters, g-h filters,
discrete Bayes, and more.</source>
          <target state="translated">이 라이브러리는 Kalman 필터링 및 Python으로 작성된 다양한 관련 최적 및 비 최적 필터링 소프트웨어를 제공합니다. 여기에는 칼만 필터, 확장 칼만 필터, 무향 칼만 필터, 칼만 스무더, 최소 제곱 필터, 페이딩 메모리 필터, gh 필터, 개별 베이 등이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="e13f7bb9ae937b5d5cd0d8b07fd0aa0ec1e81f48" translate="yes" xml:space="preserve">
          <source>This library uses NumPy, SciPy, Matplotlib, and Python.</source>
          <target state="translated">이 라이브러리는 NumPy, SciPy, Matplotlib 및 Python을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="6bf801da2d6dc208fc60fa6f2e476b5d0f913f6e" translate="yes" xml:space="preserve">
          <source>Why 3.5+, and not 3.4+? 3.5 introduced the matrix multiply symbol,
and I want my code to take advantage of it. Plus, to be honest,
I&amp;rsquo;m being selfish. I don&amp;rsquo;t want to spend my life supporting this
package, and moving as far into the present as possible means
a few extra years before the Python version I choose becomes
hopelessly dated and a liability. I recognize this makes people
running the default Python in their linux distribution more
painful. All I can say is I did not decide to do the Python
3 fork, and I don&amp;rsquo;t have the time to support the bifurcation
any longer.</source>
          <target state="translated">왜 3.4+가 아닌 3.5+입니까? 3.5는 행렬 곱하기 기호를 도입했으며 내 코드가이를 활용하기를 원합니다. 게다가 솔직히 말해서 이기적이에요. 나는이 패키지를 지원하는 데 내 인생을 보내고 싶지 않으며 가능한 한 현재로 이동한다는 것은 내가 선택한 Python 버전이 절망적 인 날짜가되고 책임이 생기기까지 몇 년이 더 걸린다는 것을 의미합니다. 나는 이것이 리눅스 배포판에서 기본 Python을 실행하는 사람들을 더 고통스럽게 만든다는 것을 알고 있습니다. 내가 말할 수있는 것은 파이썬 3 포크를하기로 결정하지 않았고 더 이상 분기를 지원할 시간이 없다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="7bda3972fd645f4aa5fd7bc9c0f516b27fc7fa48" translate="yes" xml:space="preserve">
          <source>and then install with:</source>
          <target state="translated">다음으로 설치하십시오.</target>
        </trans-unit>
        <trans-unit id="f6762bfd6156e1d6ad2d093399eec4c20a937173" translate="yes" xml:space="preserve">
          <source>at the
command line.</source>
          <target state="translated">명령 줄에서.</target>
        </trans-unit>
        <trans-unit id="30b49ad158449a6fb7703af823510598668f8ad0" translate="yes" xml:space="preserve">
          <source>conda config &amp;ndash;add channels conda-forge</source>
          <target state="translated">conda 구성 &amp;ndash; 채널 추가 conda-forge</target>
        </trans-unit>
        <trans-unit id="99422a0a2caacfadcbdf22e2c4ec04c454b2eea3" translate="yes" xml:space="preserve">
          <source>conda install filterpy</source>
          <target state="translated">conda 설치 filterpy</target>
        </trans-unit>
        <trans-unit id="0e043421bf3470cb731f4c32448c91e870f04998" translate="yes" xml:space="preserve">
          <source>py.test</source>
          <target state="translated">py.test</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
