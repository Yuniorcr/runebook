<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://pypi.org/project/mbed-host-tests/">
    <body>
      <group id="mbed-host-tests">
        <trans-unit id="73f206237358af4e214f2ad31e03066659a22927" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&amp;lt;IP_address&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;port_number&amp;gt;&lt;/code&gt; - IP address and port of remote resource manager.</source>
          <target state="translated">&lt;code&gt;&amp;lt;IP_address&amp;gt;&lt;/code&gt; 및 &lt;code&gt;&amp;lt;port_number&amp;gt;&lt;/code&gt; -원격 리소스 관리자의 IP 주소 및 포트입니다.</target>
        </trans-unit>
        <trans-unit id="2315dd8635db49d10d5ff717a07556886c485353" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&amp;lt;config_name&amp;gt;&lt;/code&gt; - ether pre-defined CONFIG_NAME from mbedfm or a local config file for the Fast Models.</source>
          <target state="translated">&lt;code&gt;&amp;lt;config_name&amp;gt;&lt;/code&gt; -mbedfm의 사전 정의 된 CONFIG_NAME 또는 Fast 모델 용 로컬 구성 파일.</target>
        </trans-unit>
        <trans-unit id="17c0b030ceb8c6259d29f69c159b24b1152ff97c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&amp;lt;module_name&amp;gt;&lt;/code&gt; - name of Python module to load as remote resource manager.</source>
          <target state="translated">&lt;code&gt;&amp;lt;module_name&amp;gt;&lt;/code&gt; -원격 리소스 관리자로로드 할 Python 모듈의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="62e60b103cf49cca316e125268312fad8ae04e38" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;--sync=-1&lt;/code&gt;- &lt;code&gt;__sync&lt;/code&gt; packets will be sent unless we will reach timeout or proper response is sent from DUT.</source>
          <target state="translated">&lt;code&gt;--sync=-1&lt;/code&gt; - &lt;code&gt;__sync&lt;/code&gt; 우리는 시간 제한에 도달되거나 적절한 응답 DUT로부터 전송하지 않는 패킷을 전송한다.</target>
        </trans-unit>
        <trans-unit id="1bde794eaa5ce5cdd871c8a8ed159f2745b594f1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;--sync=0&lt;/code&gt; - No sync packets will be sent to DUT.</source>
          <target state="translated">&lt;code&gt;--sync=0&lt;/code&gt; - 동기화 패킷이 DUT로 전송되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9202d111f81be25b256c55649110d666c93d381e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;--sync=N&lt;/code&gt; - Where N is integer &amp;gt; 0. Send up to N &lt;code&gt;__sync&lt;/code&gt; packets to target platform. Response is sent unless we get response from target platform or timeout occurs.</source>
          <target state="translated">&lt;code&gt;--sync=N&lt;/code&gt; - 여기서 N은 정수&amp;gt; 0입니다. 최대 N 개의 &lt;code&gt;__sync&lt;/code&gt; 패킷을 대상 플랫폼으로 보냅니다 . 대상 플랫폼에서 응답을받지 않거나 시간 초과가 발생하지 않으면 응답이 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="4b945ede260654e0f827dbfaa6e83ea7b0de2d24" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;CONN&lt;/code&gt; - connection process (pooling for connection source e.g. serial port),</source>
          <target state="translated">&lt;code&gt;CONN&lt;/code&gt; - 연결 프로세스 (연결 소스 풀링, 예 : 직렬 포트),</target>
        </trans-unit>
        <trans-unit id="aa36907e745e96b081ba0cf5430162f2088874fa" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;COPY&lt;/code&gt; - host test plugins, type &lt;code&gt;CopyMethod&lt;/code&gt; of the plugin,</source>
          <target state="translated">&lt;code&gt;COPY&lt;/code&gt; - 호스트 테스트 플러그인 타입 &lt;code&gt;CopyMethod&lt;/code&gt; 플러그인,</target>
        </trans-unit>
        <trans-unit id="252ece708e3ba5fff9ea90f1c513c684f79d7ed3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ERR&lt;/code&gt; (error).</source>
          <target state="translated">&lt;code&gt;ERR&lt;/code&gt; (오류).</target>
        </trans-unit>
        <trans-unit id="0324877f43e21edc185859f23fc35c8063d0a492" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;HTST&lt;/code&gt; - host test object, HostTestBase derived object,</source>
          <target state="translated">&lt;code&gt;HTST&lt;/code&gt; - 호스트 테스트 오브젝트, HostTestBase는 객체를 도출</target>
        </trans-unit>
        <trans-unit id="ae0c1f99a757da1a18a9f18f9a7c5c896def47d5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;INF&lt;/code&gt; (info),</source>
          <target state="translated">&lt;code&gt;INF&lt;/code&gt; (정보),</target>
        </trans-unit>
        <trans-unit id="b5068e5fbd010807231f1efd39c83bf9820c804d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;PLGN&lt;/code&gt; - host test plugins, type &lt;code&gt;BasePlugin&lt;/code&gt; of the plugin,</source>
          <target state="translated">&lt;code&gt;PLGN&lt;/code&gt; - 호스트 테스트 플러그인, 플러그인의 &lt;code&gt;BasePlugin&lt;/code&gt; 유형 ,</target>
        </trans-unit>
        <trans-unit id="68dcc3ab0c52c817a21c29b3f4309a9a3e6599ca" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;REST&lt;/code&gt; - host test plugins, type &lt;code&gt;ResetMethod&lt;/code&gt; of the plugin,</source>
          <target state="translated">&lt;code&gt;REST&lt;/code&gt; - 호스트 테스트 플러그인 입력 &lt;code&gt;ResetMethod&lt;/code&gt; 을 플러그인의</target>
        </trans-unit>
        <trans-unit id="d6504288f35fb136d6facff97c815828c12809b8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;RXD&lt;/code&gt; (host's RX channel, from DUT).</source>
          <target state="translated">&lt;code&gt;RXD&lt;/code&gt; (DUT에서 호스트의 RX 채널).</target>
        </trans-unit>
        <trans-unit id="be48e576ff325b898d77d4109b00a276a9b5f49e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;RXD&lt;/code&gt; channel emitted &lt;code&gt;{{__sync;a7ace3a2-4025-4950-b9fc-a3671103387a}}&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;RXD&lt;/code&gt; 채널이 &lt;code&gt;{{__sync;a7ace3a2-4025-4950-b9fc-a3671103387a}}&lt;/code&gt; 내보냈습니다 .</target>
        </trans-unit>
        <trans-unit id="c4eebcb9ceef0a9470046493bd884b5166dee8de" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SERI&lt;/code&gt; - serial port wrapper with standard read, write, flush interface,</source>
          <target state="translated">&lt;code&gt;SERI&lt;/code&gt; - 표준 읽기, 쓰기, 플러시 인터페이스가있는 직렬 포트 래퍼,</target>
        </trans-unit>
        <trans-unit id="525831b4e82343e67b3190b1ce9c195f0b1d1201" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;TXD&lt;/code&gt; (host's TX channel, to DUT).</source>
          <target state="translated">&lt;code&gt;TXD&lt;/code&gt; (호스트의 TX 채널, DUT).</target>
        </trans-unit>
        <trans-unit id="8d94a283f05853dc0c1c67fa44a75a42ed73e149" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;WRN&lt;/code&gt; (warning),</source>
          <target state="translated">&lt;code&gt;WRN&lt;/code&gt; (경고),</target>
        </trans-unit>
        <trans-unit id="a424516ef2e22ca2f296966a65c99bdb62aff720" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;[1455218713.87][CONN][RXD] {{__sync;a7ace3a2-4025-4950-b9fc-a3671103387a}}&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;[1455218713.87][CONN][RXD] {{__sync;a7ace3a2-4025-4950-b9fc-a3671103387a}}&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="3ebf8ec5cbec6661a8f3fef93bbd7aae0404f050" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;[timestamp][source][level]&lt;/code&gt; - new log format, where:</source>
          <target state="translated">&lt;code&gt;[timestamp][source][level]&lt;/code&gt; -새 로그 형식, 여기서 :</target>
        </trans-unit>
        <trans-unit id="aebb6375919652bf3cd4cec03e3f2f2c7f08969b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__coverage_start&lt;/code&gt; - sent by DUT, coverage data.</source>
          <target state="translated">&lt;code&gt;__coverage_start&lt;/code&gt; -DUT에서 전송, 커버리지 데이터.</target>
        </trans-unit>
        <trans-unit id="aef3110f389e82af1973c9bcd0c75c246fa8a691" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__exit&lt;/code&gt; - sent by DUT, test suite execution finished.</source>
          <target state="translated">&lt;code&gt;__exit&lt;/code&gt; -DUT에서 전송, 테스트 스위트 실행이 완료되었습니다.</target>
        </trans-unit>
        <trans-unit id="e73f1f004a2d367ad3306a388160e6bd776dcd7c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__exit_event_queue&lt;/code&gt; - sent by host test, indicating no more events expected.</source>
          <target state="translated">&lt;code&gt;__exit_event_queue&lt;/code&gt; - 호스트 테스트에서 전송하여 더 이상 예상되는 이벤트가 없음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="66ab6ccf2d92f9d1d9a8d6179803a40238c95c5f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__host_test_name&lt;/code&gt; - host test name, sent by DUT after &lt;code&gt;{{sync;UUID}}&lt;/code&gt; is received.</source>
          <target state="translated">&lt;code&gt;__host_test_name&lt;/code&gt; - &lt;code&gt;{{sync;UUID}}&lt;/code&gt; 가 수신 된 후 DUT에서 보낸 호스트 테스트 이름 입니다.</target>
        </trans-unit>
        <trans-unit id="b4c381c842b653117058d4eb629f3b159890c58e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__notify_complete&lt;/code&gt; - sent by DUT, async notificaion about test case result (true, false, none).</source>
          <target state="translated">&lt;code&gt;__notify_complete&lt;/code&gt; -DUT에서 전송, 테스트 케이스 결과에 대한 비동기 알림 (true, false, none).</target>
        </trans-unit>
        <trans-unit id="70915690f15f4057e050e62023b57db39122af21" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__notify_conn_lost&lt;/code&gt; - sent by host test's connection process to notify serial port connection lost.</source>
          <target state="translated">&lt;code&gt;__notify_conn_lost&lt;/code&gt; - 직렬 포트 연결이 끊어 졌음 을 알리기 위해 호스트 테스트의 연결 프로세스에서 보냅니다.</target>
        </trans-unit>
        <trans-unit id="38605565e3847c0ad513f2ba8dea7090207e8d27" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__notify_prn&lt;/code&gt; - sent by host test to print log message.</source>
          <target state="translated">&lt;code&gt;__notify_prn&lt;/code&gt; - 로그 메시지를 인쇄하기 위해 호스트 테스트에서 보냈습니다.</target>
        </trans-unit>
        <trans-unit id="2536463805107e8572fd2f50d4dafe64b11ed998" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__notify_sync_failed&lt;/code&gt; - sent by host when sync response not received from DUT.</source>
          <target state="translated">&lt;code&gt;__notify_sync_failed&lt;/code&gt; -DUT에서 동기화 응답을받지 못한 경우 호스트에서 전송합니다.</target>
        </trans-unit>
        <trans-unit id="73a87a44a506b29d322e968afa4e11f08928f7f0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__rxd_line&lt;/code&gt; - Event triggered when &lt;code&gt;\n&lt;/code&gt; was found on DUT RXD channel. It can be overridden (&lt;code&gt;self.register_callback('__rxd_line', &amp;lt;callback_function&amp;gt;)&lt;/code&gt;) and used by user. Event is sent by host test to notify a new line of text was received on RXD channel. &lt;code&gt;__rxd_line&lt;/code&gt; event payload (value) in a line of text received from DUT over RXD.</source>
          <target state="translated">&lt;code&gt;__rxd_line&lt;/code&gt; - DUT RXD 채널에서 &lt;code&gt;\n&lt;/code&gt; 이 발견 되면 이벤트가 트리거 되었습니다. 재정의 ( &lt;code&gt;self.register_callback('__rxd_line', &amp;lt;callback_function&amp;gt;)&lt;/code&gt; )하고 사용자가 사용할 수 있습니다. RXD 채널에서 새로운 텍스트 줄이 수신되었음을 알리기 위해 호스트 테스트에서 이벤트를 보냅니다. &lt;code&gt;__rxd_line&lt;/code&gt; 이벤트 페이로드 (값)는 RXD를 통해 DUT에서 수신 한 텍스트 줄입니다.</target>
        </trans-unit>
        <trans-unit id="0522521478639533401e1883eff02556a26666be" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__sync&lt;/code&gt; - sync message, used by master and DUT to handshake.</source>
          <target state="translated">&lt;code&gt;__sync&lt;/code&gt; - 마스터 및 DUT에서 핸드 셰이크에 사용하는 동기화 메시지입니다.</target>
        </trans-unit>
        <trans-unit id="e44e21591905935c4722b68cea21bca505ee8d69" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__testcase_finish&lt;/code&gt; - sent by DUT, test case result.</source>
          <target state="translated">&lt;code&gt;__testcase_finish&lt;/code&gt; -DUT에서 전송, 테스트 케이스 결과.</target>
        </trans-unit>
        <trans-unit id="b1b2477cddf45a8f624498658f7c0e05338b1976" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__testcase_start&lt;/code&gt; - sent by DUT, test case start data.</source>
          <target state="translated">&lt;code&gt;__testcase_start&lt;/code&gt; -DUT에서 전송, 테스트 케이스 시작 데이터.</target>
        </trans-unit>
        <trans-unit id="a72bf43954020d842d07f1c5611e30859cebb23a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__timeout&lt;/code&gt; - timeout in sec, sent by DUT after &lt;code&gt;{{sync;UUID}}&lt;/code&gt; is received.</source>
          <target state="translated">&lt;code&gt;__timeout&lt;/code&gt; - &lt;code&gt;{{sync;UUID}}&lt;/code&gt; 가 수신 된 후 DUT에서 보낸 시간 제한 (초) 입니다.</target>
        </trans-unit>
        <trans-unit id="f256f495b16d358fb749994641994004470ab033" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__version&lt;/code&gt; - &lt;code&gt;greentea-client&lt;/code&gt; version send from DUT to host.</source>
          <target state="translated">&lt;code&gt;__version&lt;/code&gt; - &lt;code&gt;greentea-client&lt;/code&gt; 호스트에 DUT에서 버전 보냅니다.</target>
        </trans-unit>
        <trans-unit id="6aab874b35584a0d5e82976158f12f70a498f241" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;htrun&lt;/code&gt; has extensive command line. In most cases &lt;code&gt;htrun&lt;/code&gt; (or its command line avatar &lt;code&gt;mbedhtrun&lt;/code&gt;) will be run in background:</source>
          <target state="translated">&lt;code&gt;htrun&lt;/code&gt; 에는 광범위한 명령 줄이 있습니다. 대부분의 경우 &lt;code&gt;htrun&lt;/code&gt; (또는 명령 줄 아바타 &lt;code&gt;mbedhtrun&lt;/code&gt; )은 백그라운드에서 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="1bfd8fc28acb332ed6a8cb6f250ba9930873af0a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;htrun&lt;/code&gt; is redistributed with sources, as Python 2.7 compatible module called &lt;code&gt;mbed-host-tests&lt;/code&gt; and command line tool called &lt;code&gt;mbedhtrun&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;htrun&lt;/code&gt; 은 &lt;code&gt;mbed-host-tests&lt;/code&gt; 라는 Python 2.7 호환 모듈 과 &lt;code&gt;mbedhtrun&lt;/code&gt; 이라는 명령 줄 도구 로 소스와 함께 재배포됩니다 .</target>
        </trans-unit>
        <trans-unit id="a09ab1183cd1a4455515d2dfa623110358964aae" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;htrun&lt;/code&gt; new log format:</source>
          <target state="translated">&lt;code&gt;htrun&lt;/code&gt; 새 로그 형식 :</target>
        </trans-unit>
        <trans-unit id="146047f10bfe28e6ca1342363d40e58580f19413" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;level&lt;/code&gt; - logging level:</source>
          <target state="translated">&lt;code&gt;level&lt;/code&gt; -로깅 수준 :</target>
        </trans-unit>
        <trans-unit id="d230633f3997fb0cd8a87b415d32dfb4f5ec4ee9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mbed-host-tests&lt;/code&gt; module is redistributed via PyPI. We recommend you use the &lt;a href=&quot;https://pip.pypa.io/en/latest/installing.html#install-pip&quot;&gt;application pip&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;mbed-host-tests&lt;/code&gt; 모듈은 PyPI를 통해 재배포됩니다. &lt;a href=&quot;https://pip.pypa.io/en/latest/installing.html#install-pip&quot;&gt;애플리케이션 pip&lt;/a&gt; 를 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="9ab7b650f12a748dc308096fa0d77c6e039d3f5f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mbed-host-tests&lt;/code&gt; responsibilities are:</source>
          <target state="translated">&lt;code&gt;mbed-host-tests&lt;/code&gt; 책임은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="41c86f566beb36c6b6b2c4d73651b3ec643725db" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;notify_complete(result : bool)&lt;/code&gt; used by host test to notify test case result. This result will be read after test suite &lt;code&gt;TIMEOUT&lt;/code&gt;s or after DUT send &lt;code&gt;__exit&lt;/code&gt; message (test suite execution finished event).</source>
          <target state="translated">&lt;code&gt;notify_complete(result : bool)&lt;/code&gt; 호스트 테스트에서 테스트 케이스 결과를 알리는 데 사용합니다. 이 결과는 테스트 스위트 &lt;code&gt;TIMEOUT&lt;/code&gt; 후 또는 DUT가 &lt;code&gt;__exit&lt;/code&gt; 메시지를 보낸 후 (테스트 스위트 실행 완료 이벤트) 읽 힙니다 .</target>
        </trans-unit>
        <trans-unit id="172d5caa7d56ca7f7d3a296400bb8c3531f32901" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;result()&lt;/code&gt; used to return test case result when &lt;code&gt;notify_complete()&lt;/code&gt; is not called.</source>
          <target state="translated">&lt;code&gt;result()&lt;/code&gt; &lt;code&gt;notify_complete()&lt;/code&gt; 가 호출되지 않은 경우 테스트 케이스 결과를 반환하는 데 사용되는 result () 입니다.</target>
        </trans-unit>
        <trans-unit id="633f8b8babe06c499ac945176a533e88fe992987" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;self.log(text : string)&lt;/code&gt; - send event &lt;code&gt;__notify_prn&lt;/code&gt; with text as payload (value). Your message will be printed in log.</source>
          <target state="translated">&lt;code&gt;self.log(text : string)&lt;/code&gt; - 텍스트와 함께 &lt;code&gt;__notify_prn&lt;/code&gt; 이벤트 를 페이로드 (값)로 보냅니다 . 귀하의 메시지는 로그에 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="528d177a7da06eb7a40d93df454c3d1b17ba45ee" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;self.send_kv(key : string, value : string)&lt;/code&gt; - send key-value message to DUT.</source>
          <target state="translated">&lt;code&gt;self.send_kv(key : string, value : string)&lt;/code&gt; -키-값 메시지를 DUT로 보냅니다.</target>
        </trans-unit>
        <trans-unit id="3fa3134d5f4f9085110c25014db8a0a89b5f2f5a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;setup()&lt;/code&gt; used to initialize host test and register callbacks.</source>
          <target state="translated">&lt;code&gt;setup()&lt;/code&gt; 호스트 테스트를 초기화하고 콜백을 등록하는 데 사용되는 setup () .</target>
        </trans-unit>
        <trans-unit id="3d3df85d101648df2a2e38a07d2767c6bede72a2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;source&lt;/code&gt; - log source.</source>
          <target state="translated">&lt;code&gt;source&lt;/code&gt; - 로그 소스.</target>
        </trans-unit>
        <trans-unit id="d8d216f69ea1a3eaa95ba6458b40f43c08f477d4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;teardown()&lt;/code&gt; used to finalize and resource freeing. It is guaranteed that &lt;code&gt;teardown()&lt;/code&gt; will be always called after timeout or async test completion().</source>
          <target state="translated">&lt;code&gt;teardown()&lt;/code&gt; 및 리소스 해제에 사용되는 teardown () . 그것은 그 보장 &lt;code&gt;teardown()&lt;/code&gt; 항상 시간 제한 또는 비동기 테스트 완료 후 ()를 호출 할 것이다.</target>
        </trans-unit>
        <trans-unit id="2d70bf3e0f99480aa5b2daca6cbfcc9765092684" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;timestamp&lt;/code&gt; - returned by Python's &lt;code&gt;time.time()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;timestamp&lt;/code&gt; -Python의 &lt;code&gt;time.time()&lt;/code&gt; 에서 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="c10001035cfba5804245ebe313f1c7cddd149675" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;utest&lt;/code&gt; harness allows you to define multiple test cases inside your test suite. This feature is supported by &lt;code&gt;Greentea&lt;/code&gt; test tools.</source>
          <target state="translated">&lt;code&gt;utest&lt;/code&gt; 하네스를 사용하면 테스트 스위트 내에서 여러 테스트 케이스를 정의 할 수 있습니다. 이 기능은 &lt;code&gt;Greentea&lt;/code&gt; 테스트 도구에서 지원됩니다 .</target>
        </trans-unit>
        <trans-unit id="ccf7d45fdb7a3ec8da001ef50e0b0789523e0ce2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{{key;value}}&lt;/code&gt; string captured on DUT output.</source>
          <target state="translated">&lt;code&gt;{{key;value}}&lt;/code&gt; DUT 출력에서 ​​캡처 된 {{key; value}} 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="978812719c428d1362d193a491e176614ac1cf5a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Blocking&lt;/strong&gt; wait for key-value pair message in input stream:</source>
          <target state="translated">&lt;strong&gt;&lt;/strong&gt;입력 스트림에서 키-값 쌍 메시지를 기다리는 &lt;strong&gt;차단&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="bf04b208a59aca6656cbaf500f2714b821fc5dea" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Event exchange&lt;/strong&gt; - key-value event exchange between slave and master. In this exchange in general slave (DUT) will initialize communication. This part may end with ending pair of events &lt;code&gt;end&lt;/code&gt; and &lt;code&gt;__exit&lt;/code&gt; where &lt;code&gt;end&lt;/code&gt; event carries test suite result returned by DUT and &lt;code&gt;__exit&lt;/code&gt; event marks test suite ended and exited. After &lt;code&gt;__exit&lt;/code&gt; event is received there will be no more communication between DUT and host test.</source>
          <target state="translated">&lt;strong&gt;이벤트 교환&lt;/strong&gt; -슬레이브와 마스터 간의 키-값 이벤트 교환. 이 교환에서 일반 슬레이브 (DUT)는 통신을 초기화합니다. 이 부분은 종료 이벤트 쌍 과 &lt;code&gt;__exit&lt;/code&gt; 의 종료 쌍으로 &lt;code&gt;end&lt;/code&gt; 있으며 여기서 &lt;code&gt;end&lt;/code&gt; 이벤트는 DUT에서 반환 한 테스트 스위트 결과를 전달하고 &lt;code&gt;__exit&lt;/code&gt; 이벤트는 테스트 스위트가 종료 및 종료 되었음을 표시합니다. 후 &lt;code&gt;__exit&lt;/code&gt; 의 이벤트가 수신 DUT와 테스트 호스트 사이에 통신 이상이있을 것이다.</target>
        </trans-unit>
        <trans-unit id="b82b304ec2e4d8ca5c5d2b85582fa51e84fcd23a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Handshake&lt;/strong&gt; - synchronize master and slave.</source>
          <target state="translated">&lt;strong&gt;핸드 셰이크&lt;/strong&gt; -마스터와 슬레이브를 동기화합니다.</target>
        </trans-unit>
        <trans-unit id="22001cf273403186960b9b8e3ec3f02a2b7da50d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; Python 2.7.9 onwards include &lt;code&gt;pip&lt;/code&gt; by default, so you may have &lt;code&gt;pip&lt;/code&gt; already.
&lt;strong&gt;Note:&lt;/strong&gt;&lt;code&gt;mbed-host-tests&lt;/code&gt; module is redistributed with &lt;code&gt;mbed-greentea&lt;/code&gt; module as a dependency. So if you've already installed Greentea &lt;code&gt;mbed-host-tests&lt;/code&gt; should be there!</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; Python 2.7.9 이상에는 기본적으로 &lt;code&gt;pip&lt;/code&gt; 가 포함 되어 있으므로 이미 &lt;code&gt;pip&lt;/code&gt; 가있을 수 있습니다 . &lt;strong&gt;참고 : &lt;/strong&gt; &lt;code&gt;mbed-host-tests&lt;/code&gt; 모듈은 &lt;code&gt;mbed-greentea&lt;/code&gt; 모듈과 함께 종속성으로 재배포됩니다 . 따라서 이미 Greentea를 설치 &lt;code&gt;mbed-host-tests&lt;/code&gt; 가 있어야합니다!</target>
        </trans-unit>
        <trans-unit id="7ba071ca9346f715811b90bbcf80176dafdd545a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: Switch -m &amp;lt;platform_name&amp;gt; is required to tell Global Resource Management which platform to request.
&lt;strong&gt;Note&lt;/strong&gt;: Command line switch &lt;code&gt;--grm&lt;/code&gt; implicitly forces &lt;code&gt;--skip-flashing&lt;/code&gt; and &lt;code&gt;--skip-reset&lt;/code&gt; because both flags are used for locally available DUTs.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : Global Resource Management에 요청할 플랫폼을 알리려면 Switch -m &amp;lt;platform_name&amp;gt;이 필요합니다. &lt;strong&gt;참고&lt;/strong&gt; : 명령 줄 스위치 &lt;code&gt;--grm&lt;/code&gt; 은 로컬에서 사용 가능한 DUT에 두 플래그가 모두 사용되기 때문에 암시 적으로 &lt;code&gt;--skip-flashing&lt;/code&gt; 및 &lt;code&gt;--skip-reset&lt;/code&gt; 을 강제 합니다.</target>
        </trans-unit>
        <trans-unit id="2cdb8891adb6df7e3efff295d8bfc5578b693584" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: Switch -m &amp;lt;platform_name&amp;gt; is required to tell this fastmodel connection which Fastmodel to request.
&lt;strong&gt;Note&lt;/strong&gt;: Command line switch &lt;code&gt;--fm&lt;/code&gt; implicitly forces &lt;code&gt;--skip-flashing&lt;/code&gt; and &lt;code&gt;--skip-reset&lt;/code&gt; because both flags are used for locally available DUTs.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; :이 fastmodel 연결에 요청할 Fastmodel을 알리려면 Switch -m &amp;lt;platform_name&amp;gt;이 필요합니다. &lt;strong&gt;참고&lt;/strong&gt; : 명령 줄 스위치 &lt;code&gt;--fm&lt;/code&gt; 은 로컬에서 사용 가능한 DUT에 두 플래그가 모두 사용되기 때문에 암시 적으로 &lt;code&gt;--skip-flashing&lt;/code&gt; 및 &lt;code&gt;--skip-reset&lt;/code&gt; 을 강제 합니다.</target>
        </trans-unit>
        <trans-unit id="4a7ab915a793ffe6e1b42c4b1d8fcdeea993e9cb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: Sync packet management allows you to manipulate the way &lt;code&gt;htrun&lt;/code&gt; sends &lt;code&gt;__sync&lt;/code&gt; packet(s) to DUT. With current settings we can force on &lt;code&gt;htrun&lt;/code&gt; to send &lt;code&gt;__sync&lt;/code&gt; packets in this manner:</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : 동기화 패킷 관리 당신이 방법 조작 할 수 있습니다 &lt;code&gt;htrun&lt;/code&gt; 는 전송 &lt;code&gt;__sync&lt;/code&gt; DUT에 패킷 (들). 현재 설정으로 &lt;code&gt;htrun&lt;/code&gt; 에서 다음과 같은 방식으로 &lt;code&gt;__sync&lt;/code&gt; 패킷 을 보내도록 강제 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8770be929839dfce9cf2e64ddb9e81c172f276ef" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Preamble exchange&lt;/strong&gt; - DUT informs host about test parameters such as client version, test suite timeout, requested host test name etc. After this part is finished master will create requested host test and attach callbacks to user events.</source>
          <target state="translated">&lt;strong&gt;프리앰블 교환&lt;/strong&gt; -DUT는 클라이언트 버전, 테스트 스위트 타임 아웃, 요청 된 호스트 테스트 이름 등과 같은 테스트 매개 변수에 대해 호스트에 알립니다.이 부분이 완료되면 마스터는 요청 된 호스트 테스트를 생성하고 사용자 이벤트에 콜백을 첨부합니다.</target>
        </trans-unit>
        <trans-unit id="0e4a452d838b4f1866c3fe0046ee2cbef818254f" translate="yes" xml:space="preserve">
          <source>A tested comparison log can be checked into GitHub with the examples and can be used in the CI for example verification.</source>
          <target state="translated">테스트 된 비교 로그는 예제와 함께 GitHub에서 확인할 수 있으며 CI에서 예제 확인을 위해 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="48748b3b742385e6f8c0cd5908e2bbe354c77054" translate="yes" xml:space="preserve">
          <source>After DUT send &lt;code&gt;__exit&lt;/code&gt; or after timeout it is guaranteed that host test &lt;code&gt;teardown()&lt;/code&gt; function will be called. This call is blocking, please make sure your tear down function finishes.</source>
          <target state="translated">DUT가 &lt;code&gt;__exit&lt;/code&gt; 를 보낸 후 또는 시간 초과 후에 호스트 테스트 &lt;code&gt;teardown()&lt;/code&gt; 함수가 호출됩니다. 이 통화는 차단 중입니다. 분해 기능이 완료되었는지 확인하세요.</target>
        </trans-unit>
        <trans-unit id="09a3f6d7805c4c87b061eaf31eb5e2b3ebcd5a35" translate="yes" xml:space="preserve">
          <source>After correct sync packet is received by master, messages &lt;code&gt;{{__timeout;%d}}&lt;/code&gt; and &lt;code&gt;{{__host_test_name}}&lt;/code&gt; are expected.</source>
          <target state="translated">마스터가 올바른 동기화 패킷을 수신하면 &lt;code&gt;{{__timeout;%d}}&lt;/code&gt; 및 &lt;code&gt;{{__host_test_name}}&lt;/code&gt; 메시지 가 예상됩니다.</target>
        </trans-unit>
        <trans-unit id="3a7e401b4be215749d83fbcba3e4ec8209beb67b" translate="yes" xml:space="preserve">
          <source>After reset:</source>
          <target state="translated">재설정 후 :</target>
        </trans-unit>
        <trans-unit id="779eaffcf0df94cb11b0b9a188528d63ebf25484" translate="yes" xml:space="preserve">
          <source>All &lt;code&gt;mbedhtrun&lt;/code&gt; needs is name of the binary you want to flash and method of flashing!</source>
          <target state="translated">&lt;code&gt;mbedhtrun&lt;/code&gt; 에 필요한 모든 것은 플래시하려는 바이너리의 이름과 플래시 방법입니다!</target>
        </trans-unit>
        <trans-unit id="868aecef2b53c70e54e997a0929720538a3233ce" translate="yes" xml:space="preserve">
          <source>Another example with regular examples is shown below:</source>
          <target state="translated">일반적인 예가있는 또 다른 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c48ebfecb37de922cbe7a5c790047668217efb8a" translate="yes" xml:space="preserve">
          <source>As above but we will skip reset phase (non so common but in some cases can be used to suppress reset phase for some reasons):</source>
          <target state="translated">위와 같지만 재설정 단계를 건너 뛸 것입니다 (일반적이지는 않지만 어떤 경우에는 어떤 이유로 재설정 단계를 억제하는 데 사용할 수 있음).</target>
        </trans-unit>
        <trans-unit id="7a912fdada8ea0517f6988957ab102d6e5d42000" translate="yes" xml:space="preserve">
          <source>Before Greentea v0.2.0</source>
          <target state="translated">Greentea v0.2.0 이전</target>
        </trans-unit>
        <trans-unit id="883579fd087386dfd3f74e50aa8cf2893424d97a" translate="yes" xml:space="preserve">
          <source>Below the same callback registered using decorator:</source>
          <target state="translated">데코레이터를 사용하여 등록 된 동일한 콜백 아래 :</target>
        </trans-unit>
        <trans-unit id="54f3a582e0e46c1fdbde56c6d9b5c912b1062595" translate="yes" xml:space="preserve">
          <source>Callback decorator definition</source>
          <target state="translated">콜백 데코레이터 정의</target>
        </trans-unit>
        <trans-unit id="61aea957495b12cf35ed6fa4692f689a4b6830cf" translate="yes" xml:space="preserve">
          <source>Callback registration in setup() method</source>
          <target state="translated">setup () 메서드의 콜백 등록</target>
        </trans-unit>
        <trans-unit id="9fdc2cfe374fa5bde1e4e458854875e1709add1c" translate="yes" xml:space="preserve">
          <source>Callbacks</source>
          <target state="translated">콜백</target>
        </trans-unit>
        <trans-unit id="0919f1c08841ab59f4010ca0c08be7d21b733553" translate="yes" xml:space="preserve">
          <source>Change the directory to the &lt;code&gt;mbed-os-tools/packages/mbed-host-tests&lt;/code&gt; directory:</source>
          <target state="translated">디렉토리를 &lt;code&gt;mbed-os-tools/packages/mbed-host-tests&lt;/code&gt; 디렉토리로 변경합니다.</target>
        </trans-unit>
        <trans-unit id="7741c1b49d16cff50f9f11d5390e73dce207ea10" translate="yes" xml:space="preserve">
          <source>Checking installation</source>
          <target state="translated">설치 확인</target>
        </trans-unit>
        <trans-unit id="8f421d7903d21e7af2e8365c67e68dcf4c7e23b4" translate="yes" xml:space="preserve">
          <source>Command line overview</source>
          <target state="translated">명령 줄 개요</target>
        </trans-unit>
        <trans-unit id="1e1918c7b0e450f50460cc106d52c81934e94310" translate="yes" xml:space="preserve">
          <source>Command line switch &lt;code&gt;--grm&lt;/code&gt; has format: &lt;code&gt;&amp;lt;module_name&amp;gt;:&amp;lt;IP_address&amp;gt;:&amp;lt;port_number&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">명령 줄 스위치 &lt;code&gt;--grm&lt;/code&gt; 의 형식은 &lt;code&gt;&amp;lt;module_name&amp;gt;:&amp;lt;IP_address&amp;gt;:&amp;lt;port_number&amp;gt;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="56daa4f6991ad23ee3ad9337bba1c4b9e7dae685" translate="yes" xml:space="preserve">
          <source>Command line switch format &lt;code&gt;--fm &amp;lt;config_name&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">명령 줄 스위치 형식 &lt;code&gt;--fm &amp;lt;config_name&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4ff2cd088270334c8a2f99dfc624bcd332a50384" translate="yes" xml:space="preserve">
          <source>Corresponding log:</source>
          <target state="translated">해당 로그 :</target>
        </trans-unit>
        <trans-unit id="d895d5e7e230d89bd4cfe4224c65b0d27e50070e" translate="yes" xml:space="preserve">
          <source>DUT - host test case workflow</source>
          <target state="translated">DUT-호스트 테스트 케이스 워크 플로우</target>
        </trans-unit>
        <trans-unit id="626c3ee860fb240f7628dd4674a59b588bf8f8b4" translate="yes" xml:space="preserve">
          <source>DUT always (except for handshake phase) initializes communication by sending key-value message to host.</source>
          <target state="translated">DUT는 항상 (핸드 셰이크 단계 제외) 키-값 메시지를 호스트에 전송하여 통신을 초기화합니다.</target>
        </trans-unit>
        <trans-unit id="2c6516f3287de370bb466acaf1a844e15e278271" translate="yes" xml:space="preserve">
          <source>DUT always finishes execution</source>
          <target state="translated">DUT는 항상 실행을 완료합니다.</target>
        </trans-unit>
        <trans-unit id="095e4a38df5cb9fd44a60b3fb755fc995fb05b85" translate="yes" xml:space="preserve">
          <source>DUT calls function &lt;code&gt;GREENTEA_SETUP(timeout, &quot;host test name&quot;);&lt;/code&gt; which</source>
          <target state="translated">DUT는 &lt;code&gt;GREENTEA_SETUP(timeout, &quot;host test name&quot;);&lt;/code&gt; 함수를 호출합니다 (시간 초과, &quot;호스트 테스트 이름&quot;); 어느</target>
        </trans-unit>
        <trans-unit id="165c9ff6d3335894ae3b4f0accf0b86e9682904e" translate="yes" xml:space="preserve">
          <source>DUT code:</source>
          <target state="translated">DUT 코드 :</target>
        </trans-unit>
        <trans-unit id="b921767324737366f2552e20da90f6fc8abb1ea2" translate="yes" xml:space="preserve">
          <source>DUT implementation</source>
          <target state="translated">DUT 구현</target>
        </trans-unit>
        <trans-unit id="9c597a19b077deb109c00589b1390f002b08e65d" translate="yes" xml:space="preserve">
          <source>DUT implementation using &lt;code&gt;my_host_test&lt;/code&gt; custom host test:</source>
          <target state="translated">&lt;code&gt;my_host_test&lt;/code&gt; 사용자 지정 호스트 테스트를 사용한 DUT 구현 :</target>
        </trans-unit>
        <trans-unit id="7b4a20d2bc2fb30dc4fc0306d08e9b81fe1471f2" translate="yes" xml:space="preserve">
          <source>DUT implementation:</source>
          <target state="translated">DUT 구현 :</target>
        </trans-unit>
        <trans-unit id="6a2cce350afb4935c3fdced46913ecb2c36b6dff" translate="yes" xml:space="preserve">
          <source>DUT side uses second argument of &lt;code&gt;GREENTEA_SETUP(timeout, host_test_name)&lt;/code&gt; function:</source>
          <target state="translated">DUT 측은 &lt;code&gt;GREENTEA_SETUP(timeout, host_test_name)&lt;/code&gt; 함수 의 두 번째 인수를 사용 합니다.</target>
        </trans-unit>
        <trans-unit id="14c69c2b7257c38eb710e9d086b6f9d2b90ab384" translate="yes" xml:space="preserve">
          <source>DUT slave side uses simple parser to parse key-value pairs from stream. All non key-value data will be ignored. Blocking wait for an event API is provided: This implies usage of master-slave exchange between DUT and host where DUT uses non-blocking send event API to send to host (master) event and can wait for response. Master implements corresponding response after receiving event and processing data.</source>
          <target state="translated">DUT 슬레이브 측은 간단한 파서를 사용하여 스트림에서 키-값 쌍을 구문 분석합니다. 키-값이 아닌 모든 데이터는 무시됩니다. 이벤트 API에 대한 차단 대기 제공 : DUT와 호스트 간의 마스터-슬레이브 교환 사용을 의미하며 DUT는 비 차단 전송 이벤트 API를 사용하여 호스트 (마스터) 이벤트로 전송하고 응답을 기다릴 수 있습니다. 마스터는 이벤트 수신 및 데이터 처리 후 해당 응답을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="1997bc510fdd148c5460b1f9a4c03afbb22db4b3" translate="yes" xml:space="preserve">
          <source>DUT test API was first introduced in &lt;code&gt;mbedmicro/mbed&lt;/code&gt; project &lt;a href=&quot;https://github.com/mbedmicro/mbed/tree/master/libraries/tests/mbed/env&quot;&gt;here&lt;/a&gt;. After refactoring this functionality was copied and improved in &lt;a href=&quot;https://github.com/ARMmbed/mbed-os/tree/master/features/frameworks/greentea-client&quot;&gt;greentea-client&lt;/a&gt; module.</source>
          <target state="translated">DUT 테스트 API는 먼저 도입 &lt;code&gt;mbedmicro/mbed&lt;/code&gt; 프로젝트를 &lt;a href=&quot;https://github.com/mbedmicro/mbed/tree/master/libraries/tests/mbed/env&quot;&gt;여기에&lt;/a&gt; . 리팩토링 후이 기능은 &lt;a href=&quot;https://github.com/ARMmbed/mbed-os/tree/master/features/frameworks/greentea-client&quot;&gt;greentea-client&lt;/a&gt; 모듈 에서 복사 및 개선되었습니다 .</target>
        </trans-unit>
        <trans-unit id="3cd14348a79f6dd2dc4ed92b00adfffbe3313dca" translate="yes" xml:space="preserve">
          <source>DUT test suite never finishes execution</source>
          <target state="translated">DUT 테스트 스위트가 실행을 완료하지 않음</target>
        </trans-unit>
        <trans-unit id="aebd9413076d65c89e207689ac7673ccdbe3fce1" translate="yes" xml:space="preserve">
          <source>DUT test suite with &lt;code&gt;utest&lt;/code&gt; harness</source>
          <target state="translated">&lt;code&gt;utest&lt;/code&gt; 하네스가있는 DUT 테스트 스위트</target>
        </trans-unit>
        <trans-unit id="b9a257b89d70fac4953d77b392223a7141b06c89" translate="yes" xml:space="preserve">
          <source>DUT test suite with single test case</source>
          <target state="translated">단일 테스트 케이스가있는 DUT 테스트 스위트</target>
        </trans-unit>
        <trans-unit id="736a527bb1c06de722602489784f5dff79e01f9d" translate="yes" xml:space="preserve">
          <source>DUT waits for &lt;code&gt;{{__sync;...}}&lt;/code&gt; message in input stream and replies with the same packer &lt;code&gt;{{__sync;...}}&lt;/code&gt;.</source>
          <target state="translated">DUT는 입력 스트림에서 &lt;code&gt;{{__sync;...}}&lt;/code&gt; 메시지를 &lt;code&gt;{{__sync;...}}&lt;/code&gt; 동일한 패커 {{__sync; ...}}로 응답합니다 .</target>
        </trans-unit>
        <trans-unit id="647d603597976a170b993ee2698c02e93538fd86" translate="yes" xml:space="preserve">
          <source>DUT will send to host preamble with test runner information such as:</source>
          <target state="translated">DUT는 다음과 같은 테스트 실행기 정보와 함께 호스트 프리앰블을 보냅니다.</target>
        </trans-unit>
        <trans-unit id="07c83fa7e049f4fd805d5b8928beb027731de9b8" translate="yes" xml:space="preserve">
          <source>DUT-host communication and reset phase</source>
          <target state="translated">DUT 호스트 통신 및 재설정 단계</target>
        </trans-unit>
        <trans-unit id="709809b3955dfa71a2918ff271debe54e9883a64" translate="yes" xml:space="preserve">
          <source>Default DUT reset method is one supported by &lt;a href=&quot;https://www.mbed.com/en/about-mbed/mbed-enabled/&quot;&gt;mbed-enabled&lt;/a&gt; devices: serial port (CDC) &quot;&lt;em&gt;sendBreak&lt;/em&gt;&quot; command resets target MCU on mbed-enabled platform.</source>
          <target state="translated">기본 DUT 재설정 방법은 &lt;a href=&quot;https://www.mbed.com/en/about-mbed/mbed-enabled/&quot;&gt;mbed 지원&lt;/a&gt; 장치에서 지원하는 방법입니다 . 직렬 포트 (CDC) &quot; &lt;em&gt;sendBreak&lt;/em&gt; &quot;명령은 mbed 지원 플랫폼에서 대상 MCU를 재설정합니다.</target>
        </trans-unit>
        <trans-unit id="bc2cd630546bc1cb92afe393e71240db008e5337" translate="yes" xml:space="preserve">
          <source>Default binary flashing method is one supported by &lt;a href=&quot;https://www.mbed.com/en/about-mbed/mbed-enabled/&quot;&gt;mbed-enabled&lt;/a&gt; devices: binary file is copied on mbed-enabled DUT (Device Under Test) mounted drive (MSD). This procedure will automatically flash device with given binary file content.</source>
          <target state="translated">기본 이진 플래싱 방법은 &lt;a href=&quot;https://www.mbed.com/en/about-mbed/mbed-enabled/&quot;&gt;mbed 지원&lt;/a&gt; 장치에서 지원하는 방법입니다 . 이진 파일은 mbed 지원 DUT (Device Under Test) 장착 드라이브 (MSD)에 복사됩니다. 이 절차는 주어진 이진 파일 내용으로 장치를 자동으로 플래시합니다.</target>
        </trans-unit>
        <trans-unit id="44d55f06d963a9ca25fae9517787bf49edec5269" translate="yes" xml:space="preserve">
          <source>Design draft</source>
          <target state="translated">디자인 초안</target>
        </trans-unit>
        <trans-unit id="a8c5a3b94826af621da5a375d345ece1f610fcc9" translate="yes" xml:space="preserve">
          <source>Development moved</source>
          <target state="translated">개발 이동</target>
        </trans-unit>
        <trans-unit id="9df9a8179b1a565208b4dd6239287e040d9d8d11" translate="yes" xml:space="preserve">
          <source>Do not forget to name host test accordingly. See below example host test &lt;code&gt;name&lt;/code&gt; class member.</source>
          <target state="translated">그에 따라 호스트 테스트 이름을 지정하는 것을 잊지 마십시오. 아래 예제 호스트 테스트 &lt;code&gt;name&lt;/code&gt; 클래스 멤버를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="3f7497a8dfedacd212c2996862b7d6fcb884d29e" translate="yes" xml:space="preserve">
          <source>Each event is a tuple of &lt;code&gt;(key, value, timestamp)&lt;/code&gt;, where key and value are extracted from message and</source>
          <target state="translated">각 이벤트는 &lt;code&gt;(key, value, timestamp)&lt;/code&gt; 의 튜플입니다 . 여기서 키와 값은 메시지에서 추출되고</target>
        </trans-unit>
        <trans-unit id="86254eea7d60c4ae1201fb3716651deb450e3119" translate="yes" xml:space="preserve">
          <source>Each host test (master side) has four functions used by async framework:</source>
          <target state="translated">각 호스트 테스트 (마스터 측)에는 비동기 프레임 워크에서 사용하는 네 가지 기능이 있습니다.</target>
        </trans-unit>
        <trans-unit id="3065e92116c10e024814d96a6883bff0ea8755a1" translate="yes" xml:space="preserve">
          <source>Each host test registers callbacks for available events.</source>
          <target state="translated">각 호스트 테스트는 사용 가능한 이벤트에 대한 콜백을 등록합니다.</target>
        </trans-unit>
        <trans-unit id="39ed4ebaf961ae0c8f1b791ecd147e37c0384649" translate="yes" xml:space="preserve">
          <source>Event exchange</source>
          <target state="translated">이벤트 교환</target>
        </trans-unit>
        <trans-unit id="bb60c70e550b193a26e657cf530450eafa23a645" translate="yes" xml:space="preserve">
          <source>Event is formed in host test, a tuple of &lt;code&gt;key&lt;/code&gt; (string), &lt;code&gt;value&lt;/code&gt; (string), &lt;code&gt;timestamp&lt;/code&gt; where &lt;code&gt;timestamp&lt;/code&gt; is time of message reception in Python &lt;a href=&quot;https://docs.python.org/2/library/time.html#time.time&quot;&gt;time.time()&lt;/a&gt; format (float, time in seconds since the epoch as a floating point number.).</source>
          <target state="translated">이벤트는 호스트 테스트, &lt;code&gt;key&lt;/code&gt; (문자열), &lt;code&gt;value&lt;/code&gt; (문자열), &lt;code&gt;timestamp&lt;/code&gt; 의 튜플로 구성되며 , 여기서 &lt;code&gt;timestamp&lt;/code&gt; 는 Python &lt;a href=&quot;https://docs.python.org/2/library/time.html#time.time&quot;&gt;time.time ()&lt;/a&gt; 형식 의 메시지 수신 시간입니다 (float, 부동 소수점 숫자로 epoch 이후의 시간 (초 )) .).</target>
        </trans-unit>
        <trans-unit id="18ccebe3f5dfea294643a10c4d680a7e353c7bef" translate="yes" xml:space="preserve">
          <source>Example host test template:</source>
          <target state="translated">호스트 테스트 템플릿의 예 :</target>
        </trans-unit>
        <trans-unit id="720866581bbfe73b668502026de8c5cdfa711f10" translate="yes" xml:space="preserve">
          <source>Example of corresponding host test</source>
          <target state="translated">해당 호스트 테스트의 예</target>
        </trans-unit>
        <trans-unit id="ea76c8a1d8a41f033db77eace0fd6e4212decee5" translate="yes" xml:space="preserve">
          <source>Example of handshake from &lt;code&gt;htrun&lt;/code&gt; log:</source>
          <target state="translated">&lt;code&gt;htrun&lt;/code&gt; 로그 의 핸드 셰이크 예 :</target>
        </trans-unit>
        <trans-unit id="2fda2299de8a0cdd18062acac9fba1e569417400" translate="yes" xml:space="preserve">
          <source>Example of host test expecting &lt;code&gt;Runtime error ... CallbackNode ...&lt;/code&gt; string in DUT output.
We will use allowed to override &lt;code&gt;__rxd_line&lt;/code&gt; event to hook to DUT RXD channel lines of text.</source>
          <target state="translated">&lt;code&gt;Runtime error ... CallbackNode ...&lt;/code&gt; 예상하는 호스트 테스트의 예 ... CallbackNode ... DUT 출력의 문자열. allowed to override &lt;code&gt;__rxd_line&lt;/code&gt; 이벤트를 사용하여 DUT RXD 채널 텍스트 줄에 연결합니다.</target>
        </trans-unit>
        <trans-unit id="eaaf6b7d8c3502c17a6dc3cf142c18776b31898a" translate="yes" xml:space="preserve">
          <source>Exchange data (in most cases text) between host and DUT,</source>
          <target state="translated">호스트와 DUT간에 데이터 (대부분의 경우 텍스트)를 교환합니다.</target>
        </trans-unit>
        <trans-unit id="f33ba3019954aafa1feb8235b68f034789a412bb" translate="yes" xml:space="preserve">
          <source>Fast Model connection</source>
          <target state="translated">빠른 모델 연결</target>
        </trans-unit>
        <trans-unit id="a0d877bb17464347f7e476238777723873ceebb8" translate="yes" xml:space="preserve">
          <source>Few keys' names in key-value messaging protocol are promoted to be considered &quot;system events&quot;. Their names are used by event loop mechanism to communicate between DUT, host and various internal components. Please do not use restricted even names for your own private events. What's more:</source>
          <target state="translated">키-값 메시징 프로토콜의 일부 키 이름은 &quot;시스템 이벤트&quot;로 간주됩니다. 이들 이름은 이벤트 루프 메커니즘에서 DUT, 호스트 및 다양한 내부 구성 요소간에 통신하는 데 사용됩니다. 개인 이벤트에 제한된 짝수 이름을 사용하지 마십시오. 또 뭔데:</target>
        </trans-unit>
        <trans-unit id="158f43262acd06e7642b29309e126923316f2ecd" translate="yes" xml:space="preserve">
          <source>Flash (use shell command &lt;code&gt;copy&lt;/code&gt;) binary file &lt;code&gt;/path/to/file/binary.bin&lt;/code&gt; using mount point &lt;code&gt;D:&lt;/code&gt;. Use serial port &lt;code&gt;COM4&lt;/code&gt; to communicate with DUT:</source>
          <target state="translated">플래시 (사용 쉘 명령 &lt;code&gt;copy&lt;/code&gt; ) 바이너리 파일 &lt;code&gt;/path/to/file/binary.bin&lt;/code&gt; 지점 마운트 사용하여 &lt;code&gt;D:&lt;/code&gt; . 직렬 포트 &lt;code&gt;COM4&lt;/code&gt; 를 사용 하여 DUT와 통신합니다.</target>
        </trans-unit>
        <trans-unit id="b79e8d9072014d2c3b21cd78069437deec0df9b9" translate="yes" xml:space="preserve">
          <source>Flash binary file &lt;code&gt;/path/to/file/binary.bin&lt;/code&gt; using mount point &lt;code&gt;D:&lt;/code&gt;. Use serial port &lt;code&gt;COM4&lt;/code&gt; to communicate with DUT:</source>
          <target state="translated">이진 파일을 플래시 &lt;code&gt;/path/to/file/binary.bin&lt;/code&gt; 지점 마운트 사용하여 &lt;code&gt;D:&lt;/code&gt; . 직렬 포트 &lt;code&gt;COM4&lt;/code&gt; 를 사용 하여 DUT와 통신합니다.</target>
        </trans-unit>
        <trans-unit id="0bb415010bae6adec9b342b99c1fe6276f7c8c46" translate="yes" xml:space="preserve">
          <source>Flash binary file &lt;code&gt;/path/to/file/binary.bin&lt;/code&gt; using mount point &lt;code&gt;D:&lt;/code&gt;. Use serial port &lt;code&gt;COM4&lt;/code&gt; with baudrate &lt;code&gt;115200&lt;/code&gt; to communicate with DUT:</source>
          <target state="translated">이진 파일을 플래시 &lt;code&gt;/path/to/file/binary.bin&lt;/code&gt; 지점 마운트 사용하여 &lt;code&gt;D:&lt;/code&gt; . 전송 속도가 &lt;code&gt;115200&lt;/code&gt; 인 직렬 포트 &lt;code&gt;COM4&lt;/code&gt; 를 사용 하여 DUT와 통신합니다.</target>
        </trans-unit>
        <trans-unit id="7aa54b0e3eb90e603779697ab7f217dff3331191" translate="yes" xml:space="preserve">
          <source>Flash binary file &lt;code&gt;/path/to/file/binary.bin&lt;/code&gt; using mount point &lt;code&gt;D:&lt;/code&gt;. Use serial port &lt;code&gt;COM4&lt;/code&gt; with default baudrate to communicate with DUT. Do not send &lt;code&gt;__sync&lt;/code&gt; key-value protocol synchronization packet to DUT before preamble read:</source>
          <target state="translated">이진 파일을 플래시 &lt;code&gt;/path/to/file/binary.bin&lt;/code&gt; 지점 마운트 사용하여 &lt;code&gt;D:&lt;/code&gt; . DUT와 통신하려면 기본 전송 속도로 직렬 포트 &lt;code&gt;COM4&lt;/code&gt; 를 사용 합니다. 프리앰블을 읽기 전에 &lt;code&gt;__sync&lt;/code&gt; 키-값 프로토콜 동기화 패킷을 DUT로 보내지 마십시오 .</target>
        </trans-unit>
        <trans-unit id="334ce270911437bb87db7f7e500dc3562bbd2dcb" translate="yes" xml:space="preserve">
          <source>Flash binary file &lt;code&gt;/path/to/file/binary.bin&lt;/code&gt; using plugin &lt;code&gt;stlink&lt;/code&gt;. Use serial port &lt;code&gt;COM4&lt;/code&gt; with baudrate &lt;code&gt;115200&lt;/code&gt; to communicate with DUT:</source>
          <target state="translated">플러그인 &lt;code&gt;stlink&lt;/code&gt; 를 사용하는 플래시 바이너리 파일 &lt;code&gt;/path/to/file/binary.bin&lt;/code&gt; . 전송 속도가 &lt;code&gt;115200&lt;/code&gt; 인 직렬 포트 &lt;code&gt;COM4&lt;/code&gt; 를 사용 하여 DUT와 통신합니다.</target>
        </trans-unit>
        <trans-unit id="aaa6043ae95f9a67b22b9f51a18f7faa10482294" translate="yes" xml:space="preserve">
          <source>Flash local file &lt;code&gt;/path/to/file/binary.bin&lt;/code&gt; to remote device resource (platform &lt;code&gt;K64F&lt;/code&gt;) provided by &lt;code&gt;remote_client&lt;/code&gt; GRM service available on IP address &lt;code&gt;10.2.203.31&lt;/code&gt; and port: &lt;code&gt;8000&lt;/code&gt;. Force serial port connection to remote device &lt;code&gt;9600&lt;/code&gt; with baudrate:</source>
          <target state="translated">IP 주소 &lt;code&gt;10.2.203.31&lt;/code&gt; 및 포트 : &lt;code&gt;8000&lt;/code&gt; 에서 사용 가능한 &lt;code&gt;remote_client&lt;/code&gt; GRM 서비스에서 제공하는 원격 장치 리소스 (플랫폼 &lt;code&gt;K64F&lt;/code&gt; )에 로컬 파일 &lt;code&gt;/path/to/file/binary.bin&lt;/code&gt; 을 플래시합니다 . 전송 속도 를 사용하여 원격 장치 &lt;code&gt;9600&lt;/code&gt; 에 직렬 포트 연결을 강제합니다 .</target>
        </trans-unit>
        <trans-unit id="2571f99f1680e5391cd93011b0082d4efb07cbd5" translate="yes" xml:space="preserve">
          <source>Flash mbed device with given binary.</source>
          <target state="translated">주어진 바이너리가있는 플래시 mbed 장치.</target>
        </trans-unit>
        <trans-unit id="6761cf8a57f5841e04096627ea88d5887f48e0fc" translate="yes" xml:space="preserve">
          <source>Flashing phase operations</source>
          <target state="translated">깜박임 단계 작업</target>
        </trans-unit>
        <trans-unit id="8a866d6c2d02f0bc023dc62569a6c17af0376992" translate="yes" xml:space="preserve">
          <source>For example if you hardcode in your host test UDP port 32123 and use it for UDP server implementation  of your host test bear in mind that this port may be already used. It is your responsibility to react for this event and implement means to overcome it (if possible).</source>
          <target state="translated">예를 들어 호스트 테스트 UDP 포트 32123에서 하드 코딩하고이를 호스트 테스트의 UDP 서버 구현에 사용하는 경우이 포트가 이미 사용 중일 수 있습니다. 이 이벤트에 대응하고이를 극복하기위한 수단을 구현하는 것은 귀하의 책임입니다 (가능한 경우).</target>
        </trans-unit>
        <trans-unit id="7c1aff202f7d8bcea4fa64405f0aca7af6efda87" translate="yes" xml:space="preserve">
          <source>Functions are used to send key-string or key-integer value messages to master. This functions should replace typical &lt;code&gt;printf()&lt;/code&gt; calls with payload/control data to host.</source>
          <target state="translated">마스터에 키 문자열 또는 키 정수 값 메시지를 보내는 데 함수가 사용됩니다. 이 함수는 일반적인 &lt;code&gt;printf()&lt;/code&gt; 호출을 호스트에 대한 페이로드 / 제어 데이터로 대체해야 합니다.</target>
        </trans-unit>
        <trans-unit id="af3ec244dc723a701ac058afc63d124fbfd72829" translate="yes" xml:space="preserve">
          <source>Global Resource Manager connection</source>
          <target state="translated">Global Resource Manager 연결</target>
        </trans-unit>
        <trans-unit id="a0be22585fd735b25c7d089d58ba0169fc6da82f" translate="yes" xml:space="preserve">
          <source>Greentea client API</source>
          <target state="translated">Greentea 클라이언트 API</target>
        </trans-unit>
        <trans-unit id="76ccff916d0696e0db6e0e63211aa5d404b177bb" translate="yes" xml:space="preserve">
          <source>Handshake</source>
          <target state="translated">악수</target>
        </trans-unit>
        <trans-unit id="afe7a417d745ef7f8ce3a908ad2af663ae59dca3" translate="yes" xml:space="preserve">
          <source>Hanshake between DUT and host is a sequence of &lt;code&gt;__sync&lt;/code&gt; events send between host (master) and DUT (slave). This is currently only situation when master initiates communication first. Handshake should provide synchronization point where master and slave are starting the same session.</source>
          <target state="translated">DUT와 호스트 간의 &lt;code&gt;__sync&lt;/code&gt; 는 호스트 (마스터)와 DUT (슬레이브)간에 전송 되는 일련의 __sync 이벤트입니다. 이것은 현재 마스터가 먼저 통신을 시작하는 경우에만 해당됩니다. 핸드 셰이크는 마스터와 슬레이브가 동일한 세션을 시작하는 동기화 지점을 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="c462c6142be867f0a9f93d039025a1e9848ee526" translate="yes" xml:space="preserve">
          <source>Hence the strategy for testing examples is based on observation instead of interaction. An example's serial logging is captured and converted into a templated log. All successive executions of this example should match this log.</source>
          <target state="translated">따라서 예제 테스트 전략은 상호 작용이 아닌 관찰을 기반으로합니다. 예제의 직렬 로깅이 캡처되어 템플릿 로그로 변환됩니다. 이 예제의 모든 연속 실행은이 로그와 일치해야합니다.</target>
        </trans-unit>
        <trans-unit id="81a50f092a9c1baca81536bee0ce39b6ef1ca7c0" translate="yes" xml:space="preserve">
          <source>Host parses DUTs tx stream and generates events sent to host test.</source>
          <target state="translated">호스트는 DUT tx 스트림을 구문 분석하고 호스트 테스트로 전송되는 이벤트를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="739d7ff56b572bddde7bca4b888be4430164af90" translate="yes" xml:space="preserve">
          <source>Host state machine loads callbacks registered by user in host test setup phase and hooks them to event machine.
Now host is ready to handle test suite test execution. From this moment each event sent from DUT will be handled by corresponding callback registered by user in host test setup. Unknown events will not be handled and warning will be printed in log.</source>
          <target state="translated">호스트 상태 머신은 호스트 테스트 설정 단계에서 사용자가 등록한 콜백을로드하여 이벤트 머신에 연결합니다. 이제 호스트가 테스트 스위트 테스트 실행을 처리 할 준비가되었습니다. 이때부터 DUT에서 보낸 각 이벤트는 호스트 테스트 설정에서 사용자가 등록한 해당 콜백에 의해 처리됩니다. 알 수없는 이벤트는 처리되지 않으며 경고가 로그에 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="3bf2563e8f05e77491179793ef8db96c86834d6c" translate="yes" xml:space="preserve">
          <source>Host state machine loads host test object by name provided in payload of &lt;code&gt;__host_test_name&lt;/code&gt; event.E.g. event ```{{____host_test_name;default_auto}} will load host test named &quot;&lt;em&gt;default_auto&lt;/em&gt;&quot;.</source>
          <target state="translated">호스트 상태 머신은 &lt;code&gt;__host_test_name&lt;/code&gt; 이벤트의 페이로드에 제공된 이름으로 호스트 테스트 개체를로드합니다. 예를 들어 ```{{____ host_test_name; default_auto}} 이벤트는 &quot; &lt;em&gt;default_auto&lt;/em&gt; &quot; 라는 호스트 테스트를로드합니다 .</target>
        </trans-unit>
        <trans-unit id="256e466598015d9893e7d37134c90ab1322dee71" translate="yes" xml:space="preserve">
          <source>Host test examples</source>
          <target state="translated">호스트 테스트 예</target>
        </trans-unit>
        <trans-unit id="7aa340f16d0f3e4b0a727d2aeb24e1d71f83a1d2" translate="yes" xml:space="preserve">
          <source>Host tests are now driven by simple async feature. Event state machine on master side is used to process events from DUT. Each host test is capable of registering callbacks, functions which will be executed when event occur. Event name is identical with KEY in key-value pair send as event from/to DUT.</source>
          <target state="translated">호스트 테스트는 이제 간단한 비동기 기능으로 구동됩니다. 마스터 측의 이벤트 상태 머신은 DUT의 이벤트를 처리하는 데 사용됩니다. 각 호스트 테스트는 이벤트 발생시 실행되는 기능인 콜백을 등록 할 수 있습니다. 이벤트 이름은 DUT에서 이벤트로 전송되는 키-값 쌍의 KEY와 동일합니다.</target>
        </trans-unit>
        <trans-unit id="f34c65d375ef807a0d1053054afcca89454eb733" translate="yes" xml:space="preserve">
          <source>Host will spawn host test script and test execution will be instrumented</source>
          <target state="translated">호스트가 호스트 테스트 스크립트를 생성하고 테스트 실행이 계측됩니다.</target>
        </trans-unit>
        <trans-unit id="9c5759b3a29a12c887dbdea960cf8e8e034f43a0" translate="yes" xml:space="preserve">
          <source>Htrun (mbed-host-tests)</source>
          <target state="translated">Htrun (mbed-host-tests)</target>
        </trans-unit>
        <trans-unit id="f9ca9c8e689a1271ff659bece18781ba5d93d16f" translate="yes" xml:space="preserve">
          <source>In case an application requires more time to process data and generate results, you can use the option &lt;code&gt;--polling-timeout&lt;/code&gt; to override the default timeout setting.</source>
          <target state="translated">애플리케이션에서 데이터를 처리하고 결과를 생성하는 데 더 많은 시간이 필요한 경우 &lt;code&gt;--polling-timeout&lt;/code&gt; 옵션을 사용 하여 기본 제한 시간 설정을 재정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="49317310382ddf66dd0c5d0f51b7b63b474cc3af" translate="yes" xml:space="preserve">
          <source>In order to work with platforms for which the hardware is still under development, and hence may not have an mbed interface chip, some &quot;hook&quot; files are required.  Operation with these platforms is a matter for the platform development teams involved and is not, in general, supported by ARM.</source>
          <target state="translated">하드웨어가 아직 개발 중이고 따라서 mbed 인터페이스 칩이 없을 수있는 플랫폼에서 작업하려면 일부 &quot;후크&quot;파일이 필요합니다. 이러한 플랫폼을 사용한 작업은 관련된 플랫폼 개발 팀의 문제이며 일반적으로 ARM에서 지원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="96aea4a4578a7a24ceb5456357622da825fbc337" translate="yes" xml:space="preserve">
          <source>In this example DUT code uses &lt;code&gt;greentea-client&lt;/code&gt; to sync (&lt;code&gt;GREENTEA_SETUP&lt;/code&gt;) and pass result (&lt;code&gt;GREENTEA_TESTSUITE_RESULT&lt;/code&gt;) to &lt;code&gt;Greentea&lt;/code&gt;. This is very simple example of how you can write tests. Note that in this example test suite only implements one test case. Actually test suite is test case at the same time. Result passed to &lt;code&gt;GREENTEA_TESTSUITE_RESULT&lt;/code&gt; will be at the same time test case result.</source>
          <target state="translated">이 예에서 DUT 코드는 &lt;code&gt;GREENTEA_SETUP&lt;/code&gt; &lt;code&gt;greentea-client&lt;/code&gt; 를 사용 하여 동기화 ( GREENTEA_SETUP )하고 결과 ( &lt;code&gt;GREENTEA_TESTSUITE_RESULT&lt;/code&gt; )를 &lt;code&gt;Greentea&lt;/code&gt; 에 전달 합니다. 이것은 테스트를 작성하는 방법에 대한 매우 간단한 예입니다. 이 예제에서 테스트 스위트는 하나의 테스트 케이스 만 구현합니다. 실제로 테스트 스위트는 동시에 테스트 케이스입니다. &lt;code&gt;GREENTEA_TESTSUITE_RESULT&lt;/code&gt; 에 전달 된 결과 는 동시에 테스트 케이스 결과입니다.</target>
        </trans-unit>
        <trans-unit id="63ce22e8cc62e651bfbc9d44b9fa0409b896de55" translate="yes" xml:space="preserve">
          <source>In this example DUT code uses &lt;code&gt;greentea-client&lt;/code&gt; to sync (&lt;code&gt;GREENTEA_SETUP&lt;/code&gt;) with &lt;code&gt;Greentea&lt;/code&gt;. We are not calling &lt;code&gt;GREENTEA_TESTSUITE_RESULT(result)&lt;/code&gt; at any time. In this example host test is responsible for providing test suite result using &lt;code&gt;self.notify_complete()&lt;/code&gt; API or &lt;code&gt;self.result()&lt;/code&gt; function.</source>
          <target state="translated">이 예제에서 DUT 코드는 &lt;code&gt;GREENTEA_SETUP&lt;/code&gt; &lt;code&gt;greentea-client&lt;/code&gt; 를 사용 하여 &lt;code&gt;Greentea&lt;/code&gt; 와 동기화 ( GREENTEA_SETUP ) 합니다. 우리는 언제든지 &lt;code&gt;GREENTEA_TESTSUITE_RESULT(result)&lt;/code&gt; 를 호출하지 않습니다 . 이 예제에서 호스트 테스트는 &lt;code&gt;self.notify_complete()&lt;/code&gt; API 또는 &lt;code&gt;self.result()&lt;/code&gt; 함수를 사용하여 테스트 스위트 결과를 제공 합니다.</target>
        </trans-unit>
        <trans-unit id="b31848376e9effcbed71419f7b28c04b83607698" translate="yes" xml:space="preserve">
          <source>In this phase DUT and host exchange events and host side is calling callbacks registered to each of the events sent from DUT. DUT can use function &lt;code&gt;greentea_parse_kv&lt;/code&gt; to parse input stream for next incoming key-value event.
After &lt;code&gt;__host_test_name&lt;/code&gt; event is received and before any event is consumed during this stage:</source>
          <target state="translated">이 단계에서 DUT와 호스트는 이벤트를 교환하고 호스트 측은 DUT에서 보낸 각 이벤트에 등록 된 콜백을 호출합니다. DUT는 함수 &lt;code&gt;greentea_parse_kv&lt;/code&gt; 를 사용 하여 다음 수신 키-값 이벤트에 대한 입력 스트림을 구문 분석 할 수 있습니다 . 후 &lt;code&gt;__host_test_name&lt;/code&gt; 의 이벤트를 수신하고 이벤트가이 단계에서 소비하기 전에 :</target>
        </trans-unit>
        <trans-unit id="c81b79df3c6448eae7c4f80428b54cd5692a17d7" translate="yes" xml:space="preserve">
          <source>Installation</source>
          <target state="translated">설치</target>
        </trans-unit>
        <trans-unit id="96d0cf4660194fdfbac644302310f6124c5e1dc2" translate="yes" xml:space="preserve">
          <source>Installation from PyPI (Python Package Index)</source>
          <target state="translated">PyPI (Python 패키지 색인)에서 설치</target>
        </trans-unit>
        <trans-unit id="9747b78a5614166db6f72d19c44d36053023a65b" translate="yes" xml:space="preserve">
          <source>Installation from Python sources</source>
          <target state="translated">Python 소스에서 설치</target>
        </trans-unit>
        <trans-unit id="b2c3bab72631634bc46b6364dbc4f51c943c659f" translate="yes" xml:space="preserve">
          <source>Key-value protocol has few parts:</source>
          <target state="translated">키-값 프로토콜은 몇 부분으로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="27a29f226690321a7adcc35c9e87be4bf2958fa8" translate="yes" xml:space="preserve">
          <source>Key-value protocol overview</source>
          <target state="translated">키-값 프로토콜 개요</target>
        </trans-unit>
        <trans-unit id="9f4787c2bc46ac39b36bd0d999ea31fe758ef67e" translate="yes" xml:space="preserve">
          <source>Key-value protocol was developed and is used to provide communication layer between DUT (device under test) and host computer. Key-value protocol defined host computer as master and DUT as slave.</source>
          <target state="translated">키-값 프로토콜이 개발되어 DUT (테스트 대상 장치)와 호스트 컴퓨터 간의 통신 계층을 제공하는 데 사용됩니다. 키-값 프로토콜은 호스트 컴퓨터를 마스터로, DUT를 슬레이브로 정의했습니다.</target>
        </trans-unit>
        <trans-unit id="aee26d71d33f8e98d4348ce4b5d1fd38f36b844f" translate="yes" xml:space="preserve">
          <source>Key-value transport protocol sequence</source>
          <target state="translated">키-값 전송 프로토콜 시퀀스</target>
        </trans-unit>
        <trans-unit id="7b221d84e0b3a674576d782dcc4a3da4d47eb44b" translate="yes" xml:space="preserve">
          <source>List available host tests names, class names and origin. Load additional host tests from &lt;code&gt;/path/to/host_tests&lt;/code&gt; directory:</source>
          <target state="translated">사용 가능한 호스트 테스트 이름, 클래스 이름 및 출처를 나열합니다. &lt;code&gt;/path/to/host_tests&lt;/code&gt; 디렉토리 에서 추가 호스트 테스트를로드합니다 .</target>
        </trans-unit>
        <trans-unit id="65fd4496f6282d1f960f65ea054818b571949787" translate="yes" xml:space="preserve">
          <source>List available host tests names, class names and origin:</source>
          <target state="translated">사용 가능한 호스트 테스트 이름, 클래스 이름 및 출처를 나열합니다.</target>
        </trans-unit>
        <trans-unit id="4270d9653f4f515b60eb7efd3a15a804baf85388" translate="yes" xml:space="preserve">
          <source>List available reset and flashing plugins:</source>
          <target state="translated">사용 가능한 재설정 및 플래싱 플러그인 나열 :</target>
        </trans-unit>
        <trans-unit id="afc2315b560e12839c119c3f35d4f206ec9aad28" translate="yes" xml:space="preserve">
          <source>Load local file &lt;code&gt;/path/to/file/binary.elf&lt;/code&gt; to onto fastmodel FVP_MPS2_m3 simulators:</source>
          <target state="translated">로컬 파일 &lt;code&gt;/path/to/file/binary.elf&lt;/code&gt; 를 fastmodel FVP_MPS2_m3 시뮬레이터에 로드합니다 .</target>
        </trans-unit>
        <trans-unit id="bd4905fd40b41fca6db2a780b2c9ed141892071d" translate="yes" xml:space="preserve">
          <source>Log example</source>
          <target state="translated">로그 예</target>
        </trans-unit>
        <trans-unit id="2392938c8b5602a02f802b8eac39fc88539d91dd" translate="yes" xml:space="preserve">
          <source>Log:</source>
          <target state="translated">로그:</target>
        </trans-unit>
        <trans-unit id="e4ba102e09e1016bb3bb75852b1bd476a9a61a81" translate="yes" xml:space="preserve">
          <source>Logged from &lt;code&gt;CONN&lt;/code&gt; (connection process).</source>
          <target state="translated">&lt;code&gt;CONN&lt;/code&gt; (연결 프로세스) 에서 기록되었습니다 .</target>
        </trans-unit>
        <trans-unit id="5dcabc028acea9af83a7332e2b06616cdc6121c3" translate="yes" xml:space="preserve">
          <source>Make decision if test test suite passed / failed / returned error.</source>
          <target state="translated">테스트 테스트 스위트가 통과 / 실패 / 오류를 반환했는지 결정합니다.</target>
        </trans-unit>
        <trans-unit id="ace24de34a0939e0c83d6d1e95c32d478581e3fd" translate="yes" xml:space="preserve">
          <source>Master (host) sends sync packet: &lt;code&gt;{{__sync;UUID-STRING}}}&lt;/code&gt; with message value containing random UUID string.</source>
          <target state="translated">마스터 (호스트)는 임의의 UUID 문자열을 포함하는 메시지 값과 함께 동기화 패킷 &lt;code&gt;{{__sync;UUID-STRING}}}&lt;/code&gt; 을 보냅니다.</target>
        </trans-unit>
        <trans-unit id="defc0329fd55d6e68456c7da61fb13587d2cee7e" translate="yes" xml:space="preserve">
          <source>Master side APIs and key-value protocol is encapsulated in  &lt;code&gt;mbed-host-tests&lt;/code&gt;.</source>
          <target state="translated">마스터 측 API 및 키-값 프로토콜은 &lt;code&gt;mbed-host-tests&lt;/code&gt; 에 캡슐화됩니다 .</target>
        </trans-unit>
        <trans-unit id="277ce5185e727fdbad5c6acd52d3288181ed59f6" translate="yes" xml:space="preserve">
          <source>Master-slave mode where host is master and DUT is slave.</source>
          <target state="translated">호스트가 마스터이고 DUT가 슬레이브 인 마스터-슬레이브 모드.</target>
        </trans-unit>
        <trans-unit id="1dff4f302c44478b0ce255ebb294db458ab7ceea" translate="yes" xml:space="preserve">
          <source>Message parsing transforms key-value string message to Python event in this order:</source>
          <target state="translated">메시지 구문 분석은 키-값 문자열 메시지를 다음 순서로 Python 이벤트로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="5f2cbd107037ed23248e5058a7a64cd6bae05468" translate="yes" xml:space="preserve">
          <source>Miscellaneous</source>
          <target state="translated">여러 가지 잡다한</target>
        </trans-unit>
        <trans-unit id="935dbb023ddce3e788178d70861cfc011089bbc5" translate="yes" xml:space="preserve">
          <source>Monitor serial port traffic to parse valid key-value protocol events.</source>
          <target state="translated">직렬 포트 트래픽을 모니터링하여 유효한 키-값 프로토콜 이벤트를 구문 분석합니다.</target>
        </trans-unit>
        <trans-unit id="3a9a8ab48c1b83362245fe9ad40e41a584f8107c" translate="yes" xml:space="preserve">
          <source>Non-Reserved event/message keys have leading &lt;code&gt;__&lt;/code&gt; in name:</source>
          <target state="translated">예약되지 않은 이벤트 / 메시지 키의 이름 앞에 &lt;code&gt;__&lt;/code&gt; 가 있습니다.</target>
        </trans-unit>
        <trans-unit id="8095b4836091793076a966ca6d394f63a1d2af96" translate="yes" xml:space="preserve">
          <source>Note: If you work in isolation and your test environment if fully controlled by you (for example you queue all tasks calling host tests, or use global host unique socket port numbers) this rule doesn&amp;rsquo;t apply to you.</source>
          <target state="translated">참고 : 사용자가 완전히 제어하는 ​​경우 격리 및 테스트 환경에서 작업하는 경우 (예 : 호스트 테스트를 호출하는 모든 작업을 큐에 넣거나 전역 호스트 고유 소켓 포트 번호를 사용하는 경우)이 규칙이 적용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="47e596b9e7a9a83782a11f12a805ad84ba13967a" translate="yes" xml:space="preserve">
          <source>Now you are ready to install &lt;code&gt;htrun&lt;/code&gt;:</source>
          <target state="translated">이제 &lt;code&gt;htrun&lt;/code&gt; 을 설치할 준비가되었습니다 .</target>
        </trans-unit>
        <trans-unit id="9eb0e6b2b4096bdf396e40cfffe4337cf1757660" translate="yes" xml:space="preserve">
          <source>Opening connection between host computer and DUT,</source>
          <target state="translated">호스트 컴퓨터와 DUT 간의 연결 열기,</target>
        </trans-unit>
        <trans-unit id="6321b81d1f64a69cb83d72ad2a79a36226f06233" translate="yes" xml:space="preserve">
          <source>Option &lt;code&gt;--serial-output-file&lt;/code&gt; takes file name as argument and writes the target serial output to the file. Edit the file to remove lines that will change in successive executions. Put regular expressions if needed at places like benchmark numbers in above log. With these edits you are left with a template good for comparison.</source>
          <target state="translated">옵션 &lt;code&gt;--serial-output-file&lt;/code&gt; 은 파일 이름을 인수로 사용하고 대상 직렬 출력을 파일에 씁니다. 연속 실행에서 변경 될 줄을 제거하려면 파일을 편집하십시오. 필요한 경우 위 로그의 벤치 마크 번호와 같은 위치에 정규식을 넣으십시오. 이러한 편집을 통해 비교하기에 좋은 템플릿이 남습니다.</target>
        </trans-unit>
        <trans-unit id="d0a3e88637b18b51bc10629280f2881e47522630" translate="yes" xml:space="preserve">
          <source>Parsing text received from DUT (line by line)</source>
          <target state="translated">DUT에서받은 텍스트 구문 분석 (한 줄씩)</target>
        </trans-unit>
        <trans-unit id="2b101baf417b3e1f3cb5f9dcc491b7fe9b3cb6a1" translate="yes" xml:space="preserve">
          <source>Please observe above that all the lines that have data that changes from execution to execution (on right) have been removed. It makes it possible htrun to compare these logs. htrun matches lines from the compare log (on left) one by one. It keeps on looking for a line until it matches. Once matched it moves on to match the next line. If it finds all lines from the compare log in the target serial output stream. Then it halts and passes the examples.</source>
          <target state="translated">실행에서 실행으로 변경되는 데이터가있는 모든 행 (오른쪽)이 제거되었음을 위에서 확인하십시오. htrun에서 이러한 로그를 비교할 수 있습니다. htrun은 비교 로그 (왼쪽)의 행을 하나씩 일치시킵니다. 일치 할 때까지 줄을 계속 찾습니다. 일치하면 다음 줄과 일치하도록 이동합니다. 대상 직렬 출력 스트림의 비교 로그에서 모든 행을 찾은 경우. 그런 다음 중지하고 예제를 전달합니다.</target>
        </trans-unit>
        <trans-unit id="ab2e26dd8b8868a3969cb3321e0c983c0d9d67d4" translate="yes" xml:space="preserve">
          <source>Plugins</source>
          <target state="translated">플러그인</target>
        </trans-unit>
        <trans-unit id="5cd9fc3a7d8416186a05c1eef602afb95a9a2640" translate="yes" xml:space="preserve">
          <source>Preamble exchange</source>
          <target state="translated">서문 교환</target>
        </trans-unit>
        <trans-unit id="6de83481025f3d548752a5a0be1d41faa97785e6" translate="yes" xml:space="preserve">
          <source>Protocol introduced is master-slave protocol, where master is host and slave is device under test.</source>
          <target state="translated">도입 된 프로토콜은 마스터-슬레이브 프로토콜이며, 여기서 마스터는 호스트이고 슬레이브는 테스트 대상 장치입니다.</target>
        </trans-unit>
        <trans-unit id="83b2cdb22a433b1804f63b72d0ae37234a7dd681" translate="yes" xml:space="preserve">
          <source>Provide command line tool interface, command: &lt;code&gt;mbedhtrun&lt;/code&gt; after module installation (on host).</source>
          <target state="translated">모듈 설치 후 명령 줄 도구 인터페이스, 명령 : &lt;code&gt;mbedhtrun&lt;/code&gt; 을 제공합니다 (호스트에서).</target>
        </trans-unit>
        <trans-unit id="26d998179c9bb71ad0db255dc0c7601c06595fd3" translate="yes" xml:space="preserve">
          <source>Provide few basic host test implementations which can be used out of the box for test development. For example the basic host test (called &lt;code&gt;default&lt;/code&gt; or &lt;code&gt;default_auto&lt;/code&gt;) just parses events from DUT and finished host test execution when &lt;code&gt;end&lt;/code&gt; event is received. Other included in this module host tests can help you to test timers or RTC.</source>
          <target state="translated">테스트 개발을 위해 즉시 사용할 수있는 몇 가지 기본 호스트 테스트 구현을 제공합니다. 예를 들어 기본 호스트 테스트 ( &lt;code&gt;default&lt;/code&gt; 또는 &lt;code&gt;default_auto&lt;/code&gt; 라고 함 )는 DUT에서 이벤트를 구문 분석하고 &lt;code&gt;end&lt;/code&gt; 이벤트가 수신 되면 호스트 테스트 실행을 완료합니다 . 이 모듈 호스트 테스트에 포함 된 다른 항목은 타이머 또는 RTC를 테스트하는 데 도움이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="067fdaf097fe2f4fa9cab7c1cfd6cf55767ca001" translate="yes" xml:space="preserve">
          <source>Reserved event/message keys have leading &lt;code&gt;__&lt;/code&gt; in name:</source>
          <target state="translated">예약 된 이벤트 / 메시지 키에는 이름에 &lt;code&gt;__&lt;/code&gt; 가 있습니다.</target>
        </trans-unit>
        <trans-unit id="825cd14df7acabb05a94e4445c62d49fcb9bfdc9" translate="yes" xml:space="preserve">
          <source>Reset mbed device after flashing to start test suite execution.</source>
          <target state="translated">테스트 스위트 실행을 시작하려면 깜박 인 후 mbed 장치를 재설정하십시오.</target>
        </trans-unit>
        <trans-unit id="59c74e7780ed5c235fa3625ceb843ea2d8182d8e" translate="yes" xml:space="preserve">
          <source>Result returned from host test is a test suite result. Test cases results are reported by DUT, usually using modified &lt;code&gt;utest&lt;/code&gt; framework.</source>
          <target state="translated">호스트 테스트에서 반환 된 결과는 테스트 스위트 결과입니다. 테스트 케이스 결과는 일반적으로 수정 된 &lt;code&gt;utest&lt;/code&gt; 프레임 워크를 사용하여 DUT에 의해보고됩니다 .</target>
        </trans-unit>
        <trans-unit id="7eb43fac4bae0d97d9b8c2b4f1c7a4531e1501ff" translate="yes" xml:space="preserve">
          <source>Return result after __exit</source>
          <target state="translated">__exit 후 결과 반환</target>
        </trans-unit>
        <trans-unit id="594827c48dee112f581a689b42115759d1c3c8dc" translate="yes" xml:space="preserve">
          <source>Run key-value protocol state machine and execute event callbacks.</source>
          <target state="translated">키-값 프로토콜 상태 시스템을 실행하고 이벤트 콜백을 실행합니다.</target>
        </trans-unit>
        <trans-unit id="28e87a733a5102266279adcaf92bb31b4e8dfa30" translate="yes" xml:space="preserve">
          <source>SARA NBIOT EVK</source>
          <target state="translated">SARA NBIOT EVK</target>
        </trans-unit>
        <trans-unit id="d73bb20965191cea0e2d0700f76a1ca705dd4799" translate="yes" xml:space="preserve">
          <source>Simple key-value protocol is introduced. It is used to communicate between DUT and host. Protocol main features:</source>
          <target state="translated">간단한 키-값 프로토콜이 도입되었습니다. DUT와 호스트 간의 통신에 사용됩니다. 프로토콜 주요 기능 :</target>
        </trans-unit>
        <trans-unit id="06cc574fa4d7414bcd447ee8fce507719ead92d8" translate="yes" xml:space="preserve">
          <source>Skip flashing phase (e.g. you've already flashed this device with &lt;code&gt;/path/to/file/binary.bin&lt;/code&gt; binary). Use serial port &lt;code&gt;COM4&lt;/code&gt; to communicate with DUT:</source>
          <target state="translated">플래싱 단계를 건너 뜁니다 (예 : 이미이 장치를 &lt;code&gt;/path/to/file/binary.bin&lt;/code&gt; 바이너리로 플래싱했습니다 ). 직렬 포트 &lt;code&gt;COM4&lt;/code&gt; 를 사용 하여 DUT와 통신합니다.</target>
        </trans-unit>
        <trans-unit id="4df361bbe32ced8a6f9e97b5ebddb8461b1bd534" translate="yes" xml:space="preserve">
          <source>Slave side APIs and key-value protocol implementation is encapsulated in &lt;a href=&quot;https://github.com/ARMmbed/mbed-os/tree/master/features/frameworks/greentea-client&quot;&gt;greentea-client&lt;/a&gt; module.</source>
          <target state="translated">슬레이브 측 API 및 키-값 프로토콜 구현은 &lt;a href=&quot;https://github.com/ARMmbed/mbed-os/tree/master/features/frameworks/greentea-client&quot;&gt;greentea-client&lt;/a&gt; 모듈에 캡슐화됩니다 .</target>
        </trans-unit>
        <trans-unit id="e70c5705c8542d7e86f593c06d9341c8d2b28434" translate="yes" xml:space="preserve">
          <source>Slave side key-value protocol API, see &lt;a href=&quot;https://github.com/ARMmbed/mbed-os/blob/master/features/frameworks/greentea-client/greentea-client/test_env.h&quot;&gt;here&lt;/a&gt; for details.</source>
          <target state="translated">슬레이브 측 키-값 프로토콜 API, 자세한 내용은 &lt;a href=&quot;https://github.com/ARMmbed/mbed-os/blob/master/features/frameworks/greentea-client/greentea-client/test_env.h&quot;&gt;여기&lt;/a&gt; 를 참조 하세요 .</target>
        </trans-unit>
        <trans-unit id="aa6ff5371ac33c3951672e8ff547398ae9695810" translate="yes" xml:space="preserve">
          <source>Templated log simply means a log with text that does not change or regular expressions replacing original text. Below is an example of the templated log:</source>
          <target state="translated">템플릿 로그는 단순히 텍스트가 변경되지 않거나 원본 텍스트를 대체하는 정규 표현식이있는 로그를 의미합니다. 다음은 템플릿 로그의 예입니다.</target>
        </trans-unit>
        <trans-unit id="eb391cb90069057c99db0fe99cf4552916bab489" translate="yes" xml:space="preserve">
          <source>Test execution phase will consist of:</source>
          <target state="translated">테스트 실행 단계는 다음으로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="83e3b70840fadf5bea17a0e24aef786b3d0ffc67" translate="yes" xml:space="preserve">
          <source>Test suite is implemented so that it will never exit / finish its execution. For example &lt;code&gt;main()&lt;/code&gt; or &lt;code&gt;app_start()&lt;/code&gt; functions are implemented using infinite (endless) loop. This property have for example UDP/TCP servers (listening forever), all sorts of echo servers etc.</source>
          <target state="translated">테스트 스위트는 실행을 종료 / 완료하지 않도록 구현됩니다. 예를 들어 &lt;code&gt;main()&lt;/code&gt; 또는 &lt;code&gt;app_start()&lt;/code&gt; 함수는 무한 (무한) 루프를 사용하여 구현됩니다. 이 속성에는 예를 들어 UDP / TCP 서버 (영원히 듣기), 모든 종류의 에코 서버 등이 있습니다.</target>
        </trans-unit>
        <trans-unit id="594012e05268bdd744c42186997dd5ea17a93ab5" translate="yes" xml:space="preserve">
          <source>Testing mbed-os examples</source>
          <target state="translated">mbed-os 예제 테스트</target>
        </trans-unit>
        <trans-unit id="e0519cea3ce164f13b54a2744defb9155e41b935" translate="yes" xml:space="preserve">
          <source>Text based protocol, format &lt;code&gt;{{KEY;VALUE}}}&lt;/code&gt;.</source>
          <target state="translated">텍스트 기반 프로토콜, 형식 &lt;code&gt;{{KEY;VALUE}}}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="870b045bf88b413a3138f7d28f1fad5077b089f8" translate="yes" xml:space="preserve">
          <source>The &quot;--fm&quot; option only available when &lt;a href=&quot;https://github.com/ARMmbed/mbed-fastmodel-agent&quot;&gt;mbed-fastmodel-agent&lt;/a&gt; module is installed :</source>
          <target state="translated">&quot;--fm&quot;옵션은 &lt;a href=&quot;https://github.com/ARMmbed/mbed-fastmodel-agent&quot;&gt;mbed-fastmodel-agent&lt;/a&gt; 모듈이 설치된 경우에만 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="85c890bac201b9058908fec1463a1d2a9cb01d34" translate="yes" xml:space="preserve">
          <source>The SARA NBIOT EVK board must be connected to a Windows PC using a Segger JLink box, which is used for downloading code and resetting the board. The USB port on the EVK must also be connected to the same PC.  To make use of these hooks you will also require access to some proprietary tools that can be requested from u-blox.</source>
          <target state="translated">SARA NBIOT EVK 보드는 코드 다운로드 및 보드 재설정에 사용되는 Segger JLink 박스를 사용하여 Windows PC에 연결되어야합니다. EVK의 USB 포트도 동일한 PC에 연결해야합니다. 이러한 후크를 사용하려면 u-blox에서 요청할 수있는 일부 독점 도구에 대한 액세스 권한도 필요합니다.</target>
        </trans-unit>
        <trans-unit id="a1d3614cfb60cf469b630755b7dafb4e3fd4e715" translate="yes" xml:space="preserve">
          <source>The development of Htrun has been moved into the &lt;a href=&quot;../../src/mbed_os_tools&quot;&gt;mbed-os-tools&lt;/a&gt; package. You can continue to use this module for legacy reasons, however all further development should be continued in the new package.</source>
          <target state="translated">Htrun의 개발은 mbed &lt;a href=&quot;../../src/mbed_os_tools&quot;&gt;-os-tools&lt;/a&gt; 패키지 로 이동되었습니다 . 레거시 이유로이 모듈을 계속 사용할 수 있지만 모든 추가 개발은 새 패키지에서 계속되어야합니다.</target>
        </trans-unit>
        <trans-unit id="6fce2d6a602e17341d42158c18479a0c7fde13f6" translate="yes" xml:space="preserve">
          <source>This chapter will present few examples of how you can use &lt;code&gt;mbedhtrun&lt;/code&gt; command line to execute tests. In most cases test automation tools such as &lt;a href=&quot;https://github.com/ARMmbed/greentea&quot;&gt;Greentea&lt;/a&gt; will execute &lt;code&gt;mbedhtrun&lt;/code&gt; implicitly. There are cases when we want to execute &lt;code&gt;mbedhtrun&lt;/code&gt; independently. Mostly in situation when we want to:</source>
          <target state="translated">이 장에서는 &lt;code&gt;mbedhtrun&lt;/code&gt; 명령 줄을 사용하여 테스트를 실행 하는 방법에 대한 몇 가지 예를 제공합니다 . 대부분의 경우 &lt;a href=&quot;https://github.com/ARMmbed/greentea&quot;&gt;Greentea&lt;/a&gt; 와 같은 테스트 자동화 도구 는 &lt;code&gt;mbedhtrun&lt;/code&gt; 을 암시 적으로 실행 합니다. &lt;code&gt;mbedhtrun&lt;/code&gt; 을 독립적 으로 실행하려는 경우가 있습니다 . 주로 우리가 원하는 상황에서 :</target>
        </trans-unit>
        <trans-unit id="25cfa2b01075915c44d77b45ca4c742f78dd7e79" translate="yes" xml:space="preserve">
          <source>This function should replace &lt;code&gt;scanf()&lt;/code&gt; used to check for incoming messages from master.
Function parses input and if key-value message is found load to &lt;code&gt;out_key&lt;/code&gt;, &lt;code&gt;out_value&lt;/code&gt; key-value pair. Use &lt;code&gt;out_key_size&lt;/code&gt; and &lt;code&gt;out_value_size&lt;/code&gt; to define out buffers max size (including trailing zero).</source>
          <target state="translated">이 함수는 master에서 들어오는 메시지를 확인하는 데 사용되는 &lt;code&gt;scanf()&lt;/code&gt; 대체해야합니다 . 함수는 입력을 구문 분석하고 키-값 메시지가 발견되면 &lt;code&gt;out_key&lt;/code&gt; , &lt;code&gt;out_value&lt;/code&gt; 키-값 쌍에 로드합니다 . 사용 &lt;code&gt;out_key_size&lt;/code&gt; 및 &lt;code&gt;out_value_size&lt;/code&gt; 버퍼를 (끝에 0) 최대 크기를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="65299901239874a6cb949a2e51f51f4fbb5a9775" translate="yes" xml:space="preserve">
          <source>This option is designed for htrun to use Arm Fast Models.</source>
          <target state="translated">이 옵션은 htrun이 Arm Fast 모델을 사용하도록 설계되었습니다.</target>
        </trans-unit>
        <trans-unit id="44e2532f0cb63fd8184a45f5dee53bd8b75b0c12" translate="yes" xml:space="preserve">
          <source>This phase comes just after handshake phase. DUT informs host about test parameters such as client version, timeout, requested host test name etc. After this part is finished master will create requested host test and attach callbacks to user events.
This phase is ended with &lt;code&gt;__host_test_name&lt;/code&gt; being received by host. After &lt;code&gt;__host_test_name&lt;/code&gt; event is received</source>
          <target state="translated">이 단계는 핸드 셰이크 단계 직후에 발생합니다. DUT는 클라이언트 버전, 시간 초과, 요청 된 호스트 테스트 이름 등과 같은 테스트 매개 변수에 대해 호스트에 알립니다.이 부분이 완료되면 마스터는 요청 된 호스트 테스트를 생성하고 사용자 이벤트에 콜백을 첨부합니다. 이 단계는 호스트 가 &lt;code&gt;__host_test_name&lt;/code&gt; 을 수신 하면서 종료됩니다 . &lt;code&gt;__host_test_name&lt;/code&gt; 이벤트 수신 후</target>
        </trans-unit>
        <trans-unit id="87ffd053a24a9a4cd443eaef85db7c0d348b406b" translate="yes" xml:space="preserve">
          <source>Time stamp: &lt;code&gt;2016-02-11 19:53:27&lt;/code&gt;, see below:</source>
          <target state="translated">타임 스탬프 : &lt;code&gt;2016-02-11 19:53:27&lt;/code&gt; , 아래 참조 :</target>
        </trans-unit>
        <trans-unit id="4af2c9ff1813d587766abee9f7ec0510e0469717" translate="yes" xml:space="preserve">
          <source>To avoid miscommunication between master and slave simple handshake protocol is introduces:</source>
          <target state="translated">마스터와 슬레이브 간의 통신 오류를 방지하기 위해 간단한 핸드 셰이크 프로토콜이 도입되었습니다.</target>
        </trans-unit>
        <trans-unit id="cf2dc67e3be0bab3e7a0cc8e1a40911892791049" translate="yes" xml:space="preserve">
          <source>To capture a log use following option:</source>
          <target state="translated">로그를 캡처하려면 다음 옵션을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="82291530bb70e06584cb774caa50c878ef17f36b" translate="yes" xml:space="preserve">
          <source>To check whether the installation was successful try running the &lt;code&gt;mbedgt --help&lt;/code&gt; command and check that it returns information (you may need to restart your terminal first):</source>
          <target state="translated">성공적으로 설치되었는지 확인하려면 &lt;code&gt;mbedgt --help&lt;/code&gt; 명령을 실행하고 정보가 반환 되는지 확인하십시오 (먼저 터미널을 다시 시작해야 할 수도 있음) :</target>
        </trans-unit>
        <trans-unit id="ab53aec5e2dcd07bcd2bff109dfd75ca828a92a6" translate="yes" xml:space="preserve">
          <source>To install mbed-ls from &lt;a href=&quot;https://pypi.python.org/pypi/mbed-host-tests&quot;&gt;PyPI&lt;/a&gt; use command:</source>
          <target state="translated">&lt;a href=&quot;https://pypi.python.org/pypi/mbed-host-tests&quot;&gt;PyPI&lt;/a&gt; 에서 mbed-ls를 설치하려면 다음 명령을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="820de9ca27785efb587fcd2b2a418cd80b042a8e" translate="yes" xml:space="preserve">
          <source>To install the mbed test suite, first clone the &lt;code&gt;mbed-os-tools&lt;/code&gt; repository:</source>
          <target state="translated">mbed 테스트 스위트를 설치하려면 먼저 &lt;code&gt;mbed-os-tools&lt;/code&gt; 저장소를 복제하십시오 .</target>
        </trans-unit>
        <trans-unit id="b03cb0e400fb841ec31aad1884efb8674d590f0e" translate="yes" xml:space="preserve">
          <source>Transport layer consist of simple &lt;code&gt;{{ KEY ; VALUE }} \n&lt;/code&gt; text messages sent by slave (DUT). Both key and value are strings with allowed character set limitations (to simplify parsing and protocol parser itself). Message ends with required by DUT K-V parser &lt;code&gt;\n&lt;/code&gt; character.</source>
          <target state="translated">전송 계층은 단순한 &lt;code&gt;{{ KEY ; VALUE }} \n&lt;/code&gt; 슬레이브 (DUT)에서 보낸 문자 메시지입니다. 키와 값은 모두 허용되는 문자 집합 제한이있는 문자열입니다 (파싱 및 프로토콜 파서 자체를 단순화하기 위해). 메시지는 DUT KV 구문 분석기에 필요한 &lt;code&gt;\n&lt;/code&gt; 문자로 끝납니다 .</target>
        </trans-unit>
        <trans-unit id="70fd40f266f853f835d86fc1d1b7cad7ea02d3f9" translate="yes" xml:space="preserve">
          <source>Use following command to test the example and the comparison log:</source>
          <target state="translated">다음 명령을 사용하여 예제와 비교 ​​로그를 테스트하십시오.</target>
        </trans-unit>
        <trans-unit id="334d09ec6a6d9108ec4a6116afbeec4c31b8b481" translate="yes" xml:space="preserve">
          <source>Use key-value protocol to handshake with device and make sure correct host test script is executed to supervise test suite execution.</source>
          <target state="translated">키-값 프로토콜을 사용하여 기기와 핸드 셰이크하고 테스트 스위트 실행을 감독하기 위해 올바른 호스트 테스트 스크립트가 실행되는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="e1bd0c9c0eeddbe79b76d282f89baa5e70f98f49" translate="yes" xml:space="preserve">
          <source>Useful command line end-to-end examples</source>
          <target state="translated">유용한 명령 줄 종단 간 예제</target>
        </trans-unit>
        <trans-unit id="979177c3f7c9f6589829903f8006c1110617023c" translate="yes" xml:space="preserve">
          <source>User can't register callbacks to &quot;system events&quot; with few exceptions.</source>
          <target state="translated">사용자는 몇 가지 예외를 제외하고 &quot;시스템 이벤트&quot;에 대한 콜백을 등록 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="d7f65ec270b5858ddcb0ea43a171f75c69a50de3" translate="yes" xml:space="preserve">
          <source>Using __rdx_line event</source>
          <target state="translated">__rdx_line 이벤트 사용</target>
        </trans-unit>
        <trans-unit id="36b9d36e832107c9ae2570465ca25bcbd5a3dd97" translate="yes" xml:space="preserve">
          <source>We can use few methods to structure out test suite and test cases. Simpliest would be to use &lt;code&gt;greentea-client&lt;/code&gt; API and wrap one test case inside out test suite. This way of creating test suite is useful when you want to:</source>
          <target state="translated">테스트 스위트와 테스트 케이스를 구조화하기 위해 몇 가지 방법을 사용할 수 있습니다. 가장 간단한 방법은 greentea &lt;code&gt;greentea-client&lt;/code&gt; API 를 사용 하고 하나의 테스트 케이스를 테스트 스위트로 감싸는 것입니다. 이 테스트 스위트 생성 방법은 다음과 같은 경우에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="9fc54ec0002c9b3a7dc3a343aa736d8a5a416316" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;__sync&lt;/code&gt; packet is parsed in the stream DUT sends back (echoes) &lt;code&gt;__sync&lt;/code&gt; event with the same &lt;a href=&quot;https://en.wikipedia.org/wiki/Universally_unique_identifier#Version_3_.28MD5_hash_.26_namespace.29&quot;&gt;UUID&lt;/a&gt; as payload. UUID is a random value e.g.  &lt;code&gt;5f8dbbd2-199a-449c-b286-343a57da7a37&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;__sync&lt;/code&gt; 패킷이 스트림에서 구문 분석 되면 DUT는 페이로드 와 동일한 &lt;a href=&quot;https://en.wikipedia.org/wiki/Universally_unique_identifier#Version_3_.28MD5_hash_.26_namespace.29&quot;&gt;UUID&lt;/a&gt; 를 사용하여 &lt;code&gt;__sync&lt;/code&gt; 이벤트를 다시 보냅니다 (반향) . UUID는 임의의 값입니다 (예 : &lt;code&gt;5f8dbbd2-199a-449c-b286-343a57da7a37&lt;/code&gt; ) .</target>
        </trans-unit>
        <trans-unit id="2f341882dc398289385b72f5e1d586c00508a549" translate="yes" xml:space="preserve">
          <source>When writing a new host test for your module please bear in mind that:</source>
          <target state="translated">모듈에 대한 새 호스트 테스트를 작성할 때 다음 사항에 유의하십시오.</target>
        </trans-unit>
        <trans-unit id="d09112b342b1d638b05c2a329147d91b17294862" translate="yes" xml:space="preserve">
          <source>When writing host test using OS resources such as sockets, files, serial ports, peripheral devices like for example multi-meters / scopes. remember that those resources are indivisible!</source>
          <target state="translated">소켓, 파일, 직렬 포트, 멀티 미터 / 스코프와 같은 주변 장치와 같은 OS 리소스를 사용하여 호스트 테스트를 작성할 때. 그 자원은 나눌 수 없다는 것을 기억하십시오!</target>
        </trans-unit>
        <trans-unit id="890f3875b8b3d9fcc39b709891847f99bce284ee" translate="yes" xml:space="preserve">
          <source>Writing DUT test suite (slave side)</source>
          <target state="translated">DUT 테스트 스위트 작성 (슬레이브 측)</target>
        </trans-unit>
        <trans-unit id="21e2e206cbdc9151364078fceb1dfe895ed9b4d2" translate="yes" xml:space="preserve">
          <source>Writing host tests (master side)</source>
          <target state="translated">호스트 테스트 작성 (마스터 측)</target>
        </trans-unit>
        <trans-unit id="b71b200d5a694f60a42059425701583d39b0e89e" translate="yes" xml:space="preserve">
          <source>You can register callbacks in &lt;code&gt;setup()&lt;/code&gt; phase or decorate callback functions using &lt;code&gt;@event_callback&lt;/code&gt; decorator.</source>
          <target state="translated">&lt;code&gt;setup()&lt;/code&gt; 단계 에서 콜백을 등록 하거나 &lt;code&gt;@event_callback&lt;/code&gt; 데코레이터를 사용하여 콜백 함수를 데코레이션 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0796fb65c6f1d0d01f20cd07e52afc4c962187db" translate="yes" xml:space="preserve">
          <source>You need to place your custom host test in &lt;code&gt;&amp;lt;module&amp;gt;/test/host_tests&lt;/code&gt; directory.</source>
          <target state="translated">사용자 지정 호스트 테스트를 &lt;code&gt;&amp;lt;module&amp;gt;/test/host_tests&lt;/code&gt; 디렉터리 에 배치해야합니다 .</target>
        </trans-unit>
        <trans-unit id="329e432f66c96948efd63ceddf05f381ac23e2af" translate="yes" xml:space="preserve">
          <source>You need to write and specify by name your custom host test:</source>
          <target state="translated">커스텀 호스트 테스트를 작성하고 이름으로 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="d086cfdf9e616756e97771786e29c764137f85f5" translate="yes" xml:space="preserve">
          <source>You own the host test and you should write it the way so it can coexist with the same host tests ran by other processes such as Continuous Integration systems or other host users.</source>
          <target state="translated">호스트 테스트를 소유하고 지속적 통합 시스템이나 다른 호스트 사용자와 같은 다른 프로세스에서 실행 한 동일한 호스트 테스트와 공존 할 수 있도록 작성해야합니다.</target>
        </trans-unit>
        <trans-unit id="2f248e4c7bc213c0e1d04f3156433841516876eb" translate="yes" xml:space="preserve">
          <source>calls immediately &lt;code&gt;greentea_parse_kv&lt;/code&gt; (blocking parse of input serial port for event &lt;code&gt;{{__sync;UUID}}&lt;/code&gt;).</source>
          <target state="translated">즉시 호출 &lt;code&gt;greentea_parse_kv&lt;/code&gt; (이벤트 입력 직렬 포트 파싱 차단 &lt;code&gt;{{__sync;UUID}}&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="58a78d6d31f54b4406d541d02584f0cf73d3de31" translate="yes" xml:space="preserve">
          <source>debug our code and have binary + host test instrumentation on,</source>
          <target state="translated">코드를 디버그하고 바이너리 + 호스트 테스트 도구를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="4a0d7154d60bc6a4a8440a6c5fd4b6c5c8cad825" translate="yes" xml:space="preserve">
          <source>device reset and</source>
          <target state="translated">장치 재설정 및</target>
        </trans-unit>
        <trans-unit id="0ae41492d3c7b24fb4ca6e6e797730f9f461f714" translate="yes" xml:space="preserve">
          <source>driving test binary flashing,</source>
          <target state="translated">운전 시험 바이너리 점멸,</target>
        </trans-unit>
        <trans-unit id="924e021d80ca878162edcc13bd21682f4723012d" translate="yes" xml:space="preserve">
          <source>just want to replace test runner in another OS with one compatible with mbed-enabled devices.</source>
          <target state="translated">다른 OS의 테스트 러너를 mbed 지원 장치와 호환되는 것으로 교체하고 싶습니다.</target>
        </trans-unit>
        <trans-unit id="051785d5a53040a76f3a795c9fdbe3a2b7c1ba4d" translate="yes" xml:space="preserve">
          <source>key-value data becomes a recognizable message with key (string) and value (string) payload.</source>
          <target state="translated">키-값 데이터는 키 (문자열) 및 값 (문자열) 페이로드와 함께 인식 가능한 메시지가됩니다.</target>
        </trans-unit>
        <trans-unit id="2d8a18bd8189a1ef27e733539fdea3a301fa251c" translate="yes" xml:space="preserve">
          <source>make example application (example as a test) or</source>
          <target state="translated">예제 응용 프로그램 만들기 (테스트 용 예제) 또는</target>
        </trans-unit>
        <trans-unit id="d521450035bfa4fa670a2d66f41a8c7ef4020fda" translate="yes" xml:space="preserve">
          <source>mbed tools used to flash, reset and supervise test execution for mbed-enabled devices</source>
          <target state="translated">mbed 지원 장치의 테스트 실행을 플래시, 재설정 및 감독하는 데 사용되는 mbed 도구</target>
        </trans-unit>
        <trans-unit id="c7dca3c11ec8a5b089c578680afaf92dd9f71663" translate="yes" xml:space="preserve">
          <source>mbed's test suite (codenamed &lt;code&gt;Greentea&lt;/code&gt;) supports the &lt;em&gt;test supervisor&lt;/em&gt; concept. This concept is realized by this module. &lt;code&gt;mbed-host-tests&lt;/code&gt; is a collection of host tests. Host test is script written in Python, which is executed in parallel with the test suite runner (a binary running on the target hardware / device under test) to monitor the test execution's progress or to control the test flow (interaction with the mbed device under test - DUT). The host test is also responsible for grabbing the test result, or deducing it from the test runner's behavior.</source>
          <target state="translated">mbed의 테스트 스위트 (코드 명 &lt;code&gt;Greentea&lt;/code&gt; )는 &lt;em&gt;테스트 감독자&lt;/em&gt; 개념을 지원합니다 . 이 개념은이 모듈에 의해 실현됩니다. &lt;code&gt;mbed-host-tests&lt;/code&gt; 는 호스트 테스트 모음입니다. 호스트 테스트는 테스트 실행의 진행 상황을 모니터링하거나 테스트 흐름을 제어하기 위해 테스트 스위트 실행기 (대상 하드웨어 / 테스트 대상 장치에서 실행되는 바이너리)와 병렬로 실행되는 Python으로 작성된 스크립트입니다. 테스트-DUT). 호스트 테스트는 테스트 결과를 가져 오거나 테스트 실행기의 동작에서 추론하는 역할도합니다.</target>
        </trans-unit>
        <trans-unit id="d24be69745afbb12c8b0d04eab75845575a8791d" translate="yes" xml:space="preserve">
          <source>mbed-host-tests</source>
          <target state="translated">mbed 호스트 테스트</target>
        </trans-unit>
        <trans-unit id="9a2f25d66a9f94f62ac0a0c7361a1064add6b06f" translate="yes" xml:space="preserve">
          <source>mbed-os examples are essentially sample apps written as inspirational code for developers to understand the mbed-os APIs and coding paradigms. Before every mbed-os release all examples are tested across all supported configs and platforms. There is already a large set examples available and as they grow it is important to automate them. Hence automating examples make sense. Although it is important not to pollute them with test like instrumentation. As that will defeat the purpose of examples being simple and specific.</source>
          <target state="translated">mbed-os 예제는 기본적으로 개발자가 mbed-os API 및 코딩 패러다임을 이해할 수 있도록 영감을주는 코드로 작성된 샘플 앱입니다. 모든 mbed-os 릴리스 전에 모든 예제는 지원되는 모든 구성 및 플랫폼에서 테스트됩니다. 이미 큰 세트의 예제를 사용할 수 있으며 성장함에 따라 자동화하는 것이 중요합니다. 따라서 자동화 예제가 의미가 있습니다. 기기와 같은 테스트로 오염시키지 않는 것이 중요하지만. 그것은 단순하고 구체적인 예의 목적을 무너 뜨릴 것입니다.</target>
        </trans-unit>
        <trans-unit id="f6c5a3ffbcae54629b163af76fe38d26150e50f4" translate="yes" xml:space="preserve">
          <source>preferred host test script (Python script which is used to supervise/instrument test execution),</source>
          <target state="translated">기본 호스트 테스트 스크립트 (테스트 실행을 감독 / 계측하는 데 사용되는 Python 스크립트),</target>
        </trans-unit>
        <trans-unit id="0152edce00462ac4cc087f3acc4250a2fe8763ec" translate="yes" xml:space="preserve">
          <source>prototype or</source>
          <target state="translated">프로토 타입 또는</target>
        </trans-unit>
        <trans-unit id="4c478d8822658f18e996b8d7fcfafadff0859ea5" translate="yes" xml:space="preserve">
          <source>test environment version,</source>
          <target state="translated">테스트 환경 버전,</target>
        </trans-unit>
        <trans-unit id="dde8714ae7facacf6c0b129f3ca63306b4a73d03" translate="yes" xml:space="preserve">
          <source>test execution.</source>
          <target state="translated">테스트 실행.</target>
        </trans-unit>
        <trans-unit id="3ca732331b49aa9581fbadd09382dba22ed19286" translate="yes" xml:space="preserve">
          <source>test timeout,</source>
          <target state="translated">테스트 시간 초과,</target>
        </trans-unit>
        <trans-unit id="f08278b6533f3536f5ef21e38149813caa1d07be" translate="yes" xml:space="preserve">
          <source>when your test suite is calling blocking forever function. For example all types of UDP/TCP servers which run in forever loop are in this category. In this case we do not expect from DUT &lt;code&gt;__exit&lt;/code&gt; event at all and host test should be designed in such a way that it always return result.</source>
          <target state="translated">테스트 스위트가 영원히 차단 기능을 호출 할 때. 예를 들어 영원히 루프에서 실행되는 모든 유형의 UDP / TCP 서버가이 범주에 속합니다. 이 경우 우리는 DUT &lt;code&gt;__exit&lt;/code&gt; 이벤트에서 전혀 기대하지 않으며 호스트 테스트는 항상 결과를 반환하는 방식으로 설계되어야합니다.</target>
        </trans-unit>
        <trans-unit id="cebce5c7c70edab2f7eb6dc6175ab54cb19eec96" translate="yes" xml:space="preserve">
          <source>write only one test case inside test suite,</source>
          <target state="translated">테스트 스위트 내에 하나의 테스트 케이스 만 작성하고,</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
