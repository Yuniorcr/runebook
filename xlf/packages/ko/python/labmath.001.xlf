<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://pypi.org/project/labmath/">
    <body>
      <group id="labmath">
        <trans-unit id="caf3ec883a47c1cd0ab34dc47256cfe1cd3e2fe9" translate="yes" xml:space="preserve">
          <source>! #</source>
          <target state="translated">! #</target>
        </trans-unit>
        <trans-unit id="4f07ec77c6cfa319b977c01bbbdae34d7e544a62" translate="yes" xml:space="preserve">
          <source>&amp;equiv; 0 (mod</source>
          <target state="translated">&amp;equiv; 0 (모드</target>
        </trans-unit>
        <trans-unit id="048d14889f8490b4d08978e698d471ef807b524b" translate="yes" xml:space="preserve">
          <source>&amp;gt; 0 is a nonsquare, and</source>
          <target state="translated">&amp;gt; 0은 비 정사각형이고</target>
        </trans-unit>
        <trans-unit id="f36894891c982490cf1360710c66648e07f52450" translate="yes" xml:space="preserve">
          <source>&amp;gt; 0: We check whether</source>
          <target state="translated">&amp;gt; 0 : 우리는</target>
        </trans-unit>
        <trans-unit id="2184221da3c9b9bdfcb3ddfd28733b001fde0cf0" translate="yes" xml:space="preserve">
          <source>&amp;gt; 100 or so.  We divide by</source>
          <target state="translated">&amp;gt; 100 개 정도. 우리는</target>
        </trans-unit>
        <trans-unit id="b53afd3ceb21f16bad6f4181621e0ac17d24b8ad" translate="yes" xml:space="preserve">
          <source>&amp;gt; 214 and a fully-factored integer &lt;em&gt;F&lt;/em&gt; such that &lt;em&gt;F&lt;/em&gt; divides</source>
          <target state="translated">&amp;gt; 214 및 정수 완전 반영 &lt;em&gt;F&lt;/em&gt; 되도록 &lt;em&gt;F의&lt;/em&gt; 분할</target>
        </trans-unit>
        <trans-unit id="1d9388e0d7df743210d405bec135e1efbb8ddd8b" translate="yes" xml:space="preserve">
          <source>&amp;lt; 0, then</source>
          <target state="translated">&amp;lt;0, 다음</target>
        </trans-unit>
        <trans-unit id="dbd04e1423a5593fff25c479197555fcf77cf3cf" translate="yes" xml:space="preserve">
          <source>&amp;lt; 2, then</source>
          <target state="translated">&amp;lt;2, 다음</target>
        </trans-unit>
        <trans-unit id="383f134e05f2a4eb1c9f02511f76241f497dabd8" translate="yes" xml:space="preserve">
          <source>&amp;middot;</source>
          <target state="translated">&amp;middot;</target>
        </trans-unit>
        <trans-unit id="568ce8561958384873f369b3f2e591f5f98c8464" translate="yes" xml:space="preserve">
          <source>&amp;middot; &lt;em&gt;y&lt;/em&gt;&lt;sup&gt;2&lt;/sup&gt; =</source>
          <target state="translated">&amp;middot; &lt;em&gt;y &lt;/em&gt;&lt;sup&gt;2&lt;/sup&gt; =</target>
        </trans-unit>
        <trans-unit id="92e8881f1c8e6b5ca69c5aaaffd617dd1a309927" translate="yes" xml:space="preserve">
          <source>&amp;middot; &lt;em&gt;y&lt;/em&gt;&lt;sup&gt;2&lt;/sup&gt; = 1.</source>
          <target state="translated">&amp;middot; &lt;em&gt;y &lt;/em&gt;&lt;sup&gt;2&lt;/sup&gt; = 1.</target>
        </trans-unit>
        <trans-unit id="b741186b74876f84db8c804af59332cc3291fa7a" translate="yes" xml:space="preserve">
          <source>&amp;middot; &lt;em&gt;y&lt;/em&gt;&lt;sup&gt;2&lt;/sup&gt; = 1.  We use some optimizations specific to this case of the Pell equation that makes this more efficient than calling</source>
          <target state="translated">&amp;middot; &lt;em&gt;y &lt;/em&gt;&lt;sup&gt;2&lt;/sup&gt; = 1. 호출하는 것보다 더 효율적으로 만드는 Pell 방정식의 경우에 특정한 최적화를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="6e8a6db25e42c8c4df02595ffe6820cdcdea7dd4" translate="yes" xml:space="preserve">
          <source>&amp;middot; &lt;em&gt;y&lt;/em&gt;&lt;sup&gt;2&lt;/sup&gt;.  (0,0) is always a solution.</source>
          <target state="translated">&amp;middot; &lt;em&gt;y &lt;/em&gt;&lt;sup&gt;2&lt;/sup&gt; . (0,0)은 항상 솔루션입니다.</target>
        </trans-unit>
        <trans-unit id="3ab3dd7d16cfef73fb2e61f28f40699e19c4791c" translate="yes" xml:space="preserve">
          <source>&amp;middot; U&lt;sub&gt;n-1&lt;/sub&gt; -</source>
          <target state="translated">&amp;middot; U &lt;sub&gt;N-1&lt;/sub&gt; -</target>
        </trans-unit>
        <trans-unit id="4faddae56e1c823ae0a15d49ddaac8d1571a2a83" translate="yes" xml:space="preserve">
          <source>&amp;middot; U&lt;sub&gt;n-2&lt;/sub&gt;</source>
          <target state="translated">&amp;middot; U &lt;sub&gt;n-2&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="f25dc5f49acad9097bb0b21ceb581d1f48e8b7f0" translate="yes" xml:space="preserve">
          <source>&amp;middot; V&lt;sub&gt;n-1&lt;/sub&gt; -</source>
          <target state="translated">&amp;middot; V &lt;sub&gt;N-1&lt;/sub&gt; -</target>
        </trans-unit>
        <trans-unit id="12a81352f8f9c7c3529728549d88e6a5039a225f" translate="yes" xml:space="preserve">
          <source>&amp;middot; V&lt;sub&gt;n-2&lt;/sub&gt;</source>
          <target state="translated">&amp;middot; V &lt;sub&gt;n-2&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="a9cf5bce636d1ecb41a77fa58a411d49d3e6baae" translate="yes" xml:space="preserve">
          <source>&amp;middot; ln(</source>
          <target state="translated">&amp;middot; ln (</target>
        </trans-unit>
        <trans-unit id="2b60ce12ac35015018edd0bc92ebb51fccb069ee" translate="yes" xml:space="preserve">
          <source>&amp;middot; rad(&lt;em&gt;a&lt;/em&gt;&amp;middot;&lt;em&gt;b&lt;/em&gt;&amp;middot;&lt;em&gt;c&lt;/em&gt;)&lt;sup&gt;abc[1]&lt;/sup&gt;.  This enables major speedups.  If</source>
          <target state="translated">&amp;middot; rad ( &lt;em&gt;a&lt;/em&gt; &amp;middot; &lt;em&gt;b&lt;/em&gt; &amp;middot; &lt;em&gt;c&lt;/em&gt; ) &lt;sup&gt;abc [1]&lt;/sup&gt; . 이것은 큰 속도 향상을 가능하게합니다. 만약</target>
        </trans-unit>
        <trans-unit id="44f4acd3eb3f017ce2e28ed30370f216bec96653" translate="yes" xml:space="preserve">
          <source>&amp;middot;&lt;em&gt;x&lt;/em&gt; +</source>
          <target state="translated">&amp;middot; &lt;em&gt;x&lt;/em&gt; +</target>
        </trans-unit>
        <trans-unit id="c01752f0646944d8aa6b495144cb53c0f5348ccd" translate="yes" xml:space="preserve">
          <source>&amp;middot;&lt;em&gt;x&lt;/em&gt;&lt;sup&gt;2&lt;/sup&gt; +</source>
          <target state="translated">&amp;middot; &lt;em&gt;x &lt;/em&gt;&lt;sup&gt;2&lt;/sup&gt; +</target>
        </trans-unit>
        <trans-unit id="ca281ff10e0c51f7e81335cb7834e418b7afaf78" translate="yes" xml:space="preserve">
          <source>&amp;middot;&lt;em&gt;x&lt;/em&gt;&lt;sup&gt;3&lt;/sup&gt; +</source>
          <target state="translated">&amp;middot; &lt;em&gt;x &lt;/em&gt;&lt;sup&gt;3&lt;/sup&gt; +</target>
        </trans-unit>
        <trans-unit id="8367bf1579c7db95d43ab3444547e64d4ef9b6d3" translate="yes" xml:space="preserve">
          <source>&amp;middot;&lt;em&gt;y&lt;/em&gt;.</source>
          <target state="translated">&amp;middot; &lt;em&gt;y&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="e1907af93f06047bdf97a92a5f71da9b89222d6d" translate="yes" xml:space="preserve">
          <source>&amp;ndash; integers</source>
          <target state="translated">&amp;ndash; 정수</target>
        </trans-unit>
        <trans-unit id="1d77670759947f3bb0477c2d19524e7decc4e882" translate="yes" xml:space="preserve">
          <source>&amp;ne; 0 &amp;gt;</source>
          <target state="translated">&amp;ne; 0&amp;gt;</target>
        </trans-unit>
        <trans-unit id="efe702747f33997abd2ae914a575c5e4ea38522b" translate="yes" xml:space="preserve">
          <source>&amp;ne; 0 &amp;lt;</source>
          <target state="translated">&amp;ne; 0 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="4429d48aa01c76d3396541bb843acf24b3f679b6" translate="yes" xml:space="preserve">
          <source>&amp;ne; 0 =</source>
          <target state="translated">&amp;ne; 0 =</target>
        </trans-unit>
        <trans-unit id="1f89c3f7c9d08338e52b4411b81a42f5b9417211" translate="yes" xml:space="preserve">
          <source>&amp;ne; 0,</source>
          <target state="translated">&amp;ne; 0,</target>
        </trans-unit>
        <trans-unit id="4d98a2b4f97cf7893f04666e243cc03576b4fe1a" translate="yes" xml:space="preserve">
          <source>&amp;rsquo; = -(-</source>
          <target state="translated">'=-(-</target>
        </trans-unit>
        <trans-unit id="626fcca9e3c8cf7d4a69beab2a5d9818401720bc" translate="yes" xml:space="preserve">
          <source>&amp;rsquo; = 0; if</source>
          <target state="translated">'= 0; 만약</target>
        </trans-unit>
        <trans-unit id="2e4a410348c03f30c24b0d525baf8e0197729c24" translate="yes" xml:space="preserve">
          <source>&amp;rsquo; = 1; if -2 &amp;lt;</source>
          <target state="translated">'= 1; -2 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="17f770dc35e50ddb0b9dc0105e08c9c0e3aee5b2" translate="yes" xml:space="preserve">
          <source>&amp;rsquo;s factors, we can instead pass</source>
          <target state="translated">의 요인, 대신 통과 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="03f539b2a22aaaed1db215c2950d3ed1599286f0" translate="yes" xml:space="preserve">
          <source>(1) is neither 1 nor -1, then</source>
          <target state="translated">(1)은 1도 -1도 아닌 경우</target>
        </trans-unit>
        <trans-unit id="969c5dfaebc55789601b0b4951fe01e479a5131f" translate="yes" xml:space="preserve">
          <source>(1).  Then we return the unique function</source>
          <target state="translated">(1). 그런 다음 고유 한 함수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="971a2a31fa23a7c33e144ed8640bbf8055d90b8e" translate="yes" xml:space="preserve">
          <source>(None, None)</source>
          <target state="translated">(없음, 없음)</target>
        </trans-unit>
        <trans-unit id="03dbeb1aa707806cbf5f399ce8022ae3ea2e35b4" translate="yes" xml:space="preserve">
          <source>(None, z, None)</source>
          <target state="translated">(없음, z, 없음)</target>
        </trans-unit>
        <trans-unit id="d6d85aff92c379ca9ade6ac4079ecfd78153da15" translate="yes" xml:space="preserve">
          <source>(and therefore</source>
          <target state="translated">(따라서</target>
        </trans-unit>
        <trans-unit id="a666a96c08ace45e46f2016bf528aedca5ac2394" translate="yes" xml:space="preserve">
          <source>(default), we don&amp;rsquo;t call the multiprocessing functions.</source>
          <target state="translated">(기본값), 다중 처리 기능을 호출하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d1ed1b74b6bd0c8f32a8d28b2e38be17613669ba" translate="yes" xml:space="preserve">
          <source>(gen, None, None)</source>
          <target state="translated">(gen, None, None)</target>
        </trans-unit>
        <trans-unit id="e459b13269ede555240e9185989705f723c1e0e1" translate="yes" xml:space="preserve">
          <source>(gen, z, f)</source>
          <target state="translated">(gen, z, f)</target>
        </trans-unit>
        <trans-unit id="cbffd77b9d1901c972fb0cd6a9d002d8273280c6" translate="yes" xml:space="preserve">
          <source>(inclusive) can be written as a sum of divisors of</source>
          <target state="translated">(포함)은 다음의 제수 합계로 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="622048af57626501fcc49a2751e0d8523a7e2a35" translate="yes" xml:space="preserve">
          <source>(isqrt(n), [a,b,c,...,d])</source>
          <target state="translated">(isqrt (n), [a, b, c, ..., d])</target>
        </trans-unit>
        <trans-unit id="4840cda77bfaffac296c76b7947c7053174a4ebb" translate="yes" xml:space="preserve">
          <source>(mod</source>
          <target state="translated">(모드</target>
        </trans-unit>
        <trans-unit id="6a228c46af6c061469f59308e5af49db5fc3b04c" translate="yes" xml:space="preserve">
          <source>) = 1.  Also called the reduced totient or least universal exponent.</source>
          <target state="translated">) = 1. 감소 된 토 텐트 또는 최소 보편적 지수라고도합니다.</target>
        </trans-unit>
        <trans-unit id="073d0308b8b9be18296d367b35ec54590b48f865" translate="yes" xml:space="preserve">
          <source>) and</source>
          <target state="translated">) 및</target>
        </trans-unit>
        <trans-unit id="ad9c9a8d46d9d802e701a33d2a70e6b5716d0f37" translate="yes" xml:space="preserve">
          <source>) and V(</source>
          <target state="translated">) 및 V (</target>
        </trans-unit>
        <trans-unit id="ac66979b1454bbfec91b6d7fae0329bfdf1387d9" translate="yes" xml:space="preserve">
          <source>) for all &lt;em&gt;a&lt;/em&gt; such that gcd(&lt;em&gt;a&lt;/em&gt;,</source>
          <target state="translated">) 모두 되도록 GCD ( ,&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="3355ec74401583907d7a9cbeddaf485a48f9374c" translate="yes" xml:space="preserve">
          <source>) with parameters (</source>
          <target state="translated">) 매개 변수 (</target>
        </trans-unit>
        <trans-unit id="f68a84d9836c0c97794a4934197fe60fcf86a733" translate="yes" xml:space="preserve">
          <source>)&amp;rsquo;; and (&lt;em&gt;ab&lt;/em&gt;)&amp;rsquo; = &lt;em&gt;a&lt;/em&gt;&amp;rsquo;&amp;middot;&lt;em&gt;b&lt;/em&gt; + &lt;em&gt;b&lt;/em&gt;&amp;rsquo;&amp;middot;&lt;em&gt;a&lt;/em&gt;.</source>
          <target state="translated">) '; 그리고 ( &lt;em&gt;ab&lt;/em&gt; ) '= &lt;em&gt;a&lt;/em&gt; '&amp;middot; &lt;em&gt;b&lt;/em&gt; + &lt;em&gt;b&lt;/em&gt; '&amp;middot; &lt;em&gt;a&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="d4dc2cee30052c6c649817c9e7a38b638e197cc5" translate="yes" xml:space="preserve">
          <source>)) arithmetic operations.  If</source>
          <target state="translated">)) 산술 연산. 만약</target>
        </trans-unit>
        <trans-unit id="75816c562eabe0637a5415a8a87ebd580a17db45" translate="yes" xml:space="preserve">
          <source>)) earlier Fibonaccis along the way.  This is the asymptotically fastest algorithm.</source>
          <target state="translated">)) 이전의 Fibonaccis. 이것은 점근 적으로 가장 빠른 알고리즘입니다.</target>
        </trans-unit>
        <trans-unit id="028dca72f656c1f9f2c5bf131d16859612ce8fe7" translate="yes" xml:space="preserve">
          <source>)) earlier Fibonaccis along the way.  This is, in the big-O sense, just about as fast as possible.</source>
          <target state="translated">)) 이전의 Fibonaccis. 이것은 big-O 의미에서 가능한 한 빠릅니다.</target>
        </trans-unit>
        <trans-unit id="27489df79360a12fbf20085f661e36a65b7f68e2" translate="yes" xml:space="preserve">
          <source>))) to O(</source>
          <target state="translated">)))에서 O (</target>
        </trans-unit>
        <trans-unit id="d833daeaaa13660c3317a667dae54810986ad5e9" translate="yes" xml:space="preserve">
          <source>))/&lt;em&gt;Q&lt;/em&gt;&lt;sub&gt;i&lt;/sub&gt; is the &lt;em&gt;i&lt;/em&gt;&lt;sup&gt;th&lt;/sup&gt; complete quotient of &lt;em&gt;x&lt;/em&gt;, and &lt;em&gt;B&lt;/em&gt;&lt;sub&gt;i&lt;/sub&gt; is the denominator of the &lt;em&gt;i&lt;/em&gt;&lt;sup&gt;th&lt;/sup&gt; convergent to &lt;em&gt;x&lt;/em&gt;.  For full details, see &lt;a href=&quot;https://www.jpr2718.org/pell.pdf&quot;&gt;https://www.jpr2718.org/pell.pdf&lt;/a&gt;.</source>
          <target state="translated">)) / &lt;em&gt;Q는 &lt;/em&gt;&lt;sub&gt;난&lt;/sub&gt; 은 IS &lt;em&gt;I &lt;/em&gt;&lt;sup&gt;번째&lt;/sup&gt; 의 완전한 지수 &lt;em&gt;X는&lt;/em&gt; 및 &lt;em&gt;B &lt;/em&gt;&lt;sub&gt;난&lt;/sub&gt; 의 분모 인 &lt;em&gt;I &lt;/em&gt;&lt;sup&gt;번째의&lt;/sup&gt; 수렴에 &lt;em&gt;X&lt;/em&gt; . 자세한 내용은 &lt;a href=&quot;https://www.jpr2718.org/pell.pdf&quot;&gt;https://www.jpr2718.org/pell.pdf를&lt;/a&gt; 참조 하십시오 .</target>
        </trans-unit>
        <trans-unit id="bd80da636e962ed71e291fca5e49f660ed4144a9" translate="yes" xml:space="preserve">
          <source>), hence the name of this function.</source>
          <target state="translated">), 따라서이 함수의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="20b3a9190c2085fbc25ee7fe3d2088f716aee6b8" translate="yes" xml:space="preserve">
          <source>).  Currently just a helper function for</source>
          <target state="translated">). 현재는</target>
        </trans-unit>
        <trans-unit id="fc24c2c1660830bca465674c52368b6befa93ead" translate="yes" xml:space="preserve">
          <source>).  More explicitly, if</source>
          <target state="translated">). 보다 명시 적으로</target>
        </trans-unit>
        <trans-unit id="3c7f18a5a134f67c307184ef35ec66cfd2abf329" translate="yes" xml:space="preserve">
          <source>).  Not meaningful if</source>
          <target state="translated">). 의미가없는 경우</target>
        </trans-unit>
        <trans-unit id="d2e1fe1b68c7903c6db94653115ed46c2a4ee271" translate="yes" xml:space="preserve">
          <source>).  Note that this is the generalization of the Jacobi symbol, &lt;em&gt;not&lt;/em&gt; the Dirac-delta analogue.</source>
          <target state="translated">). 이것은 Dirac-delta 유사체가 &lt;em&gt;아닌&lt;/em&gt; Jacobi 기호의 일반화입니다 .</target>
        </trans-unit>
        <trans-unit id="7ed0423caf6d9cca721055e02a0f8298586e9324" translate="yes" xml:space="preserve">
          <source>).  This is primarily a helper function for</source>
          <target state="translated">). 이것은 주로 다음을위한 도우미 함수입니다.</target>
        </trans-unit>
        <trans-unit id="aa879b8892d12724424e723c8b8b7fbd2a5451ee" translate="yes" xml:space="preserve">
          <source>).  We assume that</source>
          <target state="translated">). 우리는</target>
        </trans-unit>
        <trans-unit id="505171ddfe54c69bfaacb38ce5b92c5d42c81e6b" translate="yes" xml:space="preserve">
          <source>). We yield a sequence of tuples (&lt;em&gt;B&lt;/em&gt;&lt;sub&gt;i&lt;/sub&gt;, &lt;em&gt;G&lt;/em&gt;&lt;sub&gt;i&lt;/sub&gt;, &lt;em&gt;P&lt;/em&gt;&lt;sub&gt;i&lt;/sub&gt;, &lt;em&gt;Q&lt;/em&gt;&lt;sub&gt;i&lt;/sub&gt;) where &lt;em&gt;i&lt;/em&gt; is an index counting up from 0, &lt;em&gt;x&lt;/em&gt; = (</source>
          <target state="translated">). 튜플 시퀀스 ( &lt;em&gt;B &lt;/em&gt;&lt;sub&gt;i&lt;/sub&gt; , &lt;em&gt;G &lt;/em&gt;&lt;sub&gt;i&lt;/sub&gt; , &lt;em&gt;P &lt;/em&gt;&lt;sub&gt;i&lt;/sub&gt; , &lt;em&gt;Q &lt;/em&gt;&lt;sub&gt;i&lt;/sub&gt; )를 산출합니다. 여기서 &lt;em&gt;i&lt;/em&gt; 는 0, &lt;em&gt;x&lt;/em&gt; = (</target>
        </trans-unit>
        <trans-unit id="a66cbcc1eefeec92bf1b2e36bacce5d8d50b0b1e" translate="yes" xml:space="preserve">
          <source>): 1 if</source>
          <target state="translated">) : 1 인 경우</target>
        </trans-unit>
        <trans-unit id="3d37083a936c7247b36f337c8fa77689a4dbaae8" translate="yes" xml:space="preserve">
          <source>)&lt;sup&gt;2&lt;/sup&gt; &amp;middot; ln(ln(</source>
          <target state="translated">) &lt;sup&gt;2&lt;/sup&gt; &amp;middot; ln (ln (</target>
        </trans-unit>
        <trans-unit id="f609791b786e22175c6b8ffda42a1b240134ad4f" translate="yes" xml:space="preserve">
          <source>)&lt;sup&gt;2&lt;/sup&gt;) primality tests.  When called with the default primality test, this then uses O(log(</source>
          <target state="translated">) &lt;sup&gt;2&lt;/sup&gt; ) 소수성 테스트. 기본 소수성 테스트로 호출되면 O (log (</target>
        </trans-unit>
        <trans-unit id="fa3b1912e9f9c70c9ea40e24d137c2e2b65c834c" translate="yes" xml:space="preserve">
          <source>)&lt;sup&gt;3&lt;/sup&gt;) arithmetic operations, which in turn results in just over O(log(</source>
          <target state="translated">) &lt;sup&gt;3&lt;/sup&gt; ) 산술 연산, 결과적으로 O (log (</target>
        </trans-unit>
        <trans-unit id="eccfd3ffa4c0210f0545129d88c80138a75afcc9" translate="yes" xml:space="preserve">
          <source>)&lt;sup&gt;4&lt;/sup&gt;) to O(log(</source>
          <target state="translated">) &lt;sup&gt;4&lt;/sup&gt; )에서 O (log (</target>
        </trans-unit>
        <trans-unit id="d0f96418fdaae58aa868dfa1a04b907e3de4d8e0" translate="yes" xml:space="preserve">
          <source>)&lt;sup&gt;5&lt;/sup&gt;) bit operations, depending on how multiplication is handled.</source>
          <target state="translated">) &lt;sup&gt;5&lt;/sup&gt; ) 곱셈이 처리되는 방식에 따라 비트 연산.</target>
        </trans-unit>
        <trans-unit id="df58248c414f342c81e056b40bee12d17a08bf61" translate="yes" xml:space="preserve">
          <source>*</source>
          <target state="translated">*</target>
        </trans-unit>
        <trans-unit id="058e6364a206ec75d4ea06b216781091dc0a63b4" translate="yes" xml:space="preserve">
          <source>* &amp;hellip; *</source>
          <target state="translated">*&amp;hellip; *</target>
        </trans-unit>
        <trans-unit id="a979ef10cc6f6a36df6b8a323307ee3bb2e2db9c" translate="yes" xml:space="preserve">
          <source>+</source>
          <target state="translated">+</target>
        </trans-unit>
        <trans-unit id="6bb6d24650ce6af4e00193710ccebde9f999bbd9" translate="yes" xml:space="preserve">
          <source>+ - * / // % **</source>
          <target state="translated">+-* / // % **</target>
        </trans-unit>
        <trans-unit id="88be9dbf8c68b4e83cdc908fac5b35306ecb2688" translate="yes" xml:space="preserve">
          <source>+&amp;radic;</source>
          <target state="translated">+ &amp;radic;</target>
        </trans-unit>
        <trans-unit id="395e5e0dc693868d0fd611f9b4a861a3cf345095" translate="yes" xml:space="preserve">
          <source>+1 and &lt;em&gt;F&lt;/em&gt; &amp;gt;</source>
          <target state="translated">+1 및 &lt;em&gt;F&lt;/em&gt; &amp;gt;</target>
        </trans-unit>
        <trans-unit id="2b15d7a9a8b829e1bc4ccc67364b19c65fbdf7f0" translate="yes" xml:space="preserve">
          <source>+1 is insufficient, we compute the factorization ourselves.</source>
          <target state="translated">+1은 불충분합니다. 우리가 직접 분해를 계산합니다.</target>
        </trans-unit>
        <trans-unit id="a4e0b43c86a3bd970da095c5a06be5a4c227f37e" translate="yes" xml:space="preserve">
          <source>+1)-tuple together with</source>
          <target state="translated">+1)-튜플 함께</target>
        </trans-unit>
        <trans-unit id="5c10b5b2cd673a0616d529aa5234b12ee7153808" translate="yes" xml:space="preserve">
          <source>,</source>
          <target state="translated">,</target>
        </trans-unit>
        <trans-unit id="d1a1b525f037dbfee7a76d82c7051a2e5ebb7fa7" translate="yes" xml:space="preserve">
          <source>, -1 if it isn&amp;rsquo;t, and 0 if</source>
          <target state="translated">, 그렇지 않은 경우 -1, 그렇지 않은 경우 0</target>
        </trans-unit>
        <trans-unit id="0402a07c81f8c9e99543d7b18293125f7dd682a6" translate="yes" xml:space="preserve">
          <source>, 1).</source>
          <target state="translated">, 1).</target>
        </trans-unit>
        <trans-unit id="adb71383bb0c830dc088a44c3c3b663bf50fa2d8" translate="yes" xml:space="preserve">
          <source>, &lt;em&gt;t&lt;/em&gt;).</source>
          <target state="translated">, &lt;em&gt;t&lt;/em&gt; ).</target>
        </trans-unit>
        <trans-unit id="f77a760d23ae5acd0086318743e4a422f6fa2a4a" translate="yes" xml:space="preserve">
          <source>, &lt;em&gt;x&lt;/em&gt;, &lt;em&gt;y&lt;/em&gt;) such that</source>
          <target state="translated">, &lt;em&gt;x&lt;/em&gt; , &lt;em&gt;y&lt;/em&gt; )</target>
        </trans-unit>
        <trans-unit id="8278d2adba7612cf98a492d21a4ac4c78acb1202" translate="yes" xml:space="preserve">
          <source>, and</source>
          <target state="translated">,</target>
        </trans-unit>
        <trans-unit id="a13ee8f7bf09e35795911f99b635ce888958b07e" translate="yes" xml:space="preserve">
          <source>, but this is purely for efficiency: if this import fails, we simply set</source>
          <target state="translated">, 그러나 이것은 순전히 효율성을위한 것입니다.이 가져 오기가 실패하면 간단히</target>
        </trans-unit>
        <trans-unit id="2912e7d258bdbee79fb5448e6fb89a4149277adf" translate="yes" xml:space="preserve">
          <source>, except we compute only one sequence, and we supply the seeds.</source>
          <target state="translated">, 단 하나의 시퀀스 만 계산하고 시드를 제공하는 것을 제외하고는</target>
        </trans-unit>
        <trans-unit id="ef6b7a7bd8309377d5e53d1f069b2ebb0dbddad1" translate="yes" xml:space="preserve">
          <source>, except we only compute one sequence, and we supply the seeds.</source>
          <target state="translated">, 단 하나의 시퀀스 만 계산하고 시드를 제공하는 것을 제외하고는</target>
        </trans-unit>
        <trans-unit id="7253342fe51b33ee007666f1f184ed4fc90d8625" translate="yes" xml:space="preserve">
          <source>, indexed so that</source>
          <target state="translated">, 색인화되어</target>
        </trans-unit>
        <trans-unit id="8d163154d8e6c13b85c5bd9f16c6ce3644b2d6c6" translate="yes" xml:space="preserve">
          <source>, normalized to lie between</source>
          <target state="translated">, 정규화되어</target>
        </trans-unit>
        <trans-unit id="b366d1a229ec84d93ba42e7ecafb33db5b7b9b39" translate="yes" xml:space="preserve">
          <source>, or</source>
          <target state="translated">또는</target>
        </trans-unit>
        <trans-unit id="2ae7a3d4fae316f912bf8cd912495d732107d53c" translate="yes" xml:space="preserve">
          <source>, or if</source>
          <target state="translated">또는</target>
        </trans-unit>
        <trans-unit id="3965b16e7dcabd26afcc58e0dea964d0925db505" translate="yes" xml:space="preserve">
          <source>, or if both input polynomials are</source>
          <target state="translated">, 또는 두 입력 다항식이 모두</target>
        </trans-unit>
        <trans-unit id="f4899ae60f954a43e356842cf2c73c99b2d7f825" translate="yes" xml:space="preserve">
          <source>, returns 1.</source>
          <target state="translated">, 1을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="a9ae4d785b3d24dcbe10dec9ccaef3a5814950b5" translate="yes" xml:space="preserve">
          <source>, returns the greatest integer &amp;le; the rth root of</source>
          <target state="translated">, 가장 큰 정수 &amp;le; rth 루트를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="1991cc6b25fa65f3894fd899603280a4c42747ff" translate="yes" xml:space="preserve">
          <source>, returns the least integer &amp;ge; the</source>
          <target state="translated">, 최소 정수 &amp;ge;</target>
        </trans-unit>
        <trans-unit id="bde66d79831e0f6fa51191c837fa9d626744bf59" translate="yes" xml:space="preserve">
          <source>, so instead of feeding those functions the integer forms of</source>
          <target state="translated">, 따라서 이러한 함수를 제공하는 대신 정수 형식</target>
        </trans-unit>
        <trans-unit id="2af26fac1f5d8b2b60538d2d8175a3f4b44896fb" translate="yes" xml:space="preserve">
          <source>, then these sequences grow exponentially, so the number of bit operations is anywhere from O(</source>
          <target state="translated">, 이러한 시퀀스는 기하 급수적으로 증가하므로 비트 연산의 수는 O (</target>
        </trans-unit>
        <trans-unit id="74fa0c39cb9a52c881487f860f08a5619098244b" translate="yes" xml:space="preserve">
          <source>, then we generate all such tuples (regardless of size) that do not contain 1.</source>
          <target state="translated">, 그런 다음 크기에 관계없이 1을 포함하지 않는 모든 튜플을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="124774d26da0984041338194d3437efbb146ec0f" translate="yes" xml:space="preserve">
          <source>, then we make no such assumptions.</source>
          <target state="translated">, 그러면 우리는 그러한 가정을하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="be4bc766d7f8559c895eeb1a54a33499c8489897" translate="yes" xml:space="preserve">
          <source>, we return</source>
          <target state="translated">, 우리는 돌아 간다</target>
        </trans-unit>
        <trans-unit id="52c9d27db8d3c8f08205e64d67ed3a3b6e564d7d" translate="yes" xml:space="preserve">
          <source>, we return in a tuple all distinct integer roots of</source>
          <target state="translated">, 우리는 튜플에서 모든 고유 정수 루트를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="38dab4478fad01b1670e174fe4859917716feda1" translate="yes" xml:space="preserve">
          <source>, we return in a tuple all distinct integers &lt;em&gt;x&lt;/em&gt; such that</source>
          <target state="translated">, 우리는 튜플에서 모든 고유 정수 &lt;em&gt;x를&lt;/em&gt; 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="a8fbd0202d5d59bb16abfc27a4a724fcbb5feb8c" translate="yes" xml:space="preserve">
          <source>, where</source>
          <target state="translated">, 어디</target>
        </trans-unit>
        <trans-unit id="abd29e8823df564d7094cd5714f55d2ebab1009e" translate="yes" xml:space="preserve">
          <source>, which takes anywhere from O(</source>
          <target state="translated">, O (</target>
        </trans-unit>
        <trans-unit id="fae39a8b748ac34c7257196625985b5737c585b1" translate="yes" xml:space="preserve">
          <source>, written as their prime factorizations in factorint format.</source>
          <target state="translated">, factorint 형식의 소인수 분해로 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="508e0d8dab0b1f90c101e0fa953db8cf0119f473" translate="yes" xml:space="preserve">
          <source>-1 and &lt;em&gt;F&lt;/em&gt; &amp;gt;</source>
          <target state="translated">-1 및 &lt;em&gt;F&lt;/em&gt; &amp;gt;</target>
        </trans-unit>
        <trans-unit id="c87aef34d25ddf413df074e43b3857fc721b9f9f" translate="yes" xml:space="preserve">
          <source>-1 is insufficient, we compute the factorization ourselves.</source>
          <target state="translated">-1은 불충분합니다. 우리는 분해를 스스로 계산합니다.</target>
        </trans-unit>
        <trans-unit id="934653cf2fbb5aa343b8a17873ada188f63e69ca" translate="yes" xml:space="preserve">
          <source>-gonal number.</source>
          <target state="translated">-각 번호.</target>
        </trans-unit>
        <trans-unit id="4c9d25022f1889df6c191b749db36ada3048576a" translate="yes" xml:space="preserve">
          <source>-gonal number.  Indexing begins with 1 so that</source>
          <target state="translated">-각 번호. 인덱싱은 1로 시작하므로</target>
        </trans-unit>
        <trans-unit id="d8cec187abb579e2c29e5aa4980bca32e7aeddcd" translate="yes" xml:space="preserve">
          <source>-smooth numbers, where</source>
          <target state="translated">-부드러운 숫자, 여기서</target>
        </trans-unit>
        <trans-unit id="51799f4dddb6b8f54821f886704c610286d072d8" translate="yes" xml:space="preserve">
          <source>-smooth; the theorem also gives an effective algorithm for finding them.  We implement Lenstra&amp;rsquo;s improvement to this theorem.</source>
          <target state="translated">-부드러운; 정리는 또한 그것들을 찾는 효과적인 알고리즘을 제공합니다. 우리는이 정리에 대한 Lenstra의 개선을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="9dfb7435225d8e36f17f8e560fb966c793db1b51" translate="yes" xml:space="preserve">
          <source>-tuples of positive integers all &amp;le;</source>
          <target state="translated">-양의 정수 튜플 모두 &amp;le;</target>
        </trans-unit>
        <trans-unit id="03c31cf6bf7021202cec4b807dd5bae4b273d995" translate="yes" xml:space="preserve">
          <source>-tuples of positive integers whose product is</source>
          <target state="translated">-제품이 다음과 같은 양의 정수 튜플</target>
        </trans-unit>
        <trans-unit id="55860883266f69576a27944588d11aeb9af144a7" translate="yes" xml:space="preserve">
          <source>.  Adds two points on a Montgomery curve modulo</source>
          <target state="translated">. 몽고메리 곡선에 두 점을 모듈로 추가</target>
        </trans-unit>
        <trans-unit id="bedbd2cb0d726992a984f6022cb30b49b09c1367" translate="yes" xml:space="preserve">
          <source>.  All elements of</source>
          <target state="translated">. 모든 요소</target>
        </trans-unit>
        <trans-unit id="630822fc11b0b2f1ecc676caf2a8e615584e3581" translate="yes" xml:space="preserve">
          <source>.  Coded after algorithm 2.2.1 from &lt;em&gt;Prime Numbers: A Computational Perspective&lt;/em&gt; by Crandall &amp;amp; Pomerance (2&lt;sup&gt;nd&lt;/sup&gt; edition).</source>
          <target state="translated">. 에서 알고리즘 2.2.1 후 코딩 &lt;em&gt;전산 관점 : 국무 번호&lt;/em&gt; 크 랜달 &amp;amp; Pomerance (2에 의해 &lt;sup&gt;차&lt;/sup&gt; 판).</target>
        </trans-unit>
        <trans-unit id="b89d3c4183e2ee6ab2d3f880397ed31ad5fc9bd0" translate="yes" xml:space="preserve">
          <source>.  Does not yield anything &amp;gt;</source>
          <target state="translated">. 아무것도 산출하지 않습니다&amp;gt;</target>
        </trans-unit>
        <trans-unit id="5794214f71393c850a4e6757e629c4faabd9bd28" translate="yes" xml:space="preserve">
          <source>.  Doubles a point on a Montgomery curve modulo</source>
          <target state="translated">. 몽고메리 곡선에서 점을 두 배로 모듈로</target>
        </trans-unit>
        <trans-unit id="3b4687835edd8bbc72934f002d56164eb354f1c8" translate="yes" xml:space="preserve">
          <source>.  For best performance,</source>
          <target state="translated">. 최상의 성능을 위해</target>
        </trans-unit>
        <trans-unit id="eeca317bcf54a2fa2495313e90c0253b6765a885" translate="yes" xml:space="preserve">
          <source>.  For negative</source>
          <target state="translated">. 부정적인</target>
        </trans-unit>
        <trans-unit id="f863c23a93501fd973cdcb1d746f38bd8aa20cad" translate="yes" xml:space="preserve">
          <source>.  If</source>
          <target state="translated">. 만약</target>
        </trans-unit>
        <trans-unit id="62336538159533d8f2b7825c9e1614a8e84a8d21" translate="yes" xml:space="preserve">
          <source>.  If any of these conditions is false, then the return value is meaningless.</source>
          <target state="translated">. 이러한 조건 중 하나라도 거짓이면 반환 값은 의미가 없습니다.</target>
        </trans-unit>
        <trans-unit id="3aa2fef03cc99f2c6a29981a54b6ca0fd43a4b2f" translate="yes" xml:space="preserve">
          <source>.  Includes 0/1 and 1/1.</source>
          <target state="translated">. 0/1 및 1/1을 포함합니다.</target>
        </trans-unit>
        <trans-unit id="6c15dcaa1f706697e53ac180225305ff0bf45eb2" translate="yes" xml:space="preserve">
          <source>.  Let</source>
          <target state="translated">. 허락하다</target>
        </trans-unit>
        <trans-unit id="ec0dddd61a70dd84062d17fad04519fba3eb76f7" translate="yes" xml:space="preserve">
          <source>.  Mathematically, functions &lt;em&gt;f&lt;/em&gt; such that &lt;em&gt;f&lt;/em&gt;(1) = 0 have no Dirichlet inverses due to a division by zero.  This is reflected in this implementation by raising a</source>
          <target state="translated">. 수학적으로 &lt;em&gt;f&lt;/em&gt; (1) = 0이 되는 함수 &lt;em&gt;f&lt;/em&gt; 는 0으로 나누기 때문에 디리클레 역이 없습니다. 이것은이 구현에서&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a2df60a11b363555ab8ab834ad45360aa791f070" translate="yes" xml:space="preserve">
          <source>.  More precisely, let</source>
          <target state="translated">. 더 정확하게는</target>
        </trans-unit>
        <trans-unit id="69e208881411e7de93486694f776e8e75beea160" translate="yes" xml:space="preserve">
          <source>.  Multiplies a point on Montgomery curve by an integer modulo</source>
          <target state="translated">. 몽고메리 곡선의 점에 정수 모듈로를 곱합니다.</target>
        </trans-unit>
        <trans-unit id="24ff29b13afd939997c9d19c2291962b64252ac1" translate="yes" xml:space="preserve">
          <source>.  Multiplies along a Lucas sequence modulo</source>
          <target state="translated">. Lucas 시퀀스 모듈로를 따라 곱합니다.</target>
        </trans-unit>
        <trans-unit id="2eb0162a649d218e0a6cf19d0278bda7b26c9015" translate="yes" xml:space="preserve">
          <source>.  Note that this function is not equivalent to calling</source>
          <target state="translated">. 이 함수는 다음을 호출하는 것과 동일하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="70e6e03586456dd55a266bb8d7fc4d3529dec32e" translate="yes" xml:space="preserve">
          <source>.  Polynomials are written as lists of integers with the constant terms first.  If the high-degree coefficients are zero, those terms will be deleted from the answer so that the highest-degree term is nonzero.  We assume that the inputs also satisfy this property.  The zero polynomial is represented by the empty list.  If one of the input polynomials is</source>
          <target state="translated">. 다항식은 상수 용어가 먼저있는 정수 목록으로 작성됩니다. 고차 계수가 0이면 최고 차수가 0이 아니도록 해당 항이 답에서 삭제됩니다. 입력이이 속성도 충족한다고 가정합니다. 제로 다항식은 빈 목록으로 표시됩니다. 입력 다항식 중 하나가</target>
        </trans-unit>
        <trans-unit id="7891891653fc6cce3496396ec615e07822222198" translate="yes" xml:space="preserve">
          <source>.  Returns a modular inverse normalized to minimize absolute value.</source>
          <target state="translated">. 절대 값을 최소화하기 위해 정규화 된 모듈 식 역을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="df53b7ffad8e7c9ffc76f6c2e3ff912b135a6d75" translate="yes" xml:space="preserve">
          <source>.  Returns a possibly-trivial divisor of</source>
          <target state="translated">. 가능한 사소한 제수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="5db5695825b9f5041cedecad58afc157086c9824" translate="yes" xml:space="preserve">
          <source>.  Stops after yielding 1.</source>
          <target state="translated">. 항복 후 정지합니다.</target>
        </trans-unit>
        <trans-unit id="17ee1ebfb679c24d9865beefd1b230698dbc71f5" translate="yes" xml:space="preserve">
          <source>.  The answer is not guaranteed to exist.  In such cases, we return</source>
          <target state="translated">. 대답이 존재한다는 보장은 없습니다. 이러한 경우에는</target>
        </trans-unit>
        <trans-unit id="c97013ebd3dd56cef9ec19b305fef47446fc694c" translate="yes" xml:space="preserve">
          <source>.  The argument</source>
          <target state="translated">. 논쟁 거리</target>
        </trans-unit>
        <trans-unit id="3984dbf3fc01a765843114a64197bc76090c91a6" translate="yes" xml:space="preserve">
          <source>.  The coefficients are interpreted mod</source>
          <target state="translated">. 계수는 mod로 해석됩니다.</target>
        </trans-unit>
        <trans-unit id="e364d93738c49ae8d217216d6b8aa47157e3d801" translate="yes" xml:space="preserve">
          <source>.  The number of solutions will be finite.</source>
          <target state="translated">. 솔루션의 수는 한정되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="fa76e6d3265c6c843ae2903190d7f8d8cbd34b46" translate="yes" xml:space="preserve">
          <source>.  The output is not necessarily sorted.</source>
          <target state="translated">. 출력이 반드시 정렬되는 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="dc298eb5fce15e6a268b2efb1ab91a3189688f64" translate="yes" xml:space="preserve">
          <source>.  The result is not guaranteed to exist; in such cases we return</source>
          <target state="translated">. 결과가 존재한다고 보장되지는 않습니다. 이러한 경우 우리는</target>
        </trans-unit>
        <trans-unit id="92094b4180603ce1a85d50ea9bd933a525697ff4" translate="yes" xml:space="preserve">
          <source>.  The result is not guaranteed to exist; in such cases, we return</source>
          <target state="translated">. 결과가 존재한다고 보장되지는 않습니다. 이러한 경우 우리는</target>
        </trans-unit>
        <trans-unit id="81f5c77a504be64ba4223184977c7f81505e3e33" translate="yes" xml:space="preserve">
          <source>.  The terms of this sequence usually grow exponentially, so computing a distant term incrementally by plucking it out of this generator takes O(</source>
          <target state="translated">. 이 시퀀스의 항은 일반적으로 기하 급수적으로 증가하므로이 생성기에서 뽑아서 먼 항을 점진적으로 계산하려면 O (</target>
        </trans-unit>
        <trans-unit id="c10decf0963370caa2df4eddad2f2022d7d4cc37" translate="yes" xml:space="preserve">
          <source>.  These are all in the Python standard library.</source>
          <target state="translated">. 이것들은 모두 Python 표준 라이브러리에 있습니다.</target>
        </trans-unit>
        <trans-unit id="9fd1b8413cae2d8a7cf8b859c3afd081cf7c8fd4" translate="yes" xml:space="preserve">
          <source>.  These are also called panarithmic numbers.</source>
          <target state="translated">. 이들은 또한 panarithmic 번호라고도합니다.</target>
        </trans-unit>
        <trans-unit id="dbf9aec04ff31bff84995f4a6905d41ce7fb01ab" translate="yes" xml:space="preserve">
          <source>.  They are the factorial and primorial, respectively.  There are three aliases:</source>
          <target state="translated">. 그것들은 각각 계승과 원시입니다. 세 가지 별칭이 있습니다.</target>
        </trans-unit>
        <trans-unit id="4994d7eecfdcc83c94f0846956e2114430d8e8f1" translate="yes" xml:space="preserve">
          <source>.  This is primarily a helper function for</source>
          <target state="translated">. 이것은 주로 다음을위한 도우미 함수입니다.</target>
        </trans-unit>
        <trans-unit id="63fb949fc2e1a20504d5b8871e2ea9a276a1d2e7" translate="yes" xml:space="preserve">
          <source>.  We find lattice points on a hyperbola.</source>
          <target state="translated">. 쌍곡선에서 격자 점을 찾습니다.</target>
        </trans-unit>
        <trans-unit id="9ef5b873dc4abea1b311e3b6345ab953cf020928" translate="yes" xml:space="preserve">
          <source>.  We have several cases:</source>
          <target state="translated">. 몇 가지 경우가 있습니다.</target>
        </trans-unit>
        <trans-unit id="4f4e84829ca34bfa686bf64a2bbe339eadfd7319" translate="yes" xml:space="preserve">
          <source>.  We return the answer as</source>
          <target state="translated">. 우리는 대답을 다음과 같이 반환합니다.</target>
        </trans-unit>
        <trans-unit id="2a3ffa876c8affd5d4a2a3bdb0f9b24ccc9d2a04" translate="yes" xml:space="preserve">
          <source>.  We solve &lt;em&gt;x&lt;/em&gt;&lt;sup&gt;2&lt;/sup&gt; + |</source>
          <target state="translated">. 우리는 해결 &lt;em&gt;X &lt;/em&gt;&lt;sup&gt;2&lt;/sup&gt; + |</target>
        </trans-unit>
        <trans-unit id="aec57ea347c4cbb02e153f4e9dcdd2c7155bbc15" translate="yes" xml:space="preserve">
          <source>.  We solve &lt;em&gt;x&lt;/em&gt;&lt;sup&gt;2&lt;/sup&gt; =</source>
          <target state="translated">. 우리는 해결 &lt;em&gt;X &lt;/em&gt;&lt;sup&gt;2&lt;/sup&gt; =을</target>
        </trans-unit>
        <trans-unit id="ffdb742443cab6f6bc68d8e65b810e375ac33345" translate="yes" xml:space="preserve">
          <source>.  We use matrix methods to efficiently compute the</source>
          <target state="translated">. 행렬 방법을 사용하여 효율적으로</target>
        </trans-unit>
        <trans-unit id="d2edd7644d14b2c3ebdc5dcb244381cb86f47609" translate="yes" xml:space="preserve">
          <source>.  When</source>
          <target state="translated">. 언제</target>
        </trans-unit>
        <trans-unit id="3dd77e02a23c61ca582238169f3ebe5213f17bd1" translate="yes" xml:space="preserve">
          <source>.  When called with the keyword arguments at their default values, this is equivalent to the expression</source>
          <target state="translated">. 기본값에서 키워드 인수를 사용하여 호출하면 표현식과 동일합니다.</target>
        </trans-unit>
        <trans-unit id="c45c4ba26e34d0170e8fcfc83536c6a2c13d24eb" translate="yes" xml:space="preserve">
          <source>.  Will be upgraded to full status when the case</source>
          <target state="translated">. 사건이 발생하면 전체 상태로 업그레이드됩니다</target>
        </trans-unit>
        <trans-unit id="05a79f06cf3f67f726dae68d18a2290f6c9a50c9" translate="yes" xml:space="preserve">
          <source>:</source>
          <target state="translated">:</target>
        </trans-unit>
        <trans-unit id="cb7ea2362e2b5d69444b2add0d4466bf94a18ccd" translate="yes" xml:space="preserve">
          <source>: 1 if</source>
          <target state="translated">: 1 경우</target>
        </trans-unit>
        <trans-unit id="890b46b3be358edbcfa3d0c38fe4595d37e1a1ac" translate="yes" xml:space="preserve">
          <source>: if</source>
          <target state="translated">: 만약</target>
        </trans-unit>
        <trans-unit id="bb7195ec0056c8b0e2ce0463096c7965a6483b95" translate="yes" xml:space="preserve">
          <source>: the strongly multiplicative function that is -1 on the primes.</source>
          <target state="translated">: 소수에서 -1 인 강 곱셈 함수.</target>
        </trans-unit>
        <trans-unit id="85683ef74faa9fd110b10909edbd557af57c30bf" translate="yes" xml:space="preserve">
          <source>; i.e., finds the smallest &lt;em&gt;k&lt;/em&gt; such that</source>
          <target state="translated">; 즉, 다음 과 같은 가장 작은 &lt;em&gt;k를&lt;/em&gt; 찾습니다.</target>
        </trans-unit>
        <trans-unit id="1ec9e1cf2ec02b547b9b7d587eaa10e750c1b4c5" translate="yes" xml:space="preserve">
          <source>; if not, we keep chugging until a nontrivial factor is found.</source>
          <target state="translated">; 그렇지 않다면 우리는 사소한 요소가 발견 될 때까지 계속 흔들립니다.</target>
        </trans-unit>
        <trans-unit id="039f5fd2698055b3ba8a74fdb5cfa6c51e201fe2" translate="yes" xml:space="preserve">
          <source>; the actual factoring work is done there.  Multiprocessing incurs relatively significant overhead, so when</source>
          <target state="translated">; 실제 팩토링 작업이 여기서 이루어집니다. 다중 처리는 상대적으로 상당한 오버 헤드를 발생 시키므로</target>
        </trans-unit>
        <trans-unit id="40d77535a61760e117dbb66e25c00a2a15e0f8f9" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;x&lt;/em&gt;&lt;sub&gt;n+1&lt;/sub&gt; =</source>
          <target state="translated">&lt;em&gt;x &lt;/em&gt;&lt;sub&gt;n + 1&lt;/sub&gt; =</target>
        </trans-unit>
        <trans-unit id="6fad80e2470f3259317f0bae7ea41499d23e52bd" translate="yes" xml:space="preserve">
          <source>&lt;sub&gt;0&lt;/sub&gt; &amp;middot; &lt;em&gt;x&lt;/em&gt;&lt;sub&gt;n-k&lt;/sub&gt;,</source>
          <target state="translated">&lt;sub&gt;0&lt;/sub&gt; &amp;middot; &lt;em&gt;x &lt;/em&gt;&lt;sub&gt;n-k&lt;/sub&gt; ,</target>
        </trans-unit>
        <trans-unit id="5f7a29123ed0e3bd3cef4b66b4f233d8226b2920" translate="yes" xml:space="preserve">
          <source>&lt;sub&gt;k-1&lt;/sub&gt; &amp;middot; &lt;em&gt;x&lt;/em&gt;&lt;sub&gt;n-1&lt;/sub&gt; + &amp;hellip; +</source>
          <target state="translated">&lt;sub&gt;k-1&lt;/sub&gt; &amp;middot; &lt;em&gt;x &lt;/em&gt;&lt;sub&gt;n-1&lt;/sub&gt; +&amp;hellip; +</target>
        </trans-unit>
        <trans-unit id="a77f30fa676fba6eb28b45904ca9bf7f8407a4c8" translate="yes" xml:space="preserve">
          <source>&lt;sub&gt;k&lt;/sub&gt; &amp;middot; &lt;em&gt;x&lt;/em&gt;&lt;sub&gt;n&lt;/sub&gt; +</source>
          <target state="translated">&lt;sub&gt;케이&lt;/sub&gt; &amp;middot; &lt;em&gt;X &lt;/em&gt;&lt;sub&gt;N&lt;/sub&gt; +</target>
        </trans-unit>
        <trans-unit id="b9b3b1f557ccaa4770f762809de784e1cf71acd8" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;0.3&lt;/sup&gt;, we quickly determine without error whether</source>
          <target state="translated">&lt;sup&gt;0.3&lt;/sup&gt; , 우리는 신속하게 오류없이</target>
        </trans-unit>
        <trans-unit id="cc7ad8e27be44263423b050cf2c1d72fa330d1ec" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;2&lt;/sup&gt; &amp;equiv;</source>
          <target state="translated">&lt;sup&gt;2&lt;/sup&gt; &amp;equiv;</target>
        </trans-unit>
        <trans-unit id="8c3fed56bcf718ee6d22dfb1a2b07825ead397be" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;2&lt;/sup&gt; &amp;ne; 4&amp;middot;</source>
          <target state="translated">&lt;sup&gt;2&lt;/sup&gt; &amp;ne; 4 &amp;middot;</target>
        </trans-unit>
        <trans-unit id="c18d6e71a34fe8209f6204f366f7cb332c7dd04c" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;2&lt;/sup&gt; +</source>
          <target state="translated">&lt;sup&gt;2&lt;/sup&gt; +</target>
        </trans-unit>
        <trans-unit id="c716a113996c1b34a18ca8dadb5169431b0375fc" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;2&lt;/sup&gt; - 4&amp;middot;</source>
          <target state="translated">&lt;sup&gt;2&lt;/sup&gt; ~ 4 &amp;middot;</target>
        </trans-unit>
        <trans-unit id="ba2ef0b9899bd5abf83399d29b83f17a30d1935f" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;2&lt;/sup&gt;) bit operations depending on how multiplication is handled.</source>
          <target state="translated">&lt;sup&gt;2&lt;/sup&gt; ) 곱셈을 처리하는 방법에 따른 비트 연산.</target>
        </trans-unit>
        <trans-unit id="20c43e4a4f228b1130814bf5db7962ea64f1bd40" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;2&lt;/sup&gt;) bit operations.  Extractions of distant terms should therefore be done via</source>
          <target state="translated">&lt;sup&gt;2&lt;/sup&gt; ) 비트 연산. 따라서 먼 용어의 추출은 다음을 통해 수행되어야합니다.</target>
        </trans-unit>
        <trans-unit id="a167334eef67d44a756921a422a07f08e5fb4489" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;2&lt;/sup&gt;) depending on how multiplication is handled.  We recommend using MPZs when</source>
          <target state="translated">&lt;sup&gt;2&lt;/sup&gt; ) 곱셈을 처리하는 방법에 따라. 다음과 같은 경우 MPZ를 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="d236f231a01427fc576faf86fb013aa14e7327a7" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;3&lt;/sup&gt; +</source>
          <target state="translated">&lt;sup&gt;3&lt;/sup&gt; +</target>
        </trans-unit>
        <trans-unit id="aca3c1fe1f41e62b4cfac7c3ec7653d996a24f93" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;k&lt;/sup&gt; &amp;equiv; 1 (mod</source>
          <target state="translated">&lt;sup&gt;k&lt;/sup&gt; &amp;equiv; 1 (모드</target>
        </trans-unit>
        <trans-unit id="97c039090394f463605069bbf8c6df2722cd15df" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;k&lt;/sup&gt; &amp;le;</source>
          <target state="translated">&lt;sup&gt;k&lt;/sup&gt; &amp;le;</target>
        </trans-unit>
        <trans-unit id="55c8bf4743223131e169941ec2e4ce3a76abe7d9" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;r&lt;/sup&gt; =</source>
          <target state="translated">&lt;sup&gt;r&lt;/sup&gt; =</target>
        </trans-unit>
        <trans-unit id="4cc25447b154f91db08f310c8784b93d659d71b4" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;th&lt;/sup&gt;</source>
          <target state="translated">&lt;sup&gt;일&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="7b346dc385476d44de05bc10ba444eb03c42e758" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;th&lt;/sup&gt; Dirichlet root of the input function</source>
          <target state="translated">&lt;sup&gt;th&lt;/sup&gt; 입력 함수의 디리클레 루트</target>
        </trans-unit>
        <trans-unit id="4e0998833af3e641c4809cbbdc1acb8fa08b0c19" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;th&lt;/sup&gt; Fibonacci number, indexed so that</source>
          <target state="translated">&lt;sup&gt;th&lt;/sup&gt; 피보나치 수, 색인화되어</target>
        </trans-unit>
        <trans-unit id="9bae34915a2d899be1093417a6feae86593fe6e9" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;th&lt;/sup&gt; power and reduced modulo</source>
          <target state="translated">&lt;sup&gt;제&lt;/sup&gt; 전력 및 감소 된 모듈</target>
        </trans-unit>
        <trans-unit id="7c1b7cedd6cf4b7ea0843ae9112a88d81a587001" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;th&lt;/sup&gt; power; we return its</source>
          <target state="translated">&lt;sup&gt;th&lt;/sup&gt; 권력; 우리는 그것의 반환</target>
        </trans-unit>
        <trans-unit id="9571add5a9bb302601c68f6990cafdcaaac6ab01" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;th&lt;/sup&gt; prime (counting 2 as #1).  This is done with some efficiency by using</source>
          <target state="translated">&lt;sup&gt;th&lt;/sup&gt; 소수 (2를 # 1로 계산). 이것은 사용하여 약간의 효율성으로 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="2aa6d3c138012cea9d7e4de9efdf692013d87889" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;th&lt;/sup&gt; prime by using binary splitting on Riemann&amp;rsquo;s R function.</source>
          <target state="translated">&lt;sup&gt;&lt;/sup&gt;Riemann의 R 함수에서 이진 분할을 사용하여 &lt;sup&gt;th&lt;/sup&gt; 소수.</target>
        </trans-unit>
        <trans-unit id="1dd68f4e0732186c5eb7a5e3a2c916154df10e0a" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;th&lt;/sup&gt; root if it is and</source>
          <target state="translated">&lt;sup&gt;&lt;/sup&gt;그것이 있다면 &lt;sup&gt;th&lt;/sup&gt; 루트</target>
        </trans-unit>
        <trans-unit id="ce011f637b61645c06d252c10fe014b1c3b50958" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;th&lt;/sup&gt; root of</source>
          <target state="translated">&lt;sup&gt;의&lt;/sup&gt; 루트</target>
        </trans-unit>
        <trans-unit id="d1dae2018f87c5b4146f30281a32a978b8b8f51d" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;th&lt;/sup&gt; term of the recursion</source>
          <target state="translated">&lt;sup&gt;제&lt;/sup&gt; 재귀 용어</target>
        </trans-unit>
        <trans-unit id="bb7ebac52b158e0f3fb696936209b81e8b9d9c71" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;th&lt;/sup&gt; terms in the Lucas U- and V-sequences U(</source>
          <target state="translated">&lt;sup&gt;제&lt;/sup&gt; 루카스 U- 및 V-U 시퀀스의 용어 (</target>
        </trans-unit>
        <trans-unit id="c07471720fdc7dc843113017c61ef1da42d9636e" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;th&lt;/sup&gt; terms of Lucas U- and V-sequences modulo</source>
          <target state="translated">&lt;sup&gt;&lt;/sup&gt;Lucas U- 및 V- 시퀀스 모듈로의 &lt;sup&gt;th&lt;/sup&gt; 항</target>
        </trans-unit>
        <trans-unit id="21606782c65e44cac7afbb90977d8b6f82140e76" translate="yes" xml:space="preserve">
          <source>=</source>
          <target state="translated">=</target>
        </trans-unit>
        <trans-unit id="0e867bc45a919f6852d1707d6c564cddccc15b7e" translate="yes" xml:space="preserve">
          <source>= 0 and</source>
          <target state="translated">= 0 및</target>
        </trans-unit>
        <trans-unit id="a2b238e42ed2f58766c6f40ba1966b142c161247" translate="yes" xml:space="preserve">
          <source>= 0, we find the cubic&amp;rsquo;s other two roots an return in a tuple all distinct integer roots (including</source>
          <target state="translated">= 0, 우리는 3 차의 다른 두 뿌리를 튜플에서 반환하는 모든 고유 한 정수 뿌리 (포함</target>
        </trans-unit>
        <trans-unit id="d6b32a7fe9fea7f7dd2116e40c5126417c968633" translate="yes" xml:space="preserve">
          <source>= 0.  This is primarily a helper function for</source>
          <target state="translated">= 0. 이것은 주로 다음을위한 도우미 함수입니다.</target>
        </trans-unit>
        <trans-unit id="8c00f4833ad3bed0cee304c3bb5de05cab062a04" translate="yes" xml:space="preserve">
          <source>= 0.  We solve &lt;em&gt;x&lt;/em&gt;&lt;sup&gt;2&lt;/sup&gt; =</source>
          <target state="translated">= 0. &lt;em&gt;x &lt;/em&gt;&lt;sup&gt;2&lt;/sup&gt; =</target>
        </trans-unit>
        <trans-unit id="049f7baef9b4665ff6124dbb2667d2e49d810988" translate="yes" xml:space="preserve">
          <source>= 0: If</source>
          <target state="translated">= 0 : 만약</target>
        </trans-unit>
        <trans-unit id="b3b9cebb3d288d60423f3a8c77d0031229959706" translate="yes" xml:space="preserve">
          <source>= 1 for all applicable</source>
          <target state="translated">= 해당하는 모든 항목에 대해 1</target>
        </trans-unit>
        <trans-unit id="375e0e8806a735e7336a89fdb13202c8f2ff0bf5" translate="yes" xml:space="preserve">
          <source>= 1, this is Euler&amp;rsquo;s totient: the number of numbers less than a number that are relatively prime to that number.</source>
          <target state="translated">= 1, 이것은 오일러의 긴장입니다 : 그 숫자에 상대적으로 소수 인 숫자보다 작은 숫자의 수입니다.</target>
        </trans-unit>
        <trans-unit id="ee2a0977e48d5159f0c2700ba8564ca4daadcfd3" translate="yes" xml:space="preserve">
          <source>= 1.  The argument</source>
          <target state="translated">= 1. 인수</target>
        </trans-unit>
        <trans-unit id="127624f04c1941ca775ad41bcee5f7ed9d3f2b10" translate="yes" xml:space="preserve">
          <source>= [&lt;em&gt;a&lt;/em&gt;&lt;sub&gt;0&lt;/sub&gt;; &lt;em&gt;a&lt;/em&gt;&lt;sub&gt;1&lt;/sub&gt;, &lt;em&gt;a&lt;/em&gt;&lt;sub&gt;2&lt;/sub&gt;, &amp;hellip;], (&lt;em&gt;P&lt;/em&gt;&lt;sub&gt;i&lt;/sub&gt;+&amp;radic;</source>
          <target state="translated">= [ &lt;em&gt;a &lt;/em&gt;&lt;sub&gt;0&lt;/sub&gt; ; &lt;em&gt;a &lt;/em&gt;&lt;sub&gt;1&lt;/sub&gt; , &lt;em&gt;a &lt;/em&gt;&lt;sub&gt;2&lt;/sub&gt; ,&amp;hellip;], ( &lt;em&gt;P &lt;/em&gt;&lt;sub&gt;i&lt;/sub&gt; + &amp;radic;</target>
        </trans-unit>
        <trans-unit id="4338ffaceae0c24099d173ff2c9bfe4d749f97e7" translate="yes" xml:space="preserve">
          <source>= gcd(</source>
          <target state="translated">= gcd (</target>
        </trans-unit>
        <trans-unit id="6947818ac409551f11fbaa78f0ea6391960aa5b8" translate="yes" xml:space="preserve">
          <source>==</source>
          <target state="translated">==</target>
        </trans-unit>
        <trans-unit id="80cdd07910290457b081eafadcc6412b584e00f3" translate="yes" xml:space="preserve">
          <source>A 3-tuple.</source>
          <target state="translated">3- 튜플.</target>
        </trans-unit>
        <trans-unit id="1782b0769bc0794f66fe37be0e6e2b5095cfdace" translate="yes" xml:space="preserve">
          <source>Adds two polynomials and reduces their coefficients mod</source>
          <target state="translated">두 개의 다항식을 더하고 계수 mod를 줄입니다.</target>
        </trans-unit>
        <trans-unit id="d6dce062190a725f9378f9ddffe2e8beff5a7002" translate="yes" xml:space="preserve">
          <source>Algorithm 3.6.7 from &lt;em&gt;Prime Numbers: A Computational Perspective&lt;/em&gt; by Crandall &amp;amp; Pomerance (2&lt;sup&gt;nd&lt;/sup&gt; edition): Evaluation of a binary Lucas chain.  To quote their description:</source>
          <target state="translated">3.6.7 알고리즘에서 &lt;em&gt;프라임 번호 : 연산 관점&lt;/em&gt; 랜달 및 Pomerance (2 의한 &lt;sup&gt;ND&lt;/sup&gt; 판) : 이진 루카스 쇄의 평가. 설명을 인용하려면 :</target>
        </trans-unit>
        <trans-unit id="38985f0c549afe30d53b4af28251e9c8da4ca5e4" translate="yes" xml:space="preserve">
          <source>Case 1:</source>
          <target state="translated">사례 1 :</target>
        </trans-unit>
        <trans-unit id="f8ec5cbd58e7c0b37a334f16283abc6b7d3385e8" translate="yes" xml:space="preserve">
          <source>Case 1a: If</source>
          <target state="translated">사례 1a : If</target>
        </trans-unit>
        <trans-unit id="a222a4dfe8a3b0d870d09894dab3f856e300b606" translate="yes" xml:space="preserve">
          <source>Case 1b: If</source>
          <target state="translated">사례 1b : If</target>
        </trans-unit>
        <trans-unit id="b71fc63f13f19028ba8bff4aa1f8b7999da99de6" translate="yes" xml:space="preserve">
          <source>Case 2:</source>
          <target state="translated">사례 2 :</target>
        </trans-unit>
        <trans-unit id="49241f887a7ca8258095000020fd32271e16ed35" translate="yes" xml:space="preserve">
          <source>Case 2a: If</source>
          <target state="translated">사례 2a : If</target>
        </trans-unit>
        <trans-unit id="bbfaaabe73c148e3d2946062a4906d0302d6d1e1" translate="yes" xml:space="preserve">
          <source>Case 2b: If</source>
          <target state="translated">사례 2b : If</target>
        </trans-unit>
        <trans-unit id="5b24dd2ab24f578129e90f8bd0303c05e5361a31" translate="yes" xml:space="preserve">
          <source>Case 3:</source>
          <target state="translated">사례 3 :</target>
        </trans-unit>
        <trans-unit id="2d6c1f774782efa9b4f6af5056c1a027477495d0" translate="yes" xml:space="preserve">
          <source>Case 4:</source>
          <target state="translated">사례 4 :</target>
        </trans-unit>
        <trans-unit id="9b4eecac5205ad9ea5741a08c395a55c34819821" translate="yes" xml:space="preserve">
          <source>Case 4a: If</source>
          <target state="translated">사례 4a : If</target>
        </trans-unit>
        <trans-unit id="df4114b917f3c8d37d9ed643e8b228a82e5032d2" translate="yes" xml:space="preserve">
          <source>Case 4b: If</source>
          <target state="translated">사례 4b : If</target>
        </trans-unit>
        <trans-unit id="a450ec02055b5afb4768084d98776055638bdf23" translate="yes" xml:space="preserve">
          <source>Checks whether</source>
          <target state="translated">확인 여부</target>
        </trans-unit>
        <trans-unit id="380d837572dc516226fdab2201b5176ba208d011" translate="yes" xml:space="preserve">
          <source>Compiles the output of</source>
          <target state="translated">출력을 컴파일합니다.</target>
        </trans-unit>
        <trans-unit id="ad88b5c709893b3c20a622a8af743326fc15e581" translate="yes" xml:space="preserve">
          <source>Computes</source>
          <target state="translated">계산</target>
        </trans-unit>
        <trans-unit id="7aaa81c08dfe664800463bbb7d2b2609be00f74f" translate="yes" xml:space="preserve">
          <source>Computes all square roots of</source>
          <target state="translated">모든 제곱근을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="b71f4915a8b78a90bf71f4feb80ae5bf3e75096c" translate="yes" xml:space="preserve">
          <source>Computes the</source>
          <target state="translated">계산</target>
        </trans-unit>
        <trans-unit id="5b1f10974661e4aae9ae54437fdc601067fd19cd" translate="yes" xml:space="preserve">
          <source>Computes the Dirichlet inverse of the input function</source>
          <target state="translated">입력 함수의 디리클레 역수를 계산합니다.</target>
        </trans-unit>
        <trans-unit id="45da31757146a27f1474566145d102920965af64" translate="yes" xml:space="preserve">
          <source>Computes the Riemann zeta function by applying</source>
          <target state="translated">다음을 적용하여 Riemann zeta 함수를 계산합니다.</target>
        </trans-unit>
        <trans-unit id="84ffdb0127b01fd0dfdcfdb8b0853e1e6660615e" translate="yes" xml:space="preserve">
          <source>Computes the conjugate of a partition.</source>
          <target state="translated">파티션의 켤레를 계산합니다.</target>
        </trans-unit>
        <trans-unit id="2f7e72f636868efcf3963c89554f4f3546b46b10" translate="yes" xml:space="preserve">
          <source>Computes the determinant of a matrix via the Schur determinant identity.</source>
          <target state="translated">Schur 행렬식 단위를 통해 행렬의 행렬식을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="fddddbff9f2631233edd5bf8d0829b1d0ccca918" translate="yes" xml:space="preserve">
          <source>Computes the discriminant of a polynomial.  The input list is ordered from lowest degree to highest &amp;mdash; i.e.,</source>
          <target state="translated">다항식의 판별을 계산합니다. 입력 목록은 가장 낮은 등급에서 가장 높은 등급으로 정렬됩니다.</target>
        </trans-unit>
        <trans-unit id="b13cdb1f9f2f8c15d7b68dc85b5079cb409f0d0b" translate="yes" xml:space="preserve">
          <source>Computes the greatest common monic divisor of the polynomials</source>
          <target state="translated">다항식의 최대 공약수를 계산합니다.</target>
        </trans-unit>
        <trans-unit id="70b1bcff0851db37b6ab48af870b18b4eb899e80" translate="yes" xml:space="preserve">
          <source>Computes the multiplicative order of</source>
          <target state="translated">곱셈 순서를 계산합니다.</target>
        </trans-unit>
        <trans-unit id="e6b1d2dbff4a02700db49061c1ccad62b0f984fa" translate="yes" xml:space="preserve">
          <source>Computes the number of primes &amp;le;</source>
          <target state="translated">소수의 수를 계산합니다 &amp;le;</target>
        </trans-unit>
        <trans-unit id="70313b568710e20bcdef3dc81d824005411e54b6" translate="yes" xml:space="preserve">
          <source>Computes the remainder when the polynomial</source>
          <target state="translated">다항식이 다음과 같은 경우 나머지를 계산합니다.</target>
        </trans-unit>
        <trans-unit id="e4e418400d07ed96420a73081a8ab85a89f6efae" translate="yes" xml:space="preserve">
          <source>Computes the simple continued fraction for &amp;radic;</source>
          <target state="translated">&amp;radic;에 대한 단순 연속 분수를 계산합니다.</target>
        </trans-unit>
        <trans-unit id="06a5f586c2eb39fa66d2894fdc3bb97e1fc12155" translate="yes" xml:space="preserve">
          <source>Computes the zeros of a polynomial modulo an integer.  We do this by factoring the modulus, solving modulo the prime power factors, and putting the results back together via the Chinese Remainder Theorem.</source>
          <target state="translated">정수 모듈로 다항식의 0을 계산합니다. 우리는 계수를 인수 분해하고, 주요 역률을 계수로 풀고, 중국 나머지 정리를 통해 결과를 다시 합쳐서이를 수행합니다.</target>
        </trans-unit>
        <trans-unit id="4956ed652a1c6f51cec0f6e694b55d17d33de8a7" translate="yes" xml:space="preserve">
          <source>Computes with some semblance of efficiency the number of additive partitions of an integer.  The</source>
          <target state="translated">정수의 덧셈 분할 수를 효율성과 유사하게 계산합니다. 그만큼</target>
        </trans-unit>
        <trans-unit id="3a77df48c3f864a6b42116f2a3e15f1b92f8d260" translate="yes" xml:space="preserve">
          <source>Convergence acceleration for alternating series.  This is algorithm 1 from &lt;em&gt;Convergence Acceleration of Alternating Series&lt;/em&gt; by Cohen, Villegas, and Zagier &lt;a href=&quot;https://people.mpim-bonn.mpg.de/zagier/files/exp-math-9/fulltext.pdf&quot;&gt;(pdf)&lt;/a&gt;, with a minor tweak so that the &lt;em&gt;d&lt;/em&gt;-value isn&amp;rsquo;t computed via floating point.</source>
          <target state="translated">교대 시리즈에 대한 수렴 가속. 이것은 Cohen, Villegas 및 Zagier &lt;em&gt;의 Convergence Acceleration of Alternating Series &lt;/em&gt;&lt;a href=&quot;https://people.mpim-bonn.mpg.de/zagier/files/exp-math-9/fulltext.pdf&quot;&gt;(pdf)의&lt;/a&gt; 알고리즘 1 이며, &lt;em&gt;d&lt;/em&gt; 값이 부동 소수점을 통해 계산되지 않도록 약간 조정했습니다 .</target>
        </trans-unit>
        <trans-unit id="868ee34edfb003b759b6277c74f7c0b97d444d92" translate="yes" xml:space="preserve">
          <source>Counts the number of divisors of</source>
          <target state="translated">약수의 수를 계산</target>
        </trans-unit>
        <trans-unit id="50c9e8d5fc98727b4bbc93cf5d64a68db647f04f" translate="yes" xml:space="preserve">
          <source>D</source>
          <target state="translated">디</target>
        </trans-unit>
        <trans-unit id="0562f32dc56f5c702810cbe010068ddd38dbd69a" translate="yes" xml:space="preserve">
          <source>Dependencies</source>
          <target state="translated">의존성</target>
        </trans-unit>
        <trans-unit id="e28be8ee29e21096adf6d89d6fffac95ddaa18af" translate="yes" xml:space="preserve">
          <source>Divides the polynomial</source>
          <target state="translated">다항식을 나눕니다.</target>
        </trans-unit>
        <trans-unit id="40f7c422e533a5dba78c4675c7771558df18fb63" translate="yes" xml:space="preserve">
          <source>Efficiently computed the</source>
          <target state="translated">효율적으로 계산</target>
        </trans-unit>
        <trans-unit id="6f70b9a168f5b545c989cf3a4158ce307cfc5f6a" translate="yes" xml:space="preserve">
          <source>Efficiently computes the</source>
          <target state="translated">효율적으로 계산</target>
        </trans-unit>
        <trans-unit id="c79cfad0cd9fc1efb605194c6bd5201bdc78b768" translate="yes" xml:space="preserve">
          <source>Efficiently extracts the</source>
          <target state="translated">효율적으로 추출</target>
        </trans-unit>
        <trans-unit id="1b735210ec0711a77faa327c9d6a3e0c153f226e" translate="yes" xml:space="preserve">
          <source>Efficiently extracts the nth Fibonacci number modulo</source>
          <target state="translated">n 번째 피보나치 수를 모듈로 효율적으로 추출</target>
        </trans-unit>
        <trans-unit id="76daf7900317f7abf520a1e4a2b4b5b2dc6ddf73" translate="yes" xml:space="preserve">
          <source>Efficiently generates an integer selected uniformly from the range [1,</source>
          <target state="translated">[1,1] 범위에서 균일하게 선택된 정수를 효율적으로 생성합니다.</target>
        </trans-unit>
        <trans-unit id="42ca14cfd4cae0581ea916c6f1594ad56a1df12d" translate="yes" xml:space="preserve">
          <source>Evaluates a polynomial at a particular point, optionally modulo something.</source>
          <target state="translated">특정 지점에서 다항식을 평가하고 선택적으로 무언가를 모듈로합니다.</target>
        </trans-unit>
        <trans-unit id="8b63f3d72cb6c84d8aa9c2f9b5cdfac25b053939" translate="yes" xml:space="preserve">
          <source>Evaluates a string in reverse Polish notation.  The acceptable binary operators are</source>
          <target state="translated">역 폴란드 표기법으로 문자열을 평가합니다. 허용되는 이항 연산자는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9f45020f0002b90bc4cba364abf6bfb470d1b5da" translate="yes" xml:space="preserve">
          <source>Extended Euclidean altorithm: returns a tuple (</source>
          <target state="translated">확장 된 유클리드 altorithm : 튜플 (</target>
        </trans-unit>
        <trans-unit id="e09a8a0654b6fa8b1ac79728874341d2fcc002e7" translate="yes" xml:space="preserve">
          <source>Extra strong Lucas probable primality test as described on Wikipedia.  Its false positives are a strict subset of those for</source>
          <target state="translated">Wikipedia에 설명 된대로 매우 강력한 Lucas 가능한 소수성 테스트입니다. 잘못된 긍정은 다음에 대한 엄격한 하위 집합입니다.</target>
        </trans-unit>
        <trans-unit id="755583209467b74b108f8173066d287285913679" translate="yes" xml:space="preserve">
          <source>Factors an integer via the multiple-polynomial quadratic sieve.  Most of this function is copied verbatim from &lt;a href=&quot;https://codegolf.stackexchange.com/a/9088&quot;&gt;https://codegolf.stackexchange.com/a/9088&lt;/a&gt;.</source>
          <target state="translated">다중 다항식 2 차 체를 통해 정수를 인수 분해합니다. 이 함수의 대부분은 &lt;a href=&quot;https://codegolf.stackexchange.com/a/9088&quot;&gt;https://codegolf.stackexchange.com/a/9088&lt;/a&gt; 에서 그대로 복사됩니다 .</target>
        </trans-unit>
        <trans-unit id="aa9969810c269380b8228efaa8c405afadd239c4" translate="yes" xml:space="preserve">
          <source>Factors integers using Brent&amp;rsquo;s variation of Pollard&amp;rsquo;s rho algorithm.  If</source>
          <target state="translated">Brent의 Pollard의 rho 알고리즘 변형을 사용하여 정수를 인수 분해합니다. 만약</target>
        </trans-unit>
        <trans-unit id="c35602376c7ffa9efe97e8890d60ce2d999e78e6" translate="yes" xml:space="preserve">
          <source>Fermat&amp;rsquo;s primality test.</source>
          <target state="translated">Fermat의 소수성 검정.</target>
        </trans-unit>
        <trans-unit id="558a4d2dc169dc8bc6101e6bf8955d89cfb2a5d6" translate="yes" xml:space="preserve">
          <source>Finds &lt;em&gt;x&lt;/em&gt; such that &lt;em&gt;x&lt;/em&gt;&lt;sup&gt;2&lt;/sup&gt; &amp;equiv;</source>
          <target state="translated">발견은 &lt;em&gt;X&lt;/em&gt; 되도록 &lt;em&gt;X &lt;/em&gt;&lt;sup&gt;2&lt;/sup&gt; &amp;equiv;</target>
        </trans-unit>
        <trans-unit id="b686567435c207d22564a0533b8ee5df789dc981" translate="yes" xml:space="preserve">
          <source>For a sequence &lt;em&gt;x&lt;/em&gt;&lt;sub&gt;0&lt;/sub&gt;, &lt;em&gt;x&lt;/em&gt;&lt;sub&gt;1&lt;/sub&gt;, &amp;hellip; with a rule for computing &lt;em&gt;x&lt;/em&gt;&lt;sub&gt;2j&lt;/sub&gt; from &lt;em&gt;x&lt;/em&gt;&lt;sub&gt;j&lt;/sub&gt; and a rule for computing &lt;em&gt;x&lt;/em&gt;&lt;sub&gt;2j+1&lt;/sub&gt; from &lt;em&gt;x&lt;/em&gt;&lt;sub&gt;j&lt;/sub&gt; and &lt;em&gt;x&lt;/em&gt;&lt;sub&gt;j+1&lt;/sub&gt;, this algorithm computes (&lt;em&gt;x&lt;/em&gt;&lt;sub&gt;n&lt;/sub&gt;, &lt;em&gt;x&lt;/em&gt;&lt;sub&gt;n+1&lt;/sub&gt;) for a given positive integer &lt;em&gt;n&lt;/em&gt;.  We have &lt;em&gt;n&lt;/em&gt; in binary as (&lt;em&gt;n&lt;/em&gt;&lt;sub&gt;0&lt;/sub&gt;, &lt;em&gt;n&lt;/em&gt;&lt;sub&gt;1&lt;/sub&gt;, &amp;hellip;, &lt;em&gt;n&lt;/em&gt;&lt;sub&gt;b-1&lt;/sub&gt;) with &lt;em&gt;n&lt;/em&gt;&lt;sub&gt;0&lt;/sub&gt; being the low-order bit.  We write the rules as follows: &lt;em&gt;x&lt;/em&gt;&lt;sub&gt;2j&lt;/sub&gt; = op1(&lt;em&gt;x&lt;/em&gt;&lt;sub&gt;j&lt;/sub&gt;) and &lt;em&gt;x&lt;/em&gt;&lt;sub&gt;2j+1&lt;/sub&gt; = op2(&lt;em&gt;x&lt;/em&gt;&lt;sub&gt;j&lt;/sub&gt;, &lt;em&gt;x&lt;/em&gt;&lt;sub&gt;j+1&lt;/sub&gt;).</source>
          <target state="translated">시퀀스를 들어 &lt;em&gt;X &lt;/em&gt;&lt;sub&gt;0&lt;/sub&gt; , &lt;em&gt;X &lt;/em&gt;&lt;sub&gt;(1)를&lt;/sub&gt; 계산하는 규칙 ... &lt;em&gt;X의 &lt;/em&gt;&lt;sub&gt;2J&lt;/sub&gt; 에서 &lt;em&gt;의 X &lt;/em&gt;&lt;sub&gt;J&lt;/sub&gt; 및 연산 규칙 &lt;em&gt;X &lt;/em&gt;&lt;sub&gt;2J + 1&lt;/sub&gt; 에서 &lt;em&gt;의 X &lt;/em&gt;&lt;sub&gt;J&lt;/sub&gt; 및 &lt;em&gt;X &lt;/em&gt;&lt;sub&gt;J + 1&lt;/sub&gt; 이 알고리즘 계산하여 ( &lt;em&gt;X는 &lt;/em&gt;&lt;sub&gt;N&lt;/sub&gt; , &lt;em&gt;X &lt;/em&gt;&lt;sub&gt;, N + 1&lt;/sub&gt; ) 주어진 양의 정수 &lt;em&gt;n에 대해&lt;/em&gt; . 우리가 &lt;em&gt;N&lt;/em&gt; 으로 진수 ( &lt;em&gt;n은 &lt;/em&gt;&lt;sub&gt;0&lt;/sub&gt; , &lt;em&gt;n은 &lt;/em&gt;&lt;sub&gt;1&lt;/sub&gt; , ..., &lt;em&gt;N &lt;/em&gt;&lt;sub&gt;, B-1&lt;/sub&gt; )와 &lt;em&gt;N &lt;/em&gt;&lt;sub&gt;0&lt;/sub&gt; 하위 비트 인. 우리는 다음과 같이 규칙을 작성합니다.&lt;em&gt;x &lt;/em&gt;&lt;sub&gt;2j&lt;/sub&gt; = op1 ( &lt;em&gt;x &lt;/em&gt;&lt;sub&gt;j&lt;/sub&gt; ) 및 &lt;em&gt;x &lt;/em&gt;&lt;sub&gt;2j + 1&lt;/sub&gt; = op2 ( &lt;em&gt;x &lt;/em&gt;&lt;sub&gt;j&lt;/sub&gt; , &lt;em&gt;x &lt;/em&gt;&lt;sub&gt;j + 1&lt;/sub&gt; ).</target>
        </trans-unit>
        <trans-unit id="82e0d55e71d19ecac7cb12bebf6d2777fc0662cf" translate="yes" xml:space="preserve">
          <source>For non-negative</source>
          <target state="translated">음수가 아닌 경우</target>
        </trans-unit>
        <trans-unit id="e3037e63bf6849b84a9a65234ff16b35b8d4cade" translate="yes" xml:space="preserve">
          <source>Fraction</source>
          <target state="translated">분수</target>
        </trans-unit>
        <trans-unit id="2b961dea1dc0c60ddf9a2c8e9d090f6f7d082483" translate="yes" xml:space="preserve">
          <source>Functions</source>
          <target state="translated">기능</target>
        </trans-unit>
        <trans-unit id="7b9e3da59754229c2f32e74a42b577b4422f4918" translate="yes" xml:space="preserve">
          <source>Generates all</source>
          <target state="translated">모두 생성</target>
        </trans-unit>
        <trans-unit id="22d7ccb6d14fc4cee74c0160cabca76bfa59b245" translate="yes" xml:space="preserve">
          <source>Generates all Pythagorean triples of a given perimeter by examining the perimeter&amp;rsquo;s factors.</source>
          <target state="translated">둘레의 요인을 조사하여 지정된 둘레의 모든 피타고라스 트리플을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="20981a6085339e916312afca4c42cb21b29b3435" translate="yes" xml:space="preserve">
          <source>Generates all natural numbers that evenly divide</source>
          <target state="translated">균등하게 나누는 모든 자연수를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="d7b6cb7b6197706c909fd79e098d52255b952bca" translate="yes" xml:space="preserve">
          <source>Generates all ordered</source>
          <target state="translated">모든 주문 생성</target>
        </trans-unit>
        <trans-unit id="b5bc0df54325689a6ed5d8e44d009cbaf25e1e56" translate="yes" xml:space="preserve">
          <source>Generates all shortest Egyptian fractions for</source>
          <target state="translated">에 대한 모든 가장 짧은 이집트 분수를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="3674e97303aab2ce4c8cb585b3c01cfb064409d3" translate="yes" xml:space="preserve">
          <source>Generates partitions of integers in ascending order via an iterative algorithm.  It is the fastest known algorithm as of June 2014.</source>
          <target state="translated">반복 알고리즘을 통해 오름차순으로 정수 파티션을 생성합니다. 2014 년 6 월 현재 알려진 가장 빠른 알고리즘입니다.</target>
        </trans-unit>
        <trans-unit id="4f361d97a211e6e4027fd04a5730593d8e693bec" translate="yes" xml:space="preserve">
          <source>Generates primes less than the given limit (which may be infinite) lazily via a segmented sieve of Eratosthenes.  Uses O(&amp;radic;&lt;em&gt;p&lt;/em&gt;) memory, where &lt;em&gt;p&lt;/em&gt; is the most recently yielded prime.</source>
          <target state="translated">에라토스테네스의 분할 된 체를 통해 주어진 한계 (무한 할 수 있음)보다 작은 소수를 느리게 생성합니다. O (&amp;radic; &lt;em&gt;p&lt;/em&gt; ) 메모리를 사용합니다. 여기서 &lt;em&gt;p&lt;/em&gt; 는 가장 최근에 산출 된 소수입니다.</target>
        </trans-unit>
        <trans-unit id="16934eba3976ff01419c058e6df6c8af103e1657" translate="yes" xml:space="preserve">
          <source>Generates some sequences related to simple continued fractions of certain quadratic surds.  A helper function for</source>
          <target state="translated">특정 2 차 곡선의 단순 연속 분수와 관련된 일부 시퀀스를 생성합니다. 에 대한 도우미 기능</target>
        </trans-unit>
        <trans-unit id="5ec34d045dbcf19d83dead6f9fa5a6d49578ccf9" translate="yes" xml:space="preserve">
          <source>Generates the Collatz sequence initiated by</source>
          <target state="translated">다음에 의해 시작된 Collatz 시퀀스를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="46036a496172f9e7e59c4720ac28f38377a5a3ae" translate="yes" xml:space="preserve">
          <source>Generates the Farey sequence of maximum denominator</source>
          <target state="translated">최대 분모의 Farey 시퀀스를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="2966c2d3959f388c9f4c373f0c4789924fb35dac" translate="yes" xml:space="preserve">
          <source>Generates the Fibonacci numbers, starting with 0 and 1.</source>
          <target state="translated">0과 1로 시작하는 피보나치 수를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="a4d7c7b387f01b698c992b18b6cdbbeb8857ce38" translate="yes" xml:space="preserve">
          <source>Generates the Lucas U- and V-sequences with parameters (</source>
          <target state="translated">매개 변수 ()를 사용하여 Lucas U- 및 V- 시퀀스를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="348058674896d7698ade218b645e78aa719f733f" translate="yes" xml:space="preserve">
          <source>Generates the convergents of a simple continued fraction.</source>
          <target state="translated">단순 연속 분수의 수렴을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="03b9c7acd70153ae6f6f9b6383547d14ca22b12d" translate="yes" xml:space="preserve">
          <source>Generates the divisors of</source>
          <target state="translated">제수를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="77d96cd973f5fcc356d7ea61e98fc0354ef923eb" translate="yes" xml:space="preserve">
          <source>Generates the positive solutions of &lt;em&gt;x&lt;/em&gt;&lt;sup&gt;2&lt;/sup&gt; -</source>
          <target state="translated">의 긍정적 인 솔루션을 생성 &lt;em&gt;X &lt;/em&gt;&lt;sup&gt;2&lt;/sup&gt; -</target>
        </trans-unit>
        <trans-unit id="a2cedf2f0905a16cb97355e0f89e09a9b9e2ced4" translate="yes" xml:space="preserve">
          <source>Generates the powerset of a list, tuple, or string.  The yielded objects are always lists.</source>
          <target state="translated">목록, 튜플 또는 문자열의 거듭 제곱을 생성합니다. 산출 된 객체는 항상 목록입니다.</target>
        </trans-unit>
        <trans-unit id="d3d1a5db6f2fcf2d35cde613a5cf1b3ebe6d1ef0" translate="yes" xml:space="preserve">
          <source>Generates the sequence of perfect powers without multiplicity.</source>
          <target state="translated">다중성없이 완벽한 거듭 제곱의 시퀀스를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="9927c93125a447795cdb56a5b70e090d7a59152a" translate="yes" xml:space="preserve">
          <source>Generates the squarefree products of elements of</source>
          <target state="translated">다음 요소의 제곱없는 곱을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="48a914e25af552022c46aa19f9aad423ebb78585" translate="yes" xml:space="preserve">
          <source>Generates the squarefree products of the elements of</source>
          <target state="translated">다음 요소의 제곱이없는 곱을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="61e266b2da8f4d9e3228c6d44639b6b4b9d9c574" translate="yes" xml:space="preserve">
          <source>Generates with some efficiency and without multiplicity the zeros of a polynomial modulo a prime.  Coded after algorithm 2.3.10 from &lt;em&gt;Prime Numbers: A Computational Perspective&lt;/em&gt; by Crandall &amp;amp; Pomerance (2&lt;sup&gt;nd&lt;/sup&gt; edition), which is essentially Cantor-Zassenhaus.</source>
          <target state="translated">다항식 모듈로 프라임의 0을 다중성없이 약간의 효율성으로 생성합니다. &lt;em&gt;Prime Numbers : A Computational Perspective&lt;/em&gt; by &lt;em&gt;Prime Numbers : A Computational Perspective&lt;/em&gt; by Crandall &amp;amp; Pomerance ( &lt;sup&gt;2nd&lt;/sup&gt; edition), 이는 본질적으로 Cantor-Zassenhaus 인 알고리즘 2.3.10 이후에 코딩되었습니다 .</target>
        </trans-unit>
        <trans-unit id="afdca067c762eb09ba18fe097a8a14944b2cd94b" translate="yes" xml:space="preserve">
          <source>Generator of parameters to use for</source>
          <target state="translated">사용할 매개 변수 생성기</target>
        </trans-unit>
        <trans-unit id="6756ef06769b67757cfb7a54a00557c41b55378c" translate="yes" xml:space="preserve">
          <source>Given integers</source>
          <target state="translated">주어진 정수</target>
        </trans-unit>
        <trans-unit id="a05c89fdecd6337e222ba902e607265c0a919d19" translate="yes" xml:space="preserve">
          <source>Grantham&amp;rsquo;s general Frobenius probable primality test, in both the strong and weak versions, as described in &lt;a href=&quot;https://doi.org/10.1090/S0025-5718-00-01197-2&quot;&gt;his paper introducing the test&lt;/a&gt;.</source>
          <target state="translated">Grantham의 일반적인 Frobenius 가능한 소수성 검정 &lt;a href=&quot;https://doi.org/10.1090/S0025-5718-00-01197-2&quot;&gt;은 검정을 소개하는 그의 논문에&lt;/a&gt; 설명 된대로 강하고 약한 버전 모두에서 가능합니다 .</target>
        </trans-unit>
        <trans-unit id="2a2772645729065942d0eadaa12ba2597a7ce381" translate="yes" xml:space="preserve">
          <source>Greatest common divisor of any number of values.</source>
          <target state="translated">모든 값의 최대 공약수입니다.</target>
        </trans-unit>
        <trans-unit id="d5538fdacd40c229580844c50a0e84640071e8d2" translate="yes" xml:space="preserve">
          <source>Greatest integer &lt;em&gt;k&lt;/em&gt; such that</source>
          <target state="translated">다음 과 같은 가장 큰 정수 &lt;em&gt;k&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6f381fc48bf71efac0b87be50ca0395b1bcdb0e3" translate="yes" xml:space="preserve">
          <source>Greatest integer whose square is &amp;le;</source>
          <target state="translated">제곱이 &amp;le; 인 최대 정수</target>
        </trans-unit>
        <trans-unit id="8a9786aebdf4baf47c580d618ffbf95fee7af8a8" translate="yes" xml:space="preserve">
          <source>Helper function for</source>
          <target state="translated">도우미 기능</target>
        </trans-unit>
        <trans-unit id="751c68a3471b1c791efaee0a8e7c24ea0c266efd" translate="yes" xml:space="preserve">
          <source>If</source>
          <target state="translated">만약</target>
        </trans-unit>
        <trans-unit id="74a544b60062e69929a114bf0936c5b792215936" translate="yes" xml:space="preserve">
          <source>If the number of solutions if infinite and the equation is nondegenerate, it is</source>
          <target state="translated">해의 수가 무한하고 방정식이 퇴화되지 않으면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3601acab0087a6f1de36dbe7e247c1336341803c" translate="yes" xml:space="preserve">
          <source>If the number of solutions is finite, it is</source>
          <target state="translated">해의 수가 유한 한 경우</target>
        </trans-unit>
        <trans-unit id="4c45f1494010a75938699a86ca9f35b4af612c35" translate="yes" xml:space="preserve">
          <source>If the number of solutions is infinite and the equation is degenerate, it&amp;rsquo;s</source>
          <target state="translated">해의 수가 무한하고 방정식이 퇴화되면</target>
        </trans-unit>
        <trans-unit id="79d70dcb4f9ee8b7d94ed9539586cc73c0d399da" translate="yes" xml:space="preserve">
          <source>Input:</source>
          <target state="translated">입력:</target>
        </trans-unit>
        <trans-unit id="48558cde54ab4e31d9a52d6e368c01422d284be7" translate="yes" xml:space="preserve">
          <source>Integer factoring function.  Uses Pollard&amp;rsquo;s p-1 algorithm.  Note that this is only efficient if the number to be factored has a prime factor &lt;em&gt;p&lt;/em&gt; such that &lt;em&gt;p&lt;/em&gt;-1&amp;rsquo;s largest prime factor is &amp;ldquo;small&amp;rdquo;.</source>
          <target state="translated">정수 분해 함수. Pollard의 p-1 알고리즘을 사용합니다. 인수 분해 할 숫자에 &lt;em&gt;p&lt;/em&gt; -1의 가장 큰 소인수가 &quot;작은&quot; 것과 같은 소인수 &lt;em&gt;p&lt;/em&gt; 가있는 경우에만 효율적 입니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="58aee54e766c3d0648fe443ab71a1c4404a30692" translate="yes" xml:space="preserve">
          <source>Integer factoring function.  Uses Williams&amp;rsquo; p+1 algorithm, single-stage variant.  Note that this is only efficient when the number to be factored has a prime factor &lt;em&gt;p&lt;/em&gt; such that &lt;em&gt;p&lt;/em&gt;+1&amp;rsquo;s largest prime factor is &amp;ldquo;small&amp;rdquo;.</source>
          <target state="translated">정수 분해 함수. Williams의 p + 1 알고리즘, 단일 단계 변형을 사용합니다. 인수 분해 할 숫자에 &lt;em&gt;p&lt;/em&gt; +1의 가장 큰 소인수가 &quot;작은&quot; 것과 같은 소인수 &lt;em&gt;p&lt;/em&gt; 가있는 경우에만 효율적 입니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="eb92da6cfaf48f911b1e397ac93a72e926d82c77" translate="yes" xml:space="preserve">
          <source>Integer factoring function.  Uses several methods in parallel.  Waits for one of them to return, kills the rest, and reports.</source>
          <target state="translated">정수 분해 함수. 여러 방법을 병렬로 사용합니다. 그들 중 하나가 돌아올 때까지 기다렸다가 나머지를 죽이고보고합니다.</target>
        </trans-unit>
        <trans-unit id="36b9a195ec43bf4e36c9d0dbe3c68ca3b21e4977" translate="yes" xml:space="preserve">
          <source>Integer factoring via elliptic curves using the two-phase algorithm on Montgomery curves, and optionally uses multiple processes.  This is a shell function that repeatedly calls</source>
          <target state="translated">몽고메리 곡선에서 2 단계 알고리즘을 사용하는 타원 곡선을 통한 정수 인수 분해 및 선택적으로 여러 프로세스를 사용합니다. 이것은 반복적으로 호출하는 쉘 함수입니다.</target>
        </trans-unit>
        <trans-unit id="d950c89d45f2f17330d4a332dbacd4261edaedc3" translate="yes" xml:space="preserve">
          <source>Jordan&amp;rsquo;s totient function: the number of</source>
          <target state="translated">요르단의 끈질긴 기능 : 수</target>
        </trans-unit>
        <trans-unit id="c0dae73b357c71b4181bcabbe5d70a17d3268e2c" translate="yes" xml:space="preserve">
          <source>Largest prime strictly less than</source>
          <target state="translated">가장 큰 소수</target>
        </trans-unit>
        <trans-unit id="c55e3aef5e32189be393ed862c0ceb6f582486d0" translate="yes" xml:space="preserve">
          <source>Legendre symbol (</source>
          <target state="translated">르장 드르 기호 (</target>
        </trans-unit>
        <trans-unit id="b7b70cfe63de1ef2240623cc22aef298e95de6a5" translate="yes" xml:space="preserve">
          <source>Legendre&amp;rsquo;s phi function.  Helper function for</source>
          <target state="translated">르장 드르의 파이 함수. 도우미 기능</target>
        </trans-unit>
        <trans-unit id="0b27b9e0b34d6576fc9dbd960ff42a117b81e70c" translate="yes" xml:space="preserve">
          <source>Lucas probable primality test as described in &lt;em&gt;Prime Numbers: A Computational Perspective&lt;/em&gt; by Crandall &amp;amp; Pomerance (2&lt;sup&gt;nd&lt;/sup&gt; edition).</source>
          <target state="translated">에 설명 된대로 솟수 가능성 테스트 루카스 &lt;em&gt;전산 관점 : 국무 번호&lt;/em&gt; 크 랜달 &amp;amp; Pomerance (2 &lt;sup&gt;차&lt;/sup&gt; 판).</target>
        </trans-unit>
        <trans-unit id="de85192de03e3d43986a9c427bfca218b75f30da" translate="yes" xml:space="preserve">
          <source>Miller&amp;rsquo;s primality test.  If the extended Riemann hypothesis (the one about Dirichlet L-functions) is true, then this test is deterministic.</source>
          <target state="translated">Miller의 소수성 테스트. 확장 된 리만 가설 (디리클레 L- 함수에 관한 가설)이 참이면이 검정은 결정적입니다.</target>
        </trans-unit>
        <trans-unit id="bab38cd4e545470c7e853f0da105b99b830768c5" translate="yes" xml:space="preserve">
          <source>Miller-Rabin probable primality test.</source>
          <target state="translated">Miller-Rabin 가능한 소수성 검정.</target>
        </trans-unit>
        <trans-unit id="e68c66d68ccfd8c95781dbee10e00aff4655ac5a" translate="yes" xml:space="preserve">
          <source>Module for basic math in the general vicinity of computational number theory</source>
          <target state="translated">전산 수 이론의 일반적인 주변에서 기초 수학을위한 모듈</target>
        </trans-unit>
        <trans-unit id="46e698ab572623f8f0ad02eff524bd00be815263" translate="yes" xml:space="preserve">
          <source>Multiplies the polynomials</source>
          <target state="translated">다항식을 곱합니다.</target>
        </trans-unit>
        <trans-unit id="b51a60734da64be0e618bacbea2865a8a7dcd669" translate="yes" xml:space="preserve">
          <source>N</source>
          <target state="translated">엔</target>
        </trans-unit>
        <trans-unit id="6eef6648406c333a4035cd5e60d0bf2ecf2606d7" translate="yes" xml:space="preserve">
          <source>None</source>
          <target state="translated">없음</target>
        </trans-unit>
        <trans-unit id="4b290a83942f6f4f2844b1da336895999527b694" translate="yes" xml:space="preserve">
          <source>Note that we can check the infinitude of solutions by calling</source>
          <target state="translated">다음을 호출하여 솔루션의 무한 성을 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f3c8c95c5e534bcd2ea0034a0d83177efa6923f4" translate="yes" xml:space="preserve">
          <source>Output:</source>
          <target state="translated">산출:</target>
        </trans-unit>
        <trans-unit id="511993d3c99719e38a6779073019dacd7178ddb9" translate="yes" xml:space="preserve">
          <source>P</source>
          <target state="translated">피</target>
        </trans-unit>
        <trans-unit id="29759bca1bfc18757b044f77226b0cf5f29e7563" translate="yes" xml:space="preserve">
          <source>Produces an integer that should be rather close to the</source>
          <target state="translated">다소 가까운 정수를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="b29a525c144146bbd16fe9aea49b986119d89719" translate="yes" xml:space="preserve">
          <source>Product of the elements of a list.  The product of the empty list is 1.  We use a binary algorithm because this can easily generate huge numbers, and calling</source>
          <target state="translated">목록 요소의 곱. 빈 목록의 곱은 1입니다.이 알고리즘은 쉽게 큰 수를 생성 할 수 있으므로 이진 알고리즘을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="efa50f19205b93213ecf483dedf5829a87e91fa3" translate="yes" xml:space="preserve">
          <source>Product of the elements of any iterable.  The product of an empty iterable is 1.</source>
          <target state="translated">반복 가능한 요소의 곱. 빈 이터 러블의 곱은 1입니다.</target>
        </trans-unit>
        <trans-unit id="c3156e00d3c2588c639e0d3cf6821258b05761c7" translate="yes" xml:space="preserve">
          <source>Q</source>
          <target state="translated">큐</target>
        </trans-unit>
        <trans-unit id="4fc743668b1979c9eb68fd8f734e4c967cd38b2b" translate="yes" xml:space="preserve">
          <source>Quadratic Frobenius probable primality test as described in &lt;em&gt;Prime Numbers: A Computational Perspective&lt;/em&gt; by Crandall &amp;amp; Pomerance (2&lt;sup&gt;nd&lt;/sup&gt; edition).</source>
          <target state="translated">&lt;em&gt;Prime Numbers : A Computational Perspective&lt;/em&gt; by Crandall &amp;amp; Pomerance ( &lt;sup&gt;2nd&lt;/sup&gt; edition)에 설명 된 2 차 프로 베니 우스 확률 소수 검정 .</target>
        </trans-unit>
        <trans-unit id="9d1e4e7d27b519b1da3d7266c9c87d7861741080" translate="yes" xml:space="preserve">
          <source>References:</source>
          <target state="translated">참조 :</target>
        </trans-unit>
        <trans-unit id="8660d17bd0736a98f236fde1aca942b73dd2ccfc" translate="yes" xml:space="preserve">
          <source>Returns a random prime with the specified number of digits when rendered in the specified base.</source>
          <target state="translated">지정된 밑수로 렌더링 될 때 지정된 자릿수를 가진 임의의 소수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="bce41a017cbfed81decffd172816cfe1b081112d" translate="yes" xml:space="preserve">
          <source>Returns in a sorted list all cube roots of a mod p.  There are a bunch of easily-computed special formulae for various cases with p != 1 (mod 9); we do those first, and then if p == 1 (mod 9) we use Algorithm 4.2 in &lt;a href=&quot;https://doi.org/10.1016/S0893-9659(02)00031-9&quot;&gt;Taking Cube Roots in Zm&lt;/a&gt; by Padro and Saez, which is essentially a variation on the Tonelli-Shanks algorithm for modular square roots.</source>
          <target state="translated">mod p의 모든 세제곱근을 정렬 된 목록으로 반환합니다. p! = 1 (mod 9) 인 다양한 경우에 대해 쉽게 계산할 수있는 특수 공식이 많이 있습니다. 먼저이를 수행 한 다음 p == 1 (mod 9) 이면 Padro와 Saez의 &lt;a href=&quot;https://doi.org/10.1016/S0893-9659(02)00031-9&quot;&gt;Zm에서 Cube Roots 가져 오기&lt;/a&gt; 에서 Algorithm 4.2를 사용합니다 . 이는 본질적으로 모듈 제곱근에 대한 Tonelli-Shanks 알고리즘의 변형입니다.</target>
        </trans-unit>
        <trans-unit id="749c2334f29b2b96a440124d9ec5143c2f80d479" translate="yes" xml:space="preserve">
          <source>Returns the</source>
          <target state="translated">를 반환</target>
        </trans-unit>
        <trans-unit id="2788429877dc75f10653f8ea57742f65c3ac55e8" translate="yes" xml:space="preserve">
          <source>Returns the inverse of</source>
          <target state="translated">역수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="0aa9e156d1f9731381ea0988d61a0728f288e68a" translate="yes" xml:space="preserve">
          <source>Returns the neighbors of</source>
          <target state="translated">이웃을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="67135413b63a47ee49da0a9ed089467cc6bcdd3c" translate="yes" xml:space="preserve">
          <source>Returns the simple continued fraction of the rational number</source>
          <target state="translated">유리수의 단순 연속 분수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="8c64af7b91288bff547b95c2aa90b790e222d803" translate="yes" xml:space="preserve">
          <source>Returns the unique integer &lt;em&gt;c&lt;/em&gt; in</source>
          <target state="translated">고유 한 정수 &lt;em&gt;c&lt;/em&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="c59986e700c366e985f8e3ee48529c1d17965b5b" translate="yes" xml:space="preserve">
          <source>Seeded elliptic curve factoring using the two-phase algorithm on Montgomery curves.  Helper function for</source>
          <target state="translated">몽고메리 곡선에서 2 단계 알고리즘을 사용한 시드 타원 곡선 인수 분해. 도우미 기능</target>
        </trans-unit>
        <trans-unit id="65b8b9fcdf7545aac85c52e7e388b3087ac70080" translate="yes" xml:space="preserve">
          <source>Smallest prime strictly greater than</source>
          <target state="translated">엄격하게 다음보다 큰 가장 작은 소수</target>
        </trans-unit>
        <trans-unit id="de0a3bbda725c026719a122e2ac2435b2d45b429" translate="yes" xml:space="preserve">
          <source>St&amp;oslash;rmer&amp;rsquo;s theorem asserts that for any given set</source>
          <target state="translated">St&amp;oslash;rmer의 정리는 주어진 세트에 대해</target>
        </trans-unit>
        <trans-unit id="68b73702d7c61d8767bea5b5ab04c609a72e7a8a" translate="yes" xml:space="preserve">
          <source>Strong lucas probable primality test as described on Wikipedia.  Its false positives are a strict subset of those for</source>
          <target state="translated">Wikipedia에 설명 된대로 강력한 lucas 가능한 소수성 검정. 잘못된 긍정은 다음에 대한 엄격한 하위 집합입니다.</target>
        </trans-unit>
        <trans-unit id="2d50307e0094ceb419bc2971529dc6eda018da0d" translate="yes" xml:space="preserve">
          <source>Subtracts the polynomial</source>
          <target state="translated">다항식을 뺍니다.</target>
        </trans-unit>
        <trans-unit id="8f4e86cae681e592003cc72f1c8d1513b4e109ac" translate="yes" xml:space="preserve">
          <source>Sum of divisors of a natural number, raised to the &lt;em&gt;x&lt;/em&gt;&lt;sup&gt;th&lt;/sup&gt; power.  The conventional notation for this in mathematical literature is &amp;sigma;&lt;sub&gt;x&lt;/sub&gt;(</source>
          <target state="translated">&lt;em&gt;x &lt;/em&gt;&lt;sup&gt;번째&lt;/sup&gt; 거듭 제곱으로 올린 자연수의 제수의 합입니다 . 수학적 문헌에서 이에 대한 일반적인 표기법은 &amp;sigma; &lt;sub&gt;x&lt;/sub&gt; (</target>
        </trans-unit>
        <trans-unit id="92f71fda590da013da7b5ceae7f8c11e51160c29" translate="yes" xml:space="preserve">
          <source>Sum of primes &amp;le;</source>
          <target state="translated">소수의 합 &amp;le;</target>
        </trans-unit>
        <trans-unit id="cba2993ee0873c0dedffdfe1947866288d3632db" translate="yes" xml:space="preserve">
          <source>Tests whether</source>
          <target state="translated">다음 여부를 테스트합니다.</target>
        </trans-unit>
        <trans-unit id="93ef0dd827103681fcee453b78be2ff14e1a261d" translate="yes" xml:space="preserve">
          <source>The</source>
          <target state="translated">그만큼</target>
        </trans-unit>
        <trans-unit id="ba85a0e5b134b7d75a0b949613cddca5205a81b2" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;n&lt;/em&gt;+1 primality test: given an odd integer</source>
          <target state="translated">&lt;em&gt;N&lt;/em&gt; +1 솟수 테스트 : 홀수 주어진</target>
        </trans-unit>
        <trans-unit id="ad4b8705f8a743bd1955ae17b730f84b84e4376c" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;n&lt;/em&gt;-1 primality test: given an odd integer</source>
          <target state="translated">&lt;em&gt;N&lt;/em&gt; -1 솟수 테스트 : 홀수 주어진</target>
        </trans-unit>
        <trans-unit id="bfffb2de1764c7f6c7b23cbc9dc9333da88d067e" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;new&lt;/em&gt; functions provided by this module are as follows.  Further details, including examples and input details, are available in docstrings and accessible via the built-in</source>
          <target state="translated">&lt;em&gt;새로운&lt;/em&gt; 이 모듈이 제공하는 기능은 다음이다. 예제 및 입력 세부 정보를 포함한 추가 세부 정보는 독 스트링에서 사용할 수 있으며 기본 제공</target>
        </trans-unit>
        <trans-unit id="61cbd33546ed0c084c047ff5de63c094329f4c2e" translate="yes" xml:space="preserve">
          <source>The Baille-Pomerance-Selfridge-Wagstaff probable primality test.  Infinitely many false positives are conjectured to exist, but none are known, and the test is known to be deterministic below 2&lt;sup&gt;64&lt;/sup&gt;.</source>
          <target state="translated">Baille-Pomerance-Selfridge-Wagstaff 가능성있는 원시성 검정. 무한히 많은 오탐이 존재하는 것으로 추측되지만 알려진 바가 없으며 테스트는 2 &lt;sup&gt;64&lt;/sup&gt; 미만에서 결정적인 것으로 알려져 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8ae06f07685c373d343c2d8dc504c27dfbb71b9a" translate="yes" xml:space="preserve">
          <source>The Carmichael lambda function: the smallest positive integer &lt;em&gt;m&lt;/em&gt; such that &lt;em&gt;a&lt;/em&gt;&lt;sup&gt;m&lt;/sup&gt; &amp;equiv; 1 (mod</source>
          <target state="translated">카 마이클 람다 함수 : 작은 양의 정수 &lt;em&gt;m&lt;/em&gt; 되도록 &lt;sup&gt;m&lt;/sup&gt; &amp;equiv; 1 (MOD&lt;em&gt;&lt;/em&gt;&lt;sup&gt;&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="8f70c2b99236794b977900e87bda53588a198add" translate="yes" xml:space="preserve">
          <source>The Jacobi symbol (</source>
          <target state="translated">Jacobi 기호 (</target>
        </trans-unit>
        <trans-unit id="a201857a7bfba2cda4b9019dcb967216941b4505" translate="yes" xml:space="preserve">
          <source>The Kronecker symbol (</source>
          <target state="translated">크로네 커 기호 (</target>
        </trans-unit>
        <trans-unit id="ccae17e449c4f4559e37143960d9af689cfcf0f2" translate="yes" xml:space="preserve">
          <source>The Liouville lambda function of</source>
          <target state="translated">Liouville 람다 함수</target>
        </trans-unit>
        <trans-unit id="7005a82346ec99ebf93da31928b3d867ac8b07f7" translate="yes" xml:space="preserve">
          <source>The Lucas-Lehmer test.  Deterministically and efficiently checks whether the Mersenne number 2&lt;sup&gt;p&lt;/sup&gt;-1 is prime.</source>
          <target state="translated">Lucas-Lehmer 테스트. Mersenne number 2 &lt;sup&gt;p&lt;/sup&gt; -1이 소수 인지 결정적이고 효율적으로 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="e907e6ac5e500335ae1de374215504e8e2e4c7c3" translate="yes" xml:space="preserve">
          <source>The M&amp;ouml;bius function of</source>
          <target state="translated">뫼비우스의 기능</target>
        </trans-unit>
        <trans-unit id="2e5f733ebaf9aef7c164ef4266c033dd458c2c41" translate="yes" xml:space="preserve">
          <source>The arithmetic derivative of</source>
          <target state="translated">산술 미분</target>
        </trans-unit>
        <trans-unit id="06a3a8763738b50b1bea9bc6ecc0b4944b0219f5" translate="yes" xml:space="preserve">
          <source>The binomial coefficient nCr(</source>
          <target state="translated">이항 계수 nCr (</target>
        </trans-unit>
        <trans-unit id="20bc83d44388278bb1eba7b31066e9cfcd434670" translate="yes" xml:space="preserve">
          <source>The general binary linear recursion.  Exactly like</source>
          <target state="translated">일반 이진 선형 재귀입니다. 정확히 좋아</target>
        </trans-unit>
        <trans-unit id="04eb27028fb2518326a0aeecde4bff1a8418d50b" translate="yes" xml:space="preserve">
          <source>The general homogeneous linear recursion.  If</source>
          <target state="translated">일반적인 동종 선형 재귀입니다. 만약</target>
        </trans-unit>
        <trans-unit id="8f9383265e796810dd164492e5d2c8daca1339a1" translate="yes" xml:space="preserve">
          <source>The general homogenous linear recursion: we generate in order the sequence defined by</source>
          <target state="translated">일반적인 동종 선형 재귀 : 다음에 정의 된 순서대로 생성합니다.</target>
        </trans-unit>
        <trans-unit id="1ec1aac1b9258807d33e9aeef54c422c605055ac" translate="yes" xml:space="preserve">
          <source>The greedy algorithm for Egyptian fraction expansion; also called the Fibonacci-Sylvester algorithm.</source>
          <target state="translated">이집트 분수 확장을위한 탐욕스러운 알고리즘; 피보나치-실베스터 알고리즘이라고도합니다.</target>
        </trans-unit>
        <trans-unit id="526c959fba4910931aebf2ea03ebd2ff252a4f3a" translate="yes" xml:space="preserve">
          <source>The least common multiple of any number of values.</source>
          <target state="translated">모든 값의 최소 공배수입니다.</target>
        </trans-unit>
        <trans-unit id="164b211a3a1e3dd384d29da09a5f523fe07a1c1c" translate="yes" xml:space="preserve">
          <source>The strong probable primality test (aka single-round Miller-Rabin).</source>
          <target state="translated">강력한 가능성있는 소수 테스트 (일명 단일 라운드 Miller-Rabin).</target>
        </trans-unit>
        <trans-unit id="93dc4e2b35f32f64da2b01b8733e27df5aac6ecf" translate="yes" xml:space="preserve">
          <source>The workhorse integer factorizer.  Generates the prime factors of the input.  Factors that appear &lt;em&gt;x&lt;/em&gt; times are yielded &lt;em&gt;x&lt;/em&gt; times.</source>
          <target state="translated">주력 정수 인수 분해기. 입력의 소인수를 생성합니다. &lt;em&gt;x&lt;/em&gt; 번 나타나는 요인 은 &lt;em&gt;x&lt;/em&gt; 번 산출 됩니다.</target>
        </trans-unit>
        <trans-unit id="a95e03a7b14d113a036a7e2892678ddcf0dc5672" translate="yes" xml:space="preserve">
          <source>The workhorse primality test.  It is a BPSW primality test variant: we use the strong Lucas PRP test and preface the computation with trial division for speed.  No composites are known to pass the test, though it is suspected that infinitely many will do so.  There are definitely no such errors below 2&lt;sup&gt;64&lt;/sup&gt;.  This function is mainly a streamlined version of</source>
          <target state="translated">일꾼 소수성 테스트. 이것은 BPSW 소수 테스트 변형입니다. 우리는 강력한 Lucas PRP 테스트를 사용하고 속도를 위해 시험 분할로 계산을 시작합니다. 테스트를 통과하는 것으로 알려진 합성물은 없지만 무한히 많은 사람들이 그렇게 할 것으로 의심됩니다. 2 &lt;sup&gt;64&lt;/sup&gt; 미만의 오류는 확실히 없습니다 . 이 기능은 주로 간소화 된 버전입니다.</target>
        </trans-unit>
        <trans-unit id="a76f1026ab482ee5fefe7adb3516df5ecd470401" translate="yes" xml:space="preserve">
          <source>This function solves the generalized Pell equation: we find all non-negative integers (&lt;em&gt;x&lt;/em&gt;, &lt;em&gt;y&lt;/em&gt;) such that &lt;em&gt;x&lt;/em&gt;&lt;sup&gt;2&lt;/sup&gt; -</source>
          <target state="translated">이 기능을 해결해 일반화 펠 방정식 : 우리가 음이 아닌 정수를 찾는 ( &lt;em&gt;X&lt;/em&gt; , &lt;em&gt;Y는&lt;/em&gt; )되도록 &lt;em&gt;X &lt;/em&gt;&lt;sup&gt;2&lt;/sup&gt; -</target>
        </trans-unit>
        <trans-unit id="640dc11e3dabf59ed510e1ca891dc62e28eccc72" translate="yes" xml:space="preserve">
          <source>This is a module for basic math in the general vicinity of computational number theory.  It includes functions associated with primality testing, integer factoring, prime counting, linear recurrences, modular square roots, generalized Pell equations, the classic arithmetical functions, continued fractions, partitions, St&amp;oslash;rmer&amp;rsquo;s theorem, smooth numbers, and Dirichlet convolution.  Integer arithmetic is used wherever feasible.</source>
          <target state="translated">이것은 전산 수 이론의 일반적인 근방에서 기초 수학을위한 모듈입니다. 여기에는 소수성 검정, 정수 분해, 소수 계수, 선형 반복, 모듈 식 제곱근, 일반화 된 Pell 방정식, 고전적인 산술 함수, 연속 분수, 분할, St&amp;oslash;rmer의 정리, 평활 수 및 Dirichlet 컨볼 루션과 관련된 함수가 포함됩니다. 가능한 한 정수 산술이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="335698cb19b6ed9b7f11b37679af97f02f222696" translate="yes" xml:space="preserve">
          <source>This package imports items from</source>
          <target state="translated">이 패키지는 다음에서 항목을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="878399c850ec7dd06a4fb5120e12b31d8e51f329" translate="yes" xml:space="preserve">
          <source>This returns a function that is the Dirichlet convolution of</source>
          <target state="translated">이것은 Dirichlet 컨볼 루션 인 함수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="be0f64b2c2ec8d3f096587c95f72324b81820991" translate="yes" xml:space="preserve">
          <source>U&lt;sub&gt;0&lt;/sub&gt;, U&lt;sub&gt;1&lt;/sub&gt;, V&lt;sub&gt;0&lt;/sub&gt;, V&lt;sub&gt;1&lt;/sub&gt; = 0, 1, 2,</source>
          <target state="translated">유 &lt;sub&gt;0&lt;/sub&gt; , 유 &lt;sub&gt;1&lt;/sub&gt; , V &lt;sub&gt;0&lt;/sub&gt; , V &lt;sub&gt;1&lt;/sub&gt; = 0, 1, 2,</target>
        </trans-unit>
        <trans-unit id="6f543f0fb6ad95eac25dec517b35aea6b6271026" translate="yes" xml:space="preserve">
          <source>U&lt;sub&gt;n&lt;/sub&gt; =</source>
          <target state="translated">U &lt;sub&gt;n&lt;/sub&gt; =</target>
        </trans-unit>
        <trans-unit id="53484ab410c786bc6dca5bfa962043fa4e14f083" translate="yes" xml:space="preserve">
          <source>Uses Hensel lifting to generate with some efficiency all zeros of a polynomial modulo a prime power.</source>
          <target state="translated">Hensel 리프팅을 사용하여 다항식 모듈로 프라임 파워의 모든 0을 효율성으로 생성합니다.</target>
        </trans-unit>
        <trans-unit id="650cb1ea26f3f3435a90bca9e814486d1548f503" translate="yes" xml:space="preserve">
          <source>Uses a sieve to compute the M&amp;ouml;bius function of all whole numbers strictly less than the input.</source>
          <target state="translated">체를 사용하여 입력보다 엄격하게 작은 모든 정수의 뫼비우스 함수를 계산합니다.</target>
        </trans-unit>
        <trans-unit id="1f679058b8f35fc3f4aca9d452840fa97b4831ef" translate="yes" xml:space="preserve">
          <source>Uses a sieve to compute the factorizations of all whole numbers strictly less than the input.  This uses a lot of memory; if you aren&amp;rsquo;t after the factors directly, it&amp;rsquo;s usually better to write a dedicated function for whatever it is that you actually want.</source>
          <target state="translated">체를 사용하여 입력보다 엄격하게 작은 모든 정수의 분해를 계산합니다. 이것은 많은 메모리를 사용합니다. 요소를 직접 추구하지 않는다면 일반적으로 실제로 원하는 것이 무엇이든 전용 함수를 작성하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="268fb65f2f3e2f02c488439bf119d606ca64bad0" translate="yes" xml:space="preserve">
          <source>Uses a sieve to compute the number of divisors of all whole numbers strictly less than the input.</source>
          <target state="translated">체를 사용하여 입력보다 엄격하게 작은 모든 정수의 제수를 계산합니다.</target>
        </trans-unit>
        <trans-unit id="fe1dbbb529e7c4a4d51aa8fc84b2050e88eb99c6" translate="yes" xml:space="preserve">
          <source>Uses a sieve to compute the totients up to (and including)</source>
          <target state="translated">체를 사용하여 최대 (포함)까지 totients를 계산합니다.</target>
        </trans-unit>
        <trans-unit id="6c76d71e87a267442fe63baeaaf864ce58a75988" translate="yes" xml:space="preserve">
          <source>Uses the &lt;a href=&quot;http://mathworld.wolfram.com/GramSeries.html&quot;&gt;Gram series&lt;/a&gt; to compute &lt;a href=&quot;http://mathworld.wolfram.com/RiemannPrimeCountingFunction.html&quot;&gt;Riemann&amp;rsquo;s R function&lt;/a&gt;, which is a rather good approximation to</source>
          <target state="translated">&lt;a href=&quot;http://mathworld.wolfram.com/GramSeries.html&quot;&gt;Gram 시리즈&lt;/a&gt; 를 사용하여 &lt;a href=&quot;http://mathworld.wolfram.com/RiemannPrimeCountingFunction.html&quot;&gt;Riemann의 R 함수&lt;/a&gt; 를 계산 합니다.</target>
        </trans-unit>
        <trans-unit id="4a7d5b6d4db905be914b564683d92a8fcbe1ec25" translate="yes" xml:space="preserve">
          <source>V&lt;sub&gt;n&lt;/sub&gt; =</source>
          <target state="translated">V &lt;sub&gt;N&lt;/sub&gt; =</target>
        </trans-unit>
        <trans-unit id="50e5378d732557779f1154c3575db8e23bb5b3ab" translate="yes" xml:space="preserve">
          <source>We attempt to import</source>
          <target state="translated">우리는 수입을 시도합니다</target>
        </trans-unit>
        <trans-unit id="6c9c8399feaa2614db53d41720cd228e01ec2def" translate="yes" xml:space="preserve">
          <source>We make a few imports:</source>
          <target state="translated">우리는 몇 가지 수입품을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="18540796a32eeba141c50da1b37a95f4334c7c5a" translate="yes" xml:space="preserve">
          <source>We yield only those solutions with &lt;em&gt;x&lt;/em&gt; &amp;le;</source>
          <target state="translated">&lt;em&gt;x&lt;/em&gt; &amp;le; 인 솔루션 만 산출합니다.</target>
        </trans-unit>
        <trans-unit id="3bf3f71c4d3d91d72b09100088bc05f6648939f4" translate="yes" xml:space="preserve">
          <source>ZeroDivisionError</source>
          <target state="translated">ZeroDivisionError</target>
        </trans-unit>
        <trans-unit id="d7dbd4deb34730f22194a18ec2062259b1eeb01d" translate="yes" xml:space="preserve">
          <source>[a,b,c,...,d]</source>
          <target state="translated">[a, b, c, ..., d]</target>
        </trans-unit>
        <trans-unit id="6617db25b376b8717487a1efee6f5300001877f1" translate="yes" xml:space="preserve">
          <source>] with its factorization.  Uses Adam Kalai&amp;rsquo;s algorithm, which uses in the average case O(log(</source>
          <target state="translated">] 인수 분해. 평균 사례 O (log (</target>
        </trans-unit>
        <trans-unit id="86f7e437faa5a7fce15d1ddcb9eaeaea377667b8" translate="yes" xml:space="preserve">
          <source>a</source>
          <target state="translated">ㅏ</target>
        </trans-unit>
        <trans-unit id="a9993e364706816aba3e25717850c26c9cd0d89d" translate="yes" xml:space="preserve">
          <source>abc</source>
          <target state="translated">알파벳</target>
        </trans-unit>
        <trans-unit id="1c0aa26e5d84363b3acc6bf9fbb155954590cbdc" translate="yes" xml:space="preserve">
          <source>abc[0]</source>
          <target state="translated">abc [0]</target>
        </trans-unit>
        <trans-unit id="3e9b0dc45ae3f876b91da0bb3e60fdb7a800b813" translate="yes" xml:space="preserve">
          <source>altseriesaccel</source>
          <target state="translated">altseriesaccel</target>
        </trans-unit>
        <trans-unit id="cffa50a32cb13a240d705317bcec65dd1f31b6ad" translate="yes" xml:space="preserve">
          <source>and</source>
          <target state="translated">과</target>
        </trans-unit>
        <trans-unit id="423e3677a59be7685f327a54c3d1687a5358b06d" translate="yes" xml:space="preserve">
          <source>and any</source>
          <target state="translated">그리고</target>
        </trans-unit>
        <trans-unit id="c07674c7f138dc32ab84db4d0b94deee67cf065c" translate="yes" xml:space="preserve">
          <source>and correspond directly to those same operators in Python3 source code.  The acceptable unary operators are</source>
          <target state="translated">Python3 소스 코드의 동일한 연산자에 직접 대응합니다. 허용되는 단항 연산자는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7f00744592a776e5ffc4e1d2ec293d7812083856" translate="yes" xml:space="preserve">
          <source>and reduces their coefficients mod</source>
          <target state="translated">계수 mod를 줄입니다.</target>
        </trans-unit>
        <trans-unit id="d16ffb80cfb8fbbc45a3e956afc9384e9d88d3a4" translate="yes" xml:space="preserve">
          <source>and returns the quotient and remainder.  The coefficients are interpreted mod</source>
          <target state="translated">몫과 나머지를 반환합니다. 계수는 mod로 해석됩니다.</target>
        </trans-unit>
        <trans-unit id="8ae7da769a9bfb836cc90735badab7103384f956" translate="yes" xml:space="preserve">
          <source>and returns them in a sorted list.</source>
          <target state="translated">정렬 된 목록으로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="b083fda8a38221bc976c25ada22cbbc125bf84c5" translate="yes" xml:space="preserve">
          <source>and we have the recursions</source>
          <target state="translated">그리고 우리는 재귀가 있습니다</target>
        </trans-unit>
        <trans-unit id="22a2fa7aecbb23be92b1456ec37e8d661d6284fa" translate="yes" xml:space="preserve">
          <source>appears</source>
          <target state="translated">나타납니다</target>
        </trans-unit>
        <trans-unit id="e40428569577cb101cb980e869d504664b7d8cb9" translate="yes" xml:space="preserve">
          <source>are for internal use only.</source>
          <target state="translated">내부 전용입니다.</target>
        </trans-unit>
        <trans-unit id="7eebdb0c22367682ed44a609d37dde0a356d56a1" translate="yes" xml:space="preserve">
          <source>argument indicates that we are to assume an effective abc conjecture of the form &lt;em&gt;c&lt;/em&gt; &amp;lt;</source>
          <target state="translated">인수는 우리가 &lt;em&gt;c&lt;/em&gt; &amp;lt; 형식의 효과적인 abc 추측을 가정해야 함을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="80f3d3aa79645a7dc0c6783938d48bbec07bb175" translate="yes" xml:space="preserve">
          <source>argument is for memoization.</source>
          <target state="translated">논쟁은 암기입니다.</target>
        </trans-unit>
        <trans-unit id="d6bcc82fa6253c3c81129dc64664935466672afb" translate="yes" xml:space="preserve">
          <source>as an initial estimate, computing</source>
          <target state="translated">초기 추정치로 계산</target>
        </trans-unit>
        <trans-unit id="28e86607ff751be3dbde36b1a32f0a5776b94eba" translate="yes" xml:space="preserve">
          <source>as appropriate.  This optimization becomes more noticeable as the factoring becomes more difficult.</source>
          <target state="translated">적절한. 이 최적화는 인수 분해가 더 어려워 짐에 따라 더욱 눈에 띄게됩니다.</target>
        </trans-unit>
        <trans-unit id="b9d67952547d2d3bfbc0bfae7738b9137def3575" translate="yes" xml:space="preserve">
          <source>as the first component and the relevant power as the second component.  If</source>
          <target state="translated">첫 번째 구성 요소로 관련 전력을 두 번째 구성 요소로. 만약</target>
        </trans-unit>
        <trans-unit id="8b0167946be499c0984a56eedbabe88e5635374b" translate="yes" xml:space="preserve">
          <source>at the end, so we handle separately the case where this is zero.</source>
          <target state="translated">그래서 우리는 이것이 0 인 경우를 별도로 처리합니다.</target>
        </trans-unit>
        <trans-unit id="e9d71f5ee7c92d6dc9e92ffdad17b8bd49418f98" translate="yes" xml:space="preserve">
          <source>b</source>
          <target state="translated">비</target>
        </trans-unit>
        <trans-unit id="5e45d064f99e8d1f88b05bb3c44e7e3075a0519b" translate="yes" xml:space="preserve">
          <source>bail</source>
          <target state="translated">보석</target>
        </trans-unit>
        <trans-unit id="73c57301af9ef7b2b0d5217fa1fe9d631261d791" translate="yes" xml:space="preserve">
          <source>be a function on the positive integers, let</source>
          <target state="translated">양의 정수에 대한 함수가 되십시오.</target>
        </trans-unit>
        <trans-unit id="3df79c1e257a045b9ac776f1735507406ca949bb" translate="yes" xml:space="preserve">
          <source>be a positive integer, and let</source>
          <target state="translated">양의 정수이고</target>
        </trans-unit>
        <trans-unit id="190cd0c12bb8723300924a9625c187781783a04a" translate="yes" xml:space="preserve">
          <source>be integers such that</source>
          <target state="translated">다음과 같은 정수</target>
        </trans-unit>
        <trans-unit id="e86873283164dede4e8a6cce779c4e7fc5af7b01" translate="yes" xml:space="preserve">
          <source>bool(pell(D,N)[0])</source>
          <target state="translated">bool (pell (D, N) [0])</target>
        </trans-unit>
        <trans-unit id="5d25966d3e4427fff6f97ed668cf8e9d4ad58871" translate="yes" xml:space="preserve">
          <source>bpsw</source>
          <target state="translated">bpsw</target>
        </trans-unit>
        <trans-unit id="2cdf265410b6b700b91d7e3971139954d36d0f32" translate="yes" xml:space="preserve">
          <source>by applying</source>
          <target state="translated">적용하여</target>
        </trans-unit>
        <trans-unit id="25157648db89193cfdd9a993e256ec3b08c238c5" translate="yes" xml:space="preserve">
          <source>by the polynomial</source>
          <target state="translated">다항식으로</target>
        </trans-unit>
        <trans-unit id="84a516841ba77a5b4648de2cd0dfcb30ea46dbb4" translate="yes" xml:space="preserve">
          <source>c</source>
          <target state="translated">씨</target>
        </trans-unit>
        <trans-unit id="c4141200bfaed15b39f7442caa7d497f9c7a7989" translate="yes" xml:space="preserve">
          <source>coefs[k]</source>
          <target state="translated">coefs [k]</target>
        </trans-unit>
        <trans-unit id="0b9702797aab9ff35839ab8ce2e06faf7475d013" translate="yes" xml:space="preserve">
          <source>cubicintroots</source>
          <target state="translated">입방근</target>
        </trans-unit>
        <trans-unit id="d6269a84026917e0fccb6e13db680fd34c155dc4" translate="yes" xml:space="preserve">
          <source>cubicintrootsgiven</source>
          <target state="translated">입방근</target>
        </trans-unit>
        <trans-unit id="3c363836cf4e16666669a25da280a1865c2d2874" translate="yes" xml:space="preserve">
          <source>d</source>
          <target state="translated">디</target>
        </trans-unit>
        <trans-unit id="01b75b0700101b4727bfc89c1cd712b5c78499d8" translate="yes" xml:space="preserve">
          <source>dirconv</source>
          <target state="translated">dirconv</target>
        </trans-unit>
        <trans-unit id="d786253dcca71d5ff20ce9683b44794b24b476a5" translate="yes" xml:space="preserve">
          <source>dirichletinverse(f)</source>
          <target state="translated">dirichletinverse (f)</target>
        </trans-unit>
        <trans-unit id="03e669c63f3bfb43b5c8c3d259c64bb578bf84b5" translate="yes" xml:space="preserve">
          <source>dirichletinverse(f)(n)</source>
          <target state="translated">디리클레 인버스 (f) (n)</target>
        </trans-unit>
        <trans-unit id="5c58ad317c477f6ef15fd5698c2c3b7cd842cccd" translate="yes" xml:space="preserve">
          <source>divisors_factored(n)</source>
          <target state="translated">제수 인수 (n)</target>
        </trans-unit>
        <trans-unit id="58e6b3a414a1e090dfc6029add0f3555ccba127f" translate="yes" xml:space="preserve">
          <source>e</source>
          <target state="translated">이자형</target>
        </trans-unit>
        <trans-unit id="734f507c6428f42e9214bdadddde151f7712696e" translate="yes" xml:space="preserve">
          <source>ecm</source>
          <target state="translated">ecm</target>
        </trans-unit>
        <trans-unit id="0c236606d901bf5b5cffebee509cbfc994dbd6c2" translate="yes" xml:space="preserve">
          <source>ecmparams</source>
          <target state="translated">ecmparams</target>
        </trans-unit>
        <trans-unit id="338362566cc17e29060463088b729a5471909d9a" translate="yes" xml:space="preserve">
          <source>efficiently.</source>
          <target state="translated">효율적으로.</target>
        </trans-unit>
        <trans-unit id="4a0a19218e082a343a1b17e5333409af9d98f0f5" translate="yes" xml:space="preserve">
          <source>f</source>
          <target state="translated">에프</target>
        </trans-unit>
        <trans-unit id="315206ca84dc4ce4fe812e2863ee8eb264ac0dd0" translate="yes" xml:space="preserve">
          <source>f == []</source>
          <target state="translated">f == []</target>
        </trans-unit>
        <trans-unit id="b6af140f0f8a203779ba6dfe7596f459c4f59ac2" translate="yes" xml:space="preserve">
          <source>f == totient</source>
          <target state="translated">f == 끈기</target>
        </trans-unit>
        <trans-unit id="647df68c0784177b0691d73d2f9e3d8cd45d5e46" translate="yes" xml:space="preserve">
          <source>ffac=True</source>
          <target state="translated">ffac = 참</target>
        </trans-unit>
        <trans-unit id="4031de3cf69373e17eedea3cc0ca9bb57f697583" translate="yes" xml:space="preserve">
          <source>fibo(0)</source>
          <target state="translated">피보 (0)</target>
        </trans-unit>
        <trans-unit id="c8aae4bf7819bae8ea1d14dbff76238d6f3c650d" translate="yes" xml:space="preserve">
          <source>fibo(1)</source>
          <target state="translated">피보 (1)</target>
        </trans-unit>
        <trans-unit id="4205d665cf378fdbadc87b71e15cd669937c2d05" translate="yes" xml:space="preserve">
          <source>fibo(2)</source>
          <target state="translated">피보 (2)</target>
        </trans-unit>
        <trans-unit id="43eef9a62abb8b1e1654f8a890aae054abffa82b" translate="yes" xml:space="preserve">
          <source>for</source>
          <target state="translated">...에 대한</target>
        </trans-unit>
        <trans-unit id="a7668f7b918080cace2b7647399809cb46f37464" translate="yes" xml:space="preserve">
          <source>for any such</source>
          <target state="translated">그런 것에 대해</target>
        </trans-unit>
        <trans-unit id="d47ef507fd3562f713ba06d3c342a8541272e806" translate="yes" xml:space="preserve">
          <source>fractions</source>
          <target state="translated">분수</target>
        </trans-unit>
        <trans-unit id="0b1e95cfd9775191a7224d0a218ae79187e80c1d" translate="yes" xml:space="preserve">
          <source>from</source>
          <target state="translated">...에서</target>
        </trans-unit>
        <trans-unit id="cac02ec1a476ed80dfd51b02515cb2a3bd581ae2" translate="yes" xml:space="preserve">
          <source>function.</source>
          <target state="translated">함수.</target>
        </trans-unit>
        <trans-unit id="54fd1711209fb1c0781092374132c66e79e2241b" translate="yes" xml:space="preserve">
          <source>g</source>
          <target state="translated">지</target>
        </trans-unit>
        <trans-unit id="6f82a25f8a9d9d0f82e257528ce180c65281f0be" translate="yes" xml:space="preserve">
          <source>g == mobius</source>
          <target state="translated">g == 뫼비우스</target>
        </trans-unit>
        <trans-unit id="08da69a048896f64e8d2f2f7e539609be66ba12a" translate="yes" xml:space="preserve">
          <source>gcd(D,m)!=1</source>
          <target state="translated">gcd (D, m)! = 1</target>
        </trans-unit>
        <trans-unit id="4739319abf9070ef0b0e2a73224820ae70488aa6" translate="yes" xml:space="preserve">
          <source>gen</source>
          <target state="translated">세대</target>
        </trans-unit>
        <trans-unit id="7a164e09344c9505c271c6d424b2da33c3fd3e5b" translate="yes" xml:space="preserve">
          <source>gfac=True</source>
          <target state="translated">gfac = 참</target>
        </trans-unit>
        <trans-unit id="7b23189c90eff94402b89369c93f483db6c41344" translate="yes" xml:space="preserve">
          <source>given two bounds and a seed.</source>
          <target state="translated">두 경계와 시드가 주어집니다.</target>
        </trans-unit>
        <trans-unit id="55359a446e39ee32617d7d3eea49ead78bddb1c6" translate="yes" xml:space="preserve">
          <source>gmpy2</source>
          <target state="translated">gmpy2</target>
        </trans-unit>
        <trans-unit id="e754a4d398e711f0a035b3fd04202c34a51014bb" translate="yes" xml:space="preserve">
          <source>has a repeated prime factor.</source>
          <target state="translated">반복되는 소인수가 있습니다.</target>
        </trans-unit>
        <trans-unit id="443e0256a4f3233c27654ce6540d09aa085b841d" translate="yes" xml:space="preserve">
          <source>heapq</source>
          <target state="translated">heapq</target>
        </trans-unit>
        <trans-unit id="92005ecf3788faea8346a7919fba0232188561ab" translate="yes" xml:space="preserve">
          <source>help</source>
          <target state="translated">도움</target>
        </trans-unit>
        <trans-unit id="958f57f57d72a30f329ee5538f21b0257a49a46e" translate="yes" xml:space="preserve">
          <source>if</source>
          <target state="translated">만약</target>
        </trans-unit>
        <trans-unit id="5d98b52e53a617b661aa195fa572770a19c4f092" translate="yes" xml:space="preserve">
          <source>if it isn&amp;rsquo;t.</source>
          <target state="translated">그렇지 않은 경우.</target>
        </trans-unit>
        <trans-unit id="0ee6fa9ba4ab0cdaaf258ad7f3d55d7b283fd5be" translate="yes" xml:space="preserve">
          <source>if no such prime exists.</source>
          <target state="translated">그러한 소수가 존재하지 않는 경우.</target>
        </trans-unit>
        <trans-unit id="a8ce66926ac0d9289255d559e051bbcaf199f26f" translate="yes" xml:space="preserve">
          <source>in such situations is quite a bit slower due to the time-complexity of multiplication.  However, the size of the problem required to make this superior to</source>
          <target state="translated">이러한 상황에서는 곱셈의 시간 복잡성으로 인해 상당히 느립니다. 그러나 이것을 우월하게 만드는 데 필요한 문제의 크기는</target>
        </trans-unit>
        <trans-unit id="faca05ba26b44ae973be06d817f90318ac1402ce" translate="yes" xml:space="preserve">
          <source>in the Farey sequence of maximum denominator</source>
          <target state="translated">최대 분모의 Farey 시퀀스에서</target>
        </trans-unit>
        <trans-unit id="55fcda190a7af7698ada9d66dd1192d726e588d5" translate="yes" xml:space="preserve">
          <source>instead and feed those factored divisors into</source>
          <target state="translated">대신 그 인수 제수를</target>
        </trans-unit>
        <trans-unit id="370b5e19dba599f512446f6d2f8b476541cdea11" translate="yes" xml:space="preserve">
          <source>into a dictionary with primes as keys and multiplicities as values.</source>
          <target state="translated">소수를 키로 사용하고 다중성을 값으로 사용하는 사전으로.</target>
        </trans-unit>
        <trans-unit id="b47f363e2b430c0647f14deea3eced9b0ef300ce" translate="yes" xml:space="preserve">
          <source>is</source>
          <target state="translated">이다</target>
        </trans-unit>
        <trans-unit id="d2c35916878942bd128e969cbd953d99f1f91da4" translate="yes" xml:space="preserve">
          <source>is a cache of zeta values.</source>
          <target state="translated">제타 값의 캐시입니다.</target>
        </trans-unit>
        <trans-unit id="49c27f5f42d7861345685e0bd678d6535d255e89" translate="yes" xml:space="preserve">
          <source>is a large real number.</source>
          <target state="translated">큰 실수입니다.</target>
        </trans-unit>
        <trans-unit id="37953ec8e60d66fab1e5fe90650d66d06c0ca1eb" translate="yes" xml:space="preserve">
          <source>is a list of primes.</source>
          <target state="translated">소수의 목록입니다.</target>
        </trans-unit>
        <trans-unit id="f92be3654d8664bc640994b103f65c28ef1c9260" translate="yes" xml:space="preserve">
          <source>is a nonsquare, then there are no further solutions.</source>
          <target state="translated">정사각형이 아닌 경우 더 이상 해가 없습니다.</target>
        </trans-unit>
        <trans-unit id="341599309574d8056f163a056a090a62f656d1c6" translate="yes" xml:space="preserve">
          <source>is a nonsquare, then there are no solutions.</source>
          <target state="translated">정사각형이 아닌 경우 해가 없습니다.</target>
        </trans-unit>
        <trans-unit id="80f9364c732c11c24a040bca417f9a10802782d7" translate="yes" xml:space="preserve">
          <source>is a nonsquare, then we run the PQa/LMM algorithms: we produce a set of primitive solutions; if this set is empty, there are no solutions; if this set has members, an ininite set of solutions can be produced by repeatedly composing them with the fundamental solution of &lt;em&gt;x&lt;/em&gt;&lt;sup&gt;2&lt;/sup&gt; -</source>
          <target state="translated">정사각형이 아닌 경우 PQa / LMM 알고리즘을 실행합니다. 기본 솔루션 집합을 생성합니다. 이 세트가 비어 있으면 솔루션이 없습니다. 이 세트가 부재 한 경우 용액의 ininite 세트는 반복의 기본 용액들을 구성하여 제조 될 수있다 &lt;em&gt;(X) &lt;/em&gt;&lt;sup&gt;2&lt;/sup&gt; -</target>
        </trans-unit>
        <trans-unit id="64b6d8423fedee44b9be667f778516d17fd9a6ef" translate="yes" xml:space="preserve">
          <source>is a perfect</source>
          <target state="translated">완벽하다</target>
        </trans-unit>
        <trans-unit id="64b01ce8605073ca5d678688bf82d0be37b37679" translate="yes" xml:space="preserve">
          <source>is a perfect power, return a tuple containing the largest integer that, when squares/cubed/etc, yields</source>
          <target state="translated">완전 거듭 제곱이고, 제곱 / 입방체 / 등에서 산출되는 가장 큰 정수를 포함하는 튜플을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="898e94e521c1d947cb6950eaefe9dcdaf235b4d4" translate="yes" xml:space="preserve">
          <source>is a practical number &amp;ndash; i.e., whether every integer from 1 through</source>
          <target state="translated">실제 숫자입니다. 즉, 1부터</target>
        </trans-unit>
        <trans-unit id="a15b27d2d0f9b5a9d370396f415a9edeff569d20" translate="yes" xml:space="preserve">
          <source>is a prime and</source>
          <target state="translated">프라임이고</target>
        </trans-unit>
        <trans-unit id="fbaef629941ab443a5ffeaa9ce47284805e6064a" translate="yes" xml:space="preserve">
          <source>is a quadratic residue mod</source>
          <target state="translated">2 차 잔차 모드입니다.</target>
        </trans-unit>
        <trans-unit id="fc91dc9cd2dbb46bd4d18da2d9eedb19d417f61f" translate="yes" xml:space="preserve">
          <source>is a quadratic residue modulo</source>
          <target state="translated">2 차 잔차 모듈로</target>
        </trans-unit>
        <trans-unit id="38cfc281fba7a65b9cd32bd53f871e16a91c971c" translate="yes" xml:space="preserve">
          <source>is a square, then the number of solutions will be at most finite.  This case is solved by factoring.</source>
          <target state="translated">정사각형이면 해의 수는 최대 유한합니다. 이 경우는 인수 분해로 해결됩니다.</target>
        </trans-unit>
        <trans-unit id="76ac02c7f30e492c27f4726d0fce17f942f33edc" translate="yes" xml:space="preserve">
          <source>is a square, then there are infinitely many solutions, parametrized by (&amp;radic;</source>
          <target state="translated">정사각형이면 무한히 많은 해가 (&amp;radic;</target>
        </trans-unit>
        <trans-unit id="c9072bff9a277a0980d8f18701c036a3e095ab9e" translate="yes" xml:space="preserve">
          <source>is a square, then there are infinitely many solutions, parametrized by (&lt;em&gt;t&lt;/em&gt;&amp;middot;&amp;radic;</source>
          <target state="translated">정사각형이면 ( &lt;em&gt;t&lt;/em&gt; &amp;middot; &amp;radic;에 의해 매개 변수화 된 해가 무한히 많습니다.</target>
        </trans-unit>
        <trans-unit id="b29247d5558ad7494843a5a1d98fab25b653c0bd" translate="yes" xml:space="preserve">
          <source>is an</source>
          <target state="translated">이다</target>
        </trans-unit>
        <trans-unit id="875e5add0137d5a23ab53431827f809f09c84dc1" translate="yes" xml:space="preserve">
          <source>is called and we will call</source>
          <target state="translated">호출되고 우리는</target>
        </trans-unit>
        <trans-unit id="6fd0c436112330430676f2dd96c3c0922cc6a799" translate="yes" xml:space="preserve">
          <source>is concerned with the general equation, which may or may not have trivial solutions, and as such yields all non-negative solutions, whereas this function is concerned only with the simple Pell equation, which always has an infinite family of positive solutions generated from a single primitive solution and always has the trivial solution (1,0).</source>
          <target state="translated">이 함수는 단순한 Pell 방정식에만 관련이 있습니다. 단일 원시 솔루션이며 항상 사소한 솔루션 (1,0)을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="8bea43bb939ee6ac17ba706d8fae419a2185708b" translate="yes" xml:space="preserve">
          <source>is even.</source>
          <target state="translated">짝수이다.</target>
        </trans-unit>
        <trans-unit id="68f46528d8fc83cad934a1f14d8a844237021693" translate="yes" xml:space="preserve">
          <source>is handled properly.</source>
          <target state="translated">제대로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="48b31bfadc2521825ca08da6c36aa727b913ef52" translate="yes" xml:space="preserve">
          <source>is machine-indistinguishable from 1.0 &amp;mdash; in particular, when</source>
          <target state="translated">1.0부터 기계 식별이 불가능합니다. 특히</target>
        </trans-unit>
        <trans-unit id="10534b02e6a6fc675401f5f0d9796a5234abd865" translate="yes" xml:space="preserve">
          <source>is not a perfect power, return</source>
          <target state="translated">완벽한 힘이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="f455949b391b3e0789873e7c48e4188a0e154490" translate="yes" xml:space="preserve">
          <source>is not coprime to</source>
          <target state="translated">코 프라임이 아니다</target>
        </trans-unit>
        <trans-unit id="2fab3805742595a909144bab6b06c2c73eaa8cdb" translate="yes" xml:space="preserve">
          <source>is prime, then</source>
          <target state="translated">프라임, 그럼</target>
        </trans-unit>
        <trans-unit id="4c6563279f43ae5dc1a83638491dbb425bc13151" translate="yes" xml:space="preserve">
          <source>is prime, we immediately return</source>
          <target state="translated">프라임, 우리는 즉시 반환</target>
        </trans-unit>
        <trans-unit id="4155e05f59fd1e42f3aef2d244af0456c4369b33" translate="yes" xml:space="preserve">
          <source>is prime.  If the provided (partial) factorization of</source>
          <target state="translated">프라임입니다. 제공된 (부분) 인수 분해</target>
        </trans-unit>
        <trans-unit id="0c686c58ef3a3ae2d4c671c5ce861d019d03c96f" translate="yes" xml:space="preserve">
          <source>is quite large, so</source>
          <target state="translated">꽤 커서</target>
        </trans-unit>
        <trans-unit id="91b2fff06e4ed4d3cfda3e66159035cfcf06cc84" translate="yes" xml:space="preserve">
          <source>is raised to the</source>
          <target state="translated">에 제기됩니다</target>
        </trans-unit>
        <trans-unit id="9f389ffaacb07667243a85f2131fec4cdd1b17b4" translate="yes" xml:space="preserve">
          <source>is squarefree with an even number of prime factors, -1 if</source>
          <target state="translated">소수의 짝수로 제곱이 없습니다.</target>
        </trans-unit>
        <trans-unit id="477716014edf48baa262a068be894f69d10aacda" translate="yes" xml:space="preserve">
          <source>is squarefree with an odd number of prime factors, and 0 if</source>
          <target state="translated">홀수의 소인수가있는 제곱 자유이며, 경우 0입니다.</target>
        </trans-unit>
        <trans-unit id="f9d8d585ccc0941d1f852facf4c17ea42f55ad55" translate="yes" xml:space="preserve">
          <source>is supplied, terms are computed modulo</source>
          <target state="translated">제공된 조건은 모듈로 계산됩니다.</target>
        </trans-unit>
        <trans-unit id="7f0b64bf2ff0248f24db942aa41c34c4454057e8" translate="yes" xml:space="preserve">
          <source>is supplied, then we compute the sequence modulo</source>
          <target state="translated">공급되면 모듈로 시퀀스를 계산합니다.</target>
        </trans-unit>
        <trans-unit id="9d5047cbf7ceac0110790548ce311421463adfa5" translate="yes" xml:space="preserve">
          <source>is the coefficient of the &lt;em&gt;x&lt;/em&gt;&lt;sup&gt;k&lt;/sup&gt; term.  For low-degree polynomials, explicit formulae are used; for degrees 5 and higher, we compute it by taking the determinant (using this package&amp;rsquo;s determinant() function) of the Sylvester matrix of the input and its derivative.  This in turn is calculated by the Schur determinant identity.  Note that this has the effect of setting the discriminant of a linear polynomial to 1 (which is conventional) and that of a constant to 0.</source>
          <target state="translated">&lt;em&gt;x &lt;/em&gt;&lt;sup&gt;k&lt;/sup&gt; 항의 계수입니다 . 저차 다항식의 경우 명시 적 공식이 사용됩니다. 5도 이상인 경우 입력과 그 미분의 실베스터 행렬의 행렬식 (이 패키지의 determinant () 함수 사용)을 사용하여 계산합니다. 이것은 차례로 Schur 결정자 ID에 의해 계산됩니다. 이것은 선형 다항식의 판별을 1 (일반)로 설정하고 상수의 판별을 0으로 설정하는 효과가 있습니다.</target>
        </trans-unit>
        <trans-unit id="57a53471fa92992c70d886f43da37b86b714d40d" translate="yes" xml:space="preserve">
          <source>is the fundamental solution &amp;mdash; i.e.,</source>
          <target state="translated">근본적인 해결책입니다. 즉,</target>
        </trans-unit>
        <trans-unit id="67c4b407d69ca8235090663680de79b94b491522" translate="yes" xml:space="preserve">
          <source>is the minimal reptend.</source>
          <target state="translated">최소 reptend입니다.</target>
        </trans-unit>
        <trans-unit id="d4842b1baa18b36449c7d350288c94b9f4cefa2c" translate="yes" xml:space="preserve">
          <source>is the primitive solution of &lt;em&gt;x&lt;/em&gt;&lt;sup&gt;2&lt;/sup&gt; -</source>
          <target state="translated">프리미티브의 해결책 &lt;em&gt;X &lt;/em&gt;&lt;sup&gt;2&lt;/sup&gt; -</target>
        </trans-unit>
        <trans-unit id="b5c0a1b4dce5ac35b3bdf19568dc7d32d1ef6f5e" translate="yes" xml:space="preserve">
          <source>is the set of primitive solutions, represented as a sorted list, and</source>
          <target state="translated">정렬 된 목록으로 표시되는 기본 솔루션 세트입니다.</target>
        </trans-unit>
        <trans-unit id="9ab5df466d8fec7d686d0e8fd0a386420c3f1cf1" translate="yes" xml:space="preserve">
          <source>is the sorted list of all solutions.</source>
          <target state="translated">모든 솔루션의 정렬 된 목록입니다.</target>
        </trans-unit>
        <trans-unit id="15e7f952825b4d23ab0795f41f932fe99e0c1773" translate="yes" xml:space="preserve">
          <source>is used for memoization.  We compute O(log(</source>
          <target state="translated">메모에 사용됩니다. 우리는 O (log (</target>
        </trans-unit>
        <trans-unit id="208fcfc75abb7f097c431f4754f7d964cd0a8e48" translate="yes" xml:space="preserve">
          <source>isn&amp;rsquo;t prime.</source>
          <target state="translated">프라임이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="f38786758717970fc3a6e4cfa07bcf41bc853729" translate="yes" xml:space="preserve">
          <source>isprime_nm1</source>
          <target state="translated">isprime_nm1</target>
        </trans-unit>
        <trans-unit id="79a7da32928063c3bcec9b019a5f385da5b29a94" translate="yes" xml:space="preserve">
          <source>iterprod()</source>
          <target state="translated">iterprod ()</target>
        </trans-unit>
        <trans-unit id="9e9cf1097fbb8c0af843641c0e32781c81ce4931" translate="yes" xml:space="preserve">
          <source>itertools</source>
          <target state="translated">itertools</target>
        </trans-unit>
        <trans-unit id="13fbd79c3d390e5d6585a21e11ff5ec1970cff0c" translate="yes" xml:space="preserve">
          <source>k</source>
          <target state="translated">케이</target>
        </trans-unit>
        <trans-unit id="d685a407748e8849f1263505263236c59b428388" translate="yes" xml:space="preserve">
          <source>labmath version 1.1.1</source>
          <target state="translated">labmath 버전 1.1.1</target>
        </trans-unit>
        <trans-unit id="9ea6002473329c9bf2c6ce211d19c4f47133e091" translate="yes" xml:space="preserve">
          <source>lambda n: sum(f(d) * g(n//d) for d in divisors(n))</source>
          <target state="translated">람다 n : sum (f (d) * g (n // d) for d in divisors (n))</target>
        </trans-unit>
        <trans-unit id="edc17dae351b8e294814eb2f719beba8b1876028" translate="yes" xml:space="preserve">
          <source>linrec</source>
          <target state="translated">Linrec</target>
        </trans-unit>
        <trans-unit id="8e700c01a0954d94b4069bd7604563c4d444e2cd" translate="yes" xml:space="preserve">
          <source>lprp</source>
          <target state="translated">lprp</target>
        </trans-unit>
        <trans-unit id="10c25665e49274c39b8e8f7ad6e2a3d0b0bc5052" translate="yes" xml:space="preserve">
          <source>lucas</source>
          <target state="translated">루카스</target>
        </trans-unit>
        <trans-unit id="4e6198a411bd3928707503b4ce13a0500e756f47" translate="yes" xml:space="preserve">
          <source>lucasgen</source>
          <target state="translated">Lucasgen</target>
        </trans-unit>
        <trans-unit id="6b0d31c0d563223024da45691584643ac78c96e8" translate="yes" xml:space="preserve">
          <source>m</source>
          <target state="translated">미디엄</target>
        </trans-unit>
        <trans-unit id="9268abd0a926b297f7d2180b19d2be452ef0964a" translate="yes" xml:space="preserve">
          <source>m-1</source>
          <target state="translated">m-1</target>
        </trans-unit>
        <trans-unit id="7a488390a939c4795cc1a801e51751d5f25d800d" translate="yes" xml:space="preserve">
          <source>math</source>
          <target state="translated">수학</target>
        </trans-unit>
        <trans-unit id="3fc66ee357145c86940bacd83291c9da3c204322" translate="yes" xml:space="preserve">
          <source>mods</source>
          <target state="translated">개조</target>
        </trans-unit>
        <trans-unit id="c22f2817741e0e875ad47ea68515f3a3691c8876" translate="yes" xml:space="preserve">
          <source>module).</source>
          <target state="translated">기준 치수).</target>
        </trans-unit>
        <trans-unit id="1af60b7b96e08873e7bd780893eed25aa7a430b1" translate="yes" xml:space="preserve">
          <source>modulo</source>
          <target state="translated">모듈로</target>
        </trans-unit>
        <trans-unit id="4f1840a0bd0f57b4f24320a5c9ca1f875417a203" translate="yes" xml:space="preserve">
          <source>mpqs</source>
          <target state="translated">mpq</target>
        </trans-unit>
        <trans-unit id="481e642078ce8449a05189acf3c45795b499a245" translate="yes" xml:space="preserve">
          <source>mpz</source>
          <target state="translated">mpz</target>
        </trans-unit>
        <trans-unit id="37fa789244ba067512edeee7a888d433532a0423" translate="yes" xml:space="preserve">
          <source>mpz = int</source>
          <target state="translated">mpz = 정수</target>
        </trans-unit>
        <trans-unit id="a5bd8289887f3cf122e499e17ebfeef374ec32de" translate="yes" xml:space="preserve">
          <source>multiprocessing</source>
          <target state="translated">다중 처리</target>
        </trans-unit>
        <trans-unit id="9d1aeca2487d24afd325ff8eed2de7cabbd00552" translate="yes" xml:space="preserve">
          <source>must be pairwise coprime.</source>
          <target state="translated">쌍방향 코 프라임이어야합니다.</target>
        </trans-unit>
        <trans-unit id="d1854cae891ec7b29161ccaf79a24b00c274bdaa" translate="yes" xml:space="preserve">
          <source>n</source>
          <target state="translated">엔</target>
        </trans-unit>
        <trans-unit id="6d5e3b4bf5f0b282c1e25ab574b570589a155b0f" translate="yes" xml:space="preserve">
          <source>needs to factor its argument, such as</source>
          <target state="translated">인수를 고려해야합니다.</target>
        </trans-unit>
        <trans-unit id="b206c000b5b327ffef54cb8d8683dc454cbf29a5" translate="yes" xml:space="preserve">
          <source>ngonal(1, n)</source>
          <target state="translated">ngonal (1, n)</target>
        </trans-unit>
        <trans-unit id="b044148d4bbf95d9708824ff4c61842411fb88b5" translate="yes" xml:space="preserve">
          <source>nprocs==1</source>
          <target state="translated">nprocs == 1</target>
        </trans-unit>
        <trans-unit id="53edb37c3102831286c713f27b3cbf2fac86b534" translate="yes" xml:space="preserve">
          <source>nthprimeapprox</source>
          <target state="translated">nthprimeapprox</target>
        </trans-unit>
        <trans-unit id="8c7dd71795f90a543d5e74dce04d14e5e6d5c855" translate="yes" xml:space="preserve">
          <source>objects (as imported from the</source>
          <target state="translated">개체 (</target>
        </trans-unit>
        <trans-unit id="f1a4fd6d24ae912e143e2c8c2cb19ede84f74be8" translate="yes" xml:space="preserve">
          <source>of prime numbers, there are only finitely many pairs of consecutive integers that are both</source>
          <target state="translated">소수의 연속 된 정수 쌍이 유한히 많습니다.</target>
        </trans-unit>
        <trans-unit id="e9175e26e936a570297c6dd401d37eeb01d9bffd" translate="yes" xml:space="preserve">
          <source>of that, and then sieving to remove the error.</source>
          <target state="translated">그 다음 체질하여 오류를 제거합니다.</target>
        </trans-unit>
        <trans-unit id="1758356db21759f7c5a0da9b4dd1db8fd6feab3f" translate="yes" xml:space="preserve">
          <source>or</source>
          <target state="translated">또는</target>
        </trans-unit>
        <trans-unit id="4c51633dc554ed687fdde317b3f1058f65a348b9" translate="yes" xml:space="preserve">
          <source>or something like that, then that lambda expression calls the factorizer a lot more than it needs to &amp;mdash; we&amp;rsquo;re already factoring</source>
          <target state="translated">또는 그런 식으로 람다식이 필요한 것보다 훨씬 더 많이 factorizer를 호출합니다.</target>
        </trans-unit>
        <trans-unit id="516b9783fca517eecbd1d064da2d165310b19759" translate="yes" xml:space="preserve">
          <source>p</source>
          <target state="translated">피</target>
        </trans-unit>
        <trans-unit id="fcf2989b3c5176b44dd95fdcb12150ddb41778bd" translate="yes" xml:space="preserve">
          <source>p!</source>
          <target state="translated">피!</target>
        </trans-unit>
        <trans-unit id="909e6bf0ca53b6aa378c1e94b0db124a102075e2" translate="yes" xml:space="preserve">
          <source>parts</source>
          <target state="translated">부속</target>
        </trans-unit>
        <trans-unit id="f2fe328ab8bf537c8ecbafd3dd78355075319ce3" translate="yes" xml:space="preserve">
          <source>pell</source>
          <target state="translated">철자</target>
        </trans-unit>
        <trans-unit id="330e4c7e45b01dbbadae4a6cdb2900237e134555" translate="yes" xml:space="preserve">
          <source>pell(D,1)[0]</source>
          <target state="translated">pell (D, 1) [0]</target>
        </trans-unit>
        <trans-unit id="defa78cbf02e07b7906c773ac2bc8c860c69def5" translate="yes" xml:space="preserve">
          <source>phicache</source>
          <target state="translated">피 캐시</target>
        </trans-unit>
        <trans-unit id="4fcdd83743538a0257f58dcef6480c381fd0adff" translate="yes" xml:space="preserve">
          <source>pichache</source>
          <target state="translated">Pichache</target>
        </trans-unit>
        <trans-unit id="5e5ff4c6603b930f0e155df26b926d83b86595f0" translate="yes" xml:space="preserve">
          <source>primefac</source>
          <target state="translated">Primefac</target>
        </trans-unit>
        <trans-unit id="1514bdcddbf1f72bde938b0ca19ed1f15159d0ee" translate="yes" xml:space="preserve">
          <source>primepi</source>
          <target state="translated">Primepi</target>
        </trans-unit>
        <trans-unit id="c67f1ee17880030ce11821dcc9be7af90b863d9b" translate="yes" xml:space="preserve">
          <source>ps</source>
          <target state="translated">추신</target>
        </trans-unit>
        <trans-unit id="22ea1c649c82946aa6e479e1ffd321e4a318b1b0" translate="yes" xml:space="preserve">
          <source>q</source>
          <target state="translated">큐</target>
        </trans-unit>
        <trans-unit id="4dc7c9ec434ed06502767136789763ec11d2c4b7" translate="yes" xml:space="preserve">
          <source>r</source>
          <target state="translated">아르 자형</target>
        </trans-unit>
        <trans-unit id="a415ab5cc17c8c093c015ccdb7e552aee7911aa4" translate="yes" xml:space="preserve">
          <source>random</source>
          <target state="translated">무작위</target>
        </trans-unit>
        <trans-unit id="0aa526fef0364a6010e9a179dd3199d9e5fadcd8" translate="yes" xml:space="preserve">
          <source>range(iterprod(mods))</source>
          <target state="translated">범위 (iterprod (mods))</target>
        </trans-unit>
        <trans-unit id="e1d98009a67f2aeb1d78cab5a72f9d99082b0340" translate="yes" xml:space="preserve">
          <source>reduce(lambda x,y: x*y, a)</source>
          <target state="translated">감소 (람다 x, y : x * y, a)</target>
        </trans-unit>
        <trans-unit id="4a9f9e7ff9f4b5aa4264aba8bbd30d1c6dc892e9" translate="yes" xml:space="preserve">
          <source>riemannzeta(n)</source>
          <target state="translated">리에 만 제타 (n)</target>
        </trans-unit>
        <trans-unit id="139262cfb795de87ca2c68ffa51eb483edac019f" translate="yes" xml:space="preserve">
          <source>riemannzeta(n, k) - 1</source>
          <target state="translated">리에 만 제타 (n, k)-1</target>
        </trans-unit>
        <trans-unit id="1737d3a2dc46463ad1bf10bf62768a92500b3111" translate="yes" xml:space="preserve">
          <source>secm</source>
          <target state="translated">secm</target>
        </trans-unit>
        <trans-unit id="925dc46d581dd0d18f35a2c0fb07716dc1efcd86" translate="yes" xml:space="preserve">
          <source>should be sorted in decreasing order.</source>
          <target state="translated">내림차순으로 정렬되어야합니다.</target>
        </trans-unit>
        <trans-unit id="7d13cc40a337e3f1ae20e91e68728dde0958d1d9" translate="yes" xml:space="preserve">
          <source>should usually be used instead.</source>
          <target state="translated">대신 일반적으로 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="abe2b85a053eeba46422394e9f07fd9592ac7fb4" translate="yes" xml:space="preserve">
          <source>slprp</source>
          <target state="translated">slprp</target>
        </trans-unit>
        <trans-unit id="295188241a81ec69699501e1cd20e5df674d028e" translate="yes" xml:space="preserve">
          <source>sqrts</source>
          <target state="translated">sqrts</target>
        </trans-unit>
        <trans-unit id="fdca81ff0033bd52e01e0c38528c9264aeefc4ea" translate="yes" xml:space="preserve">
          <source>such that</source>
          <target state="translated">그런</target>
        </trans-unit>
        <trans-unit id="20846584c637996ddae8a85fd4e9014218cf8219" translate="yes" xml:space="preserve">
          <source>such that 1 = 2&lt;sup&gt;n-1&lt;/sup&gt;.</source>
          <target state="translated">그래서 1 = 2 &lt;sup&gt;n-1&lt;/sup&gt; .</target>
        </trans-unit>
        <trans-unit id="1db8a2298feaca37566d15607275854d077f3496" translate="yes" xml:space="preserve">
          <source>such that &lt;em&gt;c&lt;/em&gt; &amp;equiv; &lt;em&gt;x&lt;/em&gt; (mod &lt;em&gt;y&lt;/em&gt;) for (&lt;em&gt;x&lt;/em&gt;, &lt;em&gt;y&lt;/em&gt;) in</source>
          <target state="translated">되도록 &lt;em&gt;C&lt;/em&gt; &amp;equiv; &lt;em&gt;X&lt;/em&gt; (MOD &lt;em&gt;Y&lt;/em&gt; (대) &lt;em&gt;X&lt;/em&gt; , &lt;em&gt;Y&lt;/em&gt; )에서</target>
        </trans-unit>
        <trans-unit id="16ffe9780e7b3df743714126040a34c7875445df" translate="yes" xml:space="preserve">
          <source>sum(totient(n) for n in range(1, n+1))</source>
          <target state="translated">sum (totient (n) for n in range (1, n + 1)))</target>
        </trans-unit>
        <trans-unit id="6e0beaf39654867287ea9229dfeb08d2335389d3" translate="yes" xml:space="preserve">
          <source>that form a coprime (</source>
          <target state="translated">코 프라임 (</target>
        </trans-unit>
        <trans-unit id="3975a92d6ff3dcb8adbe2c2c5932f8cc2816e1e0" translate="yes" xml:space="preserve">
          <source>then we compute U&lt;sub&gt;k&lt;/sub&gt; and V&lt;sub&gt;k&lt;/sub&gt; in O(ln(</source>
          <target state="translated">우리는 U가 계산 &lt;sub&gt;케이&lt;/sub&gt; 와 V의 &lt;sub&gt;K&lt;/sub&gt; (O에서 (LN</target>
        </trans-unit>
        <trans-unit id="202e8e8eb91d64ae945f1b2535b5c51729fa5ed8" translate="yes" xml:space="preserve">
          <source>times and * represents Dirichlet convolution.  The values returned will be</source>
          <target state="translated">시간 및 *는 Dirichlet 회선을 나타냅니다. 반환되는 값은</target>
        </trans-unit>
        <trans-unit id="69daf7983e3f8a68d4b9be209f74e83910a55801" translate="yes" xml:space="preserve">
          <source>to the &lt;a href=&quot;https://en.wikipedia.org/wiki/Dirichlet_eta_function&quot;&gt;Dirichlet eta function&lt;/a&gt;.  Should be rather accurate throughout the complex plane except near</source>
          <target state="translated">받는 &lt;a href=&quot;https://en.wikipedia.org/wiki/Dirichlet_eta_function&quot;&gt;디리클레 ETA 기능&lt;/a&gt; . 근처를 제외하고 복잡한 평면 전체에서 다소 정확해야합니다.</target>
        </trans-unit>
        <trans-unit id="b9b3cba50dbf3adefc333414e44b38442cf55715" translate="yes" xml:space="preserve">
          <source>to the Dirichlet eta function.  Designed to be accurate even when</source>
          <target state="translated">Dirichlet eta 함수에. 언제라도 정확하도록 설계</target>
        </trans-unit>
        <trans-unit id="0d49bceae9764f901fbe19c45ce8d0429e61ae8f" translate="yes" xml:space="preserve">
          <source>using at least the indicated number of terms and whose denominators are all &amp;ge; minden.  No algorithm is known for this problem that significantly improves upon brute force, so this can take impractically long times on even modest-seeming inputs.</source>
          <target state="translated">최소한 표시된 수의 용어를 사용하고 분모가 모두 &amp;ge; minden입니다. 무차별 대입을 크게 개선하는이 문제에 대한 알고리즘은 알려져 있지 않으므로 겸손하게 보이는 입력에서도 비현실적으로 오랜 시간이 걸릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0251bb8c786cf88db78b92a0f771f8bf6c04869a" translate="yes" xml:space="preserve">
          <source>using parameters provided by</source>
          <target state="translated">에서 제공하는 매개 변수 사용</target>
        </trans-unit>
        <trans-unit id="5e6e4c0fb8ef47b4f1d6eea3e6c51152dbee94ec" translate="yes" xml:space="preserve">
          <source>val1</source>
          <target state="translated">val1</target>
        </trans-unit>
        <trans-unit id="25f05eec259d12623e65c0c20a1eadedeaa3822a" translate="yes" xml:space="preserve">
          <source>via the Meissel-Lehmer method.  The arguments</source>
          <target state="translated">Meissel-Lehmer 방법을 통해. 인수</target>
        </trans-unit>
        <trans-unit id="30603fa9e0f620c305cd627ab0ff138a960c48bd" translate="yes" xml:space="preserve">
          <source>when</source>
          <target state="translated">언제</target>
        </trans-unit>
        <trans-unit id="1291f62516ba88e56c8eba45b01c44dec887206b" translate="yes" xml:space="preserve">
          <source>when attempting to evaluate</source>
          <target state="translated">평가하려고 할 때</target>
        </trans-unit>
        <trans-unit id="6a42677517d955828716befce981ad0a0d6dd915" translate="yes" xml:space="preserve">
          <source>where the initial values are [&lt;em&gt;x&lt;/em&gt;&lt;sub&gt;0&lt;/sub&gt;, &amp;hellip;, &lt;em&gt;x&lt;/em&gt;&lt;sub&gt;k&lt;/sub&gt;] =</source>
          <target state="translated">초기 값은 [ &lt;em&gt;x &lt;/em&gt;&lt;sub&gt;0&lt;/sub&gt; ,&amp;hellip;, &lt;em&gt;x &lt;/em&gt;&lt;sub&gt;k&lt;/sub&gt; ] =</target>
        </trans-unit>
        <trans-unit id="12f847846c97f0fb0288ace1b3d95fcdb3b5ca10" translate="yes" xml:space="preserve">
          <source>whose value at 1 is</source>
          <target state="translated">1의 값은</target>
        </trans-unit>
        <trans-unit id="2a873cdbb5b91b1f460dac913d0821840473a2ef" translate="yes" xml:space="preserve">
          <source>will return</source>
          <target state="translated">돌아올 것이다</target>
        </trans-unit>
        <trans-unit id="143375b8e5feeb7dee58a5e69d40b8563339ca29" translate="yes" xml:space="preserve">
          <source>williams_pp1</source>
          <target state="translated">williams_pp1</target>
        </trans-unit>
        <trans-unit id="aa75b06d15054dd7062eecc1a854a090b01f54f0" translate="yes" xml:space="preserve">
          <source>with parameters (</source>
          <target state="translated">매개 변수 (</target>
        </trans-unit>
        <trans-unit id="312bc8ad198de0303fe47e34a05c081776f7cd10" translate="yes" xml:space="preserve">
          <source>with the same parameters.</source>
          <target state="translated">동일한 매개 변수로.</target>
        </trans-unit>
        <trans-unit id="11f6ad8ec52a2984abaafd7c3b516503785c2072" translate="yes" xml:space="preserve">
          <source>x</source>
          <target state="translated">엑스</target>
        </trans-unit>
        <trans-unit id="68ebb00048d792472ece36448817bfb237e238f4" translate="yes" xml:space="preserve">
          <source>xslprp</source>
          <target state="translated">xslprp</target>
        </trans-unit>
        <trans-unit id="dd7b7b74ea160e049dd128478e074ce47254bde8" translate="yes" xml:space="preserve">
          <source>xx</source>
          <target state="translated">더블 엑스</target>
        </trans-unit>
        <trans-unit id="34d8f96ae05eeccb172e84f975ccfb986b190d79" translate="yes" xml:space="preserve">
          <source>yields all solutions.</source>
          <target state="translated">모든 솔루션을 산출합니다.</target>
        </trans-unit>
        <trans-unit id="395df8f7c51f007019cb30201c49e884b46b92fa" translate="yes" xml:space="preserve">
          <source>z</source>
          <target state="translated">지</target>
        </trans-unit>
        <trans-unit id="029a3fcb010f8f92628023b595f00551a85179ef" translate="yes" xml:space="preserve">
          <source>zc</source>
          <target state="translated">zc</target>
        </trans-unit>
        <trans-unit id="7ac99c00e5aa89607950c93d6a0bcf99ac0cb028" translate="yes" xml:space="preserve">
          <source>zip(rems, mods)</source>
          <target state="translated">zip (rems, mods)</target>
        </trans-unit>
        <trans-unit id="3eb416223e9e69e6bb8ee19793911ad1ad2027d8" translate="yes" xml:space="preserve">
          <source>|</source>
          <target state="translated">|</target>
        </trans-unit>
        <trans-unit id="e298e579515bfddfe989d1a89ee2e1bcd4916f5c" translate="yes" xml:space="preserve">
          <source>| &amp;middot; &lt;em&gt;y&lt;/em&gt;&lt;sup&gt;2&lt;/sup&gt; =</source>
          <target state="translated">| &amp;middot; &lt;em&gt;y &lt;/em&gt;&lt;sup&gt;2&lt;/sup&gt; =</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
