<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://pypi.org/project/httpsdate/">
    <body>
      <group id="httpsdate">
        <trans-unit id="629f339ece5f916f34cf1b4dbad7d4522d7cac44" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;httpsdate.py&lt;/code&gt; automatically runs with minimal privileges.</source>
          <target state="translated">&lt;code&gt;httpsdate.py&lt;/code&gt; 는 최소 권한으로 자동 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="e1e08b267be9d956bf48997fc45771b79b2a5362" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;httpsdate.py&lt;/code&gt; depends on other software.
For instance, is written in python and runs on the Linux kernel.
Bugs in the python interpreter and the Linux kernel may therefore affect &lt;code&gt;httpsdate.py&lt;/code&gt;.
&lt;code&gt;httpsdate.py&lt;/code&gt; may have bugs of its own.</source>
          <target state="translated">&lt;code&gt;httpsdate.py&lt;/code&gt; 는 다른 소프트웨어에 따라 다릅니다. 예를 들어는 python으로 작성되고 Linux 커널에서 실행됩니다. 따라서 Python 인터프리터 및 Linux 커널의 버그가 &lt;code&gt;httpsdate.py&lt;/code&gt; 에 영향을 미칠 수 있습니다 . &lt;code&gt;httpsdate.py&lt;/code&gt; 에는 자체 버그가있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0504961d05ce8599a70c91964218d7f18a03212b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;httpsdate.py&lt;/code&gt; does not necessarily rely on a single server to provide the correct time.</source>
          <target state="translated">&lt;code&gt;httpsdate.py&lt;/code&gt; 는 정확한 시간을 제공하기 위해 반드시 단일 서버에 의존하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8ea02d635f3483f969a737b81f520b5f674bd95c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;httpsdate.py&lt;/code&gt; exits when it is done.
To keep the system clock in sync over a extended period of time, simply run &lt;code&gt;httpsdate.py&lt;/code&gt; regularly, for example as a cron job or systemd timer.</source>
          <target state="translated">&lt;code&gt;httpsdate.py&lt;/code&gt; 완료되면 httpsdate.py가 종료됩니다. 오랜 시간 동안 시스템 시계를 동기화 상태로 유지하려면 &lt;code&gt;httpsdate.py&lt;/code&gt; 를 정기적으로 실행 하십시오 ( 예 : cron 작업 또는 systemd 타이머).</target>
        </trans-unit>
        <trans-unit id="b333029a1b8074654863faf9aba17c1035197c08" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;httpsdate.py&lt;/code&gt; itself is FOSS and fairly short and simple code.
It actually has fewer raw lines than this readme.
The code can be audited independently to increase the confidence that it does not exhibit any undesirable behaviour.</source>
          <target state="translated">&lt;code&gt;httpsdate.py&lt;/code&gt; 자체는 FOSS이며 상당히 짧고 간단한 코드입니다. 실제로이 readme보다 원시 줄이 적습니다. 코드를 독립적으로 감사하여 원하지 않는 동작을 나타내지 않는다는 확신을 높일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1c0f0e5206521cd14ab8873a77e214284d339540" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;httpsdate.py&lt;/code&gt; queries one or more HTTPS servers for the timestamp in the &lt;code&gt;Date&lt;/code&gt; HTTP header.
The system clock is then set to the median of the timestamps obtained this way.</source>
          <target state="translated">&lt;code&gt;httpsdate.py&lt;/code&gt; 는 &lt;code&gt;Date&lt;/code&gt; HTTP 헤더 의 타임 스탬프에 대해 하나 이상의 HTTPS 서버를 쿼리합니다 . 그런 다음 시스템 시계는 이런 방식으로 얻은 타임 스탬프의 중앙값으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="983469f4fc141dc32bb0f1900f957385c25542ac" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;httpsdate.py&lt;/code&gt; retrieves the remote time from the &lt;code&gt;Date&lt;/code&gt; HTTP header, which only has a resolution of one second.
Hence, sub-second accuracy is simply not achievable with this approach.</source>
          <target state="translated">&lt;code&gt;httpsdate.py&lt;/code&gt; 는 1 초의 해상도 만 있는 &lt;code&gt;Date&lt;/code&gt; HTTP 헤더 에서 원격 시간을 검색합니다 . 따라서이 접근 방식으로는 1 초 미만의 정확도를 달성 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="6e07585f1eae7037614e22195a72383a43777539" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;httpsdate.py&lt;/code&gt; should also run on Python 3.3.
Before 3.4.3 Python did not validate HTTPS certificates by default, thus rendering HTTPS vulnerable to man-in-the-middle attacks, unless the respective code sets up validation.
&lt;code&gt;httpsdate.py&lt;/code&gt; relies on Python do the right thing and should therefore not be used with Python versions before 3.4.3 (unless they are patched, that is).</source>
          <target state="translated">&lt;code&gt;httpsdate.py&lt;/code&gt; 는 Python 3.3에서도 실행되어야합니다. 3.4.3 이전에는 Python이 기본적으로 HTTPS 인증서의 유효성을 검사하지 않았으므로 해당 코드가 유효성 검사를 설정하지 않는 한 HTTPS를 중간자 공격에 취약하게 만들었습니다. &lt;code&gt;httpsdate.py&lt;/code&gt; 는 Python에 의존하여 올바른 작업을 수행하므로 3.4.3 이전의 Python 버전에서 사용해서는 안됩니다 (패치되지 않는 한).</target>
        </trans-unit>
        <trans-unit id="b05cb5e1e18d30314cc4a708009bddd307670b42" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;httpsdate.py&lt;/code&gt; validates the X.509 certificates of the remote servers.
This effectively authenticates the time information using the X.509 PKI system.
Therefore, a man-in-the-middle attacker can not deliberately set an incorrect time without breaking the TLS connection(s).</source>
          <target state="translated">&lt;code&gt;httpsdate.py&lt;/code&gt; 는 원격 서버의 X.509 인증서의 유효성을 검사합니다. 이것은 X.509 PKI 시스템을 사용하여 시간 정보를 효과적으로 인증합니다. 따라서 중간자 공격자는 TLS 연결을 끊지 않고 의도적으로 잘못된 시간을 설정할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="a069bb0d2e80294ddc49789ba15af12aceaac759" translate="yes" xml:space="preserve">
          <source>A man-in-the-middle attacker who also controls (at least) one of the queried servers can easily drop connections to the servers they do not control and therefore force a single usable time value.</source>
          <target state="translated">쿼리 된 서버 중 하나를 (적어도) 제어하는 ​​중간자 공격자는 제어하지 않는 서버에 대한 연결을 쉽게 끊을 수 있으므로 사용 가능한 단일 시간 값을 강제로 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6c62befad2017ce257f32521b231a0989cf15861" translate="yes" xml:space="preserve">
          <source>As long as more than half of the timestamps are correct, the resulting system time is correct.
It may however, loose a few seconds of accuracy, due to the limitations imposed by the very simplistic protocol.</source>
          <target state="translated">타임 스탬프의 절반 이상이 정확하면 결과 시스템 시간도 정확합니다. 그러나 매우 단순한 프로토콜에 의해 부과 된 제한으로 인해 몇 초의 정확도가 떨어질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="902a146f48dede1f8a184e866e6cea2a8abca97d" translate="yes" xml:space="preserve">
          <source>As mentioned above, it is also possible to query multiple servers:</source>
          <target state="translated">위에서 언급했듯이 여러 서버를 쿼리 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="9ada26eb5bad6e4ffa674849a18d64f2685e206d" translate="yes" xml:space="preserve">
          <source>As mentioned earlier, the accuracy of &lt;code&gt;httpsdate.py&lt;/code&gt; is not very high.
&quot;Not very high&quot; means that is should usually be within a few seconds of the reference time.
This is not ideal, but good enough for most purposes.</source>
          <target state="translated">앞서 언급했듯이 &lt;code&gt;httpsdate.py&lt;/code&gt; 의 정확도는 그리 높지 않습니다. &quot;그다지 높지 않음&quot;은 일반적으로 기준 시간에서 몇 초 이내에 있어야 함을 의미합니다. 이것은 이상적이지는 않지만 대부분의 목적에 충분합니다.</target>
        </trans-unit>
        <trans-unit id="5f551a660dd21d3ff74bfdd5185fdbb9c875e881" translate="yes" xml:space="preserve">
          <source>Before explaining the other options of &lt;code&gt;httpsdate.py&lt;/code&gt;, let's have a look at the help message:</source>
          <target state="translated">&lt;code&gt;httpsdate.py&lt;/code&gt; 의 다른 옵션을 설명하기 전에 도움말 메시지를 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="ed5ec37b755eb9bd563188caae7e14161937848c" translate="yes" xml:space="preserve">
          <source>By setting the system clock to a value obtained from a remote server, one trusts the remote server's administrator to keep their time correct (and reasonably accurate).</source>
          <target state="translated">시스템 시계를 원격 서버에서 얻은 값으로 설정하면 원격 서버의 관리자가 시간을 정확하고 합리적으로 정확하게 유지하도록 신뢰합니다.</target>
        </trans-unit>
        <trans-unit id="f135c7464856b34cd1f134e48f7f75096fab7aa8" translate="yes" xml:space="preserve">
          <source>Considerations on Accuracy</source>
          <target state="translated">정확성에 대한 고려 사항</target>
        </trans-unit>
        <trans-unit id="74ddc5cd83ef11d94da01737c5813d84cbc21116" translate="yes" xml:space="preserve">
          <source>For better accuracy control, &lt;code&gt;--timeout&lt;/code&gt; can be used to change the HTTPS network timeout for the connections to the remote servers.
Remote servers that do not respond within the time limit are simply skipped and count as failed.
This can help reducing the delay between obtaining the remote time and actually changing the system clock.</source>
          <target state="translated">보다 정확한 제어를 위해 &lt;code&gt;--timeout&lt;/code&gt; 을 사용하여 원격 서버 연결에 대한 HTTPS 네트워크 시간 제한을 변경할 수 있습니다. 제한 시간 내에 응답하지 않는 원격 서버는 건너 뛰고 실패한 것으로 간주됩니다. 이렇게하면 원격 시간 확보와 실제로 시스템 시계 변경 사이의 지연을 줄이는 데 도움이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="646b8feff01a7ef332de26e746e328a2e4e52bce" translate="yes" xml:space="preserve">
          <source>For convenience, &lt;code&gt;httpsdate.py&lt;/code&gt; can also be installed using &lt;code&gt;pip&lt;/code&gt;:</source>
          <target state="translated">편의를 위해 &lt;code&gt;pip&lt;/code&gt; 를 사용하여 &lt;code&gt;httpsdate.py&lt;/code&gt; 를 설치할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c8e6559e858d5da6fe03f76864e0c4e54366af71" translate="yes" xml:space="preserve">
          <source>For this reason, &lt;code&gt;httpsdate.py&lt;/code&gt; attempts adhering to the principle of least privilege.
Setting the system clock on Linux requires elevated privileges, but not full &lt;code&gt;root&lt;/code&gt; privileges.
&lt;code&gt;httpsdate.py&lt;/code&gt; works well with only the capability &lt;code&gt;CAP_SYS_TIME&lt;/code&gt;, which is required to set the clock.
If it is started with full &lt;code&gt;root&lt;/code&gt; privileges, which is often more convenient than employing fine-grained capability control, it drops all unnecessary privileges and runs with the user and group id of an unprivileged user.
This is, of course, done before connecting to the network.</source>
          <target state="translated">이러한 이유로 &lt;code&gt;httpsdate.py&lt;/code&gt; 는 최소 권한 원칙을 고수하려고합니다. Linux에서 시스템 시계를 설정하려면 높은 권한이 필요하지만 전체 &lt;code&gt;root&lt;/code&gt; 권한 은 필요하지 않습니다 . &lt;code&gt;httpsdate.py&lt;/code&gt; 는 시계를 설정하는 데 필요한 &lt;code&gt;CAP_SYS_TIME&lt;/code&gt; 기능에서만 잘 작동합니다 . 세분화 된 기능 제어를 사용하는 것보다 더 편리한 경우가 많은 전체 &lt;code&gt;root&lt;/code&gt; 권한으로 시작하는 경우 불필요한 권한을 모두 삭제하고 권한이없는 사용자의 사용자 및 그룹 ID로 실행됩니다. 물론 이것은 네트워크에 연결하기 전에 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="e21860bf37328b97ebb0ddd904694c78e4a7b382" translate="yes" xml:space="preserve">
          <source>How does it work?</source>
          <target state="translated">어떻게 작동합니까?</target>
        </trans-unit>
        <trans-unit id="e13e18f3a4a56aeb9973b0c1bdfe43af2d3c3e20" translate="yes" xml:space="preserve">
          <source>How to use it</source>
          <target state="translated">사용 방법</target>
        </trans-unit>
        <trans-unit id="403ec604cc3568afb0e3b4bf6ad44ed0a3725f00" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;httpsdate.py&lt;/code&gt; is invoked with &lt;code&gt;root&lt;/code&gt; privileges, it will automatically drop all privileges except &lt;code&gt;CAP_SYS_TIME&lt;/code&gt; (which is required for setting the system clock) and switch to a non-privileged user.
Use &lt;code&gt;--user&lt;/code&gt; to specify what user account to switch to.</source>
          <target state="translated">&lt;code&gt;httpsdate.py&lt;/code&gt; 가 &lt;code&gt;root&lt;/code&gt; 권한 으로 호출 되면 &lt;code&gt;CAP_SYS_TIME&lt;/code&gt; (시스템 시계 설정에 필요)을 제외한 모든 권한이 자동으로 삭제 되고 권한이없는 사용자로 전환됩니다. 사용 &lt;code&gt;--user&lt;/code&gt; 로 전환하려면 어떤 사용자 계정을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4265509f228f203eab4cd3a2e8065e57013b66e1" translate="yes" xml:space="preserve">
          <source>If either command throws an error containing &lt;code&gt;CERTIFICATE_VERIFY_FAILED&lt;/code&gt;, all is well and Python &lt;em&gt;does&lt;/em&gt; validate certificates.</source>
          <target state="translated">두 명령 중 하나가 &lt;code&gt;CERTIFICATE_VERIFY_FAILED&lt;/code&gt; 를 포함하는 오류를 던지면 모든 것이 정상 이며 Python &lt;em&gt;은&lt;/em&gt; 인증서의 유효성을 검사합니다.</target>
        </trans-unit>
        <trans-unit id="99241998a2c4ecfccb326b1461eaf3e7c149a0d2" translate="yes" xml:space="preserve">
          <source>In case of doubt, one can run</source>
          <target state="translated">의심스러운 경우에는 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0daf46cf06d902e08d70effd4516b727ef1e4333" translate="yes" xml:space="preserve">
          <source>In order to reduce the amount of trust that needs to be put in each remote server, &lt;code&gt;httpsdate.py&lt;/code&gt; can use multiple servers.
If more than half of the remote servers that provide a usable time also provide a correct time, the use of the median ensures that the selected time is bounded by correct time values.
Therefore, a single rogue server can not influence the resulting system time (as long as at least two other servers respond, that is).</source>
          <target state="translated">각 원격 서버에 넣어야하는 신뢰의 양을 줄이기 위해 &lt;code&gt;httpsdate.py&lt;/code&gt; 는 여러 서버를 사용할 수 있습니다. 사용 가능한 시간을 제공하는 원격 서버의 절반 이상이 올바른 시간을 제공하는 경우 중앙값을 사용하면 선택한 시간이 올바른 시간 값으로 제한됩니다. 따라서 단일 불량 서버는 결과 시스템 시간에 영향을 줄 수 없습니다 (최소 두 대의 다른 서버가 응답하는 한).</target>
        </trans-unit>
        <trans-unit id="c81b79df3c6448eae7c4f80428b54cd5692a17d7" translate="yes" xml:space="preserve">
          <source>Installation</source>
          <target state="translated">설치</target>
        </trans-unit>
        <trans-unit id="63ecdf3b73aa896d73c5b32f5e0b9da41b096a9e" translate="yes" xml:space="preserve">
          <source>It is not necessary to run &lt;code&gt;httpsdate.py&lt;/code&gt; as &lt;code&gt;root&lt;/code&gt;.
Running it with only &lt;code&gt;CAP_SYS_TIME&lt;/code&gt; is sufficient.
Without further privileges, it can obviously not switch the user and silently ignores the &lt;code&gt;--user&lt;/code&gt; option, if provided.</source>
          <target state="translated">&lt;code&gt;httpsdate.py&lt;/code&gt; 를 &lt;code&gt;root&lt;/code&gt; 로 실행할 필요는 없습니다 . &lt;code&gt;CAP_SYS_TIME&lt;/code&gt; 만으로 실행하면 충분합니다. 추가 권한이 없으면 분명히 사용자를 전환 할 수 없으며 제공되는 경우 &lt;code&gt;--user&lt;/code&gt; 옵션을 자동으로 무시합니다 .</target>
        </trans-unit>
        <trans-unit id="3229609e15436ec51bcf00818a69a84dbc58a0c2" translate="yes" xml:space="preserve">
          <source>License</source>
          <target state="translated">특허</target>
        </trans-unit>
        <trans-unit id="555d0b4bc4d0753891064c9dcd2314589cedcd25" translate="yes" xml:space="preserve">
          <source>Linux Kernel 3.5 or newer</source>
          <target state="translated">Linux Kernel 3.5 이상</target>
        </trans-unit>
        <trans-unit id="89690ac571dcf4c9c40c842efed3f11171d07b29" translate="yes" xml:space="preserve">
          <source>MIT</source>
          <target state="translated">MIT</target>
        </trans-unit>
        <trans-unit id="575343012a6db5cd6b0c5a6b4f0c3cf5251bd57b" translate="yes" xml:space="preserve">
          <source>Man-in-the-Middle and Rogue Servers</source>
          <target state="translated">Man-in-the-Middle 및 Rogue 서버</target>
        </trans-unit>
        <trans-unit id="4132ae2e5011aeea9106f533ca4ab274ead2fd58" translate="yes" xml:space="preserve">
          <source>Man-in-the-Middle attacks</source>
          <target state="translated">중간자 (Man-in-the-Middle) 공격</target>
        </trans-unit>
        <trans-unit id="e1b456759c67630ad993ea04911e779751ef51a9" translate="yes" xml:space="preserve">
          <source>Network Delays</source>
          <target state="translated">네트워크 지연</target>
        </trans-unit>
        <trans-unit id="5f271c3582c2a7d6f4b5b67d11242e4a65b3a752" translate="yes" xml:space="preserve">
          <source>No installation is required.
It is enough to download and run &lt;code&gt;httpsdate.py&lt;/code&gt;.</source>
          <target state="translated">설치가 필요하지 않습니다. &lt;code&gt;httpsdate.py&lt;/code&gt; 를 다운로드하고 실행하는 것으로 충분합니다 .</target>
        </trans-unit>
        <trans-unit id="58369958d80082c730e784e46e959bb26d476907" translate="yes" xml:space="preserve">
          <source>Python 3.4.3 or newer</source>
          <target state="translated">Python 3.4.3 이상</target>
        </trans-unit>
        <trans-unit id="b2e50383765ee174af4820e12bfc53ddebe9c1de" translate="yes" xml:space="preserve">
          <source>Remote Clock Accuracy</source>
          <target state="translated">원격 클록 정확도</target>
        </trans-unit>
        <trans-unit id="09a428f93ec07a73d726f8bd037ecacfaaf8b044" translate="yes" xml:space="preserve">
          <source>Requirements</source>
          <target state="translated">요구 사항</target>
        </trans-unit>
        <trans-unit id="516aae52959dcf5398a9985414a78b8c24a4f0e5" translate="yes" xml:space="preserve">
          <source>Resolution</source>
          <target state="translated">해결</target>
        </trans-unit>
        <trans-unit id="2b7a71eccbc0f55ab53d78e11f0f11e35a020482" translate="yes" xml:space="preserve">
          <source>Rogue Servers</source>
          <target state="translated">불량 서버</target>
        </trans-unit>
        <trans-unit id="402cc3b6686cd294cb10dd3f5bccbebd0edd8a9b" translate="yes" xml:space="preserve">
          <source>Security Considerations</source>
          <target state="translated">보안 고려 사항</target>
        </trans-unit>
        <trans-unit id="4bd17df6f90233571eb2d51ce893467e642b1be4" translate="yes" xml:space="preserve">
          <source>See [below](#Rogue Servers) on why one would want to do that.</source>
          <target state="translated">왜 그렇게 하려는지에 대해서는 [아래] (# Rogue Servers)를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="0c885d99f8d57f887d6e46b5d7134b55b43bead8" translate="yes" xml:space="preserve">
          <source>Several of today's security technologies assume a correct local clock.
One example is certificate expiration.</source>
          <target state="translated">오늘날의 여러 보안 기술은 정확한 로컬 시계를 가정합니다. 한 가지 예는 인증서 만료입니다.</target>
        </trans-unit>
        <trans-unit id="594dbd6ed77baacb9685e9f8388dd3b6fe9506e8" translate="yes" xml:space="preserve">
          <source>Similarly, &lt;code&gt;--max-failed&lt;/code&gt; limits the fault tolerance of &lt;code&gt;httpsdate.py&lt;/code&gt;.
It will not change the system clock if more than this many remote servers failed to send a usable time.
Reasons for not getting a usable time include invalid X.509 certificates, TLS parameter incompatibilities or missing or invalid &lt;code&gt;Date&lt;/code&gt; headers.</source>
          <target state="translated">마찬가지로 &lt;code&gt;--max-failed&lt;/code&gt; 는 &lt;code&gt;httpsdate.py&lt;/code&gt; 의 내결함성을 제한합니다 . 이보다 많은 원격 서버가 사용 가능한 시간을 보내지 못하는 경우 시스템 시계를 변경하지 않습니다. 사용 가능한 시간을 얻지 못하는 이유에는 잘못된 X.509 인증서, TLS 매개 변수 비 호환성 또는 누락되거나 잘못된 &lt;code&gt;Date&lt;/code&gt; 헤더가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="0729b4d1198d9df1b86350df2b526d6cd827f3b2" translate="yes" xml:space="preserve">
          <source>Simple and secure system time synchronisation over HTTPS</source>
          <target state="translated">HTTPS를 통한 간단하고 안전한 시스템 시간 동기화</target>
        </trans-unit>
        <trans-unit id="8253efd53fa8e2daed3fb376524e22d60826910d" translate="yes" xml:space="preserve">
          <source>Software Bugs</source>
          <target state="translated">소프트웨어 버그</target>
        </trans-unit>
        <trans-unit id="4f85946df1ae01f7150ea835ecdd56478e3e2c08" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Date&lt;/code&gt; header is not intended for communicating accurate, current time information.
Therefore, administrators of HTTPS servers may not keep their own clock very accurate.
Moreover, caching (reverse) proxy servers and similar network components may result in stale &lt;code&gt;Date&lt;/code&gt; headers being returned by remote servers.</source>
          <target state="translated">&lt;code&gt;Date&lt;/code&gt; 헤더는 정확한 현재 시간 정보를 전달하기위한 것이 아닙니다. 따라서 HTTPS 서버 관리자는 자신의 시계를 매우 정확하게 유지하지 못할 수 있습니다. 또한 캐싱 (역방향) 프록시 서버 및 유사한 네트워크 구성 요소 로 인해 원격 서버 에서 오래된 &lt;code&gt;Date&lt;/code&gt; 헤더가 반환 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a4e3f83847b6fe49229921e29961b78ef08d772c" translate="yes" xml:space="preserve">
          <source>The attacker can, however, drop the connections, thus preventing time synchronisation.</source>
          <target state="translated">그러나 공격자는 연결을 끊을 수 있으므로 시간 동기화를 방지 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3afb2175ee13048da56727a9a3ad014158607803" translate="yes" xml:space="preserve">
          <source>The most simple way to use it is to run something like the following command as &lt;code&gt;root&lt;/code&gt;:</source>
          <target state="translated">이를 사용하는 가장 간단한 방법은 &lt;code&gt;root&lt;/code&gt; 로 다음 명령을 실행하는 것입니다 .</target>
        </trans-unit>
        <trans-unit id="18b45aae0e104184db4e2e34f9a6334df49e7d8e" translate="yes" xml:space="preserve">
          <source>The time, as set by the remote server, takes some time to reach &lt;code&gt;httpsdate.py&lt;/code&gt;, which then takes a few more CPU cycles before the system clock is set.
&lt;code&gt;httpsdate.py&lt;/code&gt; does not do anything clever to correct these delays or even measure the amount of error.
This simply has not been given consideration and likely never will be.
Any attempts may turn out to be infeasible due to the limited resolution of the obtained time data.</source>
          <target state="translated">원격 서버에서 설정 한 시간은 &lt;code&gt;httpsdate.py&lt;/code&gt; 에 도달하는 데 약간의 시간이 걸리며 시스템 시계가 설정되기 전에 몇 개의 CPU주기가 더 걸립니다. &lt;code&gt;httpsdate.py&lt;/code&gt; 는 이러한 지연을 수정하거나 오류 양을 측정하기 위해 영리한 작업을 수행하지 않습니다. 이것은 단순히 고려되지 않았으며 결코 그렇지 않을 것입니다. 획득 한 시간 데이터의 제한된 해상도로 인해 모든 시도가 실행 불가능한 것으로 판명 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8346a56084f0e28347950887f2e1dfb6a15aee74" translate="yes" xml:space="preserve">
          <source>The usual methods for reducing network delays apply, e.g. picking servers that have quick response times.</source>
          <target state="translated">네트워크 지연을 줄이는 일반적인 방법이 적용됩니다 (예 : 응답 시간이 빠른 서버 선택).</target>
        </trans-unit>
        <trans-unit id="76c64a56c2fa4e25d49853d17bcd3e0f84a54b17" translate="yes" xml:space="preserve">
          <source>There are three factors that influence the accuracy and that can, to some extent, be taken into account in order to get better results.</source>
          <target state="translated">정확도에 영향을 미치는 세 가지 요소가 있으며 더 나은 결과를 얻기 위해 어느 정도 고려할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="febd821b9a135f5581073a3ce7a5a9da80454ee5" translate="yes" xml:space="preserve">
          <source>There are, however, further security measures that &lt;code&gt;httpsdate.py&lt;/code&gt; does not currently employ itself, such as namespaces and seccomp filters.
It should be possible to use &lt;code&gt;httpsdate.py&lt;/code&gt; together with these technologies, if they are not configured too restrictive.
To run &lt;code&gt;httpsdate.py&lt;/code&gt; in a restricted sandbox, one can use systemd, bubblewrap or firejail, for instance.</source>
          <target state="translated">그러나 네임 스페이스 및 seccomp 필터와 같이 &lt;code&gt;httpsdate.py&lt;/code&gt; 가 현재 자체적으로 사용하지 않는 추가 보안 조치가 있습니다. 너무 제한적으로 구성되지 않은 경우 이러한 기술과 함께 &lt;code&gt;httpsdate.py&lt;/code&gt; 를 사용할 수 있어야합니다 . 제한된 샌드 박스에서 &lt;code&gt;httpsdate.py&lt;/code&gt; 를 실행하려면 예를 들어 systemd, bubblewrap 또는 firejail을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1f0bca3e3f79c6c39aecfe6f5faf33eb29118963" translate="yes" xml:space="preserve">
          <source>This is a (fairly) simple python script that sets the system clock to a value obtained from a set of HTTPS servers.
This provides a simple and secure, but not very accurate method of time synchronisation.</source>
          <target state="translated">이것은 시스템 시계를 HTTPS 서버 세트에서 얻은 값으로 설정하는 (상당히) 간단한 파이썬 스크립트입니다. 이것은 간단하고 안전하지만 시간 동기화의 매우 정확한 방법은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="458d0f2abcf9d2be50d210789333ec31725de59e" translate="yes" xml:space="preserve">
          <source>This method and the script &lt;a href=&quot;https://github.com/hannob/httpstime&quot;&gt;&lt;code&gt;httpstime&lt;/code&gt;&lt;/a&gt; are what inspired &lt;code&gt;httpsdate.py&lt;/code&gt;.
It was written to overcome some of the limitations imposed by the simplistic design of &lt;code&gt;httpstime&lt;/code&gt;:</source>
          <target state="translated">이 방법과 스크립트 &lt;a href=&quot;https://github.com/hannob/httpstime&quot;&gt; &lt;code&gt;httpstime&lt;/code&gt; &lt;/a&gt; 은 httpsdate.py 에 영감을 준 &lt;code&gt;httpsdate.py&lt;/code&gt; 입니다. &lt;code&gt;httpstime&lt;/code&gt; 의 단순한 설계로 인해 부과 된 몇 가지 한계를 극복하기 위해 작성되었습니다 .</target>
        </trans-unit>
        <trans-unit id="275a3aa3e19255b9941bba81502c53b0107154bb" translate="yes" xml:space="preserve">
          <source>This will get the current time from &lt;a href=&quot;https://www.ptb.de/&quot;&gt;www.ptb.de&lt;/a&gt; and set the local system clock to match it.
The console output looks something like this:</source>
          <target state="translated">이것은 &lt;a href=&quot;https://www.ptb.de/&quot;&gt;www.ptb.de&lt;/a&gt; 에서 현재 시간을 가져와 로컬 시스템 시계를 이에 맞게 설정합니다. 콘솔 출력은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="adfb08ccb69d10323886ee9e5ebd2c781de4765d" translate="yes" xml:space="preserve">
          <source>Unfortunately, the choice of secure and reliable clock synchronisation protocols is scarce.
A discussion of the sorry state of today's options can be found in &lt;a href=&quot;https://blog.hboeck.de/archives/890-In-Search-of-a-Secure-Time-Source.html&quot;&gt;https://blog.hboeck.de/archives/890-In-Search-of-a-Secure-Time-Source.html&lt;/a&gt; by @hannob.
The author also came up with a simple, yet effective method of securely synchronising the system clock with a remote server.</source>
          <target state="translated">안타깝게도 안전하고 신뢰할 수있는 클록 동기화 프로토콜의 선택은 거의 없습니다. 오늘 옵션의 미안한 상태에 대한 토론은 @hannob의 &lt;a href=&quot;https://blog.hboeck.de/archives/890-In-Search-of-a-Secure-Time-Source.html&quot;&gt;https://blog.hboeck.de/archives/890-In-Search-of-a-Secure-Time-Source.html&lt;/a&gt; 에서 찾을 수 있습니다 . 저자는 또한 시스템 시계를 원격 서버와 안전하게 동기화하는 간단하면서도 효과적인 방법을 제시했습니다.</target>
        </trans-unit>
        <trans-unit id="c790102b4d16fca3f8bf025844167555b95d3f15" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;--dry-run&lt;/code&gt; in order to just see what would happen but not actually change the system clock.</source>
          <target state="translated">&lt;code&gt;--dry-run&lt;/code&gt; 을 사용 하여 어떤 일이 발생하는지 확인하고 실제로 시스템 시계를 변경하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="80e3646c106ee2bd82189460638757a6379217da" translate="yes" xml:space="preserve">
          <source>Using the parameter &lt;code&gt;--max-failed&lt;/code&gt; provides some protection in this scenario as the acceptable number of failed remote servers - e.g. due to dropped connections - can be limited.
This effectively raises the number of servers that need to be under the control of the attacker.
Still, more than half of the responses need to be correct to ensure that the system clock is set to a correct time.</source>
          <target state="translated">&lt;code&gt;--max-failed&lt;/code&gt; 매개 변수를 사용하면 실패한 원격 서버의 허용 가능한 수 (예 : 연결 끊김)가 제한 될 수 있으므로이 시나리오에서 일부 보호 기능을 제공합니다. 이는 공격자가 제어해야하는 서버의 수를 효과적으로 증가시킵니다. 그러나 시스템 시계가 정확한 시간으로 설정되도록하려면 응답의 절반 이상이 정확해야합니다.</target>
        </trans-unit>
        <trans-unit id="4b6f8a92b24c475c3cccc052bd94c72fc6b4f643" translate="yes" xml:space="preserve">
          <source>Usually, the system time can be trusted to be not too far off from the correct time.
To reflect that, the option &lt;code&gt;--max-adjust&lt;/code&gt; can be used.
It instructs &lt;code&gt;httpsdate.py&lt;/code&gt; to bail out without modifying the system clock if the new time is too far from the current system time.
Together with infrequent synchronisations, this helps prevent malicious servers from deliberately changing the system clock (much).
Reasonable values are a few minutes or seconds, depending on the usual clock drift and the synchronisation frequency.</source>
          <target state="translated">일반적으로 시스템 시간은 정확한 시간에서 너무 멀지 않은 것으로 신뢰할 수 있습니다. 이를 반영하기 위해 &lt;code&gt;--max-adjust&lt;/code&gt; 옵션을 사용할 수 있습니다. 새 시간이 현재 시스템 시간과 너무 멀다면 시스템 시계를 수정하지 않고 구제 &lt;code&gt;httpsdate.py&lt;/code&gt; 를 취 하도록 httpsdate.py 에 지시 합니다. 드문 동기화와 함께 이는 악성 서버가 시스템 시계를 의도적으로 변경하는 것을 방지하는 데 도움이됩니다. 합리적인 값은 일반적인 클럭 드리프트 및 동기화 빈도에 따라 몇 분 또는 초입니다.</target>
        </trans-unit>
        <trans-unit id="09d1176beb9bb0fbc4a0b8de01998a2dd9a5934f" translate="yes" xml:space="preserve">
          <source>When invoked with &lt;code&gt;--quiet&lt;/code&gt;, &lt;code&gt;httpsdate.py&lt;/code&gt; suppresses non-error messages.
Non-error messages are:</source>
          <target state="translated">호출 할 때 &lt;code&gt;--quiet&lt;/code&gt; , &lt;code&gt;httpsdate.py&lt;/code&gt; 비 오류 메시지가 표시되지 않습니다. 비 오류 메시지는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7f92e417f2a9ce5c38d7f205d7c5e35bf3ea61c8" translate="yes" xml:space="preserve">
          <source>While it is possible to use &lt;code&gt;httpsdate.py&lt;/code&gt; with any modern HTTPS-capable web server, it does make sense to pick servers that are expected to keep their own clocks as accurate as possible and always generate fresh headers.</source>
          <target state="translated">모든 최신 HTTPS 지원 웹 서버에서 &lt;code&gt;httpsdate.py&lt;/code&gt; 를 사용할 수 있지만 , 자신의 시계를 최대한 정확하게 유지하고 항상 새로운 헤더를 생성 할 것으로 예상되는 서버를 선택하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="d77989c1e3c0e0ace735631597dc367ffdfa6f32" translate="yes" xml:space="preserve">
          <source>Why?</source>
          <target state="translated">왜?</target>
        </trans-unit>
        <trans-unit id="aecdb53407e97db707da089548464a1610640157" translate="yes" xml:space="preserve">
          <source>a moderately correct system time to begin with (a few months off should be OK)</source>
          <target state="translated">시작하기에 적당히 정확한 시스템 시간 (몇 달은 쉬어도 괜찮음)</target>
        </trans-unit>
        <trans-unit id="2ce8a16703b92eb9aba27dba8365a2778f0ef3eb" translate="yes" xml:space="preserve">
          <source>httpsdate.py</source>
          <target state="translated">httpsdate.py</target>
        </trans-unit>
        <trans-unit id="1758356db21759f7c5a0da9b4dd1db8fd6feab3f" translate="yes" xml:space="preserve">
          <source>or</source>
          <target state="translated">또는</target>
        </trans-unit>
        <trans-unit id="351128dbdbf90688ae8056315edfe9a9cbc22765" translate="yes" xml:space="preserve">
          <source>python-prctl</source>
          <target state="translated">파이썬 -prctl</target>
        </trans-unit>
        <trans-unit id="b71098a06562f27d702c7f7a2b9723634e2dd9b8" translate="yes" xml:space="preserve">
          <source>the summary at the end, which can help estimating the reliability of the new system time</source>
          <target state="translated">새로운 시스템 시간의 신뢰성을 추정하는 데 도움이 될 수있는 마지막 요약</target>
        </trans-unit>
        <trans-unit id="155397bb7b4ddb2928df106c203f8efd5d1cbf34" translate="yes" xml:space="preserve">
          <source>warnings about unusable servers, e.g. due to certificate validation errors</source>
          <target state="translated">사용할 수없는 서버에 대한 경고 (예 : 인증서 유효성 검사 오류)</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
