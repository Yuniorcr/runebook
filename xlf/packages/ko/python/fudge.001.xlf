<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://pypi.org/project/fudge/">
    <body>
      <group id="fudge">
        <trans-unit id="5eac10d955e77365c4b38c49f908818f3411a05e" translate="yes" xml:space="preserve">
          <source>Complete documentation is available at &lt;a href=&quot;https://fudge.readthedocs.org/en/latest/&quot;&gt;https://fudge.readthedocs.org/en/latest/&lt;/a&gt;</source>
          <target state="translated">완전한 문서는 &lt;a href=&quot;https://fudge.readthedocs.org/en/latest/&quot;&gt;https://fudge.readthedocs.org/en/latest/&lt;/a&gt; 에서 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c13afbf40129ff3222adbcddcbf4bdae54002f2c" translate="yes" xml:space="preserve">
          <source>Fudge is a Python module for using fake objects (mocks and stubs) to test real ones.</source>
          <target state="translated">Fudge는 가짜 객체 (모의 및 스텁)를 사용하여 실제 객체를 테스트하기위한 Python 모듈입니다.</target>
        </trans-unit>
        <trans-unit id="979e43004c2ac2a8ab821edf85d630614f648981" translate="yes" xml:space="preserve">
          <source>Here is a quick preview of how you can test code that sends
email without actually sending email:</source>
          <target state="translated">다음은 실제로 이메일을 보내지 않고 이메일을 보내는 코드를 테스트하는 방법에 대한 간단한 미리보기입니다.</target>
        </trans-unit>
        <trans-unit id="fb1bb391a7eba76e0330fd54ebd9318823b1d136" translate="yes" xml:space="preserve">
          <source>In readable Python code, you declare what methods are available on your fake and
how they should be called. Then you inject that into your application and start
testing. This declarative approach means you don&amp;rsquo;t have to record and playback
actions and you don&amp;rsquo;t have to inspect your fakes after running code. If the fake
object was used incorrectly then you&amp;rsquo;ll see an informative exception message
with a traceback that points to the culprit.</source>
          <target state="translated">읽을 수있는 Python 코드에서 가짜에서 사용할 수있는 메서드와 호출 방법을 선언합니다. 그런 다음이를 애플리케이션에 주입하고 테스트를 시작합니다. 이 선언적 접근 방식은 작업을 기록하고 재생할 필요가 없으며 코드를 실행 한 후 가짜를 검사 할 필요가 없음을 의미합니다. 가짜 개체가 잘못 사용 된 경우 범인을 가리키는 트레이스 백과 함께 유익한 예외 메시지가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="2f680878f880516cd458d6920ff922438d656c03" translate="yes" xml:space="preserve">
          <source>Replace real objects with fakes (mocks, stubs, etc) while testing.</source>
          <target state="translated">테스트하는 동안 실제 개체를 가짜 (모의, 스텁 등)로 대체합니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
