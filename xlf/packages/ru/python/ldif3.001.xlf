<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="https://pypi.org/project/ldif3/">
    <body>
      <group id="ldif3">
        <trans-unit id="4a36fa72282c7563bf7e21fc24cf3c3c9ea04d1b" translate="yes" xml:space="preserve">
          <source>By default, the</source>
          <target state="translated">По умолчанию</target>
        </trans-unit>
        <trans-unit id="d63d3b499bcac6a4dcacfac4949a2fd63334d0d8" translate="yes" xml:space="preserve">
          <source>BytesIO</source>
          <target state="translated">BytesIO</target>
        </trans-unit>
        <trans-unit id="5d2c2f534f8b461884c9b10fa9b71a6dc6e54a0a" translate="yes" xml:space="preserve">
          <source>LDIFParser</source>
          <target state="translated">LDIFParser</target>
        </trans-unit>
        <trans-unit id="6eef6648406c333a4035cd5e60d0bf2ecf2606d7" translate="yes" xml:space="preserve">
          <source>None</source>
          <target state="translated">Нет</target>
        </trans-unit>
        <trans-unit id="325f5853836d4dd2279341733d3831b7a40e781e" translate="yes" xml:space="preserve">
          <source>Parse LDIF from a file (or</source>
          <target state="translated">Разбор LDIF из файла (или</target>
        </trans-unit>
        <trans-unit id="fcc1e3307f587fae6bbcfaf9e24f713e57836607" translate="yes" xml:space="preserve">
          <source>The spec allows to include arbitrary data in base64 encoding or via URL. There
is no way of knowing the encoding of this data. To handle this, there are two
modes:</source>
          <target state="translated">Спецификация позволяет включать произвольные данные в кодировку base64 или по URL.Знать кодировку этих данных невозможно.Для этого существует два режима:</target>
        </trans-unit>
        <trans-unit id="75f45058f828bd3a7e871c1dfcff7efe62bdda8c" translate="yes" xml:space="preserve">
          <source>The stream object that is passed to parser or writer must be an ascii byte
stream.</source>
          <target state="translated">Объект потока,который передается парсеру или писателю,должен быть потоком байт ascii.</target>
        </trans-unit>
        <trans-unit id="f51ca7b3346d7faceb71b1fd4b9b19b72e75b5f2" translate="yes" xml:space="preserve">
          <source>This is a fork of the</source>
          <target state="translated">Это вилка</target>
        </trans-unit>
        <trans-unit id="4247bd31bdb74c5074c844a1f51c93a859ff8578" translate="yes" xml:space="preserve">
          <source>Unicode support</source>
          <target state="translated">Поддержка Юникода</target>
        </trans-unit>
        <trans-unit id="0bb18642b70b9f8a9c12ccf39487328f306b8e19" translate="yes" xml:space="preserve">
          <source>Usage</source>
          <target state="translated">Использование</target>
        </trans-unit>
        <trans-unit id="f9898755e2e4504a0199973aa282937ab39273be" translate="yes" xml:space="preserve">
          <source>Write LDIF to a file (or</source>
          <target state="translated">Запишите LDIF в файл (или</target>
        </trans-unit>
        <trans-unit id="14a9dc09e10179b15beaf94c0aed53904ace0336" translate="yes" xml:space="preserve">
          <source>encoding</source>
          <target state="translated">кодировка</target>
        </trans-unit>
        <trans-unit id="e0ec892ebc46f459426026411cef706f01fdc310" translate="yes" xml:space="preserve">
          <source>generate and parse LDIF data (see RFC 2849).</source>
          <target state="translated">генерировать и анализировать данные LDIF (см.RFC 2849).</target>
        </trans-unit>
        <trans-unit id="43c53ab4db0964c7ee178895699485d3162bff01" translate="yes" xml:space="preserve">
          <source>ldif</source>
          <target state="translated">ldif</target>
        </trans-unit>
        <trans-unit id="bf600c633fbafa4d16c9ce91af1257cb333769a4" translate="yes" xml:space="preserve">
          <source>ldif3 - generate and parse LDIF data (see &lt;a href=&quot;https://tools.ietf.org/html/rfc2849&quot;&gt;RFC 2849&lt;/a&gt;).</source>
          <target state="translated">ldif3 - генерировать и анализировать данные LDIF (см. &lt;a href=&quot;https://tools.ietf.org/html/rfc2849&quot;&gt;RFC 2849&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="c7c0c60e305d4a3b6280a4489d6fd11647c70957" translate="yes" xml:space="preserve">
          <source>module from &lt;a href=&quot;http://www.python-ldap.org/&quot;&gt;python-ldap&lt;/a&gt; with python3/unicode
support. See the first entry in CHANGES.rst for a more complete list of
differences.</source>
          <target state="translated">модуль из &lt;a href=&quot;http://www.python-ldap.org/&quot;&gt;python-ldap&lt;/a&gt; с поддержкой python3 / unicode. См. Первую запись в CHANGES.rst для более полного списка различий.</target>
        </trans-unit>
        <trans-unit id="de04fa0e29f9b35e24905d2e512bedc9bb6e09e4" translate="yes" xml:space="preserve">
          <source>of</source>
          <target state="translated">от</target>
        </trans-unit>
        <trans-unit id="7c5629bc397378566f9000c51c4705ec515ecdde" translate="yes" xml:space="preserve">
          <source>to the constructor, in which case the parser will not
try to do any conversion and return bytes directly.</source>
          <target state="translated">в конструктор,в этом случае парсер не будет пытаться делать никаких преобразований и возвращать байты напрямую.</target>
        </trans-unit>
        <trans-unit id="65a62e469069111064851586da7ad2bffeeeb9a1" translate="yes" xml:space="preserve">
          <source>will try to interpret all values as UTF-8 and
leave only the ones that fail to decode as bytes. But you can also pass an</source>
          <target state="translated">попытается интерпретировать все значения как UTF-8 и оставит только те,которые не могут быть расшифрованы как байты.Но вы также можете передать</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
