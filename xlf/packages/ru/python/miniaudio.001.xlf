<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="https://pypi.org/project/miniaudio/">
    <body>
      <group id="miniaudio">
        <trans-unit id="222f0192b17749c93311d6c62eceae89b44342a2" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Requires Python 3.5 or newer.  Also works on pypy3 (because it uses cffi).&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Требуется Python 3.5 или новее. Также работает на pypy3 (потому что он использует cffi).&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="ebd14829f102ab6aa17a02620106962a55992006" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;class&lt;/em&gt;&lt;code&gt;CaptureDevice&lt;/code&gt;</source>
          <target state="translated">&lt;em&gt;класс &lt;/em&gt; &lt;code&gt;CaptureDevice&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6a1d24ff6561ad5024941406d5e23a3435fe3451" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;class&lt;/em&gt;&lt;code&gt;DecodeError&lt;/code&gt;</source>
          <target state="translated">&lt;em&gt;класс &lt;/em&gt; &lt;code&gt;DecodeError&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="493d2da0409561a8f842db049375e58399cbbc31" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;class&lt;/em&gt;&lt;code&gt;DecodedSoundFile&lt;/code&gt;</source>
          <target state="translated">&lt;em&gt;класс &lt;/em&gt; &lt;code&gt;DecodedSoundFile&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5f11bba5facbf44a5ac925cc2120da2c1bacd12b" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;class&lt;/em&gt;&lt;code&gt;Devices&lt;/code&gt;</source>
          <target state="translated">&lt;em&gt;class &lt;/em&gt; &lt;code&gt;Devices&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ea5ba40d351330a11976ca2fd1c98f1d52fad96c" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;class&lt;/em&gt;&lt;code&gt;DuplexStream&lt;/code&gt;</source>
          <target state="translated">&lt;em&gt;класс &lt;/em&gt; &lt;code&gt;DuplexStream&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6fdc803f26299b761c09982d5b85e1a14cb1e707" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;class&lt;/em&gt;&lt;code&gt;MiniaudioError&lt;/code&gt;</source>
          <target state="translated">&lt;em&gt;класс &lt;/em&gt; &lt;code&gt;MiniaudioError&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="58d46f6f1e6ce71921a29afc632f2dbef686e5e9" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;class&lt;/em&gt;&lt;code&gt;PlaybackDevice&lt;/code&gt;</source>
          <target state="translated">&lt;em&gt;класс &lt;/em&gt; &lt;code&gt;PlaybackDevice&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e920936a1f954f4b86afd00191d011f770fcd9de" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;class&lt;/em&gt;&lt;code&gt;SoundFileInfo&lt;/code&gt;</source>
          <target state="translated">&lt;em&gt;класс &lt;/em&gt; &lt;code&gt;SoundFileInfo&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7d8f721e9c4ea33d87bbce20be24b1cb328055a4" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;class&lt;/em&gt;&lt;code&gt;StreamableSource&lt;/code&gt;</source>
          <target state="translated">&lt;em&gt;класс &lt;/em&gt; &lt;code&gt;StreamableSource&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b0a6170982da1af0f5c114fd46a50f0056a99af2" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;class&lt;/em&gt;&lt;code&gt;WavFileReadStream&lt;/code&gt;</source>
          <target state="translated">&lt;em&gt;класс &lt;/em&gt; &lt;code&gt;WavFileReadStream&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ff8267bae1feb5cac35868bc0e866e8d16edba2e" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;enum class&lt;/em&gt;&lt;code&gt;Backend&lt;/code&gt;
names:  &lt;code&gt;WASAPI&lt;/code&gt;&lt;code&gt;DSOUND&lt;/code&gt;&lt;code&gt;WINMM&lt;/code&gt;&lt;code&gt;COREAUDIO&lt;/code&gt;&lt;code&gt;SNDIO&lt;/code&gt;&lt;code&gt;AUDIO4&lt;/code&gt;&lt;code&gt;OSS&lt;/code&gt;&lt;code&gt;PULSEAUDIO&lt;/code&gt;&lt;code&gt;ALSA&lt;/code&gt;&lt;code&gt;JACK&lt;/code&gt;&lt;code&gt;AAUDIO&lt;/code&gt;&lt;code&gt;OPENSL&lt;/code&gt;&lt;code&gt;WEBAUDIO&lt;/code&gt;&lt;code&gt;NULL&lt;/code&gt;</source>
          <target state="translated">&lt;em&gt;Класс перечисления &lt;/em&gt; &lt;code&gt;Backend&lt;/code&gt; названия: &lt;code&gt;WASAPI&lt;/code&gt; &lt;code&gt;DSOUND&lt;/code&gt; &lt;code&gt;WINMM&lt;/code&gt; &lt;code&gt;COREAUDIO&lt;/code&gt; &lt;code&gt;SNDIO&lt;/code&gt; &lt;code&gt;AUDIO4&lt;/code&gt; &lt;code&gt;OSS&lt;/code&gt; &lt;code&gt;PULSEAUDIO&lt;/code&gt; &lt;code&gt;ALSA&lt;/code&gt; &lt;code&gt;JACK&lt;/code&gt; &lt;code&gt;AAUDIO&lt;/code&gt; &lt;code&gt;OPENSL&lt;/code&gt; &lt;code&gt;WEBAUDIO&lt;/code&gt; &lt;code&gt;NULL&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="04eee8d2954c507a3d5f4f7c78026560acd66762" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;enum class&lt;/em&gt;&lt;code&gt;ChannelMixMode&lt;/code&gt;
names:  &lt;code&gt;RECTANGULAR&lt;/code&gt;&lt;code&gt;SIMPLE&lt;/code&gt;&lt;code&gt;CUSTOMWEIGHTS&lt;/code&gt;</source>
          <target state="translated">&lt;em&gt;перечисляемые классы &lt;/em&gt; &lt;code&gt;ChannelMixMode&lt;/code&gt; имена: &lt;code&gt;RECTANGULAR&lt;/code&gt; &lt;code&gt;SIMPLE&lt;/code&gt; &lt;code&gt;CUSTOMWEIGHTS&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cf8e734fcefbf15a109424769faf04d8b7932a75" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;enum class&lt;/em&gt;&lt;code&gt;DeviceType&lt;/code&gt;
names:  &lt;code&gt;PLAYBACK&lt;/code&gt;&lt;code&gt;CAPTURE&lt;/code&gt;&lt;code&gt;DUPLEX&lt;/code&gt;</source>
          <target state="translated">&lt;em&gt;enum class&lt;/em&gt; имена &lt;code&gt;DeviceType&lt;/code&gt; : &lt;code&gt;PLAYBACK&lt;/code&gt; &lt;code&gt;CAPTURE&lt;/code&gt; &lt;code&gt;DUPLEX&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="bc484e13fb0d779d6baa6974b86e7351026797a2" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;enum class&lt;/em&gt;&lt;code&gt;DitherMode&lt;/code&gt;
names:  &lt;code&gt;NONE&lt;/code&gt;&lt;code&gt;RECTANGLE&lt;/code&gt;&lt;code&gt;TRIANGLE&lt;/code&gt;</source>
          <target state="translated">&lt;em&gt;enum class&lt;/em&gt; имена &lt;code&gt;DitherMode&lt;/code&gt; : &lt;code&gt;NONE&lt;/code&gt; &lt;code&gt;RECTANGLE&lt;/code&gt; &lt;code&gt;TRIANGLE&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fd9ba8c49c2a18cc85cd69201fd2e39509adb992" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;enum class&lt;/em&gt;&lt;code&gt;FileFormat&lt;/code&gt;
names:  &lt;code&gt;UNKNOWN&lt;/code&gt;&lt;code&gt;WAV&lt;/code&gt;&lt;code&gt;FLAC&lt;/code&gt;&lt;code&gt;VORBIS&lt;/code&gt;&lt;code&gt;MP3&lt;/code&gt;</source>
          <target state="translated">&lt;em&gt;enum class &lt;/em&gt; &lt;code&gt;FileFormat&lt;/code&gt; names: &lt;code&gt;UNKNOWN&lt;/code&gt; &lt;code&gt;WAV&lt;/code&gt; &lt;code&gt;FLAC&lt;/code&gt; &lt;code&gt;VORBIS&lt;/code&gt; &lt;code&gt;MP3&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f2640c17b627d53a39079afb79f0d52f20c9ec6d" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;enum class&lt;/em&gt;&lt;code&gt;SampleFormat&lt;/code&gt;
names:  &lt;code&gt;UNKNOWN&lt;/code&gt;&lt;code&gt;UNSIGNED8&lt;/code&gt;&lt;code&gt;SIGNED16&lt;/code&gt;&lt;code&gt;SIGNED24&lt;/code&gt;&lt;code&gt;SIGNED32&lt;/code&gt;&lt;code&gt;FLOAT32&lt;/code&gt;</source>
          <target state="translated">&lt;em&gt;enum class &lt;/em&gt; &lt;code&gt;SampleFormat&lt;/code&gt; names: &lt;code&gt;UNKNOWN&lt;/code&gt; &lt;code&gt;UNSIGNED8&lt;/code&gt; &lt;code&gt;SIGNED16&lt;/code&gt; &lt;code&gt;SIGNED24&lt;/code&gt; &lt;code&gt;SIGNED32&lt;/code&gt; &lt;code&gt;FLOAT32&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fe6df29335c1ca5577ecf2da261587678adcf50d" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;enum class&lt;/em&gt;&lt;code&gt;SeekOrigin&lt;/code&gt;
names:  &lt;code&gt;START&lt;/code&gt;&lt;code&gt;CURRENT&lt;/code&gt;</source>
          <target state="translated">&lt;em&gt;enum class&lt;/em&gt; имена &lt;code&gt;SeekOrigin&lt;/code&gt; : &lt;code&gt;START&lt;/code&gt; &lt;code&gt;CURRENT&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fd2732775876be844985474c957bbb62758bbb0e" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;enum class&lt;/em&gt;&lt;code&gt;ThreadPriority&lt;/code&gt;
names:  &lt;code&gt;IDLE&lt;/code&gt;&lt;code&gt;LOWEST&lt;/code&gt;&lt;code&gt;LOW&lt;/code&gt;&lt;code&gt;NORMAL&lt;/code&gt;&lt;code&gt;HIGH&lt;/code&gt;&lt;code&gt;HIGHEST&lt;/code&gt;&lt;code&gt;REALTIME&lt;/code&gt;</source>
          <target state="translated">&lt;em&gt;перечисляемые классы &lt;/em&gt; &lt;code&gt;ThreadPriority&lt;/code&gt; имена: &lt;code&gt;IDLE&lt;/code&gt; &lt;code&gt;LOWEST&lt;/code&gt; &lt;code&gt;LOW&lt;/code&gt; &lt;code&gt;NORMAL&lt;/code&gt; &lt;code&gt;HIGH&lt;/code&gt; &lt;code&gt;HIGHEST&lt;/code&gt; &lt;code&gt;REALTIME&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9f3461a3c2e31478d5ab381ae7b2bedc1c9b2eff" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;function&lt;/em&gt;&lt;code&gt;convert_frames (from_fmt: miniaudio.SampleFormat, from_numchannels: int, from_samplerate: int, sourcedata: bytes, to_fmt: miniaudio.SampleFormat, to_numchannels: int, to_samplerate: int) -&amp;gt; bytearray&lt;/code&gt;</source>
          <target state="translated">&lt;em&gt;function &lt;/em&gt; &lt;code&gt;convert_frames (from_fmt: miniaudio.SampleFormat, from_numchannels: int, from_samplerate: int, sourcedata: bytes, to_fmt: miniaudio.SampleFormat, to_numchannels: int, to_samplerate: int) -&amp;gt; bytearray&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c6ca0d8942bed2885e6a50534170313b7024bd51" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;function&lt;/em&gt;&lt;code&gt;convert_sample_format (from_fmt: miniaudio.SampleFormat, sourcedata: bytes, to_fmt: miniaudio.SampleFormat, dither: miniaudio.DitherMode = &amp;lt;DitherMode.NONE: 0&amp;gt;) -&amp;gt; bytearray&lt;/code&gt;</source>
          <target state="translated">&lt;em&gt;функция &lt;/em&gt; &lt;code&gt;convert_sample_format (from_fmt: miniaudio.SampleFormat, sourcedata: bytes, to_fmt: miniaudio.SampleFormat, dither: miniaudio.DitherMode = &amp;lt;DitherMode.NONE: 0&amp;gt;) -&amp;gt; bytearray&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="625edaeaac51c5e8ab28dabfa11ad90cd4a78575" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;function&lt;/em&gt;&lt;code&gt;decode (data: bytes, output_format: miniaudio.SampleFormat = &amp;lt;SampleFormat.SIGNED16: 2&amp;gt;, nchannels: int = 2, sample_rate: int = 44100, dither: miniaudio.DitherMode = &amp;lt;DitherMode.NONE: 0&amp;gt;) -&amp;gt; miniaudio.DecodedSoundFile&lt;/code&gt;</source>
          <target state="translated">&lt;em&gt;функция &lt;/em&gt; &lt;code&gt;decode (data: bytes, output_format: miniaudio.SampleFormat = &amp;lt;SampleFormat.SIGNED16: 2&amp;gt;, nchannels: int = 2, sample_rate: int = 44100, dither: miniaudio.DitherMode = &amp;lt;DitherMode.NONE: 0&amp;gt;) -&amp;gt; miniaudio.DecodedSoundFile&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="09f84fe3085974d3a87efdd245569f860a8af4c5" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;function&lt;/em&gt;&lt;code&gt;decode_file (filename: str, output_format: miniaudio.SampleFormat = &amp;lt;SampleFormat.SIGNED16: 2&amp;gt;, nchannels: int = 2, sample_rate: int = 44100, dither: miniaudio.DitherMode = &amp;lt;DitherMode.NONE: 0&amp;gt;) -&amp;gt; miniaudio.DecodedSoundFile&lt;/code&gt;</source>
          <target state="translated">&lt;em&gt;функция &lt;/em&gt; &lt;code&gt;decode_file (filename: str, output_format: miniaudio.SampleFormat = &amp;lt;SampleFormat.SIGNED16: 2&amp;gt;, nchannels: int = 2, sample_rate: int = 44100, dither: miniaudio.DitherMode = &amp;lt;DitherMode.NONE: 0&amp;gt;) -&amp;gt; miniaudio.DecodedSoundFile&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="21aace310cc2b1626114af0c8c2b589734f30c8c" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;function&lt;/em&gt;&lt;code&gt;flac_get_file_info (filename: str) -&amp;gt; miniaudio.SoundFileInfo&lt;/code&gt;</source>
          <target state="translated">&lt;em&gt;функция &lt;/em&gt; &lt;code&gt;flac_get_file_info (filename: str) -&amp;gt; miniaudio.SoundFileInfo&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4002ab4c2bdfd04c06a597bd64f40911c48c5018" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;function&lt;/em&gt;&lt;code&gt;flac_get_info (data: bytes) -&amp;gt; miniaudio.SoundFileInfo&lt;/code&gt;</source>
          <target state="translated">&lt;em&gt;функция &lt;/em&gt; &lt;code&gt;flac_get_info (data: bytes) -&amp;gt; miniaudio.SoundFileInfo&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="15f0b23ff2407295407c57fd83cd6ad803abaf55" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;function&lt;/em&gt;&lt;code&gt;flac_read_f32 (data: bytes) -&amp;gt; miniaudio.DecodedSoundFile&lt;/code&gt;</source>
          <target state="translated">&lt;em&gt;функция &lt;/em&gt; &lt;code&gt;flac_read_f32 (data: bytes) -&amp;gt; miniaudio.DecodedSoundFile&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ccd0dea213d7f84c6c0d5fd596f0c9ec7fac0531" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;function&lt;/em&gt;&lt;code&gt;flac_read_file_f32 (filename: str) -&amp;gt; miniaudio.DecodedSoundFile&lt;/code&gt;</source>
          <target state="translated">&lt;em&gt;функция &lt;/em&gt; &lt;code&gt;flac_read_file_f32 (filename: str) -&amp;gt; miniaudio.DecodedSoundFile&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="aa097a69a261882b066c894ed93e50ac2a2a0fa6" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;function&lt;/em&gt;&lt;code&gt;flac_read_file_s16 (filename: str) -&amp;gt; miniaudio.DecodedSoundFile&lt;/code&gt;</source>
          <target state="translated">&lt;em&gt;функция &lt;/em&gt; &lt;code&gt;flac_read_file_s16 (filename: str) -&amp;gt; miniaudio.DecodedSoundFile&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cd72dbdc2ab14b547fad454ab3938aceb4c6bfc8" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;function&lt;/em&gt;&lt;code&gt;flac_read_file_s32 (filename: str) -&amp;gt; miniaudio.DecodedSoundFile&lt;/code&gt;</source>
          <target state="translated">&lt;em&gt;функция &lt;/em&gt; &lt;code&gt;flac_read_file_s32 (filename: str) -&amp;gt; miniaudio.DecodedSoundFile&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="99c1a59f1077689a5993b7ebf400d00bb05d5531" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;function&lt;/em&gt;&lt;code&gt;flac_read_s16 (data: bytes) -&amp;gt; miniaudio.DecodedSoundFile&lt;/code&gt;</source>
          <target state="translated">&lt;em&gt;функция &lt;/em&gt; &lt;code&gt;flac_read_s16 (data: bytes) -&amp;gt; miniaudio.DecodedSoundFile&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="43e231c7ad6c785b85045708dee3d767c70e52da" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;function&lt;/em&gt;&lt;code&gt;flac_read_s32 (data: bytes) -&amp;gt; miniaudio.DecodedSoundFile&lt;/code&gt;</source>
          <target state="translated">&lt;em&gt;функция &lt;/em&gt; &lt;code&gt;flac_read_s32 (data: bytes) -&amp;gt; miniaudio.DecodedSoundFile&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7f07e582b9c7cb4911ce9d73c6ec6691adaa9d3b" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;function&lt;/em&gt;&lt;code&gt;flac_stream_file (filename: str, frames_to_read: int = 1024, seek_frame: int = 0) -&amp;gt; Generator[array.array, NoneType, NoneType]&lt;/code&gt;</source>
          <target state="translated">&lt;em&gt;функция &lt;/em&gt; &lt;code&gt;flac_stream_file (filename: str, frames_to_read: int = 1024, seek_frame: int = 0) -&amp;gt; Generator[array.array, NoneType, NoneType]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f055c696711ccc03e501d26e71c6cb406a9fa96f" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;function&lt;/em&gt;&lt;code&gt;get_file_info (filename: str) -&amp;gt; miniaudio.SoundFileInfo&lt;/code&gt;</source>
          <target state="translated">&lt;em&gt;функция &lt;/em&gt; &lt;code&gt;get_file_info (filename: str) -&amp;gt; miniaudio.SoundFileInfo&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cef6de0b94d4e6ed12a7206cd4ffca6f6cc2c4df" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;function&lt;/em&gt;&lt;code&gt;mp3_get_file_info (filename: str) -&amp;gt; miniaudio.SoundFileInfo&lt;/code&gt;</source>
          <target state="translated">&lt;em&gt;функция &lt;/em&gt; &lt;code&gt;mp3_get_file_info (filename: str) -&amp;gt; miniaudio.SoundFileInfo&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="73fa64ae0399eb8357b6b84fe10a80e5061024c3" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;function&lt;/em&gt;&lt;code&gt;mp3_get_info (data: bytes) -&amp;gt; miniaudio.SoundFileInfo&lt;/code&gt;</source>
          <target state="translated">&lt;em&gt;функция &lt;/em&gt; &lt;code&gt;mp3_get_info (data: bytes) -&amp;gt; miniaudio.SoundFileInfo&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="db48b57dca9143d6403a84e6a6819598a4cae0d6" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;function&lt;/em&gt;&lt;code&gt;mp3_read_f32 (data: bytes, want_nchannels: int = 0, want_sample_rate: int = 0) -&amp;gt; miniaudio.DecodedSoundFile&lt;/code&gt;</source>
          <target state="translated">&lt;em&gt;функция &lt;/em&gt; &lt;code&gt;mp3_read_f32 (data: bytes, want_nchannels: int = 0, want_sample_rate: int = 0) -&amp;gt; miniaudio.DecodedSoundFile&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6d5b10ed15cc1ebc6b67ff20f74b7eb1fbb96186" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;function&lt;/em&gt;&lt;code&gt;mp3_read_file_f32 (filename: str, want_nchannels: int = 0, want_sample_rate: int = 0) -&amp;gt; miniaudio.DecodedSoundFile&lt;/code&gt;</source>
          <target state="translated">&lt;em&gt;функция &lt;/em&gt; &lt;code&gt;mp3_read_file_f32 (filename: str, want_nchannels: int = 0, want_sample_rate: int = 0) -&amp;gt; miniaudio.DecodedSoundFile&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="631749c29dc8b243095a26dbed30124fb1b60a9a" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;function&lt;/em&gt;&lt;code&gt;mp3_read_file_s16 (filename: str, want_nchannels: int = 0, want_sample_rate: int = 0) -&amp;gt; miniaudio.DecodedSoundFile&lt;/code&gt;</source>
          <target state="translated">&lt;em&gt;функция &lt;/em&gt; &lt;code&gt;mp3_read_file_s16 (filename: str, want_nchannels: int = 0, want_sample_rate: int = 0) -&amp;gt; miniaudio.DecodedSoundFile&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="60bc4894a2464344a4b83a0d8971250cd06011f4" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;function&lt;/em&gt;&lt;code&gt;mp3_read_s16 (data: bytes, want_nchannels: int = 0, want_sample_rate: int = 0) -&amp;gt; miniaudio.DecodedSoundFile&lt;/code&gt;</source>
          <target state="translated">&lt;em&gt;функция &lt;/em&gt; &lt;code&gt;mp3_read_s16 (data: bytes, want_nchannels: int = 0, want_sample_rate: int = 0) -&amp;gt; miniaudio.DecodedSoundFile&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="83ce34d6c46e6770464bbc82d35d7c066f9dbd16" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;function&lt;/em&gt;&lt;code&gt;mp3_stream_file (filename: str, frames_to_read: int = 1024, seek_frame: int = 0) -&amp;gt; Generator[array.array, NoneType, NoneType]&lt;/code&gt;</source>
          <target state="translated">&lt;em&gt;функция &lt;/em&gt; &lt;code&gt;mp3_stream_file (filename: str, frames_to_read: int = 1024, seek_frame: int = 0) -&amp;gt; Generator[array.array, NoneType, NoneType]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4b86667b17f09d8484885d44f94900d31e4884ba" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;function&lt;/em&gt;&lt;code&gt;read_file (filename: str, convert_to_16bit: bool = False) -&amp;gt; miniaudio.DecodedSoundFile&lt;/code&gt;</source>
          <target state="translated">&lt;em&gt;функция &lt;/em&gt; &lt;code&gt;read_file (filename: str, convert_to_16bit: bool = False) -&amp;gt; miniaudio.DecodedSoundFile&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="bfd0157ea09e189b84f6365e98604fe05f9585b2" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;function&lt;/em&gt;&lt;code&gt;stream_any (source: miniaudio.StreamableSource, source_format: miniaudio.FileFormat = &amp;lt;FileFormat.UNKNOWN: 0&amp;gt;, output_format: miniaudio.SampleFormat = &amp;lt;SampleFormat.SIGNED16: 2&amp;gt;, nchannels: int = 2, sample_rate: int = 44100, frames_to_read: int = 1024, dither: miniaudio.DitherMode = &amp;lt;DitherMode.NONE: 0&amp;gt;, seek_frame: int = 0) -&amp;gt; Generator[array.array, int, NoneType]&lt;/code&gt;</source>
          <target state="translated">&lt;em&gt;функция &lt;/em&gt; &lt;code&gt;stream_any (source: miniaudio.StreamableSource, source_format: miniaudio.FileFormat = &amp;lt;FileFormat.UNKNOWN: 0&amp;gt;, output_format: miniaudio.SampleFormat = &amp;lt;SampleFormat.SIGNED16: 2&amp;gt;, nchannels: int = 2, sample_rate: int = 44100, frames_to_read: int = 1024, dither: miniaudio.DitherMode = &amp;lt;DitherMode.NONE: 0&amp;gt;, seek_frame: int = 0) -&amp;gt; Generator[array.array, int, NoneType]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="97531e6ad9ff94052688e5c33dc637c270690903" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;function&lt;/em&gt;&lt;code&gt;stream_file (filename: str, output_format: miniaudio.SampleFormat = &amp;lt;SampleFormat.SIGNED16: 2&amp;gt;, nchannels: int = 2, sample_rate: int = 44100, frames_to_read: int = 1024, dither: miniaudio.DitherMode = &amp;lt;DitherMode.NONE: 0&amp;gt;, seek_frame: int = 0) -&amp;gt; Generator[array.array, int, NoneType]&lt;/code&gt;</source>
          <target state="translated">&lt;em&gt;функция &lt;/em&gt; &lt;code&gt;stream_file (filename: str, output_format: miniaudio.SampleFormat = &amp;lt;SampleFormat.SIGNED16: 2&amp;gt;, nchannels: int = 2, sample_rate: int = 44100, frames_to_read: int = 1024, dither: miniaudio.DitherMode = &amp;lt;DitherMode.NONE: 0&amp;gt;, seek_frame: int = 0) -&amp;gt; Generator[array.array, int, NoneType]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="733c68b515e65df9d1c8e485bfd514c48bd045ea" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;function&lt;/em&gt;&lt;code&gt;stream_memory (data: bytes, output_format: miniaudio.SampleFormat = &amp;lt;SampleFormat.SIGNED16: 2&amp;gt;, nchannels: int = 2, sample_rate: int = 44100, frames_to_read: int = 1024, dither: miniaudio.DitherMode = &amp;lt;DitherMode.NONE: 0&amp;gt;) -&amp;gt; Generator[array.array, int, NoneType]&lt;/code&gt;</source>
          <target state="translated">&lt;em&gt;функция &lt;/em&gt; &lt;code&gt;stream_memory (data: bytes, output_format: miniaudio.SampleFormat = &amp;lt;SampleFormat.SIGNED16: 2&amp;gt;, nchannels: int = 2, sample_rate: int = 44100, frames_to_read: int = 1024, dither: miniaudio.DitherMode = &amp;lt;DitherMode.NONE: 0&amp;gt;) -&amp;gt; Generator[array.array, int, NoneType]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="29f63b6c1c8585c68a28025fed57dcc0d6257082" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;function&lt;/em&gt;&lt;code&gt;vorbis_get_file_info (filename: str) -&amp;gt; miniaudio.SoundFileInfo&lt;/code&gt;</source>
          <target state="translated">&lt;em&gt;функция &lt;/em&gt; &lt;code&gt;vorbis_get_file_info (filename: str) -&amp;gt; miniaudio.SoundFileInfo&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="64d5bfda26028c628eaccc410e6034d78066051c" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;function&lt;/em&gt;&lt;code&gt;vorbis_get_info (data: bytes) -&amp;gt; miniaudio.SoundFileInfo&lt;/code&gt;</source>
          <target state="translated">&lt;em&gt;функция &lt;/em&gt; &lt;code&gt;vorbis_get_info (data: bytes) -&amp;gt; miniaudio.SoundFileInfo&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e75d447aeb667024cb6bb8e7c28639d22a87b88d" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;function&lt;/em&gt;&lt;code&gt;vorbis_read (data: bytes) -&amp;gt; miniaudio.DecodedSoundFile&lt;/code&gt;</source>
          <target state="translated">&lt;em&gt;функция &lt;/em&gt; &lt;code&gt;vorbis_read (data: bytes) -&amp;gt; miniaudio.DecodedSoundFile&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3b0292788fa5d3f39114a804492c2715d94aeda4" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;function&lt;/em&gt;&lt;code&gt;vorbis_read_file (filename: str) -&amp;gt; miniaudio.DecodedSoundFile&lt;/code&gt;</source>
          <target state="translated">&lt;em&gt;функция &lt;/em&gt; &lt;code&gt;vorbis_read_file (filename: str) -&amp;gt; miniaudio.DecodedSoundFile&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="aca49fbd14919f0f9060f58d91fcb5ad9d398ed6" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;function&lt;/em&gt;&lt;code&gt;vorbis_stream_file (filename: str, seek_frame: int = 0) -&amp;gt; Generator[array.array, NoneType, NoneType]&lt;/code&gt;</source>
          <target state="translated">&lt;em&gt;функция &lt;/em&gt; &lt;code&gt;vorbis_stream_file (filename: str, seek_frame: int = 0) -&amp;gt; Generator[array.array, NoneType, NoneType]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fe529c8f6a10a9377668c32c0e5f92aa63a6783b" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;function&lt;/em&gt;&lt;code&gt;wav_get_file_info (filename: str) -&amp;gt; miniaudio.SoundFileInfo&lt;/code&gt;</source>
          <target state="translated">&lt;em&gt;функция &lt;/em&gt; &lt;code&gt;wav_get_file_info (filename: str) -&amp;gt; miniaudio.SoundFileInfo&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8396d71f96e099a69da12ecbbda402433667d4a3" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;function&lt;/em&gt;&lt;code&gt;wav_get_info (data: bytes) -&amp;gt; miniaudio.SoundFileInfo&lt;/code&gt;</source>
          <target state="translated">&lt;em&gt;функция &lt;/em&gt; &lt;code&gt;wav_get_info (data: bytes) -&amp;gt; miniaudio.SoundFileInfo&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f571956a5d8cf77b436dc839528ecead3ae28194" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;function&lt;/em&gt;&lt;code&gt;wav_read_f32 (data: bytes) -&amp;gt; miniaudio.DecodedSoundFile&lt;/code&gt;</source>
          <target state="translated">&lt;em&gt;функция &lt;/em&gt; &lt;code&gt;wav_read_f32 (data: bytes) -&amp;gt; miniaudio.DecodedSoundFile&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ac5e5b76f2b07e8111552c2ff283843b7b9eadac" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;function&lt;/em&gt;&lt;code&gt;wav_read_file_f32 (filename: str) -&amp;gt; miniaudio.DecodedSoundFile&lt;/code&gt;</source>
          <target state="translated">&lt;em&gt;функция &lt;/em&gt; &lt;code&gt;wav_read_file_f32 (filename: str) -&amp;gt; miniaudio.DecodedSoundFile&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b3d7234713237a56b96295fd7e29d38c35528f02" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;function&lt;/em&gt;&lt;code&gt;wav_read_file_s16 (filename: str) -&amp;gt; miniaudio.DecodedSoundFile&lt;/code&gt;</source>
          <target state="translated">&lt;em&gt;функция &lt;/em&gt; &lt;code&gt;wav_read_file_s16 (filename: str) -&amp;gt; miniaudio.DecodedSoundFile&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2f6b13e003ac5493bd61f66d163458af5a5caf1d" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;function&lt;/em&gt;&lt;code&gt;wav_read_file_s32 (filename: str) -&amp;gt; miniaudio.DecodedSoundFile&lt;/code&gt;</source>
          <target state="translated">&lt;em&gt;функция &lt;/em&gt; &lt;code&gt;wav_read_file_s32 (filename: str) -&amp;gt; miniaudio.DecodedSoundFile&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6c20865557f468a9175ca5224c9092b41e6cf1a2" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;function&lt;/em&gt;&lt;code&gt;wav_read_s16 (data: bytes) -&amp;gt; miniaudio.DecodedSoundFile&lt;/code&gt;</source>
          <target state="translated">&lt;em&gt;функция &lt;/em&gt; &lt;code&gt;wav_read_s16 (data: bytes) -&amp;gt; miniaudio.DecodedSoundFile&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="803de3783a5c1478245a3b75fd074f8c2b3a3a3b" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;function&lt;/em&gt;&lt;code&gt;wav_read_s32 (data: bytes) -&amp;gt; miniaudio.DecodedSoundFile&lt;/code&gt;</source>
          <target state="translated">&lt;em&gt;функция &lt;/em&gt; &lt;code&gt;wav_read_s32 (data: bytes) -&amp;gt; miniaudio.DecodedSoundFile&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="61eaa464cb06f56f36c9beec95742d3735523746" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;function&lt;/em&gt;&lt;code&gt;wav_stream_file (filename: str, frames_to_read: int = 1024, seek_frame: int = 0) -&amp;gt; Generator[array.array, NoneType, NoneType]&lt;/code&gt;</source>
          <target state="translated">&lt;em&gt;функция &lt;/em&gt; &lt;code&gt;wav_stream_file (filename: str, frames_to_read: int = 1024, seek_frame: int = 0) -&amp;gt; Generator[array.array, NoneType, NoneType]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7b86564b074d01e1f3d967efc21e00340643bffe" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;function&lt;/em&gt;&lt;code&gt;wav_write_file (filename: str, sound: miniaudio.DecodedSoundFile)&lt;/code&gt;</source>
          <target state="translated">&lt;em&gt;функция &lt;/em&gt; &lt;code&gt;wav_write_file (filename: str, sound: miniaudio.DecodedSoundFile)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a0ebedef07c23da59b8cb901f73ce3ae64aff91a" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;method&lt;/em&gt;&lt;code&gt;close (self)&lt;/code&gt;</source>
          <target state="translated">&lt;em&gt;метод &lt;/em&gt; &lt;code&gt;close (self)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9a8ed5f8825a3771f5ef950ceb4c7bf320f329aa" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;method&lt;/em&gt;&lt;code&gt;get_captures (self) -&amp;gt; List[Dict[str, Any]]&lt;/code&gt;</source>
          <target state="translated">&lt;em&gt;метод &lt;/em&gt; &lt;code&gt;get_captures (self) -&amp;gt; List[Dict[str, Any]]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="852f6bbecd94418066b5f3159994e6165f0eb836" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;method&lt;/em&gt;&lt;code&gt;get_playbacks (self) -&amp;gt; List[Dict[str, Any]]&lt;/code&gt;</source>
          <target state="translated">&lt;em&gt;метод &lt;/em&gt; &lt;code&gt;get_playbacks (self) -&amp;gt; List[Dict[str, Any]]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="019b8833d05c2ee7c09db536ef44ad4fe9ce8f6b" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;method&lt;/em&gt;&lt;code&gt;read (self, amount: int = 9223372036854775807) -&amp;gt; Union[bytes, NoneType]&lt;/code&gt;</source>
          <target state="translated">&lt;em&gt;метод &lt;/em&gt; &lt;code&gt;read (self, amount: int = 9223372036854775807) -&amp;gt; Union[bytes, NoneType]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="78a2cf50ae902687518c9d20aeb232562439eee4" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;method&lt;/em&gt;&lt;code&gt;start (self, callback_generator: Generator[NoneType, Union[bytes, array.array], NoneType], stop_callback: Union[Callable, NoneType] = None)&lt;/code&gt;</source>
          <target state="translated">&lt;em&gt;метод &lt;/em&gt; &lt;code&gt;start (self, callback_generator: Generator[NoneType, Union[bytes, array.array], NoneType], stop_callback: Union[Callable, NoneType] = None)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5e4d2a5e5d473afc2e4b3fcb747ff92a1f384016" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;method&lt;/em&gt;&lt;code&gt;start (self, callback_generator: Generator[Union[bytes, array.array], Union[bytes, array.array], NoneType], stop_callback: Union[Callable, NoneType] = None)&lt;/code&gt;</source>
          <target state="translated">&lt;em&gt;&lt;/em&gt; &lt;code&gt;start (self, callback_generator: Generator[Union[bytes, array.array], Union[bytes, array.array], NoneType], stop_callback: Union[Callable, NoneType] = None)&lt;/code&gt; &lt;em&gt;метода &lt;/em&gt;(self, callback_generator: Generator [Union [bytes, array.array], Union [bytes, array.array], NoneType], stop_callback: Union [Callable, NoneType] = None)</target>
        </trans-unit>
        <trans-unit id="6c45d195bc05c066bd21319de222d7409968da5b" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;method&lt;/em&gt;&lt;code&gt;start (self, callback_generator: Generator[Union[bytes, array.array], int, NoneType], stop_callback: Union[Callable, NoneType] = None)&lt;/code&gt;</source>
          <target state="translated">&lt;em&gt;метод &lt;/em&gt; &lt;code&gt;start (self, callback_generator: Generator[Union[bytes, array.array], int, NoneType], stop_callback: Union[Callable, NoneType] = None)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4c5020f513dae79556714e04c0f2fd6b469aae02" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;method&lt;/em&gt;&lt;code&gt;stop (self)&lt;/code&gt;</source>
          <target state="translated">&lt;em&gt;&lt;/em&gt; &lt;code&gt;stop (self)&lt;/code&gt; &lt;em&gt;метода &lt;/em&gt;(self)</target>
        </trans-unit>
        <trans-unit id="d93d10ff0fbef1b4aa0ddc24e10e907746d3c85a" translate="yes" xml:space="preserve">
          <source>API</source>
          <target state="translated">API</target>
        </trans-unit>
        <trans-unit id="e35f42f2c9c83d3d01b06737755f163bc64ebd1f" translate="yes" xml:space="preserve">
          <source>An IO stream that reads as a .wav file, and which gets its pcm samples from the provided producer</source>
          <target state="translated">Поток ввода-вывода,который читается как .wav файл,и который получает свои pcm образцы от предоставленного производителя</target>
        </trans-unit>
        <trans-unit id="a96b55bc42b80ac3452926b3b4d2db0c84b42041" translate="yes" xml:space="preserve">
          <source>An audio device provided by miniaudio, for audio capture (recording).</source>
          <target state="translated">Звуковое устройство,предоставляемое миниаудио,для захвата (записи)аудиосигнала.</target>
        </trans-unit>
        <trans-unit id="2187381720d919c285f1dc7bb60bb7242fa2271c" translate="yes" xml:space="preserve">
          <source>An audio device provided by miniaudio, for audio playback.</source>
          <target state="translated">Аудиоустройство,предоставляемое миниаудио,для воспроизведения звука.</target>
        </trans-unit>
        <trans-unit id="67617ae27f24012fc8940a4e70e106a4defc201e" translate="yes" xml:space="preserve">
          <source>Audio file format</source>
          <target state="translated">Формат аудио файла</target>
        </trans-unit>
        <trans-unit id="67eb0fbdc9915503739957021fa93d965901ce11" translate="yes" xml:space="preserve">
          <source>Close the file</source>
          <target state="translated">Закрыть файл</target>
        </trans-unit>
        <trans-unit id="5bb74c6cc926d528b1efe36584e07de893096e3b" translate="yes" xml:space="preserve">
          <source>Contains various properties and also the PCM frames of a fully decoded audio file.</source>
          <target state="translated">Содержит различные свойства,а также PCM-фреймы полностью декодированного аудиофайла.</target>
        </trans-unit>
        <trans-unit id="a725cb27e369ad13a336233973ad20749b54416c" translate="yes" xml:space="preserve">
          <source>Contains various properties of an audio file.</source>
          <target state="translated">Содержит различные свойства аудиофайла.</target>
        </trans-unit>
        <trans-unit id="ec68525aa97273376b12d9585f323e9a83e16f9a" translate="yes" xml:space="preserve">
          <source>Convenience function that returns a generator to decode and stream any source of encoded audio
data (such as a network stream). Stream result is chunks of raw PCM samples in the chosen format. If
you send() a number into the generator rather than just using next() on it, you'll get that given
number of frames, instead of the default configured amount. This is particularly useful to plug this
stream into an audio device callback that wants a variable number of frames per call.</source>
          <target state="translated">Функция удобства,которая возвращает генератор для декодирования и потокового воспроизведения любого источника закодированных аудио данных (например,сетевого потока).Результатом потока являются куски сырых PCM семплов в выбранном формате.Если вы посылаете в генератор число,а не просто используете next()на нем,вы получите это заданное количество кадров,а не заданное по умолчанию количество.Это особенно полезно для подключения этого потока к обратному вызову аудиоустройства,которое хочет иметь переменное количество кадров на вызов.</target>
        </trans-unit>
        <trans-unit id="4170ec7ebe1621e2da337b4e90124fb014ca842c" translate="yes" xml:space="preserve">
          <source>Convenience function to decode any supported audio file in memory to raw PCM samples in your
chosen format.</source>
          <target state="translated">Функция удобства для декодирования любого поддерживаемого аудио файла в памяти на необработанные PCM сэмплы в выбранном вами формате.</target>
        </trans-unit>
        <trans-unit id="cdc19fa5c41ec99df63990549d952353592715dd" translate="yes" xml:space="preserve">
          <source>Convenience function to decode any supported audio file to raw PCM samples in your chosen format.</source>
          <target state="translated">Функция удобства для декодирования любого поддерживаемого аудио файла на необработанные PCM сэмплы в выбранном вами формате.</target>
        </trans-unit>
        <trans-unit id="dbf8faf6a83cd855867e2857a83ee9d10cd267e9" translate="yes" xml:space="preserve">
          <source>Convenience generator function to decode and stream any supported audio file as chunks of raw PCM
samples in the chosen format. If you send() a number into the generator rather than just using
next() on it, you'll get that given number of frames, instead of the default configured amount. This
is particularly useful to plug this stream into an audio device callback that wants a variable
number of frames per call.</source>
          <target state="translated">Функция генератора удобства для декодирования и потокового воспроизведения любого поддерживаемого аудио файла в виде фрагментов сырых PCM сэмплов в выбранном формате.Если вы посылаете в генератор число,а не просто используете следующую(),вы получите это заданное количество кадров,а не заданное по умолчанию количество.Это особенно полезно для подключения этого потока к обратному вызову аудиоустройства,которое хочет иметь переменное количество кадров на вызов.</target>
        </trans-unit>
        <trans-unit id="d2a5c7010c1b47ff6fd2e31d527bba28bf276d85" translate="yes" xml:space="preserve">
          <source>Convenience generator function to decode and stream any supported audio file in memory as chunks
of raw PCM samples in the chosen format. If you send() a number into the generator rather than just
using next() on it, you'll get that given number of frames, instead of the default configured
amount. This is particularly useful to plug this stream into an audio device callback that wants a
variable number of frames per call.</source>
          <target state="translated">Функция генератора удобства для декодирования и потокового воспроизведения любого поддерживаемого аудио файла в памяти в виде кусков сырых PCM сэмплов в выбранном формате.Если вы посылаете в генератор число,а не просто используете следующую(),вы получите это заданное количество кадров,а не заданное по умолчанию количество.Это особенно полезно для подключения этого потока к обратному вызову аудиоустройства,которое хочет иметь переменное количество кадров на вызов.</target>
        </trans-unit>
        <trans-unit id="e75b2dbffa0dcb5c724ebefda161eb865eb07f0c" translate="yes" xml:space="preserve">
          <source>Convert a raw buffer of pcm samples to another sample format. The result is returned as another
raw pcm sample buffer</source>
          <target state="translated">Конвертировать буфер необработанных сэмплов pcm в другой формат сэмплов.Результат возвращается в качестве еще одного буфера необработанных образцов псм.</target>
        </trans-unit>
        <trans-unit id="2f648078bc3ca1dd7c22b960668a496fbac2bac8" translate="yes" xml:space="preserve">
          <source>Convert audio frames in source sample format with a certain number of channels, to another sample
format and possibly down/upmixing the number of channels as well.</source>
          <target state="translated">Преобразовывать аудио кадры в формате исходного сэмпла с определенным количеством каналов,в другой формат сэмпла,а также,возможно,уменьшать/уменьшать количество каналов.</target>
        </trans-unit>
        <trans-unit id="eb01bf04c9a0e8a71c45816513df424f1c7ffedb" translate="yes" xml:space="preserve">
          <source>Examples</source>
          <target state="translated">Примеры</target>
        </trans-unit>
        <trans-unit id="495d3d11b082af613295e96fc2e7ac624f5ad01b" translate="yes" xml:space="preserve">
          <source>Fetch some information about the audio data (flac format).</source>
          <target state="translated">Получите некоторую информацию о звуковых данных (в формате flac).</target>
        </trans-unit>
        <trans-unit id="294ed8d86f860651e60548bc652abe9b84dfc600" translate="yes" xml:space="preserve">
          <source>Fetch some information about the audio data (mp3 format).</source>
          <target state="translated">Получите некоторую информацию о звуковых данных (формат mp3).</target>
        </trans-unit>
        <trans-unit id="ced6b4c85e690d92baec62d4dfe514019f3a2a20" translate="yes" xml:space="preserve">
          <source>Fetch some information about the audio data (vorbis format).</source>
          <target state="translated">Получите некоторую информацию о звуковых данных (формат vorbis).</target>
        </trans-unit>
        <trans-unit id="0d89f8d3547aa53539b31847b65157793405af1b" translate="yes" xml:space="preserve">
          <source>Fetch some information about the audio data (wav format).</source>
          <target state="translated">Получите некоторую информацию о звуковых данных (формат wav).</target>
        </trans-unit>
        <trans-unit id="3d356649a7d770a2b0f1a0fadae14ab9ddd521a1" translate="yes" xml:space="preserve">
          <source>Fetch some information about the audio file (flac format).</source>
          <target state="translated">Получите некоторую информацию о звуковом файле (формат flac).</target>
        </trans-unit>
        <trans-unit id="a8514d85a4dd55de27a3219cb278d8fb131f6bef" translate="yes" xml:space="preserve">
          <source>Fetch some information about the audio file (mp3 format).</source>
          <target state="translated">Получите некоторую информацию о звуковом файле (формат mp3).</target>
        </trans-unit>
        <trans-unit id="389f188fcbfd725afd09c03372139258c03c7a24" translate="yes" xml:space="preserve">
          <source>Fetch some information about the audio file (vorbis format).</source>
          <target state="translated">Получите некоторую информацию о звуковом файле (формат vorbis).</target>
        </trans-unit>
        <trans-unit id="2e4202eb9f6e6dcd4cac937c7efcafd684b6457f" translate="yes" xml:space="preserve">
          <source>Fetch some information about the audio file (wav format).</source>
          <target state="translated">Получите некоторую информацию о звуковом файле (формат wav).</target>
        </trans-unit>
        <trans-unit id="186ed9dbd2bf579a770468333d387f501ffb7752" translate="yes" xml:space="preserve">
          <source>Fetch some information about the audio file.</source>
          <target state="translated">Получите информацию о звуковом файле.</target>
        </trans-unit>
        <trans-unit id="5a4f2e24777a7903f8fe536251fe32846c1b5bfd" translate="yes" xml:space="preserve">
          <source>Get a list of capture devices and some details about them</source>
          <target state="translated">Получите список устройств захвата и некоторые подробности о них.</target>
        </trans-unit>
        <trans-unit id="b8b1446c96fd3f5b208188010ebf095a045ce634" translate="yes" xml:space="preserve">
          <source>Get a list of playback devices and some details about them</source>
          <target state="translated">Получить список устройств для воспроизведения и некоторые подробности о них</target>
        </trans-unit>
        <trans-unit id="99c5a58c64a0dcefab5c129eba4b7ca9bd605bf3" translate="yes" xml:space="preserve">
          <source>Halt playback or capture and close down the device. If you use the device as a context manager,
it will be closed automatically.</source>
          <target state="translated">Остановите воспроизведение или захват и закройте устройство.Если вы используете устройство в качестве контекстного менеджера,оно будет закрыто автоматически.</target>
        </trans-unit>
        <trans-unit id="c15d34de162397ab149517d1962594775571867a" translate="yes" xml:space="preserve">
          <source>Halt playback or capture.</source>
          <target state="translated">Остановить воспроизведение или захват.</target>
        </trans-unit>
        <trans-unit id="0018035548eb18eed2a25b33d8f19122d0047472" translate="yes" xml:space="preserve">
          <source>How to dither when converting</source>
          <target state="translated">Как сгладить при преобразовании</target>
        </trans-unit>
        <trans-unit id="a840cbed29fc932cc14b53d9d64e6d53f1b5fd33" translate="yes" xml:space="preserve">
          <source>How to mix channels when converting</source>
          <target state="translated">Как смешивать каналы при преобразовании</target>
        </trans-unit>
        <trans-unit id="347c8121bfdc03e7b053c35a87cd33a64e08bfe2" translate="yes" xml:space="preserve">
          <source>How to seek() in a source</source>
          <target state="translated">Как искать()в источнике</target>
        </trans-unit>
        <trans-unit id="6e00d1353dec802fe52b88ea0cfeb01d6600ccf9" translate="yes" xml:space="preserve">
          <source>If you like this library you may also be interested in my &lt;a href=&quot;https://pypi.org/project/synthplayer/&quot;&gt;software FM synthesizer&lt;/a&gt;
or my &lt;a href=&quot;https://pypi.org/project/libxmplite/&quot;&gt;mod player&lt;/a&gt; which uses libxmp.</source>
          <target state="translated">Если вам понравилась эта библиотека, вас также может заинтересовать мой &lt;a href=&quot;https://pypi.org/project/synthplayer/&quot;&gt;программный FM-синтезатор&lt;/a&gt; или мой &lt;a href=&quot;https://pypi.org/project/libxmplite/&quot;&gt;мод-плеер,&lt;/a&gt; использующий libxmp.</target>
        </trans-unit>
        <trans-unit id="457427a8f15172bc3cb2e0839b3d93b80ecf5ddd" translate="yes" xml:space="preserve">
          <source>Joins a capture device and a playback device.</source>
          <target state="translated">Присоединяет устройство захвата и устройство воспроизведения.</target>
        </trans-unit>
        <trans-unit id="ee1878d4f1670e6a0b9f9f82af61fc0b6b013731" translate="yes" xml:space="preserve">
          <source>Most basic audio file playback</source>
          <target state="translated">Самое простое воспроизведение аудиофайлов</target>
        </trans-unit>
        <trans-unit id="dc66eb74996c944df63af7ed0de1c9b807a5d6a0" translate="yes" xml:space="preserve">
          <source>Multiplatform audio playback, recording, decoding and sample format conversion for
Linux (including Raspberri Pi), Windows, Mac and probably other systems such as BSD.</source>
          <target state="translated">Воспроизведение,запись,декодирование и преобразование формата сэмплов для Linux (включая Raspberri Pi),Windows,Mac и,возможно,других систем,таких как BSD.</target>
        </trans-unit>
        <trans-unit id="b5c91ee9d8b7bf1d7d84767669ce50d799d337d4" translate="yes" xml:space="preserve">
          <source>Operating system audio backend to use (only a subset will be available)</source>
          <target state="translated">Аудио бэкэнд операционной системы для использования (будет доступно только подмножество)</target>
        </trans-unit>
        <trans-unit id="f27a9fbd653a357fc8bb8e6f4bdc410c7a2f9b61" translate="yes" xml:space="preserve">
          <source>Playback of an unsupported file format</source>
          <target state="translated">Воспроизведение неподдерживаемого формата файла</target>
        </trans-unit>
        <trans-unit id="e591e0af6a6c6391d194bd6e12afc741ffe8406b" translate="yes" xml:space="preserve">
          <source>Python enums instead of just some integers for special values,</source>
          <target state="translated">Python enums вместо некоторых целых чисел для специальных значений,</target>
        </trans-unit>
        <trans-unit id="54793a59249c3156c861fd01e424e621b150a8dd" translate="yes" xml:space="preserve">
          <source>Python miniaudio</source>
          <target state="translated">питоновская мини-аудио</target>
        </trans-unit>
        <trans-unit id="0d191d9847ed570b471433e142d65bb66f5e2971" translate="yes" xml:space="preserve">
          <source>Query the audio playback and record devices that miniaudio provides</source>
          <target state="translated">Запрос аудио воспроизведения и записи устройств,которые мини-аудио обеспечивает</target>
        </trans-unit>
        <trans-unit id="61bab2e42a7af29d2dcce09211c38b610778bfde" translate="yes" xml:space="preserve">
          <source>Read up to the given amount of bytes from the file.</source>
          <target state="translated">Считывание до заданного количества байт из файла.</target>
        </trans-unit>
        <trans-unit id="fe56bdb333dbe0f5bddec13ce1b882cd52383449" translate="yes" xml:space="preserve">
          <source>Reads and decodes the whole audio file. Miniaudio will attempt to return the sound data in exactly
the same format as in the file. Unless you set convert_convert_to_16bit to True, then the result is
always a 16 bit sample format.</source>
          <target state="translated">Читает и декодирует весь аудиофайл.Miniaudio попытается вернуть звуковые данные в том же формате,что и в файле.Если вы не установите convert_convert_to_16bit в True,то результатом будет всегда 16-битный формат сэмпла.</target>
        </trans-unit>
        <trans-unit id="0e8bdcaedb57dd617455d038c31776466941252d" translate="yes" xml:space="preserve">
          <source>Reads and decodes the whole flac audio data. Resulting sample format is 16 bits signed integer.</source>
          <target state="translated">Читает и декодирует всю аудиофайловую информацию.Результирующий формат примера-16-битное целое число со знаком.</target>
        </trans-unit>
        <trans-unit id="83e8a8e5a3ed56569d0f9be71baa6e082d7dfac5" translate="yes" xml:space="preserve">
          <source>Reads and decodes the whole flac audio data. Resulting sample format is 32 bits signed integer.</source>
          <target state="translated">Читает и декодирует всю аудиофайловую информацию.Результирующий формат сэмпла-32-битное целое число со знаком.</target>
        </trans-unit>
        <trans-unit id="d0742dcd5ef6435f949f859ec7a58f8eaa689cb6" translate="yes" xml:space="preserve">
          <source>Reads and decodes the whole flac audio file. Resulting sample format is 16 bits signed integer.</source>
          <target state="translated">Читает и декодирует весь аудиофайл Flac.Результат-16-битное целое число со знаком.</target>
        </trans-unit>
        <trans-unit id="0888aba94a9ef51ae15ed2755cdb1df1991e3b15" translate="yes" xml:space="preserve">
          <source>Reads and decodes the whole flac audio file. Resulting sample format is 32 bits float.</source>
          <target state="translated">Читает и декодирует весь аудиофайл Flac.В результате формат сэмпла составляет 32 бита с плавающей точкой.</target>
        </trans-unit>
        <trans-unit id="d30f0ccd40b4fbb4d605c5b7d4a1a5609edd8cca" translate="yes" xml:space="preserve">
          <source>Reads and decodes the whole flac audio file. Resulting sample format is 32 bits signed integer.</source>
          <target state="translated">Читает и декодирует весь аудиофайл Flac.В результате формат примера-32-битное целое число со знаком.</target>
        </trans-unit>
        <trans-unit id="47063b2a70cb9b5a1a617f529035cd503b954756" translate="yes" xml:space="preserve">
          <source>Reads and decodes the whole mp3 audio data. Resulting sample format is 16 bits signed integer.</source>
          <target state="translated">Читает и декодирует все аудио данные mp3.Результат:формат сэмпла-16-битное целое число со знаком.</target>
        </trans-unit>
        <trans-unit id="e9b645c40de7581180539fda7f2e00a19594878d" translate="yes" xml:space="preserve">
          <source>Reads and decodes the whole mp3 audio data. Resulting sample format is 32 bits float.</source>
          <target state="translated">Читает и декодирует все аудио данные mp3.В результате формат сэмпла составляет 32 бита с плавающей точкой.</target>
        </trans-unit>
        <trans-unit id="b51b148ee75c39244a6d779136e490079f30261d" translate="yes" xml:space="preserve">
          <source>Reads and decodes the whole mp3 audio file. Resulting sample format is 16 bits signed integer.</source>
          <target state="translated">Читает и декодирует весь аудиофайл mp3.В результате формат примера-16-битное целое число со знаком.</target>
        </trans-unit>
        <trans-unit id="14cc1382f4fb5d59ec01f663604f21ca76b87c92" translate="yes" xml:space="preserve">
          <source>Reads and decodes the whole mp3 audio file. Resulting sample format is 32 bits float.</source>
          <target state="translated">Читает и декодирует весь аудиофайл mp3.В результате формат сэмпла-32 бита с плавающей точкой.</target>
        </trans-unit>
        <trans-unit id="66fd98fa7dbb958e3db6fe2376534cfd2599a4fd" translate="yes" xml:space="preserve">
          <source>Reads and decodes the whole vorbis audio data. Resulting sample format is 16 bits signed integer.</source>
          <target state="translated">Читает и декодирует все аудио данные ворбисов.Результирующий формат примера-16-битное целое число со знаком.</target>
        </trans-unit>
        <trans-unit id="7ce7effdcc92e574769789424af238e1f5022767" translate="yes" xml:space="preserve">
          <source>Reads and decodes the whole vorbis audio file. Resulting sample format is 16 bits signed integer.</source>
          <target state="translated">Читает и декодирует весь аудиофайл vorbis.Результат:формат примера-16-битное целое число со знаком.</target>
        </trans-unit>
        <trans-unit id="7bee529dbc8b35f42acc1e2d940fa7a23db13f74" translate="yes" xml:space="preserve">
          <source>Reads and decodes the whole wav audio data. Resulting sample format is 16 bits signed integer.</source>
          <target state="translated">Читает и декодирует всю звуковую информацию о волнах.Результирующий формат сэмпла-16-битное целое число со знаком.</target>
        </trans-unit>
        <trans-unit id="cd8bb367290e103b37d8e55a004d7baf5eb4b046" translate="yes" xml:space="preserve">
          <source>Reads and decodes the whole wav audio data. Resulting sample format is 32 bits float.</source>
          <target state="translated">Читает и декодирует всю звуковую информацию о волнах.В результате формат сэмпла составляет 32 бита с плавающей точкой.</target>
        </trans-unit>
        <trans-unit id="0316c1a19af6c11394e2363a0c7a909945bfd350" translate="yes" xml:space="preserve">
          <source>Reads and decodes the whole wav audio data. Resulting sample format is 32 bits signed integer.</source>
          <target state="translated">Читает и декодирует всю звуковую информацию о волнах.Результирующий формат сэмпла-32-битное целое число со знаком.</target>
        </trans-unit>
        <trans-unit id="e06be3ec9628fe144f07b9524ee4e3afb5f98e6c" translate="yes" xml:space="preserve">
          <source>Reads and decodes the whole wav audio file. Resulting sample format is 16 bits signed integer.</source>
          <target state="translated">Читает и декодирует весь аудиофайл wav.Результат-16-битное целое число со знаком.</target>
        </trans-unit>
        <trans-unit id="cf9e6ecb9c5aa6ba5d95e785c940830c651e4fe8" translate="yes" xml:space="preserve">
          <source>Reads and decodes the whole wav audio file. Resulting sample format is 32 bits float.</source>
          <target state="translated">Читает и декодирует весь аудиофайл wav.В результате получается 32-битный формат с плавающей запятой.</target>
        </trans-unit>
        <trans-unit id="211262dda5092fe90e275b0a2fdcf7b86664fed8" translate="yes" xml:space="preserve">
          <source>Reads and decodes the whole wav audio file. Resulting sample format is 32 bits signed integer.</source>
          <target state="translated">Читает и декодирует весь аудиофайл wav.В результате формат примера-32-битное целое число со знаком.</target>
        </trans-unit>
        <trans-unit id="b94764377806d47d4554064e530504fae16cbd28" translate="yes" xml:space="preserve">
          <source>Represents a source of data bytes.</source>
          <target state="translated">Представляет собой источник байтов данных.</target>
        </trans-unit>
        <trans-unit id="08dea8f05696619166984f7255726ff1f036dba6" translate="yes" xml:space="preserve">
          <source>Sample format in memory</source>
          <target state="translated">Формат образца в памяти</target>
        </trans-unit>
        <trans-unit id="1fbc24457e328192fefcfa11e3180acada1161ae" translate="yes" xml:space="preserve">
          <source>Software license for these Python bindings, miniaudio and the decoders: MIT</source>
          <target state="translated">Лицензия на программное обеспечение для этих переплетов Python,мини-аудио и декодеров:MIT</target>
        </trans-unit>
        <trans-unit id="45d391119440fd7bbd319914ab435e60fa35003b" translate="yes" xml:space="preserve">
          <source>Start the audio device: capture (recording) begins. The recorded audio data is sent to the given
callback generator as raw bytes. (it should already be started before)</source>
          <target state="translated">Запуск аудиоустройства:начинается захват (запись).Записанные звуковые данные отправляются в заданный генератор обратного вызова в виде необработанных байтов.(он уже должен быть запущен раньше)</target>
        </trans-unit>
        <trans-unit id="945b56ded1305142d54f39c6e7365e77951321bb" translate="yes" xml:space="preserve">
          <source>Start the audio device: playback and capture begin. The audio data for playback is provided by
the given callback generator, which is sent the recorded audio data at the same time. (it should
already be started before passing it in)</source>
          <target state="translated">Запустите аудиоустройство:начало воспроизведения и захвата.Звуковые данные для воспроизведения предоставляются заданным генератором обратного вызова,который одновременно отправляет записанные звуковые данные.(он уже должен быть запущен перед передачей).</target>
        </trans-unit>
        <trans-unit id="ff2caf20fc34ab9e50df0099b5a27d767b47f447" translate="yes" xml:space="preserve">
          <source>Start the audio device: playback begins. The audio data is provided by the given callback
generator. The generator gets sent the required number of frames and should yield the sample data as
raw bytes, a memoryview, an array.array, or as a numpy array with shape (numframes, numchannels).
The generator should already be started before passing it in.</source>
          <target state="translated">Запуск аудиоустройства:начинается воспроизведение.Звуковые данные предоставляются заданным генератором обратного вызова.Генератор получает необходимое количество кадров и должен выдать данные сэмпла в виде необработанных байтов,вида памяти,массива array.array или нумерованного массива с формой (нумерованные кадры,нумерованные каналы).Генератор должен быть уже запущен перед передачей.</target>
        </trans-unit>
        <trans-unit id="76c76d79173b0b9b08e168d4486dceaa35768406" translate="yes" xml:space="preserve">
          <source>Streams the WAV audio file as interleaved 16 bit signed integer sample arrays segments. This uses
a fixed chunk size and cannot be used as a generic miniaudio decoder input stream. Consider using
stream_file() instead.</source>
          <target state="translated">Потоки аудиофайла WAV в виде чередующихся 16-битных подписанных целочисленных сегментов массивов-примеров.При этом используется фиксированный размер фрагмента и не может быть использован в качестве общего входного потока миниатюрного декодера.Рассмотрим вариант использования функции stream_file().</target>
        </trans-unit>
        <trans-unit id="3738b64687d0324519ab81c368d92a787f244881" translate="yes" xml:space="preserve">
          <source>Streams the flac audio file as interleaved 16 bit signed integer sample arrays segments. This uses
a fixed chunk size and cannot be used as a generic miniaudio decoder input stream. Consider using
stream_file() instead.</source>
          <target state="translated">Потоки Flac аудио файла в виде чередующихся 16-битных подписанных целочисленных сегментов массивов-примеров.При этом используется фиксированный размер фрагмента и не может быть использован в качестве общего входного потока миниатюрного декодера.Рассмотрим вариант использования функции stream_file().</target>
        </trans-unit>
        <trans-unit id="9482cf45ccd4f9efa70e90e823a12533679ea051" translate="yes" xml:space="preserve">
          <source>Streams the mp3 audio file as interleaved 16 bit signed integer sample arrays segments. This uses
a fixed chunk size and cannot be used as a generic miniaudio decoder input stream. Consider using
stream_file() instead.</source>
          <target state="translated">Потоки аудиофайла mp3 в виде чередующихся 16-битных подписанных целочисленных сегментов массивов-примеров.При этом используется фиксированный размер фрагмента и не может быть использован в качестве общего входного потока миниатюрного декодера.Рассмотрим вариант использования функции stream_file().</target>
        </trans-unit>
        <trans-unit id="7b5b03821afe1fe31d72644c2febc2ed586f6dbb" translate="yes" xml:space="preserve">
          <source>Streams the ogg vorbis audio file as interleaved 16 bit signed integer sample arrays segments.
This uses a variable unconfigurable chunk size and cannot be used as a generic miniaudio decoder
input stream. Consider using stream_file() instead.</source>
          <target state="translated">Потоки аудио файла ogg vorbis в виде чередующихся 16-битных подписанных целочисленных сегментов массивов-примеров.При этом используется переменная с неконфигурируемым размером фрагмента и не может быть использована в качестве общего входного потока миниатюрного декодера.Рассмотрим вариант использования функции stream_file().</target>
        </trans-unit>
        <trans-unit id="e4732f234fdca3d7bb1afb9876ff4d663409e880" translate="yes" xml:space="preserve">
          <source>Synthesizer, modplayer?</source>
          <target state="translated">Синтезатор,модник?</target>
        </trans-unit>
        <trans-unit id="db65432ebabea4a5139d1b096c85c5fcbcaf2b57" translate="yes" xml:space="preserve">
          <source>TODO: filters</source>
          <target state="translated">TODO:фильтры</target>
        </trans-unit>
        <trans-unit id="8bdf7d7031ef484465db0916ba56228b84f47b7e" translate="yes" xml:space="preserve">
          <source>TODO: waveform generators</source>
          <target state="translated">TODO:генераторы сигналов</target>
        </trans-unit>
        <trans-unit id="dd6e4f4697b675457ca9ebfbfb8f624f2f8ff7de" translate="yes" xml:space="preserve">
          <source>The library is primarily distributed in source form so you need a C compiler to build and install this
(note: the setup script takes care of the actual compilation process, no need to worry about compiling things yourself).
For Linux and Mac this shouldn't be a problem. For Windows users, if the correct binary install
is not available on pypi, you'll have to get it to compile as well which may be a bit of a hassle
on this platform. You have to make sure that the required tools that allow you to compile Python extension modules
are installed (Visual Studio or the VC++ build tools).</source>
          <target state="translated">Библиотека распространяется в основном в исходном виде,поэтому для сборки и установки необходим C-компилятор (обратите внимание:скрипт установки заботится о собственно процессе компиляции,не нужно беспокоиться о компиляции самостоятельно).Для Linux и Mac это не должно быть проблемой.Для пользователей Windows,если правильная бинарная установка не доступна на pypi,вам придется заставить его скомпилировать также,что может быть немного затруднительно на этой платформе.Нужно убедиться,что установлены необходимые инструменты,позволяющие скомпилировать модули расширения Python (Visual Studio или сборочные инструменты VC++).</target>
        </trans-unit>
        <trans-unit id="3ed6ea8457e732020e5e7c68ec8bc977f320c74f" translate="yes" xml:space="preserve">
          <source>The priority of the worker thread (default=HIGHEST)</source>
          <target state="translated">Приоритет рабочего потока (по умолчанию=ВЫСОКИЙ)</target>
        </trans-unit>
        <trans-unit id="1d3f94de385ebfc9cd02ce7bb23cc8223825c59e" translate="yes" xml:space="preserve">
          <source>This example uses ffmpeg as an external tool to decode an audio file in a format
that miniaudio itself can't decode (m4a/aac in this case):</source>
          <target state="translated">В этом примере используется ffmpeg в качестве внешнего инструмента для декодирования аудиофайла в формате,который сам miniaudio не может декодировать (в данном случае m4a/aac):</target>
        </trans-unit>
        <trans-unit id="5911a575014ce2d1da77c61a88e0f76c62bfb790" translate="yes" xml:space="preserve">
          <source>This library aims to provide a Pythonic interface to the miniaudio C library.
Some of the main aspects of this are:</source>
          <target state="translated">Эта библиотека предназначена для обеспечения пифонического интерфейса для миниатюрной C-библиотеки.Некоторые из основных аспектов:</target>
        </trans-unit>
        <trans-unit id="389d67d4e425bd22cb93a94f064798d7a90e6644" translate="yes" xml:space="preserve">
          <source>This module provides:</source>
          <target state="translated">Этот модуль обеспечивает:</target>
        </trans-unit>
        <trans-unit id="170c5132604e95ae76726c1db966048a228bb943" translate="yes" xml:space="preserve">
          <source>Type of audio device</source>
          <target state="translated">Тип аудиоустройства</target>
        </trans-unit>
        <trans-unit id="f99c32a07530d0d3059a528f698be74929fb0a01" translate="yes" xml:space="preserve">
          <source>When a miniaudio specific error occurs.</source>
          <target state="translated">При возникновении специфической для миниаудио ошибки.</target>
        </trans-unit>
        <trans-unit id="93256ad3c60c2669cdc10ed669d360a02c91bcf8" translate="yes" xml:space="preserve">
          <source>When something went wrong during decoding an audio file.</source>
          <target state="translated">Когда что-то пошло не так во время декодирования аудиофайла.</target>
        </trans-unit>
        <trans-unit id="56e07f7cf6898b2eab378ae9d1ab0421de7ae314" translate="yes" xml:space="preserve">
          <source>Writes the pcm sound to a WAV file</source>
          <target state="translated">Записывает pcm звук в WAV-файл.</target>
        </trans-unit>
        <trans-unit id="b6dbe85a2dc821488f64260d49026ef62265acaa" translate="yes" xml:space="preserve">
          <source>audio playback</source>
          <target state="translated">воспроизведение аудио</target>
        </trans-unit>
        <trans-unit id="d915246f9ca1345a5feba62e84a502aa445c4311" translate="yes" xml:space="preserve">
          <source>audio recording</source>
          <target state="translated">аудиозапись</target>
        </trans-unit>
        <trans-unit id="79cd964eff1ec3f6a10c6ff422280e07044c7347" translate="yes" xml:space="preserve">
          <source>converting sample formats and frequencies</source>
          <target state="translated">преобразование форматов и частот дискретов</target>
        </trans-unit>
        <trans-unit id="3239aa4d8ed17fa10aabaeb8f958c0cf040d0723" translate="yes" xml:space="preserve">
          <source>generators for the Audio playback and recording</source>
          <target state="translated">генераторы для воспроизведения и записи звука</target>
        </trans-unit>
        <trans-unit id="9f44b27fd037879342d5e1284d5cc63359e1b680" translate="yes" xml:space="preserve">
          <source>getting audio file properties (such as duration, number of channels, sample rate)</source>
          <target state="translated">получение свойств аудиофайла (таких как продолжительность,количество каналов,частота дискретизации)</target>
        </trans-unit>
        <trans-unit id="4a530d2bffe101a83fbd1521b4e5a25c9f525273" translate="yes" xml:space="preserve">
          <source>its decoders for wav, flac, vorbis and mp3</source>
          <target state="translated">его декодеры для wav,flac,vorbis и mp3</target>
        </trans-unit>
        <trans-unit id="6e06f5192e5c61836071c7b542573ccca6113879" translate="yes" xml:space="preserve">
          <source>python bindings for most of the functions offered in those libraries:</source>
          <target state="translated">питоновые крепления для большинства функций,предлагаемых в этих библиотеках:</target>
        </trans-unit>
        <trans-unit id="5691ee15da5634f86093f97c3fd972b1c2dc3add" translate="yes" xml:space="preserve">
          <source>python bindings for the miniaudio library and its decoders (mp3, flac, ogg vorbis, wav)</source>
          <target state="translated">питоновые переплеты для миниатюрной библиотеки и ее декодеров (mp3,flac,ogg vorbis,wav)</target>
        </trans-unit>
        <trans-unit id="8a22aba5682ed6386f904e381fd0d23444b4f9e0" translate="yes" xml:space="preserve">
          <source>reading and decoding audio files</source>
          <target state="translated">чтение и декодирование аудиофайлов</target>
        </trans-unit>
        <trans-unit id="b564d1f2a1cbbfeddd85f762834889c6ca9bcd69" translate="yes" xml:space="preserve">
          <source>sample data is usually in the form of a Python &lt;code&gt;array&lt;/code&gt; with appropriately sized elements
depending on the sample width (rather than a raw block of bytes)</source>
          <target state="translated">данные образца обычно представлены в виде &lt;code&gt;array&lt;/code&gt; Python с элементами подходящего размера в зависимости от ширины образца (а не необработанного блока байтов)</target>
        </trans-unit>
        <trans-unit id="2093da2e24735be37f448f0fea1835324065015a" translate="yes" xml:space="preserve">
          <source>several classes to represent the main functions of the library,</source>
          <target state="translated">несколько классов для представления основных функций библиотеки,</target>
        </trans-unit>
        <trans-unit id="205080bba7759412ece27e6d7727faf0536b02d5" translate="yes" xml:space="preserve">
          <source>streaming large audio files</source>
          <target state="translated">потоковые большие аудиофайлы</target>
        </trans-unit>
        <trans-unit id="3ddb7f59b1ed2b644f82493a1940e3ba55dd1628" translate="yes" xml:space="preserve">
          <source>the &lt;a href=&quot;https://github.com/dr-soft/miniaudio/&quot;&gt;miniaudio&lt;/a&gt; cross platform sound playback, recording and conversion library</source>
          <target state="translated">&lt;a href=&quot;https://github.com/dr-soft/miniaudio/&quot;&gt;miniaudio&lt;/a&gt; крест воспроизведения платформы звук, запись и преобразование библиотеки</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
