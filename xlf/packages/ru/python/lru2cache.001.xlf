<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="https://pypi.org/project/lru2cache/">
    <body>
      <group id="lru2cache">
        <trans-unit id="6d6173d566ffb20c8641ba2752b927248f8ab6c3" translate="yes" xml:space="preserve">
          <source>, function arguments of different types will be
cached separately. For example, f(3) and f(3.0) will be treated as distinct
calls with distinct results.</source>
          <target state="translated">, аргументы функций разных типов будут кэшироваться отдельно. Например, f (3) и f (3.0) будут обрабатываться как отдельные вызовы с разными результатами.</target>
        </trans-unit>
        <trans-unit id="7207846477fc222c6dd0427e85462ac564927fea" translate="yes" xml:space="preserve">
          <source>, the LRU feature is disabled and the L1 cache
can grow without bound. The LRU feature performs best when maxsize is a power-of-two.</source>
          <target state="translated">, функция LRU отключена, и кэш L1 может неограниченно расти. Функция LRU работает лучше всего, когда maxsize равен степени двойки.</target>
        </trans-unit>
        <trans-unit id="d99d3502cdad96aa76d33d37c0cc8a9682cf6459" translate="yes" xml:space="preserve">
          <source>. These stats are stored within an instance, and therefore
are specific to that instance. Cumulative statistics for the shared cache would
need to be obtained from the shared cache.</source>
          <target state="translated">. Эта статистика хранится внутри экземпляра и, следовательно, относится к этому экземпляру. Накопительную статистику для общего кэша необходимо будет получить из общего кеша.</target>
        </trans-unit>
        <trans-unit id="2be5d9e9d6ec5fbbfff0627d5ceb897a4d377376" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Local and Shared Cache&lt;/strong&gt; - Combining both types of cache is much more
effective than either used on it&amp;rsquo;s own.  The local cache eliminates the
latency of calls to a shared cache, while the shared cache eliminates
the expense of returning the result</source>
          <target state="translated">&lt;strong&gt;Локальный и общий кэш&lt;/strong&gt; - сочетание обоих типов кеша намного эффективнее, чем использование любого из них по отдельности. Локальный кеш устраняет задержку вызовов общего кеша, в то время как общий кеш устраняет расходы на возврат результата</target>
        </trans-unit>
        <trans-unit id="3a61811019e173a17190bff6fd9ad90f453f5c97" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The Ability to Not Cache None Results&lt;/strong&gt; - This may seem like a minor thing
but in our environment it has greatly reduced the frequency of cache
invalidations.</source>
          <target state="translated">&lt;strong&gt;Возможность не кэшировать результаты&lt;/strong&gt; - это может показаться мелочью, но в нашей среде это значительно снизило частоту аннулирования кеша.</target>
        </trans-unit>
        <trans-unit id="4d15addbdae92bf79453914d11dea5bbd5322f8d" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;http://en.wikipedia.org/wiki/Cache_algorithms#Least_Recently_Used&quot;&gt;least recently used (LRU)&lt;/a&gt;
2 layer caching mechanism based in part on the Python 2.7 back-port of</source>
          <target state="translated">&lt;a href=&quot;http://en.wikipedia.org/wiki/Cache_algorithms#Least_Recently_Used&quot;&gt;Не менее в последнее время используется (НДИ)&lt;/a&gt; 2 слоя механизм кэширования частично основанный на Python 2.7 обратно-порт</target>
        </trans-unit>
        <trans-unit id="3efcd57fb6b3d75f3484be9e543fff6a457c01c9" translate="yes" xml:space="preserve">
          <source>A least recently used (LRU) 2 layer caching mechanism based in part on the Python 2.7 back-port of lru_cache</source>
          <target state="translated">Наименее недавно использованный (LRU)2-х слойный механизм кэширования,частично основанный на back-port lru_cache на Python 2.7.</target>
        </trans-unit>
        <trans-unit id="32e4be867670ced87f1b50b35d669b04ce0f3a8b" translate="yes" xml:space="preserve">
          <source>A shared cache can easily be cleared with the following:</source>
          <target state="translated">Общий кэш можно легко очистить следующим образом:</target>
        </trans-unit>
        <trans-unit id="b6ad70fe8987a492b217f1d3fdc6bc56a8799161" translate="yes" xml:space="preserve">
          <source>Accessing the Function without Cache</source>
          <target state="translated">Доступ к функции без кэша</target>
        </trans-unit>
        <trans-unit id="37e1c7c46791ba8b13b32bdb24bd8673a2f3fe3e" translate="yes" xml:space="preserve">
          <source>As a starting point I incorporated most of the tests for</source>
          <target state="translated">В качестве отправной точки я включил большинство тестов для</target>
        </trans-unit>
        <trans-unit id="3938496e65e6dd032b899a42196062cb85acaa7a" translate="yes" xml:space="preserve">
          <source>As with lru_cache, one can view the cache statistics via a named tuple
(l1_hits, l1_misses, l2_hits, l2_misses, l1_maxsize, l1_currsize), with</source>
          <target state="translated">Как и в случае с lru_cache,статистику кэша можно посмотреть через именованный кортеж (l1_hits,l1_misses,l2_hits,l2_misses,l1_maxsize,l1_currsize),с помощью параметра</target>
        </trans-unit>
        <trans-unit id="6bbdf159e71b2fcdfa75bfaf3c0ec17a80b21b52" translate="yes" xml:space="preserve">
          <source>At &lt;a href=&quot;http://www.3top.com/&quot;&gt;3Top&lt;/a&gt; We needed a way to improve performance of
slow queries, not just those using the Django ORM, but also for queries to
other data stores and services.  We started off with a simpler centralized
caching solution using Memcached, but even those queries, when called frequently,
can start to cause delays.  Therefore we sought a means of caching at two layers.</source>
          <target state="translated">В &lt;a href=&quot;http://www.3top.com/&quot;&gt;3Top&lt;/a&gt; Нам нужен был способ улучшить производительность медленных запросов, не только тех, которые используют Django ORM, но и запросов к другим хранилищам данных и службам. Мы начали с более простого решения для централизованного кэширования с использованием Memcached, но даже эти запросы при частом вызове могут вызывать задержки. Поэтому мы искали способ кэширования на двух уровнях.</target>
        </trans-unit>
        <trans-unit id="aeaf0e85f848b550a565ca5901e53d4306577d16" translate="yes" xml:space="preserve">
          <source>Background and Development</source>
          <target state="translated">Предыстория и развитие</target>
        </trans-unit>
        <trans-unit id="a086c0543fd27c08b64c003ddb4513c6845eb29a" translate="yes" xml:space="preserve">
          <source>Benefits Over functools.lru_cache</source>
          <target state="translated">Преимущества над functools.lru_cache</target>
        </trans-unit>
        <trans-unit id="d2469c2aa14798195f6bc3ae16fcf004712ca85e" translate="yes" xml:space="preserve">
          <source>Cache Management</source>
          <target state="translated">управление кэшем</target>
        </trans-unit>
        <trans-unit id="35242c52a20b0f631fccc4a7c16ed23a76be06bd" translate="yes" xml:space="preserve">
          <source>Cache Statistics</source>
          <target state="translated">статистика кэша</target>
        </trans-unit>
        <trans-unit id="53a0d2b5765f8ae251aea63864f78dac2259b0d7" translate="yes" xml:space="preserve">
          <source>Clearing Instance Cache</source>
          <target state="translated">Кэш очищающей таблетки</target>
        </trans-unit>
        <trans-unit id="bf5dec3573c5a5d21ca6a1425613a8510bf9f271" translate="yes" xml:space="preserve">
          <source>Clearing Shared Cache</source>
          <target state="translated">Очистка общего кэша</target>
        </trans-unit>
        <trans-unit id="751c68a3471b1c791efaee0a8e7c24ea0c266efd" translate="yes" xml:space="preserve">
          <source>If</source>
          <target state="translated">Если</target>
        </trans-unit>
        <trans-unit id="95f76da19cad315076ccc2afaa0e41daf973ca96" translate="yes" xml:space="preserve">
          <source>If available this package will use SpookyHash V2 as a hashing mechanism.
Spooky is a good fast hashing algorithm that should be suitable for most uses.
If it is not available the package will fall back to SHA-256 from the standard
hashlib.  Because SHA-256 is a proper cryptographic hash it requires more
computation than Spooky.  To install spooky use pip:</source>
          <target state="translated">Если доступно,то этот пакет будет использовать SpookyHash V2 в качестве хэш-механизма.Spooky-это хороший быстрый алгоритм хэширования,который должен подходить для большинства применений.Если он недоступен,то пакет вернётся к SHA-256 из стандартного хэширования.Поскольку SHA-256 является правильным криптографическим хэшем,он требует больше вычислений,чем Spooky.Для установки жутко используйте pip:</target>
        </trans-unit>
        <trans-unit id="bd872a8af71a679a7a57ab648b7308f8099f311d" translate="yes" xml:space="preserve">
          <source>If you do not want to use either</source>
          <target state="translated">Если вы не хотите использовать</target>
        </trans-unit>
        <trans-unit id="f20cd38b0f0d290cf5aa2dda99bb5da47f90a908" translate="yes" xml:space="preserve">
          <source>Initially we looked at the possibility of using two different mechanisms but
we quickly saw the advantage of maintaining the same set of keys for both
caches and decided to create our own mechanism.</source>
          <target state="translated">Изначально мы рассматривали возможность использования двух различных механизмов,но быстро увидели преимущество сохранения одного и того же набора ключей для обоих кэшей и решили создать свой собственный механизм.</target>
        </trans-unit>
        <trans-unit id="debd19f419480deae2e24d7b2b4c8018a365b90e" translate="yes" xml:space="preserve">
          <source>Installation &amp;amp; Configuration</source>
          <target state="translated">Установка и настройка</target>
        </trans-unit>
        <trans-unit id="cc1093a96d4b2482bcaf84ac72db0fe4a89cb2c3" translate="yes" xml:space="preserve">
          <source>Invalidating Cached Results</source>
          <target state="translated">Недействительные кэшированные результаты</target>
        </trans-unit>
        <trans-unit id="6eef6648406c333a4035cd5e60d0bf2ecf2606d7" translate="yes" xml:space="preserve">
          <source>None</source>
          <target state="translated">Нет</target>
        </trans-unit>
        <trans-unit id="5cfe5bbe5ae1dcb900a59525d853591e69656103" translate="yes" xml:space="preserve">
          <source>Once lru2cache is installed you will need to configure a shared cache as an
l2 cache.  If you are using Django your settings file will contain something
similar to the following in the settings file:</source>
          <target state="translated">После установки lru2cache вам нужно будет настроить разделяемый кэш в качестве l2 кэша.Если Вы используете Django,Ваш файл настроек будет содержать нечто похожее на следующее в файле настроек:</target>
        </trans-unit>
        <trans-unit id="5da6bc6ba91b6bc6224f81e28bb845e36941f36f" translate="yes" xml:space="preserve">
          <source>Refreshing the Cache</source>
          <target state="translated">Освежающий кэш</target>
        </trans-unit>
        <trans-unit id="3fc5f2545bc12aba6c4ecc7066bfa0304189551b" translate="yes" xml:space="preserve">
          <source>Since the lru2cache decorator does not provide a timeout for its cache although
it provides other mechanisms for programatically managing the cache.</source>
          <target state="translated">Поскольку декоратор lru2cache не предоставляет тайм-аут для своего кэша,хотя и предоставляет другие механизмы для программного управления кэшем.</target>
        </trans-unit>
        <trans-unit id="39fdec1194d94212b871a28b2aa04a73cd40fce1" translate="yes" xml:space="preserve">
          <source>Tests</source>
          <target state="translated">Тесты</target>
        </trans-unit>
        <trans-unit id="1d0165a592656f6dd286443745686b0cd7caff47" translate="yes" xml:space="preserve">
          <source>The easiest and best way to install this is with pip:</source>
          <target state="translated">Самый простой и лучший способ установки-с помощью трубопровода:</target>
        </trans-unit>
        <trans-unit id="b4358f486357d25333aa98b7ac1dc2af818fc3e0" translate="yes" xml:space="preserve">
          <source>The first layer of caching is stored in a callable that wraps the function or
method.  As with &amp;lsquo;functools.lru_cache&amp;rsquo; a dict is used to store the cached
results, therefore positional and keyword arguments must be hashable. Each
instance stores up to</source>
          <target state="translated">Первый уровень кеширования хранится в вызываемом объекте, который является оболочкой для функции или метода. Как и в случае с functools.lru_cache, для хранения кешированных результатов используется dict, поэтому позиционные аргументы и аргументы ключевого слова должны быть хешируемыми. Каждый экземпляр хранит до</target>
        </trans-unit>
        <trans-unit id="0ea4401b5713b542a1e261e03fdcbec558a8d19b" translate="yes" xml:space="preserve">
          <source>The second layer of caching requires a shared cache that can make use of
Django&amp;rsquo;s cache framework.  In this case it is assumed that any LRU mechanism
is handled by the shared cache backend.</source>
          <target state="translated">Для второго уровня кеширования требуется общий кеш, который может использовать структуру кеширования Django. В этом случае предполагается, что любой механизм LRU обрабатывается серверной частью общего кэша.</target>
        </trans-unit>
        <trans-unit id="176ea28590869923dcfef77790d0be6e85b0bc24" translate="yes" xml:space="preserve">
          <source>The un-cached underlying function can always be accessed with</source>
          <target state="translated">К некэшированной базовой функции всегда можно получить доступ с помощью</target>
        </trans-unit>
        <trans-unit id="d8e2dde7858b0f625a6bbfb5559beee48b1cb949" translate="yes" xml:space="preserve">
          <source>This arrangement allows a process that accesses a function multiple times to
retrieve the value without the expense of requesting it from a shared cache,
while still allowing different processes to access the result from the shared
cache.</source>
          <target state="translated">Такое расположение позволяет процессу,который обращается к функции несколько раз,получить значение без затрат на его запрос из общего кэша,в то же время позволяя различным процессам получить доступ к результату из общего кэша.</target>
        </trans-unit>
        <trans-unit id="75b9de2bd29cbf6751c7a36363a0fd751ecacea2" translate="yes" xml:space="preserve">
          <source>This is not yet implemented as a function but can be accomplished by first calling
invalidate and then calling the function</source>
          <target state="translated">Это еще не реализовано как функция,но может быть выполнено сначала вызовом недействительной,а затем вызовом функции</target>
        </trans-unit>
        <trans-unit id="6c5e4c3c083a750c34b9adaef009aac85d3924c6" translate="yes" xml:space="preserve">
          <source>This was developed by &lt;a href=&quot;http://www.3top.com/team&quot;&gt;3Top, Inc.&lt;/a&gt; for use with
our ranking and recommendation platform, &lt;a href=&quot;http://www.3top.com&quot;&gt;http://www.3top.com&lt;/a&gt;.</source>
          <target state="translated">Он был разработан &lt;a href=&quot;http://www.3top.com/team&quot;&gt;3Top, Inc.&lt;/a&gt; для использования с нашей платформой ранжирования и рекомендаций &lt;a href=&quot;http://www.3top.com&quot;&gt;http://www.3top.com&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="fde1a31e15e42e88afb165e49cb21121fae29131" translate="yes" xml:space="preserve">
          <source>To invalidate the cache for a specific set of arguments, including the instance
one can pass the same arguments to invalidate the both L1 and L2 caches:</source>
          <target state="translated">Чтобы сделать недействительным кэш для определенного набора аргументов,включая экземпляр,можно передать одни и те же аргументы,чтобы сделать недействительными кэши L1 и L2:</target>
        </trans-unit>
        <trans-unit id="88b33e4e12f75ac8bf792aebde41f1a090f3a612" translate="yes" xml:space="preserve">
          <source>True</source>
          <target state="translated">Правда</target>
        </trans-unit>
        <trans-unit id="0bb18642b70b9f8a9c12ccf39487328f306b8e19" translate="yes" xml:space="preserve">
          <source>Usage</source>
          <target state="translated">Использование</target>
        </trans-unit>
        <trans-unit id="3b2cb96142ae431c2df3de4bb6b9a4cbca498afc" translate="yes" xml:space="preserve">
          <source>Usage is as simple as adding the decorator to a function or method as seen in
the below examples from our test cases:</source>
          <target state="translated">Использование настолько же просто,как и добавление декоратора к функции или методу,как показано в нижеприведенных примерах из наших тестовых случаев:</target>
        </trans-unit>
        <trans-unit id="b8b4346e8782d546f582feeaec684daca029da8b" translate="yes" xml:space="preserve">
          <source>We used a backport python 3</source>
          <target state="translated">Мы использовали бэкпортовый питон 3</target>
        </trans-unit>
        <trans-unit id="235811c1759d45111475d5266bc6a107245df52d" translate="yes" xml:space="preserve">
          <source>and if not found fall back to</source>
          <target state="translated">и если не будет найдено,то</target>
        </trans-unit>
        <trans-unit id="b204bca289d16df380a96f6adc203c95eff37534" translate="yes" xml:space="preserve">
          <source>decorator as a starting
point for developing an in instance cache with LRU capabilities.  However we
needed to ensure the keys would also be unique enough to use with a shared
cache. We leverage Django&amp;rsquo;s excellent cache framework for managing the layer 2
cache. This allows the use of any shared cache supported by Django.</source>
          <target state="translated">декоратор в качестве отправной точки для разработки кэша экземпляра с возможностями LRU. Однако нам нужно было убедиться, что ключи также будут достаточно уникальными для использования с общим кешем. Мы используем отличную структуру кеширования Django для управления кешем уровня 2. Это позволяет использовать любой общий кеш, поддерживаемый Django.</target>
        </trans-unit>
        <trans-unit id="7505d64a54e061b7acd54ccd58b49dc43500b635" translate="yes" xml:space="preserve">
          <source>default</source>
          <target state="translated">стандартный</target>
        </trans-unit>
        <trans-unit id="778b425edf8ec003eb2a0a2d8a7a2a3d54043356" translate="yes" xml:space="preserve">
          <source>f.__wrapped__</source>
          <target state="translated">Завернутый.</target>
        </trans-unit>
        <trans-unit id="cf8c707a6006ea42369c462118f8380268597325" translate="yes" xml:space="preserve">
          <source>f.cache_info()</source>
          <target state="translated">f.cache_info()</target>
        </trans-unit>
        <trans-unit id="54800f8bd035a18cec9a83721a2f0d9901a88020" translate="yes" xml:space="preserve">
          <source>functools.lru_cache</source>
          <target state="translated">functools.lru_cache</target>
        </trans-unit>
        <trans-unit id="dcfadac569c49917e69f513a3e245fd1d6b2c92c" translate="yes" xml:space="preserve">
          <source>functools.lru_cache()</source>
          <target state="translated">functools.lru_cache()</target>
        </trans-unit>
        <trans-unit id="c589e370d15354bfa1c43ff28cafcd54ca93fbb2" translate="yes" xml:space="preserve">
          <source>however if it is not you will
need to specify what attribute should be used.</source>
          <target state="translated">Однако,если это не так,Вам необходимо будет указать,какой атрибут следует использовать.</target>
        </trans-unit>
        <trans-unit id="87ea5dfc8b8e384d848979496e706390b497e547" translate="yes" xml:space="preserve">
          <source>id</source>
          <target state="translated">id</target>
        </trans-unit>
        <trans-unit id="958f57f57d72a30f329ee5538f21b0257a49a46e" translate="yes" xml:space="preserve">
          <source>if</source>
          <target state="translated">если</target>
        </trans-unit>
        <trans-unit id="894f317b9160e13f41fd9889fbe20573a6a2fa51" translate="yes" xml:space="preserve">
          <source>in the case of a method you do need to explicitly pass the instance as in the
following:</source>
          <target state="translated">в случае метода вам необходимо явно передать экземпляр,как показано ниже:</target>
        </trans-unit>
        <trans-unit id="99578a0572cb4666f7da4c6317812a1795e90db6" translate="yes" xml:space="preserve">
          <source>inst_attr</source>
          <target state="translated">инстинкт</target>
        </trans-unit>
        <trans-unit id="b47f363e2b430c0647f14deea3eced9b0ef300ce" translate="yes" xml:space="preserve">
          <source>is</source>
          <target state="translated">is</target>
        </trans-unit>
        <trans-unit id="04aea98291c14f68c64d647870dcc66791bebff3" translate="yes" xml:space="preserve">
          <source>is set to</source>
          <target state="translated">наступает</target>
        </trans-unit>
        <trans-unit id="203a495a6685bc90041befff86795808f8e82182" translate="yes" xml:space="preserve">
          <source>is specified it will be used as the shared cache.  Otherwise
it will attempt to use a cache named</source>
          <target state="translated">указано,что он будет использоваться в качестве общего кэша.В противном случае он попытается использовать кэш с именем</target>
        </trans-unit>
        <trans-unit id="f6d6ab6f2a5f07bb043396b6eddd6c513b490bbb" translate="yes" xml:space="preserve">
          <source>is the attribute used to uniquely identify an object when wrapping
a method.  In Django this will typically be</source>
          <target state="translated">это атрибут,используемый для уникальной идентификации объекта при обёртывании метода.В Django это обычно будет</target>
        </trans-unit>
        <trans-unit id="4e35854b464fbca3f62f573e0ebc966a5c2346df" translate="yes" xml:space="preserve">
          <source>l1_maxsize</source>
          <target state="translated">l1_maxsize</target>
        </trans-unit>
        <trans-unit id="24239dc31cf7b79a3dd81e391ffb9cf6b8f43413" translate="yes" xml:space="preserve">
          <source>l2cache</source>
          <target state="translated">l2cache</target>
        </trans-unit>
        <trans-unit id="d25a4bf33e3adbcb4faa3349bda74f43c379251e" translate="yes" xml:space="preserve">
          <source>l2cache_name</source>
          <target state="translated">l2cache_name</target>
        </trans-unit>
        <trans-unit id="67962b5f93ab7e7aee26271b6434367efdebeb0c" translate="yes" xml:space="preserve">
          <source>lru2cache is a decorator that can be used with any user function or method to
cache the most recent results in a local cache and using the django cache
framework to cache results in a shared cache.</source>
          <target state="translated">lru2cache-это декоратор,который может быть использован с любой пользовательской функцией или методом для кэширования последних результатов в локальной кэш-памяти и использования фреймворка кэш-памяти django для кэширования результатов в общей кэш-памяти.</target>
        </trans-unit>
        <trans-unit id="a0b82c9aec209c2aeba44c98d6e0f5ac1eeb0366" translate="yes" xml:space="preserve">
          <source>none_cache</source>
          <target state="translated">none_cache</target>
        </trans-unit>
        <trans-unit id="1758356db21759f7c5a0da9b4dd1db8fd6feab3f" translate="yes" xml:space="preserve">
          <source>or</source>
          <target state="translated">или</target>
        </trans-unit>
        <trans-unit id="7bb544dbb5a0825498324c9261119887b51048a7" translate="yes" xml:space="preserve">
          <source>results that vary on the arguments. The
discarding of the LRU cached values is handled by the decorator.</source>
          <target state="translated">результаты,которые варьируются в зависимости от аргументов.Отбрасывание кэшированных значений LRU обрабатывается декоратором.</target>
        </trans-unit>
        <trans-unit id="32800976dbaf3bf9a9490995b0c0f0b6bbb55857" translate="yes" xml:space="preserve">
          <source>results will be cached, otherwise they
will not.</source>
          <target state="translated">результаты будут кэшированы,в противном случае-нет.</target>
        </trans-unit>
        <trans-unit id="d820aa5f8750fdde33200083b0702a32578a6c95" translate="yes" xml:space="preserve">
          <source>than</source>
          <target state="translated">чем</target>
        </trans-unit>
        <trans-unit id="80df4a04d26c83f618293af30f0535e20afd7329" translate="yes" xml:space="preserve">
          <source>the cache and statistics associated with a function or method can be cleared with:</source>
          <target state="translated">кэш и статистика,связанная с функцией или методом,может быть очищена:</target>
        </trans-unit>
        <trans-unit id="bda4b1c3ce007842c38ded3638ca7730d8a8aae7" translate="yes" xml:space="preserve">
          <source>typed</source>
          <target state="translated">набранный на сайте</target>
        </trans-unit>
        <trans-unit id="dcfac732a9fac915f0831ba3d8ab666199413e95" translate="yes" xml:space="preserve">
          <source>with minor changes to make them work with python 2.7
and incorporated the l2_cache stats. We will continue to add tests to validate
the additional functionality provided by this decorator.</source>
          <target state="translated">с небольшими изменениями,чтобы заставить их работать с питоном 2.7 и включили статистику l2_cache.Мы продолжим добавлять тесты для проверки дополнительной функциональности,предоставляемой этим декоратором.</target>
        </trans-unit>
        <trans-unit id="290239353d61d53048fdeae4868e219f2dd57e54" translate="yes" xml:space="preserve">
          <source>you will need to
specify the name of the cache.</source>
          <target state="translated">вам нужно будет указать имя кэша.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
