<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="https://pypi.org/project/absynthe/">
    <body>
      <group id="absynthe">
        <trans-unit id="02b011c64160798e799481cc084857488382bb41" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Anomalous&lt;/em&gt; behaviors</source>
          <target state="translated">&lt;em&gt;Аномальное&lt;/em&gt; поведение</target>
        </trans-unit>
        <trans-unit id="60027b310b5d95466e164e9b1bfc5f536be91cc0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; This tool is still in alpha stage, so backward compatibility is not
guaranteed between releases. However, inasmuch as users stick to graph builders'
&lt;code&gt;generateNewGraph()&lt;/code&gt; methods, they will stay away from compatibility problems.</source>
          <target state="translated">&lt;strong&gt;Примечание.&lt;/strong&gt; Этот инструмент все еще находится на стадии альфа-тестирования, поэтому обратная совместимость между выпусками не гарантируется. Однако, поскольку пользователи будут придерживаться методов &lt;code&gt;generateNewGraph()&lt;/code&gt; построителей графов , они будут избегать проблем совместимости.</target>
        </trans-unit>
        <trans-unit id="7d13b0e105082d251433284ac94b52e7b08baf9b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; When generating a behavior, i.e. when traversing a graph, successors
of nodes are chosen based on the probability distributions associated with those
nodes. Different nodes rely on different distributions and these nodes are
randomly assigned in the graphs that are constructed by &lt;code&gt;generateNewGraph()&lt;/code&gt;
methods, resulting in graphs with a mix of nodes.</source>
          <target state="translated">&lt;strong&gt;Примечание:&lt;/strong&gt; при генерации поведения, то есть при обходе графа, преемники узлов выбираются на основе распределений вероятностей, связанных с этими узлами. Различные узлы зависят от разных распределений, и эти узлы случайным образом назначаются в графах, построенных с &lt;code&gt;generateNewGraph()&lt;/code&gt; методов generateNewGraph () , в результате чего получаются графы со смесью узлов.</target>
        </trans-unit>
        <trans-unit id="1ed58f177ea95bd7dab803c7ed4b233a181ba7bd" translate="yes" xml:space="preserve">
          <source>A (branching) Behaviour Synthesizer</source>
          <target state="translated">A (разветвление)Поведение Синтезатора</target>
        </trans-unit>
        <trans-unit id="550e6f318db294135e3d56d0fa6d7665e997ba1a" translate="yes" xml:space="preserve">
          <source>A more interesting situation arises while trying to test log analytic (and
anomaly detection) solutions for distributed applications where multiple
sources or modules emit their respective log messages in a single log queue or
stream. This means that consecutive log lines could have originated from
different, unrelated application components. Absynthe provides &lt;em&gt;ground truth&lt;/em&gt;
models to simulate such situations.</source>
          <target state="translated">Более интересная ситуация возникает при попытке протестировать решения для анализа журналов (и обнаружения аномалий) для распределенных приложений, когда несколько источников или модулей генерируют соответствующие сообщения журнала в одной очереди или потоке журналов. Это означает, что последовательные строки журнала могли происходить из разных, не связанных между собой компонентов приложения. Absynthe предоставляет модели &lt;em&gt;достоверной информации&lt;/em&gt; для моделирования таких ситуаций.</target>
        </trans-unit>
        <trans-unit id="dde040f47497790c05666d2ef94baefd390e27bf" translate="yes" xml:space="preserve">
          <source>Absynthe came about in response to the need for test data for analysizing the
performance and accuracy of log analysis algorithms. Even though plenty of real
life logs are available, e.g. &lt;code&gt;/var/log/&lt;/code&gt; in unix-based laptops, they do not
serve the purpose of test data. For that, we need to understand the core
application logic that is generating these logs.</source>
          <target state="translated">Absynthe появился в ответ на потребность в тестовых данных для анализа производительности и точности алгоритмов анализа журналов. Несмотря на то, что доступно множество реальных журналов, например &lt;code&gt;/var/log/&lt;/code&gt; в ноутбуках на базе UNIX, они не служат для целей тестирования данных. Для этого нам нужно понять основную логику приложения, которое генерирует эти журналы.</target>
        </trans-unit>
        <trans-unit id="68e14b2ad8538d489e4858484be43ce15b328a6b" translate="yes" xml:space="preserve">
          <source>Absynthe: A (branching) Behavior Synthesizer</source>
          <target state="translated">Абсент:Поведенческий синтезатор.</target>
        </trans-unit>
        <trans-unit id="280cb3fd0e3d99cf59bd50b4980fc6af1bbad0d5" translate="yes" xml:space="preserve">
          <source>Added a separate utility class called &lt;code&gt;Utils&lt;/code&gt; in &lt;code&gt;absynthe.cfg.utils.py&lt;/code&gt; to
create a new &lt;code&gt;Node&lt;/code&gt; object from any of the concrete implementations of &lt;code&gt;Node&lt;/code&gt; at
random. All concrete implementations of &lt;code&gt;Node&lt;/code&gt; therefore transparently available
to graph builders (and everyone else) through this utility.</source>
          <target state="translated">Добавлен отдельный служебный класс под названием &lt;code&gt;Utils&lt;/code&gt; в &lt;code&gt;absynthe.cfg.utils.py&lt;/code&gt; для случайного создания нового объекта &lt;code&gt;Node&lt;/code&gt; из любой конкретной реализации &lt;code&gt;Node&lt;/code&gt; . Таким образом, все конкретные реализации &lt;code&gt;Node&lt;/code&gt; прозрачно доступны для построителей графов (и всех остальных) через эту утилиту.</target>
        </trans-unit>
        <trans-unit id="eb58484c96da64282a061ef0f8a9d40510285043" translate="yes" xml:space="preserve">
          <source>Added new graph builders, viz. &lt;code&gt;DAGBuilder&lt;/code&gt; and  &lt;code&gt;DCGBuilder&lt;/code&gt;, which build
CFGs with skip-level edges and loops respectively.</source>
          <target state="translated">Добавлены новые построители графиков, а именно. &lt;code&gt;DAGBuilder&lt;/code&gt; и &lt;code&gt;DCGBuilder&lt;/code&gt; , которые создают CFG с границами уровня пропуска и циклами соответственно.</target>
        </trans-unit>
        <trans-unit id="4cbbc2fc77fc6a8ffe051dea3ddc539034d4544b" translate="yes" xml:space="preserve">
          <source>Added new node, viz. &lt;code&gt;BinomialNode&lt;/code&gt;, which exploits the binomial distribution
in order to select its successors at the time of graph traversal.</source>
          <target state="translated">Добавлен новый узел, а именно. &lt;code&gt;BinomialNode&lt;/code&gt; , который использует биномиальное распределение для выбора его преемников во время обхода графа.</target>
        </trans-unit>
        <trans-unit id="8be003c27a6c97e5b0677757afd23716aaca94ef" translate="yes" xml:space="preserve">
          <source>An example of a more complex CFG, a directed cyclic graph, is shown in the
figure below. It expands the tree-like graph illustrated above by:</source>
          <target state="translated">Пример более сложного CFG,направленного циклического графика,показан на рисунке ниже.Он расширяет древовидный график,проиллюстрированный выше:</target>
        </trans-unit>
        <trans-unit id="6452f7e7dc3c35274e1d081266ab3bcc9990cab8" translate="yes" xml:space="preserve">
          <source>An example of a simple, tree-like CFG generated using Absynthe is shown below.
This is like a tree since nodes are laid out in levels, and nodes at level &lt;code&gt;i&lt;/code&gt;
have outgoing edges only to nodes at level &lt;code&gt;i + 1&lt;/code&gt;.</source>
          <target state="translated">Пример простого древовидного CFG, созданного с помощью Absynthe, показан ниже. Это похоже на дерево, поскольку узлы расположены по уровням, а узлы на уровне &lt;code&gt;i&lt;/code&gt; имеют выходящие ребра только к узлам на уровне &lt;code&gt;i + 1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6e925f5a187584bb93a957696eb50e796b4b787e" translate="yes" xml:space="preserve">
          <source>Coming up in future releases</source>
          <target state="translated">Грядущие выпуски</target>
        </trans-unit>
        <trans-unit id="7e9b9183f4a396da21c94f732891218fafbdc7ae" translate="yes" xml:space="preserve">
          <source>Directed Cyclic CFG</source>
          <target state="translated">Режиссерский велосипедный CFG</target>
        </trans-unit>
        <trans-unit id="7a253c500c342cfa2eda2d5a52e23d3e00a38f0f" translate="yes" xml:space="preserve">
          <source>Each &lt;em&gt;behavior&lt;/em&gt; is the sequence of nodes encountered while traversing this CFG
from a root to a leaf. Of course, a CFG might contain loops which could be
traversed multiple times before arriving at the leaf. Moreover, if there are
multiple CFGs, then Absynthe can synthesize &lt;em&gt;interleaved&lt;/em&gt; behaviors. This means
that a single sequence of nodes might contain nodes from multiple CFGs. We are
ultimately interested in this interleaving behavior, which is produced by
multiple CFGs.</source>
          <target state="translated">Каждое &lt;em&gt;поведение&lt;/em&gt; - это последовательность узлов, встречающихся при прохождении этого CFG от корня к листу. Конечно, CFG может содержать циклы, которые можно пройти несколько раз, прежде чем перейти к листу. Более того, если есть несколько CFG, тогда Absynthe может синтезировать &lt;em&gt;чередующиеся&lt;/em&gt; поведения. Это означает, что одна последовательность узлов может содержать узлы из нескольких CFG. В конечном итоге мы заинтересованы в этом поведении чередования, которое создается несколькими CFG.</target>
        </trans-unit>
        <trans-unit id="ffc30fab83bb0c85eb6e12280e0a3b95999fd852" translate="yes" xml:space="preserve">
          <source>Each business process or compuater application is modelled as a &lt;em&gt;control flow
graph&lt;/em&gt; (or &lt;em&gt;CFG&lt;/em&gt;), which typically has one or more roots (i.e. entry) nodes and
multiple leaf (i.e. end) nodes.</source>
          <target state="translated">Каждый бизнес-процесс или компьютерное приложение моделируется как &lt;em&gt;граф потока управления&lt;/em&gt; (или &lt;em&gt;CFG&lt;/em&gt; ), который обычно имеет один или несколько корневых (т. Е. Входных ) узлов и несколько конечных (т. Е. Конечных ) узлов.</target>
        </trans-unit>
        <trans-unit id="ebf05de134c94509696d1b9731d1059221894528" translate="yes" xml:space="preserve">
          <source>For instance, consider the &lt;code&gt;basicLogGeneration&lt;/code&gt; method in
&lt;code&gt;./examples/01_generateSimpleBehavior.py&lt;/code&gt;:</source>
          <target state="translated">Например, рассмотрим &lt;code&gt;basicLogGeneration&lt;/code&gt; метод в &lt;code&gt;./examples/01_generateSimpleBehavior.py&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="ece8a1e099471b12bc1db0091b0ab79cf8c8e183" translate="yes" xml:space="preserve">
          <source>For the latest features not yet released, clone or download the &lt;code&gt;develop&lt;/code&gt; branch
and then:</source>
          <target state="translated">Для последних функций, которые еще не выпущены, клонируйте или загрузите ветку &lt;code&gt;develop&lt;/code&gt; а затем:</target>
        </trans-unit>
        <trans-unit id="361323255a6e418a94fe1dd6ad98403ad687499f" translate="yes" xml:space="preserve">
          <source>In order to generate behaviors from a directed cyclic CFG, create a DCG as shown
in &lt;code&gt;./examples/03_generateControlFlowDCG.py&lt;/code&gt; and then generate behaviors after
adding the DCG to a behavior object as shown in the code snippet above.</source>
          <target state="translated">Чтобы сгенерировать поведения из направленного циклического CFG, создайте DCG, как показано в &lt;code&gt;./examples/03_generateControlFlowDCG.py&lt;/code&gt; , а затем сгенерируйте поведения после добавления DCG к объекту поведения, как показано во фрагменте кода выше.</target>
        </trans-unit>
        <trans-unit id="c81b79df3c6448eae7c4f80428b54cd5692a17d7" translate="yes" xml:space="preserve">
          <source>Installation</source>
          <target state="translated">Установка</target>
        </trans-unit>
        <trans-unit id="41d0bded83d8a4df22a78f1f0693f59a79719b3e" translate="yes" xml:space="preserve">
          <source>It is possible to start using Absynthe with two classes:</source>
          <target state="translated">Можно начать использовать Absynthe с двух классов:</target>
        </trans-unit>
        <trans-unit id="019ec01ba6d724fe41e420938f721b48570940fe" translate="yes" xml:space="preserve">
          <source>Logger nodes that emit more &lt;em&gt;life like&lt;/em&gt; log messages</source>
          <target state="translated">Узлы регистратора, которые излучают больше &lt;em&gt;жизни, как&lt;/em&gt; сообщения журнала</target>
        </trans-unit>
        <trans-unit id="80552c39193e5d627bacdc60f82ee17b182d6315" translate="yes" xml:space="preserve">
          <source>Major changes in v0.0.2</source>
          <target state="translated">Основные изменения в v0.0.2</target>
        </trans-unit>
        <trans-unit id="d6a06199cc127e571d3588aef63c79108675eabc" translate="yes" xml:space="preserve">
          <source>Motivation</source>
          <target state="translated">Мотивация</target>
        </trans-unit>
        <trans-unit id="0efc2e6be4c23b9a513d7ce0dcff8ed80e8912e7" translate="yes" xml:space="preserve">
          <source>Overview</source>
          <target state="translated">Обзор</target>
        </trans-unit>
        <trans-unit id="0ea4af908fe06688dd3fc02035189b08293c5074" translate="yes" xml:space="preserve">
          <source>Release Notes</source>
          <target state="translated">Информация о выпуске</target>
        </trans-unit>
        <trans-unit id="7137676daae9098656140de61386c7374db05941" translate="yes" xml:space="preserve">
          <source>Sophisticated interleaving behaviors</source>
          <target state="translated">Сложное чередующееся поведение</target>
        </trans-unit>
        <trans-unit id="f2903a3add32a92d3c75624c962356b7a49a5fa8" translate="yes" xml:space="preserve">
          <source>The above screenshot shows logs generated by Absynthe. Each log line starts
with a time stamp, followed by a session ID, CFG ID, and a log message. At
present, the log message is simply a random concatenation of the node ID to
which the log message corresponds. A single CFG might participate in multiple
sessions, where each session is a different traversal of the CFG. Therefore, we
maintain both session ID and CFG ID in the log line.</source>
          <target state="translated">На скриншоте выше показаны журналы,сгенерированные компанией Absynthe.Каждая строка журнала начинается с временной метки,за которой следует идентификатор сессии,идентификатор CFG и сообщение журнала.В настоящее время сообщение журнала-это просто случайная конкатенация ID узла,которому соответствует сообщение журнала.Одна CFG может участвовать в нескольких сессиях,где каждая сессия является различным обходом CFG.Поэтому мы сохраняем в строке лога как ID сессии,так и ID CFG.</target>
        </trans-unit>
        <trans-unit id="f96cc45f6b319ee18988211c883578e9a4a281c7" translate="yes" xml:space="preserve">
          <source>The identifiers of nodes appearing loops are helpfully prefixed with the
identifiers of nodes where these loops start and finish. Moreover, loops could
be traversed multiple times in a single behavior, as illustrated in the figure
below.</source>
          <target state="translated">Идентификаторы возникающих циклов удобно префиксовать с идентификаторами узлов,на которых эти циклы начинаются и заканчиваются.Более того,циклы можно переходить несколько раз в одном поведении,как показано на рисунке ниже.</target>
        </trans-unit>
        <trans-unit id="9a674369e325bdf29f6edf8edb945b651c6ac731" translate="yes" xml:space="preserve">
          <source>The latest release is available on PyPi, simply &lt;code&gt;pip install absynthe&lt;/code&gt;. The
&lt;code&gt;master&lt;/code&gt; branch of this repository will always provide the latest release.</source>
          <target state="translated">Последний выпуск доступен на PyPi, просто &lt;code&gt;pip install absynthe&lt;/code&gt; . В &lt;code&gt;master&lt;/code&gt; ветке этого репозитория всегда будет последний выпуск.</target>
        </trans-unit>
        <trans-unit id="3cbe8139be6dadccd55954ec95da87dbf1e698b5" translate="yes" xml:space="preserve">
          <source>This package has been developed with &lt;code&gt;Python 3.6.*&lt;/code&gt; and depends on &lt;code&gt;scipy 1.2.1&lt;/code&gt;.
Things might not work with &lt;code&gt;Python 3.7.*&lt;/code&gt; or &lt;code&gt;scipy 1.3.*&lt;/code&gt;. Therefore, consider
creating a virtual environment if your default configuration differs.</source>
          <target state="translated">Этот пакет был разработан с &lt;code&gt;Python 3.6.*&lt;/code&gt; И зависит от &lt;code&gt;scipy 1.2.1&lt;/code&gt; . Что-то может не работать с &lt;code&gt;Python 3.7.*&lt;/code&gt; Или &lt;code&gt;scipy 1.3.*&lt;/code&gt; . Поэтому рассмотрите возможность создания виртуальной среды, если ваша конфигурация по умолчанию отличается.</target>
        </trans-unit>
        <trans-unit id="0980855b93454e712e2b015cc0f5655541facb06" translate="yes" xml:space="preserve">
          <source>Tree-like CFG</source>
          <target state="translated">древовидный CFG</target>
        </trans-unit>
        <trans-unit id="0bb18642b70b9f8a9c12ccf39487328f306b8e19" translate="yes" xml:space="preserve">
          <source>Usage</source>
          <target state="translated">Использование</target>
        </trans-unit>
        <trans-unit id="2d75d8dd04fd465844923c80ddf7cebda12ec86a" translate="yes" xml:space="preserve">
          <source>You need Absynthe if you wish to simulate the behavior of any well defined
process -- whether it's a computer application or a business process flow.</source>
          <target state="translated">Вам нужен Absynthe,если вы хотите смоделировать поведение любого хорошо определенного процесса-будь то компьютерное приложение или поток бизнес-процессов.</target>
        </trans-unit>
        <trans-unit id="cfdf820be882593b466c12770bb42a1d31992322" translate="yes" xml:space="preserve">
          <source>any concrete implementation of the abstract &lt;code&gt;Behavior&lt;/code&gt; class, which
traverses the CFGs generated above and emits log messages.</source>
          <target state="translated">любая конкретная реализация абстрактного класса &lt;code&gt;Behavior&lt;/code&gt; , который просматривает сгенерированные выше CFG и генерирует сообщения журнала.</target>
        </trans-unit>
        <trans-unit id="f56a005cb54785defd2347c651da587bf8d12c8c" translate="yes" xml:space="preserve">
          <source>any concrete implementation of the abstract &lt;code&gt;GraphBuilder&lt;/code&gt; class, which
generates CFGs, and</source>
          <target state="translated">любая конкретная реализация абстрактного класса &lt;code&gt;GraphBuilder&lt;/code&gt; , который генерирует CFG, и</target>
        </trans-unit>
        <trans-unit id="1746725b3599b57f2c3c7c184a1e129a4b71bc36" translate="yes" xml:space="preserve">
          <source>attaching loops on some of the nodes,</source>
          <target state="translated">прикрепляя петли на некоторых узлах,</target>
        </trans-unit>
        <trans-unit id="8de1898ddf3eff19dd8e421cfc5bd3eabb848a8c" translate="yes" xml:space="preserve">
          <source>constructing skip-level edges, i.e. edges from a node at level &lt;code&gt;i&lt;/code&gt; to a
node at level &amp;ge;&lt;code&gt;(i + 2)&lt;/code&gt;, and</source>
          <target state="translated">построение ребер уровня пропуска, то есть ребер от узла на уровне &lt;code&gt;i&lt;/code&gt; до узла на уровне &amp;ge; &lt;code&gt;(i + 2)&lt;/code&gt; , и</target>
        </trans-unit>
        <trans-unit id="e1d5d9897e5bb0bd39df7fb5b19b181ff8ea808c" translate="yes" xml:space="preserve">
          <source>optionally, upward edges (not shown here), i.e. edges from a node at
level &lt;code&gt;i&lt;/code&gt; to a node at level &amp;le;&lt;code&gt;(i - 1)&lt;/code&gt;.</source>
          <target state="translated">необязательно, восходящие ребра (здесь не показаны), то есть ребра от узла на уровне &lt;code&gt;i&lt;/code&gt; до узла на уровне &amp;le; &lt;code&gt;(i - 1)&lt;/code&gt; .</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
