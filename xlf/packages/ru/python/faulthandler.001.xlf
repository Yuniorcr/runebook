<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="https://pypi.org/project/faulthandler/">
    <body>
      <group id="faulthandler">
        <trans-unit id="8b32f169fb309037a80f683a4b6d37e7cba4bdc1" translate="yes" xml:space="preserve">
          <source>Alternatively you can set the PYTHONFAULTHANDLER environment variable to a
non-empty value.</source>
          <target state="translated">В качестве альтернативы вы можете установить переменную окружения PYTHONFAULTHANDLER на непустое значение.</target>
        </trans-unit>
        <trans-unit id="b05598106e76da0d607a6a81c201935a1dbfee9a" translate="yes" xml:space="preserve">
          <source>By default, the Python traceback is written to the standard error stream. Start
your graphical applications in a terminal and run your server in foreground to
see the traceback, or pass a file to faulthandler.enable().</source>
          <target state="translated">По умолчанию трассировка Python записывается в стандартный поток ошибок.Запустите свои графические приложения в терминале и запустите сервер на переднем плане,чтобы увидеть трассировку,или передайте файл в faulthandler.enable().</target>
        </trans-unit>
        <trans-unit id="fa7641d6cb8d0ba8e60b2b86f9a48291331443a8" translate="yes" xml:space="preserve">
          <source>Display the Python traceback on a crash</source>
          <target state="translated">Отображение трассировки питона при аварии.</target>
        </trans-unit>
        <trans-unit id="148333c18dd79509f9564b86c3add191d327ffcc" translate="yes" xml:space="preserve">
          <source>Fault handler for SIGSEGV, SIGFPE, SIGABRT, SIGBUS and SIGILL signals: display
the Python traceback and restore the previous handler. Allocate an alternate
stack for this handler, if sigaltstack() is available, to be able to allocate
memory on the stack, even on stack overflow (not available on Windows).</source>
          <target state="translated">Обработчик сигналов SIGSEGV,SIGFPE,SIGABRT,SIGBUS и SIGILL:отобразить трассировку Python и восстановить предыдущий обработчик.Выделение альтернативного стека для этого обработчика,если доступна функция sigaltstack(),чтобы иметь возможность выделять память в стеке,даже при переполнении стека (недоступно в Windows).</target>
        </trans-unit>
        <trans-unit id="81e0ceb7fc7b0120d9efeaffe709c095b3d029da" translate="yes" xml:space="preserve">
          <source>Import the module and call faulthandler.enable() to enable the fault handler.</source>
          <target state="translated">Импорт модуля и вызов функции faulthandler.enable()для включения обработчика ошибок.</target>
        </trans-unit>
        <trans-unit id="45e8e62be32ad547820a512d950cbe7aeb111584" translate="yes" xml:space="preserve">
          <source>The fault handler is called on catastrophic cases and so it can only use
signal-safe functions (eg. it doesn&amp;rsquo;t allocate memory on the heap). That&amp;rsquo;s why
the traceback is limited: it only supports ASCII encoding (use the
backslashreplace error handler for non-ASCII characters) and limits each string
to 100 characters, doesn&amp;rsquo;t print the source code in the traceback (only the
filename, the function name and the line number), is limited to 100 frames and
100 threads.</source>
          <target state="translated">Обработчик ошибок вызывается в катастрофических случаях, поэтому он может использовать только сигнально-безопасные функции (например, он не выделяет память в куче). Вот почему трассировка ограничена: она поддерживает только кодировку ASCII (используйте обработчик ошибок с обратной косой чертой для символов, отличных от ASCII) и ограничивает каждую строку до 100 символов, не печатает исходный код в трассировке (только имя файла, имя функции и номер строки), ограничен 100 кадрами и 100 потоками.</target>
        </trans-unit>
        <trans-unit id="3b7e79012975d3e861952d69da3944f99e276605" translate="yes" xml:space="preserve">
          <source>This module is the backport for CPython 2.7. faulthandler is part of CPython
standard library since CPython 3.3: &lt;a href=&quot;http://docs.python.org/dev/library/faulthandler.html&quot;&gt;faulthandler&lt;/a&gt;. For PyPy,
faulthandler is builtin since PyPy 5.5: use</source>
          <target state="translated">Этот модуль является резервным портом для CPython 2.7. faulthandler является частью стандартной библиотеки CPython, начиная с CPython 3.3: &lt;a href=&quot;http://docs.python.org/dev/library/faulthandler.html&quot;&gt;faulthandler&lt;/a&gt; . Для PyPy обработчик ошибок встроен, начиная с PyPy 5.5: используйте</target>
        </trans-unit>
        <trans-unit id="5774e0c7dcae0498837702f72af167be1db50158" translate="yes" xml:space="preserve">
          <source>Website:
&lt;a href=&quot;https://faulthandler.readthedocs.io/&quot;&gt;https://faulthandler.readthedocs.io/&lt;/a&gt;</source>
          <target state="translated">Сайт: &lt;a href=&quot;https://faulthandler.readthedocs.io/&quot;&gt;https://faulthandler.readthedocs.io/&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1cb1003c13997882c35b2965310815154c6cbb5e" translate="yes" xml:space="preserve">
          <source>faulthandler 3.2 is the last version released by Victor Stinner. I maintained
it for 10 years in my free time for the great pleasure of Python 2 users, but
Python 2 is no longer supported upstream since 2020-01-01. Each faulthandler
release requires me to start my Windows VM, install Python 2.7 in 32-bit and
64-bit, install an old C compiler just for Python 2.7, and type manually some
commands to upload Windows binaries. Moreover, I have to fix some issues on
Travis CI and many small boring tasks. The maintenance is far from being free.
In 10 years, I got zero &amp;ldquo;thank you&amp;rdquo; (and 0&amp;euro;), only bug reports :-)</source>
          <target state="translated">faulthandler 3.2 - последняя версия, выпущенная Виктором Стиннером. Я поддерживал его в течение 10 лет в свободное время для большого удовольствия пользователей Python 2, но Python 2 больше не поддерживается в апстриме с 01.01.2020. Каждый выпуск обработчика ошибок требует, чтобы я запустил мою виртуальную машину Windows, установил Python 2.7 в 32-разрядной и 64-разрядной версии, установил старый компилятор C только для Python 2.7 и вручную набрал несколько команд для загрузки двоичных файлов Windows. Более того, мне нужно исправить некоторые проблемы с Travis CI и множество мелких скучных задач. Обслуживание далеко не бесплатное. За 10 лет я не получил ни одного &amp;laquo;спасибо&amp;raquo; (и 0 евро), только сообщения об ошибках :-)</target>
        </trans-unit>
        <trans-unit id="e8c4d13fd2fd99b029d92a36fad256f8f653a5a1" translate="yes" xml:space="preserve">
          <source>faulthandler is implemented in C using signal handlers to be able to dump a
traceback on a crash or when Python is blocked (eg. deadlock).</source>
          <target state="translated">faulthandler реализован в C с помощью обработчиков сигналов,чтобы иметь возможность сбросить трассировку при крушении или когда Python заблокирован (например,тупик).</target>
        </trans-unit>
        <trans-unit id="2caee2bbfef6db853f54ebef721cc989c0da49f3" translate="yes" xml:space="preserve">
          <source>pypy -X faulthandler</source>
          <target state="translated">пипи-X-фаутандлер</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
