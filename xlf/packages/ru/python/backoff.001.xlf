<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="https://pypi.org/project/backoff/">
    <body>
      <group id="backoff">
        <trans-unit id="5c10b5b2cd673a0616d529aa5234b12ee7153808" translate="yes" xml:space="preserve">
          <source>,</source>
          <target state="translated">,</target>
        </trans-unit>
        <trans-unit id="8278d2adba7612cf98a492d21a4ac4c78acb1202" translate="yes" xml:space="preserve">
          <source>, and</source>
          <target state="translated">, и</target>
        </trans-unit>
        <trans-unit id="90a63bb31aecf55896978f3194d63221fe93d0a2" translate="yes" xml:space="preserve">
          <source>-decorated function may still
need to do exception handling.</source>
          <target state="translated">-декорированная функция может по-прежнему выполнять обработку исключений.</target>
        </trans-unit>
        <trans-unit id="a6d58f8e0d971a68c4771edeac2cfab69fba4c32" translate="yes" xml:space="preserve">
          <source>.
This may be useful in reporting statistics or performing other custom
logging.</source>
          <target state="translated">. Это может быть полезно при составлении отчетов по статистике или выполнении других настраиваемых журналов.</target>
        </trans-unit>
        <trans-unit id="3a09fbc2ff44e8016d69b15fa437310bb10dcff6" translate="yes" xml:space="preserve">
          <source>. In this case, if desired alternative logging behavior
could be defined by using custom event handlers.</source>
          <target state="translated">. В этом случае, при желании, можно определить альтернативное поведение ведения журнала с помощью пользовательских обработчиков событий.</target>
        </trans-unit>
        <trans-unit id="2a7e2a74a560968937568ed386fd9142cf5f3863" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;args&lt;/em&gt;: positional arguments to func</source>
          <target state="translated">&lt;em&gt;args&lt;/em&gt; : позиционные аргументы функции func</target>
        </trans-unit>
        <trans-unit id="dfd78ba066a3c318e641052d78abcb8e5ad065a4" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;elapsed&lt;/em&gt;: elapsed time in seconds so far</source>
          <target state="translated">&lt;em&gt;elapsed&lt;/em&gt; : прошедшее время в секундах на данный момент</target>
        </trans-unit>
        <trans-unit id="8c0545d4e42723b26dcb92c68343caae530e9a0a" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;kwargs&lt;/em&gt;: keyword arguments to func</source>
          <target state="translated">&lt;em&gt;kwargs&lt;/em&gt; : аргументы ключевого слова для func</target>
        </trans-unit>
        <trans-unit id="ec9983c683159943965e22e9c62c9d055800eead" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;target&lt;/em&gt;: reference to the function or method being invoked</source>
          <target state="translated">&lt;em&gt;цель&lt;/em&gt; : ссылка на вызываемую функцию или метод</target>
        </trans-unit>
        <trans-unit id="6931b64be2d37f300eb3637508eda4da20e2af71" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;tries&lt;/em&gt;: number of invocation tries so far</source>
          <target state="translated">&lt;em&gt;пытается&lt;/em&gt; : количество попыток вызова на данный момент</target>
        </trans-unit>
        <trans-unit id="aebaa6b421e0ff2326c27b851c4dc7c6ba7364da" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;value&lt;/em&gt;: value triggering backoff (</source>
          <target state="translated">&lt;em&gt;значение&lt;/em&gt; : значение, запускающее отсрочку (</target>
        </trans-unit>
        <trans-unit id="83b1dafd7c9209d5683ef291b071c278304ff758" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;wait&lt;/em&gt;: seconds to wait (</source>
          <target state="translated">&lt;em&gt;ждать&lt;/em&gt; : секунды ждать (</target>
        </trans-unit>
        <trans-unit id="87a129cdd8433d8a00a59922804e9dda99247d90" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Function decoration for backoff and retry&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Декорирование функции для отката и повторной попытки&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0e848b69f3e2892e6d444eacdfcf5251eff104fc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Getting exception info&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Получение информации об исключении&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f6c2dbf107d639fc63d7d67033a0478bc24fbf94" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Give Up Conditions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Отказаться от условий&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="551add8f4ac65448bbdfec7c19be5ad7f030053a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Multiple handlers per event type&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Несколько обработчиков для каждого типа события&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0bde41f87792462eb2be877227d62bf8946cac2f" translate="yes" xml:space="preserve">
          <source>@backoff.on_exception</source>
          <target state="translated">@ backoff.on_exception</target>
        </trans-unit>
        <trans-unit id="6d7aa7ea26009f5a2800c97462928d4bd9e3ec91" translate="yes" xml:space="preserve">
          <source>@backoff.on_predicate</source>
          <target state="translated">@ backoff.on_predicate</target>
        </trans-unit>
        <trans-unit id="e6fd916cad4f34468ccb8375f1369d2c69c12915" translate="yes" xml:space="preserve">
          <source>A handler which prints the details of the backoff event could be
implemented like so:</source>
          <target state="translated">Обработчик,который печатает детали события отката,может быть реализован таким образом:</target>
        </trans-unit>
        <trans-unit id="dc6449749fd52d6298e19e3f00c9556d8a7f3f9f" translate="yes" xml:space="preserve">
          <source>A jitter algorithm can be supplied with the</source>
          <target state="translated">Алгоритм джиттера может быть поставлен вместе с</target>
        </trans-unit>
        <trans-unit id="6dde8d34c3e26e04943ea485778d45adae228647" translate="yes" xml:space="preserve">
          <source>As of version 1.2, the default jitter function</source>
          <target state="translated">Начиная с версии 1.2,функция джиттера по умолчанию</target>
        </trans-unit>
        <trans-unit id="8277629acfcb602df77bf7b16003d8441fce8ee5" translate="yes" xml:space="preserve">
          <source>Asynchronous code</source>
          <target state="translated">асинхронный код</target>
        </trans-unit>
        <trans-unit id="96265d2c05b9f5357f6954c89577ab90fb7ac4d8" translate="yes" xml:space="preserve">
          <source>Backoff supports asynchronous execution in Python 3.5 and above.</source>
          <target state="translated">Backoff поддерживает асинхронное выполнение на Python 3.5 и выше.</target>
        </trans-unit>
        <trans-unit id="4bfd87a6a68b461a2365a6c1d22a3d4bc1f19c8b" translate="yes" xml:space="preserve">
          <source>Both backoff decorators optionally accept event handler functions
using the keyword arguments</source>
          <target state="translated">Оба декоратора обратного отсчета опционально принимают функции обработчика событий,используя аргументы ключевых слов</target>
        </trans-unit>
        <trans-unit id="318c75c311e8e14cf5c0dbc86ee333f34b9c24d2" translate="yes" xml:space="preserve">
          <source>By default, backoff and retry attempts are logged to the &amp;lsquo;backoff&amp;rsquo;
logger. By default, this logger is configured with a NullHandler, so
there will be nothing output unless you configure a handler.
Programmatically, this might be accomplished with something as simple
as:</source>
          <target state="translated">По умолчанию попытки отката и повторной попытки регистрируются в регистраторе отсрочки. По умолчанию этот регистратор настроен с помощью NullHandler, поэтому ничего не будет выводиться, если вы не настроите обработчик. Программно это можно сделать с помощью чего-то очень простого:</target>
        </trans-unit>
        <trans-unit id="ef7e401c25dd6ae87144a52fa5d0354d8586c594" translate="yes" xml:space="preserve">
          <source>Decorators support both regular functions for synchronous code and
&lt;a href=&quot;https://docs.python.org/3/library/asyncio.html&quot;&gt;asyncio&lt;/a&gt;&amp;rsquo;s coroutines
for asynchronous code.</source>
          <target state="translated">Декораторы поддерживают как обычные функции для синхронного кода, так и сопрограммы &lt;a href=&quot;https://docs.python.org/3/library/asyncio.html&quot;&gt;asyncio&lt;/a&gt; для асинхронного кода.</target>
        </trans-unit>
        <trans-unit id="4bb99e856dea0b88518519339118a3c5d0fa7c7c" translate="yes" xml:space="preserve">
          <source>Default logging can be disabled all together by specifying</source>
          <target state="translated">Логи по умолчанию можно отключить все вместе путем указания</target>
        </trans-unit>
        <trans-unit id="1d0a0bc46dabda5a6dbcf0a2f18e3e9acbc27ae7" translate="yes" xml:space="preserve">
          <source>Event handlers</source>
          <target state="translated">Организаторы мероприятий</target>
        </trans-unit>
        <trans-unit id="eb01bf04c9a0e8a71c45816513df424f1c7ffedb" translate="yes" xml:space="preserve">
          <source>Examples</source>
          <target state="translated">Примеры</target>
        </trans-unit>
        <trans-unit id="8548c32df11b47436b77713ee1818090b42adb4a" translate="yes" xml:space="preserve">
          <source>Extra keyword arguments are passed when initializing the
wait generator, so the</source>
          <target state="translated">Дополнительные аргументы по ключевым словам передаются при инициализации генератора ожидания,так что</target>
        </trans-unit>
        <trans-unit id="842f406064f2a8940c26bb023caa19a7d5cfbc65" translate="yes" xml:space="preserve">
          <source>Function decoration for backoff and retry</source>
          <target state="translated">Функциональное оформление для отступления и повторных попыток</target>
        </trans-unit>
        <trans-unit id="965ca5a5200702e7e2c17a9d1e689e2a85aaa0a2" translate="yes" xml:space="preserve">
          <source>Handlers must be callables with a unary signature accepting a dict
argument. This dict contains the details of the invocation. Valid keys
include:</source>
          <target state="translated">Обработчики должны быть позывными с одинарной подписью,принимающими аргумент диктата.Этот аргумент содержит подробности вызова.Действительные ключи включают в себя:</target>
        </trans-unit>
        <trans-unit id="976ba0b3f3d1500e284893871e638c8e6ef54068" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s an example which uses a fibonacci sequence backoff when the
return value of the target function is the empty list:</source>
          <target state="translated">Вот пример, в котором используется отсрочка последовательности Фибоначчи, когда возвращаемое значение целевой функции - пустой список:</target>
        </trans-unit>
        <trans-unit id="4e3e3b622a1d30df4cdbe5caf8b7e03c55b57bac" translate="yes" xml:space="preserve">
          <source>In all cases, iterables of handler functions are also accepted, which
are called in turn. For example, you might provide a simple list of
handler functions as the value of the</source>
          <target state="translated">Во всех случаях также принимаются итерабельные функции обработчика,которые вызываются по очереди.Например,вы можете предоставить простой список обработчиков в виде значения параметра</target>
        </trans-unit>
        <trans-unit id="1003d9c9fc0ab02f7e70c56589df98f30061835a" translate="yes" xml:space="preserve">
          <source>In some cases the raised exception instance itself may need to be
inspected in order to determine if it is a retryable condition. The</source>
          <target state="translated">В некоторых случаях может потребоваться проверка самого случая упомянутого исключения,чтобы определить,является ли это условие повторной попыткой.</target>
        </trans-unit>
        <trans-unit id="7ed84ab6b5608ec53c300dfeca86893cb101cd3d" translate="yes" xml:space="preserve">
          <source>In the case of the</source>
          <target state="translated">В случае с</target>
        </trans-unit>
        <trans-unit id="b010576ebc543abd3692e57f27392f714005c646" translate="yes" xml:space="preserve">
          <source>It is also possible to specify an alternate logger with the</source>
          <target state="translated">Также можно указать альтернативный регистратор с помощью параметра</target>
        </trans-unit>
        <trans-unit id="b15f24c3efa82c27eb813106ed5b08a8ae7a0d32" translate="yes" xml:space="preserve">
          <source>It is also supported to specify a Logger (or LoggerAdapter) object
directly.</source>
          <target state="translated">Также поддерживается прямое указание объекта Logger (или LoggerAdapter).</target>
        </trans-unit>
        <trans-unit id="70a5b3c8eeaa674ea3790971e290d22205948eed" translate="yes" xml:space="preserve">
          <source>Jitter</source>
          <target state="translated">Джиттер</target>
        </trans-unit>
        <trans-unit id="9aaa1a381dcc0e6e8917fc93ec91556612a58ab9" translate="yes" xml:space="preserve">
          <source>Keyword argument</source>
          <target state="translated">Ключевой аргумент</target>
        </trans-unit>
        <trans-unit id="2ebee8b95304d6f2641fb64aa8296a4b89bfa1d6" translate="yes" xml:space="preserve">
          <source>Logging configuration</source>
          <target state="translated">Конфигурация протоколирования</target>
        </trans-unit>
        <trans-unit id="fb264b08d8e7d7ca99131988c482768cfbbdad2e" translate="yes" xml:space="preserve">
          <source>More simply, a function which continues polling every second until it
gets a non-falsey result could be defined like like this:</source>
          <target state="translated">Проще говоря,функция,которая продолжает опрашивать каждую секунду до тех пор,пока не получит неверный результат,может быть определена таким образом:</target>
        </trans-unit>
        <trans-unit id="7074c51adff5fe8077a44fc37dfe15c3d888a94d" translate="yes" xml:space="preserve">
          <source>Optional keyword arguments can specify conditions under which to give
up.</source>
          <target state="translated">Необязательные аргументы по ключевым словам могут указывать условия,при которых можно сдаться.</target>
        </trans-unit>
        <trans-unit id="130cfc058c7d998616e2eec552a73c41bac6d39a" translate="yes" xml:space="preserve">
          <source>Previous versions of backoff defaulted to adding some random number of
milliseconds (up to 1s) to the raw sleep value. If desired, this
behavior is now available as</source>
          <target state="translated">Предыдущие версии отката по умолчанию добавляли случайное количество миллисекунд (до 1 с)к исходному значению сна.При желании такое поведение теперь доступно как</target>
        </trans-unit>
        <trans-unit id="222cad2bd37e45b5f33d5d967590f4b613622bfd" translate="yes" xml:space="preserve">
          <source>Runtime Configuration</source>
          <target state="translated">Настройка исполнения</target>
        </trans-unit>
        <trans-unit id="80311937e5f169e8775775b4cb00be4bad3ff41b" translate="yes" xml:space="preserve">
          <source>Since Kenneth Reitz&amp;rsquo;s &lt;a href=&quot;http://python-requests.org&quot;&gt;requests&lt;/a&gt; module
has become a defacto standard for synchronous HTTP clients in Python,
networking examples below are written using it, but it is in no way required
by the backoff module.</source>
          <target state="translated">Поскольку модуль &lt;a href=&quot;http://python-requests.org&quot;&gt;запросов&lt;/a&gt; Кеннета Рейца стал де-факто стандартом для синхронных HTTP-клиентов в Python, сетевые примеры ниже написаны с его использованием, но модуль отката никоим образом не требует этого.</target>
        </trans-unit>
        <trans-unit id="93ef0dd827103681fcee453b78be2ff14e1a261d" translate="yes" xml:space="preserve">
          <source>The</source>
          <target state="translated">The</target>
        </trans-unit>
        <trans-unit id="a1300be1037211dd17daeea4a61bd04c4b3d348d" translate="yes" xml:space="preserve">
          <source>The backoff decorators may also be combined to specify different
backoff behavior for different cases:</source>
          <target state="translated">Декораторы обратного отступления также могут быть скомбинированы для задания различного поведения обратного отступления в разных случаях:</target>
        </trans-unit>
        <trans-unit id="6808d8b00d91ba9be9ceb865b10b088f93f09fba" translate="yes" xml:space="preserve">
          <source>The decorator functions</source>
          <target state="translated">Функции декоратора</target>
        </trans-unit>
        <trans-unit id="4fd61cdc0f9215a43f3229ce364ff4b43d81daf9" translate="yes" xml:space="preserve">
          <source>The decorator will also accept a tuple of exceptions for cases where
the same backoff behavior is desired for more than one exception type:</source>
          <target state="translated">Декоратор также примет кортеж исключений для случаев,когда одно и то же поведение отката желательно для более чем одного типа исключений:</target>
        </trans-unit>
        <trans-unit id="4ffe89f92aa1721f1cf4ca5d509ab4e24b6b9c8d" translate="yes" xml:space="preserve">
          <source>The default logging level is INFO, which corresponds to logging
anytime a retry event occurs. If you would instead like to log
only when a giveup event occurs, set the logger level to ERROR.</source>
          <target state="translated">Уровень протоколирования по умолчанию-INFO,который соответствует протоколированию в любой момент,когда происходит повторная попытка.Если вместо этого вы хотите вести журнал только при возникновении события отказа,установите уровень протоколирования на ERROR (ОШИБКА).</target>
        </trans-unit>
        <trans-unit id="9b748d80f0f4f4eca1bdac9cac21ea2760233073" translate="yes" xml:space="preserve">
          <source>The following examples use &lt;a href=&quot;https://aiohttp.readthedocs.io/&quot;&gt;aiohttp&lt;/a&gt;
asynchronous HTTP client/server library.</source>
          <target state="translated">В следующих примерах используется асинхронная HTTP-библиотека клиент / сервер &lt;a href=&quot;https://aiohttp.readthedocs.io/&quot;&gt;aiohttp&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8babceca3345543f64ae1f6dc816baed9fc6b6cb" translate="yes" xml:space="preserve">
          <source>The keyword argument</source>
          <target state="translated">Ключевой аргумент</target>
        </trans-unit>
        <trans-unit id="4ea583cb63d3b492dc8bdb9071ca2a85ad974b45" translate="yes" xml:space="preserve">
          <source>This module provides function decorators which can be used to wrap a
function such that it will be retried until some condition is met. It
is meant to be of use when accessing unreliable resources with the
potential for intermittent failures i.e. network resources and external
APIs. Somewhat more generally, it may also be of use for dynamically
polling resources for externally generated content.</source>
          <target state="translated">Этот модуль предоставляет декораторы функций,которые могут быть использованы для обёртывания функции таким образом,что она будет перепроверена до тех пор,пока не будет выполнено какое-либо условие.Он предназначен для использования при доступе к ненадежным ресурсам с возможностью прерывистых сбоев,т.е.сетевым ресурсам и внешним API.В более общем плане,она также может быть использована для динамического опроса ресурсов на предмет внешнего контента.</target>
        </trans-unit>
        <trans-unit id="5b62c692188e74042ed4ac3596b109553329f5f6" translate="yes" xml:space="preserve">
          <source>To use backoff in asynchronous code based on
&lt;a href=&quot;https://docs.python.org/3/library/asyncio.html&quot;&gt;asyncio&lt;/a&gt;
you simply need to apply</source>
          <target state="translated">Чтобы использовать откат в асинхронном коде на основе &lt;a href=&quot;https://docs.python.org/3/library/asyncio.html&quot;&gt;asyncio,&lt;/a&gt; вам просто нужно применить</target>
        </trans-unit>
        <trans-unit id="1e89e75f9a3b03d5875f7198d0b26223e016d739" translate="yes" xml:space="preserve">
          <source>Using multiple decorators</source>
          <target state="translated">Использование нескольких декораторов</target>
        </trans-unit>
        <trans-unit id="db476ea02bfda997c6f84abede63f9e1fa009fe6" translate="yes" xml:space="preserve">
          <source>When a give up event occurs, the exception in question is reraised
and so code calling an</source>
          <target state="translated">При возникновении события сдачи происходит повторный вывод рассматриваемого исключения,в результате чего код вызова</target>
        </trans-unit>
        <trans-unit id="e0ff4106a7634bdf197aab35ef83d93777bbb8be" translate="yes" xml:space="preserve">
          <source>When not specified, the predicate param defaults to the falsey test,
so the above can more concisely be written:</source>
          <target state="translated">Если не указано,предикатный параметр по умолчанию переходит в тест falsey,поэтому вышеприведенное можно записать более лаконично:</target>
        </trans-unit>
        <trans-unit id="cffa50a32cb13a240d705317bcec65dd1f31b6ad" translate="yes" xml:space="preserve">
          <source>and</source>
          <target state="translated">and</target>
        </trans-unit>
        <trans-unit id="54ab597856e732f26d81ef11672f12bd22d8bd79" translate="yes" xml:space="preserve">
          <source>are
generally evaluated at import time. This is fine when the keyword args
are passed as constant values, but suppose we want to consult a
dictionary with configuration options that only become available at
runtime. The relevant values are not available at import time. Instead,
decorator functions can be passed callables which are evaluated at
runtime to obtain the value:</source>
          <target state="translated">обычно оцениваются во время импорта.Это нормально,когда аргументы ключевых слов передаются в виде постоянных значений,но предположим,что мы захотим обратиться к словарю с опциями конфигурации,которые становятся доступными только во время выполнения.Соответствующие значения недоступны во время импорта.Вместо этого,функции декоратора могут передавать вызовы,которые вычисляются во время выполнения для получения значения:</target>
        </trans-unit>
        <trans-unit id="33992bda86ce5e398daa20c60a44384d076932f7" translate="yes" xml:space="preserve">
          <source>backoff</source>
          <target state="translated">отступление</target>
        </trans-unit>
        <trans-unit id="883fbad72cde00d78793e0adb7ebce26785fd48c" translate="yes" xml:space="preserve">
          <source>backoff.full_jitter</source>
          <target state="translated">отступление.full_jitter</target>
        </trans-unit>
        <trans-unit id="6d209351faf6cd160018566e5d6291773f86d57a" translate="yes" xml:space="preserve">
          <source>backoff.on_exception</source>
          <target state="translated">отступление.on_exception</target>
        </trans-unit>
        <trans-unit id="76213c773d1d4c253faab360ccfbd56db2974d83" translate="yes" xml:space="preserve">
          <source>backoff.on_predicate</source>
          <target state="translated">отступить.on_predicate</target>
        </trans-unit>
        <trans-unit id="dd2c9c3da740e6fcbb8aa485a4a2c4ba85f69a82" translate="yes" xml:space="preserve">
          <source>backoff.random_jitter</source>
          <target state="translated">отступление.random_jitter</target>
        </trans-unit>
        <trans-unit id="6302daa274d5f40479278fadea5058fece41bdf2" translate="yes" xml:space="preserve">
          <source>decorator is used to retry when a particular
condition is true of the return value of the target function.  This may
be useful when polling a resource for externally generated content.</source>
          <target state="translated">Декоратор используется для повторных попыток,когда определенное условие верно для возвращаемого значения целевой функции.Это может быть полезно при опросе ресурса на предмет внешнего контента.</target>
        </trans-unit>
        <trans-unit id="2dcdbddeb8e5af4e252faa32ba58ef1a93e84077" translate="yes" xml:space="preserve">
          <source>decorator is used to retry when a specified exception
is raised. Here&amp;rsquo;s an example using exponential backoff when any</source>
          <target state="translated">декоратор используется для повторной попытки при возникновении указанного исключения. Вот пример использования экспоненциального отката, когда любой</target>
        </trans-unit>
        <trans-unit id="d8fd4ed07c5bcf64ff34124afba87df495b2dade" translate="yes" xml:space="preserve">
          <source>decorator only)</source>
          <target state="translated">только декоратор)</target>
        </trans-unit>
        <trans-unit id="dc0ba2e25de0a6ceb23ceec1ba6543a1b3193aaf" translate="yes" xml:space="preserve">
          <source>decorator, all</source>
          <target state="translated">декоратор,все</target>
        </trans-unit>
        <trans-unit id="c583e253674b8faed4ea3b06d969d80f8bf28fe4" translate="yes" xml:space="preserve">
          <source>event handlers, with the interface otherwise being identical.</source>
          <target state="translated">обработчики событий,с идентичным интерфейсом.</target>
        </trans-unit>
        <trans-unit id="3362aa4886a690e2310ba2f4ccf246fd533d38e5" translate="yes" xml:space="preserve">
          <source>exception is raised:</source>
          <target state="translated">Исключение выдвинуто:</target>
        </trans-unit>
        <trans-unit id="c1908a2cba1e490ae68d447210006357a26b91da" translate="yes" xml:space="preserve">
          <source>giveup</source>
          <target state="translated">сдаваться</target>
        </trans-unit>
        <trans-unit id="02a6f585713df2740f3ac6113f0755bb7067356a" translate="yes" xml:space="preserve">
          <source>handler only)</source>
          <target state="translated">только обработчик)</target>
        </trans-unit>
        <trans-unit id="1ef6fcc7985aa5b73889100f791ba5b0e2c79b11" translate="yes" xml:space="preserve">
          <source>handlers are called from within the except block for the
exception being handled. Therefore exception info is available to the
handler functions via the python standard library, specifically</source>
          <target state="translated">обработчики вызываются изнутри блока за исключением блока,в котором обрабатывается исключение.Поэтому информация об исключениях доступна функциям обработчика через стандартную библиотеку python,а именно</target>
        </trans-unit>
        <trans-unit id="cd97bcc8f09050b324c9e8f060d8bbd9742ba0a0" translate="yes" xml:space="preserve">
          <source>implements the &amp;lsquo;Full Jitter&amp;rsquo; algorithm as defined in the AWS
Architecture Blog&amp;rsquo;s &lt;a href=&quot;https://www.awsarchitectureblog.com/2015/03/backoff.html&quot;&gt;Exponential Backoff And Jitter&lt;/a&gt; post.
Note that with this algorithm, the time yielded by the wait generator
is actually the &lt;em&gt;maximum&lt;/em&gt; amount of time to wait.</source>
          <target state="translated">реализует алгоритм &amp;laquo;Полный джиттер&amp;raquo;, как определено в публикации &amp;laquo; &lt;a href=&quot;https://www.awsarchitectureblog.com/2015/03/backoff.html&quot;&gt;Экспоненциальная отсрочка и джиттер&amp;raquo; в&lt;/a&gt; блоге об архитектуре AWS . Обратите внимание, что с этим алгоритмом время, выдаваемое генератором ожидания, фактически является &lt;em&gt;максимальным&lt;/em&gt; временем ожидания.</target>
        </trans-unit>
        <trans-unit id="dd70fee7318e50e2fc644c67e5e0149e17e005de" translate="yes" xml:space="preserve">
          <source>jitter</source>
          <target state="translated">дрожать</target>
        </trans-unit>
        <trans-unit id="23cd92941bb91f11acce7147fe5d5f0df91a6f28" translate="yes" xml:space="preserve">
          <source>keyword arg can be used to specify a function which accepts
the exception and returns a truthy value if the exception should not
be retried:</source>
          <target state="translated">ключевое слово arg может быть использовано для указания функции,которая принимает исключение и возвращает правдивое значение,если исключение не должно быть перепроверено:</target>
        </trans-unit>
        <trans-unit id="fd25e57f1179439e43e9176b29603a8e4daf6c01" translate="yes" xml:space="preserve">
          <source>keyword arg to
either of the backoff decorators. This argument should be a function
accepting the original unadulterated backoff value and returning it&amp;rsquo;s
jittered counterpart.</source>
          <target state="translated">ключевое слово arg к любому из декораторов отсрочки. Этот аргумент должен быть функцией, принимающей исходное чистое значение отсрочки и возвращающей его дублирующуюся копию.</target>
        </trans-unit>
        <trans-unit id="8902082efd7d95ef030b2725ddaa341e9abb259a" translate="yes" xml:space="preserve">
          <source>keyword arg:</source>
          <target state="translated">ключевое слово &quot;аргумент&quot;:</target>
        </trans-unit>
        <trans-unit id="734b09307197ce7ee36d76fa36ac8ba6c869d00d" translate="yes" xml:space="preserve">
          <source>keyword argument.  If a string value is specified the logger will be
looked up by name.</source>
          <target state="translated">аргумент по ключевому слову.Если указано строковое значение,то регистратор будет искаться по имени.</target>
        </trans-unit>
        <trans-unit id="16cc54fff246b441f70de548a07315312e912e1b" translate="yes" xml:space="preserve">
          <source>logger</source>
          <target state="translated">регистратор</target>
        </trans-unit>
        <trans-unit id="ca17dd53223e9c38ef8f4de47aefda840d75b77a" translate="yes" xml:space="preserve">
          <source>logger=None</source>
          <target state="translated">регистратор=Нет</target>
        </trans-unit>
        <trans-unit id="99cfebf41aabaab987d279328c13aa572af56d72" translate="yes" xml:space="preserve">
          <source>max_time</source>
          <target state="translated">макс_время</target>
        </trans-unit>
        <trans-unit id="b34a389b4430eaf8437f3b1eff0165353d3d90b9" translate="yes" xml:space="preserve">
          <source>max_tries</source>
          <target state="translated">максимальные попытки</target>
        </trans-unit>
        <trans-unit id="444da5b0eb3c62d0024a8c8fbc551f62d0962a84" translate="yes" xml:space="preserve">
          <source>max_value</source>
          <target state="translated">максимальное значение</target>
        </trans-unit>
        <trans-unit id="a21867509c883fff7a024de5f5d5839d06e9f445" translate="yes" xml:space="preserve">
          <source>module.</source>
          <target state="translated">модуль.</target>
        </trans-unit>
        <trans-unit id="53f1da882133377426e903990a9b646cdb58c26c" translate="yes" xml:space="preserve">
          <source>on_backoff</source>
          <target state="translated">отключённый</target>
        </trans-unit>
        <trans-unit id="86a7062cb7f642e0f803cb0a235ead0ed02fd061" translate="yes" xml:space="preserve">
          <source>on_exception</source>
          <target state="translated">на_исключении</target>
        </trans-unit>
        <trans-unit id="9fa3f957808be6e115183e4eb3da38a710f3d645" translate="yes" xml:space="preserve">
          <source>on_giveup</source>
          <target state="translated">on_giveup</target>
        </trans-unit>
        <trans-unit id="4ccc9a3f9a447f10b552d03cab8572bb09b0e946" translate="yes" xml:space="preserve">
          <source>on_predicate</source>
          <target state="translated">предикат</target>
        </trans-unit>
        <trans-unit id="cbbb521981be089fc497be6f4d6939d3b2d48351" translate="yes" xml:space="preserve">
          <source>on_success</source>
          <target state="translated">удача</target>
        </trans-unit>
        <trans-unit id="1758356db21759f7c5a0da9b4dd1db8fd6feab3f" translate="yes" xml:space="preserve">
          <source>or</source>
          <target state="translated">или</target>
        </trans-unit>
        <trans-unit id="6f0b2ce24add914e491c80aacf6014cb9e1b7f98" translate="yes" xml:space="preserve">
          <source>or the</source>
          <target state="translated">или</target>
        </trans-unit>
        <trans-unit id="392a1ae1ace3f90b99c6a1b593e3a896950d0a10" translate="yes" xml:space="preserve">
          <source>param above is passed as a keyword
arg when initializing the fibo generator.</source>
          <target state="translated">Параметр выше передается в качестве ключевого слова arg при инициализации генератора фибо.</target>
        </trans-unit>
        <trans-unit id="54faec366d11efdac0f9d2da560e273f92288c2a" translate="yes" xml:space="preserve">
          <source>requests</source>
          <target state="translated">запросы</target>
        </trans-unit>
        <trans-unit id="8c3ffb6a96195a147c7dde1f03492d5e0cdff303" translate="yes" xml:space="preserve">
          <source>specifies the maximum amount
of total time in seconds that can elapse before giving up.</source>
          <target state="translated">определяет максимальное количество общего времени в секундах,которое может пройти до сдачи.</target>
        </trans-unit>
        <trans-unit id="2e07abea61bef93a94f8fb642448b9b6c5d7d8be" translate="yes" xml:space="preserve">
          <source>specifies the maximum number of calls
to make to the target function before giving up.</source>
          <target state="translated">указывает максимальное количество вызовов целевой функции перед тем,как сдаться.</target>
        </trans-unit>
        <trans-unit id="268327991ab40460122814287fd515d2ebb9b960" translate="yes" xml:space="preserve">
          <source>sys.exc_info()</source>
          <target state="translated">sys.exc_info()</target>
        </trans-unit>
        <trans-unit id="8bdf48221c79cdff6f82682481fb3aac85a04a04" translate="yes" xml:space="preserve">
          <source>to coroutines.
You can also use coroutines for the</source>
          <target state="translated">к корутинам.Вы также можете использовать корудины для</target>
        </trans-unit>
        <trans-unit id="efac37b56b3a17b838dbca790f381ac20a5f457c" translate="yes" xml:space="preserve">
          <source>traceback</source>
          <target state="translated">обратная связь</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
