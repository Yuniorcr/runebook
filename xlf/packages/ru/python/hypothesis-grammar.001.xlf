<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="https://pypi.org/project/hypothesis-grammar/">
    <body>
      <group id="hypothesis-grammar">
        <trans-unit id="06e715f999c1e8bb74d0ef668de5467dbc5404e8" translate="yes" xml:space="preserve">
          <source>'Rules' must be named all-lowercase, e.g. &lt;code&gt;np&lt;/code&gt;</source>
          <target state="translated">&quot;Правила&quot; должны быть написаны в нижнем регистре, например &lt;code&gt;np&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="065e98511a3f896062d78116f1f4a79818a9d74c" translate="yes" xml:space="preserve">
          <source>'Terminals' must be named all-caps (terminals only reference literals, not other rules), e.g. &lt;code&gt;DET&lt;/code&gt;</source>
          <target state="translated">&quot;Терминалы&quot; должны называться заглавными буквами (терминалы ссылаются только на литералы, а не на другие правила), например &lt;code&gt;DET&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0e4306aaec34e61c0ed5b8039ff9c6bd77e8c070" translate="yes" xml:space="preserve">
          <source>(But if you're generating action sequences for tests then probably you should check out Hypothesis' &lt;a href=&quot;https://hypothesis.readthedocs.io/en/latest/stateful.html&quot;&gt;stateful testing&lt;/a&gt; features first)</source>
          <target state="translated">(Но если вы создаете последовательности действий для тестов, то, вероятно, вам сначала следует проверить функции &lt;a href=&quot;https://hypothesis.readthedocs.io/en/latest/stateful.html&quot;&gt;тестирования&lt;/a&gt; Hypothesis с отслеживанием состояния )</target>
        </trans-unit>
        <trans-unit id="7da59d650a4228de748a0d71280684a68d5ad441" translate="yes" xml:space="preserve">
          <source>(If you are looking to generate text from a grammar for purposes other than testing with Hypothesis then this lib can still be useful, but I stongly recommend looking at the &lt;a href=&quot;http://www.nltk.org/howto/generate.html&quot;&gt;tools provided with NLTK&lt;/a&gt; instead.)</source>
          <target state="translated">(Если вы хотите сгенерировать текст из грамматики для целей, отличных от тестирования с помощью гипотезы, эта библиотека все еще может быть полезна, но я настоятельно рекомендую вместо этого взглянуть на &lt;a href=&quot;http://www.nltk.org/howto/generate.html&quot;&gt;инструменты, предоставляемые с NLTK&lt;/a&gt; .)</target>
        </trans-unit>
        <trans-unit id="f79e28061ca25a0dae68cd9212d7c2ddaf953658" translate="yes" xml:space="preserve">
          <source>(pre-alpha... the stuff I've tried all works, not well tested yet though)</source>
          <target state="translated">(пре-альфа ... все, что я пробовал, работает, но еще не проверено)</target>
        </trans-unit>
        <trans-unit id="34ef5ca7249f5ce6a9b2a03376eb3bd60d72a35b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;(&lt;/code&gt; and &lt;code&gt;)&lt;/code&gt; are for grouping, the group can be quantified using any of the modifiers above.</source>
          <target state="translated">&lt;code&gt;(&lt;/code&gt; и &lt;code&gt;)&lt;/code&gt; предназначены для группировки, группа может быть количественно определена с использованием любого из модификаторов выше.</target>
        </trans-unit>
        <trans-unit id="69d0a0282362c3d1a791adf8f0b422ad59bbc4f7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;*&lt;/code&gt; i.e. &lt;code&gt;&quot;in&quot;*&lt;/code&gt; means &lt;code&gt;&quot;in&quot;&lt;/code&gt; is expected zero-or-many times.</source>
          <target state="translated">&lt;code&gt;*&lt;/code&gt; т.е. &lt;code&gt;&quot;in&quot;*&lt;/code&gt; означает, что &lt;code&gt;&quot;in&quot;&lt;/code&gt; ожидается ноль или много раз.</target>
        </trans-unit>
        <trans-unit id="594929d4a73449a1758113e6a81964a0eed29be9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;+&lt;/code&gt; i.e. &lt;code&gt;&quot;in&quot;+&lt;/code&gt; means &lt;code&gt;&quot;in&quot;&lt;/code&gt; is expected one-or-many times.</source>
          <target state="translated">&lt;code&gt;+&lt;/code&gt; т.е. &lt;code&gt;&quot;in&quot;+&lt;/code&gt; означает &lt;code&gt;&quot;in&quot;&lt;/code&gt; ожидается один или несколько раз.</target>
        </trans-unit>
        <trans-unit id="acfb5e63bd26caad67b133356629e859d7e8040b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;?&lt;/code&gt; means optional, i.e. &lt;code&gt;&quot;in&quot;?&lt;/code&gt; means &lt;code&gt;&quot;in&quot;&lt;/code&gt; is expected zero-or-one time.</source>
          <target state="translated">&lt;code&gt;?&lt;/code&gt; значит необязательный, т.е. &lt;code&gt;&quot;in&quot;?&lt;/code&gt; означает, что &lt;code&gt;&quot;in&quot;&lt;/code&gt; ожидается ноль или один раз.</target>
        </trans-unit>
        <trans-unit id="65c66d8b9aad8e761dd0438f1755afc753cb14b7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;start=&quot;s&quot;&lt;/code&gt; tells the parser that the start rule is &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;start=&quot;s&quot;&lt;/code&gt; сообщает парсеру, что стартовым правилом является &lt;code&gt;s&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ffba1884ae5cdd5a0572dae34fed56976c21cf0d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;|&lt;/code&gt; is alternation, so &lt;code&gt;&quot;in&quot; | &quot;with&quot;&lt;/code&gt; means one-of &lt;code&gt;&quot;in&quot;&lt;/code&gt; or &lt;code&gt;&quot;with&quot;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;|&lt;/code&gt; есть чередование, поэтому &lt;code&gt;&quot;in&quot; | &quot;with&quot;&lt;/code&gt; означает один из &lt;code&gt;&quot;in&quot;&lt;/code&gt; или &lt;code&gt;&quot;with&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="53f6efc5cdcf9f3a22526511d7745bdb7b12979b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;~ &amp;lt;min&amp;gt;..&amp;lt;max&amp;gt;&lt;/code&gt; is a range, expected between-&amp;lt;min&amp;gt;-and-&amp;lt;max&amp;gt; times.</source>
          <target state="translated">&lt;code&gt;~ &amp;lt;min&amp;gt;..&amp;lt;max&amp;gt;&lt;/code&gt; - это диапазон, ожидаемый между- &amp;lt;min&amp;gt; и- &amp;lt;max&amp;gt; раз.</target>
        </trans-unit>
        <trans-unit id="8175495afd0f99be24db86f956abbc7435b000f3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;~ &amp;lt;num&amp;gt;&lt;/code&gt; means exactly-&amp;lt;num&amp;gt; times.</source>
          <target state="translated">&lt;code&gt;~ &amp;lt;num&amp;gt;&lt;/code&gt; означает точно- &amp;lt;число&amp;gt; раз.</target>
        </trans-unit>
        <trans-unit id="6fc2a5bf81a73fe237a154328c768027afa67a3c" translate="yes" xml:space="preserve">
          <source>A reverse-parser as a Hypotheses strategy: generate examples from an EBNF grammar</source>
          <target state="translated">Обратный парсер как стратегия гипотез:генерация примеров из грамматики EBNF</target>
        </trans-unit>
        <trans-unit id="b11f8183e944886fa59148cbb5189e20f31848dd" translate="yes" xml:space="preserve">
          <source>Adjacent tokens are concatenated, i.e. &lt;code&gt;DET N&lt;/code&gt; means a &lt;code&gt;DET&lt;/code&gt; followed by a &lt;code&gt;N&lt;/code&gt;.</source>
          <target state="translated">Прилегающие маркеры сцеплены, т.е. &lt;code&gt;DET N&lt;/code&gt; означает &lt;code&gt;DET&lt;/code&gt; с последующим &lt;code&gt;N&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fc800738edcebd003994663a677ad7f8e3341029" translate="yes" xml:space="preserve">
          <source>As you can see, we have produced a Hypothesis strategy which is able to generate examples which match the grammar (in this case, short sentences which sometimes makes sense).</source>
          <target state="translated">Как видите,мы создали стратегию Гипотезы,которая способна генерировать примеры,соответствующие грамматике (в данном случае,короткие предложения,что иногда имеет смысл).</target>
        </trans-unit>
        <trans-unit id="4c34dcc622b1da6b7f78e159b817ba5ba1108fcb" translate="yes" xml:space="preserve">
          <source>But the grammar doesn't have to describe text, it might represent a sequence of actions for example. In that case you might want to convert your result tokens into object instances, which could be done via a lookup table.</source>
          <target state="translated">Но грамматика не обязательно должна описывать текст,она может представлять собой последовательность действий,например.В этом случае вам может понадобиться преобразовать маркеры результата в экземпляры объектов,что можно сделать с помощью таблицы поиска.</target>
        </trans-unit>
        <trans-unit id="dc9401e01d92475f18b6c76f30c9f4b07ca762e8" translate="yes" xml:space="preserve">
          <source>First you need a grammar. Our grammar format is based on that used by the &lt;a href=&quot;https://lark-parser.readthedocs.io/en/latest/grammar/&quot;&gt;Lark parser&lt;/a&gt; library.  You can see our grammar-parsing grammar &lt;a href=&quot;hypothesis_grammar/grammar.lark&quot;&gt;here&lt;/a&gt;. More details of our grammar format &lt;a href=&quot;#grammar-details&quot;&gt;below&lt;/a&gt;.</source>
          <target state="translated">Для начала вам понадобится грамматика. Наш формат грамматики основан на том, что используется библиотекой &lt;a href=&quot;https://lark-parser.readthedocs.io/en/latest/grammar/&quot;&gt;парсера Lark&lt;/a&gt; . Вы можете увидеть нашу грамматику для синтаксического анализа &lt;a href=&quot;hypothesis_grammar/grammar.lark&quot;&gt;здесь&lt;/a&gt; . Более подробная информация о нашем формате грамматики &lt;a href=&quot;#grammar-details&quot;&gt;ниже&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f2784e07adcbc7db90051cd83d24796138debae1" translate="yes" xml:space="preserve">
          <source>Grammar details</source>
          <target state="translated">Грамматические подробности</target>
        </trans-unit>
        <trans-unit id="c7530a6dc53e039db1fa76c609ca7579225d1de7" translate="yes" xml:space="preserve">
          <source>Here is an example of using Hypothesis-Grammar:</source>
          <target state="translated">Вот пример использования Гипотезы-Грамматики:</target>
        </trans-unit>
        <trans-unit id="334513e51b766e5689a61997385d87079b5771e1" translate="yes" xml:space="preserve">
          <source>Hypothesis-Grammar</source>
          <target state="translated">Гипотеза Грамматика</target>
        </trans-unit>
        <trans-unit id="d23367f26b61f8267251a6d0cd014c1bfc25fe30" translate="yes" xml:space="preserve">
          <source>Hypothesis-Grammar is a &quot;reverse parser&quot; - given a grammar it will generate examples of that grammar.</source>
          <target state="translated">Гипотеза-Грамматика-это &quot;обратный парсер&quot;-при заданной грамматике он будет генерировать примеры этой грамматики.</target>
        </trans-unit>
        <trans-unit id="8512397b4e5d55cc7988da53f1e53707a6b4cd51" translate="yes" xml:space="preserve">
          <source>It is implemented as a &lt;a href=&quot;https://hypothesis.readthedocs.io/&quot;&gt;Hypothesis&lt;/a&gt; strategy.</source>
          <target state="translated">Он реализован как стратегия &lt;a href=&quot;https://hypothesis.readthedocs.io/&quot;&gt;гипотез&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1e8128625511f78e7f6a98221108be4105cd8796" translate="yes" xml:space="preserve">
          <source>LHS (name) and RHS are separated by &lt;code&gt;:&lt;/code&gt;</source>
          <target state="translated">LHS (имя) и RHS разделяются &lt;code&gt;:&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3fe993dc8d00fe8d1dcd9fd70305c2ef4e2c9d81" translate="yes" xml:space="preserve">
          <source>So, how does this look?</source>
          <target state="translated">Ну,и как это выглядит?</target>
        </trans-unit>
        <trans-unit id="4bdde3ae857cfb158e4e4b54e3b745c97059108f" translate="yes" xml:space="preserve">
          <source>String literals must be quoted with double-quotes e.g. &lt;code&gt;&quot;man&quot;&lt;/code&gt;</source>
          <target state="translated">Строковые литералы необходимо заключать в двойные кавычки, например &lt;code&gt;&quot;man&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e9fdfd1e154ac05cf9c3cf579648d547828051f8" translate="yes" xml:space="preserve">
          <source>The grammar is taken from an example in the NLTK docs and converted into our &quot;simplified Lark&quot; format.</source>
          <target state="translated">Грамматика взята из примера в NLTK-документах и преобразована в наш &quot;упрощенный Жаворонок&quot; формат.</target>
        </trans-unit>
        <trans-unit id="7e17a3d7bd0d9cde371729a97139671e37c46125" translate="yes" xml:space="preserve">
          <source>The output will always be a flat list of token strings. If you want a sentence you can just &lt;code&gt;&quot; &quot;.join(example)&lt;/code&gt;.</source>
          <target state="translated">На выходе всегда будет плоский список строк токенов. Если вам нужно предложение, вы можете просто &lt;code&gt;&quot; &quot;.join(example)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0bb18642b70b9f8a9c12ccf39487328f306b8e19" translate="yes" xml:space="preserve">
          <source>Usage</source>
          <target state="translated">Использование</target>
        </trans-unit>
        <trans-unit id="89511a76c8cbc174d6fe0018b08443f894e18a4b" translate="yes" xml:space="preserve">
          <source>What is it?</source>
          <target state="translated">Что это?</target>
        </trans-unit>
        <trans-unit id="5f5f8cd4a78f6cd933cbf9fff486ee98721bee8a" translate="yes" xml:space="preserve">
          <source>Whitespace is ignored</source>
          <target state="translated">Пробельные символы игнорируются</target>
        </trans-unit>
        <trans-unit id="f440fc0b5a8ed2198e0c8ff92108351e7b09573a" translate="yes" xml:space="preserve">
          <source>You can also use regex literals, they are delimited with forward-slash, e.g. &lt;code&gt;/the[a-z]{0,2}/&lt;/code&gt;. Content for the regex token is generated using Hypothesis' &lt;a href=&quot;https://hypothesis.readthedocs.io/en/latest/data.html#hypothesis.strategies.from_regex&quot;&gt;&lt;code&gt;from_regex&lt;/code&gt;&lt;/a&gt; strategy, with &lt;code&gt;fullmatch=True&lt;/code&gt;.</source>
          <target state="translated">Вы также можете использовать литералы регулярных выражений, они разделяются косой чертой, например &lt;code&gt;/the[a-z]{0,2}/&lt;/code&gt; . Контент для токена регулярного выражения создается с использованием стратегии Hypothesis &lt;a href=&quot;https://hypothesis.readthedocs.io/en/latest/data.html#hypothesis.strategies.from_regex&quot;&gt; &lt;code&gt;from_regex&lt;/code&gt; &lt;/a&gt; с &lt;code&gt;fullmatch=True&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="63a91052414204f961faae0fbe524fde2183273f" translate="yes" xml:space="preserve">
          <source>or as a test...</source>
          <target state="translated">или в качестве теста...</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
