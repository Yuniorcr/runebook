<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="https://pypi.org/project/justbytes/">
    <body>
      <group id="justbytes">
        <trans-unit id="447b8348b9c2348111a636255e107995a2ed4367" translate="yes" xml:space="preserve">
          <source>All errors raised by justbytes operations are subtypes of the RangeError class.</source>
          <target state="translated">Все ошибки,возникающие при выполнении операций с юстайтами,являются подтипами класса RangeError.</target>
        </trans-unit>
        <trans-unit id="3c736d39cfcbcaf284f80530e8748d5df12b2eb3" translate="yes" xml:space="preserve">
          <source>Alternative Packages</source>
          <target state="translated">Альтернативные пакеты</target>
        </trans-unit>
        <trans-unit id="1f878420017dbe53c0a2676a433496213e5811a0" translate="yes" xml:space="preserve">
          <source>Computing the Representation of a Range</source>
          <target state="translated">Вычисление представления диапазона</target>
        </trans-unit>
        <trans-unit id="7b6af984283fa6b9adedb133907862c2f2663660" translate="yes" xml:space="preserve">
          <source>Consequently, computations such as addition of two Ranges, and conversion
between different magnitudes of bytes, i.e., from MiB to GiB, must be done
precisely. The underlying implementation must therefore use a precise
representation of the number of bytes. Floating point numbers, which are
frequently the preferred type for the representation of physical
quantities, are disallowed by this requirement.</source>
          <target state="translated">Следовательно,такие вычисления,как сложение двух диапазонов и преобразование между разными величинами байтов,т.е.от MiB к GiB,должны выполняться точно.Поэтому в базовой реализации должно использоваться точное представление количества байтов.Числа с плавающей точкой,которые часто являются предпочтительным типом для представления физических величин,не допускаются этим требованием.</target>
        </trans-unit>
        <trans-unit id="3f4700f344a55dd2a413f15f371fad0a05b8a575" translate="yes" xml:space="preserve">
          <source>Constructing Ranges Programatically</source>
          <target state="translated">Построение хребтов программно</target>
        </trans-unit>
        <trans-unit id="9c6c971ced78a1f9bbe931fd59030db5c8588db9" translate="yes" xml:space="preserve">
          <source>Displaying Ranges</source>
          <target state="translated">Диапазоны отображения</target>
        </trans-unit>
        <trans-unit id="805e86a8cbf628e38e4c45612c005a504009e79a" translate="yes" xml:space="preserve">
          <source>Errors</source>
          <target state="translated">Ошибки</target>
        </trans-unit>
        <trans-unit id="cbfba25d0250d74cb72b3ec89534cd1cbcf21211" translate="yes" xml:space="preserve">
          <source>Floating Point Numbers</source>
          <target state="translated">Числа с плавающей точкой</target>
        </trans-unit>
        <trans-unit id="d6d84fa09f507b8c85bc8b38c187fe899a44a5c1" translate="yes" xml:space="preserve">
          <source>If you are interested in computing in Python with physical, rather than
logical, quantities, you should consult the pint package:
&lt;a href=&quot;http://pint.readthedocs.org&quot;&gt;http://pint.readthedocs.org&lt;/a&gt;.</source>
          <target state="translated">Если вас интересуют вычисления на Python с физическими, а не логическими величинами, вам следует обратиться к пакету pint: &lt;a href=&quot;http://pint.readthedocs.org&quot;&gt;http://pint.readthedocs.org&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8d205500c8f287783d5e6ffd528d2f8fbd78d600" translate="yes" xml:space="preserve">
          <source>It is not possible to use floating point numbers or Decimal in computations
with Ranges. Where a fractional quantity is desired, use Fraction objects.
Thus, Range(0) * 1.2 and Range(0) * Decimal(&amp;ldquo;1.2&amp;rdquo;) raise an exception, but
Range(0) * Fraction(&amp;ldquo;1.2&amp;rdquo;) is acceptable.</source>
          <target state="translated">Невозможно использовать числа с плавающей запятой или десятичные числа в вычислениях с помощью диапазонов. Если требуется дробное количество, используйте объекты Fraction. Таким образом, Range (0) * 1.2 и Range (0) * Decimal (&amp;laquo;1.2&amp;raquo;) вызывают исключение, но допустимый диапазон (0) * Fraction (&amp;laquo;1.2&amp;raquo;).</target>
        </trans-unit>
        <trans-unit id="d2fac8f190d6ba2310cd04193e6922d40dd4506a" translate="yes" xml:space="preserve">
          <source>Its sole purpose is the representation of real address ranges on real
machines. For that reason, it does not allow powers of ranges, imprecise
ranges, or non-finite ranges. In order that the
usual laws of arithmetic can be maintained, it does allow fractional ranges.</source>
          <target state="translated">Его единственной целью является представление реальных диапазонов адресов на реальных машинах.По этой причине она не допускает полномочий диапазонов,неточных диапазонов или бесконечных диапазонов.Для того,чтобы сохранить обычные законы арифметики,она допускает дробные диапазоны.</target>
        </trans-unit>
        <trans-unit id="45882d11d2960503d0c63d16f01836831a20d4a5" translate="yes" xml:space="preserve">
          <source>Justbytes</source>
          <target state="translated">Юстбайты</target>
        </trans-unit>
        <trans-unit id="fadaa413fdb8e444db665691407ee547102d51d5" translate="yes" xml:space="preserve">
          <source>Justbytes is a module for handling computation with
address ranges expressed in bytes. Its principle feature is a Range class from
which can be constructed Range objects which represent a precise and finite
address range in bytes. Various arithmetic operations are defined for Range
objects.</source>
          <target state="translated">Юстбайты-модуль для обработки вычислений с диапазонами адресов,выраженными в байтах.Его основной особенностью является класс Range,из которого можно построить объекты Range,представляющие точный и конечный диапазон адресов в байтах.Для объектов Range задаются различные арифметические операции.</target>
        </trans-unit>
        <trans-unit id="e3ac283515eac7e729ac10b009dc00d848c8e9ac" translate="yes" xml:space="preserve">
          <source>Memory Consumption and Bandwidth vs. Address Ranges</source>
          <target state="translated">Потребление памяти и пропускная способность против диапазонов адресов</target>
        </trans-unit>
        <trans-unit id="65725c5cbb6b40fb6d8721e0f58b7f2d9f219336" translate="yes" xml:space="preserve">
          <source>Memory consumption, e.g., by a process during execution on a specified
workload, is a quantity, that like address ranges, is specified in
bytes. However, memory consumption is simply a measurement of the amount of
a phsyical quantity consumed.  When bytes are used only to represent memory
consumption, computations do not generally require the special handling
supplied by this library. Generally, measurement of memory consumption can
be treated like any other physical quantity. The same reasoning applies to
bandwidth. For a physical analogy, one can imagine memory consumption to be
analogous to volume, e.g., litres, and bandwidth to be analogous to flow,
e.g., litres per minute.</source>
          <target state="translated">Потребление памяти,например,процессом во время выполнения на указанной рабочей нагрузке,представляет собой количество,которое,как и диапазоны адресов,задается в байтах.Однако,потребление памяти-это просто измерение количества потребляемой фсической величины.Когда байты используются только для представления потребляемой памяти,вычисления,как правило,не требуют специальной обработки,предоставляемой этой библиотекой.Обычно измерение расхода памяти можно трактовать как любую другую физическую величину.То же самое можно сказать и о пропускной способности.Для физической аналогии можно представить потребление памяти,аналогичное объему,например,литрам,и пропускную способность,аналогичную расходу,например,литрам в минуту.</target>
        </trans-unit>
        <trans-unit id="8a99d14f970e76756815cc726112e9e4f2356fee" translate="yes" xml:space="preserve">
          <source>New Range objects can be constructed from Range objects, numeric values, e.g.,
int or Fraction, or strings which represent such numeric values.
strings may be used to represent fractional quantities, e.g., &amp;ldquo;1.2&amp;rdquo;, but
floats and Decimals are disallowed.</source>
          <target state="translated">Новые объекты Range могут быть созданы из объектов Range, числовых значений, например int или Fraction, или строк, которые представляют такие числовые значения. строки могут использоваться для представления дробных величин, например &amp;laquo;1,2&amp;raquo;, но числа с плавающей запятой и десятичные дроби не допускаются.</target>
        </trans-unit>
        <trans-unit id="8e8e76e830d5d5d96809802aa0ea50ad46a0e846" translate="yes" xml:space="preserve">
          <source>Numerous computations with address ranges are nonsensical. For example, 2
raised to a power which is some address range, is a meaningless computation.
All such operations cause an error to be raised.</source>
          <target state="translated">Многочисленные вычисления с диапазонами адресов являются бессмысленными.Например,2,поднятые до мощности,которая представляет собой некоторый диапазон адресов,являются бессмысленными вычислениями.Все подобные операции приводят к ошибке.</target>
        </trans-unit>
        <trans-unit id="a1fdaa6b2a846c8fcf18d414bf8c61db610eda6a" translate="yes" xml:space="preserve">
          <source>Operations</source>
          <target state="translated">Операции</target>
        </trans-unit>
        <trans-unit id="43aaf6f57b7c95249bd643787aad1b1255593812" translate="yes" xml:space="preserve">
          <source>Practical Computing with Address Ranges</source>
          <target state="translated">Практическое вычисление с диапазонами адресов</target>
        </trans-unit>
        <trans-unit id="a85446ae4efaa1d6aaa78d5db82169a15cd8c137" translate="yes" xml:space="preserve">
          <source>Representing Units</source>
          <target state="translated">Представляющие подразделения</target>
        </trans-unit>
        <trans-unit id="32508a9e120d4892b64a069406f889c0158d8e4a" translate="yes" xml:space="preserve">
          <source>Some computations with precise, finite, values may yield irrational results.
For example, while 2 is rational, its square root is an irrational number.
There is no allowed operation on Range objects which can result in an
irrational Range value. It turns out that all such operations are either
nonsensical or would result in a value with an unrepresentable type.</source>
          <target state="translated">Некоторые вычисления с точными,конечными значениями могут дать иррациональные результаты.Например,если 2 является рациональным,то его квадратный корень-иррациональное число.На объектах Range недопустимы операции,которые могут привести к нерациональному значению Range.Получается,что все такие операции либо бессмысленны,либо приведут к получению значения с непредсказуемым типом.</target>
        </trans-unit>
        <trans-unit id="a8b73a8356a1277aa6a8d1b69dbdb2cb2c5bcc98" translate="yes" xml:space="preserve">
          <source>The Range class also has standard methods for the representation of Range
objects as str objects.</source>
          <target state="translated">Класс Range также имеет стандартные методы для представления объектов Range как str-объектов.</target>
        </trans-unit>
        <trans-unit id="94d414b4b47ed43fadec12a10ba6e7313b163f7c" translate="yes" xml:space="preserve">
          <source>The constructor takes an optional units specifier, which defaults to bytes
for all numeric values, and to None for Range objects. The type of the
unit specifier is a named prefix supplied by the size module or a Range object.</source>
          <target state="translated">Конструктор принимает необязательный спецификатор единиц,который по умолчанию равен байтам для всех числовых значений,а для объектов Range-None.Тип спецификатора единиц-это именованный префикс,поставляемый модулем размеров или объектом Range.</target>
        </trans-unit>
        <trans-unit id="097c7c0496973f59f9c251a898f12945055be5c7" translate="yes" xml:space="preserve">
          <source>The representation of a Range is computed according to a specified
configuration. In the default configuration, the representation uses IEC
rather than SI units.</source>
          <target state="translated">Представление диапазона вычисляется в соответствии с заданной конфигурацией.В конфигурации по умолчанию представление использует IEC,а не SI.</target>
        </trans-unit>
        <trans-unit id="10256571c4110a674ceb91b10fbb1a84d4045c07" translate="yes" xml:space="preserve">
          <source>The representation of a Range is not a string, but a structured representation
of the precise value, as well as the relationship of the representation to
the actual value.</source>
          <target state="translated">Представление диапазона-это не строковое,а структурированное представление точного значения,а также отношения представления к фактическому значению.</target>
        </trans-unit>
        <trans-unit id="39a94149ce22e4db399e8e0e373611c2d8539226" translate="yes" xml:space="preserve">
          <source>The result type of operations is a Range, where appropriate, or a subtype of
Rational, where a numeric value is appropriate.</source>
          <target state="translated">Типом результата операции является Диапазон,где уместно,или подтип Рациональный,где уместно числовое значение.</target>
        </trans-unit>
        <trans-unit id="9ed4545ef7ef3799a6493364429d8f4f3088d609" translate="yes" xml:space="preserve">
          <source>The size module supplies a set of named prefixes for both SI and binary units,
for all non-fractional prefixes. Fractional prefixes are not defined.</source>
          <target state="translated">Модуль типоразмеров предоставляет набор именованных префиксов как для SI,так и для двоичных модулей,для всех не дробных префиксов.Дробные префиксы не определены.</target>
        </trans-unit>
        <trans-unit id="6c9670cfffbaa49a042fc163ff0b2776907074d3" translate="yes" xml:space="preserve">
          <source>The str representation can also be configured. The manipulation of the
representation to form a str object is abstracted from the rest of the source
to emphasize that clients of the package may choose to represent address ranges
in any manner they choose.</source>
          <target state="translated">Также можно настроить представление в виде строки.Управление представлением для формирования объекта str абстрагируется от остальной части исходного текста,чтобы подчеркнуть,что клиенты пакета могут выбирать представление диапазонов адресов любым выбранным ими способом.</target>
        </trans-unit>
        <trans-unit id="c9d82d1c8a3f153080dfa8f031173eb4da4b8f13" translate="yes" xml:space="preserve">
          <source>This module does not accomodate multi-dimensionality of address ranges.
Consequently, multiplying one Range object by another Range object will cause
an error to be raised, since bytes^2 is not representable by the module.
For most uses any operation which would yield a multi-dimensional quantity
is not useful. There are no plans to adapt this package so that it
can accomodate multi-dimensionality of address ranges.</source>
          <target state="translated">Данный модуль не вмещает в себя многомерность диапазонов адресов.Следовательно,умножение одного объекта Range на другой Range приведет к ошибке,так как байты^2 не отображаются модулем.В большинстве случаев нецелесообразно использовать любую операцию,которая привела бы к многомерности.Не планируется адаптировать данный пакет таким образом,чтобы он вмещал в себя многомерность диапазонов адресов.</target>
        </trans-unit>
        <trans-unit id="d5695091f3f7dbec419aa9a43a489657cd3cec78" translate="yes" xml:space="preserve">
          <source>This package does not handle arbitrary user input. It is expected that the
client will transform any input, from whatever source, into a number and an
optional unit specification which can be passed directly to the Range
constructor.</source>
          <target state="translated">Данный пакет не обрабатывает произвольный пользовательский ввод.Предполагается,что клиент будет преобразовывать любой вход,из любого источника,в число и дополнительную спецификацию блока,которая может быть передана непосредственно конструктору Range.</target>
        </trans-unit>
        <trans-unit id="0ad10cd434a732c22b242d2eb564844e1c3e7716" translate="yes" xml:space="preserve">
          <source>This representation is exposed to clients of the library, which may use it
in any way.</source>
          <target state="translated">Это представление предоставляется клиентам библиотеки,которые могут использовать его любым способом.</target>
        </trans-unit>
        <trans-unit id="0b75d4ee12567b39421e5cdafacb9fdac3567042" translate="yes" xml:space="preserve">
          <source>User Input</source>
          <target state="translated">пользовательский ввод</target>
        </trans-unit>
        <trans-unit id="4cfb3a9ba784840220f2270e361d47e1ff0d6f04" translate="yes" xml:space="preserve">
          <source>When computing with address ranges, the numeric value can be viewed as a
logical, rather than a physical, quantity. That is, unlike, e.g., mass or
length, which are quantities which must be measured with a measuring instrument
which has some built-in imprecision, an address range
is a quantity that is not measured, but is known precisely.
This precision arises because the number represents not as much an amount of
memory as a number of addressable, byte-size, locations in memory.</source>
          <target state="translated">При вычислениях с диапазонами адресов числовое значение можно рассматривать как логическую,а не физическую величину.То есть,в отличие,например,от массы или длины,которые представляют собой величины,которые должны измеряться с помощью средства измерений,имеющего некоторую встроенную неточность,диапазон адресов-это величина,которая не измеряется,но точно известна.Такая точность возникает потому,что число представляет собой не столько объем памяти,сколько количество адресуемых,байтовых ячеек в памяти.</target>
        </trans-unit>
        <trans-unit id="d2fff8678cd4207ea323bf9803cc0d1f80906f54" translate="yes" xml:space="preserve">
          <source>computing with and displaying bytes</source>
          <target state="translated">вычисление и отображение байтов</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
