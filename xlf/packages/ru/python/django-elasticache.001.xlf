<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="https://pypi.org/project/django-elasticache/">
    <body>
      <group id="django-elasticache">
        <trans-unit id="8278d2adba7612cf98a492d21a4ac4c78acb1202" translate="yes" xml:space="preserve">
          <source>, and</source>
          <target state="translated">, и</target>
        </trans-unit>
        <trans-unit id="e2bc2a15ce8dae5e5969eee6d10ba152147f9f02" translate="yes" xml:space="preserve">
          <source>. When set to</source>
          <target state="translated">. При установке на</target>
        </trans-unit>
        <trans-unit id="1b954e259d9778652df4bfdda7fd01994b4e0d7e" translate="yes" xml:space="preserve">
          <source>1. Memcached configured with location = Configuration Endpoint</source>
          <target state="translated">1.Конфигурация кэша с местоположением=конечная точка конфигурации</target>
        </trans-unit>
        <trans-unit id="95c4d4c63d90a3652d39048059c7ebb378cd0da5" translate="yes" xml:space="preserve">
          <source>2. Memcached configured with all nodes</source>
          <target state="translated">2.Мемкэш сконфигурирован со всеми узлами</target>
        </trans-unit>
        <trans-unit id="6ce167003d7bcb23a9e9502ba565e65ed6026279" translate="yes" xml:space="preserve">
          <source>3. Use django-elasticache</source>
          <target state="translated">3.Использовать django-elasticache</target>
        </trans-unit>
        <trans-unit id="01e743d1b711e4b8118553cc539fbd031722014c" translate="yes" xml:space="preserve">
          <source>Another solutions</source>
          <target state="translated">Другие решения</target>
        </trans-unit>
        <trans-unit id="591ab42e357bf25adf4fe44eea1f8dcaeb6bdf99" translate="yes" xml:space="preserve">
          <source>By the first call to cache it connects to cluster (using</source>
          <target state="translated">По первому вызову кэширования он подключается к кластеру (используя</target>
        </trans-unit>
        <trans-unit id="f6774cf92d1ff654549a8873c1dab250e9d33208" translate="yes" xml:space="preserve">
          <source>Difference between setup with nodes list (django-elasticache) and
connection to only one configuration Endpoint (using dns routing) you can see on
this graph:</source>
          <target state="translated">Разницу между установкой со списком узлов (django-elasticache)и подключением только к одной конечной точке конфигурации (используя маршрутизацию dns)вы можете увидеть на этом графике:</target>
        </trans-unit>
        <trans-unit id="4ba8b7a054fd0a477ce11807754bf638dbd8875c" translate="yes" xml:space="preserve">
          <source>Django 1.5+.</source>
          <target state="translated">Джанго 1.5+.</target>
        </trans-unit>
        <trans-unit id="96d0c7c9954c664505b3f313afa9536f20c485f6" translate="yes" xml:space="preserve">
          <source>Django cache backend for Amazon ElastiCache (memcached)</source>
          <target state="translated">Бэкэнд кэша Django для Amazon ElastiCache (memcached)</target>
        </trans-unit>
        <trans-unit id="c0f5ce01034acc77e1f3c7080b2120b344d72c5d" translate="yes" xml:space="preserve">
          <source>Django-elasticache changes default pylibmc params to increase performance.</source>
          <target state="translated">Для повышения производительности Django-elasticache изменяет параметры pylibmc по умолчанию.</target>
        </trans-unit>
        <trans-unit id="ef5d1b9f5ee502ffbf45d1e356093bd2bb470c2d" translate="yes" xml:space="preserve">
          <source>ElastiCache provides memcached interface so there are three solution of using it:</source>
          <target state="translated">ElastiCache предоставляет интерфейс memcached,поэтому существует три варианта его использования:</target>
        </trans-unit>
        <trans-unit id="bf7a0f0eb10723db2bd2e06594f233a150cf376b" translate="yes" xml:space="preserve">
          <source>Get it from &lt;a href=&quot;http://pypi.python.org/pypi/django-elasticache&quot;&gt;pypi&lt;/a&gt;:</source>
          <target state="translated">Получите это из &lt;a href=&quot;http://pypi.python.org/pypi/django-elasticache&quot;&gt;pypi&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="cf2eabc3e15e04556cf331bdf1da268312a370a5" translate="yes" xml:space="preserve">
          <source>IGNORE_CLUSTER_ERRORS</source>
          <target state="translated">ИГНОРИРОВАТЬ_КЛАСТЕР_ОШИБКИ</target>
        </trans-unit>
        <trans-unit id="d07ff1939b5a825de60f525b17298f83d1af8026" translate="yes" xml:space="preserve">
          <source>In this case your application
will randomly connect to nodes in cluster and cache will be used with not optimal
way. At some moment you will be connected to first node and set item. Minute later
you will be connected to another node and will not able to get this item.</source>
          <target state="translated">В этом случае ваше приложение будет случайным образом подключаться к узлам в кластере,и кэш будет использоваться не оптимальным образом.В какой-то момент вы подключитесь к первому узлу и установите элемент.Через минуту вы будете подключены к другому узлу и не сможете получить этот элемент.</target>
        </trans-unit>
        <trans-unit id="c81b79df3c6448eae7c4f80428b54cd5692a17d7" translate="yes" xml:space="preserve">
          <source>Installation</source>
          <target state="translated">Установка</target>
        </trans-unit>
        <trans-unit id="d97a56b58699a167763def3745442dbea8b7d317" translate="yes" xml:space="preserve">
          <source>It was written and tested on Python 2.7 and 3.4.</source>
          <target state="translated">Он был написан и протестирован на питонах 2.7 и 3.4.</target>
        </trans-unit>
        <trans-unit id="56a2e96ce679c7def9a8b2ddc1689061789ef197" translate="yes" xml:space="preserve">
          <source>It will connect to cluster and retrieve ip addresses
of all nodes and configure memcached to use all nodes.</source>
          <target state="translated">Он подключится к кластеру и получит ip адреса всех узлов,а также настроит memcached на использование всех узлов.</target>
        </trans-unit>
        <trans-unit id="4cbb610d07abd4de00a916dea1c26c7f96b96395" translate="yes" xml:space="preserve">
          <source>It will work fine, memcache client will
separate items between all nodes and will balance loading on client side. You will
have problems only after adding new nodes or delete old nodes. In this case you should
add new nodes manually and don&amp;rsquo;t forget update your app after all changes on AWS.</source>
          <target state="translated">Он будет работать нормально, клиент memcache будет разделять элементы между всеми узлами и балансировать нагрузку на стороне клиента. Проблемы возникнут только после добавления новых узлов или удаления старых узлов. В этом случае вам следует добавлять новые узлы вручную и не забывать обновлять приложение после всех изменений в AWS.</target>
        </trans-unit>
        <trans-unit id="40c3322b3b3d0d946724fe784d34663629e1932a" translate="yes" xml:space="preserve">
          <source>LOCATION</source>
          <target state="translated">РАСПОЛОЖЕНИЕ</target>
        </trans-unit>
        <trans-unit id="09a428f93ec07a73d726f8bd037ecacfaaf8b044" translate="yes" xml:space="preserve">
          <source>Requirements</source>
          <target state="translated">Требования</target>
        </trans-unit>
        <trans-unit id="751eb68ffdb680fc5c3057f81248e031baa7b6db" translate="yes" xml:space="preserve">
          <source>Run the tests like this:</source>
          <target state="translated">Проведите такие тесты:</target>
        </trans-unit>
        <trans-unit id="5b62f292a927f052cce0ebfd49375e069c454722" translate="yes" xml:space="preserve">
          <source>Simple Django cache backend for Amazon ElastiCache (memcached based). It uses
&lt;a href=&quot;http://github.com/lericson/pylibmc&quot;&gt;pylibmc&lt;/a&gt; and sets up a connection to each
node in the cluster using
&lt;a href=&quot;http://docs.aws.amazon.com/AmazonElastiCache/latest/UserGuide/AutoDiscovery.html&quot;&gt;auto discovery&lt;/a&gt;.</source>
          <target state="translated">Простая серверная часть кеширования Django для Amazon ElastiCache (на основе memcached). Он использует &lt;a href=&quot;http://github.com/lericson/pylibmc&quot;&gt;pylibmc&lt;/a&gt; и устанавливает соединение с каждым узлом в кластере с помощью &lt;a href=&quot;http://docs.aws.amazon.com/AmazonElastiCache/latest/UserGuide/AutoDiscovery.html&quot;&gt;автоматического обнаружения&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0820b32b206b7352858e8903a838ed14319acdfd" translate="yes" xml:space="preserve">
          <source>Testing</source>
          <target state="translated">Тестирование</target>
        </trans-unit>
        <trans-unit id="93ef0dd827103681fcee453b78be2ff14e1a261d" translate="yes" xml:space="preserve">
          <source>The</source>
          <target state="translated">The</target>
        </trans-unit>
        <trans-unit id="88b33e4e12f75ac8bf792aebde41f1a090f3a612" translate="yes" xml:space="preserve">
          <source>True</source>
          <target state="translated">Правда</target>
        </trans-unit>
        <trans-unit id="0bb18642b70b9f8a9c12ccf39487328f306b8e19" translate="yes" xml:space="preserve">
          <source>Usage</source>
          <target state="translated">Использование</target>
        </trans-unit>
        <trans-unit id="7ddadb61200c5d2fbe72688cdd9ba64db7f35fdd" translate="yes" xml:space="preserve">
          <source>Your cache backend should look something like this:</source>
          <target state="translated">Твоя кэш-бэкэнд должна выглядеть примерно так:</target>
        </trans-unit>
        <trans-unit id="6066a2c377d1f3245d673c2ff2e078e25081e3bc" translate="yes" xml:space="preserve">
          <source>config get cluster</source>
          <target state="translated">получить конфигурацию кластеров</target>
        </trans-unit>
        <trans-unit id="1e2159e398ac0b72f64428a363b82c6b9946c829" translate="yes" xml:space="preserve">
          <source>doesn&amp;rsquo;t have support
for</source>
          <target state="translated">не поддерживает</target>
        </trans-unit>
        <trans-unit id="371cc7343d473e2d73d8393f22a039ae352fc95b" translate="yes" xml:space="preserve">
          <source>fails,
it returns a list of a single node with the same endpoint supplied to</source>
          <target state="translated">не удается,он возвращает список одного узла с одной и той же конечной точкой,поставляемой для</target>
        </trans-unit>
        <trans-unit id="38827606a0945559ffc7c96d3d53ab40c63bbaa0" translate="yes" xml:space="preserve">
          <source>option is useful when</source>
          <target state="translated">вариант полезен,когда</target>
        </trans-unit>
        <trans-unit id="feffea0d5bc93465efdccc93f9adef30c886bc13" translate="yes" xml:space="preserve">
          <source>or &lt;a href=&quot;http://github.com/gusdan/django-elasticache&quot;&gt;github&lt;/a&gt;:</source>
          <target state="translated">или &lt;a href=&quot;http://github.com/gusdan/django-elasticache&quot;&gt;github&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="14b109f1263bfc21f7ba0577cf57779716596583" translate="yes" xml:space="preserve">
          <source>param),
gets list of all nodes and setup pylibmc client using full
list of nodes. As result your cache will work with all nodes in cluster and
automatically detect new nodes in cluster. List of nodes are stored in class-level
cached, so any changes in cluster take affect only after restart of working process.
But if you&amp;rsquo;re using gunicorn or mod_wsgi you usually have max_request settings which
restart process after some count of processed requests, so auto discovery will work
fine.</source>
          <target state="translated">param), получает список всех узлов и настраивает клиент pylibmc, используя полный список узлов. В результате ваш кеш будет работать со всеми узлами в кластере и автоматически обнаруживать новые узлы в кластере. Список узлов хранится в кэше уровня классов, поэтому любые изменения в кластере вступают в силу только после перезапуска рабочего процесса. Но если вы используете gunicorn или mod_wsgi, у вас обычно есть настройки max_request, которые перезапускают процесс после некоторого количества обработанных запросов, поэтому автоматическое обнаружение будет работать нормально.</target>
        </trans-unit>
        <trans-unit id="57748d5675ff25b5a147e34fa985986bcddb1a56" translate="yes" xml:space="preserve">
          <source>pylibmc</source>
          <target state="translated">pylibmc</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
