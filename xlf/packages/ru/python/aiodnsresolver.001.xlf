<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="https://pypi.org/project/aiodnsresolver/">
    <body>
      <group id="aiodnsresolver">
        <trans-unit id="5271bccbbe941ae52abb53cc0fecaec4be011917" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://nvd.nist.gov/vuln/detail/CVE-2017-2909&quot;&gt;Pointer loops&lt;/a&gt; are detected.</source>
          <target state="translated">&lt;a href=&quot;https://nvd.nist.gov/vuln/detail/CVE-2017-2909&quot;&gt;&lt;/a&gt;Обнаружены петли указателя .</target>
        </trans-unit>
        <trans-unit id="929dca150227ac071b7a3bc11408a076f3f42dcd" translate="yes" xml:space="preserve">
          <source>A cache is part of each &lt;code&gt;Resolver()&lt;/code&gt;, expiring records automatically according to their TTL.</source>
          <target state="translated">Кеш является частью каждого &lt;code&gt;Resolver()&lt;/code&gt; , автоматически удаляя записи в соответствии с их TTL.</target>
        </trans-unit>
        <trans-unit id="211b06c40eb506400c76ecdf544257469ed37a5b" translate="yes" xml:space="preserve">
          <source>A higher risk assumption is that many tests use the, otherwise private, &lt;code&gt;pack&lt;/code&gt; and &lt;code&gt;parse&lt;/code&gt; functions as part of the built-in DNS server that is used by the tests. These are the core functions used by the production code used to pack and parse DNS messages. While asserting that the resolver can communicate to the built-in nameserver, all the tests do is assert that &lt;code&gt;pack&lt;/code&gt; and &lt;code&gt;parse&lt;/code&gt; are consistent with each other: it is an assumption that other nameservers have equivalent behaviour.</source>
          <target state="translated">Предположение с более высоким риском заключается в том, что многие тесты используют функции &lt;code&gt;pack&lt;/code&gt; и &lt;code&gt;parse&lt;/code&gt; , которые в противном случае являются частными, как часть встроенного DNS-сервера, используемого тестами. Это основные функции, используемые производственным кодом, используемым для упаковки и анализа сообщений DNS. Утверждая, что преобразователь может взаимодействовать со встроенным сервером имен, все тесты подтверждают, что &lt;code&gt;pack&lt;/code&gt; и &lt;code&gt;parse&lt;/code&gt; согласованы друг с другом: предполагается, что другие серверы имен имеют аналогичное поведение.</target>
        </trans-unit>
        <trans-unit id="5e187dda81d772797388202838eb2eeeac356582" translate="yes" xml:space="preserve">
          <source>A maximum of two messages per DNS query are logged at &lt;code&gt;INFO&lt;/code&gt;. If a nameserver fails, a &lt;code&gt;WARNING&lt;/code&gt; is issued [although an exception will be raised if no nameservers succeed], and the remainder of messages are logged at &lt;code&gt;DEBUG&lt;/code&gt;. No &lt;code&gt;ERROR&lt;/code&gt; or &lt;code&gt;CRITICAL&lt;/code&gt; messages are issued when exceptions are raised: it is the responsiblity of client code to log these if desired.</source>
          <target state="translated">В &lt;code&gt;INFO&lt;/code&gt; регистрируется максимум два сообщения на запрос DNS . Если сервер имен выходит из строя, выдается &lt;code&gt;WARNING&lt;/code&gt; [хотя будет сгенерировано исключение, если серверы имен не преуспеют], а остальные сообщения регистрируются в &lt;code&gt;DEBUG&lt;/code&gt; . При возникновении исключений сообщения &lt;code&gt;ERROR&lt;/code&gt; или &lt;code&gt;CRITICAL&lt;/code&gt; не выдаются: ответственность за регистрацию этих исключений лежит на клиентском коде.</target>
        </trans-unit>
        <trans-unit id="51f7f0ed3e00a224445ea9af92863e69074b3f06" translate="yes" xml:space="preserve">
          <source>A new socket, and so a new random local port, is used for each query.</source>
          <target state="translated">Для каждого запроса используется новый сокет,а значит,и новый случайный локальный порт.</target>
        </trans-unit>
        <trans-unit id="9100aca195719601490d3778547d5c3de3ae9465" translate="yes" xml:space="preserve">
          <source>Also, to migitate the risk of evil responses/configuration</source>
          <target state="translated">Также,для миграции риска злых ответов/конфигурации</target>
        </trans-unit>
        <trans-unit id="52e9f6aaf6e7b4bf71883e35141db1b9fcfd8250" translate="yes" xml:space="preserve">
          <source>Asyncio Python DNS resolver. Pure Python, with no dependencies other than the standard library, threads are not used, no additional tasks are created, and all code is in a single module. The nameservers to query are taken from &lt;code&gt;/etc/resolv.conf&lt;/code&gt;, and treats hosts in &lt;code&gt;/etc/hosts&lt;/code&gt; as A or AAAA records with a TTL of 0.</source>
          <target state="translated">DNS-преобразователь Asyncio Python. Чистый Python, без каких-либо зависимостей, кроме стандартной библиотеки, потоки не используются, никаких дополнительных задач не создается, и весь код находится в одном модуле. Запрашиваемые серверы имен берутся из &lt;code&gt;/etc/resolv.conf&lt;/code&gt; и обрабатывают хосты в &lt;code&gt;/etc/hosts&lt;/code&gt; как записи A или AAAA с TTL равным 0.</target>
        </trans-unit>
        <trans-unit id="61a84ef6505fac2720810c22f65c1971715da98b" translate="yes" xml:space="preserve">
          <source>By default each domain name is encoded with &lt;a href=&quot;https://astrolavos.gatech.edu/articles/increased_dns_resistance.pdf&quot;&gt;0x20-bit encoding&lt;/a&gt; before being sent to the nameservers. However, some nameservers, such as Docker's built-in, do not support this. So, to control or disable the encoding, you can pass a custom &lt;code&gt;transform_fqdn&lt;/code&gt; coroutine to Resolver that does not perform any additional encoding.</source>
          <target state="translated">По умолчанию каждое доменное имя кодируется с помощью &lt;a href=&quot;https://astrolavos.gatech.edu/articles/increased_dns_resistance.pdf&quot;&gt;0x20-битной кодировки&lt;/a&gt; перед отправкой на серверы имен. Однако некоторые серверы имен, например встроенный Docker, не поддерживают это. Таким образом, для управления или отключения кодирования вы можете передать в Resolver настраиваемую сопрограмму &lt;code&gt;transform_fqdn&lt;/code&gt; , которая не выполняет никакого дополнительного кодирования.</target>
        </trans-unit>
        <trans-unit id="e4c00516cc8b5ef50215908476d463b79c1132af" translate="yes" xml:space="preserve">
          <source>By default each domain name is encoded with &lt;a href=&quot;https://astrolavos.gatech.edu/articles/increased_dns_resistance.pdf&quot;&gt;0x20-bit encoding&lt;/a&gt;, which is checked against any response.</source>
          <target state="translated">По умолчанию каждое доменное имя закодировано в кодировке &lt;a href=&quot;https://astrolavos.gatech.edu/articles/increased_dns_resistance.pdf&quot;&gt;0x20 бит&lt;/a&gt; , которая проверяется на любой ответ.</target>
        </trans-unit>
        <trans-unit id="503d0636b431f0d0a6b8edd31c135f4675377d16" translate="yes" xml:space="preserve">
          <source>By default logging is through the &lt;code&gt;Logger&lt;/code&gt; named &lt;code&gt;aiodnsresolver&lt;/code&gt;, and all messages are prefixed with &lt;code&gt;[dns]&lt;/code&gt; or &lt;code&gt;[dns:&amp;lt;fqdn&amp;gt;,&amp;lt;query-type&amp;gt;]&lt;/code&gt; through a &lt;code&gt;LoggerAdapter&lt;/code&gt;. Each function accepts &lt;code&gt;get_logger_adapter&lt;/code&gt;: the default of which results in this behaviour, and can be overridden to set either the &lt;code&gt;Logger&lt;/code&gt; or the &lt;code&gt;LoggerAdapter&lt;/code&gt;.</source>
          <target state="translated">По умолчанию ведение журнала через &lt;code&gt;Logger&lt;/code&gt; с именем &lt;code&gt;aiodnsresolver&lt;/code&gt; , и все сообщения с префиксом &lt;code&gt;[dns]&lt;/code&gt; или &lt;code&gt;[dns:&amp;lt;fqdn&amp;gt;,&amp;lt;query-type&amp;gt;]&lt;/code&gt; через &lt;code&gt;LoggerAdapter&lt;/code&gt; . Каждая функция принимает &lt;code&gt;get_logger_adapter&lt;/code&gt; : значение по умолчанию, которое приводит к такому поведению, и может быть переопределено для установки либо &lt;code&gt;Logger&lt;/code&gt; , либо &lt;code&gt;LoggerAdapter&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="83abfbe2bfed3c1a456c2d7e47463ba5e76f0bf5" translate="yes" xml:space="preserve">
          <source>CNAME chains have a maximum length.</source>
          <target state="translated">Цепь CNAME имеет максимальную длину.</target>
        </trans-unit>
        <trans-unit id="73ab091294665e57efeb4610bc88824653477946" translate="yes" xml:space="preserve">
          <source>CNAME records are followed transparently. The &lt;code&gt;expires_at&lt;/code&gt; of IP addresses found via intermediate CNAME(s) is determined by using the minimum &lt;code&gt;expires_at&lt;/code&gt; of all the records involved in determining those IP addresses.</source>
          <target state="translated">Записи CNAME отслеживаются прозрачно. &lt;code&gt;expires_at&lt;/code&gt; из IP - адресов найден через промежуточный продукт CNAME (ы) определяется с использованием минимального &lt;code&gt;expires_at&lt;/code&gt; всех записей , участвующих в определении этих IP - адресов.</target>
        </trans-unit>
        <trans-unit id="86ce9e2117503436712e78317ab8f9b96432ceac" translate="yes" xml:space="preserve">
          <source>CNAMEs</source>
          <target state="translated">CNAMEs</target>
        </trans-unit>
        <trans-unit id="50338b3b242845e21a0ace9ae9684283d945fb52" translate="yes" xml:space="preserve">
          <source>Cache</source>
          <target state="translated">Кэш</target>
        </trans-unit>
        <trans-unit id="2061cc2c0ce561bb4de9ddce9e6148ae313ff804" translate="yes" xml:space="preserve">
          <source>Chaining logging adapters</source>
          <target state="translated">Цепочные лесозаготовительные адаптеры</target>
        </trans-unit>
        <trans-unit id="8c053f773becf89e1d9c570970fcb6dea5254931" translate="yes" xml:space="preserve">
          <source>Custom hosts</source>
          <target state="translated">Пользовательские хосты</target>
        </trans-unit>
        <trans-unit id="95f255134c54184a554be6e3edb813828ba95cc9" translate="yes" xml:space="preserve">
          <source>Custom nameservers and timeouts</source>
          <target state="translated">Клиентские серверы имён и таймауты</target>
        </trans-unit>
        <trans-unit id="4331f6e2659b79348247b80b3a69e3c78192b683" translate="yes" xml:space="preserve">
          <source>Designed for highly concurrent/HA situations. Based on &lt;a href=&quot;https://github.com/gera2ld/async_dns&quot;&gt;https://github.com/gera2ld/async_dns&lt;/a&gt;.</source>
          <target state="translated">Разработан для ситуаций с высокой степенью одновременности и высокой доступности. На основе &lt;a href=&quot;https://github.com/gera2ld/async_dns&quot;&gt;https://github.com/gera2ld/async_dns&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7d4318283b3f106b523e323d9909c77fc9121b46" translate="yes" xml:space="preserve">
          <source>Disable 0x20-bit encoding</source>
          <target state="translated">Отключить 0x20-битное кодирование</target>
        </trans-unit>
        <trans-unit id="325543124cab344013bc013d35cbe2a615311047" translate="yes" xml:space="preserve">
          <source>Each query is given a random ID, which is checked against any response.</source>
          <target state="translated">Каждому запросу присваивается случайный идентификатор,который проверяется по любому ответу.</target>
        </trans-unit>
        <trans-unit id="8d63cc4af916c7b99a241bad8b0d502181c245e4" translate="yes" xml:space="preserve">
          <source>Event loop, tasks, and yielding</source>
          <target state="translated">Цикл событий,задачи и доходность</target>
        </trans-unit>
        <trans-unit id="8f118b077e6a503af07b266e698154147805e76c" translate="yes" xml:space="preserve">
          <source>Example: aiohttp</source>
          <target state="translated">Пример:aiohttp</target>
        </trans-unit>
        <trans-unit id="db74fe5b20374d125b242d991f69908b127e41ce" translate="yes" xml:space="preserve">
          <source>Example: lowhaio</source>
          <target state="translated">Пример:lowhaio</target>
        </trans-unit>
        <trans-unit id="daa475826a7caf2c8d6e1edf8f9fcbc611880db5" translate="yes" xml:space="preserve">
          <source>Example: tornado</source>
          <target state="translated">Пример:торнадо</target>
        </trans-unit>
        <trans-unit id="cd3dfbe79fda3a9d92de67b1bd4f1dc9f60ab723" translate="yes" xml:space="preserve">
          <source>Exceptions</source>
          <target state="translated">Исключения</target>
        </trans-unit>
        <trans-unit id="5e214e6879427a717b554f7c20bad14ac9ba6048" translate="yes" xml:space="preserve">
          <source>Exceptions are subclasses of &lt;code&gt;DnsError&lt;/code&gt;, and are raised if a record does not exist, on socket errors, timeouts, message parsing errors, or other errors returned from the nameserver.</source>
          <target state="translated">Исключения являются подклассами &lt;code&gt;DnsError&lt;/code&gt; и возникают, если запись не существует, при ошибках сокета, тайм-аутах, ошибках синтаксического анализа сообщений или других ошибках, возвращаемых сервером имен.</target>
        </trans-unit>
        <trans-unit id="5481c7b8170c168b824c771b6718a3b6d2901efe" translate="yes" xml:space="preserve">
          <source>For CNAME chains, the event loop is yielded during each communication for non-cached parts of the chain.</source>
          <target state="translated">Для цепей CNAME петля событий выдается при каждом обмене данными для некэшированных частей цепи.</target>
        </trans-unit>
        <trans-unit id="d1ce204dbf3ac8a86a74a6e0f2ade815849b3dd0" translate="yes" xml:space="preserve">
          <source>For complex or highly concurrent applications, it may be desirable that logging adapters be chained to output log messages that incorporate a parent context. So the default ouput of</source>
          <target state="translated">Для сложных или сильно параллельных приложений может быть желательно,чтобы протоколирующие адаптеры были прикованы к выходным сообщениям журнала,которые включают родительский контекст.Таким образом,по умолчанию</target>
        </trans-unit>
        <trans-unit id="37b6d39ee4f6fbd194c7fcc66f1205f74e971cac" translate="yes" xml:space="preserve">
          <source>If a lower-level exception caused the &lt;code&gt;DnsError&lt;/code&gt;, it will be in the &lt;code&gt;__cause__&lt;/code&gt; attribute of the exception.</source>
          <target state="translated">Если исключение более низкого уровня вызвало &lt;code&gt;DnsError&lt;/code&gt; , оно будет в &lt;code&gt;__cause__&lt;/code&gt; исключения.</target>
        </trans-unit>
        <trans-unit id="c81b79df3c6448eae7c4f80428b54cd5692a17d7" translate="yes" xml:space="preserve">
          <source>Installation</source>
          <target state="translated">Установка</target>
        </trans-unit>
        <trans-unit id="98c528a0f6bb272f1be116323214c541e9884abd" translate="yes" xml:space="preserve">
          <source>It is possible to query nameservers other than those in &lt;code&gt;/etc/resolv.conf&lt;/code&gt;, and for each to specify a timeout in seconds to wait for a reply before querying the next.</source>
          <target state="translated">Можно запросить серверы имен, отличные от тех , что указаны в &lt;code&gt;/etc/resolv.conf&lt;/code&gt; , и для каждого указать тайм-аут в секундах для ожидания ответа перед запросом следующего.</target>
        </trans-unit>
        <trans-unit id="15c9db7d7fff447ccf33673477c532475866aef0" translate="yes" xml:space="preserve">
          <source>It is technically possible that in the case of extremely high numbers of A or AAAA records for a domain, they would not fit in a single UDP message. However, this is extremely unlikely, and in this unlikely case, extremely unlikely to affect target applications in any meaningful way. If a truncated message is received, a warning is logged.</source>
          <target state="translated">Технически возможно,что в случае чрезвычайно большого количества записей A или AAAA для домена,они не поместятся в одно UDP-сообщение.Однако это крайне маловероятно,и в этом маловероятном случае крайне маловероятно,что это каким-либо значимым образом повлияет на целевые приложения.Если получено усеченное сообщение,то заносится в журнал предупреждение.</target>
        </trans-unit>
        <trans-unit id="24c4c96f064c57e2f915eb36267d9c1af72b39d9" translate="yes" xml:space="preserve">
          <source>It's possible to specify hosts without editing the &lt;code&gt;/etc/hosts&lt;/code&gt; file.</source>
          <target state="translated">Можно указать хосты без редактирования файла &lt;code&gt;/etc/hosts&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="81abd20921dba1c2e53084d841b924ad28377ed3" translate="yes" xml:space="preserve">
          <source>Log levels</source>
          <target state="translated">Уровни журнала</target>
        </trans-unit>
        <trans-unit id="57003616863fe634c645e342ee9080681e419c5f" translate="yes" xml:space="preserve">
          <source>Logging</source>
          <target state="translated">Регистрация</target>
        </trans-unit>
        <trans-unit id="bf89335514117c4e318f57395975d95081d6e290" translate="yes" xml:space="preserve">
          <source>Many tests assume that timeouts are controlled by &lt;code&gt;asyncio.sleep&lt;/code&gt;, &lt;code&gt;loop.call_later&lt;/code&gt; or &lt;code&gt;loop.call_at&lt;/code&gt;. This is to allow time to be fast-forwarded through cache invalidation using &lt;a href=&quot;https://github.com/michalc/aiofastforward&quot;&gt;aiofastforward&lt;/a&gt; without actually having to wait the corresponding time in the tests. Also, many tests assume &lt;code&gt;open&lt;/code&gt; is used to access files, and patch it to allow assertions on what the code would do with different contents of &lt;code&gt;/etc/resolv.conf&lt;/code&gt; or &lt;code&gt;/etc/hosts&lt;/code&gt;.</source>
          <target state="translated">Многие тесты предполагают, что тайм-ауты контролируются &lt;code&gt;asyncio.sleep&lt;/code&gt; , &lt;code&gt;loop.call_later&lt;/code&gt; или &lt;code&gt;loop.call_at&lt;/code&gt; . Это &lt;a href=&quot;https://github.com/michalc/aiofastforward&quot;&gt;сделано&lt;/a&gt; для того, чтобы время можно было быстро перемотать через аннулирование кеша с помощью aiofastforward без необходимости фактически ждать соответствующее время в тестах. Кроме того, многие тесты предполагают, что &lt;code&gt;open&lt;/code&gt; используется для доступа к файлам, и исправляют его, чтобы разрешить утверждения о том, что код будет делать с различным содержимым &lt;code&gt;/etc/resolv.conf&lt;/code&gt; или &lt;code&gt;/etc/hosts&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="47e6cc73f64a548366be4705e275679eeccea863" translate="yes" xml:space="preserve">
          <source>No extra code is needed to use aiodnsresolver with &lt;a href=&quot;https://github.com/michalc/lowhaio&quot;&gt;lowhaio&lt;/a&gt;: it is used by default.</source>
          <target state="translated">Для использования aiodnsresolver с &lt;a href=&quot;https://github.com/michalc/lowhaio&quot;&gt;lowhaio&lt;/a&gt; дополнительный код не требуется : он используется по умолчанию.</target>
        </trans-unit>
        <trans-unit id="0dd8a289d527539de842bf7f512ddc6f16bab278" translate="yes" xml:space="preserve">
          <source>No tasks are created, and the event loop is only yielded to during socket communication. Because fetching results from the cache involves no socket communication, this means that cached results are fetched without yielding. This introduces a small inconsistency between fetching cached and non-cached results, and so clients should be written to not depend on the presence or lack of a yield during resolution. This is a typically recommended process however: it should be expected that coroutines might yield.</source>
          <target state="translated">Задания не создаются,а шлейф событий выдается только при обмене данными через разъем.Поскольку извлечение результатов из кэша не предполагает взаимодействия с сокетами,это означает,что результаты в кэше извлекаются без результата.Это вводит небольшое несоответствие между получением кэшированных и некэшированных результатов,и поэтому клиенты должны быть написаны так,чтобы не зависеть от наличия или отсутствия доходности во время разрешения.Однако,это обычно рекомендуемый процесс:следует ожидать,что coroutines может дать результат.</target>
        </trans-unit>
        <trans-unit id="13af06a45ae2e367e0503ca4e7145d79f1f7d234" translate="yes" xml:space="preserve">
          <source>Parallel requests to multiple nameservers are also possible, where the first response from each set of requests is used.</source>
          <target state="translated">Также возможны параллельные запросы к нескольким серверам имён,где используется первый ответ от каждого набора запросов.</target>
        </trans-unit>
        <trans-unit id="7fd5bb751b3ce87db39b88c5e968bcfa48b440a4" translate="yes" xml:space="preserve">
          <source>Pure asyncio Python DNS resolver</source>
          <target state="translated">Чистый асинсцио Python DNS-резольвер</target>
        </trans-unit>
        <trans-unit id="bef2a4699d00603b20da781b86d5845c0046fb44" translate="yes" xml:space="preserve">
          <source>Requests made for a domain while there is an in-flight query for that domain, wait for the the in-flight query to finish, and use its result.</source>
          <target state="translated">Запросы,сделанные для домена в то время,когда есть бортовой запрос для этого домена,ждать завершения бортового запроса,и использовать его результат.</target>
        </trans-unit>
        <trans-unit id="c1ada94ed2819eb16c6fe64f64fb6e10147a7afd" translate="yes" xml:space="preserve">
          <source>Returned are tuples of subclasses of &lt;a href=&quot;https://docs.python.org/3/library/ipaddress.html#ipaddress.IPv4Address&quot;&gt;IPv4Address&lt;/a&gt; or &lt;a href=&quot;https://docs.python.org/3/library/ipaddress.html#ipaddress.IPv6Address&quot;&gt;IPv6Address&lt;/a&gt;. Both support conversion to their usual string form by passing them to &lt;code&gt;str&lt;/code&gt;.</source>
          <target state="translated">Возвращаются кортежи подклассов &lt;a href=&quot;https://docs.python.org/3/library/ipaddress.html#ipaddress.IPv4Address&quot;&gt;IPv4Address&lt;/a&gt; или &lt;a href=&quot;https://docs.python.org/3/library/ipaddress.html#ipaddress.IPv6Address&quot;&gt;IPv6Address&lt;/a&gt; . Оба поддерживают преобразование в обычную строковую форму, передавая их в &lt;code&gt;str&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4651a34e4df9619783ad372f905d6d3b84e9d76d" translate="yes" xml:space="preserve">
          <source>Scope</source>
          <target state="translated">Область применения</target>
        </trans-unit>
        <trans-unit id="2931d5d3232f2248933a3926c6bcfde0392f4223" translate="yes" xml:space="preserve">
          <source>Security considerations</source>
          <target state="translated">Соображения безопасности</target>
        </trans-unit>
        <trans-unit id="d4bcd58ee108472a46cd86b218d9752854fdfe5c" translate="yes" xml:space="preserve">
          <source>Specifically, if a record is determined to not exist, &lt;code&gt;DnsRecordDoesNotExist&lt;/code&gt; is raised.</source>
          <target state="translated">В частности, если определено, что запись не существует, &lt;code&gt;DnsRecordDoesNotExist&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fd95ae54dec0b2580591259365e6f9ec1bc37a56" translate="yes" xml:space="preserve">
          <source>TTL / Record expiry</source>
          <target state="translated">TTL/истечение срока годности записи</target>
        </trans-unit>
        <trans-unit id="d84c76a661a2d9eed7c499c29179e4493a22dfb7" translate="yes" xml:space="preserve">
          <source>Testing strategy</source>
          <target state="translated">Стратегия тестирования</target>
        </trans-unit>
        <trans-unit id="724d10488fa0d7f2fcdb5593b3ca64e996ef7b86" translate="yes" xml:space="preserve">
          <source>Tests attempt to closly match real-world use, and assert on how input translate to output, i.e. the &lt;em&gt;public&lt;/em&gt; behaviour of the resolver. Therefore the tests avoid assumptions on implementation details.</source>
          <target state="translated">Тесты пытаются точно сопоставить с реальным использованием и утверждать, как входные данные преобразуются в выходные, то есть &lt;em&gt;публичное&lt;/em&gt; поведение преобразователя. Поэтому тесты избегают предположений о деталях реализации.</target>
        </trans-unit>
        <trans-unit id="8c7516866aa18f7d36f81b46de3023d136af8722" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;LoggerAdapter&lt;/code&gt; used by &lt;code&gt;resolve&lt;/code&gt; and &lt;code&gt;clear_cache&lt;/code&gt; defaults to the one passed to &lt;code&gt;Resolver&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;LoggerAdapter&lt;/code&gt; используется &lt;code&gt;resolve&lt;/code&gt; и &lt;code&gt;clear_cache&lt;/code&gt; по умолчанию для одного передаваемого &lt;code&gt;Resolver&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="466b71a3cf44833cb3278ebc0b07a27c257d9e55" translate="yes" xml:space="preserve">
          <source>The address objects each have an extra property, &lt;code&gt;expires_at&lt;/code&gt;, that returns the expiry time of the address, according to the &lt;code&gt;loop.time()&lt;/code&gt; clock, and the TTL of the records involved to find that address.</source>
          <target state="translated">Каждый объект адреса имеет дополнительное свойство &lt;code&gt;expires_at&lt;/code&gt; , которое возвращает время истечения срока действия адреса в соответствии с &lt;code&gt;loop.time()&lt;/code&gt; и TTL записей, задействованных для поиска этого адреса.</target>
        </trans-unit>
        <trans-unit id="9e9f8b0ae56b3bb4ce43ae4f8e3ab8863677bbde" translate="yes" xml:space="preserve">
          <source>The cache for each record starts on the &lt;em&gt;start&lt;/em&gt; of each request, so duplicate concurrent requests for the same record are not made.</source>
          <target state="translated">Кэш для каждой записи запускается в &lt;em&gt;начале&lt;/em&gt; каждого запроса, поэтому повторяющиеся одновременные запросы для одной и той же записи не выполняются.</target>
        </trans-unit>
        <trans-unit id="a30c90204c5ee38410b23c24343172c003f232be" translate="yes" xml:space="preserve">
          <source>The resolver is a &lt;em&gt;stub&lt;/em&gt; resolver: it delegates the responsibility of recursion to the nameserver(s) it queries. In the vast majority of envisioned use cases this is acceptable, since the nameservers in &lt;code&gt;/etc/resolv.conf&lt;/code&gt; will be recursive.</source>
          <target state="translated">Преобразователь - это преобразователь- &lt;em&gt;заглушка&lt;/em&gt; : он делегирует ответственность за рекурсию серверу (-ам) имен, который запрашивает. В подавляющем большинстве предполагаемых вариантов использования это приемлемо, поскольку серверы имен в &lt;code&gt;/etc/resolv.conf&lt;/code&gt; будут рекурсивными.</target>
        </trans-unit>
        <trans-unit id="ad52e794eb4fcc06ecc4985810a0f8022f6a02b9" translate="yes" xml:space="preserve">
          <source>The scope of this project is deliberately restricted to operations that are used to resolve A or AAAA records: to resolve a domain name to its IP addresses so that IP connections can be made, and have similar responsibilities to &lt;code&gt;gethostbyname&lt;/code&gt;. Some limited extra behaviour is present/may be added, but great care is taken to prevent scope creep, especially to not add complexity that isn't required to resolve A or AAAA records.</source>
          <target state="translated">Объем этого проекта намеренно ограничен операциями, которые используются для разрешения записей A или AAAA: для разрешения доменного имени на его IP-адреса, чтобы можно было устанавливать IP-соединения, и иметь аналогичные обязанности с &lt;code&gt;gethostbyname&lt;/code&gt; . Некоторое ограниченное дополнительное поведение присутствует / может быть добавлено, но большое внимание уделяется предотвращению расползания области, особенно, чтобы не добавлять сложности, которые не требуются для разрешения записей A или AAAA.</target>
        </trans-unit>
        <trans-unit id="57e4103bc66f1c02c2c9e171ff330eee6102ce2e" translate="yes" xml:space="preserve">
          <source>The trade-off for this inconsistency is that cached results are fetched slightly faster than if resolving were to yield in all cases.</source>
          <target state="translated">Компромисс в этом несоответствии заключается в том,что результаты кэширования получаются немного быстрее,чем если бы решение было принято во всех случаях.</target>
        </trans-unit>
        <trans-unit id="568b9215249186337b28f4ddd655addeb1beaa3b" translate="yes" xml:space="preserve">
          <source>There are however exceptions.</source>
          <target state="translated">Однако есть и исключения.</target>
        </trans-unit>
        <trans-unit id="b70f278fda8094a172d4312fe7f6e058f3578c19" translate="yes" xml:space="preserve">
          <source>This can be used as part of a HA system: if a nameserver isn't contactable, this pattern avoids waiting for its timeout before querying another nameserver.</source>
          <target state="translated">Это может быть использовано как часть системы HA:если сервер имён не заходит на связь,то этот шаблон позволяет избежать ожидания таймаута перед запросом к другому серверу имён.</target>
        </trans-unit>
        <trans-unit id="cbcd6514ef7beea9d2b0457fb1fbbe2b4b520b8e" translate="yes" xml:space="preserve">
          <source>This can be used in HA situations to assist failovers. The timer for &lt;code&gt;expires_at&lt;/code&gt; starts just &lt;em&gt;before&lt;/em&gt; the request to the nameserver is made.</source>
          <target state="translated">Это можно использовать в ситуациях высокой доступности, чтобы помочь при отказе. Таймер для &lt;code&gt;expires_at&lt;/code&gt; запускается непосредственно &lt;em&gt;перед отправкой&lt;/em&gt; запроса к серверу имен.</target>
        </trans-unit>
        <trans-unit id="69758f85250db2d85cf4c9bb890236bb8f46f07d" translate="yes" xml:space="preserve">
          <source>To do this, set &lt;code&gt;get_logger_adapter&lt;/code&gt; as a function that chains multiple &lt;code&gt;LoggerAdapter&lt;/code&gt;.</source>
          <target state="translated">Для этого установите &lt;code&gt;get_logger_adapter&lt;/code&gt; как функцию, которая &lt;code&gt;LoggerAdapter&lt;/code&gt; несколько LoggerAdapter .</target>
        </trans-unit>
        <trans-unit id="e5453419f7808d077e72a0951df66da4d335a1ef" translate="yes" xml:space="preserve">
          <source>To migitate spoofing, several techniques are used.</source>
          <target state="translated">Для миграции спуфинга используется несколько методов.</target>
        </trans-unit>
        <trans-unit id="fdac2c4c6b417e4e42de66d3df4d768bdf14bb25" translate="yes" xml:space="preserve">
          <source>To mitigate the risks that these assumptions bring, some &quot;end to end&quot;-style tests are included, which use whatever nameservers are in &lt;code&gt;/etc/resolv.conf&lt;/code&gt;, and asserting on globally available DNS results. While not going through every possible case of input, they do validate that core behaviour is consistent with one other implementation of the protocol.</source>
          <target state="translated">Чтобы снизить риски, связанные с этими предположениями, включены некоторые тесты в стиле &amp;laquo;от начала до конца&amp;raquo;, которые используют любые серверы имен из &lt;code&gt;/etc/resolv.conf&lt;/code&gt; и утверждают результаты DNS, доступные во всем мире. Не рассматривая все возможные варианты ввода, они подтверждают, что основное поведение согласуется с другой реализацией протокола.</target>
        </trans-unit>
        <trans-unit id="ee99461aee3846058cc1f0f7023e131f12d74143" translate="yes" xml:space="preserve">
          <source>UDP queries are made, but not TCP. DNS servers must support UDP, and it's impossible for a single A and AAAA record to not fit into the maximum size of a UDP DNS response, 512 bytes. There may be other data that the DNS server would return in TCP connections, but this isn't required to resolve a domain name to a single IP address.</source>
          <target state="translated">UDP-запросы делаются,но не TCP.DNS серверы должны поддерживать UDP,и невозможно,чтобы одна A и AAAAA запись не входила в максимальный размер UDP DNS ответа,512 байт.Могут быть и другие данные,которые DNS-сервер возвращал бы в TCP-соединениях,но это не требуется для разрешения доменного имени в один IP-адрес.</target>
        </trans-unit>
        <trans-unit id="0bb18642b70b9f8a9c12ccf39487328f306b8e19" translate="yes" xml:space="preserve">
          <source>Usage</source>
          <target state="translated">Использование</target>
        </trans-unit>
        <trans-unit id="e3eb7e120df55fe0ce4ae5e02b1795d6bc597530" translate="yes" xml:space="preserve">
          <source>While both being assumptions, they are both unlikely to change, and in the case that they are changed, this would much more likely result in tests failing incorrectly rather than passing incorrectly. Therefore these are low-risk assumptions.</source>
          <target state="translated">Хотя оба являются предположениями,они оба вряд ли изменятся,и в случае,если они изменятся,это,скорее всего,приведет к тому,что тесты будут неправильно выполнены,а не пройдут неправильно.Следовательно,это предположения низкого риска.</target>
        </trans-unit>
        <trans-unit id="f7cccc0372b47247d5fc2e3825d4126fb7823822" translate="yes" xml:space="preserve">
          <source>aiodnsresolver</source>
          <target state="translated">айодресолвер</target>
        </trans-unit>
        <trans-unit id="08aea82c41d0ad520a61ea165d592487b6c577fe" translate="yes" xml:space="preserve">
          <source>or performs it conditionally</source>
          <target state="translated">или выполняет его условно</target>
        </trans-unit>
        <trans-unit id="e329b5389944db05ea8909e826a45be38a49022b" translate="yes" xml:space="preserve">
          <source>would be prefixed with a &lt;em&gt;parent&lt;/em&gt; context to output something like</source>
          <target state="translated">будет иметь префикс &lt;em&gt;родительского&lt;/em&gt; контекста для вывода чего-то вроде</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
