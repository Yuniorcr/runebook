<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="es" datatype="htmlbody" original="https://pypi.org/project/miniaudio/">
    <body>
      <group id="miniaudio">
        <trans-unit id="222f0192b17749c93311d6c62eceae89b44342a2" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Requires Python 3.5 or newer.  Also works on pypy3 (because it uses cffi).&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Requiere Python 3.5 o m&amp;aacute;s reciente. Tambi&amp;eacute;n funciona en pypy3 (porque usa cffi).&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="ebd14829f102ab6aa17a02620106962a55992006" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;class&lt;/em&gt;&lt;code&gt;CaptureDevice&lt;/code&gt;</source>
          <target state="translated">&lt;em&gt;clase &lt;/em&gt; &lt;code&gt;CaptureDevice&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6a1d24ff6561ad5024941406d5e23a3435fe3451" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;class&lt;/em&gt;&lt;code&gt;DecodeError&lt;/code&gt;</source>
          <target state="translated">&lt;em&gt;clase &lt;/em&gt; &lt;code&gt;DecodeError&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="493d2da0409561a8f842db049375e58399cbbc31" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;class&lt;/em&gt;&lt;code&gt;DecodedSoundFile&lt;/code&gt;</source>
          <target state="translated">&lt;em&gt;clase &lt;/em&gt; &lt;code&gt;DecodedSoundFile&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5f11bba5facbf44a5ac925cc2120da2c1bacd12b" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;class&lt;/em&gt;&lt;code&gt;Devices&lt;/code&gt;</source>
          <target state="translated">&lt;em&gt;&lt;/em&gt; &lt;code&gt;Devices&lt;/code&gt; &lt;em&gt;clase&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="ea5ba40d351330a11976ca2fd1c98f1d52fad96c" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;class&lt;/em&gt;&lt;code&gt;DuplexStream&lt;/code&gt;</source>
          <target state="translated">&lt;em&gt;clase &lt;/em&gt; &lt;code&gt;DuplexStream&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6fdc803f26299b761c09982d5b85e1a14cb1e707" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;class&lt;/em&gt;&lt;code&gt;MiniaudioError&lt;/code&gt;</source>
          <target state="translated">&lt;em&gt;clase &lt;/em&gt; &lt;code&gt;MiniaudioError&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="58d46f6f1e6ce71921a29afc632f2dbef686e5e9" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;class&lt;/em&gt;&lt;code&gt;PlaybackDevice&lt;/code&gt;</source>
          <target state="translated">&lt;em&gt;clase &lt;/em&gt; &lt;code&gt;PlaybackDevice&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e920936a1f954f4b86afd00191d011f770fcd9de" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;class&lt;/em&gt;&lt;code&gt;SoundFileInfo&lt;/code&gt;</source>
          <target state="translated">&lt;em&gt;clase &lt;/em&gt; &lt;code&gt;SoundFileInfo&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7d8f721e9c4ea33d87bbce20be24b1cb328055a4" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;class&lt;/em&gt;&lt;code&gt;StreamableSource&lt;/code&gt;</source>
          <target state="translated">&lt;em&gt;clase &lt;/em&gt; &lt;code&gt;StreamableSource&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b0a6170982da1af0f5c114fd46a50f0056a99af2" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;class&lt;/em&gt;&lt;code&gt;WavFileReadStream&lt;/code&gt;</source>
          <target state="translated">&lt;em&gt;clase &lt;/em&gt; &lt;code&gt;WavFileReadStream&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ff8267bae1feb5cac35868bc0e866e8d16edba2e" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;enum class&lt;/em&gt;&lt;code&gt;Backend&lt;/code&gt;
names:  &lt;code&gt;WASAPI&lt;/code&gt;&lt;code&gt;DSOUND&lt;/code&gt;&lt;code&gt;WINMM&lt;/code&gt;&lt;code&gt;COREAUDIO&lt;/code&gt;&lt;code&gt;SNDIO&lt;/code&gt;&lt;code&gt;AUDIO4&lt;/code&gt;&lt;code&gt;OSS&lt;/code&gt;&lt;code&gt;PULSEAUDIO&lt;/code&gt;&lt;code&gt;ALSA&lt;/code&gt;&lt;code&gt;JACK&lt;/code&gt;&lt;code&gt;AAUDIO&lt;/code&gt;&lt;code&gt;OPENSL&lt;/code&gt;&lt;code&gt;WEBAUDIO&lt;/code&gt;&lt;code&gt;NULL&lt;/code&gt;</source>
          <target state="translated">&lt;em&gt;enum class&lt;/em&gt; Nombres de &lt;code&gt;Backend&lt;/code&gt; : &lt;code&gt;WASAPI&lt;/code&gt; &lt;code&gt;DSOUND&lt;/code&gt; &lt;code&gt;WINMM&lt;/code&gt; &lt;code&gt;COREAUDIO&lt;/code&gt; &lt;code&gt;SNDIO&lt;/code&gt; &lt;code&gt;AUDIO4&lt;/code&gt; &lt;code&gt;OSS&lt;/code&gt; &lt;code&gt;PULSEAUDIO&lt;/code&gt; &lt;code&gt;ALSA&lt;/code&gt; &lt;code&gt;JACK&lt;/code&gt; &lt;code&gt;AAUDIO&lt;/code&gt; &lt;code&gt;OPENSL&lt;/code&gt; &lt;code&gt;WEBAUDIO&lt;/code&gt; &lt;code&gt;NULL&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="04eee8d2954c507a3d5f4f7c78026560acd66762" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;enum class&lt;/em&gt;&lt;code&gt;ChannelMixMode&lt;/code&gt;
names:  &lt;code&gt;RECTANGULAR&lt;/code&gt;&lt;code&gt;SIMPLE&lt;/code&gt;&lt;code&gt;CUSTOMWEIGHTS&lt;/code&gt;</source>
          <target state="translated">&lt;em&gt;enum class &lt;/em&gt; &lt;code&gt;ChannelMixMode&lt;/code&gt; nombres: &lt;code&gt;RECTANGULAR&lt;/code&gt; &lt;code&gt;SIMPLE&lt;/code&gt; &lt;code&gt;CUSTOMWEIGHTS&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cf8e734fcefbf15a109424769faf04d8b7932a75" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;enum class&lt;/em&gt;&lt;code&gt;DeviceType&lt;/code&gt;
names:  &lt;code&gt;PLAYBACK&lt;/code&gt;&lt;code&gt;CAPTURE&lt;/code&gt;&lt;code&gt;DUPLEX&lt;/code&gt;</source>
          <target state="translated">&lt;em&gt;enum class &lt;/em&gt; &lt;code&gt;DeviceType&lt;/code&gt; nombres: &lt;code&gt;PLAYBACK&lt;/code&gt; &lt;code&gt;CAPTURE&lt;/code&gt; &lt;code&gt;DUPLEX&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="bc484e13fb0d779d6baa6974b86e7351026797a2" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;enum class&lt;/em&gt;&lt;code&gt;DitherMode&lt;/code&gt;
names:  &lt;code&gt;NONE&lt;/code&gt;&lt;code&gt;RECTANGLE&lt;/code&gt;&lt;code&gt;TRIANGLE&lt;/code&gt;</source>
          <target state="translated">&lt;em&gt;enum class &lt;/em&gt; &lt;code&gt;DitherMode&lt;/code&gt; nombres: &lt;code&gt;NONE&lt;/code&gt; &lt;code&gt;RECTANGLE&lt;/code&gt; &lt;code&gt;TRIANGLE&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fd9ba8c49c2a18cc85cd69201fd2e39509adb992" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;enum class&lt;/em&gt;&lt;code&gt;FileFormat&lt;/code&gt;
names:  &lt;code&gt;UNKNOWN&lt;/code&gt;&lt;code&gt;WAV&lt;/code&gt;&lt;code&gt;FLAC&lt;/code&gt;&lt;code&gt;VORBIS&lt;/code&gt;&lt;code&gt;MP3&lt;/code&gt;</source>
          <target state="translated">&lt;em&gt;enum class&lt;/em&gt; Nombres de &lt;code&gt;FileFormat&lt;/code&gt; : &lt;code&gt;UNKNOWN&lt;/code&gt; &lt;code&gt;WAV&lt;/code&gt; &lt;code&gt;FLAC&lt;/code&gt; &lt;code&gt;VORBIS&lt;/code&gt; &lt;code&gt;MP3&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f2640c17b627d53a39079afb79f0d52f20c9ec6d" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;enum class&lt;/em&gt;&lt;code&gt;SampleFormat&lt;/code&gt;
names:  &lt;code&gt;UNKNOWN&lt;/code&gt;&lt;code&gt;UNSIGNED8&lt;/code&gt;&lt;code&gt;SIGNED16&lt;/code&gt;&lt;code&gt;SIGNED24&lt;/code&gt;&lt;code&gt;SIGNED32&lt;/code&gt;&lt;code&gt;FLOAT32&lt;/code&gt;</source>
          <target state="translated">&lt;em&gt;enum clase &lt;/em&gt; &lt;code&gt;SampleFormat&lt;/code&gt; nombres: &lt;code&gt;UNKNOWN&lt;/code&gt; &lt;code&gt;UNSIGNED8&lt;/code&gt; &lt;code&gt;SIGNED16&lt;/code&gt; &lt;code&gt;SIGNED24&lt;/code&gt; &lt;code&gt;SIGNED32&lt;/code&gt; &lt;code&gt;FLOAT32&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fe6df29335c1ca5577ecf2da261587678adcf50d" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;enum class&lt;/em&gt;&lt;code&gt;SeekOrigin&lt;/code&gt;
names:  &lt;code&gt;START&lt;/code&gt;&lt;code&gt;CURRENT&lt;/code&gt;</source>
          <target state="translated">&lt;em&gt;enum class &lt;/em&gt; &lt;code&gt;SeekOrigin&lt;/code&gt; nombres: &lt;code&gt;START&lt;/code&gt; &lt;code&gt;CURRENT&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fd2732775876be844985474c957bbb62758bbb0e" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;enum class&lt;/em&gt;&lt;code&gt;ThreadPriority&lt;/code&gt;
names:  &lt;code&gt;IDLE&lt;/code&gt;&lt;code&gt;LOWEST&lt;/code&gt;&lt;code&gt;LOW&lt;/code&gt;&lt;code&gt;NORMAL&lt;/code&gt;&lt;code&gt;HIGH&lt;/code&gt;&lt;code&gt;HIGHEST&lt;/code&gt;&lt;code&gt;REALTIME&lt;/code&gt;</source>
          <target state="translated">&lt;em&gt;enumeraci&amp;oacute;n de clase &lt;/em&gt; &lt;code&gt;ThreadPriority&lt;/code&gt; nombres: &lt;code&gt;IDLE&lt;/code&gt; &lt;code&gt;LOWEST&lt;/code&gt; &lt;code&gt;LOW&lt;/code&gt; &lt;code&gt;NORMAL&lt;/code&gt; &lt;code&gt;HIGH&lt;/code&gt; &lt;code&gt;HIGHEST&lt;/code&gt; &lt;code&gt;REALTIME&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9f3461a3c2e31478d5ab381ae7b2bedc1c9b2eff" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;function&lt;/em&gt;&lt;code&gt;convert_frames (from_fmt: miniaudio.SampleFormat, from_numchannels: int, from_samplerate: int, sourcedata: bytes, to_fmt: miniaudio.SampleFormat, to_numchannels: int, to_samplerate: int) -&amp;gt; bytearray&lt;/code&gt;</source>
          <target state="translated">&lt;em&gt;funci&amp;oacute;n &lt;/em&gt; &lt;code&gt;convert_frames (from_fmt: miniaudio.SampleFormat, from_numchannels: int, from_samplerate: int, sourcedata: bytes, to_fmt: miniaudio.SampleFormat, to_numchannels: int, to_samplerate: int) -&amp;gt; bytearray&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c6ca0d8942bed2885e6a50534170313b7024bd51" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;function&lt;/em&gt;&lt;code&gt;convert_sample_format (from_fmt: miniaudio.SampleFormat, sourcedata: bytes, to_fmt: miniaudio.SampleFormat, dither: miniaudio.DitherMode = &amp;lt;DitherMode.NONE: 0&amp;gt;) -&amp;gt; bytearray&lt;/code&gt;</source>
          <target state="translated">&lt;em&gt;funci&amp;oacute;n &lt;/em&gt; &lt;code&gt;convert_sample_format (from_fmt: miniaudio.SampleFormat, sourcedata: bytes, to_fmt: miniaudio.SampleFormat, dither: miniaudio.DitherMode = &amp;lt;DitherMode.NONE: 0&amp;gt;) -&amp;gt; bytearray&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="625edaeaac51c5e8ab28dabfa11ad90cd4a78575" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;function&lt;/em&gt;&lt;code&gt;decode (data: bytes, output_format: miniaudio.SampleFormat = &amp;lt;SampleFormat.SIGNED16: 2&amp;gt;, nchannels: int = 2, sample_rate: int = 44100, dither: miniaudio.DitherMode = &amp;lt;DitherMode.NONE: 0&amp;gt;) -&amp;gt; miniaudio.DecodedSoundFile&lt;/code&gt;</source>
          <target state="translated">&lt;em&gt;&lt;/em&gt; &lt;code&gt;decode (data: bytes, output_format: miniaudio.SampleFormat = &amp;lt;SampleFormat.SIGNED16: 2&amp;gt;, nchannels: int = 2, sample_rate: int = 44100, dither: miniaudio.DitherMode = &amp;lt;DitherMode.NONE: 0&amp;gt;) -&amp;gt; miniaudio.DecodedSoundFile&lt;/code&gt; &lt;em&gt;funci&amp;oacute;n &lt;/em&gt;(datos: bytes, formato_de_salida: miniaudio.SampleFormat = &amp;lt;SampleFormat.SIGNED16: 2&amp;gt;, nchannels: int = 2, sample_rate: int = 44100, dither: miniaudio.DitherMode = &amp;lt;DitherMode.NONE: 0&amp;gt;) -&amp;gt; miniaudio .DecodedSoundFile</target>
        </trans-unit>
        <trans-unit id="09f84fe3085974d3a87efdd245569f860a8af4c5" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;function&lt;/em&gt;&lt;code&gt;decode_file (filename: str, output_format: miniaudio.SampleFormat = &amp;lt;SampleFormat.SIGNED16: 2&amp;gt;, nchannels: int = 2, sample_rate: int = 44100, dither: miniaudio.DitherMode = &amp;lt;DitherMode.NONE: 0&amp;gt;) -&amp;gt; miniaudio.DecodedSoundFile&lt;/code&gt;</source>
          <target state="translated">&lt;em&gt;function &lt;/em&gt; &lt;code&gt;decode_file (filename: str, output_format: miniaudio.SampleFormat = &amp;lt;SampleFormat.SIGNED16: 2&amp;gt;, nchannels: int = 2, sample_rate: int = 44100, dither: miniaudio.DitherMode = &amp;lt;DitherMode.NONE: 0&amp;gt;) -&amp;gt; miniaudio.DecodedSoundFile&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="21aace310cc2b1626114af0c8c2b589734f30c8c" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;function&lt;/em&gt;&lt;code&gt;flac_get_file_info (filename: str) -&amp;gt; miniaudio.SoundFileInfo&lt;/code&gt;</source>
          <target state="translated">&lt;em&gt;funci&amp;oacute;n &lt;/em&gt; &lt;code&gt;flac_get_file_info (filename: str) -&amp;gt; miniaudio.SoundFileInfo&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4002ab4c2bdfd04c06a597bd64f40911c48c5018" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;function&lt;/em&gt;&lt;code&gt;flac_get_info (data: bytes) -&amp;gt; miniaudio.SoundFileInfo&lt;/code&gt;</source>
          <target state="translated">&lt;em&gt;funci&amp;oacute;n &lt;/em&gt; &lt;code&gt;flac_get_info (data: bytes) -&amp;gt; miniaudio.SoundFileInfo&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="15f0b23ff2407295407c57fd83cd6ad803abaf55" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;function&lt;/em&gt;&lt;code&gt;flac_read_f32 (data: bytes) -&amp;gt; miniaudio.DecodedSoundFile&lt;/code&gt;</source>
          <target state="translated">&lt;em&gt;funci&amp;oacute;n &lt;/em&gt; &lt;code&gt;flac_read_f32 (data: bytes) -&amp;gt; miniaudio.DecodedSoundFile&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ccd0dea213d7f84c6c0d5fd596f0c9ec7fac0531" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;function&lt;/em&gt;&lt;code&gt;flac_read_file_f32 (filename: str) -&amp;gt; miniaudio.DecodedSoundFile&lt;/code&gt;</source>
          <target state="translated">&lt;em&gt;funci&amp;oacute;n &lt;/em&gt; &lt;code&gt;flac_read_file_f32 (filename: str) -&amp;gt; miniaudio.DecodedSoundFile&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="aa097a69a261882b066c894ed93e50ac2a2a0fa6" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;function&lt;/em&gt;&lt;code&gt;flac_read_file_s16 (filename: str) -&amp;gt; miniaudio.DecodedSoundFile&lt;/code&gt;</source>
          <target state="translated">&lt;em&gt;funci&amp;oacute;n &lt;/em&gt; &lt;code&gt;flac_read_file_s16 (filename: str) -&amp;gt; miniaudio.DecodedSoundFile&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cd72dbdc2ab14b547fad454ab3938aceb4c6bfc8" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;function&lt;/em&gt;&lt;code&gt;flac_read_file_s32 (filename: str) -&amp;gt; miniaudio.DecodedSoundFile&lt;/code&gt;</source>
          <target state="translated">&lt;em&gt;funci&amp;oacute;n &lt;/em&gt; &lt;code&gt;flac_read_file_s32 (filename: str) -&amp;gt; miniaudio.DecodedSoundFile&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="99c1a59f1077689a5993b7ebf400d00bb05d5531" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;function&lt;/em&gt;&lt;code&gt;flac_read_s16 (data: bytes) -&amp;gt; miniaudio.DecodedSoundFile&lt;/code&gt;</source>
          <target state="translated">&lt;em&gt;funci&amp;oacute;n &lt;/em&gt; &lt;code&gt;flac_read_s16 (data: bytes) -&amp;gt; miniaudio.DecodedSoundFile&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="43e231c7ad6c785b85045708dee3d767c70e52da" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;function&lt;/em&gt;&lt;code&gt;flac_read_s32 (data: bytes) -&amp;gt; miniaudio.DecodedSoundFile&lt;/code&gt;</source>
          <target state="translated">&lt;em&gt;funci&amp;oacute;n &lt;/em&gt; &lt;code&gt;flac_read_s32 (data: bytes) -&amp;gt; miniaudio.DecodedSoundFile&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7f07e582b9c7cb4911ce9d73c6ec6691adaa9d3b" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;function&lt;/em&gt;&lt;code&gt;flac_stream_file (filename: str, frames_to_read: int = 1024, seek_frame: int = 0) -&amp;gt; Generator[array.array, NoneType, NoneType]&lt;/code&gt;</source>
          <target state="translated">&lt;em&gt;function &lt;/em&gt; &lt;code&gt;flac_stream_file (filename: str, frames_to_read: int = 1024, seek_frame: int = 0) -&amp;gt; Generator[array.array, NoneType, NoneType]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f055c696711ccc03e501d26e71c6cb406a9fa96f" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;function&lt;/em&gt;&lt;code&gt;get_file_info (filename: str) -&amp;gt; miniaudio.SoundFileInfo&lt;/code&gt;</source>
          <target state="translated">&lt;em&gt;funci&amp;oacute;n &lt;/em&gt; &lt;code&gt;get_file_info (filename: str) -&amp;gt; miniaudio.SoundFileInfo&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cef6de0b94d4e6ed12a7206cd4ffca6f6cc2c4df" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;function&lt;/em&gt;&lt;code&gt;mp3_get_file_info (filename: str) -&amp;gt; miniaudio.SoundFileInfo&lt;/code&gt;</source>
          <target state="translated">&lt;em&gt;funci&amp;oacute;n &lt;/em&gt; &lt;code&gt;mp3_get_file_info (filename: str) -&amp;gt; miniaudio.SoundFileInfo&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="73fa64ae0399eb8357b6b84fe10a80e5061024c3" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;function&lt;/em&gt;&lt;code&gt;mp3_get_info (data: bytes) -&amp;gt; miniaudio.SoundFileInfo&lt;/code&gt;</source>
          <target state="translated">&lt;em&gt;funci&amp;oacute;n &lt;/em&gt; &lt;code&gt;mp3_get_info (data: bytes) -&amp;gt; miniaudio.SoundFileInfo&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="db48b57dca9143d6403a84e6a6819598a4cae0d6" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;function&lt;/em&gt;&lt;code&gt;mp3_read_f32 (data: bytes, want_nchannels: int = 0, want_sample_rate: int = 0) -&amp;gt; miniaudio.DecodedSoundFile&lt;/code&gt;</source>
          <target state="translated">&lt;em&gt;funci&amp;oacute;n &lt;/em&gt; &lt;code&gt;mp3_read_f32 (data: bytes, want_nchannels: int = 0, want_sample_rate: int = 0) -&amp;gt; miniaudio.DecodedSoundFile&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6d5b10ed15cc1ebc6b67ff20f74b7eb1fbb96186" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;function&lt;/em&gt;&lt;code&gt;mp3_read_file_f32 (filename: str, want_nchannels: int = 0, want_sample_rate: int = 0) -&amp;gt; miniaudio.DecodedSoundFile&lt;/code&gt;</source>
          <target state="translated">&lt;em&gt;function &lt;/em&gt; &lt;code&gt;mp3_read_file_f32 (filename: str, want_nchannels: int = 0, want_sample_rate: int = 0) -&amp;gt; miniaudio.DecodedSoundFile&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="631749c29dc8b243095a26dbed30124fb1b60a9a" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;function&lt;/em&gt;&lt;code&gt;mp3_read_file_s16 (filename: str, want_nchannels: int = 0, want_sample_rate: int = 0) -&amp;gt; miniaudio.DecodedSoundFile&lt;/code&gt;</source>
          <target state="translated">&lt;em&gt;function &lt;/em&gt; &lt;code&gt;mp3_read_file_s16 (filename: str, want_nchannels: int = 0, want_sample_rate: int = 0) -&amp;gt; miniaudio.DecodedSoundFile&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="60bc4894a2464344a4b83a0d8971250cd06011f4" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;function&lt;/em&gt;&lt;code&gt;mp3_read_s16 (data: bytes, want_nchannels: int = 0, want_sample_rate: int = 0) -&amp;gt; miniaudio.DecodedSoundFile&lt;/code&gt;</source>
          <target state="translated">&lt;em&gt;funci&amp;oacute;n &lt;/em&gt; &lt;code&gt;mp3_read_s16 (data: bytes, want_nchannels: int = 0, want_sample_rate: int = 0) -&amp;gt; miniaudio.DecodedSoundFile&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="83ce34d6c46e6770464bbc82d35d7c066f9dbd16" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;function&lt;/em&gt;&lt;code&gt;mp3_stream_file (filename: str, frames_to_read: int = 1024, seek_frame: int = 0) -&amp;gt; Generator[array.array, NoneType, NoneType]&lt;/code&gt;</source>
          <target state="translated">&lt;em&gt;function &lt;/em&gt; &lt;code&gt;mp3_stream_file (filename: str, frames_to_read: int = 1024, seek_frame: int = 0) -&amp;gt; Generator[array.array, NoneType, NoneType]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4b86667b17f09d8484885d44f94900d31e4884ba" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;function&lt;/em&gt;&lt;code&gt;read_file (filename: str, convert_to_16bit: bool = False) -&amp;gt; miniaudio.DecodedSoundFile&lt;/code&gt;</source>
          <target state="translated">&lt;em&gt;funci&amp;oacute;n &lt;/em&gt; &lt;code&gt;read_file (filename: str, convert_to_16bit: bool = False) -&amp;gt; miniaudio.DecodedSoundFile&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="bfd0157ea09e189b84f6365e98604fe05f9585b2" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;function&lt;/em&gt;&lt;code&gt;stream_any (source: miniaudio.StreamableSource, source_format: miniaudio.FileFormat = &amp;lt;FileFormat.UNKNOWN: 0&amp;gt;, output_format: miniaudio.SampleFormat = &amp;lt;SampleFormat.SIGNED16: 2&amp;gt;, nchannels: int = 2, sample_rate: int = 44100, frames_to_read: int = 1024, dither: miniaudio.DitherMode = &amp;lt;DitherMode.NONE: 0&amp;gt;, seek_frame: int = 0) -&amp;gt; Generator[array.array, int, NoneType]&lt;/code&gt;</source>
          <target state="translated">&lt;em&gt;funci&amp;oacute;n &lt;/em&gt; &lt;code&gt;stream_any (source: miniaudio.StreamableSource, source_format: miniaudio.FileFormat = &amp;lt;FileFormat.UNKNOWN: 0&amp;gt;, output_format: miniaudio.SampleFormat = &amp;lt;SampleFormat.SIGNED16: 2&amp;gt;, nchannels: int = 2, sample_rate: int = 44100, frames_to_read: int = 1024, dither: miniaudio.DitherMode = &amp;lt;DitherMode.NONE: 0&amp;gt;, seek_frame: int = 0) -&amp;gt; Generator[array.array, int, NoneType]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="97531e6ad9ff94052688e5c33dc637c270690903" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;function&lt;/em&gt;&lt;code&gt;stream_file (filename: str, output_format: miniaudio.SampleFormat = &amp;lt;SampleFormat.SIGNED16: 2&amp;gt;, nchannels: int = 2, sample_rate: int = 44100, frames_to_read: int = 1024, dither: miniaudio.DitherMode = &amp;lt;DitherMode.NONE: 0&amp;gt;, seek_frame: int = 0) -&amp;gt; Generator[array.array, int, NoneType]&lt;/code&gt;</source>
          <target state="translated">&lt;em&gt;function &lt;/em&gt; &lt;code&gt;stream_file (filename: str, output_format: miniaudio.SampleFormat = &amp;lt;SampleFormat.SIGNED16: 2&amp;gt;, nchannels: int = 2, sample_rate: int = 44100, frames_to_read: int = 1024, dither: miniaudio.DitherMode = &amp;lt;DitherMode.NONE: 0&amp;gt;, seek_frame: int = 0) -&amp;gt; Generator[array.array, int, NoneType]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="733c68b515e65df9d1c8e485bfd514c48bd045ea" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;function&lt;/em&gt;&lt;code&gt;stream_memory (data: bytes, output_format: miniaudio.SampleFormat = &amp;lt;SampleFormat.SIGNED16: 2&amp;gt;, nchannels: int = 2, sample_rate: int = 44100, frames_to_read: int = 1024, dither: miniaudio.DitherMode = &amp;lt;DitherMode.NONE: 0&amp;gt;) -&amp;gt; Generator[array.array, int, NoneType]&lt;/code&gt;</source>
          <target state="translated">&lt;em&gt;function &lt;/em&gt; &lt;code&gt;stream_memory (data: bytes, output_format: miniaudio.SampleFormat = &amp;lt;SampleFormat.SIGNED16: 2&amp;gt;, nchannels: int = 2, sample_rate: int = 44100, frames_to_read: int = 1024, dither: miniaudio.DitherMode = &amp;lt;DitherMode.NONE: 0&amp;gt;) -&amp;gt; Generator[array.array, int, NoneType]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="29f63b6c1c8585c68a28025fed57dcc0d6257082" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;function&lt;/em&gt;&lt;code&gt;vorbis_get_file_info (filename: str) -&amp;gt; miniaudio.SoundFileInfo&lt;/code&gt;</source>
          <target state="translated">&lt;em&gt;funci&amp;oacute;n &lt;/em&gt; &lt;code&gt;vorbis_get_file_info (filename: str) -&amp;gt; miniaudio.SoundFileInfo&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="64d5bfda26028c628eaccc410e6034d78066051c" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;function&lt;/em&gt;&lt;code&gt;vorbis_get_info (data: bytes) -&amp;gt; miniaudio.SoundFileInfo&lt;/code&gt;</source>
          <target state="translated">&lt;em&gt;funci&amp;oacute;n &lt;/em&gt; &lt;code&gt;vorbis_get_info (data: bytes) -&amp;gt; miniaudio.SoundFileInfo&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e75d447aeb667024cb6bb8e7c28639d22a87b88d" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;function&lt;/em&gt;&lt;code&gt;vorbis_read (data: bytes) -&amp;gt; miniaudio.DecodedSoundFile&lt;/code&gt;</source>
          <target state="translated">&lt;em&gt;funci&amp;oacute;n &lt;/em&gt; &lt;code&gt;vorbis_read (data: bytes) -&amp;gt; miniaudio.DecodedSoundFile&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3b0292788fa5d3f39114a804492c2715d94aeda4" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;function&lt;/em&gt;&lt;code&gt;vorbis_read_file (filename: str) -&amp;gt; miniaudio.DecodedSoundFile&lt;/code&gt;</source>
          <target state="translated">&lt;em&gt;funci&amp;oacute;n &lt;/em&gt; &lt;code&gt;vorbis_read_file (filename: str) -&amp;gt; miniaudio.DecodedSoundFile&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="aca49fbd14919f0f9060f58d91fcb5ad9d398ed6" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;function&lt;/em&gt;&lt;code&gt;vorbis_stream_file (filename: str, seek_frame: int = 0) -&amp;gt; Generator[array.array, NoneType, NoneType]&lt;/code&gt;</source>
          <target state="translated">&lt;em&gt;funci&amp;oacute;n &lt;/em&gt; &lt;code&gt;vorbis_stream_file (filename: str, seek_frame: int = 0) -&amp;gt; Generator[array.array, NoneType, NoneType]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fe529c8f6a10a9377668c32c0e5f92aa63a6783b" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;function&lt;/em&gt;&lt;code&gt;wav_get_file_info (filename: str) -&amp;gt; miniaudio.SoundFileInfo&lt;/code&gt;</source>
          <target state="translated">&lt;em&gt;funci&amp;oacute;n &lt;/em&gt; &lt;code&gt;wav_get_file_info (filename: str) -&amp;gt; miniaudio.SoundFileInfo&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8396d71f96e099a69da12ecbbda402433667d4a3" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;function&lt;/em&gt;&lt;code&gt;wav_get_info (data: bytes) -&amp;gt; miniaudio.SoundFileInfo&lt;/code&gt;</source>
          <target state="translated">&lt;em&gt;funci&amp;oacute;n &lt;/em&gt; &lt;code&gt;wav_get_info (data: bytes) -&amp;gt; miniaudio.SoundFileInfo&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f571956a5d8cf77b436dc839528ecead3ae28194" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;function&lt;/em&gt;&lt;code&gt;wav_read_f32 (data: bytes) -&amp;gt; miniaudio.DecodedSoundFile&lt;/code&gt;</source>
          <target state="translated">&lt;em&gt;funci&amp;oacute;n &lt;/em&gt; &lt;code&gt;wav_read_f32 (data: bytes) -&amp;gt; miniaudio.DecodedSoundFile&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ac5e5b76f2b07e8111552c2ff283843b7b9eadac" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;function&lt;/em&gt;&lt;code&gt;wav_read_file_f32 (filename: str) -&amp;gt; miniaudio.DecodedSoundFile&lt;/code&gt;</source>
          <target state="translated">&lt;em&gt;function &lt;/em&gt; &lt;code&gt;wav_read_file_f32 (filename: str) -&amp;gt; miniaudio.DecodedSoundFile&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b3d7234713237a56b96295fd7e29d38c35528f02" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;function&lt;/em&gt;&lt;code&gt;wav_read_file_s16 (filename: str) -&amp;gt; miniaudio.DecodedSoundFile&lt;/code&gt;</source>
          <target state="translated">&lt;em&gt;function &lt;/em&gt; &lt;code&gt;wav_read_file_s16 (filename: str) -&amp;gt; miniaudio.DecodedSoundFile&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2f6b13e003ac5493bd61f66d163458af5a5caf1d" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;function&lt;/em&gt;&lt;code&gt;wav_read_file_s32 (filename: str) -&amp;gt; miniaudio.DecodedSoundFile&lt;/code&gt;</source>
          <target state="translated">&lt;em&gt;funci&amp;oacute;n &lt;/em&gt; &lt;code&gt;wav_read_file_s32 (filename: str) -&amp;gt; miniaudio.DecodedSoundFile&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6c20865557f468a9175ca5224c9092b41e6cf1a2" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;function&lt;/em&gt;&lt;code&gt;wav_read_s16 (data: bytes) -&amp;gt; miniaudio.DecodedSoundFile&lt;/code&gt;</source>
          <target state="translated">&lt;em&gt;funci&amp;oacute;n &lt;/em&gt; &lt;code&gt;wav_read_s16 (data: bytes) -&amp;gt; miniaudio.DecodedSoundFile&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="803de3783a5c1478245a3b75fd074f8c2b3a3a3b" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;function&lt;/em&gt;&lt;code&gt;wav_read_s32 (data: bytes) -&amp;gt; miniaudio.DecodedSoundFile&lt;/code&gt;</source>
          <target state="translated">&lt;em&gt;funci&amp;oacute;n &lt;/em&gt; &lt;code&gt;wav_read_s32 (data: bytes) -&amp;gt; miniaudio.DecodedSoundFile&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="61eaa464cb06f56f36c9beec95742d3735523746" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;function&lt;/em&gt;&lt;code&gt;wav_stream_file (filename: str, frames_to_read: int = 1024, seek_frame: int = 0) -&amp;gt; Generator[array.array, NoneType, NoneType]&lt;/code&gt;</source>
          <target state="translated">&lt;em&gt;function &lt;/em&gt; &lt;code&gt;wav_stream_file (filename: str, frames_to_read: int = 1024, seek_frame: int = 0) -&amp;gt; Generator[array.array, NoneType, NoneType]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7b86564b074d01e1f3d967efc21e00340643bffe" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;function&lt;/em&gt;&lt;code&gt;wav_write_file (filename: str, sound: miniaudio.DecodedSoundFile)&lt;/code&gt;</source>
          <target state="translated">&lt;em&gt;funci&amp;oacute;n &lt;/em&gt; &lt;code&gt;wav_write_file (filename: str, sound: miniaudio.DecodedSoundFile)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a0ebedef07c23da59b8cb901f73ce3ae64aff91a" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;method&lt;/em&gt;&lt;code&gt;close (self)&lt;/code&gt;</source>
          <target state="translated">&lt;em&gt;m&amp;eacute;todo de &lt;/em&gt; &lt;code&gt;close (self)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9a8ed5f8825a3771f5ef950ceb4c7bf320f329aa" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;method&lt;/em&gt;&lt;code&gt;get_captures (self) -&amp;gt; List[Dict[str, Any]]&lt;/code&gt;</source>
          <target state="translated">&lt;em&gt;m&amp;eacute;todo &lt;/em&gt; &lt;code&gt;get_captures (self) -&amp;gt; List[Dict[str, Any]]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="852f6bbecd94418066b5f3159994e6165f0eb836" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;method&lt;/em&gt;&lt;code&gt;get_playbacks (self) -&amp;gt; List[Dict[str, Any]]&lt;/code&gt;</source>
          <target state="translated">&lt;em&gt;m&amp;eacute;todo &lt;/em&gt; &lt;code&gt;get_playbacks (self) -&amp;gt; List[Dict[str, Any]]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="019b8833d05c2ee7c09db536ef44ad4fe9ce8f6b" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;method&lt;/em&gt;&lt;code&gt;read (self, amount: int = 9223372036854775807) -&amp;gt; Union[bytes, NoneType]&lt;/code&gt;</source>
          <target state="translated">&lt;em&gt;m&amp;eacute;todo &lt;/em&gt; &lt;code&gt;read (self, amount: int = 9223372036854775807) -&amp;gt; Union[bytes, NoneType]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="78a2cf50ae902687518c9d20aeb232562439eee4" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;method&lt;/em&gt;&lt;code&gt;start (self, callback_generator: Generator[NoneType, Union[bytes, array.array], NoneType], stop_callback: Union[Callable, NoneType] = None)&lt;/code&gt;</source>
          <target state="translated">&lt;em&gt;m&amp;eacute;todo &lt;/em&gt; &lt;code&gt;start (self, callback_generator: Generator[NoneType, Union[bytes, array.array], NoneType], stop_callback: Union[Callable, NoneType] = None)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5e4d2a5e5d473afc2e4b3fcb747ff92a1f384016" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;method&lt;/em&gt;&lt;code&gt;start (self, callback_generator: Generator[Union[bytes, array.array], Union[bytes, array.array], NoneType], stop_callback: Union[Callable, NoneType] = None)&lt;/code&gt;</source>
          <target state="translated">&lt;em&gt;m&amp;eacute;todo &lt;/em&gt; &lt;code&gt;start (self, callback_generator: Generator[Union[bytes, array.array], Union[bytes, array.array], NoneType], stop_callback: Union[Callable, NoneType] = None)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6c45d195bc05c066bd21319de222d7409968da5b" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;method&lt;/em&gt;&lt;code&gt;start (self, callback_generator: Generator[Union[bytes, array.array], int, NoneType], stop_callback: Union[Callable, NoneType] = None)&lt;/code&gt;</source>
          <target state="translated">&lt;em&gt;m&amp;eacute;todo &lt;/em&gt; &lt;code&gt;start (self, callback_generator: Generator[Union[bytes, array.array], int, NoneType], stop_callback: Union[Callable, NoneType] = None)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4c5020f513dae79556714e04c0f2fd6b469aae02" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;method&lt;/em&gt;&lt;code&gt;stop (self)&lt;/code&gt;</source>
          <target state="translated">&lt;em&gt;m&amp;eacute;todo de &lt;/em&gt; &lt;code&gt;stop (self)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d93d10ff0fbef1b4aa0ddc24e10e907746d3c85a" translate="yes" xml:space="preserve">
          <source>API</source>
          <target state="translated">API</target>
        </trans-unit>
        <trans-unit id="e35f42f2c9c83d3d01b06737755f163bc64ebd1f" translate="yes" xml:space="preserve">
          <source>An IO stream that reads as a .wav file, and which gets its pcm samples from the provided producer</source>
          <target state="translated">Un flujo IO que se lee como un archivo .wav,y que obtiene sus muestras pcm del productor proporcionado</target>
        </trans-unit>
        <trans-unit id="a96b55bc42b80ac3452926b3b4d2db0c84b42041" translate="yes" xml:space="preserve">
          <source>An audio device provided by miniaudio, for audio capture (recording).</source>
          <target state="translated">Un dispositivo de audio proporcionado por miniaudio,para la captura (grabación)de audio.</target>
        </trans-unit>
        <trans-unit id="2187381720d919c285f1dc7bb60bb7242fa2271c" translate="yes" xml:space="preserve">
          <source>An audio device provided by miniaudio, for audio playback.</source>
          <target state="translated">Un dispositivo de audio provisto por miniaudio,para la reproducción de audio.</target>
        </trans-unit>
        <trans-unit id="67617ae27f24012fc8940a4e70e106a4defc201e" translate="yes" xml:space="preserve">
          <source>Audio file format</source>
          <target state="translated">Formato de archivo de audio</target>
        </trans-unit>
        <trans-unit id="67eb0fbdc9915503739957021fa93d965901ce11" translate="yes" xml:space="preserve">
          <source>Close the file</source>
          <target state="translated">Cierra el archivo</target>
        </trans-unit>
        <trans-unit id="5bb74c6cc926d528b1efe36584e07de893096e3b" translate="yes" xml:space="preserve">
          <source>Contains various properties and also the PCM frames of a fully decoded audio file.</source>
          <target state="translated">Contiene varias propiedades y también los fotogramas PCM de un archivo de audio totalmente decodificado.</target>
        </trans-unit>
        <trans-unit id="a725cb27e369ad13a336233973ad20749b54416c" translate="yes" xml:space="preserve">
          <source>Contains various properties of an audio file.</source>
          <target state="translated">Contiene varias propiedades de un archivo de audio.</target>
        </trans-unit>
        <trans-unit id="ec68525aa97273376b12d9585f323e9a83e16f9a" translate="yes" xml:space="preserve">
          <source>Convenience function that returns a generator to decode and stream any source of encoded audio
data (such as a network stream). Stream result is chunks of raw PCM samples in the chosen format. If
you send() a number into the generator rather than just using next() on it, you'll get that given
number of frames, instead of the default configured amount. This is particularly useful to plug this
stream into an audio device callback that wants a variable number of frames per call.</source>
          <target state="translated">Función de conveniencia que devuelve un generador para decodificar y transmitir cualquier fuente de datos de audio codificados (como un flujo de red).El resultado del flujo son trozos de muestras PCM sin procesar en el formato elegido.Si envía()un número al generador en lugar de usar next()en él,obtendrá ese número de fotogramas dado,en lugar de la cantidad configurada por defecto.Esto es particularmente útil para conectar este flujo a una llamada de un dispositivo de audio que quiere un número variable de cuadros por llamada.</target>
        </trans-unit>
        <trans-unit id="4170ec7ebe1621e2da337b4e90124fb014ca842c" translate="yes" xml:space="preserve">
          <source>Convenience function to decode any supported audio file in memory to raw PCM samples in your
chosen format.</source>
          <target state="translated">Función de conveniencia para decodificar cualquier archivo de audio soportado en la memoria a muestras PCM sin procesar en el formato elegido.</target>
        </trans-unit>
        <trans-unit id="cdc19fa5c41ec99df63990549d952353592715dd" translate="yes" xml:space="preserve">
          <source>Convenience function to decode any supported audio file to raw PCM samples in your chosen format.</source>
          <target state="translated">Función de conveniencia para decodificar cualquier archivo de audio soportado a muestras PCM sin procesar en el formato elegido.</target>
        </trans-unit>
        <trans-unit id="dbf8faf6a83cd855867e2857a83ee9d10cd267e9" translate="yes" xml:space="preserve">
          <source>Convenience generator function to decode and stream any supported audio file as chunks of raw PCM
samples in the chosen format. If you send() a number into the generator rather than just using
next() on it, you'll get that given number of frames, instead of the default configured amount. This
is particularly useful to plug this stream into an audio device callback that wants a variable
number of frames per call.</source>
          <target state="translated">Función de generador de conveniencia para decodificar y transmitir cualquier archivo de audio soportado como trozos de muestras PCM sin procesar en el formato elegido.Si envías()un número al generador en lugar de usar next()en él,obtendrás ese número de fotogramas dado,en lugar de la cantidad configurada por defecto.Esto es particularmente útil para conectar este flujo a una llamada de un dispositivo de audio que quiere un número variable de cuadros por llamada.</target>
        </trans-unit>
        <trans-unit id="d2a5c7010c1b47ff6fd2e31d527bba28bf276d85" translate="yes" xml:space="preserve">
          <source>Convenience generator function to decode and stream any supported audio file in memory as chunks
of raw PCM samples in the chosen format. If you send() a number into the generator rather than just
using next() on it, you'll get that given number of frames, instead of the default configured
amount. This is particularly useful to plug this stream into an audio device callback that wants a
variable number of frames per call.</source>
          <target state="translated">Función de generador de conveniencia para decodificar y transmitir cualquier archivo de audio soportado en la memoria como trozos de muestras PCM sin procesar en el formato elegido.Si envías()un número al generador en lugar de usar next()en él,obtendrás ese número de fotogramas dado,en lugar de la cantidad configurada por defecto.Esto es particularmente útil para conectar este flujo a una llamada de un dispositivo de audio que quiere un número variable de cuadros por llamada.</target>
        </trans-unit>
        <trans-unit id="e75b2dbffa0dcb5c724ebefda161eb865eb07f0c" translate="yes" xml:space="preserve">
          <source>Convert a raw buffer of pcm samples to another sample format. The result is returned as another
raw pcm sample buffer</source>
          <target state="translated">Convierte un búfer crudo de muestras pcm a otro formato de muestra.El resultado se devuelve como otra memoria intermedia de muestras pcm en bruto</target>
        </trans-unit>
        <trans-unit id="2f648078bc3ca1dd7c22b960668a496fbac2bac8" translate="yes" xml:space="preserve">
          <source>Convert audio frames in source sample format with a certain number of channels, to another sample
format and possibly down/upmixing the number of channels as well.</source>
          <target state="translated">Convertir los cuadros de audio en el formato de muestra de la fuente con un cierto número de canales,a otro formato de muestra y posiblemente bajando o subiendo el número de canales también.</target>
        </trans-unit>
        <trans-unit id="eb01bf04c9a0e8a71c45816513df424f1c7ffedb" translate="yes" xml:space="preserve">
          <source>Examples</source>
          <target state="translated">Ejemplos</target>
        </trans-unit>
        <trans-unit id="495d3d11b082af613295e96fc2e7ac624f5ad01b" translate="yes" xml:space="preserve">
          <source>Fetch some information about the audio data (flac format).</source>
          <target state="translated">Busca información sobre los datos de audio (formato flac).</target>
        </trans-unit>
        <trans-unit id="294ed8d86f860651e60548bc652abe9b84dfc600" translate="yes" xml:space="preserve">
          <source>Fetch some information about the audio data (mp3 format).</source>
          <target state="translated">Busca información sobre los datos de audio (formato mp3).</target>
        </trans-unit>
        <trans-unit id="ced6b4c85e690d92baec62d4dfe514019f3a2a20" translate="yes" xml:space="preserve">
          <source>Fetch some information about the audio data (vorbis format).</source>
          <target state="translated">Busca información sobre los datos de audio (formato vorbis).</target>
        </trans-unit>
        <trans-unit id="0d89f8d3547aa53539b31847b65157793405af1b" translate="yes" xml:space="preserve">
          <source>Fetch some information about the audio data (wav format).</source>
          <target state="translated">Busca información sobre los datos de audio (formato wav).</target>
        </trans-unit>
        <trans-unit id="3d356649a7d770a2b0f1a0fadae14ab9ddd521a1" translate="yes" xml:space="preserve">
          <source>Fetch some information about the audio file (flac format).</source>
          <target state="translated">Busca algo de información sobre el archivo de audio (formato flac).</target>
        </trans-unit>
        <trans-unit id="a8514d85a4dd55de27a3219cb278d8fb131f6bef" translate="yes" xml:space="preserve">
          <source>Fetch some information about the audio file (mp3 format).</source>
          <target state="translated">Busca algo de información sobre el archivo de audio (formato mp3).</target>
        </trans-unit>
        <trans-unit id="389f188fcbfd725afd09c03372139258c03c7a24" translate="yes" xml:space="preserve">
          <source>Fetch some information about the audio file (vorbis format).</source>
          <target state="translated">Busca algo de información sobre el archivo de audio (formato vorbis).</target>
        </trans-unit>
        <trans-unit id="2e4202eb9f6e6dcd4cac937c7efcafd684b6457f" translate="yes" xml:space="preserve">
          <source>Fetch some information about the audio file (wav format).</source>
          <target state="translated">Busca algo de información sobre el archivo de audio (formato wav).</target>
        </trans-unit>
        <trans-unit id="186ed9dbd2bf579a770468333d387f501ffb7752" translate="yes" xml:space="preserve">
          <source>Fetch some information about the audio file.</source>
          <target state="translated">Busca algo de información sobre el archivo de audio.</target>
        </trans-unit>
        <trans-unit id="5a4f2e24777a7903f8fe536251fe32846c1b5bfd" translate="yes" xml:space="preserve">
          <source>Get a list of capture devices and some details about them</source>
          <target state="translated">Consigue una lista de dispositivos de captura y algunos detalles sobre ellos</target>
        </trans-unit>
        <trans-unit id="b8b1446c96fd3f5b208188010ebf095a045ce634" translate="yes" xml:space="preserve">
          <source>Get a list of playback devices and some details about them</source>
          <target state="translated">Consigue una lista de dispositivos de reproducción y algunos detalles sobre ellos</target>
        </trans-unit>
        <trans-unit id="99c5a58c64a0dcefab5c129eba4b7ca9bd605bf3" translate="yes" xml:space="preserve">
          <source>Halt playback or capture and close down the device. If you use the device as a context manager,
it will be closed automatically.</source>
          <target state="translated">Detenga la reproducción o la captura y cierre el dispositivo.Si utiliza el dispositivo como gestor de contexto,se cerrará automáticamente.</target>
        </trans-unit>
        <trans-unit id="c15d34de162397ab149517d1962594775571867a" translate="yes" xml:space="preserve">
          <source>Halt playback or capture.</source>
          <target state="translated">Detener la reproducción o la captura.</target>
        </trans-unit>
        <trans-unit id="0018035548eb18eed2a25b33d8f19122d0047472" translate="yes" xml:space="preserve">
          <source>How to dither when converting</source>
          <target state="translated">Cómo vacilar al convertir</target>
        </trans-unit>
        <trans-unit id="a840cbed29fc932cc14b53d9d64e6d53f1b5fd33" translate="yes" xml:space="preserve">
          <source>How to mix channels when converting</source>
          <target state="translated">Cómo mezclar los canales al convertir</target>
        </trans-unit>
        <trans-unit id="347c8121bfdc03e7b053c35a87cd33a64e08bfe2" translate="yes" xml:space="preserve">
          <source>How to seek() in a source</source>
          <target state="translated">Cómo buscar()en una fuente</target>
        </trans-unit>
        <trans-unit id="6e00d1353dec802fe52b88ea0cfeb01d6600ccf9" translate="yes" xml:space="preserve">
          <source>If you like this library you may also be interested in my &lt;a href=&quot;https://pypi.org/project/synthplayer/&quot;&gt;software FM synthesizer&lt;/a&gt;
or my &lt;a href=&quot;https://pypi.org/project/libxmplite/&quot;&gt;mod player&lt;/a&gt; which uses libxmp.</source>
          <target state="translated">Si le gusta esta biblioteca, tambi&amp;eacute;n puede estar interesado en mi &lt;a href=&quot;https://pypi.org/project/synthplayer/&quot;&gt;software sintetizador FM&lt;/a&gt; o en mi &lt;a href=&quot;https://pypi.org/project/libxmplite/&quot;&gt;mod player&lt;/a&gt; que usa libxmp.</target>
        </trans-unit>
        <trans-unit id="457427a8f15172bc3cb2e0839b3d93b80ecf5ddd" translate="yes" xml:space="preserve">
          <source>Joins a capture device and a playback device.</source>
          <target state="translated">Une un dispositivo de captura y un dispositivo de reproducción.</target>
        </trans-unit>
        <trans-unit id="ee1878d4f1670e6a0b9f9f82af61fc0b6b013731" translate="yes" xml:space="preserve">
          <source>Most basic audio file playback</source>
          <target state="translated">La reproducción de archivos de audio más básica</target>
        </trans-unit>
        <trans-unit id="dc66eb74996c944df63af7ed0de1c9b807a5d6a0" translate="yes" xml:space="preserve">
          <source>Multiplatform audio playback, recording, decoding and sample format conversion for
Linux (including Raspberri Pi), Windows, Mac and probably other systems such as BSD.</source>
          <target state="translated">Reproducción de audio multiplataforma,grabación,decodificación y conversión de formatos de muestra para Linux (incluyendo Raspberri Pi),Windows,Mac y probablemente otros sistemas como BSD.</target>
        </trans-unit>
        <trans-unit id="b5c91ee9d8b7bf1d7d84767669ce50d799d337d4" translate="yes" xml:space="preserve">
          <source>Operating system audio backend to use (only a subset will be available)</source>
          <target state="translated">Sistema operativo de audio backend a utilizar (sólo un subconjunto estará disponible)</target>
        </trans-unit>
        <trans-unit id="f27a9fbd653a357fc8bb8e6f4bdc410c7a2f9b61" translate="yes" xml:space="preserve">
          <source>Playback of an unsupported file format</source>
          <target state="translated">Reproducción de un formato de archivo no soportado</target>
        </trans-unit>
        <trans-unit id="e591e0af6a6c6391d194bd6e12afc741ffe8406b" translate="yes" xml:space="preserve">
          <source>Python enums instead of just some integers for special values,</source>
          <target state="translated">Enums de pitón en lugar de sólo algunos enteros para valores especiales,</target>
        </trans-unit>
        <trans-unit id="54793a59249c3156c861fd01e424e621b150a8dd" translate="yes" xml:space="preserve">
          <source>Python miniaudio</source>
          <target state="translated">Miniaudio de Python</target>
        </trans-unit>
        <trans-unit id="0d191d9847ed570b471433e142d65bb66f5e2971" translate="yes" xml:space="preserve">
          <source>Query the audio playback and record devices that miniaudio provides</source>
          <target state="translated">Consulta los dispositivos de reproducción y grabación de audio que proporciona miniaudio</target>
        </trans-unit>
        <trans-unit id="61bab2e42a7af29d2dcce09211c38b610778bfde" translate="yes" xml:space="preserve">
          <source>Read up to the given amount of bytes from the file.</source>
          <target state="translated">Lee hasta la cantidad dada de bytes del archivo.</target>
        </trans-unit>
        <trans-unit id="fe56bdb333dbe0f5bddec13ce1b882cd52383449" translate="yes" xml:space="preserve">
          <source>Reads and decodes the whole audio file. Miniaudio will attempt to return the sound data in exactly
the same format as in the file. Unless you set convert_convert_to_16bit to True, then the result is
always a 16 bit sample format.</source>
          <target state="translated">Lee y decodifica todo el archivo de audio.Miniaudio intentará devolver los datos de sonido en exactamente el mismo formato que en el archivo.A menos que establezca convert_convert_to_16bit en True,entonces el resultado es siempre un formato de muestra de 16 bits.</target>
        </trans-unit>
        <trans-unit id="0e8bdcaedb57dd617455d038c31776466941252d" translate="yes" xml:space="preserve">
          <source>Reads and decodes the whole flac audio data. Resulting sample format is 16 bits signed integer.</source>
          <target state="translated">Lee y decodifica todos los datos de audio del flac.El formato de muestra resultante es un entero con signo de 16 bits.</target>
        </trans-unit>
        <trans-unit id="83e8a8e5a3ed56569d0f9be71baa6e082d7dfac5" translate="yes" xml:space="preserve">
          <source>Reads and decodes the whole flac audio data. Resulting sample format is 32 bits signed integer.</source>
          <target state="translated">Lee y decodifica todos los datos de audio del flac.El formato de muestra resultante es un entero con signo de 32 bits.</target>
        </trans-unit>
        <trans-unit id="d0742dcd5ef6435f949f859ec7a58f8eaa689cb6" translate="yes" xml:space="preserve">
          <source>Reads and decodes the whole flac audio file. Resulting sample format is 16 bits signed integer.</source>
          <target state="translated">Lee y decodifica todo el archivo de audio flac.El formato de muestra resultante es un entero con signo de 16 bits.</target>
        </trans-unit>
        <trans-unit id="0888aba94a9ef51ae15ed2755cdb1df1991e3b15" translate="yes" xml:space="preserve">
          <source>Reads and decodes the whole flac audio file. Resulting sample format is 32 bits float.</source>
          <target state="translated">Lee y decodifica todo el archivo de audio flac.El formato de muestra resultante es de 32 bits de flotación.</target>
        </trans-unit>
        <trans-unit id="d30f0ccd40b4fbb4d605c5b7d4a1a5609edd8cca" translate="yes" xml:space="preserve">
          <source>Reads and decodes the whole flac audio file. Resulting sample format is 32 bits signed integer.</source>
          <target state="translated">Lee y decodifica todo el archivo de audio flac.El formato de muestra resultante es un entero con signo de 32 bits.</target>
        </trans-unit>
        <trans-unit id="47063b2a70cb9b5a1a617f529035cd503b954756" translate="yes" xml:space="preserve">
          <source>Reads and decodes the whole mp3 audio data. Resulting sample format is 16 bits signed integer.</source>
          <target state="translated">Lee y decodifica todos los datos de audio en mp3.El formato de muestra resultante es un entero con signo de 16 bits.</target>
        </trans-unit>
        <trans-unit id="e9b645c40de7581180539fda7f2e00a19594878d" translate="yes" xml:space="preserve">
          <source>Reads and decodes the whole mp3 audio data. Resulting sample format is 32 bits float.</source>
          <target state="translated">Lee y decodifica todos los datos de audio en mp3.El formato de muestra resultante es de 32 bits de flotación.</target>
        </trans-unit>
        <trans-unit id="b51b148ee75c39244a6d779136e490079f30261d" translate="yes" xml:space="preserve">
          <source>Reads and decodes the whole mp3 audio file. Resulting sample format is 16 bits signed integer.</source>
          <target state="translated">Lee y decodifica todo el archivo de audio mp3.El formato de muestra resultante es un entero con signo de 16 bits.</target>
        </trans-unit>
        <trans-unit id="14cc1382f4fb5d59ec01f663604f21ca76b87c92" translate="yes" xml:space="preserve">
          <source>Reads and decodes the whole mp3 audio file. Resulting sample format is 32 bits float.</source>
          <target state="translated">Lee y decodifica todo el archivo de audio mp3.El formato de muestra resultante es de 32 bits flotantes.</target>
        </trans-unit>
        <trans-unit id="66fd98fa7dbb958e3db6fe2376534cfd2599a4fd" translate="yes" xml:space="preserve">
          <source>Reads and decodes the whole vorbis audio data. Resulting sample format is 16 bits signed integer.</source>
          <target state="translated">Lee y decodifica todos los datos de audio de los vorbis.El formato de muestra resultante es un entero de 16 bits con signo.</target>
        </trans-unit>
        <trans-unit id="7ce7effdcc92e574769789424af238e1f5022767" translate="yes" xml:space="preserve">
          <source>Reads and decodes the whole vorbis audio file. Resulting sample format is 16 bits signed integer.</source>
          <target state="translated">Lee y decodifica todo el archivo de audio de los Vorbis.El formato de muestra resultante es un entero de 16 bits con signo.</target>
        </trans-unit>
        <trans-unit id="7bee529dbc8b35f42acc1e2d940fa7a23db13f74" translate="yes" xml:space="preserve">
          <source>Reads and decodes the whole wav audio data. Resulting sample format is 16 bits signed integer.</source>
          <target state="translated">Lee y decodifica todos los datos de audio de wav.El formato de muestra resultante es un entero con signo de 16 bits.</target>
        </trans-unit>
        <trans-unit id="cd8bb367290e103b37d8e55a004d7baf5eb4b046" translate="yes" xml:space="preserve">
          <source>Reads and decodes the whole wav audio data. Resulting sample format is 32 bits float.</source>
          <target state="translated">Lee y decodifica todos los datos de audio de wav.El formato de muestra resultante es de 32 bits de flotación.</target>
        </trans-unit>
        <trans-unit id="0316c1a19af6c11394e2363a0c7a909945bfd350" translate="yes" xml:space="preserve">
          <source>Reads and decodes the whole wav audio data. Resulting sample format is 32 bits signed integer.</source>
          <target state="translated">Lee y decodifica todos los datos de audio de wav.El formato de muestra resultante es un entero con signo de 32 bits.</target>
        </trans-unit>
        <trans-unit id="e06be3ec9628fe144f07b9524ee4e3afb5f98e6c" translate="yes" xml:space="preserve">
          <source>Reads and decodes the whole wav audio file. Resulting sample format is 16 bits signed integer.</source>
          <target state="translated">Lee y decodifica todo el archivo de audio wav.El formato de muestra resultante es un entero con signo de 16 bits.</target>
        </trans-unit>
        <trans-unit id="cf9e6ecb9c5aa6ba5d95e785c940830c651e4fe8" translate="yes" xml:space="preserve">
          <source>Reads and decodes the whole wav audio file. Resulting sample format is 32 bits float.</source>
          <target state="translated">Lee y decodifica todo el archivo de audio wav.El formato de muestra resultante es de 32 bits de flotación.</target>
        </trans-unit>
        <trans-unit id="211262dda5092fe90e275b0a2fdcf7b86664fed8" translate="yes" xml:space="preserve">
          <source>Reads and decodes the whole wav audio file. Resulting sample format is 32 bits signed integer.</source>
          <target state="translated">Lee y decodifica todo el archivo de audio wav.El formato de muestra resultante es un entero con signo de 32 bits.</target>
        </trans-unit>
        <trans-unit id="b94764377806d47d4554064e530504fae16cbd28" translate="yes" xml:space="preserve">
          <source>Represents a source of data bytes.</source>
          <target state="translated">Representa una fuente de bytes de datos.</target>
        </trans-unit>
        <trans-unit id="08dea8f05696619166984f7255726ff1f036dba6" translate="yes" xml:space="preserve">
          <source>Sample format in memory</source>
          <target state="translated">Formato de la muestra en la memoria</target>
        </trans-unit>
        <trans-unit id="1fbc24457e328192fefcfa11e3180acada1161ae" translate="yes" xml:space="preserve">
          <source>Software license for these Python bindings, miniaudio and the decoders: MIT</source>
          <target state="translated">Licencia de software para estos enlaces de Python,miniaudio y los decodificadores:MIT</target>
        </trans-unit>
        <trans-unit id="45d391119440fd7bbd319914ab435e60fa35003b" translate="yes" xml:space="preserve">
          <source>Start the audio device: capture (recording) begins. The recorded audio data is sent to the given
callback generator as raw bytes. (it should already be started before)</source>
          <target state="translated">Inicie el dispositivo de audio:comienza la captura (grabación).Los datos de audio grabados se envían al generador de devolución de llamada como bytes sin procesar.(ya debería haberse iniciado antes)</target>
        </trans-unit>
        <trans-unit id="945b56ded1305142d54f39c6e7365e77951321bb" translate="yes" xml:space="preserve">
          <source>Start the audio device: playback and capture begin. The audio data for playback is provided by
the given callback generator, which is sent the recorded audio data at the same time. (it should
already be started before passing it in)</source>
          <target state="translated">Inicie el dispositivo de audio:comience la reproducción y la captura.Los datos de audio para la reproducción son proporcionados por el generador de devolución de llamada dado,al que se le envían los datos de audio grabados al mismo tiempo.(ya debe iniciarse antes de pasarla)</target>
        </trans-unit>
        <trans-unit id="ff2caf20fc34ab9e50df0099b5a27d767b47f447" translate="yes" xml:space="preserve">
          <source>Start the audio device: playback begins. The audio data is provided by the given callback
generator. The generator gets sent the required number of frames and should yield the sample data as
raw bytes, a memoryview, an array.array, or as a numpy array with shape (numframes, numchannels).
The generator should already be started before passing it in.</source>
          <target state="translated">Inicie el dispositivo de audio:comienza la reproducción.Los datos de audio son proporcionados por el generador de llamadas de retorno dado.El generador recibe el número de fotogramas requerido y debería proporcionar los datos de la muestra en forma de bytes sin procesar,una vista de memoria,un array.array o un array numérico con forma (numframes,numchannels).El generador debe ponerse en marcha ya antes de entregarlo.</target>
        </trans-unit>
        <trans-unit id="76c76d79173b0b9b08e168d4486dceaa35768406" translate="yes" xml:space="preserve">
          <source>Streams the WAV audio file as interleaved 16 bit signed integer sample arrays segments. This uses
a fixed chunk size and cannot be used as a generic miniaudio decoder input stream. Consider using
stream_file() instead.</source>
          <target state="translated">Transmite el archivo de audio WAV como segmentos enteros de 16 bits intercalados.Esto utiliza un tamaño de porción fija y no puede ser usado como un flujo de entrada de un decodificador miniaudio genérico.Considere usar stream_file()en su lugar.</target>
        </trans-unit>
        <trans-unit id="3738b64687d0324519ab81c368d92a787f244881" translate="yes" xml:space="preserve">
          <source>Streams the flac audio file as interleaved 16 bit signed integer sample arrays segments. This uses
a fixed chunk size and cannot be used as a generic miniaudio decoder input stream. Consider using
stream_file() instead.</source>
          <target state="translated">Transmite el archivo de audio flac como segmentos enteros de 16 bits intercalados y firmados.Esto utiliza un tamaño de porción fija y no puede ser usado como un flujo de entrada de un decodificador miniaudio genérico.Considere usar stream_file()en su lugar.</target>
        </trans-unit>
        <trans-unit id="9482cf45ccd4f9efa70e90e823a12533679ea051" translate="yes" xml:space="preserve">
          <source>Streams the mp3 audio file as interleaved 16 bit signed integer sample arrays segments. This uses
a fixed chunk size and cannot be used as a generic miniaudio decoder input stream. Consider using
stream_file() instead.</source>
          <target state="translated">Transmite el archivo de audio mp3 como segmentos de arreglos de muestras enteras de 16 bits intercalados.Esto utiliza un tamaño de porción fija y no puede ser usado como un flujo de entrada de un decodificador miniaudio genérico.Considere usar stream_file()en su lugar.</target>
        </trans-unit>
        <trans-unit id="7b5b03821afe1fe31d72644c2febc2ed586f6dbb" translate="yes" xml:space="preserve">
          <source>Streams the ogg vorbis audio file as interleaved 16 bit signed integer sample arrays segments.
This uses a variable unconfigurable chunk size and cannot be used as a generic miniaudio decoder
input stream. Consider using stream_file() instead.</source>
          <target state="translated">Transmite el archivo de audio ogg vorbis como segmentos enteros de matrices de muestras de 16 bits con firma intercalada.Esto utiliza un tamaño de porción variable e inconfigurable y no puede ser usado como un flujo de entrada de un decodificador miniaudio genérico.Considere la posibilidad de usar stream_file()en su lugar.</target>
        </trans-unit>
        <trans-unit id="e4732f234fdca3d7bb1afb9876ff4d663409e880" translate="yes" xml:space="preserve">
          <source>Synthesizer, modplayer?</source>
          <target state="translated">¿Sintetizador,modplayer?</target>
        </trans-unit>
        <trans-unit id="db65432ebabea4a5139d1b096c85c5fcbcaf2b57" translate="yes" xml:space="preserve">
          <source>TODO: filters</source>
          <target state="translated">TODO:filtros</target>
        </trans-unit>
        <trans-unit id="8bdf7d7031ef484465db0916ba56228b84f47b7e" translate="yes" xml:space="preserve">
          <source>TODO: waveform generators</source>
          <target state="translated">TODO:generadores de formas de onda</target>
        </trans-unit>
        <trans-unit id="dd6e4f4697b675457ca9ebfbfb8f624f2f8ff7de" translate="yes" xml:space="preserve">
          <source>The library is primarily distributed in source form so you need a C compiler to build and install this
(note: the setup script takes care of the actual compilation process, no need to worry about compiling things yourself).
For Linux and Mac this shouldn't be a problem. For Windows users, if the correct binary install
is not available on pypi, you'll have to get it to compile as well which may be a bit of a hassle
on this platform. You have to make sure that the required tools that allow you to compile Python extension modules
are installed (Visual Studio or the VC++ build tools).</source>
          <target state="translated">La biblioteca se distribuye principalmente en forma de código fuente,por lo que se necesita un compilador de C para construir e instalar esto (nota:el script de instalación se encarga del proceso de compilación real,no hay necesidad de preocuparse de compilar las cosas por sí mismo).Para Linux y Mac esto no debería ser un problema.Para los usuarios de Windows,si la instalación binaria correcta no está disponible en pypi,tendrás que hacer que se compile también,lo que puede ser un poco complicado en esta plataforma.Tienes que asegurarte de que las herramientas necesarias que te permiten compilar los módulos de extensión de Python están instaladas (Visual Studio o las herramientas de construcción VC++).</target>
        </trans-unit>
        <trans-unit id="3ed6ea8457e732020e5e7c68ec8bc977f320c74f" translate="yes" xml:space="preserve">
          <source>The priority of the worker thread (default=HIGHEST)</source>
          <target state="translated">La prioridad del hilo de trabajo (default=ALTA)</target>
        </trans-unit>
        <trans-unit id="1d3f94de385ebfc9cd02ce7bb23cc8223825c59e" translate="yes" xml:space="preserve">
          <source>This example uses ffmpeg as an external tool to decode an audio file in a format
that miniaudio itself can't decode (m4a/aac in this case):</source>
          <target state="translated">Este ejemplo utiliza ffmpeg como herramienta externa para decodificar un archivo de audio en un formato que el propio miniaudio no puede decodificar (m4a/aac en este caso):</target>
        </trans-unit>
        <trans-unit id="5911a575014ce2d1da77c61a88e0f76c62bfb790" translate="yes" xml:space="preserve">
          <source>This library aims to provide a Pythonic interface to the miniaudio C library.
Some of the main aspects of this are:</source>
          <target state="translated">Esta biblioteca tiene como objetivo proporcionar una interfaz pitónica a la biblioteca del miniaudio C.Algunos de los principales aspectos de esto son:</target>
        </trans-unit>
        <trans-unit id="389d67d4e425bd22cb93a94f064798d7a90e6644" translate="yes" xml:space="preserve">
          <source>This module provides:</source>
          <target state="translated">Este módulo proporciona:</target>
        </trans-unit>
        <trans-unit id="170c5132604e95ae76726c1db966048a228bb943" translate="yes" xml:space="preserve">
          <source>Type of audio device</source>
          <target state="translated">Tipo de dispositivo de audio</target>
        </trans-unit>
        <trans-unit id="f99c32a07530d0d3059a528f698be74929fb0a01" translate="yes" xml:space="preserve">
          <source>When a miniaudio specific error occurs.</source>
          <target state="translated">Cuando se produce un error específico de miniaudio.</target>
        </trans-unit>
        <trans-unit id="93256ad3c60c2669cdc10ed669d360a02c91bcf8" translate="yes" xml:space="preserve">
          <source>When something went wrong during decoding an audio file.</source>
          <target state="translated">Cuando algo salió mal durante la decodificación de un archivo de audio.</target>
        </trans-unit>
        <trans-unit id="56e07f7cf6898b2eab378ae9d1ab0421de7ae314" translate="yes" xml:space="preserve">
          <source>Writes the pcm sound to a WAV file</source>
          <target state="translated">Escribe el sonido pcm a un archivo WAV</target>
        </trans-unit>
        <trans-unit id="b6dbe85a2dc821488f64260d49026ef62265acaa" translate="yes" xml:space="preserve">
          <source>audio playback</source>
          <target state="translated">reproducción de audio</target>
        </trans-unit>
        <trans-unit id="d915246f9ca1345a5feba62e84a502aa445c4311" translate="yes" xml:space="preserve">
          <source>audio recording</source>
          <target state="translated">grabación de audio</target>
        </trans-unit>
        <trans-unit id="79cd964eff1ec3f6a10c6ff422280e07044c7347" translate="yes" xml:space="preserve">
          <source>converting sample formats and frequencies</source>
          <target state="translated">convertir los formatos y frecuencias de las muestras</target>
        </trans-unit>
        <trans-unit id="3239aa4d8ed17fa10aabaeb8f958c0cf040d0723" translate="yes" xml:space="preserve">
          <source>generators for the Audio playback and recording</source>
          <target state="translated">generadores para la reproducción y grabación de audio</target>
        </trans-unit>
        <trans-unit id="9f44b27fd037879342d5e1284d5cc63359e1b680" translate="yes" xml:space="preserve">
          <source>getting audio file properties (such as duration, number of channels, sample rate)</source>
          <target state="translated">Obtención de las propiedades de los archivos de audio (como la duración,el número de canales,la frecuencia de muestreo)</target>
        </trans-unit>
        <trans-unit id="4a530d2bffe101a83fbd1521b4e5a25c9f525273" translate="yes" xml:space="preserve">
          <source>its decoders for wav, flac, vorbis and mp3</source>
          <target state="translated">sus decodificadores para wav,flac,vorbis y mp3</target>
        </trans-unit>
        <trans-unit id="6e06f5192e5c61836071c7b542573ccca6113879" translate="yes" xml:space="preserve">
          <source>python bindings for most of the functions offered in those libraries:</source>
          <target state="translated">encuadernaciones de pitón para la mayoría de las funciones que se ofrecen en esas bibliotecas:</target>
        </trans-unit>
        <trans-unit id="5691ee15da5634f86093f97c3fd972b1c2dc3add" translate="yes" xml:space="preserve">
          <source>python bindings for the miniaudio library and its decoders (mp3, flac, ogg vorbis, wav)</source>
          <target state="translated">fijaciones de pitón para la biblioteca de miniaudio y sus decodificadores (mp3,flac,ogg vorbis,wav)</target>
        </trans-unit>
        <trans-unit id="8a22aba5682ed6386f904e381fd0d23444b4f9e0" translate="yes" xml:space="preserve">
          <source>reading and decoding audio files</source>
          <target state="translated">lectura y decodificación de archivos de audio</target>
        </trans-unit>
        <trans-unit id="b564d1f2a1cbbfeddd85f762834889c6ca9bcd69" translate="yes" xml:space="preserve">
          <source>sample data is usually in the form of a Python &lt;code&gt;array&lt;/code&gt; with appropriately sized elements
depending on the sample width (rather than a raw block of bytes)</source>
          <target state="translated">Los datos de muestra generalmente tienen la forma de una &lt;code&gt;array&lt;/code&gt; Python con elementos de tama&amp;ntilde;o apropiado seg&amp;uacute;n el ancho de la muestra (en lugar de un bloque de bytes sin procesar)</target>
        </trans-unit>
        <trans-unit id="2093da2e24735be37f448f0fea1835324065015a" translate="yes" xml:space="preserve">
          <source>several classes to represent the main functions of the library,</source>
          <target state="translated">varias clases para representar las principales funciones de la biblioteca,</target>
        </trans-unit>
        <trans-unit id="205080bba7759412ece27e6d7727faf0536b02d5" translate="yes" xml:space="preserve">
          <source>streaming large audio files</source>
          <target state="translated">transmitir archivos de audio de gran tamaño</target>
        </trans-unit>
        <trans-unit id="3ddb7f59b1ed2b644f82493a1940e3ba55dd1628" translate="yes" xml:space="preserve">
          <source>the &lt;a href=&quot;https://github.com/dr-soft/miniaudio/&quot;&gt;miniaudio&lt;/a&gt; cross platform sound playback, recording and conversion library</source>
          <target state="translated">la biblioteca de conversi&amp;oacute;n, grabaci&amp;oacute;n y reproducci&amp;oacute;n de sonido multiplataforma de &lt;a href=&quot;https://github.com/dr-soft/miniaudio/&quot;&gt;miniaudio&lt;/a&gt;</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
