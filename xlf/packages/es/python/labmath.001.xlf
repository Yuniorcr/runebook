<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="es" datatype="htmlbody" original="https://pypi.org/project/labmath/">
    <body>
      <group id="labmath">
        <trans-unit id="caf3ec883a47c1cd0ab34dc47256cfe1cd3e2fe9" translate="yes" xml:space="preserve">
          <source>! #</source>
          <target state="translated">! #</target>
        </trans-unit>
        <trans-unit id="4f07ec77c6cfa319b977c01bbbdae34d7e544a62" translate="yes" xml:space="preserve">
          <source>&amp;equiv; 0 (mod</source>
          <target state="translated">&amp;equiv; 0 (mod</target>
        </trans-unit>
        <trans-unit id="048d14889f8490b4d08978e698d471ef807b524b" translate="yes" xml:space="preserve">
          <source>&amp;gt; 0 is a nonsquare, and</source>
          <target state="translated">&amp;gt; 0 es un no cuadrado y</target>
        </trans-unit>
        <trans-unit id="f36894891c982490cf1360710c66648e07f52450" translate="yes" xml:space="preserve">
          <source>&amp;gt; 0: We check whether</source>
          <target state="translated">&amp;gt; 0: comprobamos si</target>
        </trans-unit>
        <trans-unit id="2184221da3c9b9bdfcb3ddfd28733b001fde0cf0" translate="yes" xml:space="preserve">
          <source>&amp;gt; 100 or so.  We divide by</source>
          <target state="translated">&amp;gt; 100 m&amp;aacute;s o menos. Dividimos por</target>
        </trans-unit>
        <trans-unit id="b53afd3ceb21f16bad6f4181621e0ac17d24b8ad" translate="yes" xml:space="preserve">
          <source>&amp;gt; 214 and a fully-factored integer &lt;em&gt;F&lt;/em&gt; such that &lt;em&gt;F&lt;/em&gt; divides</source>
          <target state="translated">&amp;gt; 214 y un entero &lt;em&gt;F&lt;/em&gt; completamente factorizado tal que &lt;em&gt;F&lt;/em&gt; divide</target>
        </trans-unit>
        <trans-unit id="1d9388e0d7df743210d405bec135e1efbb8ddd8b" translate="yes" xml:space="preserve">
          <source>&amp;lt; 0, then</source>
          <target state="translated">&amp;lt;0, entonces</target>
        </trans-unit>
        <trans-unit id="dbd04e1423a5593fff25c479197555fcf77cf3cf" translate="yes" xml:space="preserve">
          <source>&amp;lt; 2, then</source>
          <target state="translated">&amp;lt;2, entonces</target>
        </trans-unit>
        <trans-unit id="383f134e05f2a4eb1c9f02511f76241f497dabd8" translate="yes" xml:space="preserve">
          <source>&amp;middot;</source>
          <target state="translated">&amp;middot;</target>
        </trans-unit>
        <trans-unit id="568ce8561958384873f369b3f2e591f5f98c8464" translate="yes" xml:space="preserve">
          <source>&amp;middot; &lt;em&gt;y&lt;/em&gt;&lt;sup&gt;2&lt;/sup&gt; =</source>
          <target state="translated">&amp;middot; &lt;em&gt;Y &lt;/em&gt;&lt;sup&gt;2&lt;/sup&gt; =</target>
        </trans-unit>
        <trans-unit id="92e8881f1c8e6b5ca69c5aaaffd617dd1a309927" translate="yes" xml:space="preserve">
          <source>&amp;middot; &lt;em&gt;y&lt;/em&gt;&lt;sup&gt;2&lt;/sup&gt; = 1.</source>
          <target state="translated">&amp;middot; &lt;em&gt;Y &lt;/em&gt;&lt;sup&gt;2&lt;/sup&gt; = 1.</target>
        </trans-unit>
        <trans-unit id="b741186b74876f84db8c804af59332cc3291fa7a" translate="yes" xml:space="preserve">
          <source>&amp;middot; &lt;em&gt;y&lt;/em&gt;&lt;sup&gt;2&lt;/sup&gt; = 1.  We use some optimizations specific to this case of the Pell equation that makes this more efficient than calling</source>
          <target state="translated">&amp;middot; &lt;em&gt;Y &lt;/em&gt;&lt;sup&gt;2&lt;/sup&gt; = 1. Usamos algunas optimizaciones espec&amp;iacute;ficas para este caso de la ecuaci&amp;oacute;n de Pell que la hacen m&amp;aacute;s eficiente que llamar</target>
        </trans-unit>
        <trans-unit id="6e8a6db25e42c8c4df02595ffe6820cdcdea7dd4" translate="yes" xml:space="preserve">
          <source>&amp;middot; &lt;em&gt;y&lt;/em&gt;&lt;sup&gt;2&lt;/sup&gt;.  (0,0) is always a solution.</source>
          <target state="translated">&amp;middot; &lt;em&gt;Y &lt;/em&gt;&lt;sup&gt;2&lt;/sup&gt; . (0,0) siempre es una soluci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="3ab3dd7d16cfef73fb2e61f28f40699e19c4791c" translate="yes" xml:space="preserve">
          <source>&amp;middot; U&lt;sub&gt;n-1&lt;/sub&gt; -</source>
          <target state="translated">&amp;middot; U &lt;sub&gt;n-1&lt;/sub&gt; -</target>
        </trans-unit>
        <trans-unit id="4faddae56e1c823ae0a15d49ddaac8d1571a2a83" translate="yes" xml:space="preserve">
          <source>&amp;middot; U&lt;sub&gt;n-2&lt;/sub&gt;</source>
          <target state="translated">&amp;middot; U &lt;sub&gt;n-2&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="f25dc5f49acad9097bb0b21ceb581d1f48e8b7f0" translate="yes" xml:space="preserve">
          <source>&amp;middot; V&lt;sub&gt;n-1&lt;/sub&gt; -</source>
          <target state="translated">&amp;middot; V &lt;sub&gt;n-1&lt;/sub&gt; -</target>
        </trans-unit>
        <trans-unit id="12a81352f8f9c7c3529728549d88e6a5039a225f" translate="yes" xml:space="preserve">
          <source>&amp;middot; V&lt;sub&gt;n-2&lt;/sub&gt;</source>
          <target state="translated">&amp;middot; V &lt;sub&gt;n-2&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="a9cf5bce636d1ecb41a77fa58a411d49d3e6baae" translate="yes" xml:space="preserve">
          <source>&amp;middot; ln(</source>
          <target state="translated">&amp;middot; Ln (</target>
        </trans-unit>
        <trans-unit id="2b60ce12ac35015018edd0bc92ebb51fccb069ee" translate="yes" xml:space="preserve">
          <source>&amp;middot; rad(&lt;em&gt;a&lt;/em&gt;&amp;middot;&lt;em&gt;b&lt;/em&gt;&amp;middot;&lt;em&gt;c&lt;/em&gt;)&lt;sup&gt;abc[1]&lt;/sup&gt;.  This enables major speedups.  If</source>
          <target state="translated">&amp;middot; Rad ( &lt;em&gt;a&lt;/em&gt; &amp;middot; &lt;em&gt;b&lt;/em&gt; &amp;middot; &lt;em&gt;c&lt;/em&gt; ) &lt;sup&gt;abc [1]&lt;/sup&gt; . Esto permite importantes aceleraciones. Si</target>
        </trans-unit>
        <trans-unit id="44f4acd3eb3f017ce2e28ed30370f216bec96653" translate="yes" xml:space="preserve">
          <source>&amp;middot;&lt;em&gt;x&lt;/em&gt; +</source>
          <target state="translated">&amp;middot; &lt;em&gt;X&lt;/em&gt; +</target>
        </trans-unit>
        <trans-unit id="c01752f0646944d8aa6b495144cb53c0f5348ccd" translate="yes" xml:space="preserve">
          <source>&amp;middot;&lt;em&gt;x&lt;/em&gt;&lt;sup&gt;2&lt;/sup&gt; +</source>
          <target state="translated">&amp;middot; &lt;em&gt;X &lt;/em&gt;&lt;sup&gt;2&lt;/sup&gt; +</target>
        </trans-unit>
        <trans-unit id="ca281ff10e0c51f7e81335cb7834e418b7afaf78" translate="yes" xml:space="preserve">
          <source>&amp;middot;&lt;em&gt;x&lt;/em&gt;&lt;sup&gt;3&lt;/sup&gt; +</source>
          <target state="translated">&amp;middot; &lt;em&gt;X &lt;/em&gt;&lt;sup&gt;3&lt;/sup&gt; +</target>
        </trans-unit>
        <trans-unit id="8367bf1579c7db95d43ab3444547e64d4ef9b6d3" translate="yes" xml:space="preserve">
          <source>&amp;middot;&lt;em&gt;y&lt;/em&gt;.</source>
          <target state="translated">&amp;middot; &lt;em&gt;Y&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="e1907af93f06047bdf97a92a5f71da9b89222d6d" translate="yes" xml:space="preserve">
          <source>&amp;ndash; integers</source>
          <target state="translated">- enteros</target>
        </trans-unit>
        <trans-unit id="1d77670759947f3bb0477c2d19524e7decc4e882" translate="yes" xml:space="preserve">
          <source>&amp;ne; 0 &amp;gt;</source>
          <target state="translated">&amp;ne; 0&amp;gt;</target>
        </trans-unit>
        <trans-unit id="efe702747f33997abd2ae914a575c5e4ea38522b" translate="yes" xml:space="preserve">
          <source>&amp;ne; 0 &amp;lt;</source>
          <target state="translated">&amp;ne; 0 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="4429d48aa01c76d3396541bb843acf24b3f679b6" translate="yes" xml:space="preserve">
          <source>&amp;ne; 0 =</source>
          <target state="translated">&amp;ne; 0 =</target>
        </trans-unit>
        <trans-unit id="1f89c3f7c9d08338e52b4411b81a42f5b9417211" translate="yes" xml:space="preserve">
          <source>&amp;ne; 0,</source>
          <target state="translated">&amp;ne; 0,</target>
        </trans-unit>
        <trans-unit id="4d98a2b4f97cf7893f04666e243cc03576b4fe1a" translate="yes" xml:space="preserve">
          <source>&amp;rsquo; = -(-</source>
          <target state="translated">'= - (-</target>
        </trans-unit>
        <trans-unit id="626fcca9e3c8cf7d4a69beab2a5d9818401720bc" translate="yes" xml:space="preserve">
          <source>&amp;rsquo; = 0; if</source>
          <target state="translated">'= 0; Si</target>
        </trans-unit>
        <trans-unit id="2e4a410348c03f30c24b0d525baf8e0197729c24" translate="yes" xml:space="preserve">
          <source>&amp;rsquo; = 1; if -2 &amp;lt;</source>
          <target state="translated">'= 1; si -2 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="17f770dc35e50ddb0b9dc0105e08c9c0e3aee5b2" translate="yes" xml:space="preserve">
          <source>&amp;rsquo;s factors, we can instead pass</source>
          <target state="translated">factores, en su lugar podemos pasar</target>
        </trans-unit>
        <trans-unit id="03f539b2a22aaaed1db215c2950d3ed1599286f0" translate="yes" xml:space="preserve">
          <source>(1) is neither 1 nor -1, then</source>
          <target state="translated">(1) no es ni 1 ni -1, entonces</target>
        </trans-unit>
        <trans-unit id="969c5dfaebc55789601b0b4951fe01e479a5131f" translate="yes" xml:space="preserve">
          <source>(1).  Then we return the unique function</source>
          <target state="translated">(1). Luego devolvemos la funci&amp;oacute;n &amp;uacute;nica</target>
        </trans-unit>
        <trans-unit id="971a2a31fa23a7c33e144ed8640bbf8055d90b8e" translate="yes" xml:space="preserve">
          <source>(None, None)</source>
          <target state="translated">(Ninguno Ninguno)</target>
        </trans-unit>
        <trans-unit id="03dbeb1aa707806cbf5f399ce8022ae3ea2e35b4" translate="yes" xml:space="preserve">
          <source>(None, z, None)</source>
          <target state="translated">(Ninguno, z, Ninguno)</target>
        </trans-unit>
        <trans-unit id="d6d85aff92c379ca9ade6ac4079ecfd78153da15" translate="yes" xml:space="preserve">
          <source>(and therefore</source>
          <target state="translated">(y por lo tanto</target>
        </trans-unit>
        <trans-unit id="a666a96c08ace45e46f2016bf528aedca5ac2394" translate="yes" xml:space="preserve">
          <source>(default), we don&amp;rsquo;t call the multiprocessing functions.</source>
          <target state="translated">(predeterminado), no llamamos a las funciones de multiprocesamiento.</target>
        </trans-unit>
        <trans-unit id="d1ed1b74b6bd0c8f32a8d28b2e38be17613669ba" translate="yes" xml:space="preserve">
          <source>(gen, None, None)</source>
          <target state="translated">(gen, Ninguno, Ninguno)</target>
        </trans-unit>
        <trans-unit id="e459b13269ede555240e9185989705f723c1e0e1" translate="yes" xml:space="preserve">
          <source>(gen, z, f)</source>
          <target state="translated">(gen, z, f)</target>
        </trans-unit>
        <trans-unit id="cbffd77b9d1901c972fb0cd6a9d002d8273280c6" translate="yes" xml:space="preserve">
          <source>(inclusive) can be written as a sum of divisors of</source>
          <target state="translated">(inclusive) se puede escribir como una suma de divisores de</target>
        </trans-unit>
        <trans-unit id="622048af57626501fcc49a2751e0d8523a7e2a35" translate="yes" xml:space="preserve">
          <source>(isqrt(n), [a,b,c,...,d])</source>
          <target state="translated">(isqrt (n), [a, b, c, ..., d])</target>
        </trans-unit>
        <trans-unit id="4840cda77bfaffac296c76b7947c7053174a4ebb" translate="yes" xml:space="preserve">
          <source>(mod</source>
          <target state="translated">(modificaci&amp;oacute;n</target>
        </trans-unit>
        <trans-unit id="6a228c46af6c061469f59308e5af49db5fc3b04c" translate="yes" xml:space="preserve">
          <source>) = 1.  Also called the reduced totient or least universal exponent.</source>
          <target state="translated">) = 1. Tambi&amp;eacute;n se llama totiente reducido o exponente m&amp;iacute;nimo universal.</target>
        </trans-unit>
        <trans-unit id="073d0308b8b9be18296d367b35ec54590b48f865" translate="yes" xml:space="preserve">
          <source>) and</source>
          <target state="translated">) y</target>
        </trans-unit>
        <trans-unit id="ad9c9a8d46d9d802e701a33d2a70e6b5716d0f37" translate="yes" xml:space="preserve">
          <source>) and V(</source>
          <target state="translated">) y V(</target>
        </trans-unit>
        <trans-unit id="ac66979b1454bbfec91b6d7fae0329bfdf1387d9" translate="yes" xml:space="preserve">
          <source>) for all &lt;em&gt;a&lt;/em&gt; such that gcd(&lt;em&gt;a&lt;/em&gt;,</source>
          <target state="translated">) Para todo &lt;em&gt;un&lt;/em&gt; tal que gcd ( &lt;em&gt;a&lt;/em&gt; ,</target>
        </trans-unit>
        <trans-unit id="3355ec74401583907d7a9cbeddaf485a48f9374c" translate="yes" xml:space="preserve">
          <source>) with parameters (</source>
          <target state="translated">) con par&amp;aacute;metros (</target>
        </trans-unit>
        <trans-unit id="f68a84d9836c0c97794a4934197fe60fcf86a733" translate="yes" xml:space="preserve">
          <source>)&amp;rsquo;; and (&lt;em&gt;ab&lt;/em&gt;)&amp;rsquo; = &lt;em&gt;a&lt;/em&gt;&amp;rsquo;&amp;middot;&lt;em&gt;b&lt;/em&gt; + &lt;em&gt;b&lt;/em&gt;&amp;rsquo;&amp;middot;&lt;em&gt;a&lt;/em&gt;.</source>
          <target state="translated">) '; y ( &lt;em&gt;ab&lt;/em&gt; ) '= &lt;em&gt;a&lt;/em&gt; ' &amp;middot; &lt;em&gt;b&lt;/em&gt; + &lt;em&gt;b&lt;/em&gt; '&amp;middot; &lt;em&gt;a&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="d4dc2cee30052c6c649817c9e7a38b638e197cc5" translate="yes" xml:space="preserve">
          <source>)) arithmetic operations.  If</source>
          <target state="translated">)) operaciones aritmeticas. Si</target>
        </trans-unit>
        <trans-unit id="75816c562eabe0637a5415a8a87ebd580a17db45" translate="yes" xml:space="preserve">
          <source>)) earlier Fibonaccis along the way.  This is the asymptotically fastest algorithm.</source>
          <target state="translated">)) Fibonaccis anterior en el camino. Este es el algoritmo asint&amp;oacute;ticamente m&amp;aacute;s r&amp;aacute;pido.</target>
        </trans-unit>
        <trans-unit id="028dca72f656c1f9f2c5bf131d16859612ce8fe7" translate="yes" xml:space="preserve">
          <source>)) earlier Fibonaccis along the way.  This is, in the big-O sense, just about as fast as possible.</source>
          <target state="translated">)) Fibonaccis anterior en el camino. Esto es, en el sentido de la gran O, lo m&amp;aacute;s r&amp;aacute;pido posible.</target>
        </trans-unit>
        <trans-unit id="27489df79360a12fbf20085f661e36a65b7f68e2" translate="yes" xml:space="preserve">
          <source>))) to O(</source>
          <target state="translated">))) tambi&amp;eacute;n(</target>
        </trans-unit>
        <trans-unit id="d833daeaaa13660c3317a667dae54810986ad5e9" translate="yes" xml:space="preserve">
          <source>))/&lt;em&gt;Q&lt;/em&gt;&lt;sub&gt;i&lt;/sub&gt; is the &lt;em&gt;i&lt;/em&gt;&lt;sup&gt;th&lt;/sup&gt; complete quotient of &lt;em&gt;x&lt;/em&gt;, and &lt;em&gt;B&lt;/em&gt;&lt;sub&gt;i&lt;/sub&gt; is the denominator of the &lt;em&gt;i&lt;/em&gt;&lt;sup&gt;th&lt;/sup&gt; convergent to &lt;em&gt;x&lt;/em&gt;.  For full details, see &lt;a href=&quot;https://www.jpr2718.org/pell.pdf&quot;&gt;https://www.jpr2718.org/pell.pdf&lt;/a&gt;.</source>
          <target state="translated">)) / &lt;em&gt;Q &lt;/em&gt;&lt;sub&gt;i&lt;/sub&gt; es el &lt;em&gt;i- &lt;/em&gt;&lt;sup&gt;&amp;eacute;simo&lt;/sup&gt; cociente completo de &lt;em&gt;x&lt;/em&gt; , y &lt;em&gt;B &lt;/em&gt;&lt;sub&gt;i&lt;/sub&gt; es el denominador del &lt;em&gt;i- &lt;/em&gt;&lt;sup&gt;&amp;eacute;simo&lt;/sup&gt; convergente &lt;em&gt;ax&lt;/em&gt; . Para obtener detalles completos, consulte &lt;a href=&quot;https://www.jpr2718.org/pell.pdf&quot;&gt;https://www.jpr2718.org/pell.pdf&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="bd80da636e962ed71e291fca5e49f660ed4144a9" translate="yes" xml:space="preserve">
          <source>), hence the name of this function.</source>
          <target state="translated">), de ah&amp;iacute; el nombre de esta funci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="20b3a9190c2085fbc25ee7fe3d2088f716aee6b8" translate="yes" xml:space="preserve">
          <source>).  Currently just a helper function for</source>
          <target state="translated">). Actualmente solo una funci&amp;oacute;n auxiliar para</target>
        </trans-unit>
        <trans-unit id="fc24c2c1660830bca465674c52368b6befa93ead" translate="yes" xml:space="preserve">
          <source>).  More explicitly, if</source>
          <target state="translated">). M&amp;aacute;s expl&amp;iacute;citamente, si</target>
        </trans-unit>
        <trans-unit id="3c7f18a5a134f67c307184ef35ec66cfd2abf329" translate="yes" xml:space="preserve">
          <source>).  Not meaningful if</source>
          <target state="translated">). No tiene sentido si</target>
        </trans-unit>
        <trans-unit id="d2e1fe1b68c7903c6db94653115ed46c2a4ee271" translate="yes" xml:space="preserve">
          <source>).  Note that this is the generalization of the Jacobi symbol, &lt;em&gt;not&lt;/em&gt; the Dirac-delta analogue.</source>
          <target state="translated">). Tenga en cuenta que esta es la generalizaci&amp;oacute;n del s&amp;iacute;mbolo de Jacobi, &lt;em&gt;no&lt;/em&gt; el an&amp;aacute;logo Dirac-delta.</target>
        </trans-unit>
        <trans-unit id="7ed0423caf6d9cca721055e02a0f8298586e9324" translate="yes" xml:space="preserve">
          <source>).  This is primarily a helper function for</source>
          <target state="translated">). Esta es principalmente una funci&amp;oacute;n de ayuda para</target>
        </trans-unit>
        <trans-unit id="aa879b8892d12724424e723c8b8b7fbd2a5451ee" translate="yes" xml:space="preserve">
          <source>).  We assume that</source>
          <target state="translated">). Asumimos que</target>
        </trans-unit>
        <trans-unit id="505171ddfe54c69bfaacb38ce5b92c5d42c81e6b" translate="yes" xml:space="preserve">
          <source>). We yield a sequence of tuples (&lt;em&gt;B&lt;/em&gt;&lt;sub&gt;i&lt;/sub&gt;, &lt;em&gt;G&lt;/em&gt;&lt;sub&gt;i&lt;/sub&gt;, &lt;em&gt;P&lt;/em&gt;&lt;sub&gt;i&lt;/sub&gt;, &lt;em&gt;Q&lt;/em&gt;&lt;sub&gt;i&lt;/sub&gt;) where &lt;em&gt;i&lt;/em&gt; is an index counting up from 0, &lt;em&gt;x&lt;/em&gt; = (</source>
          <target state="translated">). Obtenemos una secuencia de tuplas ( &lt;em&gt;B &lt;/em&gt;&lt;sub&gt;i&lt;/sub&gt; , &lt;em&gt;G &lt;/em&gt;&lt;sub&gt;i&lt;/sub&gt; , &lt;em&gt;P &lt;/em&gt;&lt;sub&gt;i&lt;/sub&gt; , &lt;em&gt;Q &lt;/em&gt;&lt;sub&gt;i&lt;/sub&gt; ) donde &lt;em&gt;i&lt;/em&gt; es un &amp;iacute;ndice que cuenta desde 0, &lt;em&gt;x&lt;/em&gt; = (</target>
        </trans-unit>
        <trans-unit id="a66cbcc1eefeec92bf1b2e36bacce5d8d50b0b1e" translate="yes" xml:space="preserve">
          <source>): 1 if</source>
          <target state="translated">): 1 si</target>
        </trans-unit>
        <trans-unit id="3d37083a936c7247b36f337c8fa77689a4dbaae8" translate="yes" xml:space="preserve">
          <source>)&lt;sup&gt;2&lt;/sup&gt; &amp;middot; ln(ln(</source>
          <target state="translated">) &lt;sup&gt;2&lt;/sup&gt; &amp;middot; ln (ln (</target>
        </trans-unit>
        <trans-unit id="f609791b786e22175c6b8ffda42a1b240134ad4f" translate="yes" xml:space="preserve">
          <source>)&lt;sup&gt;2&lt;/sup&gt;) primality tests.  When called with the default primality test, this then uses O(log(</source>
          <target state="translated">) &lt;sup&gt;2&lt;/sup&gt; ) pruebas de primalidad. Cuando se llama con la prueba de primalidad predeterminada, esto usa O (log (</target>
        </trans-unit>
        <trans-unit id="fa3b1912e9f9c70c9ea40e24d137c2e2b65c834c" translate="yes" xml:space="preserve">
          <source>)&lt;sup&gt;3&lt;/sup&gt;) arithmetic operations, which in turn results in just over O(log(</source>
          <target state="translated">) &lt;sup&gt;3&lt;/sup&gt; ) operaciones aritm&amp;eacute;ticas, que a su vez dan como resultado un poco m&amp;aacute;s de O (log (</target>
        </trans-unit>
        <trans-unit id="eccfd3ffa4c0210f0545129d88c80138a75afcc9" translate="yes" xml:space="preserve">
          <source>)&lt;sup&gt;4&lt;/sup&gt;) to O(log(</source>
          <target state="translated">) &lt;sup&gt;4&lt;/sup&gt; ) a O (log (</target>
        </trans-unit>
        <trans-unit id="d0f96418fdaae58aa868dfa1a04b907e3de4d8e0" translate="yes" xml:space="preserve">
          <source>)&lt;sup&gt;5&lt;/sup&gt;) bit operations, depending on how multiplication is handled.</source>
          <target state="translated">) &lt;sup&gt;5&lt;/sup&gt; ) operaciones de bit, dependiendo de c&amp;oacute;mo se maneje la multiplicaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="df58248c414f342c81e056b40bee12d17a08bf61" translate="yes" xml:space="preserve">
          <source>*</source>
          <target state="translated">*</target>
        </trans-unit>
        <trans-unit id="058e6364a206ec75d4ea06b216781091dc0a63b4" translate="yes" xml:space="preserve">
          <source>* &amp;hellip; *</source>
          <target state="translated">*&amp;hellip; *</target>
        </trans-unit>
        <trans-unit id="a979ef10cc6f6a36df6b8a323307ee3bb2e2db9c" translate="yes" xml:space="preserve">
          <source>+</source>
          <target state="translated">+</target>
        </trans-unit>
        <trans-unit id="6bb6d24650ce6af4e00193710ccebde9f999bbd9" translate="yes" xml:space="preserve">
          <source>+ - * / // % **</source>
          <target state="translated">+ - * / //% **</target>
        </trans-unit>
        <trans-unit id="88be9dbf8c68b4e83cdc908fac5b35306ecb2688" translate="yes" xml:space="preserve">
          <source>+&amp;radic;</source>
          <target state="translated">+ &amp;radic;</target>
        </trans-unit>
        <trans-unit id="395e5e0dc693868d0fd611f9b4a861a3cf345095" translate="yes" xml:space="preserve">
          <source>+1 and &lt;em&gt;F&lt;/em&gt; &amp;gt;</source>
          <target state="translated">+1 y &lt;em&gt;F&lt;/em&gt; &amp;gt;</target>
        </trans-unit>
        <trans-unit id="2b15d7a9a8b829e1bc4ccc67364b19c65fbdf7f0" translate="yes" xml:space="preserve">
          <source>+1 is insufficient, we compute the factorization ourselves.</source>
          <target state="translated">+1 es insuficiente, calculamos la factorizaci&amp;oacute;n nosotros mismos.</target>
        </trans-unit>
        <trans-unit id="a4e0b43c86a3bd970da095c5a06be5a4c227f37e" translate="yes" xml:space="preserve">
          <source>+1)-tuple together with</source>
          <target state="translated">+1) -tupla junto con</target>
        </trans-unit>
        <trans-unit id="5c10b5b2cd673a0616d529aa5234b12ee7153808" translate="yes" xml:space="preserve">
          <source>,</source>
          <target state="translated">,</target>
        </trans-unit>
        <trans-unit id="d1a1b525f037dbfee7a76d82c7051a2e5ebb7fa7" translate="yes" xml:space="preserve">
          <source>, -1 if it isn&amp;rsquo;t, and 0 if</source>
          <target state="translated">, -1 si no lo es, y 0 si</target>
        </trans-unit>
        <trans-unit id="0402a07c81f8c9e99543d7b18293125f7dd682a6" translate="yes" xml:space="preserve">
          <source>, 1).</source>
          <target state="translated">, 1).</target>
        </trans-unit>
        <trans-unit id="adb71383bb0c830dc088a44c3c3b663bf50fa2d8" translate="yes" xml:space="preserve">
          <source>, &lt;em&gt;t&lt;/em&gt;).</source>
          <target state="translated">, &lt;em&gt;t&lt;/em&gt; ).</target>
        </trans-unit>
        <trans-unit id="f77a760d23ae5acd0086318743e4a422f6fa2a4a" translate="yes" xml:space="preserve">
          <source>, &lt;em&gt;x&lt;/em&gt;, &lt;em&gt;y&lt;/em&gt;) such that</source>
          <target state="translated">, &lt;em&gt;x&lt;/em&gt; , &lt;em&gt;y&lt;/em&gt; ) tal que</target>
        </trans-unit>
        <trans-unit id="8278d2adba7612cf98a492d21a4ac4c78acb1202" translate="yes" xml:space="preserve">
          <source>, and</source>
          <target state="translated">y</target>
        </trans-unit>
        <trans-unit id="a13ee8f7bf09e35795911f99b635ce888958b07e" translate="yes" xml:space="preserve">
          <source>, but this is purely for efficiency: if this import fails, we simply set</source>
          <target state="translated">, pero esto es puramente por eficiencia: si esta importaci&amp;oacute;n falla, simplemente configuramos</target>
        </trans-unit>
        <trans-unit id="2912e7d258bdbee79fb5448e6fb89a4149277adf" translate="yes" xml:space="preserve">
          <source>, except we compute only one sequence, and we supply the seeds.</source>
          <target state="translated">, excepto que calculamos una sola secuencia y proporcionamos las semillas.</target>
        </trans-unit>
        <trans-unit id="ef6b7a7bd8309377d5e53d1f069b2ebb0dbddad1" translate="yes" xml:space="preserve">
          <source>, except we only compute one sequence, and we supply the seeds.</source>
          <target state="translated">, excepto que solo calculamos una secuencia y proporcionamos las semillas.</target>
        </trans-unit>
        <trans-unit id="7253342fe51b33ee007666f1f184ed4fc90d8625" translate="yes" xml:space="preserve">
          <source>, indexed so that</source>
          <target state="translated">, indexado para que</target>
        </trans-unit>
        <trans-unit id="8d163154d8e6c13b85c5bd9f16c6ce3644b2d6c6" translate="yes" xml:space="preserve">
          <source>, normalized to lie between</source>
          <target state="translated">, normalizado para estar entre</target>
        </trans-unit>
        <trans-unit id="b366d1a229ec84d93ba42e7ecafb33db5b7b9b39" translate="yes" xml:space="preserve">
          <source>, or</source>
          <target state="translated">o</target>
        </trans-unit>
        <trans-unit id="2ae7a3d4fae316f912bf8cd912495d732107d53c" translate="yes" xml:space="preserve">
          <source>, or if</source>
          <target state="translated">, o si</target>
        </trans-unit>
        <trans-unit id="3965b16e7dcabd26afcc58e0dea964d0925db505" translate="yes" xml:space="preserve">
          <source>, or if both input polynomials are</source>
          <target state="translated">, o si ambos polinomios de entrada son</target>
        </trans-unit>
        <trans-unit id="f4899ae60f954a43e356842cf2c73c99b2d7f825" translate="yes" xml:space="preserve">
          <source>, returns 1.</source>
          <target state="translated">, devuelve 1.</target>
        </trans-unit>
        <trans-unit id="a9ae4d785b3d24dcbe10dec9ccaef3a5814950b5" translate="yes" xml:space="preserve">
          <source>, returns the greatest integer &amp;le; the rth root of</source>
          <target state="translated">, devuelve el mayor n&amp;uacute;mero entero &amp;le; la-&amp;eacute;sima ra&amp;iacute;z de</target>
        </trans-unit>
        <trans-unit id="1991cc6b25fa65f3894fd899603280a4c42747ff" translate="yes" xml:space="preserve">
          <source>, returns the least integer &amp;ge; the</source>
          <target state="translated">, devuelve el menor n&amp;uacute;mero entero &amp;ge; el</target>
        </trans-unit>
        <trans-unit id="bde66d79831e0f6fa51191c837fa9d626744bf59" translate="yes" xml:space="preserve">
          <source>, so instead of feeding those functions the integer forms of</source>
          <target state="translated">, as&amp;iacute; que en lugar de alimentar esas funciones, las formas enteras de</target>
        </trans-unit>
        <trans-unit id="2af26fac1f5d8b2b60538d2d8175a3f4b44896fb" translate="yes" xml:space="preserve">
          <source>, then these sequences grow exponentially, so the number of bit operations is anywhere from O(</source>
          <target state="translated">, entonces estas secuencias crecen exponencialmente, por lo que el n&amp;uacute;mero de operaciones de bits est&amp;aacute; entre O (</target>
        </trans-unit>
        <trans-unit id="74fa0c39cb9a52c881487f860f08a5619098244b" translate="yes" xml:space="preserve">
          <source>, then we generate all such tuples (regardless of size) that do not contain 1.</source>
          <target state="translated">, luego generamos todas esas tuplas (independientemente del tama&amp;ntilde;o) que no contienen 1.</target>
        </trans-unit>
        <trans-unit id="124774d26da0984041338194d3437efbb146ec0f" translate="yes" xml:space="preserve">
          <source>, then we make no such assumptions.</source>
          <target state="translated">, entonces no hacemos tales suposiciones.</target>
        </trans-unit>
        <trans-unit id="be4bc766d7f8559c895eeb1a54a33499c8489897" translate="yes" xml:space="preserve">
          <source>, we return</source>
          <target state="translated">, regresamos</target>
        </trans-unit>
        <trans-unit id="52c9d27db8d3c8f08205e64d67ed3a3b6e564d7d" translate="yes" xml:space="preserve">
          <source>, we return in a tuple all distinct integer roots of</source>
          <target state="translated">, devolvemos en una tupla todas las ra&amp;iacute;ces enteras distintas de</target>
        </trans-unit>
        <trans-unit id="38dab4478fad01b1670e174fe4859917716feda1" translate="yes" xml:space="preserve">
          <source>, we return in a tuple all distinct integers &lt;em&gt;x&lt;/em&gt; such that</source>
          <target state="translated">, devolvemos en una tupla todos los enteros distintos &lt;em&gt;x&lt;/em&gt; tales que</target>
        </trans-unit>
        <trans-unit id="a8fbd0202d5d59bb16abfc27a4a724fcbb5feb8c" translate="yes" xml:space="preserve">
          <source>, where</source>
          <target state="translated">, d&amp;oacute;nde</target>
        </trans-unit>
        <trans-unit id="abd29e8823df564d7094cd5714f55d2ebab1009e" translate="yes" xml:space="preserve">
          <source>, which takes anywhere from O(</source>
          <target state="translated">, que toma cualquier lugar de O (</target>
        </trans-unit>
        <trans-unit id="fae39a8b748ac34c7257196625985b5737c585b1" translate="yes" xml:space="preserve">
          <source>, written as their prime factorizations in factorint format.</source>
          <target state="translated">, escrito como sus factorizaciones principales en formato factorint.</target>
        </trans-unit>
        <trans-unit id="508e0d8dab0b1f90c101e0fa953db8cf0119f473" translate="yes" xml:space="preserve">
          <source>-1 and &lt;em&gt;F&lt;/em&gt; &amp;gt;</source>
          <target state="translated">-1 y &lt;em&gt;F&lt;/em&gt; &amp;gt;</target>
        </trans-unit>
        <trans-unit id="c87aef34d25ddf413df074e43b3857fc721b9f9f" translate="yes" xml:space="preserve">
          <source>-1 is insufficient, we compute the factorization ourselves.</source>
          <target state="translated">-1 es insuficiente, calculamos la factorizaci&amp;oacute;n nosotros mismos.</target>
        </trans-unit>
        <trans-unit id="934653cf2fbb5aa343b8a17873ada188f63e69ca" translate="yes" xml:space="preserve">
          <source>-gonal number.</source>
          <target state="translated">-n&amp;uacute;mero diagonal.</target>
        </trans-unit>
        <trans-unit id="4c9d25022f1889df6c191b749db36ada3048576a" translate="yes" xml:space="preserve">
          <source>-gonal number.  Indexing begins with 1 so that</source>
          <target state="translated">-n&amp;uacute;mero diagonal. La indexaci&amp;oacute;n comienza con 1 para que</target>
        </trans-unit>
        <trans-unit id="d8cec187abb579e2c29e5aa4980bca32e7aeddcd" translate="yes" xml:space="preserve">
          <source>-smooth numbers, where</source>
          <target state="translated">-n&amp;uacute;meros suaves, donde</target>
        </trans-unit>
        <trans-unit id="51799f4dddb6b8f54821f886704c610286d072d8" translate="yes" xml:space="preserve">
          <source>-smooth; the theorem also gives an effective algorithm for finding them.  We implement Lenstra&amp;rsquo;s improvement to this theorem.</source>
          <target state="translated">-suave; el teorema tambi&amp;eacute;n proporciona un algoritmo eficaz para encontrarlos. Implementamos la mejora de Lenstra a este teorema.</target>
        </trans-unit>
        <trans-unit id="9dfb7435225d8e36f17f8e560fb966c793db1b51" translate="yes" xml:space="preserve">
          <source>-tuples of positive integers all &amp;le;</source>
          <target state="translated">-tuplas de enteros positivos todos &amp;le;</target>
        </trans-unit>
        <trans-unit id="03c31cf6bf7021202cec4b807dd5bae4b273d995" translate="yes" xml:space="preserve">
          <source>-tuples of positive integers whose product is</source>
          <target state="translated">-tuplas de enteros positivos cuyo producto es</target>
        </trans-unit>
        <trans-unit id="55860883266f69576a27944588d11aeb9af144a7" translate="yes" xml:space="preserve">
          <source>.  Adds two points on a Montgomery curve modulo</source>
          <target state="translated">. Agrega dos puntos en un m&amp;oacute;dulo de curva de Montgomery</target>
        </trans-unit>
        <trans-unit id="bedbd2cb0d726992a984f6022cb30b49b09c1367" translate="yes" xml:space="preserve">
          <source>.  All elements of</source>
          <target state="translated">. Todos los elementos de</target>
        </trans-unit>
        <trans-unit id="630822fc11b0b2f1ecc676caf2a8e615584e3581" translate="yes" xml:space="preserve">
          <source>.  Coded after algorithm 2.2.1 from &lt;em&gt;Prime Numbers: A Computational Perspective&lt;/em&gt; by Crandall &amp;amp; Pomerance (2&lt;sup&gt;nd&lt;/sup&gt; edition).</source>
          <target state="translated">. Codificado seg&amp;uacute;n el algoritmo 2.2.1 de &lt;em&gt;Prime Numbers: A Computational Perspective&lt;/em&gt; por Crandall &amp;amp; Pomerance ( &lt;sup&gt;2&amp;ordf;&lt;/sup&gt; edici&amp;oacute;n).</target>
        </trans-unit>
        <trans-unit id="b89d3c4183e2ee6ab2d3f880397ed31ad5fc9bd0" translate="yes" xml:space="preserve">
          <source>.  Does not yield anything &amp;gt;</source>
          <target state="translated">. No cede nada&amp;gt;</target>
        </trans-unit>
        <trans-unit id="5794214f71393c850a4e6757e629c4faabd9bd28" translate="yes" xml:space="preserve">
          <source>.  Doubles a point on a Montgomery curve modulo</source>
          <target state="translated">. Dobla un punto en un m&amp;oacute;dulo de curva de Montgomery</target>
        </trans-unit>
        <trans-unit id="3b4687835edd8bbc72934f002d56164eb354f1c8" translate="yes" xml:space="preserve">
          <source>.  For best performance,</source>
          <target state="translated">. Para un mejor desempe&amp;ntilde;o,</target>
        </trans-unit>
        <trans-unit id="eeca317bcf54a2fa2495313e90c0253b6765a885" translate="yes" xml:space="preserve">
          <source>.  For negative</source>
          <target state="translated">. Por negativo</target>
        </trans-unit>
        <trans-unit id="f863c23a93501fd973cdcb1d746f38bd8aa20cad" translate="yes" xml:space="preserve">
          <source>.  If</source>
          <target state="translated">. Si</target>
        </trans-unit>
        <trans-unit id="62336538159533d8f2b7825c9e1614a8e84a8d21" translate="yes" xml:space="preserve">
          <source>.  If any of these conditions is false, then the return value is meaningless.</source>
          <target state="translated">. Si alguna de estas condiciones es falsa, el valor de retorno no tiene sentido.</target>
        </trans-unit>
        <trans-unit id="3aa2fef03cc99f2c6a29981a54b6ca0fd43a4b2f" translate="yes" xml:space="preserve">
          <source>.  Includes 0/1 and 1/1.</source>
          <target state="translated">. Incluye 0/1 y 1/1.</target>
        </trans-unit>
        <trans-unit id="6c15dcaa1f706697e53ac180225305ff0bf45eb2" translate="yes" xml:space="preserve">
          <source>.  Let</source>
          <target state="translated">. Dejar</target>
        </trans-unit>
        <trans-unit id="ec0dddd61a70dd84062d17fad04519fba3eb76f7" translate="yes" xml:space="preserve">
          <source>.  Mathematically, functions &lt;em&gt;f&lt;/em&gt; such that &lt;em&gt;f&lt;/em&gt;(1) = 0 have no Dirichlet inverses due to a division by zero.  This is reflected in this implementation by raising a</source>
          <target state="translated">. Matem&amp;aacute;ticamente, las funciones &lt;em&gt;f&lt;/em&gt; tales que &lt;em&gt;f&lt;/em&gt; (1) = 0 no tienen inversas de Dirichlet debido a una divisi&amp;oacute;n por cero. Esto se refleja en esta implementaci&amp;oacute;n al plantear un</target>
        </trans-unit>
        <trans-unit id="a2df60a11b363555ab8ab834ad45360aa791f070" translate="yes" xml:space="preserve">
          <source>.  More precisely, let</source>
          <target state="translated">. M&amp;aacute;s precisamente, dejemos</target>
        </trans-unit>
        <trans-unit id="69e208881411e7de93486694f776e8e75beea160" translate="yes" xml:space="preserve">
          <source>.  Multiplies a point on Montgomery curve by an integer modulo</source>
          <target state="translated">. Multiplica un punto en la curva de Montgomery por un m&amp;oacute;dulo entero</target>
        </trans-unit>
        <trans-unit id="24ff29b13afd939997c9d19c2291962b64252ac1" translate="yes" xml:space="preserve">
          <source>.  Multiplies along a Lucas sequence modulo</source>
          <target state="translated">. Se multiplica a lo largo de un m&amp;oacute;dulo de secuencia de Lucas</target>
        </trans-unit>
        <trans-unit id="2eb0162a649d218e0a6cf19d0278bda7b26c9015" translate="yes" xml:space="preserve">
          <source>.  Note that this function is not equivalent to calling</source>
          <target state="translated">. Tenga en cuenta que esta funci&amp;oacute;n no es equivalente a llamar</target>
        </trans-unit>
        <trans-unit id="70e6e03586456dd55a266bb8d7fc4d3529dec32e" translate="yes" xml:space="preserve">
          <source>.  Polynomials are written as lists of integers with the constant terms first.  If the high-degree coefficients are zero, those terms will be deleted from the answer so that the highest-degree term is nonzero.  We assume that the inputs also satisfy this property.  The zero polynomial is represented by the empty list.  If one of the input polynomials is</source>
          <target state="translated">. Los polinomios se escriben como listas de n&amp;uacute;meros enteros con los t&amp;eacute;rminos constantes primero. Si los coeficientes de alto grado son cero, esos t&amp;eacute;rminos se eliminar&amp;aacute;n de la respuesta para que el t&amp;eacute;rmino de grado m&amp;aacute;s alto sea distinto de cero. Suponemos que las entradas tambi&amp;eacute;n satisfacen esta propiedad. El polinomio cero est&amp;aacute; representado por la lista vac&amp;iacute;a. Si uno de los polinomios de entrada es</target>
        </trans-unit>
        <trans-unit id="7891891653fc6cce3496396ec615e07822222198" translate="yes" xml:space="preserve">
          <source>.  Returns a modular inverse normalized to minimize absolute value.</source>
          <target state="translated">. Devuelve un inverso modular normalizado para minimizar el valor absoluto.</target>
        </trans-unit>
        <trans-unit id="df53b7ffad8e7c9ffc76f6c2e3ff912b135a6d75" translate="yes" xml:space="preserve">
          <source>.  Returns a possibly-trivial divisor of</source>
          <target state="translated">. Devuelve un divisor posiblemente trivial de</target>
        </trans-unit>
        <trans-unit id="5db5695825b9f5041cedecad58afc157086c9824" translate="yes" xml:space="preserve">
          <source>.  Stops after yielding 1.</source>
          <target state="translated">. Se detiene despu&amp;eacute;s de ceder 1.</target>
        </trans-unit>
        <trans-unit id="17ee1ebfb679c24d9865beefd1b230698dbc71f5" translate="yes" xml:space="preserve">
          <source>.  The answer is not guaranteed to exist.  In such cases, we return</source>
          <target state="translated">. No se garantiza que la respuesta exista. En tales casos, volvemos</target>
        </trans-unit>
        <trans-unit id="c97013ebd3dd56cef9ec19b305fef47446fc694c" translate="yes" xml:space="preserve">
          <source>.  The argument</source>
          <target state="translated">. El argumento</target>
        </trans-unit>
        <trans-unit id="3984dbf3fc01a765843114a64197bc76090c91a6" translate="yes" xml:space="preserve">
          <source>.  The coefficients are interpreted mod</source>
          <target state="translated">. Los coeficientes se interpretan mod</target>
        </trans-unit>
        <trans-unit id="e364d93738c49ae8d217216d6b8aa47157e3d801" translate="yes" xml:space="preserve">
          <source>.  The number of solutions will be finite.</source>
          <target state="translated">. El n&amp;uacute;mero de soluciones ser&amp;aacute; finito.</target>
        </trans-unit>
        <trans-unit id="fa76e6d3265c6c843ae2903190d7f8d8cbd34b46" translate="yes" xml:space="preserve">
          <source>.  The output is not necessarily sorted.</source>
          <target state="translated">. La salida no est&amp;aacute; necesariamente ordenada.</target>
        </trans-unit>
        <trans-unit id="dc298eb5fce15e6a268b2efb1ab91a3189688f64" translate="yes" xml:space="preserve">
          <source>.  The result is not guaranteed to exist; in such cases we return</source>
          <target state="translated">. No se garantiza que exista el resultado; en tales casos volvemos</target>
        </trans-unit>
        <trans-unit id="92094b4180603ce1a85d50ea9bd933a525697ff4" translate="yes" xml:space="preserve">
          <source>.  The result is not guaranteed to exist; in such cases, we return</source>
          <target state="translated">. No se garantiza que exista el resultado; en tales casos, volvemos</target>
        </trans-unit>
        <trans-unit id="81f5c77a504be64ba4223184977c7f81505e3e33" translate="yes" xml:space="preserve">
          <source>.  The terms of this sequence usually grow exponentially, so computing a distant term incrementally by plucking it out of this generator takes O(</source>
          <target state="translated">. Los t&amp;eacute;rminos de esta secuencia generalmente crecen exponencialmente, por lo que calcular un t&amp;eacute;rmino distante de manera incremental sac&amp;aacute;ndolo de este generador toma O (</target>
        </trans-unit>
        <trans-unit id="c10decf0963370caa2df4eddad2f2022d7d4cc37" translate="yes" xml:space="preserve">
          <source>.  These are all in the Python standard library.</source>
          <target state="translated">. Todos estos est&amp;aacute;n en la biblioteca est&amp;aacute;ndar de Python.</target>
        </trans-unit>
        <trans-unit id="9fd1b8413cae2d8a7cf8b859c3afd081cf7c8fd4" translate="yes" xml:space="preserve">
          <source>.  These are also called panarithmic numbers.</source>
          <target state="translated">. Tambi&amp;eacute;n se denominan n&amp;uacute;meros panar&amp;iacute;tmicos.</target>
        </trans-unit>
        <trans-unit id="dbf9aec04ff31bff84995f4a6905d41ce7fb01ab" translate="yes" xml:space="preserve">
          <source>.  They are the factorial and primorial, respectively.  There are three aliases:</source>
          <target state="translated">. Son el factorial y el primorial, respectivamente. Hay tres alias:</target>
        </trans-unit>
        <trans-unit id="4994d7eecfdcc83c94f0846956e2114430d8e8f1" translate="yes" xml:space="preserve">
          <source>.  This is primarily a helper function for</source>
          <target state="translated">. Esta es principalmente una funci&amp;oacute;n de ayuda para</target>
        </trans-unit>
        <trans-unit id="63fb949fc2e1a20504d5b8871e2ea9a276a1d2e7" translate="yes" xml:space="preserve">
          <source>.  We find lattice points on a hyperbola.</source>
          <target state="translated">. Encontramos puntos de celos&amp;iacute;a en una hip&amp;eacute;rbola.</target>
        </trans-unit>
        <trans-unit id="9ef5b873dc4abea1b311e3b6345ab953cf020928" translate="yes" xml:space="preserve">
          <source>.  We have several cases:</source>
          <target state="translated">. Tenemos varios casos:</target>
        </trans-unit>
        <trans-unit id="4f4e84829ca34bfa686bf64a2bbe339eadfd7319" translate="yes" xml:space="preserve">
          <source>.  We return the answer as</source>
          <target state="translated">. Devolvemos la respuesta como</target>
        </trans-unit>
        <trans-unit id="2a3ffa876c8affd5d4a2a3bdb0f9b24ccc9d2a04" translate="yes" xml:space="preserve">
          <source>.  We solve &lt;em&gt;x&lt;/em&gt;&lt;sup&gt;2&lt;/sup&gt; + |</source>
          <target state="translated">. Resolvemos &lt;em&gt;x &lt;/em&gt;&lt;sup&gt;2&lt;/sup&gt; + |</target>
        </trans-unit>
        <trans-unit id="aec57ea347c4cbb02e153f4e9dcdd2c7155bbc15" translate="yes" xml:space="preserve">
          <source>.  We solve &lt;em&gt;x&lt;/em&gt;&lt;sup&gt;2&lt;/sup&gt; =</source>
          <target state="translated">. Resolvemos &lt;em&gt;x &lt;/em&gt;&lt;sup&gt;2&lt;/sup&gt; =</target>
        </trans-unit>
        <trans-unit id="ffdb742443cab6f6bc68d8e65b810e375ac33345" translate="yes" xml:space="preserve">
          <source>.  We use matrix methods to efficiently compute the</source>
          <target state="translated">. Usamos m&amp;eacute;todos matriciales para calcular eficientemente el</target>
        </trans-unit>
        <trans-unit id="d2edd7644d14b2c3ebdc5dcb244381cb86f47609" translate="yes" xml:space="preserve">
          <source>.  When</source>
          <target state="translated">. Cuando</target>
        </trans-unit>
        <trans-unit id="3dd77e02a23c61ca582238169f3ebe5213f17bd1" translate="yes" xml:space="preserve">
          <source>.  When called with the keyword arguments at their default values, this is equivalent to the expression</source>
          <target state="translated">. Cuando se llama con los argumentos de la palabra clave en sus valores predeterminados, esto es equivalente a la expresi&amp;oacute;n</target>
        </trans-unit>
        <trans-unit id="c45c4ba26e34d0170e8fcfc83536c6a2c13d24eb" translate="yes" xml:space="preserve">
          <source>.  Will be upgraded to full status when the case</source>
          <target state="translated">. Se actualizar&amp;aacute; al estado completo cuando el caso</target>
        </trans-unit>
        <trans-unit id="05a79f06cf3f67f726dae68d18a2290f6c9a50c9" translate="yes" xml:space="preserve">
          <source>:</source>
          <target state="translated">:</target>
        </trans-unit>
        <trans-unit id="cb7ea2362e2b5d69444b2add0d4466bf94a18ccd" translate="yes" xml:space="preserve">
          <source>: 1 if</source>
          <target state="translated">: 1 si</target>
        </trans-unit>
        <trans-unit id="890b46b3be358edbcfa3d0c38fe4595d37e1a1ac" translate="yes" xml:space="preserve">
          <source>: if</source>
          <target state="translated">: Si</target>
        </trans-unit>
        <trans-unit id="bb7195ec0056c8b0e2ce0463096c7965a6483b95" translate="yes" xml:space="preserve">
          <source>: the strongly multiplicative function that is -1 on the primes.</source>
          <target state="translated">: la funci&amp;oacute;n fuertemente multiplicativa que es -1 en los n&amp;uacute;meros primos.</target>
        </trans-unit>
        <trans-unit id="85683ef74faa9fd110b10909edbd557af57c30bf" translate="yes" xml:space="preserve">
          <source>; i.e., finds the smallest &lt;em&gt;k&lt;/em&gt; such that</source>
          <target state="translated">; es decir, encuentra el &lt;em&gt;k&lt;/em&gt; m&amp;aacute;s peque&amp;ntilde;o tal que</target>
        </trans-unit>
        <trans-unit id="1ec9e1cf2ec02b547b9b7d587eaa10e750c1b4c5" translate="yes" xml:space="preserve">
          <source>; if not, we keep chugging until a nontrivial factor is found.</source>
          <target state="translated">; si no, seguimos trabajando hasta encontrar un factor no trivial.</target>
        </trans-unit>
        <trans-unit id="039f5fd2698055b3ba8a74fdb5cfa6c51e201fe2" translate="yes" xml:space="preserve">
          <source>; the actual factoring work is done there.  Multiprocessing incurs relatively significant overhead, so when</source>
          <target state="translated">; el trabajo de factorizaci&amp;oacute;n real se realiza all&amp;iacute;. El multiprocesamiento genera una sobrecarga relativamente significativa, por lo que cuando</target>
        </trans-unit>
        <trans-unit id="40d77535a61760e117dbb66e25c00a2a15e0f8f9" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;x&lt;/em&gt;&lt;sub&gt;n+1&lt;/sub&gt; =</source>
          <target state="translated">&lt;em&gt;x &lt;/em&gt;&lt;sub&gt;n + 1&lt;/sub&gt; =</target>
        </trans-unit>
        <trans-unit id="6fad80e2470f3259317f0bae7ea41499d23e52bd" translate="yes" xml:space="preserve">
          <source>&lt;sub&gt;0&lt;/sub&gt; &amp;middot; &lt;em&gt;x&lt;/em&gt;&lt;sub&gt;n-k&lt;/sub&gt;,</source>
          <target state="translated">&lt;sub&gt;0&lt;/sub&gt; &amp;middot; &lt;em&gt;x &lt;/em&gt;&lt;sub&gt;n-k&lt;/sub&gt; ,</target>
        </trans-unit>
        <trans-unit id="5f7a29123ed0e3bd3cef4b66b4f233d8226b2920" translate="yes" xml:space="preserve">
          <source>&lt;sub&gt;k-1&lt;/sub&gt; &amp;middot; &lt;em&gt;x&lt;/em&gt;&lt;sub&gt;n-1&lt;/sub&gt; + &amp;hellip; +</source>
          <target state="translated">&lt;sub&gt;k-1&lt;/sub&gt; &amp;middot; &lt;em&gt;x &lt;/em&gt;&lt;sub&gt;n-1&lt;/sub&gt; +&amp;hellip; +</target>
        </trans-unit>
        <trans-unit id="a77f30fa676fba6eb28b45904ca9bf7f8407a4c8" translate="yes" xml:space="preserve">
          <source>&lt;sub&gt;k&lt;/sub&gt; &amp;middot; &lt;em&gt;x&lt;/em&gt;&lt;sub&gt;n&lt;/sub&gt; +</source>
          <target state="translated">&lt;sub&gt;k&lt;/sub&gt; &amp;middot; &lt;em&gt;x &lt;/em&gt;&lt;sub&gt;n&lt;/sub&gt; +</target>
        </trans-unit>
        <trans-unit id="b9b3b1f557ccaa4770f762809de784e1cf71acd8" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;0.3&lt;/sup&gt;, we quickly determine without error whether</source>
          <target state="translated">&lt;sup&gt;0.3&lt;/sup&gt; , determinamos r&amp;aacute;pidamente sin error si</target>
        </trans-unit>
        <trans-unit id="cc7ad8e27be44263423b050cf2c1d72fa330d1ec" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;2&lt;/sup&gt; &amp;equiv;</source>
          <target state="translated">&lt;sup&gt;2&lt;/sup&gt; &amp;equiv;</target>
        </trans-unit>
        <trans-unit id="8c3fed56bcf718ee6d22dfb1a2b07825ead397be" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;2&lt;/sup&gt; &amp;ne; 4&amp;middot;</source>
          <target state="translated">&lt;sup&gt;2&lt;/sup&gt; &amp;ne; 4 &amp;middot;</target>
        </trans-unit>
        <trans-unit id="c18d6e71a34fe8209f6204f366f7cb332c7dd04c" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;2&lt;/sup&gt; +</source>
          <target state="translated">&lt;sup&gt;2&lt;/sup&gt; +</target>
        </trans-unit>
        <trans-unit id="c716a113996c1b34a18ca8dadb5169431b0375fc" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;2&lt;/sup&gt; - 4&amp;middot;</source>
          <target state="translated">&lt;sup&gt;2&lt;/sup&gt; - 4 &amp;middot;</target>
        </trans-unit>
        <trans-unit id="ba2ef0b9899bd5abf83399d29b83f17a30d1935f" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;2&lt;/sup&gt;) bit operations depending on how multiplication is handled.</source>
          <target state="translated">&lt;sup&gt;2&lt;/sup&gt; ) operaciones de bits dependiendo de c&amp;oacute;mo se maneje la multiplicaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="20c43e4a4f228b1130814bf5db7962ea64f1bd40" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;2&lt;/sup&gt;) bit operations.  Extractions of distant terms should therefore be done via</source>
          <target state="translated">&lt;sup&gt;2&lt;/sup&gt; ) operaciones de bits. Por tanto, las extracciones de t&amp;eacute;rminos distantes deben realizarse a trav&amp;eacute;s de</target>
        </trans-unit>
        <trans-unit id="a167334eef67d44a756921a422a07f08e5fb4489" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;2&lt;/sup&gt;) depending on how multiplication is handled.  We recommend using MPZs when</source>
          <target state="translated">&lt;sup&gt;2&lt;/sup&gt; ) dependiendo de c&amp;oacute;mo se maneje la multiplicaci&amp;oacute;n. Recomendamos utilizar MPZ cuando</target>
        </trans-unit>
        <trans-unit id="d236f231a01427fc576faf86fb013aa14e7327a7" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;3&lt;/sup&gt; +</source>
          <target state="translated">&lt;sup&gt;3&lt;/sup&gt; +</target>
        </trans-unit>
        <trans-unit id="aca3c1fe1f41e62b4cfac7c3ec7653d996a24f93" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;k&lt;/sup&gt; &amp;equiv; 1 (mod</source>
          <target state="translated">&lt;sup&gt;k&lt;/sup&gt; &amp;equiv; 1 (mod</target>
        </trans-unit>
        <trans-unit id="97c039090394f463605069bbf8c6df2722cd15df" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;k&lt;/sup&gt; &amp;le;</source>
          <target state="translated">&lt;sup&gt;k&lt;/sup&gt; &amp;le;</target>
        </trans-unit>
        <trans-unit id="55c8bf4743223131e169941ec2e4ce3a76abe7d9" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;r&lt;/sup&gt; =</source>
          <target state="translated">&lt;sup&gt;r&lt;/sup&gt; =</target>
        </trans-unit>
        <trans-unit id="4cc25447b154f91db08f310c8784b93d659d71b4" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;th&lt;/sup&gt;</source>
          <target state="translated">&lt;sup&gt;th&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="7b346dc385476d44de05bc10ba444eb03c42e758" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;th&lt;/sup&gt; Dirichlet root of the input function</source>
          <target state="translated">&lt;sup&gt;th&lt;/sup&gt; ra&amp;iacute;z de Dirichlet de la funci&amp;oacute;n de entrada</target>
        </trans-unit>
        <trans-unit id="4e0998833af3e641c4809cbbdc1acb8fa08b0c19" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;th&lt;/sup&gt; Fibonacci number, indexed so that</source>
          <target state="translated">&lt;sup&gt;el n&amp;uacute;mero de&lt;/sup&gt; Fibonacci, indexado de modo que</target>
        </trans-unit>
        <trans-unit id="9bae34915a2d899be1093417a6feae86593fe6e9" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;th&lt;/sup&gt; power and reduced modulo</source>
          <target state="translated">&lt;sup&gt;th&lt;/sup&gt; potencia y m&amp;oacute;dulo reducido</target>
        </trans-unit>
        <trans-unit id="7c1b7cedd6cf4b7ea0843ae9112a88d81a587001" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;th&lt;/sup&gt; power; we return its</source>
          <target state="translated">&lt;sup&gt;th&lt;/sup&gt; poder; devolvemos su</target>
        </trans-unit>
        <trans-unit id="9571add5a9bb302601c68f6990cafdcaaac6ab01" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;th&lt;/sup&gt; prime (counting 2 as #1).  This is done with some efficiency by using</source>
          <target state="translated">&lt;sup&gt;th&lt;/sup&gt; primo (contando 2 como # 1). Esto se hace con cierta eficiencia utilizando</target>
        </trans-unit>
        <trans-unit id="2aa6d3c138012cea9d7e4de9efdf692013d87889" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;th&lt;/sup&gt; prime by using binary splitting on Riemann&amp;rsquo;s R function.</source>
          <target state="translated">&lt;sup&gt;el&lt;/sup&gt; primo utilizando la divisi&amp;oacute;n binaria en la funci&amp;oacute;n R de Riemann.</target>
        </trans-unit>
        <trans-unit id="1dd68f4e0732186c5eb7a5e3a2c916154df10e0a" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;th&lt;/sup&gt; root if it is and</source>
          <target state="translated">&lt;sup&gt;la&lt;/sup&gt; ra&amp;iacute;z si es y</target>
        </trans-unit>
        <trans-unit id="ce011f637b61645c06d252c10fe014b1c3b50958" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;th&lt;/sup&gt; root of</source>
          <target state="translated">&lt;sup&gt;la&lt;/sup&gt; ra&amp;iacute;z de</target>
        </trans-unit>
        <trans-unit id="d1dae2018f87c5b4146f30281a32a978b8b8f51d" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;th&lt;/sup&gt; term of the recursion</source>
          <target state="translated">&lt;sup&gt;el&lt;/sup&gt; t&amp;eacute;rmino de la recursividad</target>
        </trans-unit>
        <trans-unit id="bb7ebac52b158e0f3fb696936209b81e8b9d9c71" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;th&lt;/sup&gt; terms in the Lucas U- and V-sequences U(</source>
          <target state="translated">&lt;sup&gt;th&lt;/sup&gt; t&amp;eacute;rminos en la Lucas U y V secuencias de U (</target>
        </trans-unit>
        <trans-unit id="c07471720fdc7dc843113017c61ef1da42d9636e" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;th&lt;/sup&gt; terms of Lucas U- and V-sequences modulo</source>
          <target state="translated">&lt;sup&gt;los&lt;/sup&gt; t&amp;eacute;rminos de las secuencias U y V de Lucas m&amp;oacute;dulo</target>
        </trans-unit>
        <trans-unit id="21606782c65e44cac7afbb90977d8b6f82140e76" translate="yes" xml:space="preserve">
          <source>=</source>
          <target state="translated">=</target>
        </trans-unit>
        <trans-unit id="0e867bc45a919f6852d1707d6c564cddccc15b7e" translate="yes" xml:space="preserve">
          <source>= 0 and</source>
          <target state="translated">= 0 y</target>
        </trans-unit>
        <trans-unit id="a2b238e42ed2f58766c6f40ba1966b142c161247" translate="yes" xml:space="preserve">
          <source>= 0, we find the cubic&amp;rsquo;s other two roots an return in a tuple all distinct integer roots (including</source>
          <target state="translated">= 0, encontramos que las otras dos ra&amp;iacute;ces del c&amp;uacute;bico son un retorno en una tupla todas las ra&amp;iacute;ces enteras distintas (incluidas</target>
        </trans-unit>
        <trans-unit id="d6b32a7fe9fea7f7dd2116e40c5126417c968633" translate="yes" xml:space="preserve">
          <source>= 0.  This is primarily a helper function for</source>
          <target state="translated">= 0. Esta es principalmente una funci&amp;oacute;n auxiliar para</target>
        </trans-unit>
        <trans-unit id="8c00f4833ad3bed0cee304c3bb5de05cab062a04" translate="yes" xml:space="preserve">
          <source>= 0.  We solve &lt;em&gt;x&lt;/em&gt;&lt;sup&gt;2&lt;/sup&gt; =</source>
          <target state="translated">= 0. Resolvemos &lt;em&gt;x &lt;/em&gt;&lt;sup&gt;2&lt;/sup&gt; =</target>
        </trans-unit>
        <trans-unit id="049f7baef9b4665ff6124dbb2667d2e49d810988" translate="yes" xml:space="preserve">
          <source>= 0: If</source>
          <target state="translated">= 0: Si</target>
        </trans-unit>
        <trans-unit id="b3b9cebb3d288d60423f3a8c77d0031229959706" translate="yes" xml:space="preserve">
          <source>= 1 for all applicable</source>
          <target state="translated">= 1 para todos los aplicables</target>
        </trans-unit>
        <trans-unit id="375e0e8806a735e7336a89fdb13202c8f2ff0bf5" translate="yes" xml:space="preserve">
          <source>= 1, this is Euler&amp;rsquo;s totient: the number of numbers less than a number that are relatively prime to that number.</source>
          <target state="translated">= 1, este es el totient de Euler: el n&amp;uacute;mero de n&amp;uacute;meros menores que un n&amp;uacute;mero que son relativamente primos a ese n&amp;uacute;mero.</target>
        </trans-unit>
        <trans-unit id="ee2a0977e48d5159f0c2700ba8564ca4daadcfd3" translate="yes" xml:space="preserve">
          <source>= 1.  The argument</source>
          <target state="translated">= 1. El argumento</target>
        </trans-unit>
        <trans-unit id="127624f04c1941ca775ad41bcee5f7ed9d3f2b10" translate="yes" xml:space="preserve">
          <source>= [&lt;em&gt;a&lt;/em&gt;&lt;sub&gt;0&lt;/sub&gt;; &lt;em&gt;a&lt;/em&gt;&lt;sub&gt;1&lt;/sub&gt;, &lt;em&gt;a&lt;/em&gt;&lt;sub&gt;2&lt;/sub&gt;, &amp;hellip;], (&lt;em&gt;P&lt;/em&gt;&lt;sub&gt;i&lt;/sub&gt;+&amp;radic;</source>
          <target state="translated">= [ &lt;em&gt;a &lt;/em&gt;&lt;sub&gt;0&lt;/sub&gt; ; &lt;em&gt;a &lt;/em&gt;&lt;sub&gt;1&lt;/sub&gt; , &lt;em&gt;a &lt;/em&gt;&lt;sub&gt;2&lt;/sub&gt; ,&amp;hellip;], ( &lt;em&gt;P &lt;/em&gt;&lt;sub&gt;i&lt;/sub&gt; + &amp;radic;</target>
        </trans-unit>
        <trans-unit id="4338ffaceae0c24099d173ff2c9bfe4d749f97e7" translate="yes" xml:space="preserve">
          <source>= gcd(</source>
          <target state="translated">= mcd (</target>
        </trans-unit>
        <trans-unit id="6947818ac409551f11fbaa78f0ea6391960aa5b8" translate="yes" xml:space="preserve">
          <source>==</source>
          <target state="translated">==</target>
        </trans-unit>
        <trans-unit id="80cdd07910290457b081eafadcc6412b584e00f3" translate="yes" xml:space="preserve">
          <source>A 3-tuple.</source>
          <target state="translated">Un 3-tuple.</target>
        </trans-unit>
        <trans-unit id="1782b0769bc0794f66fe37be0e6e2b5095cfdace" translate="yes" xml:space="preserve">
          <source>Adds two polynomials and reduces their coefficients mod</source>
          <target state="translated">Añade dos polinomios y reduce sus coeficientes mod</target>
        </trans-unit>
        <trans-unit id="d6dce062190a725f9378f9ddffe2e8beff5a7002" translate="yes" xml:space="preserve">
          <source>Algorithm 3.6.7 from &lt;em&gt;Prime Numbers: A Computational Perspective&lt;/em&gt; by Crandall &amp;amp; Pomerance (2&lt;sup&gt;nd&lt;/sup&gt; edition): Evaluation of a binary Lucas chain.  To quote their description:</source>
          <target state="translated">Algoritmo 3.6.7 de &lt;em&gt;n&amp;uacute;meros primos: una perspectiva computacional&lt;/em&gt; de Crandall &amp;amp; Pomerance ( &lt;sup&gt;2&amp;ordf;&lt;/sup&gt; edici&amp;oacute;n): Evaluaci&amp;oacute;n de una cadena binaria de Lucas. Para citar su descripci&amp;oacute;n:</target>
        </trans-unit>
        <trans-unit id="38985f0c549afe30d53b4af28251e9c8da4ca5e4" translate="yes" xml:space="preserve">
          <source>Case 1:</source>
          <target state="translated">Caso 1:</target>
        </trans-unit>
        <trans-unit id="f8ec5cbd58e7c0b37a334f16283abc6b7d3385e8" translate="yes" xml:space="preserve">
          <source>Case 1a: If</source>
          <target state="translated">Caso 1a:Si</target>
        </trans-unit>
        <trans-unit id="a222a4dfe8a3b0d870d09894dab3f856e300b606" translate="yes" xml:space="preserve">
          <source>Case 1b: If</source>
          <target state="translated">Casas 1b:Si</target>
        </trans-unit>
        <trans-unit id="b71fc63f13f19028ba8bff4aa1f8b7999da99de6" translate="yes" xml:space="preserve">
          <source>Case 2:</source>
          <target state="translated">Casa 2:</target>
        </trans-unit>
        <trans-unit id="49241f887a7ca8258095000020fd32271e16ed35" translate="yes" xml:space="preserve">
          <source>Case 2a: If</source>
          <target state="translated">Caso 2a:Si</target>
        </trans-unit>
        <trans-unit id="bbfaaabe73c148e3d2946062a4906d0302d6d1e1" translate="yes" xml:space="preserve">
          <source>Case 2b: If</source>
          <target state="translated">Casas 2b:Si</target>
        </trans-unit>
        <trans-unit id="5b24dd2ab24f578129e90f8bd0303c05e5361a31" translate="yes" xml:space="preserve">
          <source>Case 3:</source>
          <target state="translated">Casa 3:</target>
        </trans-unit>
        <trans-unit id="2d6c1f774782efa9b4f6af5056c1a027477495d0" translate="yes" xml:space="preserve">
          <source>Case 4:</source>
          <target state="translated">Casas 4:</target>
        </trans-unit>
        <trans-unit id="9b4eecac5205ad9ea5741a08c395a55c34819821" translate="yes" xml:space="preserve">
          <source>Case 4a: If</source>
          <target state="translated">Casas 4a:Si</target>
        </trans-unit>
        <trans-unit id="df4114b917f3c8d37d9ed643e8b228a82e5032d2" translate="yes" xml:space="preserve">
          <source>Case 4b: If</source>
          <target state="translated">Casas 4b:Si</target>
        </trans-unit>
        <trans-unit id="a450ec02055b5afb4768084d98776055638bdf23" translate="yes" xml:space="preserve">
          <source>Checks whether</source>
          <target state="translated">Comprueba si</target>
        </trans-unit>
        <trans-unit id="380d837572dc516226fdab2201b5176ba208d011" translate="yes" xml:space="preserve">
          <source>Compiles the output of</source>
          <target state="translated">Compila la salida de</target>
        </trans-unit>
        <trans-unit id="ad88b5c709893b3c20a622a8af743326fc15e581" translate="yes" xml:space="preserve">
          <source>Computes</source>
          <target state="translated">Compotas</target>
        </trans-unit>
        <trans-unit id="7aaa81c08dfe664800463bbb7d2b2609be00f74f" translate="yes" xml:space="preserve">
          <source>Computes all square roots of</source>
          <target state="translated">Calcula todas las raíces cuadradas de</target>
        </trans-unit>
        <trans-unit id="b71f4915a8b78a90bf71f4feb80ae5bf3e75096c" translate="yes" xml:space="preserve">
          <source>Computes the</source>
          <target state="translated">Calcula el</target>
        </trans-unit>
        <trans-unit id="5b1f10974661e4aae9ae54437fdc601067fd19cd" translate="yes" xml:space="preserve">
          <source>Computes the Dirichlet inverse of the input function</source>
          <target state="translated">Calcula el Dirichlet inverso de la función de entrada</target>
        </trans-unit>
        <trans-unit id="45da31757146a27f1474566145d102920965af64" translate="yes" xml:space="preserve">
          <source>Computes the Riemann zeta function by applying</source>
          <target state="translated">Calcula la función zeta de Riemann aplicando</target>
        </trans-unit>
        <trans-unit id="84ffdb0127b01fd0dfdcfdb8b0853e1e6660615e" translate="yes" xml:space="preserve">
          <source>Computes the conjugate of a partition.</source>
          <target state="translated">Calcula el conjugado de una partición.</target>
        </trans-unit>
        <trans-unit id="2f7e72f636868efcf3963c89554f4f3546b46b10" translate="yes" xml:space="preserve">
          <source>Computes the determinant of a matrix via the Schur determinant identity.</source>
          <target state="translated">Calcula el determinante de una matriz a través de la identidad del determinante de Schur.</target>
        </trans-unit>
        <trans-unit id="fddddbff9f2631233edd5bf8d0829b1d0ccca918" translate="yes" xml:space="preserve">
          <source>Computes the discriminant of a polynomial.  The input list is ordered from lowest degree to highest &amp;mdash; i.e.,</source>
          <target state="translated">Calcula el discriminante de un polinomio. La lista de entrada est&amp;aacute; ordenada de menor a mayor grado, es decir,</target>
        </trans-unit>
        <trans-unit id="b13cdb1f9f2f8c15d7b68dc85b5079cb409f0d0b" translate="yes" xml:space="preserve">
          <source>Computes the greatest common monic divisor of the polynomials</source>
          <target state="translated">Calcula el mayor divisor común de los polinomios...</target>
        </trans-unit>
        <trans-unit id="70b1bcff0851db37b6ab48af870b18b4eb899e80" translate="yes" xml:space="preserve">
          <source>Computes the multiplicative order of</source>
          <target state="translated">Calcula el orden multiplicador de</target>
        </trans-unit>
        <trans-unit id="e6b1d2dbff4a02700db49061c1ccad62b0f984fa" translate="yes" xml:space="preserve">
          <source>Computes the number of primes &amp;le;</source>
          <target state="translated">Calcula el n&amp;uacute;mero de primos &amp;le;</target>
        </trans-unit>
        <trans-unit id="70313b568710e20bcdef3dc81d824005411e54b6" translate="yes" xml:space="preserve">
          <source>Computes the remainder when the polynomial</source>
          <target state="translated">Calcula el resto cuando el polinomio</target>
        </trans-unit>
        <trans-unit id="e4e418400d07ed96420a73081a8ab85a89f6efae" translate="yes" xml:space="preserve">
          <source>Computes the simple continued fraction for &amp;radic;</source>
          <target state="translated">Calcula la fracci&amp;oacute;n continua simple para &amp;radic;</target>
        </trans-unit>
        <trans-unit id="06a5f586c2eb39fa66d2894fdc3bb97e1fc12155" translate="yes" xml:space="preserve">
          <source>Computes the zeros of a polynomial modulo an integer.  We do this by factoring the modulus, solving modulo the prime power factors, and putting the results back together via the Chinese Remainder Theorem.</source>
          <target state="translated">Calcula los ceros de un módulo polinómico y un número entero.Lo hacemos factorizando el módulo,resolviendo los factores de potencia primarios del módulo,y recomponiendo los resultados mediante el Teorema del Resto Chino.</target>
        </trans-unit>
        <trans-unit id="4956ed652a1c6f51cec0f6e694b55d17d33de8a7" translate="yes" xml:space="preserve">
          <source>Computes with some semblance of efficiency the number of additive partitions of an integer.  The</source>
          <target state="translated">Calcula con cierta apariencia de eficiencia el número de particiones aditivas de un entero.El</target>
        </trans-unit>
        <trans-unit id="3a77df48c3f864a6b42116f2a3e15f1b92f8d260" translate="yes" xml:space="preserve">
          <source>Convergence acceleration for alternating series.  This is algorithm 1 from &lt;em&gt;Convergence Acceleration of Alternating Series&lt;/em&gt; by Cohen, Villegas, and Zagier &lt;a href=&quot;https://people.mpim-bonn.mpg.de/zagier/files/exp-math-9/fulltext.pdf&quot;&gt;(pdf)&lt;/a&gt;, with a minor tweak so that the &lt;em&gt;d&lt;/em&gt;-value isn&amp;rsquo;t computed via floating point.</source>
          <target state="translated">Aceleraci&amp;oacute;n de convergencia para series alternas. Este es el algoritmo 1 de &lt;em&gt;Convergence Acceleration of Alternating Series&lt;/em&gt; de Cohen, Villegas y Zagier &lt;a href=&quot;https://people.mpim-bonn.mpg.de/zagier/files/exp-math-9/fulltext.pdf&quot;&gt;(pdf)&lt;/a&gt; , con un peque&amp;ntilde;o ajuste para que el valor &lt;em&gt;d&lt;/em&gt; no se calcule mediante punto flotante.</target>
        </trans-unit>
        <trans-unit id="868ee34edfb003b759b6277c74f7c0b97d444d92" translate="yes" xml:space="preserve">
          <source>Counts the number of divisors of</source>
          <target state="translated">Cuenta el número de divisores de</target>
        </trans-unit>
        <trans-unit id="50c9e8d5fc98727b4bbc93cf5d64a68db647f04f" translate="yes" xml:space="preserve">
          <source>D</source>
          <target state="translated">D</target>
        </trans-unit>
        <trans-unit id="0562f32dc56f5c702810cbe010068ddd38dbd69a" translate="yes" xml:space="preserve">
          <source>Dependencies</source>
          <target state="translated">Dependencias</target>
        </trans-unit>
        <trans-unit id="e28be8ee29e21096adf6d89d6fffac95ddaa18af" translate="yes" xml:space="preserve">
          <source>Divides the polynomial</source>
          <target state="translated">Divide el polinomio</target>
        </trans-unit>
        <trans-unit id="40f7c422e533a5dba78c4675c7771558df18fb63" translate="yes" xml:space="preserve">
          <source>Efficiently computed the</source>
          <target state="translated">El cálculo eficiente de la</target>
        </trans-unit>
        <trans-unit id="6f70b9a168f5b545c989cf3a4158ce307cfc5f6a" translate="yes" xml:space="preserve">
          <source>Efficiently computes the</source>
          <target state="translated">Calcula de manera eficiente la</target>
        </trans-unit>
        <trans-unit id="c79cfad0cd9fc1efb605194c6bd5201bdc78b768" translate="yes" xml:space="preserve">
          <source>Efficiently extracts the</source>
          <target state="translated">Extrae eficientemente la</target>
        </trans-unit>
        <trans-unit id="1b735210ec0711a77faa327c9d6a3e0c153f226e" translate="yes" xml:space="preserve">
          <source>Efficiently extracts the nth Fibonacci number modulo</source>
          <target state="translated">Extrae eficientemente el enésimo módulo del número de Fibonacci</target>
        </trans-unit>
        <trans-unit id="76daf7900317f7abf520a1e4a2b4b5b2dc6ddf73" translate="yes" xml:space="preserve">
          <source>Efficiently generates an integer selected uniformly from the range [1,</source>
          <target state="translated">Genera eficientemente un entero seleccionado uniformemente del rango [1,</target>
        </trans-unit>
        <trans-unit id="42ca14cfd4cae0581ea916c6f1594ad56a1df12d" translate="yes" xml:space="preserve">
          <source>Evaluates a polynomial at a particular point, optionally modulo something.</source>
          <target state="translated">Evalúa un polinomio en un punto determinado,opcionalmente modulo algo.</target>
        </trans-unit>
        <trans-unit id="8b63f3d72cb6c84d8aa9c2f9b5cdfac25b053939" translate="yes" xml:space="preserve">
          <source>Evaluates a string in reverse Polish notation.  The acceptable binary operators are</source>
          <target state="translated">Evalúa una cadena en notación polaca inversa.Los operadores binarios aceptables son</target>
        </trans-unit>
        <trans-unit id="9f45020f0002b90bc4cba364abf6bfb470d1b5da" translate="yes" xml:space="preserve">
          <source>Extended Euclidean altorithm: returns a tuple (</source>
          <target state="translated">Altoritmo euclidiano extendido:devuelve una tupla (</target>
        </trans-unit>
        <trans-unit id="e09a8a0654b6fa8b1ac79728874341d2fcc002e7" translate="yes" xml:space="preserve">
          <source>Extra strong Lucas probable primality test as described on Wikipedia.  Its false positives are a strict subset of those for</source>
          <target state="translated">Prueba de primacía probable de Lucas extra fuerte como se describe en Wikipedia.Sus falsos positivos son un subconjunto estricto de los de</target>
        </trans-unit>
        <trans-unit id="755583209467b74b108f8173066d287285913679" translate="yes" xml:space="preserve">
          <source>Factors an integer via the multiple-polynomial quadratic sieve.  Most of this function is copied verbatim from &lt;a href=&quot;https://codegolf.stackexchange.com/a/9088&quot;&gt;https://codegolf.stackexchange.com/a/9088&lt;/a&gt;.</source>
          <target state="translated">Factores de un n&amp;uacute;mero entero a trav&amp;eacute;s del tamiz cuadr&amp;aacute;tico de polinomios m&amp;uacute;ltiples. La mayor parte de esta funci&amp;oacute;n se copia literalmente de &lt;a href=&quot;https://codegolf.stackexchange.com/a/9088&quot;&gt;https://codegolf.stackexchange.com/a/9088&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="aa9969810c269380b8228efaa8c405afadd239c4" translate="yes" xml:space="preserve">
          <source>Factors integers using Brent&amp;rsquo;s variation of Pollard&amp;rsquo;s rho algorithm.  If</source>
          <target state="translated">Factores enteros usando la variaci&amp;oacute;n de Brent del algoritmo rho de Pollard. Si</target>
        </trans-unit>
        <trans-unit id="c35602376c7ffa9efe97e8890d60ce2d999e78e6" translate="yes" xml:space="preserve">
          <source>Fermat&amp;rsquo;s primality test.</source>
          <target state="translated">Prueba de primalidad de Fermat.</target>
        </trans-unit>
        <trans-unit id="558a4d2dc169dc8bc6101e6bf8955d89cfb2a5d6" translate="yes" xml:space="preserve">
          <source>Finds &lt;em&gt;x&lt;/em&gt; such that &lt;em&gt;x&lt;/em&gt;&lt;sup&gt;2&lt;/sup&gt; &amp;equiv;</source>
          <target state="translated">Encuentra &lt;em&gt;x&lt;/em&gt; tal que &lt;em&gt;x &lt;/em&gt;&lt;sup&gt;2&lt;/sup&gt; &amp;equiv;</target>
        </trans-unit>
        <trans-unit id="b686567435c207d22564a0533b8ee5df789dc981" translate="yes" xml:space="preserve">
          <source>For a sequence &lt;em&gt;x&lt;/em&gt;&lt;sub&gt;0&lt;/sub&gt;, &lt;em&gt;x&lt;/em&gt;&lt;sub&gt;1&lt;/sub&gt;, &amp;hellip; with a rule for computing &lt;em&gt;x&lt;/em&gt;&lt;sub&gt;2j&lt;/sub&gt; from &lt;em&gt;x&lt;/em&gt;&lt;sub&gt;j&lt;/sub&gt; and a rule for computing &lt;em&gt;x&lt;/em&gt;&lt;sub&gt;2j+1&lt;/sub&gt; from &lt;em&gt;x&lt;/em&gt;&lt;sub&gt;j&lt;/sub&gt; and &lt;em&gt;x&lt;/em&gt;&lt;sub&gt;j+1&lt;/sub&gt;, this algorithm computes (&lt;em&gt;x&lt;/em&gt;&lt;sub&gt;n&lt;/sub&gt;, &lt;em&gt;x&lt;/em&gt;&lt;sub&gt;n+1&lt;/sub&gt;) for a given positive integer &lt;em&gt;n&lt;/em&gt;.  We have &lt;em&gt;n&lt;/em&gt; in binary as (&lt;em&gt;n&lt;/em&gt;&lt;sub&gt;0&lt;/sub&gt;, &lt;em&gt;n&lt;/em&gt;&lt;sub&gt;1&lt;/sub&gt;, &amp;hellip;, &lt;em&gt;n&lt;/em&gt;&lt;sub&gt;b-1&lt;/sub&gt;) with &lt;em&gt;n&lt;/em&gt;&lt;sub&gt;0&lt;/sub&gt; being the low-order bit.  We write the rules as follows: &lt;em&gt;x&lt;/em&gt;&lt;sub&gt;2j&lt;/sub&gt; = op1(&lt;em&gt;x&lt;/em&gt;&lt;sub&gt;j&lt;/sub&gt;) and &lt;em&gt;x&lt;/em&gt;&lt;sub&gt;2j+1&lt;/sub&gt; = op2(&lt;em&gt;x&lt;/em&gt;&lt;sub&gt;j&lt;/sub&gt;, &lt;em&gt;x&lt;/em&gt;&lt;sub&gt;j+1&lt;/sub&gt;).</source>
          <target state="translated">Para una secuencia &lt;em&gt;x &lt;/em&gt;&lt;sub&gt;0&lt;/sub&gt; , &lt;em&gt;x &lt;/em&gt;&lt;sub&gt;1&lt;/sub&gt; ,&amp;hellip; con una regla para calcular &lt;em&gt;x &lt;/em&gt;&lt;sub&gt;2j a&lt;/sub&gt; partir de &lt;em&gt;x &lt;/em&gt;&lt;sub&gt;j&lt;/sub&gt; y una regla para calcular &lt;em&gt;x &lt;/em&gt;&lt;sub&gt;2j + 1 a&lt;/sub&gt; partir de &lt;em&gt;x &lt;/em&gt;&lt;sub&gt;j&lt;/sub&gt; y &lt;em&gt;x &lt;/em&gt;&lt;sub&gt;j + 1&lt;/sub&gt; , este algoritmo calcula ( &lt;em&gt;x &lt;/em&gt;&lt;sub&gt;n&lt;/sub&gt; , &lt;em&gt;x &lt;/em&gt;&lt;sub&gt;n + 1&lt;/sub&gt; ) para un entero positivo dado &lt;em&gt;n&lt;/em&gt; . Tenemos &lt;em&gt;n&lt;/em&gt; en binario como ( &lt;em&gt;n &lt;/em&gt;&lt;sub&gt;0&lt;/sub&gt; , &lt;em&gt;n &lt;/em&gt;&lt;sub&gt;1&lt;/sub&gt; ,&amp;hellip;, &lt;em&gt;n &lt;/em&gt;&lt;sub&gt;b-1&lt;/sub&gt; ) siendo &lt;em&gt;n &lt;/em&gt;&lt;sub&gt;0&lt;/sub&gt; el bit de orden inferior. Escribimos las reglas de la siguiente manera:&lt;em&gt;x &lt;/em&gt;&lt;sub&gt;2j&lt;/sub&gt; = op1 ( &lt;em&gt;x &lt;/em&gt;&lt;sub&gt;j&lt;/sub&gt; ) y &lt;em&gt;x &lt;/em&gt;&lt;sub&gt;2j + 1&lt;/sub&gt; = op2 ( &lt;em&gt;x &lt;/em&gt;&lt;sub&gt;j&lt;/sub&gt; , &lt;em&gt;x &lt;/em&gt;&lt;sub&gt;j + 1&lt;/sub&gt; ).</target>
        </trans-unit>
        <trans-unit id="82e0d55e71d19ecac7cb12bebf6d2777fc0662cf" translate="yes" xml:space="preserve">
          <source>For non-negative</source>
          <target state="translated">Para los no negativos</target>
        </trans-unit>
        <trans-unit id="e3037e63bf6849b84a9a65234ff16b35b8d4cade" translate="yes" xml:space="preserve">
          <source>Fraction</source>
          <target state="translated">Fracción</target>
        </trans-unit>
        <trans-unit id="2b961dea1dc0c60ddf9a2c8e9d090f6f7d082483" translate="yes" xml:space="preserve">
          <source>Functions</source>
          <target state="translated">Funciones</target>
        </trans-unit>
        <trans-unit id="7b9e3da59754229c2f32e74a42b577b4422f4918" translate="yes" xml:space="preserve">
          <source>Generates all</source>
          <target state="translated">Genera todos los</target>
        </trans-unit>
        <trans-unit id="22d7ccb6d14fc4cee74c0160cabca76bfa59b245" translate="yes" xml:space="preserve">
          <source>Generates all Pythagorean triples of a given perimeter by examining the perimeter&amp;rsquo;s factors.</source>
          <target state="translated">Genera todos los triples pitag&amp;oacute;ricos de un per&amp;iacute;metro dado al examinar los factores del per&amp;iacute;metro.</target>
        </trans-unit>
        <trans-unit id="20981a6085339e916312afca4c42cb21b29b3435" translate="yes" xml:space="preserve">
          <source>Generates all natural numbers that evenly divide</source>
          <target state="translated">Genera todos los números naturales que se dividen por igual</target>
        </trans-unit>
        <trans-unit id="d7b6cb7b6197706c909fd79e098d52255b952bca" translate="yes" xml:space="preserve">
          <source>Generates all ordered</source>
          <target state="translated">Genera todos los pedidos</target>
        </trans-unit>
        <trans-unit id="b5bc0df54325689a6ed5d8e44d009cbaf25e1e56" translate="yes" xml:space="preserve">
          <source>Generates all shortest Egyptian fractions for</source>
          <target state="translated">Genera todas las fracciones egipcias más cortas para</target>
        </trans-unit>
        <trans-unit id="3674e97303aab2ce4c8cb585b3c01cfb064409d3" translate="yes" xml:space="preserve">
          <source>Generates partitions of integers in ascending order via an iterative algorithm.  It is the fastest known algorithm as of June 2014.</source>
          <target state="translated">Genera particiones de números enteros en orden ascendente a través de un algoritmo iterativo.Es el algoritmo más rápido conocido hasta junio de 2014.</target>
        </trans-unit>
        <trans-unit id="4f361d97a211e6e4027fd04a5730593d8e693bec" translate="yes" xml:space="preserve">
          <source>Generates primes less than the given limit (which may be infinite) lazily via a segmented sieve of Eratosthenes.  Uses O(&amp;radic;&lt;em&gt;p&lt;/em&gt;) memory, where &lt;em&gt;p&lt;/em&gt; is the most recently yielded prime.</source>
          <target state="translated">Genera n&amp;uacute;meros primos menores que el l&amp;iacute;mite dado (que puede ser infinito) perezosamente a trav&amp;eacute;s de un tamiz segmentado de Erat&amp;oacute;stenes. Utiliza la memoria O (&amp;radic; &lt;em&gt;p&lt;/em&gt; ), donde &lt;em&gt;p&lt;/em&gt; es el n&amp;uacute;mero primo producido m&amp;aacute;s recientemente.</target>
        </trans-unit>
        <trans-unit id="16934eba3976ff01419c058e6df6c8af103e1657" translate="yes" xml:space="preserve">
          <source>Generates some sequences related to simple continued fractions of certain quadratic surds.  A helper function for</source>
          <target state="translated">Genera algunas secuencias relacionadas con simples fracciones continuas de ciertas surcos cuadráticos.Una función de ayuda para</target>
        </trans-unit>
        <trans-unit id="5ec34d045dbcf19d83dead6f9fa5a6d49578ccf9" translate="yes" xml:space="preserve">
          <source>Generates the Collatz sequence initiated by</source>
          <target state="translated">Genera la secuencia Collatz iniciada por</target>
        </trans-unit>
        <trans-unit id="46036a496172f9e7e59c4720ac28f38377a5a3ae" translate="yes" xml:space="preserve">
          <source>Generates the Farey sequence of maximum denominator</source>
          <target state="translated">Genera la secuencia Farey de máximo denominador</target>
        </trans-unit>
        <trans-unit id="2966c2d3959f388c9f4c373f0c4789924fb35dac" translate="yes" xml:space="preserve">
          <source>Generates the Fibonacci numbers, starting with 0 and 1.</source>
          <target state="translated">Genera los números de Fibonacci,empezando por el 0 y el 1.</target>
        </trans-unit>
        <trans-unit id="a4d7c7b387f01b698c992b18b6cdbbeb8857ce38" translate="yes" xml:space="preserve">
          <source>Generates the Lucas U- and V-sequences with parameters (</source>
          <target state="translated">Genera las secuencias U y V de Lucas con parámetros (</target>
        </trans-unit>
        <trans-unit id="348058674896d7698ade218b645e78aa719f733f" translate="yes" xml:space="preserve">
          <source>Generates the convergents of a simple continued fraction.</source>
          <target state="translated">Genera los convergentes de una simple fracción continua.</target>
        </trans-unit>
        <trans-unit id="03b9c7acd70153ae6f6f9b6383547d14ca22b12d" translate="yes" xml:space="preserve">
          <source>Generates the divisors of</source>
          <target state="translated">Genera los divisores de</target>
        </trans-unit>
        <trans-unit id="77d96cd973f5fcc356d7ea61e98fc0354ef923eb" translate="yes" xml:space="preserve">
          <source>Generates the positive solutions of &lt;em&gt;x&lt;/em&gt;&lt;sup&gt;2&lt;/sup&gt; -</source>
          <target state="translated">Genera las soluciones positivas de &lt;em&gt;x &lt;/em&gt;&lt;sup&gt;2&lt;/sup&gt; -</target>
        </trans-unit>
        <trans-unit id="a2cedf2f0905a16cb97355e0f89e09a9b9e2ced4" translate="yes" xml:space="preserve">
          <source>Generates the powerset of a list, tuple, or string.  The yielded objects are always lists.</source>
          <target state="translated">Genera el conjunto de poderes de una lista,tupla o cadena.Los objetos cedidos son siempre listas.</target>
        </trans-unit>
        <trans-unit id="d3d1a5db6f2fcf2d35cde613a5cf1b3ebe6d1ef0" translate="yes" xml:space="preserve">
          <source>Generates the sequence of perfect powers without multiplicity.</source>
          <target state="translated">Genera la secuencia de poderes perfectos sin multiplicidad.</target>
        </trans-unit>
        <trans-unit id="9927c93125a447795cdb56a5b70e090d7a59152a" translate="yes" xml:space="preserve">
          <source>Generates the squarefree products of elements of</source>
          <target state="translated">Genera los productos libres de cuadrado de los elementos de</target>
        </trans-unit>
        <trans-unit id="48a914e25af552022c46aa19f9aad423ebb78585" translate="yes" xml:space="preserve">
          <source>Generates the squarefree products of the elements of</source>
          <target state="translated">Genera los productos libres de cuadrado de los elementos de</target>
        </trans-unit>
        <trans-unit id="61e266b2da8f4d9e3228c6d44639b6b4b9d9c574" translate="yes" xml:space="preserve">
          <source>Generates with some efficiency and without multiplicity the zeros of a polynomial modulo a prime.  Coded after algorithm 2.3.10 from &lt;em&gt;Prime Numbers: A Computational Perspective&lt;/em&gt; by Crandall &amp;amp; Pomerance (2&lt;sup&gt;nd&lt;/sup&gt; edition), which is essentially Cantor-Zassenhaus.</source>
          <target state="translated">Genera con cierta eficiencia y sin multiplicidad los ceros de un polinomio m&amp;oacute;dulo un primo. Codificado seg&amp;uacute;n el algoritmo 2.3.10 de &lt;em&gt;Prime Numbers: A Computational Perspective&lt;/em&gt; de Crandall &amp;amp; Pomerance ( &lt;sup&gt;2&amp;ordf;&lt;/sup&gt; edici&amp;oacute;n), que es esencialmente Cantor-Zassenhaus.</target>
        </trans-unit>
        <trans-unit id="afdca067c762eb09ba18fe097a8a14944b2cd94b" translate="yes" xml:space="preserve">
          <source>Generator of parameters to use for</source>
          <target state="translated">Generador de parámetros a utilizar para</target>
        </trans-unit>
        <trans-unit id="6756ef06769b67757cfb7a54a00557c41b55378c" translate="yes" xml:space="preserve">
          <source>Given integers</source>
          <target state="translated">Dados los números enteros</target>
        </trans-unit>
        <trans-unit id="a05c89fdecd6337e222ba902e607265c0a919d19" translate="yes" xml:space="preserve">
          <source>Grantham&amp;rsquo;s general Frobenius probable primality test, in both the strong and weak versions, as described in &lt;a href=&quot;https://doi.org/10.1090/S0025-5718-00-01197-2&quot;&gt;his paper introducing the test&lt;/a&gt;.</source>
          <target state="translated">Prueba de primalidad probable de Frobenius general de Grantham, tanto en la versi&amp;oacute;n fuerte como en la d&amp;eacute;bil, como se describe en &lt;a href=&quot;https://doi.org/10.1090/S0025-5718-00-01197-2&quot;&gt;su art&amp;iacute;culo de presentaci&amp;oacute;n de la prueba&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2a2772645729065942d0eadaa12ba2597a7ce381" translate="yes" xml:space="preserve">
          <source>Greatest common divisor of any number of values.</source>
          <target state="translated">El mayor divisor común de cualquier número de valores.</target>
        </trans-unit>
        <trans-unit id="d5538fdacd40c229580844c50a0e84640071e8d2" translate="yes" xml:space="preserve">
          <source>Greatest integer &lt;em&gt;k&lt;/em&gt; such that</source>
          <target state="translated">Mayor entero &lt;em&gt;k&lt;/em&gt; tal que</target>
        </trans-unit>
        <trans-unit id="6f381fc48bf71efac0b87be50ca0395b1bcdb0e3" translate="yes" xml:space="preserve">
          <source>Greatest integer whose square is &amp;le;</source>
          <target state="translated">Mayor entero cuyo cuadrado es &amp;le;</target>
        </trans-unit>
        <trans-unit id="8a9786aebdf4baf47c580d618ffbf95fee7af8a8" translate="yes" xml:space="preserve">
          <source>Helper function for</source>
          <target state="translated">Función de ayuda para</target>
        </trans-unit>
        <trans-unit id="751c68a3471b1c791efaee0a8e7c24ea0c266efd" translate="yes" xml:space="preserve">
          <source>If</source>
          <target state="translated">Si</target>
        </trans-unit>
        <trans-unit id="74a544b60062e69929a114bf0936c5b792215936" translate="yes" xml:space="preserve">
          <source>If the number of solutions if infinite and the equation is nondegenerate, it is</source>
          <target state="translated">Si el número de soluciones es infinito y la ecuación es no degenerada,es</target>
        </trans-unit>
        <trans-unit id="3601acab0087a6f1de36dbe7e247c1336341803c" translate="yes" xml:space="preserve">
          <source>If the number of solutions is finite, it is</source>
          <target state="translated">Si el número de soluciones es finito,es</target>
        </trans-unit>
        <trans-unit id="4c45f1494010a75938699a86ca9f35b4af612c35" translate="yes" xml:space="preserve">
          <source>If the number of solutions is infinite and the equation is degenerate, it&amp;rsquo;s</source>
          <target state="translated">Si el n&amp;uacute;mero de soluciones es infinito y la ecuaci&amp;oacute;n est&amp;aacute; degenerada, es</target>
        </trans-unit>
        <trans-unit id="79d70dcb4f9ee8b7d94ed9539586cc73c0d399da" translate="yes" xml:space="preserve">
          <source>Input:</source>
          <target state="translated">Entrada:</target>
        </trans-unit>
        <trans-unit id="48558cde54ab4e31d9a52d6e368c01422d284be7" translate="yes" xml:space="preserve">
          <source>Integer factoring function.  Uses Pollard&amp;rsquo;s p-1 algorithm.  Note that this is only efficient if the number to be factored has a prime factor &lt;em&gt;p&lt;/em&gt; such that &lt;em&gt;p&lt;/em&gt;-1&amp;rsquo;s largest prime factor is &amp;ldquo;small&amp;rdquo;.</source>
          <target state="translated">Funci&amp;oacute;n de factorizaci&amp;oacute;n de enteros. Utiliza el algoritmo p-1 de Pollard. Tenga en cuenta que esto solo es eficiente si el n&amp;uacute;mero a factorizar tiene un factor primo &lt;em&gt;p&lt;/em&gt; tal que el factor primo m&amp;aacute;s grande de &lt;em&gt;p&lt;/em&gt; -1 es &amp;ldquo;peque&amp;ntilde;o&amp;rdquo;.</target>
        </trans-unit>
        <trans-unit id="58aee54e766c3d0648fe443ab71a1c4404a30692" translate="yes" xml:space="preserve">
          <source>Integer factoring function.  Uses Williams&amp;rsquo; p+1 algorithm, single-stage variant.  Note that this is only efficient when the number to be factored has a prime factor &lt;em&gt;p&lt;/em&gt; such that &lt;em&gt;p&lt;/em&gt;+1&amp;rsquo;s largest prime factor is &amp;ldquo;small&amp;rdquo;.</source>
          <target state="translated">Funci&amp;oacute;n de factorizaci&amp;oacute;n de enteros. Utiliza el algoritmo p + 1 de Williams, variante de una etapa. Tenga en cuenta que esto solo es eficiente cuando el n&amp;uacute;mero a factorizar tiene un factor primo &lt;em&gt;p&lt;/em&gt; tal que el factor primo m&amp;aacute;s grande de &lt;em&gt;p&lt;/em&gt; + 1 es &amp;ldquo;peque&amp;ntilde;o&amp;rdquo;.</target>
        </trans-unit>
        <trans-unit id="eb92da6cfaf48f911b1e397ac93a72e926d82c77" translate="yes" xml:space="preserve">
          <source>Integer factoring function.  Uses several methods in parallel.  Waits for one of them to return, kills the rest, and reports.</source>
          <target state="translated">Función de factorización de números enteros.Utiliza varios métodos en paralelo.Espera a que uno de ellos regrese,mata al resto e informa.</target>
        </trans-unit>
        <trans-unit id="36b9a195ec43bf4e36c9d0dbe3c68ca3b21e4977" translate="yes" xml:space="preserve">
          <source>Integer factoring via elliptic curves using the two-phase algorithm on Montgomery curves, and optionally uses multiple processes.  This is a shell function that repeatedly calls</source>
          <target state="translated">Factorización de números enteros mediante curvas elípticas utilizando el algoritmo de dos fases en las curvas de Montgomery,y opcionalmente utiliza procesos múltiples.Esta es una función de shell que llama repetidamente</target>
        </trans-unit>
        <trans-unit id="d950c89d45f2f17330d4a332dbacd4261edaedc3" translate="yes" xml:space="preserve">
          <source>Jordan&amp;rsquo;s totient function: the number of</source>
          <target state="translated">Funci&amp;oacute;n totient de Jordan: el n&amp;uacute;mero de</target>
        </trans-unit>
        <trans-unit id="c0dae73b357c71b4181bcabbe5d70a17d3268e2c" translate="yes" xml:space="preserve">
          <source>Largest prime strictly less than</source>
          <target state="translated">El mayor primo estrictamente menos que</target>
        </trans-unit>
        <trans-unit id="c55e3aef5e32189be393ed862c0ceb6f582486d0" translate="yes" xml:space="preserve">
          <source>Legendre symbol (</source>
          <target state="translated">El símbolo de la leyenda (</target>
        </trans-unit>
        <trans-unit id="b7b70cfe63de1ef2240623cc22aef298e95de6a5" translate="yes" xml:space="preserve">
          <source>Legendre&amp;rsquo;s phi function.  Helper function for</source>
          <target state="translated">Funci&amp;oacute;n phi de Legendre. Funci&amp;oacute;n auxiliar para</target>
        </trans-unit>
        <trans-unit id="0b27b9e0b34d6576fc9dbd960ff42a117b81e70c" translate="yes" xml:space="preserve">
          <source>Lucas probable primality test as described in &lt;em&gt;Prime Numbers: A Computational Perspective&lt;/em&gt; by Crandall &amp;amp; Pomerance (2&lt;sup&gt;nd&lt;/sup&gt; edition).</source>
          <target state="translated">Prueba de primalidad probable de Lucas como se describe en &lt;em&gt;Prime Numbers: A Computational Perspective&lt;/em&gt; de Crandall &amp;amp; Pomerance ( &lt;sup&gt;2&amp;ordf;&lt;/sup&gt; edici&amp;oacute;n).</target>
        </trans-unit>
        <trans-unit id="de85192de03e3d43986a9c427bfca218b75f30da" translate="yes" xml:space="preserve">
          <source>Miller&amp;rsquo;s primality test.  If the extended Riemann hypothesis (the one about Dirichlet L-functions) is true, then this test is deterministic.</source>
          <target state="translated">Prueba de primac&amp;iacute;a de Miller. Si la hip&amp;oacute;tesis de Riemann extendida (la de las funciones L de Dirichlet) es verdadera, entonces esta prueba es determinista.</target>
        </trans-unit>
        <trans-unit id="bab38cd4e545470c7e853f0da105b99b830768c5" translate="yes" xml:space="preserve">
          <source>Miller-Rabin probable primality test.</source>
          <target state="translated">Prueba de primacía probable de Miller-Rabin.</target>
        </trans-unit>
        <trans-unit id="e68c66d68ccfd8c95781dbee10e00aff4655ac5a" translate="yes" xml:space="preserve">
          <source>Module for basic math in the general vicinity of computational number theory</source>
          <target state="translated">Módulo de matemáticas básicas en la vecindad general de la teoría de los números computacionales</target>
        </trans-unit>
        <trans-unit id="46e698ab572623f8f0ad02eff524bd00be815263" translate="yes" xml:space="preserve">
          <source>Multiplies the polynomials</source>
          <target state="translated">Multiplica los polinomios</target>
        </trans-unit>
        <trans-unit id="b51a60734da64be0e618bacbea2865a8a7dcd669" translate="yes" xml:space="preserve">
          <source>N</source>
          <target state="translated">N</target>
        </trans-unit>
        <trans-unit id="6eef6648406c333a4035cd5e60d0bf2ecf2606d7" translate="yes" xml:space="preserve">
          <source>None</source>
          <target state="translated">Ninguno</target>
        </trans-unit>
        <trans-unit id="4b290a83942f6f4f2844b1da336895999527b694" translate="yes" xml:space="preserve">
          <source>Note that we can check the infinitude of solutions by calling</source>
          <target state="translated">Obsérvese que podemos comprobar la infinitud de soluciones llamando a</target>
        </trans-unit>
        <trans-unit id="f3c8c95c5e534bcd2ea0034a0d83177efa6923f4" translate="yes" xml:space="preserve">
          <source>Output:</source>
          <target state="translated">Salida:</target>
        </trans-unit>
        <trans-unit id="511993d3c99719e38a6779073019dacd7178ddb9" translate="yes" xml:space="preserve">
          <source>P</source>
          <target state="translated">P</target>
        </trans-unit>
        <trans-unit id="29759bca1bfc18757b044f77226b0cf5f29e7563" translate="yes" xml:space="preserve">
          <source>Produces an integer that should be rather close to the</source>
          <target state="translated">Produce un número entero que debería estar bastante cerca de la</target>
        </trans-unit>
        <trans-unit id="b29a525c144146bbd16fe9aea49b986119d89719" translate="yes" xml:space="preserve">
          <source>Product of the elements of a list.  The product of the empty list is 1.  We use a binary algorithm because this can easily generate huge numbers, and calling</source>
          <target state="translated">Producto de los elementos de una lista.El producto de la lista vacía es 1.Utilizamos un algoritmo binario porque este puede generar fácilmente números enormes,y llamar</target>
        </trans-unit>
        <trans-unit id="efa50f19205b93213ecf483dedf5829a87e91fa3" translate="yes" xml:space="preserve">
          <source>Product of the elements of any iterable.  The product of an empty iterable is 1.</source>
          <target state="translated">Producto de los elementos de cualquier iterable.El producto de un iterable vacío es 1.</target>
        </trans-unit>
        <trans-unit id="c3156e00d3c2588c639e0d3cf6821258b05761c7" translate="yes" xml:space="preserve">
          <source>Q</source>
          <target state="translated">Q</target>
        </trans-unit>
        <trans-unit id="4fc743668b1979c9eb68fd8f734e4c967cd38b2b" translate="yes" xml:space="preserve">
          <source>Quadratic Frobenius probable primality test as described in &lt;em&gt;Prime Numbers: A Computational Perspective&lt;/em&gt; by Crandall &amp;amp; Pomerance (2&lt;sup&gt;nd&lt;/sup&gt; edition).</source>
          <target state="translated">Prueba cuadr&amp;aacute;tica de primalidad probable de Frobenius como se describe en &lt;em&gt;Prime Numbers: A Computational Perspective&lt;/em&gt; de Crandall &amp;amp; Pomerance ( &lt;sup&gt;2&amp;ordf;&lt;/sup&gt; edici&amp;oacute;n).</target>
        </trans-unit>
        <trans-unit id="9d1e4e7d27b519b1da3d7266c9c87d7861741080" translate="yes" xml:space="preserve">
          <source>References:</source>
          <target state="translated">Referencias:</target>
        </trans-unit>
        <trans-unit id="8660d17bd0736a98f236fde1aca942b73dd2ccfc" translate="yes" xml:space="preserve">
          <source>Returns a random prime with the specified number of digits when rendered in the specified base.</source>
          <target state="translated">Devuelve un primo aleatorio con el número de dígitos especificado cuando se renderiza en la base especificada.</target>
        </trans-unit>
        <trans-unit id="bce41a017cbfed81decffd172816cfe1b081112d" translate="yes" xml:space="preserve">
          <source>Returns in a sorted list all cube roots of a mod p.  There are a bunch of easily-computed special formulae for various cases with p != 1 (mod 9); we do those first, and then if p == 1 (mod 9) we use Algorithm 4.2 in &lt;a href=&quot;https://doi.org/10.1016/S0893-9659(02)00031-9&quot;&gt;Taking Cube Roots in Zm&lt;/a&gt; by Padro and Saez, which is essentially a variation on the Tonelli-Shanks algorithm for modular square roots.</source>
          <target state="translated">Devuelve en una lista ordenada todas las ra&amp;iacute;ces c&amp;uacute;bicas de un mod p. Hay un mont&amp;oacute;n de f&amp;oacute;rmulas especiales de f&amp;aacute;cil c&amp;aacute;lculo para varios casos con p! = 1 (mod 9); los hacemos primero, y luego si p == 1 (mod 9) usamos el algoritmo 4.2 en &lt;a href=&quot;https://doi.org/10.1016/S0893-9659(02)00031-9&quot;&gt;Taking Cube Roots in Zm&lt;/a&gt; por Padro y Saez, que es esencialmente una variaci&amp;oacute;n del algoritmo Tonelli-Shanks para ra&amp;iacute;ces cuadradas modulares.</target>
        </trans-unit>
        <trans-unit id="749c2334f29b2b96a440124d9ec5143c2f80d479" translate="yes" xml:space="preserve">
          <source>Returns the</source>
          <target state="translated">Devuelve el</target>
        </trans-unit>
        <trans-unit id="2788429877dc75f10653f8ea57742f65c3ac55e8" translate="yes" xml:space="preserve">
          <source>Returns the inverse of</source>
          <target state="translated">Devuelve el inverso de</target>
        </trans-unit>
        <trans-unit id="0aa9e156d1f9731381ea0988d61a0728f288e68a" translate="yes" xml:space="preserve">
          <source>Returns the neighbors of</source>
          <target state="translated">Devuelve a los vecinos de</target>
        </trans-unit>
        <trans-unit id="67135413b63a47ee49da0a9ed089467cc6bcdd3c" translate="yes" xml:space="preserve">
          <source>Returns the simple continued fraction of the rational number</source>
          <target state="translated">Devuelve la simple fracción continua del número racional</target>
        </trans-unit>
        <trans-unit id="8c64af7b91288bff547b95c2aa90b790e222d803" translate="yes" xml:space="preserve">
          <source>Returns the unique integer &lt;em&gt;c&lt;/em&gt; in</source>
          <target state="translated">Devuelve el entero &amp;uacute;nico &lt;em&gt;c&lt;/em&gt; en</target>
        </trans-unit>
        <trans-unit id="c59986e700c366e985f8e3ee48529c1d17965b5b" translate="yes" xml:space="preserve">
          <source>Seeded elliptic curve factoring using the two-phase algorithm on Montgomery curves.  Helper function for</source>
          <target state="translated">Factorización de la curva elíptica de semillas usando el algoritmo de dos fases en las curvas de Montgomery.La función de ayuda para</target>
        </trans-unit>
        <trans-unit id="65b8b9fcdf7545aac85c52e7e388b3087ac70080" translate="yes" xml:space="preserve">
          <source>Smallest prime strictly greater than</source>
          <target state="translated">El primo más pequeño es estrictamente mayor que</target>
        </trans-unit>
        <trans-unit id="de0a3bbda725c026719a122e2ac2435b2d45b429" translate="yes" xml:space="preserve">
          <source>St&amp;oslash;rmer&amp;rsquo;s theorem asserts that for any given set</source>
          <target state="translated">El teorema de St&amp;oslash;rmer afirma que para cualquier conjunto dado</target>
        </trans-unit>
        <trans-unit id="68b73702d7c61d8767bea5b5ab04c609a72e7a8a" translate="yes" xml:space="preserve">
          <source>Strong lucas probable primality test as described on Wikipedia.  Its false positives are a strict subset of those for</source>
          <target state="translated">La prueba de primacía probable de Lucas como se describe en Wikipedia.Sus falsos positivos son un subconjunto estricto de los de</target>
        </trans-unit>
        <trans-unit id="2d50307e0094ceb419bc2971529dc6eda018da0d" translate="yes" xml:space="preserve">
          <source>Subtracts the polynomial</source>
          <target state="translated">Resta el polinomio</target>
        </trans-unit>
        <trans-unit id="8f4e86cae681e592003cc72f1c8d1513b4e109ac" translate="yes" xml:space="preserve">
          <source>Sum of divisors of a natural number, raised to the &lt;em&gt;x&lt;/em&gt;&lt;sup&gt;th&lt;/sup&gt; power.  The conventional notation for this in mathematical literature is &amp;sigma;&lt;sub&gt;x&lt;/sub&gt;(</source>
          <target state="translated">Suma de los divisores de un n&amp;uacute;mero natural, elevado a la &lt;em&gt;x &lt;/em&gt;&lt;sup&gt;&amp;ordm;&lt;/sup&gt; potencia. La notaci&amp;oacute;n convencional para esto en la literatura matem&amp;aacute;tica es &amp;sigma; &lt;sub&gt;x&lt;/sub&gt; (</target>
        </trans-unit>
        <trans-unit id="92f71fda590da013da7b5ceae7f8c11e51160c29" translate="yes" xml:space="preserve">
          <source>Sum of primes &amp;le;</source>
          <target state="translated">Suma de primos &amp;le;</target>
        </trans-unit>
        <trans-unit id="cba2993ee0873c0dedffdfe1947866288d3632db" translate="yes" xml:space="preserve">
          <source>Tests whether</source>
          <target state="translated">Prueba si</target>
        </trans-unit>
        <trans-unit id="93ef0dd827103681fcee453b78be2ff14e1a261d" translate="yes" xml:space="preserve">
          <source>The</source>
          <target state="translated">El</target>
        </trans-unit>
        <trans-unit id="ba85a0e5b134b7d75a0b949613cddca5205a81b2" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;n&lt;/em&gt;+1 primality test: given an odd integer</source>
          <target state="translated">La prueba de primalidad &lt;em&gt;n&lt;/em&gt; +1: dado un n&amp;uacute;mero entero impar</target>
        </trans-unit>
        <trans-unit id="ad4b8705f8a743bd1955ae17b730f84b84e4376c" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;n&lt;/em&gt;-1 primality test: given an odd integer</source>
          <target state="translated">La prueba de primalidad &lt;em&gt;n&lt;/em&gt; -1: dado un n&amp;uacute;mero entero impar</target>
        </trans-unit>
        <trans-unit id="bfffb2de1764c7f6c7b23cbc9dc9333da88d067e" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;new&lt;/em&gt; functions provided by this module are as follows.  Further details, including examples and input details, are available in docstrings and accessible via the built-in</source>
          <target state="translated">Las &lt;em&gt;nuevas&lt;/em&gt; funciones que ofrece este m&amp;oacute;dulo son las siguientes. M&amp;aacute;s detalles, incluidos ejemplos y detalles de entrada, est&amp;aacute;n disponibles en las cadenas de documentos y se puede acceder a ellos a trav&amp;eacute;s del</target>
        </trans-unit>
        <trans-unit id="61cbd33546ed0c084c047ff5de63c094329f4c2e" translate="yes" xml:space="preserve">
          <source>The Baille-Pomerance-Selfridge-Wagstaff probable primality test.  Infinitely many false positives are conjectured to exist, but none are known, and the test is known to be deterministic below 2&lt;sup&gt;64&lt;/sup&gt;.</source>
          <target state="translated">Prueba de primalidad probable de Baille-Pomerance-Selfridge-Wagstaff. Se conjetura que existen infinidad de falsos positivos, pero no se conoce ninguno, y se sabe que la prueba es determinista por debajo de 2 &lt;sup&gt;64&lt;/sup&gt; .</target>
        </trans-unit>
        <trans-unit id="8ae06f07685c373d343c2d8dc504c27dfbb71b9a" translate="yes" xml:space="preserve">
          <source>The Carmichael lambda function: the smallest positive integer &lt;em&gt;m&lt;/em&gt; such that &lt;em&gt;a&lt;/em&gt;&lt;sup&gt;m&lt;/sup&gt; &amp;equiv; 1 (mod</source>
          <target state="translated">La funci&amp;oacute;n lambda de Carmichael: el entero positivo m&amp;aacute;s peque&amp;ntilde;o &lt;em&gt;m&lt;/em&gt; tal que &lt;em&gt;a &lt;/em&gt;&lt;sup&gt;m&lt;/sup&gt; &amp;equiv; 1 (mod</target>
        </trans-unit>
        <trans-unit id="8f70c2b99236794b977900e87bda53588a198add" translate="yes" xml:space="preserve">
          <source>The Jacobi symbol (</source>
          <target state="translated">El símbolo jacobino (</target>
        </trans-unit>
        <trans-unit id="a201857a7bfba2cda4b9019dcb967216941b4505" translate="yes" xml:space="preserve">
          <source>The Kronecker symbol (</source>
          <target state="translated">El símbolo de Kronecker (</target>
        </trans-unit>
        <trans-unit id="ccae17e449c4f4559e37143960d9af689cfcf0f2" translate="yes" xml:space="preserve">
          <source>The Liouville lambda function of</source>
          <target state="translated">La función lambda de Liouville de</target>
        </trans-unit>
        <trans-unit id="7005a82346ec99ebf93da31928b3d867ac8b07f7" translate="yes" xml:space="preserve">
          <source>The Lucas-Lehmer test.  Deterministically and efficiently checks whether the Mersenne number 2&lt;sup&gt;p&lt;/sup&gt;-1 is prime.</source>
          <target state="translated">La prueba de Lucas-Lehmer. Comprueba de manera determinista y eficiente si el n&amp;uacute;mero de Mersenne 2 &lt;sup&gt;p&lt;/sup&gt; -1 es primo.</target>
        </trans-unit>
        <trans-unit id="e907e6ac5e500335ae1de374215504e8e2e4c7c3" translate="yes" xml:space="preserve">
          <source>The M&amp;ouml;bius function of</source>
          <target state="translated">La funci&amp;oacute;n de M&amp;ouml;bius de</target>
        </trans-unit>
        <trans-unit id="2e5f733ebaf9aef7c164ef4266c033dd458c2c41" translate="yes" xml:space="preserve">
          <source>The arithmetic derivative of</source>
          <target state="translated">El derivado aritmético de</target>
        </trans-unit>
        <trans-unit id="06a3a8763738b50b1bea9bc6ecc0b4944b0219f5" translate="yes" xml:space="preserve">
          <source>The binomial coefficient nCr(</source>
          <target state="translated">El coeficiente binomial nCr(</target>
        </trans-unit>
        <trans-unit id="20bc83d44388278bb1eba7b31066e9cfcd434670" translate="yes" xml:space="preserve">
          <source>The general binary linear recursion.  Exactly like</source>
          <target state="translated">La recursividad lineal binaria general.Exactamente como</target>
        </trans-unit>
        <trans-unit id="04eb27028fb2518326a0aeecde4bff1a8418d50b" translate="yes" xml:space="preserve">
          <source>The general homogeneous linear recursion.  If</source>
          <target state="translated">La recursividad lineal homogénea general.Si</target>
        </trans-unit>
        <trans-unit id="8f9383265e796810dd164492e5d2c8daca1339a1" translate="yes" xml:space="preserve">
          <source>The general homogenous linear recursion: we generate in order the sequence defined by</source>
          <target state="translated">La recursividad lineal homogénea general:generamos en orden la secuencia definida por</target>
        </trans-unit>
        <trans-unit id="1ec1aac1b9258807d33e9aeef54c422c605055ac" translate="yes" xml:space="preserve">
          <source>The greedy algorithm for Egyptian fraction expansion; also called the Fibonacci-Sylvester algorithm.</source>
          <target state="translated">El codicioso algoritmo para la expansión de la fracción egipcia;también llamado algoritmo Fibonacci-Sylvester.</target>
        </trans-unit>
        <trans-unit id="526c959fba4910931aebf2ea03ebd2ff252a4f3a" translate="yes" xml:space="preserve">
          <source>The least common multiple of any number of values.</source>
          <target state="translated">El múltiplo menos común de cualquier número de valores.</target>
        </trans-unit>
        <trans-unit id="164b211a3a1e3dd384d29da09a5f523fe07a1c1c" translate="yes" xml:space="preserve">
          <source>The strong probable primality test (aka single-round Miller-Rabin).</source>
          <target state="translated">La prueba de primalidad probable fuerte (alias Miller-Rabin de una sola ronda).</target>
        </trans-unit>
        <trans-unit id="93dc4e2b35f32f64da2b01b8733e27df5aac6ecf" translate="yes" xml:space="preserve">
          <source>The workhorse integer factorizer.  Generates the prime factors of the input.  Factors that appear &lt;em&gt;x&lt;/em&gt; times are yielded &lt;em&gt;x&lt;/em&gt; times.</source>
          <target state="translated">El factorizador de enteros de caballo de batalla. Genera los factores primos de la entrada. Los factores que aparecen &lt;em&gt;x&lt;/em&gt; veces se obtienen &lt;em&gt;x&lt;/em&gt; veces.</target>
        </trans-unit>
        <trans-unit id="a95e03a7b14d113a036a7e2892678ddcf0dc5672" translate="yes" xml:space="preserve">
          <source>The workhorse primality test.  It is a BPSW primality test variant: we use the strong Lucas PRP test and preface the computation with trial division for speed.  No composites are known to pass the test, though it is suspected that infinitely many will do so.  There are definitely no such errors below 2&lt;sup&gt;64&lt;/sup&gt;.  This function is mainly a streamlined version of</source>
          <target state="translated">La prueba de la primac&amp;iacute;a del caballo de batalla. Es una variante de prueba de primalidad BPSW: utilizamos la prueba fuerte PRP de Lucas y precedemos el c&amp;aacute;lculo con divisi&amp;oacute;n de prueba para la velocidad. No se conocen compuestos que pasen la prueba, aunque se sospecha que infinitamente muchos lo har&amp;aacute;n. Definitivamente no hay tales errores por debajo de 2 &lt;sup&gt;64&lt;/sup&gt; . Esta funci&amp;oacute;n es principalmente una versi&amp;oacute;n simplificada de</target>
        </trans-unit>
        <trans-unit id="a76f1026ab482ee5fefe7adb3516df5ecd470401" translate="yes" xml:space="preserve">
          <source>This function solves the generalized Pell equation: we find all non-negative integers (&lt;em&gt;x&lt;/em&gt;, &lt;em&gt;y&lt;/em&gt;) such that &lt;em&gt;x&lt;/em&gt;&lt;sup&gt;2&lt;/sup&gt; -</source>
          <target state="translated">Esta funci&amp;oacute;n resuelve la ecuaci&amp;oacute;n de Pell generalizada: encontramos todos los enteros no negativos ( &lt;em&gt;x&lt;/em&gt; , &lt;em&gt;y&lt;/em&gt; ) tales que &lt;em&gt;x &lt;/em&gt;&lt;sup&gt;2&lt;/sup&gt; -</target>
        </trans-unit>
        <trans-unit id="640dc11e3dabf59ed510e1ca891dc62e28eccc72" translate="yes" xml:space="preserve">
          <source>This is a module for basic math in the general vicinity of computational number theory.  It includes functions associated with primality testing, integer factoring, prime counting, linear recurrences, modular square roots, generalized Pell equations, the classic arithmetical functions, continued fractions, partitions, St&amp;oslash;rmer&amp;rsquo;s theorem, smooth numbers, and Dirichlet convolution.  Integer arithmetic is used wherever feasible.</source>
          <target state="translated">Este es un m&amp;oacute;dulo de matem&amp;aacute;ticas b&amp;aacute;sicas en la vecindad general de la teor&amp;iacute;a num&amp;eacute;rica computacional. Incluye funciones asociadas con pruebas de primalidad, factorizaci&amp;oacute;n de enteros, recuento de primos, recurrencias lineales, ra&amp;iacute;ces cuadradas modulares, ecuaciones de Pell generalizadas, funciones aritm&amp;eacute;ticas cl&amp;aacute;sicas, fracciones continuas, particiones, teorema de St&amp;oslash;rmer, n&amp;uacute;meros suaves y convoluci&amp;oacute;n de Dirichlet. La aritm&amp;eacute;tica de enteros se utiliza siempre que sea posible.</target>
        </trans-unit>
        <trans-unit id="335698cb19b6ed9b7f11b37679af97f02f222696" translate="yes" xml:space="preserve">
          <source>This package imports items from</source>
          <target state="translated">Este paquete importa artículos de</target>
        </trans-unit>
        <trans-unit id="878399c850ec7dd06a4fb5120e12b31d8e51f329" translate="yes" xml:space="preserve">
          <source>This returns a function that is the Dirichlet convolution of</source>
          <target state="translated">Esto devuelve una función que es la convolución Dirichlet de</target>
        </trans-unit>
        <trans-unit id="be0f64b2c2ec8d3f096587c95f72324b81820991" translate="yes" xml:space="preserve">
          <source>U&lt;sub&gt;0&lt;/sub&gt;, U&lt;sub&gt;1&lt;/sub&gt;, V&lt;sub&gt;0&lt;/sub&gt;, V&lt;sub&gt;1&lt;/sub&gt; = 0, 1, 2,</source>
          <target state="translated">U &lt;sub&gt;0&lt;/sub&gt; , U &lt;sub&gt;1&lt;/sub&gt; , V &lt;sub&gt;0&lt;/sub&gt; , V &lt;sub&gt;1&lt;/sub&gt; = 0, 1, 2,</target>
        </trans-unit>
        <trans-unit id="6f543f0fb6ad95eac25dec517b35aea6b6271026" translate="yes" xml:space="preserve">
          <source>U&lt;sub&gt;n&lt;/sub&gt; =</source>
          <target state="translated">U &lt;sub&gt;n&lt;/sub&gt; =</target>
        </trans-unit>
        <trans-unit id="53484ab410c786bc6dca5bfa962043fa4e14f083" translate="yes" xml:space="preserve">
          <source>Uses Hensel lifting to generate with some efficiency all zeros of a polynomial modulo a prime power.</source>
          <target state="translated">Utiliza el levantamiento de Hensel para generar con cierta eficiencia todos los ceros de un módulo polinomio una energía primaria.</target>
        </trans-unit>
        <trans-unit id="650cb1ea26f3f3435a90bca9e814486d1548f503" translate="yes" xml:space="preserve">
          <source>Uses a sieve to compute the M&amp;ouml;bius function of all whole numbers strictly less than the input.</source>
          <target state="translated">Utiliza un tamiz para calcular la funci&amp;oacute;n de M&amp;ouml;bius de todos los n&amp;uacute;meros enteros estrictamente menores que la entrada.</target>
        </trans-unit>
        <trans-unit id="1f679058b8f35fc3f4aca9d452840fa97b4831ef" translate="yes" xml:space="preserve">
          <source>Uses a sieve to compute the factorizations of all whole numbers strictly less than the input.  This uses a lot of memory; if you aren&amp;rsquo;t after the factors directly, it&amp;rsquo;s usually better to write a dedicated function for whatever it is that you actually want.</source>
          <target state="translated">Utiliza un tamiz para calcular las factorizaciones de todos los n&amp;uacute;meros enteros estrictamente menores que la entrada. Esto usa mucha memoria; si no busca los factores directamente, generalmente es mejor escribir una funci&amp;oacute;n dedicada para lo que sea que realmente desee.</target>
        </trans-unit>
        <trans-unit id="268fb65f2f3e2f02c488439bf119d606ca64bad0" translate="yes" xml:space="preserve">
          <source>Uses a sieve to compute the number of divisors of all whole numbers strictly less than the input.</source>
          <target state="translated">Utiliza un tamiz para calcular el número de divisores de todos los números enteros estrictamente menor que la entrada.</target>
        </trans-unit>
        <trans-unit id="fe1dbbb529e7c4a4d51aa8fc84b2050e88eb99c6" translate="yes" xml:space="preserve">
          <source>Uses a sieve to compute the totients up to (and including)</source>
          <target state="translated">Utiliza un tamiz para calcular los totients hasta (e incluso)</target>
        </trans-unit>
        <trans-unit id="6c76d71e87a267442fe63baeaaf864ce58a75988" translate="yes" xml:space="preserve">
          <source>Uses the &lt;a href=&quot;http://mathworld.wolfram.com/GramSeries.html&quot;&gt;Gram series&lt;/a&gt; to compute &lt;a href=&quot;http://mathworld.wolfram.com/RiemannPrimeCountingFunction.html&quot;&gt;Riemann&amp;rsquo;s R function&lt;/a&gt;, which is a rather good approximation to</source>
          <target state="translated">Utiliza la &lt;a href=&quot;http://mathworld.wolfram.com/GramSeries.html&quot;&gt;serie de Gram&lt;/a&gt; para calcular la &lt;a href=&quot;http://mathworld.wolfram.com/RiemannPrimeCountingFunction.html&quot;&gt;funci&amp;oacute;n R de Riemann&lt;/a&gt; , que es una aproximaci&amp;oacute;n bastante buena a</target>
        </trans-unit>
        <trans-unit id="4a7d5b6d4db905be914b564683d92a8fcbe1ec25" translate="yes" xml:space="preserve">
          <source>V&lt;sub&gt;n&lt;/sub&gt; =</source>
          <target state="translated">V &lt;sub&gt;n&lt;/sub&gt; =</target>
        </trans-unit>
        <trans-unit id="50e5378d732557779f1154c3575db8e23bb5b3ab" translate="yes" xml:space="preserve">
          <source>We attempt to import</source>
          <target state="translated">Intentamos importar</target>
        </trans-unit>
        <trans-unit id="6c9c8399feaa2614db53d41720cd228e01ec2def" translate="yes" xml:space="preserve">
          <source>We make a few imports:</source>
          <target state="translated">Hacemos algunas importaciones:</target>
        </trans-unit>
        <trans-unit id="18540796a32eeba141c50da1b37a95f4334c7c5a" translate="yes" xml:space="preserve">
          <source>We yield only those solutions with &lt;em&gt;x&lt;/em&gt; &amp;le;</source>
          <target state="translated">Solo obtenemos aquellas soluciones con &lt;em&gt;x&lt;/em&gt; &amp;le;</target>
        </trans-unit>
        <trans-unit id="3bf3f71c4d3d91d72b09100088bc05f6648939f4" translate="yes" xml:space="preserve">
          <source>ZeroDivisionError</source>
          <target state="translated">ZeroDivisionError</target>
        </trans-unit>
        <trans-unit id="d7dbd4deb34730f22194a18ec2062259b1eeb01d" translate="yes" xml:space="preserve">
          <source>[a,b,c,...,d]</source>
          <target state="translated">[a B C D]</target>
        </trans-unit>
        <trans-unit id="6617db25b376b8717487a1efee6f5300001877f1" translate="yes" xml:space="preserve">
          <source>] with its factorization.  Uses Adam Kalai&amp;rsquo;s algorithm, which uses in the average case O(log(</source>
          <target state="translated">] con su factorizaci&amp;oacute;n. Utiliza el algoritmo de Adam Kalai, que utiliza en el caso medio O (log (</target>
        </trans-unit>
        <trans-unit id="86f7e437faa5a7fce15d1ddcb9eaeaea377667b8" translate="yes" xml:space="preserve">
          <source>a</source>
          <target state="translated">a</target>
        </trans-unit>
        <trans-unit id="a9993e364706816aba3e25717850c26c9cd0d89d" translate="yes" xml:space="preserve">
          <source>abc</source>
          <target state="translated">abc</target>
        </trans-unit>
        <trans-unit id="1c0aa26e5d84363b3acc6bf9fbb155954590cbdc" translate="yes" xml:space="preserve">
          <source>abc[0]</source>
          <target state="translated">abc[0]</target>
        </trans-unit>
        <trans-unit id="3e9b0dc45ae3f876b91da0bb3e60fdb7a800b813" translate="yes" xml:space="preserve">
          <source>altseriesaccel</source>
          <target state="translated">altseriesaccel</target>
        </trans-unit>
        <trans-unit id="cffa50a32cb13a240d705317bcec65dd1f31b6ad" translate="yes" xml:space="preserve">
          <source>and</source>
          <target state="translated">en</target>
        </trans-unit>
        <trans-unit id="423e3677a59be7685f327a54c3d1687a5358b06d" translate="yes" xml:space="preserve">
          <source>and any</source>
          <target state="translated">y cualquier</target>
        </trans-unit>
        <trans-unit id="c07674c7f138dc32ab84db4d0b94deee67cf065c" translate="yes" xml:space="preserve">
          <source>and correspond directly to those same operators in Python3 source code.  The acceptable unary operators are</source>
          <target state="translated">y corresponden directamente a esos mismos operadores en el código fuente de Python3.Los operadores unarios aceptables son</target>
        </trans-unit>
        <trans-unit id="7f00744592a776e5ffc4e1d2ec293d7812083856" translate="yes" xml:space="preserve">
          <source>and reduces their coefficients mod</source>
          <target state="translated">y reduce sus coeficientes mod</target>
        </trans-unit>
        <trans-unit id="d16ffb80cfb8fbbc45a3e956afc9384e9d88d3a4" translate="yes" xml:space="preserve">
          <source>and returns the quotient and remainder.  The coefficients are interpreted mod</source>
          <target state="translated">y devuelve el cociente y el resto.Los coeficientes se interpretan mod</target>
        </trans-unit>
        <trans-unit id="8ae7da769a9bfb836cc90735badab7103384f956" translate="yes" xml:space="preserve">
          <source>and returns them in a sorted list.</source>
          <target state="translated">y los devuelve en una lista ordenada.</target>
        </trans-unit>
        <trans-unit id="b083fda8a38221bc976c25ada22cbbc125bf84c5" translate="yes" xml:space="preserve">
          <source>and we have the recursions</source>
          <target state="translated">y tenemos las recurrencias</target>
        </trans-unit>
        <trans-unit id="22a2fa7aecbb23be92b1456ec37e8d661d6284fa" translate="yes" xml:space="preserve">
          <source>appears</source>
          <target state="translated">aparece</target>
        </trans-unit>
        <trans-unit id="e40428569577cb101cb980e869d504664b7d8cb9" translate="yes" xml:space="preserve">
          <source>are for internal use only.</source>
          <target state="translated">son sólo para uso interno.</target>
        </trans-unit>
        <trans-unit id="7eebdb0c22367682ed44a609d37dde0a356d56a1" translate="yes" xml:space="preserve">
          <source>argument indicates that we are to assume an effective abc conjecture of the form &lt;em&gt;c&lt;/em&gt; &amp;lt;</source>
          <target state="translated">El argumento indica que debemos asumir una conjetura abc efectiva de la forma &lt;em&gt;c&lt;/em&gt; &amp;lt;</target>
        </trans-unit>
        <trans-unit id="80f3d3aa79645a7dc0c6783938d48bbec07bb175" translate="yes" xml:space="preserve">
          <source>argument is for memoization.</source>
          <target state="translated">El argumento es para la memorización.</target>
        </trans-unit>
        <trans-unit id="d6bcc82fa6253c3c81129dc64664935466672afb" translate="yes" xml:space="preserve">
          <source>as an initial estimate, computing</source>
          <target state="translated">como una estimación inicial,la computación</target>
        </trans-unit>
        <trans-unit id="28e86607ff751be3dbde36b1a32f0a5776b94eba" translate="yes" xml:space="preserve">
          <source>as appropriate.  This optimization becomes more noticeable as the factoring becomes more difficult.</source>
          <target state="translated">como sea apropiado.Esta optimización se hace más notoria a medida que el factoraje se hace más difícil.</target>
        </trans-unit>
        <trans-unit id="b9d67952547d2d3bfbc0bfae7738b9137def3575" translate="yes" xml:space="preserve">
          <source>as the first component and the relevant power as the second component.  If</source>
          <target state="translated">como el primer componente y la potencia relevante como el segundo componente.Si</target>
        </trans-unit>
        <trans-unit id="8b0167946be499c0984a56eedbabe88e5635374b" translate="yes" xml:space="preserve">
          <source>at the end, so we handle separately the case where this is zero.</source>
          <target state="translated">al final,así que manejamos por separado el caso en el que esto es cero.</target>
        </trans-unit>
        <trans-unit id="e9d71f5ee7c92d6dc9e92ffdad17b8bd49418f98" translate="yes" xml:space="preserve">
          <source>b</source>
          <target state="translated">b</target>
        </trans-unit>
        <trans-unit id="5e45d064f99e8d1f88b05bb3c44e7e3075a0519b" translate="yes" xml:space="preserve">
          <source>bail</source>
          <target state="translated">fianza</target>
        </trans-unit>
        <trans-unit id="73c57301af9ef7b2b0d5217fa1fe9d631261d791" translate="yes" xml:space="preserve">
          <source>be a function on the positive integers, let</source>
          <target state="translated">sea una función de los números enteros positivos,que</target>
        </trans-unit>
        <trans-unit id="3df79c1e257a045b9ac776f1735507406ca949bb" translate="yes" xml:space="preserve">
          <source>be a positive integer, and let</source>
          <target state="translated">ser un entero positivo,y dejar</target>
        </trans-unit>
        <trans-unit id="190cd0c12bb8723300924a9625c187781783a04a" translate="yes" xml:space="preserve">
          <source>be integers such that</source>
          <target state="translated">ser enteros de tal manera que</target>
        </trans-unit>
        <trans-unit id="e86873283164dede4e8a6cce779c4e7fc5af7b01" translate="yes" xml:space="preserve">
          <source>bool(pell(D,N)[0])</source>
          <target state="translated">bool(pell(D,N)[0])</target>
        </trans-unit>
        <trans-unit id="5d25966d3e4427fff6f97ed668cf8e9d4ad58871" translate="yes" xml:space="preserve">
          <source>bpsw</source>
          <target state="translated">bpsw</target>
        </trans-unit>
        <trans-unit id="2cdf265410b6b700b91d7e3971139954d36d0f32" translate="yes" xml:space="preserve">
          <source>by applying</source>
          <target state="translated">aplicando</target>
        </trans-unit>
        <trans-unit id="25157648db89193cfdd9a993e256ec3b08c238c5" translate="yes" xml:space="preserve">
          <source>by the polynomial</source>
          <target state="translated">por el polinomio</target>
        </trans-unit>
        <trans-unit id="84a516841ba77a5b4648de2cd0dfcb30ea46dbb4" translate="yes" xml:space="preserve">
          <source>c</source>
          <target state="translated">c</target>
        </trans-unit>
        <trans-unit id="c4141200bfaed15b39f7442caa7d497f9c7a7989" translate="yes" xml:space="preserve">
          <source>coefs[k]</source>
          <target state="translated">coefs[k]</target>
        </trans-unit>
        <trans-unit id="0b9702797aab9ff35839ab8ce2e06faf7475d013" translate="yes" xml:space="preserve">
          <source>cubicintroots</source>
          <target state="translated">cubicintroots</target>
        </trans-unit>
        <trans-unit id="d6269a84026917e0fccb6e13db680fd34c155dc4" translate="yes" xml:space="preserve">
          <source>cubicintrootsgiven</source>
          <target state="translated">cubicintrootsgiven</target>
        </trans-unit>
        <trans-unit id="3c363836cf4e16666669a25da280a1865c2d2874" translate="yes" xml:space="preserve">
          <source>d</source>
          <target state="translated">d</target>
        </trans-unit>
        <trans-unit id="01b75b0700101b4727bfc89c1cd712b5c78499d8" translate="yes" xml:space="preserve">
          <source>dirconv</source>
          <target state="translated">dirconv</target>
        </trans-unit>
        <trans-unit id="d786253dcca71d5ff20ce9683b44794b24b476a5" translate="yes" xml:space="preserve">
          <source>dirichletinverse(f)</source>
          <target state="translated">dirichletinverse(f)</target>
        </trans-unit>
        <trans-unit id="03e669c63f3bfb43b5c8c3d259c64bb578bf84b5" translate="yes" xml:space="preserve">
          <source>dirichletinverse(f)(n)</source>
          <target state="translated">dirichletinverse(f)(n)</target>
        </trans-unit>
        <trans-unit id="5c58ad317c477f6ef15fd5698c2c3b7cd842cccd" translate="yes" xml:space="preserve">
          <source>divisors_factored(n)</source>
          <target state="translated">divisors_factored(n)</target>
        </trans-unit>
        <trans-unit id="58e6b3a414a1e090dfc6029add0f3555ccba127f" translate="yes" xml:space="preserve">
          <source>e</source>
          <target state="translated">e</target>
        </trans-unit>
        <trans-unit id="734f507c6428f42e9214bdadddde151f7712696e" translate="yes" xml:space="preserve">
          <source>ecm</source>
          <target state="translated">ecm</target>
        </trans-unit>
        <trans-unit id="0c236606d901bf5b5cffebee509cbfc994dbd6c2" translate="yes" xml:space="preserve">
          <source>ecmparams</source>
          <target state="translated">ecmparams</target>
        </trans-unit>
        <trans-unit id="338362566cc17e29060463088b729a5471909d9a" translate="yes" xml:space="preserve">
          <source>efficiently.</source>
          <target state="translated">de manera eficiente.</target>
        </trans-unit>
        <trans-unit id="4a0a19218e082a343a1b17e5333409af9d98f0f5" translate="yes" xml:space="preserve">
          <source>f</source>
          <target state="translated">f</target>
        </trans-unit>
        <trans-unit id="315206ca84dc4ce4fe812e2863ee8eb264ac0dd0" translate="yes" xml:space="preserve">
          <source>f == []</source>
          <target state="translated">f ==[]</target>
        </trans-unit>
        <trans-unit id="b6af140f0f8a203779ba6dfe7596f459c4f59ac2" translate="yes" xml:space="preserve">
          <source>f == totient</source>
          <target state="translated">f ==totient</target>
        </trans-unit>
        <trans-unit id="647df68c0784177b0691d73d2f9e3d8cd45d5e46" translate="yes" xml:space="preserve">
          <source>ffac=True</source>
          <target state="translated">ffac=Verdad</target>
        </trans-unit>
        <trans-unit id="4031de3cf69373e17eedea3cc0ca9bb57f697583" translate="yes" xml:space="preserve">
          <source>fibo(0)</source>
          <target state="translated">fibo(0)</target>
        </trans-unit>
        <trans-unit id="c8aae4bf7819bae8ea1d14dbff76238d6f3c650d" translate="yes" xml:space="preserve">
          <source>fibo(1)</source>
          <target state="translated">fibo(1)</target>
        </trans-unit>
        <trans-unit id="4205d665cf378fdbadc87b71e15cd669937c2d05" translate="yes" xml:space="preserve">
          <source>fibo(2)</source>
          <target state="translated">fibo(2)</target>
        </trans-unit>
        <trans-unit id="43eef9a62abb8b1e1654f8a890aae054abffa82b" translate="yes" xml:space="preserve">
          <source>for</source>
          <target state="translated">para</target>
        </trans-unit>
        <trans-unit id="a7668f7b918080cace2b7647399809cb46f37464" translate="yes" xml:space="preserve">
          <source>for any such</source>
          <target state="translated">para cualquier</target>
        </trans-unit>
        <trans-unit id="d47ef507fd3562f713ba06d3c342a8541272e806" translate="yes" xml:space="preserve">
          <source>fractions</source>
          <target state="translated">fracciones</target>
        </trans-unit>
        <trans-unit id="0b1e95cfd9775191a7224d0a218ae79187e80c1d" translate="yes" xml:space="preserve">
          <source>from</source>
          <target state="translated">de</target>
        </trans-unit>
        <trans-unit id="cac02ec1a476ed80dfd51b02515cb2a3bd581ae2" translate="yes" xml:space="preserve">
          <source>function.</source>
          <target state="translated">función.</target>
        </trans-unit>
        <trans-unit id="54fd1711209fb1c0781092374132c66e79e2241b" translate="yes" xml:space="preserve">
          <source>g</source>
          <target state="translated">g</target>
        </trans-unit>
        <trans-unit id="6f82a25f8a9d9d0f82e257528ce180c65281f0be" translate="yes" xml:space="preserve">
          <source>g == mobius</source>
          <target state="translated">g ==mobius</target>
        </trans-unit>
        <trans-unit id="08da69a048896f64e8d2f2f7e539609be66ba12a" translate="yes" xml:space="preserve">
          <source>gcd(D,m)!=1</source>
          <target state="translated">gcd(D,m)!=1</target>
        </trans-unit>
        <trans-unit id="4739319abf9070ef0b0e2a73224820ae70488aa6" translate="yes" xml:space="preserve">
          <source>gen</source>
          <target state="translated">gen</target>
        </trans-unit>
        <trans-unit id="7a164e09344c9505c271c6d424b2da33c3fd3e5b" translate="yes" xml:space="preserve">
          <source>gfac=True</source>
          <target state="translated">gfac=Verdad</target>
        </trans-unit>
        <trans-unit id="7b23189c90eff94402b89369c93f483db6c41344" translate="yes" xml:space="preserve">
          <source>given two bounds and a seed.</source>
          <target state="translated">dado dos límites y una semilla.</target>
        </trans-unit>
        <trans-unit id="55359a446e39ee32617d7d3eea49ead78bddb1c6" translate="yes" xml:space="preserve">
          <source>gmpy2</source>
          <target state="translated">gmpy2</target>
        </trans-unit>
        <trans-unit id="e754a4d398e711f0a035b3fd04202c34a51014bb" translate="yes" xml:space="preserve">
          <source>has a repeated prime factor.</source>
          <target state="translated">tiene un factor primordial repetido.</target>
        </trans-unit>
        <trans-unit id="443e0256a4f3233c27654ce6540d09aa085b841d" translate="yes" xml:space="preserve">
          <source>heapq</source>
          <target state="translated">heapq</target>
        </trans-unit>
        <trans-unit id="92005ecf3788faea8346a7919fba0232188561ab" translate="yes" xml:space="preserve">
          <source>help</source>
          <target state="translated">ayuda</target>
        </trans-unit>
        <trans-unit id="958f57f57d72a30f329ee5538f21b0257a49a46e" translate="yes" xml:space="preserve">
          <source>if</source>
          <target state="translated">si</target>
        </trans-unit>
        <trans-unit id="5d98b52e53a617b661aa195fa572770a19c4f092" translate="yes" xml:space="preserve">
          <source>if it isn&amp;rsquo;t.</source>
          <target state="translated">si no lo es.</target>
        </trans-unit>
        <trans-unit id="0ee6fa9ba4ab0cdaaf258ad7f3d55d7b283fd5be" translate="yes" xml:space="preserve">
          <source>if no such prime exists.</source>
          <target state="translated">si no existe tal primo.</target>
        </trans-unit>
        <trans-unit id="a8ce66926ac0d9289255d559e051bbcaf199f26f" translate="yes" xml:space="preserve">
          <source>in such situations is quite a bit slower due to the time-complexity of multiplication.  However, the size of the problem required to make this superior to</source>
          <target state="translated">en tales situaciones es bastante más lenta debido a la complejidad temporal de la multiplicación.Sin embargo,el tamaño del problema requerido para hacer esto superior a</target>
        </trans-unit>
        <trans-unit id="faca05ba26b44ae973be06d817f90318ac1402ce" translate="yes" xml:space="preserve">
          <source>in the Farey sequence of maximum denominator</source>
          <target state="translated">en la secuencia de Farey del máximo denominador</target>
        </trans-unit>
        <trans-unit id="55fcda190a7af7698ada9d66dd1192d726e588d5" translate="yes" xml:space="preserve">
          <source>instead and feed those factored divisors into</source>
          <target state="translated">en su lugar y alimentar esos divisores factorizados en</target>
        </trans-unit>
        <trans-unit id="370b5e19dba599f512446f6d2f8b476541cdea11" translate="yes" xml:space="preserve">
          <source>into a dictionary with primes as keys and multiplicities as values.</source>
          <target state="translated">en un diccionario con los primos como claves y las multiplicidades como valores.</target>
        </trans-unit>
        <trans-unit id="b47f363e2b430c0647f14deea3eced9b0ef300ce" translate="yes" xml:space="preserve">
          <source>is</source>
          <target state="translated">es</target>
        </trans-unit>
        <trans-unit id="d2c35916878942bd128e969cbd953d99f1f91da4" translate="yes" xml:space="preserve">
          <source>is a cache of zeta values.</source>
          <target state="translated">es un caché de valores zeta.</target>
        </trans-unit>
        <trans-unit id="49c27f5f42d7861345685e0bd678d6535d255e89" translate="yes" xml:space="preserve">
          <source>is a large real number.</source>
          <target state="translated">es un gran número real.</target>
        </trans-unit>
        <trans-unit id="37953ec8e60d66fab1e5fe90650d66d06c0ca1eb" translate="yes" xml:space="preserve">
          <source>is a list of primes.</source>
          <target state="translated">es una lista de primos.</target>
        </trans-unit>
        <trans-unit id="f92be3654d8664bc640994b103f65c28ef1c9260" translate="yes" xml:space="preserve">
          <source>is a nonsquare, then there are no further solutions.</source>
          <target state="translated">es un no-cuadrado,entonces no hay más soluciones.</target>
        </trans-unit>
        <trans-unit id="341599309574d8056f163a056a090a62f656d1c6" translate="yes" xml:space="preserve">
          <source>is a nonsquare, then there are no solutions.</source>
          <target state="translated">es un no-cuadrado,entonces no hay soluciones.</target>
        </trans-unit>
        <trans-unit id="80f9364c732c11c24a040bca417f9a10802782d7" translate="yes" xml:space="preserve">
          <source>is a nonsquare, then we run the PQa/LMM algorithms: we produce a set of primitive solutions; if this set is empty, there are no solutions; if this set has members, an ininite set of solutions can be produced by repeatedly composing them with the fundamental solution of &lt;em&gt;x&lt;/em&gt;&lt;sup&gt;2&lt;/sup&gt; -</source>
          <target state="translated">es un no cuadrado, luego ejecutamos los algoritmos PQa / LMM: producimos un conjunto de soluciones primitivas; si este conjunto est&amp;aacute; vac&amp;iacute;o, no hay soluciones; si este conjunto tiene miembros, se puede producir un conjunto infinito de soluciones componi&amp;eacute;ndolos repetidamente con la soluci&amp;oacute;n fundamental de &lt;em&gt;x &lt;/em&gt;&lt;sup&gt;2&lt;/sup&gt; -</target>
        </trans-unit>
        <trans-unit id="64b6d8423fedee44b9be667f778516d17fd9a6ef" translate="yes" xml:space="preserve">
          <source>is a perfect</source>
          <target state="translated">es un perfecto</target>
        </trans-unit>
        <trans-unit id="64b01ce8605073ca5d678688bf82d0be37b37679" translate="yes" xml:space="preserve">
          <source>is a perfect power, return a tuple containing the largest integer that, when squares/cubed/etc, yields</source>
          <target state="translated">es una potencia perfecta,devuelve una tupla que contiene el mayor número entero que,cuando es cuadrada/cubierta/etc.,produce</target>
        </trans-unit>
        <trans-unit id="898e94e521c1d947cb6950eaefe9dcdaf235b4d4" translate="yes" xml:space="preserve">
          <source>is a practical number &amp;ndash; i.e., whether every integer from 1 through</source>
          <target state="translated">es un n&amp;uacute;mero pr&amp;aacute;ctico, es decir, si cada entero desde 1 hasta</target>
        </trans-unit>
        <trans-unit id="a15b27d2d0f9b5a9d370396f415a9edeff569d20" translate="yes" xml:space="preserve">
          <source>is a prime and</source>
          <target state="translated">es un primer y</target>
        </trans-unit>
        <trans-unit id="fbaef629941ab443a5ffeaa9ce47284805e6064a" translate="yes" xml:space="preserve">
          <source>is a quadratic residue mod</source>
          <target state="translated">es un residuo cuadrático mod</target>
        </trans-unit>
        <trans-unit id="fc91dc9cd2dbb46bd4d18da2d9eedb19d417f61f" translate="yes" xml:space="preserve">
          <source>is a quadratic residue modulo</source>
          <target state="translated">es un módulo de residuos cuadrático</target>
        </trans-unit>
        <trans-unit id="38cfc281fba7a65b9cd32bd53f871e16a91c971c" translate="yes" xml:space="preserve">
          <source>is a square, then the number of solutions will be at most finite.  This case is solved by factoring.</source>
          <target state="translated">es un cuadrado,entonces el número de soluciones será como mucho finito.Este caso se resuelve mediante la factorización.</target>
        </trans-unit>
        <trans-unit id="76ac02c7f30e492c27f4726d0fce17f942f33edc" translate="yes" xml:space="preserve">
          <source>is a square, then there are infinitely many solutions, parametrized by (&amp;radic;</source>
          <target state="translated">es un cuadrado, entonces hay infinitas soluciones, parametrizadas por (&amp;radic;</target>
        </trans-unit>
        <trans-unit id="c9072bff9a277a0980d8f18701c036a3e095ab9e" translate="yes" xml:space="preserve">
          <source>is a square, then there are infinitely many solutions, parametrized by (&lt;em&gt;t&lt;/em&gt;&amp;middot;&amp;radic;</source>
          <target state="translated">es un cuadrado, entonces hay infinitas soluciones, parametrizadas por ( &lt;em&gt;t&lt;/em&gt; &amp;middot; &amp;radic;</target>
        </trans-unit>
        <trans-unit id="b29247d5558ad7494843a5a1d98fab25b653c0bd" translate="yes" xml:space="preserve">
          <source>is an</source>
          <target state="translated">es un</target>
        </trans-unit>
        <trans-unit id="875e5add0137d5a23ab53431827f809f09c84dc1" translate="yes" xml:space="preserve">
          <source>is called and we will call</source>
          <target state="translated">se llama y llamaremos</target>
        </trans-unit>
        <trans-unit id="6fd0c436112330430676f2dd96c3c0922cc6a799" translate="yes" xml:space="preserve">
          <source>is concerned with the general equation, which may or may not have trivial solutions, and as such yields all non-negative solutions, whereas this function is concerned only with the simple Pell equation, which always has an infinite family of positive solutions generated from a single primitive solution and always has the trivial solution (1,0).</source>
          <target state="translated">se ocupa de la ecuación general,que puede o no tener soluciones triviales,y como tal arroja todas las soluciones no negativas,mientras que esta función sólo se ocupa de la simple ecuación de Pell,que siempre tiene una familia infinita de soluciones positivas generadas a partir de una única solución primitiva y siempre tiene la solución trivial (1,0).</target>
        </trans-unit>
        <trans-unit id="8bea43bb939ee6ac17ba706d8fae419a2185708b" translate="yes" xml:space="preserve">
          <source>is even.</source>
          <target state="translated">es parejo.</target>
        </trans-unit>
        <trans-unit id="68f46528d8fc83cad934a1f14d8a844237021693" translate="yes" xml:space="preserve">
          <source>is handled properly.</source>
          <target state="translated">se maneja adecuadamente.</target>
        </trans-unit>
        <trans-unit id="48b31bfadc2521825ca08da6c36aa727b913ef52" translate="yes" xml:space="preserve">
          <source>is machine-indistinguishable from 1.0 &amp;mdash; in particular, when</source>
          <target state="translated">es indistinguible de la m&amp;aacute;quina de 1.0, en particular, cuando</target>
        </trans-unit>
        <trans-unit id="10534b02e6a6fc675401f5f0d9796a5234abd865" translate="yes" xml:space="preserve">
          <source>is not a perfect power, return</source>
          <target state="translated">no es un poder perfecto,regresa</target>
        </trans-unit>
        <trans-unit id="f455949b391b3e0789873e7c48e4188a0e154490" translate="yes" xml:space="preserve">
          <source>is not coprime to</source>
          <target state="translated">no es un coprimo para</target>
        </trans-unit>
        <trans-unit id="2fab3805742595a909144bab6b06c2c73eaa8cdb" translate="yes" xml:space="preserve">
          <source>is prime, then</source>
          <target state="translated">es primordial,entonces</target>
        </trans-unit>
        <trans-unit id="4c6563279f43ae5dc1a83638491dbb425bc13151" translate="yes" xml:space="preserve">
          <source>is prime, we immediately return</source>
          <target state="translated">es primo,regresamos inmediatamente</target>
        </trans-unit>
        <trans-unit id="4155e05f59fd1e42f3aef2d244af0456c4369b33" translate="yes" xml:space="preserve">
          <source>is prime.  If the provided (partial) factorization of</source>
          <target state="translated">es primordial.Si la factorización (parcial)proporcionada de</target>
        </trans-unit>
        <trans-unit id="0c686c58ef3a3ae2d4c671c5ce861d019d03c96f" translate="yes" xml:space="preserve">
          <source>is quite large, so</source>
          <target state="translated">es bastante grande,así que</target>
        </trans-unit>
        <trans-unit id="91b2fff06e4ed4d3cfda3e66159035cfcf06cc84" translate="yes" xml:space="preserve">
          <source>is raised to the</source>
          <target state="translated">se eleva a la</target>
        </trans-unit>
        <trans-unit id="9f389ffaacb07667243a85f2131fec4cdd1b17b4" translate="yes" xml:space="preserve">
          <source>is squarefree with an even number of prime factors, -1 if</source>
          <target state="translated">es al cuadrado con un número par de factores primos,-1 si</target>
        </trans-unit>
        <trans-unit id="477716014edf48baa262a068be894f69d10aacda" translate="yes" xml:space="preserve">
          <source>is squarefree with an odd number of prime factors, and 0 if</source>
          <target state="translated">es al cuadrado con un número impar de factores primos,y 0 si</target>
        </trans-unit>
        <trans-unit id="f9d8d585ccc0941d1f852facf4c17ea42f55ad55" translate="yes" xml:space="preserve">
          <source>is supplied, terms are computed modulo</source>
          <target state="translated">se suministra,los términos se calculan por módulos</target>
        </trans-unit>
        <trans-unit id="7f0b64bf2ff0248f24db942aa41c34c4454057e8" translate="yes" xml:space="preserve">
          <source>is supplied, then we compute the sequence modulo</source>
          <target state="translated">se suministra,entonces calculamos el módulo de secuencia</target>
        </trans-unit>
        <trans-unit id="9d5047cbf7ceac0110790548ce311421463adfa5" translate="yes" xml:space="preserve">
          <source>is the coefficient of the &lt;em&gt;x&lt;/em&gt;&lt;sup&gt;k&lt;/sup&gt; term.  For low-degree polynomials, explicit formulae are used; for degrees 5 and higher, we compute it by taking the determinant (using this package&amp;rsquo;s determinant() function) of the Sylvester matrix of the input and its derivative.  This in turn is calculated by the Schur determinant identity.  Note that this has the effect of setting the discriminant of a linear polynomial to 1 (which is conventional) and that of a constant to 0.</source>
          <target state="translated">es el coeficiente del t&amp;eacute;rmino &lt;em&gt;x &lt;/em&gt;&lt;sup&gt;k&lt;/sup&gt; . Para polinomios de bajo grado, se utilizan f&amp;oacute;rmulas expl&amp;iacute;citas; para los grados 5 y superiores, lo calculamos tomando el determinante (usando la funci&amp;oacute;n determinante () de este paquete) de la matriz de Sylvester de la entrada y su derivada. Esto a su vez se calcula mediante la identidad determinante de Schur. Tenga en cuenta que esto tiene el efecto de establecer el discriminante de un polinomio lineal en 1 (que es convencional) y el de una constante en 0.</target>
        </trans-unit>
        <trans-unit id="57a53471fa92992c70d886f43da37b86b714d40d" translate="yes" xml:space="preserve">
          <source>is the fundamental solution &amp;mdash; i.e.,</source>
          <target state="translated">es la soluci&amp;oacute;n fundamental, es decir,</target>
        </trans-unit>
        <trans-unit id="67c4b407d69ca8235090663680de79b94b491522" translate="yes" xml:space="preserve">
          <source>is the minimal reptend.</source>
          <target state="translated">es la respuesta mínima.</target>
        </trans-unit>
        <trans-unit id="d4842b1baa18b36449c7d350288c94b9f4cefa2c" translate="yes" xml:space="preserve">
          <source>is the primitive solution of &lt;em&gt;x&lt;/em&gt;&lt;sup&gt;2&lt;/sup&gt; -</source>
          <target state="translated">es la soluci&amp;oacute;n primitiva de &lt;em&gt;x &lt;/em&gt;&lt;sup&gt;2&lt;/sup&gt; -</target>
        </trans-unit>
        <trans-unit id="b5c0a1b4dce5ac35b3bdf19568dc7d32d1ef6f5e" translate="yes" xml:space="preserve">
          <source>is the set of primitive solutions, represented as a sorted list, and</source>
          <target state="translated">es el conjunto de soluciones primitivas,representado como una lista ordenada,y</target>
        </trans-unit>
        <trans-unit id="9ab5df466d8fec7d686d0e8fd0a386420c3f1cf1" translate="yes" xml:space="preserve">
          <source>is the sorted list of all solutions.</source>
          <target state="translated">es la lista ordenada de todas las soluciones.</target>
        </trans-unit>
        <trans-unit id="15e7f952825b4d23ab0795f41f932fe99e0c1773" translate="yes" xml:space="preserve">
          <source>is used for memoization.  We compute O(log(</source>
          <target state="translated">se utiliza para la memorización.Calculamos O(log(</target>
        </trans-unit>
        <trans-unit id="208fcfc75abb7f097c431f4754f7d964cd0a8e48" translate="yes" xml:space="preserve">
          <source>isn&amp;rsquo;t prime.</source>
          <target state="translated">no es primo.</target>
        </trans-unit>
        <trans-unit id="f38786758717970fc3a6e4cfa07bcf41bc853729" translate="yes" xml:space="preserve">
          <source>isprime_nm1</source>
          <target state="translated">isprime_nm1</target>
        </trans-unit>
        <trans-unit id="79a7da32928063c3bcec9b019a5f385da5b29a94" translate="yes" xml:space="preserve">
          <source>iterprod()</source>
          <target state="translated">iterprod()</target>
        </trans-unit>
        <trans-unit id="9e9cf1097fbb8c0af843641c0e32781c81ce4931" translate="yes" xml:space="preserve">
          <source>itertools</source>
          <target state="translated">itertools</target>
        </trans-unit>
        <trans-unit id="13fbd79c3d390e5d6585a21e11ff5ec1970cff0c" translate="yes" xml:space="preserve">
          <source>k</source>
          <target state="translated">k</target>
        </trans-unit>
        <trans-unit id="d685a407748e8849f1263505263236c59b428388" translate="yes" xml:space="preserve">
          <source>labmath version 1.1.1</source>
          <target state="translated">labmath versión 1.1.1</target>
        </trans-unit>
        <trans-unit id="9ea6002473329c9bf2c6ce211d19c4f47133e091" translate="yes" xml:space="preserve">
          <source>lambda n: sum(f(d) * g(n//d) for d in divisors(n))</source>
          <target state="translated">lambda n:suma(f(d)*g(n//d)para d en divisores(n))</target>
        </trans-unit>
        <trans-unit id="edc17dae351b8e294814eb2f719beba8b1876028" translate="yes" xml:space="preserve">
          <source>linrec</source>
          <target state="translated">linrec</target>
        </trans-unit>
        <trans-unit id="8e700c01a0954d94b4069bd7604563c4d444e2cd" translate="yes" xml:space="preserve">
          <source>lprp</source>
          <target state="translated">lprp</target>
        </trans-unit>
        <trans-unit id="10c25665e49274c39b8e8f7ad6e2a3d0b0bc5052" translate="yes" xml:space="preserve">
          <source>lucas</source>
          <target state="translated">lucas</target>
        </trans-unit>
        <trans-unit id="4e6198a411bd3928707503b4ce13a0500e756f47" translate="yes" xml:space="preserve">
          <source>lucasgen</source>
          <target state="translated">lucasgen</target>
        </trans-unit>
        <trans-unit id="6b0d31c0d563223024da45691584643ac78c96e8" translate="yes" xml:space="preserve">
          <source>m</source>
          <target state="translated">m</target>
        </trans-unit>
        <trans-unit id="9268abd0a926b297f7d2180b19d2be452ef0964a" translate="yes" xml:space="preserve">
          <source>m-1</source>
          <target state="translated">m-1</target>
        </trans-unit>
        <trans-unit id="7a488390a939c4795cc1a801e51751d5f25d800d" translate="yes" xml:space="preserve">
          <source>math</source>
          <target state="translated">matemáticas</target>
        </trans-unit>
        <trans-unit id="3fc66ee357145c86940bacd83291c9da3c204322" translate="yes" xml:space="preserve">
          <source>mods</source>
          <target state="translated">mods</target>
        </trans-unit>
        <trans-unit id="c22f2817741e0e875ad47ea68515f3a3691c8876" translate="yes" xml:space="preserve">
          <source>module).</source>
          <target state="translated">módulo).</target>
        </trans-unit>
        <trans-unit id="1af60b7b96e08873e7bd780893eed25aa7a430b1" translate="yes" xml:space="preserve">
          <source>modulo</source>
          <target state="translated">modulo</target>
        </trans-unit>
        <trans-unit id="4f1840a0bd0f57b4f24320a5c9ca1f875417a203" translate="yes" xml:space="preserve">
          <source>mpqs</source>
          <target state="translated">mpqs</target>
        </trans-unit>
        <trans-unit id="481e642078ce8449a05189acf3c45795b499a245" translate="yes" xml:space="preserve">
          <source>mpz</source>
          <target state="translated">mpz</target>
        </trans-unit>
        <trans-unit id="37fa789244ba067512edeee7a888d433532a0423" translate="yes" xml:space="preserve">
          <source>mpz = int</source>
          <target state="translated">mpz=int</target>
        </trans-unit>
        <trans-unit id="a5bd8289887f3cf122e499e17ebfeef374ec32de" translate="yes" xml:space="preserve">
          <source>multiprocessing</source>
          <target state="translated">multiprocesamiento</target>
        </trans-unit>
        <trans-unit id="9d1aeca2487d24afd325ff8eed2de7cabbd00552" translate="yes" xml:space="preserve">
          <source>must be pairwise coprime.</source>
          <target state="translated">debe ser un coprimo a pares.</target>
        </trans-unit>
        <trans-unit id="d1854cae891ec7b29161ccaf79a24b00c274bdaa" translate="yes" xml:space="preserve">
          <source>n</source>
          <target state="translated">n</target>
        </trans-unit>
        <trans-unit id="6d5e3b4bf5f0b282c1e25ab574b570589a155b0f" translate="yes" xml:space="preserve">
          <source>needs to factor its argument, such as</source>
          <target state="translated">necesita factorizar su argumento,como</target>
        </trans-unit>
        <trans-unit id="b206c000b5b327ffef54cb8d8683dc454cbf29a5" translate="yes" xml:space="preserve">
          <source>ngonal(1, n)</source>
          <target state="translated">ngonal(1,n)</target>
        </trans-unit>
        <trans-unit id="b044148d4bbf95d9708824ff4c61842411fb88b5" translate="yes" xml:space="preserve">
          <source>nprocs==1</source>
          <target state="translated">nprocs==1</target>
        </trans-unit>
        <trans-unit id="53edb37c3102831286c713f27b3cbf2fac86b534" translate="yes" xml:space="preserve">
          <source>nthprimeapprox</source>
          <target state="translated">nthprimeapprox</target>
        </trans-unit>
        <trans-unit id="8c7dd71795f90a543d5e74dce04d14e5e6d5c855" translate="yes" xml:space="preserve">
          <source>objects (as imported from the</source>
          <target state="translated">objetos (como los importados de la</target>
        </trans-unit>
        <trans-unit id="f1a4fd6d24ae912e143e2c8c2cb19ede84f74be8" translate="yes" xml:space="preserve">
          <source>of prime numbers, there are only finitely many pairs of consecutive integers that are both</source>
          <target state="translated">de números primos,sólo hay finamente muchos pares de enteros consecutivos que son ambos</target>
        </trans-unit>
        <trans-unit id="e9175e26e936a570297c6dd401d37eeb01d9bffd" translate="yes" xml:space="preserve">
          <source>of that, and then sieving to remove the error.</source>
          <target state="translated">de eso,y luego tamizar para eliminar el error.</target>
        </trans-unit>
        <trans-unit id="1758356db21759f7c5a0da9b4dd1db8fd6feab3f" translate="yes" xml:space="preserve">
          <source>or</source>
          <target state="translated">lub</target>
        </trans-unit>
        <trans-unit id="4c51633dc554ed687fdde317b3f1058f65a348b9" translate="yes" xml:space="preserve">
          <source>or something like that, then that lambda expression calls the factorizer a lot more than it needs to &amp;mdash; we&amp;rsquo;re already factoring</source>
          <target state="translated">o algo as&amp;iacute;, entonces esa expresi&amp;oacute;n lambda llama al factorizador mucho m&amp;aacute;s de lo necesario; ya estamos factorizando</target>
        </trans-unit>
        <trans-unit id="516b9783fca517eecbd1d064da2d165310b19759" translate="yes" xml:space="preserve">
          <source>p</source>
          <target state="translated">p</target>
        </trans-unit>
        <trans-unit id="fcf2989b3c5176b44dd95fdcb12150ddb41778bd" translate="yes" xml:space="preserve">
          <source>p!</source>
          <target state="translated">p!</target>
        </trans-unit>
        <trans-unit id="909e6bf0ca53b6aa378c1e94b0db124a102075e2" translate="yes" xml:space="preserve">
          <source>parts</source>
          <target state="translated">partes</target>
        </trans-unit>
        <trans-unit id="f2fe328ab8bf537c8ecbafd3dd78355075319ce3" translate="yes" xml:space="preserve">
          <source>pell</source>
          <target state="translated">pell</target>
        </trans-unit>
        <trans-unit id="330e4c7e45b01dbbadae4a6cdb2900237e134555" translate="yes" xml:space="preserve">
          <source>pell(D,1)[0]</source>
          <target state="translated">pell(D,1)[0]</target>
        </trans-unit>
        <trans-unit id="defa78cbf02e07b7906c773ac2bc8c860c69def5" translate="yes" xml:space="preserve">
          <source>phicache</source>
          <target state="translated">phicache</target>
        </trans-unit>
        <trans-unit id="4fcdd83743538a0257f58dcef6480c381fd0adff" translate="yes" xml:space="preserve">
          <source>pichache</source>
          <target state="translated">pichache</target>
        </trans-unit>
        <trans-unit id="5e5ff4c6603b930f0e155df26b926d83b86595f0" translate="yes" xml:space="preserve">
          <source>primefac</source>
          <target state="translated">primefac</target>
        </trans-unit>
        <trans-unit id="1514bdcddbf1f72bde938b0ca19ed1f15159d0ee" translate="yes" xml:space="preserve">
          <source>primepi</source>
          <target state="translated">primepi</target>
        </trans-unit>
        <trans-unit id="c67f1ee17880030ce11821dcc9be7af90b863d9b" translate="yes" xml:space="preserve">
          <source>ps</source>
          <target state="translated">ps</target>
        </trans-unit>
        <trans-unit id="22ea1c649c82946aa6e479e1ffd321e4a318b1b0" translate="yes" xml:space="preserve">
          <source>q</source>
          <target state="translated">q</target>
        </trans-unit>
        <trans-unit id="4dc7c9ec434ed06502767136789763ec11d2c4b7" translate="yes" xml:space="preserve">
          <source>r</source>
          <target state="translated">r</target>
        </trans-unit>
        <trans-unit id="a415ab5cc17c8c093c015ccdb7e552aee7911aa4" translate="yes" xml:space="preserve">
          <source>random</source>
          <target state="translated">al azar</target>
        </trans-unit>
        <trans-unit id="0aa526fef0364a6010e9a179dd3199d9e5fadcd8" translate="yes" xml:space="preserve">
          <source>range(iterprod(mods))</source>
          <target state="translated">rango(iterprod(mods))</target>
        </trans-unit>
        <trans-unit id="e1d98009a67f2aeb1d78cab5a72f9d99082b0340" translate="yes" xml:space="preserve">
          <source>reduce(lambda x,y: x*y, a)</source>
          <target state="translated">reducir(lambda x,y:x*y,a)</target>
        </trans-unit>
        <trans-unit id="4a9f9e7ff9f4b5aa4264aba8bbd30d1c6dc892e9" translate="yes" xml:space="preserve">
          <source>riemannzeta(n)</source>
          <target state="translated">riemannzeta(s)</target>
        </trans-unit>
        <trans-unit id="139262cfb795de87ca2c68ffa51eb483edac019f" translate="yes" xml:space="preserve">
          <source>riemannzeta(n, k) - 1</source>
          <target state="translated">riemannzeta(n,k)-1</target>
        </trans-unit>
        <trans-unit id="1737d3a2dc46463ad1bf10bf62768a92500b3111" translate="yes" xml:space="preserve">
          <source>secm</source>
          <target state="translated">secm</target>
        </trans-unit>
        <trans-unit id="925dc46d581dd0d18f35a2c0fb07716dc1efcd86" translate="yes" xml:space="preserve">
          <source>should be sorted in decreasing order.</source>
          <target state="translated">deben ser ordenados en orden decreciente.</target>
        </trans-unit>
        <trans-unit id="7d13cc40a337e3f1ae20e91e68728dde0958d1d9" translate="yes" xml:space="preserve">
          <source>should usually be used instead.</source>
          <target state="translated">debería utilizarse en su lugar.</target>
        </trans-unit>
        <trans-unit id="abe2b85a053eeba46422394e9f07fd9592ac7fb4" translate="yes" xml:space="preserve">
          <source>slprp</source>
          <target state="translated">slprp</target>
        </trans-unit>
        <trans-unit id="295188241a81ec69699501e1cd20e5df674d028e" translate="yes" xml:space="preserve">
          <source>sqrts</source>
          <target state="translated">sqrts</target>
        </trans-unit>
        <trans-unit id="fdca81ff0033bd52e01e0c38528c9264aeefc4ea" translate="yes" xml:space="preserve">
          <source>such that</source>
          <target state="translated">de tal manera que</target>
        </trans-unit>
        <trans-unit id="20846584c637996ddae8a85fd4e9014218cf8219" translate="yes" xml:space="preserve">
          <source>such that 1 = 2&lt;sup&gt;n-1&lt;/sup&gt;.</source>
          <target state="translated">tal que 1 = 2 &lt;sup&gt;n-1&lt;/sup&gt; .</target>
        </trans-unit>
        <trans-unit id="1db8a2298feaca37566d15607275854d077f3496" translate="yes" xml:space="preserve">
          <source>such that &lt;em&gt;c&lt;/em&gt; &amp;equiv; &lt;em&gt;x&lt;/em&gt; (mod &lt;em&gt;y&lt;/em&gt;) for (&lt;em&gt;x&lt;/em&gt;, &lt;em&gt;y&lt;/em&gt;) in</source>
          <target state="translated">tal que &lt;em&gt;c&lt;/em&gt; &amp;equiv; &lt;em&gt;x&lt;/em&gt; (mod &lt;em&gt;y&lt;/em&gt; ) para ( &lt;em&gt;x&lt;/em&gt; , &lt;em&gt;y&lt;/em&gt; ) en</target>
        </trans-unit>
        <trans-unit id="16ffe9780e7b3df743714126040a34c7875445df" translate="yes" xml:space="preserve">
          <source>sum(totient(n) for n in range(1, n+1))</source>
          <target state="translated">suma(totient(n)para n en el rango(1,n+1))</target>
        </trans-unit>
        <trans-unit id="6e0beaf39654867287ea9229dfeb08d2335389d3" translate="yes" xml:space="preserve">
          <source>that form a coprime (</source>
          <target state="translated">que forman un coprimo (</target>
        </trans-unit>
        <trans-unit id="3975a92d6ff3dcb8adbe2c2c5932f8cc2816e1e0" translate="yes" xml:space="preserve">
          <source>then we compute U&lt;sub&gt;k&lt;/sub&gt; and V&lt;sub&gt;k&lt;/sub&gt; in O(ln(</source>
          <target state="translated">luego calculamos U &lt;sub&gt;k&lt;/sub&gt; y V &lt;sub&gt;k&lt;/sub&gt; en O (ln (</target>
        </trans-unit>
        <trans-unit id="202e8e8eb91d64ae945f1b2535b5c51729fa5ed8" translate="yes" xml:space="preserve">
          <source>times and * represents Dirichlet convolution.  The values returned will be</source>
          <target state="translated">tiempos y*representa la convolución de Dirichlet.Los valores devueltos serán</target>
        </trans-unit>
        <trans-unit id="69daf7983e3f8a68d4b9be209f74e83910a55801" translate="yes" xml:space="preserve">
          <source>to the &lt;a href=&quot;https://en.wikipedia.org/wiki/Dirichlet_eta_function&quot;&gt;Dirichlet eta function&lt;/a&gt;.  Should be rather accurate throughout the complex plane except near</source>
          <target state="translated">a la &lt;a href=&quot;https://en.wikipedia.org/wiki/Dirichlet_eta_function&quot;&gt;funci&amp;oacute;n eta de Dirichlet&lt;/a&gt; . Debe ser bastante preciso en todo el plano complejo, excepto cerca</target>
        </trans-unit>
        <trans-unit id="b9b3cba50dbf3adefc333414e44b38442cf55715" translate="yes" xml:space="preserve">
          <source>to the Dirichlet eta function.  Designed to be accurate even when</source>
          <target state="translated">a la función Dirichlet eta.Diseñado para ser preciso incluso cuando</target>
        </trans-unit>
        <trans-unit id="0d49bceae9764f901fbe19c45ce8d0429e61ae8f" translate="yes" xml:space="preserve">
          <source>using at least the indicated number of terms and whose denominators are all &amp;ge; minden.  No algorithm is known for this problem that significantly improves upon brute force, so this can take impractically long times on even modest-seeming inputs.</source>
          <target state="translated">utilizando al menos el n&amp;uacute;mero indicado de t&amp;eacute;rminos y cuyos denominadores son todos &amp;ge; minden. No se conoce ning&amp;uacute;n algoritmo para este problema que mejore significativamente la fuerza bruta, por lo que esto puede llevar tiempos impr&amp;aacute;cticamente largos incluso en entradas aparentemente modestas.</target>
        </trans-unit>
        <trans-unit id="0251bb8c786cf88db78b92a0f771f8bf6c04869a" translate="yes" xml:space="preserve">
          <source>using parameters provided by</source>
          <target state="translated">utilizando los parámetros proporcionados por</target>
        </trans-unit>
        <trans-unit id="5e6e4c0fb8ef47b4f1d6eea3e6c51152dbee94ec" translate="yes" xml:space="preserve">
          <source>val1</source>
          <target state="translated">val1</target>
        </trans-unit>
        <trans-unit id="25f05eec259d12623e65c0c20a1eadedeaa3822a" translate="yes" xml:space="preserve">
          <source>via the Meissel-Lehmer method.  The arguments</source>
          <target state="translated">a través del método Meissel-Lehmer.Los argumentos</target>
        </trans-unit>
        <trans-unit id="30603fa9e0f620c305cd627ab0ff138a960c48bd" translate="yes" xml:space="preserve">
          <source>when</source>
          <target state="translated">cuando</target>
        </trans-unit>
        <trans-unit id="1291f62516ba88e56c8eba45b01c44dec887206b" translate="yes" xml:space="preserve">
          <source>when attempting to evaluate</source>
          <target state="translated">al intentar evaluar</target>
        </trans-unit>
        <trans-unit id="6a42677517d955828716befce981ad0a0d6dd915" translate="yes" xml:space="preserve">
          <source>where the initial values are [&lt;em&gt;x&lt;/em&gt;&lt;sub&gt;0&lt;/sub&gt;, &amp;hellip;, &lt;em&gt;x&lt;/em&gt;&lt;sub&gt;k&lt;/sub&gt;] =</source>
          <target state="translated">donde los valores iniciales son [ &lt;em&gt;x &lt;/em&gt;&lt;sub&gt;0&lt;/sub&gt; ,&amp;hellip;, &lt;em&gt;x &lt;/em&gt;&lt;sub&gt;k&lt;/sub&gt; ] =</target>
        </trans-unit>
        <trans-unit id="12f847846c97f0fb0288ace1b3d95fcdb3b5ca10" translate="yes" xml:space="preserve">
          <source>whose value at 1 is</source>
          <target state="translated">cuyo valor a 1 es</target>
        </trans-unit>
        <trans-unit id="2a873cdbb5b91b1f460dac913d0821840473a2ef" translate="yes" xml:space="preserve">
          <source>will return</source>
          <target state="translated">...volverá...</target>
        </trans-unit>
        <trans-unit id="143375b8e5feeb7dee58a5e69d40b8563339ca29" translate="yes" xml:space="preserve">
          <source>williams_pp1</source>
          <target state="translated">williams_pp1</target>
        </trans-unit>
        <trans-unit id="aa75b06d15054dd7062eecc1a854a090b01f54f0" translate="yes" xml:space="preserve">
          <source>with parameters (</source>
          <target state="translated">con parámetros (</target>
        </trans-unit>
        <trans-unit id="312bc8ad198de0303fe47e34a05c081776f7cd10" translate="yes" xml:space="preserve">
          <source>with the same parameters.</source>
          <target state="translated">con los mismos parámetros.</target>
        </trans-unit>
        <trans-unit id="11f6ad8ec52a2984abaafd7c3b516503785c2072" translate="yes" xml:space="preserve">
          <source>x</source>
          <target state="translated">x</target>
        </trans-unit>
        <trans-unit id="68ebb00048d792472ece36448817bfb237e238f4" translate="yes" xml:space="preserve">
          <source>xslprp</source>
          <target state="translated">xslprp</target>
        </trans-unit>
        <trans-unit id="dd7b7b74ea160e049dd128478e074ce47254bde8" translate="yes" xml:space="preserve">
          <source>xx</source>
          <target state="translated">xx</target>
        </trans-unit>
        <trans-unit id="34d8f96ae05eeccb172e84f975ccfb986b190d79" translate="yes" xml:space="preserve">
          <source>yields all solutions.</source>
          <target state="translated">da lugar a todas las soluciones.</target>
        </trans-unit>
        <trans-unit id="395df8f7c51f007019cb30201c49e884b46b92fa" translate="yes" xml:space="preserve">
          <source>z</source>
          <target state="translated">z</target>
        </trans-unit>
        <trans-unit id="029a3fcb010f8f92628023b595f00551a85179ef" translate="yes" xml:space="preserve">
          <source>zc</source>
          <target state="translated">zc</target>
        </trans-unit>
        <trans-unit id="7ac99c00e5aa89607950c93d6a0bcf99ac0cb028" translate="yes" xml:space="preserve">
          <source>zip(rems, mods)</source>
          <target state="translated">zip(rems,mods)</target>
        </trans-unit>
        <trans-unit id="3eb416223e9e69e6bb8ee19793911ad1ad2027d8" translate="yes" xml:space="preserve">
          <source>|</source>
          <target state="translated">|</target>
        </trans-unit>
        <trans-unit id="e298e579515bfddfe989d1a89ee2e1bcd4916f5c" translate="yes" xml:space="preserve">
          <source>| &amp;middot; &lt;em&gt;y&lt;/em&gt;&lt;sup&gt;2&lt;/sup&gt; =</source>
          <target state="translated">| &amp;middot; &lt;em&gt;Y &lt;/em&gt;&lt;sup&gt;2&lt;/sup&gt; =</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
