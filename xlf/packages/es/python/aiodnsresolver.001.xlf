<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="es" datatype="htmlbody" original="https://pypi.org/project/aiodnsresolver/">
    <body>
      <group id="aiodnsresolver">
        <trans-unit id="5271bccbbe941ae52abb53cc0fecaec4be011917" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://nvd.nist.gov/vuln/detail/CVE-2017-2909&quot;&gt;Pointer loops&lt;/a&gt; are detected.</source>
          <target state="translated">&lt;a href=&quot;https://nvd.nist.gov/vuln/detail/CVE-2017-2909&quot;&gt;&lt;/a&gt;Se detectan bucles de puntero .</target>
        </trans-unit>
        <trans-unit id="929dca150227ac071b7a3bc11408a076f3f42dcd" translate="yes" xml:space="preserve">
          <source>A cache is part of each &lt;code&gt;Resolver()&lt;/code&gt;, expiring records automatically according to their TTL.</source>
          <target state="translated">Un cach&amp;eacute; es parte de cada &lt;code&gt;Resolver()&lt;/code&gt; , y los registros expiran autom&amp;aacute;ticamente de acuerdo con su TTL.</target>
        </trans-unit>
        <trans-unit id="211b06c40eb506400c76ecdf544257469ed37a5b" translate="yes" xml:space="preserve">
          <source>A higher risk assumption is that many tests use the, otherwise private, &lt;code&gt;pack&lt;/code&gt; and &lt;code&gt;parse&lt;/code&gt; functions as part of the built-in DNS server that is used by the tests. These are the core functions used by the production code used to pack and parse DNS messages. While asserting that the resolver can communicate to the built-in nameserver, all the tests do is assert that &lt;code&gt;pack&lt;/code&gt; and &lt;code&gt;parse&lt;/code&gt; are consistent with each other: it is an assumption that other nameservers have equivalent behaviour.</source>
          <target state="translated">Una suposici&amp;oacute;n de mayor riesgo es que muchas pruebas usan las funciones de &lt;code&gt;pack&lt;/code&gt; y &lt;code&gt;parse&lt;/code&gt; , que de otro modo ser&amp;iacute;an privadas, como parte del servidor DNS integrado que utilizan las pruebas. Estas son las funciones principales que utiliza el c&amp;oacute;digo de producci&amp;oacute;n utilizado para empaquetar y analizar mensajes DNS. Si bien afirman que el resolutor puede comunicarse con el servidor de nombres integrado, todo lo que hacen las pruebas es afirmar que el &lt;code&gt;pack&lt;/code&gt; y el &lt;code&gt;parse&lt;/code&gt; son coherentes entre s&amp;iacute;: se supone que otros servidores de nombres tienen un comportamiento equivalente.</target>
        </trans-unit>
        <trans-unit id="5e187dda81d772797388202838eb2eeeac356582" translate="yes" xml:space="preserve">
          <source>A maximum of two messages per DNS query are logged at &lt;code&gt;INFO&lt;/code&gt;. If a nameserver fails, a &lt;code&gt;WARNING&lt;/code&gt; is issued [although an exception will be raised if no nameservers succeed], and the remainder of messages are logged at &lt;code&gt;DEBUG&lt;/code&gt;. No &lt;code&gt;ERROR&lt;/code&gt; or &lt;code&gt;CRITICAL&lt;/code&gt; messages are issued when exceptions are raised: it is the responsiblity of client code to log these if desired.</source>
          <target state="translated">En &lt;code&gt;INFO&lt;/code&gt; se registra un m&amp;aacute;ximo de dos mensajes por consulta de DNS . Si un servidor de nombres falla, se emite una &lt;code&gt;WARNING&lt;/code&gt; [aunque se generar&amp;aacute; una excepci&amp;oacute;n si ning&amp;uacute;n servidor de nombres tiene &amp;eacute;xito] y el resto de los mensajes se registran en &lt;code&gt;DEBUG&lt;/code&gt; . No se emiten mensajes de &lt;code&gt;ERROR&lt;/code&gt; o &lt;code&gt;CRITICAL&lt;/code&gt; cuando se generan excepciones: es responsabilidad del c&amp;oacute;digo del cliente registrarlos si lo desea.</target>
        </trans-unit>
        <trans-unit id="51f7f0ed3e00a224445ea9af92863e69074b3f06" translate="yes" xml:space="preserve">
          <source>A new socket, and so a new random local port, is used for each query.</source>
          <target state="translated">Un nuevo enchufe,y por lo tanto un nuevo puerto local aleatorio,se utiliza para cada consulta.</target>
        </trans-unit>
        <trans-unit id="9100aca195719601490d3778547d5c3de3ae9465" translate="yes" xml:space="preserve">
          <source>Also, to migitate the risk of evil responses/configuration</source>
          <target state="translated">Además,para mitigar el riesgo de respuestas/configuración maligna</target>
        </trans-unit>
        <trans-unit id="52e9f6aaf6e7b4bf71883e35141db1b9fcfd8250" translate="yes" xml:space="preserve">
          <source>Asyncio Python DNS resolver. Pure Python, with no dependencies other than the standard library, threads are not used, no additional tasks are created, and all code is in a single module. The nameservers to query are taken from &lt;code&gt;/etc/resolv.conf&lt;/code&gt;, and treats hosts in &lt;code&gt;/etc/hosts&lt;/code&gt; as A or AAAA records with a TTL of 0.</source>
          <target state="translated">Resoluci&amp;oacute;n de DNS Asyncio Python. Python puro, sin dependencias m&amp;aacute;s que la biblioteca est&amp;aacute;ndar, no se utilizan subprocesos, no se crean tareas adicionales y todo el c&amp;oacute;digo est&amp;aacute; en un solo m&amp;oacute;dulo. Los servidores de nombres a consultar se toman de &lt;code&gt;/etc/resolv.conf&lt;/code&gt; y tratan los hosts en &lt;code&gt;/etc/hosts&lt;/code&gt; como registros A o AAAA con un TTL de 0.</target>
        </trans-unit>
        <trans-unit id="61a84ef6505fac2720810c22f65c1971715da98b" translate="yes" xml:space="preserve">
          <source>By default each domain name is encoded with &lt;a href=&quot;https://astrolavos.gatech.edu/articles/increased_dns_resistance.pdf&quot;&gt;0x20-bit encoding&lt;/a&gt; before being sent to the nameservers. However, some nameservers, such as Docker's built-in, do not support this. So, to control or disable the encoding, you can pass a custom &lt;code&gt;transform_fqdn&lt;/code&gt; coroutine to Resolver that does not perform any additional encoding.</source>
          <target state="translated">De forma predeterminada, cada nombre de dominio est&amp;aacute; codificado con una codificaci&amp;oacute;n de &lt;a href=&quot;https://astrolavos.gatech.edu/articles/increased_dns_resistance.pdf&quot;&gt;0x20 bits&lt;/a&gt; antes de enviarse a los servidores de nombres. Sin embargo, algunos servidores de nombres, como el integrado de Docker, no lo admiten. Por lo tanto, para controlar o deshabilitar la codificaci&amp;oacute;n, puede pasar una corrutina &lt;code&gt;transform_fqdn&lt;/code&gt; personalizada a Resolver que no realiza ninguna codificaci&amp;oacute;n adicional.</target>
        </trans-unit>
        <trans-unit id="e4c00516cc8b5ef50215908476d463b79c1132af" translate="yes" xml:space="preserve">
          <source>By default each domain name is encoded with &lt;a href=&quot;https://astrolavos.gatech.edu/articles/increased_dns_resistance.pdf&quot;&gt;0x20-bit encoding&lt;/a&gt;, which is checked against any response.</source>
          <target state="translated">De forma predeterminada, cada nombre de dominio est&amp;aacute; codificado con una codificaci&amp;oacute;n de &lt;a href=&quot;https://astrolavos.gatech.edu/articles/increased_dns_resistance.pdf&quot;&gt;0x20 bits&lt;/a&gt; , que se compara con cualquier respuesta.</target>
        </trans-unit>
        <trans-unit id="503d0636b431f0d0a6b8edd31c135f4675377d16" translate="yes" xml:space="preserve">
          <source>By default logging is through the &lt;code&gt;Logger&lt;/code&gt; named &lt;code&gt;aiodnsresolver&lt;/code&gt;, and all messages are prefixed with &lt;code&gt;[dns]&lt;/code&gt; or &lt;code&gt;[dns:&amp;lt;fqdn&amp;gt;,&amp;lt;query-type&amp;gt;]&lt;/code&gt; through a &lt;code&gt;LoggerAdapter&lt;/code&gt;. Each function accepts &lt;code&gt;get_logger_adapter&lt;/code&gt;: the default of which results in this behaviour, and can be overridden to set either the &lt;code&gt;Logger&lt;/code&gt; or the &lt;code&gt;LoggerAdapter&lt;/code&gt;.</source>
          <target state="translated">Por defecto, el registro se realiza a trav&amp;eacute;s del &lt;code&gt;Logger&lt;/code&gt; llamado &lt;code&gt;aiodnsresolver&lt;/code&gt; , y todos los mensajes tienen el prefijo &lt;code&gt;[dns]&lt;/code&gt; o &lt;code&gt;[dns:&amp;lt;fqdn&amp;gt;,&amp;lt;query-type&amp;gt;]&lt;/code&gt; a trav&amp;eacute;s de &lt;code&gt;LoggerAdapter&lt;/code&gt; . Cada funci&amp;oacute;n acepta &lt;code&gt;get_logger_adapter&lt;/code&gt; : el valor predeterminado da como resultado este comportamiento, y se puede anular para configurar el &lt;code&gt;Logger&lt;/code&gt; o el &lt;code&gt;LoggerAdapter&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="83abfbe2bfed3c1a456c2d7e47463ba5e76f0bf5" translate="yes" xml:space="preserve">
          <source>CNAME chains have a maximum length.</source>
          <target state="translated">Las cadenas CNAME tienen una longitud máxima.</target>
        </trans-unit>
        <trans-unit id="73ab091294665e57efeb4610bc88824653477946" translate="yes" xml:space="preserve">
          <source>CNAME records are followed transparently. The &lt;code&gt;expires_at&lt;/code&gt; of IP addresses found via intermediate CNAME(s) is determined by using the minimum &lt;code&gt;expires_at&lt;/code&gt; of all the records involved in determining those IP addresses.</source>
          <target state="translated">Los registros CNAME se siguen de forma transparente. El &lt;code&gt;expires_at&lt;/code&gt; de las direcciones IP encontradas a trav&amp;eacute;s de CNAME intermedios se determina utilizando el m&amp;iacute;nimo &lt;code&gt;expires_at&lt;/code&gt; de todos los registros involucrados en la determinaci&amp;oacute;n de esas direcciones IP.</target>
        </trans-unit>
        <trans-unit id="86ce9e2117503436712e78317ab8f9b96432ceac" translate="yes" xml:space="preserve">
          <source>CNAMEs</source>
          <target state="translated">CNAME</target>
        </trans-unit>
        <trans-unit id="50338b3b242845e21a0ace9ae9684283d945fb52" translate="yes" xml:space="preserve">
          <source>Cache</source>
          <target state="translated">Cache</target>
        </trans-unit>
        <trans-unit id="2061cc2c0ce561bb4de9ddce9e6148ae313ff804" translate="yes" xml:space="preserve">
          <source>Chaining logging adapters</source>
          <target state="translated">Encadenando adaptadores de registro</target>
        </trans-unit>
        <trans-unit id="8c053f773becf89e1d9c570970fcb6dea5254931" translate="yes" xml:space="preserve">
          <source>Custom hosts</source>
          <target state="translated">Anfitriones personalizados</target>
        </trans-unit>
        <trans-unit id="95f255134c54184a554be6e3edb813828ba95cc9" translate="yes" xml:space="preserve">
          <source>Custom nameservers and timeouts</source>
          <target state="translated">Servidores de nombre y tiempos de espera personalizados</target>
        </trans-unit>
        <trans-unit id="4331f6e2659b79348247b80b3a69e3c78192b683" translate="yes" xml:space="preserve">
          <source>Designed for highly concurrent/HA situations. Based on &lt;a href=&quot;https://github.com/gera2ld/async_dns&quot;&gt;https://github.com/gera2ld/async_dns&lt;/a&gt;.</source>
          <target state="translated">Dise&amp;ntilde;ado para situaciones altamente concurrentes / HA. Basado en &lt;a href=&quot;https://github.com/gera2ld/async_dns&quot;&gt;https://github.com/gera2ld/async_dns&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7d4318283b3f106b523e323d9909c77fc9121b46" translate="yes" xml:space="preserve">
          <source>Disable 0x20-bit encoding</source>
          <target state="translated">Deshabilitar la codificación de 0x20 bits</target>
        </trans-unit>
        <trans-unit id="325543124cab344013bc013d35cbe2a615311047" translate="yes" xml:space="preserve">
          <source>Each query is given a random ID, which is checked against any response.</source>
          <target state="translated">A cada consulta se le da una identificación aleatoria,que se coteja con cualquier respuesta.</target>
        </trans-unit>
        <trans-unit id="8d63cc4af916c7b99a241bad8b0d502181c245e4" translate="yes" xml:space="preserve">
          <source>Event loop, tasks, and yielding</source>
          <target state="translated">El bucle de eventos,las tareas y el rendimiento</target>
        </trans-unit>
        <trans-unit id="8f118b077e6a503af07b266e698154147805e76c" translate="yes" xml:space="preserve">
          <source>Example: aiohttp</source>
          <target state="translated">Ejemplo:aiohttp</target>
        </trans-unit>
        <trans-unit id="db74fe5b20374d125b242d991f69908b127e41ce" translate="yes" xml:space="preserve">
          <source>Example: lowhaio</source>
          <target state="translated">Ejemplo:lowhaio</target>
        </trans-unit>
        <trans-unit id="daa475826a7caf2c8d6e1edf8f9fcbc611880db5" translate="yes" xml:space="preserve">
          <source>Example: tornado</source>
          <target state="translated">Ejemplo:tornado</target>
        </trans-unit>
        <trans-unit id="cd3dfbe79fda3a9d92de67b1bd4f1dc9f60ab723" translate="yes" xml:space="preserve">
          <source>Exceptions</source>
          <target state="translated">Excepciones</target>
        </trans-unit>
        <trans-unit id="5e214e6879427a717b554f7c20bad14ac9ba6048" translate="yes" xml:space="preserve">
          <source>Exceptions are subclasses of &lt;code&gt;DnsError&lt;/code&gt;, and are raised if a record does not exist, on socket errors, timeouts, message parsing errors, or other errors returned from the nameserver.</source>
          <target state="translated">Las excepciones son subclases de &lt;code&gt;DnsError&lt;/code&gt; y se generan si no existe un registro, en errores de socket, tiempos de espera, errores de an&amp;aacute;lisis de mensajes u otros errores devueltos desde el servidor de nombres.</target>
        </trans-unit>
        <trans-unit id="5481c7b8170c168b824c771b6718a3b6d2901efe" translate="yes" xml:space="preserve">
          <source>For CNAME chains, the event loop is yielded during each communication for non-cached parts of the chain.</source>
          <target state="translated">Para las cadenas CNAME,el bucle de eventos se cede durante cada comunicación para las partes de la cadena que no están en caché.</target>
        </trans-unit>
        <trans-unit id="d1ce204dbf3ac8a86a74a6e0f2ade815849b3dd0" translate="yes" xml:space="preserve">
          <source>For complex or highly concurrent applications, it may be desirable that logging adapters be chained to output log messages that incorporate a parent context. So the default ouput of</source>
          <target state="translated">En el caso de aplicaciones complejas o muy concurrentes,puede ser conveniente que los adaptadores de registro se encadenen a los mensajes de registro de salida que incorporen un contexto padre.Así pues,la salida por defecto de</target>
        </trans-unit>
        <trans-unit id="37b6d39ee4f6fbd194c7fcc66f1205f74e971cac" translate="yes" xml:space="preserve">
          <source>If a lower-level exception caused the &lt;code&gt;DnsError&lt;/code&gt;, it will be in the &lt;code&gt;__cause__&lt;/code&gt; attribute of the exception.</source>
          <target state="translated">Si una excepci&amp;oacute;n de nivel inferior provoc&amp;oacute; el &lt;code&gt;DnsError&lt;/code&gt; , estar&amp;aacute; en el atributo &lt;code&gt;__cause__&lt;/code&gt; de la excepci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="c81b79df3c6448eae7c4f80428b54cd5692a17d7" translate="yes" xml:space="preserve">
          <source>Installation</source>
          <target state="translated">Instalación</target>
        </trans-unit>
        <trans-unit id="98c528a0f6bb272f1be116323214c541e9884abd" translate="yes" xml:space="preserve">
          <source>It is possible to query nameservers other than those in &lt;code&gt;/etc/resolv.conf&lt;/code&gt;, and for each to specify a timeout in seconds to wait for a reply before querying the next.</source>
          <target state="translated">Es posible consultar servidores de nombres distintos a los de &lt;code&gt;/etc/resolv.conf&lt;/code&gt; , y que cada uno especifique un tiempo de espera en segundos para esperar una respuesta antes de consultar el siguiente.</target>
        </trans-unit>
        <trans-unit id="15c9db7d7fff447ccf33673477c532475866aef0" translate="yes" xml:space="preserve">
          <source>It is technically possible that in the case of extremely high numbers of A or AAAA records for a domain, they would not fit in a single UDP message. However, this is extremely unlikely, and in this unlikely case, extremely unlikely to affect target applications in any meaningful way. If a truncated message is received, a warning is logged.</source>
          <target state="translated">Es técnicamente posible que en el caso de un número extremadamente alto de registros A o AAAA de un dominio,no quepan en un solo mensaje UDP.Sin embargo,esto es sumamente improbable y,en este caso improbable,es muy poco probable que afecte a las aplicaciones de destino de manera significativa.Si se recibe un mensaje truncado,se registra una advertencia.</target>
        </trans-unit>
        <trans-unit id="24c4c96f064c57e2f915eb36267d9c1af72b39d9" translate="yes" xml:space="preserve">
          <source>It's possible to specify hosts without editing the &lt;code&gt;/etc/hosts&lt;/code&gt; file.</source>
          <target state="translated">Es posible especificar hosts sin editar el &lt;code&gt;/etc/hosts&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="81abd20921dba1c2e53084d841b924ad28377ed3" translate="yes" xml:space="preserve">
          <source>Log levels</source>
          <target state="translated">Niveles de registro</target>
        </trans-unit>
        <trans-unit id="57003616863fe634c645e342ee9080681e419c5f" translate="yes" xml:space="preserve">
          <source>Logging</source>
          <target state="translated">Registro</target>
        </trans-unit>
        <trans-unit id="bf89335514117c4e318f57395975d95081d6e290" translate="yes" xml:space="preserve">
          <source>Many tests assume that timeouts are controlled by &lt;code&gt;asyncio.sleep&lt;/code&gt;, &lt;code&gt;loop.call_later&lt;/code&gt; or &lt;code&gt;loop.call_at&lt;/code&gt;. This is to allow time to be fast-forwarded through cache invalidation using &lt;a href=&quot;https://github.com/michalc/aiofastforward&quot;&gt;aiofastforward&lt;/a&gt; without actually having to wait the corresponding time in the tests. Also, many tests assume &lt;code&gt;open&lt;/code&gt; is used to access files, and patch it to allow assertions on what the code would do with different contents of &lt;code&gt;/etc/resolv.conf&lt;/code&gt; or &lt;code&gt;/etc/hosts&lt;/code&gt;.</source>
          <target state="translated">Muchas pruebas asumen que los tiempos de espera est&amp;aacute;n controlados por &lt;code&gt;asyncio.sleep&lt;/code&gt; , &lt;code&gt;loop.call_later&lt;/code&gt; o &lt;code&gt;loop.call_at&lt;/code&gt; . Esto es para permitir que el tiempo se reenv&amp;iacute;e r&amp;aacute;pidamente a trav&amp;eacute;s de la invalidaci&amp;oacute;n de la cach&amp;eacute; utilizando &lt;a href=&quot;https://github.com/michalc/aiofastforward&quot;&gt;aiofastforward&lt;/a&gt; sin tener que esperar el tiempo correspondiente en las pruebas. Adem&amp;aacute;s, muchas pruebas asumen que se usa &lt;code&gt;open&lt;/code&gt; para acceder a archivos y parchearlo para permitir afirmaciones sobre lo que har&amp;iacute;a el c&amp;oacute;digo con diferentes contenidos de &lt;code&gt;/etc/resolv.conf&lt;/code&gt; o &lt;code&gt;/etc/hosts&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="47e6cc73f64a548366be4705e275679eeccea863" translate="yes" xml:space="preserve">
          <source>No extra code is needed to use aiodnsresolver with &lt;a href=&quot;https://github.com/michalc/lowhaio&quot;&gt;lowhaio&lt;/a&gt;: it is used by default.</source>
          <target state="translated">No se necesita c&amp;oacute;digo adicional para usar aiodnsresolver con &lt;a href=&quot;https://github.com/michalc/lowhaio&quot;&gt;lowhaio&lt;/a&gt; : se usa por defecto.</target>
        </trans-unit>
        <trans-unit id="0dd8a289d527539de842bf7f512ddc6f16bab278" translate="yes" xml:space="preserve">
          <source>No tasks are created, and the event loop is only yielded to during socket communication. Because fetching results from the cache involves no socket communication, this means that cached results are fetched without yielding. This introduces a small inconsistency between fetching cached and non-cached results, and so clients should be written to not depend on the presence or lack of a yield during resolution. This is a typically recommended process however: it should be expected that coroutines might yield.</source>
          <target state="translated">No se crean tareas,y el bucle de eventos sólo se cede durante la comunicación del socket.Dado que la obtención de resultados de la caché no implica una comunicación entre sockets,esto significa que los resultados de la caché se obtienen sin ceder.Esto introduce una pequeña inconsistencia entre la obtención de resultados en la caché y los que no lo son,por lo que los clientes deben escribirse de forma que no dependan de la presencia o falta de rendimiento durante la resolución.Sin embargo,este es un proceso típicamente recomendado:debe esperarse que las cortinas puedan rendir.</target>
        </trans-unit>
        <trans-unit id="13af06a45ae2e367e0503ca4e7145d79f1f7d234" translate="yes" xml:space="preserve">
          <source>Parallel requests to multiple nameservers are also possible, where the first response from each set of requests is used.</source>
          <target state="translated">También es posible realizar solicitudes paralelas a múltiples servidores de nombres,en las que se utiliza la primera respuesta de cada conjunto de solicitudes.</target>
        </trans-unit>
        <trans-unit id="7fd5bb751b3ce87db39b88c5e968bcfa48b440a4" translate="yes" xml:space="preserve">
          <source>Pure asyncio Python DNS resolver</source>
          <target state="translated">Puro asíncio Python DNS resolver</target>
        </trans-unit>
        <trans-unit id="bef2a4699d00603b20da781b86d5845c0046fb44" translate="yes" xml:space="preserve">
          <source>Requests made for a domain while there is an in-flight query for that domain, wait for the the in-flight query to finish, and use its result.</source>
          <target state="translated">Las solicitudes realizadas para un dominio mientras hay una consulta en vuelo para ese dominio,espera a que la consulta en vuelo termine y utiliza su resultado.</target>
        </trans-unit>
        <trans-unit id="c1ada94ed2819eb16c6fe64f64fb6e10147a7afd" translate="yes" xml:space="preserve">
          <source>Returned are tuples of subclasses of &lt;a href=&quot;https://docs.python.org/3/library/ipaddress.html#ipaddress.IPv4Address&quot;&gt;IPv4Address&lt;/a&gt; or &lt;a href=&quot;https://docs.python.org/3/library/ipaddress.html#ipaddress.IPv6Address&quot;&gt;IPv6Address&lt;/a&gt;. Both support conversion to their usual string form by passing them to &lt;code&gt;str&lt;/code&gt;.</source>
          <target state="translated">Se devuelven tuplas de subclases de &lt;a href=&quot;https://docs.python.org/3/library/ipaddress.html#ipaddress.IPv4Address&quot;&gt;IPv4Address&lt;/a&gt; o &lt;a href=&quot;https://docs.python.org/3/library/ipaddress.html#ipaddress.IPv6Address&quot;&gt;IPv6Address&lt;/a&gt; . Ambos admiten la conversi&amp;oacute;n a su forma de cadena habitual pas&amp;aacute;ndolos a &lt;code&gt;str&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4651a34e4df9619783ad372f905d6d3b84e9d76d" translate="yes" xml:space="preserve">
          <source>Scope</source>
          <target state="translated">Alcance</target>
        </trans-unit>
        <trans-unit id="2931d5d3232f2248933a3926c6bcfde0392f4223" translate="yes" xml:space="preserve">
          <source>Security considerations</source>
          <target state="translated">Consideraciones de seguridad</target>
        </trans-unit>
        <trans-unit id="d4bcd58ee108472a46cd86b218d9752854fdfe5c" translate="yes" xml:space="preserve">
          <source>Specifically, if a record is determined to not exist, &lt;code&gt;DnsRecordDoesNotExist&lt;/code&gt; is raised.</source>
          <target state="translated">Espec&amp;iacute;ficamente, si se determina que un registro no existe, se &lt;code&gt;DnsRecordDoesNotExist&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fd95ae54dec0b2580591259365e6f9ec1bc37a56" translate="yes" xml:space="preserve">
          <source>TTL / Record expiry</source>
          <target state="translated">TTL/Expiración del registro</target>
        </trans-unit>
        <trans-unit id="d84c76a661a2d9eed7c499c29179e4493a22dfb7" translate="yes" xml:space="preserve">
          <source>Testing strategy</source>
          <target state="translated">Estrategia de prueba</target>
        </trans-unit>
        <trans-unit id="724d10488fa0d7f2fcdb5593b3ca64e996ef7b86" translate="yes" xml:space="preserve">
          <source>Tests attempt to closly match real-world use, and assert on how input translate to output, i.e. the &lt;em&gt;public&lt;/em&gt; behaviour of the resolver. Therefore the tests avoid assumptions on implementation details.</source>
          <target state="translated">Las pruebas intentan coincidir estrechamente con el uso del mundo real y afirman c&amp;oacute;mo la entrada se traduce en salida, es decir, el comportamiento &lt;em&gt;p&amp;uacute;blico&lt;/em&gt; del resolutor. Por lo tanto, las pruebas evitan suposiciones sobre los detalles de implementaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="8c7516866aa18f7d36f81b46de3023d136af8722" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;LoggerAdapter&lt;/code&gt; used by &lt;code&gt;resolve&lt;/code&gt; and &lt;code&gt;clear_cache&lt;/code&gt; defaults to the one passed to &lt;code&gt;Resolver&lt;/code&gt;.</source>
          <target state="translated">El &lt;code&gt;LoggerAdapter&lt;/code&gt; utilizado por &lt;code&gt;resolve&lt;/code&gt; y &lt;code&gt;clear_cache&lt;/code&gt; tiene como valor predeterminado el que se pasa a &lt;code&gt;Resolver&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="466b71a3cf44833cb3278ebc0b07a27c257d9e55" translate="yes" xml:space="preserve">
          <source>The address objects each have an extra property, &lt;code&gt;expires_at&lt;/code&gt;, that returns the expiry time of the address, according to the &lt;code&gt;loop.time()&lt;/code&gt; clock, and the TTL of the records involved to find that address.</source>
          <target state="translated">Cada uno de los objetos de direcci&amp;oacute;n tiene una propiedad adicional, &lt;code&gt;expires_at&lt;/code&gt; , que devuelve el tiempo de vencimiento de la direcci&amp;oacute;n, de acuerdo con el reloj &lt;code&gt;loop.time()&lt;/code&gt; , y el TTL de los registros involucrados para encontrar esa direcci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="9e9f8b0ae56b3bb4ce43ae4f8e3ab8863677bbde" translate="yes" xml:space="preserve">
          <source>The cache for each record starts on the &lt;em&gt;start&lt;/em&gt; of each request, so duplicate concurrent requests for the same record are not made.</source>
          <target state="translated">La cach&amp;eacute; para cada registro comienza al &lt;em&gt;inicio&lt;/em&gt; de cada solicitud, por lo que no se realizan solicitudes simult&amp;aacute;neas duplicadas para el mismo registro.</target>
        </trans-unit>
        <trans-unit id="a30c90204c5ee38410b23c24343172c003f232be" translate="yes" xml:space="preserve">
          <source>The resolver is a &lt;em&gt;stub&lt;/em&gt; resolver: it delegates the responsibility of recursion to the nameserver(s) it queries. In the vast majority of envisioned use cases this is acceptable, since the nameservers in &lt;code&gt;/etc/resolv.conf&lt;/code&gt; will be recursive.</source>
          <target state="translated">El resolutor es un resolutor de &lt;em&gt;stub&lt;/em&gt; : delega la responsabilidad de la recursividad a los servidores de nombres que consulta. En la gran mayor&amp;iacute;a de los casos de uso previstos, esto es aceptable, ya que los servidores de nombres en &lt;code&gt;/etc/resolv.conf&lt;/code&gt; ser&amp;aacute;n recursivos.</target>
        </trans-unit>
        <trans-unit id="ad52e794eb4fcc06ecc4985810a0f8022f6a02b9" translate="yes" xml:space="preserve">
          <source>The scope of this project is deliberately restricted to operations that are used to resolve A or AAAA records: to resolve a domain name to its IP addresses so that IP connections can be made, and have similar responsibilities to &lt;code&gt;gethostbyname&lt;/code&gt;. Some limited extra behaviour is present/may be added, but great care is taken to prevent scope creep, especially to not add complexity that isn't required to resolve A or AAAA records.</source>
          <target state="translated">El alcance de este proyecto est&amp;aacute; deliberadamente restringido a las operaciones que se utilizan para resolver registros A o AAAA: para resolver un nombre de dominio en sus direcciones IP para que se puedan realizar conexiones IP, y tienen responsabilidades similares a &lt;code&gt;gethostbyname&lt;/code&gt; . Est&amp;aacute; presente / puede agregarse alg&amp;uacute;n comportamiento adicional limitado, pero se tiene mucho cuidado para evitar el deslizamiento del alcance, especialmente para no agregar complejidad que no es necesaria para resolver registros A o AAAA.</target>
        </trans-unit>
        <trans-unit id="57e4103bc66f1c02c2c9e171ff330eee6102ce2e" translate="yes" xml:space="preserve">
          <source>The trade-off for this inconsistency is that cached results are fetched slightly faster than if resolving were to yield in all cases.</source>
          <target state="translated">La contrapartida de esta incoherencia es que los resultados almacenados en la memoria intermedia se obtienen ligeramente más rápido que si se resolviera en todos los casos.</target>
        </trans-unit>
        <trans-unit id="568b9215249186337b28f4ddd655addeb1beaa3b" translate="yes" xml:space="preserve">
          <source>There are however exceptions.</source>
          <target state="translated">Sin embargo,hay excepciones.</target>
        </trans-unit>
        <trans-unit id="b70f278fda8094a172d4312fe7f6e058f3578c19" translate="yes" xml:space="preserve">
          <source>This can be used as part of a HA system: if a nameserver isn't contactable, this pattern avoids waiting for its timeout before querying another nameserver.</source>
          <target state="translated">Esto puede ser usado como parte de un sistema HA:si un servidor de nombres no es localizable,este patrón evita esperar su tiempo de espera antes de consultar a otro servidor de nombres.</target>
        </trans-unit>
        <trans-unit id="cbcd6514ef7beea9d2b0457fb1fbbe2b4b520b8e" translate="yes" xml:space="preserve">
          <source>This can be used in HA situations to assist failovers. The timer for &lt;code&gt;expires_at&lt;/code&gt; starts just &lt;em&gt;before&lt;/em&gt; the request to the nameserver is made.</source>
          <target state="translated">Esto se puede utilizar en situaciones de alta disponibilidad para ayudar a las conmutaciones por error. El temporizador para &lt;code&gt;expires_at&lt;/code&gt; comienza justo &lt;em&gt;antes de que se &lt;/em&gt;realice la solicitud al servidor de nombres.</target>
        </trans-unit>
        <trans-unit id="69758f85250db2d85cf4c9bb890236bb8f46f07d" translate="yes" xml:space="preserve">
          <source>To do this, set &lt;code&gt;get_logger_adapter&lt;/code&gt; as a function that chains multiple &lt;code&gt;LoggerAdapter&lt;/code&gt;.</source>
          <target state="translated">Para hacer esto, configure &lt;code&gt;get_logger_adapter&lt;/code&gt; como una funci&amp;oacute;n que encadena m&amp;uacute;ltiples &lt;code&gt;LoggerAdapter&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e5453419f7808d077e72a0951df66da4d335a1ef" translate="yes" xml:space="preserve">
          <source>To migitate spoofing, several techniques are used.</source>
          <target state="translated">Para mitigar el engaño,se utilizan varias técnicas.</target>
        </trans-unit>
        <trans-unit id="fdac2c4c6b417e4e42de66d3df4d768bdf14bb25" translate="yes" xml:space="preserve">
          <source>To mitigate the risks that these assumptions bring, some &quot;end to end&quot;-style tests are included, which use whatever nameservers are in &lt;code&gt;/etc/resolv.conf&lt;/code&gt;, and asserting on globally available DNS results. While not going through every possible case of input, they do validate that core behaviour is consistent with one other implementation of the protocol.</source>
          <target state="translated">Para mitigar los riesgos que conllevan estas suposiciones, se incluyen algunas pruebas de estilo &quot;de extremo a extremo&quot;, que utilizan los servidores de nombres que se encuentran en &lt;code&gt;/etc/resolv.conf&lt;/code&gt; y afirman los resultados de DNS disponibles globalmente. Si bien no analizan todos los casos posibles de entrada, s&amp;iacute; validan que el comportamiento central es consistente con otra implementaci&amp;oacute;n del protocolo.</target>
        </trans-unit>
        <trans-unit id="ee99461aee3846058cc1f0f7023e131f12d74143" translate="yes" xml:space="preserve">
          <source>UDP queries are made, but not TCP. DNS servers must support UDP, and it's impossible for a single A and AAAA record to not fit into the maximum size of a UDP DNS response, 512 bytes. There may be other data that the DNS server would return in TCP connections, but this isn't required to resolve a domain name to a single IP address.</source>
          <target state="translated">Se hacen consultas UDP,pero no TCP.Los servidores DNS deben soportar UDP,y es imposible que un solo registro A y AAAA no quepa en el tamaño máximo de una respuesta DNS UDP,512 bytes.Puede haber otros datos que el servidor DNS devolvería en las conexiones TCP,pero esto no es necesario para resolver un nombre de dominio a una sola dirección IP.</target>
        </trans-unit>
        <trans-unit id="0bb18642b70b9f8a9c12ccf39487328f306b8e19" translate="yes" xml:space="preserve">
          <source>Usage</source>
          <target state="translated">Uso</target>
        </trans-unit>
        <trans-unit id="e3eb7e120df55fe0ce4ae5e02b1795d6bc597530" translate="yes" xml:space="preserve">
          <source>While both being assumptions, they are both unlikely to change, and in the case that they are changed, this would much more likely result in tests failing incorrectly rather than passing incorrectly. Therefore these are low-risk assumptions.</source>
          <target state="translated">Aunque ambas son suposiciones,es poco probable que cambien y,en caso de que lo hagan,es mucho más probable que las pruebas fallen de forma incorrecta en lugar de aprobarlas.Por lo tanto,se trata de supuestos de bajo riesgo.</target>
        </trans-unit>
        <trans-unit id="f7cccc0372b47247d5fc2e3825d4126fb7823822" translate="yes" xml:space="preserve">
          <source>aiodnsresolver</source>
          <target state="translated">aiodnsresolver</target>
        </trans-unit>
        <trans-unit id="08aea82c41d0ad520a61ea165d592487b6c577fe" translate="yes" xml:space="preserve">
          <source>or performs it conditionally</source>
          <target state="translated">o la realiza condicionalmente</target>
        </trans-unit>
        <trans-unit id="e329b5389944db05ea8909e826a45be38a49022b" translate="yes" xml:space="preserve">
          <source>would be prefixed with a &lt;em&gt;parent&lt;/em&gt; context to output something like</source>
          <target state="translated">tendr&amp;iacute;a un prefijo con un contexto &lt;em&gt;principal&lt;/em&gt; para generar algo como</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
