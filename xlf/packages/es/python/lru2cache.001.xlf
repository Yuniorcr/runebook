<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="es" datatype="htmlbody" original="https://pypi.org/project/lru2cache/">
    <body>
      <group id="lru2cache">
        <trans-unit id="6d6173d566ffb20c8641ba2752b927248f8ab6c3" translate="yes" xml:space="preserve">
          <source>, function arguments of different types will be
cached separately. For example, f(3) and f(3.0) will be treated as distinct
calls with distinct results.</source>
          <target state="translated">, los argumentos de funci&amp;oacute;n de diferentes tipos se almacenar&amp;aacute;n en cach&amp;eacute; por separado. Por ejemplo, f (3) yf (3.0) se tratar&amp;aacute;n como llamadas distintas con resultados distintos.</target>
        </trans-unit>
        <trans-unit id="7207846477fc222c6dd0427e85462ac564927fea" translate="yes" xml:space="preserve">
          <source>, the LRU feature is disabled and the L1 cache
can grow without bound. The LRU feature performs best when maxsize is a power-of-two.</source>
          <target state="translated">, la funci&amp;oacute;n LRU est&amp;aacute; desactivada y la cach&amp;eacute; L1 puede crecer sin l&amp;iacute;mite. La funci&amp;oacute;n LRU funciona mejor cuando el tama&amp;ntilde;o m&amp;aacute;ximo es una potencia de dos.</target>
        </trans-unit>
        <trans-unit id="d99d3502cdad96aa76d33d37c0cc8a9682cf6459" translate="yes" xml:space="preserve">
          <source>. These stats are stored within an instance, and therefore
are specific to that instance. Cumulative statistics for the shared cache would
need to be obtained from the shared cache.</source>
          <target state="translated">. Estas estad&amp;iacute;sticas se almacenan dentro de una instancia y, por lo tanto, son espec&amp;iacute;ficas de esa instancia. Las estad&amp;iacute;sticas acumulativas para la memoria cach&amp;eacute; compartida deber&amp;iacute;an obtenerse de la memoria cach&amp;eacute; compartida.</target>
        </trans-unit>
        <trans-unit id="2be5d9e9d6ec5fbbfff0627d5ceb897a4d377376" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Local and Shared Cache&lt;/strong&gt; - Combining both types of cache is much more
effective than either used on it&amp;rsquo;s own.  The local cache eliminates the
latency of calls to a shared cache, while the shared cache eliminates
the expense of returning the result</source>
          <target state="translated">&lt;strong&gt;Cach&amp;eacute; local y compartido&lt;/strong&gt; : combinar ambos tipos de cach&amp;eacute; es mucho m&amp;aacute;s efectivo que usar cualquiera de ellos por s&amp;iacute; solo. La cach&amp;eacute; local elimina la latencia de las llamadas a una cach&amp;eacute; compartida, mientras que la cach&amp;eacute; compartida elimina el gasto de devolver el resultado.</target>
        </trans-unit>
        <trans-unit id="3a61811019e173a17190bff6fd9ad90f453f5c97" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The Ability to Not Cache None Results&lt;/strong&gt; - This may seem like a minor thing
but in our environment it has greatly reduced the frequency of cache
invalidations.</source>
          <target state="translated">&lt;strong&gt;La capacidad de no almacenar en cach&amp;eacute; ninguno de los resultados&lt;/strong&gt; : esto puede parecer una cosa menor, pero en nuestro entorno ha reducido en gran medida la frecuencia de invalidaciones de cach&amp;eacute;.</target>
        </trans-unit>
        <trans-unit id="4d15addbdae92bf79453914d11dea5bbd5322f8d" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;http://en.wikipedia.org/wiki/Cache_algorithms#Least_Recently_Used&quot;&gt;least recently used (LRU)&lt;/a&gt;
2 layer caching mechanism based in part on the Python 2.7 back-port of</source>
          <target state="translated">Un mecanismo de almacenamiento en cach&amp;eacute; de 2 capas &lt;a href=&quot;http://en.wikipedia.org/wiki/Cache_algorithms#Least_Recently_Used&quot;&gt;utilizado menos recientemente (LRU)&lt;/a&gt; basado en parte en el puerto posterior de Python 2.7 de</target>
        </trans-unit>
        <trans-unit id="3efcd57fb6b3d75f3484be9e543fff6a457c01c9" translate="yes" xml:space="preserve">
          <source>A least recently used (LRU) 2 layer caching mechanism based in part on the Python 2.7 back-port of lru_cache</source>
          <target state="translated">Un mecanismo de caché de 2 capas de uso menos reciente (LRU)basado en parte en el puerto trasero de Python 2.7 de lru_cache</target>
        </trans-unit>
        <trans-unit id="32e4be867670ced87f1b50b35d669b04ce0f3a8b" translate="yes" xml:space="preserve">
          <source>A shared cache can easily be cleared with the following:</source>
          <target state="translated">Un caché compartido puede ser fácilmente limpiado con lo siguiente:</target>
        </trans-unit>
        <trans-unit id="b6ad70fe8987a492b217f1d3fdc6bc56a8799161" translate="yes" xml:space="preserve">
          <source>Accessing the Function without Cache</source>
          <target state="translated">Acceder a la función sin caché</target>
        </trans-unit>
        <trans-unit id="37e1c7c46791ba8b13b32bdb24bd8673a2f3fe3e" translate="yes" xml:space="preserve">
          <source>As a starting point I incorporated most of the tests for</source>
          <target state="translated">Como punto de partida incorporé la mayoría de las pruebas para</target>
        </trans-unit>
        <trans-unit id="3938496e65e6dd032b899a42196062cb85acaa7a" translate="yes" xml:space="preserve">
          <source>As with lru_cache, one can view the cache statistics via a named tuple
(l1_hits, l1_misses, l2_hits, l2_misses, l1_maxsize, l1_currsize), with</source>
          <target state="translated">Al igual que con lru_cache,uno puede ver las estadísticas de la caché a través de una tupla con nombre (l1_hits,l1_misses,l2_hits,l2_misses,l1_maxsize,l1_currsize),con</target>
        </trans-unit>
        <trans-unit id="6bbdf159e71b2fcdfa75bfaf3c0ec17a80b21b52" translate="yes" xml:space="preserve">
          <source>At &lt;a href=&quot;http://www.3top.com/&quot;&gt;3Top&lt;/a&gt; We needed a way to improve performance of
slow queries, not just those using the Django ORM, but also for queries to
other data stores and services.  We started off with a simpler centralized
caching solution using Memcached, but even those queries, when called frequently,
can start to cause delays.  Therefore we sought a means of caching at two layers.</source>
          <target state="translated">En &lt;a href=&quot;http://www.3top.com/&quot;&gt;3Top&lt;/a&gt; necesit&amp;aacute;bamos una forma de mejorar el rendimiento de las consultas lentas, no solo las que utilizan el ORM de Django, sino tambi&amp;eacute;n para las consultas a otros almacenes de datos y servicios. Comenzamos con una soluci&amp;oacute;n de almacenamiento en cach&amp;eacute; centralizada m&amp;aacute;s simple usando Memcached, pero incluso esas consultas, cuando se llaman con frecuencia, pueden comenzar a causar retrasos. Por lo tanto, buscamos un medio de almacenamiento en cach&amp;eacute; en dos capas.</target>
        </trans-unit>
        <trans-unit id="aeaf0e85f848b550a565ca5901e53d4306577d16" translate="yes" xml:space="preserve">
          <source>Background and Development</source>
          <target state="translated">Antecedentes y desarrollo</target>
        </trans-unit>
        <trans-unit id="a086c0543fd27c08b64c003ddb4513c6845eb29a" translate="yes" xml:space="preserve">
          <source>Benefits Over functools.lru_cache</source>
          <target state="translated">Beneficios sobre functools.lru_cache</target>
        </trans-unit>
        <trans-unit id="d2469c2aa14798195f6bc3ae16fcf004712ca85e" translate="yes" xml:space="preserve">
          <source>Cache Management</source>
          <target state="translated">gestión de la caché</target>
        </trans-unit>
        <trans-unit id="35242c52a20b0f631fccc4a7c16ed23a76be06bd" translate="yes" xml:space="preserve">
          <source>Cache Statistics</source>
          <target state="translated">estadísticas de la caché</target>
        </trans-unit>
        <trans-unit id="53a0d2b5765f8ae251aea63864f78dac2259b0d7" translate="yes" xml:space="preserve">
          <source>Clearing Instance Cache</source>
          <target state="translated">Borrado de la memoria caché de la instancia</target>
        </trans-unit>
        <trans-unit id="bf5dec3573c5a5d21ca6a1425613a8510bf9f271" translate="yes" xml:space="preserve">
          <source>Clearing Shared Cache</source>
          <target state="translated">Despejando la caché compartida</target>
        </trans-unit>
        <trans-unit id="751c68a3471b1c791efaee0a8e7c24ea0c266efd" translate="yes" xml:space="preserve">
          <source>If</source>
          <target state="translated">Si</target>
        </trans-unit>
        <trans-unit id="95f76da19cad315076ccc2afaa0e41daf973ca96" translate="yes" xml:space="preserve">
          <source>If available this package will use SpookyHash V2 as a hashing mechanism.
Spooky is a good fast hashing algorithm that should be suitable for most uses.
If it is not available the package will fall back to SHA-256 from the standard
hashlib.  Because SHA-256 is a proper cryptographic hash it requires more
computation than Spooky.  To install spooky use pip:</source>
          <target state="translated">Si está disponible,este paquete usará SpookyHash V2 como un mecanismo de hashing.Spooky es un buen algoritmo de hashing rápido que debería ser adecuado para la mayoría de los usos.Si no está disponible,el paquete volverá a SHA-256 desde el hashlib estándar.Debido a que SHA-256 es un hash criptográfico apropiado,requiere más computación que Spooky.Para instalar Spooky usa pip:</target>
        </trans-unit>
        <trans-unit id="bd872a8af71a679a7a57ab648b7308f8099f311d" translate="yes" xml:space="preserve">
          <source>If you do not want to use either</source>
          <target state="translated">Si no quieres usar ninguno de los dos</target>
        </trans-unit>
        <trans-unit id="f20cd38b0f0d290cf5aa2dda99bb5da47f90a908" translate="yes" xml:space="preserve">
          <source>Initially we looked at the possibility of using two different mechanisms but
we quickly saw the advantage of maintaining the same set of keys for both
caches and decided to create our own mechanism.</source>
          <target state="translated">Inicialmente consideramos la posibilidad de usar dos mecanismos diferentes,pero rápidamente vimos la ventaja de mantener el mismo juego de llaves para ambos escondites y decidimos crear nuestro propio mecanismo.</target>
        </trans-unit>
        <trans-unit id="debd19f419480deae2e24d7b2b4c8018a365b90e" translate="yes" xml:space="preserve">
          <source>Installation &amp;amp; Configuration</source>
          <target state="translated">Instalaci&amp;oacute;n y configuraci&amp;oacute;n</target>
        </trans-unit>
        <trans-unit id="cc1093a96d4b2482bcaf84ac72db0fe4a89cb2c3" translate="yes" xml:space="preserve">
          <source>Invalidating Cached Results</source>
          <target state="translated">Invalidación de los resultados almacenados en la memoria caché</target>
        </trans-unit>
        <trans-unit id="6eef6648406c333a4035cd5e60d0bf2ecf2606d7" translate="yes" xml:space="preserve">
          <source>None</source>
          <target state="translated">Ninguno</target>
        </trans-unit>
        <trans-unit id="5cfe5bbe5ae1dcb900a59525d853591e69656103" translate="yes" xml:space="preserve">
          <source>Once lru2cache is installed you will need to configure a shared cache as an
l2 cache.  If you are using Django your settings file will contain something
similar to the following in the settings file:</source>
          <target state="translated">Una vez que lru2cache esté instalado,necesitarás configurar un cache compartido como un cache l2.Si utilizas Django,tu archivo de configuración contendrá algo similar a lo siguiente en el archivo de configuración:</target>
        </trans-unit>
        <trans-unit id="5da6bc6ba91b6bc6224f81e28bb845e36941f36f" translate="yes" xml:space="preserve">
          <source>Refreshing the Cache</source>
          <target state="translated">Refrescando el caché</target>
        </trans-unit>
        <trans-unit id="3fc5f2545bc12aba6c4ecc7066bfa0304189551b" translate="yes" xml:space="preserve">
          <source>Since the lru2cache decorator does not provide a timeout for its cache although
it provides other mechanisms for programatically managing the cache.</source>
          <target state="translated">Dado que el decorador de lru2cache no proporciona un tiempo de espera para su caché,aunque sí otros mecanismos para gestionar el caché de forma programada.</target>
        </trans-unit>
        <trans-unit id="39fdec1194d94212b871a28b2aa04a73cd40fce1" translate="yes" xml:space="preserve">
          <source>Tests</source>
          <target state="translated">Pruebas</target>
        </trans-unit>
        <trans-unit id="1d0165a592656f6dd286443745686b0cd7caff47" translate="yes" xml:space="preserve">
          <source>The easiest and best way to install this is with pip:</source>
          <target state="translated">La mejor y más fácil manera de instalar esto es con pip:</target>
        </trans-unit>
        <trans-unit id="b4358f486357d25333aa98b7ac1dc2af818fc3e0" translate="yes" xml:space="preserve">
          <source>The first layer of caching is stored in a callable that wraps the function or
method.  As with &amp;lsquo;functools.lru_cache&amp;rsquo; a dict is used to store the cached
results, therefore positional and keyword arguments must be hashable. Each
instance stores up to</source>
          <target state="translated">La primera capa de almacenamiento en cach&amp;eacute; se almacena en un invocable que envuelve la funci&amp;oacute;n o el m&amp;eacute;todo. Al igual que con 'functools.lru_cache', se usa un dict para almacenar los resultados en cach&amp;eacute;, por lo tanto, los argumentos posicionales y de palabras clave deben ser hash. Cada instancia almacena hasta</target>
        </trans-unit>
        <trans-unit id="0ea4401b5713b542a1e261e03fdcbec558a8d19b" translate="yes" xml:space="preserve">
          <source>The second layer of caching requires a shared cache that can make use of
Django&amp;rsquo;s cache framework.  In this case it is assumed that any LRU mechanism
is handled by the shared cache backend.</source>
          <target state="translated">La segunda capa de almacenamiento en cach&amp;eacute; requiere una cach&amp;eacute; compartida que pueda hacer uso del marco de cach&amp;eacute; de Django. En este caso, se supone que cualquier mecanismo LRU es manejado por el backend de cach&amp;eacute; compartido.</target>
        </trans-unit>
        <trans-unit id="176ea28590869923dcfef77790d0be6e85b0bc24" translate="yes" xml:space="preserve">
          <source>The un-cached underlying function can always be accessed with</source>
          <target state="translated">Siempre se puede acceder a la función subyacente no almacenada con</target>
        </trans-unit>
        <trans-unit id="d8e2dde7858b0f625a6bbfb5559beee48b1cb949" translate="yes" xml:space="preserve">
          <source>This arrangement allows a process that accesses a function multiple times to
retrieve the value without the expense of requesting it from a shared cache,
while still allowing different processes to access the result from the shared
cache.</source>
          <target state="translated">Esta disposición permite que un proceso acceda a una función varias veces para recuperar el valor sin el gasto que supone solicitarlo de una memoria caché compartida,al tiempo que permite que diferentes procesos accedan al resultado de la memoria caché compartida.</target>
        </trans-unit>
        <trans-unit id="75b9de2bd29cbf6751c7a36363a0fd751ecacea2" translate="yes" xml:space="preserve">
          <source>This is not yet implemented as a function but can be accomplished by first calling
invalidate and then calling the function</source>
          <target state="translated">Esto no se ha implementado todavía como una función,pero se puede lograr llamando primero a invalidar y luego a la función</target>
        </trans-unit>
        <trans-unit id="6c5e4c3c083a750c34b9adaef009aac85d3924c6" translate="yes" xml:space="preserve">
          <source>This was developed by &lt;a href=&quot;http://www.3top.com/team&quot;&gt;3Top, Inc.&lt;/a&gt; for use with
our ranking and recommendation platform, &lt;a href=&quot;http://www.3top.com&quot;&gt;http://www.3top.com&lt;/a&gt;.</source>
          <target state="translated">Esto fue desarrollado por &lt;a href=&quot;http://www.3top.com/team&quot;&gt;3Top, Inc.&lt;/a&gt; para su uso con nuestra plataforma de clasificaci&amp;oacute;n y recomendaci&amp;oacute;n, &lt;a href=&quot;http://www.3top.com&quot;&gt;http://www.3top.com&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="fde1a31e15e42e88afb165e49cb21121fae29131" translate="yes" xml:space="preserve">
          <source>To invalidate the cache for a specific set of arguments, including the instance
one can pass the same arguments to invalidate the both L1 and L2 caches:</source>
          <target state="translated">Para invalidar la caché de un conjunto específico de argumentos,incluyendo la instancia,se pueden pasar los mismos argumentos para invalidar las cachés L1 y L2:</target>
        </trans-unit>
        <trans-unit id="88b33e4e12f75ac8bf792aebde41f1a090f3a612" translate="yes" xml:space="preserve">
          <source>True</source>
          <target state="translated">Verdadero</target>
        </trans-unit>
        <trans-unit id="0bb18642b70b9f8a9c12ccf39487328f306b8e19" translate="yes" xml:space="preserve">
          <source>Usage</source>
          <target state="translated">Uso</target>
        </trans-unit>
        <trans-unit id="3b2cb96142ae431c2df3de4bb6b9a4cbca498afc" translate="yes" xml:space="preserve">
          <source>Usage is as simple as adding the decorator to a function or method as seen in
the below examples from our test cases:</source>
          <target state="translated">El uso es tan simple como añadir el decorador a una función o método como se ve en los siguientes ejemplos de nuestros casos de prueba:</target>
        </trans-unit>
        <trans-unit id="b8b4346e8782d546f582feeaec684daca029da8b" translate="yes" xml:space="preserve">
          <source>We used a backport python 3</source>
          <target state="translated">Usamos una pitón de backport 3</target>
        </trans-unit>
        <trans-unit id="235811c1759d45111475d5266bc6a107245df52d" translate="yes" xml:space="preserve">
          <source>and if not found fall back to</source>
          <target state="translated">y si no se encuentra,volver a</target>
        </trans-unit>
        <trans-unit id="b204bca289d16df380a96f6adc203c95eff37534" translate="yes" xml:space="preserve">
          <source>decorator as a starting
point for developing an in instance cache with LRU capabilities.  However we
needed to ensure the keys would also be unique enough to use with a shared
cache. We leverage Django&amp;rsquo;s excellent cache framework for managing the layer 2
cache. This allows the use of any shared cache supported by Django.</source>
          <target state="translated">decorador como punto de partida para desarrollar una cach&amp;eacute; en instancia con capacidades LRU. Sin embargo, necesit&amp;aacute;bamos asegurarnos de que las claves tambi&amp;eacute;n fueran lo suficientemente &amp;uacute;nicas como para usarlas con una cach&amp;eacute; compartida. Aprovechamos el excelente marco de cach&amp;eacute; de Django para administrar la cach&amp;eacute; de capa 2. Esto permite el uso de cualquier cach&amp;eacute; compartido compatible con Django.</target>
        </trans-unit>
        <trans-unit id="7505d64a54e061b7acd54ccd58b49dc43500b635" translate="yes" xml:space="preserve">
          <source>default</source>
          <target state="translated">por defecto</target>
        </trans-unit>
        <trans-unit id="778b425edf8ec003eb2a0a2d8a7a2a3d54043356" translate="yes" xml:space="preserve">
          <source>f.__wrapped__</source>
          <target state="translated">f.__envuelto__</target>
        </trans-unit>
        <trans-unit id="cf8c707a6006ea42369c462118f8380268597325" translate="yes" xml:space="preserve">
          <source>f.cache_info()</source>
          <target state="translated">f.cache_info()</target>
        </trans-unit>
        <trans-unit id="54800f8bd035a18cec9a83721a2f0d9901a88020" translate="yes" xml:space="preserve">
          <source>functools.lru_cache</source>
          <target state="translated">functools.lru_cache</target>
        </trans-unit>
        <trans-unit id="dcfadac569c49917e69f513a3e245fd1d6b2c92c" translate="yes" xml:space="preserve">
          <source>functools.lru_cache()</source>
          <target state="translated">functools.lru_cache()</target>
        </trans-unit>
        <trans-unit id="c589e370d15354bfa1c43ff28cafcd54ca93fbb2" translate="yes" xml:space="preserve">
          <source>however if it is not you will
need to specify what attribute should be used.</source>
          <target state="translated">Sin embargo,si no lo es,deberá especificar qué atributo debe utilizarse.</target>
        </trans-unit>
        <trans-unit id="87ea5dfc8b8e384d848979496e706390b497e547" translate="yes" xml:space="preserve">
          <source>id</source>
          <target state="translated">id</target>
        </trans-unit>
        <trans-unit id="958f57f57d72a30f329ee5538f21b0257a49a46e" translate="yes" xml:space="preserve">
          <source>if</source>
          <target state="translated">si</target>
        </trans-unit>
        <trans-unit id="894f317b9160e13f41fd9889fbe20573a6a2fa51" translate="yes" xml:space="preserve">
          <source>in the case of a method you do need to explicitly pass the instance as in the
following:</source>
          <target state="translated">en el caso de un método es necesario pasar explícitamente la instancia como en el siguiente:</target>
        </trans-unit>
        <trans-unit id="99578a0572cb4666f7da4c6317812a1795e90db6" translate="yes" xml:space="preserve">
          <source>inst_attr</source>
          <target state="translated">inst_attr</target>
        </trans-unit>
        <trans-unit id="b47f363e2b430c0647f14deea3eced9b0ef300ce" translate="yes" xml:space="preserve">
          <source>is</source>
          <target state="translated">es</target>
        </trans-unit>
        <trans-unit id="04aea98291c14f68c64d647870dcc66791bebff3" translate="yes" xml:space="preserve">
          <source>is set to</source>
          <target state="translated">se establece en</target>
        </trans-unit>
        <trans-unit id="203a495a6685bc90041befff86795808f8e82182" translate="yes" xml:space="preserve">
          <source>is specified it will be used as the shared cache.  Otherwise
it will attempt to use a cache named</source>
          <target state="translated">se especifica que se usará como la caché compartida.De lo contrario,intentará utilizar un caché llamado</target>
        </trans-unit>
        <trans-unit id="f6d6ab6f2a5f07bb043396b6eddd6c513b490bbb" translate="yes" xml:space="preserve">
          <source>is the attribute used to uniquely identify an object when wrapping
a method.  In Django this will typically be</source>
          <target state="translated">es el atributo utilizado para identificar un objeto de manera única cuando se envuelve un método.En Django esto será típicamente</target>
        </trans-unit>
        <trans-unit id="4e35854b464fbca3f62f573e0ebc966a5c2346df" translate="yes" xml:space="preserve">
          <source>l1_maxsize</source>
          <target state="translated">l1_máximo tamaño</target>
        </trans-unit>
        <trans-unit id="24239dc31cf7b79a3dd81e391ffb9cf6b8f43413" translate="yes" xml:space="preserve">
          <source>l2cache</source>
          <target state="translated">l2cache</target>
        </trans-unit>
        <trans-unit id="d25a4bf33e3adbcb4faa3349bda74f43c379251e" translate="yes" xml:space="preserve">
          <source>l2cache_name</source>
          <target state="translated">l2cache_name</target>
        </trans-unit>
        <trans-unit id="67962b5f93ab7e7aee26271b6434367efdebeb0c" translate="yes" xml:space="preserve">
          <source>lru2cache is a decorator that can be used with any user function or method to
cache the most recent results in a local cache and using the django cache
framework to cache results in a shared cache.</source>
          <target state="translated">lru2cache es un decorador que se puede utilizar con cualquier función o método de usuario para almacenar en caché los resultados más recientes en un caché local y utilizar el marco de caché django para almacenar los resultados en un caché compartido.</target>
        </trans-unit>
        <trans-unit id="a0b82c9aec209c2aeba44c98d6e0f5ac1eeb0366" translate="yes" xml:space="preserve">
          <source>none_cache</source>
          <target state="translated">none_cache</target>
        </trans-unit>
        <trans-unit id="1758356db21759f7c5a0da9b4dd1db8fd6feab3f" translate="yes" xml:space="preserve">
          <source>or</source>
          <target state="translated">lub</target>
        </trans-unit>
        <trans-unit id="7bb544dbb5a0825498324c9261119887b51048a7" translate="yes" xml:space="preserve">
          <source>results that vary on the arguments. The
discarding of the LRU cached values is handled by the decorator.</source>
          <target state="translated">resultados que varían en los argumentos.El descarte de los valores almacenados de la LRU es manejado por el decorador.</target>
        </trans-unit>
        <trans-unit id="32800976dbaf3bf9a9490995b0c0f0b6bbb55857" translate="yes" xml:space="preserve">
          <source>results will be cached, otherwise they
will not.</source>
          <target state="translated">los resultados serán almacenados,de lo contrario no lo harán.</target>
        </trans-unit>
        <trans-unit id="d820aa5f8750fdde33200083b0702a32578a6c95" translate="yes" xml:space="preserve">
          <source>than</source>
          <target state="translated">que</target>
        </trans-unit>
        <trans-unit id="80df4a04d26c83f618293af30f0535e20afd7329" translate="yes" xml:space="preserve">
          <source>the cache and statistics associated with a function or method can be cleared with:</source>
          <target state="translated">el caché y las estadísticas asociadas a una función o método se pueden borrar con:</target>
        </trans-unit>
        <trans-unit id="bda4b1c3ce007842c38ded3638ca7730d8a8aae7" translate="yes" xml:space="preserve">
          <source>typed</source>
          <target state="translated">escrito a máquina</target>
        </trans-unit>
        <trans-unit id="dcfac732a9fac915f0831ba3d8ab666199413e95" translate="yes" xml:space="preserve">
          <source>with minor changes to make them work with python 2.7
and incorporated the l2_cache stats. We will continue to add tests to validate
the additional functionality provided by this decorator.</source>
          <target state="translated">con pequeños cambios para que funcionen con pitón 2.7 e incorporó las estadísticas de l2_cache.Continuaremos añadiendo pruebas para validar la funcionalidad adicional proporcionada por este decorador.</target>
        </trans-unit>
        <trans-unit id="290239353d61d53048fdeae4868e219f2dd57e54" translate="yes" xml:space="preserve">
          <source>you will need to
specify the name of the cache.</source>
          <target state="translated">tendrá que especificar el nombre del caché.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
