<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="es" datatype="htmlbody" original="https://pypi.org/project/faulthandler/">
    <body>
      <group id="faulthandler">
        <trans-unit id="8b32f169fb309037a80f683a4b6d37e7cba4bdc1" translate="yes" xml:space="preserve">
          <source>Alternatively you can set the PYTHONFAULTHANDLER environment variable to a
non-empty value.</source>
          <target state="translated">Alternativamente puede establecer la variable de entorno de PYTHONFAULTHANDLER a un valor no vacío.</target>
        </trans-unit>
        <trans-unit id="b05598106e76da0d607a6a81c201935a1dbfee9a" translate="yes" xml:space="preserve">
          <source>By default, the Python traceback is written to the standard error stream. Start
your graphical applications in a terminal and run your server in foreground to
see the traceback, or pass a file to faulthandler.enable().</source>
          <target state="translated">Por defecto,el rastreo de Python se escribe en el flujo de error estándar.Inicie sus aplicaciones gráficas en una terminal y ejecute su servidor en primer plano para ver el rastreo,o pase un archivo a faulthandler.enable().</target>
        </trans-unit>
        <trans-unit id="fa7641d6cb8d0ba8e60b2b86f9a48291331443a8" translate="yes" xml:space="preserve">
          <source>Display the Python traceback on a crash</source>
          <target state="translated">Mostrar el rastro de Python en un accidente</target>
        </trans-unit>
        <trans-unit id="148333c18dd79509f9564b86c3add191d327ffcc" translate="yes" xml:space="preserve">
          <source>Fault handler for SIGSEGV, SIGFPE, SIGABRT, SIGBUS and SIGILL signals: display
the Python traceback and restore the previous handler. Allocate an alternate
stack for this handler, if sigaltstack() is available, to be able to allocate
memory on the stack, even on stack overflow (not available on Windows).</source>
          <target state="translated">Manejador de fallas para las señales SIGSEGV,SIGFPE,SIGABRT,SIGBUS y SIGILL:muestra el rastreo de Python y restaura el manejador anterior.Asignar una pila alternativa para este manejador,si sigaltstack()está disponible,para poder asignar memoria en la pila,incluso en caso de desbordamiento de la pila (no disponible en Windows).</target>
        </trans-unit>
        <trans-unit id="81e0ceb7fc7b0120d9efeaffe709c095b3d029da" translate="yes" xml:space="preserve">
          <source>Import the module and call faulthandler.enable() to enable the fault handler.</source>
          <target state="translated">Importa el módulo y llama a faulthandler.enable()para habilitar el manejador de fallas.</target>
        </trans-unit>
        <trans-unit id="45e8e62be32ad547820a512d950cbe7aeb111584" translate="yes" xml:space="preserve">
          <source>The fault handler is called on catastrophic cases and so it can only use
signal-safe functions (eg. it doesn&amp;rsquo;t allocate memory on the heap). That&amp;rsquo;s why
the traceback is limited: it only supports ASCII encoding (use the
backslashreplace error handler for non-ASCII characters) and limits each string
to 100 characters, doesn&amp;rsquo;t print the source code in the traceback (only the
filename, the function name and the line number), is limited to 100 frames and
100 threads.</source>
          <target state="translated">El manejador de fallas se llama en casos catastr&amp;oacute;ficos y, por lo tanto, solo puede usar funciones seguras de se&amp;ntilde;al (por ejemplo, no asigna memoria en el mont&amp;oacute;n). Es por eso que el rastreo es limitado: solo admite codificaci&amp;oacute;n ASCII (use el controlador de error de reemplazo de barra invertida para caracteres que no son ASCII) y limita cada cadena a 100 caracteres, no imprime el c&amp;oacute;digo fuente en el rastreo (solo el nombre del archivo, el nombre de la funci&amp;oacute;n y el n&amp;uacute;mero de l&amp;iacute;nea), est&amp;aacute; limitado a 100 fotogramas y 100 hilos.</target>
        </trans-unit>
        <trans-unit id="3b7e79012975d3e861952d69da3944f99e276605" translate="yes" xml:space="preserve">
          <source>This module is the backport for CPython 2.7. faulthandler is part of CPython
standard library since CPython 3.3: &lt;a href=&quot;http://docs.python.org/dev/library/faulthandler.html&quot;&gt;faulthandler&lt;/a&gt;. For PyPy,
faulthandler is builtin since PyPy 5.5: use</source>
          <target state="translated">Este m&amp;oacute;dulo es el backport para CPython 2.7. failhandler es parte de la biblioteca est&amp;aacute;ndar de CPython desde CPython 3.3: &lt;a href=&quot;http://docs.python.org/dev/library/faulthandler.html&quot;&gt;failurehandler&lt;/a&gt; . Para PyPy, el administrador de fallas est&amp;aacute; incorporado desde PyPy 5.5: use</target>
        </trans-unit>
        <trans-unit id="5774e0c7dcae0498837702f72af167be1db50158" translate="yes" xml:space="preserve">
          <source>Website:
&lt;a href=&quot;https://faulthandler.readthedocs.io/&quot;&gt;https://faulthandler.readthedocs.io/&lt;/a&gt;</source>
          <target state="translated">Sitio web: &lt;a href=&quot;https://faulthandler.readthedocs.io/&quot;&gt;https://faulthandler.readthedocs.io/&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1cb1003c13997882c35b2965310815154c6cbb5e" translate="yes" xml:space="preserve">
          <source>faulthandler 3.2 is the last version released by Victor Stinner. I maintained
it for 10 years in my free time for the great pleasure of Python 2 users, but
Python 2 is no longer supported upstream since 2020-01-01. Each faulthandler
release requires me to start my Windows VM, install Python 2.7 in 32-bit and
64-bit, install an old C compiler just for Python 2.7, and type manually some
commands to upload Windows binaries. Moreover, I have to fix some issues on
Travis CI and many small boring tasks. The maintenance is far from being free.
In 10 years, I got zero &amp;ldquo;thank you&amp;rdquo; (and 0&amp;euro;), only bug reports :-)</source>
          <target state="translated">Failhandler 3.2 es la &amp;uacute;ltima versi&amp;oacute;n lanzada por Victor Stinner. Lo mantuve durante 10 a&amp;ntilde;os en mi tiempo libre para el gran placer de los usuarios de Python 2, pero Python 2 ya no es compatible con versiones anteriores desde 2020-01-01. Cada versi&amp;oacute;n del administrador de fallas requiere que inicie mi VM de Windows, instale Python 2.7 en 32 bits y 64 bits, instale un compilador de C antiguo solo para Python 2.7 y escriba manualmente algunos comandos para cargar archivos binarios de Windows. Adem&amp;aacute;s, tengo que solucionar algunos problemas en Travis CI y muchas peque&amp;ntilde;as tareas aburridas. El mantenimiento est&amp;aacute; lejos de ser gratuito. En 10 a&amp;ntilde;os, obtuve cero &quot;gracias&quot; (y 0 &amp;euro;), solo informes de errores :-)</target>
        </trans-unit>
        <trans-unit id="e8c4d13fd2fd99b029d92a36fad256f8f653a5a1" translate="yes" xml:space="preserve">
          <source>faulthandler is implemented in C using signal handlers to be able to dump a
traceback on a crash or when Python is blocked (eg. deadlock).</source>
          <target state="translated">El manejador de fallas se implementa en C usando manejadores de señales para poder volcar un rastreo en un choque o cuando Python se bloquea (por ejemplo,un bloqueo).</target>
        </trans-unit>
        <trans-unit id="2caee2bbfef6db853f54ebef721cc989c0da49f3" translate="yes" xml:space="preserve">
          <source>pypy -X faulthandler</source>
          <target state="translated">pypy -X faulthandler</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
