<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="es" datatype="htmlbody" original="https://pypi.org/project/django-cache-memoize/">
    <body>
      <group id="django-cache-memoize">
        <trans-unit id="6ec3b6aae5a1a82f8273b1342bb46136833a7a6a" translate="yes" xml:space="preserve">
          <source>&amp;ldquo;Competition&amp;rdquo;</source>
          <target state="translated">&quot;Competencia&quot;</target>
        </trans-unit>
        <trans-unit id="195796f5339ee048530325688564a5319aced725" translate="yes" xml:space="preserve">
          <source>.
So if you have a function that returns something that can&amp;rsquo;t be pickled and
cached it won&amp;rsquo;t work.</source>
          <target state="translated">. Entonces, si tiene una funci&amp;oacute;n que devuelve algo que no se puede decapado y almacenamiento en cach&amp;eacute;, no funcionar&amp;aacute;.</target>
        </trans-unit>
        <trans-unit id="cf664adba84fbf2801d648fd52ef5acf5fa8715c" translate="yes" xml:space="preserve">
          <source>. It gets the same positional and keyword arguments
as the function you&amp;rsquo;re decorating. Here&amp;rsquo;s an example implementation:</source>
          <target state="translated">. Obtiene los mismos argumentos posicionales y de palabras clave que la funci&amp;oacute;n que est&amp;aacute; decorando. Aqu&amp;iacute; hay una implementaci&amp;oacute;n de ejemplo:</target>
        </trans-unit>
        <trans-unit id="d3b0fb652099658032a196e2d388abacedbef6ed" translate="yes" xml:space="preserve">
          <source>. Like this:</source>
          <target state="translated">. Me gusta esto:</target>
        </trans-unit>
        <trans-unit id="fc0cfef2762bdfdf9b3175d7c76b34f1f4ce28f7" translate="yes" xml:space="preserve">
          <source>. This is equivalent to your function
returning</source>
          <target state="translated">. Esto es equivalente a que su funci&amp;oacute;n regrese</target>
        </trans-unit>
        <trans-unit id="29ea70480c9828cb62a31a8baa47f907af0cbb17" translate="yes" xml:space="preserve">
          <source>.invalidate</source>
          <target state="translated">.invalidar</target>
        </trans-unit>
        <trans-unit id="c95f9ef1896d04dc31914dff53823d43f85e3b7b" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://symbols.mozilla.org&quot;&gt;Mozilla Symbol Server&lt;/a&gt; is written in Django. It&amp;rsquo;s a web service that
sits between C++ debuggers and AWS S3. It shuffles symbol files in and out of
AWS S3. Symbol files are for C++ (and other compiled languages) what
sourcemaps are for JavaScript.</source>
          <target state="translated">&lt;a href=&quot;https://symbols.mozilla.org&quot;&gt;Mozilla Symbol Server&lt;/a&gt; est&amp;aacute; escrito en Django. Es un servicio web que se encuentra entre los depuradores de C ++ y AWS S3. Reorganiza archivos de s&amp;iacute;mbolos dentro y fuera de AWS S3. Los archivos de s&amp;iacute;mbolos son para C ++ (y otros lenguajes compilados) lo que los mapas de origen son para JavaScript.</target>
        </trans-unit>
        <trans-unit id="dd08610940962995d60e40413951d9f7631cb407" translate="yes" xml:space="preserve">
          <source>Ability to use as a &amp;ldquo;guard&amp;rdquo; for repeated execution when storing the function
result isn&amp;rsquo;t important or needed.</source>
          <target state="translated">La capacidad de utilizarlo como un &quot;protector&quot; para la ejecuci&amp;oacute;n repetida cuando el almacenamiento del resultado de la funci&amp;oacute;n no es importante o necesario.</target>
        </trans-unit>
        <trans-unit id="ec9c1eee60a6c8d412e86494c4538774b81ce815" translate="yes" xml:space="preserve">
          <source>Advanced Usage</source>
          <target state="translated">Uso avanzado</target>
        </trans-unit>
        <trans-unit id="f7c7d47fe21bd9222fc313673e59c857eab8d6dc" translate="yes" xml:space="preserve">
          <source>All code has to be formatted with &lt;a href=&quot;https://pypi.org/project/black/&quot;&gt;Black&lt;/a&gt;
and the best tool for checking this is
&lt;a href=&quot;https://pypi.org/project/therapist/&quot;&gt;therapist&lt;/a&gt; since it can help you run
all, help you fix things, and help you make sure linting is passing before
you git commit. This project also uses</source>
          <target state="translated">Todo el c&amp;oacute;digo debe estar formateado con &lt;a href=&quot;https://pypi.org/project/black/&quot;&gt;Black&lt;/a&gt; y la mejor herramienta para verificar esto es el &lt;a href=&quot;https://pypi.org/project/therapist/&quot;&gt;terapeuta,&lt;/a&gt; ya que puede ayudarlo a ejecutar todo, ayudarlo a arreglar las cosas y ayudarlo a asegurarse de que el borr&amp;oacute;n est&amp;eacute; pasando antes de realizar el compromiso. Este proyecto tambi&amp;eacute;n utiliza</target>
        </trans-unit>
        <trans-unit id="58cf010477011085508d82c17f77fa7b2057c87a" translate="yes" xml:space="preserve">
          <source>An &amp;ldquo;alias&amp;rdquo; of doing the same thing is to pass a keyword argument called</source>
          <target state="translated">Un &quot;alias&quot; para hacer lo mismo es pasar un argumento de palabra clave llamado</target>
        </trans-unit>
        <trans-unit id="86b9a89b3322904ffd98fa9a61a0cb15a4862069" translate="yes" xml:space="preserve">
          <source>And to fix all/any issues run:</source>
          <target state="translated">Y para arreglar todos los problemas que se presentan:</target>
        </trans-unit>
        <trans-unit id="b6ab6d4d2f8fdbf80724698cc472a96935583553" translate="yes" xml:space="preserve">
          <source>Another key difference is that</source>
          <target state="translated">Otra diferencia clave es que</target>
        </trans-unit>
        <trans-unit id="fbb72ba5eb0ff9020b0af6414d8f3a709dbeb528" translate="yes" xml:space="preserve">
          <source>By default the prefix becomes the name of the function. Consider:</source>
          <target state="translated">Por defecto,el prefijo se convierte en el nombre de la función.Considere:</target>
        </trans-unit>
        <trans-unit id="ac0b7cf2ddb0e2c3a2da80e8d13396dd6b5e7368" translate="yes" xml:space="preserve">
          <source>Cache invalidation</source>
          <target state="translated">Invalidación de la caché</target>
        </trans-unit>
        <trans-unit id="c8b1a972fe343f3d2f2fe444fb3a7ab3f0148ace" translate="yes" xml:space="preserve">
          <source>Check out the &lt;a href=&quot;https://github.com/peterbe/django-cache-memoize/blob/master/tox.ini&quot;&gt;tox.ini&lt;/a&gt; file for more up-to-date compatibility by
test coverage.</source>
          <target state="translated">Consulte el archivo &lt;a href=&quot;https://github.com/peterbe/django-cache-memoize/blob/master/tox.ini&quot;&gt;tox.ini&lt;/a&gt; para obtener m&amp;aacute;s compatibilidad actualizada por cobertura de prueba.</target>
        </trans-unit>
        <trans-unit id="4463915d681f344a6328f56dad4ca5b776b764cf" translate="yes" xml:space="preserve">
          <source>Code style is all black</source>
          <target state="translated">El estilo de código es todo negro</target>
        </trans-unit>
        <trans-unit id="5d60c7dd62fdcf4abcc61a6a7d335b7117968b4d" translate="yes" xml:space="preserve">
          <source>Compatibility</source>
          <target state="translated">Compatibilidad</target>
        </trans-unit>
        <trans-unit id="4c17aadf5117487aab7bc50cbf056caf3977cc31" translate="yes" xml:space="preserve">
          <source>Development</source>
          <target state="translated">Desarrollo</target>
        </trans-unit>
        <trans-unit id="10a39b8b5ae782212eea401964ea72a478e45605" translate="yes" xml:space="preserve">
          <source>Django 1.11, 2.0, 2.1, 2.2, 3.0</source>
          <target state="translated">Django 1.11,2.0,2.1,2.2,3.0</target>
        </trans-unit>
        <trans-unit id="a57ade0e7edd103cd1d485c8463965b1ac7633a8" translate="yes" xml:space="preserve">
          <source>Django utility for a memoization decorator that uses the Django cache framework.</source>
          <target state="translated">Utilidad Django para un decorador de memorias que usa el marco de caché Django.</target>
        </trans-unit>
        <trans-unit id="8f99733e60eb12c427254adc05371199f97031b9" translate="yes" xml:space="preserve">
          <source>Exact same functionality as</source>
          <target state="translated">Exactamente la misma funcionalidad que</target>
        </trans-unit>
        <trans-unit id="654d7a479004b2b26e7de7b5ed9cd79a331ded80" translate="yes" xml:space="preserve">
          <source>Example Usage</source>
          <target state="translated">Ejemplo de uso</target>
        </trans-unit>
        <trans-unit id="97cdbdc7feff827efb082a6b6dd2727237cd49fd" translate="yes" xml:space="preserve">
          <source>False</source>
          <target state="translated">Falso</target>
        </trans-unit>
        <trans-unit id="eacfb351a37f91d2ddcd1a637cc6d5b859374c16" translate="yes" xml:space="preserve">
          <source>For cases like this, Django exposes a simple, low-level cache API. You can
use this API to store objects in the cache with any level of granularity
you like. You can cache any Python object that can be pickled safely:
strings, dictionaries, lists of model objects, and so forth. (Most
common Python objects can be pickled; refer to the Python documentation
for more information about pickling.)</source>
          <target state="translated">Para casos como este,Django expone una API de caché simple y de bajo nivel.Puedes usar esta API para almacenar objetos en la caché con cualquier nivel de granularidad que desees.Puedes almacenar en la caché cualquier objeto Python que se pueda decapar de forma segura:cadenas,diccionarios,listas de objetos modelo,etc.(Los objetos Python más comunes pueden ser decapados;consulta la documentación de Python para obtener más información sobre el decapado).</target>
        </trans-unit>
        <trans-unit id="c127c7a6353c9161520bb9cf466c2ad170121c8e" translate="yes" xml:space="preserve">
          <source>For versions of Python and Django, check out &lt;a href=&quot;https://github.com/peterbe/django-cache-memoize/blob/master/tox.ini&quot;&gt;the tox.ini file&lt;/a&gt;.</source>
          <target state="translated">Para las versiones de Python y Django, consulte &lt;a href=&quot;https://github.com/peterbe/django-cache-memoize/blob/master/tox.ini&quot;&gt;el archivo tox.ini&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="90ccd6497400b5576aeca1bd94af74aae1e0a250" translate="yes" xml:space="preserve">
          <source>History</source>
          <target state="translated">Historia</target>
        </trans-unit>
        <trans-unit id="31eeefb0cc8def847d0cd40be77be1e18d9b669d" translate="yes" xml:space="preserve">
          <source>However, this works&amp;hellip;</source>
          <target state="translated">Sin embargo, esto funciona ...</target>
        </trans-unit>
        <trans-unit id="2d1e7cecea0d3e8b3a70342e1c998a736be94364" translate="yes" xml:space="preserve">
          <source>I found</source>
          <target state="translated">Encontré</target>
        </trans-unit>
        <trans-unit id="dff2aa583f28c699de8049360dc0ce52eb30bec6" translate="yes" xml:space="preserve">
          <source>If set, a function that gets called with the original argument and keyword
arguments &lt;strong&gt;if&lt;/strong&gt; the cache was able to find and return a cache hit.
For example, suppose you want to tell your</source>
          <target state="translated">Si se establece, una funci&amp;oacute;n que se llama con el argumento original y los argumentos de palabras clave &lt;strong&gt;si&lt;/strong&gt; la cach&amp;eacute; pudo encontrar y devolver un acierto de cach&amp;eacute;. Por ejemplo, suponga que quiere decirle a su</target>
        </trans-unit>
        <trans-unit id="46f1baf59147d06cab6a248e863fac0b1b90b01a" translate="yes" xml:space="preserve">
          <source>In benchmarks running both</source>
          <target state="translated">En los puntos de referencia que corren ambos</target>
        </trans-unit>
        <trans-unit id="d4bb5945ba5eb05b71622300259d5bae786c0b1f" translate="yes" xml:space="preserve">
          <source>Insight into cache hits and cache missed with a callback.</source>
          <target state="translated">La comprensión de los éxitos y los fracasos de la memoria caché con una llamada de retorno.</target>
        </trans-unit>
        <trans-unit id="c81b79df3c6448eae7c4f80428b54cd5692a17d7" translate="yes" xml:space="preserve">
          <source>Installation</source>
          <target state="translated">Instalación</target>
        </trans-unit>
        <trans-unit id="28bb408cf6748a2669f64e5cc7fae7cc107d035b" translate="yes" xml:space="preserve">
          <source>Internally the decorator rewrites every argument and keyword argument to
the function it wraps into a concatenated string. The first thing you
might want to do is help the decorator rewrite the arguments to something
more suitable as a cache key string. For example, suppose you have instances
of a class whose</source>
          <target state="translated">Internamente el decorador reescribe cada argumento y argumento de la palabra clave a la función que envuelve en una cadena concatenada.Lo primero que puede hacer es ayudar al decorador a reescribir los argumentos a algo más adecuado como una cadena clave de caché.Por ejemplo,supongamos que tienes ejemplos de una clase cuya</target>
        </trans-unit>
        <trans-unit id="b678919728657ea65b442a31404d2f928488f8da" translate="yes" xml:space="preserve">
          <source>It demonstrates similarly to the above Usage example but with a little more
detail. In particular it demonstrates the difference between &lt;em&gt;not&lt;/em&gt; using</source>
          <target state="translated">Se demuestra de manera similar al ejemplo de uso anterior, pero con un poco m&amp;aacute;s de detalle. En particular, demuestra la diferencia entre &lt;em&gt;no&lt;/em&gt; usar</target>
        </trans-unit>
        <trans-unit id="c961da4e3b66e2f97987a7afe330011eb7cb4e36" translate="yes" xml:space="preserve">
          <source>Key Features</source>
          <target state="translated">Características principales</target>
        </trans-unit>
        <trans-unit id="9ee5748c28412f181c0feb7f1944a0f013fb8598" translate="yes" xml:space="preserve">
          <source>License: MPL 2.0</source>
          <target state="translated">Licencia:MPL 2.0</target>
        </trans-unit>
        <trans-unit id="95eb537f1f43117e2efaa31432c732381cc7792a" translate="yes" xml:space="preserve">
          <source>Memoized function calls can be invalidated.</source>
          <target state="translated">Las llamadas a funciones memorizadas pueden ser invalidadas.</target>
        </trans-unit>
        <trans-unit id="e22c1d1c10240eafae9cf8c0c19975c8915cc6fa" translate="yes" xml:space="preserve">
          <source>New uploads are arriving as zip file bundles of files, from Mozilla&amp;rsquo;s build
systems, at a rate of about 600MB every minute, each containing on average
about 100 files each. When a new upload comes in we need to quickly be able
find out if it exists in S3 and this gets cached since often the same files
are repeated in different uploads. But when a file does get uploaded into S3
we need to quickly and confidently invalidate any local caches. That way you
get to keep a really aggressive cache without any stale periods.</source>
          <target state="translated">Las nuevas cargas est&amp;aacute;n llegando como paquetes de archivos zip de los sistemas de compilaci&amp;oacute;n de Mozilla, a una velocidad de aproximadamente 600 MB por minuto, cada uno con un promedio de aproximadamente 100 archivos cada uno. Cuando llega una nueva carga, necesitamos saber r&amp;aacute;pidamente si existe en S3 y esto se almacena en cach&amp;eacute;, ya que a menudo los mismos archivos se repiten en diferentes cargas. Pero cuando un archivo se carga en S3, debemos invalidar de forma r&amp;aacute;pida y segura cualquier cach&amp;eacute; local. De esa manera, puede mantener una cach&amp;eacute; realmente agresiva sin per&amp;iacute;odos obsoletos.</target>
        </trans-unit>
        <trans-unit id="f184d44b598b788adde29d493e92a5c25b0ed0b5" translate="yes" xml:space="preserve">
          <source>Prior Art</source>
          <target state="translated">El arte previo</target>
        </trans-unit>
        <trans-unit id="e1f0561decc4c7ee615ce7515e92fc9e586d4dc8" translate="yes" xml:space="preserve">
          <source>Python 3.4, 3.5, 3.6, 3.7</source>
          <target state="translated">Pitón 3.4,3.5,3.6,3.7</target>
        </trans-unit>
        <trans-unit id="2cd4b406ae0bb568e7df884db51c4e2de1e96c91" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://docs.djangoproject.com/en/1.11/topics/cache/#the-low-level-cache-api&quot;&gt;documentation&lt;/a&gt;.</source>
          <target state="translated">Ver &lt;a href=&quot;https://docs.djangoproject.com/en/1.11/topics/cache/#the-low-level-cache-api&quot;&gt;documentaci&amp;oacute;n&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="93ef0dd827103681fcee453b78be2ff14e1a261d" translate="yes" xml:space="preserve">
          <source>The</source>
          <target state="translated">El</target>
        </trans-unit>
        <trans-unit id="0fabf29b01ae976d48430cd70d46e857b0923aae" translate="yes" xml:space="preserve">
          <source>The caching uses &lt;a href=&quot;https://docs.djangoproject.com/en/1.11/topics/cache/&quot;&gt;Django&amp;rsquo;s default cache framework&lt;/a&gt;. Ultimately, it calls</source>
          <target state="translated">El almacenamiento en cach&amp;eacute; utiliza &lt;a href=&quot;https://docs.djangoproject.com/en/1.11/topics/cache/&quot;&gt;el marco de cach&amp;eacute; predeterminado de Django&lt;/a&gt; . En &amp;uacute;ltima instancia, llama</target>
        </trans-unit>
        <trans-unit id="69416aae8f6e90c66323ed064f4902f45ddb3690" translate="yes" xml:space="preserve">
          <source>The most basic thing is to clone the repo and run:</source>
          <target state="translated">Lo más básico es clonar el repo y correr:</target>
        </trans-unit>
        <trans-unit id="79aca7afb5689b85853200c712230fe7c9f6f4ea" translate="yes" xml:space="preserve">
          <source>There is already &lt;a href=&quot;http://pythonhosted.org/django-memoize/&quot;&gt;django-memoize&lt;/a&gt; by &lt;a href=&quot;https://github.com/tvavrys&quot;&gt;Thomas Vavrys&lt;/a&gt;.
It too is available as a memoization decorator you use in Django. And it
uses the default cache framework as a storage. It used</source>
          <target state="translated">Ya existe &lt;a href=&quot;http://pythonhosted.org/django-memoize/&quot;&gt;django-memoize&lt;/a&gt; de &lt;a href=&quot;https://github.com/tvavrys&quot;&gt;Thomas Vavrys&lt;/a&gt; . Tambi&amp;eacute;n est&amp;aacute; disponible como decorador de notas que usa en Django. Y utiliza el marco de cach&amp;eacute; predeterminado como almacenamiento. Sol&amp;iacute;a</target>
        </trans-unit>
        <trans-unit id="e1fd32e9479a8d9629519ca06d6314d4a453b727" translate="yes" xml:space="preserve">
          <source>There is no way to clear more than one cache key. In the above example,
you had to know the &amp;ldquo;original arguments&amp;rdquo; when you wanted to invalidate
the cache. There is no method &amp;ldquo;search&amp;rdquo; for all cache keys that match a
certain pattern.</source>
          <target state="translated">No hay forma de borrar m&amp;aacute;s de una clave de cach&amp;eacute;. En el ejemplo anterior, ten&amp;iacute;a que conocer los &quot;argumentos originales&quot; cuando quer&amp;iacute;a invalidar la cach&amp;eacute;. No existe un m&amp;eacute;todo de &quot;b&amp;uacute;squeda&quot; para todas las claves de cach&amp;eacute; que coinciden con un patr&amp;oacute;n determinado.</target>
        </trans-unit>
        <trans-unit id="a884f2faf6825ccf26aff0dbc9395db6b4d54129" translate="yes" xml:space="preserve">
          <source>This blog post: &lt;a href=&quot;https://www.peterbe.com/plog/how-to-use-django-cache-memoize&quot;&gt;How to use django-cache-memoize&lt;/a&gt;</source>
          <target state="translated">Esta publicaci&amp;oacute;n de blog: &lt;a href=&quot;https://www.peterbe.com/plog/how-to-use-django-cache-memoize&quot;&gt;C&amp;oacute;mo usar django-cache-memoize&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="96e8906e8784301f166709fb0c52f6fc3e25ad3a" translate="yes" xml:space="preserve">
          <source>This is a contrived example, but basically &lt;em&gt;you know&lt;/em&gt; that the</source>
          <target state="translated">Este es un ejemplo artificial, pero b&amp;aacute;sicamente &lt;em&gt;sabes&lt;/em&gt; que el</target>
        </trans-unit>
        <trans-unit id="88b371a5aa0588701d7c4024ea93a09a38f1d07c" translate="yes" xml:space="preserve">
          <source>This is the use case</source>
          <target state="translated">Este es el caso de uso</target>
        </trans-unit>
        <trans-unit id="8761cf1620b74a634c1f7aa4939f54f3997a2863" translate="yes" xml:space="preserve">
          <source>This is useful if you have a function you want to make sure only gets called
once per timeout expiration but you don&amp;rsquo;t actually care that much about
what the function return value was. Perhaps because you know that the
function returns something that would quickly fill up your</source>
          <target state="translated">Esto es &amp;uacute;til si tiene una funci&amp;oacute;n que desea asegurarse de que solo se llame una vez por expiraci&amp;oacute;n del tiempo de espera, pero en realidad no le importa mucho cu&amp;aacute;l fue el valor de retorno de la funci&amp;oacute;n. Quiz&amp;aacute;s porque sabe que la funci&amp;oacute;n devuelve algo que llenar&amp;iacute;a r&amp;aacute;pidamente su</target>
        </trans-unit>
        <trans-unit id="650e69b32239f5b5255bb7d62bf3983174bc1da2" translate="yes" xml:space="preserve">
          <source>This service gets a LOT of traffic. The download traffic (proxying requests
for symbols in S3) gets about ~40 requests per second. Due to the nature
of the application most of these GETs result in a 404 Not Found but instead
of asking AWS S3 for every single file, these lookups are cached in a
highly configured &lt;a href=&quot;https://redis.io/&quot;&gt;Redis&lt;/a&gt; configuration. This Redis cache is also connected
to the part of the code that uploads new files.</source>
          <target state="translated">Este servicio recibe MUCHO tr&amp;aacute;fico. El tr&amp;aacute;fico de descarga (solicitudes de proxy de s&amp;iacute;mbolos en S3) recibe aproximadamente 40 solicitudes por segundo. Debido a la naturaleza de la aplicaci&amp;oacute;n, la mayor&amp;iacute;a de estos GET dan como resultado un 404 Not Found, pero en lugar de preguntar a AWS S3 por cada archivo, estas b&amp;uacute;squedas se almacenan en cach&amp;eacute; en una configuraci&amp;oacute;n de &lt;a href=&quot;https://redis.io/&quot;&gt;Redis&lt;/a&gt; altamente configurada. Esta cach&amp;eacute; de Redis tambi&amp;eacute;n est&amp;aacute; conectada a la parte del c&amp;oacute;digo que carga nuevos archivos.</target>
        </trans-unit>
        <trans-unit id="fd6a68ad54dd35d7d49f345e65bbbe1e77795fb8" translate="yes" xml:space="preserve">
          <source>To check linting with</source>
          <target state="translated">Para comprobar las pelusas con</target>
        </trans-unit>
        <trans-unit id="032ef0eb8dec93b7e7afbf4e77825cceb1a68639" translate="yes" xml:space="preserve">
          <source>To install the</source>
          <target state="translated">Para instalar el</target>
        </trans-unit>
        <trans-unit id="88b33e4e12f75ac8bf792aebde41f1a090f3a612" translate="yes" xml:space="preserve">
          <source>True</source>
          <target state="translated">Verdadero</target>
        </trans-unit>
        <trans-unit id="0bb18642b70b9f8a9c12ccf39487328f306b8e19" translate="yes" xml:space="preserve">
          <source>Usage</source>
          <target state="translated">Uso</target>
        </trans-unit>
        <trans-unit id="768a0f8218c09504241ccf7722807f3194fe7e32" translate="yes" xml:space="preserve">
          <source>When you run</source>
          <target state="translated">Cuando corres</target>
        </trans-unit>
        <trans-unit id="4afb59a83fb8064633a4597f3c972d80ff1693b5" translate="yes" xml:space="preserve">
          <source>When you want to &amp;ldquo;undo&amp;rdquo; some caching done, you simply call the function
again with the same arguments except you add</source>
          <target state="translated">Cuando desee &quot;deshacer&quot; el almacenamiento en cach&amp;eacute; realizado, simplemente vuelva a llamar a la funci&amp;oacute;n con los mismos argumentos, excepto que agrega</target>
        </trans-unit>
        <trans-unit id="49b9baa2954d1440877eb4b80f37995a181297be" translate="yes" xml:space="preserve">
          <source>Works with non-trivial arguments and keyword arguments</source>
          <target state="translated">Trabaja con argumentos no triviales y argumentos de palabras clave</target>
        </trans-unit>
        <trans-unit id="145b45cbc08ae9b05fff89019c2e31ad888355df" translate="yes" xml:space="preserve">
          <source>__str__</source>
          <target state="translated">__str__</target>
        </trans-unit>
        <trans-unit id="a4d2bac54e12a16306abedb9ee76efe7146eed42" translate="yes" xml:space="preserve">
          <source>_refresh=True</source>
          <target state="translated">_refresh = Verdadero</target>
        </trans-unit>
        <trans-unit id="cffa50a32cb13a240d705317bcec65dd1f31b6ad" translate="yes" xml:space="preserve">
          <source>and</source>
          <target state="translated">en</target>
        </trans-unit>
        <trans-unit id="4d911ebf7913ac41fb9b9b5971ef20d0b1715324" translate="yes" xml:space="preserve">
          <source>and then adding it to your code after.</source>
          <target state="translated">y luego agregarlo a tu código después.</target>
        </trans-unit>
        <trans-unit id="075d408136da3093c1320171e98d32b766508126" translate="yes" xml:space="preserve">
          <source>args_rewrite</source>
          <target state="translated">args_rewrite</target>
        </trans-unit>
        <trans-unit id="034373531242ccb88e4a23e703c0c45f7a2b3f75" translate="yes" xml:space="preserve">
          <source>argument allows you to use a cache other than the default.</source>
          <target state="translated">permite utilizar una caché distinta a la predeterminada.</target>
        </trans-unit>
        <trans-unit id="5aa4352fe7730966ddcc032da8e484d48e33b881" translate="yes" xml:space="preserve">
          <source>cache_alias</source>
          <target state="translated">cache_alias</target>
        </trans-unit>
        <trans-unit id="ee6c0c88442fb75d05c7fae83539af81eba3bd8b" translate="yes" xml:space="preserve">
          <source>conversion of certain arguments isn&amp;rsquo;t safe. Then you can pass in a callable
called</source>
          <target state="translated">la conversi&amp;oacute;n de ciertos argumentos no es segura. Entonces puedes pasar un invocable llamado</target>
        </trans-unit>
        <trans-unit id="1e21c4fd0ecc353240fb4daa6918e4bc23cb5926" translate="yes" xml:space="preserve">
          <source>django-cache-memoize</source>
          <target state="translated">django-cache-memoize</target>
        </trans-unit>
        <trans-unit id="ca1bcc56b8ac1d212738fe3761c5733e7e1e5202" translate="yes" xml:space="preserve">
          <source>django-memoize</source>
          <target state="translated">django-memoize</target>
        </trans-unit>
        <trans-unit id="83655978ff4986a00479ba572a0650e7d6afeb00" translate="yes" xml:space="preserve">
          <source>django.core.cache.cache.set(cache_key, function_out, expiration)</source>
          <target state="translated">django.core.cache.cache.set(cache_key,function_out,expiración)</target>
        </trans-unit>
        <trans-unit id="d04d6b5227e45ed7d1e2b779ddb25a19563ca79f" translate="yes" xml:space="preserve">
          <source>except the obvious difference
that it gets called if it was &lt;em&gt;not&lt;/em&gt; a cache hit.</source>
          <target state="translated">excepto la diferencia obvia de que se llama a si era &lt;em&gt;no&lt;/em&gt; un acierto de cach&amp;eacute;.</target>
        </trans-unit>
        <trans-unit id="8f27e4f0b0e1fabc56425bc40b6e79fabb64c9af" translate="yes" xml:space="preserve">
          <source>flake8</source>
          <target state="translated">escamas8</target>
        </trans-unit>
        <trans-unit id="4bea928f978b80953a462f43c97fd0c7217b29ec" translate="yes" xml:space="preserve">
          <source>hit_callable</source>
          <target state="translated">hit_callable</target>
        </trans-unit>
        <trans-unit id="a1a2ae18fa153a52a05172a40a60c6c0848214e2" translate="yes" xml:space="preserve">
          <source>inspect</source>
          <target state="translated">inspeccionar</target>
        </trans-unit>
        <trans-unit id="bfc7ce912866e8975c538d814c39a3c899b0303f" translate="yes" xml:space="preserve">
          <source>is also used in &lt;a href=&quot;https://songsear.ch&quot;&gt;SongSear.ch&lt;/a&gt; to cache short
queries in the autocomplete search input. All autocomplete is done by
Elasticsearch, which is amazingly fast, but not as fast as</source>
          <target state="translated">tambi&amp;eacute;n se utiliza en &lt;a href=&quot;https://songsear.ch&quot;&gt;SongSear.ch&lt;/a&gt; para almacenar en cach&amp;eacute; consultas breves en la entrada de b&amp;uacute;squeda de autocompletar. Todo el autocompletado lo realiza Elasticsearch, que es incre&amp;iacute;blemente r&amp;aacute;pido, pero no tan r&amp;aacute;pido como</target>
        </trans-unit>
        <trans-unit id="8e0a88a8f80897eab0baeaf5d470318edd276a02" translate="yes" xml:space="preserve">
          <source>it will only check the files you&amp;rsquo;ve touched.
To run it for all files use:</source>
          <target state="translated">solo comprobar&amp;aacute; los archivos que haya tocado. Para ejecutarlo para todos los archivos, use:</target>
        </trans-unit>
        <trans-unit id="ebf4a2fb4c21393bd3b0f15341b36c9367fc8350" translate="yes" xml:space="preserve">
          <source>memcached</source>
          <target state="translated">memcached</target>
        </trans-unit>
        <trans-unit id="38bdf1b7b2f334bb0e04539854077b708945e1a5" translate="yes" xml:space="preserve">
          <source>method doesn&amp;rsquo;t return a unique value. For example:</source>
          <target state="translated">El m&amp;eacute;todo no devuelve un valor &amp;uacute;nico. Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="359bf218f380faa3b508b0d52398c1d82faa4447" translate="yes" xml:space="preserve">
          <source>miss_callable</source>
          <target state="translated">miss_callable</target>
        </trans-unit>
        <trans-unit id="5913a59c742b6f7ddaff13288ca5440da9d3e641" translate="yes" xml:space="preserve">
          <source>on the
decorated function to build a cache key.</source>
          <target state="translated">en la función decorada para construir una llave de caché.</target>
        </trans-unit>
        <trans-unit id="9147986e14654f718d2ca5614901f9cbb16ffedc" translate="yes" xml:space="preserve">
          <source>or
perhaps you know it returns something that can&amp;rsquo;t be pickled. Then you
can set</source>
          <target state="translated">o quiz&amp;aacute;s sepa que devuelve algo que no se puede encurtir. Entonces puedes configurar</target>
        </trans-unit>
        <trans-unit id="3a86b4f955fdbaf12a19a6b2f43abbc097c6c857" translate="yes" xml:space="preserve">
          <source>pre-commit hook simply run:</source>
          <target state="translated">pre-compromiso de gancho simplemente correr:</target>
        </trans-unit>
        <trans-unit id="b4ebfe34d0fa97f0dd2bb1234fad8f59805f4e8d" translate="yes" xml:space="preserve">
          <source>prefix</source>
          <target state="translated">prefijo</target>
        </trans-unit>
        <trans-unit id="f644b7f7c3513bd8118b5fdb1b3b09e20b03d49e" translate="yes" xml:space="preserve">
          <source>repr()</source>
          <target state="translated">repr()</target>
        </trans-unit>
        <trans-unit id="d8ce2dda7d24b72634dc662ee116a12b6f6d2a4e" translate="yes" xml:space="preserve">
          <source>server every time
there&amp;rsquo;s a cache hit.</source>
          <target state="translated">servidor cada vez que hay un golpe de cach&amp;eacute;.</target>
        </trans-unit>
        <trans-unit id="e76c3ee222fac4befe15667056f4b2920a123b38" translate="yes" xml:space="preserve">
          <source>statsd</source>
          <target state="translated">statsd</target>
        </trans-unit>
        <trans-unit id="78002de9e5d5335e08a33a0d8d2445e4a64dccdf" translate="yes" xml:space="preserve">
          <source>store_result</source>
          <target state="translated">store_resultado</target>
        </trans-unit>
        <trans-unit id="3346abc026c7e2630a0511db843d74222dbf1533" translate="yes" xml:space="preserve">
          <source>str()</source>
          <target state="translated">str()</target>
        </trans-unit>
        <trans-unit id="cbcbe46084f65e236884cc6e9855d5767ce177d9" translate="yes" xml:space="preserve">
          <source>therapist</source>
          <target state="translated">terapeuta</target>
        </trans-unit>
        <trans-unit id="c03b431e6d407109eb5c7098b58a51252f15fd87" translate="yes" xml:space="preserve">
          <source>therapist run</source>
          <target state="translated">el terapeuta se encarga de</target>
        </trans-unit>
        <trans-unit id="4374aaee247fb237ce6c97d5c8d64bbe474d16de" translate="yes" xml:space="preserve">
          <source>to</source>
          <target state="translated">to</target>
        </trans-unit>
        <trans-unit id="310e5c24ed1c9e43d455ac90257e5431ee8150e5" translate="yes" xml:space="preserve">
          <source>to be &lt;strong&gt;~4 times faster&lt;/strong&gt; on average.</source>
          <target state="translated">para ser &lt;strong&gt;~ 4 veces m&amp;aacute;s r&amp;aacute;pido&lt;/strong&gt; en promedio.</target>
        </trans-unit>
        <trans-unit id="99d8e905a7d600faf9a9d9c17521371f9cee7e52" translate="yes" xml:space="preserve">
          <source>to check other things
Black can&amp;rsquo;t check.</source>
          <target state="translated">para comprobar otras cosas que las negras no pueden comprobar.</target>
        </trans-unit>
        <trans-unit id="72bfe11a92639014f0cdb9cf1c3ace8e0c5d115d" translate="yes" xml:space="preserve">
          <source>to the function.</source>
          <target state="translated">a la función.</target>
        </trans-unit>
        <trans-unit id="7bdf31978c0210720b3420242d2f1d74927c098c" translate="yes" xml:space="preserve">
          <source>tox</source>
          <target state="translated">tox</target>
        </trans-unit>
        <trans-unit id="0d57c3cb335cbcd6be4a00d2b3759c640eb0d722" translate="yes" xml:space="preserve">
          <source>use:</source>
          <target state="translated">uso:</target>
        </trans-unit>
        <trans-unit id="a7e2c648dc9941f38aea4196f90df226d6e93b2b" translate="yes" xml:space="preserve">
          <source>uses</source>
          <target state="translated">utiliza</target>
        </trans-unit>
        <trans-unit id="9666f8671ec96151fd7bf6c20ec1ae92d1258331" translate="yes" xml:space="preserve">
          <source>was built for and tested in.
It was originally written for Python 3.6 in Django 1.11 but when
extracted, made compatible with Python 2.7 and as far back as Django 1.8.</source>
          <target state="translated">fue construido y probado.Fue escrito originalmente para Python 3.6 en Django 1.11 pero cuando se extrajo,se hizo compatible con Python 2.7 y hasta Django 1.8.</target>
        </trans-unit>
        <trans-unit id="66696c9cfa39181b00e5ae7d2bc628b38e67ff88" translate="yes" xml:space="preserve">
          <source>which in certain cases of mutable objects
(e.g. class instances) as arguments the caching will not work. For example,
this does &lt;em&gt;not&lt;/em&gt; work in</source>
          <target state="translated">que en ciertos casos de objetos mutables (por ejemplo, instancias de clases) como argumentos, el almacenamiento en cach&amp;eacute; no funcionar&amp;aacute;. Por ejemplo, esto &lt;em&gt;no&lt;/em&gt; funciona en</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
