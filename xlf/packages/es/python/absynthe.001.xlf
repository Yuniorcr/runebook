<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="es" datatype="htmlbody" original="https://pypi.org/project/absynthe/">
    <body>
      <group id="absynthe">
        <trans-unit id="02b011c64160798e799481cc084857488382bb41" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Anomalous&lt;/em&gt; behaviors</source>
          <target state="translated">&lt;em&gt;&lt;/em&gt;Comportamientos &lt;em&gt;an&amp;oacute;malos&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="60027b310b5d95466e164e9b1bfc5f536be91cc0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; This tool is still in alpha stage, so backward compatibility is not
guaranteed between releases. However, inasmuch as users stick to graph builders'
&lt;code&gt;generateNewGraph()&lt;/code&gt; methods, they will stay away from compatibility problems.</source>
          <target state="translated">&lt;strong&gt;Nota:&lt;/strong&gt; Esta herramienta a&amp;uacute;n se encuentra en etapa alfa, por lo que no se garantiza la compatibilidad con versiones anteriores entre versiones. Sin embargo, en la medida en que los usuarios se apeguen a los m&amp;eacute;todos &lt;code&gt;generateNewGraph()&lt;/code&gt; constructores de gr&amp;aacute;ficos , se mantendr&amp;aacute;n alejados de los problemas de compatibilidad.</target>
        </trans-unit>
        <trans-unit id="7d13b0e105082d251433284ac94b52e7b08baf9b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; When generating a behavior, i.e. when traversing a graph, successors
of nodes are chosen based on the probability distributions associated with those
nodes. Different nodes rely on different distributions and these nodes are
randomly assigned in the graphs that are constructed by &lt;code&gt;generateNewGraph()&lt;/code&gt;
methods, resulting in graphs with a mix of nodes.</source>
          <target state="translated">&lt;strong&gt;Nota:&lt;/strong&gt; Al generar un comportamiento, es decir, al atravesar un gr&amp;aacute;fico, los sucesores de nodos se eligen en funci&amp;oacute;n de las distribuciones de probabilidad asociadas con esos nodos. Los diferentes nodos se basan en diferentes distribuciones y estos nodos se asignan aleatoriamente en los gr&amp;aacute;ficos que se construyen mediante los m&amp;eacute;todos &lt;code&gt;generateNewGraph()&lt;/code&gt; , lo que da como resultado gr&amp;aacute;ficos con una combinaci&amp;oacute;n de nodos.</target>
        </trans-unit>
        <trans-unit id="1ed58f177ea95bd7dab803c7ed4b233a181ba7bd" translate="yes" xml:space="preserve">
          <source>A (branching) Behaviour Synthesizer</source>
          <target state="translated">Un sintetizador de comportamiento (ramificado)</target>
        </trans-unit>
        <trans-unit id="550e6f318db294135e3d56d0fa6d7665e997ba1a" translate="yes" xml:space="preserve">
          <source>A more interesting situation arises while trying to test log analytic (and
anomaly detection) solutions for distributed applications where multiple
sources or modules emit their respective log messages in a single log queue or
stream. This means that consecutive log lines could have originated from
different, unrelated application components. Absynthe provides &lt;em&gt;ground truth&lt;/em&gt;
models to simulate such situations.</source>
          <target state="translated">Surge una situaci&amp;oacute;n m&amp;aacute;s interesante al intentar probar soluciones de an&amp;aacute;lisis de registros (y detecci&amp;oacute;n de anomal&amp;iacute;as) para aplicaciones distribuidas en las que varias fuentes o m&amp;oacute;dulos emiten sus respectivos mensajes de registro en una &amp;uacute;nica cola o flujo de registros. Esto significa que las l&amp;iacute;neas de registro consecutivas podr&amp;iacute;an haberse originado en diferentes componentes de la aplicaci&amp;oacute;n no relacionados. Absynthe proporciona modelos de &lt;em&gt;verdad fundamental&lt;/em&gt; para simular tales situaciones.</target>
        </trans-unit>
        <trans-unit id="dde040f47497790c05666d2ef94baefd390e27bf" translate="yes" xml:space="preserve">
          <source>Absynthe came about in response to the need for test data for analysizing the
performance and accuracy of log analysis algorithms. Even though plenty of real
life logs are available, e.g. &lt;code&gt;/var/log/&lt;/code&gt; in unix-based laptops, they do not
serve the purpose of test data. For that, we need to understand the core
application logic that is generating these logs.</source>
          <target state="translated">Absynthe surgi&amp;oacute; en respuesta a la necesidad de datos de prueba para analizar el rendimiento y la precisi&amp;oacute;n de los algoritmos de an&amp;aacute;lisis de registros. A pesar de que hay muchos registros de la vida real disponibles, por ejemplo, &lt;code&gt;/var/log/&lt;/code&gt; en computadoras port&amp;aacute;tiles basadas en Unix, no sirven como datos de prueba. Para eso, necesitamos comprender la l&amp;oacute;gica central de la aplicaci&amp;oacute;n que genera estos registros.</target>
        </trans-unit>
        <trans-unit id="68e14b2ad8538d489e4858484be43ce15b328a6b" translate="yes" xml:space="preserve">
          <source>Absynthe: A (branching) Behavior Synthesizer</source>
          <target state="translated">Absynthe:Un sintetizador de comportamiento (ramificado)</target>
        </trans-unit>
        <trans-unit id="280cb3fd0e3d99cf59bd50b4980fc6af1bbad0d5" translate="yes" xml:space="preserve">
          <source>Added a separate utility class called &lt;code&gt;Utils&lt;/code&gt; in &lt;code&gt;absynthe.cfg.utils.py&lt;/code&gt; to
create a new &lt;code&gt;Node&lt;/code&gt; object from any of the concrete implementations of &lt;code&gt;Node&lt;/code&gt; at
random. All concrete implementations of &lt;code&gt;Node&lt;/code&gt; therefore transparently available
to graph builders (and everyone else) through this utility.</source>
          <target state="translated">Se ha a&amp;ntilde;adido una clase de utilidad separada llamada &lt;code&gt;Utils&lt;/code&gt; en &lt;code&gt;absynthe.cfg.utils.py&lt;/code&gt; para crear un nuevo &lt;code&gt;Node&lt;/code&gt; objeto de cualquiera de las implementaciones concretas de &lt;code&gt;Node&lt;/code&gt; al azar. Por lo tanto, todas las implementaciones concretas de &lt;code&gt;Node&lt;/code&gt; est&amp;aacute;n disponibles de forma transparente para los creadores de gr&amp;aacute;ficos (y todos los dem&amp;aacute;s) a trav&amp;eacute;s de esta utilidad.</target>
        </trans-unit>
        <trans-unit id="eb58484c96da64282a061ef0f8a9d40510285043" translate="yes" xml:space="preserve">
          <source>Added new graph builders, viz. &lt;code&gt;DAGBuilder&lt;/code&gt; and  &lt;code&gt;DCGBuilder&lt;/code&gt;, which build
CFGs with skip-level edges and loops respectively.</source>
          <target state="translated">Se agregaron nuevos constructores de gr&amp;aacute;ficos, a saber. &lt;code&gt;DAGBuilder&lt;/code&gt; y &lt;code&gt;DCGBuilder&lt;/code&gt; , que crean CFG con bordes y bucles de nivel de salto, respectivamente.</target>
        </trans-unit>
        <trans-unit id="4cbbc2fc77fc6a8ffe051dea3ddc539034d4544b" translate="yes" xml:space="preserve">
          <source>Added new node, viz. &lt;code&gt;BinomialNode&lt;/code&gt;, which exploits the binomial distribution
in order to select its successors at the time of graph traversal.</source>
          <target state="translated">Se agreg&amp;oacute; un nuevo nodo, a saber. &lt;code&gt;BinomialNode&lt;/code&gt; , que explota la distribuci&amp;oacute;n binomial para seleccionar sus sucesores en el momento del recorrido del gr&amp;aacute;fico.</target>
        </trans-unit>
        <trans-unit id="8be003c27a6c97e5b0677757afd23716aaca94ef" translate="yes" xml:space="preserve">
          <source>An example of a more complex CFG, a directed cyclic graph, is shown in the
figure below. It expands the tree-like graph illustrated above by:</source>
          <target state="translated">Un ejemplo de un GFC más complejo,un gráfico cíclico dirigido,se muestra en la siguiente figura.Expande el gráfico en forma de árbol ilustrado arriba por:</target>
        </trans-unit>
        <trans-unit id="6452f7e7dc3c35274e1d081266ab3bcc9990cab8" translate="yes" xml:space="preserve">
          <source>An example of a simple, tree-like CFG generated using Absynthe is shown below.
This is like a tree since nodes are laid out in levels, and nodes at level &lt;code&gt;i&lt;/code&gt;
have outgoing edges only to nodes at level &lt;code&gt;i + 1&lt;/code&gt;.</source>
          <target state="translated">A continuaci&amp;oacute;n, se muestra un ejemplo de un CFG simple en forma de &amp;aacute;rbol generado con Absynthe. Esto es como un &amp;aacute;rbol, ya que los nodos se disponen en niveles y los nodos en el nivel &lt;code&gt;i&lt;/code&gt; tienen bordes salientes solo para los nodos en el nivel &lt;code&gt;i + 1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6e925f5a187584bb93a957696eb50e796b4b787e" translate="yes" xml:space="preserve">
          <source>Coming up in future releases</source>
          <target state="translated">Próximamente en futuros lanzamientos</target>
        </trans-unit>
        <trans-unit id="7e9b9183f4a396da21c94f732891218fafbdc7ae" translate="yes" xml:space="preserve">
          <source>Directed Cyclic CFG</source>
          <target state="translated">CFG Cíclico Dirigido</target>
        </trans-unit>
        <trans-unit id="7a253c500c342cfa2eda2d5a52e23d3e00a38f0f" translate="yes" xml:space="preserve">
          <source>Each &lt;em&gt;behavior&lt;/em&gt; is the sequence of nodes encountered while traversing this CFG
from a root to a leaf. Of course, a CFG might contain loops which could be
traversed multiple times before arriving at the leaf. Moreover, if there are
multiple CFGs, then Absynthe can synthesize &lt;em&gt;interleaved&lt;/em&gt; behaviors. This means
that a single sequence of nodes might contain nodes from multiple CFGs. We are
ultimately interested in this interleaving behavior, which is produced by
multiple CFGs.</source>
          <target state="translated">Cada &lt;em&gt;comportamiento&lt;/em&gt; es la secuencia de nodos encontrados al atravesar este CFG desde una ra&amp;iacute;z a una hoja. Por supuesto, un CFG puede contener bucles que podr&amp;iacute;an atravesarse varias veces antes de llegar a la hoja. Adem&amp;aacute;s, si hay varios CFG, Absynthe puede sintetizar comportamientos &lt;em&gt;intercalados&lt;/em&gt; . Esto significa que una sola secuencia de nodos puede contener nodos de varios CFG. En &amp;uacute;ltima instancia, estamos interesados ​​en este comportamiento de intercalaci&amp;oacute;n, que es producido por m&amp;uacute;ltiples CFG.</target>
        </trans-unit>
        <trans-unit id="ffc30fab83bb0c85eb6e12280e0a3b95999fd852" translate="yes" xml:space="preserve">
          <source>Each business process or compuater application is modelled as a &lt;em&gt;control flow
graph&lt;/em&gt; (or &lt;em&gt;CFG&lt;/em&gt;), which typically has one or more roots (i.e. entry) nodes and
multiple leaf (i.e. end) nodes.</source>
          <target state="translated">Cada proceso de negocio o aplicaci&amp;oacute;n de computadora se modela como un &lt;em&gt;diagrama de flujo de control&lt;/em&gt; (o &lt;em&gt;CFG&lt;/em&gt; ), que normalmente tiene uno o m&amp;aacute;s nodos de ra&amp;iacute;z (es decir, entrada) y m&amp;uacute;ltiples nodos de hoja (es decir, finales).</target>
        </trans-unit>
        <trans-unit id="ebf05de134c94509696d1b9731d1059221894528" translate="yes" xml:space="preserve">
          <source>For instance, consider the &lt;code&gt;basicLogGeneration&lt;/code&gt; method in
&lt;code&gt;./examples/01_generateSimpleBehavior.py&lt;/code&gt;:</source>
          <target state="translated">Por ejemplo, considere la &lt;code&gt;basicLogGeneration&lt;/code&gt; m&amp;eacute;todo en el &lt;code&gt;./examples/01_generateSimpleBehavior.py&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="ece8a1e099471b12bc1db0091b0ab79cf8c8e183" translate="yes" xml:space="preserve">
          <source>For the latest features not yet released, clone or download the &lt;code&gt;develop&lt;/code&gt; branch
and then:</source>
          <target state="translated">Para las funciones m&amp;aacute;s recientes que a&amp;uacute;n no se han lanzado, clone o descargue la rama de &lt;code&gt;develop&lt;/code&gt; y luego:</target>
        </trans-unit>
        <trans-unit id="361323255a6e418a94fe1dd6ad98403ad687499f" translate="yes" xml:space="preserve">
          <source>In order to generate behaviors from a directed cyclic CFG, create a DCG as shown
in &lt;code&gt;./examples/03_generateControlFlowDCG.py&lt;/code&gt; and then generate behaviors after
adding the DCG to a behavior object as shown in the code snippet above.</source>
          <target state="translated">Para generar comportamientos a partir de un CFG c&amp;iacute;clico dirigido, cree un DCG como se muestra en &lt;code&gt;./examples/03_generateControlFlowDCG.py&lt;/code&gt; y luego genere comportamientos despu&amp;eacute;s de agregar el DCG a un objeto de comportamiento como se muestra en el fragmento de c&amp;oacute;digo anterior.</target>
        </trans-unit>
        <trans-unit id="c81b79df3c6448eae7c4f80428b54cd5692a17d7" translate="yes" xml:space="preserve">
          <source>Installation</source>
          <target state="translated">Instalación</target>
        </trans-unit>
        <trans-unit id="41d0bded83d8a4df22a78f1f0693f59a79719b3e" translate="yes" xml:space="preserve">
          <source>It is possible to start using Absynthe with two classes:</source>
          <target state="translated">Es posible empezar a usar Absynthe con dos clases:</target>
        </trans-unit>
        <trans-unit id="019ec01ba6d724fe41e420938f721b48570940fe" translate="yes" xml:space="preserve">
          <source>Logger nodes that emit more &lt;em&gt;life like&lt;/em&gt; log messages</source>
          <target state="translated">Nodos de registrador que emiten m&amp;aacute;s &lt;em&gt;vida como&lt;/em&gt; mensajes de registro</target>
        </trans-unit>
        <trans-unit id="80552c39193e5d627bacdc60f82ee17b182d6315" translate="yes" xml:space="preserve">
          <source>Major changes in v0.0.2</source>
          <target state="translated">Cambios importantes en v0.0.2</target>
        </trans-unit>
        <trans-unit id="d6a06199cc127e571d3588aef63c79108675eabc" translate="yes" xml:space="preserve">
          <source>Motivation</source>
          <target state="translated">Motivación</target>
        </trans-unit>
        <trans-unit id="0efc2e6be4c23b9a513d7ce0dcff8ed80e8912e7" translate="yes" xml:space="preserve">
          <source>Overview</source>
          <target state="translated">Visión general</target>
        </trans-unit>
        <trans-unit id="0ea4af908fe06688dd3fc02035189b08293c5074" translate="yes" xml:space="preserve">
          <source>Release Notes</source>
          <target state="translated">Notas de lanzamiento</target>
        </trans-unit>
        <trans-unit id="7137676daae9098656140de61386c7374db05941" translate="yes" xml:space="preserve">
          <source>Sophisticated interleaving behaviors</source>
          <target state="translated">Sofisticados comportamientos de intercalación</target>
        </trans-unit>
        <trans-unit id="f2903a3add32a92d3c75624c962356b7a49a5fa8" translate="yes" xml:space="preserve">
          <source>The above screenshot shows logs generated by Absynthe. Each log line starts
with a time stamp, followed by a session ID, CFG ID, and a log message. At
present, the log message is simply a random concatenation of the node ID to
which the log message corresponds. A single CFG might participate in multiple
sessions, where each session is a different traversal of the CFG. Therefore, we
maintain both session ID and CFG ID in the log line.</source>
          <target state="translated">La captura de pantalla anterior muestra los registros generados por Absynthe.Cada línea del registro comienza con una marca de tiempo,seguida de un ID de sesión,un ID de CFG y un mensaje de registro.En la actualidad,el mensaje de registro es simplemente una concatenación aleatoria del ID del nodo al que corresponde el mensaje de registro.Un solo GFC puede participar en múltiples sesiones,donde cada sesión es un recorrido diferente del GFC.Por lo tanto,mantenemos tanto el ID de la sesión como el ID del CFG en la línea de registro.</target>
        </trans-unit>
        <trans-unit id="f96cc45f6b319ee18988211c883578e9a4a281c7" translate="yes" xml:space="preserve">
          <source>The identifiers of nodes appearing loops are helpfully prefixed with the
identifiers of nodes where these loops start and finish. Moreover, loops could
be traversed multiple times in a single behavior, as illustrated in the figure
below.</source>
          <target state="translated">Los identificadores de los nodos que aparecen en los bucles se prefijan útilmente con los identificadores de los nodos donde estos bucles comienzan y terminan.Además,los bucles pueden ser atravesados varias veces en un solo comportamiento,como se ilustra en la siguiente figura.</target>
        </trans-unit>
        <trans-unit id="9a674369e325bdf29f6edf8edb945b651c6ac731" translate="yes" xml:space="preserve">
          <source>The latest release is available on PyPi, simply &lt;code&gt;pip install absynthe&lt;/code&gt;. The
&lt;code&gt;master&lt;/code&gt; branch of this repository will always provide the latest release.</source>
          <target state="translated">La &amp;uacute;ltima versi&amp;oacute;n est&amp;aacute; disponible en PyPi, simplemente &lt;code&gt;pip install absynthe&lt;/code&gt; . La rama &lt;code&gt;master&lt;/code&gt; de este repositorio siempre proporcionar&amp;aacute; la &amp;uacute;ltima versi&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="3cbe8139be6dadccd55954ec95da87dbf1e698b5" translate="yes" xml:space="preserve">
          <source>This package has been developed with &lt;code&gt;Python 3.6.*&lt;/code&gt; and depends on &lt;code&gt;scipy 1.2.1&lt;/code&gt;.
Things might not work with &lt;code&gt;Python 3.7.*&lt;/code&gt; or &lt;code&gt;scipy 1.3.*&lt;/code&gt;. Therefore, consider
creating a virtual environment if your default configuration differs.</source>
          <target state="translated">Este paquete ha sido desarrollado con &lt;code&gt;Python 3.6.*&lt;/code&gt; Y depende de &lt;code&gt;scipy 1.2.1&lt;/code&gt; . Es posible que las cosas no funcionen con &lt;code&gt;Python 3.7.*&lt;/code&gt; O &lt;code&gt;scipy 1.3.*&lt;/code&gt; . Por lo tanto, considere la posibilidad de crear un entorno virtual si su configuraci&amp;oacute;n predeterminada es diferente.</target>
        </trans-unit>
        <trans-unit id="0980855b93454e712e2b015cc0f5655541facb06" translate="yes" xml:space="preserve">
          <source>Tree-like CFG</source>
          <target state="translated">CFG en forma de árbol</target>
        </trans-unit>
        <trans-unit id="0bb18642b70b9f8a9c12ccf39487328f306b8e19" translate="yes" xml:space="preserve">
          <source>Usage</source>
          <target state="translated">Uso</target>
        </trans-unit>
        <trans-unit id="2d75d8dd04fd465844923c80ddf7cebda12ec86a" translate="yes" xml:space="preserve">
          <source>You need Absynthe if you wish to simulate the behavior of any well defined
process -- whether it's a computer application or a business process flow.</source>
          <target state="translated">Necesitas Absynthe si deseas simular el comportamiento de cualquier proceso bien definido...ya sea una aplicación informática o un flujo de procesos de negocios.</target>
        </trans-unit>
        <trans-unit id="cfdf820be882593b466c12770bb42a1d31992322" translate="yes" xml:space="preserve">
          <source>any concrete implementation of the abstract &lt;code&gt;Behavior&lt;/code&gt; class, which
traverses the CFGs generated above and emits log messages.</source>
          <target state="translated">cualquier implementaci&amp;oacute;n concreta de la clase &lt;code&gt;Behavior&lt;/code&gt; abstracta , que atraviesa los CFG generados anteriormente y emite mensajes de registro.</target>
        </trans-unit>
        <trans-unit id="f56a005cb54785defd2347c651da587bf8d12c8c" translate="yes" xml:space="preserve">
          <source>any concrete implementation of the abstract &lt;code&gt;GraphBuilder&lt;/code&gt; class, which
generates CFGs, and</source>
          <target state="translated">cualquier implementaci&amp;oacute;n concreta de la clase &lt;code&gt;GraphBuilder&lt;/code&gt; abstracta , que genera CFG, y</target>
        </trans-unit>
        <trans-unit id="1746725b3599b57f2c3c7c184a1e129a4b71bc36" translate="yes" xml:space="preserve">
          <source>attaching loops on some of the nodes,</source>
          <target state="translated">...uniendo los bucles en algunos de los nodos,</target>
        </trans-unit>
        <trans-unit id="8de1898ddf3eff19dd8e421cfc5bd3eabb848a8c" translate="yes" xml:space="preserve">
          <source>constructing skip-level edges, i.e. edges from a node at level &lt;code&gt;i&lt;/code&gt; to a
node at level &amp;ge;&lt;code&gt;(i + 2)&lt;/code&gt;, and</source>
          <target state="translated">construir bordes de nivel de salto, es decir, bordes desde un nodo en el nivel &lt;code&gt;i&lt;/code&gt; hasta un nodo en el nivel &amp;ge; &lt;code&gt;(i + 2)&lt;/code&gt; , y</target>
        </trans-unit>
        <trans-unit id="e1d5d9897e5bb0bd39df7fb5b19b181ff8ea808c" translate="yes" xml:space="preserve">
          <source>optionally, upward edges (not shown here), i.e. edges from a node at
level &lt;code&gt;i&lt;/code&gt; to a node at level &amp;le;&lt;code&gt;(i - 1)&lt;/code&gt;.</source>
          <target state="translated">opcionalmente, bordes hacia arriba (no mostrados aqu&amp;iacute;), es decir, bordes desde un nodo en el nivel &lt;code&gt;i&lt;/code&gt; hasta un nodo en el nivel &amp;le; &lt;code&gt;(i - 1)&lt;/code&gt; .</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
