<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="es" datatype="htmlbody" original="https://pypi.org/project/justbytes/">
    <body>
      <group id="justbytes">
        <trans-unit id="447b8348b9c2348111a636255e107995a2ed4367" translate="yes" xml:space="preserve">
          <source>All errors raised by justbytes operations are subtypes of the RangeError class.</source>
          <target state="translated">Todos los errores planteados por las operaciones de justbytes son subtipos de la clase RangeError.</target>
        </trans-unit>
        <trans-unit id="3c736d39cfcbcaf284f80530e8748d5df12b2eb3" translate="yes" xml:space="preserve">
          <source>Alternative Packages</source>
          <target state="translated">Paquetes alternativos</target>
        </trans-unit>
        <trans-unit id="1f878420017dbe53c0a2676a433496213e5811a0" translate="yes" xml:space="preserve">
          <source>Computing the Representation of a Range</source>
          <target state="translated">Computar la representación de un rango</target>
        </trans-unit>
        <trans-unit id="7b6af984283fa6b9adedb133907862c2f2663660" translate="yes" xml:space="preserve">
          <source>Consequently, computations such as addition of two Ranges, and conversion
between different magnitudes of bytes, i.e., from MiB to GiB, must be done
precisely. The underlying implementation must therefore use a precise
representation of the number of bytes. Floating point numbers, which are
frequently the preferred type for the representation of physical
quantities, are disallowed by this requirement.</source>
          <target state="translated">En consecuencia,los cálculos como la adición de dos Rangos,y la conversión entre diferentes magnitudes de bytes,es decir,de MiB a GiB,deben hacerse con precisión.Por lo tanto,la aplicación subyacente debe utilizar una representación precisa del número de bytes.Los números en coma flotante,que suelen ser el tipo preferido para la representación de las cantidades físicas,no están permitidos por este requisito.</target>
        </trans-unit>
        <trans-unit id="3f4700f344a55dd2a413f15f371fad0a05b8a575" translate="yes" xml:space="preserve">
          <source>Constructing Ranges Programatically</source>
          <target state="translated">Construyendo rangos programados</target>
        </trans-unit>
        <trans-unit id="9c6c971ced78a1f9bbe931fd59030db5c8588db9" translate="yes" xml:space="preserve">
          <source>Displaying Ranges</source>
          <target state="translated">Mostrando los rangos</target>
        </trans-unit>
        <trans-unit id="805e86a8cbf628e38e4c45612c005a504009e79a" translate="yes" xml:space="preserve">
          <source>Errors</source>
          <target state="translated">Errores</target>
        </trans-unit>
        <trans-unit id="cbfba25d0250d74cb72b3ec89534cd1cbcf21211" translate="yes" xml:space="preserve">
          <source>Floating Point Numbers</source>
          <target state="translated">Números de punto flotante</target>
        </trans-unit>
        <trans-unit id="d6d84fa09f507b8c85bc8b38c187fe899a44a5c1" translate="yes" xml:space="preserve">
          <source>If you are interested in computing in Python with physical, rather than
logical, quantities, you should consult the pint package:
&lt;a href=&quot;http://pint.readthedocs.org&quot;&gt;http://pint.readthedocs.org&lt;/a&gt;.</source>
          <target state="translated">Si est&amp;aacute; interesado en computar en Python con cantidades f&amp;iacute;sicas, en lugar de l&amp;oacute;gicas, debe consultar el paquete pint: &lt;a href=&quot;http://pint.readthedocs.org&quot;&gt;http://pint.readthedocs.org&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8d205500c8f287783d5e6ffd528d2f8fbd78d600" translate="yes" xml:space="preserve">
          <source>It is not possible to use floating point numbers or Decimal in computations
with Ranges. Where a fractional quantity is desired, use Fraction objects.
Thus, Range(0) * 1.2 and Range(0) * Decimal(&amp;ldquo;1.2&amp;rdquo;) raise an exception, but
Range(0) * Fraction(&amp;ldquo;1.2&amp;rdquo;) is acceptable.</source>
          <target state="translated">No es posible utilizar n&amp;uacute;meros de coma flotante o decimales en c&amp;aacute;lculos con rangos. Cuando se desee una cantidad fraccionaria, utilice objetos Fraction. Por lo tanto, Range (0) * 1.2 y Range (0) * Decimal (&quot;1.2&quot;) generan una excepci&amp;oacute;n, pero Range (0) * Fraction (&quot;1.2&quot;) es aceptable.</target>
        </trans-unit>
        <trans-unit id="d2fac8f190d6ba2310cd04193e6922d40dd4506a" translate="yes" xml:space="preserve">
          <source>Its sole purpose is the representation of real address ranges on real
machines. For that reason, it does not allow powers of ranges, imprecise
ranges, or non-finite ranges. In order that the
usual laws of arithmetic can be maintained, it does allow fractional ranges.</source>
          <target state="translated">Su único propósito es la representación de rangos de direcciones reales en máquinas reales.Por esa razón,no permite potencias de rangos,rangos imprecisos o rangos no finitos.Para poder mantener las leyes aritméticas habituales,permite rangos fraccionarios.</target>
        </trans-unit>
        <trans-unit id="45882d11d2960503d0c63d16f01836831a20d4a5" translate="yes" xml:space="preserve">
          <source>Justbytes</source>
          <target state="translated">Justbytes</target>
        </trans-unit>
        <trans-unit id="fadaa413fdb8e444db665691407ee547102d51d5" translate="yes" xml:space="preserve">
          <source>Justbytes is a module for handling computation with
address ranges expressed in bytes. Its principle feature is a Range class from
which can be constructed Range objects which represent a precise and finite
address range in bytes. Various arithmetic operations are defined for Range
objects.</source>
          <target state="translated">Justbytes es un módulo para manejar la computación con rangos de direcciones expresados en bytes.Su principal característica es una clase de rango a partir de la cual se pueden construir objetos de rango que representan un rango de direcciones preciso y finito en bytes.Se definen varias operaciones aritméticas para los objetos Range.</target>
        </trans-unit>
        <trans-unit id="e3ac283515eac7e729ac10b009dc00d848c8e9ac" translate="yes" xml:space="preserve">
          <source>Memory Consumption and Bandwidth vs. Address Ranges</source>
          <target state="translated">Consumo de Memoria y Ancho de Banda vs.Rangos de Dirección</target>
        </trans-unit>
        <trans-unit id="65725c5cbb6b40fb6d8721e0f58b7f2d9f219336" translate="yes" xml:space="preserve">
          <source>Memory consumption, e.g., by a process during execution on a specified
workload, is a quantity, that like address ranges, is specified in
bytes. However, memory consumption is simply a measurement of the amount of
a phsyical quantity consumed.  When bytes are used only to represent memory
consumption, computations do not generally require the special handling
supplied by this library. Generally, measurement of memory consumption can
be treated like any other physical quantity. The same reasoning applies to
bandwidth. For a physical analogy, one can imagine memory consumption to be
analogous to volume, e.g., litres, and bandwidth to be analogous to flow,
e.g., litres per minute.</source>
          <target state="translated">El consumo de memoria,por ejemplo,por un proceso durante la ejecución en una carga de trabajo especificada,es una cantidad,que al igual que los rangos de direcciones,se especifica en bytes.Sin embargo,el consumo de memoria es simplemente una medida de la cantidad de una cantidad física consumida.Cuando los bytes se utilizan únicamente para representar el consumo de memoria,los cálculos no suelen requerir la manipulación especial que proporciona esta biblioteca.En general,la medición del consumo de memoria puede tratarse como cualquier otra cantidad física.El mismo razonamiento se aplica al ancho de banda.Para una analogía física,se puede imaginar que el consumo de memoria es análogo al volumen,por ejemplo,los litros,y el ancho de banda es análogo al flujo,por ejemplo,los litros por minuto.</target>
        </trans-unit>
        <trans-unit id="8a99d14f970e76756815cc726112e9e4f2356fee" translate="yes" xml:space="preserve">
          <source>New Range objects can be constructed from Range objects, numeric values, e.g.,
int or Fraction, or strings which represent such numeric values.
strings may be used to represent fractional quantities, e.g., &amp;ldquo;1.2&amp;rdquo;, but
floats and Decimals are disallowed.</source>
          <target state="translated">Los nuevos objetos Range se pueden construir a partir de objetos Range, valores num&amp;eacute;ricos, por ejemplo, int o Fraction, o cadenas que representan dichos valores num&amp;eacute;ricos. Las cadenas se pueden usar para representar cantidades fraccionarias, por ejemplo, &quot;1.2&quot;, pero no se permiten los n&amp;uacute;meros flotantes y decimales.</target>
        </trans-unit>
        <trans-unit id="8e8e76e830d5d5d96809802aa0ea50ad46a0e846" translate="yes" xml:space="preserve">
          <source>Numerous computations with address ranges are nonsensical. For example, 2
raised to a power which is some address range, is a meaningless computation.
All such operations cause an error to be raised.</source>
          <target state="translated">Numerosos cálculos con rangos de direcciones no tienen sentido.Por ejemplo,2 elevado a una potencia que es un cierto rango de direcciones,es un cálculo sin sentido.Todas estas operaciones provocan un error que se eleva.</target>
        </trans-unit>
        <trans-unit id="a1fdaa6b2a846c8fcf18d414bf8c61db610eda6a" translate="yes" xml:space="preserve">
          <source>Operations</source>
          <target state="translated">Operaciones</target>
        </trans-unit>
        <trans-unit id="43aaf6f57b7c95249bd643787aad1b1255593812" translate="yes" xml:space="preserve">
          <source>Practical Computing with Address Ranges</source>
          <target state="translated">Computación práctica con rangos de direcciones</target>
        </trans-unit>
        <trans-unit id="a85446ae4efaa1d6aaa78d5db82169a15cd8c137" translate="yes" xml:space="preserve">
          <source>Representing Units</source>
          <target state="translated">Representando a las unidades</target>
        </trans-unit>
        <trans-unit id="32508a9e120d4892b64a069406f889c0158d8e4a" translate="yes" xml:space="preserve">
          <source>Some computations with precise, finite, values may yield irrational results.
For example, while 2 is rational, its square root is an irrational number.
There is no allowed operation on Range objects which can result in an
irrational Range value. It turns out that all such operations are either
nonsensical or would result in a value with an unrepresentable type.</source>
          <target state="translated">Algunos cálculos con valores precisos y finitos pueden dar resultados irracionales.Por ejemplo,mientras que el 2 es racional,su raíz cuadrada es un número irracional.No se permite ninguna operación en los objetos de Range que pueda dar lugar a un valor de Range irracional.Resulta que todas esas operaciones no tienen sentido o darían como resultado un valor de tipo no representativo.</target>
        </trans-unit>
        <trans-unit id="a8b73a8356a1277aa6a8d1b69dbdb2cb2c5bcc98" translate="yes" xml:space="preserve">
          <source>The Range class also has standard methods for the representation of Range
objects as str objects.</source>
          <target state="translated">La clase Range también tiene métodos estándar para la representación de los objetos Range como objetos str.</target>
        </trans-unit>
        <trans-unit id="94d414b4b47ed43fadec12a10ba6e7313b163f7c" translate="yes" xml:space="preserve">
          <source>The constructor takes an optional units specifier, which defaults to bytes
for all numeric values, and to None for Range objects. The type of the
unit specifier is a named prefix supplied by the size module or a Range object.</source>
          <target state="translated">El constructor toma un especificador de unidades opcional,que por defecto es de bytes para todos los valores numéricos,y de Ninguno para los objetos del rango.El tipo de especificador de unidades es un prefijo de nombre suministrado por el módulo de tamaño o un objeto de rango.</target>
        </trans-unit>
        <trans-unit id="097c7c0496973f59f9c251a898f12945055be5c7" translate="yes" xml:space="preserve">
          <source>The representation of a Range is computed according to a specified
configuration. In the default configuration, the representation uses IEC
rather than SI units.</source>
          <target state="translated">La representación de un rango se calcula según una configuración específica.En la configuración por defecto,la representación utiliza unidades IEC en lugar de unidades SI.</target>
        </trans-unit>
        <trans-unit id="10256571c4110a674ceb91b10fbb1a84d4045c07" translate="yes" xml:space="preserve">
          <source>The representation of a Range is not a string, but a structured representation
of the precise value, as well as the relationship of the representation to
the actual value.</source>
          <target state="translated">La representación de una Gama no es una cadena,sino una representación estructurada del valor preciso,así como la relación de la representación con el valor real.</target>
        </trans-unit>
        <trans-unit id="39a94149ce22e4db399e8e0e373611c2d8539226" translate="yes" xml:space="preserve">
          <source>The result type of operations is a Range, where appropriate, or a subtype of
Rational, where a numeric value is appropriate.</source>
          <target state="translated">El tipo de operaciones resultante es un Rango,cuando sea apropiado,o un subtipo de Racional,donde un valor numérico es apropiado.</target>
        </trans-unit>
        <trans-unit id="9ed4545ef7ef3799a6493364429d8f4f3088d609" translate="yes" xml:space="preserve">
          <source>The size module supplies a set of named prefixes for both SI and binary units,
for all non-fractional prefixes. Fractional prefixes are not defined.</source>
          <target state="translated">El módulo de tamaño suministra un conjunto de prefijos nombrados tanto para el SI como para las unidades binarias,para todos los prefijos no fraccionados.Los prefijos fraccionarios no están definidos.</target>
        </trans-unit>
        <trans-unit id="6c9670cfffbaa49a042fc163ff0b2776907074d3" translate="yes" xml:space="preserve">
          <source>The str representation can also be configured. The manipulation of the
representation to form a str object is abstracted from the rest of the source
to emphasize that clients of the package may choose to represent address ranges
in any manner they choose.</source>
          <target state="translated">También se puede configurar la representación str.La manipulación de la representación para formar un objeto str se abstrae del resto de la fuente para enfatizar que los clientes del paquete pueden elegir representar los rangos de direcciones de la manera que deseen.</target>
        </trans-unit>
        <trans-unit id="c9d82d1c8a3f153080dfa8f031173eb4da4b8f13" translate="yes" xml:space="preserve">
          <source>This module does not accomodate multi-dimensionality of address ranges.
Consequently, multiplying one Range object by another Range object will cause
an error to be raised, since bytes^2 is not representable by the module.
For most uses any operation which would yield a multi-dimensional quantity
is not useful. There are no plans to adapt this package so that it
can accomodate multi-dimensionality of address ranges.</source>
          <target state="translated">Este módulo no tiene en cuenta la multidimensionalidad de los rangos de direcciones.En consecuencia,multiplicar un objeto Range por otro objeto Range provocará un error,ya que los bytes^2 no son representables por el módulo.Para la mayoría de los usos,cualquier operación que produzca una cantidad multidimensional no es útil.No hay planes para adaptar este paquete de manera que pueda acomodar la multidimensionalidad de los rangos de dirección.</target>
        </trans-unit>
        <trans-unit id="d5695091f3f7dbec419aa9a43a489657cd3cec78" translate="yes" xml:space="preserve">
          <source>This package does not handle arbitrary user input. It is expected that the
client will transform any input, from whatever source, into a number and an
optional unit specification which can be passed directly to the Range
constructor.</source>
          <target state="translated">Este paquete no maneja entradas arbitrarias del usuario.Se espera que el cliente transforme cualquier entrada,de cualquier fuente,en un número y una especificación de unidad opcional que puede ser pasada directamente al constructor de la gama.</target>
        </trans-unit>
        <trans-unit id="0ad10cd434a732c22b242d2eb564844e1c3e7716" translate="yes" xml:space="preserve">
          <source>This representation is exposed to clients of the library, which may use it
in any way.</source>
          <target state="translated">Esta representación está expuesta a los clientes de la biblioteca,que pueden utilizarla de cualquier manera.</target>
        </trans-unit>
        <trans-unit id="0b75d4ee12567b39421e5cdafacb9fdac3567042" translate="yes" xml:space="preserve">
          <source>User Input</source>
          <target state="translated">las entradas de los usuarios</target>
        </trans-unit>
        <trans-unit id="4cfb3a9ba784840220f2270e361d47e1ff0d6f04" translate="yes" xml:space="preserve">
          <source>When computing with address ranges, the numeric value can be viewed as a
logical, rather than a physical, quantity. That is, unlike, e.g., mass or
length, which are quantities which must be measured with a measuring instrument
which has some built-in imprecision, an address range
is a quantity that is not measured, but is known precisely.
This precision arises because the number represents not as much an amount of
memory as a number of addressable, byte-size, locations in memory.</source>
          <target state="translated">Al computar con rangos de direcciones,el valor numérico puede ser visto como una cantidad lógica,más que física.Es decir,a diferencia de,por ejemplo,la masa o la longitud,que son cantidades que deben medirse con un instrumento de medición que tiene cierta imprecisión incorporada,un rango de direcciones es una cantidad que no se mide,pero que se conoce con precisión.Esta precisión se debe a que el número representa no tanto una cantidad de memoria como un número de lugares direccionables,de tamaño de byte,en la memoria.</target>
        </trans-unit>
        <trans-unit id="d2fff8678cd4207ea323bf9803cc0d1f80906f54" translate="yes" xml:space="preserve">
          <source>computing with and displaying bytes</source>
          <target state="translated">computar con y mostrar los bytes</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
