<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="https://pypi.org/project/lru2cache/">
    <body>
      <group id="lru2cache">
        <trans-unit id="6d6173d566ffb20c8641ba2752b927248f8ab6c3" translate="yes" xml:space="preserve">
          <source>, function arguments of different types will be
cached separately. For example, f(3) and f(3.0) will be treated as distinct
calls with distinct results.</source>
          <target state="translated">、異なるタイプの関数引数は個別にキャッシュされます。たとえば、f（3）とf（3.0）は別個の呼び出しとして扱われ、別個の結果が得られます。</target>
        </trans-unit>
        <trans-unit id="7207846477fc222c6dd0427e85462ac564927fea" translate="yes" xml:space="preserve">
          <source>, the LRU feature is disabled and the L1 cache
can grow without bound. The LRU feature performs best when maxsize is a power-of-two.</source>
          <target state="translated">、LRU機能が無効になり、L1キャッシュが無制限に増大する可能性があります。LRU機能は、maxsizeが2の累乗の場合に最高のパフォーマンスを発揮します。</target>
        </trans-unit>
        <trans-unit id="d99d3502cdad96aa76d33d37c0cc8a9682cf6459" translate="yes" xml:space="preserve">
          <source>. These stats are stored within an instance, and therefore
are specific to that instance. Cumulative statistics for the shared cache would
need to be obtained from the shared cache.</source>
          <target state="translated">。これらの統計はインスタンス内に保存されるため、そのインスタンスに固有です。共有キャッシュの累積統計は、共有キャッシュから取得する必要があります。</target>
        </trans-unit>
        <trans-unit id="2be5d9e9d6ec5fbbfff0627d5ceb897a4d377376" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Local and Shared Cache&lt;/strong&gt; - Combining both types of cache is much more
effective than either used on it&amp;rsquo;s own.  The local cache eliminates the
latency of calls to a shared cache, while the shared cache eliminates
the expense of returning the result</source>
          <target state="translated">&lt;strong&gt;ローカルキャッシュと共有キャッシュ&lt;/strong&gt;-両方のタイプのキャッシュを組み合わせると、どちらかを単独で使用するよりもはるかに効果的です。ローカルキャッシュは共有キャッシュへの呼び出しの待ち時間を排除し、共有キャッシュは結果を返す費用を排除します</target>
        </trans-unit>
        <trans-unit id="3a61811019e173a17190bff6fd9ad90f453f5c97" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The Ability to Not Cache None Results&lt;/strong&gt; - This may seem like a minor thing
but in our environment it has greatly reduced the frequency of cache
invalidations.</source>
          <target state="translated">&lt;strong&gt;結果をキャッシュしない機能&lt;/strong&gt;-これは些細なことのように思えるかもしれ&lt;strong&gt;ません&lt;/strong&gt;が、私たちの環境では、キャッシュの無効化の頻度が大幅に減少しています。</target>
        </trans-unit>
        <trans-unit id="4d15addbdae92bf79453914d11dea5bbd5322f8d" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;http://en.wikipedia.org/wiki/Cache_algorithms#Least_Recently_Used&quot;&gt;least recently used (LRU)&lt;/a&gt;
2 layer caching mechanism based in part on the Python 2.7 back-port of</source>
          <target state="translated">の Python2.7バックポートに部分的に基づく&lt;a href=&quot;http://en.wikipedia.org/wiki/Cache_algorithms#Least_Recently_Used&quot;&gt;最も最近使用されていない（LRU）&lt;/a&gt; 2層キャッシュメカニズム</target>
        </trans-unit>
        <trans-unit id="3efcd57fb6b3d75f3484be9e543fff6a457c01c9" translate="yes" xml:space="preserve">
          <source>A least recently used (LRU) 2 layer caching mechanism based in part on the Python 2.7 back-port of lru_cache</source>
          <target state="translated">最近使われている (LRU)2 層キャッシュ機構で、一部は lru_cache の Python 2.7 バックポートに基づいています。</target>
        </trans-unit>
        <trans-unit id="32e4be867670ced87f1b50b35d669b04ce0f3a8b" translate="yes" xml:space="preserve">
          <source>A shared cache can easily be cleared with the following:</source>
          <target state="translated">共有キャッシュは以下の方法で簡単にクリアできます。</target>
        </trans-unit>
        <trans-unit id="b6ad70fe8987a492b217f1d3fdc6bc56a8799161" translate="yes" xml:space="preserve">
          <source>Accessing the Function without Cache</source>
          <target state="translated">キャッシュなしで関数にアクセスする</target>
        </trans-unit>
        <trans-unit id="37e1c7c46791ba8b13b32bdb24bd8673a2f3fe3e" translate="yes" xml:space="preserve">
          <source>As a starting point I incorporated most of the tests for</source>
          <target state="translated">出発点として、私は以下のテストのほとんどを取り入れました。</target>
        </trans-unit>
        <trans-unit id="3938496e65e6dd032b899a42196062cb85acaa7a" translate="yes" xml:space="preserve">
          <source>As with lru_cache, one can view the cache statistics via a named tuple
(l1_hits, l1_misses, l2_hits, l2_misses, l1_maxsize, l1_currsize), with</source>
          <target state="translated">lru_cache と同様に、名前付きタプル (l1_hits,l1_misses,l2_hits,l2_misses,l1_maxsize,l1_currsize)を使用してキャッシュの統計情報を見ることができます。</target>
        </trans-unit>
        <trans-unit id="6bbdf159e71b2fcdfa75bfaf3c0ec17a80b21b52" translate="yes" xml:space="preserve">
          <source>At &lt;a href=&quot;http://www.3top.com/&quot;&gt;3Top&lt;/a&gt; We needed a way to improve performance of
slow queries, not just those using the Django ORM, but also for queries to
other data stores and services.  We started off with a simpler centralized
caching solution using Memcached, but even those queries, when called frequently,
can start to cause delays.  Therefore we sought a means of caching at two layers.</source>
          <target state="translated">&lt;a href=&quot;http://www.3top.com/&quot;&gt;3Top&lt;/a&gt;ではDjangoORMを使用するクエリだけでなく、他のデータストアやサービスへのクエリのパフォーマンスを向上させる方法が必要でした。Memcachedを使用した、より単純な集中型キャッシュソリューションから始めましたが、これらのクエリでさえ、頻繁に呼び出されると、遅延が発生し始める可能性があります。したがって、2つのレイヤーでキャッシュする手段を探しました。</target>
        </trans-unit>
        <trans-unit id="aeaf0e85f848b550a565ca5901e53d4306577d16" translate="yes" xml:space="preserve">
          <source>Background and Development</source>
          <target state="translated">背景と開発</target>
        </trans-unit>
        <trans-unit id="a086c0543fd27c08b64c003ddb4513c6845eb29a" translate="yes" xml:space="preserve">
          <source>Benefits Over functools.lru_cache</source>
          <target state="translated">functools.lru_cache よりも優れている点</target>
        </trans-unit>
        <trans-unit id="d2469c2aa14798195f6bc3ae16fcf004712ca85e" translate="yes" xml:space="preserve">
          <source>Cache Management</source>
          <target state="translated">キャッシュ管理</target>
        </trans-unit>
        <trans-unit id="35242c52a20b0f631fccc4a7c16ed23a76be06bd" translate="yes" xml:space="preserve">
          <source>Cache Statistics</source>
          <target state="translated">キャッシュ統計</target>
        </trans-unit>
        <trans-unit id="53a0d2b5765f8ae251aea63864f78dac2259b0d7" translate="yes" xml:space="preserve">
          <source>Clearing Instance Cache</source>
          <target state="translated">インスタンスキャッシュのクリア</target>
        </trans-unit>
        <trans-unit id="bf5dec3573c5a5d21ca6a1425613a8510bf9f271" translate="yes" xml:space="preserve">
          <source>Clearing Shared Cache</source>
          <target state="translated">共有キャッシュのクリア</target>
        </trans-unit>
        <trans-unit id="751c68a3471b1c791efaee0a8e7c24ea0c266efd" translate="yes" xml:space="preserve">
          <source>If</source>
          <target state="translated">もし</target>
        </trans-unit>
        <trans-unit id="95f76da19cad315076ccc2afaa0e41daf973ca96" translate="yes" xml:space="preserve">
          <source>If available this package will use SpookyHash V2 as a hashing mechanism.
Spooky is a good fast hashing algorithm that should be suitable for most uses.
If it is not available the package will fall back to SHA-256 from the standard
hashlib.  Because SHA-256 is a proper cryptographic hash it requires more
computation than Spooky.  To install spooky use pip:</source>
          <target state="translated">利用可能な場合、本パッケージは SpookyHash V2 をハッシュ機構として使用します。Spooky は高速なハッシュアルゴリズムで、ほとんどの用途に適しています。利用できない場合は、パッケージは標準の hashlib から SHA-256 にフォールバックします。SHA-256 は適切な暗号化ハッシュなので、Spooky よりも多くの計算を必要とします。spooky をインストールするには pip を使用してください。</target>
        </trans-unit>
        <trans-unit id="bd872a8af71a679a7a57ab648b7308f8099f311d" translate="yes" xml:space="preserve">
          <source>If you do not want to use either</source>
          <target state="translated">どちらも使いたくない場合は</target>
        </trans-unit>
        <trans-unit id="f20cd38b0f0d290cf5aa2dda99bb5da47f90a908" translate="yes" xml:space="preserve">
          <source>Initially we looked at the possibility of using two different mechanisms but
we quickly saw the advantage of maintaining the same set of keys for both
caches and decided to create our own mechanism.</source>
          <target state="translated">最初は2つの異なるメカニズムを使用する可能性を検討しましたが、両方のキャッシュで同じキーセットを維持することの利点をすぐに理解し、独自のメカニズムを作成することにしました。</target>
        </trans-unit>
        <trans-unit id="debd19f419480deae2e24d7b2b4c8018a365b90e" translate="yes" xml:space="preserve">
          <source>Installation &amp;amp; Configuration</source>
          <target state="translated">インストールと構成</target>
        </trans-unit>
        <trans-unit id="cc1093a96d4b2482bcaf84ac72db0fe4a89cb2c3" translate="yes" xml:space="preserve">
          <source>Invalidating Cached Results</source>
          <target state="translated">キャッシュされた結果の無効化</target>
        </trans-unit>
        <trans-unit id="6eef6648406c333a4035cd5e60d0bf2ecf2606d7" translate="yes" xml:space="preserve">
          <source>None</source>
          <target state="translated">なし</target>
        </trans-unit>
        <trans-unit id="5cfe5bbe5ae1dcb900a59525d853591e69656103" translate="yes" xml:space="preserve">
          <source>Once lru2cache is installed you will need to configure a shared cache as an
l2 cache.  If you are using Django your settings file will contain something
similar to the following in the settings file:</source>
          <target state="translated">lru2cache をインストールしたら、共有キャッシュを l2 キャッシュとして設定する必要があります。Django を使用している場合、設定ファイルには以下のような内容が含まれています。</target>
        </trans-unit>
        <trans-unit id="5da6bc6ba91b6bc6224f81e28bb845e36941f36f" translate="yes" xml:space="preserve">
          <source>Refreshing the Cache</source>
          <target state="translated">キャッシュの更新</target>
        </trans-unit>
        <trans-unit id="3fc5f2545bc12aba6c4ecc7066bfa0304189551b" translate="yes" xml:space="preserve">
          <source>Since the lru2cache decorator does not provide a timeout for its cache although
it provides other mechanisms for programatically managing the cache.</source>
          <target state="translated">lru2cache デコレータはキャッシュをプログラムで管理するための他のメカニズムを提供していますが、キャッシュのタイムアウトを提供しません。</target>
        </trans-unit>
        <trans-unit id="39fdec1194d94212b871a28b2aa04a73cd40fce1" translate="yes" xml:space="preserve">
          <source>Tests</source>
          <target state="translated">テスト</target>
        </trans-unit>
        <trans-unit id="1d0165a592656f6dd286443745686b0cd7caff47" translate="yes" xml:space="preserve">
          <source>The easiest and best way to install this is with pip:</source>
          <target state="translated">これをインストールするにはpipを使うのが一番簡単で良い方法です。</target>
        </trans-unit>
        <trans-unit id="b4358f486357d25333aa98b7ac1dc2af818fc3e0" translate="yes" xml:space="preserve">
          <source>The first layer of caching is stored in a callable that wraps the function or
method.  As with &amp;lsquo;functools.lru_cache&amp;rsquo; a dict is used to store the cached
results, therefore positional and keyword arguments must be hashable. Each
instance stores up to</source>
          <target state="translated">キャッシュの最初のレイヤーは、関数またはメソッドをラップする呼び出し可能オブジェクトに格納されます。'functools.lru_cache'と同様に、キャッシュされた結果を格納するためにdictが使用されるため、位置引数とキーワード引数はハッシュ可能である必要があります。各インスタンスは最大</target>
        </trans-unit>
        <trans-unit id="0ea4401b5713b542a1e261e03fdcbec558a8d19b" translate="yes" xml:space="preserve">
          <source>The second layer of caching requires a shared cache that can make use of
Django&amp;rsquo;s cache framework.  In this case it is assumed that any LRU mechanism
is handled by the shared cache backend.</source>
          <target state="translated">キャッシュの第2層には、Djangoのキャッシュフレームワークを利用できる共有キャッシュが必要です。この場合、LRUメカニズムはすべて共有キャッシュバックエンドによって処理されると想定されています。</target>
        </trans-unit>
        <trans-unit id="176ea28590869923dcfef77790d0be6e85b0bc24" translate="yes" xml:space="preserve">
          <source>The un-cached underlying function can always be accessed with</source>
          <target state="translated">キャッシュされていない基礎となる関数は、常に</target>
        </trans-unit>
        <trans-unit id="d8e2dde7858b0f625a6bbfb5559beee48b1cb949" translate="yes" xml:space="preserve">
          <source>This arrangement allows a process that accesses a function multiple times to
retrieve the value without the expense of requesting it from a shared cache,
while still allowing different processes to access the result from the shared
cache.</source>
          <target state="translated">この配置では、関数に複数回アクセスするプロセスが共有キャッシュから値を要求することなく値を取得することができ、同時に異なるプロセスが共有キャッシュから結果にアクセスできるようになります。</target>
        </trans-unit>
        <trans-unit id="75b9de2bd29cbf6751c7a36363a0fd751ecacea2" translate="yes" xml:space="preserve">
          <source>This is not yet implemented as a function but can be accomplished by first calling
invalidate and then calling the function</source>
          <target state="translated">これはまだ関数として実装されていませんが、最初に invalidate を呼び出してから関数</target>
        </trans-unit>
        <trans-unit id="6c5e4c3c083a750c34b9adaef009aac85d3924c6" translate="yes" xml:space="preserve">
          <source>This was developed by &lt;a href=&quot;http://www.3top.com/team&quot;&gt;3Top, Inc.&lt;/a&gt; for use with
our ranking and recommendation platform, &lt;a href=&quot;http://www.3top.com&quot;&gt;http://www.3top.com&lt;/a&gt;.</source>
          <target state="translated">これは、ランキングおよび推奨プラットフォーム&lt;a href=&quot;http://www.3top.com&quot;&gt;http://www.3top.com&lt;/a&gt;で使用するために&lt;a href=&quot;http://www.3top.com/team&quot;&gt;3Top、Inc。&lt;/a&gt;によって開発されました。</target>
        </trans-unit>
        <trans-unit id="fde1a31e15e42e88afb165e49cb21121fae29131" translate="yes" xml:space="preserve">
          <source>To invalidate the cache for a specific set of arguments, including the instance
one can pass the same arguments to invalidate the both L1 and L2 caches:</source>
          <target state="translated">インスタンスを含む特定の引数のキャッシュを無効にするには、同じ引数を渡すことで L1 と L2 の両方のキャッシュを無効にすることができます。</target>
        </trans-unit>
        <trans-unit id="88b33e4e12f75ac8bf792aebde41f1a090f3a612" translate="yes" xml:space="preserve">
          <source>True</source>
          <target state="translated">Vero</target>
        </trans-unit>
        <trans-unit id="0bb18642b70b9f8a9c12ccf39487328f306b8e19" translate="yes" xml:space="preserve">
          <source>Usage</source>
          <target state="translated">使用方法</target>
        </trans-unit>
        <trans-unit id="3b2cb96142ae431c2df3de4bb6b9a4cbca498afc" translate="yes" xml:space="preserve">
          <source>Usage is as simple as adding the decorator to a function or method as seen in
the below examples from our test cases:</source>
          <target state="translated">使い方は、以下のテストケースの例のように、関数やメソッドにデコレータを追加するのと同じくらい簡単です。</target>
        </trans-unit>
        <trans-unit id="b8b4346e8782d546f582feeaec684daca029da8b" translate="yes" xml:space="preserve">
          <source>We used a backport python 3</source>
          <target state="translated">私たちはpython 3のバックポートを使用しています</target>
        </trans-unit>
        <trans-unit id="235811c1759d45111475d5266bc6a107245df52d" translate="yes" xml:space="preserve">
          <source>and if not found fall back to</source>
          <target state="translated">見つからなければ</target>
        </trans-unit>
        <trans-unit id="b204bca289d16df380a96f6adc203c95eff37534" translate="yes" xml:space="preserve">
          <source>decorator as a starting
point for developing an in instance cache with LRU capabilities.  However we
needed to ensure the keys would also be unique enough to use with a shared
cache. We leverage Django&amp;rsquo;s excellent cache framework for managing the layer 2
cache. This allows the use of any shared cache supported by Django.</source>
          <target state="translated">LRU機能を備えたインスタンス内キャッシュを開発するための開始点としてのデコレータ。ただし、キーが共有キャッシュで使用するのに十分な一意であることを確認する必要がありました。 Djangoの優れたキャッシュフレームワークを活用して、レイヤー2キャッシュを管理します。これにより、Djangoでサポートされている共有キャッシュを使用できます。</target>
        </trans-unit>
        <trans-unit id="7505d64a54e061b7acd54ccd58b49dc43500b635" translate="yes" xml:space="preserve">
          <source>default</source>
          <target state="translated">デフォルト</target>
        </trans-unit>
        <trans-unit id="778b425edf8ec003eb2a0a2d8a7a2a3d54043356" translate="yes" xml:space="preserve">
          <source>f.__wrapped__</source>
          <target state="translated">f.__ラッピングされた</target>
        </trans-unit>
        <trans-unit id="cf8c707a6006ea42369c462118f8380268597325" translate="yes" xml:space="preserve">
          <source>f.cache_info()</source>
          <target state="translated">f.cache_info()</target>
        </trans-unit>
        <trans-unit id="54800f8bd035a18cec9a83721a2f0d9901a88020" translate="yes" xml:space="preserve">
          <source>functools.lru_cache</source>
          <target state="translated">functools.lru_cache</target>
        </trans-unit>
        <trans-unit id="dcfadac569c49917e69f513a3e245fd1d6b2c92c" translate="yes" xml:space="preserve">
          <source>functools.lru_cache()</source>
          <target state="translated">functools.lru_cache()</target>
        </trans-unit>
        <trans-unit id="c589e370d15354bfa1c43ff28cafcd54ca93fbb2" translate="yes" xml:space="preserve">
          <source>however if it is not you will
need to specify what attribute should be used.</source>
          <target state="translated">を使用しますが、そうでない場合は、どの属性を使用するかを指定する必要があります。</target>
        </trans-unit>
        <trans-unit id="87ea5dfc8b8e384d848979496e706390b497e547" translate="yes" xml:space="preserve">
          <source>id</source>
          <target state="translated">偶像</target>
        </trans-unit>
        <trans-unit id="958f57f57d72a30f329ee5538f21b0257a49a46e" translate="yes" xml:space="preserve">
          <source>if</source>
          <target state="translated">とすれば</target>
        </trans-unit>
        <trans-unit id="894f317b9160e13f41fd9889fbe20573a6a2fa51" translate="yes" xml:space="preserve">
          <source>in the case of a method you do need to explicitly pass the instance as in the
following:</source>
          <target state="translated">メソッドの場合は、次のように明示的にインスタンスを渡す必要があります。</target>
        </trans-unit>
        <trans-unit id="99578a0572cb4666f7da4c6317812a1795e90db6" translate="yes" xml:space="preserve">
          <source>inst_attr</source>
          <target state="translated">インストアトリビュート</target>
        </trans-unit>
        <trans-unit id="b47f363e2b430c0647f14deea3eced9b0ef300ce" translate="yes" xml:space="preserve">
          <source>is</source>
          <target state="translated">でござる</target>
        </trans-unit>
        <trans-unit id="04aea98291c14f68c64d647870dcc66791bebff3" translate="yes" xml:space="preserve">
          <source>is set to</source>
          <target state="translated">に設定されています。</target>
        </trans-unit>
        <trans-unit id="203a495a6685bc90041befff86795808f8e82182" translate="yes" xml:space="preserve">
          <source>is specified it will be used as the shared cache.  Otherwise
it will attempt to use a cache named</source>
          <target state="translated">が指定されている場合は共有キャッシュとして使用されます。という名前のキャッシュを使用しようとします。</target>
        </trans-unit>
        <trans-unit id="f6d6ab6f2a5f07bb043396b6eddd6c513b490bbb" translate="yes" xml:space="preserve">
          <source>is the attribute used to uniquely identify an object when wrapping
a method.  In Django this will typically be</source>
          <target state="translated">は、メソッドをラップする際にオブジェクトを一意に識別するために使われる属性です。Django では、これは通常</target>
        </trans-unit>
        <trans-unit id="4e35854b464fbca3f62f573e0ebc966a5c2346df" translate="yes" xml:space="preserve">
          <source>l1_maxsize</source>
          <target state="translated">エルワンマックスサイズ</target>
        </trans-unit>
        <trans-unit id="24239dc31cf7b79a3dd81e391ffb9cf6b8f43413" translate="yes" xml:space="preserve">
          <source>l2cache</source>
          <target state="translated">l2キャッシュ</target>
        </trans-unit>
        <trans-unit id="d25a4bf33e3adbcb4faa3349bda74f43c379251e" translate="yes" xml:space="preserve">
          <source>l2cache_name</source>
          <target state="translated">l2キャッシュ名</target>
        </trans-unit>
        <trans-unit id="67962b5f93ab7e7aee26271b6434367efdebeb0c" translate="yes" xml:space="preserve">
          <source>lru2cache is a decorator that can be used with any user function or method to
cache the most recent results in a local cache and using the django cache
framework to cache results in a shared cache.</source>
          <target state="translated">lru2cache は、ローカルキャッシュに最新の結果をキャッシュしたり、django キャッシュフレームワークを使って共有キャッシュに結果をキャッシュしたりするために、任意のユーザ関数やメソッドで使用できるデコレータです。</target>
        </trans-unit>
        <trans-unit id="a0b82c9aec209c2aeba44c98d6e0f5ac1eeb0366" translate="yes" xml:space="preserve">
          <source>none_cache</source>
          <target state="translated">なしキャッシュ</target>
        </trans-unit>
        <trans-unit id="1758356db21759f7c5a0da9b4dd1db8fd6feab3f" translate="yes" xml:space="preserve">
          <source>or</source>
          <target state="translated">或いは</target>
        </trans-unit>
        <trans-unit id="7bb544dbb5a0825498324c9261119887b51048a7" translate="yes" xml:space="preserve">
          <source>results that vary on the arguments. The
discarding of the LRU cached values is handled by the decorator.</source>
          <target state="translated">結果は引数に応じて変化します。LRU キャッシュされた値の破棄はデコレータによって処理されます。</target>
        </trans-unit>
        <trans-unit id="32800976dbaf3bf9a9490995b0c0f0b6bbb55857" translate="yes" xml:space="preserve">
          <source>results will be cached, otherwise they
will not.</source>
          <target state="translated">結果はキャッシュされますが、そうでなければキャッシュされません。</target>
        </trans-unit>
        <trans-unit id="d820aa5f8750fdde33200083b0702a32578a6c95" translate="yes" xml:space="preserve">
          <source>than</source>
          <target state="translated">よりも</target>
        </trans-unit>
        <trans-unit id="80df4a04d26c83f618293af30f0535e20afd7329" translate="yes" xml:space="preserve">
          <source>the cache and statistics associated with a function or method can be cleared with:</source>
          <target state="translated">関数やメソッドに関連付けられたキャッシュや統計情報をクリアできるようになります。</target>
        </trans-unit>
        <trans-unit id="bda4b1c3ce007842c38ded3638ca7730d8a8aae7" translate="yes" xml:space="preserve">
          <source>typed</source>
          <target state="translated">タイプされた</target>
        </trans-unit>
        <trans-unit id="dcfac732a9fac915f0831ba3d8ab666199413e95" translate="yes" xml:space="preserve">
          <source>with minor changes to make them work with python 2.7
and incorporated the l2_cache stats. We will continue to add tests to validate
the additional functionality provided by this decorator.</source>
          <target state="translated">を python 2.7 で動作するようにマイナーチェンジし、l2_cache 統計情報を組み込みました。このデコレータが提供する追加機能を検証するためのテストを今後も追加していきます。</target>
        </trans-unit>
        <trans-unit id="290239353d61d53048fdeae4868e219f2dd57e54" translate="yes" xml:space="preserve">
          <source>you will need to
specify the name of the cache.</source>
          <target state="translated">を使用する場合は、キャッシュの名前を指定する必要があります。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
