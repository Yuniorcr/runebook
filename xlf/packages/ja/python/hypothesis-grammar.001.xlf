<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="https://pypi.org/project/hypothesis-grammar/">
    <body>
      <group id="hypothesis-grammar">
        <trans-unit id="06e715f999c1e8bb74d0ef668de5467dbc5404e8" translate="yes" xml:space="preserve">
          <source>'Rules' must be named all-lowercase, e.g. &lt;code&gt;np&lt;/code&gt;</source>
          <target state="translated">「ルール」はすべて小文字で指定する必要があります（例： &lt;code&gt;np&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="065e98511a3f896062d78116f1f4a79818a9d74c" translate="yes" xml:space="preserve">
          <source>'Terminals' must be named all-caps (terminals only reference literals, not other rules), e.g. &lt;code&gt;DET&lt;/code&gt;</source>
          <target state="translated">「端末」には、すべて大文字で名前を付ける必要があります（端末はリテラルのみを参照し、他のルールは参照しません）。例： &lt;code&gt;DET&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0e4306aaec34e61c0ed5b8039ff9c6bd77e8c070" translate="yes" xml:space="preserve">
          <source>(But if you're generating action sequences for tests then probably you should check out Hypothesis' &lt;a href=&quot;https://hypothesis.readthedocs.io/en/latest/stateful.html&quot;&gt;stateful testing&lt;/a&gt; features first)</source>
          <target state="translated">（ただし、テストのアクションシーケンスを生成している場合は、最初にHypothesisの&lt;a href=&quot;https://hypothesis.readthedocs.io/en/latest/stateful.html&quot;&gt;ステートフルテスト&lt;/a&gt;機能を確認する必要があります）</target>
        </trans-unit>
        <trans-unit id="7da59d650a4228de748a0d71280684a68d5ad441" translate="yes" xml:space="preserve">
          <source>(If you are looking to generate text from a grammar for purposes other than testing with Hypothesis then this lib can still be useful, but I stongly recommend looking at the &lt;a href=&quot;http://www.nltk.org/howto/generate.html&quot;&gt;tools provided with NLTK&lt;/a&gt; instead.)</source>
          <target state="translated">（仮説でのテスト以外の目的で文法からテキストを生成する場合は、このライブラリが引き続き役立ち&lt;a href=&quot;http://www.nltk.org/howto/generate.html&quot;&gt;ますが、&lt;/a&gt;代わりにNLTKで提供されるツールを確認することを強くお勧めします。）</target>
        </trans-unit>
        <trans-unit id="f79e28061ca25a0dae68cd9212d7c2ddaf953658" translate="yes" xml:space="preserve">
          <source>(pre-alpha... the stuff I've tried all works, not well tested yet though)</source>
          <target state="translated">（プレアルファ...私がすべての作品を試したものですが、まだ十分にテストされていません）</target>
        </trans-unit>
        <trans-unit id="34ef5ca7249f5ce6a9b2a03376eb3bd60d72a35b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;(&lt;/code&gt; and &lt;code&gt;)&lt;/code&gt; are for grouping, the group can be quantified using any of the modifiers above.</source>
          <target state="translated">&lt;code&gt;(&lt;/code&gt; および &lt;code&gt;)&lt;/code&gt; はグループ化用であり、グループは上記の修飾子のいずれかを使用して定量化できます。</target>
        </trans-unit>
        <trans-unit id="69d0a0282362c3d1a791adf8f0b422ad59bbc4f7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;*&lt;/code&gt; i.e. &lt;code&gt;&quot;in&quot;*&lt;/code&gt; means &lt;code&gt;&quot;in&quot;&lt;/code&gt; is expected zero-or-many times.</source>
          <target state="translated">&lt;code&gt;*&lt;/code&gt; つまり、 &lt;code&gt;&quot;in&quot;*&lt;/code&gt; は、 &lt;code&gt;&quot;in&quot;&lt;/code&gt; が0回または何度も予想されることを意味します。</target>
        </trans-unit>
        <trans-unit id="594929d4a73449a1758113e6a81964a0eed29be9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;+&lt;/code&gt; i.e. &lt;code&gt;&quot;in&quot;+&lt;/code&gt; means &lt;code&gt;&quot;in&quot;&lt;/code&gt; is expected one-or-many times.</source>
          <target state="translated">&lt;code&gt;+&lt;/code&gt; つまり、 &lt;code&gt;&quot;in&quot;+&lt;/code&gt; は、 &lt;code&gt;&quot;in&quot;&lt;/code&gt; が1回または複数回予想されることを意味します。</target>
        </trans-unit>
        <trans-unit id="acfb5e63bd26caad67b133356629e859d7e8040b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;?&lt;/code&gt; means optional, i.e. &lt;code&gt;&quot;in&quot;?&lt;/code&gt; means &lt;code&gt;&quot;in&quot;&lt;/code&gt; is expected zero-or-one time.</source>
          <target state="translated">&lt;code&gt;?&lt;/code&gt; オプション、つまり &lt;code&gt;&quot;in&quot;?&lt;/code&gt; 意味しますか？ &lt;code&gt;&quot;in&quot;&lt;/code&gt; が0回または1回期待されることを意味します。</target>
        </trans-unit>
        <trans-unit id="65c66d8b9aad8e761dd0438f1755afc753cb14b7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;start=&quot;s&quot;&lt;/code&gt; tells the parser that the start rule is &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;start=&quot;s&quot;&lt;/code&gt; は、開始ルールが &lt;code&gt;s&lt;/code&gt; であることをパーサーに通知します。</target>
        </trans-unit>
        <trans-unit id="ffba1884ae5cdd5a0572dae34fed56976c21cf0d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;|&lt;/code&gt; is alternation, so &lt;code&gt;&quot;in&quot; | &quot;with&quot;&lt;/code&gt; means one-of &lt;code&gt;&quot;in&quot;&lt;/code&gt; or &lt;code&gt;&quot;with&quot;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;|&lt;/code&gt; 交替なので、 &lt;code&gt;&quot;in&quot; | &quot;with&quot;&lt;/code&gt; は &lt;code&gt;&quot;in&quot;&lt;/code&gt; または &lt;code&gt;&quot;with&quot;&lt;/code&gt; いずれかを意味します</target>
        </trans-unit>
        <trans-unit id="53f6efc5cdcf9f3a22526511d7745bdb7b12979b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;~ &amp;lt;min&amp;gt;..&amp;lt;max&amp;gt;&lt;/code&gt; is a range, expected between-&amp;lt;min&amp;gt;-and-&amp;lt;max&amp;gt; times.</source>
          <target state="translated">&lt;code&gt;~ &amp;lt;min&amp;gt;..&amp;lt;max&amp;gt;&lt;/code&gt; は範囲であり、-&amp;lt;min&amp;gt;-と-&amp;lt;max&amp;gt;の間に予想されます。</target>
        </trans-unit>
        <trans-unit id="8175495afd0f99be24db86f956abbc7435b000f3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;~ &amp;lt;num&amp;gt;&lt;/code&gt; means exactly-&amp;lt;num&amp;gt; times.</source>
          <target state="translated">&lt;code&gt;~ &amp;lt;num&amp;gt;&lt;/code&gt; は正確に-&amp;lt;num&amp;gt;回を意味します。</target>
        </trans-unit>
        <trans-unit id="6fc2a5bf81a73fe237a154328c768027afa67a3c" translate="yes" xml:space="preserve">
          <source>A reverse-parser as a Hypotheses strategy: generate examples from an EBNF grammar</source>
          <target state="translated">仮説戦略としての逆パーサー:EBNF文法から例を生成する</target>
        </trans-unit>
        <trans-unit id="b11f8183e944886fa59148cbb5189e20f31848dd" translate="yes" xml:space="preserve">
          <source>Adjacent tokens are concatenated, i.e. &lt;code&gt;DET N&lt;/code&gt; means a &lt;code&gt;DET&lt;/code&gt; followed by a &lt;code&gt;N&lt;/code&gt;.</source>
          <target state="translated">隣接するトークンが連結されている、すなわち &lt;code&gt;DET N&lt;/code&gt; は意味 &lt;code&gt;DET&lt;/code&gt; 続く &lt;code&gt;N&lt;/code&gt; を。</target>
        </trans-unit>
        <trans-unit id="fc800738edcebd003994663a677ad7f8e3341029" translate="yes" xml:space="preserve">
          <source>As you can see, we have produced a Hypothesis strategy which is able to generate examples which match the grammar (in this case, short sentences which sometimes makes sense).</source>
          <target state="translated">ご覧のように、文法に合った例文(この場合は、たまに意味のある短文)を生成することができる仮説ストラテジーが出来上がりました。</target>
        </trans-unit>
        <trans-unit id="4c34dcc622b1da6b7f78e159b817ba5ba1108fcb" translate="yes" xml:space="preserve">
          <source>But the grammar doesn't have to describe text, it might represent a sequence of actions for example. In that case you might want to convert your result tokens into object instances, which could be done via a lookup table.</source>
          <target state="translated">しかし、文法はテキストを記述する必要はなく、例えば一連のアクションを表すかもしれません。その場合、結果トークンをオブジェクトインスタンスに変換したいかもしれません。</target>
        </trans-unit>
        <trans-unit id="dc9401e01d92475f18b6c76f30c9f4b07ca762e8" translate="yes" xml:space="preserve">
          <source>First you need a grammar. Our grammar format is based on that used by the &lt;a href=&quot;https://lark-parser.readthedocs.io/en/latest/grammar/&quot;&gt;Lark parser&lt;/a&gt; library.  You can see our grammar-parsing grammar &lt;a href=&quot;hypothesis_grammar/grammar.lark&quot;&gt;here&lt;/a&gt;. More details of our grammar format &lt;a href=&quot;#grammar-details&quot;&gt;below&lt;/a&gt;.</source>
          <target state="translated">まず、文法が必要です。私たちの文法形式は、&lt;a href=&quot;https://lark-parser.readthedocs.io/en/latest/grammar/&quot;&gt;Larkパーサー&lt;/a&gt;ライブラリで使用されている形式に基づいています。&lt;a href=&quot;hypothesis_grammar/grammar.lark&quot;&gt;ここで&lt;/a&gt;文法解析文法を見ることができます。&lt;a href=&quot;#grammar-details&quot;&gt;以下の&lt;/a&gt;文法形式の詳細。</target>
        </trans-unit>
        <trans-unit id="f2784e07adcbc7db90051cd83d24796138debae1" translate="yes" xml:space="preserve">
          <source>Grammar details</source>
          <target state="translated">文法の詳細</target>
        </trans-unit>
        <trans-unit id="c7530a6dc53e039db1fa76c609ca7579225d1de7" translate="yes" xml:space="preserve">
          <source>Here is an example of using Hypothesis-Grammar:</source>
          <target state="translated">仮説文法の使用例です。</target>
        </trans-unit>
        <trans-unit id="334513e51b766e5689a61997385d87079b5771e1" translate="yes" xml:space="preserve">
          <source>Hypothesis-Grammar</source>
          <target state="translated">仮説の文法</target>
        </trans-unit>
        <trans-unit id="d23367f26b61f8267251a6d0cd014c1bfc25fe30" translate="yes" xml:space="preserve">
          <source>Hypothesis-Grammar is a &quot;reverse parser&quot; - given a grammar it will generate examples of that grammar.</source>
          <target state="translated">仮説-Grammarは「逆パーサー」であり、文法が与えられるとその文法の例を生成します。</target>
        </trans-unit>
        <trans-unit id="8512397b4e5d55cc7988da53f1e53707a6b4cd51" translate="yes" xml:space="preserve">
          <source>It is implemented as a &lt;a href=&quot;https://hypothesis.readthedocs.io/&quot;&gt;Hypothesis&lt;/a&gt; strategy.</source>
          <target state="translated">これは、&lt;a href=&quot;https://hypothesis.readthedocs.io/&quot;&gt;仮説&lt;/a&gt;戦略として実装されます。</target>
        </trans-unit>
        <trans-unit id="1e8128625511f78e7f6a98221108be4105cd8796" translate="yes" xml:space="preserve">
          <source>LHS (name) and RHS are separated by &lt;code&gt;:&lt;/code&gt;</source>
          <target state="translated">LHS（名前）とRHSは次のように区切られ &lt;code&gt;:&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3fe993dc8d00fe8d1dcd9fd70305c2ef4e2c9d81" translate="yes" xml:space="preserve">
          <source>So, how does this look?</source>
          <target state="translated">で、これはどうなんでしょうか?</target>
        </trans-unit>
        <trans-unit id="4bdde3ae857cfb158e4e4b54e3b745c97059108f" translate="yes" xml:space="preserve">
          <source>String literals must be quoted with double-quotes e.g. &lt;code&gt;&quot;man&quot;&lt;/code&gt;</source>
          <target state="translated">文字列リテラルは二重引用符で囲む必要があります（例： &lt;code&gt;&quot;man&quot;&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="e9fdfd1e154ac05cf9c3cf579648d547828051f8" translate="yes" xml:space="preserve">
          <source>The grammar is taken from an example in the NLTK docs and converted into our &quot;simplified Lark&quot; format.</source>
          <target state="translated">文法はNLTK docsの例を参考にして、当社の「簡易ラルク」形式に変換しています。</target>
        </trans-unit>
        <trans-unit id="7e17a3d7bd0d9cde371729a97139671e37c46125" translate="yes" xml:space="preserve">
          <source>The output will always be a flat list of token strings. If you want a sentence you can just &lt;code&gt;&quot; &quot;.join(example)&lt;/code&gt;.</source>
          <target state="translated">出力は常にトークン文字列のフラットリストになります。文が必要な場合は、 &lt;code&gt;&quot; &quot;.join(example)&lt;/code&gt; ます。</target>
        </trans-unit>
        <trans-unit id="0bb18642b70b9f8a9c12ccf39487328f306b8e19" translate="yes" xml:space="preserve">
          <source>Usage</source>
          <target state="translated">使用方法</target>
        </trans-unit>
        <trans-unit id="89511a76c8cbc174d6fe0018b08443f894e18a4b" translate="yes" xml:space="preserve">
          <source>What is it?</source>
          <target state="translated">それは何ですか?</target>
        </trans-unit>
        <trans-unit id="5f5f8cd4a78f6cd933cbf9fff486ee98721bee8a" translate="yes" xml:space="preserve">
          <source>Whitespace is ignored</source>
          <target state="translated">空白は無視されます。</target>
        </trans-unit>
        <trans-unit id="f440fc0b5a8ed2198e0c8ff92108351e7b09573a" translate="yes" xml:space="preserve">
          <source>You can also use regex literals, they are delimited with forward-slash, e.g. &lt;code&gt;/the[a-z]{0,2}/&lt;/code&gt;. Content for the regex token is generated using Hypothesis' &lt;a href=&quot;https://hypothesis.readthedocs.io/en/latest/data.html#hypothesis.strategies.from_regex&quot;&gt;&lt;code&gt;from_regex&lt;/code&gt;&lt;/a&gt; strategy, with &lt;code&gt;fullmatch=True&lt;/code&gt;.</source>
          <target state="translated">正規表現リテラルを使用することもできます。これらはスラッシュで区切られます（例： &lt;code&gt;/the[a-z]{0,2}/&lt;/code&gt; 。正規表現トークンのコンテンツは、仮説の&lt;a href=&quot;https://hypothesis.readthedocs.io/en/latest/data.html#hypothesis.strategies.from_regex&quot;&gt; &lt;code&gt;from_regex&lt;/code&gt; &lt;/a&gt;戦略を使用して、 &lt;code&gt;fullmatch=True&lt;/code&gt; で生成されます。</target>
        </trans-unit>
        <trans-unit id="63a91052414204f961faae0fbe524fde2183273f" translate="yes" xml:space="preserve">
          <source>or as a test...</source>
          <target state="translated">またはテストとして...</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
