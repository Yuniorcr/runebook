<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="https://pypi.org/project/asyncscope/">
    <body>
      <group id="asyncscope">
        <trans-unit id="80e2beb36491b20581dbcedf302120f4e7151f17" translate="yes" xml:space="preserve">
          <source>&amp;ldquo;Clean termination&amp;rdquo; means that the scope&amp;rsquo;s call to</source>
          <target state="translated">「クリーン終了」とは、スコープが</target>
        </trans-unit>
        <trans-unit id="a77cb6b5652c4005532755d55df9906e50c68b74" translate="yes" xml:space="preserve">
          <source>&amp;rsquo;s global</source>
          <target state="translated">のグローバル</target>
        </trans-unit>
        <trans-unit id="947cab548ff029f91ef570a175d1383baf0a5828" translate="yes" xml:space="preserve">
          <source>(subordinate task) or wait for SIGTERM (daemon main task)
or terminate (main task&amp;rsquo;s job is done)</source>
          <target state="translated">（従属タスク）またはSIGTERMを待つ（デーモンのメインタスク）または終了（メインタスクのジョブが完了する）</target>
        </trans-unit>
        <trans-unit id="3a52ce780950d4d969792a2559cd519d7ee8c727" translate="yes" xml:space="preserve">
          <source>.</source>
          <target state="translated">。</target>
        </trans-unit>
        <trans-unit id="9e3edd5906a2460bab23ca2086bbd93812e1625e" translate="yes" xml:space="preserve">
          <source>. This function returns the new tasks&amp;rsquo;s cancel scope so that you
can cancel the new task if you need to. All tasks started that way are
auto-cancelled when your main code exits.</source>
          <target state="translated">。この関数は、必要に応じて新しいタスクをキャンセルできるように、新しいタスクのキャンセルスコープを返します。その方法で開始されたすべてのタスクは、メインコードが終了すると自動的にキャンセルされます。</target>
        </trans-unit>
        <trans-unit id="b54ad0f09fdbeb343c772bec07e2001d8693d217" translate="yes" xml:space="preserve">
          <source>A scope&amp;rsquo;s main code typically looks like this:</source>
          <target state="translated">スコープのメインコードは通常、次のようになります。</target>
        </trans-unit>
        <trans-unit id="6f7fcc06f5a43a47848f403f55c311da91fec7d8" translate="yes" xml:space="preserve">
          <source>Alternately, if the service is created by an async context manager:</source>
          <target state="translated">あるいは、サービスが非同期コンテキストマネージャによって作成されている場合。</target>
        </trans-unit>
        <trans-unit id="d3a30a245e5eb40f2058c501aadf106d3644b773" translate="yes" xml:space="preserve">
          <source>Another part of your program also needs the error handler database
connections and loading a handler are expensive, so you want to re-use
them.</source>
          <target state="translated">また、プログラムの別の部分では、エラーハンドラのデータベース接続やハンドラのロードは高価なので、それらを再利用したいと思います。</target>
        </trans-unit>
        <trans-unit id="1264ac5499d19a2dc2fda3977b57eb2f7ced1f68" translate="yes" xml:space="preserve">
          <source>AsyncScope can help you.</source>
          <target state="translated">AsyncScopeがお手伝いします。</target>
        </trans-unit>
        <trans-unit id="096c62d357c259f713d3671465a274cf7b4ecf8e" translate="yes" xml:space="preserve">
          <source>AsyncScope keeps track of your program&amp;rsquo;s building blocks. It remembers
which parts depend on which other parts, prevents cyclic dependencies,
and terminates a scope as soon as nobody uses it any more.</source>
          <target state="translated">AsyncScopeは、プログラムのビルディングブロックを追跡します。どの部分が他のどの部分に依存しているかを記憶し、循環依存を防ぎ、スコープが使用されなくなるとすぐにスコープを終了します。</target>
        </trans-unit>
        <trans-unit id="59b0482bdded1133e8a5fead2d8afd30f974346d" translate="yes" xml:space="preserve">
          <source>Cancellation semantics</source>
          <target state="translated">キャンセルの意味</target>
        </trans-unit>
        <trans-unit id="c6a3981c0605028beccb698a3439ee4282147add" translate="yes" xml:space="preserve">
          <source>Code structure</source>
          <target state="translated">コード構造</target>
        </trans-unit>
        <trans-unit id="aeaea4443a2ba13db76c47382325d4718b4ff08c" translate="yes" xml:space="preserve">
          <source>Every scope has a separate taskgroup which you can access by calling</source>
          <target state="translated">各スコープには個別のタスクグループがあり、これにアクセスするには</target>
        </trans-unit>
        <trans-unit id="751c68a3471b1c791efaee0a8e7c24ea0c266efd" translate="yes" xml:space="preserve">
          <source>If</source>
          <target state="translated">もし</target>
        </trans-unit>
        <trans-unit id="e6f0de840ad4353a783325b26597620059fe57d4" translate="yes" xml:space="preserve">
          <source>Large programs often consist of building blocks which depend on each other.
Those dependencies may be non-trivial, aren&amp;rsquo;t always linear, and generally
form some sort of directed acyclic graph instead of a nice linear or
hierarchical set of relationships.</source>
          <target state="translated">大規模なプログラムは、多くの場合、相互に依存するビルディングブロックで構成されています。これらの依存関係は重要な場合があり、常に線形であるとは限らず、一般に、関係の線形または階層的なセットではなく、ある種の有向非循環グラフを形成します。</target>
        </trans-unit>
        <trans-unit id="dc6898c4cf754556aa24ff98774c9a7b8b48737e" translate="yes" xml:space="preserve">
          <source>Later the admin code terminates. It can&amp;rsquo;t unload the error handler because
that other code still needs it.</source>
          <target state="translated">その後、管理コードは終了します。エラーハンドラーをアンロードすることはできません。他のコードでエラーハンドラーがまだ必要だからです。</target>
        </trans-unit>
        <trans-unit id="2826b3b8d53942e914dd917cc08e57bfef8efe4d" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s invent an example.</source>
          <target state="translated">例を考えてみましょう。</target>
        </trans-unit>
        <trans-unit id="4835fbb132d02a0d1324d266ab9d295c5a2c2a3b" translate="yes" xml:space="preserve">
          <source>Now your error handler stays around exactly as long as you need it, your
database connection won&amp;rsquo;t die while the error handler (or any other code,
for that matter) requires it, your error gets logged correctly, and you
find the problem easily.</source>
          <target state="translated">これで、エラーハンドラーは必要な間正確に残ります。データベース接続は、エラーハンドラー（または、他のすべてのコード）が必要とする間は停止せず、エラーが正しく記録され、問題を簡単に見つけることができます。</target>
        </trans-unit>
        <trans-unit id="98365abf7a35b55e3b549f20aa17daee9fe3c995" translate="yes" xml:space="preserve">
          <source>Rationale</source>
          <target state="translated">根拠</target>
        </trans-unit>
        <trans-unit id="7e42e371e1139786764c46314b85ef21b7a750d7" translate="yes" xml:space="preserve">
          <source>Scopes typically don&amp;rsquo;t need to access its own scope object. It&amp;rsquo;s stored in
a contextvar and can be retrieved via</source>
          <target state="translated">スコープは通常、独自のスコープオブジェクトにアクセスする必要はありません。これはcontextvarに格納され、次の方法で取得できます</target>
        </trans-unit>
        <trans-unit id="2507c2b55d5db39a9f83e01f96320bf24ea1b23a" translate="yes" xml:space="preserve">
          <source>Start a service task (i.e. something you depend on) with</source>
          <target state="translated">サービスタスク(つまり依存しているもの)を</target>
        </trans-unit>
        <trans-unit id="674c454ba310e310a32c1322e2e45801d1bb9239" translate="yes" xml:space="preserve">
          <source>TODO: write a service which your code can use to keep another service alive
for a bit.</source>
          <target state="translated">TODO:あなたのコードが他のサービスを少しの間存続させるために使用できるサービスを書いてください。</target>
        </trans-unit>
        <trans-unit id="6c1e956d40870f2b75767e81f9483d9dda74fe72" translate="yes" xml:space="preserve">
          <source>Task scopes for AnyIO</source>
          <target state="translated">AnyIOのタスクスコープ</target>
        </trans-unit>
        <trans-unit id="93ef0dd827103681fcee453b78be2ff14e1a261d" translate="yes" xml:space="preserve">
          <source>The</source>
          <target state="translated">The</target>
        </trans-unit>
        <trans-unit id="36e03547626d68a092132496f04f21d59aeb8d83" translate="yes" xml:space="preserve">
          <source>The current scope is available as the</source>
          <target state="translated">現在のスコープは</target>
        </trans-unit>
        <trans-unit id="125c5e78921cb603c94d4f0c951d3ab16641dddf" translate="yes" xml:space="preserve">
          <source>The service&amp;rsquo;s setup code typically looks like this:</source>
          <target state="translated">サービスのセットアップコードは通常、次のようになります。</target>
        </trans-unit>
        <trans-unit id="641fa6952b7f92fe6e90337e9bdda258ee4ff9af" translate="yes" xml:space="preserve">
          <source>This also happens when a scope&amp;rsquo;s main task ends.</source>
          <target state="translated">これは、スコープのメインタスクが終了したときにも発生します。</target>
        </trans-unit>
        <trans-unit id="8a3cc2e8c196435d99f13f9317c2637176c56fc5" translate="yes" xml:space="preserve">
          <source>This is a problem because you like to use Structured Programming
principles. Thus you need to jump through interesting hoops getting all of
this connected up and keeping track of each module&amp;rsquo;s users.</source>
          <target state="translated">構造化プログラミングの原則を使用したいので、これは問題です。したがって、これらすべてを接続し、各モジュールのユーザーを追跡する興味深いフープをジャンプする必要があります。</target>
        </trans-unit>
        <trans-unit id="85c3cae45815aa53d8bdc35b0cd38e9e00c3fae1" translate="yes" xml:space="preserve">
          <source>This library implements scoped taskgroups / nurseries.</source>
          <target state="translated">このライブラリは、スコープされたタスクグループ/保育園を実装しています。</target>
        </trans-unit>
        <trans-unit id="0bb18642b70b9f8a9c12ccf39487328f306b8e19" translate="yes" xml:space="preserve">
          <source>Usage</source>
          <target state="translated">使用方法</target>
        </trans-unit>
        <trans-unit id="711e7706d1362390d17b75a0e39f6c52a84dafe5" translate="yes" xml:space="preserve">
          <source>When a scope exits (either cleanly or when it raises an error that escapes
its taskgroup), all scopes depending on it are cancelled immediately, in
parallel. Then those it itself depends on are terminated cleanly and
in-order.</source>
          <target state="translated">スコープが終了すると (クリーンに終了するか、またはそのタスクグループをエスケープしたエラーが発生した場合)、そのスコープに依存しているすべてのスコープは、並行して即座にキャンセルされます。その後、そのスコープ自身が依存しているスコープは、クリーンに順番に終了します。</target>
        </trans-unit>
        <trans-unit id="88d45e6a980f0df68d27ce165ed197e0a5665884" translate="yes" xml:space="preserve">
          <source>Worse, assume that your code dies with a fatal exception. The exception
typically propagates through your code and cancels the database connection
before the error handler has a chance to log the problem. This happens
randomly, depending on which cancelled task runs first, so you have a lot
of fun trying to reproduce the problem and debug all of this.</source>
          <target state="translated">さらに悪いことに、あなたのコードが致命的な例外で死んだと仮定してください。この例外は通常、コードを伝播し、エラーハンドラが問題をログに記録する前にデータベース接続をキャンセルします。これは、どのキャンセルされたタスクが最初に実行されるかに応じてランダムに発生するので、問題を再現したり、このすべてをデバッグしたりするのはとても楽しいことです。</target>
        </trans-unit>
        <trans-unit id="a2268d48cac5e24ed6c2d566336bdb20614f616f" translate="yes" xml:space="preserve">
          <source>Wrap your main code in</source>
          <target state="translated">メインコードを</target>
        </trans-unit>
        <trans-unit id="0d518b326eb1f8e7dd14bb6dacd324e99b66610e" translate="yes" xml:space="preserve">
          <source>Your main code runs some admin module, which requires a support library,
which connects to a database. Halfway through it encounters an error, thus
loads an error handler, which also uses the database.</source>
          <target state="translated">あなたのメインコードは、データベースに接続するサポートライブラリを必要とする管理モジュールを実行しています。途中でエラーに遭遇し、エラーハンドラをロードします。</target>
        </trans-unit>
        <trans-unit id="1119e4e9e700cfa21cbdc86bfd28782fd00e25c5" translate="yes" xml:space="preserve">
          <source>Your service &lt;strong&gt;must&lt;/strong&gt; call</source>
          <target state="translated">あなたのサービス&lt;strong&gt;は&lt;/strong&gt;呼び出す&lt;strong&gt;必要があり&lt;/strong&gt;ます</target>
        </trans-unit>
        <trans-unit id="3a717f099d0f0afdd183e5fe1e60a3b2d4be0eb4" translate="yes" xml:space="preserve">
          <source>async with main_scope(): ...</source>
          <target state="translated">main_scope()で非同期にした場合:...</target>
        </trans-unit>
        <trans-unit id="b72db8dc97d16fc439c9e88e0ec58e8077ef01ab" translate="yes" xml:space="preserve">
          <source>asyncscope</source>
          <target state="translated">非同期スコープ</target>
        </trans-unit>
        <trans-unit id="20a233212a0283598b8ad388f4dfb864f5ebd77c" translate="yes" xml:space="preserve">
          <source>await no_more_dependents()</source>
          <target state="translated">await no_more_dependents()</target>
        </trans-unit>
        <trans-unit id="aa2798085d2c659cfb598dd371714e356971dc0f" translate="yes" xml:space="preserve">
          <source>call &amp;ldquo;register(serice_object)&amp;rdquo;</source>
          <target state="translated">「register（serice_object）」を呼び出します</target>
        </trans-unit>
        <trans-unit id="c0720160b6469d73b573d17b9baa627ef8a4dbda" translate="yes" xml:space="preserve">
          <source>cleanly stop itself</source>
          <target state="translated">綺麗さっぱりと止まる</target>
        </trans-unit>
        <trans-unit id="24594bf61f7292e625c39f9e5b1f6322ddfa99f4" translate="yes" xml:space="preserve">
          <source>context variable.</source>
          <target state="translated">コンテキスト変数を使用しています。</target>
        </trans-unit>
        <trans-unit id="bc884f7b9dec3f520e2cec89e0cb4fab48854777" translate="yes" xml:space="preserve">
          <source>directory contains some sample code.</source>
          <target state="translated">ディレクトリにはいくつかのサンプルコードが含まれています。</target>
        </trans-unit>
        <trans-unit id="0377f9ae43f8abfdfef3cb8a30fc7ffb76e6c7e1" translate="yes" xml:space="preserve">
          <source>exactly once,
otherwise the scopes waiting for it to start will wait forever. (They&amp;rsquo;ll
get cancelled if your scope&amp;rsquo;s main task exits before doing so.)</source>
          <target state="translated">それ以外の場合は、開始を待機しているスコープが永久に待機します。（スコープのメインタスクが終了する前に終了すると、キャンセルされます。）</target>
        </trans-unit>
        <trans-unit id="99345ce680cd3e48acdb9ab4212e4bd9bf9358b7" translate="yes" xml:space="preserve">
          <source>examples</source>
          <target state="translated">例示</target>
        </trans-unit>
        <trans-unit id="18cec78ad75ad5bc21fe0afbd305a42d810df378" translate="yes" xml:space="preserve">
          <source>if you need it.
For most uses, however,</source>
          <target state="translated">が必要な場合に使用します。しかしほとんどの用途では</target>
        </trans-unit>
        <trans-unit id="ddc0b76895c74c93ff932eab9b3a373a77695d03" translate="yes" xml:space="preserve">
          <source>is not used, the scope will be cancelled.</source>
          <target state="translated">を使用しない場合、スコープはキャンセルされます。</target>
        </trans-unit>
        <trans-unit id="dde037b9ca7ec60bc5542d1cd1dfcf993a27956c" translate="yes" xml:space="preserve">
          <source>is whatever object the service
intends you to use.</source>
          <target state="translated">はサービスが使用することを意図したものであれば何でも構いません。</target>
        </trans-unit>
        <trans-unit id="8e8d640d4780daa9d1e2d50f79d823d1725ac844" translate="yes" xml:space="preserve">
          <source>no_more_dependents</source>
          <target state="translated">ノーモアデペンデント</target>
        </trans-unit>
        <trans-unit id="b28688d24af9e039e2c7a373b5e70a234fd7bff1" translate="yes" xml:space="preserve">
          <source>no_more_dependents()</source>
          <target state="translated">no_more_dependents()</target>
        </trans-unit>
        <trans-unit id="1b8609b64802c1e1e712fe0688541bad04cde071" translate="yes" xml:space="preserve">
          <source>object accesses
the current scope transparently.</source>
          <target state="translated">オブジェクトは現在のスコープに透過的にアクセスします。</target>
        </trans-unit>
        <trans-unit id="a34d3973aa4a92dce9223ea3cbe7510703eadfdf" translate="yes" xml:space="preserve">
          <source>returns. If there is no such call, the scope&amp;rsquo;s tasks are cancelled.</source>
          <target state="translated">戻り値。そのような呼び出しがない場合、スコープのタスクはキャンセルされます。</target>
        </trans-unit>
        <trans-unit id="aacd3103f3f1fcab0248f041a315ab6816c8a0e9" translate="yes" xml:space="preserve">
          <source>scope</source>
          <target state="translated">範囲</target>
        </trans-unit>
        <trans-unit id="de4060842e9f284d70298a268fbe7633a8243e81" translate="yes" xml:space="preserve">
          <source>scope.get()</source>
          <target state="translated">scope.get()</target>
        </trans-unit>
        <trans-unit id="1591ae4b198edf6f9620668e97f994bf4cae30d6" translate="yes" xml:space="preserve">
          <source>scope.register()</source>
          <target state="translated">scope.register()</target>
        </trans-unit>
        <trans-unit id="365abe542cc145e8760e0e0900dae32083ca97bd" translate="yes" xml:space="preserve">
          <source>setup: start other services,</source>
          <target state="translated">setup:他のサービスを開始します。</target>
        </trans-unit>
        <trans-unit id="9d0be451884e0a33ad114f81a23f503cd1b10777" translate="yes" xml:space="preserve">
          <source>spawn()</source>
          <target state="translated">スポーン()</target>
        </trans-unit>
        <trans-unit id="2e0c9f4b78d08d11496b33a2fc91d961531be91b" translate="yes" xml:space="preserve">
          <source>srv</source>
          <target state="translated">寂寥感</target>
        </trans-unit>
        <trans-unit id="bff8141be3b6c225d8136650e66758e745231248" translate="yes" xml:space="preserve">
          <source>srv = await
service(name, some_service, *params)</source>
          <target state="translated">srv=await service(name,some_service,*params)</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
