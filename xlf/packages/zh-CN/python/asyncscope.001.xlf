<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://pypi.org/project/asyncscope/">
    <body>
      <group id="asyncscope">
        <trans-unit id="80e2beb36491b20581dbcedf302120f4e7151f17" translate="yes" xml:space="preserve">
          <source>&amp;ldquo;Clean termination&amp;rdquo; means that the scope&amp;rsquo;s call to</source>
          <target state="translated">&amp;ldquo;清除终止&amp;rdquo;是指示波器对</target>
        </trans-unit>
        <trans-unit id="a77cb6b5652c4005532755d55df9906e50c68b74" translate="yes" xml:space="preserve">
          <source>&amp;rsquo;s global</source>
          <target state="translated">的全球</target>
        </trans-unit>
        <trans-unit id="947cab548ff029f91ef570a175d1383baf0a5828" translate="yes" xml:space="preserve">
          <source>(subordinate task) or wait for SIGTERM (daemon main task)
or terminate (main task&amp;rsquo;s job is done)</source>
          <target state="translated">（下级任务）或等待SIGTERM（守护程序主任务）或终止（完成主任务的工作）</target>
        </trans-unit>
        <trans-unit id="3a52ce780950d4d969792a2559cd519d7ee8c727" translate="yes" xml:space="preserve">
          <source>.</source>
          <target state="translated">。</target>
        </trans-unit>
        <trans-unit id="9e3edd5906a2460bab23ca2086bbd93812e1625e" translate="yes" xml:space="preserve">
          <source>. This function returns the new tasks&amp;rsquo;s cancel scope so that you
can cancel the new task if you need to. All tasks started that way are
auto-cancelled when your main code exits.</source>
          <target state="translated">。此函数返回新任务的取消范围，以便您可以根据需要取消新任务。当您的主要代码退出时，以这种方式启动的所有任务都会自动取消。</target>
        </trans-unit>
        <trans-unit id="b54ad0f09fdbeb343c772bec07e2001d8693d217" translate="yes" xml:space="preserve">
          <source>A scope&amp;rsquo;s main code typically looks like this:</source>
          <target state="translated">范围的主要代码通常如下所示：</target>
        </trans-unit>
        <trans-unit id="6f7fcc06f5a43a47848f403f55c311da91fec7d8" translate="yes" xml:space="preserve">
          <source>Alternately, if the service is created by an async context manager:</source>
          <target state="translated">另外,如果服务是由异步上下文管理器创建的。</target>
        </trans-unit>
        <trans-unit id="d3a30a245e5eb40f2058c501aadf106d3644b773" translate="yes" xml:space="preserve">
          <source>Another part of your program also needs the error handler database
connections and loading a handler are expensive, so you want to re-use
them.</source>
          <target state="translated">你的程序的另一部分也需要错误处理程序数据库连接和加载处理程序是很昂贵的,所以你要重复使用它们。</target>
        </trans-unit>
        <trans-unit id="1264ac5499d19a2dc2fda3977b57eb2f7ced1f68" translate="yes" xml:space="preserve">
          <source>AsyncScope can help you.</source>
          <target state="translated">AsyncScope可以帮助你。</target>
        </trans-unit>
        <trans-unit id="096c62d357c259f713d3671465a274cf7b4ecf8e" translate="yes" xml:space="preserve">
          <source>AsyncScope keeps track of your program&amp;rsquo;s building blocks. It remembers
which parts depend on which other parts, prevents cyclic dependencies,
and terminates a scope as soon as nobody uses it any more.</source>
          <target state="translated">AsyncScope跟踪程序的构造块。它记住哪些部分取决于其他部分，防止循环依赖性，并在没有人使用它时立即终止作用域。</target>
        </trans-unit>
        <trans-unit id="59b0482bdded1133e8a5fead2d8afd30f974346d" translate="yes" xml:space="preserve">
          <source>Cancellation semantics</source>
          <target state="translated">取消语义</target>
        </trans-unit>
        <trans-unit id="c6a3981c0605028beccb698a3439ee4282147add" translate="yes" xml:space="preserve">
          <source>Code structure</source>
          <target state="translated">代码结构</target>
        </trans-unit>
        <trans-unit id="aeaea4443a2ba13db76c47382325d4718b4ff08c" translate="yes" xml:space="preserve">
          <source>Every scope has a separate taskgroup which you can access by calling</source>
          <target state="translated">每个作用域都有一个单独的任务组,您可以通过调用</target>
        </trans-unit>
        <trans-unit id="751c68a3471b1c791efaee0a8e7c24ea0c266efd" translate="yes" xml:space="preserve">
          <source>If</source>
          <target state="translated">如果</target>
        </trans-unit>
        <trans-unit id="e6f0de840ad4353a783325b26597620059fe57d4" translate="yes" xml:space="preserve">
          <source>Large programs often consist of building blocks which depend on each other.
Those dependencies may be non-trivial, aren&amp;rsquo;t always linear, and generally
form some sort of directed acyclic graph instead of a nice linear or
hierarchical set of relationships.</source>
          <target state="translated">大型程序通常由相互依赖的构建块组成。这些依赖关系可能是不平凡的，并不总是线性的，并且通常形成某种有向无环图，而不是良好的线性或层次关系集。</target>
        </trans-unit>
        <trans-unit id="dc6898c4cf754556aa24ff98774c9a7b8b48737e" translate="yes" xml:space="preserve">
          <source>Later the admin code terminates. It can&amp;rsquo;t unload the error handler because
that other code still needs it.</source>
          <target state="translated">稍后，管理代码终止。它无法卸载错误处理程序，因为其他代码仍然需要它。</target>
        </trans-unit>
        <trans-unit id="2826b3b8d53942e914dd917cc08e57bfef8efe4d" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s invent an example.</source>
          <target state="translated">让我们发明一个例子。</target>
        </trans-unit>
        <trans-unit id="4835fbb132d02a0d1324d266ab9d295c5a2c2a3b" translate="yes" xml:space="preserve">
          <source>Now your error handler stays around exactly as long as you need it, your
database connection won&amp;rsquo;t die while the error handler (or any other code,
for that matter) requires it, your error gets logged correctly, and you
find the problem easily.</source>
          <target state="translated">现在，您的错误处理程序会停留在您所需的时间范围内，当错误处理程序（或其他任何代码）需要它时，数据库连接也不会死，您的错误被正确记录，并且您可以轻松地找到问题。</target>
        </trans-unit>
        <trans-unit id="98365abf7a35b55e3b549f20aa17daee9fe3c995" translate="yes" xml:space="preserve">
          <source>Rationale</source>
          <target state="translated">理由</target>
        </trans-unit>
        <trans-unit id="7e42e371e1139786764c46314b85ef21b7a750d7" translate="yes" xml:space="preserve">
          <source>Scopes typically don&amp;rsquo;t need to access its own scope object. It&amp;rsquo;s stored in
a contextvar and can be retrieved via</source>
          <target state="translated">范围通常不需要访问其自己的范围对象。它存储在contextvar中，可以通过以下方式检索</target>
        </trans-unit>
        <trans-unit id="2507c2b55d5db39a9f83e01f96320bf24ea1b23a" translate="yes" xml:space="preserve">
          <source>Start a service task (i.e. something you depend on) with</source>
          <target state="translated">启动一个服务任务(即您所依赖的东西),并使用</target>
        </trans-unit>
        <trans-unit id="674c454ba310e310a32c1322e2e45801d1bb9239" translate="yes" xml:space="preserve">
          <source>TODO: write a service which your code can use to keep another service alive
for a bit.</source>
          <target state="translated">TODO:写一个服务,你的代码可以用它来让另一个服务存活一下。</target>
        </trans-unit>
        <trans-unit id="6c1e956d40870f2b75767e81f9483d9dda74fe72" translate="yes" xml:space="preserve">
          <source>Task scopes for AnyIO</source>
          <target state="translated">AnyIO的任务范围</target>
        </trans-unit>
        <trans-unit id="93ef0dd827103681fcee453b78be2ff14e1a261d" translate="yes" xml:space="preserve">
          <source>The</source>
          <target state="translated">The</target>
        </trans-unit>
        <trans-unit id="36e03547626d68a092132496f04f21d59aeb8d83" translate="yes" xml:space="preserve">
          <source>The current scope is available as the</source>
          <target state="translated">当前的作用域是以</target>
        </trans-unit>
        <trans-unit id="125c5e78921cb603c94d4f0c951d3ab16641dddf" translate="yes" xml:space="preserve">
          <source>The service&amp;rsquo;s setup code typically looks like this:</source>
          <target state="translated">该服务的设置代码通常如下所示：</target>
        </trans-unit>
        <trans-unit id="641fa6952b7f92fe6e90337e9bdda258ee4ff9af" translate="yes" xml:space="preserve">
          <source>This also happens when a scope&amp;rsquo;s main task ends.</source>
          <target state="translated">当合并范围的主要任务结束时，也会发生这种情况。</target>
        </trans-unit>
        <trans-unit id="8a3cc2e8c196435d99f13f9317c2637176c56fc5" translate="yes" xml:space="preserve">
          <source>This is a problem because you like to use Structured Programming
principles. Thus you need to jump through interesting hoops getting all of
this connected up and keeping track of each module&amp;rsquo;s users.</source>
          <target state="translated">这是一个问题，因为您喜欢使用结构化编程原理。因此，您需要跳过有趣的圈，将所有这些连接起来，并跟踪每个模块的用户。</target>
        </trans-unit>
        <trans-unit id="85c3cae45815aa53d8bdc35b0cd38e9e00c3fae1" translate="yes" xml:space="preserve">
          <source>This library implements scoped taskgroups / nurseries.</source>
          <target state="translated">这个库实现了范围内的任务组/苗圃。</target>
        </trans-unit>
        <trans-unit id="0bb18642b70b9f8a9c12ccf39487328f306b8e19" translate="yes" xml:space="preserve">
          <source>Usage</source>
          <target state="translated">使用方法</target>
        </trans-unit>
        <trans-unit id="711e7706d1362390d17b75a0e39f6c52a84dafe5" translate="yes" xml:space="preserve">
          <source>When a scope exits (either cleanly or when it raises an error that escapes
its taskgroup), all scopes depending on it are cancelled immediately, in
parallel. Then those it itself depends on are terminated cleanly and
in-order.</source>
          <target state="translated">当一个作用域退出时(无论是干净地退出,还是当它引发一个逃出其任务组的错误时),所有依赖于它的作用域都会被立即并行地取消。然后,它自己所依赖的那些作用域也会按顺序被干净地终止。</target>
        </trans-unit>
        <trans-unit id="88d45e6a980f0df68d27ce165ed197e0a5665884" translate="yes" xml:space="preserve">
          <source>Worse, assume that your code dies with a fatal exception. The exception
typically propagates through your code and cancels the database connection
before the error handler has a chance to log the problem. This happens
randomly, depending on which cancelled task runs first, so you have a lot
of fun trying to reproduce the problem and debug all of this.</source>
          <target state="translated">更糟糕的是,假设你的代码死于一个致命的异常。异常通常会在你的代码中传播,并在错误处理程序有机会记录问题之前取消数据库连接。这种情况是随机发生的,取决于哪个被取消的任务先运行,所以你在试图重现问题和调试这一切的时候会有很多乐趣。</target>
        </trans-unit>
        <trans-unit id="a2268d48cac5e24ed6c2d566336bdb20614f616f" translate="yes" xml:space="preserve">
          <source>Wrap your main code in</source>
          <target state="translated">将你的主代码封装在</target>
        </trans-unit>
        <trans-unit id="0d518b326eb1f8e7dd14bb6dacd324e99b66610e" translate="yes" xml:space="preserve">
          <source>Your main code runs some admin module, which requires a support library,
which connects to a database. Halfway through it encounters an error, thus
loads an error handler, which also uses the database.</source>
          <target state="translated">你的主代码运行一些管理模块,它需要一个支持库,它连接到一个数据库。中途遇到了一个错误,因此加载了一个错误处理程序,它也使用了数据库。</target>
        </trans-unit>
        <trans-unit id="1119e4e9e700cfa21cbdc86bfd28782fd00e25c5" translate="yes" xml:space="preserve">
          <source>Your service &lt;strong&gt;must&lt;/strong&gt; call</source>
          <target state="translated">您的服务&lt;strong&gt;必须&lt;/strong&gt;致电</target>
        </trans-unit>
        <trans-unit id="3a717f099d0f0afdd183e5fe1e60a3b2d4be0eb4" translate="yes" xml:space="preserve">
          <source>async with main_scope(): ...</source>
          <target state="translated">async with main_scope():...</target>
        </trans-unit>
        <trans-unit id="b72db8dc97d16fc439c9e88e0ec58e8077ef01ab" translate="yes" xml:space="preserve">
          <source>asyncscope</source>
          <target state="translated">同步范围</target>
        </trans-unit>
        <trans-unit id="20a233212a0283598b8ad388f4dfb864f5ebd77c" translate="yes" xml:space="preserve">
          <source>await no_more_dependents()</source>
          <target state="translated">await no_more_dependents()</target>
        </trans-unit>
        <trans-unit id="aa2798085d2c659cfb598dd371714e356971dc0f" translate="yes" xml:space="preserve">
          <source>call &amp;ldquo;register(serice_object)&amp;rdquo;</source>
          <target state="translated">称为&amp;ldquo; register（serice_object）&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="c0720160b6469d73b573d17b9baa627ef8a4dbda" translate="yes" xml:space="preserve">
          <source>cleanly stop itself</source>
          <target state="translated">自止</target>
        </trans-unit>
        <trans-unit id="24594bf61f7292e625c39f9e5b1f6322ddfa99f4" translate="yes" xml:space="preserve">
          <source>context variable.</source>
          <target state="translated">语境变量。</target>
        </trans-unit>
        <trans-unit id="bc884f7b9dec3f520e2cec89e0cb4fab48854777" translate="yes" xml:space="preserve">
          <source>directory contains some sample code.</source>
          <target state="translated">目录中包含一些示例代码。</target>
        </trans-unit>
        <trans-unit id="0377f9ae43f8abfdfef3cb8a30fc7ffb76e6c7e1" translate="yes" xml:space="preserve">
          <source>exactly once,
otherwise the scopes waiting for it to start will wait forever. (They&amp;rsquo;ll
get cancelled if your scope&amp;rsquo;s main task exits before doing so.)</source>
          <target state="translated">正好一次，否则等待它启动的作用域将永远等待。（如果在执行此操作之前退出示波器的主要任务，它们将被取消。）</target>
        </trans-unit>
        <trans-unit id="99345ce680cd3e48acdb9ab4212e4bd9bf9358b7" translate="yes" xml:space="preserve">
          <source>examples</source>
          <target state="translated">例子</target>
        </trans-unit>
        <trans-unit id="18cec78ad75ad5bc21fe0afbd305a42d810df378" translate="yes" xml:space="preserve">
          <source>if you need it.
For most uses, however,</source>
          <target state="translated">如果你需要它。但对于大多数用途来说,。</target>
        </trans-unit>
        <trans-unit id="ddc0b76895c74c93ff932eab9b3a373a77695d03" translate="yes" xml:space="preserve">
          <source>is not used, the scope will be cancelled.</source>
          <target state="translated">不使用,范围将被取消。</target>
        </trans-unit>
        <trans-unit id="dde037b9ca7ec60bc5542d1cd1dfcf993a27956c" translate="yes" xml:space="preserve">
          <source>is whatever object the service
intends you to use.</source>
          <target state="translated">是服务想让你使用的任何对象。</target>
        </trans-unit>
        <trans-unit id="8e8d640d4780daa9d1e2d50f79d823d1725ac844" translate="yes" xml:space="preserve">
          <source>no_more_dependents</source>
          <target state="translated">no_more_dependents</target>
        </trans-unit>
        <trans-unit id="b28688d24af9e039e2c7a373b5e70a234fd7bff1" translate="yes" xml:space="preserve">
          <source>no_more_dependents()</source>
          <target state="translated">no_more_dependents()</target>
        </trans-unit>
        <trans-unit id="1b8609b64802c1e1e712fe0688541bad04cde071" translate="yes" xml:space="preserve">
          <source>object accesses
the current scope transparently.</source>
          <target state="translated">对象透明地访问当前作用域。</target>
        </trans-unit>
        <trans-unit id="a34d3973aa4a92dce9223ea3cbe7510703eadfdf" translate="yes" xml:space="preserve">
          <source>returns. If there is no such call, the scope&amp;rsquo;s tasks are cancelled.</source>
          <target state="translated">返回。如果没有此类调用，则取消示波器的任务。</target>
        </trans-unit>
        <trans-unit id="aacd3103f3f1fcab0248f041a315ab6816c8a0e9" translate="yes" xml:space="preserve">
          <source>scope</source>
          <target state="translated">范围</target>
        </trans-unit>
        <trans-unit id="de4060842e9f284d70298a268fbe7633a8243e81" translate="yes" xml:space="preserve">
          <source>scope.get()</source>
          <target state="translated">scope.get()</target>
        </trans-unit>
        <trans-unit id="1591ae4b198edf6f9620668e97f994bf4cae30d6" translate="yes" xml:space="preserve">
          <source>scope.register()</source>
          <target state="translated">scope.register()</target>
        </trans-unit>
        <trans-unit id="365abe542cc145e8760e0e0900dae32083ca97bd" translate="yes" xml:space="preserve">
          <source>setup: start other services,</source>
          <target state="translated">设置:启动其他服务。</target>
        </trans-unit>
        <trans-unit id="9d0be451884e0a33ad114f81a23f503cd1b10777" translate="yes" xml:space="preserve">
          <source>spawn()</source>
          <target state="translated">spawn()</target>
        </trans-unit>
        <trans-unit id="2e0c9f4b78d08d11496b33a2fc91d961531be91b" translate="yes" xml:space="preserve">
          <source>srv</source>
          <target state="translated">赡养费</target>
        </trans-unit>
        <trans-unit id="bff8141be3b6c225d8136650e66758e745231248" translate="yes" xml:space="preserve">
          <source>srv = await
service(name, some_service, *params)</source>
          <target state="translated">srv=await service(name,some_service,*params)</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
