<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://pypi.org/project/multi-registry/">
    <body>
      <group id="multi-registry">
        <trans-unit id="719ae988f7aa1b855033df6ed335c38abf591269" translate="yes" xml:space="preserve">
          <source>&amp;gt;&amp;gt;&amp;gt;r = MultiRegistry()</source>
          <target state="translated">&amp;gt;&amp;gt;&amp;gt; r = MultiRegistry（）</target>
        </trans-unit>
        <trans-unit id="677598520fbe1496d80691d0dce525b8222ce8d1" translate="yes" xml:space="preserve">
          <source>&amp;gt;&amp;gt;&amp;gt;r = MultiRegistry(A, B, 'some.registry.C')</source>
          <target state="translated">&amp;gt;&amp;gt;&amp;gt; r = MultiRegistry（A，B，'some.registry.C'）</target>
        </trans-unit>
        <trans-unit id="cfb75262382d2b1f94d25a7a0a3e0a715fb59cc9" translate="yes" xml:space="preserve">
          <source>&amp;gt;&amp;gt;&amp;gt;r.append(A)</source>
          <target state="translated">&amp;gt;&amp;gt;&amp;gt; r.append（A）</target>
        </trans-unit>
        <trans-unit id="7173517702ed62a5bd7f6d01c38ca90849c4c666" translate="yes" xml:space="preserve">
          <source>&amp;gt;&amp;gt;&amp;gt;r.append(B)</source>
          <target state="translated">&amp;gt;&amp;gt;&amp;gt; r.append（B）</target>
        </trans-unit>
        <trans-unit id="55440ff0babf76397cbb2d847f3793c244a0c73e" translate="yes" xml:space="preserve">
          <source>&amp;gt;&amp;gt;&amp;gt;r.insert(2, 'some.registry.C')</source>
          <target state="translated">&amp;gt;&amp;gt;&amp;gt; r.insert（2，'some.registry.C'）</target>
        </trans-unit>
        <trans-unit id="534263b055901edb4717e6d30836b4048c9a824f" translate="yes" xml:space="preserve">
          <source>* order of ``append()`` calls.</source>
          <target state="translated">*``append（）``调用的顺序。</target>
        </trans-unit>
        <trans-unit id="acd3f9857b53b6f787fc39b06c6a5ff9fa06e6d7" translate="yes" xml:space="preserve">
          <source>* order the registries were provided at the object initialization</source>
          <target state="translated">*命令在对象初始化时提供注册表</target>
        </trans-unit>
        <trans-unit id="1991543999798d865b1b018d89fcc07168e92043" translate="yes" xml:space="preserve">
          <source>* taking into account indices provided with ``insert()`` call</source>
          <target state="translated">*考虑到``insert（）``调用提供的索引</target>
        </trans-unit>
        <trans-unit id="1dff53afa2a7b7a3f94dcd2842f3dfe0d65a5128" translate="yes" xml:space="preserve">
          <source>.. note::</source>
          <target state="translated">.. 注意：：</target>
        </trans-unit>
        <trans-unit id="f401a3ff303f2801cfdf87f2b59288c241bd6ad4" translate="yes" xml:space="preserve">
          <source>A module that aggregates key-value attributes from multiple sources</source>
          <target state="translated">从多个来源汇总键值属性的模块。</target>
        </trans-unit>
        <trans-unit id="1af72887a096114e484cd78a9cb1a94838c45598" translate="yes" xml:space="preserve">
          <source>Allows to aggregate key-value data from many sources.</source>
          <target state="translated">允许从多个来源汇总键值数据。</target>
        </trans-unit>
        <trans-unit id="7299ed38e4218a1bdb2603f98aa3e65d8430b7e1" translate="yes" xml:space="preserve">
          <source>Can be used, for example, as a proxy to settings object in Django framework.</source>
          <target state="translated">例如,可以作为Django框架中设置对象的代理。</target>
        </trans-unit>
        <trans-unit id="b5846852fb185992b105cf5ea00dbb901127f99f" translate="yes" xml:space="preserve">
          <source>For example, if we have two settings like objects:</source>
          <target state="translated">例如,如果我们有两个设置,如对象。</target>
        </trans-unit>
        <trans-unit id="330c5f67e32dbcdbbf08c7190eda8255ede7f97f" translate="yes" xml:space="preserve">
          <source>If the attribute is not found, attribute error will be</source>
          <target state="translated">如果找不到属性,属性错误将是</target>
        </trans-unit>
        <trans-unit id="418ab01a05e05f5e1be2594abe5836ec257d227a" translate="yes" xml:space="preserve">
          <source>If there is an attribute present in more than one appended object,</source>
          <target state="translated">如果有一个属性存在于一个以上的附加对象中。</target>
        </trans-unit>
        <trans-unit id="360ba8c15a8223a576246892d638cf3e1d05a785" translate="yes" xml:space="preserve">
          <source>The registries can be provided as python objects or</source>
          <target state="translated">注册表可以以python对象或</target>
        </trans-unit>
        <trans-unit id="fc86211a1d0abd09a625bcfe1a5da460f528d7ca" translate="yes" xml:space="preserve">
          <source>The sources of key-value data are appended to :class:`MultiRegistry`</source>
          <target state="translated">键值数据的来源附加到:class:`MultiRegistry`。</target>
        </trans-unit>
        <trans-unit id="c5b05202105d22280e18cada8f7f37ac1fade741" translate="yes" xml:space="preserve">
          <source>Upon access, attributes will be looked up in the parent objects</source>
          <target state="translated">访问时,将在父对象中查找属性</target>
        </trans-unit>
        <trans-unit id="1502b3370b27ea91e078983ba91aee9d649aa9cc" translate="yes" xml:space="preserve">
          <source>``A`` with attribute ``a``</source>
          <target state="translated">属性为a的A</target>
        </trans-unit>
        <trans-unit id="eeeb5e115c6ff6a6e9f0606d018b4e9595c8d1eb" translate="yes" xml:space="preserve">
          <source>and ``B`` with attribute ``b``</source>
          <target state="translated">和属性为``b``的``B``。</target>
        </trans-unit>
        <trans-unit id="d2fd0cbc491c80084500e9233bab85441c052afa" translate="yes" xml:space="preserve">
          <source>and a third one, found in module importable from ``'some.registry.C'``,</source>
          <target state="translated">第三种是在``''some.registry.C'``中可导入的模块中找到的。</target>
        </trans-unit>
        <trans-unit id="df0a06b3a0f58af6d65c0bc3e9e2cb555e514462" translate="yes" xml:space="preserve">
          <source>be raised if module at the path does not exist</source>
          <target state="translated">如果路径上的模块不存在,则会被触发。</target>
        </trans-unit>
        <trans-unit id="94971d32425e02e6154c63a4a4d3c2e40f5b531e" translate="yes" xml:space="preserve">
          <source>dotted notation, as explained in more detail below.</source>
          <target state="translated">虚线符号,下文将详细解释。</target>
        </trans-unit>
        <trans-unit id="3f12d38957261e8d95b9f91465adc70543616394" translate="yes" xml:space="preserve">
          <source>dotted python paths. In the latter case an import error will</source>
          <target state="translated">虚线的python路径。在后一种情况下,导入错误将</target>
        </trans-unit>
        <trans-unit id="512f7f0c07df580134f76435ed1f857abe4f9bc6" translate="yes" xml:space="preserve">
          <source>in the order the latter were appended.</source>
          <target state="translated">按后者的顺序排列。</target>
        </trans-unit>
        <trans-unit id="9612c50b47a481c53a39b65625075fa440ca332e" translate="yes" xml:space="preserve">
          <source>it will be found.</source>
          <target state="translated">它将被发现。</target>
        </trans-unit>
        <trans-unit id="c6b08100abcdab1cf09ffff8a534795c812a26e7" translate="yes" xml:space="preserve">
          <source>or alternatively:</source>
          <target state="translated">或者:</target>
        </trans-unit>
        <trans-unit id="c20b0b65439f562fb67544e396af99806341f8d3" translate="yes" xml:space="preserve">
          <source>r.b - attrubute b will be first looked</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5d7563c36c87c47613a165bd59f6753a48550de" translate="yes" xml:space="preserve">
          <source>raised.</source>
          <target state="translated">提出。</target>
        </trans-unit>
        <trans-unit id="c9394ed7c47826281f1a98d025c6742eb7b5f933" translate="yes" xml:space="preserve">
          <source>registries are stored internally, which takes into account:</source>
          <target state="translated">注册表在内部存储,其中考虑到:</target>
        </trans-unit>
        <trans-unit id="d35b46a753cf7292214c0a1cc5d77e8c4d423fc5" translate="yes" xml:space="preserve">
          <source>the first one will be returned - in the same order the</source>
          <target state="translated">第一个将被返回--与</target>
        </trans-unit>
        <trans-unit id="5d94299f8576ec5ee49eb8e7775a8b891c7f0cab" translate="yes" xml:space="preserve">
          <source>then access the registry as:</source>
          <target state="translated">然后以下列方式访问注册表:</target>
        </trans-unit>
        <trans-unit id="999f43a53e7fbbec92a3b62e760cfd030b63fd38" translate="yes" xml:space="preserve">
          <source>up in the object A, then in the object B, where</source>
          <target state="translated">在对象A中上升,然后在对象B中上升,其中的</target>
        </trans-unit>
        <trans-unit id="878b93bc71647f53572380b8fa9840aedb62764a" translate="yes" xml:space="preserve">
          <source>vi ``append()`` method, then looked up via standard Python</source>
          <target state="translated">vi ``append()``方法,然后通过标准的Python查找</target>
        </trans-unit>
        <trans-unit id="b7d38a5f587e50e0769d562c1c23867ca5dd37f5" translate="yes" xml:space="preserve">
          <source>we can construct the registry as:</source>
          <target state="translated">我们可以将注册表构造为:</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
