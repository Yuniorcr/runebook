<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://pypi.org/project/ctinker/">
    <body>
      <group id="ctinker">
        <trans-unit id="cee4558221adcab19d9848dabd5a722aaaa2ed45" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;CTinker&lt;/code&gt; is capable of getting in the middle of virtually any build process by:</source>
          <target state="translated">&lt;code&gt;CTinker&lt;/code&gt; 能够通过以下方式进入几乎所有构建过程的中间：</target>
        </trans-unit>
        <trans-unit id="d4be7dd37d857b4f4a77721a1fb365ec77bd3f49" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;C Tinker&lt;/strong&gt;, pronounced &lt;em&gt;see-tinker&lt;/em&gt; (or humorously &quot;stinker&quot;, as suggested by
&lt;a href=&quot;https://github.com/ocheret&quot;&gt;Chuck Ocheret&lt;/a&gt;) allows you to get in the middle of the build process of a
make/Ninja-style project and augment the compilation and linking as well as extract and redirect artifacts using
policies you can't implement otherwise even with LDFLAGS/CFLAGS magic.</source>
          <target state="translated">&lt;strong&gt;C Tinker&lt;/strong&gt;，发音为&lt;em&gt;see-tinker&lt;/em&gt;（或&lt;a href=&quot;https://github.com/ocheret&quot;&gt;Chuck Ocheret&lt;/a&gt;所建议的幽默的&amp;ldquo;臭味&amp;rdquo; ），使您可以进入make / Ninja风格项目的构建过程的中间，并增强编译和链接以及提取和提取。使用LDFLAGS / CFLAGS魔术，使用您无法实现的策略来重定向工件。</target>
        </trans-unit>
        <trans-unit id="b1a8f2af082da0e64e0f6efd4f4818db6b61c01a" translate="yes" xml:space="preserve">
          <source>As a further illustration, if the original process invocation chain for a sample build is as follows:</source>
          <target state="translated">再举例说明,如果一个样本构建的原始进程调用链如下。</target>
        </trans-unit>
        <trans-unit id="8f7b8db04007ab4e6cb522976d9fad3475938b3f" translate="yes" xml:space="preserve">
          <source>Being invoked for each tool invocation in a &lt;code&gt;worker&lt;/code&gt; mode (based on environmental variables),
communicating with the &lt;code&gt;supervisor&lt;/code&gt;, sending command-line arguments to the &lt;code&gt;supervisor&lt;/code&gt; process and then
invoking the tool itself.</source>
          <target state="translated">在 &lt;code&gt;worker&lt;/code&gt; 模式（基于环境变量）中为每次工具调用而被调用，与 &lt;code&gt;supervisor&lt;/code&gt; 通信，将命令行参数发送给 &lt;code&gt;supervisor&lt;/code&gt; 进程，然后调用工具本身。</target>
        </trans-unit>
        <trans-unit id="45f892e57440dc6c011ce74aa8bafde4a8414521" translate="yes" xml:space="preserve">
          <source>CTinker - C/C++ Project Introspection and Augmentation Tool</source>
          <target state="translated">CTinker-C/C++项目自省和增强工具。</target>
        </trans-unit>
        <trans-unit id="7661ba55453b25e5a4a35c5bd413a649b654e8fa" translate="yes" xml:space="preserve">
          <source>CTinker is a C project introspection and augmentation tool</source>
          <target state="translated">CTinker是一个C项目反省和增强工具。</target>
        </trans-unit>
        <trans-unit id="611f6daef3d61f0ff9fdc4a77292e4a5970e7bb8" translate="yes" xml:space="preserve">
          <source>Creating a temporary directory full of toolkit-specific (e.g. for LLVM Clang it's &lt;code&gt;clang&lt;/code&gt;, &lt;code&gt;ar&lt;/code&gt; etc)
symlinks referring back to &lt;code&gt;CTinker&lt;/code&gt; executable.</source>
          <target state="translated">创建一个充满了特定于工具箱的临时目录（例如，对于LLVM Clang它是 &lt;code&gt;clang&lt;/code&gt; ， &lt;code&gt;ar&lt;/code&gt; 等），这些符号链接指的是 &lt;code&gt;CTinker&lt;/code&gt; 可执行文件。</target>
        </trans-unit>
        <trans-unit id="0f01ed56a1e32a05e5ef96e4d779f34784af9a96" translate="yes" xml:space="preserve">
          <source>Example</source>
          <target state="translated">例子</target>
        </trans-unit>
        <trans-unit id="c47ae15370cfe1ed2781eedc1dc2547d12d9e972" translate="yes" xml:space="preserve">
          <source>Help</source>
          <target state="translated">帮忙</target>
        </trans-unit>
        <trans-unit id="e230b4612943b3fee8bed470ec510d31f987ca01" translate="yes" xml:space="preserve">
          <source>I need to get in the middle of a build process of a project I can know intimately but do not control
and that I have no intention of maintaining a fork/patches for, or for which I need to obtain runtime
dynamic control of the build process.</source>
          <target state="translated">我需要进入一个项目的构建过程中,我可以密切了解但无法控制,而且我不打算为其维护一个分叉/补丁,或者我需要获得构建过程的运行时动态控制。</target>
        </trans-unit>
        <trans-unit id="a7c7003f41154bf59e66e5ddd53746641e5a73d4" translate="yes" xml:space="preserve">
          <source>If specified, invoking &lt;code&gt;scripting&lt;/code&gt; handlers before and after the build as a whole (in the &lt;code&gt;supervisor&lt;/code&gt;)
and before and after each intercepted tool invocation (in the &lt;code&gt;worker&lt;/code&gt;).</source>
          <target state="translated">如果指定，则在整个构建之前和之后（在 &lt;code&gt;supervisor&lt;/code&gt; ）以及在每次拦截的工具调用之前和之后（在 &lt;code&gt;worker&lt;/code&gt; 中）调用 &lt;code&gt;scripting&lt;/code&gt; 处理程序。</target>
        </trans-unit>
        <trans-unit id="e14c1358024a39bc8a17ea229eea7c677186beef" translate="yes" xml:space="preserve">
          <source>Invoking the build process as specified by the user.</source>
          <target state="translated">调用用户指定的构建过程。</target>
        </trans-unit>
        <trans-unit id="4c083951aea114db79b695e69826f30d7a158cf2" translate="yes" xml:space="preserve">
          <source>It is guaranteed that &lt;code&gt;ctinker_start&lt;/code&gt; - &lt;code&gt;ctinker_finish&lt;/code&gt; and &lt;code&gt;ctinker_before_tool&lt;/code&gt; - &lt;code&gt;ctinker_after_tool&lt;/code&gt; pairs will
be executed in the same &lt;code&gt;supervisor&lt;/code&gt; and &lt;code&gt;worker&lt;/code&gt; processes &lt;em&gt;respectively&lt;/em&gt; and therefore you can pass values between
the start/finish and before/after functions (for example by a global or within the same instance of an object).</source>
          <target state="translated">这是保证 &lt;code&gt;ctinker_start&lt;/code&gt; - &lt;code&gt;ctinker_finish&lt;/code&gt; 和 &lt;code&gt;ctinker_before_tool&lt;/code&gt; - &lt;code&gt;ctinker_after_tool&lt;/code&gt; 对将在同一执行 &lt;code&gt;supervisor&lt;/code&gt; 和 &lt;code&gt;worker&lt;/code&gt; 进程&lt;em&gt;分别&lt;/em&gt;并因此可以由全局或相同的实例内的开始/结束和前/后的功能（例如之间传递值对象）。</target>
        </trans-unit>
        <trans-unit id="b127eaa52b0044c93134cac365a89c16698e6291" translate="yes" xml:space="preserve">
          <source>More formally the problem &lt;strong&gt;CTinker&lt;/strong&gt; solves can be stated as follows:</source>
          <target state="translated">&lt;strong&gt;CTinker&lt;/strong&gt;解决的问题可以更正式地说如下：</target>
        </trans-unit>
        <trans-unit id="0efc2e6be4c23b9a513d7ce0dcff8ed80e8912e7" translate="yes" xml:space="preserve">
          <source>Overview</source>
          <target state="translated">概述</target>
        </trans-unit>
        <trans-unit id="774fec522beda5af3a1a17d19833e6b56fcc7eba" translate="yes" xml:space="preserve">
          <source>Printing to &lt;code&gt;sys.stdout&lt;/code&gt; from the &lt;code&gt;worker&lt;/code&gt; is dangerous as the stdout is often interpreted by the invoking tool
which can lead to a crash in the tool expecting certain data format. &lt;code&gt;print(&quot;debug!&quot;, file=sys.stderr)&lt;/code&gt; is generally
safe.</source>
          <target state="translated">从 &lt;code&gt;worker&lt;/code&gt; &lt;code&gt;sys.stdout&lt;/code&gt; 打印到sys.stdout很危险，因为调用工具通常会解释stdout，这可能会导致期望某些数据格式的工具崩溃。 &lt;code&gt;print(&quot;debug!&quot;, file=sys.stderr)&lt;/code&gt; 通常是安全的。</target>
        </trans-unit>
        <trans-unit id="1baa06b4c8bc2d63f9db4d4cc86a2e2b12a7e893" translate="yes" xml:space="preserve">
          <source>Problem</source>
          <target state="translated">问题</target>
        </trans-unit>
        <trans-unit id="7522becbe814d8b8cbc378f8930c8ca68bb2b8b5" translate="yes" xml:space="preserve">
          <source>Scripting</source>
          <target state="translated">脚本</target>
        </trans-unit>
        <trans-unit id="91146ee3bd4bd067d3589f2d17261dcb5f0642ce" translate="yes" xml:space="preserve">
          <source>Scripting is the most powerful part of &lt;code&gt;CTinker&lt;/code&gt; that provides an ability to really change how build functions
at runtime. It is implemented via a visitor pattern, invoking functions specified in the user-supplied script:</source>
          <target state="translated">脚本编写是 &lt;code&gt;CTinker&lt;/code&gt; 最强大的部分，它提供了在运行时真正改变构建函数方式的功能。它是通过访问者模式实现的，它调用了用户提供的脚本中指定的功能：</target>
        </trans-unit>
        <trans-unit id="7d35abde352ff3e67f5295268c2e4e0d394c89ea" translate="yes" xml:space="preserve">
          <source>Setting up environ and a local socket to communicate with the &lt;code&gt;workers&lt;/code&gt;.</source>
          <target state="translated">设置环境和本地套接字以与 &lt;code&gt;workers&lt;/code&gt; 进行通信。</target>
        </trans-unit>
        <trans-unit id="b4f91bdb0e1b0e40fff4debcd0fea22f1999f491" translate="yes" xml:space="preserve">
          <source>Solution</source>
          <target state="translated">解决办法</target>
        </trans-unit>
        <trans-unit id="85ff3c02942ec7b1321cb3c749a4a1a25edaec6a" translate="yes" xml:space="preserve">
          <source>Starting in the &lt;code&gt;supervisor&lt;/code&gt; mode.</source>
          <target state="translated">从 &lt;code&gt;supervisor&lt;/code&gt; 模式启动。</target>
        </trans-unit>
        <trans-unit id="9ac8af0e3202f4f96d6c5b701dbe9563d6abd4d9" translate="yes" xml:space="preserve">
          <source>TBW</source>
          <target state="translated">TBW</target>
        </trans-unit>
        <trans-unit id="285ec850c11d78bac10f6bfa31b69a37f1b257c9" translate="yes" xml:space="preserve">
          <source>Troubleshooting</source>
          <target state="translated">疑难解答</target>
        </trans-unit>
        <trans-unit id="6b2df7574f43d9cd7f0639cc019bc85ef4fce271" translate="yes" xml:space="preserve">
          <source>ctinker =&amp;gt; make =&amp;gt; ctinker-clang =&amp;gt; clang =&amp;gt; ctinker-lld =&amp;gt; lld, =&amp;gt; make =&amp;gt; ctinker-clang =&amp;gt; clang,
=&amp;gt; ctinker-clang =&amp;gt; clang =&amp;gt; ctinker-lld =&amp;gt; lld</source>
          <target state="translated">ctinker =&amp;gt; make =&amp;gt; ctinker-clang =&amp;gt; clang =&amp;gt; ctinker-lld =&amp;gt; lld，=&amp;gt; make =&amp;gt; ctinker-clang =&amp;gt; clang，=&amp;gt; ctinker-clang =&amp;gt; clang =&amp;gt; ctinker-lld =&amp;gt; lld</target>
        </trans-unit>
        <trans-unit id="b84d7c90d27ded663b935bf795fa8a6b36c73ff0" translate="yes" xml:space="preserve">
          <source>make =&amp;gt; clang =&amp;gt; lld, =&amp;gt; make =&amp;gt; clang, =&amp;gt; clang =&amp;gt; lld</source>
          <target state="translated">make =&amp;gt; clang =&amp;gt; lld，=&amp;gt; make =&amp;gt; clang，=&amp;gt; clang =&amp;gt; lld</target>
        </trans-unit>
        <trans-unit id="57beee9c14bbf9cd52f31f78522c6d9f9f7dc20c" translate="yes" xml:space="preserve">
          <source>then the same build instrumented with CTinker will produce the following process invocation chain:</source>
          <target state="translated">然后,用CTinker进行同样的构建,将产生以下进程调用链。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
