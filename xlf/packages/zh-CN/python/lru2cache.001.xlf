<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://pypi.org/project/lru2cache/">
    <body>
      <group id="lru2cache">
        <trans-unit id="6d6173d566ffb20c8641ba2752b927248f8ab6c3" translate="yes" xml:space="preserve">
          <source>, function arguments of different types will be
cached separately. For example, f(3) and f(3.0) will be treated as distinct
calls with distinct results.</source>
          <target state="translated">，不同类型的函数参数将分别缓存。例如，f（3）和f（3.0）将被视为具有不同结果的不同调用。</target>
        </trans-unit>
        <trans-unit id="7207846477fc222c6dd0427e85462ac564927fea" translate="yes" xml:space="preserve">
          <source>, the LRU feature is disabled and the L1 cache
can grow without bound. The LRU feature performs best when maxsize is a power-of-two.</source>
          <target state="translated">，则会禁用LRU功能，并且L1缓存可以无限增长。当maxsize为2的幂时，LRU功能表现最佳。</target>
        </trans-unit>
        <trans-unit id="d99d3502cdad96aa76d33d37c0cc8a9682cf6459" translate="yes" xml:space="preserve">
          <source>. These stats are stored within an instance, and therefore
are specific to that instance. Cumulative statistics for the shared cache would
need to be obtained from the shared cache.</source>
          <target state="translated">。这些统计信息存储在实例中，因此特定于该实例。共享缓存的累积统计信息将需要从共享缓存中获取。</target>
        </trans-unit>
        <trans-unit id="2be5d9e9d6ec5fbbfff0627d5ceb897a4d377376" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Local and Shared Cache&lt;/strong&gt; - Combining both types of cache is much more
effective than either used on it&amp;rsquo;s own.  The local cache eliminates the
latency of calls to a shared cache, while the shared cache eliminates
the expense of returning the result</source>
          <target state="translated">&lt;strong&gt;本地和共享缓存&lt;/strong&gt;-组合两种类型的缓存比单独使用两种缓存要有效得多。本地缓存消除了对共享缓存的调用的等待时间，而共享缓存消除了返回结果的开销</target>
        </trans-unit>
        <trans-unit id="3a61811019e173a17190bff6fd9ad90f453f5c97" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The Ability to Not Cache None Results&lt;/strong&gt; - This may seem like a minor thing
but in our environment it has greatly reduced the frequency of cache
invalidations.</source>
          <target state="translated">&lt;strong&gt;不缓存没有结果的能力&lt;/strong&gt;-这似乎是一件小事，但是在我们的环境中，它大大降低了缓存失效的频率。</target>
        </trans-unit>
        <trans-unit id="4d15addbdae92bf79453914d11dea5bbd5322f8d" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;http://en.wikipedia.org/wiki/Cache_algorithms#Least_Recently_Used&quot;&gt;least recently used (LRU)&lt;/a&gt;
2 layer caching mechanism based in part on the Python 2.7 back-port of</source>
          <target state="translated">甲&lt;a href=&quot;http://en.wikipedia.org/wiki/Cache_algorithms#Least_Recently_Used&quot;&gt;最近最少使用（LRU）&lt;/a&gt; 2层的缓存机制部分基于的Python 2.7版背面端口上</target>
        </trans-unit>
        <trans-unit id="3efcd57fb6b3d75f3484be9e543fff6a457c01c9" translate="yes" xml:space="preserve">
          <source>A least recently used (LRU) 2 layer caching mechanism based in part on the Python 2.7 back-port of lru_cache</source>
          <target state="translated">最近最少使用的(LRU)二层缓存机制,部分基于Python 2.7的后端lru_cache。</target>
        </trans-unit>
        <trans-unit id="32e4be867670ced87f1b50b35d669b04ce0f3a8b" translate="yes" xml:space="preserve">
          <source>A shared cache can easily be cleared with the following:</source>
          <target state="translated">共享缓存可以通过以下方法轻松清除。</target>
        </trans-unit>
        <trans-unit id="b6ad70fe8987a492b217f1d3fdc6bc56a8799161" translate="yes" xml:space="preserve">
          <source>Accessing the Function without Cache</source>
          <target state="translated">无缓存访问函数</target>
        </trans-unit>
        <trans-unit id="37e1c7c46791ba8b13b32bdb24bd8673a2f3fe3e" translate="yes" xml:space="preserve">
          <source>As a starting point I incorporated most of the tests for</source>
          <target state="translated">作为出发点,我将大部分的测试纳入了</target>
        </trans-unit>
        <trans-unit id="3938496e65e6dd032b899a42196062cb85acaa7a" translate="yes" xml:space="preserve">
          <source>As with lru_cache, one can view the cache statistics via a named tuple
(l1_hits, l1_misses, l2_hits, l2_misses, l1_maxsize, l1_currsize), with</source>
          <target state="translated">和lru_cache一样,可以通过一个命名的元组(l1_hits,l1_misses,l2_hits,l2_misses,l1_maxsize,l1_currsize)来查看缓存的统计信息,用</target>
        </trans-unit>
        <trans-unit id="6bbdf159e71b2fcdfa75bfaf3c0ec17a80b21b52" translate="yes" xml:space="preserve">
          <source>At &lt;a href=&quot;http://www.3top.com/&quot;&gt;3Top&lt;/a&gt; We needed a way to improve performance of
slow queries, not just those using the Django ORM, but also for queries to
other data stores and services.  We started off with a simpler centralized
caching solution using Memcached, but even those queries, when called frequently,
can start to cause delays.  Therefore we sought a means of caching at two layers.</source>
          <target state="translated">在&lt;a href=&quot;http://www.3top.com/&quot;&gt;3Top上，&lt;/a&gt;我们需要一种方法来提高慢速查询的性能，不仅是使用Django ORM的查询，而且还可以用于查询其他数据存储和服务。我们从使用Memcached的更简单的集中式缓存解决方案开始，但是即使频繁查询这些查询，也可能导致延迟。因此，我们寻求一种在两层进行缓存的方法。</target>
        </trans-unit>
        <trans-unit id="aeaf0e85f848b550a565ca5901e53d4306577d16" translate="yes" xml:space="preserve">
          <source>Background and Development</source>
          <target state="translated">背景和发展</target>
        </trans-unit>
        <trans-unit id="a086c0543fd27c08b64c003ddb4513c6845eb29a" translate="yes" xml:space="preserve">
          <source>Benefits Over functools.lru_cache</source>
          <target state="translated">比 functools.lru_cache 的优势</target>
        </trans-unit>
        <trans-unit id="d2469c2aa14798195f6bc3ae16fcf004712ca85e" translate="yes" xml:space="preserve">
          <source>Cache Management</source>
          <target state="translated">缓存管理</target>
        </trans-unit>
        <trans-unit id="35242c52a20b0f631fccc4a7c16ed23a76be06bd" translate="yes" xml:space="preserve">
          <source>Cache Statistics</source>
          <target state="translated">缓存统计</target>
        </trans-unit>
        <trans-unit id="53a0d2b5765f8ae251aea63864f78dac2259b0d7" translate="yes" xml:space="preserve">
          <source>Clearing Instance Cache</source>
          <target state="translated">清理实例缓存</target>
        </trans-unit>
        <trans-unit id="bf5dec3573c5a5d21ca6a1425613a8510bf9f271" translate="yes" xml:space="preserve">
          <source>Clearing Shared Cache</source>
          <target state="translated">清理共享缓存</target>
        </trans-unit>
        <trans-unit id="751c68a3471b1c791efaee0a8e7c24ea0c266efd" translate="yes" xml:space="preserve">
          <source>If</source>
          <target state="translated">如果</target>
        </trans-unit>
        <trans-unit id="95f76da19cad315076ccc2afaa0e41daf973ca96" translate="yes" xml:space="preserve">
          <source>If available this package will use SpookyHash V2 as a hashing mechanism.
Spooky is a good fast hashing algorithm that should be suitable for most uses.
If it is not available the package will fall back to SHA-256 from the standard
hashlib.  Because SHA-256 is a proper cryptographic hash it requires more
computation than Spooky.  To install spooky use pip:</source>
          <target state="translated">如果有的话,这个包将使用SpookyHash V2作为哈希机制。Spooky是一个很好的快速散列算法,应该适合大多数用途。如果它不可用,这个软件包将回到标准哈希lib的SHA-256。因为SHA-256是一个合适的加密哈希算法,它需要比Spooky更多的计算。要安装spooky,请使用pip。</target>
        </trans-unit>
        <trans-unit id="bd872a8af71a679a7a57ab648b7308f8099f311d" translate="yes" xml:space="preserve">
          <source>If you do not want to use either</source>
          <target state="translated">如果您不想使用任何一种</target>
        </trans-unit>
        <trans-unit id="f20cd38b0f0d290cf5aa2dda99bb5da47f90a908" translate="yes" xml:space="preserve">
          <source>Initially we looked at the possibility of using two different mechanisms but
we quickly saw the advantage of maintaining the same set of keys for both
caches and decided to create our own mechanism.</source>
          <target state="translated">最初我们研究了使用两种不同机制的可能性,但我们很快就看到了为两个缓存维护同一组密钥的优势,并决定创建我们自己的机制。</target>
        </trans-unit>
        <trans-unit id="debd19f419480deae2e24d7b2b4c8018a365b90e" translate="yes" xml:space="preserve">
          <source>Installation &amp;amp; Configuration</source>
          <target state="translated">安装与配置</target>
        </trans-unit>
        <trans-unit id="cc1093a96d4b2482bcaf84ac72db0fe4a89cb2c3" translate="yes" xml:space="preserve">
          <source>Invalidating Cached Results</source>
          <target state="translated">缓存结果无效</target>
        </trans-unit>
        <trans-unit id="6eef6648406c333a4035cd5e60d0bf2ecf2606d7" translate="yes" xml:space="preserve">
          <source>None</source>
          <target state="translated">なし</target>
        </trans-unit>
        <trans-unit id="5cfe5bbe5ae1dcb900a59525d853591e69656103" translate="yes" xml:space="preserve">
          <source>Once lru2cache is installed you will need to configure a shared cache as an
l2 cache.  If you are using Django your settings file will contain something
similar to the following in the settings file:</source>
          <target state="translated">一旦安装了lru2cache,你将需要配置一个共享缓存作为l2缓存。如果你使用的是Django,你的设置文件中会有类似下面的内容。</target>
        </trans-unit>
        <trans-unit id="5da6bc6ba91b6bc6224f81e28bb845e36941f36f" translate="yes" xml:space="preserve">
          <source>Refreshing the Cache</source>
          <target state="translated">刷新缓存</target>
        </trans-unit>
        <trans-unit id="3fc5f2545bc12aba6c4ecc7066bfa0304189551b" translate="yes" xml:space="preserve">
          <source>Since the lru2cache decorator does not provide a timeout for its cache although
it provides other mechanisms for programatically managing the cache.</source>
          <target state="translated">由于lru2cache decorator虽然提供了其他机制对缓存进行程序化管理,但并没有为其缓存提供超时。</target>
        </trans-unit>
        <trans-unit id="39fdec1194d94212b871a28b2aa04a73cd40fce1" translate="yes" xml:space="preserve">
          <source>Tests</source>
          <target state="translated">测试</target>
        </trans-unit>
        <trans-unit id="1d0165a592656f6dd286443745686b0cd7caff47" translate="yes" xml:space="preserve">
          <source>The easiest and best way to install this is with pip:</source>
          <target state="translated">最简单也是最好的安装方式是用pip。</target>
        </trans-unit>
        <trans-unit id="b4358f486357d25333aa98b7ac1dc2af818fc3e0" translate="yes" xml:space="preserve">
          <source>The first layer of caching is stored in a callable that wraps the function or
method.  As with &amp;lsquo;functools.lru_cache&amp;rsquo; a dict is used to store the cached
results, therefore positional and keyword arguments must be hashable. Each
instance stores up to</source>
          <target state="translated">缓存的第一层存储在包装函数或方法的可调用对象中。与&amp;ldquo; functools.lru_cache&amp;rdquo;一样，字典用于存储缓存的结果，因此位置和关键字参数必须是可哈希的。每个实例最多可存储</target>
        </trans-unit>
        <trans-unit id="0ea4401b5713b542a1e261e03fdcbec558a8d19b" translate="yes" xml:space="preserve">
          <source>The second layer of caching requires a shared cache that can make use of
Django&amp;rsquo;s cache framework.  In this case it is assumed that any LRU mechanism
is handled by the shared cache backend.</source>
          <target state="translated">第二层缓存需要共享缓存，该共享缓存可以利用Django的缓存框架。在这种情况下，假定任何LRU机制都由共享缓存后端处理。</target>
        </trans-unit>
        <trans-unit id="176ea28590869923dcfef77790d0be6e85b0bc24" translate="yes" xml:space="preserve">
          <source>The un-cached underlying function can always be accessed with</source>
          <target state="translated">未缓存的底层函数总是可以用</target>
        </trans-unit>
        <trans-unit id="d8e2dde7858b0f625a6bbfb5559beee48b1cb949" translate="yes" xml:space="preserve">
          <source>This arrangement allows a process that accesses a function multiple times to
retrieve the value without the expense of requesting it from a shared cache,
while still allowing different processes to access the result from the shared
cache.</source>
          <target state="translated">这种安排允许一个多次访问函数的进程检索该值,而不需要花费从共享缓存中请求该值,同时仍然允许不同的进程从共享缓存中访问结果。</target>
        </trans-unit>
        <trans-unit id="75b9de2bd29cbf6751c7a36363a0fd751ecacea2" translate="yes" xml:space="preserve">
          <source>This is not yet implemented as a function but can be accomplished by first calling
invalidate and then calling the function</source>
          <target state="translated">这还没有作为一个函数来实现,但可以通过先调用invalidate,然后再调用函数</target>
        </trans-unit>
        <trans-unit id="6c5e4c3c083a750c34b9adaef009aac85d3924c6" translate="yes" xml:space="preserve">
          <source>This was developed by &lt;a href=&quot;http://www.3top.com/team&quot;&gt;3Top, Inc.&lt;/a&gt; for use with
our ranking and recommendation platform, &lt;a href=&quot;http://www.3top.com&quot;&gt;http://www.3top.com&lt;/a&gt;.</source>
          <target state="translated">这是由&lt;a href=&quot;http://www.3top.com/team&quot;&gt;3Top，Inc&lt;/a&gt; .开发的，可与我们的排名和推荐平台&lt;a href=&quot;http://www.3top.com&quot;&gt;http://www.3top.com一起使用&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="fde1a31e15e42e88afb165e49cb21121fae29131" translate="yes" xml:space="preserve">
          <source>To invalidate the cache for a specific set of arguments, including the instance
one can pass the same arguments to invalidate the both L1 and L2 caches:</source>
          <target state="translated">要使包括实例在内的一组特定参数的缓存无效,可以传递相同的参数,使L1和L2缓存都无效。</target>
        </trans-unit>
        <trans-unit id="88b33e4e12f75ac8bf792aebde41f1a090f3a612" translate="yes" xml:space="preserve">
          <source>True</source>
          <target state="translated">True</target>
        </trans-unit>
        <trans-unit id="0bb18642b70b9f8a9c12ccf39487328f306b8e19" translate="yes" xml:space="preserve">
          <source>Usage</source>
          <target state="translated">使用方法</target>
        </trans-unit>
        <trans-unit id="3b2cb96142ae431c2df3de4bb6b9a4cbca498afc" translate="yes" xml:space="preserve">
          <source>Usage is as simple as adding the decorator to a function or method as seen in
the below examples from our test cases:</source>
          <target state="translated">使用方法很简单,就像在一个函数或方法中添加装饰器一样,从下面的测试案例中可以看出。</target>
        </trans-unit>
        <trans-unit id="b8b4346e8782d546f582feeaec684daca029da8b" translate="yes" xml:space="preserve">
          <source>We used a backport python 3</source>
          <target state="translated">我们使用了一个回迁的python 3</target>
        </trans-unit>
        <trans-unit id="235811c1759d45111475d5266bc6a107245df52d" translate="yes" xml:space="preserve">
          <source>and if not found fall back to</source>
          <target state="translated">失而复得</target>
        </trans-unit>
        <trans-unit id="b204bca289d16df380a96f6adc203c95eff37534" translate="yes" xml:space="preserve">
          <source>decorator as a starting
point for developing an in instance cache with LRU capabilities.  However we
needed to ensure the keys would also be unique enough to use with a shared
cache. We leverage Django&amp;rsquo;s excellent cache framework for managing the layer 2
cache. This allows the use of any shared cache supported by Django.</source>
          <target state="translated">装饰器作为开发具有LRU功能的实例缓存的起点。但是，我们需要确保密钥也足够唯一以与共享缓存一起使用。我们利用Django出色的缓存框架来管理第2层缓存。这允许使用Django支持的任何共享缓存。</target>
        </trans-unit>
        <trans-unit id="7505d64a54e061b7acd54ccd58b49dc43500b635" translate="yes" xml:space="preserve">
          <source>default</source>
          <target state="translated">默认</target>
        </trans-unit>
        <trans-unit id="778b425edf8ec003eb2a0a2d8a7a2a3d54043356" translate="yes" xml:space="preserve">
          <source>f.__wrapped__</source>
          <target state="translated">f.___包装__</target>
        </trans-unit>
        <trans-unit id="cf8c707a6006ea42369c462118f8380268597325" translate="yes" xml:space="preserve">
          <source>f.cache_info()</source>
          <target state="translated">f.cache_info()</target>
        </trans-unit>
        <trans-unit id="54800f8bd035a18cec9a83721a2f0d9901a88020" translate="yes" xml:space="preserve">
          <source>functools.lru_cache</source>
          <target state="translated">functools.lru_cache</target>
        </trans-unit>
        <trans-unit id="dcfadac569c49917e69f513a3e245fd1d6b2c92c" translate="yes" xml:space="preserve">
          <source>functools.lru_cache()</source>
          <target state="translated">functools.lru_cache()</target>
        </trans-unit>
        <trans-unit id="c589e370d15354bfa1c43ff28cafcd54ca93fbb2" translate="yes" xml:space="preserve">
          <source>however if it is not you will
need to specify what attribute should be used.</source>
          <target state="translated">然而,如果不是,你将需要指定应该使用什么属性。</target>
        </trans-unit>
        <trans-unit id="87ea5dfc8b8e384d848979496e706390b497e547" translate="yes" xml:space="preserve">
          <source>id</source>
          <target state="translated">身份证</target>
        </trans-unit>
        <trans-unit id="958f57f57d72a30f329ee5538f21b0257a49a46e" translate="yes" xml:space="preserve">
          <source>if</source>
          <target state="translated">如果</target>
        </trans-unit>
        <trans-unit id="894f317b9160e13f41fd9889fbe20573a6a2fa51" translate="yes" xml:space="preserve">
          <source>in the case of a method you do need to explicitly pass the instance as in the
following:</source>
          <target state="translated">在方法的情况下,你确实需要显式地传递实例,如下所示。</target>
        </trans-unit>
        <trans-unit id="99578a0572cb4666f7da4c6317812a1795e90db6" translate="yes" xml:space="preserve">
          <source>inst_attr</source>
          <target state="translated">inst_attr</target>
        </trans-unit>
        <trans-unit id="b47f363e2b430c0647f14deea3eced9b0ef300ce" translate="yes" xml:space="preserve">
          <source>is</source>
          <target state="translated">is</target>
        </trans-unit>
        <trans-unit id="04aea98291c14f68c64d647870dcc66791bebff3" translate="yes" xml:space="preserve">
          <source>is set to</source>
          <target state="translated">设置为</target>
        </trans-unit>
        <trans-unit id="203a495a6685bc90041befff86795808f8e82182" translate="yes" xml:space="preserve">
          <source>is specified it will be used as the shared cache.  Otherwise
it will attempt to use a cache named</source>
          <target state="translated">被指定,它将被用作共享缓存。否则它将尝试使用一个名为</target>
        </trans-unit>
        <trans-unit id="f6d6ab6f2a5f07bb043396b6eddd6c513b490bbb" translate="yes" xml:space="preserve">
          <source>is the attribute used to uniquely identify an object when wrapping
a method.  In Django this will typically be</source>
          <target state="translated">是在封装一个方法时用来唯一标识对象的属性。在Django中,这个属性通常是</target>
        </trans-unit>
        <trans-unit id="4e35854b464fbca3f62f573e0ebc966a5c2346df" translate="yes" xml:space="preserve">
          <source>l1_maxsize</source>
          <target state="translated">l1_maxsize</target>
        </trans-unit>
        <trans-unit id="24239dc31cf7b79a3dd81e391ffb9cf6b8f43413" translate="yes" xml:space="preserve">
          <source>l2cache</source>
          <target state="translated">l2cache</target>
        </trans-unit>
        <trans-unit id="d25a4bf33e3adbcb4faa3349bda74f43c379251e" translate="yes" xml:space="preserve">
          <source>l2cache_name</source>
          <target state="translated">l2cache_name</target>
        </trans-unit>
        <trans-unit id="67962b5f93ab7e7aee26271b6434367efdebeb0c" translate="yes" xml:space="preserve">
          <source>lru2cache is a decorator that can be used with any user function or method to
cache the most recent results in a local cache and using the django cache
framework to cache results in a shared cache.</source>
          <target state="translated">lru2cache是一个装饰器,它可以与任何用户函数或方法一起使用,将最近的结果缓存在本地缓存中,并使用django缓存框架将结果缓存在共享缓存中。</target>
        </trans-unit>
        <trans-unit id="a0b82c9aec209c2aeba44c98d6e0f5ac1eeb0366" translate="yes" xml:space="preserve">
          <source>none_cache</source>
          <target state="translated">none_cache</target>
        </trans-unit>
        <trans-unit id="1758356db21759f7c5a0da9b4dd1db8fd6feab3f" translate="yes" xml:space="preserve">
          <source>or</source>
          <target state="translated">or</target>
        </trans-unit>
        <trans-unit id="7bb544dbb5a0825498324c9261119887b51048a7" translate="yes" xml:space="preserve">
          <source>results that vary on the arguments. The
discarding of the LRU cached values is handled by the decorator.</source>
          <target state="translated">的结果,根据参数的不同而不同。LRU缓存值的丢弃由装饰器处理。</target>
        </trans-unit>
        <trans-unit id="32800976dbaf3bf9a9490995b0c0f0b6bbb55857" translate="yes" xml:space="preserve">
          <source>results will be cached, otherwise they
will not.</source>
          <target state="translated">结果会被缓存,否则不会。</target>
        </trans-unit>
        <trans-unit id="d820aa5f8750fdde33200083b0702a32578a6c95" translate="yes" xml:space="preserve">
          <source>than</source>
          <target state="translated">than</target>
        </trans-unit>
        <trans-unit id="80df4a04d26c83f618293af30f0535e20afd7329" translate="yes" xml:space="preserve">
          <source>the cache and statistics associated with a function or method can be cleared with:</source>
          <target state="translated">可以用以下方法清除与函数或方法相关的缓存和统计数据。</target>
        </trans-unit>
        <trans-unit id="bda4b1c3ce007842c38ded3638ca7730d8a8aae7" translate="yes" xml:space="preserve">
          <source>typed</source>
          <target state="translated">类型化</target>
        </trans-unit>
        <trans-unit id="dcfac732a9fac915f0831ba3d8ab666199413e95" translate="yes" xml:space="preserve">
          <source>with minor changes to make them work with python 2.7
and incorporated the l2_cache stats. We will continue to add tests to validate
the additional functionality provided by this decorator.</source>
          <target state="translated">并做了一些小的改动,使其能在python 2.7中使用,并加入了l2_cache stats。我们将继续添加测试来验证这个装饰器提供的额外功能。</target>
        </trans-unit>
        <trans-unit id="290239353d61d53048fdeae4868e219f2dd57e54" translate="yes" xml:space="preserve">
          <source>you will need to
specify the name of the cache.</source>
          <target state="translated">你需要指定缓存的名称。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
