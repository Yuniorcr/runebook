<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://pypi.org/project/moz-sql-parser/">
    <body>
      <group id="moz-sql-parser">
        <trans-unit id="4e28d29be344385ea302dcef3fbb66860d416f31" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://pypi.python.org/pypi/sqlparse&quot;&gt;sqlparse&lt;/a&gt; does not provide a tree, rather a list of tokens.</source>
          <target state="translated">&lt;a href=&quot;https://pypi.python.org/pypi/sqlparse&quot;&gt;sqlparse&lt;/a&gt;不提供树，而是提供令牌列表。</target>
        </trans-unit>
        <trans-unit id="94a7af134274f802f7d6f8c671505a6104b37384" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;WARNING!&lt;/strong&gt; There is a recursion limit of &lt;code&gt;1500&lt;/code&gt;. This prevents parsing of complex expressions or deeply nested nested queries. You can increase the recursion limit &lt;em&gt;after&lt;/em&gt; you have imported &lt;code&gt;moz_sql_parser&lt;/code&gt;, and before you &lt;code&gt;parse&lt;/code&gt;:</source>
          <target state="translated">&lt;strong&gt;警告！&lt;/strong&gt;递归限制为 &lt;code&gt;1500&lt;/code&gt; 。这样可以防止解析复杂的表达式或深度嵌套的嵌套查询。&lt;em&gt;在&lt;/em&gt;导入 &lt;code&gt;moz_sql_parser&lt;/code&gt; 之后和 &lt;code&gt;parse&lt;/code&gt; 之前，可以增加递归限制：</target>
        </trans-unit>
        <trans-unit id="1627510b242fdd96752b823f80c1c2b488d0747b" translate="yes" xml:space="preserve">
          <source>Branch</source>
          <target state="translated">分公司</target>
        </trans-unit>
        <trans-unit id="2d82a4b27a4b305690d5ac612046a955778a9fa5" translate="yes" xml:space="preserve">
          <source>Contributing</source>
          <target state="translated">贡献</target>
        </trans-unit>
        <trans-unit id="f965a3acfa3282329fed41fc1e47392daa396d54" translate="yes" xml:space="preserve">
          <source>Each SQL query is parsed to an object: Each clause is assigned to an object property of the same name.</source>
          <target state="translated">每个SQL查询都被解析为一个对象。每一个子句都被分配给一个同名的对象属性。</target>
        </trans-unit>
        <trans-unit id="966c089e2169b8a55bd60dc592b73c2aca57fcde" translate="yes" xml:space="preserve">
          <source>Expressions are also objects, but with only one property: The name of the operation, and the value holding (an array of) parameters for that operation.</source>
          <target state="translated">表达式也是对象,但只有一个属性。The name of the operation,and the value holding (an array of)parameters for that operation.操作的名称和持有该操作参数的值(一个数组)。</target>
        </trans-unit>
        <trans-unit id="0a4eefe2ba9d52aae17ac211d2c4b4029e262334" translate="yes" xml:space="preserve">
          <source>Extract Parse Tree from SQL</source>
          <target state="translated">从SQL中提取解析树</target>
        </trans-unit>
        <trans-unit id="2663443ee624833850c1162ce7a9bfaf9816461b" translate="yes" xml:space="preserve">
          <source>Generating SQL</source>
          <target state="translated">生成SQL</target>
        </trans-unit>
        <trans-unit id="832bd26971dbce25436004fb6f78071d58d6e3ea" translate="yes" xml:space="preserve">
          <source>In the event that the parser is not working for you, you can help make this better but simply pasting your sql (or JSON) into a new issue. Extra points if you describe the problem. Even more points if you submit a PR with a test.  If you also submit a fix, then you also have my gratitude.</source>
          <target state="translated">在解析器对你无效的情况下,你可以帮助使这个问题变得更好,但只需将你的sql(或JSON)粘贴到一个新的问题中。如果你描述了问题,会得到额外的分数。如果你提交了一个带有测试的PR,则加分。如果你也提交了一个修复,那么你也会得到我的感谢。</target>
        </trans-unit>
        <trans-unit id="fd6c3ebf7befca9f8208f86c76e4d4180303745c" translate="yes" xml:space="preserve">
          <source>Install</source>
          <target state="translated">安装</target>
        </trans-unit>
        <trans-unit id="6b4d04f9f8fa44794465762f162279a868429354" translate="yes" xml:space="preserve">
          <source>Let's make a SQL parser so we can provide a familiar interface to non-sql datastores!</source>
          <target state="translated">让我们来做一个SQL解析器,这样我们就可以为非sql数据存储提供一个熟悉的接口了!</target>
        </trans-unit>
        <trans-unit id="010bc6c086848dea1af62fc5ce30971d49859381" translate="yes" xml:space="preserve">
          <source>More about implementation</source>
          <target state="translated">更多关于执行情况</target>
        </trans-unit>
        <trans-unit id="c61d361e892493c40018ce5123358566c5a83225" translate="yes" xml:space="preserve">
          <source>Moz SQL Parser</source>
          <target state="translated">Moz SQL解析器</target>
        </trans-unit>
        <trans-unit id="33a39b12e43bde0be5e98a7db5de429002890c78" translate="yes" xml:space="preserve">
          <source>No plans to expand the language to all of SQL:2011</source>
          <target state="translated">没有计划将该语言扩展到所有的SQL:2011。</target>
        </trans-unit>
        <trans-unit id="75e617f9065f00ca469e2f4802d0bfcf90a09902" translate="yes" xml:space="preserve">
          <source>No plans to provide data access tools</source>
          <target state="translated">没有提供数据访问工具的计划</target>
        </trans-unit>
        <trans-unit id="a81ece075d0edfc6b929bf939e6e5b5f43e31326" translate="yes" xml:space="preserve">
          <source>No plans to provide update statements, like &lt;code&gt;update&lt;/code&gt; or &lt;code&gt;insert&lt;/code&gt;</source>
          <target state="translated">没有计划提供更新语句，例如 &lt;code&gt;update&lt;/code&gt; 或 &lt;code&gt;insert&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4f9f5a604eaaa999d173a12f209a86773406674b" translate="yes" xml:space="preserve">
          <source>Non-Objectives</source>
          <target state="translated">非目标</target>
        </trans-unit>
        <trans-unit id="70440046a3dc2e079f23ee1c57dfa76669b732aa" translate="yes" xml:space="preserve">
          <source>Notes</source>
          <target state="translated">笔记</target>
        </trans-unit>
        <trans-unit id="24d50592b70a997e82a3839de9c69ef0c75660a9" translate="yes" xml:space="preserve">
          <source>Objectives</source>
          <target state="translated">目标</target>
        </trans-unit>
        <trans-unit id="fe57dbf747e895148349c1fa9634e51dbecd7517" translate="yes" xml:space="preserve">
          <source>Parsing SQL</source>
          <target state="translated">解析SQL</target>
        </trans-unit>
        <trans-unit id="fa172cf233798ad6b9a563a7017eabd723d0e92e" translate="yes" xml:space="preserve">
          <source>Problem Statement</source>
          <target state="translated">问题陈述</target>
        </trans-unit>
        <trans-unit id="1cb0bee5478facc7715136ce6ca34b0fe11136cb" translate="yes" xml:space="preserve">
          <source>Project Status</source>
          <target state="translated">项目状态</target>
        </trans-unit>
        <trans-unit id="5217fc37ffff1ea7636afe621cf814248a879901" translate="yes" xml:space="preserve">
          <source>Recursion Limit</source>
          <target state="translated">递归极限</target>
        </trans-unit>
        <trans-unit id="40e0369df9d75435b2e7be5903874c57c9829e0d" translate="yes" xml:space="preserve">
          <source>Run Tests</source>
          <target state="translated">运行测试</target>
        </trans-unit>
        <trans-unit id="f1e002404e674984e90046729044367c19480e51" translate="yes" xml:space="preserve">
          <source>SQL is a familiar language used to access databases. Although, each database vendor has its quirky implementation, the average developer does not know enough SQL to be concerned with those quirks. This familiar core SQL (lowest common denominator, if you will) is useful enough to explore data in primitive ways. It is hoped that, once programmers have reviewed a datastore with basic SQL queries, and they see the value of that data, they will be motivated to use the datastore's native query format.</source>
          <target state="translated">SQL是人们熟悉的用于访问数据库的语言。虽然,每个数据库厂商都有其奇特的实现方式,但一般的开发人员对SQL的了解还不够多,不需要关注这些奇特的地方。这种熟悉的核心SQL(最低共同点,如果你愿意的话)足够有用,可以用原始的方式探索数据。希望一旦程序员用基本的SQL查询回顾了一个数据存储,并且他们看到了这些数据的价值,他们就会有动力使用数据存储的原始查询格式。</target>
        </trans-unit>
        <trans-unit id="2e605a358b5ec3cecdbd821c273f7059f717c064" translate="yes" xml:space="preserve">
          <source>SQL queries are translated to JSON objects: Each clause is assigned to an object property of the same name.</source>
          <target state="translated">SQL查询被翻译成JSON对象。每个子句都被分配给一个同名的对象属性。</target>
        </trans-unit>
        <trans-unit id="d275310c79fc97ae9e1fcfef4efbead08afa37a4" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://github.com/mozilla/moz-sql-parser/tree/dev/tests&quot;&gt;the tests directory&lt;/a&gt; for instructions running tests, or writing new ones.</source>
          <target state="translated">请参阅&lt;a href=&quot;https://github.com/mozilla/moz-sql-parser/tree/dev/tests&quot;&gt;测试目录，&lt;/a&gt;以获取运行测试或编写新测试的说明。</target>
        </trans-unit>
        <trans-unit id="bae7d5be70820ed56467bd9a63744e23b47bd711" translate="yes" xml:space="preserve">
          <source>Status</source>
          <target state="translated">状况</target>
        </trans-unit>
        <trans-unit id="c62c75e18bbe6c1877bcf42feca5efb923577207" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SELECT&lt;/code&gt; clause is an array of objects containing &lt;code&gt;name&lt;/code&gt; and &lt;code&gt;value&lt;/code&gt; properties.</source>
          <target state="translated">该 &lt;code&gt;SELECT&lt;/code&gt; 子句是包含对象的数组 &lt;code&gt;name&lt;/code&gt; 和 &lt;code&gt;value&lt;/code&gt; 的属性。</target>
        </trans-unit>
        <trans-unit id="f4f8178674aaff567ed07f488140adbfbfe94dce" translate="yes" xml:space="preserve">
          <source>The primary objective of this library is to convert some subset of &lt;a href=&quot;https://en.wikipedia.org/wiki/SQL-92&quot;&gt;SQL-92&lt;/a&gt; queries to JSON-izable parse trees. A big enough subset to provide superficial data access via SQL, but not so much as we must deal with the document-relational impedance mismatch.</source>
          <target state="translated">该库的主要目的是将&lt;a href=&quot;https://en.wikipedia.org/wiki/SQL-92&quot;&gt;SQL-92&lt;/a&gt;查询的某些子集转换为可实现JSON的解析树。一个足够大的子集可以通过SQL提供浅层数据访问，但是数量不多，因为我们必须处理文档关系阻抗不匹配的问题。</target>
        </trans-unit>
        <trans-unit id="5f4f8976bb3862e29b0a28428cc921697b71fec5" translate="yes" xml:space="preserve">
          <source>There are &lt;a href=&quot;https://github.com/mozilla/moz-sql-parser/tree/dev/tests&quot;&gt;over 400 tests&lt;/a&gt;. This parser is good enough for basic usage, including inner queries.</source>
          <target state="translated">有&lt;a href=&quot;https://github.com/mozilla/moz-sql-parser/tree/dev/tests&quot;&gt;超过400个测试&lt;/a&gt;。对于基本用法（包括内部查询），此解析器已足够好。</target>
        </trans-unit>
        <trans-unit id="189973b5cf5444d3d7004008dbae95df268cf639" translate="yes" xml:space="preserve">
          <source>Uses the glorious &lt;code&gt;pyparsing&lt;/code&gt; library (see &lt;a href=&quot;https://github.com/pyparsing/pyparsing&quot;&gt;https://github.com/pyparsing/pyparsing&lt;/a&gt;) to define the grammar, and define the shape of the tokens it generates.</source>
          <target state="translated">使用光荣的 &lt;code&gt;pyparsing&lt;/code&gt; 库（请参阅&lt;a href=&quot;https://github.com/pyparsing/pyparsing&quot;&gt;https://github.com/pyparsing/pyparsing&lt;/a&gt;）定义语法，并定义其生成的标记的形状。</target>
        </trans-unit>
        <trans-unit id="4651977612eb15d974adfac2507a3a4205f35900" translate="yes" xml:space="preserve">
          <source>You can see the parser in action at &lt;a href=&quot;https://sql.telemetry.mozilla.org/&quot;&gt;https://sql.telemetry.mozilla.org/&lt;/a&gt; while using the ActiveData datasource</source>
          <target state="translated">使用ActiveData数据源时，您可以在&lt;a href=&quot;https://sql.telemetry.mozilla.org/&quot;&gt;https://sql.telemetry.mozilla.org/上&lt;/a&gt;看到解析器的运行情况</target>
        </trans-unit>
        <trans-unit id="c2a7051d7ad2f9e606a29f9a31af46c0beb7103b" translate="yes" xml:space="preserve">
          <source>You may also generate SQL from the a given JSON document. This is done by the formatter, which is still incomplete (Jan2020).</source>
          <target state="translated">你也可以从给定的JSON文档中生成SQL。这是由格式化器完成的,它仍然是不完整的(Jan2020)。</target>
        </trans-unit>
        <trans-unit id="54d094d08ab3dedca2a6d6466c75b306bf10f81b" translate="yes" xml:space="preserve">
          <source>and you can see this pattern in the previous example:</source>
          <target state="translated">你可以在前面的例子中看到这种模式。</target>
        </trans-unit>
        <trans-unit id="34c6fceca75e456f25e7e99531e2425c6c1de443" translate="yes" xml:space="preserve">
          <source>dev</source>
          <target state="translated">开发</target>
        </trans-unit>
        <trans-unit id="4f26aeafdb2367620a393c973eddbe8f8b846ebd" translate="yes" xml:space="preserve">
          <source>master</source>
          <target state="translated">掌握</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
