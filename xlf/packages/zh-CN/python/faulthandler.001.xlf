<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://pypi.org/project/faulthandler/">
    <body>
      <group id="faulthandler">
        <trans-unit id="8b32f169fb309037a80f683a4b6d37e7cba4bdc1" translate="yes" xml:space="preserve">
          <source>Alternatively you can set the PYTHONFAULTHANDLER environment variable to a
non-empty value.</source>
          <target state="translated">或者你可以将PYTHONFAULTHANDLER环境变量设置为非空值。</target>
        </trans-unit>
        <trans-unit id="b05598106e76da0d607a6a81c201935a1dbfee9a" translate="yes" xml:space="preserve">
          <source>By default, the Python traceback is written to the standard error stream. Start
your graphical applications in a terminal and run your server in foreground to
see the traceback, or pass a file to faulthandler.enable().</source>
          <target state="translated">默认情况下,Python的回溯是写入标准错误流的。在终端中启动你的图形应用程序,并在前台运行你的服务器来查看回溯,或者传递一个文件给failthandler.enable()。</target>
        </trans-unit>
        <trans-unit id="fa7641d6cb8d0ba8e60b2b86f9a48291331443a8" translate="yes" xml:space="preserve">
          <source>Display the Python traceback on a crash</source>
          <target state="translated">显示崩溃时的Python回溯</target>
        </trans-unit>
        <trans-unit id="148333c18dd79509f9564b86c3add191d327ffcc" translate="yes" xml:space="preserve">
          <source>Fault handler for SIGSEGV, SIGFPE, SIGABRT, SIGBUS and SIGILL signals: display
the Python traceback and restore the previous handler. Allocate an alternate
stack for this handler, if sigaltstack() is available, to be able to allocate
memory on the stack, even on stack overflow (not available on Windows).</source>
          <target state="translated">对SIGSEGV、SIGFPE、SIGABRT、SIGBUS和SIGILL信号的故障处理程序:显示Python回溯并恢复之前的处理程序。如果 sigaltstack()可用的话,为该处理程序分配一个备用栈,以便能够在栈上分配内存,即使是在栈溢出时 (在 Windows 上不可用)。</target>
        </trans-unit>
        <trans-unit id="81e0ceb7fc7b0120d9efeaffe709c095b3d029da" translate="yes" xml:space="preserve">
          <source>Import the module and call faulthandler.enable() to enable the fault handler.</source>
          <target state="translated">导入模块并调用 faulthandler.enable()来启用故障处理程序。</target>
        </trans-unit>
        <trans-unit id="45e8e62be32ad547820a512d950cbe7aeb111584" translate="yes" xml:space="preserve">
          <source>The fault handler is called on catastrophic cases and so it can only use
signal-safe functions (eg. it doesn&amp;rsquo;t allocate memory on the heap). That&amp;rsquo;s why
the traceback is limited: it only supports ASCII encoding (use the
backslashreplace error handler for non-ASCII characters) and limits each string
to 100 characters, doesn&amp;rsquo;t print the source code in the traceback (only the
filename, the function name and the line number), is limited to 100 frames and
100 threads.</source>
          <target state="translated">故障处理程序在灾难性情况下被调用，因此它只能使用信号安全功能（例如，它不会在堆上分配内存）。这就是限制回溯的原因：它仅支持ASCII编码（对于非ASCII字符，请使用反斜杠替换错误处理程序），并将每个字符串限制为100个字符，不在回溯中打印源代码（仅显示文件名，函数名和行号）限制为100帧和100个线程。</target>
        </trans-unit>
        <trans-unit id="3b7e79012975d3e861952d69da3944f99e276605" translate="yes" xml:space="preserve">
          <source>This module is the backport for CPython 2.7. faulthandler is part of CPython
standard library since CPython 3.3: &lt;a href=&quot;http://docs.python.org/dev/library/faulthandler.html&quot;&gt;faulthandler&lt;/a&gt;. For PyPy,
faulthandler is builtin since PyPy 5.5: use</source>
          <target state="translated">该模块是CPython 2.7的反向端口。从CPython 3.3：&lt;a href=&quot;http://docs.python.org/dev/library/faulthandler.html&quot;&gt;faulthandler&lt;/a&gt;开始，faulthandler是CPython标准库的一部分。对于PyPy，自PyPy 5.5起内置了faulthandler：</target>
        </trans-unit>
        <trans-unit id="5774e0c7dcae0498837702f72af167be1db50158" translate="yes" xml:space="preserve">
          <source>Website:
&lt;a href=&quot;https://faulthandler.readthedocs.io/&quot;&gt;https://faulthandler.readthedocs.io/&lt;/a&gt;</source>
          <target state="translated">网站：&lt;a href=&quot;https://faulthandler.readthedocs.io/&quot;&gt;https&lt;/a&gt;： //faulthandler.readthedocs.io/</target>
        </trans-unit>
        <trans-unit id="1cb1003c13997882c35b2965310815154c6cbb5e" translate="yes" xml:space="preserve">
          <source>faulthandler 3.2 is the last version released by Victor Stinner. I maintained
it for 10 years in my free time for the great pleasure of Python 2 users, but
Python 2 is no longer supported upstream since 2020-01-01. Each faulthandler
release requires me to start my Windows VM, install Python 2.7 in 32-bit and
64-bit, install an old C compiler just for Python 2.7, and type manually some
commands to upload Windows binaries. Moreover, I have to fix some issues on
Travis CI and many small boring tasks. The maintenance is far from being free.
In 10 years, I got zero &amp;ldquo;thank you&amp;rdquo; (and 0&amp;euro;), only bug reports :-)</source>
          <target state="translated">faulthandler 3.2是Victor Stinner发布的最新版本。为了让Python 2用户感到非常高兴，我在业余时间将其维护了10年，但是自2020年1月1日以来，不再支持上游的Python 2。每个故障处理程序版本都要求我启动Windows VM，在32位和64位安装Python 2.7，安装仅适用于Python 2.7的旧C编译器，并手动键入一些命令以上传Windows二进制文件。此外，我必须解决有关Travis CI的一些问题和许多无聊的小任务。维护远非免费。在10年中，我得到了零&amp;ldquo;谢谢&amp;rdquo;（和0&amp;euro;），只有错误报告:-)</target>
        </trans-unit>
        <trans-unit id="e8c4d13fd2fd99b029d92a36fad256f8f653a5a1" translate="yes" xml:space="preserve">
          <source>faulthandler is implemented in C using signal handlers to be able to dump a
traceback on a crash or when Python is blocked (eg. deadlock).</source>
          <target state="translated">faulthandler 是在 C 语言中使用信号处理程序实现的,它能够在崩溃或 Python 被阻塞时 (例如,死锁)转储一个跟踪。</target>
        </trans-unit>
        <trans-unit id="2caee2bbfef6db853f54ebef721cc989c0da49f3" translate="yes" xml:space="preserve">
          <source>pypy -X faulthandler</source>
          <target state="translated">pypy -X faulthandler</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
