<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://pypi.org/project/absynthe/">
    <body>
      <group id="absynthe">
        <trans-unit id="02b011c64160798e799481cc084857488382bb41" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Anomalous&lt;/em&gt; behaviors</source>
          <target state="translated">&lt;em&gt;异常&lt;/em&gt;行为</target>
        </trans-unit>
        <trans-unit id="60027b310b5d95466e164e9b1bfc5f536be91cc0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; This tool is still in alpha stage, so backward compatibility is not
guaranteed between releases. However, inasmuch as users stick to graph builders'
&lt;code&gt;generateNewGraph()&lt;/code&gt; methods, they will stay away from compatibility problems.</source>
          <target state="translated">&lt;strong&gt;注意：&lt;/strong&gt;此工具仍处于Alpha阶段，因此不能保证版本之间的向后兼容性。但是，由于用户坚持使用图形构建器的 &lt;code&gt;generateNewGraph()&lt;/code&gt; 方法，因此他们将避免兼容性问题。</target>
        </trans-unit>
        <trans-unit id="7d13b0e105082d251433284ac94b52e7b08baf9b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; When generating a behavior, i.e. when traversing a graph, successors
of nodes are chosen based on the probability distributions associated with those
nodes. Different nodes rely on different distributions and these nodes are
randomly assigned in the graphs that are constructed by &lt;code&gt;generateNewGraph()&lt;/code&gt;
methods, resulting in graphs with a mix of nodes.</source>
          <target state="translated">&lt;strong&gt;注意：&lt;/strong&gt;生成行为时，即遍历图形时，将基于与节点关联的概率分布来选择节点的后继节点。不同的节点依赖于不同的分布，并且这些节点在由 &lt;code&gt;generateNewGraph()&lt;/code&gt; 方法构造的图中被随机分配，从而产生带有节点混合的图。</target>
        </trans-unit>
        <trans-unit id="1ed58f177ea95bd7dab803c7ed4b233a181ba7bd" translate="yes" xml:space="preserve">
          <source>A (branching) Behaviour Synthesizer</source>
          <target state="translated">一个(分支)行为合成器。</target>
        </trans-unit>
        <trans-unit id="550e6f318db294135e3d56d0fa6d7665e997ba1a" translate="yes" xml:space="preserve">
          <source>A more interesting situation arises while trying to test log analytic (and
anomaly detection) solutions for distributed applications where multiple
sources or modules emit their respective log messages in a single log queue or
stream. This means that consecutive log lines could have originated from
different, unrelated application components. Absynthe provides &lt;em&gt;ground truth&lt;/em&gt;
models to simulate such situations.</source>
          <target state="translated">在尝试测试分布式应用程序的日志分析（和异常检测）解决方案时，会出现一个更有趣的情况，在该解决方案中，多个源或模块在单个日志队列或流中发出各自的日志消息。这意味着连续的日志行可能源自不同的，不相关的应用程序组件。Absynthe提供了&lt;em&gt;地面真实&lt;/em&gt; 模型来模拟这种情况。</target>
        </trans-unit>
        <trans-unit id="dde040f47497790c05666d2ef94baefd390e27bf" translate="yes" xml:space="preserve">
          <source>Absynthe came about in response to the need for test data for analysizing the
performance and accuracy of log analysis algorithms. Even though plenty of real
life logs are available, e.g. &lt;code&gt;/var/log/&lt;/code&gt; in unix-based laptops, they do not
serve the purpose of test data. For that, we need to understand the core
application logic that is generating these logs.</source>
          <target state="translated">Absynthe的出现是为了响应对测试数据的需求，以分析测井分析算法的性能和准确性。即使有大量现实生活的日志，例如，在基于unix的便携式计算机中的 &lt;code&gt;/var/log/&lt;/code&gt; ，它们也不能用于测试数据。为此，我们需要了解生成这些日志的核心应用程序逻辑。</target>
        </trans-unit>
        <trans-unit id="68e14b2ad8538d489e4858484be43ce15b328a6b" translate="yes" xml:space="preserve">
          <source>Absynthe: A (branching) Behavior Synthesizer</source>
          <target state="translated">Absynthe:A (branching)Behavior Synthesizer.</target>
        </trans-unit>
        <trans-unit id="280cb3fd0e3d99cf59bd50b4980fc6af1bbad0d5" translate="yes" xml:space="preserve">
          <source>Added a separate utility class called &lt;code&gt;Utils&lt;/code&gt; in &lt;code&gt;absynthe.cfg.utils.py&lt;/code&gt; to
create a new &lt;code&gt;Node&lt;/code&gt; object from any of the concrete implementations of &lt;code&gt;Node&lt;/code&gt; at
random. All concrete implementations of &lt;code&gt;Node&lt;/code&gt; therefore transparently available
to graph builders (and everyone else) through this utility.</source>
          <target state="translated">增加了一个叫做单独的实用程序类 &lt;code&gt;Utils&lt;/code&gt; 在 &lt;code&gt;absynthe.cfg.utils.py&lt;/code&gt; 创建一个新的 &lt;code&gt;Node&lt;/code&gt; 从任何的具体实现的目标 &lt;code&gt;Node&lt;/code&gt; 随机。因此，通过此实用程序， &lt;code&gt;Node&lt;/code&gt; 的所有具体实现都可以透明地提供给图形生成器（以及其他所有人）。</target>
        </trans-unit>
        <trans-unit id="eb58484c96da64282a061ef0f8a9d40510285043" translate="yes" xml:space="preserve">
          <source>Added new graph builders, viz. &lt;code&gt;DAGBuilder&lt;/code&gt; and  &lt;code&gt;DCGBuilder&lt;/code&gt;, which build
CFGs with skip-level edges and loops respectively.</source>
          <target state="translated">添加了新的图形构建器，即。 &lt;code&gt;DAGBuilder&lt;/code&gt; 和 &lt;code&gt;DCGBuilder&lt;/code&gt; ，分别构建具有跳过级边缘和循环的CFG。</target>
        </trans-unit>
        <trans-unit id="4cbbc2fc77fc6a8ffe051dea3ddc539034d4544b" translate="yes" xml:space="preserve">
          <source>Added new node, viz. &lt;code&gt;BinomialNode&lt;/code&gt;, which exploits the binomial distribution
in order to select its successors at the time of graph traversal.</source>
          <target state="translated">添加了新节点，即。 &lt;code&gt;BinomialNode&lt;/code&gt; ，它利用二项分布来在遍历图时选择其后继。</target>
        </trans-unit>
        <trans-unit id="8be003c27a6c97e5b0677757afd23716aaca94ef" translate="yes" xml:space="preserve">
          <source>An example of a more complex CFG, a directed cyclic graph, is shown in the
figure below. It expands the tree-like graph illustrated above by:</source>
          <target state="translated">下图是一个更复杂的CFG的例子,一个有向循环图。它将上述树状图扩展为:</target>
        </trans-unit>
        <trans-unit id="6452f7e7dc3c35274e1d081266ab3bcc9990cab8" translate="yes" xml:space="preserve">
          <source>An example of a simple, tree-like CFG generated using Absynthe is shown below.
This is like a tree since nodes are laid out in levels, and nodes at level &lt;code&gt;i&lt;/code&gt;
have outgoing edges only to nodes at level &lt;code&gt;i + 1&lt;/code&gt;.</source>
          <target state="translated">使用Absynthe生成的简单树状CFG的示例如下所示。这就像一棵树，因为节点是按级别布局的，而级别 &lt;code&gt;i&lt;/code&gt; 的 节点仅对级别 &lt;code&gt;i + 1&lt;/code&gt; 节点具有输出边缘。</target>
        </trans-unit>
        <trans-unit id="6e925f5a187584bb93a957696eb50e796b4b787e" translate="yes" xml:space="preserve">
          <source>Coming up in future releases</source>
          <target state="translated">在未来的版本中,即将推出</target>
        </trans-unit>
        <trans-unit id="7e9b9183f4a396da21c94f732891218fafbdc7ae" translate="yes" xml:space="preserve">
          <source>Directed Cyclic CFG</source>
          <target state="translated">定向循环CFG</target>
        </trans-unit>
        <trans-unit id="7a253c500c342cfa2eda2d5a52e23d3e00a38f0f" translate="yes" xml:space="preserve">
          <source>Each &lt;em&gt;behavior&lt;/em&gt; is the sequence of nodes encountered while traversing this CFG
from a root to a leaf. Of course, a CFG might contain loops which could be
traversed multiple times before arriving at the leaf. Moreover, if there are
multiple CFGs, then Absynthe can synthesize &lt;em&gt;interleaved&lt;/em&gt; behaviors. This means
that a single sequence of nodes might contain nodes from multiple CFGs. We are
ultimately interested in this interleaving behavior, which is produced by
multiple CFGs.</source>
          <target state="translated">每个&lt;em&gt;行为&lt;/em&gt;都是从根到叶遍历此CFG时遇到的节点序列。当然，CFG可能包含在到达叶子之前可以遍历多次的循环。此外，如果有多个CFG，则Absynthe可以合成&lt;em&gt;交错&lt;/em&gt;行为。这意味着单个节点序列可能包含来自多个CFG的节点。我们最终对由多个CFG产生的这种交错行为感兴趣。</target>
        </trans-unit>
        <trans-unit id="ffc30fab83bb0c85eb6e12280e0a3b95999fd852" translate="yes" xml:space="preserve">
          <source>Each business process or compuater application is modelled as a &lt;em&gt;control flow
graph&lt;/em&gt; (or &lt;em&gt;CFG&lt;/em&gt;), which typically has one or more roots (i.e. entry) nodes and
multiple leaf (i.e. end) nodes.</source>
          <target state="translated">每个业务流程或计算机应用程序都被建模为&lt;em&gt;控制流程图&lt;/em&gt;（或&lt;em&gt;CFG&lt;/em&gt;），该&lt;em&gt;流程图&lt;/em&gt;通常具有一个或多个根（即入口）节点和多个叶（即末端）节点。</target>
        </trans-unit>
        <trans-unit id="ebf05de134c94509696d1b9731d1059221894528" translate="yes" xml:space="preserve">
          <source>For instance, consider the &lt;code&gt;basicLogGeneration&lt;/code&gt; method in
&lt;code&gt;./examples/01_generateSimpleBehavior.py&lt;/code&gt;:</source>
          <target state="translated">例如，考虑 &lt;code&gt;basicLogGeneration&lt;/code&gt; 的方法 &lt;code&gt;./examples/01_generateSimpleBehavior.py&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="ece8a1e099471b12bc1db0091b0ab79cf8c8e183" translate="yes" xml:space="preserve">
          <source>For the latest features not yet released, clone or download the &lt;code&gt;develop&lt;/code&gt; branch
and then:</source>
          <target state="translated">对于尚未发布的最新功能，请克隆或下载 &lt;code&gt;develop&lt;/code&gt; 分支，然后：</target>
        </trans-unit>
        <trans-unit id="361323255a6e418a94fe1dd6ad98403ad687499f" translate="yes" xml:space="preserve">
          <source>In order to generate behaviors from a directed cyclic CFG, create a DCG as shown
in &lt;code&gt;./examples/03_generateControlFlowDCG.py&lt;/code&gt; and then generate behaviors after
adding the DCG to a behavior object as shown in the code snippet above.</source>
          <target state="translated">为了从有向循环CFG生成行为，请创建一个DCG，如 &lt;code&gt;./examples/03_generateControlFlowDCG.py&lt;/code&gt; 中所示，然后在将DCG添加到行为对象后生成行为，如上面的代码片段所示。</target>
        </trans-unit>
        <trans-unit id="c81b79df3c6448eae7c4f80428b54cd5692a17d7" translate="yes" xml:space="preserve">
          <source>Installation</source>
          <target state="translated">安装</target>
        </trans-unit>
        <trans-unit id="41d0bded83d8a4df22a78f1f0693f59a79719b3e" translate="yes" xml:space="preserve">
          <source>It is possible to start using Absynthe with two classes:</source>
          <target state="translated">可以用两个班级开始使用Absynthe。</target>
        </trans-unit>
        <trans-unit id="019ec01ba6d724fe41e420938f721b48570940fe" translate="yes" xml:space="preserve">
          <source>Logger nodes that emit more &lt;em&gt;life like&lt;/em&gt; log messages</source>
          <target state="translated">发射更多的记录器节点&lt;em&gt;的生活就像&lt;/em&gt;日志消息</target>
        </trans-unit>
        <trans-unit id="80552c39193e5d627bacdc60f82ee17b182d6315" translate="yes" xml:space="preserve">
          <source>Major changes in v0.0.2</source>
          <target state="translated">v0.0.2的主要变化</target>
        </trans-unit>
        <trans-unit id="d6a06199cc127e571d3588aef63c79108675eabc" translate="yes" xml:space="preserve">
          <source>Motivation</source>
          <target state="translated">动机</target>
        </trans-unit>
        <trans-unit id="0efc2e6be4c23b9a513d7ce0dcff8ed80e8912e7" translate="yes" xml:space="preserve">
          <source>Overview</source>
          <target state="translated">概述</target>
        </trans-unit>
        <trans-unit id="0ea4af908fe06688dd3fc02035189b08293c5074" translate="yes" xml:space="preserve">
          <source>Release Notes</source>
          <target state="translated">发行说明</target>
        </trans-unit>
        <trans-unit id="7137676daae9098656140de61386c7374db05941" translate="yes" xml:space="preserve">
          <source>Sophisticated interleaving behaviors</source>
          <target state="translated">复杂的交织行为</target>
        </trans-unit>
        <trans-unit id="f2903a3add32a92d3c75624c962356b7a49a5fa8" translate="yes" xml:space="preserve">
          <source>The above screenshot shows logs generated by Absynthe. Each log line starts
with a time stamp, followed by a session ID, CFG ID, and a log message. At
present, the log message is simply a random concatenation of the node ID to
which the log message corresponds. A single CFG might participate in multiple
sessions, where each session is a different traversal of the CFG. Therefore, we
maintain both session ID and CFG ID in the log line.</source>
          <target state="translated">上面的截图显示了Absynthe生成的日志。每一行日志都以时间戳开头,后面是会话ID、CFG ID和日志消息。目前,日志信息只是日志信息所对应的节点ID的随机串联。一个CFG可能参与多个会话,每个会话都是对CFG的不同遍历。因此,我们在日志行中同时保留会话ID和CFG ID。</target>
        </trans-unit>
        <trans-unit id="f96cc45f6b319ee18988211c883578e9a4a281c7" translate="yes" xml:space="preserve">
          <source>The identifiers of nodes appearing loops are helpfully prefixed with the
identifiers of nodes where these loops start and finish. Moreover, loops could
be traversed multiple times in a single behavior, as illustrated in the figure
below.</source>
          <target state="translated">出现循环的节点的标识符是有用的前缀,这些循环开始和结束的节点的标识符。此外,循环可以在一个行为中被多次遍历,如下图所示。</target>
        </trans-unit>
        <trans-unit id="9a674369e325bdf29f6edf8edb945b651c6ac731" translate="yes" xml:space="preserve">
          <source>The latest release is available on PyPi, simply &lt;code&gt;pip install absynthe&lt;/code&gt;. The
&lt;code&gt;master&lt;/code&gt; branch of this repository will always provide the latest release.</source>
          <target state="translated">PyPi提供了最新版本，只需 &lt;code&gt;pip install absynthe&lt;/code&gt; 即可。此存储库的 &lt;code&gt;master&lt;/code&gt; 分支将始终提供最新版本。</target>
        </trans-unit>
        <trans-unit id="3cbe8139be6dadccd55954ec95da87dbf1e698b5" translate="yes" xml:space="preserve">
          <source>This package has been developed with &lt;code&gt;Python 3.6.*&lt;/code&gt; and depends on &lt;code&gt;scipy 1.2.1&lt;/code&gt;.
Things might not work with &lt;code&gt;Python 3.7.*&lt;/code&gt; or &lt;code&gt;scipy 1.3.*&lt;/code&gt;. Therefore, consider
creating a virtual environment if your default configuration differs.</source>
          <target state="translated">该软件包已使用 &lt;code&gt;Python 3.6.*&lt;/code&gt; 开发，并依赖于 &lt;code&gt;scipy 1.2.1&lt;/code&gt; 。 &lt;code&gt;Python 3.7.*&lt;/code&gt; 或 &lt;code&gt;scipy 1.3.*&lt;/code&gt; 可能无法正常工作。因此，如果您的默认配置不同，请考虑创建虚拟环境。</target>
        </trans-unit>
        <trans-unit id="0980855b93454e712e2b015cc0f5655541facb06" translate="yes" xml:space="preserve">
          <source>Tree-like CFG</source>
          <target state="translated">树状CFG</target>
        </trans-unit>
        <trans-unit id="0bb18642b70b9f8a9c12ccf39487328f306b8e19" translate="yes" xml:space="preserve">
          <source>Usage</source>
          <target state="translated">使用方法</target>
        </trans-unit>
        <trans-unit id="2d75d8dd04fd465844923c80ddf7cebda12ec86a" translate="yes" xml:space="preserve">
          <source>You need Absynthe if you wish to simulate the behavior of any well defined
process -- whether it's a computer application or a business process flow.</source>
          <target state="translated">如果您希望模拟任何定义好的过程的行为--无论是计算机应用程序还是业务流程,您都需要Absynthe。</target>
        </trans-unit>
        <trans-unit id="cfdf820be882593b466c12770bb42a1d31992322" translate="yes" xml:space="preserve">
          <source>any concrete implementation of the abstract &lt;code&gt;Behavior&lt;/code&gt; class, which
traverses the CFGs generated above and emits log messages.</source>
          <target state="translated">抽象 &lt;code&gt;Behavior&lt;/code&gt; 类的任何具体实现，该类遍历上面生成的CFG并发出日志消息。</target>
        </trans-unit>
        <trans-unit id="f56a005cb54785defd2347c651da587bf8d12c8c" translate="yes" xml:space="preserve">
          <source>any concrete implementation of the abstract &lt;code&gt;GraphBuilder&lt;/code&gt; class, which
generates CFGs, and</source>
          <target state="translated">生成CFG 的抽象 &lt;code&gt;GraphBuilder&lt;/code&gt; 类的任何具体实现，以及</target>
        </trans-unit>
        <trans-unit id="1746725b3599b57f2c3c7c184a1e129a4b71bc36" translate="yes" xml:space="preserve">
          <source>attaching loops on some of the nodes,</source>
          <target state="translated">在一些节点上附加环路。</target>
        </trans-unit>
        <trans-unit id="8de1898ddf3eff19dd8e421cfc5bd3eabb848a8c" translate="yes" xml:space="preserve">
          <source>constructing skip-level edges, i.e. edges from a node at level &lt;code&gt;i&lt;/code&gt; to a
node at level &amp;ge;&lt;code&gt;(i + 2)&lt;/code&gt;, and</source>
          <target state="translated">构造跳过级边，即从第 &lt;code&gt;i&lt;/code&gt; 级节点到&amp;ge; &lt;code&gt;(i + 2)&lt;/code&gt; 级节点的边缘，以及</target>
        </trans-unit>
        <trans-unit id="e1d5d9897e5bb0bd39df7fb5b19b181ff8ea808c" translate="yes" xml:space="preserve">
          <source>optionally, upward edges (not shown here), i.e. edges from a node at
level &lt;code&gt;i&lt;/code&gt; to a node at level &amp;le;&lt;code&gt;(i - 1)&lt;/code&gt;.</source>
          <target state="translated">可选地，向上边缘（此处未示出），即，从级别 &lt;code&gt;i&lt;/code&gt; 的节点到级别&amp;le; &lt;code&gt;(i - 1)&lt;/code&gt; 的节点的边缘。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
