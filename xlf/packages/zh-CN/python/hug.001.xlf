<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://pypi.org/project/hug/">
    <body>
      <group id="hug">
        <trans-unit id="1891cd1442749ae72069c9b8cd5cea2844856a51" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://hugapi.github.io/hug/&quot;&gt;Read Latest Documentation&lt;/a&gt; - &lt;a href=&quot;https://github.com/hugapi/hug&quot;&gt;Browse GitHub Code Repository&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://hugapi.github.io/hug/&quot;&gt;阅读最新文档&lt;/a&gt;-&lt;a href=&quot;https://github.com/hugapi/hug&quot;&gt;浏览GitHub代码存储库&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5fd1eceee6a3dddacede2ff00f0045a329abb963" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Directives&lt;/strong&gt; functions that get executed with the request / response data based on being requested as an argument in your api_function.
These apply as input parameters only, and can not be applied currently as output formats or transformations.</source>
          <target state="translated">&lt;strong&gt;&lt;/strong&gt;基于在api_function中作为参数被请求而使用请求/响应数据执行的&lt;strong&gt;指令&lt;/strong&gt;函数。这些仅用作输入参数，当前不能用作输出格式或转换。</target>
        </trans-unit>
        <trans-unit id="f0b92d435337779f16ada3f239b1093f1550126a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Input Formatters&lt;/strong&gt; a function that takes the body of data given from a user of your API and formats it for handling.</source>
          <target state="translated">&lt;strong&gt;输入格式化程序&lt;/strong&gt;可以接收API用户提供的数据主体并对其进行格式化以进行处理。</target>
        </trans-unit>
        <trans-unit id="5d0f84ef4dfbdd8691433446b2f3d30323ecfde0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;METHOD Decorators&lt;/strong&gt;&lt;code&gt;get&lt;/code&gt;, &lt;code&gt;post&lt;/code&gt;, &lt;code&gt;update&lt;/code&gt;, etc HTTP method decorators that expose your Python function as an API while keeping your Python method unchanged</source>
          <target state="translated">&lt;strong&gt;方法&lt;/strong&gt;修饰符 &lt;code&gt;get&lt;/code&gt; ， &lt;code&gt;post&lt;/code&gt; ， &lt;code&gt;update&lt;/code&gt; 等HTTP方法修饰符，这些修饰符将Python函数作为API公开，同时保持Python方法不变</target>
        </trans-unit>
        <trans-unit id="337920445117b90d3c38853e9b3f5a0a264ece63" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Middleware&lt;/strong&gt; functions that get called for every request a hug API processes</source>
          <target state="translated">&lt;strong&gt;&lt;/strong&gt;拥抱API处理每个请求的&lt;strong&gt;中间件&lt;/strong&gt;函数</target>
        </trans-unit>
        <trans-unit id="26cfd9566f33dc84fdf2e04ec121504c3a006a41" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Output Formatters&lt;/strong&gt; a function that takes the output of your API function and formats it for transport to the user of the API.</source>
          <target state="translated">&lt;strong&gt;输出格式化程序&lt;/strong&gt;可以获取API函数的输出并将其格式化以传输给API用户的函数。</target>
        </trans-unit>
        <trans-unit id="f0393068b82fd41f7d3c7b081d85a787d6aec1e6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Parameter mapping&lt;/strong&gt; can be used to override inferred parameter names, eg. for reserved keywords:</source>
          <target state="translated">&lt;strong&gt;参数映射&lt;/strong&gt;可用于覆盖推断的参数名称，例如。对于保留关键字：</target>
        </trans-unit>
        <trans-unit id="a046197910bd9944460f562ddf1c6de1a78eaa7e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Type Annotations&lt;/strong&gt; functions that optionally are attached to your methods arguments to specify how the argument is validated and converted into a Python type</source>
          <target state="translated">&lt;strong&gt;类型注释&lt;/strong&gt;函数，可以选择地附加到您的方法参数上，以指定如何验证参数并将其转换为Python类型</target>
        </trans-unit>
        <trans-unit id="3a951d35e81f9a92861645f522c6a01ab47401b1" translate="yes" xml:space="preserve">
          <source>A Python framework that makes developing APIs as simple as possible, but no simpler.</source>
          <target state="translated">一个Python框架,让开发API变得尽可能简单,但不会更简单。</target>
        </trans-unit>
        <trans-unit id="3d0a354729291e8b8f1225393dd2a6b39a8c8fb8" translate="yes" xml:space="preserve">
          <source>Adding your own directives is straight forward:</source>
          <target state="translated">添加自己的指令是直接的。</target>
        </trans-unit>
        <trans-unit id="b32141e09c28252c817db030d2a7de86a3b2a036" translate="yes" xml:space="preserve">
          <source>Additionally, you can easily create a custom 404 handler using the &lt;code&gt;hug.not_found&lt;/code&gt; decorator:</source>
          <target state="translated">此外，您可以使用 &lt;code&gt;hug.not_found&lt;/code&gt; 装饰器轻松创建自定义404处理程序：</target>
        </trans-unit>
        <trans-unit id="7f33cf112928c8c4636bfabd6fd6f96bee8527d0" translate="yes" xml:space="preserve">
          <source>As a result of these goals, hug is Python 3+ only and built upon &lt;a href=&quot;https://github.com/falconry/falcon&quot;&gt;Falcon's&lt;/a&gt; high performance HTTP library</source>
          <target state="translated">由于这些目标，拥抱仅适用于Python 3+，并基于&lt;a href=&quot;https://github.com/falconry/falcon&quot;&gt;Falcon的&lt;/a&gt;高性能HTTP库构建</target>
        </trans-unit>
        <trans-unit id="a8df05afb98eec12798dde02aa621accbaa4a973" translate="yes" xml:space="preserve">
          <source>Aside from the obvious input transformation use case, directives can be used to pipe data into your API functions, even if they are not present in the request query string, POST body, etc. For an example of how to use directives in this way, see the authentication example in the examples folder.</source>
          <target state="translated">除了显而易见的输入转换用例之外,指令还可以用来将数据导入到你的API函数中,即使它们不存在于请求查询字符串、POST body等中。关于如何以这种方式使用指令的例子,请参见examples文件夹中的验证示例。</target>
        </trans-unit>
        <trans-unit id="87fae54a50b27140b756b9e37a86b1e78537c4a1" translate="yes" xml:space="preserve">
          <source>Asyncio support</source>
          <target state="translated">支持Asyncio</target>
        </trans-unit>
        <trans-unit id="754e1e5db57d014e36284f09734da7ee9ade8e7f" translate="yes" xml:space="preserve">
          <source>Be the basis for next generation Python APIs, embracing the latest technology.</source>
          <target state="translated">成为下一代Python API的基础,拥抱最新技术。</target>
        </trans-unit>
        <trans-unit id="e104776120d29dd6459bcfa52cf9116c58729400" translate="yes" xml:space="preserve">
          <source>Build an example API with a simple endpoint in just a few lines.</source>
          <target state="translated">只需几行字就能用一个简单的端点构建一个示例API。</target>
        </trans-unit>
        <trans-unit id="22fce8cfcd346175db9ddbab078350c1a657d4f3" translate="yes" xml:space="preserve">
          <source>Building Blocks of a hug API</source>
          <target state="translated">拥抱API的构件</target>
        </trans-unit>
        <trans-unit id="973e7afeaa4e40433590d46f7048f4263188c8b7" translate="yes" xml:space="preserve">
          <source>By default, hug returns an auto generated API spec when a user tries to access an endpoint that isn't defined. If you would not like to return this spec you can turn off 404 documentation:</source>
          <target state="translated">默认情况下,当用户试图访问一个没有定义的端点时,hug会返回一个自动生成的API规范。如果你不想返回这个规范,你可以关闭404文档。</target>
        </trans-unit>
        <trans-unit id="ed3c98a24ca7c20314ccede0ba6b97c33e7cd11d" translate="yes" xml:space="preserve">
          <source>By default, the IP is 172.17.0.1. Assuming that's the IP you see, as well, you would then go to &lt;code&gt;http://172.17.0.1:8000/&lt;/code&gt; in your browser to view your API.</source>
          <target state="translated">默认情况下，IP为172.17.0.1。假设这也是您看到的IP，然后您将在浏览器中转到 &lt;code&gt;http://172.17.0.1:8000/&lt;/code&gt; 查看API。</target>
        </trans-unit>
        <trans-unit id="db63f0c176088a648bb7851cf6d0b3c69e011ded" translate="yes" xml:space="preserve">
          <source>Can be imported into the main API file:</source>
          <target state="translated">可以导入到主API文件中。</target>
        </trans-unit>
        <trans-unit id="0ce123ace99cd0029fc0622f5a38b96e8cbee984" translate="yes" xml:space="preserve">
          <source>Configuring hug 404</source>
          <target state="translated">配置hug 404</target>
        </trans-unit>
        <trans-unit id="29c1f935aff4d7ef2949abda669b629a517cdd9a" translate="yes" xml:space="preserve">
          <source>Directives may be accessed via an argument with a &lt;code&gt;hug_&lt;/code&gt; prefix, or by using Python 3 type annotations. The latter is the more modern approach, and is recommended. Directives declared in a module can be accessed by using their fully qualified name as the type annotation (ex: &lt;code&gt;module.directive_name&lt;/code&gt;).</source>
          <target state="translated">可以通过带有 &lt;code&gt;hug_&lt;/code&gt; 前缀的参数或使用Python 3类型注释来访问指令。后者是更现代的方法，建议使用。可以使用模块的标准名称作为类型注释（例如： &lt;code&gt;module.directive_name&lt;/code&gt; ）来访问模块中声明的指令。</target>
        </trans-unit>
        <trans-unit id="358d84aa8148063b462186c221ef88a0bda8ec99" translate="yes" xml:space="preserve">
          <source>For Example:</source>
          <target state="translated">例如:</target>
        </trans-unit>
        <trans-unit id="7785dfa6b5b2ac73312e8d5251b8d042d702b7f1" translate="yes" xml:space="preserve">
          <source>For completeness, here is an example of accessing the directive via the magic name approach:</source>
          <target state="translated">为了完整起见,这里有一个通过魔名方法访问指令的例子。</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">例如:</target>
        </trans-unit>
        <trans-unit id="ec1e6db6e6c03fb8bad69c299593b12da3a0dc24" translate="yes" xml:space="preserve">
          <source>From the command line application:</source>
          <target state="translated">从命令行应用程序中。</target>
        </trans-unit>
        <trans-unit id="bdb4e742101adce19db03bb43f2a3ef4a3a7e139" translate="yes" xml:space="preserve">
          <source>Get professionally supported hug with the Tidelift Subscription</source>
          <target state="translated">获得专业支持的抱抱,使用泰得利订购。</target>
        </trans-unit>
        <trans-unit id="010b85ad56b34c34c7c2a3b2436c740e30428ed5" translate="yes" xml:space="preserve">
          <source>Getting Started</source>
          <target state="translated">入门</target>
        </trans-unit>
        <trans-unit id="b33664f205bae044a7540d189a9f463f85322603" translate="yes" xml:space="preserve">
          <source>HUG simply stands for Hopefully Useful Guide. This represents the project's goal to help guide developers into creating well written and intuitive APIs.</source>
          <target state="translated">HUG简单来说是Hopefully Useful Guide的缩写。这代表了项目的目标,即帮助指导开发者创建良好的编写和直观的API。</target>
        </trans-unit>
        <trans-unit id="4241eda4d6144efaa18c072736bfe08f7593223d" translate="yes" xml:space="preserve">
          <source>Ideally, within a &lt;a href=&quot;http://docs.python-guide.org/en/latest/dev/virtualenvs/&quot;&gt;virtual environment&lt;/a&gt;.</source>
          <target state="translated">理想情况下，在&lt;a href=&quot;http://docs.python-guide.org/en/latest/dev/virtualenvs/&quot;&gt;虚拟环境中&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="32ee1aa77e7bb32063fdb2b2fc12e0c28a6d63ab" translate="yes" xml:space="preserve">
          <source>If you like to develop in Docker and keep your system clean, you can do that but you'll need to first install &lt;a href=&quot;https://docs.docker.com/compose/install/&quot;&gt;Docker Compose&lt;/a&gt;.</source>
          <target state="translated">如果您想在Docker中进行开发并保持系统清洁，则可以这样做，但是首先需要安装&lt;a href=&quot;https://docs.docker.com/compose/install/&quot;&gt;Docker Compose&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7f9b6c5909f91a333882fd964ac2dbbc32dbbfa3" translate="yes" xml:space="preserve">
          <source>Input formatters are mapped based on the &lt;code&gt;content_type&lt;/code&gt; of the request data, and only perform basic parsing. More detailed parsing should be done by the Type Annotations present on your &lt;code&gt;api_function&lt;/code&gt;</source>
          <target state="translated">输入格式化程序根据请求数据的 &lt;code&gt;content_type&lt;/code&gt; 进行映射，并且仅执行基本解析。更详细的解析应通过 &lt;code&gt;api_function&lt;/code&gt; 中的Type Annotations完成。</target>
        </trans-unit>
        <trans-unit id="7c920197ca42bd6cbc5aaef91042da46af9d9ad6" translate="yes" xml:space="preserve">
          <source>Installing hug</source>
          <target state="translated">安装抱枕</target>
        </trans-unit>
        <trans-unit id="9279433dcb5025919ded69799bd1fcfdd4bbeca1" translate="yes" xml:space="preserve">
          <source>Installing hug is as simple as:</source>
          <target state="translated">安装抱抱就这么简单。</target>
        </trans-unit>
        <trans-unit id="831984903762fc97309a8e41bcf90f4c95b8dd38" translate="yes" xml:space="preserve">
          <source>It should be fast. A developer should never feel the need to look somewhere else for performance reasons.</source>
          <target state="translated">它应该是快速的。开发者永远不应该因为性能原因而觉得需要去别的地方找。</target>
        </trans-unit>
        <trans-unit id="bf52013fff0f47b4338b87ed66a34d37ea549a73" translate="yes" xml:space="preserve">
          <source>Magic done once, in an API framework, is better than pushing the problem set to the user of the API framework.</source>
          <target state="translated">在API框架中,一次完成的魔术,比把问题集推送给API框架的用户要好。</target>
        </trans-unit>
        <trans-unit id="d23eebc35f489d3b763d90e2c12b6a6a144a1e89" translate="yes" xml:space="preserve">
          <source>Make developing a Python driven API as succinct as a written definition.</source>
          <target state="translated">让开发一个Python驱动的API像书面定义一样简洁。</target>
        </trans-unit>
        <trans-unit id="4850343cb2494afc0d45b0bdbcfb4698a176fb71" translate="yes" xml:space="preserve">
          <source>NOTE: Hug is running on top Falcon which is not an asynchronous server. Even if using
asyncio, requests will still be processed synchronously.</source>
          <target state="translated">注意:Hug运行在Falcon之上,而Falcon不是异步服务器。即使使用asyncio,请求仍然会被同步处理。</target>
        </trans-unit>
        <trans-unit id="3cc3453903d306e07a247c36a1a7aade091f9601" translate="yes" xml:space="preserve">
          <source>Note: versioning in hug automatically supports both the version header as well as direct URL based specification.</source>
          <target state="translated">注意:hug中的版本管理自动支持版本头以及直接基于URL的规范。</target>
        </trans-unit>
        <trans-unit id="9be8845d032ba090ccafb26f1758fd381984819c" translate="yes" xml:space="preserve">
          <source>On your Docker &lt;code&gt;workspace&lt;/code&gt; container, the &lt;code&gt;./docker/templates&lt;/code&gt; directory on your host computer is mounted to &lt;code&gt;/src&lt;/code&gt; in the Docker container. This is specified under &lt;code&gt;services&lt;/code&gt; &amp;gt; &lt;code&gt;app&lt;/code&gt; of &lt;code&gt;./docker/docker-compose.yml&lt;/code&gt;.</source>
          <target state="translated">在Docker &lt;code&gt;workspace&lt;/code&gt; 容器上，主机上的 &lt;code&gt;./docker/templates&lt;/code&gt; 目录已安装到Docker容器中的 &lt;code&gt;/src&lt;/code&gt; 。这是在 &lt;code&gt;./docker/docker-compose.yml&lt;/code&gt; 的 &lt;code&gt;services&lt;/code&gt; &amp;gt; &lt;code&gt;app&lt;/code&gt; 下指定的。</target>
        </trans-unit>
        <trans-unit id="aa9860d695862a7eb3daf9e8e36c34497710171a" translate="yes" xml:space="preserve">
          <source>Once you've done that, you'll need to &lt;code&gt;cd&lt;/code&gt; into the &lt;code&gt;docker&lt;/code&gt; directory and run the web server (Gunicorn) specified in &lt;code&gt;./docker/gunicorn/Dockerfile&lt;/code&gt;, after which you can preview the output of your API in the browser on your host machine.</source>
          <target state="translated">一旦你做到了这一点，你需要 &lt;code&gt;cd&lt;/code&gt; 到 &lt;code&gt;docker&lt;/code&gt; 目录和运行中指定的Web服务器（Gunicorn） &lt;code&gt;./docker/gunicorn/Dockerfile&lt;/code&gt; ，之后您可以预览API的输出在浏览器上你主机。</target>
        </trans-unit>
        <trans-unit id="10610ae894a2a7a10eede2205febf1d1758dac6f" translate="yes" xml:space="preserve">
          <source>Or alternatively - for cases like this - where only one module is being included per a URL route:</source>
          <target state="translated">或者像这样的情况--一个URL路由只包含一个模块。</target>
        </trans-unit>
        <trans-unit id="9599139a3da06884b1086130404707b1c040bb60" translate="yes" xml:space="preserve">
          <source>Parameters can also be encoded in the URL (check
out &lt;a href=&quot;examples/happy_birthday.py&quot;&gt;&lt;code&gt;happy_birthday.py&lt;/code&gt;&lt;/a&gt; for the whole
example).</source>
          <target state="translated">参数也可以在URL中编码（查看整个示例的&lt;a href=&quot;examples/happy_birthday.py&quot;&gt; &lt;code&gt;happy_birthday.py&lt;/code&gt; &lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="70eea5c68d9f081a0dac9b82df9ef6906b884950" translate="yes" xml:space="preserve">
          <source>Professional support for hug is available as part of the &lt;a href=&quot;https://tidelift.com/subscription/pkg/pypi-hug?utm_source=pypi-hug&amp;amp;utm_medium=referral&amp;amp;utm_campaign=readme&quot;&gt;Tidelift
Subscription&lt;/a&gt;.
Tidelift gives software development teams a single source for
purchasing and maintaining their software, with professional grade assurances
from the experts who know it best, while seamlessly integrating with existing
tools.</source>
          <target state="translated">&lt;a href=&quot;https://tidelift.com/subscription/pkg/pypi-hug?utm_source=pypi-hug&amp;amp;utm_medium=referral&amp;amp;utm_campaign=readme&quot;&gt;Tidelift订阅中包含&lt;/a&gt;专业的拥抱支持。Tidelift为软件开发团队提供了购买和维护其软件的单一渠道，并由最了解它的专家提供专业等级保证，同时与现有工具无缝集成。</target>
        </trans-unit>
        <trans-unit id="4ad07fe8cab325006610e5c7f9d4c3cf9d378e9a" translate="yes" xml:space="preserve">
          <source>Running hug with other WSGI based servers</source>
          <target state="translated">与其他基于WSGI的服务器运行拥抱</target>
        </trans-unit>
        <trans-unit id="7e197170524d0049b65494c29f9941c06215db04" translate="yes" xml:space="preserve">
          <source>Security contact information</source>
          <target state="translated">安全联系信息</target>
        </trans-unit>
        <trans-unit id="a5f0572bebdaf623329747d1a6d728c16dcb7212" translate="yes" xml:space="preserve">
          <source>Splitting APIs over multiple files</source>
          <target state="translated">在多个文件上分割API</target>
        </trans-unit>
        <trans-unit id="92428f0e12da119c2c985be2440ab07ccde29faa" translate="yes" xml:space="preserve">
          <source>Supporting hug development</source>
          <target state="translated">支持抱团发展</target>
        </trans-unit>
        <trans-unit id="fda1a2f92c23d9bd588062628a1a6dec5fce5020" translate="yes" xml:space="preserve">
          <source>Testing hug APIs</source>
          <target state="translated">测试拥抱API</target>
        </trans-unit>
        <trans-unit id="0a0dc0ebd769cd2d6e2f3c5c04c9ba7bb9d6375f" translate="yes" xml:space="preserve">
          <source>Thanks and I hope you find &lt;em&gt;this&lt;/em&gt; hug helpful as you develop your next Python API!</source>
          <target state="translated">谢谢，我希望&lt;em&gt;这个&lt;/em&gt;拥抱对您开发下一个Python API有帮助！</target>
        </trans-unit>
        <trans-unit id="6b5748267b4a92ff501ece9f49a1eae7d4bdd557" translate="yes" xml:space="preserve">
          <source>The framework should encourage code that self-documents.</source>
          <target state="translated">该框架应该鼓励代码自我记录。</target>
        </trans-unit>
        <trans-unit id="4c3a720e1f09b4bf3195ba27f2a83cc0403fae64" translate="yes" xml:space="preserve">
          <source>Then you can access the example from &lt;code&gt;localhost:8000/v1/echo?text=Hi&lt;/code&gt; / &lt;code&gt;localhost:8000/v2/echo?text=Hi&lt;/code&gt; Or access the documentation for your API from &lt;code&gt;localhost:8000&lt;/code&gt;</source>
          <target state="translated">然后，您可以从 &lt;code&gt;localhost:8000/v1/echo?text=Hi&lt;/code&gt; / &lt;code&gt;localhost:8000/v2/echo?text=Hi&lt;/code&gt; 访问示例，或者从 &lt;code&gt;localhost:8000&lt;/code&gt; 访问API文档。</target>
        </trans-unit>
        <trans-unit id="85423025067361be7aff0e935bf79ce621300d9a" translate="yes" xml:space="preserve">
          <source>This decorator works in the same manner as the hug HTTP method decorators, and is even version aware:</source>
          <target state="translated">这个装饰器的工作方式和hug HTTP方法装饰器一样,甚至还能感知版本。</target>
        </trans-unit>
        <trans-unit id="4b5392cfdf232f6cc068904b2d9b657e651e978e" translate="yes" xml:space="preserve">
          <source>To report a security vulnerability, please use the
&lt;a href=&quot;https://tidelift.com/security&quot;&gt;Tidelift security contact&lt;/a&gt;.
Tidelift will coordinate the fix and disclosure.</source>
          <target state="translated">要报告安全漏洞，请使用&lt;a href=&quot;https://tidelift.com/security&quot;&gt;Tidelift安全联系人&lt;/a&gt;。Tidelift将协调修复和公开。</target>
        </trans-unit>
        <trans-unit id="bd75e7993dd4451f4e2e80c87bb17eaf0f068b43" translate="yes" xml:space="preserve">
          <source>To run the example:</source>
          <target state="translated">要运行这个例子。</target>
        </trans-unit>
        <trans-unit id="c1e8307e6a9d01923949fbbd7e72d258fbe70276" translate="yes" xml:space="preserve">
          <source>To run the hello world hug example API.</source>
          <target state="translated">要运行hello world hug示例API。</target>
        </trans-unit>
        <trans-unit id="cc3a5a60ceb8a3bda715ca81ef1dd0184522d378" translate="yes" xml:space="preserve">
          <source>To run, from the command line type:</source>
          <target state="translated">要运行,从命令行输入:</target>
        </trans-unit>
        <trans-unit id="460f7658f324eaf15f96e695cc776bdfeb4def6a" translate="yes" xml:space="preserve">
          <source>Type annotations also feed into &lt;code&gt;hug&lt;/code&gt;'s automatic documentation
generation to let users of your API know what data to supply.</source>
          <target state="translated">类型批注还加入到 &lt;code&gt;hug&lt;/code&gt; 的自动文档生成中，以使您的API用户知道要提供什么数据。</target>
        </trans-unit>
        <trans-unit id="f1e887ad301db2838308801456e01403dfd27811" translate="yes" xml:space="preserve">
          <source>Using Docker</source>
          <target state="translated">使用Docker</target>
        </trans-unit>
        <trans-unit id="b3a69340ce0be8b5b74b7e46cc90f9bdf3479d67" translate="yes" xml:space="preserve">
          <source>Using Python 3.5 async keyword.</source>
          <target state="translated">使用Python 3.5 async关键字。</target>
        </trans-unit>
        <trans-unit id="e944aca10e018a969b5d6881683c7baf9dcf0f14" translate="yes" xml:space="preserve">
          <source>Using asyncio coroutine decorator</source>
          <target state="translated">使用asyncio coroutine decorator</target>
        </trans-unit>
        <trans-unit id="5e51f6cfcd116a5a628b50e89b4f92dc36c5179c" translate="yes" xml:space="preserve">
          <source>Versioning with hug</source>
          <target state="translated">拥抱的版本</target>
        </trans-unit>
        <trans-unit id="09156ba196e26e6c7e939d56e7a41867c91c8cdb" translate="yes" xml:space="preserve">
          <source>When building an API using the hug framework you'll use the following concepts:</source>
          <target state="translated">当使用hug框架构建一个API时,你将使用以下概念。</target>
        </trans-unit>
        <trans-unit id="fc1dcc9006d3215e8d86472a32249b3b0d28c175" translate="yes" xml:space="preserve">
          <source>When using the &lt;code&gt;get&lt;/code&gt; and &lt;code&gt;cli&lt;/code&gt; method decorator on coroutines, hug will schedule
the execution of the coroutine.</source>
          <target state="translated">在协程上使用 &lt;code&gt;get&lt;/code&gt; 和 &lt;code&gt;cli&lt;/code&gt; 方法修饰符时，拥抱将安排协程的执行。</target>
        </trans-unit>
        <trans-unit id="a8c632d98b9268376854cbc30eae096e0ad704ba" translate="yes" xml:space="preserve">
          <source>Which, once you are running the server as above, you can use this way:</source>
          <target state="translated">其中,当你按照上面的方式运行服务器后,你就可以使用这种方式。</target>
        </trans-unit>
        <trans-unit id="d0a3f7e6138efc1ed8290339051ecc68996dd29f" translate="yes" xml:space="preserve">
          <source>Why hug?</source>
          <target state="translated">为什么要拥抱?</target>
        </trans-unit>
        <trans-unit id="92066db15ca2736eb11343ec0aadc200ecf6f967" translate="yes" xml:space="preserve">
          <source>Writing tests for APIs written on-top of hug should be easy and intuitive.</source>
          <target state="translated">为写在hug之上的API编写测试应该是简单而直观的。</target>
        </trans-unit>
        <trans-unit id="69d5b5a97e867377eb7c90bf67d6835ea56e79a9" translate="yes" xml:space="preserve">
          <source>You can access the example in your browser at:
&lt;code&gt;localhost:8000/happy_birthday?name=hug&amp;amp;age=1&lt;/code&gt;. Then check out the
documentation for your API at &lt;code&gt;localhost:8000/documentation&lt;/code&gt;</source>
          <target state="translated">您可以在浏览器中访问以下示例： &lt;code&gt;localhost:8000/happy_birthday?name=hug&amp;amp;age=1&lt;/code&gt; 。然后在 &lt;code&gt;localhost:8000/documentation&lt;/code&gt; 上查看API的文档</target>
        </trans-unit>
        <trans-unit id="c975556850a95fbf44c5d623233058643734a205" translate="yes" xml:space="preserve">
          <source>You can also easily add any Falcon style middleware using:</source>
          <target state="translated">您还可以使用以下方法轻松添加任何Falcon风格的中间件。</target>
        </trans-unit>
        <trans-unit id="a98264703b814e298ce686a7fef9cd2bd9476746" translate="yes" xml:space="preserve">
          <source>You can also log into a Docker container that you can consider your work space. This workspace has Python and Pip installed so you can use those tools within Docker. If you need to test the CLI interface, for example, you would use this.</source>
          <target state="translated">你也可以登录一个Docker容器,你可以将其视为你的工作空间。这个工作空间安装了Python和Pip,所以你可以在Docker中使用这些工具。例如,如果你需要测试CLI接口,你会使用这个。</target>
        </trans-unit>
        <trans-unit id="acbfd6cceacd1855a44b41caf026e84b2d619740" translate="yes" xml:space="preserve">
          <source>You can use this &lt;code&gt;Response&lt;/code&gt; object for test assertions (check
out &lt;a href=&quot;examples/test_happy_birthday.py&quot;&gt;&lt;code&gt;test_happy_birthday.py&lt;/code&gt;&lt;/a&gt; ):</source>
          <target state="translated">您可以将此 &lt;code&gt;Response&lt;/code&gt; 对象用于测试断言（请检出&lt;a href=&quot;examples/test_happy_birthday.py&quot;&gt; &lt;code&gt;test_happy_birthday.py&lt;/code&gt; &lt;/a&gt;）：</target>
        </trans-unit>
        <trans-unit id="68863bd3822201be0e105f9d6f13a036936a9dbe" translate="yes" xml:space="preserve">
          <source>as shown, you can easily change the output format for both an entire API as well as an individual API call</source>
          <target state="translated">如图所示,你可以很容易地改变整个API以及单个API调用的输出格式。</target>
        </trans-unit>
        <trans-unit id="5260dfd635468aad848584daf1e1051cea7a8706" translate="yes" xml:space="preserve">
          <source>hug aims to make developing Python driven APIs as simple as possible, but no simpler. As a result, it drastically simplifies Python API development.</source>
          <target state="translated">hug的目的是让开发Python驱动的API尽可能的简单,但不会更简单。因此,它极大地简化了Python API的开发。</target>
        </trans-unit>
        <trans-unit id="ccbdd588925c256b0089f80475f85b716a8765e4" translate="yes" xml:space="preserve">
          <source>hug enables you to organize large projects in any manner you see fit. You can import any module that contains hug decorated functions (request handling, directives, type handlers, etc) and extend your base API with that module.</source>
          <target state="translated">hug使你能够以任何你认为合适的方式组织大型项目。你可以导入任何包含hug装饰函数的模块(请求处理、指令、类型处理程序等),并使用该模块扩展你的基础API。</target>
        </trans-unit>
        <trans-unit id="d6cf0c89c4034b80e5b63e10795426ce000eb1b2" translate="yes" xml:space="preserve">
          <source>hug exposes a &lt;code&gt;__hug_wsgi__&lt;/code&gt; magic method on every API module automatically. Running your hug based API on any standard wsgi server should be as simple as pointing it to &lt;code&gt;module_name&lt;/code&gt;: &lt;code&gt;__hug_wsgi__&lt;/code&gt;.</source>
          <target state="translated">拥抱会在每个API模块上自动公开 &lt;code&gt;__hug_wsgi__&lt;/code&gt; 魔术方法。在任何标准wsgi服务器上运行基于拥抱的API都应该像将其指向 &lt;code&gt;module_name&lt;/code&gt; 一样简单： &lt;code&gt;__hug_wsgi__&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="63294d52f42102fddab47d3be28869d5d978e85a" translate="yes" xml:space="preserve">
          <source>hug takes security and quality seriously. This focus is why we depend only on thoroughly tested components and utilize static analysis tools (such as bandit and safety) to verify the security of our code base.
If you find or encounter any potential security issues, please let us know right away so we can resolve them.</source>
          <target state="translated">hug非常重视安全和质量。这也是为什么我们只依赖经过彻底测试的组件,并利用静态分析工具(如 bandit 和 safety)来验证我们代码库的安全性。如果您发现或遇到任何潜在的安全问题,请立即告诉我们,以便我们解决它们。</target>
        </trans-unit>
        <trans-unit id="840c736b58826c43bb285b4729a6389c2a271f7e" translate="yes" xml:space="preserve">
          <source>hug uses the structure of the function you decorate to automatically generate documentation for users of your API. hug always passes a request, response, and api_version variable to your function if they are defined params in your function definition.</source>
          <target state="translated">如果函数定义中定义了params,那么hug会将request、response和api_version变量传递给你的函数。</target>
        </trans-unit>
        <trans-unit id="4dba083e9006e12eb8972a15afb1acc690437b00" translate="yes" xml:space="preserve">
          <source>hug's &lt;code&gt;http&lt;/code&gt; method decorators don't modify your original functions. This makes testing hug APIs as simple as testing any other Python functions. Additionally, this means interacting with your API functions in other Python code is as straight forward as calling Python only API functions. hug makes it easy to test the full Python stack of your API by using the &lt;code&gt;hug.test&lt;/code&gt; module:</source>
          <target state="translated">拥抱的 &lt;code&gt;http&lt;/code&gt; 方法修饰符不会修改您的原始功能。这使得测试拥抱API就像测试其他Python函数一样简单。此外，这意味着与其他Python代码中的API函数进行交互就像调用仅Python API函数一样简单。通过使用 &lt;code&gt;hug.test&lt;/code&gt; 模块，可以很容易地测试API的完整Python堆栈：</target>
        </trans-unit>
        <trans-unit id="a1ca4d71412d197d55f7225c9894b598beacb582" translate="yes" xml:space="preserve">
          <source>hug's Design Objectives:</source>
          <target state="translated">hug的设计目标。</target>
        </trans-unit>
        <trans-unit id="6415c2d844d4e6ce1c534ee71f1d8a7e411903ea" translate="yes" xml:space="preserve">
          <source>~Timothy Crosley</source>
          <target state="translated">〜蒂莫西&amp;middot;克罗斯利</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
