<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://pypi.org/project/netfilterqueue/">
    <body>
      <group id="netfilterqueue">
        <trans-unit id="34c5f4d9647af744e1c72f64867d010e6b05ba1a" translate="yes" xml:space="preserve">
          <source>, and rebuild.</source>
          <target state="translated">, and rebuild.</target>
        </trans-unit>
        <trans-unit id="f1ce8f7ef7dd119a8970ce98f05c519d94055cf4" translate="yes" xml:space="preserve">
          <source>, then start receiving packets with a call to</source>
          <target state="translated">, then start receiving packets with a call to</target>
        </trans-unit>
        <trans-unit id="2dff8be0f7d3def5ea34e6c600ffd095cdef501a" translate="yes" xml:space="preserve">
          <source>A C compiler</source>
          <target state="translated">一个C语言编译器</target>
        </trans-unit>
        <trans-unit id="08ece874f59033bcbf82b053a86c42e906720401" translate="yes" xml:space="preserve">
          <source>A NetfilterQueue object represents a single queue. Configure your queue with
a call to</source>
          <target state="translated">一个NetfilterQueue对象代表一个单一的队列。通过调用</target>
        </trans-unit>
        <trans-unit id="d93d10ff0fbef1b4aa0ddc24e10e907746d3c85a" translate="yes" xml:space="preserve">
          <source>API</source>
          <target state="translated">API</target>
        </trans-unit>
        <trans-unit id="6e4657bd053719cc651b8db4284b4871781028f9" translate="yes" xml:space="preserve">
          <source>Accept the packet.</source>
          <target state="translated">接受数据包。</target>
        </trans-unit>
        <trans-unit id="2aa2f29c230e06bb8df07aaade412f178213a8ef" translate="yes" xml:space="preserve">
          <source>Bound process ID</source>
          <target state="translated">绑定流程ID</target>
        </trans-unit>
        <trans-unit id="02c0bf2d2c66cef9a79a400c4e5d3f1af8560e67" translate="yes" xml:space="preserve">
          <source>Callback objects</source>
          <target state="translated">回调对象</target>
        </trans-unit>
        <trans-unit id="1a804c44ea894d5351b2eff7384b3af0f32e037b" translate="yes" xml:space="preserve">
          <source>Compiled with a 4096-byte buffer for packets, so it probably won&amp;rsquo;t work on
loopback or Ethernet with jumbo packets. If this is a problem, either lower
MTU on your loopback, disable jumbo packets, or get Cython,
change</source>
          <target state="translated">Compiled with a 4096-byte buffer for packets, so it probably won&amp;rsquo;t work on loopback or Ethernet with jumbo packets. If this is a problem, either lower MTU on your loopback, disable jumbo packets, or get Cython, change</target>
        </trans-unit>
        <trans-unit id="67b9f5bf5872b56c0fce5167d3f281b233b1d9a0" translate="yes" xml:space="preserve">
          <source>Copy mode</source>
          <target state="translated">复制模式</target>
        </trans-unit>
        <trans-unit id="3d1ebcd2c52b82c6dd3e60cc33604e868535c8ac" translate="yes" xml:space="preserve">
          <source>Copy size</source>
          <target state="translated">复制大小</target>
        </trans-unit>
        <trans-unit id="67850bc8e2c8a7dcab55880cd81dc0628d244471" translate="yes" xml:space="preserve">
          <source>Copyright (c) 2011, Kerkhoff Technologies, Inc.</source>
          <target state="translated">Copyright (c)2011,Kerkhoff Technologies,Inc.</target>
        </trans-unit>
        <trans-unit id="840456fd71d9750adbe6e0a11cd6101f6aad286f" translate="yes" xml:space="preserve">
          <source>Create and bind to the queue.</source>
          <target state="translated">创建并绑定到队列中。</target>
        </trans-unit>
        <trans-unit id="918be972a485bbb0dfae1cfbdf4196143c3a93b7" translate="yes" xml:space="preserve">
          <source>DEF BufferSize = 4096</source>
          <target state="translated">DEF BufferSize=4096</target>
        </trans-unit>
        <trans-unit id="3f80c04b656645005a80baefd19d0ec440b11a60" translate="yes" xml:space="preserve">
          <source>Drop the packet.</source>
          <target state="translated">丢掉这个包。</target>
        </trans-unit>
        <trans-unit id="0f01ed56a1e32a05e5ef96e4d779f34784af9a96" translate="yes" xml:space="preserve">
          <source>Example</source>
          <target state="translated">例子</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">例如:</target>
        </trans-unit>
        <trans-unit id="0497f9c6f240debffc9e9a2160d24cab3f0d8f5e" translate="yes" xml:space="preserve">
          <source>From PyPI</source>
          <target state="translated">来自PyPI</target>
        </trans-unit>
        <trans-unit id="d600deecd9fabec09865ba5fbee27a4731d8713b" translate="yes" xml:space="preserve">
          <source>From source</source>
          <target state="translated">来自来源</target>
        </trans-unit>
        <trans-unit id="a65f239128468ac0b18567b89b5871064c571581" translate="yes" xml:space="preserve">
          <source>Full libnetfilter_queue API is not yet implemented:</source>
          <target state="translated">尚未实现完整的libnetfilter_queue API。</target>
        </trans-unit>
        <trans-unit id="1bd35aaa1a17fb006c7de8a98962e104ad6e649a" translate="yes" xml:space="preserve">
          <source>Get the file descriptor of the queue handler.</source>
          <target state="translated">获取队列处理程序的文件描述符。</target>
        </trans-unit>
        <trans-unit id="aba1404a9ded53966af8158b258b9bd6433abeb5" translate="yes" xml:space="preserve">
          <source>Get the mark already on the packet.</source>
          <target state="translated">得到的标记已经在包上。</target>
        </trans-unit>
        <trans-unit id="d6e265794b19c64dbf79c3f2613a61d79bc5626d" translate="yes" xml:space="preserve">
          <source>Give the packet a kernel mark.</source>
          <target state="translated">给数据包一个内核标记。</target>
        </trans-unit>
        <trans-unit id="7c8e1bf13fe3e1ddcb2f80c62d8b8f81380e3458" translate="yes" xml:space="preserve">
          <source>Handle a single packet from the queue. You must call either</source>
          <target state="translated">处理队列中的单个数据包。您必须调用</target>
        </trans-unit>
        <trans-unit id="8acae9dfc4a2257ffb1c00ccf6a8221cfc8a4ea5" translate="yes" xml:space="preserve">
          <source>If Cython is installed, Distutils will use it to regenerate the .c source from the .pyx. It will then compile the .c into a .so.</source>
          <target state="translated">如果安装了Cython,Distutils将使用它从.pyx中重新生成.c源代码。然后它将把.c编译成.so。</target>
        </trans-unit>
        <trans-unit id="c81b79df3c6448eae7c4f80428b54cd5692a17d7" translate="yes" xml:space="preserve">
          <source>Installation</source>
          <target state="translated">安装</target>
        </trans-unit>
        <trans-unit id="6a2eb4275b5f1bcf07cce7d06ced16b9fe7641b3" translate="yes" xml:space="preserve">
          <source>Iterate the same cycle once more.</source>
          <target state="translated">再迭代一次同样的循环。</target>
        </trans-unit>
        <trans-unit id="6a574e10a7e332a93431a87d2200ab88b8249518" translate="yes" xml:space="preserve">
          <source>Libnetfilter_queue (the netfilter library, not this module) is part of the
&lt;a href=&quot;http://netfilter.org/projects/libnetfilter_queue/&quot;&gt;Netfilter project&lt;/a&gt;.</source>
          <target state="translated">Libnetfilter_queue (the netfilter library, not this module) is part of the &lt;a href=&quot;http://netfilter.org/projects/libnetfilter_queue/&quot;&gt;Netfilter project&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="3c2109bddae8e214d03b79f6f5cdc10df26c4202" translate="yes" xml:space="preserve">
          <source>Libnetfilter_queue development files and associated dependencies</source>
          <target state="translated">Libnetfilter_queue开发文件和相关的依赖关系。</target>
        </trans-unit>
        <trans-unit id="3229609e15436ec51bcf00818a69a84dbc58a0c2" translate="yes" xml:space="preserve">
          <source>License</source>
          <target state="translated">许可证</target>
        </trans-unit>
        <trans-unit id="a7c04c64ed3f2a9374590c76c50d3b7f1b18e3da" translate="yes" xml:space="preserve">
          <source>Limitations</source>
          <target state="translated">局限性</target>
        </trans-unit>
        <trans-unit id="569e10846b9c6e380e6808ca426ca621c2f5882f" translate="yes" xml:space="preserve">
          <source>MIT licensed</source>
          <target state="translated">麻省理工学院许可</target>
        </trans-unit>
        <trans-unit id="5c6a49bec27623f009e68a24c2137f0f4a4a7f67" translate="yes" xml:space="preserve">
          <source>NetfilterQueue is a C extention module that links against libnetfilter_queue.
Before installing, ensure you have:</source>
          <target state="translated">NetfilterQueue是一个与libnetfilter_queue相对应的C语言扩展模块。在安装之前,请确保你有。</target>
        </trans-unit>
        <trans-unit id="1a904e87f5ecd6e3af35a074a34a5d2ababda015" translate="yes" xml:space="preserve">
          <source>NetfilterQueue objects</source>
          <target state="translated">NetfilterQueue对象</target>
        </trans-unit>
        <trans-unit id="b0c7d4321a01e58b6c9daf67ad590e874cc8d6fa" translate="yes" xml:space="preserve">
          <source>NetfilterQueue provides access to packets matched by an iptables rule in
Linux. Packets so matched can be accepted, dropped, altered, or given a mark.</source>
          <target state="translated">NetfilterQueue提供了对Linux中iptables规则所匹配的数据包的访问。匹配到的数据包可以被接受、丢弃、更改或给予标记。</target>
        </trans-unit>
        <trans-unit id="f469c63dda59a61d64a96362f99c867ee899e896" translate="yes" xml:space="preserve">
          <source>NetfilterQueue.COPY_META</source>
          <target state="translated">NetfilterQueue.COPY_META。</target>
        </trans-unit>
        <trans-unit id="5ca777b18297628fbd558425aaf49df2644e5a77" translate="yes" xml:space="preserve">
          <source>NetfilterQueue.COPY_NONE</source>
          <target state="translated">NetfilterQueue.COPY_NONE。</target>
        </trans-unit>
        <trans-unit id="1bc389fde0cfe6c6f37f457430bdf614e223bb5c" translate="yes" xml:space="preserve">
          <source>NetfilterQueue.COPY_PACKET</source>
          <target state="translated">NetfilterQueue.COPY_PACKET</target>
        </trans-unit>
        <trans-unit id="b9123ea491124e159c73f91a517df28b11962d1b" translate="yes" xml:space="preserve">
          <source>Number of currently queued packets</source>
          <target state="translated">当前排队的数据包数量</target>
        </trans-unit>
        <trans-unit id="f6ac9503f5ec1bb9665fb297e6efeccacb403879" translate="yes" xml:space="preserve">
          <source>Number of packets dropped due to netlink socket failure</source>
          <target state="translated">由于netlink套接字失败而丢弃的数据包数量。</target>
        </trans-unit>
        <trans-unit id="0ff67f7813e52033624455db46bd7b4eaba9c906" translate="yes" xml:space="preserve">
          <source>Number of packets dropped due to reaching max queue size</source>
          <target state="translated">由于达到最大队列规模而丢弃的数据包数量。</target>
        </trans-unit>
        <trans-unit id="90c963c1d66a7620b463a552c0b2febfb5ea0c9c" translate="yes" xml:space="preserve">
          <source>Objects of this type are passed to your callback.</source>
          <target state="translated">该类型的对象会被传递给你的回调。</target>
        </trans-unit>
        <trans-unit id="306e63404b1755b0f306e04171764711a3c06f6a" translate="yes" xml:space="preserve">
          <source>Omits methods for getting information about the interface a packet has
arrived on or is leaving on</source>
          <target state="translated">省略了获取数据包已经到达或即将离开的接口信息的方法。</target>
        </trans-unit>
        <trans-unit id="d7136bde86b16c3b217c4c3b01c1b14ed63bd068" translate="yes" xml:space="preserve">
          <source>On Debian or Ubuntu, install these files with:</source>
          <target state="translated">在Debian或Ubuntu上,用以下方法安装这些文件。</target>
        </trans-unit>
        <trans-unit id="6c3487baef95a484cf0704cf6a7c6ed2c759ad97" translate="yes" xml:space="preserve">
          <source>Packet objects</source>
          <target state="translated">数据包对象</target>
        </trans-unit>
        <trans-unit id="929925b7f9d5ae86c4c4afd5b7bec7c6cbb5ec2d" translate="yes" xml:space="preserve">
          <source>Packet.accept()</source>
          <target state="translated">Packet.accept()</target>
        </trans-unit>
        <trans-unit id="dd813ce17489aec60902ac51beef2e9c0087e5ed" translate="yes" xml:space="preserve">
          <source>Packet.drop()</source>
          <target state="translated">Packet.drop()</target>
        </trans-unit>
        <trans-unit id="d67d3cefaae731dd8f0476d73a684e938bcb547c" translate="yes" xml:space="preserve">
          <source>Packet.get_hw()</source>
          <target state="translated">Packet.get_hw()</target>
        </trans-unit>
        <trans-unit id="63818313a926acb308c3e8d26d224916d4658f13" translate="yes" xml:space="preserve">
          <source>Packet.get_mark()</source>
          <target state="translated">Packet.get_mark()</target>
        </trans-unit>
        <trans-unit id="46acec9834e014668bb9bb8d4f9bb82731a3b0ed" translate="yes" xml:space="preserve">
          <source>Packet.get_payload()</source>
          <target state="translated">Packet.get_payload()</target>
        </trans-unit>
        <trans-unit id="baf879f0a0e32857a79a0fa509273634a0969feb" translate="yes" xml:space="preserve">
          <source>Packet.get_payload_len()</source>
          <target state="translated">Packet.get_payload_len()</target>
        </trans-unit>
        <trans-unit id="46904ec4de5ff68146a1efc4dda5a2b25124b43a" translate="yes" xml:space="preserve">
          <source>Packet.repeat()</source>
          <target state="translated">Packet.repeat()</target>
        </trans-unit>
        <trans-unit id="37810aaeb5aa6ffe1c4924ae6575d0bb697c95a5" translate="yes" xml:space="preserve">
          <source>Packet.set_mark(mark)</source>
          <target state="translated">Packet.set_mark(mark)</target>
        </trans-unit>
        <trans-unit id="e5e77a66c2a161cf0b30194548556e730f621a59" translate="yes" xml:space="preserve">
          <source>Packet.set_payload(payload)</source>
          <target state="translated">Packet.set_payload(payload)</target>
        </trans-unit>
        <trans-unit id="b9ef547f2385b3b101d631375c8547cb954c0857" translate="yes" xml:space="preserve">
          <source>Probably other stuff is omitted too</source>
          <target state="translated">可能其他的东西也被省略了</target>
        </trans-unit>
        <trans-unit id="3435b86a901c378810c668d91923cc6c24eed6ec" translate="yes" xml:space="preserve">
          <source>Python bindings for libnetfilter_queue</source>
          <target state="translated">libnetfilter_queue的Python绑定。</target>
        </trans-unit>
        <trans-unit id="c0ab5d40b126a07cd8d6c2d3e5b73cb1f52a372d" translate="yes" xml:space="preserve">
          <source>Python development files</source>
          <target state="translated">Python开发文件</target>
        </trans-unit>
        <trans-unit id="f52189d3511d47fbd39685374346dab1a8f7638e" translate="yes" xml:space="preserve">
          <source>Queue ID</source>
          <target state="translated">队列ID</target>
        </trans-unit>
        <trans-unit id="23b36e5127e6cde3a3c0f9c98f153602eab640e5" translate="yes" xml:space="preserve">
          <source>QueueHandler.bind(queue_num, callback[, max_len[, mode[, range, [sock_len]]]])</source>
          <target state="translated">QueueHandler.bind(queue_num,callback[,max_len[,mode[,range,[sock_len]]]])</target>
        </trans-unit>
        <trans-unit id="acb9d79d7743ebfd9efd2b356369f7438ebcf93a" translate="yes" xml:space="preserve">
          <source>QueueHandler.get_fd()</source>
          <target state="translated">QueueHandler.get_fd()</target>
        </trans-unit>
        <trans-unit id="55f6c5788421f756fbd29f2840d22c83423e378c" translate="yes" xml:space="preserve">
          <source>QueueHandler.run([block])</source>
          <target state="translated">QueueHandler.run([block])</target>
        </trans-unit>
        <trans-unit id="1862c650c5b374c6df7d64e90eacc8ec55bdb2f8" translate="yes" xml:space="preserve">
          <source>QueueHandler.run_socket(socket)</source>
          <target state="translated">QueueHandler.run_socket(socket)</target>
        </trans-unit>
        <trans-unit id="929e2576f064225a905dde1f95cc3793d0881b68" translate="yes" xml:space="preserve">
          <source>QueueHandler.unbind()</source>
          <target state="translated">QueueHandler.unbind()</target>
        </trans-unit>
        <trans-unit id="504dcecdf01dd3cee0f91943459137bbab67b105" translate="yes" xml:space="preserve">
          <source>Remove the queue. Packets matched by your iptables rule will be dropped.</source>
          <target state="translated">删除队列。匹配您的iptables规则的数据包将被丢弃。</target>
        </trans-unit>
        <trans-unit id="dbbae45b44cee79b20d5b89d4f11db8b42aa9530" translate="yes" xml:space="preserve">
          <source>Return the hardware address as a Python string.</source>
          <target state="translated">以Python字符串的形式返回硬件地址。</target>
        </trans-unit>
        <trans-unit id="c6bcafd8abbf0f9a918f41dbfddb2ee3357887a6" translate="yes" xml:space="preserve">
          <source>Return the packet&amp;rsquo;s payload as a string (Python 2) or bytes (Python 3).</source>
          <target state="translated">Return the packet&amp;rsquo;s payload as a string (Python 2) or bytes (Python 3).</target>
        </trans-unit>
        <trans-unit id="7db72bbbd857bc975ce47c9958e9ad512e729002" translate="yes" xml:space="preserve">
          <source>Return the size of the payload.</source>
          <target state="translated">返回有效载荷的大小。</target>
        </trans-unit>
        <trans-unit id="76905d9b0f06afe8c169248601c19911915de561" translate="yes" xml:space="preserve">
          <source>Send packets to your callback, but use the supplied socket instead of
recv, so that, for example, gevent can monkeypatch it. You can make a
socket with</source>
          <target state="translated">向你的回调发送数据包,但使用提供的套接字而不是recv,这样,例如,gevent就可以对它进行猴子补丁。你可以用</target>
        </trans-unit>
        <trans-unit id="8fce215f2bfdcb0b79cff74fe25dcabc406483fd" translate="yes" xml:space="preserve">
          <source>Send packets to your callback. By default, this method blocks. Set
block=False to let your thread continue. You can get the file descriptor
of the socket with the</source>
          <target state="translated">向你的回调发送数据包。默认情况下,这个方法会阻塞。设置block=False,让你的线程继续。你可以通过函数的</target>
        </trans-unit>
        <trans-unit id="2c05af93f48033c508c2ed0fc2dc38808490c49c" translate="yes" xml:space="preserve">
          <source>Set the packet payload.</source>
          <target state="translated">设置数据包的有效载荷。</target>
        </trans-unit>
        <trans-unit id="403faf6ecfed7c2f6276f598d6b66e1f44c7ef7d" translate="yes" xml:space="preserve">
          <source>Something for libnetfilter_queue&amp;rsquo;s internal use</source>
          <target state="translated">Something for libnetfilter_queue&amp;rsquo;s internal use</target>
        </trans-unit>
        <trans-unit id="6da13addb000b67d42a6d66391713819e634149f" translate="yes" xml:space="preserve">
          <source>Source</source>
          <target state="translated">资料来源</target>
        </trans-unit>
        <trans-unit id="28d67d8abd4a4854029b14119fba01291b055159" translate="yes" xml:space="preserve">
          <source>The fields are:</source>
          <target state="translated">这些领域是:</target>
        </trans-unit>
        <trans-unit id="13c97daf3032146d20511c18d1ea69545676e0ee" translate="yes" xml:space="preserve">
          <source>The following script prints a short description of each packet before accepting
it.</source>
          <target state="translated">下面的脚本在接受每个数据包之前会打印出它的简短描述。</target>
        </trans-unit>
        <trans-unit id="286bac9f400ab479f26f993c19fc7b8c077537ff" translate="yes" xml:space="preserve">
          <source>The only special part of the rule is the target. Rules can have any match and
can be added to any table or chain.</source>
          <target state="translated">规则中唯一特殊的部分是目标。规则可以有任何匹配,可以添加到任何表或链。</target>
        </trans-unit>
        <trans-unit id="35ede51bbe7dc3e0e604b7d1bf1e81d9018778fc" translate="yes" xml:space="preserve">
          <source>These constants specify how much of the packet should be given to the
script- nothing, metadata, or the whole packet.</source>
          <target state="translated">这些常量指定了应该给脚本多少数据包--什么都不给,元数据,或者整个数据包。</target>
        </trans-unit>
        <trans-unit id="c40a28bc42ad55df3e9e5977f04fd8e171475095" translate="yes" xml:space="preserve">
          <source>To install from PyPI by pip:</source>
          <target state="translated">用pip从PyPI安装。</target>
        </trans-unit>
        <trans-unit id="1044a1391e771c0f365099c8dd291250e2900737" translate="yes" xml:space="preserve">
          <source>To install from source:</source>
          <target state="translated">要从源头安装。</target>
        </trans-unit>
        <trans-unit id="521b5022e366da1238b463eb6b4c017516c0a2b5" translate="yes" xml:space="preserve">
          <source>To send packets destined for your LAN to the script, type something like:</source>
          <target state="translated">要向脚本发送发往局域网的数据包,请键入以下内容。</target>
        </trans-unit>
        <trans-unit id="52504978c5021c28fafd55a6bc0513681c35e0b0" translate="yes" xml:space="preserve">
          <source>To send packets to the queue:</source>
          <target state="translated">要向队列发送数据包。</target>
        </trans-unit>
        <trans-unit id="4efa3d9c1534cecb4e3c2d96cab3ecb703fbf7de" translate="yes" xml:space="preserve">
          <source>To view libnetfilter_queue stats, refer to /proc/net/netfilter/nfnetlink_queue:</source>
          <target state="translated">要查看libnetfilter_queue统计,请参考/proc/net/netfilter/nfnetlink_queue。</target>
        </trans-unit>
        <trans-unit id="707b39ad00d4837a57f4b3dc0dc1f718467a80ce" translate="yes" xml:space="preserve">
          <source>Total number of packets sent to queue</source>
          <target state="translated">发送到队列的数据包总数</target>
        </trans-unit>
        <trans-unit id="0bb18642b70b9f8a9c12ccf39487328f306b8e19" translate="yes" xml:space="preserve">
          <source>Usage</source>
          <target state="translated">使用方法</target>
        </trans-unit>
        <trans-unit id="c3662c66c51e7a37ab0e84758e819a555dff0ee2" translate="yes" xml:space="preserve">
          <source>Valid queue numbers are integers from 0 to 65,535 inclusive.</source>
          <target state="translated">有效的队列号是0到65,535(含)之间的整数。</target>
        </trans-unit>
        <trans-unit id="4f0734c6c3896f6903a0d7a2d93f5710965c2c60" translate="yes" xml:space="preserve">
          <source>You can also make your own socket so that it can be used with gevent, for example.</source>
          <target state="translated">你也可以制作自己的socket,这样就可以和gevent一起使用,比如说。</target>
        </trans-unit>
        <trans-unit id="296843751cd405224e152aad34a5f1e23b2458ee" translate="yes" xml:space="preserve">
          <source>Your callback can be function or a method and must accept one argument, a
Packet object. You must call either Packet.accept() or Packet.drop() before
returning.</source>
          <target state="translated">您的回调可以是函数或方法,并且必须接受一个参数,即Packet对象。你必须在返回之前调用Packet.accept()或Packet.drop()。</target>
        </trans-unit>
        <trans-unit id="7d56792fb91e9acad880f295a14d078c17918c09" translate="yes" xml:space="preserve">
          <source>and optionally make it non-blocking with</source>
          <target state="translated">并可选择用</target>
        </trans-unit>
        <trans-unit id="6bdd4db977b0f96aaf3bff2e4300153c648ca382" translate="yes" xml:space="preserve">
          <source>bind</source>
          <target state="translated">束缚</target>
        </trans-unit>
        <trans-unit id="b4d5b37bf7a986c138ede89e0806f366b5cb1830" translate="yes" xml:space="preserve">
          <source>callback</source>
          <target state="translated">回调</target>
        </trans-unit>
        <trans-unit id="0d831459c025b7b64cb08547f99828b31c5734fa" translate="yes" xml:space="preserve">
          <source>callback(packet)</source>
          <target state="translated">回调</target>
        </trans-unit>
        <trans-unit id="7eceb2a714bbee8abcf25e78f8f491f0b34679f3" translate="yes" xml:space="preserve">
          <source>callback(self, packet)</source>
          <target state="translated">回调(self,packet)</target>
        </trans-unit>
        <trans-unit id="94111c4b3c81c397a338293349778eb86f4e4755" translate="yes" xml:space="preserve">
          <source>could be 20.</source>
          <target state="translated">可能是20。</target>
        </trans-unit>
        <trans-unit id="8ed5e494b765a64796b544c775f1d3182d609502" translate="yes" xml:space="preserve">
          <source>defines
how many bytes of the packet you want to get. For example, if you only want
the source and destination IPs of a IPv4 packet,</source>
          <target state="translated">定义了你想得到的数据包的字节数。例如,如果你只想得到一个IPv4数据包的源和目标IP。</target>
        </trans-unit>
        <trans-unit id="fa04f4d777bd01284b30d5c4d97d8eb77be6a5bc" translate="yes" xml:space="preserve">
          <source>determines how much of the packet
data is provided to your script. Use the constants above.</source>
          <target state="translated">决定有多少数据包数据被提供给你的脚本。使用上面的常量。</target>
        </trans-unit>
        <trans-unit id="526ab213912ea3f50c8198cc60d6575f8bc082d0" translate="yes" xml:space="preserve">
          <source>get_fd</source>
          <target state="translated">get_fd</target>
        </trans-unit>
        <trans-unit id="af10ef20dd9060bbeead0afbc55381a66af442ef" translate="yes" xml:space="preserve">
          <source>in</source>
          <target state="translated">in</target>
        </trans-unit>
        <trans-unit id="4c143b277dc808febfcf82d2591156322be9f594" translate="yes" xml:space="preserve">
          <source>is a 32-bit number.</source>
          <target state="translated">是一个32位的数字。</target>
        </trans-unit>
        <trans-unit id="ed10e0e9f8a31e03fbf3b2fc83bfc0986bbbffef" translate="yes" xml:space="preserve">
          <source>is a bytes.</source>
          <target state="translated">是一个字节。</target>
        </trans-unit>
        <trans-unit id="730fcd221d6fa112cc4b7c9e14093375a73a28f9" translate="yes" xml:space="preserve">
          <source>is a function or method that takes one
argument, a Packet object (see below).</source>
          <target state="translated">是一个函数或方法,它只接受一个参数,即Packet对象(见下文)。</target>
        </trans-unit>
        <trans-unit id="f1b5a91d4d6ad523f2610114591c007e75d15084" translate="yes" xml:space="preserve">
          <source>mark</source>
          <target state="translated">标志</target>
        </trans-unit>
        <trans-unit id="b84ea409181930772b96f9e354dc02344f3b03d6" translate="yes" xml:space="preserve">
          <source>max_len</source>
          <target state="translated">最大长度</target>
        </trans-unit>
        <trans-unit id="946465000bd9e24c032001a54783f3574c94142e" translate="yes" xml:space="preserve">
          <source>method.</source>
          <target state="translated">方法。</target>
        </trans-unit>
        <trans-unit id="e78fe7049341b36116d8054f5a3e00d01f245fcc" translate="yes" xml:space="preserve">
          <source>mode</source>
          <target state="translated">模式</target>
        </trans-unit>
        <trans-unit id="27c605f494af4f8008c2defb095feed614937651" translate="yes" xml:space="preserve">
          <source>must match the number in your
iptables rule.</source>
          <target state="translated">必须符合你的iptables规则中的数字。</target>
        </trans-unit>
        <trans-unit id="ee22b3c9ed1b9a510d4d3597b7118775ad74fc96" translate="yes" xml:space="preserve">
          <source>netfilterqueue.pyx</source>
          <target state="translated">netfilterqueue.pyx</target>
        </trans-unit>
        <trans-unit id="1758356db21759f7c5a0da9b4dd1db8fd6feab3f" translate="yes" xml:space="preserve">
          <source>or</source>
          <target state="translated">or</target>
        </trans-unit>
        <trans-unit id="d864ca47b0e280b1152bdd1b06de44d020f04bfb" translate="yes" xml:space="preserve">
          <source>packet.accept()</source>
          <target state="translated">packet.accept()</target>
        </trans-unit>
        <trans-unit id="4df539c615ce3fe8792a8a855d2b0d672efb56a4" translate="yes" xml:space="preserve">
          <source>packet.drop()</source>
          <target state="translated">packet.drop()</target>
        </trans-unit>
        <trans-unit id="f07e5a815613c5abeddc4b682247a4c42d8a95df" translate="yes" xml:space="preserve">
          <source>payload</source>
          <target state="translated">有效载荷</target>
        </trans-unit>
        <trans-unit id="1978049f4d6bf9e31e1241abd09c45c0dc5df75d" translate="yes" xml:space="preserve">
          <source>queue_num</source>
          <target state="translated">队列数量</target>
        </trans-unit>
        <trans-unit id="4d55af37dbbb6a42088d917caa1ca25428ec42c9" translate="yes" xml:space="preserve">
          <source>range</source>
          <target state="translated">range</target>
        </trans-unit>
        <trans-unit id="df6ad19037c97987c4ff9792810c0e145356717c" translate="yes" xml:space="preserve">
          <source>run</source>
          <target state="translated">运行</target>
        </trans-unit>
        <trans-unit id="a1dde0c7f4bdd6fde427433e85701352e9c9f901" translate="yes" xml:space="preserve">
          <source>sets the largest number
of packets that can be in the queue; new packets are dropped if the size of
the queue reaches this number.</source>
          <target state="translated">设置队列中可容纳的最大数据包数量;如果队列的大小达到这个数量,新的数据包将被丢弃。</target>
        </trans-unit>
        <trans-unit id="50f77e1eb0fa0ecc7dc43f1707533f43c7292db8" translate="yes" xml:space="preserve">
          <source>sets the receive socket buffer size.</source>
          <target state="translated">设置接收套接字缓冲区大小。</target>
        </trans-unit>
        <trans-unit id="65cd13ce9ffc79a7306d505ecd83d7b25e3a5ef6" translate="yes" xml:space="preserve">
          <source>sock_len</source>
          <target state="translated">sock_len</target>
        </trans-unit>
        <trans-unit id="0a989f1f2900da2868332ab41978973482dc16e4" translate="yes" xml:space="preserve">
          <source>socket.fromfd(nfqueue.get_fd(), socket.AF_UNIX, socket.SOCK_STREAM)</source>
          <target state="translated">socket.fromfd(nfqueue.get_fd(),socket.AF_UNIX,socket.SOCK_STREAM)</target>
        </trans-unit>
        <trans-unit id="9e3d03ccf9d31105dc9b71bfd03812b8670e9099" translate="yes" xml:space="preserve">
          <source>socket.setblocking(False)</source>
          <target state="translated">socket.setblocking(False)</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
