<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://pypi.org/project/django-elasticache/">
    <body>
      <group id="django-elasticache">
        <trans-unit id="8278d2adba7612cf98a492d21a4ac4c78acb1202" translate="yes" xml:space="preserve">
          <source>, and</source>
          <target state="translated">和</target>
        </trans-unit>
        <trans-unit id="e2bc2a15ce8dae5e5969eee6d10ba152147f9f02" translate="yes" xml:space="preserve">
          <source>. When set to</source>
          <target state="translated">。设置为</target>
        </trans-unit>
        <trans-unit id="1b954e259d9778652df4bfdda7fd01994b4e0d7e" translate="yes" xml:space="preserve">
          <source>1. Memcached configured with location = Configuration Endpoint</source>
          <target state="translated">1.配置Memcached的位置=配置端点</target>
        </trans-unit>
        <trans-unit id="95c4d4c63d90a3652d39048059c7ebb378cd0da5" translate="yes" xml:space="preserve">
          <source>2. Memcached configured with all nodes</source>
          <target state="translated">2.配置了所有节点的Memcached</target>
        </trans-unit>
        <trans-unit id="6ce167003d7bcb23a9e9502ba565e65ed6026279" translate="yes" xml:space="preserve">
          <source>3. Use django-elasticache</source>
          <target state="translated">3.使用django-elasticache</target>
        </trans-unit>
        <trans-unit id="01e743d1b711e4b8118553cc539fbd031722014c" translate="yes" xml:space="preserve">
          <source>Another solutions</source>
          <target state="translated">另一种解决方案</target>
        </trans-unit>
        <trans-unit id="591ab42e357bf25adf4fe44eea1f8dcaeb6bdf99" translate="yes" xml:space="preserve">
          <source>By the first call to cache it connects to cluster (using</source>
          <target state="translated">通过对缓存的第一次调用,它连接到集群(用</target>
        </trans-unit>
        <trans-unit id="f6774cf92d1ff654549a8873c1dab250e9d33208" translate="yes" xml:space="preserve">
          <source>Difference between setup with nodes list (django-elasticache) and
connection to only one configuration Endpoint (using dns routing) you can see on
this graph:</source>
          <target state="translated">使用节点列表(django-elasticache)和只连接到一个配置端点(使用dns路由)的设置之间的差异,你可以在这个图上看到。</target>
        </trans-unit>
        <trans-unit id="4ba8b7a054fd0a477ce11807754bf638dbd8875c" translate="yes" xml:space="preserve">
          <source>Django 1.5+.</source>
          <target state="translated">Django 1.5+。</target>
        </trans-unit>
        <trans-unit id="96d0c7c9954c664505b3f313afa9536f20c485f6" translate="yes" xml:space="preserve">
          <source>Django cache backend for Amazon ElastiCache (memcached)</source>
          <target state="translated">亚马逊ElastiCache(memcached)的Django缓存后端。</target>
        </trans-unit>
        <trans-unit id="c0f5ce01034acc77e1f3c7080b2120b344d72c5d" translate="yes" xml:space="preserve">
          <source>Django-elasticache changes default pylibmc params to increase performance.</source>
          <target state="translated">Django-elasticache改变了默认的pylibmc参数以提高性能。</target>
        </trans-unit>
        <trans-unit id="ef5d1b9f5ee502ffbf45d1e356093bd2bb470c2d" translate="yes" xml:space="preserve">
          <source>ElastiCache provides memcached interface so there are three solution of using it:</source>
          <target state="translated">ElastiCache提供memcached接口,所以有三种使用方案。</target>
        </trans-unit>
        <trans-unit id="bf7a0f0eb10723db2bd2e06594f233a150cf376b" translate="yes" xml:space="preserve">
          <source>Get it from &lt;a href=&quot;http://pypi.python.org/pypi/django-elasticache&quot;&gt;pypi&lt;/a&gt;:</source>
          <target state="translated">从&lt;a href=&quot;http://pypi.python.org/pypi/django-elasticache&quot;&gt;pypi&lt;/a&gt;获取它：</target>
        </trans-unit>
        <trans-unit id="cf2eabc3e15e04556cf331bdf1da268312a370a5" translate="yes" xml:space="preserve">
          <source>IGNORE_CLUSTER_ERRORS</source>
          <target state="translated">IGNORE_CLUSTER_ERRORS。</target>
        </trans-unit>
        <trans-unit id="d07ff1939b5a825de60f525b17298f83d1af8026" translate="yes" xml:space="preserve">
          <source>In this case your application
will randomly connect to nodes in cluster and cache will be used with not optimal
way. At some moment you will be connected to first node and set item. Minute later
you will be connected to another node and will not able to get this item.</source>
          <target state="translated">在这种情况下,你的应用程序将随机连接到集群中的节点,缓存将以非最佳方式使用。在某个时刻,你会连接到第一个节点并设置项目。一分钟后,你将连接到另一个节点,并不能得到这个项目。</target>
        </trans-unit>
        <trans-unit id="c81b79df3c6448eae7c4f80428b54cd5692a17d7" translate="yes" xml:space="preserve">
          <source>Installation</source>
          <target state="translated">安装</target>
        </trans-unit>
        <trans-unit id="d97a56b58699a167763def3745442dbea8b7d317" translate="yes" xml:space="preserve">
          <source>It was written and tested on Python 2.7 and 3.4.</source>
          <target state="translated">它是在Python 2.7和3.4上编写和测试的。</target>
        </trans-unit>
        <trans-unit id="56a2e96ce679c7def9a8b2ddc1689061789ef197" translate="yes" xml:space="preserve">
          <source>It will connect to cluster and retrieve ip addresses
of all nodes and configure memcached to use all nodes.</source>
          <target state="translated">它将连接到集群并检索所有节点的IP地址,并配置memcached来使用所有节点。</target>
        </trans-unit>
        <trans-unit id="4cbb610d07abd4de00a916dea1c26c7f96b96395" translate="yes" xml:space="preserve">
          <source>It will work fine, memcache client will
separate items between all nodes and will balance loading on client side. You will
have problems only after adding new nodes or delete old nodes. In this case you should
add new nodes manually and don&amp;rsquo;t forget update your app after all changes on AWS.</source>
          <target state="translated">它将工作正常，memcache客户端会将所有节点之间的项目分开，并平衡客户端的负载。仅在添加新节点或删除旧节点后，您才会遇到问题。在这种情况下，您应该手动添加新节点，并且不要忘记在AWS上进行所有更改后更新应用程序。</target>
        </trans-unit>
        <trans-unit id="40c3322b3b3d0d946724fe784d34663629e1932a" translate="yes" xml:space="preserve">
          <source>LOCATION</source>
          <target state="translated">地点</target>
        </trans-unit>
        <trans-unit id="09a428f93ec07a73d726f8bd037ecacfaaf8b044" translate="yes" xml:space="preserve">
          <source>Requirements</source>
          <target state="translated">所需经费</target>
        </trans-unit>
        <trans-unit id="751eb68ffdb680fc5c3057f81248e031baa7b6db" translate="yes" xml:space="preserve">
          <source>Run the tests like this:</source>
          <target state="translated">像这样运行测试。</target>
        </trans-unit>
        <trans-unit id="5b62f292a927f052cce0ebfd49375e069c454722" translate="yes" xml:space="preserve">
          <source>Simple Django cache backend for Amazon ElastiCache (memcached based). It uses
&lt;a href=&quot;http://github.com/lericson/pylibmc&quot;&gt;pylibmc&lt;/a&gt; and sets up a connection to each
node in the cluster using
&lt;a href=&quot;http://docs.aws.amazon.com/AmazonElastiCache/latest/UserGuide/AutoDiscovery.html&quot;&gt;auto discovery&lt;/a&gt;.</source>
          <target state="translated">Amazon ElastiCache（基于memcached）的简单Django缓存后端。它使用 &lt;a href=&quot;http://github.com/lericson/pylibmc&quot;&gt;pylibmc&lt;/a&gt;并使用&lt;a href=&quot;http://docs.aws.amazon.com/AmazonElastiCache/latest/UserGuide/AutoDiscovery.html&quot;&gt;自动发现功能建立&lt;/a&gt;与集群中每个节点的连接 。</target>
        </trans-unit>
        <trans-unit id="0820b32b206b7352858e8903a838ed14319acdfd" translate="yes" xml:space="preserve">
          <source>Testing</source>
          <target state="translated">测试</target>
        </trans-unit>
        <trans-unit id="93ef0dd827103681fcee453b78be2ff14e1a261d" translate="yes" xml:space="preserve">
          <source>The</source>
          <target state="translated">The</target>
        </trans-unit>
        <trans-unit id="88b33e4e12f75ac8bf792aebde41f1a090f3a612" translate="yes" xml:space="preserve">
          <source>True</source>
          <target state="translated">True</target>
        </trans-unit>
        <trans-unit id="0bb18642b70b9f8a9c12ccf39487328f306b8e19" translate="yes" xml:space="preserve">
          <source>Usage</source>
          <target state="translated">使用方法</target>
        </trans-unit>
        <trans-unit id="7ddadb61200c5d2fbe72688cdd9ba64db7f35fdd" translate="yes" xml:space="preserve">
          <source>Your cache backend should look something like this:</source>
          <target state="translated">你的缓存后台应该是这样的。</target>
        </trans-unit>
        <trans-unit id="6066a2c377d1f3245d673c2ff2e078e25081e3bc" translate="yes" xml:space="preserve">
          <source>config get cluster</source>
          <target state="translated">配置获取集群</target>
        </trans-unit>
        <trans-unit id="1e2159e398ac0b72f64428a363b82c6b9946c829" translate="yes" xml:space="preserve">
          <source>doesn&amp;rsquo;t have support
for</source>
          <target state="translated">不支持</target>
        </trans-unit>
        <trans-unit id="371cc7343d473e2d73d8393f22a039ae352fc95b" translate="yes" xml:space="preserve">
          <source>fails,
it returns a list of a single node with the same endpoint supplied to</source>
          <target state="translated">失败,它将返回一个具有相同端点的单节点列表,提供给</target>
        </trans-unit>
        <trans-unit id="38827606a0945559ffc7c96d3d53ab40c63bbaa0" translate="yes" xml:space="preserve">
          <source>option is useful when</source>
          <target state="translated">选项在以下情况下很有用</target>
        </trans-unit>
        <trans-unit id="feffea0d5bc93465efdccc93f9adef30c886bc13" translate="yes" xml:space="preserve">
          <source>or &lt;a href=&quot;http://github.com/gusdan/django-elasticache&quot;&gt;github&lt;/a&gt;:</source>
          <target state="translated">或&lt;a href=&quot;http://github.com/gusdan/django-elasticache&quot;&gt;github&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="14b109f1263bfc21f7ba0577cf57779716596583" translate="yes" xml:space="preserve">
          <source>param),
gets list of all nodes and setup pylibmc client using full
list of nodes. As result your cache will work with all nodes in cluster and
automatically detect new nodes in cluster. List of nodes are stored in class-level
cached, so any changes in cluster take affect only after restart of working process.
But if you&amp;rsquo;re using gunicorn or mod_wsgi you usually have max_request settings which
restart process after some count of processed requests, so auto discovery will work
fine.</source>
          <target state="translated">参数），获取所有节点的列表，并使用完整的节点列表设置pylibmc客户端。结果，您的缓存将与群集中的所有节点一起使用，并自动检测群集中的新节点。节点列表存储在类级别的缓存中，因此群集中的任何更改仅在重新启动工作流程后才会生效。但是，如果您使用的是gunicorn或mod_wsgi，则通常具有max_request设置，这些设置会在处理完一定数量的请求后重新启动进程，因此自动发现会很好地工作。</target>
        </trans-unit>
        <trans-unit id="57748d5675ff25b5a147e34fa985986bcddb1a56" translate="yes" xml:space="preserve">
          <source>pylibmc</source>
          <target state="translated">pylibmc</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
