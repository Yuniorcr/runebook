<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://pypi.org/project/pprofile/">
    <body>
      <group id="pprofile">
        <trans-unit id="08d8c48010dc495c8c0ca446499203cb84c0223d" translate="yes" xml:space="preserve">
          <source>&amp;ndash;</source>
          <target state="translated">&amp;ndash;</target>
        </trans-unit>
        <trans-unit id="e2a406a6b9a6683df6928a40f7ae9c0fbd1a441f" translate="yes" xml:space="preserve">
          <source>&amp;ndash;exclude-syspath</source>
          <target state="translated">&amp;ndash;exclude-syspath</target>
        </trans-unit>
        <trans-unit id="0ae45eb99227ea66b9f0530a105bbbe8eed68676" translate="yes" xml:space="preserve">
          <source>(ie, python modules
themselves), for shorter output:</source>
          <target state="translated">(ie, python modules themselves), for shorter output:</target>
        </trans-unit>
        <trans-unit id="963a4845e64d366d352de0877c6d9b40a884dc23" translate="yes" xml:space="preserve">
          <source>, but uses</source>
          <target state="translated">, but uses</target>
        </trans-unit>
        <trans-unit id="cce71bad005c33e479211c58b324af84b52aab81" translate="yes" xml:space="preserve">
          <source>, so above command can be simplified as:</source>
          <target state="translated">, so above command can be simplified as:</target>
        </trans-unit>
        <trans-unit id="d17fe22d96000047d44436b78cbe5a5295383b67" translate="yes" xml:space="preserve">
          <source>--out</source>
          <target state="translated">--out</target>
        </trans-unit>
        <trans-unit id="e58003a4e3bcafd0f742453f718bb64b4a248435" translate="yes" xml:space="preserve">
          <source>--zipfile</source>
          <target state="translated">--zipfile</target>
        </trans-unit>
        <trans-unit id="da7a483ee8a43922bf070a85379736180cb8093c" translate="yes" xml:space="preserve">
          <source>Annotated code</source>
          <target state="translated">附加说明的编码</target>
        </trans-unit>
        <trans-unit id="375a8a1f0f4583826c58d6b7457843a28224a72b" translate="yes" xml:space="preserve">
          <source>As a command, ignoring any files from default</source>
          <target state="translated">作为一个命令,忽略任何来自默认的文件。</target>
        </trans-unit>
        <trans-unit id="4f7adf42fe54faaafadb623d350f16fb3150a2f4" translate="yes" xml:space="preserve">
          <source>As a command:</source>
          <target state="translated">作为一个命令。</target>
        </trans-unit>
        <trans-unit id="40946c5c22fe6e410c2cfce023f55e9db2619ece" translate="yes" xml:space="preserve">
          <source>As a module:</source>
          <target state="translated">作为一个模块。</target>
        </trans-unit>
        <trans-unit id="ba5a8e6fe23c1ce473de71051941895a9a8dc974" translate="yes" xml:space="preserve">
          <source>As an effect of previous point, it does not have a notion above individual
callable, annotating functions but not whole files - preventing module
import profiling.</source>
          <target state="translated">作为前一点的效果,它没有一个单独的可调用上面的概念,注释函数,但不是整个文件-防止模块导入剖析。</target>
        </trans-unit>
        <trans-unit id="a865f1fb2dee88138c639374a6b8661cec106e84" translate="yes" xml:space="preserve">
          <source>Callgrind</source>
          <target state="translated">呼叫研磨</target>
        </trans-unit>
        <trans-unit id="cc987637fb23a4f8fd2f404b249127cf81a646d4" translate="yes" xml:space="preserve">
          <source>Callgrind format is implicitly enabled if</source>
          <target state="translated">Callgrind格式在以下情况下被隐式启用</target>
        </trans-unit>
        <trans-unit id="16884032d4f5494add8e3b7c437d72709beff50e" translate="yes" xml:space="preserve">
          <source>Code to profile runs for&amp;hellip;</source>
          <target state="translated">Code to profile runs for&amp;hellip;</target>
        </trans-unit>
        <trans-unit id="f5cbdf6bfb51439be085b5c6b7460a7c91eabc3c" translate="yes" xml:space="preserve">
          <source>Contents</source>
          <target state="translated">内容</target>
        </trans-unit>
        <trans-unit id="26531c59c3e9b4b0d2ca2ed03be4aa5ad253239d" translate="yes" xml:space="preserve">
          <source>Deterministic profiling</source>
          <target state="translated">确定性分析</target>
        </trans-unit>
        <trans-unit id="08782b57b83605d4a635a3eaf54bdfa876435fb0" translate="yes" xml:space="preserve">
          <source>Example (lines are reported as taking longer to execute when profiled along
with another thread - although the other thread is not profiled):</source>
          <target state="translated">例子(当与另一个线程一起剖析时,行被报告为执行时间较长--尽管另一个线程没有被剖析)。</target>
        </trans-unit>
        <trans-unit id="d131726d8c92c8c104a984cdd97c823fa8f01b2c" translate="yes" xml:space="preserve">
          <source>Example with 3 threads:</source>
          <target state="translated">例子有3条线。</target>
        </trans-unit>
        <trans-unit id="e5101d180a2cf88e1574772bc6cf137cb0e37923" translate="yes" xml:space="preserve">
          <source>Executing a module, like &lt;code&gt;python -m&lt;/code&gt;.</source>
          <target state="translated">Executing a module, like &lt;code&gt;python -m&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d83333eeade63618ebe2a32b8e705b1dad95a848" translate="yes" xml:space="preserve">
          <source>For advanced usage, see &lt;code&gt;pprofile --help&lt;/code&gt; and &lt;code&gt;pydoc pprofile&lt;/code&gt;.</source>
          <target state="translated">For advanced usage, see &lt;code&gt;pprofile --help&lt;/code&gt; and &lt;code&gt;pydoc pprofile&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="920d9d704544a79d086d6cc50c498fc6616387fc" translate="yes" xml:space="preserve">
          <source>Generated files will use relative paths, so you can extract generated archive
in the same path as profiling result, and kcachegrind will load them - and not
your system-wide files, which may differ.</source>
          <target state="translated">生成的文件将使用相对路径,所以你可以将生成的档案提取到与分析结果相同的路径中,并且kcachegrind将加载它们--而不是你的系统范围内的文件,后者可能会有所不同。</target>
        </trans-unit>
        <trans-unit id="0cf09e3973c463fa3fc54b20a3533f9e4c64c142" translate="yes" xml:space="preserve">
          <source>Human-readable output, but can become difficult to use with large programs.</source>
          <target state="translated">人类可读的输出,但在大型程序中可能变得难以使用。</target>
        </trans-unit>
        <trans-unit id="248ac1e7527d88296f12e17629ea64c998385800" translate="yes" xml:space="preserve">
          <source>If you are analyzing callgrind traces on a different machine, you may want to
use the</source>
          <target state="translated">如果您要在不同的机器上分析callgrind痕迹,您可能需要使用</target>
        </trans-unit>
        <trans-unit id="0988bf8886a6a0d120683a8bd5a33fe3db5c757c" translate="yes" xml:space="preserve">
          <source>In deterministic profiling mode, pprofile gets notified of each executed line.
This mode generates very detailed reports, but at the cost of a large overhead.
Also, profiling hooks being per-thread, either profiling must be enable before
spawning threads (if you want to profile more than just the current thread),
or profiled application must provide ways of enabling profiling afterwards
- which is not very convenient.</source>
          <target state="translated">在确定性剖析模式下,pprofile会得到每个执行行的通知。这种模式可以生成非常详细的报告,但代价是开销很大。此外,剖析钩子是按线程的,要么剖析必须在产卵线程之前启用(如果你想剖析的不仅仅是当前线程),要么被剖析的应用程序必须提供之后启用剖析的方法--这不是很方便。</target>
        </trans-unit>
        <trans-unit id="ae6cfb0c6022f050a2f84797462675810e57c755" translate="yes" xml:space="preserve">
          <source>In statistic profiling mode, pprofile periodically snapshots the current
callstack(s) of current process to see what is being executed.
As a result, profiler overhead can be dramatically reduced, making it possible
to profile real workloads. Also, as statistic profiling acts at the
whole-process level, it can be toggled independently of profiled code.</source>
          <target state="translated">在统计分析模式下,pprofile会定期对当前进程的当前调用栈进行快照,以查看正在执行的内容。因此,剖析器的开销可以大大减少,使得对真实工作负载进行剖析成为可能。此外,由于统计剖析是在整个进程级别上进行的,所以它可以独立于剖析的代码进行切换。</target>
        </trans-unit>
        <trans-unit id="819e3ed9414de2a9bbcb54833855a580d3faf310" translate="yes" xml:space="preserve">
          <source>Inspired from Robert Kern&amp;rsquo;s &lt;a href=&quot;https://github.com/rkern/line_profiler&quot;&gt;line_profiler&lt;/a&gt; .</source>
          <target state="translated">Inspired from Robert Kern&amp;rsquo;s &lt;a href=&quot;https://github.com/rkern/line_profiler&quot;&gt;line_profiler&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="edb39c1b5934ecb2e3264583452f7b6aa391dc98" translate="yes" xml:space="preserve">
          <source>It is not pure-python. This choice makes sense for performance
but makes usage with pypy difficult and requires installation (I value
execution straight from checkout).</source>
          <target state="translated">它不是纯python。这样的选择对性能有意义,但与pypy一起使用就很困难了,需要安装(我看重的是直接从结账开始执行)。</target>
        </trans-unit>
        <trans-unit id="3f199f94405e8f05179010cd4a964ab49a00640f" translate="yes" xml:space="preserve">
          <source>It requires source code modification to select what should be profiled.
I prefer to have the option to do an in-depth, non-intrusive profiling.</source>
          <target state="translated">它需要修改源代码来选择应该剖析的内容。我更倾向于选择做一个深入的、非侵入式的剖析。</target>
        </trans-unit>
        <trans-unit id="a7c04c64ed3f2a9374590c76c50d3b7f1b18e3da" translate="yes" xml:space="preserve">
          <source>Limitations</source>
          <target state="translated">局限性</target>
        </trans-unit>
        <trans-unit id="0e9b3d44155d766a737755aa269a8c0ce81f2812" translate="yes" xml:space="preserve">
          <source>Line-granularity, thread-aware deterministic and statistic pure-python profiler</source>
          <target state="translated">线程粒度、线程感知的确定性和统计性纯python剖析器。</target>
        </trans-unit>
        <trans-unit id="56dd8d0bbe9dcb95403cd2c187064106af47af84" translate="yes" xml:space="preserve">
          <source>Maybe</source>
          <target state="translated">也许吧</target>
        </trans-unit>
        <trans-unit id="816c52fd2bdd94a63cd0944823a6c0aa9384c103" translate="yes" xml:space="preserve">
          <source>No</source>
          <target state="translated">没有</target>
        </trans-unit>
        <trans-unit id="5e52bb0aa7caf0b66cf7eea97de236c324876370" translate="yes" xml:space="preserve">
          <source>No &lt;a href=&quot;#id3&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt;</source>
          <target state="translated">No &lt;a href=&quot;#id3&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="185a496deb9bdea8b947addc462aa7973cd6ea61" translate="yes" xml:space="preserve">
          <source>Note that the call time is not added to file total: it&amp;rsquo;s already accounted
for inside &amp;ldquo;func&amp;rdquo;.</source>
          <target state="translated">Note that the call time is not added to file total: it&amp;rsquo;s already accounted for inside &amp;ldquo;func&amp;rdquo;.</target>
        </trans-unit>
        <trans-unit id="b496aa7bd246908173fc2b93ffd69f1d7f890d4c" translate="yes" xml:space="preserve">
          <source>Note that time.sleep call is not counted as such. For some reason, python is
not generating c_call/c_return/c_exception events (which are ignored by current
code, as a result).</source>
          <target state="translated">请注意,time.sleep的调用并没有被计算在内。由于某些原因,python没有生成c_call/c_return/c_exception事件(结果被当前代码忽略了)。</target>
        </trans-unit>
        <trans-unit id="d9c768782ea8653d485fb3b7f5aba21cb2ca7bf3" translate="yes" xml:space="preserve">
          <source>Once</source>
          <target state="translated">一旦</target>
        </trans-unit>
        <trans-unit id="848342fe3d773a66dfbf53801215f16e8c32d49f" translate="yes" xml:space="preserve">
          <source>Once you identified the hot spot and you decide you need finer-grained
profiling to understand what needs fixing, you should try to make to-profile
code run for shorter time so you can reasonably use deterministic profiling:
use a smaller data set triggering the same code path, modify the code to only
enable profiling on small pieces of code&amp;hellip;</source>
          <target state="translated">Once you identified the hot spot and you decide you need finer-grained profiling to understand what needs fixing, you should try to make to-profile code run for shorter time so you can reasonably use deterministic profiling: use a smaller data set triggering the same code path, modify the code to only enable profiling on small pieces of code&amp;hellip;</target>
        </trans-unit>
        <trans-unit id="4bed336194a9a5c86b6a734f03b3570d2aae1a68" translate="yes" xml:space="preserve">
          <source>Output</source>
          <target state="translated">产量</target>
        </trans-unit>
        <trans-unit id="ff4fc0276e960c348647b647235f68200887c9d2" translate="yes" xml:space="preserve">
          <source>Profile</source>
          <target state="translated">简介</target>
        </trans-unit>
        <trans-unit id="fa358bf850bf1b4e121dc78f29e90b4d68fa62d4" translate="yes" xml:space="preserve">
          <source>Profiling modes</source>
          <target state="translated">剖析模式</target>
        </trans-unit>
        <trans-unit id="307633c8c1287471722288ea298ef740fd9f2029" translate="yes" xml:space="preserve">
          <source>Profiling overhead</source>
          <target state="translated">高空剖面</target>
        </trans-unit>
        <trans-unit id="28147f1f311ae34221ebb99faab6c56141236af4" translate="yes" xml:space="preserve">
          <source>Profiling recursive code provides unexpected results (recursion cost is
accumulated on callable&amp;rsquo;s first line) because it doesn&amp;rsquo;t track call stack.
This may be unintended, and may be fixed at some point in line_profiler.</source>
          <target state="translated">Profiling recursive code provides unexpected results (recursion cost is accumulated on callable&amp;rsquo;s first line) because it doesn&amp;rsquo;t track call stack. This may be unintended, and may be fixed at some point in line_profiler.</target>
        </trans-unit>
        <trans-unit id="82ff105645a1a50c3478fbd4fe3d88e7ea516ae4" translate="yes" xml:space="preserve">
          <source>Python&amp;rsquo;s standard profiling tools have a callable-level granularity, which
means it is only possible to tell which function is a hot-spot, not which
lines in that function.</source>
          <target state="translated">Python&amp;rsquo;s standard profiling tools have a callable-level granularity, which means it is only possible to tell which function is a hot-spot, not which lines in that function.</target>
        </trans-unit>
        <trans-unit id="b3ef15eab75370281ebe7e31fd1314a16f9c1077" translate="yes" xml:space="preserve">
          <source>Robert Kern&amp;rsquo;s &lt;a href=&quot;https://github.com/rkern/line_profiler&quot;&gt;line_profiler&lt;/a&gt; is a very nice alternative providing line-level
profiling granularity, but in my opinion it has a few drawbacks which (in
addition to the attractive technical challenge) made me start pprofile:</source>
          <target state="translated">Robert Kern&amp;rsquo;s &lt;a href=&quot;https://github.com/rkern/line_profiler&quot;&gt;line_profiler&lt;/a&gt; is a very nice alternative providing line-level profiling granularity, but in my opinion it has a few drawbacks which (in addition to the attractive technical challenge) made me start pprofile:</target>
        </trans-unit>
        <trans-unit id="8644dd3acfdaeead0c8466b3d16008f15f606cb1" translate="yes" xml:space="preserve">
          <source>Rule of thumb:</source>
          <target state="translated">经验法则。</target>
        </trans-unit>
        <trans-unit id="28cf4f57753c49e0d92147ea6e5a3b8140af57b8" translate="yes" xml:space="preserve">
          <source>Some details are lost (not all executed lines have a non-null hit-count), but
the hot spot is still easily identifiable in this trivial example, and its call
stack is still visible.</source>
          <target state="translated">一些细节丢失了(并不是所有执行的行都有一个非空的命中数),但在这个微不足道的例子中,热点还是很容易识别的,它的调用堆栈仍然可见。</target>
        </trans-unit>
        <trans-unit id="f56dcb00c5c08e7bd5a7365d9fbf4bc6464a97ca" translate="yes" xml:space="preserve">
          <source>Statistic profiling</source>
          <target state="translated">统计分析</target>
        </trans-unit>
        <trans-unit id="6193022ab02334ca88552c61e2cdecef58c421a2" translate="yes" xml:space="preserve">
          <source>Statistic profiling will not have time to collect
enough samples to produce usable output.</source>
          <target state="translated">统计剖析将没有时间收集足够的样本来产生可用的输出。</target>
        </trans-unit>
        <trans-unit id="60d80d43bb632d7b2b6ec64f4910b83560690096" translate="yes" xml:space="preserve">
          <source>Supported output formats.</source>
          <target state="translated">支持的输出格式。</target>
        </trans-unit>
        <trans-unit id="4b75d82deb086272d83c9cc7ecac679728522916" translate="yes" xml:space="preserve">
          <source>The downside of statistic profiling is that output lacks timing information,
which makes it harder to understand.</source>
          <target state="translated">统计剖析的缺点是输出缺乏时序信息,这使得它更难理解。</target>
        </trans-unit>
        <trans-unit id="4ccff0d8ab217873badb62cbecfc7ec6f4bbd651" translate="yes" xml:space="preserve">
          <source>The most useful output mode of pprofile is &lt;a href=&quot;http://valgrind.org/docs/manual/cl-format.html&quot;&gt;Callgrind Profile Format&lt;/a&gt;, allows
browsing profiling results with &lt;a href=&quot;http://kcachegrind.sourceforge.net&quot;&gt;kcachegrind&lt;/a&gt; (or &lt;a href=&quot;http://sourceforge.net/projects/qcachegrindwin/&quot;&gt;qcachegrind&lt;/a&gt; on Windows).</source>
          <target state="translated">The most useful output mode of pprofile is &lt;a href=&quot;http://valgrind.org/docs/manual/cl-format.html&quot;&gt;Callgrind Profile Format&lt;/a&gt;, allows browsing profiling results with &lt;a href=&quot;http://kcachegrind.sourceforge.net&quot;&gt;kcachegrind&lt;/a&gt; (or &lt;a href=&quot;http://sourceforge.net/projects/qcachegrindwin/&quot;&gt;qcachegrind&lt;/a&gt; on Windows).</target>
        </trans-unit>
        <trans-unit id="99217e33f5f136f9a6e6fedcdde656a23541eecd" translate="yes" xml:space="preserve">
          <source>The time spent in another thread is not discounted from interrupted line.
On the long run, it should not be a problem if switches are evenly distributed
among lines, but threads executing fewer lines will appear as eating more CPU
time than they really do.</source>
          <target state="translated">在另一个线程中所花费的时间并没有被中断的线路所折算。从长远来看,如果开关均匀分布在各线程中,应该不会有问题,但执行线程较少的线程会显得比实际消耗的CPU时间多。</target>
        </trans-unit>
        <trans-unit id="48dce668f017215e3663eb812e4280c07f7cbb44" translate="yes" xml:space="preserve">
          <source>This also means that the sum of the percentage of all lines can exceed 100%. It
can reach the number of concurrent threads (200% with 2 threads being busy for
the whole profiled execution time, etc).</source>
          <target state="translated">这也就意味着所有线路的百分比之和可以超过100%。它可以达到并发线程数(200%,在整个剖析执行时间内有2个线程繁忙,等等)。</target>
        </trans-unit>
        <trans-unit id="09174b45faa2e2462c148dcf21552048422a0f0e" translate="yes" xml:space="preserve">
          <source>This is not specific to simultaneous multi-thread profiling: profiling a single
thread of a multi-threaded application will also be polluted by time spent in
other threads.</source>
          <target state="translated">这并不是针对同步多线程剖析的:剖析多线程应用程序的单线程也会被其他线程花费的时间所污染。</target>
        </trans-unit>
        <trans-unit id="d06515092700ff54640a00ee1d4fd426bbff1705" translate="yes" xml:space="preserve">
          <source>Thread-aware profiling</source>
          <target state="translated">线程感知剖析</target>
        </trans-unit>
        <trans-unit id="aa5a59b6fefb89120123dd8194b080ce97426c1a" translate="yes" xml:space="preserve">
          <source>ThreadProfile</source>
          <target state="translated">线程简介</target>
        </trans-unit>
        <trans-unit id="0bb18642b70b9f8a9c12ccf39487328f306b8e19" translate="yes" xml:space="preserve">
          <source>Usage</source>
          <target state="translated">使用方法</target>
        </trans-unit>
        <trans-unit id="7b6f28b4579a699bbda8bff7d83d1e1b57122ca2" translate="yes" xml:space="preserve">
          <source>Why another profiler ?</source>
          <target state="translated">为什么是另一个侧写器?</target>
        </trans-unit>
        <trans-unit id="5397e0583f14f6c88de06b1ef28f460a1fb5b0ae" translate="yes" xml:space="preserve">
          <source>Yes</source>
          <target state="translated">是的,是的</target>
        </trans-unit>
        <trans-unit id="d2d1924f9f73dbc61d0e5c570b8de06ebce2b0c2" translate="yes" xml:space="preserve">
          <source>Yes &lt;a href=&quot;#id4&quot; id=&quot;id2&quot;&gt;[2]&lt;/a&gt;</source>
          <target state="translated">Yes &lt;a href=&quot;#id4&quot; id=&quot;id2&quot;&gt;[2]&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="fae1f4f8fb48bdf42d73a55cb59d65486c2ede72" translate="yes" xml:space="preserve">
          <source>You may want to consider triggering pprofile from
a signal handler or other IPC mechanism to profile
a shorter subset. See</source>
          <target state="translated">您可能需要考虑从信号处理程序或其他 IPC 机制中触发 pprofile,以对较短的子集进行配置。请看</target>
        </trans-unit>
        <trans-unit id="c5e083c5a82e792658c81c5e18f4a039efb18471" translate="yes" xml:space="preserve">
          <source>a few minutes</source>
          <target state="translated">几分钟</target>
        </trans-unit>
        <trans-unit id="40cc308a97ea96803b446173b192edcddc1c0e99" translate="yes" xml:space="preserve">
          <source>a few seconds</source>
          <target state="translated">几秒钟</target>
        </trans-unit>
        <trans-unit id="1a8b2182cb32a0517bd1bec9fd436cc1dc7994f9" translate="yes" xml:space="preserve">
          <source>basename starts with</source>
          <target state="translated">基名以</target>
        </trans-unit>
        <trans-unit id="02ceeb200621e1c672fe3630bb8f93c3b12f6cf2" translate="yes" xml:space="preserve">
          <source>cachegrind.out.</source>
          <target state="translated">cachegrind.out。</target>
        </trans-unit>
        <trans-unit id="63c024834063d34a084a67ec2f1005db669160bc" translate="yes" xml:space="preserve">
          <source>class provides the same features as</source>
          <target state="translated">类提供了与</target>
        </trans-unit>
        <trans-unit id="041e3ed9cf9aa8999731e1583619fc193cd8c553" translate="yes" xml:space="preserve">
          <source>for how it can
be used to profile code inside a running (zope)
service (in which case the IPC mechanism is just
Zope normal URL handling).</source>
          <target state="translated">以了解如何在运行中的(zope)服务中使用它来描述代码(在这种情况下,IPC机制只是Zope正常的URL处理)。</target>
        </trans-unit>
        <trans-unit id="cdfe790d1b761a8ace6f86395e948731a16a5c3d" translate="yes" xml:space="preserve">
          <source>is not
recommended in this mode, as it will likely hide what you intend to profile.
Also, explicitly ending pprofile arguments with</source>
          <target state="translated">不建议在这种模式下使用,因为它很可能会隐藏您要配置的内容。另外,明确地以</target>
        </trans-unit>
        <trans-unit id="66ecb3d334060ed9db1900fea75b1e32ea4340e0" translate="yes" xml:space="preserve">
          <source>more (ex: daemon)</source>
          <target state="translated">更多</target>
        </trans-unit>
        <trans-unit id="c8ef8996cf57bd2ba195804b64bb1609f427c445" translate="yes" xml:space="preserve">
          <source>option to generate a zip file containing all files:</source>
          <target state="translated">选项来生成一个包含所有文件的压缩文件。</target>
        </trans-unit>
        <trans-unit id="7034444ab2c1ccb61261863fe31bc8bab6ea6c2a" translate="yes" xml:space="preserve">
          <source>pprofile default mode (&lt;a href=&quot;#deterministic-profiling&quot;&gt;Deterministic profiling&lt;/a&gt;) has a large overhead.
Part of the reason being that it is written to be as portable as possible
(so no C extension). This large overhead can be an issue, which can be
avoided by using &lt;a href=&quot;#statistic-profiling&quot;&gt;Statistic profiling&lt;/a&gt; at the cost of some result
readability decrease.</source>
          <target state="translated">pprofile default mode (&lt;a href=&quot;#deterministic-profiling&quot;&gt;Deterministic profiling&lt;/a&gt;) has a large overhead. Part of the reason being that it is written to be as portable as possible (so no C extension). This large overhead can be an issue, which can be avoided by using &lt;a href=&quot;#statistic-profiling&quot;&gt;Statistic profiling&lt;/a&gt; at the cost of some result readability decrease.</target>
        </trans-unit>
        <trans-unit id="9915a362d32631ebcfa3c8bd7c676b6a8d2c84d5" translate="yes" xml:space="preserve">
          <source>returns, prints annotated code of each file
involved in the execution.</source>
          <target state="translated">返回,打印参与执行的每个文件的注释代码。</target>
        </trans-unit>
        <trans-unit id="79293ae13f1771b041207a5dc49532fca205d3f9" translate="yes" xml:space="preserve">
          <source>some_python_executable</source>
          <target state="translated">一些可执行的python文件</target>
        </trans-unit>
        <trans-unit id="34eb390220700dc0cf34d88553728e9f0d097c17" translate="yes" xml:space="preserve">
          <source>sys.path</source>
          <target state="translated">sys.path</target>
        </trans-unit>
        <trans-unit id="5e7675ec76891e485aab7dca5f72e076e0c3dd4f" translate="yes" xml:space="preserve">
          <source>threading.Thread</source>
          <target state="translated">线程.线程</target>
        </trans-unit>
        <trans-unit id="256ae309370c8a1d805997ca7d0e184ce5966a2d" translate="yes" xml:space="preserve">
          <source>threading.settrace</source>
          <target state="translated">线程.settrace</target>
        </trans-unit>
        <trans-unit id="6794d8a10b21ed918cecebcf20316eb6fbc80def" translate="yes" xml:space="preserve">
          <source>threads
started after profiling is enabled.</source>
          <target state="translated">启用剖析后启动的线程。</target>
        </trans-unit>
        <trans-unit id="cea85174f330eda0e88d0360bcdcf8084a5425d5" translate="yes" xml:space="preserve">
          <source>to propagate tracing to</source>
          <target state="translated">以传播追踪到</target>
        </trans-unit>
        <trans-unit id="1dcedb1625ded1795d244332952cf4511eb16ecb" translate="yes" xml:space="preserve">
          <source>will prevent accidentally
stealing command&amp;rsquo;s arguments:</source>
          <target state="translated">will prevent accidentally stealing command&amp;rsquo;s arguments:</target>
        </trans-unit>
        <trans-unit id="7038159c9e42bd09b4fc2fc48f7146cc3d85873f" translate="yes" xml:space="preserve">
          <source>zpprofile.py</source>
          <target state="translated">zpprofile.py</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
