<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://pypi.org/project/hypothesis-grammar/">
    <body>
      <group id="hypothesis-grammar">
        <trans-unit id="06e715f999c1e8bb74d0ef668de5467dbc5404e8" translate="yes" xml:space="preserve">
          <source>'Rules' must be named all-lowercase, e.g. &lt;code&gt;np&lt;/code&gt;</source>
          <target state="translated">&amp;ldquo;规则&amp;rdquo;必须命名为全小写，例如 &lt;code&gt;np&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="065e98511a3f896062d78116f1f4a79818a9d74c" translate="yes" xml:space="preserve">
          <source>'Terminals' must be named all-caps (terminals only reference literals, not other rules), e.g. &lt;code&gt;DET&lt;/code&gt;</source>
          <target state="translated">&amp;ldquo;端子&amp;rdquo;必须命名为全大写（端子仅引用文字，而不是其他规则），例如 &lt;code&gt;DET&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0e4306aaec34e61c0ed5b8039ff9c6bd77e8c070" translate="yes" xml:space="preserve">
          <source>(But if you're generating action sequences for tests then probably you should check out Hypothesis' &lt;a href=&quot;https://hypothesis.readthedocs.io/en/latest/stateful.html&quot;&gt;stateful testing&lt;/a&gt; features first)</source>
          <target state="translated">（但是，如果您要生成测试的动作序列，那么可能应该首先检查一下假设的&lt;a href=&quot;https://hypothesis.readthedocs.io/en/latest/stateful.html&quot;&gt;状态测试&lt;/a&gt;功能）</target>
        </trans-unit>
        <trans-unit id="7da59d650a4228de748a0d71280684a68d5ad441" translate="yes" xml:space="preserve">
          <source>(If you are looking to generate text from a grammar for purposes other than testing with Hypothesis then this lib can still be useful, but I stongly recommend looking at the &lt;a href=&quot;http://www.nltk.org/howto/generate.html&quot;&gt;tools provided with NLTK&lt;/a&gt; instead.)</source>
          <target state="translated">（如果您要出于语法目的而不是使用假设进行测试来生成文本，则此库仍然有用，但是我强烈建议您查看&lt;a href=&quot;http://www.nltk.org/howto/generate.html&quot;&gt;NLTK随附&lt;/a&gt;的工具。）</target>
        </trans-unit>
        <trans-unit id="f79e28061ca25a0dae68cd9212d7c2ddaf953658" translate="yes" xml:space="preserve">
          <source>(pre-alpha... the stuff I've tried all works, not well tested yet though)</source>
          <target state="translated">（pre-alpha ...我尝试过的所有作品，但尚未经过良好测试）</target>
        </trans-unit>
        <trans-unit id="34ef5ca7249f5ce6a9b2a03376eb3bd60d72a35b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;(&lt;/code&gt; and &lt;code&gt;)&lt;/code&gt; are for grouping, the group can be quantified using any of the modifiers above.</source>
          <target state="translated">&lt;code&gt;(&lt;/code&gt; 和 &lt;code&gt;)&lt;/code&gt; 用于分组，可以使用以上任何修饰符对组进行量化。</target>
        </trans-unit>
        <trans-unit id="69d0a0282362c3d1a791adf8f0b422ad59bbc4f7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;*&lt;/code&gt; i.e. &lt;code&gt;&quot;in&quot;*&lt;/code&gt; means &lt;code&gt;&quot;in&quot;&lt;/code&gt; is expected zero-or-many times.</source>
          <target state="translated">&lt;code&gt;*&lt;/code&gt; 即 &lt;code&gt;&quot;in&quot;*&lt;/code&gt; 表示 &lt;code&gt;&quot;in&quot;&lt;/code&gt; 是预期的零次或多次。</target>
        </trans-unit>
        <trans-unit id="594929d4a73449a1758113e6a81964a0eed29be9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;+&lt;/code&gt; i.e. &lt;code&gt;&quot;in&quot;+&lt;/code&gt; means &lt;code&gt;&quot;in&quot;&lt;/code&gt; is expected one-or-many times.</source>
          <target state="translated">&lt;code&gt;+&lt;/code&gt; 即 &lt;code&gt;&quot;in&quot;+&lt;/code&gt; 表示 &lt;code&gt;&quot;in&quot;&lt;/code&gt; 是预期的多次。</target>
        </trans-unit>
        <trans-unit id="acfb5e63bd26caad67b133356629e859d7e8040b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;?&lt;/code&gt; means optional, i.e. &lt;code&gt;&quot;in&quot;?&lt;/code&gt; means &lt;code&gt;&quot;in&quot;&lt;/code&gt; is expected zero-or-one time.</source>
          <target state="translated">&lt;code&gt;?&lt;/code&gt; 是可选的，即 &lt;code&gt;&quot;in&quot;?&lt;/code&gt; 表示 &lt;code&gt;&quot;in&quot;&lt;/code&gt; 预期为零或一次。</target>
        </trans-unit>
        <trans-unit id="65c66d8b9aad8e761dd0438f1755afc753cb14b7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;start=&quot;s&quot;&lt;/code&gt; tells the parser that the start rule is &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;start=&quot;s&quot;&lt;/code&gt; 告诉解析器开始规则为 &lt;code&gt;s&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ffba1884ae5cdd5a0572dae34fed56976c21cf0d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;|&lt;/code&gt; is alternation, so &lt;code&gt;&quot;in&quot; | &quot;with&quot;&lt;/code&gt; means one-of &lt;code&gt;&quot;in&quot;&lt;/code&gt; or &lt;code&gt;&quot;with&quot;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;|&lt;/code&gt; 是交替的，所以 &lt;code&gt;&quot;in&quot; | &quot;with&quot;&lt;/code&gt; 的装置之一的 &lt;code&gt;&quot;in&quot;&lt;/code&gt; 或 &lt;code&gt;&quot;with&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="53f6efc5cdcf9f3a22526511d7745bdb7b12979b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;~ &amp;lt;min&amp;gt;..&amp;lt;max&amp;gt;&lt;/code&gt; is a range, expected between-&amp;lt;min&amp;gt;-and-&amp;lt;max&amp;gt; times.</source>
          <target state="translated">&lt;code&gt;~ &amp;lt;min&amp;gt;..&amp;lt;max&amp;gt;&lt;/code&gt; 是一个范围，期望介于-&amp;lt;min&amp;gt;-和-&amp;lt;max&amp;gt;次之间。</target>
        </trans-unit>
        <trans-unit id="8175495afd0f99be24db86f956abbc7435b000f3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;~ &amp;lt;num&amp;gt;&lt;/code&gt; means exactly-&amp;lt;num&amp;gt; times.</source>
          <target state="translated">&lt;code&gt;~ &amp;lt;num&amp;gt;&lt;/code&gt; 表示正好-&amp;lt;num&amp;gt;次。</target>
        </trans-unit>
        <trans-unit id="6fc2a5bf81a73fe237a154328c768027afa67a3c" translate="yes" xml:space="preserve">
          <source>A reverse-parser as a Hypotheses strategy: generate examples from an EBNF grammar</source>
          <target state="translated">作为假设策略的逆向解析器:从EBNF语法中生成例子。</target>
        </trans-unit>
        <trans-unit id="b11f8183e944886fa59148cbb5189e20f31848dd" translate="yes" xml:space="preserve">
          <source>Adjacent tokens are concatenated, i.e. &lt;code&gt;DET N&lt;/code&gt; means a &lt;code&gt;DET&lt;/code&gt; followed by a &lt;code&gt;N&lt;/code&gt;.</source>
          <target state="translated">相邻的标记被级联，即 &lt;code&gt;DET N&lt;/code&gt; 指 &lt;code&gt;DET&lt;/code&gt; 后跟一个 &lt;code&gt;N&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fc800738edcebd003994663a677ad7f8e3341029" translate="yes" xml:space="preserve">
          <source>As you can see, we have produced a Hypothesis strategy which is able to generate examples which match the grammar (in this case, short sentences which sometimes makes sense).</source>
          <target state="translated">正如你所看到的,我们已经制作了一个Hypothesis策略,它能够生成符合语法的例子(在这种情况下,短句有时是有意义的)。</target>
        </trans-unit>
        <trans-unit id="4c34dcc622b1da6b7f78e159b817ba5ba1108fcb" translate="yes" xml:space="preserve">
          <source>But the grammar doesn't have to describe text, it might represent a sequence of actions for example. In that case you might want to convert your result tokens into object instances, which could be done via a lookup table.</source>
          <target state="translated">但是,语法不一定要描述文本,比如说,它可能代表一个动作序列。在这种情况下,你可能希望将你的结果标记转换为对象实例,这可以通过一个查找表来完成。</target>
        </trans-unit>
        <trans-unit id="dc9401e01d92475f18b6c76f30c9f4b07ca762e8" translate="yes" xml:space="preserve">
          <source>First you need a grammar. Our grammar format is based on that used by the &lt;a href=&quot;https://lark-parser.readthedocs.io/en/latest/grammar/&quot;&gt;Lark parser&lt;/a&gt; library.  You can see our grammar-parsing grammar &lt;a href=&quot;hypothesis_grammar/grammar.lark&quot;&gt;here&lt;/a&gt;. More details of our grammar format &lt;a href=&quot;#grammar-details&quot;&gt;below&lt;/a&gt;.</source>
          <target state="translated">首先，您需要语法。我们的语法格式基于&lt;a href=&quot;https://lark-parser.readthedocs.io/en/latest/grammar/&quot;&gt;Lark解析器&lt;/a&gt;库使用的语法格式。您可以&lt;a href=&quot;hypothesis_grammar/grammar.lark&quot;&gt;在这里&lt;/a&gt;查看我们的语法解析语法。&lt;a href=&quot;#grammar-details&quot;&gt;下面&lt;/a&gt;是我们语法格式的更多详细信息。</target>
        </trans-unit>
        <trans-unit id="f2784e07adcbc7db90051cd83d24796138debae1" translate="yes" xml:space="preserve">
          <source>Grammar details</source>
          <target state="translated">语法细节</target>
        </trans-unit>
        <trans-unit id="c7530a6dc53e039db1fa76c609ca7579225d1de7" translate="yes" xml:space="preserve">
          <source>Here is an example of using Hypothesis-Grammar:</source>
          <target state="translated">下面是一个使用假设-语法的例子。</target>
        </trans-unit>
        <trans-unit id="334513e51b766e5689a61997385d87079b5771e1" translate="yes" xml:space="preserve">
          <source>Hypothesis-Grammar</source>
          <target state="translated">假设语法</target>
        </trans-unit>
        <trans-unit id="d23367f26b61f8267251a6d0cd014c1bfc25fe30" translate="yes" xml:space="preserve">
          <source>Hypothesis-Grammar is a &quot;reverse parser&quot; - given a grammar it will generate examples of that grammar.</source>
          <target state="translated">Hypothesis-Grammar是一个 &quot;反向解析器&quot;--给定一个语法,它将生成该语法的例子。</target>
        </trans-unit>
        <trans-unit id="8512397b4e5d55cc7988da53f1e53707a6b4cd51" translate="yes" xml:space="preserve">
          <source>It is implemented as a &lt;a href=&quot;https://hypothesis.readthedocs.io/&quot;&gt;Hypothesis&lt;/a&gt; strategy.</source>
          <target state="translated">它是作为&lt;a href=&quot;https://hypothesis.readthedocs.io/&quot;&gt;假设&lt;/a&gt;策略实施的。</target>
        </trans-unit>
        <trans-unit id="1e8128625511f78e7f6a98221108be4105cd8796" translate="yes" xml:space="preserve">
          <source>LHS (name) and RHS are separated by &lt;code&gt;:&lt;/code&gt;</source>
          <target state="translated">LHS（名称）和RHS由以下分隔 &lt;code&gt;:&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3fe993dc8d00fe8d1dcd9fd70305c2ef4e2c9d81" translate="yes" xml:space="preserve">
          <source>So, how does this look?</source>
          <target state="translated">那么,这个怎么看呢?</target>
        </trans-unit>
        <trans-unit id="4bdde3ae857cfb158e4e4b54e3b745c97059108f" translate="yes" xml:space="preserve">
          <source>String literals must be quoted with double-quotes e.g. &lt;code&gt;&quot;man&quot;&lt;/code&gt;</source>
          <target state="translated">字符串文字必须用双引号引起来，例如 &lt;code&gt;&quot;man&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e9fdfd1e154ac05cf9c3cf579648d547828051f8" translate="yes" xml:space="preserve">
          <source>The grammar is taken from an example in the NLTK docs and converted into our &quot;simplified Lark&quot; format.</source>
          <target state="translated">该语法取自NLTK文档中的一个例子,并转换为我们的 &quot;简化云雀 &quot;格式。</target>
        </trans-unit>
        <trans-unit id="7e17a3d7bd0d9cde371729a97139671e37c46125" translate="yes" xml:space="preserve">
          <source>The output will always be a flat list of token strings. If you want a sentence you can just &lt;code&gt;&quot; &quot;.join(example)&lt;/code&gt;.</source>
          <target state="translated">输出将始终是令牌字符串的平面列表。如果您想要一个句子，则只需 &lt;code&gt;&quot; &quot;.join(example)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0bb18642b70b9f8a9c12ccf39487328f306b8e19" translate="yes" xml:space="preserve">
          <source>Usage</source>
          <target state="translated">使用方法</target>
        </trans-unit>
        <trans-unit id="89511a76c8cbc174d6fe0018b08443f894e18a4b" translate="yes" xml:space="preserve">
          <source>What is it?</source>
          <target state="translated">这是什么?</target>
        </trans-unit>
        <trans-unit id="5f5f8cd4a78f6cd933cbf9fff486ee98721bee8a" translate="yes" xml:space="preserve">
          <source>Whitespace is ignored</source>
          <target state="translated">忽略空白处</target>
        </trans-unit>
        <trans-unit id="f440fc0b5a8ed2198e0c8ff92108351e7b09573a" translate="yes" xml:space="preserve">
          <source>You can also use regex literals, they are delimited with forward-slash, e.g. &lt;code&gt;/the[a-z]{0,2}/&lt;/code&gt;. Content for the regex token is generated using Hypothesis' &lt;a href=&quot;https://hypothesis.readthedocs.io/en/latest/data.html#hypothesis.strategies.from_regex&quot;&gt;&lt;code&gt;from_regex&lt;/code&gt;&lt;/a&gt; strategy, with &lt;code&gt;fullmatch=True&lt;/code&gt;.</source>
          <target state="translated">您还可以使用正则表达式文字，它们用正斜杠分隔，例如 &lt;code&gt;/the[a-z]{0,2}/&lt;/code&gt; 。regex令牌的内容是使用Hypothesis的&lt;a href=&quot;https://hypothesis.readthedocs.io/en/latest/data.html#hypothesis.strategies.from_regex&quot;&gt; &lt;code&gt;from_regex&lt;/code&gt; &lt;/a&gt;策略生成的，具有 &lt;code&gt;fullmatch=True&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="63a91052414204f961faae0fbe524fde2183273f" translate="yes" xml:space="preserve">
          <source>or as a test...</source>
          <target state="translated">或作为一个测试...</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
