<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://pypi.org/project/lektor-limit-dependencies/">
    <body>
      <group id="lektor-limit-dependencies">
        <trans-unit id="57c87362ba9f1e26cae0ef2c8570b440c07075fd" translate="yes" xml:space="preserve">
          <source>A Solution?</source>
          <target state="translated">一个解决方案?</target>
        </trans-unit>
        <trans-unit id="d1113406dab4d805986dcd36838b9de599df25f6" translate="yes" xml:space="preserve">
          <source>Add lektor-limit-dependencies to your project from command line:</source>
          <target state="translated">通过命令行将lektor-limit-dependencies添加到你的项目中。</target>
        </trans-unit>
        <trans-unit id="de5446a74e74314a1477b0d84ed3111a64def114" translate="yes" xml:space="preserve">
          <source>At the end, &lt;code&gt;limit_dependencies&lt;/code&gt; records one dependency on a &lt;a href=&quot;https://www.getlektor.com/docs/api/db/obj/#virtual-source-objects&quot;&gt;virtual
source object&lt;/a&gt; which depends only on the sequence of the identities
of the records in the query result.  (Lektor provides a means by which
virtual source objects can report checksums.  If they do, the
dependency tracking mechanism records those checksums, and will
trigger a rebuild should the checksum change.  &lt;code&gt;Limit_dependencies&lt;/code&gt;
generates a virtual source object whose checksum depends on the
sequence identities in the query result.)</source>
          <target state="translated">最后， &lt;code&gt;limit_dependencies&lt;/code&gt; 在&lt;a href=&quot;https://www.getlektor.com/docs/api/db/obj/#virtual-source-objects&quot;&gt;虚拟源对象&lt;/a&gt;上记录了一个依赖关系，该依赖关系仅取决于查询结果中记录的标识顺序。 （Lektor提供了一种方法，虚拟源对象可以通过该方法报告校验和。如果确实如此，则依赖项跟踪机制将记录这些校验和，并在校验和发生更改时触发重建 &lt;code&gt;Limit_dependencies&lt;/code&gt; 生成一个虚拟源对象，其校验和取决于序列中的序列标识。查询结果。）</target>
        </trans-unit>
        <trans-unit id="5fda23d62015b99fb2a9f86b38bcdf2bdf7609c8" translate="yes" xml:space="preserve">
          <source>Author</source>
          <target state="translated">撰稿人</target>
        </trans-unit>
        <trans-unit id="164b3d4809f98d0458414f1bf9cf3c9dcba16bb5" translate="yes" xml:space="preserve">
          <source>Changelog</source>
          <target state="translated">变更日志</target>
        </trans-unit>
        <trans-unit id="e40891d544d734f645310d4547a9707f7290cd49" translate="yes" xml:space="preserve">
          <source>In the above example, this is exactly what we want.  We only want to
trigger a rebuild if the order or composition of the most-recent three
posts changes.  (Or if any of their titles change.  Note that this
gets covered, too, since when the resulting query is iterated over in
the &lt;code&gt;{% for %}&lt;/code&gt; loop, dependencies will be recorded on the three
most-recent posts.)</source>
          <target state="translated">在上面的示例中，这正是我们想要的。我们只想在最近三个职位的顺序或组成发生变化时触发重建。（或者，如果它们的标题发生变化。请注意，这也会被覆盖，因为当在 &lt;code&gt;{% for %}&lt;/code&gt; 循环中迭代结果查询时，相关性将记录在最近的三个帖子中。）</target>
        </trans-unit>
        <trans-unit id="970d9459b2c3bd1aab215bea63f715a31dc6bf75" translate="yes" xml:space="preserve">
          <source>Initial release.</source>
          <target state="translated">初次发布。</target>
        </trans-unit>
        <trans-unit id="c81b79df3c6448eae7c4f80428b54cd5692a17d7" translate="yes" xml:space="preserve">
          <source>Installation</source>
          <target state="translated">安装</target>
        </trans-unit>
        <trans-unit id="2473e96bc614a911821242119918a241a41836d6" translate="yes" xml:space="preserve">
          <source>Introduction</source>
          <target state="translated">介紹</target>
        </trans-unit>
        <trans-unit id="a80231e80e493a0843c82d046db4885620c204bd" translate="yes" xml:space="preserve">
          <source>Jeff Dairiki &lt;a href=&quot;mailto:dairiki@dairiki.org&quot;&gt;dairiki@dairiki.org&lt;/a&gt;</source>
          <target state="translated">Jeff Dairiki &lt;a href=&quot;mailto:dairiki@dairiki.org&quot;&gt;dairiki@dairiki.org&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f1c69b703e5eeee07b4e03f38b8ec2e506b4d1f6" translate="yes" xml:space="preserve">
          <source>Lektor Limit Dependencies</source>
          <target state="translated">Lektor限制依赖性</target>
        </trans-unit>
        <trans-unit id="60cb043c992a452ab9f217a8cde4afda8f6e6de3" translate="yes" xml:space="preserve">
          <source>Lektor plugin to limit dependencies created by queries</source>
          <target state="translated">Lektor插件来限制由查询创建的依赖关系。</target>
        </trans-unit>
        <trans-unit id="a3353eaedd716dcf00a8eb537b2bf88cc7369d5c" translate="yes" xml:space="preserve">
          <source>Motivating Example</source>
          <target state="translated">鼓舞人心的例子</target>
        </trans-unit>
        <trans-unit id="4f61a37e7ab6cdf29f7199297dd3c44c0e71d984" translate="yes" xml:space="preserve">
          <source>Release 0.1a1</source>
          <target state="translated">0.1a1版</target>
        </trans-unit>
        <trans-unit id="ad8e8d940187e590f1575ebb0dee021bd4f2428c" translate="yes" xml:space="preserve">
          <source>Released May 19, 2020</source>
          <target state="translated">2020年5月19日发布</target>
        </trans-unit>
        <trans-unit id="8e488136e008259e15bbae5985cf0aa2665b393d" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://www.getlektor.com/docs/plugins/&quot;&gt;the Lektor plugin documentation&lt;/a&gt; for more information.</source>
          <target state="translated">有关更多信息，请参见&lt;a href=&quot;https://www.getlektor.com/docs/plugins/&quot;&gt;Lektor插件文档&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e6f3dd6a517bec9ad78a5571d8399366f8054ce9" translate="yes" xml:space="preserve">
          <source>Suppose that you would like to list the three most recent blog posts
in the sidebar of your Lektor-based site.  This can be done by adding
something like to your site base template:</source>
          <target state="translated">假设你想在你基于Lektor的网站的侧边栏中列出最近的三篇博客文章。这可以通过在你的网站基础模板中添加类似的内容来实现。</target>
        </trans-unit>
        <trans-unit id="ef34e67472be2550caccfd199e06b9692653f647" translate="yes" xml:space="preserve">
          <source>Technically, it is true that all pages now depend on all posts.  You
might well edit the &lt;code&gt;pub_date&lt;/code&gt; of one of your older posts, such that
it should now appear in the most-recent listing.  However, it is not
true that all pages need to be rebuilt for &lt;em&gt;any&lt;/em&gt; edit of any post.
Unfortunately, Lektor&amp;rsquo;s dependency tracking system is not elaborate
enough to be able to express details about &lt;em&gt;how&lt;/em&gt; pages are
dependendent on other pages; it only records that they &lt;em&gt;are&lt;/em&gt;
dependent, so Lektor has no option but to rebuild everything.</source>
          <target state="translated">从技术上讲，所有页面现在都依赖于所有帖子。您可以编辑其中一个较早的帖子的 &lt;code&gt;pub_date&lt;/code&gt; ，这样它现在应该出现在最新列表中。然而，事实并非如此，所有的页面需要重建的&lt;em&gt;任何&lt;/em&gt;任何职位的编辑。不幸的是，Lektor的依赖性跟踪系统不够完善，无法表达有关页面&lt;em&gt;如何&lt;/em&gt;依赖于其他页面的详细信息。它仅记录它们&lt;em&gt;是&lt;/em&gt; 依赖的，因此Lektor别无选择，只能重建所有内容。</target>
        </trans-unit>
        <trans-unit id="8fc14956143b61b5e6552b4238eb89bcdc0e3571" translate="yes" xml:space="preserve">
          <source>This is an experimental &lt;a href=&quot;https://www.getlektor.com/&quot;&gt;Lektor&lt;/a&gt; plugin which aims to provide tools (or,
at least, a tool) to help keep Lektor&amp;rsquo;s dependency tracking under
control.</source>
          <target state="translated">这是一个实验性的&lt;a href=&quot;https://www.getlektor.com/&quot;&gt;Lektor&lt;/a&gt;插件，旨在提供工具（或至少一个工具）来帮助控制Lektor的依赖项跟踪。</target>
        </trans-unit>
        <trans-unit id="79efab6a67350c7a0ceafd5d7595a06bea3c4fe0" translate="yes" xml:space="preserve">
          <source>This is not without drawbacks, however.  To sort the post query by
date, Lektor iterates through &lt;em&gt;&lt;strong&gt;all&lt;/strong&gt;&lt;/em&gt; of the blogs posts, then sorts
them.  In so doing, it records all of the blog posts as dependencies
&lt;em&gt;of every page on which this most-recent-post query is used&lt;/em&gt;.  If this
is in the sidebar of every page on your site, &lt;em&gt;now every page on your
site will be rebuilt whenever any blog post at all&lt;/em&gt; (not just one of
the three most recent posts) &lt;em&gt;is edited&lt;/em&gt;.</source>
          <target state="translated">但是，这并非没有缺点。为了按日期对帖子查询进行排序，Lektor遍历&lt;em&gt;&lt;strong&gt;所有&lt;/strong&gt;&lt;/em&gt;博客帖子，然后对其进行排序。这样，它将所有博客帖子记录&lt;em&gt;为使用此最新帖子查询的每个页面的&lt;/em&gt;依存关系 。如果这是在每一个页面的网站上的侧边栏，&lt;em&gt;只要任何博客文章在现在所有网站上的每一页将被重建&lt;/em&gt;（不只是最近的三个职位之一）&lt;em&gt;的编辑&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="bffd16dcab6fcb616e39b6db02118ba34204eea1" translate="yes" xml:space="preserve">
          <source>This plugin introduces a Jinja filter, &lt;code&gt;limit_dependencies&lt;/code&gt;.  It
expects, as input, a Lektor query instance.  It iterates through the
input query, and returns a new query instance which will yield the
same results.  While it is doing its iteration, it, essentially,
monkey-patches Lektor&amp;rsquo;s dependency tracking machinery to prevent it
from recording any dependencies.</source>
          <target state="translated">该插件引入了Jinja过滤器 &lt;code&gt;limit_dependencies&lt;/code&gt; 。它期望将Lektor查询实例作为输入。它遍历输入查询，并返回一个新的查询实例，该实例将产生相同的结果。在进行迭代时，从本质上讲，它修补了Lektor的依赖性跟踪机制，以防止其记录任何依赖性。</target>
        </trans-unit>
        <trans-unit id="6f9c48e9e181daa94845c47f890c02f187920d72" translate="yes" xml:space="preserve">
          <source>Thus, the example above, if replaced by:</source>
          <target state="translated">因此,上面的例子,如果换成。</target>
        </trans-unit>
        <trans-unit id="f0a8c31491c46af17c5e928d5a50a07d9232fb61" translate="yes" xml:space="preserve">
          <source>will work in a much more efficient and sane manner.  Pages will be
rebuilt only if there are changes in the order, composition or content
of the three most recent posts.</source>
          <target state="translated">将以更有效和更合理的方式工作。只有在最近三个帖子的顺序、组成或内容发生变化时,才会重建页面。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
