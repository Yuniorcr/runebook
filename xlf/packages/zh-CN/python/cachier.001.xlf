<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://pypi.org/project/cachier/">
    <body>
      <group id="cachier">
        <trans-unit id="28ed3a797da3c48c309a4ef792147f3c56cfec40" translate="yes" xml:space="preserve">
          <source>(</source>
          <target state="translated">（</target>
        </trans-unit>
        <trans-unit id="f1c23d557df7c67b96eb73c14595d021fedefade" translate="yes" xml:space="preserve">
          <source>A simple interface.</source>
          <target state="translated">一个简单的界面。</target>
        </trans-unit>
        <trans-unit id="a3f8605b79d02776fe60576c8b6cbd1b37077b75" translate="yes" xml:space="preserve">
          <source>Adding documentation</source>
          <target state="translated">增加文件</target>
        </trans-unit>
        <trans-unit id="9e4d50dd58881047e7f1c60fdae31281ca7fe1cf" translate="yes" xml:space="preserve">
          <source>As mentioned above, the positional and keyword arguments to the wrapped function must be hashable (i.e. Python&amp;rsquo;s immutable built-in objects, not mutable containers). To get around this limitation the</source>
          <target state="translated">如上所述，包装函数的位置和关键字参数必须是可哈希的（即Python的不可变内置对象，而不是可变容器）。为了解决这个限制，</target>
        </trans-unit>
        <trans-unit id="885c324b71008672d23faa36b63495e5c68708bf" translate="yes" xml:space="preserve">
          <source>Cache Shelf Life</source>
          <target state="translated">缓存保质期</target>
        </trans-unit>
        <trans-unit id="192fde71881059b33be37320e825e6a9ce660d38" translate="yes" xml:space="preserve">
          <source>Cache replacement policies</source>
          <target state="translated">缓存替换政策</target>
        </trans-unit>
        <trans-unit id="8cca54fb45f77abb6f995eeb317c162e2b2df076" translate="yes" xml:space="preserve">
          <source>Cachier Cores</source>
          <target state="translated">Cachier核心</target>
        </trans-unit>
        <trans-unit id="e40e1be9a5b3993dc1b0cc890ba160f49bf4dd90" translate="yes" xml:space="preserve">
          <source>Cachier also accepts several keyword arguments in the calls of the function it wraps rather than in the decorator call, allowing you to modify its behaviour for a specific function call.</source>
          <target state="translated">Cachier还在它所封装的函数调用中而不是在装饰器调用中接受几个关键字参数,允许你修改它对特定函数调用的行为。</target>
        </trans-unit>
        <trans-unit id="bd0e46db3073a89e733cfb41ee671964f5e98b57" translate="yes" xml:space="preserve">
          <source>Cachier is &lt;strong&gt;NOT&lt;/strong&gt;:</source>
          <target state="translated">Cachier &lt;strong&gt;不是&lt;/strong&gt;：</target>
        </trans-unit>
        <trans-unit id="19c18795128ee395941c4ad9aa8df542b8fabbf2" translate="yes" xml:space="preserve">
          <source>Cachier provides a decorator which you can wrap around your functions to give them a persistent cache. The positional and keyword arguments to the wrapped function must be hashable (i.e. Python&amp;rsquo;s immutable built-in objects, not mutable containers). Also, notice that since objects which are instances of user-defined classes are hashable but all compare unequal (their hash value is their id), equal objects across different sessions will not yield identical keys.</source>
          <target state="translated">Cachier提供了一个装饰器，您可以将其包装起来以为它们提供持久的缓存。包装函数的位置和关键字参数必须是可哈希的（即Python的不可变内置对象，而不是可变容器）。另外，请注意，由于作为用户定义类实例的对象是可哈希的，但所有对象都不相等（它们的哈希值是其id），因此不同会话中相等的对象将不会产生相同的键。</target>
        </trans-unit>
        <trans-unit id="89f17d8a59bed1ec95801a6d2e10b5cbf72f502e" translate="yes" xml:space="preserve">
          <source>Clone:</source>
          <target state="translated">克隆。</target>
        </trans-unit>
        <trans-unit id="17658d26a87b890ac602476949f222675089531a" translate="yes" xml:space="preserve">
          <source>Compatible with Python 3.5+ (and Python 2.7 up until version 1.2.8).</source>
          <target state="translated">兼容Python 3.5+(和Python 2.7直到1.2.8版本)。</target>
        </trans-unit>
        <trans-unit id="f5cbdf6bfb51439be085b5c6b7460a7c91eabc3c" translate="yes" xml:space="preserve">
          <source>Contents</source>
          <target state="translated">内容</target>
        </trans-unit>
        <trans-unit id="2d82a4b27a4b305690d5ac612046a955778a9fa5" translate="yes" xml:space="preserve">
          <source>Contributing</source>
          <target state="translated">贡献</target>
        </trans-unit>
        <trans-unit id="8cff37c62de016b4fbf7dc9191fc5f06950c29c6" translate="yes" xml:space="preserve">
          <source>Created by Shay Palachy (&lt;a href=&quot;mailto:shay.palachy%40gmail.com&quot;&gt;shay.palachy@gmail.com&lt;/a&gt;).</source>
          <target state="translated">由Shay Palachy（&lt;a href=&quot;mailto:shay.palachy%40gmail.com&quot;&gt;shay.palachy@gmail.com&lt;/a&gt;）创建。</target>
        </trans-unit>
        <trans-unit id="bfac50d6424b5166c3ee2808c85ae7c139b5182f" translate="yes" xml:space="preserve">
          <source>Credits</source>
          <target state="translated">学分</target>
        </trans-unit>
        <trans-unit id="39294e5b7f716b740934bb27a6f8acc167bfc163" translate="yes" xml:space="preserve">
          <source>Cross-machine caching using MongoDB.</source>
          <target state="translated">使用MongoDB进行跨机缓存。</target>
        </trans-unit>
        <trans-unit id="9288ecf1c8a1acb108a4bc56ae642257e5bbf1ed" translate="yes" xml:space="preserve">
          <source>Defining &amp;ldquo;shelf life&amp;rdquo; for cached values.</source>
          <target state="translated">定义缓存值的&amp;ldquo;保存期限&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="ab9a3c6274e8d3a19a1d8aec9bd7a0f61345d9f2" translate="yes" xml:space="preserve">
          <source>Especially fast. It is meant to replace function calls that take more than&amp;hellip; a second, say (overhead is around 1 millisecond).</source>
          <target state="translated">特别快。它旨在替换耗时超过一秒的函数调用（例如，开销约为1毫秒）。</target>
        </trans-unit>
        <trans-unit id="fc338f87a058158eb824b53705961801516a9460" translate="yes" xml:space="preserve">
          <source>Features</source>
          <target state="translated">特点</target>
        </trans-unit>
        <trans-unit id="96a6679755240f287f1aa5700cdcb0c8cfbe3952" translate="yes" xml:space="preserve">
          <source>For the latest version supporting Python 2.7 please use:</source>
          <target state="translated">对于支持Python 2.7的最新版本,请使用。</target>
        </trans-unit>
        <trans-unit id="c18b32d9c12477f0203d28c4b2014879a5ec64e5" translate="yes" xml:space="preserve">
          <source>Further function calls made while the calculation is being performed will not trigger redundant calculations.</source>
          <target state="translated">在计算进行时,进一步的函数调用将不会触发多余的计算。</target>
        </trans-unit>
        <trans-unit id="4295171aefeb231d8cc32c01f6f51fb25f299f9b" translate="yes" xml:space="preserve">
          <source>Future features</source>
          <target state="translated">未来的特点</target>
        </trans-unit>
        <trans-unit id="d8181a1860e0fdbdf8f3878c274e8d48da124399" translate="yes" xml:space="preserve">
          <source>Fuzzy Shelf Life</source>
          <target state="translated">模糊的保质期</target>
        </trans-unit>
        <trans-unit id="86398fcb1018b8bf6a11f1d567004e5148604845" translate="yes" xml:space="preserve">
          <source>Ignore Cache</source>
          <target state="translated">忽略缓存</target>
        </trans-unit>
        <trans-unit id="fd6c3ebf7befca9f8208f86c76e4d4180303745c" translate="yes" xml:space="preserve">
          <source>Install</source>
          <target state="translated">安装</target>
        </trans-unit>
        <trans-unit id="0c9ff54110ec464917f5d6fb06d076add82a30b7" translate="yes" xml:space="preserve">
          <source>Install in development mode with test dependencies:</source>
          <target state="translated">在开发模式下安装,并进行测试依赖。</target>
        </trans-unit>
        <trans-unit id="c81b79df3c6448eae7c4f80428b54cd5692a17d7" translate="yes" xml:space="preserve">
          <source>Installation</source>
          <target state="translated">安装</target>
        </trans-unit>
        <trans-unit id="d2ea71ee1c3628e8909d3b842a53a04949e266aa" translate="yes" xml:space="preserve">
          <source>Installing for development</source>
          <target state="translated">为开发而安装</target>
        </trans-unit>
        <trans-unit id="d8932cc0951902dc760a2ff0f7b07139c2b684a4" translate="yes" xml:space="preserve">
          <source>Local caching using pickle files.</source>
          <target state="translated">使用pickle文件进行本地缓存。</target>
        </trans-unit>
        <trans-unit id="d6ac3db979e659a31315ee4ae733e293e34e23c9" translate="yes" xml:space="preserve">
          <source>Meant as a transient cache. Python&amp;rsquo;s @lru_cache is better.</source>
          <target state="translated">表示为临时缓存。Python的@lru_cache更好。</target>
        </trans-unit>
        <trans-unit id="76047f09fd28fa2d64394e9a9822cdd1a519966f" translate="yes" xml:space="preserve">
          <source>MongoDB Core</source>
          <target state="translated">MongoDB核心</target>
        </trans-unit>
        <trans-unit id="d0fedd0053b0cef9060cffb1a1493b815eaa4108" translate="yes" xml:space="preserve">
          <source>Multi-core caching.</source>
          <target state="translated">多核缓存。</target>
        </trans-unit>
        <trans-unit id="6eff13a1ed6bcf9aa7db3a60759e6af3639de287" translate="yes" xml:space="preserve">
          <source>Now when a cached value matching the given arguments is found the time of its calculation is checked; if more than</source>
          <target state="translated">现在,当找到一个与给定参数相匹配的缓存值时,会检查其计算时间;如果多于</target>
        </trans-unit>
        <trans-unit id="b48da51eecc56d03a5f0135e841b1cfec0121383" translate="yes" xml:space="preserve">
          <source>Overwrite Cache</source>
          <target state="translated">覆盖缓存</target>
        </trans-unit>
        <trans-unit id="95127e27db8a9c0984185792cf0b5bce6c066cce" translate="yes" xml:space="preserve">
          <source>Package author and current maintainer is Shay Palachy (&lt;a href=&quot;mailto:shay.palachy%40gmail.com&quot;&gt;shay.palachy@gmail.com&lt;/a&gt;); You are more than welcome to approach him for help. Contributions are very welcomed.</source>
          <target state="translated">软件包的作者和现任维护者是Shay Palachy（&lt;a href=&quot;mailto:shay.palachy%40gmail.com&quot;&gt;shay.palachy@gmail.com&lt;/a&gt;）；非常欢迎您向他寻求帮助。捐款非常受欢迎。</target>
        </trans-unit>
        <trans-unit id="2d05a26ce14bd4c58f533ef1558842b5c115caa5" translate="yes" xml:space="preserve">
          <source>Per-function call arguments</source>
          <target state="translated">每个函数的调用参数</target>
        </trans-unit>
        <trans-unit id="5cb651f2803235ed309df22a1f8f93a687150833" translate="yes" xml:space="preserve">
          <source>Persistent, stale-free, local and cross-machine caching for Python functions.</source>
          <target state="translated">对Python函数进行持久的、无滞后的、本地的和跨机器的缓存。</target>
        </trans-unit>
        <trans-unit id="9b13f3a908629efbc78f59451c69b50d919a13ab" translate="yes" xml:space="preserve">
          <source>Pickle Core</source>
          <target state="translated">泡菜芯</target>
        </trans-unit>
        <trans-unit id="8e099f9f7cae947c5ff0ef7a5271190cf4b7cfc7" translate="yes" xml:space="preserve">
          <source>Pure Python.</source>
          <target state="translated">纯粹的Python。</target>
        </trans-unit>
        <trans-unit id="ea753bdc0936e4500b4b92850d42c242fb09c1c1" translate="yes" xml:space="preserve">
          <source>Resetting a Cache</source>
          <target state="translated">重新设置缓存</target>
        </trans-unit>
        <trans-unit id="1e0883db26345cee9aa196cedada38c2dbef49be" translate="yes" xml:space="preserve">
          <source>Running the tests</source>
          <target state="translated">运行测试</target>
        </trans-unit>
        <trans-unit id="38f21c43b8c6057044eef13d4363cb5cd3f535d7" translate="yes" xml:space="preserve">
          <source>S3 core.</source>
          <target state="translated">S3核心。</target>
        </trans-unit>
        <trans-unit id="4ed4ba175074eb0a0278b3104c426821fcf38307" translate="yes" xml:space="preserve">
          <source>Setting Shelf Life</source>
          <target state="translated">设置保质期</target>
        </trans-unit>
        <trans-unit id="73e56e67c864ba412812dd644b749d0c5ee7860d" translate="yes" xml:space="preserve">
          <source>Setting up a Cache</source>
          <target state="translated">设置缓存</target>
        </trans-unit>
        <trans-unit id="9acf535b8cd991fba143356c2b422f9281f1e208" translate="yes" xml:space="preserve">
          <source>Sometimes you may want your function to trigger a calculation when it encounters a stale result, but still not wait on it if it&amp;rsquo;s not that critical. In that case, you can set</source>
          <target state="translated">有时，您可能希望函数在遇到过时的结果时触发计算，但是如果不是那么关键，就不要等待它。在这种情况下，您可以设置</target>
        </trans-unit>
        <trans-unit id="85e9fa7ad0cb402508c319030793dbc3af865082" translate="yes" xml:space="preserve">
          <source>Supported and &lt;a href=&quot;https://travis-ci.org/shaypal5/cachier&quot;&gt;tested on Linux, OS X and Windows&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://travis-ci.org/shaypal5/cachier&quot;&gt;在Linux，OS X和Windows上&lt;/a&gt;受支持和测试。</target>
        </trans-unit>
        <trans-unit id="ffd4cd1d4ffaab2140ba8fb47783028157d679ee" translate="yes" xml:space="preserve">
          <source>The Cachier wrapper adds a</source>
          <target state="translated">Cachier包装器增加了一个</target>
        </trans-unit>
        <trans-unit id="0ba3fff411a237ed1b36fea7ff07c946935aee7f" translate="yes" xml:space="preserve">
          <source>The default core for Cachier is pickle based, meaning each function will store its cache is a separate pickle file in the</source>
          <target state="translated">Cachier的默认核心是基于pickle的,这意味着每个函数都会将其缓存存储在一个单独的pickle文件中。</target>
        </trans-unit>
        <trans-unit id="d5f515c4318635d6885b07dd1e4efdad57820fb7" translate="yes" xml:space="preserve">
          <source>This allows you to have a cross-machine, albeit slower, cache. This functionality requires that the installation of the</source>
          <target state="translated">这允许您拥有一个跨机器的缓存,尽管速度较慢。这个功能需要安装</target>
        </trans-unit>
        <trans-unit id="38bf05017bdec1ae480537a91ba873e819f6ca67" translate="yes" xml:space="preserve">
          <source>This is useful for lengthy calculations that depend on a dynamic data source.</source>
          <target state="translated">这对于依赖于动态数据源的冗长计算非常有用。</target>
        </trans-unit>
        <trans-unit id="5e3a9f91b15e29dd03dbbaa3f14fa9c0ea902d2b" translate="yes" xml:space="preserve">
          <source>This project is documented using the &lt;a href=&quot;https://github.com/numpy/numpy/blob/master/doc/HOWTO_DOCUMENT.rst.txt&quot;&gt;numpy docstring conventions&lt;/a&gt;, which were chosen as they are perhaps the most widely-spread conventions that are both supported by common tools such as Sphinx and result in human-readable docstrings (in my personal opinion, of course). When documenting code you add to this project, please follow &lt;a href=&quot;https://github.com/numpy/numpy/blob/master/doc/HOWTO_DOCUMENT.rst.txt&quot;&gt;these conventions&lt;/a&gt;.</source>
          <target state="translated">该项目使用&lt;a href=&quot;https://github.com/numpy/numpy/blob/master/doc/HOWTO_DOCUMENT.rst.txt&quot;&gt;numpy docstring约定&lt;/a&gt;进行了文档记录，之所以选择numpy docstring约定，是因为它们可能是得到最广泛使用的约定，它们都受到Sphinx等通用工具的支持，并且会导致人类可读的docstring（当然，根据我个人的观点）。在记录添加到该项目的代码时，请遵循&lt;a href=&quot;https://github.com/numpy/numpy/blob/master/doc/HOWTO_DOCUMENT.rst.txt&quot;&gt;以下约定&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d6ed9424b0bf428af630a45ef086f454c9751dbd" translate="yes" xml:space="preserve">
          <source>This will prevent reading the cache file on each cache read, speeding things up a bit, while also nullifying inter-thread functionality (the code is still thread safe, but different threads will have different versions of the cache at times, and will sometime make unnecessary function calls).</source>
          <target state="translated">这样就可以防止在每次读取缓存文件时读取缓存文件,加快一点速度,同时也使线程间的功能无效化(代码仍然是线程安全的,但不同的线程有时会有不同版本的缓存,有时会进行不必要的函数调用)。</target>
        </trans-unit>
        <trans-unit id="7184dc6d1888a8cd5f95d77fe614c2d5cbdae377" translate="yes" xml:space="preserve">
          <source>Thread-safety.</source>
          <target state="translated">线程安全。</target>
        </trans-unit>
        <trans-unit id="85075d46e62374545f38d529e1ce2894579848b7" translate="yes" xml:space="preserve">
          <source>To run the tests, use:</source>
          <target state="translated">要运行测试,使用。</target>
        </trans-unit>
        <trans-unit id="88b33e4e12f75ac8bf792aebde41f1a090f3a612" translate="yes" xml:space="preserve">
          <source>True</source>
          <target state="translated">True</target>
        </trans-unit>
        <trans-unit id="1d4d43cc6f3a833e0340a0d1794b6d7b9958657e" translate="yes" xml:space="preserve">
          <source>Use</source>
          <target state="translated">使用</target>
        </trans-unit>
        <trans-unit id="ec523f870ffe73c6cb867d15120b990291d7a1aa" translate="yes" xml:space="preserve">
          <source>Verbose Cache Call</source>
          <target state="translated">冗长的缓存调用</target>
        </trans-unit>
        <trans-unit id="ecadf77c167c3456c2abfee388ba27a2408c5d16" translate="yes" xml:space="preserve">
          <source>Working with unhashable arguments</source>
          <target state="translated">使用不可隐藏的参数</target>
        </trans-unit>
        <trans-unit id="6be0f5c4c27d575412c88c047bbaf395ae6a9c0e" translate="yes" xml:space="preserve">
          <source>You can add a default, pickle-based, persistent cache to your function - meaning it will last across different Python kernels calling the wrapped function - by decorating it with the</source>
          <target state="translated">你可以为你的函数添加一个默认的、基于pickle的、持久化的缓存--这意味着它将在不同的Python内核中调用封装的函数--通过使用</target>
        </trans-unit>
        <trans-unit id="49fddf8851061f1494f32053795e5506592e53bd" translate="yes" xml:space="preserve">
          <source>You can configure</source>
          <target state="translated">您可以配置</target>
        </trans-unit>
        <trans-unit id="b7e239658d29aa242a3a03e14e0d55e96a101faf" translate="yes" xml:space="preserve">
          <source>You can get the fully qualified path to the directory of cache files used by</source>
          <target state="translated">您可以获得由您所使用的缓存文件目录的完整路径。</target>
        </trans-unit>
        <trans-unit id="a09c32f46d01d7b214108f5d34f668cf41814456" translate="yes" xml:space="preserve">
          <source>You can have</source>
          <target state="translated">你可以有</target>
        </trans-unit>
        <trans-unit id="37da9562f95c42d49b6dc50a001f288e2462da25" translate="yes" xml:space="preserve">
          <source>You can set a MongoDB-based cache by assigning</source>
          <target state="translated">您可以通过为您指定的</target>
        </trans-unit>
        <trans-unit id="69b8bcc418bf42924034a6e6027e3298ef1cd351" translate="yes" xml:space="preserve">
          <source>You can set any duration as the shelf life of cached return values of a function by providing a corresponding</source>
          <target state="translated">您可以通过提供一个相应的函数的返回值的保质期来设置任何持续时间。</target>
        </trans-unit>
        <trans-unit id="ea2253517fd9a1942a64d5fbdc7cb65b351a8275" translate="yes" xml:space="preserve">
          <source>You can slightly optimise pickle-based caching if you know your code will only be used in a single thread environment by setting:</source>
          <target state="translated">如果你知道你的代码只会在单线程环境中使用,你可以通过设置稍微优化基于pickle的缓存。</target>
        </trans-unit>
        <trans-unit id="17f9f9ea6a8cabefa26354ebaf84c1cb7a0e669d" translate="yes" xml:space="preserve">
          <source>by default) by calling the</source>
          <target state="translated">默认情况下)通过调用</target>
        </trans-unit>
        <trans-unit id="943fd08e21be8c211effe5646ae93d24b4953a34" translate="yes" xml:space="preserve">
          <source>cache_dir</source>
          <target state="translated">cache_dir</target>
        </trans-unit>
        <trans-unit id="fc04b41d746aade203f2f1116ae46531d9b0ccbf" translate="yes" xml:space="preserve">
          <source>cache_dpath()</source>
          <target state="translated">cache_dpath()</target>
        </trans-unit>
        <trans-unit id="4fbf98b670de0e87ed74da8f425dd1a2bf2c5f15" translate="yes" xml:space="preserve">
          <source>cachier</source>
          <target state="translated">缓存器</target>
        </trans-unit>
        <trans-unit id="6405eb3aa0bf918bef6ccd2c7a59a6d517d7fdca" translate="yes" xml:space="preserve">
          <source>clear_cache()</source>
          <target state="translated">Clear_cache()</target>
        </trans-unit>
        <trans-unit id="268ac1088e9156a29d90bd406f07973cf2d4ead1" translate="yes" xml:space="preserve">
          <source>decorator (notice the</source>
          <target state="translated">装饰者(注意</target>
        </trans-unit>
        <trans-unit id="5cb8118a19c4bcf707996d44256a04d527479ace" translate="yes" xml:space="preserve">
          <source>decorator can be provided with a callable that gets the args and kwargs from the decorated function and returns a hash key for them.</source>
          <target state="translated">decorator可以提供一个可调用的函数,从被装饰的函数中获取args和kwargs,并返回它们的哈希键。</target>
        </trans-unit>
        <trans-unit id="692619d762ccc0152433ecf7042819426be553da" translate="yes" xml:space="preserve">
          <source>directory. Naturally, this kind of cache is both machine-specific and user-specific.</source>
          <target state="translated">目录。当然,这种缓存既是机器特有的,也是用户特有的。</target>
        </trans-unit>
        <trans-unit id="d828b1ef4a3fc648615997943a705cfcd5f1a45d" translate="yes" xml:space="preserve">
          <source>function to each wrapped function. To reset the cache of the wrapped function simply call this method:</source>
          <target state="translated">函数到每个被封装的函数。要重置封装函数的缓存,只需调用这个方法。</target>
        </trans-unit>
        <trans-unit id="1dfae75987ab2c547d85f2eedd53692b234672e0" translate="yes" xml:space="preserve">
          <source>function:</source>
          <target state="translated">职能。</target>
        </trans-unit>
        <trans-unit id="39ef1df9f3c2574b9f5b17ea97aaf727f95378b5" translate="yes" xml:space="preserve">
          <source>hash_params</source>
          <target state="translated">hash_params</target>
        </trans-unit>
        <trans-unit id="4f96136e69b99e31e1103d170617cab2880f5569" translate="yes" xml:space="preserve">
          <source>ignore any existing cache for a specific function call by passing</source>
          <target state="translated">忽略特定函数调用的任何现有缓存,通过传递</target>
        </trans-unit>
        <trans-unit id="0bcf6f5c751e824b70527ad40a64cfe08ab0b2d3" translate="yes" xml:space="preserve">
          <source>ignore_cache=True</source>
          <target state="translated">ignore_cache=True</target>
        </trans-unit>
        <trans-unit id="43fd6eeb2ca43fb4d39fab01758a9cdfad59d46e" translate="yes" xml:space="preserve">
          <source>mongetter</source>
          <target state="translated">灌注者</target>
        </trans-unit>
        <trans-unit id="071cbb0d73f35caada63d23592aa40a90a99be1f" translate="yes" xml:space="preserve">
          <source>next_time</source>
          <target state="translated">next_time</target>
        </trans-unit>
        <trans-unit id="cb37b70cbef5a43f1b34b6de71c6690065f8a6bf" translate="yes" xml:space="preserve">
          <source>object to the</source>
          <target state="translated">反对</target>
        </trans-unit>
        <trans-unit id="83f217d33dd3b2bef4ecbaad0fcdd9a4bee43f9c" translate="yes" xml:space="preserve">
          <source>object with writing permissions:</source>
          <target state="translated">有写入权限的对象。</target>
        </trans-unit>
        <trans-unit id="1bc618bef32305253848df2dfab299ca0775b15d" translate="yes" xml:space="preserve">
          <source>overwrite an existing cache entry - if one exists - for a specific function call by passing</source>
          <target state="translated">覆盖一个现有的缓存条目--如果存在的话--通过传递</target>
        </trans-unit>
        <trans-unit id="1cf41e8f669824d9c3412a34c25923c4450856dc" translate="yes" xml:space="preserve">
          <source>overwrite_cache=True</source>
          <target state="translated">overwrite_cache=True</target>
        </trans-unit>
        <trans-unit id="43e5c7eecb2d3f1deb9e4618471ef5eb22af1ee5" translate="yes" xml:space="preserve">
          <source>parameter of the</source>
          <target state="translated">参数的</target>
        </trans-unit>
        <trans-unit id="9ef2f8ace50c9e18d95ea57b385e20d9d73e70a4" translate="yes" xml:space="preserve">
          <source>parameter with the path to that directory:</source>
          <target state="translated">用该目录的路径作为参数。</target>
        </trans-unit>
        <trans-unit id="bd2a0f5ff9872c4fb53012a32fc945714cec69e7" translate="yes" xml:space="preserve">
          <source>parameter:</source>
          <target state="translated">参数。</target>
        </trans-unit>
        <trans-unit id="9af3a2dc436aaf0e87970b9d0d357a87ee073312" translate="yes" xml:space="preserve">
          <source>print out a detailed explanation of the logic of a specific call by passing</source>
          <target state="translated">打印出一个特定调用的详细逻辑解释,通过传递</target>
        </trans-unit>
        <trans-unit id="2fb96b514a8ad2cc749969aeeb375de53ee188e7" translate="yes" xml:space="preserve">
          <source>pymongo</source>
          <target state="translated">皮蒙果</target>
        </trans-unit>
        <trans-unit id="e33c5e100375494f1c86202478ee15788119e6ac" translate="yes" xml:space="preserve">
          <source>pymongo.Collection</source>
          <target state="translated">pymongo.Collection</target>
        </trans-unit>
        <trans-unit id="b0dbd8e9151f3fd900cdc9e5a53f37ef18a112f9" translate="yes" xml:space="preserve">
          <source>python package.</source>
          <target state="translated">python包。</target>
        </trans-unit>
        <trans-unit id="34505a8098e5fcb0582b1c9db55fc7851e039497" translate="yes" xml:space="preserve">
          <source>stale_after</source>
          <target state="translated">陈旧的_后</target>
        </trans-unit>
        <trans-unit id="c1f72fbadf2daff20c945f18078ad8f6d5b5b223" translate="yes" xml:space="preserve">
          <source>time has since passed, the function will be run again for the same arguments and the new value will be cached and returned.</source>
          <target state="translated">时间已过,函数将再次运行相同的参数,新的值将被缓存并返回。</target>
        </trans-unit>
        <trans-unit id="74962d37bf1cb045da5386cecce96f2b7b6bc2e6" translate="yes" xml:space="preserve">
          <source>timedelta</source>
          <target state="translated">时效性</target>
        </trans-unit>
        <trans-unit id="4374aaee247fb237ce6c97d5c8d64bbe474d16de" translate="yes" xml:space="preserve">
          <source>to</source>
          <target state="translated">にとって</target>
        </trans-unit>
        <trans-unit id="15bf9f4122b7e8ba17a99a2a08538b63e1d6205e" translate="yes" xml:space="preserve">
          <source>to have your function trigger a recalculation &lt;strong&gt;in a separate thread&lt;/strong&gt;, but return the currently cached stale value:</source>
          <target state="translated">让您的函数&lt;strong&gt;在单独的线程中&lt;/strong&gt;触发重新计算，但返回当前缓存的陈旧值：</target>
        </trans-unit>
        <trans-unit id="fbde8376553198493927b83cefcaa52320217062" translate="yes" xml:space="preserve">
          <source>to the function call. The cache will neither be checked nor updated with the new return value.</source>
          <target state="translated">到函数调用中。缓存不会被检查,也不会用新的返回值更新。</target>
        </trans-unit>
        <trans-unit id="bacf89622bfe072162c0a9036069a8a8784b8f6b" translate="yes" xml:space="preserve">
          <source>to the function call. The cache will not be checked but will be updated with the new return value.</source>
          <target state="translated">到函数调用中。缓存不会被检查,但会用新的返回值更新。</target>
        </trans-unit>
        <trans-unit id="5d5d2f650a33457708e1991c324e2d188789f923" translate="yes" xml:space="preserve">
          <source>to the function call. This can be useful if you are not sure why a certain function result is, or is not, returned.</source>
          <target state="translated">到函数调用中。如果你不确定为什么返回或不返回某个函数的结果,这很有用。</target>
        </trans-unit>
        <trans-unit id="87ba19b359dd9b96802bdeac2d8fed68133e74ba" translate="yes" xml:space="preserve">
          <source>to use another directory by providing the</source>
          <target state="translated">来使用另一个目录,提供</target>
        </trans-unit>
        <trans-unit id="8ffb4c66d744bf0b095062777f02a26f7280acfb" translate="yes" xml:space="preserve">
          <source>verbose_cache=True</source>
          <target state="translated">verbose_cache=True</target>
        </trans-unit>
        <trans-unit id="908448b98001f4a2c7b2a90b25ac220c1bf6ce5d" translate="yes" xml:space="preserve">
          <source>with a callable that returns a</source>
          <target state="translated">与一个可调用的,返回一个</target>
        </trans-unit>
        <trans-unit id="52e0612303b39c0691e807b9c7a297fa35003367" translate="yes" xml:space="preserve">
          <source>with:</source>
          <target state="translated">与:</target>
        </trans-unit>
        <trans-unit id="27f5343120ff3f20919d9f0a2bf9b73cb6fd9cde" translate="yes" xml:space="preserve">
          <source>~/.cachier</source>
          <target state="translated">〜/ .cachier</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
