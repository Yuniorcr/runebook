<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://pypi.org/project/backoff/">
    <body>
      <group id="backoff">
        <trans-unit id="5c10b5b2cd673a0616d529aa5234b12ee7153808" translate="yes" xml:space="preserve">
          <source>,</source>
          <target state="translated">，</target>
        </trans-unit>
        <trans-unit id="8278d2adba7612cf98a492d21a4ac4c78acb1202" translate="yes" xml:space="preserve">
          <source>, and</source>
          <target state="translated">和</target>
        </trans-unit>
        <trans-unit id="90a63bb31aecf55896978f3194d63221fe93d0a2" translate="yes" xml:space="preserve">
          <source>-decorated function may still
need to do exception handling.</source>
          <target state="translated">装饰的函数可能仍需要执行异常处理。</target>
        </trans-unit>
        <trans-unit id="a6d58f8e0d971a68c4771edeac2cfab69fba4c32" translate="yes" xml:space="preserve">
          <source>.
This may be useful in reporting statistics or performing other custom
logging.</source>
          <target state="translated">。这在报告统计信息或执行其他自定义日志记录时可能很有用。</target>
        </trans-unit>
        <trans-unit id="3a09fbc2ff44e8016d69b15fa437310bb10dcff6" translate="yes" xml:space="preserve">
          <source>. In this case, if desired alternative logging behavior
could be defined by using custom event handlers.</source>
          <target state="translated">。在这种情况下，如果需要，可以使用自定义事件处理程序定义替代的日志记录行为。</target>
        </trans-unit>
        <trans-unit id="2a7e2a74a560968937568ed386fd9142cf5f3863" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;args&lt;/em&gt;: positional arguments to func</source>
          <target state="translated">&lt;em&gt;args&lt;/em&gt;：func的位置参数</target>
        </trans-unit>
        <trans-unit id="dfd78ba066a3c318e641052d78abcb8e5ad065a4" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;elapsed&lt;/em&gt;: elapsed time in seconds so far</source>
          <target state="translated">&lt;em&gt;经过的时间&lt;/em&gt;：到目前为止经过的时间（以秒为单位）</target>
        </trans-unit>
        <trans-unit id="8c0545d4e42723b26dcb92c68343caae530e9a0a" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;kwargs&lt;/em&gt;: keyword arguments to func</source>
          <target state="translated">&lt;em&gt;kwargs&lt;/em&gt;：func的关键字参数</target>
        </trans-unit>
        <trans-unit id="ec9983c683159943965e22e9c62c9d055800eead" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;target&lt;/em&gt;: reference to the function or method being invoked</source>
          <target state="translated">&lt;em&gt;target&lt;/em&gt;：对要调用的函数或方法的引用</target>
        </trans-unit>
        <trans-unit id="6931b64be2d37f300eb3637508eda4da20e2af71" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;tries&lt;/em&gt;: number of invocation tries so far</source>
          <target state="translated">&lt;em&gt;trys&lt;/em&gt;：到目前为止的调用尝试次数</target>
        </trans-unit>
        <trans-unit id="aebaa6b421e0ff2326c27b851c4dc7c6ba7364da" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;value&lt;/em&gt;: value triggering backoff (</source>
          <target state="translated">&lt;em&gt;value&lt;/em&gt;：触发​​退避值（</target>
        </trans-unit>
        <trans-unit id="83b1dafd7c9209d5683ef291b071c278304ff758" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;wait&lt;/em&gt;: seconds to wait (</source>
          <target state="translated">&lt;em&gt;等待&lt;/em&gt;：&lt;em&gt;等待的&lt;/em&gt;秒数（</target>
        </trans-unit>
        <trans-unit id="87a129cdd8433d8a00a59922804e9dda99247d90" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Function decoration for backoff and retry&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;功能装饰，用于退回和重试&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0e848b69f3e2892e6d444eacdfcf5251eff104fc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Getting exception info&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;获取异常信息&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f6c2dbf107d639fc63d7d67033a0478bc24fbf94" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Give Up Conditions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;放弃条件&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="551add8f4ac65448bbdfec7c19be5ad7f030053a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Multiple handlers per event type&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;每种事件类型有多个处理程序&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0bde41f87792462eb2be877227d62bf8946cac2f" translate="yes" xml:space="preserve">
          <source>@backoff.on_exception</source>
          <target state="translated">@ backoff.on_exception</target>
        </trans-unit>
        <trans-unit id="6d7aa7ea26009f5a2800c97462928d4bd9e3ec91" translate="yes" xml:space="preserve">
          <source>@backoff.on_predicate</source>
          <target state="translated">@ backoff.on_predicate</target>
        </trans-unit>
        <trans-unit id="e6fd916cad4f34468ccb8375f1369d2c69c12915" translate="yes" xml:space="preserve">
          <source>A handler which prints the details of the backoff event could be
implemented like so:</source>
          <target state="translated">一个打印backoff事件细节的处理程序可以这样实现。</target>
        </trans-unit>
        <trans-unit id="dc6449749fd52d6298e19e3f00c9556d8a7f3f9f" translate="yes" xml:space="preserve">
          <source>A jitter algorithm can be supplied with the</source>
          <target state="translated">抖动算法可以提供与</target>
        </trans-unit>
        <trans-unit id="6dde8d34c3e26e04943ea485778d45adae228647" translate="yes" xml:space="preserve">
          <source>As of version 1.2, the default jitter function</source>
          <target state="translated">从1.2版本开始,默认的抖动函数为</target>
        </trans-unit>
        <trans-unit id="8277629acfcb602df77bf7b16003d8441fce8ee5" translate="yes" xml:space="preserve">
          <source>Asynchronous code</source>
          <target state="translated">异步代码</target>
        </trans-unit>
        <trans-unit id="96265d2c05b9f5357f6954c89577ab90fb7ac4d8" translate="yes" xml:space="preserve">
          <source>Backoff supports asynchronous execution in Python 3.5 and above.</source>
          <target state="translated">Backoff支持Python 3.5及以上版本的异步执行。</target>
        </trans-unit>
        <trans-unit id="4bfd87a6a68b461a2365a6c1d22a3d4bc1f19c8b" translate="yes" xml:space="preserve">
          <source>Both backoff decorators optionally accept event handler functions
using the keyword arguments</source>
          <target state="translated">这两个backoff装饰器都可以使用关键字参数来选择接受事件处理函数。</target>
        </trans-unit>
        <trans-unit id="318c75c311e8e14cf5c0dbc86ee333f34b9c24d2" translate="yes" xml:space="preserve">
          <source>By default, backoff and retry attempts are logged to the &amp;lsquo;backoff&amp;rsquo;
logger. By default, this logger is configured with a NullHandler, so
there will be nothing output unless you configure a handler.
Programmatically, this might be accomplished with something as simple
as:</source>
          <target state="translated">默认情况下，退避和重试尝试会记录到&amp;ldquo;退避&amp;rdquo;记录器中。默认情况下，此记录器配置有NullHandler，因此除非配置处理程序，否则不会输出任何内容。以编程方式，这可以通过以下简单的方式完成：</target>
        </trans-unit>
        <trans-unit id="ef7e401c25dd6ae87144a52fa5d0354d8586c594" translate="yes" xml:space="preserve">
          <source>Decorators support both regular functions for synchronous code and
&lt;a href=&quot;https://docs.python.org/3/library/asyncio.html&quot;&gt;asyncio&lt;/a&gt;&amp;rsquo;s coroutines
for asynchronous code.</source>
          <target state="translated">装饰器支持同步代码的常规功能和 异步代码的&lt;a href=&quot;https://docs.python.org/3/library/asyncio.html&quot;&gt;asyncio&lt;/a&gt;协程。</target>
        </trans-unit>
        <trans-unit id="4bb99e856dea0b88518519339118a3c5d0fa7c7c" translate="yes" xml:space="preserve">
          <source>Default logging can be disabled all together by specifying</source>
          <target state="translated">默认日志记录可以通过指定的</target>
        </trans-unit>
        <trans-unit id="1d0a0bc46dabda5a6dbcf0a2f18e3e9acbc27ae7" translate="yes" xml:space="preserve">
          <source>Event handlers</source>
          <target state="translated">事件处理程序</target>
        </trans-unit>
        <trans-unit id="eb01bf04c9a0e8a71c45816513df424f1c7ffedb" translate="yes" xml:space="preserve">
          <source>Examples</source>
          <target state="translated">例子</target>
        </trans-unit>
        <trans-unit id="8548c32df11b47436b77713ee1818090b42adb4a" translate="yes" xml:space="preserve">
          <source>Extra keyword arguments are passed when initializing the
wait generator, so the</source>
          <target state="translated">初始化等待生成器时,会传递额外的关键字参数,所以</target>
        </trans-unit>
        <trans-unit id="842f406064f2a8940c26bb023caa19a7d5cfbc65" translate="yes" xml:space="preserve">
          <source>Function decoration for backoff and retry</source>
          <target state="translated">后退和重试的功能装饰</target>
        </trans-unit>
        <trans-unit id="965ca5a5200702e7e2c17a9d1e689e2a85aaa0a2" translate="yes" xml:space="preserve">
          <source>Handlers must be callables with a unary signature accepting a dict
argument. This dict contains the details of the invocation. Valid keys
include:</source>
          <target state="translated">处理程序必须是可调用的,具有接受dict参数的单数签名。这个dict包含了调用的细节。有效的键包括:</target>
        </trans-unit>
        <trans-unit id="976ba0b3f3d1500e284893871e638c8e6ef54068" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s an example which uses a fibonacci sequence backoff when the
return value of the target function is the empty list:</source>
          <target state="translated">这是一个示例，该示例在目标函数的返回值为空列表时使用斐波那契序列退避：</target>
        </trans-unit>
        <trans-unit id="4e3e3b622a1d30df4cdbe5caf8b7e03c55b57bac" translate="yes" xml:space="preserve">
          <source>In all cases, iterables of handler functions are also accepted, which
are called in turn. For example, you might provide a simple list of
handler functions as the value of the</source>
          <target state="translated">在所有情况下,处理函数的迭代函数也是可以接受的,这些函数依次被调用。例如,你可以提供一个简单的处理函数列表,作为函数的</target>
        </trans-unit>
        <trans-unit id="1003d9c9fc0ab02f7e70c56589df98f30061835a" translate="yes" xml:space="preserve">
          <source>In some cases the raised exception instance itself may need to be
inspected in order to determine if it is a retryable condition. The</source>
          <target state="translated">在某些情况下,可能需要检查引发的异常实例本身,以确定它是否是一个可重试的条件。异常实例的</target>
        </trans-unit>
        <trans-unit id="7ed84ab6b5608ec53c300dfeca86893cb101cd3d" translate="yes" xml:space="preserve">
          <source>In the case of the</source>
          <target state="translated">的情况下。</target>
        </trans-unit>
        <trans-unit id="b010576ebc543abd3692e57f27392f714005c646" translate="yes" xml:space="preserve">
          <source>It is also possible to specify an alternate logger with the</source>
          <target state="translated">也可以通过设置的</target>
        </trans-unit>
        <trans-unit id="b15f24c3efa82c27eb813106ed5b08a8ae7a0d32" translate="yes" xml:space="preserve">
          <source>It is also supported to specify a Logger (or LoggerAdapter) object
directly.</source>
          <target state="translated">也支持直接指定一个Logger(或LoggerAdapter)对象。</target>
        </trans-unit>
        <trans-unit id="70a5b3c8eeaa674ea3790971e290d22205948eed" translate="yes" xml:space="preserve">
          <source>Jitter</source>
          <target state="translated">抖动</target>
        </trans-unit>
        <trans-unit id="9aaa1a381dcc0e6e8917fc93ec91556612a58ab9" translate="yes" xml:space="preserve">
          <source>Keyword argument</source>
          <target state="translated">关键字论点</target>
        </trans-unit>
        <trans-unit id="2ebee8b95304d6f2641fb64aa8296a4b89bfa1d6" translate="yes" xml:space="preserve">
          <source>Logging configuration</source>
          <target state="translated">记录配置</target>
        </trans-unit>
        <trans-unit id="fb264b08d8e7d7ca99131988c482768cfbbdad2e" translate="yes" xml:space="preserve">
          <source>More simply, a function which continues polling every second until it
gets a non-falsey result could be defined like like this:</source>
          <target state="translated">更简单地说,可以这样定义一个每秒钟继续轮询一次直到得到一个非falsey结果的函数。</target>
        </trans-unit>
        <trans-unit id="7074c51adff5fe8077a44fc37dfe15c3d888a94d" translate="yes" xml:space="preserve">
          <source>Optional keyword arguments can specify conditions under which to give
up.</source>
          <target state="translated">可选的关键字参数可以指定放弃的条件。</target>
        </trans-unit>
        <trans-unit id="130cfc058c7d998616e2eec552a73c41bac6d39a" translate="yes" xml:space="preserve">
          <source>Previous versions of backoff defaulted to adding some random number of
milliseconds (up to 1s) to the raw sleep value. If desired, this
behavior is now available as</source>
          <target state="translated">以前版本的backoff默认为在原始睡眠值中加入一些随机的毫秒数(最多1s)。如果需要,这个行为现在可以用</target>
        </trans-unit>
        <trans-unit id="222cad2bd37e45b5f33d5d967590f4b613622bfd" translate="yes" xml:space="preserve">
          <source>Runtime Configuration</source>
          <target state="translated">运行时配置</target>
        </trans-unit>
        <trans-unit id="80311937e5f169e8775775b4cb00be4bad3ff41b" translate="yes" xml:space="preserve">
          <source>Since Kenneth Reitz&amp;rsquo;s &lt;a href=&quot;http://python-requests.org&quot;&gt;requests&lt;/a&gt; module
has become a defacto standard for synchronous HTTP clients in Python,
networking examples below are written using it, but it is in no way required
by the backoff module.</source>
          <target state="translated">由于Kenneth Reitz的&lt;a href=&quot;http://python-requests.org&quot;&gt;请求&lt;/a&gt;模块已成为Python中同步HTTP客户端的事实上的标准，因此下面的网络示例均使用该模块编写，但是backoff模块并不需要。</target>
        </trans-unit>
        <trans-unit id="93ef0dd827103681fcee453b78be2ff14e1a261d" translate="yes" xml:space="preserve">
          <source>The</source>
          <target state="translated">The</target>
        </trans-unit>
        <trans-unit id="a1300be1037211dd17daeea4a61bd04c4b3d348d" translate="yes" xml:space="preserve">
          <source>The backoff decorators may also be combined to specify different
backoff behavior for different cases:</source>
          <target state="translated">也可以将背离装饰器组合起来,为不同的情况指定不同的背离行为。</target>
        </trans-unit>
        <trans-unit id="6808d8b00d91ba9be9ceb865b10b088f93f09fba" translate="yes" xml:space="preserve">
          <source>The decorator functions</source>
          <target state="translated">装饰者功能</target>
        </trans-unit>
        <trans-unit id="4fd61cdc0f9215a43f3229ce364ff4b43d81daf9" translate="yes" xml:space="preserve">
          <source>The decorator will also accept a tuple of exceptions for cases where
the same backoff behavior is desired for more than one exception type:</source>
          <target state="translated">装饰器还将接受一个异常元组,用于需要对多个异常类型进行相同回退行为的情况。</target>
        </trans-unit>
        <trans-unit id="4ffe89f92aa1721f1cf4ca5d509ab4e24b6b9c8d" translate="yes" xml:space="preserve">
          <source>The default logging level is INFO, which corresponds to logging
anytime a retry event occurs. If you would instead like to log
only when a giveup event occurs, set the logger level to ERROR.</source>
          <target state="translated">默认的日志记录级别是INFO,相当于随时记录发生的重试事件。如果您想只在发生放弃事件时进行记录,则将记录器级别设置为ERROR。</target>
        </trans-unit>
        <trans-unit id="9b748d80f0f4f4eca1bdac9cac21ea2760233073" translate="yes" xml:space="preserve">
          <source>The following examples use &lt;a href=&quot;https://aiohttp.readthedocs.io/&quot;&gt;aiohttp&lt;/a&gt;
asynchronous HTTP client/server library.</source>
          <target state="translated">以下示例使用&lt;a href=&quot;https://aiohttp.readthedocs.io/&quot;&gt;aiohttp&lt;/a&gt; 异步HTTP客户端/服务器库。</target>
        </trans-unit>
        <trans-unit id="8babceca3345543f64ae1f6dc816baed9fc6b6cb" translate="yes" xml:space="preserve">
          <source>The keyword argument</source>
          <target state="translated">关键字参数</target>
        </trans-unit>
        <trans-unit id="4ea583cb63d3b492dc8bdb9071ca2a85ad974b45" translate="yes" xml:space="preserve">
          <source>This module provides function decorators which can be used to wrap a
function such that it will be retried until some condition is met. It
is meant to be of use when accessing unreliable resources with the
potential for intermittent failures i.e. network resources and external
APIs. Somewhat more generally, it may also be of use for dynamically
polling resources for externally generated content.</source>
          <target state="translated">这个模块提供了函数装饰器,可以用来包装一个函数,使其在满足某些条件之前被重试。它的目的是在访问不可靠的资源时使用,有可能出现间歇性故障,例如网络资源和外部API。更广泛一点说,它也可以用于动态轮询资源以获取外部生成的内容。</target>
        </trans-unit>
        <trans-unit id="5b62c692188e74042ed4ac3596b109553329f5f6" translate="yes" xml:space="preserve">
          <source>To use backoff in asynchronous code based on
&lt;a href=&quot;https://docs.python.org/3/library/asyncio.html&quot;&gt;asyncio&lt;/a&gt;
you simply need to apply</source>
          <target state="translated">要在基于&lt;a href=&quot;https://docs.python.org/3/library/asyncio.html&quot;&gt;asyncio的&lt;/a&gt;异步代码中使用退避， 您只需要应用</target>
        </trans-unit>
        <trans-unit id="1e89e75f9a3b03d5875f7198d0b26223e016d739" translate="yes" xml:space="preserve">
          <source>Using multiple decorators</source>
          <target state="translated">使用多个装饰者</target>
        </trans-unit>
        <trans-unit id="db476ea02bfda997c6f84abede63f9e1fa009fe6" translate="yes" xml:space="preserve">
          <source>When a give up event occurs, the exception in question is reraised
and so code calling an</source>
          <target state="translated">当放弃事件发生时,相关的异常会被重新启动,因此调用</target>
        </trans-unit>
        <trans-unit id="e0ff4106a7634bdf197aab35ef83d93777bbb8be" translate="yes" xml:space="preserve">
          <source>When not specified, the predicate param defaults to the falsey test,
so the above can more concisely be written:</source>
          <target state="translated">当不指定时,谓词param默认为falsey测试,所以上面可以写得更简洁。</target>
        </trans-unit>
        <trans-unit id="cffa50a32cb13a240d705317bcec65dd1f31b6ad" translate="yes" xml:space="preserve">
          <source>and</source>
          <target state="translated">そして</target>
        </trans-unit>
        <trans-unit id="54ab597856e732f26d81ef11672f12bd22d8bd79" translate="yes" xml:space="preserve">
          <source>are
generally evaluated at import time. This is fine when the keyword args
are passed as constant values, but suppose we want to consult a
dictionary with configuration options that only become available at
runtime. The relevant values are not available at import time. Instead,
decorator functions can be passed callables which are evaluated at
runtime to obtain the value:</source>
          <target state="translated">通常在导入时评估。当关键字args作为常量值传递时,这是很好的,但是假设我们想查阅一个配置选项的字典,这些配置选项只有在运行时才可用。相关的值在导入时是不可用的。相反,可以传递装饰器函数的callables,这些callables在运行时被评估以获得值。</target>
        </trans-unit>
        <trans-unit id="33992bda86ce5e398daa20c60a44384d076932f7" translate="yes" xml:space="preserve">
          <source>backoff</source>
          <target state="translated">后退</target>
        </trans-unit>
        <trans-unit id="883fbad72cde00d78793e0adb7ebce26785fd48c" translate="yes" xml:space="preserve">
          <source>backoff.full_jitter</source>
          <target state="translated">后退.全抖动</target>
        </trans-unit>
        <trans-unit id="6d209351faf6cd160018566e5d6291773f86d57a" translate="yes" xml:space="preserve">
          <source>backoff.on_exception</source>
          <target state="translated">Backoff.on_exception</target>
        </trans-unit>
        <trans-unit id="76213c773d1d4c253faab360ccfbd56db2974d83" translate="yes" xml:space="preserve">
          <source>backoff.on_predicate</source>
          <target state="translated">Backoff.on_predicate</target>
        </trans-unit>
        <trans-unit id="dd2c9c3da740e6fcbb8aa485a4a2c4ba85f69a82" translate="yes" xml:space="preserve">
          <source>backoff.random_jitter</source>
          <target state="translated">后退.随机抖动</target>
        </trans-unit>
        <trans-unit id="6302daa274d5f40479278fadea5058fece41bdf2" translate="yes" xml:space="preserve">
          <source>decorator is used to retry when a particular
condition is true of the return value of the target function.  This may
be useful when polling a resource for externally generated content.</source>
          <target state="translated">装饰器用于在目标函数的返回值的特定条件为真时重试。这在轮询外部生成内容的资源时可能很有用。</target>
        </trans-unit>
        <trans-unit id="2dcdbddeb8e5af4e252faa32ba58ef1a93e84077" translate="yes" xml:space="preserve">
          <source>decorator is used to retry when a specified exception
is raised. Here&amp;rsquo;s an example using exponential backoff when any</source>
          <target state="translated">装饰器用于在引发指定的异常时重试。这是一个使用指数补偿的示例</target>
        </trans-unit>
        <trans-unit id="d8fd4ed07c5bcf64ff34124afba87df495b2dade" translate="yes" xml:space="preserve">
          <source>decorator only)</source>
          <target state="translated">仅限装饰者)</target>
        </trans-unit>
        <trans-unit id="dc0ba2e25de0a6ceb23ceec1ba6543a1b3193aaf" translate="yes" xml:space="preserve">
          <source>decorator, all</source>
          <target state="translated">装饰者,所有</target>
        </trans-unit>
        <trans-unit id="c583e253674b8faed4ea3b06d969d80f8bf28fe4" translate="yes" xml:space="preserve">
          <source>event handlers, with the interface otherwise being identical.</source>
          <target state="translated">事件处理程序,其他方面的接口是相同的。</target>
        </trans-unit>
        <trans-unit id="3362aa4886a690e2310ba2f4ccf246fd533d38e5" translate="yes" xml:space="preserve">
          <source>exception is raised:</source>
          <target state="translated">异常被提出。</target>
        </trans-unit>
        <trans-unit id="c1908a2cba1e490ae68d447210006357a26b91da" translate="yes" xml:space="preserve">
          <source>giveup</source>
          <target state="translated">放弃</target>
        </trans-unit>
        <trans-unit id="02a6f585713df2740f3ac6113f0755bb7067356a" translate="yes" xml:space="preserve">
          <source>handler only)</source>
          <target state="translated">(仅限处理人)</target>
        </trans-unit>
        <trans-unit id="1ef6fcc7985aa5b73889100f791ba5b0e2c79b11" translate="yes" xml:space="preserve">
          <source>handlers are called from within the except block for the
exception being handled. Therefore exception info is available to the
handler functions via the python standard library, specifically</source>
          <target state="translated">处理程序是在被处理的异常的except块中调用的。因此,异常信息可以通过 python 标准库提供给处理函数,特别是通过</target>
        </trans-unit>
        <trans-unit id="cd97bcc8f09050b324c9e8f060d8bbd9742ba0a0" translate="yes" xml:space="preserve">
          <source>implements the &amp;lsquo;Full Jitter&amp;rsquo; algorithm as defined in the AWS
Architecture Blog&amp;rsquo;s &lt;a href=&quot;https://www.awsarchitectureblog.com/2015/03/backoff.html&quot;&gt;Exponential Backoff And Jitter&lt;/a&gt; post.
Note that with this algorithm, the time yielded by the wait generator
is actually the &lt;em&gt;maximum&lt;/em&gt; amount of time to wait.</source>
          <target state="translated">实现了AWS Architecture Blog的&lt;a href=&quot;https://www.awsarchitectureblog.com/2015/03/backoff.html&quot;&gt;指数退避和抖动&lt;/a&gt;帖子中定义的&amp;ldquo;全抖动&amp;rdquo;算法。请注意，使用此算法，等待生成器产生的时间实际上是&lt;em&gt;最大&lt;/em&gt;等待时间。</target>
        </trans-unit>
        <trans-unit id="dd70fee7318e50e2fc644c67e5e0149e17e005de" translate="yes" xml:space="preserve">
          <source>jitter</source>
          <target state="translated">抖动</target>
        </trans-unit>
        <trans-unit id="23cd92941bb91f11acce7147fe5d5f0df91a6f28" translate="yes" xml:space="preserve">
          <source>keyword arg can be used to specify a function which accepts
the exception and returns a truthy value if the exception should not
be retried:</source>
          <target state="translated">关键字arg可以用来指定一个接受异常的函数,如果异常不应该被重试,则返回一个truthhy值。</target>
        </trans-unit>
        <trans-unit id="fd25e57f1179439e43e9176b29603a8e4daf6c01" translate="yes" xml:space="preserve">
          <source>keyword arg to
either of the backoff decorators. This argument should be a function
accepting the original unadulterated backoff value and returning it&amp;rsquo;s
jittered counterpart.</source>
          <target state="translated">关键字arg到任一退避装饰器。此参数应该是一个函数，该函数接受原始的纯净退避值并返回其抖动的对应值。</target>
        </trans-unit>
        <trans-unit id="8902082efd7d95ef030b2725ddaa341e9abb259a" translate="yes" xml:space="preserve">
          <source>keyword arg:</source>
          <target state="translated">关键字arg。</target>
        </trans-unit>
        <trans-unit id="734b09307197ce7ee36d76fa36ac8ba6c869d00d" translate="yes" xml:space="preserve">
          <source>keyword argument.  If a string value is specified the logger will be
looked up by name.</source>
          <target state="translated">关键字参数。如果指定了字符串值,则将按名称查找记录仪。</target>
        </trans-unit>
        <trans-unit id="16cc54fff246b441f70de548a07315312e912e1b" translate="yes" xml:space="preserve">
          <source>logger</source>
          <target state="translated">记录仪</target>
        </trans-unit>
        <trans-unit id="ca17dd53223e9c38ef8f4de47aefda840d75b77a" translate="yes" xml:space="preserve">
          <source>logger=None</source>
          <target state="translated">logger=None</target>
        </trans-unit>
        <trans-unit id="99cfebf41aabaab987d279328c13aa572af56d72" translate="yes" xml:space="preserve">
          <source>max_time</source>
          <target state="translated">最大时间</target>
        </trans-unit>
        <trans-unit id="b34a389b4430eaf8437f3b1eff0165353d3d90b9" translate="yes" xml:space="preserve">
          <source>max_tries</source>
          <target state="translated">最大尝试次数</target>
        </trans-unit>
        <trans-unit id="444da5b0eb3c62d0024a8c8fbc551f62d0962a84" translate="yes" xml:space="preserve">
          <source>max_value</source>
          <target state="translated">最大值</target>
        </trans-unit>
        <trans-unit id="a21867509c883fff7a024de5f5d5839d06e9f445" translate="yes" xml:space="preserve">
          <source>module.</source>
          <target state="translated">模块。</target>
        </trans-unit>
        <trans-unit id="53f1da882133377426e903990a9b646cdb58c26c" translate="yes" xml:space="preserve">
          <source>on_backoff</source>
          <target state="translated">开/关</target>
        </trans-unit>
        <trans-unit id="86a7062cb7f642e0f803cb0a235ead0ed02fd061" translate="yes" xml:space="preserve">
          <source>on_exception</source>
          <target state="translated">异常时</target>
        </trans-unit>
        <trans-unit id="9fa3f957808be6e115183e4eb3da38a710f3d645" translate="yes" xml:space="preserve">
          <source>on_giveup</source>
          <target state="translated">关于放弃</target>
        </trans-unit>
        <trans-unit id="4ccc9a3f9a447f10b552d03cab8572bb09b0e946" translate="yes" xml:space="preserve">
          <source>on_predicate</source>
          <target state="translated">on_predicate</target>
        </trans-unit>
        <trans-unit id="cbbb521981be089fc497be6f4d6939d3b2d48351" translate="yes" xml:space="preserve">
          <source>on_success</source>
          <target state="translated">on_success</target>
        </trans-unit>
        <trans-unit id="1758356db21759f7c5a0da9b4dd1db8fd6feab3f" translate="yes" xml:space="preserve">
          <source>or</source>
          <target state="translated">or</target>
        </trans-unit>
        <trans-unit id="6f0b2ce24add914e491c80aacf6014cb9e1b7f98" translate="yes" xml:space="preserve">
          <source>or the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="392a1ae1ace3f90b99c6a1b593e3a896950d0a10" translate="yes" xml:space="preserve">
          <source>param above is passed as a keyword
arg when initializing the fibo generator.</source>
          <target state="translated">以上param在初始化fibo生成器时作为关键字arg传递。</target>
        </trans-unit>
        <trans-unit id="54faec366d11efdac0f9d2da560e273f92288c2a" translate="yes" xml:space="preserve">
          <source>requests</source>
          <target state="translated">请求</target>
        </trans-unit>
        <trans-unit id="8c3ffb6a96195a147c7dde1f03492d5e0cdff303" translate="yes" xml:space="preserve">
          <source>specifies the maximum amount
of total time in seconds that can elapse before giving up.</source>
          <target state="translated">指定在放弃之前可以经过的最大总时间,以秒为单位。</target>
        </trans-unit>
        <trans-unit id="2e07abea61bef93a94f8fb642448b9b6c5d7d8be" translate="yes" xml:space="preserve">
          <source>specifies the maximum number of calls
to make to the target function before giving up.</source>
          <target state="translated">指定在放弃之前对目标函数的最大调用次数。</target>
        </trans-unit>
        <trans-unit id="268327991ab40460122814287fd515d2ebb9b960" translate="yes" xml:space="preserve">
          <source>sys.exc_info()</source>
          <target state="translated">sys.exc_info()</target>
        </trans-unit>
        <trans-unit id="8bdf48221c79cdff6f82682481fb3aac85a04a04" translate="yes" xml:space="preserve">
          <source>to coroutines.
You can also use coroutines for the</source>
          <target state="translated">到coroutines。您也可以将coroutines用于</target>
        </trans-unit>
        <trans-unit id="efac37b56b3a17b838dbca790f381ac20a5f457c" translate="yes" xml:space="preserve">
          <source>traceback</source>
          <target state="translated">回溯</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
