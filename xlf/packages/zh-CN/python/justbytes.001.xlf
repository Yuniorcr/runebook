<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://pypi.org/project/justbytes/">
    <body>
      <group id="justbytes">
        <trans-unit id="447b8348b9c2348111a636255e107995a2ed4367" translate="yes" xml:space="preserve">
          <source>All errors raised by justbytes operations are subtypes of the RangeError class.</source>
          <target state="translated">所有由justbytes操作引发的错误都是RangeError类的子类型。</target>
        </trans-unit>
        <trans-unit id="3c736d39cfcbcaf284f80530e8748d5df12b2eb3" translate="yes" xml:space="preserve">
          <source>Alternative Packages</source>
          <target state="translated">替代套餐</target>
        </trans-unit>
        <trans-unit id="1f878420017dbe53c0a2676a433496213e5811a0" translate="yes" xml:space="preserve">
          <source>Computing the Representation of a Range</source>
          <target state="translated">计算范围的表示方法</target>
        </trans-unit>
        <trans-unit id="7b6af984283fa6b9adedb133907862c2f2663660" translate="yes" xml:space="preserve">
          <source>Consequently, computations such as addition of two Ranges, and conversion
between different magnitudes of bytes, i.e., from MiB to GiB, must be done
precisely. The underlying implementation must therefore use a precise
representation of the number of bytes. Floating point numbers, which are
frequently the preferred type for the representation of physical
quantities, are disallowed by this requirement.</source>
          <target state="translated">因此,诸如两个Ranges的加法,以及不同数量级的字节之间的转换,即从MiB到GiB的转换等计算必须精确地完成。因此,底层实现必须使用精确的字节数表示。浮点数通常是表示物理量的首选类型,但这一要求不允许使用。</target>
        </trans-unit>
        <trans-unit id="3f4700f344a55dd2a413f15f371fad0a05b8a575" translate="yes" xml:space="preserve">
          <source>Constructing Ranges Programatically</source>
          <target state="translated">以程序化方式构建范围</target>
        </trans-unit>
        <trans-unit id="9c6c971ced78a1f9bbe931fd59030db5c8588db9" translate="yes" xml:space="preserve">
          <source>Displaying Ranges</source>
          <target state="translated">显示范围</target>
        </trans-unit>
        <trans-unit id="805e86a8cbf628e38e4c45612c005a504009e79a" translate="yes" xml:space="preserve">
          <source>Errors</source>
          <target state="translated">错误</target>
        </trans-unit>
        <trans-unit id="cbfba25d0250d74cb72b3ec89534cd1cbcf21211" translate="yes" xml:space="preserve">
          <source>Floating Point Numbers</source>
          <target state="translated">浮点数</target>
        </trans-unit>
        <trans-unit id="d6d84fa09f507b8c85bc8b38c187fe899a44a5c1" translate="yes" xml:space="preserve">
          <source>If you are interested in computing in Python with physical, rather than
logical, quantities, you should consult the pint package:
&lt;a href=&quot;http://pint.readthedocs.org&quot;&gt;http://pint.readthedocs.org&lt;/a&gt;.</source>
          <target state="translated">如果您对使用物理而不是逻辑数量的Python计算感兴趣，则应查阅品脱软件包：&lt;a href=&quot;http://pint.readthedocs.org&quot;&gt;http&lt;/a&gt; : //pint.readthedocs.org。</target>
        </trans-unit>
        <trans-unit id="8d205500c8f287783d5e6ffd528d2f8fbd78d600" translate="yes" xml:space="preserve">
          <source>It is not possible to use floating point numbers or Decimal in computations
with Ranges. Where a fractional quantity is desired, use Fraction objects.
Thus, Range(0) * 1.2 and Range(0) * Decimal(&amp;ldquo;1.2&amp;rdquo;) raise an exception, but
Range(0) * Fraction(&amp;ldquo;1.2&amp;rdquo;) is acceptable.</source>
          <target state="translated">在使用范围进行计算时，不能使用浮点数或十进制。如果需要分数，请使用分数对象。因此，Range（0）* 1.2和Range（0）* Decimal（&amp;ldquo; 1.2&amp;rdquo;）引发了一个例外，但是Range（0）* Fraction（&amp;ldquo; 1.2&amp;rdquo;）是可以接受的。</target>
        </trans-unit>
        <trans-unit id="d2fac8f190d6ba2310cd04193e6922d40dd4506a" translate="yes" xml:space="preserve">
          <source>Its sole purpose is the representation of real address ranges on real
machines. For that reason, it does not allow powers of ranges, imprecise
ranges, or non-finite ranges. In order that the
usual laws of arithmetic can be maintained, it does allow fractional ranges.</source>
          <target state="translated">它的唯一目的是在真实的机器上表示真实的地址范围。因此,它不允许使用范围的幂、不精确的范围或非无限范围。为了保持通常的算术法则,它确实允许小数范围。</target>
        </trans-unit>
        <trans-unit id="45882d11d2960503d0c63d16f01836831a20d4a5" translate="yes" xml:space="preserve">
          <source>Justbytes</source>
          <target state="translated">Justbytes</target>
        </trans-unit>
        <trans-unit id="fadaa413fdb8e444db665691407ee547102d51d5" translate="yes" xml:space="preserve">
          <source>Justbytes is a module for handling computation with
address ranges expressed in bytes. Its principle feature is a Range class from
which can be constructed Range objects which represent a precise and finite
address range in bytes. Various arithmetic operations are defined for Range
objects.</source>
          <target state="translated">Justbytes 是一个处理以字节为单位的地址范围计算的模块。它的主要特点是一个Range类,从这个Range类中可以构造出Range对象,它代表了以字节为单位的精确和有限的地址范围。为Range对象定义了各种算术运算。</target>
        </trans-unit>
        <trans-unit id="e3ac283515eac7e729ac10b009dc00d848c8e9ac" translate="yes" xml:space="preserve">
          <source>Memory Consumption and Bandwidth vs. Address Ranges</source>
          <target state="translated">内存消耗和带宽与地址范围的关系</target>
        </trans-unit>
        <trans-unit id="65725c5cbb6b40fb6d8721e0f58b7f2d9f219336" translate="yes" xml:space="preserve">
          <source>Memory consumption, e.g., by a process during execution on a specified
workload, is a quantity, that like address ranges, is specified in
bytes. However, memory consumption is simply a measurement of the amount of
a phsyical quantity consumed.  When bytes are used only to represent memory
consumption, computations do not generally require the special handling
supplied by this library. Generally, measurement of memory consumption can
be treated like any other physical quantity. The same reasoning applies to
bandwidth. For a physical analogy, one can imagine memory consumption to be
analogous to volume, e.g., litres, and bandwidth to be analogous to flow,
e.g., litres per minute.</source>
          <target state="translated">内存消耗,例如,一个进程在指定的工作负载上执行期间的内存消耗,是一个数量,像地址范围一样,以字节为单位指定。然而,内存消耗只是对消耗的物理量的测量。当字节只用来表示内存消耗时,计算一般不需要本库提供的特殊处理。一般来说,内存消耗的测量可以像其他物理量一样对待。同样的道理也适用于带宽。为了进行物理类比,我们可以想象内存消耗类似于体积,例如,升,带宽类似于流量,例如,每分钟升。</target>
        </trans-unit>
        <trans-unit id="8a99d14f970e76756815cc726112e9e4f2356fee" translate="yes" xml:space="preserve">
          <source>New Range objects can be constructed from Range objects, numeric values, e.g.,
int or Fraction, or strings which represent such numeric values.
strings may be used to represent fractional quantities, e.g., &amp;ldquo;1.2&amp;rdquo;, but
floats and Decimals are disallowed.</source>
          <target state="translated">可以从范围对象，数值（例如int或Fraction）或代表此类数值的字符串构造新的Range对象。字符串可用于表示小数，例如&amp;ldquo; 1.2&amp;rdquo;，但不允许使用浮点数和小数。</target>
        </trans-unit>
        <trans-unit id="8e8e76e830d5d5d96809802aa0ea50ad46a0e846" translate="yes" xml:space="preserve">
          <source>Numerous computations with address ranges are nonsensical. For example, 2
raised to a power which is some address range, is a meaningless computation.
All such operations cause an error to be raised.</source>
          <target state="translated">许多有地址范围的计算都是无意义的。例如,2升到某个地址范围的幂,是一个无意义的计算。所有这样的操作都会引起错误。</target>
        </trans-unit>
        <trans-unit id="a1fdaa6b2a846c8fcf18d414bf8c61db610eda6a" translate="yes" xml:space="preserve">
          <source>Operations</source>
          <target state="translated">业务</target>
        </trans-unit>
        <trans-unit id="43aaf6f57b7c95249bd643787aad1b1255593812" translate="yes" xml:space="preserve">
          <source>Practical Computing with Address Ranges</source>
          <target state="translated">地址范围的实用计算</target>
        </trans-unit>
        <trans-unit id="a85446ae4efaa1d6aaa78d5db82169a15cd8c137" translate="yes" xml:space="preserve">
          <source>Representing Units</source>
          <target state="translated">代表单位</target>
        </trans-unit>
        <trans-unit id="32508a9e120d4892b64a069406f889c0158d8e4a" translate="yes" xml:space="preserve">
          <source>Some computations with precise, finite, values may yield irrational results.
For example, while 2 is rational, its square root is an irrational number.
There is no allowed operation on Range objects which can result in an
irrational Range value. It turns out that all such operations are either
nonsensical or would result in a value with an unrepresentable type.</source>
          <target state="translated">一些精确的、有限的数值的计算可能会产生非理性的结果。例如,虽然2是有理数,但它的平方根却是一个无理数。在Range对象上没有任何允许的操作可以导致非理性的Range值。事实证明,所有这样的操作要么是无意义的,要么会导致一个不可表示类型的值。</target>
        </trans-unit>
        <trans-unit id="a8b73a8356a1277aa6a8d1b69dbdb2cb2c5bcc98" translate="yes" xml:space="preserve">
          <source>The Range class also has standard methods for the representation of Range
objects as str objects.</source>
          <target state="translated">Range类也有标准的方法来表示Range对象为str对象。</target>
        </trans-unit>
        <trans-unit id="94d414b4b47ed43fadec12a10ba6e7313b163f7c" translate="yes" xml:space="preserve">
          <source>The constructor takes an optional units specifier, which defaults to bytes
for all numeric values, and to None for Range objects. The type of the
unit specifier is a named prefix supplied by the size module or a Range object.</source>
          <target state="translated">构造函数接收一个可选的单位指定符,对于所有数值,默认为字节,对于Range对象,默认为None。单位指定符的类型是一个由size模块或Range对象提供的命名前缀。</target>
        </trans-unit>
        <trans-unit id="097c7c0496973f59f9c251a898f12945055be5c7" translate="yes" xml:space="preserve">
          <source>The representation of a Range is computed according to a specified
configuration. In the default configuration, the representation uses IEC
rather than SI units.</source>
          <target state="translated">范围的表示方法是根据指定的配置来计算的。在默认配置中,表示方法使用IEC而不是SI单位。</target>
        </trans-unit>
        <trans-unit id="10256571c4110a674ceb91b10fbb1a84d4045c07" translate="yes" xml:space="preserve">
          <source>The representation of a Range is not a string, but a structured representation
of the precise value, as well as the relationship of the representation to
the actual value.</source>
          <target state="translated">Range的表示不是一个字符串,而是精确值的结构化表示,以及表示与实际值的关系。</target>
        </trans-unit>
        <trans-unit id="39a94149ce22e4db399e8e0e373611c2d8539226" translate="yes" xml:space="preserve">
          <source>The result type of operations is a Range, where appropriate, or a subtype of
Rational, where a numeric value is appropriate.</source>
          <target state="translated">操作的结果类型在适当的情况下是Range,在适当的情况下是Rational的子类型,在适当的情况下是一个数值。</target>
        </trans-unit>
        <trans-unit id="9ed4545ef7ef3799a6493364429d8f4f3088d609" translate="yes" xml:space="preserve">
          <source>The size module supplies a set of named prefixes for both SI and binary units,
for all non-fractional prefixes. Fractional prefixes are not defined.</source>
          <target state="translated">大小模块提供了一组命名的前缀,用于SI和二进制单位,所有非小数前缀。小数前缀没有被定义。</target>
        </trans-unit>
        <trans-unit id="6c9670cfffbaa49a042fc163ff0b2776907074d3" translate="yes" xml:space="preserve">
          <source>The str representation can also be configured. The manipulation of the
representation to form a str object is abstracted from the rest of the source
to emphasize that clients of the package may choose to represent address ranges
in any manner they choose.</source>
          <target state="translated">str表示法也可以被配置。对表示法的操作形成一个str对象的过程是从源的其他部分抽象出来的,以强调包的客户可以选择以任何方式表示地址范围。</target>
        </trans-unit>
        <trans-unit id="c9d82d1c8a3f153080dfa8f031173eb4da4b8f13" translate="yes" xml:space="preserve">
          <source>This module does not accomodate multi-dimensionality of address ranges.
Consequently, multiplying one Range object by another Range object will cause
an error to be raised, since bytes^2 is not representable by the module.
For most uses any operation which would yield a multi-dimensional quantity
is not useful. There are no plans to adapt this package so that it
can accomodate multi-dimensionality of address ranges.</source>
          <target state="translated">本模块不支持地址范围的多维性。因此,用一个Range对象乘以另一个Range对象会引起错误,因为字节^2在本模块中无法表示。对于大多数用途来说,任何会产生一个多维量的操作都是没有用的。目前还没有计划对这个包进行调整,使其能够适应多维度的地址范围。</target>
        </trans-unit>
        <trans-unit id="d5695091f3f7dbec419aa9a43a489657cd3cec78" translate="yes" xml:space="preserve">
          <source>This package does not handle arbitrary user input. It is expected that the
client will transform any input, from whatever source, into a number and an
optional unit specification which can be passed directly to the Range
constructor.</source>
          <target state="translated">这个包不处理任意的用户输入。我们希望客户端能够将任何输入,无论其来源如何,转化为一个数字和一个可选的单位规格,这个单位规格可以直接传递给Range构造函数。</target>
        </trans-unit>
        <trans-unit id="0ad10cd434a732c22b242d2eb564844e1c3e7716" translate="yes" xml:space="preserve">
          <source>This representation is exposed to clients of the library, which may use it
in any way.</source>
          <target state="translated">这种表示方式暴露给库的客户,客户可以以任何方式使用它。</target>
        </trans-unit>
        <trans-unit id="0b75d4ee12567b39421e5cdafacb9fdac3567042" translate="yes" xml:space="preserve">
          <source>User Input</source>
          <target state="translated">用户输入</target>
        </trans-unit>
        <trans-unit id="4cfb3a9ba784840220f2270e361d47e1ff0d6f04" translate="yes" xml:space="preserve">
          <source>When computing with address ranges, the numeric value can be viewed as a
logical, rather than a physical, quantity. That is, unlike, e.g., mass or
length, which are quantities which must be measured with a measuring instrument
which has some built-in imprecision, an address range
is a quantity that is not measured, but is known precisely.
This precision arises because the number represents not as much an amount of
memory as a number of addressable, byte-size, locations in memory.</source>
          <target state="translated">当使用地址范围进行计算时,数值可以被看作是一个逻辑量,而不是一个物理量。也就是说,与质量或长度等必须用测量仪器测量的量不同,这些仪器有一些内在的不精确性,而地址范围是一个不需要测量的量,但却是精确的。这种精确性的产生,是因为数字所代表的不是内存的数量,而是内存中可寻址的、字节大小的位置的数量。</target>
        </trans-unit>
        <trans-unit id="d2fff8678cd4207ea323bf9803cc0d1f80906f54" translate="yes" xml:space="preserve">
          <source>computing with and displaying bytes</source>
          <target state="translated">字节计算和显示</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
