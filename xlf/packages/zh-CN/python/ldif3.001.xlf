<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://pypi.org/project/ldif3/">
    <body>
      <group id="ldif3">
        <trans-unit id="4a36fa72282c7563bf7e21fc24cf3c3c9ea04d1b" translate="yes" xml:space="preserve">
          <source>By default, the</source>
          <target state="translated">默认情况下</target>
        </trans-unit>
        <trans-unit id="d63d3b499bcac6a4dcacfac4949a2fd63334d0d8" translate="yes" xml:space="preserve">
          <source>BytesIO</source>
          <target state="translated">字节IO</target>
        </trans-unit>
        <trans-unit id="5d2c2f534f8b461884c9b10fa9b71a6dc6e54a0a" translate="yes" xml:space="preserve">
          <source>LDIFParser</source>
          <target state="translated">LDIFParser</target>
        </trans-unit>
        <trans-unit id="6eef6648406c333a4035cd5e60d0bf2ecf2606d7" translate="yes" xml:space="preserve">
          <source>None</source>
          <target state="translated">なし</target>
        </trans-unit>
        <trans-unit id="325f5853836d4dd2279341733d3831b7a40e781e" translate="yes" xml:space="preserve">
          <source>Parse LDIF from a file (or</source>
          <target state="translated">从文件中解析LDIF(或</target>
        </trans-unit>
        <trans-unit id="fcc1e3307f587fae6bbcfaf9e24f713e57836607" translate="yes" xml:space="preserve">
          <source>The spec allows to include arbitrary data in base64 encoding or via URL. There
is no way of knowing the encoding of this data. To handle this, there are two
modes:</source>
          <target state="translated">该规范允许以base64编码或通过URL包含任意数据。没有办法知道这些数据的编码。为了处理这个问题,有两种模式。</target>
        </trans-unit>
        <trans-unit id="75f45058f828bd3a7e871c1dfcff7efe62bdda8c" translate="yes" xml:space="preserve">
          <source>The stream object that is passed to parser or writer must be an ascii byte
stream.</source>
          <target state="translated">传递给解析器或写入器的流对象必须是ascii字节流。</target>
        </trans-unit>
        <trans-unit id="f51ca7b3346d7faceb71b1fd4b9b19b72e75b5f2" translate="yes" xml:space="preserve">
          <source>This is a fork of the</source>
          <target state="translated">这是一个分叉的</target>
        </trans-unit>
        <trans-unit id="4247bd31bdb74c5074c844a1f51c93a859ff8578" translate="yes" xml:space="preserve">
          <source>Unicode support</source>
          <target state="translated">支持Unicode</target>
        </trans-unit>
        <trans-unit id="0bb18642b70b9f8a9c12ccf39487328f306b8e19" translate="yes" xml:space="preserve">
          <source>Usage</source>
          <target state="translated">使用方法</target>
        </trans-unit>
        <trans-unit id="f9898755e2e4504a0199973aa282937ab39273be" translate="yes" xml:space="preserve">
          <source>Write LDIF to a file (or</source>
          <target state="translated">将LDIF写入文件(或</target>
        </trans-unit>
        <trans-unit id="14a9dc09e10179b15beaf94c0aed53904ace0336" translate="yes" xml:space="preserve">
          <source>encoding</source>
          <target state="translated">编码</target>
        </trans-unit>
        <trans-unit id="e0ec892ebc46f459426026411cef706f01fdc310" translate="yes" xml:space="preserve">
          <source>generate and parse LDIF data (see RFC 2849).</source>
          <target state="translated">生成并解析LDIF数据(见RFC 2849)。</target>
        </trans-unit>
        <trans-unit id="43c53ab4db0964c7ee178895699485d3162bff01" translate="yes" xml:space="preserve">
          <source>ldif</source>
          <target state="translated">ldif</target>
        </trans-unit>
        <trans-unit id="bf600c633fbafa4d16c9ce91af1257cb333769a4" translate="yes" xml:space="preserve">
          <source>ldif3 - generate and parse LDIF data (see &lt;a href=&quot;https://tools.ietf.org/html/rfc2849&quot;&gt;RFC 2849&lt;/a&gt;).</source>
          <target state="translated">ldif3-生成和解析LDIF数据（请参阅&lt;a href=&quot;https://tools.ietf.org/html/rfc2849&quot;&gt;RFC 2849&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="c7c0c60e305d4a3b6280a4489d6fd11647c70957" translate="yes" xml:space="preserve">
          <source>module from &lt;a href=&quot;http://www.python-ldap.org/&quot;&gt;python-ldap&lt;/a&gt; with python3/unicode
support. See the first entry in CHANGES.rst for a more complete list of
differences.</source>
          <target state="translated">来自&lt;a href=&quot;http://www.python-ldap.org/&quot;&gt;python-ldap的&lt;/a&gt;模块，具有python3 / unicode支持。有关差异的更完整列表，请参见CHANGES.rst中的第一项。</target>
        </trans-unit>
        <trans-unit id="de04fa0e29f9b35e24905d2e512bedc9bb6e09e4" translate="yes" xml:space="preserve">
          <source>of</source>
          <target state="translated">of</target>
        </trans-unit>
        <trans-unit id="7c5629bc397378566f9000c51c4705ec515ecdde" translate="yes" xml:space="preserve">
          <source>to the constructor, in which case the parser will not
try to do any conversion and return bytes directly.</source>
          <target state="translated">到构造函数,在这种情况下,解析器不会尝试进行任何转换,而是直接返回字节。</target>
        </trans-unit>
        <trans-unit id="65a62e469069111064851586da7ad2bffeeeb9a1" translate="yes" xml:space="preserve">
          <source>will try to interpret all values as UTF-8 and
leave only the ones that fail to decode as bytes. But you can also pass an</source>
          <target state="translated">将尝试把所有的值解释为UTF-8,只留下那些未能解码的值作为字节。但你也可以通过一个</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
