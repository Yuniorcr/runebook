<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://pypi.org/project/django-post-request-task/">
    <body>
      <group id="django-post-request-task">
        <trans-unit id="9c6a262e123f8cec5208a5e1ce3b503879875167" translate="yes" xml:space="preserve">
          <source>@atomic</source>
          <target state="translated">@原子</target>
        </trans-unit>
        <trans-unit id="3a282220304a1ac2f5056bbf0b729c4e6019b781" translate="yes" xml:space="preserve">
          <source>A celery 3.x task class whose execution is delayed until after the request
finishes, using</source>
          <target state="translated">celery 3.x任务类,它的执行被延迟到请求完成之后,使用的是</target>
        </trans-unit>
        <trans-unit id="9b53bdae5c9adad66e8048cc6988e4b7af27ab3d" translate="yes" xml:space="preserve">
          <source>A celery task class whose execution is delayed until after the request finishes</source>
          <target state="translated">一个芹菜任务类,它的执行被延迟到请求完成后。</target>
        </trans-unit>
        <trans-unit id="a7fa8efb5fd2089844f8ee2c0842bd372a21b5e9" translate="yes" xml:space="preserve">
          <source>ATOMIC_REQUESTS</source>
          <target state="translated">ATOMIC_REQUES</target>
        </trans-unit>
        <trans-unit id="808e9d4c7515cbc677e6dbe63d1e593abe8dd26f" translate="yes" xml:space="preserve">
          <source>As a bonus feature, if the same task is called with the same argument several
times during a request-response cycle, it will only be queued up once.</source>
          <target state="translated">作为一个额外的功能,如果在一个请求-响应周期内,同一个任务以相同的参数被多次调用,它将只被排队一次。</target>
        </trans-unit>
        <trans-unit id="0215ec6c36578b6ee32c720b3e3e56f4d8ae21b4" translate="yes" xml:space="preserve">
          <source>By default, tests are run with whatever django version is installed. If you want to run tests for other versions
use tox:</source>
          <target state="translated">默认情况下,安装了哪个版本的django就运行哪个版本的测试。如果你想运行其他版本的测试,可以使用 tox.net。</target>
        </trans-unit>
        <trans-unit id="e8d21aae998f108f27cc676cfc04709ebbc6bf82" translate="yes" xml:space="preserve">
          <source>By listening to the</source>
          <target state="translated">通过聆听</target>
        </trans-unit>
        <trans-unit id="48cab693eb729d55251cc97a744543bb36e4c1fe" translate="yes" xml:space="preserve">
          <source>Or, if you are using the task decorator directly:</source>
          <target state="translated">或者,如果你是直接使用任务装饰器。</target>
        </trans-unit>
        <trans-unit id="be64280ade23e74f60a4ce8d57444019c4382156" translate="yes" xml:space="preserve">
          <source>Running tests</source>
          <target state="translated">运行测试</target>
        </trans-unit>
        <trans-unit id="d364fe82578a64da294328080ac6f8cbc2da2ce4" translate="yes" xml:space="preserve">
          <source>That&amp;rsquo;s it. If the task is called from outside the django request-response
cycle, then it will be triggered normally.</source>
          <target state="translated">而已。如果从Django请求-响应周期之外调用该任务，则它将正常触发。</target>
        </trans-unit>
        <trans-unit id="f68aef7ca54e3aa4454b14f4b3f778baf9b05eff" translate="yes" xml:space="preserve">
          <source>This is useful if your views are wrapped in transactions (as they should if
you&amp;rsquo;re making database modifications in them), as you can end up triggering a
celery task too soon before the transaction has been committed (or even trigger
a task when the corresponding transaction has been rolled back).</source>
          <target state="translated">如果您的视图包含在事务中（如果您要在其中进行数据库修改，则应该这样做），这很有用，因为您最终可能会在提交事务之前过早触发celery任务（甚至在交易完成时触发任务）相应的交易已回滚）。</target>
        </trans-unit>
        <trans-unit id="0bb18642b70b9f8a9c12ccf39487328f306b8e19" translate="yes" xml:space="preserve">
          <source>Usage</source>
          <target state="translated">使用方法</target>
        </trans-unit>
        <trans-unit id="cffa50a32cb13a240d705317bcec65dd1f31b6ad" translate="yes" xml:space="preserve">
          <source>and</source>
          <target state="translated">そして</target>
        </trans-unit>
        <trans-unit id="a4746a7771db14dacb5a8b872972117e030be30a" translate="yes" xml:space="preserve">
          <source>django signals, we
can safely trigger a task after all transactions created from</source>
          <target state="translated">django信号,我们可以安全地在所有交易创建后触发一个任务。</target>
        </trans-unit>
        <trans-unit id="158ed7c023ecfd114c86a7b33565c5de6e04f266" translate="yes" xml:space="preserve">
          <source>have been committed.</source>
          <target state="translated">已实施。</target>
        </trans-unit>
        <trans-unit id="1758356db21759f7c5a0da9b4dd1db8fd6feab3f" translate="yes" xml:space="preserve">
          <source>or</source>
          <target state="translated">or</target>
        </trans-unit>
        <trans-unit id="1f5de95823f94b880c38a080d68de9aecdac36be" translate="yes" xml:space="preserve">
          <source>request_finished</source>
          <target state="translated">请求完成</target>
        </trans-unit>
        <trans-unit id="5979286ffbded94e077edc3e8d4a391fc1d68823" translate="yes" xml:space="preserve">
          <source>request_started</source>
          <target state="translated">request_started</target>
        </trans-unit>
        <trans-unit id="469dd20c0176df356dbf53964eb0ad37a3499e2c" translate="yes" xml:space="preserve">
          <source>signals from django
and thread locals.</source>
          <target state="translated">来自django和线程locals的信号。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
