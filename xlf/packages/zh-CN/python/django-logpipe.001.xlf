<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://pypi.org/project/django-logpipe/">
    <body>
      <group id="django-logpipe">
        <trans-unit id="5c10b5b2cd673a0616d529aa5234b12ee7153808" translate="yes" xml:space="preserve">
          <source>,</source>
          <target state="translated">，</target>
        </trans-unit>
        <trans-unit id="8278d2adba7612cf98a492d21a4ac4c78acb1202" translate="yes" xml:space="preserve">
          <source>, and</source>
          <target state="translated">和</target>
        </trans-unit>
        <trans-unit id="903765c186e31c456af2dd0a8b1af35e27926e69" translate="yes" xml:space="preserve">
          <source>, which allows the consumer to explicitly ignore specific message types silently. This helps to filter log noise (messages that a consumer really doesn&amp;rsquo;t care about) from actual errors (messages a consumer is skipping, but should be processing).</source>
          <target state="translated">，它使使用者可以无提示地显式忽略特定的消息类型。这有助于从实际错误（使用者正在跳过但应该处理的消息）中过滤日志噪声（使用者真正不在意的消息）。</target>
        </trans-unit>
        <trans-unit id="7e0b7dff883d6861e892a62c5d13fdeee2afeb2b" translate="yes" xml:space="preserve">
          <source>.
1. Must have a</source>
          <target state="translated">。1.必须有一个</target>
        </trans-unit>
        <trans-unit id="e2d7ba2bf4939b39661ef6382455724c12db2b73" translate="yes" xml:space="preserve">
          <source>. This class method will be called with message data as keyword arguments directly before instantiating the serializer. It should lookup and return the related object (if one exists) so that it can be passed to the serializer&amp;rsquo;s</source>
          <target state="translated">。在实例化序列化程序之前，将直接使用消息数据作为关键字参数来调用此类方法。它应该查找并返回相关对象（如果存在），以便可以将其传递给序列化程序的</target>
        </trans-unit>
        <trans-unit id="88ab9fedb07f1ab06d98fe20e0aa97c4fe67882d" translate="yes" xml:space="preserve">
          <source>1. Must be either a subclass of</source>
          <target state="translated">1.必须是</target>
        </trans-unit>
        <trans-unit id="61cc55aa0453184734c3fa0b621eda6fa874bd83" translate="yes" xml:space="preserve">
          <source>Add</source>
          <target state="translated">添加</target>
        </trans-unit>
        <trans-unit id="f21c4dfb46a3cd544ca1b7134542dcdc6e71187b" translate="yes" xml:space="preserve">
          <source>Add Django 2.1 to tox test suite.</source>
          <target state="translated">将 Django 2.1 加入到 tox 测试套件中。</target>
        </trans-unit>
        <trans-unit id="2e7d120ba3320d9e3ba55ac298fb7121216ba4be" translate="yes" xml:space="preserve">
          <source>Add connection settings to your</source>
          <target state="translated">添加连接设置到您的</target>
        </trans-unit>
        <trans-unit id="dbd3d7c17cc0b57d2980784d2b44e7de422bd091" translate="yes" xml:space="preserve">
          <source>Add new method:</source>
          <target state="translated">增加新方法:</target>
        </trans-unit>
        <trans-unit id="5c9939d96ec5030765ea376c476f6394ff1b1c68" translate="yes" xml:space="preserve">
          <source>Add support for Python 3.7.</source>
          <target state="translated">增加对Python 3.7的支持。</target>
        </trans-unit>
        <trans-unit id="144c7a6c50347e783af6e04fe897ccdc25cdeff1" translate="yes" xml:space="preserve">
          <source>Add support for python-kafka 1.4.4.</source>
          <target state="translated">增加对python-kafka 1.4.4的支持。</target>
        </trans-unit>
        <trans-unit id="74e23423b466ccf9447a0d5a069e2d3feb919c8f" translate="yes" xml:space="preserve">
          <source>Added concept of message types.</source>
          <target state="translated">增加了消息类型的概念。</target>
        </trans-unit>
        <trans-unit id="e7db4f6c303e2a63a9d4926308603e481bf8fb87" translate="yes" xml:space="preserve">
          <source>Added support for AWS Kinesis.</source>
          <target state="translated">增加了对AWS Kinesis的支持。</target>
        </trans-unit>
        <trans-unit id="43ddd06cc437eac739c0896b99458abfb6684f35" translate="yes" xml:space="preserve">
          <source>After some amount of time (when you are sure no old-version messages still exist in Kafka), remove the code related to the old schema version.</source>
          <target state="translated">经过一段时间后(当你确定Kafka中没有旧版本的消息仍然存在时),删除与旧模式版本相关的代码。</target>
        </trans-unit>
        <trans-unit id="e26792af16c97fd3c5d213187b0b33cbfe98b605" translate="yes" xml:space="preserve">
          <source>Below is a sample Django model and it&amp;rsquo;s accompanying serializer.</source>
          <target state="translated">下面是一个示例Django模型及其随附的序列化器。</target>
        </trans-unit>
        <trans-unit id="164b3d4809f98d0458414f1bf9cf3c9dcba16bb5" translate="yes" xml:space="preserve">
          <source>Changelog</source>
          <target state="translated">变更日志</target>
        </trans-unit>
        <trans-unit id="e38de8a0028066c885206cb0346572995a1642d3" translate="yes" xml:space="preserve">
          <source>Dealing with Schema Changes</source>
          <target state="translated">处理模式变更</target>
        </trans-unit>
        <trans-unit id="9cd780126a6cbee99f4a1663a13604d9125012dd" translate="yes" xml:space="preserve">
          <source>Finally, after all the old version 1 messages have been dropped (by log compaction), the</source>
          <target state="translated">最后,在所有旧的版本1的消息都被删除后(通过日志压缩),这个</target>
        </trans-unit>
        <trans-unit id="627b6464f73da86d7de18686941d7b09fc58adb6" translate="yes" xml:space="preserve">
          <source>Finally, consumers can be registered and run automatically by the build in</source>
          <target state="translated">最后,消费者可以通过内置的注册并自动运行在</target>
        </trans-unit>
        <trans-unit id="21aa4df0e5ee730531b02a18b193bd8447274a3d" translate="yes" xml:space="preserve">
          <source>Fix compatibility issue with Django 3.0</source>
          <target state="translated">修正与Django 3.0的兼容性问题。</target>
        </trans-unit>
        <trans-unit id="5f4d11805dd6ed2de8e4b66c76b7fb48b5493c4d" translate="yes" xml:space="preserve">
          <source>For example, if we wanted to require an email field on the</source>
          <target state="translated">举例来说,如果我们要在</target>
        </trans-unit>
        <trans-unit id="68edffd510af78279e051f946b30e579dd35c521" translate="yes" xml:space="preserve">
          <source>If you have multiple data-types in a single topic or stream, you can consume them all by registering multiple serializers with the consumer.</source>
          <target state="translated">如果你在一个主题或流中有多个数据类型,你可以通过向消费者注册多个序列器来消费它们。</target>
        </trans-unit>
        <trans-unit id="271836dc950be42ea67e7e4d2f48692567828398" translate="yes" xml:space="preserve">
          <source>If you have multiple streams or topics to watch, make a consumers for each, and watch them all simultaneously in the same process by using a MultiConsumer.</source>
          <target state="translated">如果您有多个流或主题要观看,可以为每个流或主题制作一个消费者,并通过使用MultiConsumer在同一过程中同时观看它们。</target>
        </trans-unit>
        <trans-unit id="124d52fb04f2c7f1db15f3ed0feaccbb45b60443" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re using AWS Kinesis instead of Kafka, it will look like this:</source>
          <target state="translated">如果您使用的是AWS Kinesis而不是Kafka，它将看起来像这样：</target>
        </trans-unit>
        <trans-unit id="1a83b2ad6d7db2286ab50ca7a435e58c25172b5b" translate="yes" xml:space="preserve">
          <source>Improve log messages and levels for invalid or unknown messages.</source>
          <target state="translated">改进日志信息和无效或未知信息的级别。</target>
        </trans-unit>
        <trans-unit id="8d977302311c1f20782e75d4f1942383b9f18b74" translate="yes" xml:space="preserve">
          <source>Improved logic for detecting the current AWS region.</source>
          <target state="translated">改进了检测当前AWS区域的逻辑。</target>
        </trans-unit>
        <trans-unit id="9a3a1734e49dbe1a6c8b63692409a3b98786a172" translate="yes" xml:space="preserve">
          <source>In KinesisOffset model, track the AWS region for a stream. This allows a single database to subscribe to multiple streams in different regions, even it they have the same name.</source>
          <target state="translated">在KinesisOffset模型中,跟踪一个流的AWS区域。这允许一个数据库订阅不同区域的多个流,即使它们有相同的名称。</target>
        </trans-unit>
        <trans-unit id="970d9459b2c3bd1aab215bea63f715a31dc6bf75" translate="yes" xml:space="preserve">
          <source>Initial release.</source>
          <target state="translated">初次发布。</target>
        </trans-unit>
        <trans-unit id="fd6c3ebf7befca9f8208f86c76e4d4180303745c" translate="yes" xml:space="preserve">
          <source>Install</source>
          <target state="translated">安装</target>
        </trans-unit>
        <trans-unit id="c81b79df3c6448eae7c4f80428b54cd5692a17d7" translate="yes" xml:space="preserve">
          <source>Installation</source>
          <target state="translated">安装</target>
        </trans-unit>
        <trans-unit id="3b755f7b857b999860755840e5f0964f6b120c4d" translate="yes" xml:space="preserve">
          <source>Internationalization</source>
          <target state="translated">国际化</target>
        </trans-unit>
        <trans-unit id="0e921845ded85f4ca71612e4983252e0fd2d93a9" translate="yes" xml:space="preserve">
          <source>KEY_FIELD</source>
          <target state="translated">KEY_FIELD</target>
        </trans-unit>
        <trans-unit id="9adf8aa78ce63d42002629004f9d8c5d6e3a24c6" translate="yes" xml:space="preserve">
          <source>MESSAGE_TYPE</source>
          <target state="translated">MESSAGE_TYPE</target>
        </trans-unit>
        <trans-unit id="4276e29a02fd8f6945c318a424eea128da500f12" translate="yes" xml:space="preserve">
          <source>More robustly handle exceptions thrown by a consumer serializer&amp;rsquo;s</source>
          <target state="translated">更健壮地处理使用者序列化程序引发的异常</target>
        </trans-unit>
        <trans-unit id="1b6da58d60c7bcb0b62a3c84017df86a6a8a4e4e" translate="yes" xml:space="preserve">
          <source>Move data around between Python services using Kafka and/or AWS Kinesis and Django Rest Framework serializers.</source>
          <target state="translated">使用Kafka和/或AWS Kinesis和Django Rest Framework序列化器在Python服务之间移动数据。</target>
        </trans-unit>
        <trans-unit id="9b1fcbda693f085c4d6d33acbf333e420ba23fca" translate="yes" xml:space="preserve">
          <source>No changes.</source>
          <target state="translated">没有变化。</target>
        </trans-unit>
        <trans-unit id="6eef6648406c333a4035cd5e60d0bf2ecf2606d7" translate="yes" xml:space="preserve">
          <source>None</source>
          <target state="translated">なし</target>
        </trans-unit>
        <trans-unit id="b05bfe270cc8d7c863fcaef41cec57b4a874688f" translate="yes" xml:space="preserve">
          <source>Once a serializer exists, you can send a message to Kafka by creating Producer object and calling the</source>
          <target state="translated">一旦序列化器存在,你可以通过创建Producer对象并调用</target>
        </trans-unit>
        <trans-unit id="8c41ae88467fe5bbad09fcd488662b25c3ec5333" translate="yes" xml:space="preserve">
          <source>Person</source>
          <target state="translated">人物</target>
        </trans-unit>
        <trans-unit id="2d4de422295bafb2c7667583c219074d358b9914" translate="yes" xml:space="preserve">
          <source>PersonSerializerV1</source>
          <target state="translated">PersonSerializerV1</target>
        </trans-unit>
        <trans-unit id="4afc4c099bd08e0d44d6982b97152facf84d0c8d" translate="yes" xml:space="preserve">
          <source>Receiving Messages</source>
          <target state="translated">接收信息</target>
        </trans-unit>
        <trans-unit id="8611e40d1056868462071ad966dca76f00201f08" translate="yes" xml:space="preserve">
          <source>Run migrations. This will create the model used to store Kafka log position offsets.:</source>
          <target state="translated">运行迁移。这将创建用于存储Kafka日志位置偏移的模型。</target>
        </trans-unit>
        <trans-unit id="6fa3703a1bdf2d255844c1967f71f224913cffac" translate="yes" xml:space="preserve">
          <source>Schema changes are handled using the</source>
          <target state="translated">模式的变化是用</target>
        </trans-unit>
        <trans-unit id="f0662ea4ce2ba05b7f07ad1199c4b10caa58025d" translate="yes" xml:space="preserve">
          <source>Sending Messages</source>
          <target state="translated">发送消息</target>
        </trans-unit>
        <trans-unit id="71796031218483adb9338df6ac1fe8ad1217e178" translate="yes" xml:space="preserve">
          <source>Serializers</source>
          <target state="translated">序列器</target>
        </trans-unit>
        <trans-unit id="845c23acd2d57e4a45e5f9d2ddd30f9cfc985ce9" translate="yes" xml:space="preserve">
          <source>The above sample code would result in the following message being sent to the Kafka topic named</source>
          <target state="translated">上面的示例代码将导致以下消息被发送到Kafka主题,名为</target>
        </trans-unit>
        <trans-unit id="ffa25f9133ff3c7db5f21fa0df07b10a5586ea06" translate="yes" xml:space="preserve">
          <source>The consumer object uses Django REST Framework&amp;rsquo;s built-in</source>
          <target state="translated">使用者对象使用Django REST Framework的内置</target>
        </trans-unit>
        <trans-unit id="1d106a3b7b84e0ca3d5e70cafd0526170152e47c" translate="yes" xml:space="preserve">
          <source>The consumers will now use the appropriate serializer for the message version. Second, we need to update producer code to being using schema version 2.:</source>
          <target state="translated">消费者现在将使用适当的序列器来处理消息版本。其次,我们需要更新生产者代码,使其使用模式版本2。</target>
        </trans-unit>
        <trans-unit id="b47903da5844aaf66338046865341227ddf794af" translate="yes" xml:space="preserve">
          <source>The first step in either sending or receiving messages with</source>
          <target state="translated">收发信息的第一步,无论是发送还是接收信息,都要用</target>
        </trans-unit>
        <trans-unit id="c22aa8ea3bbd87b3fdb24798299beac0d377babf" translate="yes" xml:space="preserve">
          <source>This library serves as a universal pipe for moving data around between Django applications and services. It is build on
top of &lt;a href=&quot;https://boto3.readthedocs.io/en/latest/&quot;&gt;Boto3&lt;/a&gt;, &lt;a href=&quot;https://kafka.apache.org/&quot;&gt;Apache Kafka&lt;/a&gt;, &lt;a href=&quot;https://github.com/dpkp/kafka-python&quot;&gt;kafka-python&lt;/a&gt;, and &lt;a href=&quot;http://www.django-rest-framework.org/&quot;&gt;Django REST Framework&lt;/a&gt;.</source>
          <target state="translated">该库用作在Django应用程序和服务之间移动数据的通用管道。它基于&lt;a href=&quot;https://boto3.readthedocs.io/en/latest/&quot;&gt;Boto3&lt;/a&gt;，&lt;a href=&quot;https://kafka.apache.org/&quot;&gt;Apache Kafka&lt;/a&gt;，&lt;a href=&quot;https://github.com/dpkp/kafka-python&quot;&gt;kafka-python&lt;/a&gt;和&lt;a href=&quot;http://www.django-rest-framework.org/&quot;&gt;Django REST Framework&lt;/a&gt;构建。</target>
        </trans-unit>
        <trans-unit id="bee3d83cc56cf9bb415862ee5d7d2fa680b12552" translate="yes" xml:space="preserve">
          <source>To perform a backwards-incompatible schema change, the following steps should be performed.</source>
          <target state="translated">要执行向后不兼容的模式变更,应执行以下步骤。</target>
        </trans-unit>
        <trans-unit id="44a75fd9ae981e96331b4fd634c35934f291b0eb" translate="yes" xml:space="preserve">
          <source>To processing incoming messages, we can reuse the same model and serializer. We just need to instantiate a Consumer object.</source>
          <target state="translated">为了处理传入的消息,我们可以重复使用相同的模型和序列器。我们只需要实例化一个Consumer对象。</target>
        </trans-unit>
        <trans-unit id="760d77319d33dd98f7de4a21a9beebd585f4f1bb" translate="yes" xml:space="preserve">
          <source>Update consumer code to have knowledge of the new schema version.</source>
          <target state="translated">更新消费者代码,了解新的模式版本。</target>
        </trans-unit>
        <trans-unit id="e9d9bf0c4f187aed5459d99826260d2d90fbd55e" translate="yes" xml:space="preserve">
          <source>Update producer code to being sending the new schema version.</source>
          <target state="translated">更新生产者代码,发送新的模式版本。</target>
        </trans-unit>
        <trans-unit id="0bb18642b70b9f8a9c12ccf39487328f306b8e19" translate="yes" xml:space="preserve">
          <source>Usage</source>
          <target state="translated">使用方法</target>
        </trans-unit>
        <trans-unit id="340d33e2025ffe706ac456af47f78712a84bc2c1" translate="yes" xml:space="preserve">
          <source>Use the</source>
          <target state="translated">使用</target>
        </trans-unit>
        <trans-unit id="b33892fbddeffc3368077b4904ad0b3d562a7312" translate="yes" xml:space="preserve">
          <source>VERSION</source>
          <target state="translated">版本</target>
        </trans-unit>
        <trans-unit id="05d85e7d0002fe23af087c94dcb76e1cd32d04dc" translate="yes" xml:space="preserve">
          <source>You can also support multiple incompatible version of message types by defining a serializer for each message type version and registering them all with the consumer.</source>
          <target state="translated">您还可以通过为每个消息类型版本定义一个序列器,并将它们全部注册到消费者那里,来支持多个不兼容的消息类型版本。</target>
        </trans-unit>
        <trans-unit id="ff69380b6a64172adf8d15c916fbc2984553e8b2" translate="yes" xml:space="preserve">
          <source>argument during initialization. If no object exists yet (the message is representing a new object), it should return</source>
          <target state="translated">参数。如果对象还不存在(消息代表一个新的对象),它应该回到</target>
        </trans-unit>
        <trans-unit id="93d4e6db7d8ed0b59ae019e317a84d1c04c7b2e9" translate="yes" xml:space="preserve">
          <source>attribute defined on the class, representing the name of the field to use as the message key. The message key is used by Kafka when performing log compaction and by Kinesis as the shard partition key. The property can be omitted for topics which do not require a key.
4. If the serializer will be used for incoming-messages, it should implement class method</source>
          <target state="translated">属性,表示要用作消息密钥的字段名称。消息密钥被 Kafka 在执行日志压缩时使用,被 Kinesis 用作碎片分区密钥。对于不需要密钥的主题,可以省略该属性。4.如果序列器将用于传入消息,它应该实现类方法</target>
        </trans-unit>
        <trans-unit id="bd9eb1ec81cf0e354af01d5b454d18b18ba35af5" translate="yes" xml:space="preserve">
          <source>attribute defined on the class. The value should be a monotonic integer representing the schema version number.
3. Must have a</source>
          <target state="translated">属性定义在类上。该值应该是代表模式版本号的单调整数。3.必须有一个</target>
        </trans-unit>
        <trans-unit id="9af0277498ccdb7d81bd3aca08dc767cb572f99e" translate="yes" xml:space="preserve">
          <source>attribute defined on the class. The value should be a string that defines uniquely defines the data-type within it&amp;rsquo;s Topic / Stream.
2. Must have a</source>
          <target state="translated">在类上定义的属性。该值应该是一个字符串，该字符串定义唯一定义其&amp;ldquo;主题/流&amp;rdquo;中的数据类型。2.必须有一个</target>
        </trans-unit>
        <trans-unit id="c76b77da8f80ae0f36ca4375d587a4d6e9b07cc4" translate="yes" xml:space="preserve">
          <source>attribute required on every serializer class. When sending, a producer includes the schema version number in the message data. Then, when a consumer receives a message, it looks for a register serializer with a matching version number. If no serializer is found with a matching version number, a</source>
          <target state="translated">属性,每个序列化器类都需要。当发送时,生产者在消息数据中包含模式版本号。然后,当消费者收到消息时,它会寻找具有匹配版本号的寄存器序列化器。如果没有找到与版本号匹配的序列化器,则会出现一个</target>
        </trans-unit>
        <trans-unit id="a383ee670aa695f58764b603c943107f5067c7b4" translate="yes" xml:space="preserve">
          <source>class can be removed form the code base.</source>
          <target state="translated">类可以从代码库中删除。</target>
        </trans-unit>
        <trans-unit id="a2671e5741b7108b36c72c01251577ade8fb8620" translate="yes" xml:space="preserve">
          <source>class method and override the</source>
          <target state="translated">类方法,并覆盖</target>
        </trans-unit>
        <trans-unit id="607607967c83fde63c7ac6218e62c8d8d8d9f82a" translate="yes" xml:space="preserve">
          <source>command to process messages for all consumers automatically in a round-robin fashion.</source>
          <target state="translated">命令以循环方式自动处理所有消费者的信息。</target>
        </trans-unit>
        <trans-unit id="9b7c68a918b17eb053809b198d7c9abfc142f30a" translate="yes" xml:space="preserve">
          <source>create</source>
          <target state="translated">创造</target>
        </trans-unit>
        <trans-unit id="0429b9e83b66b59909c053bc5a0efcfb4118df17" translate="yes" xml:space="preserve">
          <source>decorator to register as many consumers and topics as you need to work with. Then, run the</source>
          <target state="translated">装饰器来注册您所需要的消费者和主题。然后,运行</target>
        </trans-unit>
        <trans-unit id="6db6d22f2341a724787c19661f9a03b8af917dee" translate="yes" xml:space="preserve">
          <source>django-logpipe</source>
          <target state="translated">django-logpipe</target>
        </trans-unit>
        <trans-unit id="eb5ea3e550c8a238d1064ce1bd153ab0bb463cef" translate="yes" xml:space="preserve">
          <source>exception is raised.</source>
          <target state="translated">异常被提出。</target>
        </trans-unit>
        <trans-unit id="8180f2a38646a5bd778ded7f5d80b0b2cc557fdc" translate="yes" xml:space="preserve">
          <source>file. If you&amp;rsquo;re using Kafka, this will look like this:</source>
          <target state="translated">文件。如果您使用的是Kafka，则如下所示：</target>
        </trans-unit>
        <trans-unit id="e0146d3c2aaac8ec8c30d770f1f5ae31a3830b61" translate="yes" xml:space="preserve">
          <source>from pip.</source>
          <target state="translated">从pip。</target>
        </trans-unit>
        <trans-unit id="2eb0d5936952bd20410363efc11f7ffc58192e78" translate="yes" xml:space="preserve">
          <source>have a few rules:</source>
          <target state="translated">有一些规则。</target>
        </trans-unit>
        <trans-unit id="c3bec6bcbc9b9f04e60fcb1d9c9c1a37f3e12e93" translate="yes" xml:space="preserve">
          <source>instance</source>
          <target state="translated">实例</target>
        </trans-unit>
        <trans-unit id="971ec26da6739c0841ca2036050b557b38608197" translate="yes" xml:space="preserve">
          <source>is to define a serializer. Serializers for</source>
          <target state="translated">是为了定义一个序列器。序列器的</target>
        </trans-unit>
        <trans-unit id="ec62eb1162567055d7591d12606567ebabf9d45a" translate="yes" xml:space="preserve">
          <source>logpipe</source>
          <target state="translated">木管</target>
        </trans-unit>
        <trans-unit id="68ab13c1ee3eb80843c62c83ad85e5427f1354b1" translate="yes" xml:space="preserve">
          <source>logpipe.Consumer.add_ignored_message_type</source>
          <target state="translated">logpipe.Consumer.add_ignored_message_type.</target>
        </trans-unit>
        <trans-unit id="866bf7a68fd126768389e054ca0333d99f633dd6" translate="yes" xml:space="preserve">
          <source>logpipe.exceptions.UnknownMessageVersionError</source>
          <target state="translated">logpipe.exceptions.UnknownMessageVersionError</target>
        </trans-unit>
        <trans-unit id="487a129194d8bab3388b17cedad6ac2309617628" translate="yes" xml:space="preserve">
          <source>lookup_instance</source>
          <target state="translated">lookup_instance</target>
        </trans-unit>
        <trans-unit id="8f30ae503298b1630ae61f30da1f4f96ec59e5b9" translate="yes" xml:space="preserve">
          <source>lookup_instance(cls, **kwargs)</source>
          <target state="translated">lookup_instance(cls,**kwargs)</target>
        </trans-unit>
        <trans-unit id="b162fbb03dc1aa300376a56456a17652d116706b" translate="yes" xml:space="preserve">
          <source>management command.</source>
          <target state="translated">管理命令。</target>
        </trans-unit>
        <trans-unit id="25b2a8e1649db9eb78d5a6f63c054db6cf1d25f6" translate="yes" xml:space="preserve">
          <source>method to house your custom import logic.</source>
          <target state="translated">方法来存放你的自定义导入逻辑。</target>
        </trans-unit>
        <trans-unit id="946465000bd9e24c032001a54783f3574c94142e" translate="yes" xml:space="preserve">
          <source>method.</source>
          <target state="translated">方法。</target>
        </trans-unit>
        <trans-unit id="f01c78cad73d84091232241f809db9ba41c59d1a" translate="yes" xml:space="preserve">
          <source>methods to apply the message. If your messages aren&amp;rsquo;t tied directly to a Django model, skip defining the</source>
          <target state="translated">应用消息的方法。如果您的消息没有直接绑定到Django模型，请跳过定义</target>
        </trans-unit>
        <trans-unit id="82d0b640d3bbd4f8ec32ced98b5ac12fe7458b06" translate="yes" xml:space="preserve">
          <source>model we defined above, the first step would be to update consumers to know about the new field.:</source>
          <target state="translated">我们上面定义的模型,第一步是更新消费者知道新的领域。</target>
        </trans-unit>
        <trans-unit id="cb018a0b6b8b13ea37b90c6cce35b1f9415e9d9a" translate="yes" xml:space="preserve">
          <source>or a class implementing an interface that mimics</source>
          <target state="translated">或一个实现了模拟</target>
        </trans-unit>
        <trans-unit id="ab3ccc8dba2a0cf7a1ce4d830bb8a6238ff03833" translate="yes" xml:space="preserve">
          <source>people</source>
          <target state="translated">people</target>
        </trans-unit>
        <trans-unit id="7d77ba9fe9d607843ffbaf91b5d5b4a99d0addc6" translate="yes" xml:space="preserve">
          <source>register_consumer</source>
          <target state="translated">注册_消费者</target>
        </trans-unit>
        <trans-unit id="ee3ff40d65945658f82886ab211a89acda8f669d" translate="yes" xml:space="preserve">
          <source>rest_framework.serializers.Serializer</source>
          <target state="translated">rest_framework.serializers.Serializer。</target>
        </trans-unit>
        <trans-unit id="424e9779dcf2f71f85ca2c05122581ed8e4069bb" translate="yes" xml:space="preserve">
          <source>run_kafka_consumer</source>
          <target state="translated">run_kafka_consumer</target>
        </trans-unit>
        <trans-unit id="13a4a11319d31c1b323d5774f44240a9ffc984d0" translate="yes" xml:space="preserve">
          <source>save</source>
          <target state="translated">保存</target>
        </trans-unit>
        <trans-unit id="0a29d9a6c7b1489e391f3b143cd4fbfabd7fadde" translate="yes" xml:space="preserve">
          <source>save()</source>
          <target state="translated">保存()</target>
        </trans-unit>
        <trans-unit id="37ed539c0cef13959abd980bebf30f4922f606e3" translate="yes" xml:space="preserve">
          <source>send</source>
          <target state="translated">发出</target>
        </trans-unit>
        <trans-unit id="888c15d72e41c9f0f1882f4aea4c2d19f1a044eb" translate="yes" xml:space="preserve">
          <source>settings.py</source>
          <target state="translated">设置.py</target>
        </trans-unit>
        <trans-unit id="4efef4bb8b9ed78a7dd6d74fa9828da5c0783a1e" translate="yes" xml:space="preserve">
          <source>to your installed apps.</source>
          <target state="translated">到您安装的应用程序。</target>
        </trans-unit>
        <trans-unit id="0a25ba5991316bdda4a9b3abcee2106016df28a0" translate="yes" xml:space="preserve">
          <source>update</source>
          <target state="translated">更新</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
