<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://pypi.org/project/capturer/">
    <body>
      <group id="capturer">
        <trans-unit id="067d37005e41e9e28425c1041aba52aa775ce3db" translate="yes" xml:space="preserve">
          <source>&amp;copy; 2020 Peter Odding.</source>
          <target state="translated">&amp;copy;2020彼得&amp;middot;奥丁（Peter Odding）。</target>
        </trans-unit>
        <trans-unit id="96a313b29626f9c796fd0c58c93ed79675febfc2" translate="yes" xml:space="preserve">
          <source>A big thanks goes out to the &lt;a href=&quot;https://pypi.org/project/pytest&quot;&gt;pytest&lt;/a&gt; developers because pytest&amp;rsquo;s mechanism for
capturing the output of subprocesses provided inspiration for the</source>
          <target state="translated">非常感谢&lt;a href=&quot;https://pypi.org/project/pytest&quot;&gt;pytest&lt;/a&gt;开发人员，因为pytest的捕获子流程输出的机制为</target>
        </trans-unit>
        <trans-unit id="5067ec6ec3c8bc695f33d7314315ee45d6022ae2" translate="yes" xml:space="preserve">
          <source>All output captured is relayed on the &lt;a href=&quot;https://en.wikipedia.org/wiki/Standard_streams#Standard_error_.28stderr.29&quot;&gt;stderr&lt;/a&gt; stream by default, so capturing
changes the semantics of your programs. How much this matters obviously
depends on your use case. For the use cases that triggered me to create</source>
          <target state="translated">默认情况下，捕获的所有输出都会在&lt;a href=&quot;https://en.wikipedia.org/wiki/Standard_streams#Standard_error_.28stderr.29&quot;&gt;stderr&lt;/a&gt;流上中继，因此捕获会更改程序的语义。这有多重要，显然取决于您的用例。对于触发我创建的用例</target>
        </trans-unit>
        <trans-unit id="8c94fc11e4f1956615d07ca478e8a24defe94515" translate="yes" xml:space="preserve">
          <source>CaptureOutput</source>
          <target state="translated">捕捉输出</target>
        </trans-unit>
        <trans-unit id="0173862a56b8960fa3799085a3af62407f739de2" translate="yes" xml:space="preserve">
          <source>CaptureOutput(merged=False)</source>
          <target state="translated">CaptureOutput(merged=False)</target>
        </trans-unit>
        <trans-unit id="b37456c4530be810dc040f50da72eda09addfb0a" translate="yes" xml:space="preserve">
          <source>Contact</source>
          <target state="translated">联系我们</target>
        </trans-unit>
        <trans-unit id="f26d7814fc08c5accfe0925c334424a0f5185a51" translate="yes" xml:space="preserve">
          <source>Design choices</source>
          <target state="translated">设计选择</target>
        </trans-unit>
        <trans-unit id="ce1ec03c06db3b1cd681378b14d3d8988481cd83" translate="yes" xml:space="preserve">
          <source>Easily capture stdout/stderr of the current process and subprocesses</source>
          <target state="translated">轻松捕获当前进程和子进程的stdout/stderr。</target>
        </trans-unit>
        <trans-unit id="76e7a3a3f9c225fe820ba7e9cff10ea2a73b79a1" translate="yes" xml:space="preserve">
          <source>Getting started</source>
          <target state="translated">开始</target>
        </trans-unit>
        <trans-unit id="6d477e9f192964a9fe4e48582901c3444ead950a" translate="yes" xml:space="preserve">
          <source>I say experimental because this method of capturing can unintentionally
change the order in which captured output is emitted, in order to avoid
interleaving output emitted on the &lt;a href=&quot;https://en.wikipedia.org/wiki/Standard_streams#Standard_output_.28stdout.29&quot;&gt;stdout&lt;/a&gt; and &lt;a href=&quot;https://en.wikipedia.org/wiki/Standard_streams#Standard_error_.28stderr.29&quot;&gt;stderr&lt;/a&gt; streams (which would
most likely result in incomprehensible output). Basically output is relayed
on each stream separately after each line break. This means interactive
prompts that block on reading from standard input without emitting a line
break won&amp;rsquo;t show up (until it&amp;rsquo;s too late ;-).</source>
          <target state="translated">我说是实验性的，因为这种捕获方法可以无意间更改捕获输出的发出顺序，以避免交错在&lt;a href=&quot;https://en.wikipedia.org/wiki/Standard_streams#Standard_output_.28stdout.29&quot;&gt;stdout&lt;/a&gt;和&lt;a href=&quot;https://en.wikipedia.org/wiki/Standard_streams#Standard_error_.28stderr.29&quot;&gt;stderr&lt;/a&gt;流上发出的输出（这很可能导致无法理解的输出）。基本上，每个断行后，输出将分别中继到每个流上。这意味着在没有发出换行符的情况下阻止从标准输入读取的交互式提示将不会显示（直到为时已晚；-)。</target>
        </trans-unit>
        <trans-unit id="c81b79df3c6448eae7c4f80428b54cd5692a17d7" translate="yes" xml:space="preserve">
          <source>Installation</source>
          <target state="translated">安装</target>
        </trans-unit>
        <trans-unit id="47f9a8b6f738de18de4d17340d61c56f28aa624e" translate="yes" xml:space="preserve">
          <source>Intercepts writes to low level file descriptors</source>
          <target state="translated">拦截对低级文件描述符的写入。</target>
        </trans-unit>
        <trans-unit id="62de9052cf06aea7ff2b5663d068e174e3368ec8" translate="yes" xml:space="preserve">
          <source>Libraries like &lt;a href=&quot;https://pypi.org/project/capture&quot;&gt;capture&lt;/a&gt; and &lt;a href=&quot;https://pypi.org/project/iocapture&quot;&gt;iocapture&lt;/a&gt; change Python&amp;rsquo;s &lt;a href=&quot;https://docs.python.org/2/library/sys.html#sys.stdout&quot;&gt;sys.stdout&lt;/a&gt; and
&lt;a href=&quot;https://docs.python.org/2/library/sys.html#sys.stderr&quot;&gt;sys.stderr&lt;/a&gt; file objects to fake file objects (using &lt;a href=&quot;https://docs.python.org/2/library/stringio.html&quot;&gt;StringIO&lt;/a&gt;). This enables
capturing of (most) output written to the &lt;a href=&quot;https://en.wikipedia.org/wiki/Standard_streams#Standard_output_.28stdout.29&quot;&gt;stdout&lt;/a&gt; and &lt;a href=&quot;https://en.wikipedia.org/wiki/Standard_streams#Standard_error_.28stderr.29&quot;&gt;stderr&lt;/a&gt; streams from the
same Python process, however any output from subprocesses is unaffected by the
redirection and not captured.</source>
          <target state="translated">&lt;a href=&quot;https://pypi.org/project/capture&quot;&gt;捕获&lt;/a&gt;和&lt;a href=&quot;https://pypi.org/project/iocapture&quot;&gt;iocapture之&lt;/a&gt;类的库将Python的&lt;a href=&quot;https://docs.python.org/2/library/sys.html#sys.stdout&quot;&gt;sys.stdout&lt;/a&gt;和 &lt;a href=&quot;https://docs.python.org/2/library/sys.html#sys.stderr&quot;&gt;sys.stderr&lt;/a&gt;文件对象更改为伪造的文件对象（使用&lt;a href=&quot;https://docs.python.org/2/library/stringio.html&quot;&gt;StringIO&lt;/a&gt;）。这样就可以捕获来自同一Python进程的（大多数）写入&lt;a href=&quot;https://en.wikipedia.org/wiki/Standard_streams#Standard_output_.28stdout.29&quot;&gt;stdout&lt;/a&gt;和&lt;a href=&quot;https://en.wikipedia.org/wiki/Standard_streams#Standard_error_.28stderr.29&quot;&gt;stderr&lt;/a&gt;流的输出，但是子进程的任何输出都不会受到重定向的影响，也不会被捕获。</target>
        </trans-unit>
        <trans-unit id="3229609e15436ec51bcf00818a69a84dbc58a0c2" translate="yes" xml:space="preserve">
          <source>License</source>
          <target state="translated">许可证</target>
        </trans-unit>
        <trans-unit id="73457a5e828fb3b721e39222bf814b197e899a6a" translate="yes" xml:space="preserve">
          <source>Long running operations can provide the operator with real time feedback by
emitting output on the terminal. This sounds obvious (and it is!) but it is
non-trivial to implement (an understatement :-) when you &lt;em&gt;also&lt;/em&gt; want to
capture the output.</source>
          <target state="translated">长时间运行的操作可以通过在终端上发出输出来为操作员提供实时反馈。这听起来很明显（这是！），但它是不容易实现（轻描淡写:-)当你&lt;em&gt;也&lt;/em&gt;想捕获输出。</target>
        </trans-unit>
        <trans-unit id="5c38227657096bc714717fbafdc49d643ed3e74c" translate="yes" xml:space="preserve">
          <source>Note that the first call to &lt;a href=&quot;https://capturer.readthedocs.io/en/latest/api.html#capturer.CaptureOutput.get_bytes&quot;&gt;get_bytes()&lt;/a&gt;, &lt;a href=&quot;https://capturer.readthedocs.io/en/latest/api.html#capturer.CaptureOutput.get_lines&quot;&gt;get_lines()&lt;/a&gt; or &lt;a href=&quot;https://capturer.readthedocs.io/en/latest/api.html#capturer.CaptureOutput.get_text&quot;&gt;get_text()&lt;/a&gt;
will stop the capturing of output by default. This is intended as a sane
default to prevent partial reads (which can be confusing as hell when you don&amp;rsquo;t
have experience with them). So we could have simply used</source>
          <target state="translated">请注意， 默认情况下，第一次调用&lt;a href=&quot;https://capturer.readthedocs.io/en/latest/api.html#capturer.CaptureOutput.get_bytes&quot;&gt;get_bytes（）&lt;/a&gt;，&lt;a href=&quot;https://capturer.readthedocs.io/en/latest/api.html#capturer.CaptureOutput.get_lines&quot;&gt;get_lines（）&lt;/a&gt;或&lt;a href=&quot;https://capturer.readthedocs.io/en/latest/api.html#capturer.CaptureOutput.get_text&quot;&gt;get_text（）&lt;/a&gt;将停止捕获输出。这旨在作为默认的默认设置，以防止部分读取（当您没有使用它们的经验时，可能会造成混乱）。所以我们可以简单地使用</target>
        </trans-unit>
        <trans-unit id="a42b6f37f68ce916c7654d2325495e2ffc917711" translate="yes" xml:space="preserve">
          <source>Programs like &lt;a href=&quot;https://en.wikipedia.org/wiki/GNU_Privacy_Guard&quot;&gt;gpg&lt;/a&gt; and &lt;a href=&quot;https://en.wikipedia.org/wiki/Secure_Shell&quot;&gt;ssh&lt;/a&gt; that use interactive password prompts will render
their password prompt on the terminal in real time. This avoids the awkward
interaction where a password prompt is silenced but the program still hangs,
waiting for input on &lt;a href=&quot;https://en.wikipedia.org/wiki/Standard_streams#Standard_input_.28stdin.29&quot;&gt;stdin&lt;/a&gt;.</source>
          <target state="translated">使用交互式密码提示的&lt;a href=&quot;https://en.wikipedia.org/wiki/GNU_Privacy_Guard&quot;&gt;gpg&lt;/a&gt;和&lt;a href=&quot;https://en.wikipedia.org/wiki/Secure_Shell&quot;&gt;ssh&lt;/a&gt;等程序将在终端上实时呈现其密码提示。这避免了笨拙的交互，在这种交互中，密码提示被静音，但是程序仍然挂起，等待在&lt;a href=&quot;https://en.wikipedia.org/wiki/Standard_streams#Standard_input_.28stdin.29&quot;&gt;stdin&lt;/a&gt;上的输入。</target>
        </trans-unit>
        <trans-unit id="d606f457b941c69624384d635c6373c9af90939d" translate="yes" xml:space="preserve">
          <source>Relays output to the terminal in real time</source>
          <target state="translated">继电器实时输出到终端</target>
        </trans-unit>
        <trans-unit id="bae7d5be70820ed56467bd9a63744e23b47bd711" translate="yes" xml:space="preserve">
          <source>Status</source>
          <target state="translated">状况</target>
        </trans-unit>
        <trans-unit id="93ef0dd827103681fcee453b78be2ff14e1a261d" translate="yes" xml:space="preserve">
          <source>The</source>
          <target state="translated">The</target>
        </trans-unit>
        <trans-unit id="0091e40260b7b58d6e652641475f696d15bcd706" translate="yes" xml:space="preserve">
          <source>The capturer package makes it easy to capture the &lt;a href=&quot;https://en.wikipedia.org/wiki/Standard_streams#Standard_output_.28stdout.29&quot;&gt;stdout&lt;/a&gt; and &lt;a href=&quot;https://en.wikipedia.org/wiki/Standard_streams#Standard_error_.28stderr.29&quot;&gt;stderr&lt;/a&gt; streams
of the current process &lt;em&gt;and subprocesses&lt;/em&gt;. Output can be relayed to the
terminal in real time but is also available to the Python program for
additional processing. It&amp;rsquo;s currently tested on cPython 2.7, 3.5+ and PyPy
(2.7). It&amp;rsquo;s tested on Linux and Mac OS X and may work on other unixes but
definitely won&amp;rsquo;t work on Windows (due to the use of the platform dependent &lt;a href=&quot;https://docs.python.org/2/library/pty.html&quot;&gt;pty&lt;/a&gt;
module). For usage instructions please refer to the &lt;a href=&quot;https://capturer.readthedocs.io&quot;&gt;documentation&lt;/a&gt;.</source>
          <target state="translated">捕获程序包使捕获当前进程&lt;em&gt;和子&lt;/em&gt;进程的&lt;a href=&quot;https://en.wikipedia.org/wiki/Standard_streams#Standard_output_.28stdout.29&quot;&gt;stdout&lt;/a&gt;和&lt;a href=&quot;https://en.wikipedia.org/wiki/Standard_streams#Standard_error_.28stderr.29&quot;&gt;stderr&lt;/a&gt;流变得容易。输出可以实时中继到终端，但也可用于Python程序进行其他处理。目前已在cPython 2.7、3.5+和PyPy（2.7）上进行了测试。它已经在Linux和Mac OS X上进行了测试，并且可以在其他Unix上运行，但是绝对不能在Windows上运行（由于使用了依赖于平台的&lt;a href=&quot;https://docs.python.org/2/library/pty.html&quot;&gt;pty&lt;/a&gt; 模块）。有关使用说明，请参阅&lt;a href=&quot;https://capturer.readthedocs.io&quot;&gt;文档&lt;/a&gt;。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="467730d33ffe3b679f8d21fea344daddf7fca4fb" translate="yes" xml:space="preserve">
          <source>The easiest way to capture output is to use a context manager:</source>
          <target state="translated">捕捉输出的最简单方法是使用上下文管理器。</target>
        </trans-unit>
        <trans-unit id="4e651dc5449474dd97ef6c540edb40ca90313c55" translate="yes" xml:space="preserve">
          <source>The latest version of</source>
          <target state="translated">最新版本的</target>
        </trans-unit>
        <trans-unit id="b909d18007f17d144eb5a6414f16718e1b9f9936" translate="yes" xml:space="preserve">
          <source>The main use case of</source>
          <target state="translated">的主要使用情况</target>
        </trans-unit>
        <trans-unit id="96f334c1550fc35ac7537f7405268afe69e0c993" translate="yes" xml:space="preserve">
          <source>The use of &lt;a href=&quot;https://docs.python.org/2/library/pty.html#pty.openpty&quot;&gt;pty.openpty()&lt;/a&gt; means you need to be running in a UNIX like
environment for</source>
          <target state="translated">使用&lt;a href=&quot;https://docs.python.org/2/library/pty.html#pty.openpty&quot;&gt;pty.openpty（）&lt;/a&gt;意味着您需要在类似UNIX的环境中运行</target>
        </trans-unit>
        <trans-unit id="29ae03f183f2d9ce11ef204b3e59748bb4ff43f7" translate="yes" xml:space="preserve">
          <source>The use of a context manager (&lt;a href=&quot;https://docs.python.org/2/reference/compound_stmts.html#the-with-statement&quot;&gt;the with statement&lt;/a&gt;) ensures that output
capturing is enabled and disabled at the appropriate time, regardless of
whether exceptions interrupt the normal flow of processing.</source>
          <target state="translated">使用上下文管理器（&lt;a href=&quot;https://docs.python.org/2/reference/compound_stmts.html#the-with-statement&quot;&gt;with语句&lt;/a&gt;）可确保在适当的时间启用和禁用输出捕获，而不管异常是否中断正常的处理流程。</target>
        </trans-unit>
        <trans-unit id="b0b1b7db39c535f73ba96f47cf4c93cde41211e0" translate="yes" xml:space="preserve">
          <source>There are existing solutions out there to capture the &lt;a href=&quot;https://en.wikipedia.org/wiki/Standard_streams#Standard_output_.28stdout.29&quot;&gt;stdout&lt;/a&gt; and &lt;a href=&quot;https://en.wikipedia.org/wiki/Standard_streams#Standard_error_.28stderr.29&quot;&gt;stderr&lt;/a&gt;
streams of (Python) processes. The</source>
          <target state="translated">现有的解决方案可以捕获 （Python）进程的&lt;a href=&quot;https://en.wikipedia.org/wiki/Standard_streams#Standard_output_.28stdout.29&quot;&gt;stdout&lt;/a&gt;和&lt;a href=&quot;https://en.wikipedia.org/wiki/Standard_streams#Standard_error_.28stderr.29&quot;&gt;stderr&lt;/a&gt;流。的</target>
        </trans-unit>
        <trans-unit id="bf16a5a2c76cab9516867262b98d421ead9a3db9" translate="yes" xml:space="preserve">
          <source>There is experimental support for capturing &lt;a href=&quot;https://en.wikipedia.org/wiki/Standard_streams#Standard_output_.28stdout.29&quot;&gt;stdout&lt;/a&gt; and &lt;a href=&quot;https://en.wikipedia.org/wiki/Standard_streams#Standard_error_.28stderr.29&quot;&gt;stderr&lt;/a&gt; separately
and relaying captured output to the appropriate original stream. Basically
you call</source>
          <target state="translated">实验支持分别捕获&lt;a href=&quot;https://en.wikipedia.org/wiki/Standard_streams#Standard_output_.28stdout.29&quot;&gt;stdout&lt;/a&gt;和&lt;a href=&quot;https://en.wikipedia.org/wiki/Standard_streams#Standard_error_.28stderr.29&quot;&gt;stderr&lt;/a&gt;并将捕获的输出中继到适当的原始流。基本上你打电话</target>
        </trans-unit>
        <trans-unit id="413e33ea01e94adb5a7994e3b126429dad6e0aa0" translate="yes" xml:space="preserve">
          <source>There&amp;rsquo;s actually a multitude of ways to install Python packages (e.g. the &lt;a href=&quot;https://www.python.org/dev/peps/pep-0370/&quot;&gt;per
user site-packages directory&lt;/a&gt;, &lt;a href=&quot;http://docs.python-guide.org/en/latest/dev/virtualenvs/&quot;&gt;virtual environments&lt;/a&gt; or just installing
system wide) and I have no intention of getting into that discussion here, so
if this intimidates you then read up on your options before returning to these
instructions ;-).</source>
          <target state="translated">实际上，有很多安装Python软件包的方法（例如，&lt;a href=&quot;https://www.python.org/dev/peps/pep-0370/&quot;&gt;每个用户的site-packages目录&lt;/a&gt;，&lt;a href=&quot;http://docs.python-guide.org/en/latest/dev/virtualenvs/&quot;&gt;虚拟环境&lt;/a&gt;或仅在系统范围内安装），我无意在这里进行讨论，因此，如果这吓到您，请继续阅读本文。返回这些说明之前的选项；-)。</target>
        </trans-unit>
        <trans-unit id="f27a0dc4aa2c3bb4dbe16bb6623bff3027267eb7" translate="yes" xml:space="preserve">
          <source>This software is licensed under the &lt;a href=&quot;http://en.wikipedia.org/wiki/MIT_License&quot;&gt;MIT license&lt;/a&gt;.</source>
          <target state="translated">该软件已获得&lt;a href=&quot;http://en.wikipedia.org/wiki/MIT_License&quot;&gt;MIT许可&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7aa3d371321a712db54ce3177e0c62c338d94f28" translate="yes" xml:space="preserve">
          <source>Uses a pseudo terminal to emulate a real terminal</source>
          <target state="translated">使用一个伪终端来模拟真实的终端。</target>
        </trans-unit>
        <trans-unit id="cffa50a32cb13a240d705317bcec65dd1f31b6ad" translate="yes" xml:space="preserve">
          <source>and</source>
          <target state="translated">そして</target>
        </trans-unit>
        <trans-unit id="ecf5c466c5c9de7de63a537c3e693212e007e15f" translate="yes" xml:space="preserve">
          <source>and then you use the</source>
          <target state="translated">然后你用</target>
        </trans-unit>
        <trans-unit id="cf4966c8256316dfb7378caa6748113487e2e9e0" translate="yes" xml:space="preserve">
          <source>attributes of the</source>
          <target state="translated">的属性</target>
        </trans-unit>
        <trans-unit id="c1364357c4c9bf705a9cee2f161afe63cf37ebc5" translate="yes" xml:space="preserve">
          <source>capturer</source>
          <target state="translated">捕捉器</target>
        </trans-unit>
        <trans-unit id="280f73b29ad44c388ef792f1064b14b963b572db" translate="yes" xml:space="preserve">
          <source>is available on &lt;a href=&quot;https://pypi.org/project/capturer&quot;&gt;PyPI&lt;/a&gt; and &lt;a href=&quot;https://github.com/xolox/python-capturer&quot;&gt;GitHub&lt;/a&gt;. The
documentation is hosted on &lt;a href=&quot;https://capturer.readthedocs.io&quot;&gt;Read the Docs&lt;/a&gt; and includes a &lt;a href=&quot;https://capturer.readthedocs.io/en/latest/changelog.html&quot;&gt;changelog&lt;/a&gt;. For bug
reports please create an issue on &lt;a href=&quot;https://github.com/xolox/python-capturer&quot;&gt;GitHub&lt;/a&gt;. If you have questions, suggestions,
etc. feel free to send me an e-mail at &lt;a href=&quot;mailto:peter%40peterodding.com&quot;&gt;peter@peterodding.com&lt;/a&gt;.</source>
          <target state="translated">在&lt;a href=&quot;https://pypi.org/project/capturer&quot;&gt;PyPI&lt;/a&gt;和&lt;a href=&quot;https://github.com/xolox/python-capturer&quot;&gt;GitHub上可用&lt;/a&gt;。该文档位于&amp;ldquo; &lt;a href=&quot;https://capturer.readthedocs.io&quot;&gt;阅读文档&amp;rdquo;上，&lt;/a&gt;并包含一个&lt;a href=&quot;https://capturer.readthedocs.io/en/latest/changelog.html&quot;&gt;changelog&lt;/a&gt;。对于错误报告，请在&lt;a href=&quot;https://github.com/xolox/python-capturer&quot;&gt;GitHub上&lt;/a&gt;创建一个问题。如果您有任何疑问，建议等，请随时给我发送电子邮件至&lt;a href=&quot;mailto:peter%40peterodding.com&quot;&gt;peter@peterodding.com&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="cc328241821ec81a0bd727eb8307ec218e3aca67" translate="yes" xml:space="preserve">
          <source>is to capture all output of a snippet of Python
code (including any output by subprocesses) but also relay the output to the
terminal in real time. This has a couple of useful properties:</source>
          <target state="translated">是为了捕获一段Python代码的所有输出(包括子进程的任何输出),但同时也将输出实时传递到终端。这有几个有用的特性。</target>
        </trans-unit>
        <trans-unit id="8af0779f22f7e46b85797dd52e0b3e50d1509da3" translate="yes" xml:space="preserve">
          <source>it doesn&amp;rsquo;t matter, which explains why this is the default mode.</source>
          <target state="translated">没关系，这说明了为什么这是默认模式。</target>
        </trans-unit>
        <trans-unit id="34fb25f83b43204dad2ad028bbed94e517200a0a" translate="yes" xml:space="preserve">
          <source>keyword argument
that can be used to disable this behavior (please refer to the &lt;a href=&quot;https://capturer.readthedocs.io&quot;&gt;documentation&lt;/a&gt;
for details).</source>
          <target state="translated">可以用于禁用此行为的关键字参数（请参阅&lt;a href=&quot;https://capturer.readthedocs.io&quot;&gt;文档&lt;/a&gt; 以获取详细信息）。</target>
        </trans-unit>
        <trans-unit id="830979b8b59a226d370a424fcaf263da13f1ff3c" translate="yes" xml:space="preserve">
          <source>object to get at the output
captured on each stream.</source>
          <target state="translated">对象来获取每个流的输出。</target>
        </trans-unit>
        <trans-unit id="1bf789c5f353e49a156b15a628b99a02803f754f" translate="yes" xml:space="preserve">
          <source>package instead intercepts writes to low level file descriptors
(similar to and inspired by &lt;a href=&quot;https://pytest.org/latest/capture.html&quot;&gt;how pytest does it&lt;/a&gt;). This enables capturing of
output written to the standard output and error streams from the same Python
process as well as any subprocesses.</source>
          <target state="translated">软件包会截取对低级文件描述符的写入（类似于&lt;a href=&quot;https://pytest.org/latest/capture.html&quot;&gt;pytest的做法&lt;/a&gt;并受其启发）。这样可以捕获来自同一Python进程以及任何子进程的写入标准输出和错误流的输出。</target>
        </trans-unit>
        <trans-unit id="a17fb22aac4e90f542768571c3097ae532fc9bea" translate="yes" xml:space="preserve">
          <source>package is available on &lt;a href=&quot;https://pypi.org/project/capturer&quot;&gt;PyPI&lt;/a&gt; which means installation should be
as simple as:</source>
          <target state="translated">&lt;a href=&quot;https://pypi.org/project/capturer&quot;&gt;PyPI&lt;/a&gt;上有可用的软件包，这意味着安装应尽可能简单：</target>
        </trans-unit>
        <trans-unit id="56dfcefbd3bce0e406f073d7929c42b9ae1edce1" translate="yes" xml:space="preserve">
          <source>package uses a pseudo terminal created using &lt;a href=&quot;https://docs.python.org/2/library/pty.html#pty.openpty&quot;&gt;pty.openpty()&lt;/a&gt; to
capture output. This means subprocesses will use ANSI escape sequences because
they think they&amp;rsquo;re connected to a terminal. In the current implementation you
can&amp;rsquo;t opt out of this, but feel free to submit a feature request to change this
:-). This does have some drawbacks:</source>
          <target state="translated">程序包使用使用&lt;a href=&quot;https://docs.python.org/2/library/pty.html#pty.openpty&quot;&gt;pty.openpty（）&lt;/a&gt;创建的伪终端来捕获输出。这意味着子进程将使用ANSI转义序列，因为它们认为它们已连接到终端。在当前的实现中，您不能选择退出此功能，但可以随时提交功能请求以更改此:-)。这确实有一些缺点：</target>
        </trans-unit>
        <trans-unit id="6825c88f8c8676d5e6d8f79c1357352c45ed8741" translate="yes" xml:space="preserve">
          <source>package was created for a very
specific use case that wasn&amp;rsquo;t catered for by existing solutions (that I could
find). This section documents the design choices that guided the development of
the</source>
          <target state="translated">程序包是针对非常特定的用例创建的，而现有解决方案无法满足我的需求（我可以找到）。本节记录了指导开发的设计选择。</target>
        </trans-unit>
        <trans-unit id="599fe20e7281222b71474c879769a9e94f602fea" translate="yes" xml:space="preserve">
          <source>package was developed as a proof of concept over the course of a
weekend, because I was curious to see if it could be done (reliably). After a
weekend of extensive testing it seems to work fairly well so I&amp;rsquo;m publishing the
initial release as version 1.0, however I still consider this a proof of
concept because I don&amp;rsquo;t have extensive &amp;ldquo;production&amp;rdquo; experience using it yet.
Here&amp;rsquo;s hoping it works as well in practice as it did during my testing :-).</source>
          <target state="translated">这个软件包是在一个周末的过程中开发的，目的是为了证明这一点，因为我很好奇能否做到（可靠地）。经过一个周末的广泛测试后，它似乎运行良好，因此我将发布最初的版本1.0版，但是我仍然认为这是一个概念证明，因为我还没有使用它的丰富&amp;ldquo;生产&amp;rdquo;经验。希望它在实践中能像我在测试中一样有效:-)。</target>
        </trans-unit>
        <trans-unit id="af066bfb6456ec7e023df9ba903d7d0a4c65d9d5" translate="yes" xml:space="preserve">
          <source>package. No code was copied, but both projects are MIT licensed anyway, so it&amp;rsquo;s
not like it&amp;rsquo;s very relevant :-).</source>
          <target state="translated">包。没有代码被复制，但是两个项目都获得了麻省理工学院的许可，因此，它并不是很相关：-)。</target>
        </trans-unit>
        <trans-unit id="feac2e72858e6aacadfda0ac55b74ac3719313cb" translate="yes" xml:space="preserve">
          <source>package:</source>
          <target state="translated">包。</target>
        </trans-unit>
        <trans-unit id="cee9d62e6df8cf072e5ddffcd07319f953cac369" translate="yes" xml:space="preserve">
          <source>partial=True</source>
          <target state="translated">部分=Tr</target>
        </trans-unit>
        <trans-unit id="6d0d5876e6710ebb4f309b5af01090cb97381d06" translate="yes" xml:space="preserve">
          <source>print</source>
          <target state="translated">印制</target>
        </trans-unit>
        <trans-unit id="351eb7019c1640acf10c265cc31c377fd68443b5" translate="yes" xml:space="preserve">
          <source>stderr</source>
          <target state="translated">stderr</target>
        </trans-unit>
        <trans-unit id="476d9ec701e2de6a6c37ab5211117a7cb8333a27" translate="yes" xml:space="preserve">
          <source>stdout</source>
          <target state="translated">stdout</target>
        </trans-unit>
        <trans-unit id="abf2af82450fe8a25b8fd52be056c75ed0e169dd" translate="yes" xml:space="preserve">
          <source>to show
the results without causing a recursive &amp;ldquo;captured output is printed and then
captured again&amp;rdquo; loop. There&amp;rsquo;s an optional</source>
          <target state="translated">以显示结果而不会导致递归的&amp;ldquo;捕获的输出先打印然后再次捕获&amp;rdquo;循环。有一个可选的</target>
        </trans-unit>
        <trans-unit id="7c23946dffb55ffa0ee800ecba4e2d38b3a1d5d6" translate="yes" xml:space="preserve">
          <source>to work (Windows definitely isn&amp;rsquo;t supported).</source>
          <target state="translated">正常工作（绝对不支持Windows）。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
