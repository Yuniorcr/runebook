<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://pypi.org/project/labmath/">
    <body>
      <group id="labmath">
        <trans-unit id="caf3ec883a47c1cd0ab34dc47256cfe1cd3e2fe9" translate="yes" xml:space="preserve">
          <source>! #</source>
          <target state="translated">！＃</target>
        </trans-unit>
        <trans-unit id="4f07ec77c6cfa319b977c01bbbdae34d7e544a62" translate="yes" xml:space="preserve">
          <source>&amp;equiv; 0 (mod</source>
          <target state="translated">&amp;equiv;0（修改</target>
        </trans-unit>
        <trans-unit id="048d14889f8490b4d08978e698d471ef807b524b" translate="yes" xml:space="preserve">
          <source>&amp;gt; 0 is a nonsquare, and</source>
          <target state="translated">&amp;gt; 0是一个非平方，并且</target>
        </trans-unit>
        <trans-unit id="f36894891c982490cf1360710c66648e07f52450" translate="yes" xml:space="preserve">
          <source>&amp;gt; 0: We check whether</source>
          <target state="translated">&amp;gt; 0：我们检查是否</target>
        </trans-unit>
        <trans-unit id="2184221da3c9b9bdfcb3ddfd28733b001fde0cf0" translate="yes" xml:space="preserve">
          <source>&amp;gt; 100 or so.  We divide by</source>
          <target state="translated">&amp;gt; 100左右。我们除以</target>
        </trans-unit>
        <trans-unit id="b53afd3ceb21f16bad6f4181621e0ac17d24b8ad" translate="yes" xml:space="preserve">
          <source>&amp;gt; 214 and a fully-factored integer &lt;em&gt;F&lt;/em&gt; such that &lt;em&gt;F&lt;/em&gt; divides</source>
          <target state="translated">&amp;gt; 214和一个全因数&lt;em&gt;F&lt;/em&gt;使得&lt;em&gt;F&lt;/em&gt;除</target>
        </trans-unit>
        <trans-unit id="1d9388e0d7df743210d405bec135e1efbb8ddd8b" translate="yes" xml:space="preserve">
          <source>&amp;lt; 0, then</source>
          <target state="translated">&amp;lt;0，那么</target>
        </trans-unit>
        <trans-unit id="dbd04e1423a5593fff25c479197555fcf77cf3cf" translate="yes" xml:space="preserve">
          <source>&amp;lt; 2, then</source>
          <target state="translated">&amp;lt;2，然后</target>
        </trans-unit>
        <trans-unit id="383f134e05f2a4eb1c9f02511f76241f497dabd8" translate="yes" xml:space="preserve">
          <source>&amp;middot;</source>
          <target state="translated">&amp;middot;</target>
        </trans-unit>
        <trans-unit id="568ce8561958384873f369b3f2e591f5f98c8464" translate="yes" xml:space="preserve">
          <source>&amp;middot; &lt;em&gt;y&lt;/em&gt;&lt;sup&gt;2&lt;/sup&gt; =</source>
          <target state="translated">&amp;middot; &lt;em&gt;y &lt;/em&gt;&lt;sup&gt;2&lt;/sup&gt; =</target>
        </trans-unit>
        <trans-unit id="92e8881f1c8e6b5ca69c5aaaffd617dd1a309927" translate="yes" xml:space="preserve">
          <source>&amp;middot; &lt;em&gt;y&lt;/em&gt;&lt;sup&gt;2&lt;/sup&gt; = 1.</source>
          <target state="translated">&amp;middot; &lt;em&gt;y &lt;/em&gt;&lt;sup&gt;2&lt;/sup&gt; = 1</target>
        </trans-unit>
        <trans-unit id="b741186b74876f84db8c804af59332cc3291fa7a" translate="yes" xml:space="preserve">
          <source>&amp;middot; &lt;em&gt;y&lt;/em&gt;&lt;sup&gt;2&lt;/sup&gt; = 1.  We use some optimizations specific to this case of the Pell equation that makes this more efficient than calling</source>
          <target state="translated">&amp;middot; &lt;em&gt;y &lt;/em&gt;&lt;sup&gt;2&lt;/sup&gt; =1。我们使用一些特定于Pell方程的优化方法，使这种方法比调用更有效。</target>
        </trans-unit>
        <trans-unit id="6e8a6db25e42c8c4df02595ffe6820cdcdea7dd4" translate="yes" xml:space="preserve">
          <source>&amp;middot; &lt;em&gt;y&lt;/em&gt;&lt;sup&gt;2&lt;/sup&gt;.  (0,0) is always a solution.</source>
          <target state="translated">&amp;middot; &lt;em&gt;y &lt;/em&gt;&lt;sup&gt;2&lt;/sup&gt;。（0,0）始终是解决方案。</target>
        </trans-unit>
        <trans-unit id="3ab3dd7d16cfef73fb2e61f28f40699e19c4791c" translate="yes" xml:space="preserve">
          <source>&amp;middot; U&lt;sub&gt;n-1&lt;/sub&gt; -</source>
          <target state="translated">&amp;middot;U &lt;sub&gt;n-1个&lt;/sub&gt;-</target>
        </trans-unit>
        <trans-unit id="4faddae56e1c823ae0a15d49ddaac8d1571a2a83" translate="yes" xml:space="preserve">
          <source>&amp;middot; U&lt;sub&gt;n-2&lt;/sub&gt;</source>
          <target state="translated">&amp;middot;U &lt;sub&gt;n-2&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="f25dc5f49acad9097bb0b21ceb581d1f48e8b7f0" translate="yes" xml:space="preserve">
          <source>&amp;middot; V&lt;sub&gt;n-1&lt;/sub&gt; -</source>
          <target state="translated">&amp;middot;V &lt;sub&gt;n-1个&lt;/sub&gt;-</target>
        </trans-unit>
        <trans-unit id="12a81352f8f9c7c3529728549d88e6a5039a225f" translate="yes" xml:space="preserve">
          <source>&amp;middot; V&lt;sub&gt;n-2&lt;/sub&gt;</source>
          <target state="translated">V &lt;sub&gt;n-2&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="a9cf5bce636d1ecb41a77fa58a411d49d3e6baae" translate="yes" xml:space="preserve">
          <source>&amp;middot; ln(</source>
          <target state="translated">&amp;middot;ln（</target>
        </trans-unit>
        <trans-unit id="2b60ce12ac35015018edd0bc92ebb51fccb069ee" translate="yes" xml:space="preserve">
          <source>&amp;middot; rad(&lt;em&gt;a&lt;/em&gt;&amp;middot;&lt;em&gt;b&lt;/em&gt;&amp;middot;&lt;em&gt;c&lt;/em&gt;)&lt;sup&gt;abc[1]&lt;/sup&gt;.  This enables major speedups.  If</source>
          <target state="translated">&amp;middot;rad（&lt;em&gt;a&lt;/em&gt; &amp;middot; &lt;em&gt;b&lt;/em&gt; &amp;middot; &lt;em&gt;c&lt;/em&gt;）&lt;sup&gt;abc [1]&lt;/sup&gt;。这样可以大大提高速度。如果</target>
        </trans-unit>
        <trans-unit id="44f4acd3eb3f017ce2e28ed30370f216bec96653" translate="yes" xml:space="preserve">
          <source>&amp;middot;&lt;em&gt;x&lt;/em&gt; +</source>
          <target state="translated">&amp;middot; &lt;em&gt;x&lt;/em&gt; +</target>
        </trans-unit>
        <trans-unit id="c01752f0646944d8aa6b495144cb53c0f5348ccd" translate="yes" xml:space="preserve">
          <source>&amp;middot;&lt;em&gt;x&lt;/em&gt;&lt;sup&gt;2&lt;/sup&gt; +</source>
          <target state="translated">&amp;middot; &lt;em&gt;x &lt;/em&gt;&lt;sup&gt;2&lt;/sup&gt; +</target>
        </trans-unit>
        <trans-unit id="ca281ff10e0c51f7e81335cb7834e418b7afaf78" translate="yes" xml:space="preserve">
          <source>&amp;middot;&lt;em&gt;x&lt;/em&gt;&lt;sup&gt;3&lt;/sup&gt; +</source>
          <target state="translated">&amp;middot; &lt;em&gt;x &lt;/em&gt;&lt;sup&gt;3&lt;/sup&gt; +</target>
        </trans-unit>
        <trans-unit id="8367bf1579c7db95d43ab3444547e64d4ef9b6d3" translate="yes" xml:space="preserve">
          <source>&amp;middot;&lt;em&gt;y&lt;/em&gt;.</source>
          <target state="translated">&amp;middot; &lt;em&gt;y&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="e1907af93f06047bdf97a92a5f71da9b89222d6d" translate="yes" xml:space="preserve">
          <source>&amp;ndash; integers</source>
          <target state="translated">&amp;ndash;整数</target>
        </trans-unit>
        <trans-unit id="1d77670759947f3bb0477c2d19524e7decc4e882" translate="yes" xml:space="preserve">
          <source>&amp;ne; 0 &amp;gt;</source>
          <target state="translated">&amp;ne;0&amp;gt;</target>
        </trans-unit>
        <trans-unit id="efe702747f33997abd2ae914a575c5e4ea38522b" translate="yes" xml:space="preserve">
          <source>&amp;ne; 0 &amp;lt;</source>
          <target state="translated">&amp;ne;0 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="4429d48aa01c76d3396541bb843acf24b3f679b6" translate="yes" xml:space="preserve">
          <source>&amp;ne; 0 =</source>
          <target state="translated">&amp;ne;0 =</target>
        </trans-unit>
        <trans-unit id="1f89c3f7c9d08338e52b4411b81a42f5b9417211" translate="yes" xml:space="preserve">
          <source>&amp;ne; 0,</source>
          <target state="translated">&amp;ne;0，</target>
        </trans-unit>
        <trans-unit id="4d98a2b4f97cf7893f04666e243cc03576b4fe1a" translate="yes" xml:space="preserve">
          <source>&amp;rsquo; = -(-</source>
          <target state="translated">'=-（-</target>
        </trans-unit>
        <trans-unit id="626fcca9e3c8cf7d4a69beab2a5d9818401720bc" translate="yes" xml:space="preserve">
          <source>&amp;rsquo; = 0; if</source>
          <target state="translated">'= 0; 如果</target>
        </trans-unit>
        <trans-unit id="2e4a410348c03f30c24b0d525baf8e0197729c24" translate="yes" xml:space="preserve">
          <source>&amp;rsquo; = 1; if -2 &amp;lt;</source>
          <target state="translated">'= 1; 如果-2 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="17f770dc35e50ddb0b9dc0105e08c9c0e3aee5b2" translate="yes" xml:space="preserve">
          <source>&amp;rsquo;s factors, we can instead pass</source>
          <target state="translated">的因素，我们可以通过</target>
        </trans-unit>
        <trans-unit id="03f539b2a22aaaed1db215c2950d3ed1599286f0" translate="yes" xml:space="preserve">
          <source>(1) is neither 1 nor -1, then</source>
          <target state="translated">（1）既不是1也不是-1，则</target>
        </trans-unit>
        <trans-unit id="969c5dfaebc55789601b0b4951fe01e479a5131f" translate="yes" xml:space="preserve">
          <source>(1).  Then we return the unique function</source>
          <target state="translated">（1）。然后我们返回唯一函数</target>
        </trans-unit>
        <trans-unit id="971a2a31fa23a7c33e144ed8640bbf8055d90b8e" translate="yes" xml:space="preserve">
          <source>(None, None)</source>
          <target state="translated">（无，无）</target>
        </trans-unit>
        <trans-unit id="03dbeb1aa707806cbf5f399ce8022ae3ea2e35b4" translate="yes" xml:space="preserve">
          <source>(None, z, None)</source>
          <target state="translated">（无，z，无）</target>
        </trans-unit>
        <trans-unit id="d6d85aff92c379ca9ade6ac4079ecfd78153da15" translate="yes" xml:space="preserve">
          <source>(and therefore</source>
          <target state="translated">（因此</target>
        </trans-unit>
        <trans-unit id="a666a96c08ace45e46f2016bf528aedca5ac2394" translate="yes" xml:space="preserve">
          <source>(default), we don&amp;rsquo;t call the multiprocessing functions.</source>
          <target state="translated">（默认），我们不调用多重处理功能。</target>
        </trans-unit>
        <trans-unit id="d1ed1b74b6bd0c8f32a8d28b2e38be17613669ba" translate="yes" xml:space="preserve">
          <source>(gen, None, None)</source>
          <target state="translated">（gen，None，None）</target>
        </trans-unit>
        <trans-unit id="e459b13269ede555240e9185989705f723c1e0e1" translate="yes" xml:space="preserve">
          <source>(gen, z, f)</source>
          <target state="translated">（gen，z，f）</target>
        </trans-unit>
        <trans-unit id="cbffd77b9d1901c972fb0cd6a9d002d8273280c6" translate="yes" xml:space="preserve">
          <source>(inclusive) can be written as a sum of divisors of</source>
          <target state="translated">（含）可以写为除数的总和</target>
        </trans-unit>
        <trans-unit id="622048af57626501fcc49a2751e0d8523a7e2a35" translate="yes" xml:space="preserve">
          <source>(isqrt(n), [a,b,c,...,d])</source>
          <target state="translated">（isqrt（n），[a，b，c，...，d]）</target>
        </trans-unit>
        <trans-unit id="4840cda77bfaffac296c76b7947c7053174a4ebb" translate="yes" xml:space="preserve">
          <source>(mod</source>
          <target state="translated">（修改</target>
        </trans-unit>
        <trans-unit id="6a228c46af6c061469f59308e5af49db5fc3b04c" translate="yes" xml:space="preserve">
          <source>) = 1.  Also called the reduced totient or least universal exponent.</source>
          <target state="translated">）=1。也称为简化的或最小通用指数。</target>
        </trans-unit>
        <trans-unit id="073d0308b8b9be18296d367b35ec54590b48f865" translate="yes" xml:space="preserve">
          <source>) and</source>
          <target state="translated">）和</target>
        </trans-unit>
        <trans-unit id="ad9c9a8d46d9d802e701a33d2a70e6b5716d0f37" translate="yes" xml:space="preserve">
          <source>) and V(</source>
          <target state="translated">）和V（</target>
        </trans-unit>
        <trans-unit id="ac66979b1454bbfec91b6d7fae0329bfdf1387d9" translate="yes" xml:space="preserve">
          <source>) for all &lt;em&gt;a&lt;/em&gt; such that gcd(&lt;em&gt;a&lt;/em&gt;,</source>
          <target state="translated">）为所有&lt;em&gt;一&lt;/em&gt;，使得满足gcd（&lt;em&gt;一&lt;/em&gt;，</target>
        </trans-unit>
        <trans-unit id="3355ec74401583907d7a9cbeddaf485a48f9374c" translate="yes" xml:space="preserve">
          <source>) with parameters (</source>
          <target state="translated">）和参数（</target>
        </trans-unit>
        <trans-unit id="f68a84d9836c0c97794a4934197fe60fcf86a733" translate="yes" xml:space="preserve">
          <source>)&amp;rsquo;; and (&lt;em&gt;ab&lt;/em&gt;)&amp;rsquo; = &lt;em&gt;a&lt;/em&gt;&amp;rsquo;&amp;middot;&lt;em&gt;b&lt;/em&gt; + &lt;em&gt;b&lt;/em&gt;&amp;rsquo;&amp;middot;&lt;em&gt;a&lt;/em&gt;.</source>
          <target state="translated">）'; 和（&lt;em&gt;ab&lt;/em&gt;）'= &lt;em&gt;a&lt;/em&gt; '&amp;middot; &lt;em&gt;b&lt;/em&gt; + &lt;em&gt;b&lt;/em&gt; '&amp;middot; &lt;em&gt;a&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="d4dc2cee30052c6c649817c9e7a38b638e197cc5" translate="yes" xml:space="preserve">
          <source>)) arithmetic operations.  If</source>
          <target state="translated">））算术运算。如果</target>
        </trans-unit>
        <trans-unit id="75816c562eabe0637a5415a8a87ebd580a17db45" translate="yes" xml:space="preserve">
          <source>)) earlier Fibonaccis along the way.  This is the asymptotically fastest algorithm.</source>
          <target state="translated">））一路走来的斐波那契。这是渐近最快的算法。</target>
        </trans-unit>
        <trans-unit id="028dca72f656c1f9f2c5bf131d16859612ce8fe7" translate="yes" xml:space="preserve">
          <source>)) earlier Fibonaccis along the way.  This is, in the big-O sense, just about as fast as possible.</source>
          <target state="translated">））一路走来的斐波那契。从大O的角度来看，这几乎是最快的。</target>
        </trans-unit>
        <trans-unit id="27489df79360a12fbf20085f661e36a65b7f68e2" translate="yes" xml:space="preserve">
          <source>))) to O(</source>
          <target state="translated">）））到O（</target>
        </trans-unit>
        <trans-unit id="d833daeaaa13660c3317a667dae54810986ad5e9" translate="yes" xml:space="preserve">
          <source>))/&lt;em&gt;Q&lt;/em&gt;&lt;sub&gt;i&lt;/sub&gt; is the &lt;em&gt;i&lt;/em&gt;&lt;sup&gt;th&lt;/sup&gt; complete quotient of &lt;em&gt;x&lt;/em&gt;, and &lt;em&gt;B&lt;/em&gt;&lt;sub&gt;i&lt;/sub&gt; is the denominator of the &lt;em&gt;i&lt;/em&gt;&lt;sup&gt;th&lt;/sup&gt; convergent to &lt;em&gt;x&lt;/em&gt;.  For full details, see &lt;a href=&quot;https://www.jpr2718.org/pell.pdf&quot;&gt;https://www.jpr2718.org/pell.pdf&lt;/a&gt;.</source>
          <target state="translated">））/ &lt;em&gt;Q &lt;/em&gt;&lt;sub&gt;i&lt;/sub&gt;是&lt;em&gt;x的&lt;/em&gt;&lt;sup&gt;第&lt;/sup&gt;&lt;em&gt;i&lt;/em&gt;&lt;sup&gt;个&lt;/sup&gt;完全商，而&lt;em&gt;B &lt;/em&gt;&lt;sub&gt;i&lt;/sub&gt;是第&lt;em&gt;i&lt;/em&gt;&lt;sup&gt;个&lt;/sup&gt;收敛于&lt;em&gt;x&lt;/em&gt;的分母。有关完整的详细信息，请参见&lt;a href=&quot;https://www.jpr2718.org/pell.pdf&quot;&gt;https://www.jpr2718.org/pell.pdf&lt;/a&gt;。&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;sub&gt;&lt;/sub&gt;&lt;em&gt;&lt;/em&gt;&lt;sup&gt;&lt;/sup&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="bd80da636e962ed71e291fca5e49f660ed4144a9" translate="yes" xml:space="preserve">
          <source>), hence the name of this function.</source>
          <target state="translated">），因此该函数的名称。</target>
        </trans-unit>
        <trans-unit id="20b3a9190c2085fbc25ee7fe3d2088f716aee6b8" translate="yes" xml:space="preserve">
          <source>).  Currently just a helper function for</source>
          <target state="translated">）。目前只是一个辅助功能</target>
        </trans-unit>
        <trans-unit id="fc24c2c1660830bca465674c52368b6befa93ead" translate="yes" xml:space="preserve">
          <source>).  More explicitly, if</source>
          <target state="translated">）。更明确地说，如果</target>
        </trans-unit>
        <trans-unit id="3c7f18a5a134f67c307184ef35ec66cfd2abf329" translate="yes" xml:space="preserve">
          <source>).  Not meaningful if</source>
          <target state="translated">）。如果没有意义</target>
        </trans-unit>
        <trans-unit id="d2e1fe1b68c7903c6db94653115ed46c2a4ee271" translate="yes" xml:space="preserve">
          <source>).  Note that this is the generalization of the Jacobi symbol, &lt;em&gt;not&lt;/em&gt; the Dirac-delta analogue.</source>
          <target state="translated">）。请注意，这是Jacobi符号的推广，&lt;em&gt;而不是&lt;/em&gt;Dirac-delta类似物。</target>
        </trans-unit>
        <trans-unit id="7ed0423caf6d9cca721055e02a0f8298586e9324" translate="yes" xml:space="preserve">
          <source>).  This is primarily a helper function for</source>
          <target state="translated">）。这主要是用于</target>
        </trans-unit>
        <trans-unit id="aa879b8892d12724424e723c8b8b7fbd2a5451ee" translate="yes" xml:space="preserve">
          <source>).  We assume that</source>
          <target state="translated">）。我们假设</target>
        </trans-unit>
        <trans-unit id="505171ddfe54c69bfaacb38ce5b92c5d42c81e6b" translate="yes" xml:space="preserve">
          <source>). We yield a sequence of tuples (&lt;em&gt;B&lt;/em&gt;&lt;sub&gt;i&lt;/sub&gt;, &lt;em&gt;G&lt;/em&gt;&lt;sub&gt;i&lt;/sub&gt;, &lt;em&gt;P&lt;/em&gt;&lt;sub&gt;i&lt;/sub&gt;, &lt;em&gt;Q&lt;/em&gt;&lt;sub&gt;i&lt;/sub&gt;) where &lt;em&gt;i&lt;/em&gt; is an index counting up from 0, &lt;em&gt;x&lt;/em&gt; = (</source>
          <target state="translated">）。我们产生一个元组序列（&lt;em&gt;B &lt;/em&gt;&lt;sub&gt;i&lt;/sub&gt;，&lt;em&gt;G &lt;/em&gt;&lt;sub&gt;i&lt;/sub&gt;，&lt;em&gt;P &lt;/em&gt;&lt;sub&gt;i&lt;/sub&gt;，&lt;em&gt;Q &lt;/em&gt;&lt;sub&gt;i&lt;/sub&gt;），其中&lt;em&gt;i&lt;/em&gt;是从0开始计数的索引，&lt;em&gt;x&lt;/em&gt; =（</target>
        </trans-unit>
        <trans-unit id="a66cbcc1eefeec92bf1b2e36bacce5d8d50b0b1e" translate="yes" xml:space="preserve">
          <source>): 1 if</source>
          <target state="translated">）：如果1</target>
        </trans-unit>
        <trans-unit id="3d37083a936c7247b36f337c8fa77689a4dbaae8" translate="yes" xml:space="preserve">
          <source>)&lt;sup&gt;2&lt;/sup&gt; &amp;middot; ln(ln(</source>
          <target state="translated">）&lt;sup&gt;2&lt;/sup&gt; &amp;middot;ln（ln（</target>
        </trans-unit>
        <trans-unit id="f609791b786e22175c6b8ffda42a1b240134ad4f" translate="yes" xml:space="preserve">
          <source>)&lt;sup&gt;2&lt;/sup&gt;) primality tests.  When called with the default primality test, this then uses O(log(</source>
          <target state="translated">）&lt;sup&gt;2&lt;/sup&gt;）素数测试。当使用默认素数测试调用时，该函数将使用O（log（</target>
        </trans-unit>
        <trans-unit id="fa3b1912e9f9c70c9ea40e24d137c2e2b65c834c" translate="yes" xml:space="preserve">
          <source>)&lt;sup&gt;3&lt;/sup&gt;) arithmetic operations, which in turn results in just over O(log(</source>
          <target state="translated">）&lt;sup&gt;3&lt;/sup&gt;）算术运算，其结果恰好超过O（log（</target>
        </trans-unit>
        <trans-unit id="eccfd3ffa4c0210f0545129d88c80138a75afcc9" translate="yes" xml:space="preserve">
          <source>)&lt;sup&gt;4&lt;/sup&gt;) to O(log(</source>
          <target state="translated">）&lt;sup&gt;4&lt;/sup&gt;）至O（log（</target>
        </trans-unit>
        <trans-unit id="d0f96418fdaae58aa868dfa1a04b907e3de4d8e0" translate="yes" xml:space="preserve">
          <source>)&lt;sup&gt;5&lt;/sup&gt;) bit operations, depending on how multiplication is handled.</source>
          <target state="translated">）&lt;sup&gt;5&lt;/sup&gt;）位运算，具体取决于乘法的处理方式。</target>
        </trans-unit>
        <trans-unit id="df58248c414f342c81e056b40bee12d17a08bf61" translate="yes" xml:space="preserve">
          <source>*</source>
          <target state="translated">*</target>
        </trans-unit>
        <trans-unit id="058e6364a206ec75d4ea06b216781091dc0a63b4" translate="yes" xml:space="preserve">
          <source>* &amp;hellip; *</source>
          <target state="translated">*&amp;hellip;*</target>
        </trans-unit>
        <trans-unit id="a979ef10cc6f6a36df6b8a323307ee3bb2e2db9c" translate="yes" xml:space="preserve">
          <source>+</source>
          <target state="translated">+</target>
        </trans-unit>
        <trans-unit id="6bb6d24650ce6af4e00193710ccebde9f999bbd9" translate="yes" xml:space="preserve">
          <source>+ - * / // % **</source>
          <target state="translated">+-* / //％**</target>
        </trans-unit>
        <trans-unit id="88be9dbf8c68b4e83cdc908fac5b35306ecb2688" translate="yes" xml:space="preserve">
          <source>+&amp;radic;</source>
          <target state="translated">+&amp;radic;</target>
        </trans-unit>
        <trans-unit id="395e5e0dc693868d0fd611f9b4a861a3cf345095" translate="yes" xml:space="preserve">
          <source>+1 and &lt;em&gt;F&lt;/em&gt; &amp;gt;</source>
          <target state="translated">+1和&lt;em&gt;F&lt;/em&gt; &amp;gt;</target>
        </trans-unit>
        <trans-unit id="2b15d7a9a8b829e1bc4ccc67364b19c65fbdf7f0" translate="yes" xml:space="preserve">
          <source>+1 is insufficient, we compute the factorization ourselves.</source>
          <target state="translated">+1不足，我们自己计算因式分解。</target>
        </trans-unit>
        <trans-unit id="a4e0b43c86a3bd970da095c5a06be5a4c227f37e" translate="yes" xml:space="preserve">
          <source>+1)-tuple together with</source>
          <target state="translated">+1）元组与</target>
        </trans-unit>
        <trans-unit id="5c10b5b2cd673a0616d529aa5234b12ee7153808" translate="yes" xml:space="preserve">
          <source>,</source>
          <target state="translated">，</target>
        </trans-unit>
        <trans-unit id="d1a1b525f037dbfee7a76d82c7051a2e5ebb7fa7" translate="yes" xml:space="preserve">
          <source>, -1 if it isn&amp;rsquo;t, and 0 if</source>
          <target state="translated">，如果不是，则为-1，如果不是，则为0</target>
        </trans-unit>
        <trans-unit id="0402a07c81f8c9e99543d7b18293125f7dd682a6" translate="yes" xml:space="preserve">
          <source>, 1).</source>
          <target state="translated">，1）。</target>
        </trans-unit>
        <trans-unit id="adb71383bb0c830dc088a44c3c3b663bf50fa2d8" translate="yes" xml:space="preserve">
          <source>, &lt;em&gt;t&lt;/em&gt;).</source>
          <target state="translated">，&lt;em&gt;t&lt;/em&gt;）。</target>
        </trans-unit>
        <trans-unit id="f77a760d23ae5acd0086318743e4a422f6fa2a4a" translate="yes" xml:space="preserve">
          <source>, &lt;em&gt;x&lt;/em&gt;, &lt;em&gt;y&lt;/em&gt;) such that</source>
          <target state="translated">，&lt;em&gt;x&lt;/em&gt;，&lt;em&gt;y&lt;/em&gt;）这样</target>
        </trans-unit>
        <trans-unit id="8278d2adba7612cf98a492d21a4ac4c78acb1202" translate="yes" xml:space="preserve">
          <source>, and</source>
          <target state="translated">和</target>
        </trans-unit>
        <trans-unit id="a13ee8f7bf09e35795911f99b635ce888958b07e" translate="yes" xml:space="preserve">
          <source>, but this is purely for efficiency: if this import fails, we simply set</source>
          <target state="translated">，但这纯粹是为了提高效率：如果导入失败，我们只需设置</target>
        </trans-unit>
        <trans-unit id="2912e7d258bdbee79fb5448e6fb89a4149277adf" translate="yes" xml:space="preserve">
          <source>, except we compute only one sequence, and we supply the seeds.</source>
          <target state="translated">，除了我们只计算一个序列，然后提供种子。</target>
        </trans-unit>
        <trans-unit id="ef6b7a7bd8309377d5e53d1f069b2ebb0dbddad1" translate="yes" xml:space="preserve">
          <source>, except we only compute one sequence, and we supply the seeds.</source>
          <target state="translated">，除了我们只计算一个序列，然后提供种子。</target>
        </trans-unit>
        <trans-unit id="7253342fe51b33ee007666f1f184ed4fc90d8625" translate="yes" xml:space="preserve">
          <source>, indexed so that</source>
          <target state="translated">，索引到</target>
        </trans-unit>
        <trans-unit id="8d163154d8e6c13b85c5bd9f16c6ce3644b2d6c6" translate="yes" xml:space="preserve">
          <source>, normalized to lie between</source>
          <target state="translated">，归一化为介于</target>
        </trans-unit>
        <trans-unit id="b366d1a229ec84d93ba42e7ecafb33db5b7b9b39" translate="yes" xml:space="preserve">
          <source>, or</source>
          <target state="translated">， 要么</target>
        </trans-unit>
        <trans-unit id="2ae7a3d4fae316f912bf8cd912495d732107d53c" translate="yes" xml:space="preserve">
          <source>, or if</source>
          <target state="translated">， 或者如果</target>
        </trans-unit>
        <trans-unit id="3965b16e7dcabd26afcc58e0dea964d0925db505" translate="yes" xml:space="preserve">
          <source>, or if both input polynomials are</source>
          <target state="translated">，或者两个输入多项式均为</target>
        </trans-unit>
        <trans-unit id="f4899ae60f954a43e356842cf2c73c99b2d7f825" translate="yes" xml:space="preserve">
          <source>, returns 1.</source>
          <target state="translated">，返回1。</target>
        </trans-unit>
        <trans-unit id="a9ae4d785b3d24dcbe10dec9ccaef3a5814950b5" translate="yes" xml:space="preserve">
          <source>, returns the greatest integer &amp;le; the rth root of</source>
          <target state="translated">，返回&amp;le;的第r个根的最大整数</target>
        </trans-unit>
        <trans-unit id="1991cc6b25fa65f3894fd899603280a4c42747ff" translate="yes" xml:space="preserve">
          <source>, returns the least integer &amp;ge; the</source>
          <target state="translated">，返回&amp;ge;的最小整数</target>
        </trans-unit>
        <trans-unit id="bde66d79831e0f6fa51191c837fa9d626744bf59" translate="yes" xml:space="preserve">
          <source>, so instead of feeding those functions the integer forms of</source>
          <target state="translated">，因此与其输入这些函数的整数形式，不如</target>
        </trans-unit>
        <trans-unit id="2af26fac1f5d8b2b60538d2d8175a3f4b44896fb" translate="yes" xml:space="preserve">
          <source>, then these sequences grow exponentially, so the number of bit operations is anywhere from O(</source>
          <target state="translated">，则这些序列呈指数增长，因此位运算的数量从O（</target>
        </trans-unit>
        <trans-unit id="74fa0c39cb9a52c881487f860f08a5619098244b" translate="yes" xml:space="preserve">
          <source>, then we generate all such tuples (regardless of size) that do not contain 1.</source>
          <target state="translated">，则我们生成所有不包含1的元组（无论大小）。</target>
        </trans-unit>
        <trans-unit id="124774d26da0984041338194d3437efbb146ec0f" translate="yes" xml:space="preserve">
          <source>, then we make no such assumptions.</source>
          <target state="translated">，那么我们不做这样的假设。</target>
        </trans-unit>
        <trans-unit id="be4bc766d7f8559c895eeb1a54a33499c8489897" translate="yes" xml:space="preserve">
          <source>, we return</source>
          <target state="translated">， 我们返回</target>
        </trans-unit>
        <trans-unit id="52c9d27db8d3c8f08205e64d67ed3a3b6e564d7d" translate="yes" xml:space="preserve">
          <source>, we return in a tuple all distinct integer roots of</source>
          <target state="translated">，我们在元组中返回的所有不同整数根</target>
        </trans-unit>
        <trans-unit id="38dab4478fad01b1670e174fe4859917716feda1" translate="yes" xml:space="preserve">
          <source>, we return in a tuple all distinct integers &lt;em&gt;x&lt;/em&gt; such that</source>
          <target state="translated">，我们在元组中返回所有不同的整数&lt;em&gt;x&lt;/em&gt;，使得</target>
        </trans-unit>
        <trans-unit id="a8fbd0202d5d59bb16abfc27a4a724fcbb5feb8c" translate="yes" xml:space="preserve">
          <source>, where</source>
          <target state="translated">，在哪里</target>
        </trans-unit>
        <trans-unit id="abd29e8823df564d7094cd5714f55d2ebab1009e" translate="yes" xml:space="preserve">
          <source>, which takes anywhere from O(</source>
          <target state="translated">，从O（</target>
        </trans-unit>
        <trans-unit id="fae39a8b748ac34c7257196625985b5737c585b1" translate="yes" xml:space="preserve">
          <source>, written as their prime factorizations in factorint format.</source>
          <target state="translated">，以factorint格式写为它们的主要分解。</target>
        </trans-unit>
        <trans-unit id="508e0d8dab0b1f90c101e0fa953db8cf0119f473" translate="yes" xml:space="preserve">
          <source>-1 and &lt;em&gt;F&lt;/em&gt; &amp;gt;</source>
          <target state="translated">-1和&lt;em&gt;F&lt;/em&gt; &amp;gt;</target>
        </trans-unit>
        <trans-unit id="c87aef34d25ddf413df074e43b3857fc721b9f9f" translate="yes" xml:space="preserve">
          <source>-1 is insufficient, we compute the factorization ourselves.</source>
          <target state="translated">-1是不足的，我们自己计算因式分解。</target>
        </trans-unit>
        <trans-unit id="934653cf2fbb5aa343b8a17873ada188f63e69ca" translate="yes" xml:space="preserve">
          <source>-gonal number.</source>
          <target state="translated">-多边形数。</target>
        </trans-unit>
        <trans-unit id="4c9d25022f1889df6c191b749db36ada3048576a" translate="yes" xml:space="preserve">
          <source>-gonal number.  Indexing begins with 1 so that</source>
          <target state="translated">-多边形数。索引以1开头，因此</target>
        </trans-unit>
        <trans-unit id="d8cec187abb579e2c29e5aa4980bca32e7aeddcd" translate="yes" xml:space="preserve">
          <source>-smooth numbers, where</source>
          <target state="translated">-平滑数字</target>
        </trans-unit>
        <trans-unit id="51799f4dddb6b8f54821f886704c610286d072d8" translate="yes" xml:space="preserve">
          <source>-smooth; the theorem also gives an effective algorithm for finding them.  We implement Lenstra&amp;rsquo;s improvement to this theorem.</source>
          <target state="translated">-光滑; 该定理还给出了找到它们的有效算法。我们执行Lenstra对这个定理的改进。</target>
        </trans-unit>
        <trans-unit id="9dfb7435225d8e36f17f8e560fb966c793db1b51" translate="yes" xml:space="preserve">
          <source>-tuples of positive integers all &amp;le;</source>
          <target state="translated">-正整数元组全部&amp;le;</target>
        </trans-unit>
        <trans-unit id="03c31cf6bf7021202cec4b807dd5bae4b273d995" translate="yes" xml:space="preserve">
          <source>-tuples of positive integers whose product is</source>
          <target state="translated">-其乘积为的正整数元组</target>
        </trans-unit>
        <trans-unit id="55860883266f69576a27944588d11aeb9af144a7" translate="yes" xml:space="preserve">
          <source>.  Adds two points on a Montgomery curve modulo</source>
          <target state="translated">。在蒙哥马利曲线模上相加两个点</target>
        </trans-unit>
        <trans-unit id="bedbd2cb0d726992a984f6022cb30b49b09c1367" translate="yes" xml:space="preserve">
          <source>.  All elements of</source>
          <target state="translated">。的所有元素</target>
        </trans-unit>
        <trans-unit id="630822fc11b0b2f1ecc676caf2a8e615584e3581" translate="yes" xml:space="preserve">
          <source>.  Coded after algorithm 2.2.1 from &lt;em&gt;Prime Numbers: A Computational Perspective&lt;/em&gt; by Crandall &amp;amp; Pomerance (2&lt;sup&gt;nd&lt;/sup&gt; edition).</source>
          <target state="translated">。根据&lt;em&gt;《素数：&lt;/em&gt;算法&lt;em&gt;视角》的&lt;/em&gt;算法2.2.1进行编码，由Crandall＆Pomerance撰写（&lt;sup&gt;第二&lt;/sup&gt;版）。</target>
        </trans-unit>
        <trans-unit id="b89d3c4183e2ee6ab2d3f880397ed31ad5fc9bd0" translate="yes" xml:space="preserve">
          <source>.  Does not yield anything &amp;gt;</source>
          <target state="translated">。不产生任何东西&amp;gt;</target>
        </trans-unit>
        <trans-unit id="5794214f71393c850a4e6757e629c4faabd9bd28" translate="yes" xml:space="preserve">
          <source>.  Doubles a point on a Montgomery curve modulo</source>
          <target state="translated">。将蒙哥马利曲线模上的点加倍</target>
        </trans-unit>
        <trans-unit id="3b4687835edd8bbc72934f002d56164eb354f1c8" translate="yes" xml:space="preserve">
          <source>.  For best performance,</source>
          <target state="translated">。为了获得最佳性能，</target>
        </trans-unit>
        <trans-unit id="eeca317bcf54a2fa2495313e90c0253b6765a885" translate="yes" xml:space="preserve">
          <source>.  For negative</source>
          <target state="translated">。对于负面</target>
        </trans-unit>
        <trans-unit id="f863c23a93501fd973cdcb1d746f38bd8aa20cad" translate="yes" xml:space="preserve">
          <source>.  If</source>
          <target state="translated">。如果</target>
        </trans-unit>
        <trans-unit id="62336538159533d8f2b7825c9e1614a8e84a8d21" translate="yes" xml:space="preserve">
          <source>.  If any of these conditions is false, then the return value is meaningless.</source>
          <target state="translated">。如果这些条件中的任何一个为假，则返回值是没有意义的。</target>
        </trans-unit>
        <trans-unit id="3aa2fef03cc99f2c6a29981a54b6ca0fd43a4b2f" translate="yes" xml:space="preserve">
          <source>.  Includes 0/1 and 1/1.</source>
          <target state="translated">。包括0/1和1/1。</target>
        </trans-unit>
        <trans-unit id="6c15dcaa1f706697e53ac180225305ff0bf45eb2" translate="yes" xml:space="preserve">
          <source>.  Let</source>
          <target state="translated">。让</target>
        </trans-unit>
        <trans-unit id="ec0dddd61a70dd84062d17fad04519fba3eb76f7" translate="yes" xml:space="preserve">
          <source>.  Mathematically, functions &lt;em&gt;f&lt;/em&gt; such that &lt;em&gt;f&lt;/em&gt;(1) = 0 have no Dirichlet inverses due to a division by zero.  This is reflected in this implementation by raising a</source>
          <target state="translated">。在数学上，由于除以零，使得&lt;em&gt;f&lt;/em&gt;（1）= 0的函数&lt;em&gt;f&lt;/em&gt;没有Dirichlet逆。在此实施中，通过提高&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a2df60a11b363555ab8ab834ad45360aa791f070" translate="yes" xml:space="preserve">
          <source>.  More precisely, let</source>
          <target state="translated">。更确切地说，让</target>
        </trans-unit>
        <trans-unit id="69e208881411e7de93486694f776e8e75beea160" translate="yes" xml:space="preserve">
          <source>.  Multiplies a point on Montgomery curve by an integer modulo</source>
          <target state="translated">。将蒙哥马利曲线上的点乘以整数模</target>
        </trans-unit>
        <trans-unit id="24ff29b13afd939997c9d19c2291962b64252ac1" translate="yes" xml:space="preserve">
          <source>.  Multiplies along a Lucas sequence modulo</source>
          <target state="translated">。沿卢卡斯序列模相乘</target>
        </trans-unit>
        <trans-unit id="2eb0162a649d218e0a6cf19d0278bda7b26c9015" translate="yes" xml:space="preserve">
          <source>.  Note that this function is not equivalent to calling</source>
          <target state="translated">。请注意，此功能不等同于调用</target>
        </trans-unit>
        <trans-unit id="70e6e03586456dd55a266bb8d7fc4d3529dec32e" translate="yes" xml:space="preserve">
          <source>.  Polynomials are written as lists of integers with the constant terms first.  If the high-degree coefficients are zero, those terms will be deleted from the answer so that the highest-degree term is nonzero.  We assume that the inputs also satisfy this property.  The zero polynomial is represented by the empty list.  If one of the input polynomials is</source>
          <target state="translated">。多项式被写为先有常数项的整数列表。如果高次项系数为零，则将从答案中删除这些项，以便使最高次项项为非零。我们假设输入也满足此属性。零多项式由空列表表示。如果输入多项式之一是</target>
        </trans-unit>
        <trans-unit id="7891891653fc6cce3496396ec615e07822222198" translate="yes" xml:space="preserve">
          <source>.  Returns a modular inverse normalized to minimize absolute value.</source>
          <target state="translated">。返回标准化逆以最小化绝对值。</target>
        </trans-unit>
        <trans-unit id="df53b7ffad8e7c9ffc76f6c2e3ff912b135a6d75" translate="yes" xml:space="preserve">
          <source>.  Returns a possibly-trivial divisor of</source>
          <target state="translated">。返回一个可能平凡的除数</target>
        </trans-unit>
        <trans-unit id="5db5695825b9f5041cedecad58afc157086c9824" translate="yes" xml:space="preserve">
          <source>.  Stops after yielding 1.</source>
          <target state="translated">。屈服后停止1。</target>
        </trans-unit>
        <trans-unit id="17ee1ebfb679c24d9865beefd1b230698dbc71f5" translate="yes" xml:space="preserve">
          <source>.  The answer is not guaranteed to exist.  In such cases, we return</source>
          <target state="translated">。答案不能保证存在。在这种情况下，我们返回</target>
        </trans-unit>
        <trans-unit id="c97013ebd3dd56cef9ec19b305fef47446fc694c" translate="yes" xml:space="preserve">
          <source>.  The argument</source>
          <target state="translated">。争论</target>
        </trans-unit>
        <trans-unit id="3984dbf3fc01a765843114a64197bc76090c91a6" translate="yes" xml:space="preserve">
          <source>.  The coefficients are interpreted mod</source>
          <target state="translated">。系数解释为mod</target>
        </trans-unit>
        <trans-unit id="e364d93738c49ae8d217216d6b8aa47157e3d801" translate="yes" xml:space="preserve">
          <source>.  The number of solutions will be finite.</source>
          <target state="translated">。解决方案的数量将是有限的。</target>
        </trans-unit>
        <trans-unit id="fa76e6d3265c6c843ae2903190d7f8d8cbd34b46" translate="yes" xml:space="preserve">
          <source>.  The output is not necessarily sorted.</source>
          <target state="translated">。输出不一定要排序。</target>
        </trans-unit>
        <trans-unit id="dc298eb5fce15e6a268b2efb1ab91a3189688f64" translate="yes" xml:space="preserve">
          <source>.  The result is not guaranteed to exist; in such cases we return</source>
          <target state="translated">。结果不保证存在。在这种情况下，我们返回</target>
        </trans-unit>
        <trans-unit id="92094b4180603ce1a85d50ea9bd933a525697ff4" translate="yes" xml:space="preserve">
          <source>.  The result is not guaranteed to exist; in such cases, we return</source>
          <target state="translated">。结果不保证存在。在这种情况下，我们返回</target>
        </trans-unit>
        <trans-unit id="81f5c77a504be64ba4223184977c7f81505e3e33" translate="yes" xml:space="preserve">
          <source>.  The terms of this sequence usually grow exponentially, so computing a distant term incrementally by plucking it out of this generator takes O(</source>
          <target state="translated">。此序列的项通常呈指数增长，因此通过将远项从该生成器中拔出来逐步计算远项，则O（</target>
        </trans-unit>
        <trans-unit id="c10decf0963370caa2df4eddad2f2022d7d4cc37" translate="yes" xml:space="preserve">
          <source>.  These are all in the Python standard library.</source>
          <target state="translated">。这些都在Python标准库中。</target>
        </trans-unit>
        <trans-unit id="9fd1b8413cae2d8a7cf8b859c3afd081cf7c8fd4" translate="yes" xml:space="preserve">
          <source>.  These are also called panarithmic numbers.</source>
          <target state="translated">。这些也称为泛数。</target>
        </trans-unit>
        <trans-unit id="dbf9aec04ff31bff84995f4a6905d41ce7fb01ab" translate="yes" xml:space="preserve">
          <source>.  They are the factorial and primorial, respectively.  There are three aliases:</source>
          <target state="translated">。它们分别是阶乘和原始。共有三个别名：</target>
        </trans-unit>
        <trans-unit id="4994d7eecfdcc83c94f0846956e2114430d8e8f1" translate="yes" xml:space="preserve">
          <source>.  This is primarily a helper function for</source>
          <target state="translated">。这主要是用于</target>
        </trans-unit>
        <trans-unit id="63fb949fc2e1a20504d5b8871e2ea9a276a1d2e7" translate="yes" xml:space="preserve">
          <source>.  We find lattice points on a hyperbola.</source>
          <target state="translated">。我们在双曲线上找到晶格点。</target>
        </trans-unit>
        <trans-unit id="9ef5b873dc4abea1b311e3b6345ab953cf020928" translate="yes" xml:space="preserve">
          <source>.  We have several cases:</source>
          <target state="translated">。我们有几种情况：</target>
        </trans-unit>
        <trans-unit id="4f4e84829ca34bfa686bf64a2bbe339eadfd7319" translate="yes" xml:space="preserve">
          <source>.  We return the answer as</source>
          <target state="translated">。我们将答案返回为</target>
        </trans-unit>
        <trans-unit id="2a3ffa876c8affd5d4a2a3bdb0f9b24ccc9d2a04" translate="yes" xml:space="preserve">
          <source>.  We solve &lt;em&gt;x&lt;/em&gt;&lt;sup&gt;2&lt;/sup&gt; + |</source>
          <target state="translated">。我们解决&lt;em&gt;x &lt;/em&gt;&lt;sup&gt;2&lt;/sup&gt; + |</target>
        </trans-unit>
        <trans-unit id="aec57ea347c4cbb02e153f4e9dcdd2c7155bbc15" translate="yes" xml:space="preserve">
          <source>.  We solve &lt;em&gt;x&lt;/em&gt;&lt;sup&gt;2&lt;/sup&gt; =</source>
          <target state="translated">。我们求解&lt;em&gt;x &lt;/em&gt;&lt;sup&gt;2&lt;/sup&gt; =</target>
        </trans-unit>
        <trans-unit id="ffdb742443cab6f6bc68d8e65b810e375ac33345" translate="yes" xml:space="preserve">
          <source>.  We use matrix methods to efficiently compute the</source>
          <target state="translated">。我们使用矩阵方法来有效地计算</target>
        </trans-unit>
        <trans-unit id="d2edd7644d14b2c3ebdc5dcb244381cb86f47609" translate="yes" xml:space="preserve">
          <source>.  When</source>
          <target state="translated">。什么时候</target>
        </trans-unit>
        <trans-unit id="3dd77e02a23c61ca582238169f3ebe5213f17bd1" translate="yes" xml:space="preserve">
          <source>.  When called with the keyword arguments at their default values, this is equivalent to the expression</source>
          <target state="translated">。当使用关键字参数为其默认值调用时，这等效于表达式</target>
        </trans-unit>
        <trans-unit id="c45c4ba26e34d0170e8fcfc83536c6a2c13d24eb" translate="yes" xml:space="preserve">
          <source>.  Will be upgraded to full status when the case</source>
          <target state="translated">。遇有情况将升级为完整状态</target>
        </trans-unit>
        <trans-unit id="05a79f06cf3f67f726dae68d18a2290f6c9a50c9" translate="yes" xml:space="preserve">
          <source>:</source>
          <target state="translated">：</target>
        </trans-unit>
        <trans-unit id="cb7ea2362e2b5d69444b2add0d4466bf94a18ccd" translate="yes" xml:space="preserve">
          <source>: 1 if</source>
          <target state="translated">：1，如果</target>
        </trans-unit>
        <trans-unit id="890b46b3be358edbcfa3d0c38fe4595d37e1a1ac" translate="yes" xml:space="preserve">
          <source>: if</source>
          <target state="translated">：如果</target>
        </trans-unit>
        <trans-unit id="bb7195ec0056c8b0e2ce0463096c7965a6483b95" translate="yes" xml:space="preserve">
          <source>: the strongly multiplicative function that is -1 on the primes.</source>
          <target state="translated">：在质数上为-1的强乘法函数。</target>
        </trans-unit>
        <trans-unit id="85683ef74faa9fd110b10909edbd557af57c30bf" translate="yes" xml:space="preserve">
          <source>; i.e., finds the smallest &lt;em&gt;k&lt;/em&gt; such that</source>
          <target state="translated">; 即找到最小的&lt;em&gt;k&lt;/em&gt;使得</target>
        </trans-unit>
        <trans-unit id="1ec9e1cf2ec02b547b9b7d587eaa10e750c1b4c5" translate="yes" xml:space="preserve">
          <source>; if not, we keep chugging until a nontrivial factor is found.</source>
          <target state="translated">; 如果没有，我们将继续努力直到找到一个重要的因素。</target>
        </trans-unit>
        <trans-unit id="039f5fd2698055b3ba8a74fdb5cfa6c51e201fe2" translate="yes" xml:space="preserve">
          <source>; the actual factoring work is done there.  Multiprocessing incurs relatively significant overhead, so when</source>
          <target state="translated">; 实际的保理工作在那里完成。多处理会产生相当大的开销，因此当</target>
        </trans-unit>
        <trans-unit id="40d77535a61760e117dbb66e25c00a2a15e0f8f9" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;x&lt;/em&gt;&lt;sub&gt;n+1&lt;/sub&gt; =</source>
          <target state="translated">&lt;em&gt;x &lt;/em&gt;&lt;sub&gt;n + 1&lt;/sub&gt; =</target>
        </trans-unit>
        <trans-unit id="6fad80e2470f3259317f0bae7ea41499d23e52bd" translate="yes" xml:space="preserve">
          <source>&lt;sub&gt;0&lt;/sub&gt; &amp;middot; &lt;em&gt;x&lt;/em&gt;&lt;sub&gt;n-k&lt;/sub&gt;,</source>
          <target state="translated">&lt;sub&gt;0&lt;/sub&gt; &amp;middot; &lt;em&gt;x &lt;/em&gt;&lt;sub&gt;n-k&lt;/sub&gt;，</target>
        </trans-unit>
        <trans-unit id="5f7a29123ed0e3bd3cef4b66b4f233d8226b2920" translate="yes" xml:space="preserve">
          <source>&lt;sub&gt;k-1&lt;/sub&gt; &amp;middot; &lt;em&gt;x&lt;/em&gt;&lt;sub&gt;n-1&lt;/sub&gt; + &amp;hellip; +</source>
          <target state="translated">&lt;sub&gt;k-1&lt;/sub&gt; &amp;middot; &lt;em&gt;x &lt;/em&gt;&lt;sub&gt;n-1&lt;/sub&gt; +&amp;hellip;+</target>
        </trans-unit>
        <trans-unit id="a77f30fa676fba6eb28b45904ca9bf7f8407a4c8" translate="yes" xml:space="preserve">
          <source>&lt;sub&gt;k&lt;/sub&gt; &amp;middot; &lt;em&gt;x&lt;/em&gt;&lt;sub&gt;n&lt;/sub&gt; +</source>
          <target state="translated">&lt;sub&gt;k&lt;/sub&gt; &amp;middot; &lt;em&gt;x &lt;/em&gt;&lt;sub&gt;n&lt;/sub&gt; +</target>
        </trans-unit>
        <trans-unit id="b9b3b1f557ccaa4770f762809de784e1cf71acd8" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;0.3&lt;/sup&gt;, we quickly determine without error whether</source>
          <target state="translated">&lt;sup&gt;0.3&lt;/sup&gt;，我们迅速确定是否</target>
        </trans-unit>
        <trans-unit id="cc7ad8e27be44263423b050cf2c1d72fa330d1ec" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;2&lt;/sup&gt; &amp;equiv;</source>
          <target state="translated">&lt;sup&gt;2&lt;/sup&gt; &amp;equiv;</target>
        </trans-unit>
        <trans-unit id="8c3fed56bcf718ee6d22dfb1a2b07825ead397be" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;2&lt;/sup&gt; &amp;ne; 4&amp;middot;</source>
          <target state="translated">&lt;sup&gt;2&lt;/sup&gt; &amp;ne;4&amp;middot;</target>
        </trans-unit>
        <trans-unit id="c18d6e71a34fe8209f6204f366f7cb332c7dd04c" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;2&lt;/sup&gt; +</source>
          <target state="translated">&lt;sup&gt;2&lt;/sup&gt; +</target>
        </trans-unit>
        <trans-unit id="c716a113996c1b34a18ca8dadb5169431b0375fc" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;2&lt;/sup&gt; - 4&amp;middot;</source>
          <target state="translated">&lt;sup&gt;2&lt;/sup&gt; - 4&amp;middot;</target>
        </trans-unit>
        <trans-unit id="ba2ef0b9899bd5abf83399d29b83f17a30d1935f" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;2&lt;/sup&gt;) bit operations depending on how multiplication is handled.</source>
          <target state="translated">&lt;sup&gt;2&lt;/sup&gt;）位运算取决于乘法的处理方式。</target>
        </trans-unit>
        <trans-unit id="20c43e4a4f228b1130814bf5db7962ea64f1bd40" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;2&lt;/sup&gt;) bit operations.  Extractions of distant terms should therefore be done via</source>
          <target state="translated">&lt;sup&gt;2&lt;/sup&gt;）位运算。因此，应通过以下方式提取远项</target>
        </trans-unit>
        <trans-unit id="a167334eef67d44a756921a422a07f08e5fb4489" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;2&lt;/sup&gt;) depending on how multiplication is handled.  We recommend using MPZs when</source>
          <target state="translated">&lt;sup&gt;2&lt;/sup&gt;）取决于如何处理乘法。我们建议在以下情况下使用MPZ：</target>
        </trans-unit>
        <trans-unit id="d236f231a01427fc576faf86fb013aa14e7327a7" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;3&lt;/sup&gt; +</source>
          <target state="translated">&lt;sup&gt;3&lt;/sup&gt; +</target>
        </trans-unit>
        <trans-unit id="aca3c1fe1f41e62b4cfac7c3ec7653d996a24f93" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;k&lt;/sup&gt; &amp;equiv; 1 (mod</source>
          <target state="translated">&lt;sup&gt;ķ&lt;/sup&gt; &amp;equiv;1（模</target>
        </trans-unit>
        <trans-unit id="97c039090394f463605069bbf8c6df2722cd15df" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;k&lt;/sup&gt; &amp;le;</source>
          <target state="translated">&lt;sup&gt;ķ&lt;/sup&gt; &amp;le;</target>
        </trans-unit>
        <trans-unit id="55c8bf4743223131e169941ec2e4ce3a76abe7d9" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;r&lt;/sup&gt; =</source>
          <target state="translated">&lt;sup&gt;r&lt;/sup&gt; =</target>
        </trans-unit>
        <trans-unit id="4cc25447b154f91db08f310c8784b93d659d71b4" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;th&lt;/sup&gt;</source>
          <target state="translated">&lt;sup&gt;日&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="7b346dc385476d44de05bc10ba444eb03c42e758" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;th&lt;/sup&gt; Dirichlet root of the input function</source>
          <target state="translated">&lt;sup&gt;个&lt;/sup&gt;输入函数的狄利克雷根</target>
        </trans-unit>
        <trans-unit id="4e0998833af3e641c4809cbbdc1acb8fa08b0c19" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;th&lt;/sup&gt; Fibonacci number, indexed so that</source>
          <target state="translated">&lt;sup&gt;个&lt;/sup&gt;斐波那契数，索引，使得</target>
        </trans-unit>
        <trans-unit id="9bae34915a2d899be1093417a6feae86593fe6e9" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;th&lt;/sup&gt; power and reduced modulo</source>
          <target state="translated">&lt;sup&gt;个&lt;/sup&gt;功率和降低的模</target>
        </trans-unit>
        <trans-unit id="7c1b7cedd6cf4b7ea0843ae9112a88d81a587001" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;th&lt;/sup&gt; power; we return its</source>
          <target state="translated">&lt;sup&gt;个&lt;/sup&gt;功率; 我们返回它</target>
        </trans-unit>
        <trans-unit id="9571add5a9bb302601c68f6990cafdcaaac6ab01" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;th&lt;/sup&gt; prime (counting 2 as #1).  This is done with some efficiency by using</source>
          <target state="translated">&lt;sup&gt;第&lt;/sup&gt;素数（将2视为＃1）。通过使用</target>
        </trans-unit>
        <trans-unit id="2aa6d3c138012cea9d7e4de9efdf692013d87889" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;th&lt;/sup&gt; prime by using binary splitting on Riemann&amp;rsquo;s R function.</source>
          <target state="translated">&lt;sup&gt;&lt;/sup&gt;通过在Riemann的R函数上使用二进制拆分获得&lt;sup&gt;第一个&lt;/sup&gt;素数。</target>
        </trans-unit>
        <trans-unit id="1dd68f4e0732186c5eb7a5e3a2c916154df10e0a" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;th&lt;/sup&gt; root if it is and</source>
          <target state="translated">&lt;sup&gt;个&lt;/sup&gt;根，如果它是与</target>
        </trans-unit>
        <trans-unit id="ce011f637b61645c06d252c10fe014b1c3b50958" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;th&lt;/sup&gt; root of</source>
          <target state="translated">&lt;sup&gt;的&lt;/sup&gt;根</target>
        </trans-unit>
        <trans-unit id="d1dae2018f87c5b4146f30281a32a978b8b8f51d" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;th&lt;/sup&gt; term of the recursion</source>
          <target state="translated">&lt;sup&gt;次&lt;/sup&gt;递归的期限</target>
        </trans-unit>
        <trans-unit id="bb7ebac52b158e0f3fb696936209b81e8b9d9c71" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;th&lt;/sup&gt; terms in the Lucas U- and V-sequences U(</source>
          <target state="translated">&lt;sup&gt;个&lt;/sup&gt;在卢卡斯U-和V-序列&amp;ugrave;术语（</target>
        </trans-unit>
        <trans-unit id="c07471720fdc7dc843113017c61ef1da42d9636e" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;th&lt;/sup&gt; terms of Lucas U- and V-sequences modulo</source>
          <target state="translated">&lt;sup&gt;&lt;/sup&gt;Lucas U序列和V序列取模的&lt;sup&gt;第&lt;/sup&gt;项</target>
        </trans-unit>
        <trans-unit id="21606782c65e44cac7afbb90977d8b6f82140e76" translate="yes" xml:space="preserve">
          <source>=</source>
          <target state="translated">=</target>
        </trans-unit>
        <trans-unit id="0e867bc45a919f6852d1707d6c564cddccc15b7e" translate="yes" xml:space="preserve">
          <source>= 0 and</source>
          <target state="translated">= 0且</target>
        </trans-unit>
        <trans-unit id="a2b238e42ed2f58766c6f40ba1966b142c161247" translate="yes" xml:space="preserve">
          <source>= 0, we find the cubic&amp;rsquo;s other two roots an return in a tuple all distinct integer roots (including</source>
          <target state="translated">= 0，我们发现三次方的另外两个根在元组中返回所有不同的整数根（包括</target>
        </trans-unit>
        <trans-unit id="d6b32a7fe9fea7f7dd2116e40c5126417c968633" translate="yes" xml:space="preserve">
          <source>= 0.  This is primarily a helper function for</source>
          <target state="translated">=0。这主要是针对</target>
        </trans-unit>
        <trans-unit id="8c00f4833ad3bed0cee304c3bb5de05cab062a04" translate="yes" xml:space="preserve">
          <source>= 0.  We solve &lt;em&gt;x&lt;/em&gt;&lt;sup&gt;2&lt;/sup&gt; =</source>
          <target state="translated">=0。我们求解&lt;em&gt;x &lt;/em&gt;&lt;sup&gt;2&lt;/sup&gt; =</target>
        </trans-unit>
        <trans-unit id="049f7baef9b4665ff6124dbb2667d2e49d810988" translate="yes" xml:space="preserve">
          <source>= 0: If</source>
          <target state="translated">= 0：如果</target>
        </trans-unit>
        <trans-unit id="b3b9cebb3d288d60423f3a8c77d0031229959706" translate="yes" xml:space="preserve">
          <source>= 1 for all applicable</source>
          <target state="translated">= 1适用</target>
        </trans-unit>
        <trans-unit id="375e0e8806a735e7336a89fdb13202c8f2ff0bf5" translate="yes" xml:space="preserve">
          <source>= 1, this is Euler&amp;rsquo;s totient: the number of numbers less than a number that are relatively prime to that number.</source>
          <target state="translated">= 1，这是欧拉的最爱：小于该数字相对质数的数字数量。</target>
        </trans-unit>
        <trans-unit id="ee2a0977e48d5159f0c2700ba8564ca4daadcfd3" translate="yes" xml:space="preserve">
          <source>= 1.  The argument</source>
          <target state="translated">= 1.参数</target>
        </trans-unit>
        <trans-unit id="127624f04c1941ca775ad41bcee5f7ed9d3f2b10" translate="yes" xml:space="preserve">
          <source>= [&lt;em&gt;a&lt;/em&gt;&lt;sub&gt;0&lt;/sub&gt;; &lt;em&gt;a&lt;/em&gt;&lt;sub&gt;1&lt;/sub&gt;, &lt;em&gt;a&lt;/em&gt;&lt;sub&gt;2&lt;/sub&gt;, &amp;hellip;], (&lt;em&gt;P&lt;/em&gt;&lt;sub&gt;i&lt;/sub&gt;+&amp;radic;</source>
          <target state="translated">= [ &lt;em&gt;a &lt;/em&gt;&lt;sub&gt;0&lt;/sub&gt; ; &lt;em&gt;a &lt;/em&gt;&lt;sub&gt;1&lt;/sub&gt;，&lt;em&gt;a &lt;/em&gt;&lt;sub&gt;2&lt;/sub&gt;，&amp;hellip;]，（&lt;em&gt;P &lt;/em&gt;&lt;sub&gt;i&lt;/sub&gt; +&amp;radic;</target>
        </trans-unit>
        <trans-unit id="4338ffaceae0c24099d173ff2c9bfe4d749f97e7" translate="yes" xml:space="preserve">
          <source>= gcd(</source>
          <target state="translated">= gcd（</target>
        </trans-unit>
        <trans-unit id="6947818ac409551f11fbaa78f0ea6391960aa5b8" translate="yes" xml:space="preserve">
          <source>==</source>
          <target state="translated">==</target>
        </trans-unit>
        <trans-unit id="80cdd07910290457b081eafadcc6412b584e00f3" translate="yes" xml:space="preserve">
          <source>A 3-tuple.</source>
          <target state="translated">一个3元组。</target>
        </trans-unit>
        <trans-unit id="1782b0769bc0794f66fe37be0e6e2b5095cfdace" translate="yes" xml:space="preserve">
          <source>Adds two polynomials and reduces their coefficients mod</source>
          <target state="translated">将两个多项式相加,并将它们的系数模数化。</target>
        </trans-unit>
        <trans-unit id="d6dce062190a725f9378f9ddffe2e8beff5a7002" translate="yes" xml:space="preserve">
          <source>Algorithm 3.6.7 from &lt;em&gt;Prime Numbers: A Computational Perspective&lt;/em&gt; by Crandall &amp;amp; Pomerance (2&lt;sup&gt;nd&lt;/sup&gt; edition): Evaluation of a binary Lucas chain.  To quote their description:</source>
          <target state="translated">来自质&lt;em&gt;数的&lt;/em&gt;算法3.6.7 &lt;em&gt;：&lt;/em&gt; Crandall＆Pomerance的&lt;em&gt;计算视角&lt;/em&gt;（&lt;sup&gt;第二&lt;/sup&gt;版）：二元Lucas链的评估。引用其描述：</target>
        </trans-unit>
        <trans-unit id="38985f0c549afe30d53b4af28251e9c8da4ca5e4" translate="yes" xml:space="preserve">
          <source>Case 1:</source>
          <target state="translated">案例1:</target>
        </trans-unit>
        <trans-unit id="f8ec5cbd58e7c0b37a334f16283abc6b7d3385e8" translate="yes" xml:space="preserve">
          <source>Case 1a: If</source>
          <target state="translated">案例1a:如果</target>
        </trans-unit>
        <trans-unit id="a222a4dfe8a3b0d870d09894dab3f856e300b606" translate="yes" xml:space="preserve">
          <source>Case 1b: If</source>
          <target state="translated">房屋1b:如果</target>
        </trans-unit>
        <trans-unit id="b71fc63f13f19028ba8bff4aa1f8b7999da99de6" translate="yes" xml:space="preserve">
          <source>Case 2:</source>
          <target state="translated">2号院。</target>
        </trans-unit>
        <trans-unit id="49241f887a7ca8258095000020fd32271e16ed35" translate="yes" xml:space="preserve">
          <source>Case 2a: If</source>
          <target state="translated">案例2a:如果</target>
        </trans-unit>
        <trans-unit id="bbfaaabe73c148e3d2946062a4906d0302d6d1e1" translate="yes" xml:space="preserve">
          <source>Case 2b: If</source>
          <target state="translated">房屋2b:如果</target>
        </trans-unit>
        <trans-unit id="5b24dd2ab24f578129e90f8bd0303c05e5361a31" translate="yes" xml:space="preserve">
          <source>Case 3:</source>
          <target state="translated">3号院。</target>
        </trans-unit>
        <trans-unit id="2d6c1f774782efa9b4f6af5056c1a027477495d0" translate="yes" xml:space="preserve">
          <source>Case 4:</source>
          <target state="translated">房屋4。</target>
        </trans-unit>
        <trans-unit id="9b4eecac5205ad9ea5741a08c395a55c34819821" translate="yes" xml:space="preserve">
          <source>Case 4a: If</source>
          <target state="translated">房屋4a:如果</target>
        </trans-unit>
        <trans-unit id="df4114b917f3c8d37d9ed643e8b228a82e5032d2" translate="yes" xml:space="preserve">
          <source>Case 4b: If</source>
          <target state="translated">房屋4b:如果</target>
        </trans-unit>
        <trans-unit id="a450ec02055b5afb4768084d98776055638bdf23" translate="yes" xml:space="preserve">
          <source>Checks whether</source>
          <target state="translated">检查是否</target>
        </trans-unit>
        <trans-unit id="380d837572dc516226fdab2201b5176ba208d011" translate="yes" xml:space="preserve">
          <source>Compiles the output of</source>
          <target state="translated">编译输出的</target>
        </trans-unit>
        <trans-unit id="ad88b5c709893b3c20a622a8af743326fc15e581" translate="yes" xml:space="preserve">
          <source>Computes</source>
          <target state="translated">计算</target>
        </trans-unit>
        <trans-unit id="7aaa81c08dfe664800463bbb7d2b2609be00f74f" translate="yes" xml:space="preserve">
          <source>Computes all square roots of</source>
          <target state="translated">计算所有的平方根</target>
        </trans-unit>
        <trans-unit id="b71f4915a8b78a90bf71f4feb80ae5bf3e75096c" translate="yes" xml:space="preserve">
          <source>Computes the</source>
          <target state="translated">计算</target>
        </trans-unit>
        <trans-unit id="5b1f10974661e4aae9ae54437fdc601067fd19cd" translate="yes" xml:space="preserve">
          <source>Computes the Dirichlet inverse of the input function</source>
          <target state="translated">计算输入函数的Dirichlet反。</target>
        </trans-unit>
        <trans-unit id="45da31757146a27f1474566145d102920965af64" translate="yes" xml:space="preserve">
          <source>Computes the Riemann zeta function by applying</source>
          <target state="translated">计算黎曼zeta函数的方法是应用</target>
        </trans-unit>
        <trans-unit id="84ffdb0127b01fd0dfdcfdb8b0853e1e6660615e" translate="yes" xml:space="preserve">
          <source>Computes the conjugate of a partition.</source>
          <target state="translated">计算分割的共轭。</target>
        </trans-unit>
        <trans-unit id="2f7e72f636868efcf3963c89554f4f3546b46b10" translate="yes" xml:space="preserve">
          <source>Computes the determinant of a matrix via the Schur determinant identity.</source>
          <target state="translated">通过舒尔行列式特征计算矩阵的行列式。</target>
        </trans-unit>
        <trans-unit id="fddddbff9f2631233edd5bf8d0829b1d0ccca918" translate="yes" xml:space="preserve">
          <source>Computes the discriminant of a polynomial.  The input list is ordered from lowest degree to highest &amp;mdash; i.e.,</source>
          <target state="translated">计算多项式的判别式。输入列表是按从最低到最高的顺序排列的，即，</target>
        </trans-unit>
        <trans-unit id="b13cdb1f9f2f8c15d7b68dc85b5079cb409f0d0b" translate="yes" xml:space="preserve">
          <source>Computes the greatest common monic divisor of the polynomials</source>
          <target state="translated">计算多项式的最大公有一元除数。</target>
        </trans-unit>
        <trans-unit id="70b1bcff0851db37b6ab48af870b18b4eb899e80" translate="yes" xml:space="preserve">
          <source>Computes the multiplicative order of</source>
          <target state="translated">的乘法顺序。</target>
        </trans-unit>
        <trans-unit id="e6b1d2dbff4a02700db49061c1ccad62b0f984fa" translate="yes" xml:space="preserve">
          <source>Computes the number of primes &amp;le;</source>
          <target state="translated">计算素数&amp;le;</target>
        </trans-unit>
        <trans-unit id="70313b568710e20bcdef3dc81d824005411e54b6" translate="yes" xml:space="preserve">
          <source>Computes the remainder when the polynomial</source>
          <target state="translated">计算多项式的余数。</target>
        </trans-unit>
        <trans-unit id="e4e418400d07ed96420a73081a8ab85a89f6efae" translate="yes" xml:space="preserve">
          <source>Computes the simple continued fraction for &amp;radic;</source>
          <target state="translated">计算&amp;radic;的简单连续分数</target>
        </trans-unit>
        <trans-unit id="06a5f586c2eb39fa66d2894fdc3bb97e1fc12155" translate="yes" xml:space="preserve">
          <source>Computes the zeros of a polynomial modulo an integer.  We do this by factoring the modulus, solving modulo the prime power factors, and putting the results back together via the Chinese Remainder Theorem.</source>
          <target state="translated">计算多项式的零点整数模数。我们通过对模数进行因子化,求解模数的质数因子,并通过中国余数定理将结果重新组合起来。</target>
        </trans-unit>
        <trans-unit id="4956ed652a1c6f51cec0f6e694b55d17d33de8a7" translate="yes" xml:space="preserve">
          <source>Computes with some semblance of efficiency the number of additive partitions of an integer.  The</source>
          <target state="translated">以某种程度上的效率计算整数的加法分割数。该</target>
        </trans-unit>
        <trans-unit id="3a77df48c3f864a6b42116f2a3e15f1b92f8d260" translate="yes" xml:space="preserve">
          <source>Convergence acceleration for alternating series.  This is algorithm 1 from &lt;em&gt;Convergence Acceleration of Alternating Series&lt;/em&gt; by Cohen, Villegas, and Zagier &lt;a href=&quot;https://people.mpim-bonn.mpg.de/zagier/files/exp-math-9/fulltext.pdf&quot;&gt;(pdf)&lt;/a&gt;, with a minor tweak so that the &lt;em&gt;d&lt;/em&gt;-value isn&amp;rsquo;t computed via floating point.</source>
          <target state="translated">交替级数的收敛速度。这是Cohen，Villegas和Zagier &lt;a href=&quot;https://people.mpim-bonn.mpg.de/zagier/files/exp-math-9/fulltext.pdf&quot;&gt;（pdf）&lt;/a&gt;&lt;em&gt;的交替序列&lt;/em&gt;的&lt;em&gt;收敛加速&lt;/em&gt;算法（pdf）中的算法1 ，进行了微小的调整，因此不会通过浮点计算&lt;em&gt;d&lt;/em&gt;值。</target>
        </trans-unit>
        <trans-unit id="868ee34edfb003b759b6277c74f7c0b97d444d92" translate="yes" xml:space="preserve">
          <source>Counts the number of divisors of</source>
          <target state="translated">的除数。</target>
        </trans-unit>
        <trans-unit id="50c9e8d5fc98727b4bbc93cf5d64a68db647f04f" translate="yes" xml:space="preserve">
          <source>D</source>
          <target state="translated">D</target>
        </trans-unit>
        <trans-unit id="0562f32dc56f5c702810cbe010068ddd38dbd69a" translate="yes" xml:space="preserve">
          <source>Dependencies</source>
          <target state="translated">依赖性</target>
        </trans-unit>
        <trans-unit id="e28be8ee29e21096adf6d89d6fffac95ddaa18af" translate="yes" xml:space="preserve">
          <source>Divides the polynomial</source>
          <target state="translated">除以多项式</target>
        </trans-unit>
        <trans-unit id="40f7c422e533a5dba78c4675c7771558df18fb63" translate="yes" xml:space="preserve">
          <source>Efficiently computed the</source>
          <target state="translated">有效地计算出</target>
        </trans-unit>
        <trans-unit id="6f70b9a168f5b545c989cf3a4158ce307cfc5f6a" translate="yes" xml:space="preserve">
          <source>Efficiently computes the</source>
          <target state="translated">高效地计算</target>
        </trans-unit>
        <trans-unit id="c79cfad0cd9fc1efb605194c6bd5201bdc78b768" translate="yes" xml:space="preserve">
          <source>Efficiently extracts the</source>
          <target state="translated">高效地提取</target>
        </trans-unit>
        <trans-unit id="1b735210ec0711a77faa327c9d6a3e0c153f226e" translate="yes" xml:space="preserve">
          <source>Efficiently extracts the nth Fibonacci number modulo</source>
          <target state="translated">有效地提取第n个斐波那契数的模数。</target>
        </trans-unit>
        <trans-unit id="76daf7900317f7abf520a1e4a2b4b5b2dc6ddf73" translate="yes" xml:space="preserve">
          <source>Efficiently generates an integer selected uniformly from the range [1,</source>
          <target state="translated">有效地生成一个从范围[1.]中统一选择的整数。</target>
        </trans-unit>
        <trans-unit id="42ca14cfd4cae0581ea916c6f1594ad56a1df12d" translate="yes" xml:space="preserve">
          <source>Evaluates a polynomial at a particular point, optionally modulo something.</source>
          <target state="translated">在某一特定点上对多项式进行评价,可以选择模数。</target>
        </trans-unit>
        <trans-unit id="8b63f3d72cb6c84d8aa9c2f9b5cdfac25b053939" translate="yes" xml:space="preserve">
          <source>Evaluates a string in reverse Polish notation.  The acceptable binary operators are</source>
          <target state="translated">用反波兰语符号来评估一个字符串。可接受的二进制运算符是</target>
        </trans-unit>
        <trans-unit id="9f45020f0002b90bc4cba364abf6bfb470d1b5da" translate="yes" xml:space="preserve">
          <source>Extended Euclidean altorithm: returns a tuple (</source>
          <target state="translated">扩展的欧几里得算法:返回一个元组(</target>
        </trans-unit>
        <trans-unit id="e09a8a0654b6fa8b1ac79728874341d2fcc002e7" translate="yes" xml:space="preserve">
          <source>Extra strong Lucas probable primality test as described on Wikipedia.  Its false positives are a strict subset of those for</source>
          <target state="translated">维基百科上描述的特强卢卡斯概率初性检验。它的假阳性是严格意义上的子集。</target>
        </trans-unit>
        <trans-unit id="755583209467b74b108f8173066d287285913679" translate="yes" xml:space="preserve">
          <source>Factors an integer via the multiple-polynomial quadratic sieve.  Most of this function is copied verbatim from &lt;a href=&quot;https://codegolf.stackexchange.com/a/9088&quot;&gt;https://codegolf.stackexchange.com/a/9088&lt;/a&gt;.</source>
          <target state="translated">通过多项式二次筛分解整数。此功能大部分都是从&lt;a href=&quot;https://codegolf.stackexchange.com/a/9088&quot;&gt;https://codegolf.stackexchange.com/a/9088&lt;/a&gt;逐字复制的。</target>
        </trans-unit>
        <trans-unit id="aa9969810c269380b8228efaa8c405afadd239c4" translate="yes" xml:space="preserve">
          <source>Factors integers using Brent&amp;rsquo;s variation of Pollard&amp;rsquo;s rho algorithm.  If</source>
          <target state="translated">使用Pollard rho算法的Brent变体对整数进行分解。如果</target>
        </trans-unit>
        <trans-unit id="c35602376c7ffa9efe97e8890d60ce2d999e78e6" translate="yes" xml:space="preserve">
          <source>Fermat&amp;rsquo;s primality test.</source>
          <target state="translated">费马的素数检验。</target>
        </trans-unit>
        <trans-unit id="558a4d2dc169dc8bc6101e6bf8955d89cfb2a5d6" translate="yes" xml:space="preserve">
          <source>Finds &lt;em&gt;x&lt;/em&gt; such that &lt;em&gt;x&lt;/em&gt;&lt;sup&gt;2&lt;/sup&gt; &amp;equiv;</source>
          <target state="translated">发现&lt;em&gt;X&lt;/em&gt;，使得&lt;em&gt;X &lt;/em&gt;&lt;sup&gt;2&lt;/sup&gt; &amp;equiv;</target>
        </trans-unit>
        <trans-unit id="b686567435c207d22564a0533b8ee5df789dc981" translate="yes" xml:space="preserve">
          <source>For a sequence &lt;em&gt;x&lt;/em&gt;&lt;sub&gt;0&lt;/sub&gt;, &lt;em&gt;x&lt;/em&gt;&lt;sub&gt;1&lt;/sub&gt;, &amp;hellip; with a rule for computing &lt;em&gt;x&lt;/em&gt;&lt;sub&gt;2j&lt;/sub&gt; from &lt;em&gt;x&lt;/em&gt;&lt;sub&gt;j&lt;/sub&gt; and a rule for computing &lt;em&gt;x&lt;/em&gt;&lt;sub&gt;2j+1&lt;/sub&gt; from &lt;em&gt;x&lt;/em&gt;&lt;sub&gt;j&lt;/sub&gt; and &lt;em&gt;x&lt;/em&gt;&lt;sub&gt;j+1&lt;/sub&gt;, this algorithm computes (&lt;em&gt;x&lt;/em&gt;&lt;sub&gt;n&lt;/sub&gt;, &lt;em&gt;x&lt;/em&gt;&lt;sub&gt;n+1&lt;/sub&gt;) for a given positive integer &lt;em&gt;n&lt;/em&gt;.  We have &lt;em&gt;n&lt;/em&gt; in binary as (&lt;em&gt;n&lt;/em&gt;&lt;sub&gt;0&lt;/sub&gt;, &lt;em&gt;n&lt;/em&gt;&lt;sub&gt;1&lt;/sub&gt;, &amp;hellip;, &lt;em&gt;n&lt;/em&gt;&lt;sub&gt;b-1&lt;/sub&gt;) with &lt;em&gt;n&lt;/em&gt;&lt;sub&gt;0&lt;/sub&gt; being the low-order bit.  We write the rules as follows: &lt;em&gt;x&lt;/em&gt;&lt;sub&gt;2j&lt;/sub&gt; = op1(&lt;em&gt;x&lt;/em&gt;&lt;sub&gt;j&lt;/sub&gt;) and &lt;em&gt;x&lt;/em&gt;&lt;sub&gt;2j+1&lt;/sub&gt; = op2(&lt;em&gt;x&lt;/em&gt;&lt;sub&gt;j&lt;/sub&gt;, &lt;em&gt;x&lt;/em&gt;&lt;sub&gt;j+1&lt;/sub&gt;).</source>
          <target state="translated">对于序列&lt;em&gt;x &lt;/em&gt;&lt;sub&gt;0&lt;/sub&gt;，&lt;em&gt;x &lt;/em&gt;&lt;sub&gt;1&lt;/sub&gt;，&amp;hellip;，其中有一个从&lt;em&gt;x &lt;/em&gt;&lt;sub&gt;j&lt;/sub&gt;计算&lt;em&gt;x &lt;/em&gt;&lt;sub&gt;2j&lt;/sub&gt;的规则以及从&lt;em&gt;x &lt;/em&gt;&lt;sub&gt;j&lt;/sub&gt;和&lt;em&gt;x &lt;/em&gt;&lt;sub&gt;j + 1&lt;/sub&gt;计算&lt;em&gt;x &lt;/em&gt;&lt;sub&gt;2j + 1&lt;/sub&gt;的规则，该算法计算（&lt;em&gt;x &lt;/em&gt;&lt;sub&gt;n&lt;/sub&gt;，&lt;em&gt;x &lt;/em&gt;&lt;sub&gt;n + 1&lt;/sub&gt;）对于给定的正整数&lt;em&gt;n&lt;/em&gt;。我们将&lt;em&gt;n&lt;/em&gt;以（&lt;em&gt;n &lt;/em&gt;&lt;sub&gt;0&lt;/sub&gt;，&lt;em&gt;n &lt;/em&gt;&lt;sub&gt;1&lt;/sub&gt;，&amp;hellip;，&lt;em&gt;n &lt;/em&gt;&lt;sub&gt;b-1&lt;/sub&gt;）的二进制形式&lt;em&gt;表示&lt;/em&gt;，其中&lt;em&gt;n &lt;/em&gt;&lt;sub&gt;0&lt;/sub&gt;为低位。我们将规则编写如下：&lt;em&gt;&lt;/em&gt;&lt;sub&gt;&lt;/sub&gt;&lt;em&gt;&lt;/em&gt;&lt;sub&gt;&lt;/sub&gt;&lt;em&gt;&lt;/em&gt;&lt;sub&gt;&lt;/sub&gt;&lt;em&gt;&lt;/em&gt;&lt;sub&gt;&lt;/sub&gt;&lt;em&gt;&lt;/em&gt;&lt;sub&gt;&lt;/sub&gt;&lt;em&gt;&lt;/em&gt;&lt;sub&gt;&lt;/sub&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;sub&gt;&lt;/sub&gt;&lt;em&gt;&lt;/em&gt;&lt;sub&gt;&lt;/sub&gt;&lt;em&gt;&lt;/em&gt;&lt;sub&gt;&lt;/sub&gt;&lt;em&gt;&lt;/em&gt;&lt;sub&gt;&lt;/sub&gt;&lt;em&gt;x &lt;/em&gt;&lt;sub&gt;2j&lt;/sub&gt; = op1（&lt;em&gt;x &lt;/em&gt;&lt;sub&gt;j&lt;/sub&gt;）和&lt;em&gt;x &lt;/em&gt;&lt;sub&gt;2j + 1&lt;/sub&gt; = op2（&lt;em&gt;x &lt;/em&gt;&lt;sub&gt;j&lt;/sub&gt;，&lt;em&gt;x &lt;/em&gt;&lt;sub&gt;j + 1&lt;/sub&gt;）。</target>
        </trans-unit>
        <trans-unit id="82e0d55e71d19ecac7cb12bebf6d2777fc0662cf" translate="yes" xml:space="preserve">
          <source>For non-negative</source>
          <target state="translated">对于非负数</target>
        </trans-unit>
        <trans-unit id="e3037e63bf6849b84a9a65234ff16b35b8d4cade" translate="yes" xml:space="preserve">
          <source>Fraction</source>
          <target state="translated">分数</target>
        </trans-unit>
        <trans-unit id="2b961dea1dc0c60ddf9a2c8e9d090f6f7d082483" translate="yes" xml:space="preserve">
          <source>Functions</source>
          <target state="translated">职能</target>
        </trans-unit>
        <trans-unit id="7b9e3da59754229c2f32e74a42b577b4422f4918" translate="yes" xml:space="preserve">
          <source>Generates all</source>
          <target state="translated">生成所有</target>
        </trans-unit>
        <trans-unit id="22d7ccb6d14fc4cee74c0160cabca76bfa59b245" translate="yes" xml:space="preserve">
          <source>Generates all Pythagorean triples of a given perimeter by examining the perimeter&amp;rsquo;s factors.</source>
          <target state="translated">通过检查周边因素，生成给定周边的所有勾股三重体。</target>
        </trans-unit>
        <trans-unit id="20981a6085339e916312afca4c42cb21b29b3435" translate="yes" xml:space="preserve">
          <source>Generates all natural numbers that evenly divide</source>
          <target state="translated">生成所有自然数,并均匀地除以。</target>
        </trans-unit>
        <trans-unit id="d7b6cb7b6197706c909fd79e098d52255b952bca" translate="yes" xml:space="preserve">
          <source>Generates all ordered</source>
          <target state="translated">生成所有有序的</target>
        </trans-unit>
        <trans-unit id="b5bc0df54325689a6ed5d8e44d009cbaf25e1e56" translate="yes" xml:space="preserve">
          <source>Generates all shortest Egyptian fractions for</source>
          <target state="translated">生成所有最短的埃及分数。</target>
        </trans-unit>
        <trans-unit id="3674e97303aab2ce4c8cb585b3c01cfb064409d3" translate="yes" xml:space="preserve">
          <source>Generates partitions of integers in ascending order via an iterative algorithm.  It is the fastest known algorithm as of June 2014.</source>
          <target state="translated">通过迭代算法,按升序生成整数的分区。这是截至2014年6月已知最快的算法。</target>
        </trans-unit>
        <trans-unit id="4f361d97a211e6e4027fd04a5730593d8e693bec" translate="yes" xml:space="preserve">
          <source>Generates primes less than the given limit (which may be infinite) lazily via a segmented sieve of Eratosthenes.  Uses O(&amp;radic;&lt;em&gt;p&lt;/em&gt;) memory, where &lt;em&gt;p&lt;/em&gt; is the most recently yielded prime.</source>
          <target state="translated">通过Eratosthenes的分段筛懒惰地生成小于给定限制（可能是无限大）的素数。用途O（&amp;radic; &lt;em&gt;p&lt;/em&gt;）的内存，其中&lt;em&gt;p&lt;/em&gt;是最近取得了素数。</target>
        </trans-unit>
        <trans-unit id="16934eba3976ff01419c058e6df6c8af103e1657" translate="yes" xml:space="preserve">
          <source>Generates some sequences related to simple continued fractions of certain quadratic surds.  A helper function for</source>
          <target state="translated">生成一些与某些二次根式的简单连续分数相关的序列。一个辅助函数,用于</target>
        </trans-unit>
        <trans-unit id="5ec34d045dbcf19d83dead6f9fa5a6d49578ccf9" translate="yes" xml:space="preserve">
          <source>Generates the Collatz sequence initiated by</source>
          <target state="translated">生成由</target>
        </trans-unit>
        <trans-unit id="46036a496172f9e7e59c4720ac28f38377a5a3ae" translate="yes" xml:space="preserve">
          <source>Generates the Farey sequence of maximum denominator</source>
          <target state="translated">生成最大分母的Farey序列。</target>
        </trans-unit>
        <trans-unit id="2966c2d3959f388c9f4c373f0c4789924fb35dac" translate="yes" xml:space="preserve">
          <source>Generates the Fibonacci numbers, starting with 0 and 1.</source>
          <target state="translated">生成从0和1开始的斐波那契数。</target>
        </trans-unit>
        <trans-unit id="a4d7c7b387f01b698c992b18b6cdbbeb8857ce38" translate="yes" xml:space="preserve">
          <source>Generates the Lucas U- and V-sequences with parameters (</source>
          <target state="translated">生成Lucas U-和V-序列,参数(</target>
        </trans-unit>
        <trans-unit id="348058674896d7698ade218b645e78aa719f733f" translate="yes" xml:space="preserve">
          <source>Generates the convergents of a simple continued fraction.</source>
          <target state="translated">生成一个简单的续分数的收敛。</target>
        </trans-unit>
        <trans-unit id="03b9c7acd70153ae6f6f9b6383547d14ca22b12d" translate="yes" xml:space="preserve">
          <source>Generates the divisors of</source>
          <target state="translated">生成被除数的</target>
        </trans-unit>
        <trans-unit id="77d96cd973f5fcc356d7ea61e98fc0354ef923eb" translate="yes" xml:space="preserve">
          <source>Generates the positive solutions of &lt;em&gt;x&lt;/em&gt;&lt;sup&gt;2&lt;/sup&gt; -</source>
          <target state="translated">生成&lt;em&gt;x &lt;/em&gt;&lt;sup&gt;2&lt;/sup&gt;的正解-</target>
        </trans-unit>
        <trans-unit id="a2cedf2f0905a16cb97355e0f89e09a9b9e2ced4" translate="yes" xml:space="preserve">
          <source>Generates the powerset of a list, tuple, or string.  The yielded objects are always lists.</source>
          <target state="translated">生成列表、元组或字符串的幂集。生成的对象总是列表。</target>
        </trans-unit>
        <trans-unit id="d3d1a5db6f2fcf2d35cde613a5cf1b3ebe6d1ef0" translate="yes" xml:space="preserve">
          <source>Generates the sequence of perfect powers without multiplicity.</source>
          <target state="translated">生成无倍数的完全权力序列。</target>
        </trans-unit>
        <trans-unit id="9927c93125a447795cdb56a5b70e090d7a59152a" translate="yes" xml:space="preserve">
          <source>Generates the squarefree products of elements of</source>
          <target state="translated">的元素的无平方积。</target>
        </trans-unit>
        <trans-unit id="48a914e25af552022c46aa19f9aad423ebb78585" translate="yes" xml:space="preserve">
          <source>Generates the squarefree products of the elements of</source>
          <target state="translated">的元素的无平方积。</target>
        </trans-unit>
        <trans-unit id="61e266b2da8f4d9e3228c6d44639b6b4b9d9c574" translate="yes" xml:space="preserve">
          <source>Generates with some efficiency and without multiplicity the zeros of a polynomial modulo a prime.  Coded after algorithm 2.3.10 from &lt;em&gt;Prime Numbers: A Computational Perspective&lt;/em&gt; by Crandall &amp;amp; Pomerance (2&lt;sup&gt;nd&lt;/sup&gt; edition), which is essentially Cantor-Zassenhaus.</source>
          <target state="translated">高效地生成且不乘以质数模的多项式零。从算法2.3.10后编码&lt;em&gt;一种计算视角：素数&lt;/em&gt;由克兰德尔＆Pomerance（2&lt;sup&gt;次&lt;/sup&gt;版），它基本上是坎托-Zassenhaus。</target>
        </trans-unit>
        <trans-unit id="afdca067c762eb09ba18fe097a8a14944b2cd94b" translate="yes" xml:space="preserve">
          <source>Generator of parameters to use for</source>
          <target state="translated">生成参数,用于</target>
        </trans-unit>
        <trans-unit id="6756ef06769b67757cfb7a54a00557c41b55378c" translate="yes" xml:space="preserve">
          <source>Given integers</source>
          <target state="translated">给定整数</target>
        </trans-unit>
        <trans-unit id="a05c89fdecd6337e222ba902e607265c0a919d19" translate="yes" xml:space="preserve">
          <source>Grantham&amp;rsquo;s general Frobenius probable primality test, in both the strong and weak versions, as described in &lt;a href=&quot;https://doi.org/10.1090/S0025-5718-00-01197-2&quot;&gt;his paper introducing the test&lt;/a&gt;.</source>
          <target state="translated">格兰瑟姆（Grantham）的通用Frobenius大概素性检验，包括强版本和弱版本，如&lt;a href=&quot;https://doi.org/10.1090/S0025-5718-00-01197-2&quot;&gt;他&lt;/a&gt;在介绍该检验的论文中所述。</target>
        </trans-unit>
        <trans-unit id="2a2772645729065942d0eadaa12ba2597a7ce381" translate="yes" xml:space="preserve">
          <source>Greatest common divisor of any number of values.</source>
          <target state="translated">任何数值的最大公除数。</target>
        </trans-unit>
        <trans-unit id="d5538fdacd40c229580844c50a0e84640071e8d2" translate="yes" xml:space="preserve">
          <source>Greatest integer &lt;em&gt;k&lt;/em&gt; such that</source>
          <target state="translated">最大整数&lt;em&gt;k&lt;/em&gt;使得</target>
        </trans-unit>
        <trans-unit id="6f381fc48bf71efac0b87be50ca0395b1bcdb0e3" translate="yes" xml:space="preserve">
          <source>Greatest integer whose square is &amp;le;</source>
          <target state="translated">平方&amp;le;的最大整数</target>
        </trans-unit>
        <trans-unit id="8a9786aebdf4baf47c580d618ffbf95fee7af8a8" translate="yes" xml:space="preserve">
          <source>Helper function for</source>
          <target state="translated">輔助功能</target>
        </trans-unit>
        <trans-unit id="751c68a3471b1c791efaee0a8e7c24ea0c266efd" translate="yes" xml:space="preserve">
          <source>If</source>
          <target state="translated">如果</target>
        </trans-unit>
        <trans-unit id="74a544b60062e69929a114bf0936c5b792215936" translate="yes" xml:space="preserve">
          <source>If the number of solutions if infinite and the equation is nondegenerate, it is</source>
          <target state="translated">如果解的个数是无限的,且方程是无根的,则是</target>
        </trans-unit>
        <trans-unit id="3601acab0087a6f1de36dbe7e247c1336341803c" translate="yes" xml:space="preserve">
          <source>If the number of solutions is finite, it is</source>
          <target state="translated">如果解的数量是有限的,那么它是</target>
        </trans-unit>
        <trans-unit id="4c45f1494010a75938699a86ca9f35b4af612c35" translate="yes" xml:space="preserve">
          <source>If the number of solutions is infinite and the equation is degenerate, it&amp;rsquo;s</source>
          <target state="translated">如果解的数量是无限的并且方程式是简并的，那就是</target>
        </trans-unit>
        <trans-unit id="79d70dcb4f9ee8b7d94ed9539586cc73c0d399da" translate="yes" xml:space="preserve">
          <source>Input:</source>
          <target state="translated">输入:</target>
        </trans-unit>
        <trans-unit id="48558cde54ab4e31d9a52d6e368c01422d284be7" translate="yes" xml:space="preserve">
          <source>Integer factoring function.  Uses Pollard&amp;rsquo;s p-1 algorithm.  Note that this is only efficient if the number to be factored has a prime factor &lt;em&gt;p&lt;/em&gt; such that &lt;em&gt;p&lt;/em&gt;-1&amp;rsquo;s largest prime factor is &amp;ldquo;small&amp;rdquo;.</source>
          <target state="translated">整数分解功能。使用Pollard的p-1算法。注意，这仅在要分解的数具有素数&lt;em&gt;p&lt;/em&gt;使得&lt;em&gt;p&lt;/em&gt; -1的最大素数为&amp;ldquo;小&amp;rdquo;时才有效。</target>
        </trans-unit>
        <trans-unit id="58aee54e766c3d0648fe443ab71a1c4404a30692" translate="yes" xml:space="preserve">
          <source>Integer factoring function.  Uses Williams&amp;rsquo; p+1 algorithm, single-stage variant.  Note that this is only efficient when the number to be factored has a prime factor &lt;em&gt;p&lt;/em&gt; such that &lt;em&gt;p&lt;/em&gt;+1&amp;rsquo;s largest prime factor is &amp;ldquo;small&amp;rdquo;.</source>
          <target state="translated">整数分解功能。使用Williams的p + 1算法（单级变体）。注意，这仅在要分解的数具有质数&lt;em&gt;p&lt;/em&gt;使得&lt;em&gt;p&lt;/em&gt; +1的最大质数为&amp;ldquo;小&amp;rdquo;时才有效。</target>
        </trans-unit>
        <trans-unit id="eb92da6cfaf48f911b1e397ac93a72e926d82c77" translate="yes" xml:space="preserve">
          <source>Integer factoring function.  Uses several methods in parallel.  Waits for one of them to return, kills the rest, and reports.</source>
          <target state="translated">整数分解函数。并行使用多个方法。等待其中一个方法返回,杀死其余的方法,然后报告。</target>
        </trans-unit>
        <trans-unit id="36b9a195ec43bf4e36c9d0dbe3c68ca3b21e4977" translate="yes" xml:space="preserve">
          <source>Integer factoring via elliptic curves using the two-phase algorithm on Montgomery curves, and optionally uses multiple processes.  This is a shell function that repeatedly calls</source>
          <target state="translated">通过椭圆曲线进行整数分解,使用蒙哥马利曲线上的两阶段算法,并可选择使用多个过程。这是一个重复调用</target>
        </trans-unit>
        <trans-unit id="d950c89d45f2f17330d4a332dbacd4261edaedc3" translate="yes" xml:space="preserve">
          <source>Jordan&amp;rsquo;s totient function: the number of</source>
          <target state="translated">乔丹的上衣功能：</target>
        </trans-unit>
        <trans-unit id="c0dae73b357c71b4181bcabbe5d70a17d3268e2c" translate="yes" xml:space="preserve">
          <source>Largest prime strictly less than</source>
          <target state="translated">严格来说,最大的质数小于</target>
        </trans-unit>
        <trans-unit id="c55e3aef5e32189be393ed862c0ceb6f582486d0" translate="yes" xml:space="preserve">
          <source>Legendre symbol (</source>
          <target state="translated">Legendre符号 (</target>
        </trans-unit>
        <trans-unit id="b7b70cfe63de1ef2240623cc22aef298e95de6a5" translate="yes" xml:space="preserve">
          <source>Legendre&amp;rsquo;s phi function.  Helper function for</source>
          <target state="translated">Legendre的phi函数。辅助功能</target>
        </trans-unit>
        <trans-unit id="0b27b9e0b34d6576fc9dbd960ff42a117b81e70c" translate="yes" xml:space="preserve">
          <source>Lucas probable primality test as described in &lt;em&gt;Prime Numbers: A Computational Perspective&lt;/em&gt; by Crandall &amp;amp; Pomerance (2&lt;sup&gt;nd&lt;/sup&gt; edition).</source>
          <target state="translated">卢卡斯如描述可能素性测试&lt;em&gt;素数：计算视角&lt;/em&gt;由克兰德尔＆Pomerance（2&lt;sup&gt;次&lt;/sup&gt;版）。</target>
        </trans-unit>
        <trans-unit id="de85192de03e3d43986a9c427bfca218b75f30da" translate="yes" xml:space="preserve">
          <source>Miller&amp;rsquo;s primality test.  If the extended Riemann hypothesis (the one about Dirichlet L-functions) is true, then this test is deterministic.</source>
          <target state="translated">米勒的素数检验。如果扩展的黎曼假设（关于Dirichlet L函数的假设）是正确的，则该检验是确定性的。</target>
        </trans-unit>
        <trans-unit id="bab38cd4e545470c7e853f0da105b99b830768c5" translate="yes" xml:space="preserve">
          <source>Miller-Rabin probable primality test.</source>
          <target state="translated">米勒-拉宾可能的首要性检验。</target>
        </trans-unit>
        <trans-unit id="e68c66d68ccfd8c95781dbee10e00aff4655ac5a" translate="yes" xml:space="preserve">
          <source>Module for basic math in the general vicinity of computational number theory</source>
          <target state="translated">计算数论一般附近的基础数学模块</target>
        </trans-unit>
        <trans-unit id="46e698ab572623f8f0ad02eff524bd00be815263" translate="yes" xml:space="preserve">
          <source>Multiplies the polynomials</source>
          <target state="translated">乘以多项式</target>
        </trans-unit>
        <trans-unit id="b51a60734da64be0e618bacbea2865a8a7dcd669" translate="yes" xml:space="preserve">
          <source>N</source>
          <target state="translated">N</target>
        </trans-unit>
        <trans-unit id="6eef6648406c333a4035cd5e60d0bf2ecf2606d7" translate="yes" xml:space="preserve">
          <source>None</source>
          <target state="translated">なし</target>
        </trans-unit>
        <trans-unit id="4b290a83942f6f4f2844b1da336895999527b694" translate="yes" xml:space="preserve">
          <source>Note that we can check the infinitude of solutions by calling</source>
          <target state="translated">请注意,我们可以通过调用</target>
        </trans-unit>
        <trans-unit id="f3c8c95c5e534bcd2ea0034a0d83177efa6923f4" translate="yes" xml:space="preserve">
          <source>Output:</source>
          <target state="translated">产出:</target>
        </trans-unit>
        <trans-unit id="511993d3c99719e38a6779073019dacd7178ddb9" translate="yes" xml:space="preserve">
          <source>P</source>
          <target state="translated">P</target>
        </trans-unit>
        <trans-unit id="29759bca1bfc18757b044f77226b0cf5f29e7563" translate="yes" xml:space="preserve">
          <source>Produces an integer that should be rather close to the</source>
          <target state="translated">生成的整数应该非常接近于</target>
        </trans-unit>
        <trans-unit id="b29a525c144146bbd16fe9aea49b986119d89719" translate="yes" xml:space="preserve">
          <source>Product of the elements of a list.  The product of the empty list is 1.  We use a binary algorithm because this can easily generate huge numbers, and calling</source>
          <target state="translated">列表中元素的乘积。空列表的乘积是1,我们使用二进制算法,因为这很容易产生巨大的数字,而调用</target>
        </trans-unit>
        <trans-unit id="efa50f19205b93213ecf483dedf5829a87e91fa3" translate="yes" xml:space="preserve">
          <source>Product of the elements of any iterable.  The product of an empty iterable is 1.</source>
          <target state="translated">任何可迭代元素的乘积。空迭代元素的乘积是1。</target>
        </trans-unit>
        <trans-unit id="c3156e00d3c2588c639e0d3cf6821258b05761c7" translate="yes" xml:space="preserve">
          <source>Q</source>
          <target state="translated">Q</target>
        </trans-unit>
        <trans-unit id="4fc743668b1979c9eb68fd8f734e4c967cd38b2b" translate="yes" xml:space="preserve">
          <source>Quadratic Frobenius probable primality test as described in &lt;em&gt;Prime Numbers: A Computational Perspective&lt;/em&gt; by Crandall &amp;amp; Pomerance (2&lt;sup&gt;nd&lt;/sup&gt; edition).</source>
          <target state="translated">如上述二次弗罗贝纽斯可能素性测试&lt;em&gt;素数：计算视角&lt;/em&gt;由克兰德尔＆Pomerance（2&lt;sup&gt;次&lt;/sup&gt;版）。</target>
        </trans-unit>
        <trans-unit id="9d1e4e7d27b519b1da3d7266c9c87d7861741080" translate="yes" xml:space="preserve">
          <source>References:</source>
          <target state="translated">参考文献:</target>
        </trans-unit>
        <trans-unit id="8660d17bd0736a98f236fde1aca942b73dd2ccfc" translate="yes" xml:space="preserve">
          <source>Returns a random prime with the specified number of digits when rendered in the specified base.</source>
          <target state="translated">当以指定的基数呈现时,返回一个具有指定位数的随机素数。</target>
        </trans-unit>
        <trans-unit id="bce41a017cbfed81decffd172816cfe1b081112d" translate="yes" xml:space="preserve">
          <source>Returns in a sorted list all cube roots of a mod p.  There are a bunch of easily-computed special formulae for various cases with p != 1 (mod 9); we do those first, and then if p == 1 (mod 9) we use Algorithm 4.2 in &lt;a href=&quot;https://doi.org/10.1016/S0893-9659(02)00031-9&quot;&gt;Taking Cube Roots in Zm&lt;/a&gt; by Padro and Saez, which is essentially a variation on the Tonelli-Shanks algorithm for modular square roots.</source>
          <target state="translated">在排序列表中返回mod p的所有立方根。对于p！= 1（mod 9）的各种情况，有很多易于计算的特殊公式；我们首先执行这些操作，然后如果p == 1（mod 9），我们使用Padro和Saez在&lt;a href=&quot;https://doi.org/10.1016/S0893-9659(02)00031-9&quot;&gt;以Zm&lt;/a&gt;求立方根中使用算法4.2 ，这本质上是对模块化平方根的Tonelli-Shanks算法的一种改进。</target>
        </trans-unit>
        <trans-unit id="749c2334f29b2b96a440124d9ec5143c2f80d479" translate="yes" xml:space="preserve">
          <source>Returns the</source>
          <target state="translated">返回</target>
        </trans-unit>
        <trans-unit id="2788429877dc75f10653f8ea57742f65c3ac55e8" translate="yes" xml:space="preserve">
          <source>Returns the inverse of</source>
          <target state="translated">返回</target>
        </trans-unit>
        <trans-unit id="0aa9e156d1f9731381ea0988d61a0728f288e68a" translate="yes" xml:space="preserve">
          <source>Returns the neighbors of</source>
          <target state="translated">返回</target>
        </trans-unit>
        <trans-unit id="67135413b63a47ee49da0a9ed089467cc6bcdd3c" translate="yes" xml:space="preserve">
          <source>Returns the simple continued fraction of the rational number</source>
          <target state="translated">返回有理数的简单续分数。</target>
        </trans-unit>
        <trans-unit id="8c64af7b91288bff547b95c2aa90b790e222d803" translate="yes" xml:space="preserve">
          <source>Returns the unique integer &lt;em&gt;c&lt;/em&gt; in</source>
          <target state="translated">返回in中的唯一整数&lt;em&gt;c&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c59986e700c366e985f8e3ee48529c1d17965b5b" translate="yes" xml:space="preserve">
          <source>Seeded elliptic curve factoring using the two-phase algorithm on Montgomery curves.  Helper function for</source>
          <target state="translated">在Montgomery曲线上使用两阶段算法进行种子椭圆曲线分解。輔助功能</target>
        </trans-unit>
        <trans-unit id="65b8b9fcdf7545aac85c52e7e388b3087ac70080" translate="yes" xml:space="preserve">
          <source>Smallest prime strictly greater than</source>
          <target state="translated">严格大于最小质数</target>
        </trans-unit>
        <trans-unit id="de0a3bbda725c026719a122e2ac2435b2d45b429" translate="yes" xml:space="preserve">
          <source>St&amp;oslash;rmer&amp;rsquo;s theorem asserts that for any given set</source>
          <target state="translated">斯托默定理断言对于任何给定的集合</target>
        </trans-unit>
        <trans-unit id="68b73702d7c61d8767bea5b5ab04c609a72e7a8a" translate="yes" xml:space="preserve">
          <source>Strong lucas probable primality test as described on Wikipedia.  Its false positives are a strict subset of those for</source>
          <target state="translated">维基百科上描述的强卢卡斯概率初性检验。它的假阳性是严格意义上的子集。</target>
        </trans-unit>
        <trans-unit id="2d50307e0094ceb419bc2971529dc6eda018da0d" translate="yes" xml:space="preserve">
          <source>Subtracts the polynomial</source>
          <target state="translated">减去多项式</target>
        </trans-unit>
        <trans-unit id="8f4e86cae681e592003cc72f1c8d1513b4e109ac" translate="yes" xml:space="preserve">
          <source>Sum of divisors of a natural number, raised to the &lt;em&gt;x&lt;/em&gt;&lt;sup&gt;th&lt;/sup&gt; power.  The conventional notation for this in mathematical literature is &amp;sigma;&lt;sub&gt;x&lt;/sub&gt;(</source>
          <target state="translated">自然数的约数，提高到总和&lt;em&gt;X&lt;/em&gt;&lt;sup&gt;次&lt;/sup&gt;幂。此在数学文献常规符号是&amp;sigma; &lt;sub&gt;X&lt;/sub&gt;（</target>
        </trans-unit>
        <trans-unit id="92f71fda590da013da7b5ceae7f8c11e51160c29" translate="yes" xml:space="preserve">
          <source>Sum of primes &amp;le;</source>
          <target state="translated">质数总和&amp;le;</target>
        </trans-unit>
        <trans-unit id="cba2993ee0873c0dedffdfe1947866288d3632db" translate="yes" xml:space="preserve">
          <source>Tests whether</source>
          <target state="translated">测试是否</target>
        </trans-unit>
        <trans-unit id="93ef0dd827103681fcee453b78be2ff14e1a261d" translate="yes" xml:space="preserve">
          <source>The</source>
          <target state="translated">De</target>
        </trans-unit>
        <trans-unit id="ba85a0e5b134b7d75a0b949613cddca5205a81b2" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;n&lt;/em&gt;+1 primality test: given an odd integer</source>
          <target state="translated">所述&lt;em&gt;&amp;Ntilde;&lt;/em&gt; 1素性测试：给定一个奇整数</target>
        </trans-unit>
        <trans-unit id="ad4b8705f8a743bd1955ae17b730f84b84e4376c" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;n&lt;/em&gt;-1 primality test: given an odd integer</source>
          <target state="translated">所述&lt;em&gt;&amp;Ntilde;&lt;/em&gt; -1素性测试：给定一个奇整数</target>
        </trans-unit>
        <trans-unit id="bfffb2de1764c7f6c7b23cbc9dc9333da88d067e" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;new&lt;/em&gt; functions provided by this module are as follows.  Further details, including examples and input details, are available in docstrings and accessible via the built-in</source>
          <target state="translated">该模块提供的&lt;em&gt;新&lt;/em&gt;功能如下。其他详细信息（包括示例和输入详细信息）可在文档字符串中找到，并可通过内置的文件进行访问</target>
        </trans-unit>
        <trans-unit id="61cbd33546ed0c084c047ff5de63c094329f4c2e" translate="yes" xml:space="preserve">
          <source>The Baille-Pomerance-Selfridge-Wagstaff probable primality test.  Infinitely many false positives are conjectured to exist, but none are known, and the test is known to be deterministic below 2&lt;sup&gt;64&lt;/sup&gt;.</source>
          <target state="translated">Baille-Pomerance-Selfridge-Wagstaff可能的素性检验。可以推测存在无限多个误报，但都不知道，并且在2 &lt;sup&gt;64&lt;/sup&gt;以下已知该测试是确定性的。</target>
        </trans-unit>
        <trans-unit id="8ae06f07685c373d343c2d8dc504c27dfbb71b9a" translate="yes" xml:space="preserve">
          <source>The Carmichael lambda function: the smallest positive integer &lt;em&gt;m&lt;/em&gt; such that &lt;em&gt;a&lt;/em&gt;&lt;sup&gt;m&lt;/sup&gt; &amp;equiv; 1 (mod</source>
          <target state="translated">的卡迈克尔lambda函数：最小的正整数&lt;em&gt;米&lt;/em&gt;，使得&lt;em&gt;一&lt;/em&gt;&lt;sup&gt;米&lt;/sup&gt;&amp;equiv;1（模</target>
        </trans-unit>
        <trans-unit id="8f70c2b99236794b977900e87bda53588a198add" translate="yes" xml:space="preserve">
          <source>The Jacobi symbol (</source>
          <target state="translated">雅克比符号(</target>
        </trans-unit>
        <trans-unit id="a201857a7bfba2cda4b9019dcb967216941b4505" translate="yes" xml:space="preserve">
          <source>The Kronecker symbol (</source>
          <target state="translated">Kronecker符号(</target>
        </trans-unit>
        <trans-unit id="ccae17e449c4f4559e37143960d9af689cfcf0f2" translate="yes" xml:space="preserve">
          <source>The Liouville lambda function of</source>
          <target state="translated">的Liouville lambda函数</target>
        </trans-unit>
        <trans-unit id="7005a82346ec99ebf93da31928b3d867ac8b07f7" translate="yes" xml:space="preserve">
          <source>The Lucas-Lehmer test.  Deterministically and efficiently checks whether the Mersenne number 2&lt;sup&gt;p&lt;/sup&gt;-1 is prime.</source>
          <target state="translated">Lucas-Lehmer检验。确定性和有效地检查Mersenne数2 &lt;sup&gt;p&lt;/sup&gt; -1是否为质数。</target>
        </trans-unit>
        <trans-unit id="e907e6ac5e500335ae1de374215504e8e2e4c7c3" translate="yes" xml:space="preserve">
          <source>The M&amp;ouml;bius function of</source>
          <target state="translated">的莫比乌斯函数</target>
        </trans-unit>
        <trans-unit id="2e5f733ebaf9aef7c164ef4266c033dd458c2c41" translate="yes" xml:space="preserve">
          <source>The arithmetic derivative of</source>
          <target state="translated">的算术导数</target>
        </trans-unit>
        <trans-unit id="06a3a8763738b50b1bea9bc6ecc0b4944b0219f5" translate="yes" xml:space="preserve">
          <source>The binomial coefficient nCr(</source>
          <target state="translated">二项式系数nCr(</target>
        </trans-unit>
        <trans-unit id="20bc83d44388278bb1eba7b31066e9cfcd434670" translate="yes" xml:space="preserve">
          <source>The general binary linear recursion.  Exactly like</source>
          <target state="translated">一般的二元线性递归。完全像</target>
        </trans-unit>
        <trans-unit id="04eb27028fb2518326a0aeecde4bff1a8418d50b" translate="yes" xml:space="preserve">
          <source>The general homogeneous linear recursion.  If</source>
          <target state="translated">一般同质线性递推。如果</target>
        </trans-unit>
        <trans-unit id="8f9383265e796810dd164492e5d2c8daca1339a1" translate="yes" xml:space="preserve">
          <source>The general homogenous linear recursion: we generate in order the sequence defined by</source>
          <target state="translated">一般同质线性递归:我们依次生成由以下定义的序列</target>
        </trans-unit>
        <trans-unit id="1ec1aac1b9258807d33e9aeef54c422c605055ac" translate="yes" xml:space="preserve">
          <source>The greedy algorithm for Egyptian fraction expansion; also called the Fibonacci-Sylvester algorithm.</source>
          <target state="translated">埃及分数膨胀的贪婪算法;也叫斐波那契-西尔维斯特算法。</target>
        </trans-unit>
        <trans-unit id="526c959fba4910931aebf2ea03ebd2ff252a4f3a" translate="yes" xml:space="preserve">
          <source>The least common multiple of any number of values.</source>
          <target state="translated">任何数值的最小公倍数。</target>
        </trans-unit>
        <trans-unit id="164b211a3a1e3dd384d29da09a5f523fe07a1c1c" translate="yes" xml:space="preserve">
          <source>The strong probable primality test (aka single-round Miller-Rabin).</source>
          <target state="translated">强概率首要性检验(又称单轮米勒-拉宾)。</target>
        </trans-unit>
        <trans-unit id="93dc4e2b35f32f64da2b01b8733e27df5aac6ecf" translate="yes" xml:space="preserve">
          <source>The workhorse integer factorizer.  Generates the prime factors of the input.  Factors that appear &lt;em&gt;x&lt;/em&gt; times are yielded &lt;em&gt;x&lt;/em&gt; times.</source>
          <target state="translated">主力整数分解器。生成输入的主要因子。出现&lt;em&gt;x&lt;/em&gt;次的因子产生&lt;em&gt;x&lt;/em&gt;次。</target>
        </trans-unit>
        <trans-unit id="a95e03a7b14d113a036a7e2892678ddcf0dc5672" translate="yes" xml:space="preserve">
          <source>The workhorse primality test.  It is a BPSW primality test variant: we use the strong Lucas PRP test and preface the computation with trial division for speed.  No composites are known to pass the test, though it is suspected that infinitely many will do so.  There are definitely no such errors below 2&lt;sup&gt;64&lt;/sup&gt;.  This function is mainly a streamlined version of</source>
          <target state="translated">主力素性测试。这是BPSW素数测试的一种变体：我们使用强大的Lucas PRP测试，并在计算前加试算以提高速度。尚无复合材料通过测试，尽管怀疑有很多复合材料可以通过测试。低于2 &lt;sup&gt;64&lt;/sup&gt;绝对没有这种错误。此功能主要是的简化版本</target>
        </trans-unit>
        <trans-unit id="a76f1026ab482ee5fefe7adb3516df5ecd470401" translate="yes" xml:space="preserve">
          <source>This function solves the generalized Pell equation: we find all non-negative integers (&lt;em&gt;x&lt;/em&gt;, &lt;em&gt;y&lt;/em&gt;) such that &lt;em&gt;x&lt;/em&gt;&lt;sup&gt;2&lt;/sup&gt; -</source>
          <target state="translated">此功能解决了广义佩尔方程：我们发现所有的非负整数（&lt;em&gt;X&lt;/em&gt;，&lt;em&gt;Y ^&lt;/em&gt;），使得&lt;em&gt;X &lt;/em&gt;&lt;sup&gt;2&lt;/sup&gt; -</target>
        </trans-unit>
        <trans-unit id="640dc11e3dabf59ed510e1ca891dc62e28eccc72" translate="yes" xml:space="preserve">
          <source>This is a module for basic math in the general vicinity of computational number theory.  It includes functions associated with primality testing, integer factoring, prime counting, linear recurrences, modular square roots, generalized Pell equations, the classic arithmetical functions, continued fractions, partitions, St&amp;oslash;rmer&amp;rsquo;s theorem, smooth numbers, and Dirichlet convolution.  Integer arithmetic is used wherever feasible.</source>
          <target state="translated">在计算数论的一般范围内，这是基础数学的模块。它包括与素数测试，整数分解，素数计数，线性递归，模平方根，广义Pell方程，经典算术函数，连续分数，分区，St&amp;oslash;rmer定理，光滑数和Dirichlet卷积相关的函数。在可行的情况下使用整数算法。</target>
        </trans-unit>
        <trans-unit id="335698cb19b6ed9b7f11b37679af97f02f222696" translate="yes" xml:space="preserve">
          <source>This package imports items from</source>
          <target state="translated">这个软件包从</target>
        </trans-unit>
        <trans-unit id="878399c850ec7dd06a4fb5120e12b31d8e51f329" translate="yes" xml:space="preserve">
          <source>This returns a function that is the Dirichlet convolution of</source>
          <target state="translated">这将返回一个函数,该函数是以下的Dirichlet卷积</target>
        </trans-unit>
        <trans-unit id="be0f64b2c2ec8d3f096587c95f72324b81820991" translate="yes" xml:space="preserve">
          <source>U&lt;sub&gt;0&lt;/sub&gt;, U&lt;sub&gt;1&lt;/sub&gt;, V&lt;sub&gt;0&lt;/sub&gt;, V&lt;sub&gt;1&lt;/sub&gt; = 0, 1, 2,</source>
          <target state="translated">U &lt;sub&gt;0&lt;/sub&gt;，U &lt;sub&gt;1&lt;/sub&gt;，V &lt;sub&gt;0&lt;/sub&gt;，V &lt;sub&gt;1&lt;/sub&gt; = 0、1、2</target>
        </trans-unit>
        <trans-unit id="6f543f0fb6ad95eac25dec517b35aea6b6271026" translate="yes" xml:space="preserve">
          <source>U&lt;sub&gt;n&lt;/sub&gt; =</source>
          <target state="translated">U &lt;sub&gt;n&lt;/sub&gt; =</target>
        </trans-unit>
        <trans-unit id="53484ab410c786bc6dca5bfa962043fa4e14f083" translate="yes" xml:space="preserve">
          <source>Uses Hensel lifting to generate with some efficiency all zeros of a polynomial modulo a prime power.</source>
          <target state="translated">使用Hensel提升,以一定的效率生成多项式的所有零点的素数模数。</target>
        </trans-unit>
        <trans-unit id="650cb1ea26f3f3435a90bca9e814486d1548f503" translate="yes" xml:space="preserve">
          <source>Uses a sieve to compute the M&amp;ouml;bius function of all whole numbers strictly less than the input.</source>
          <target state="translated">使用筛子来计算所有比输入严格少的整数的M&amp;ouml;bius函数。</target>
        </trans-unit>
        <trans-unit id="1f679058b8f35fc3f4aca9d452840fa97b4831ef" translate="yes" xml:space="preserve">
          <source>Uses a sieve to compute the factorizations of all whole numbers strictly less than the input.  This uses a lot of memory; if you aren&amp;rsquo;t after the factors directly, it&amp;rsquo;s usually better to write a dedicated function for whatever it is that you actually want.</source>
          <target state="translated">使用筛子来计算严格小于输入的所有整数的因式分解。这会占用大量内存。如果您不直接考虑这些因素，通常最好针对您的实际需求编写专用的函数。</target>
        </trans-unit>
        <trans-unit id="268fb65f2f3e2f02c488439bf119d606ca64bad0" translate="yes" xml:space="preserve">
          <source>Uses a sieve to compute the number of divisors of all whole numbers strictly less than the input.</source>
          <target state="translated">使用筛子来计算严格小于输入的所有整数的除数。</target>
        </trans-unit>
        <trans-unit id="fe1dbbb529e7c4a4d51aa8fc84b2050e88eb99c6" translate="yes" xml:space="preserve">
          <source>Uses a sieve to compute the totients up to (and including)</source>
          <target state="translated">使用筛子来计算直至(并包括)Totients。</target>
        </trans-unit>
        <trans-unit id="6c76d71e87a267442fe63baeaaf864ce58a75988" translate="yes" xml:space="preserve">
          <source>Uses the &lt;a href=&quot;http://mathworld.wolfram.com/GramSeries.html&quot;&gt;Gram series&lt;/a&gt; to compute &lt;a href=&quot;http://mathworld.wolfram.com/RiemannPrimeCountingFunction.html&quot;&gt;Riemann&amp;rsquo;s R function&lt;/a&gt;, which is a rather good approximation to</source>
          <target state="translated">使用&lt;a href=&quot;http://mathworld.wolfram.com/GramSeries.html&quot;&gt;Gram级数&lt;/a&gt;计算&lt;a href=&quot;http://mathworld.wolfram.com/RiemannPrimeCountingFunction.html&quot;&gt;Riemann的R函数&lt;/a&gt;，该函数非常近似于</target>
        </trans-unit>
        <trans-unit id="4a7d5b6d4db905be914b564683d92a8fcbe1ec25" translate="yes" xml:space="preserve">
          <source>V&lt;sub&gt;n&lt;/sub&gt; =</source>
          <target state="translated">V &lt;sub&gt;n&lt;/sub&gt; =</target>
        </trans-unit>
        <trans-unit id="50e5378d732557779f1154c3575db8e23bb5b3ab" translate="yes" xml:space="preserve">
          <source>We attempt to import</source>
          <target state="translated">我们尝试导入</target>
        </trans-unit>
        <trans-unit id="6c9c8399feaa2614db53d41720cd228e01ec2def" translate="yes" xml:space="preserve">
          <source>We make a few imports:</source>
          <target state="translated">我们做了一些进口。</target>
        </trans-unit>
        <trans-unit id="18540796a32eeba141c50da1b37a95f4334c7c5a" translate="yes" xml:space="preserve">
          <source>We yield only those solutions with &lt;em&gt;x&lt;/em&gt; &amp;le;</source>
          <target state="translated">我们只产生与解决方案&lt;em&gt;X&lt;/em&gt; &amp;le;</target>
        </trans-unit>
        <trans-unit id="3bf3f71c4d3d91d72b09100088bc05f6648939f4" translate="yes" xml:space="preserve">
          <source>ZeroDivisionError</source>
          <target state="translated">零除法错误</target>
        </trans-unit>
        <trans-unit id="d7dbd4deb34730f22194a18ec2062259b1eeb01d" translate="yes" xml:space="preserve">
          <source>[a,b,c,...,d]</source>
          <target state="translated">[A B C D]</target>
        </trans-unit>
        <trans-unit id="6617db25b376b8717487a1efee6f5300001877f1" translate="yes" xml:space="preserve">
          <source>] with its factorization.  Uses Adam Kalai&amp;rsquo;s algorithm, which uses in the average case O(log(</source>
          <target state="translated">]及其分解。使用Adam Kalai的算法，该算法平均使用O（log（</target>
        </trans-unit>
        <trans-unit id="86f7e437faa5a7fce15d1ddcb9eaeaea377667b8" translate="yes" xml:space="preserve">
          <source>a</source>
          <target state="translated">a</target>
        </trans-unit>
        <trans-unit id="a9993e364706816aba3e25717850c26c9cd0d89d" translate="yes" xml:space="preserve">
          <source>abc</source>
          <target state="translated">abc</target>
        </trans-unit>
        <trans-unit id="1c0aa26e5d84363b3acc6bf9fbb155954590cbdc" translate="yes" xml:space="preserve">
          <source>abc[0]</source>
          <target state="translated">abc[0]</target>
        </trans-unit>
        <trans-unit id="3e9b0dc45ae3f876b91da0bb3e60fdb7a800b813" translate="yes" xml:space="preserve">
          <source>altseriesaccel</source>
          <target state="translated">系列加速器</target>
        </trans-unit>
        <trans-unit id="cffa50a32cb13a240d705317bcec65dd1f31b6ad" translate="yes" xml:space="preserve">
          <source>and</source>
          <target state="translated">そして</target>
        </trans-unit>
        <trans-unit id="423e3677a59be7685f327a54c3d1687a5358b06d" translate="yes" xml:space="preserve">
          <source>and any</source>
          <target state="translated">和任何</target>
        </trans-unit>
        <trans-unit id="c07674c7f138dc32ab84db4d0b94deee67cf065c" translate="yes" xml:space="preserve">
          <source>and correspond directly to those same operators in Python3 source code.  The acceptable unary operators are</source>
          <target state="translated">并直接对应于Python3源代码中的那些相同的运算符。可接受的单子运算符是</target>
        </trans-unit>
        <trans-unit id="7f00744592a776e5ffc4e1d2ec293d7812083856" translate="yes" xml:space="preserve">
          <source>and reduces their coefficients mod</source>
          <target state="translated">并减少其系数模</target>
        </trans-unit>
        <trans-unit id="d16ffb80cfb8fbbc45a3e956afc9384e9d88d3a4" translate="yes" xml:space="preserve">
          <source>and returns the quotient and remainder.  The coefficients are interpreted mod</source>
          <target state="translated">并返回商和余数。系数的解释是mod</target>
        </trans-unit>
        <trans-unit id="8ae7da769a9bfb836cc90735badab7103384f956" translate="yes" xml:space="preserve">
          <source>and returns them in a sorted list.</source>
          <target state="translated">并以排序列表的方式返回它们。</target>
        </trans-unit>
        <trans-unit id="b083fda8a38221bc976c25ada22cbbc125bf84c5" translate="yes" xml:space="preserve">
          <source>and we have the recursions</source>
          <target state="translated">和我们的递归</target>
        </trans-unit>
        <trans-unit id="22a2fa7aecbb23be92b1456ec37e8d661d6284fa" translate="yes" xml:space="preserve">
          <source>appears</source>
          <target state="translated">出现</target>
        </trans-unit>
        <trans-unit id="e40428569577cb101cb980e869d504664b7d8cb9" translate="yes" xml:space="preserve">
          <source>are for internal use only.</source>
          <target state="translated">仅供内部使用。</target>
        </trans-unit>
        <trans-unit id="7eebdb0c22367682ed44a609d37dde0a356d56a1" translate="yes" xml:space="preserve">
          <source>argument indicates that we are to assume an effective abc conjecture of the form &lt;em&gt;c&lt;/em&gt; &amp;lt;</source>
          <target state="translated">参数表明我们将假设有效的abc猜想形式为&lt;em&gt;c&lt;/em&gt; &amp;lt;</target>
        </trans-unit>
        <trans-unit id="80f3d3aa79645a7dc0c6783938d48bbec07bb175" translate="yes" xml:space="preserve">
          <source>argument is for memoization.</source>
          <target state="translated">争论是为了记忆化。</target>
        </trans-unit>
        <trans-unit id="d6bcc82fa6253c3c81129dc64664935466672afb" translate="yes" xml:space="preserve">
          <source>as an initial estimate, computing</source>
          <target state="translated">作为初步估计,计算</target>
        </trans-unit>
        <trans-unit id="28e86607ff751be3dbde36b1a32f0a5776b94eba" translate="yes" xml:space="preserve">
          <source>as appropriate.  This optimization becomes more noticeable as the factoring becomes more difficult.</source>
          <target state="translated">视情况而定。随着保理难度的增加,这种优化会更加明显。</target>
        </trans-unit>
        <trans-unit id="b9d67952547d2d3bfbc0bfae7738b9137def3575" translate="yes" xml:space="preserve">
          <source>as the first component and the relevant power as the second component.  If</source>
          <target state="translated">作为第一分量,相关功率作为第二分量。如果</target>
        </trans-unit>
        <trans-unit id="8b0167946be499c0984a56eedbabe88e5635374b" translate="yes" xml:space="preserve">
          <source>at the end, so we handle separately the case where this is zero.</source>
          <target state="translated">在最后,所以我们分别处理这个为零的情况。</target>
        </trans-unit>
        <trans-unit id="e9d71f5ee7c92d6dc9e92ffdad17b8bd49418f98" translate="yes" xml:space="preserve">
          <source>b</source>
          <target state="translated">b</target>
        </trans-unit>
        <trans-unit id="5e45d064f99e8d1f88b05bb3c44e7e3075a0519b" translate="yes" xml:space="preserve">
          <source>bail</source>
          <target state="translated">保释金</target>
        </trans-unit>
        <trans-unit id="73c57301af9ef7b2b0d5217fa1fe9d631261d791" translate="yes" xml:space="preserve">
          <source>be a function on the positive integers, let</source>
          <target state="translated">是正整数上的函数,让</target>
        </trans-unit>
        <trans-unit id="3df79c1e257a045b9ac776f1735507406ca949bb" translate="yes" xml:space="preserve">
          <source>be a positive integer, and let</source>
          <target state="translated">是一个正整数,并让</target>
        </trans-unit>
        <trans-unit id="190cd0c12bb8723300924a9625c187781783a04a" translate="yes" xml:space="preserve">
          <source>be integers such that</source>
          <target state="translated">是整数,以至于</target>
        </trans-unit>
        <trans-unit id="e86873283164dede4e8a6cce779c4e7fc5af7b01" translate="yes" xml:space="preserve">
          <source>bool(pell(D,N)[0])</source>
          <target state="translated">bool(pell(D,N)[0])</target>
        </trans-unit>
        <trans-unit id="5d25966d3e4427fff6f97ed668cf8e9d4ad58871" translate="yes" xml:space="preserve">
          <source>bpsw</source>
          <target state="translated">bpsw</target>
        </trans-unit>
        <trans-unit id="2cdf265410b6b700b91d7e3971139954d36d0f32" translate="yes" xml:space="preserve">
          <source>by applying</source>
          <target state="translated">通过应用</target>
        </trans-unit>
        <trans-unit id="25157648db89193cfdd9a993e256ec3b08c238c5" translate="yes" xml:space="preserve">
          <source>by the polynomial</source>
          <target state="translated">以多项式</target>
        </trans-unit>
        <trans-unit id="84a516841ba77a5b4648de2cd0dfcb30ea46dbb4" translate="yes" xml:space="preserve">
          <source>c</source>
          <target state="translated">c</target>
        </trans-unit>
        <trans-unit id="c4141200bfaed15b39f7442caa7d497f9c7a7989" translate="yes" xml:space="preserve">
          <source>coefs[k]</source>
          <target state="translated">coefs[k]</target>
        </trans-unit>
        <trans-unit id="0b9702797aab9ff35839ab8ce2e06faf7475d013" translate="yes" xml:space="preserve">
          <source>cubicintroots</source>
          <target state="translated">立方根</target>
        </trans-unit>
        <trans-unit id="d6269a84026917e0fccb6e13db680fd34c155dc4" translate="yes" xml:space="preserve">
          <source>cubicintrootsgiven</source>
          <target state="translated">立方根</target>
        </trans-unit>
        <trans-unit id="3c363836cf4e16666669a25da280a1865c2d2874" translate="yes" xml:space="preserve">
          <source>d</source>
          <target state="translated">d</target>
        </trans-unit>
        <trans-unit id="01b75b0700101b4727bfc89c1cd712b5c78499d8" translate="yes" xml:space="preserve">
          <source>dirconv</source>
          <target state="translated">dirconv</target>
        </trans-unit>
        <trans-unit id="d786253dcca71d5ff20ce9683b44794b24b476a5" translate="yes" xml:space="preserve">
          <source>dirichletinverse(f)</source>
          <target state="translated">dirichletinverse(f)</target>
        </trans-unit>
        <trans-unit id="03e669c63f3bfb43b5c8c3d259c64bb578bf84b5" translate="yes" xml:space="preserve">
          <source>dirichletinverse(f)(n)</source>
          <target state="translated">dirichletinverse(f)(n)</target>
        </trans-unit>
        <trans-unit id="5c58ad317c477f6ef15fd5698c2c3b7cd842cccd" translate="yes" xml:space="preserve">
          <source>divisors_factored(n)</source>
          <target state="translated">divisors_factorored(n)</target>
        </trans-unit>
        <trans-unit id="58e6b3a414a1e090dfc6029add0f3555ccba127f" translate="yes" xml:space="preserve">
          <source>e</source>
          <target state="translated">e</target>
        </trans-unit>
        <trans-unit id="734f507c6428f42e9214bdadddde151f7712696e" translate="yes" xml:space="preserve">
          <source>ecm</source>
          <target state="translated">电子厘米</target>
        </trans-unit>
        <trans-unit id="0c236606d901bf5b5cffebee509cbfc994dbd6c2" translate="yes" xml:space="preserve">
          <source>ecmparams</source>
          <target state="translated">谱系</target>
        </trans-unit>
        <trans-unit id="338362566cc17e29060463088b729a5471909d9a" translate="yes" xml:space="preserve">
          <source>efficiently.</source>
          <target state="translated">有效地。</target>
        </trans-unit>
        <trans-unit id="4a0a19218e082a343a1b17e5333409af9d98f0f5" translate="yes" xml:space="preserve">
          <source>f</source>
          <target state="translated">f</target>
        </trans-unit>
        <trans-unit id="315206ca84dc4ce4fe812e2863ee8eb264ac0dd0" translate="yes" xml:space="preserve">
          <source>f == []</source>
          <target state="translated">f ==[]</target>
        </trans-unit>
        <trans-unit id="b6af140f0f8a203779ba6dfe7596f459c4f59ac2" translate="yes" xml:space="preserve">
          <source>f == totient</source>
          <target state="translated">f ==totient</target>
        </trans-unit>
        <trans-unit id="647df68c0784177b0691d73d2f9e3d8cd45d5e46" translate="yes" xml:space="preserve">
          <source>ffac=True</source>
          <target state="translated">ffac=True</target>
        </trans-unit>
        <trans-unit id="4031de3cf69373e17eedea3cc0ca9bb57f697583" translate="yes" xml:space="preserve">
          <source>fibo(0)</source>
          <target state="translated">fibo(0)</target>
        </trans-unit>
        <trans-unit id="c8aae4bf7819bae8ea1d14dbff76238d6f3c650d" translate="yes" xml:space="preserve">
          <source>fibo(1)</source>
          <target state="translated">fibo(1)</target>
        </trans-unit>
        <trans-unit id="4205d665cf378fdbadc87b71e15cd669937c2d05" translate="yes" xml:space="preserve">
          <source>fibo(2)</source>
          <target state="translated">菲博(2)</target>
        </trans-unit>
        <trans-unit id="43eef9a62abb8b1e1654f8a890aae054abffa82b" translate="yes" xml:space="preserve">
          <source>for</source>
          <target state="translated">对于</target>
        </trans-unit>
        <trans-unit id="a7668f7b918080cace2b7647399809cb46f37464" translate="yes" xml:space="preserve">
          <source>for any such</source>
          <target state="translated">对于任何此类</target>
        </trans-unit>
        <trans-unit id="d47ef507fd3562f713ba06d3c342a8541272e806" translate="yes" xml:space="preserve">
          <source>fractions</source>
          <target state="translated">小数</target>
        </trans-unit>
        <trans-unit id="0b1e95cfd9775191a7224d0a218ae79187e80c1d" translate="yes" xml:space="preserve">
          <source>from</source>
          <target state="translated">à partir de</target>
        </trans-unit>
        <trans-unit id="cac02ec1a476ed80dfd51b02515cb2a3bd581ae2" translate="yes" xml:space="preserve">
          <source>function.</source>
          <target state="translated">职能。</target>
        </trans-unit>
        <trans-unit id="54fd1711209fb1c0781092374132c66e79e2241b" translate="yes" xml:space="preserve">
          <source>g</source>
          <target state="translated">g</target>
        </trans-unit>
        <trans-unit id="6f82a25f8a9d9d0f82e257528ce180c65281f0be" translate="yes" xml:space="preserve">
          <source>g == mobius</source>
          <target state="translated">g ==mobius</target>
        </trans-unit>
        <trans-unit id="08da69a048896f64e8d2f2f7e539609be66ba12a" translate="yes" xml:space="preserve">
          <source>gcd(D,m)!=1</source>
          <target state="translated">gcd(D,m)!=1。</target>
        </trans-unit>
        <trans-unit id="4739319abf9070ef0b0e2a73224820ae70488aa6" translate="yes" xml:space="preserve">
          <source>gen</source>
          <target state="translated">遗传</target>
        </trans-unit>
        <trans-unit id="7a164e09344c9505c271c6d424b2da33c3fd3e5b" translate="yes" xml:space="preserve">
          <source>gfac=True</source>
          <target state="translated">gfac=True</target>
        </trans-unit>
        <trans-unit id="7b23189c90eff94402b89369c93f483db6c41344" translate="yes" xml:space="preserve">
          <source>given two bounds and a seed.</source>
          <target state="translated">给定两个边界和一个种子。</target>
        </trans-unit>
        <trans-unit id="55359a446e39ee32617d7d3eea49ead78bddb1c6" translate="yes" xml:space="preserve">
          <source>gmpy2</source>
          <target state="translated">gmpy2</target>
        </trans-unit>
        <trans-unit id="e754a4d398e711f0a035b3fd04202c34a51014bb" translate="yes" xml:space="preserve">
          <source>has a repeated prime factor.</source>
          <target state="translated">具有重复的质因数。</target>
        </trans-unit>
        <trans-unit id="443e0256a4f3233c27654ce6540d09aa085b841d" translate="yes" xml:space="preserve">
          <source>heapq</source>
          <target state="translated">堆栈</target>
        </trans-unit>
        <trans-unit id="92005ecf3788faea8346a7919fba0232188561ab" translate="yes" xml:space="preserve">
          <source>help</source>
          <target state="translated">帮助</target>
        </trans-unit>
        <trans-unit id="958f57f57d72a30f329ee5538f21b0257a49a46e" translate="yes" xml:space="preserve">
          <source>if</source>
          <target state="translated">如果</target>
        </trans-unit>
        <trans-unit id="5d98b52e53a617b661aa195fa572770a19c4f092" translate="yes" xml:space="preserve">
          <source>if it isn&amp;rsquo;t.</source>
          <target state="translated">如果不是这样。</target>
        </trans-unit>
        <trans-unit id="0ee6fa9ba4ab0cdaaf258ad7f3d55d7b283fd5be" translate="yes" xml:space="preserve">
          <source>if no such prime exists.</source>
          <target state="translated">如果没有这样的质数存在。</target>
        </trans-unit>
        <trans-unit id="a8ce66926ac0d9289255d559e051bbcaf199f26f" translate="yes" xml:space="preserve">
          <source>in such situations is quite a bit slower due to the time-complexity of multiplication.  However, the size of the problem required to make this superior to</source>
          <target state="translated">在这种情况下,由于乘法的时间复杂性,速度要慢很多。然而,由于所需问题的大小,使其优于</target>
        </trans-unit>
        <trans-unit id="faca05ba26b44ae973be06d817f90318ac1402ce" translate="yes" xml:space="preserve">
          <source>in the Farey sequence of maximum denominator</source>
          <target state="translated">在最大分母的Farey序列中。</target>
        </trans-unit>
        <trans-unit id="55fcda190a7af7698ada9d66dd1192d726e588d5" translate="yes" xml:space="preserve">
          <source>instead and feed those factored divisors into</source>
          <target state="translated">而不是将这些因式除数输入到</target>
        </trans-unit>
        <trans-unit id="370b5e19dba599f512446f6d2f8b476541cdea11" translate="yes" xml:space="preserve">
          <source>into a dictionary with primes as keys and multiplicities as values.</source>
          <target state="translated">变成一个以质数为键、乘数为值的字典。</target>
        </trans-unit>
        <trans-unit id="b47f363e2b430c0647f14deea3eced9b0ef300ce" translate="yes" xml:space="preserve">
          <source>is</source>
          <target state="translated">is</target>
        </trans-unit>
        <trans-unit id="d2c35916878942bd128e969cbd953d99f1f91da4" translate="yes" xml:space="preserve">
          <source>is a cache of zeta values.</source>
          <target state="translated">是一个zeta值的缓存。</target>
        </trans-unit>
        <trans-unit id="49c27f5f42d7861345685e0bd678d6535d255e89" translate="yes" xml:space="preserve">
          <source>is a large real number.</source>
          <target state="translated">是一个大的实数。</target>
        </trans-unit>
        <trans-unit id="37953ec8e60d66fab1e5fe90650d66d06c0ca1eb" translate="yes" xml:space="preserve">
          <source>is a list of primes.</source>
          <target state="translated">是一个质数的列表。</target>
        </trans-unit>
        <trans-unit id="f92be3654d8664bc640994b103f65c28ef1c9260" translate="yes" xml:space="preserve">
          <source>is a nonsquare, then there are no further solutions.</source>
          <target state="translated">是一个非正方形,那么就没有进一步的解决方案。</target>
        </trans-unit>
        <trans-unit id="341599309574d8056f163a056a090a62f656d1c6" translate="yes" xml:space="preserve">
          <source>is a nonsquare, then there are no solutions.</source>
          <target state="translated">是一个非正方形,那么就没有解。</target>
        </trans-unit>
        <trans-unit id="80f9364c732c11c24a040bca417f9a10802782d7" translate="yes" xml:space="preserve">
          <source>is a nonsquare, then we run the PQa/LMM algorithms: we produce a set of primitive solutions; if this set is empty, there are no solutions; if this set has members, an ininite set of solutions can be produced by repeatedly composing them with the fundamental solution of &lt;em&gt;x&lt;/em&gt;&lt;sup&gt;2&lt;/sup&gt; -</source>
          <target state="translated">是一个非平方，然后我们运行PQa / LMM算法：我们产生了一组原始解；如果此集合为空，则没有解决方案；如果该组有成员，一个ininite一套解决方案可以通过用的基本溶液反复将它们组成来制备&lt;em&gt;X &lt;/em&gt;&lt;sup&gt;2&lt;/sup&gt; -</target>
        </trans-unit>
        <trans-unit id="64b6d8423fedee44b9be667f778516d17fd9a6ef" translate="yes" xml:space="preserve">
          <source>is a perfect</source>
          <target state="translated">堪称完美</target>
        </trans-unit>
        <trans-unit id="64b01ce8605073ca5d678688bf82d0be37b37679" translate="yes" xml:space="preserve">
          <source>is a perfect power, return a tuple containing the largest integer that, when squares/cubed/etc, yields</source>
          <target state="translated">是一个完全幂,返回一个包含最大整数的元组,当平方/立方体/等等时,产生了</target>
        </trans-unit>
        <trans-unit id="898e94e521c1d947cb6950eaefe9dcdaf235b4d4" translate="yes" xml:space="preserve">
          <source>is a practical number &amp;ndash; i.e., whether every integer from 1 through</source>
          <target state="translated">是一个实际数字&amp;ndash;即，是否每个整数从1到</target>
        </trans-unit>
        <trans-unit id="a15b27d2d0f9b5a9d370396f415a9edeff569d20" translate="yes" xml:space="preserve">
          <source>is a prime and</source>
          <target state="translated">是一个质数,并且</target>
        </trans-unit>
        <trans-unit id="fbaef629941ab443a5ffeaa9ce47284805e6064a" translate="yes" xml:space="preserve">
          <source>is a quadratic residue mod</source>
          <target state="translated">是二次元余数模</target>
        </trans-unit>
        <trans-unit id="fc91dc9cd2dbb46bd4d18da2d9eedb19d417f61f" translate="yes" xml:space="preserve">
          <source>is a quadratic residue modulo</source>
          <target state="translated">是二次元余数模数。</target>
        </trans-unit>
        <trans-unit id="38cfc281fba7a65b9cd32bd53f871e16a91c971c" translate="yes" xml:space="preserve">
          <source>is a square, then the number of solutions will be at most finite.  This case is solved by factoring.</source>
          <target state="translated">是一个平方,那么解的数量最多只能是有限的。这种情况下,可以用因子法来解决。</target>
        </trans-unit>
        <trans-unit id="76ac02c7f30e492c27f4726d0fce17f942f33edc" translate="yes" xml:space="preserve">
          <source>is a square, then there are infinitely many solutions, parametrized by (&amp;radic;</source>
          <target state="translated">是一个正方形，那么有无数个解，其参数为（&amp;radic;</target>
        </trans-unit>
        <trans-unit id="c9072bff9a277a0980d8f18701c036a3e095ab9e" translate="yes" xml:space="preserve">
          <source>is a square, then there are infinitely many solutions, parametrized by (&lt;em&gt;t&lt;/em&gt;&amp;middot;&amp;radic;</source>
          <target state="translated">是一个正方形，那么有无穷多个解，其参数为（&lt;em&gt;t&lt;/em&gt; &amp;middot;&amp;radic;</target>
        </trans-unit>
        <trans-unit id="b29247d5558ad7494843a5a1d98fab25b653c0bd" translate="yes" xml:space="preserve">
          <source>is an</source>
          <target state="translated">是一个</target>
        </trans-unit>
        <trans-unit id="875e5add0137d5a23ab53431827f809f09c84dc1" translate="yes" xml:space="preserve">
          <source>is called and we will call</source>
          <target state="translated">被称为,我们将称为</target>
        </trans-unit>
        <trans-unit id="6fd0c436112330430676f2dd96c3c0922cc6a799" translate="yes" xml:space="preserve">
          <source>is concerned with the general equation, which may or may not have trivial solutions, and as such yields all non-negative solutions, whereas this function is concerned only with the simple Pell equation, which always has an infinite family of positive solutions generated from a single primitive solution and always has the trivial solution (1,0).</source>
          <target state="translated">关注的是一般方程,它可能有也可能没有琐碎的解,因此会产生所有非负解,而这个函数只关注简单的Pell方程,它总是有一个由单一的基数解产生的无限的正解族,并且总是有琐碎的解(1,0)。</target>
        </trans-unit>
        <trans-unit id="8bea43bb939ee6ac17ba706d8fae419a2185708b" translate="yes" xml:space="preserve">
          <source>is even.</source>
          <target state="translated">是偶。</target>
        </trans-unit>
        <trans-unit id="68f46528d8fc83cad934a1f14d8a844237021693" translate="yes" xml:space="preserve">
          <source>is handled properly.</source>
          <target state="translated">妥善处理。</target>
        </trans-unit>
        <trans-unit id="48b31bfadc2521825ca08da6c36aa727b913ef52" translate="yes" xml:space="preserve">
          <source>is machine-indistinguishable from 1.0 &amp;mdash; in particular, when</source>
          <target state="translated">与1.0在机器上没有区别-特别是当</target>
        </trans-unit>
        <trans-unit id="10534b02e6a6fc675401f5f0d9796a5234abd865" translate="yes" xml:space="preserve">
          <source>is not a perfect power, return</source>
          <target state="translated">势不两立</target>
        </trans-unit>
        <trans-unit id="f455949b391b3e0789873e7c48e4188a0e154490" translate="yes" xml:space="preserve">
          <source>is not coprime to</source>
          <target state="translated">并不等同于</target>
        </trans-unit>
        <trans-unit id="2fab3805742595a909144bab6b06c2c73eaa8cdb" translate="yes" xml:space="preserve">
          <source>is prime, then</source>
          <target state="translated">是素数,那么</target>
        </trans-unit>
        <trans-unit id="4c6563279f43ae5dc1a83638491dbb425bc13151" translate="yes" xml:space="preserve">
          <source>is prime, we immediately return</source>
          <target state="translated">是素数,我们立即返回</target>
        </trans-unit>
        <trans-unit id="4155e05f59fd1e42f3aef2d244af0456c4369b33" translate="yes" xml:space="preserve">
          <source>is prime.  If the provided (partial) factorization of</source>
          <target state="translated">是素数。如果所提供的</target>
        </trans-unit>
        <trans-unit id="0c686c58ef3a3ae2d4c671c5ce861d019d03c96f" translate="yes" xml:space="preserve">
          <source>is quite large, so</source>
          <target state="translated">是相当大的,所以</target>
        </trans-unit>
        <trans-unit id="91b2fff06e4ed4d3cfda3e66159035cfcf06cc84" translate="yes" xml:space="preserve">
          <source>is raised to the</source>
          <target state="translated">被提升到</target>
        </trans-unit>
        <trans-unit id="9f389ffaacb07667243a85f2131fec4cdd1b17b4" translate="yes" xml:space="preserve">
          <source>is squarefree with an even number of prime factors, -1 if</source>
          <target state="translated">是无平方的,有偶数的质因数,-1,如果</target>
        </trans-unit>
        <trans-unit id="477716014edf48baa262a068be894f69d10aacda" translate="yes" xml:space="preserve">
          <source>is squarefree with an odd number of prime factors, and 0 if</source>
          <target state="translated">是不含奇数质因数的平方,如果</target>
        </trans-unit>
        <trans-unit id="f9d8d585ccc0941d1f852facf4c17ea42f55ad55" translate="yes" xml:space="preserve">
          <source>is supplied, terms are computed modulo</source>
          <target state="translated">提供的条件下,条款的计算是以</target>
        </trans-unit>
        <trans-unit id="7f0b64bf2ff0248f24db942aa41c34c4454057e8" translate="yes" xml:space="preserve">
          <source>is supplied, then we compute the sequence modulo</source>
          <target state="translated">提供了,那么我们计算序列的模数为</target>
        </trans-unit>
        <trans-unit id="9d5047cbf7ceac0110790548ce311421463adfa5" translate="yes" xml:space="preserve">
          <source>is the coefficient of the &lt;em&gt;x&lt;/em&gt;&lt;sup&gt;k&lt;/sup&gt; term.  For low-degree polynomials, explicit formulae are used; for degrees 5 and higher, we compute it by taking the determinant (using this package&amp;rsquo;s determinant() function) of the Sylvester matrix of the input and its derivative.  This in turn is calculated by the Schur determinant identity.  Note that this has the effect of setting the discriminant of a linear polynomial to 1 (which is conventional) and that of a constant to 0.</source>
          <target state="translated">是&lt;em&gt;x &lt;/em&gt;&lt;sup&gt;k&lt;/sup&gt;项的系数。对于低次多项式，使用显式公式。对于5度或更高的度数，我们通过采用输入及其导数的Sylvester矩阵的行列式（使用此程序包的determinant（）函数）来进行计算。这又由Schur行列式同一性计算。请注意，这具有将线性多项式的判别式设置为1（常规）并将常数的判别式设置为0的效果。</target>
        </trans-unit>
        <trans-unit id="57a53471fa92992c70d886f43da37b86b714d40d" translate="yes" xml:space="preserve">
          <source>is the fundamental solution &amp;mdash; i.e.,</source>
          <target state="translated">是根本的解决方案，即</target>
        </trans-unit>
        <trans-unit id="67c4b407d69ca8235090663680de79b94b491522" translate="yes" xml:space="preserve">
          <source>is the minimal reptend.</source>
          <target state="translated">是最小的reptend。</target>
        </trans-unit>
        <trans-unit id="d4842b1baa18b36449c7d350288c94b9f4cefa2c" translate="yes" xml:space="preserve">
          <source>is the primitive solution of &lt;em&gt;x&lt;/em&gt;&lt;sup&gt;2&lt;/sup&gt; -</source>
          <target state="translated">是&lt;em&gt;x &lt;/em&gt;&lt;sup&gt;2&lt;/sup&gt;的原始解-</target>
        </trans-unit>
        <trans-unit id="b5c0a1b4dce5ac35b3bdf19568dc7d32d1ef6f5e" translate="yes" xml:space="preserve">
          <source>is the set of primitive solutions, represented as a sorted list, and</source>
          <target state="translated">是原始解的集合,用排序的列表表示,而</target>
        </trans-unit>
        <trans-unit id="9ab5df466d8fec7d686d0e8fd0a386420c3f1cf1" translate="yes" xml:space="preserve">
          <source>is the sorted list of all solutions.</source>
          <target state="translated">是所有解决方案的排序列表。</target>
        </trans-unit>
        <trans-unit id="15e7f952825b4d23ab0795f41f932fe99e0c1773" translate="yes" xml:space="preserve">
          <source>is used for memoization.  We compute O(log(</source>
          <target state="translated">是用于记忆化的。我们计算O(log(</target>
        </trans-unit>
        <trans-unit id="208fcfc75abb7f097c431f4754f7d964cd0a8e48" translate="yes" xml:space="preserve">
          <source>isn&amp;rsquo;t prime.</source>
          <target state="translated">不是素数。</target>
        </trans-unit>
        <trans-unit id="f38786758717970fc3a6e4cfa07bcf41bc853729" translate="yes" xml:space="preserve">
          <source>isprime_nm1</source>
          <target state="translated">isprime_nm1</target>
        </trans-unit>
        <trans-unit id="79a7da32928063c3bcec9b019a5f385da5b29a94" translate="yes" xml:space="preserve">
          <source>iterprod()</source>
          <target state="translated">iterprod()</target>
        </trans-unit>
        <trans-unit id="9e9cf1097fbb8c0af843641c0e32781c81ce4931" translate="yes" xml:space="preserve">
          <source>itertools</source>
          <target state="translated">迭代工具</target>
        </trans-unit>
        <trans-unit id="13fbd79c3d390e5d6585a21e11ff5ec1970cff0c" translate="yes" xml:space="preserve">
          <source>k</source>
          <target state="translated">k</target>
        </trans-unit>
        <trans-unit id="d685a407748e8849f1263505263236c59b428388" translate="yes" xml:space="preserve">
          <source>labmath version 1.1.1</source>
          <target state="translated">Labmath 1.1.1版</target>
        </trans-unit>
        <trans-unit id="9ea6002473329c9bf2c6ce211d19c4f47133e091" translate="yes" xml:space="preserve">
          <source>lambda n: sum(f(d) * g(n//d) for d in divisors(n))</source>
          <target state="translated">lambda n:sum(f(d)*g(n/d)for d in divisors(n))</target>
        </trans-unit>
        <trans-unit id="edc17dae351b8e294814eb2f719beba8b1876028" translate="yes" xml:space="preserve">
          <source>linrec</source>
          <target state="translated">linrec</target>
        </trans-unit>
        <trans-unit id="8e700c01a0954d94b4069bd7604563c4d444e2cd" translate="yes" xml:space="preserve">
          <source>lprp</source>
          <target state="translated">lprp</target>
        </trans-unit>
        <trans-unit id="10c25665e49274c39b8e8f7ad6e2a3d0b0bc5052" translate="yes" xml:space="preserve">
          <source>lucas</source>
          <target state="translated">卢卡斯</target>
        </trans-unit>
        <trans-unit id="4e6198a411bd3928707503b4ce13a0500e756f47" translate="yes" xml:space="preserve">
          <source>lucasgen</source>
          <target state="translated">lucasgen</target>
        </trans-unit>
        <trans-unit id="6b0d31c0d563223024da45691584643ac78c96e8" translate="yes" xml:space="preserve">
          <source>m</source>
          <target state="translated">m</target>
        </trans-unit>
        <trans-unit id="9268abd0a926b297f7d2180b19d2be452ef0964a" translate="yes" xml:space="preserve">
          <source>m-1</source>
          <target state="translated">m-1</target>
        </trans-unit>
        <trans-unit id="7a488390a939c4795cc1a801e51751d5f25d800d" translate="yes" xml:space="preserve">
          <source>math</source>
          <target state="translated">数学</target>
        </trans-unit>
        <trans-unit id="3fc66ee357145c86940bacd83291c9da3c204322" translate="yes" xml:space="preserve">
          <source>mods</source>
          <target state="translated">mods</target>
        </trans-unit>
        <trans-unit id="c22f2817741e0e875ad47ea68515f3a3691c8876" translate="yes" xml:space="preserve">
          <source>module).</source>
          <target state="translated">模块)。)</target>
        </trans-unit>
        <trans-unit id="1af60b7b96e08873e7bd780893eed25aa7a430b1" translate="yes" xml:space="preserve">
          <source>modulo</source>
          <target state="translated">模数</target>
        </trans-unit>
        <trans-unit id="4f1840a0bd0f57b4f24320a5c9ca1f875417a203" translate="yes" xml:space="preserve">
          <source>mpqs</source>
          <target state="translated">mpqs</target>
        </trans-unit>
        <trans-unit id="481e642078ce8449a05189acf3c45795b499a245" translate="yes" xml:space="preserve">
          <source>mpz</source>
          <target state="translated">mpz</target>
        </trans-unit>
        <trans-unit id="37fa789244ba067512edeee7a888d433532a0423" translate="yes" xml:space="preserve">
          <source>mpz = int</source>
          <target state="translated">mpz=int</target>
        </trans-unit>
        <trans-unit id="a5bd8289887f3cf122e499e17ebfeef374ec32de" translate="yes" xml:space="preserve">
          <source>multiprocessing</source>
          <target state="translated">多处理</target>
        </trans-unit>
        <trans-unit id="9d1aeca2487d24afd325ff8eed2de7cabbd00552" translate="yes" xml:space="preserve">
          <source>must be pairwise coprime.</source>
          <target state="translated">必须是成对共时的。</target>
        </trans-unit>
        <trans-unit id="d1854cae891ec7b29161ccaf79a24b00c274bdaa" translate="yes" xml:space="preserve">
          <source>n</source>
          <target state="translated">n</target>
        </trans-unit>
        <trans-unit id="6d5e3b4bf5f0b282c1e25ab574b570589a155b0f" translate="yes" xml:space="preserve">
          <source>needs to factor its argument, such as</source>
          <target state="translated">需要考虑其论点,如</target>
        </trans-unit>
        <trans-unit id="b206c000b5b327ffef54cb8d8683dc454cbf29a5" translate="yes" xml:space="preserve">
          <source>ngonal(1, n)</source>
          <target state="translated">ngonal(1,n)</target>
        </trans-unit>
        <trans-unit id="b044148d4bbf95d9708824ff4c61842411fb88b5" translate="yes" xml:space="preserve">
          <source>nprocs==1</source>
          <target state="translated">nprocs==1</target>
        </trans-unit>
        <trans-unit id="53edb37c3102831286c713f27b3cbf2fac86b534" translate="yes" xml:space="preserve">
          <source>nthprimeapprox</source>
          <target state="translated">nthprimeapprox</target>
        </trans-unit>
        <trans-unit id="8c7dd71795f90a543d5e74dce04d14e5e6d5c855" translate="yes" xml:space="preserve">
          <source>objects (as imported from the</source>
          <target state="translated">对象(从</target>
        </trans-unit>
        <trans-unit id="f1a4fd6d24ae912e143e2c8c2cb19ede84f74be8" translate="yes" xml:space="preserve">
          <source>of prime numbers, there are only finitely many pairs of consecutive integers that are both</source>
          <target state="translated">的质数,只有有限的几个连续整数对都是</target>
        </trans-unit>
        <trans-unit id="e9175e26e936a570297c6dd401d37eeb01d9bffd" translate="yes" xml:space="preserve">
          <source>of that, and then sieving to remove the error.</source>
          <target state="translated">的,然后再进行筛分,去除误差。</target>
        </trans-unit>
        <trans-unit id="1758356db21759f7c5a0da9b4dd1db8fd6feab3f" translate="yes" xml:space="preserve">
          <source>or</source>
          <target state="translated">or</target>
        </trans-unit>
        <trans-unit id="4c51633dc554ed687fdde317b3f1058f65a348b9" translate="yes" xml:space="preserve">
          <source>or something like that, then that lambda expression calls the factorizer a lot more than it needs to &amp;mdash; we&amp;rsquo;re already factoring</source>
          <target state="translated">或类似的东西，那么那个lambda表达式调用分解器的次数远远超过了它的需要&amp;mdash;我们已经在分解</target>
        </trans-unit>
        <trans-unit id="516b9783fca517eecbd1d064da2d165310b19759" translate="yes" xml:space="preserve">
          <source>p</source>
          <target state="translated">p</target>
        </trans-unit>
        <trans-unit id="fcf2989b3c5176b44dd95fdcb12150ddb41778bd" translate="yes" xml:space="preserve">
          <source>p!</source>
          <target state="translated">p!</target>
        </trans-unit>
        <trans-unit id="909e6bf0ca53b6aa378c1e94b0db124a102075e2" translate="yes" xml:space="preserve">
          <source>parts</source>
          <target state="translated">partes</target>
        </trans-unit>
        <trans-unit id="f2fe328ab8bf537c8ecbafd3dd78355075319ce3" translate="yes" xml:space="preserve">
          <source>pell</source>
          <target state="translated">果肉</target>
        </trans-unit>
        <trans-unit id="330e4c7e45b01dbbadae4a6cdb2900237e134555" translate="yes" xml:space="preserve">
          <source>pell(D,1)[0]</source>
          <target state="translated">pell(D,1)[0]</target>
        </trans-unit>
        <trans-unit id="defa78cbf02e07b7906c773ac2bc8c860c69def5" translate="yes" xml:space="preserve">
          <source>phicache</source>
          <target state="translated">phicache</target>
        </trans-unit>
        <trans-unit id="4fcdd83743538a0257f58dcef6480c381fd0adff" translate="yes" xml:space="preserve">
          <source>pichache</source>
          <target state="translated">薯片</target>
        </trans-unit>
        <trans-unit id="5e5ff4c6603b930f0e155df26b926d83b86595f0" translate="yes" xml:space="preserve">
          <source>primefac</source>
          <target state="translated">基本面</target>
        </trans-unit>
        <trans-unit id="1514bdcddbf1f72bde938b0ca19ed1f15159d0ee" translate="yes" xml:space="preserve">
          <source>primepi</source>
          <target state="translated">骁勇</target>
        </trans-unit>
        <trans-unit id="c67f1ee17880030ce11821dcc9be7af90b863d9b" translate="yes" xml:space="preserve">
          <source>ps</source>
          <target state="translated">ps</target>
        </trans-unit>
        <trans-unit id="22ea1c649c82946aa6e479e1ffd321e4a318b1b0" translate="yes" xml:space="preserve">
          <source>q</source>
          <target state="translated">q</target>
        </trans-unit>
        <trans-unit id="4dc7c9ec434ed06502767136789763ec11d2c4b7" translate="yes" xml:space="preserve">
          <source>r</source>
          <target state="translated">r</target>
        </trans-unit>
        <trans-unit id="a415ab5cc17c8c093c015ccdb7e552aee7911aa4" translate="yes" xml:space="preserve">
          <source>random</source>
          <target state="translated">随机的</target>
        </trans-unit>
        <trans-unit id="0aa526fef0364a6010e9a179dd3199d9e5fadcd8" translate="yes" xml:space="preserve">
          <source>range(iterprod(mods))</source>
          <target state="translated">范围(iterprod(mods))</target>
        </trans-unit>
        <trans-unit id="e1d98009a67f2aeb1d78cab5a72f9d99082b0340" translate="yes" xml:space="preserve">
          <source>reduce(lambda x,y: x*y, a)</source>
          <target state="translated">reduce(lambda x,y:x*y,a)</target>
        </trans-unit>
        <trans-unit id="4a9f9e7ff9f4b5aa4264aba8bbd30d1c6dc892e9" translate="yes" xml:space="preserve">
          <source>riemannzeta(n)</source>
          <target state="translated">riemannzeta(s)</target>
        </trans-unit>
        <trans-unit id="139262cfb795de87ca2c68ffa51eb483edac019f" translate="yes" xml:space="preserve">
          <source>riemannzeta(n, k) - 1</source>
          <target state="translated">riemannzeta(n,k)-1</target>
        </trans-unit>
        <trans-unit id="1737d3a2dc46463ad1bf10bf62768a92500b3111" translate="yes" xml:space="preserve">
          <source>secm</source>
          <target state="translated">secm</target>
        </trans-unit>
        <trans-unit id="925dc46d581dd0d18f35a2c0fb07716dc1efcd86" translate="yes" xml:space="preserve">
          <source>should be sorted in decreasing order.</source>
          <target state="translated">应按递减顺序排列。</target>
        </trans-unit>
        <trans-unit id="7d13cc40a337e3f1ae20e91e68728dde0958d1d9" translate="yes" xml:space="preserve">
          <source>should usually be used instead.</source>
          <target state="translated">通常应该使用代替。</target>
        </trans-unit>
        <trans-unit id="abe2b85a053eeba46422394e9f07fd9592ac7fb4" translate="yes" xml:space="preserve">
          <source>slprp</source>
          <target state="translated">slprp</target>
        </trans-unit>
        <trans-unit id="295188241a81ec69699501e1cd20e5df674d028e" translate="yes" xml:space="preserve">
          <source>sqrts</source>
          <target state="translated">sqrts</target>
        </trans-unit>
        <trans-unit id="fdca81ff0033bd52e01e0c38528c9264aeefc4ea" translate="yes" xml:space="preserve">
          <source>such that</source>
          <target state="translated">以致于</target>
        </trans-unit>
        <trans-unit id="20846584c637996ddae8a85fd4e9014218cf8219" translate="yes" xml:space="preserve">
          <source>such that 1 = 2&lt;sup&gt;n-1&lt;/sup&gt;.</source>
          <target state="translated">这样1 = 2 &lt;sup&gt;n-1&lt;/sup&gt;。</target>
        </trans-unit>
        <trans-unit id="1db8a2298feaca37566d15607275854d077f3496" translate="yes" xml:space="preserve">
          <source>such that &lt;em&gt;c&lt;/em&gt; &amp;equiv; &lt;em&gt;x&lt;/em&gt; (mod &lt;em&gt;y&lt;/em&gt;) for (&lt;em&gt;x&lt;/em&gt;, &lt;em&gt;y&lt;/em&gt;) in</source>
          <target state="translated">使得&lt;em&gt;&amp;Ccedil;&lt;/em&gt; &amp;equiv; &lt;em&gt;X&lt;/em&gt;（MOD &lt;em&gt;&amp;Yacute;&lt;/em&gt;）为（&lt;em&gt;X&lt;/em&gt;，&lt;em&gt;&amp;yuml;&lt;/em&gt;）在</target>
        </trans-unit>
        <trans-unit id="16ffe9780e7b3df743714126040a34c7875445df" translate="yes" xml:space="preserve">
          <source>sum(totient(n) for n in range(1, n+1))</source>
          <target state="translated">sum(totient(n)for n in range(1,n+1))</target>
        </trans-unit>
        <trans-unit id="6e0beaf39654867287ea9229dfeb08d2335389d3" translate="yes" xml:space="preserve">
          <source>that form a coprime (</source>
          <target state="translated">形成一个共时性(</target>
        </trans-unit>
        <trans-unit id="3975a92d6ff3dcb8adbe2c2c5932f8cc2816e1e0" translate="yes" xml:space="preserve">
          <source>then we compute U&lt;sub&gt;k&lt;/sub&gt; and V&lt;sub&gt;k&lt;/sub&gt; in O(ln(</source>
          <target state="translated">然后我们计算&amp;ugrave; &lt;sub&gt;ķ&lt;/sub&gt;和V &lt;sub&gt;ķ&lt;/sub&gt;在O（LN（</target>
        </trans-unit>
        <trans-unit id="202e8e8eb91d64ae945f1b2535b5c51729fa5ed8" translate="yes" xml:space="preserve">
          <source>times and * represents Dirichlet convolution.  The values returned will be</source>
          <target state="translated">次,*代表Dirichlet卷积。返回的值将是</target>
        </trans-unit>
        <trans-unit id="69daf7983e3f8a68d4b9be209f74e83910a55801" translate="yes" xml:space="preserve">
          <source>to the &lt;a href=&quot;https://en.wikipedia.org/wiki/Dirichlet_eta_function&quot;&gt;Dirichlet eta function&lt;/a&gt;.  Should be rather accurate throughout the complex plane except near</source>
          <target state="translated">到&lt;a href=&quot;https://en.wikipedia.org/wiki/Dirichlet_eta_function&quot;&gt;Dirichlet eta函数&lt;/a&gt;。在整个复杂平面上应该相当准确，除了附近</target>
        </trans-unit>
        <trans-unit id="b9b3cba50dbf3adefc333414e44b38442cf55715" translate="yes" xml:space="preserve">
          <source>to the Dirichlet eta function.  Designed to be accurate even when</source>
          <target state="translated">到Dirichlet eta函数。设计为即使在</target>
        </trans-unit>
        <trans-unit id="0d49bceae9764f901fbe19c45ce8d0429e61ae8f" translate="yes" xml:space="preserve">
          <source>using at least the indicated number of terms and whose denominators are all &amp;ge; minden.  No algorithm is known for this problem that significantly improves upon brute force, so this can take impractically long times on even modest-seeming inputs.</source>
          <target state="translated">至少使用指定数量的术语并且其分母均&amp;ge;mined。尚无算法可以解决此问题，该算法可显着改善蛮力，因此，即使是看起来适度的输入，也可能花费不切实际的长时间。</target>
        </trans-unit>
        <trans-unit id="0251bb8c786cf88db78b92a0f771f8bf6c04869a" translate="yes" xml:space="preserve">
          <source>using parameters provided by</source>
          <target state="translated">使用</target>
        </trans-unit>
        <trans-unit id="5e6e4c0fb8ef47b4f1d6eea3e6c51152dbee94ec" translate="yes" xml:space="preserve">
          <source>val1</source>
          <target state="translated">价值1</target>
        </trans-unit>
        <trans-unit id="25f05eec259d12623e65c0c20a1eadedeaa3822a" translate="yes" xml:space="preserve">
          <source>via the Meissel-Lehmer method.  The arguments</source>
          <target state="translated">通过Meissel-Lehmer方法。参数</target>
        </trans-unit>
        <trans-unit id="30603fa9e0f620c305cd627ab0ff138a960c48bd" translate="yes" xml:space="preserve">
          <source>when</source>
          <target state="translated">when</target>
        </trans-unit>
        <trans-unit id="1291f62516ba88e56c8eba45b01c44dec887206b" translate="yes" xml:space="preserve">
          <source>when attempting to evaluate</source>
          <target state="translated">当试图评估</target>
        </trans-unit>
        <trans-unit id="6a42677517d955828716befce981ad0a0d6dd915" translate="yes" xml:space="preserve">
          <source>where the initial values are [&lt;em&gt;x&lt;/em&gt;&lt;sub&gt;0&lt;/sub&gt;, &amp;hellip;, &lt;em&gt;x&lt;/em&gt;&lt;sub&gt;k&lt;/sub&gt;] =</source>
          <target state="translated">初始值为[ &lt;em&gt;x &lt;/em&gt;&lt;sub&gt;0&lt;/sub&gt;，&amp;hellip;，&lt;em&gt;x &lt;/em&gt;&lt;sub&gt;k&lt;/sub&gt; ] =</target>
        </trans-unit>
        <trans-unit id="12f847846c97f0fb0288ace1b3d95fcdb3b5ca10" translate="yes" xml:space="preserve">
          <source>whose value at 1 is</source>
          <target state="translated">其1时的值为</target>
        </trans-unit>
        <trans-unit id="2a873cdbb5b91b1f460dac913d0821840473a2ef" translate="yes" xml:space="preserve">
          <source>will return</source>
          <target state="translated">将返回</target>
        </trans-unit>
        <trans-unit id="143375b8e5feeb7dee58a5e69d40b8563339ca29" translate="yes" xml:space="preserve">
          <source>williams_pp1</source>
          <target state="translated">williams_pp1</target>
        </trans-unit>
        <trans-unit id="aa75b06d15054dd7062eecc1a854a090b01f54f0" translate="yes" xml:space="preserve">
          <source>with parameters (</source>
          <target state="translated">与参数(</target>
        </trans-unit>
        <trans-unit id="312bc8ad198de0303fe47e34a05c081776f7cd10" translate="yes" xml:space="preserve">
          <source>with the same parameters.</source>
          <target state="translated">具有相同的参数。</target>
        </trans-unit>
        <trans-unit id="11f6ad8ec52a2984abaafd7c3b516503785c2072" translate="yes" xml:space="preserve">
          <source>x</source>
          <target state="translated">x</target>
        </trans-unit>
        <trans-unit id="68ebb00048d792472ece36448817bfb237e238f4" translate="yes" xml:space="preserve">
          <source>xslprp</source>
          <target state="translated">xslprp</target>
        </trans-unit>
        <trans-unit id="dd7b7b74ea160e049dd128478e074ce47254bde8" translate="yes" xml:space="preserve">
          <source>xx</source>
          <target state="translated">xx</target>
        </trans-unit>
        <trans-unit id="34d8f96ae05eeccb172e84f975ccfb986b190d79" translate="yes" xml:space="preserve">
          <source>yields all solutions.</source>
          <target state="translated">产生所有的解决方案。</target>
        </trans-unit>
        <trans-unit id="395df8f7c51f007019cb30201c49e884b46b92fa" translate="yes" xml:space="preserve">
          <source>z</source>
          <target state="translated">z</target>
        </trans-unit>
        <trans-unit id="029a3fcb010f8f92628023b595f00551a85179ef" translate="yes" xml:space="preserve">
          <source>zc</source>
          <target state="translated">zc</target>
        </trans-unit>
        <trans-unit id="7ac99c00e5aa89607950c93d6a0bcf99ac0cb028" translate="yes" xml:space="preserve">
          <source>zip(rems, mods)</source>
          <target state="translated">zip(rems,mods)</target>
        </trans-unit>
        <trans-unit id="3eb416223e9e69e6bb8ee19793911ad1ad2027d8" translate="yes" xml:space="preserve">
          <source>|</source>
          <target state="translated">|</target>
        </trans-unit>
        <trans-unit id="e298e579515bfddfe989d1a89ee2e1bcd4916f5c" translate="yes" xml:space="preserve">
          <source>| &amp;middot; &lt;em&gt;y&lt;/em&gt;&lt;sup&gt;2&lt;/sup&gt; =</source>
          <target state="translated">| &amp;middot; &lt;em&gt;y &lt;/em&gt;&lt;sup&gt;2&lt;/sup&gt; =</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
