<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://pypi.org/project/attrdict/">
    <body>
      <group id="attrdict">
        <trans-unit id="35177623fd7781a2664a3d3aa7fa30447ed667fa" translate="yes" xml:space="preserve">
          <source>(e.g., lists, tuples) will automatically be converted to tuples, with any
mappings converted to Attrs:</source>
          <target state="translated">（例如列表，元组）将自动转换为元组，并将任何映射转换为Attrs：</target>
        </trans-unit>
        <trans-unit id="5c10b5b2cd673a0616d529aa5234b12ee7153808" translate="yes" xml:space="preserve">
          <source>,</source>
          <target state="translated">，</target>
        </trans-unit>
        <trans-unit id="8278d2adba7612cf98a492d21a4ac4c78acb1202" translate="yes" xml:space="preserve">
          <source>, and</source>
          <target state="translated">和</target>
        </trans-unit>
        <trans-unit id="4ec42912ea5168fc100706cb26d27ba42c6f7b8d" translate="yes" xml:space="preserve">
          <source>, consider using</source>
          <target state="translated">，请考虑使用</target>
        </trans-unit>
        <trans-unit id="b366d1a229ec84d93ba42e7ecafb33db5b7b9b39" translate="yes" xml:space="preserve">
          <source>, or</source>
          <target state="translated">， 要么</target>
        </trans-unit>
        <trans-unit id="03167baa1adaf511453a138943d542f9ca8991fd" translate="yes" xml:space="preserve">
          <source>. They are all fairly similar, as they all are MutableMappings (
read: dictionaries) that allow creating, accessing, and deleting key-value
pairs as attributes.</source>
          <target state="translated">。它们都是相当相似的，因为它们都是MutableMappings（阅读：词典），允许创建，访问和删除键-值对作为属性。</target>
        </trans-unit>
        <trans-unit id="17fd68ccb03b7b09f7ae7b600547bd46717d26d9" translate="yes" xml:space="preserve">
          <source>. This allows on-the-fly,
automatic key creation:</source>
          <target state="translated">。这允许即时自动创建密钥：</target>
        </trans-unit>
        <trans-unit id="edb81bfb0504a5c51414b30faee233682ff1586c" translate="yes" xml:space="preserve">
          <source>. While this is probably the class you
want to use, there are a few caveats that follow from this being a</source>
          <target state="translated">。虽然这可能是您要使用的类，但在此之后有一些注意事项</target>
        </trans-unit>
        <trans-unit id="c84dcf9dadcc7e66f5e3007f0cd3deacfaffd669" translate="yes" xml:space="preserve">
          <source>. You should be able to use this
absolutely anywhere you can use a</source>
          <target state="translated">。您应该绝对可以在任何可以使用的地方使用它</target>
        </trans-unit>
        <trans-unit id="e7f36d14ee5e1f6d131d0fcabe098d27f86aad7d" translate="yes" xml:space="preserve">
          <source>A dict with attribute-style access</source>
          <target state="translated">一个具有属性式访问的dict</target>
        </trans-unit>
        <trans-unit id="388a951440518f6d73c198361e0518b929a2cd1a" translate="yes" xml:space="preserve">
          <source>All three Attr classes can be merged with eachother or other Mappings using the</source>
          <target state="translated">所有三个Attr类都可以通过使用</target>
        </trans-unit>
        <trans-unit id="80cfc66f597ad1a9a7a74a2569f032e8ed192826" translate="yes" xml:space="preserve">
          <source>An Attr object that subclasses</source>
          <target state="translated">一个Attr对象,它的子类是</target>
        </trans-unit>
        <trans-unit id="3d777f94e6c2538c81bbeca36c71defbfa75a07e" translate="yes" xml:space="preserve">
          <source>Any key can be used as an attribute as long as:</source>
          <target state="translated">任何键都可以作为一个属性使用,只要:</target>
        </trans-unit>
        <trans-unit id="866b536688e92b28271400dd183fd9ffd9a0f52a" translate="yes" xml:space="preserve">
          <source>Assignment as keys will still work:</source>
          <target state="translated">以钥匙的形式进行分配仍可使用。</target>
        </trans-unit>
        <trans-unit id="fc04a24097921ddaa01e14ab8bcf63fd87f05c1b" translate="yes" xml:space="preserve">
          <source>At Attr object that behaves like a</source>
          <target state="translated">Attr对象,它的行为就像是一个</target>
        </trans-unit>
        <trans-unit id="b861b0ae4a7bca3fd5304fa2e10f363cbda3deb7" translate="yes" xml:space="preserve">
          <source>AttrDefault</source>
          <target state="translated">AttrDefault</target>
        </trans-unit>
        <trans-unit id="de7cd9086777ba676dc66efc06dbabff4f8b2b23" translate="yes" xml:space="preserve">
          <source>AttrDefault also has a</source>
          <target state="translated">AttrDefault也有一个</target>
        </trans-unit>
        <trans-unit id="563a42155c5bb513cebfd27a686d7f5c3c9450a4" translate="yes" xml:space="preserve">
          <source>AttrDict</source>
          <target state="translated">AttrDict</target>
        </trans-unit>
        <trans-unit id="e1e02581e9da83c6e107d134a2e4da1edf5f9ee7" translate="yes" xml:space="preserve">
          <source>AttrDict comes with three different classes,</source>
          <target state="translated">AttrDict有三个不同的类。</target>
        </trans-unit>
        <trans-unit id="b7acc9c2fa3145e01bcb1735a96320082d5d4d4f" translate="yes" xml:space="preserve">
          <source>AttrDict comes with three different objects,</source>
          <target state="translated">AttrDict有三个不同的对象。</target>
        </trans-unit>
        <trans-unit id="97cad167761ce8e174d2547443223671eb18025d" translate="yes" xml:space="preserve">
          <source>AttrDict is an MIT-licensed library that provides mapping objects that allow
their elements to be accessed both as keys and as attributes:</source>
          <target state="translated">AttrDict是一个MIT授权的库,它提供了映射对象,允许将元素作为键和属性来访问。</target>
        </trans-unit>
        <trans-unit id="d2f69ecd892fc3e419fbe280247fba45a9af46f2" translate="yes" xml:space="preserve">
          <source>AttrDict is in PyPI, so it can be installed directly using:</source>
          <target state="translated">AttrDict在PyPI中,所以可以直接使用。</target>
        </trans-unit>
        <trans-unit id="ea6f44c5f7d2ba1d492f7dfe3527126e847d80da" translate="yes" xml:space="preserve">
          <source>AttrDict is released under a MIT license.</source>
          <target state="translated">AttrDict是在MIT许可下发布的。</target>
        </trans-unit>
        <trans-unit id="7d16f63f233c884b88c024beef93ef4869894f31" translate="yes" xml:space="preserve">
          <source>AttrMap</source>
          <target state="translated">AttrMap</target>
        </trans-unit>
        <trans-unit id="cb565fb6cdf158e9ebf3f2242d07987e99755a44" translate="yes" xml:space="preserve">
          <source>Attribute access makes it easy to create convenient, hierarchical settings
objects:</source>
          <target state="translated">属性访问使得它可以轻松地创建方便的、层次化的设置对象。</target>
        </trans-unit>
        <trans-unit id="de07dccdfb62e16b05d0e3c001fe5f755934aee3" translate="yes" xml:space="preserve">
          <source>Attributes vs. Keys</source>
          <target state="translated">属性与键</target>
        </trans-unit>
        <trans-unit id="b20cbc384159fd820ed034fd3615298ec09f5902" translate="yes" xml:space="preserve">
          <source>Basic Usage</source>
          <target state="translated">基本使用方法</target>
        </trans-unit>
        <trans-unit id="c0b86a828bc5ced4f5e696be4d306284c36e5926" translate="yes" xml:space="preserve">
          <source>By default, items in non-string Sequences (e.g. lists, tuples) will be
converted to AttrDicts:</source>
          <target state="translated">默认情况下,非字符串序列(如列表、元组)中的项目将被转换为AttrDicts。</target>
        </trans-unit>
        <trans-unit id="ed1846afee3be21521286932b99e2aeae9e6414a" translate="yes" xml:space="preserve">
          <source>Classes</source>
          <target state="translated">班级</target>
        </trans-unit>
        <trans-unit id="97cdbdc7feff827efb082a6b6dd2727237cd49fd" translate="yes" xml:space="preserve">
          <source>False</source>
          <target state="translated">假的</target>
        </trans-unit>
        <trans-unit id="be9ae17642442049ac4c2ef919fd9c28a90f1087" translate="yes" xml:space="preserve">
          <source>If either of these caveats are deal-breakers, or you don&amp;rsquo;t need your object to
be a</source>
          <target state="translated">如果这些警告中有一项是破坏交易的，或者您不需要将您的对象作为</target>
        </trans-unit>
        <trans-unit id="c81b79df3c6448eae7c4f80428b54cd5692a17d7" translate="yes" xml:space="preserve">
          <source>Installation</source>
          <target state="translated">安装</target>
        </trans-unit>
        <trans-unit id="3229609e15436ec51bcf00818a69a84dbc58a0c2" translate="yes" xml:space="preserve">
          <source>License</source>
          <target state="translated">许可证</target>
        </trans-unit>
        <trans-unit id="40de0d4de887a374168bf79e72c7aa0fa4594d6e" translate="yes" xml:space="preserve">
          <source>Merging</source>
          <target state="translated">合并</target>
        </trans-unit>
        <trans-unit id="304995ed252b737012b035215aa311a2b98a2c54" translate="yes" xml:space="preserve">
          <source>NOTE: AttrDict&amp;rsquo;s add is not commutative,</source>
          <target state="translated">注意：AttrDict的添加不是可交换的，</target>
        </trans-unit>
        <trans-unit id="07c24fa219fba84d32880ece6fdadce59ecadb6b" translate="yes" xml:space="preserve">
          <source>Or from Github:</source>
          <target state="translated">或来自Github。</target>
        </trans-unit>
        <trans-unit id="68d52809828fe7472e5716c4dff1ef72595a17cb" translate="yes" xml:space="preserve">
          <source>Recursive attribute access results in a shallow copy, so recursive assignment
will fail (as you will be writing to a copy of that dictionary):</source>
          <target state="translated">递归属性访问的结果是一个浅层的副本,所以递归赋值将失败(因为你将写到该字典的副本)。</target>
        </trans-unit>
        <trans-unit id="ae6e1ecc353f021830966b6e7c9d88505471ce64" translate="yes" xml:space="preserve">
          <source>Relatedly, by default, sequence types that aren&amp;rsquo;t</source>
          <target state="translated">相关地，默认情况下，不是</target>
        </trans-unit>
        <trans-unit id="b5fb636023abb67d347041d398442118f79ea091" translate="yes" xml:space="preserve">
          <source>Sequences</source>
          <target state="translated">序列</target>
        </trans-unit>
        <trans-unit id="93ef0dd827103681fcee453b78be2ff14e1a261d" translate="yes" xml:space="preserve">
          <source>The</source>
          <target state="translated">The</target>
        </trans-unit>
        <trans-unit id="ae8ddde88faa73f8ba66cdf8e427cb20f61236ab" translate="yes" xml:space="preserve">
          <source>The key does not shadow a class attribute (e.g., get).</source>
          <target state="translated">键不影射一个类属性(例如,get)。</target>
        </trans-unit>
        <trans-unit id="60650cfe0ce8c828561272ae234237ead311df69" translate="yes" xml:space="preserve">
          <source>The key represents a public attribute (i.e., it doesn&amp;rsquo;t start with an
underscore). This is done (in part) so that implementation changes between
minor and micro versions don&amp;rsquo;t force major version changes.</source>
          <target state="translated">该键代表一个公共属性（即，它不以下划线开头）。这样做（部分完成）是为了使次要版本和微型版本之间的实现更改不会强制主要版本更改。</target>
        </trans-unit>
        <trans-unit id="f071eaca5e568c54b292f6a4ba70ed1cbdd2a92d" translate="yes" xml:space="preserve">
          <source>The key represents a valid attribute (i.e., it is a string comprised only of
alphanumeric characters and underscores that doesn&amp;rsquo;t start with a number)</source>
          <target state="translated">键代表有效的属性（即，它是仅由字母数字字符和下划线组成的字符串，该字符串不能以数字开头）</target>
        </trans-unit>
        <trans-unit id="03e297e14a6beaf56419f226a304a42c4da6cc1e" translate="yes" xml:space="preserve">
          <source>The most basic implementation. Use this if you want to limit the number of
invalid keys, or otherwise cannot use</source>
          <target state="translated">最基本的实现。如果你想限制无效键的数量,或者无法使用</target>
        </trans-unit>
        <trans-unit id="83caa4896bb23997dea2bd3cae2ad3e62fe16ea3" translate="yes" xml:space="preserve">
          <source>There is a minor difference between accessing a value as an attribute vs.
accessing it as a key, is that when a dict is accessed as an attribute, it will
automatically be converted to an Attr object. This allows you to recursively
access keys:</source>
          <target state="translated">将一个值作为属性访问与作为键访问之间有一个小的区别,那就是当一个dict作为属性访问时,它将自动转换为Attr对象。这允许你递归地访问键。</target>
        </trans-unit>
        <trans-unit id="2760e3308bbbc670c560af3f04349f3bf82f07de" translate="yes" xml:space="preserve">
          <source>This will not occur if you access the AttrDict as a dictionary:</source>
          <target state="translated">如果你以字典的形式访问AttrDict,就不会发生这种情况。</target>
        </trans-unit>
        <trans-unit id="fcda2a058c36d257277b667fccf603ffcf587ffa" translate="yes" xml:space="preserve">
          <source>To disable this behavior globally, pass the attribute</source>
          <target state="translated">要在全局范围内禁用这种行为,需要传递属性</target>
        </trans-unit>
        <trans-unit id="b4c6da101d3a4b1594ec988563f47f1f60e85748" translate="yes" xml:space="preserve">
          <source>To get this recursive functionality for keys that cannot be used as attributes,
you can replicate the behavior by calling the Attr object:</source>
          <target state="translated">要想对不能作为属性使用的键获得这种递归功能,可以通过调用Attr对象来复制该行为。</target>
        </trans-unit>
        <trans-unit id="d488cb468296278b27f92e9fea26cec2d90b1a00" translate="yes" xml:space="preserve">
          <source>Valid Names</source>
          <target state="translated">有效名称</target>
        </trans-unit>
        <trans-unit id="7b0db9c5d2d41e5d824e05f9241184027edcdf1e" translate="yes" xml:space="preserve">
          <source>When merging an AttrDict with another mapping, this behavior will be disabled
if at least one of the merged items is an AttrDict that has set</source>
          <target state="translated">当合并一个AttrDict和另一个映射时,如果合并的项目中至少有一个是已经设置了</target>
        </trans-unit>
        <trans-unit id="c91ac9b9df178938cde8e690cc6951a4ead06690" translate="yes" xml:space="preserve">
          <source>a + b != b + a</source>
          <target state="translated">a+b!=b+a</target>
        </trans-unit>
        <trans-unit id="daf529a73101c2be626b99fc6938163e7a27620b" translate="yes" xml:space="preserve">
          <source>bytes</source>
          <target state="translated">字节数</target>
        </trans-unit>
        <trans-unit id="f84e2e2dadd87384fb55f25886926b777e8378f1" translate="yes" xml:space="preserve">
          <source>copy</source>
          <target state="translated">复制</target>
        </trans-unit>
        <trans-unit id="0fa494c647221d96036c09dd3917bd470e3aa168" translate="yes" xml:space="preserve">
          <source>default_factory</source>
          <target state="translated">厂家默认</target>
        </trans-unit>
        <trans-unit id="f90aef983629a7d310fd034c80bf7a15787a6479" translate="yes" xml:space="preserve">
          <source>defaultdict</source>
          <target state="translated">违约金</target>
        </trans-unit>
        <trans-unit id="76e94348139b788d21edc7b9cd011af238d0de03" translate="yes" xml:space="preserve">
          <source>dict</source>
          <target state="translated">口述</target>
        </trans-unit>
        <trans-unit id="dcecaa58d8e4bf0eb155a96557f2e868a53aa3df" translate="yes" xml:space="preserve">
          <source>instead of an</source>
          <target state="translated">而非</target>
        </trans-unit>
        <trans-unit id="6568964b0e39083c6acb94093d9e6cd117dbe508" translate="yes" xml:space="preserve">
          <source>instead.</source>
          <target state="translated">而不是。</target>
        </trans-unit>
        <trans-unit id="5f9ca3ec02bdc0f84434f55d6b4157c56df643ef" translate="yes" xml:space="preserve">
          <source>method (which returns a shallow copy of the mapping) returns a</source>
          <target state="translated">方法(返回映射的一个浅层副本)返回一个</target>
        </trans-unit>
        <trans-unit id="350430ff75db011e0220198b8bb2f73a4c7a4a03" translate="yes" xml:space="preserve">
          <source>operator. For conflicting keys, the right dict&amp;rsquo;s value will be
preferred, but in the case of two dictionary values, they will be
recursively merged:</source>
          <target state="translated">操作员。对于冲突的键，将优先使用正确的dict的值，但是在两个字典值的情况下，它们将被递归合并：</target>
        </trans-unit>
        <trans-unit id="56f5df31bd18359684e05cffd9194742f875d381" translate="yes" xml:space="preserve">
          <source>option that passes the supplied key to the</source>
          <target state="translated">选项,将提供的密钥传递给</target>
        </trans-unit>
        <trans-unit id="18d1939e4fcb64d387808676e5e665321397115a" translate="yes" xml:space="preserve">
          <source>pass_key</source>
          <target state="translated">pass_key</target>
        </trans-unit>
        <trans-unit id="594a4346defb3386cfbe1790c0232c2bf0dd0137" translate="yes" xml:space="preserve">
          <source>recursive</source>
          <target state="translated">递归</target>
        </trans-unit>
        <trans-unit id="d1be42a7594e592e9e6a87ff56e92dbef4ae0c72" translate="yes" xml:space="preserve">
          <source>recursive=False</source>
          <target state="translated">递归=False</target>
        </trans-unit>
        <trans-unit id="3442496b96dd01591a8cd44b1eec1368ab728aba" translate="yes" xml:space="preserve">
          <source>str</source>
          <target state="translated">跨越</target>
        </trans-unit>
        <trans-unit id="4374aaee247fb237ce6c97d5c8d64bbe474d16de" translate="yes" xml:space="preserve">
          <source>to</source>
          <target state="translated">にとって</target>
        </trans-unit>
        <trans-unit id="eefb40ba442d03ca50c1f1cf284208d3a89c7abe" translate="yes" xml:space="preserve">
          <source>to
the constructor:</source>
          <target state="translated">到构造函数。</target>
        </trans-unit>
        <trans-unit id="96c6908f66b1b7d0e5248f7ae9e4039ca1564e60" translate="yes" xml:space="preserve">
          <source>under
the hood.</source>
          <target state="translated">引擎盖下。</target>
        </trans-unit>
        <trans-unit id="1d1e8914a3d46b4097dec7a7370a1cc102848137" translate="yes" xml:space="preserve">
          <source>unicode</source>
          <target state="translated">统一码</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
