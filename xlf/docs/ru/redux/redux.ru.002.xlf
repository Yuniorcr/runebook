<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="redux">
    <body>
      <group id="redux">
        <trans-unit id="f289628c32a4808458fe68440054d194866e8e5c" translate="yes" xml:space="preserve">
          <source>Is there value to you in being able to restore this state to a given point in time (ie, time travel debugging)?</source>
          <target state="translated">Имеет ли значение для вас возможность восстановить это состояние в заданный момент времени (т.е.отладка путешествий во времени)?</target>
        </trans-unit>
        <trans-unit id="ea4cec2a5adc22a33671afe8c2442bda5e76ae5a" translate="yes" xml:space="preserve">
          <source>Isolating Redux Sub-Apps</source>
          <target state="translated">Изолирующие под-приложения Redux</target>
        </trans-unit>
        <trans-unit id="ce286d263926cfdb1859da7cb4876ed9e5c9ba84" translate="yes" xml:space="preserve">
          <source>Isolating Subapps</source>
          <target state="translated">Изолирующие субаппы</target>
        </trans-unit>
        <trans-unit id="b03cd03c1cbbbb49e2d53831a74d4f4cbf478570" translate="yes" xml:space="preserve">
          <source>Isolating a Redux app as a component in a bigger application, in which case you might want to create a store per root component instance.</source>
          <target state="translated">Изоляция приложения Redux как компонента в большом приложении,в этом случае вы можете захотеть создать хранилище для экземпляра корневого компонента.</target>
        </trans-unit>
        <trans-unit id="3e2da235921f2dc98b67a3405af6d4d8b66644a3" translate="yes" xml:space="preserve">
          <source>It detects a change by keeping a reference to the root state object, and a reference to &lt;em&gt;each value&lt;/em&gt; in the props object that's returned from the &lt;code&gt;mapStateToProps&lt;/code&gt; function.</source>
          <target state="translated">Он обнаруживает изменение, сохраняя ссылку на объект корневого состояния и ссылку на &lt;em&gt;каждое значение&lt;/em&gt; в объекте &lt;code&gt;mapStateToProps&lt;/code&gt; функцией mapStateToProps .</target>
        </trans-unit>
        <trans-unit id="0678b386548901ffe5796fba691a7dd7a055517b" translate="yes" xml:space="preserve">
          <source>It does a bit of trickery to make sure that if you call &lt;code&gt;store.dispatch(action)&lt;/code&gt; from your middleware instead of &lt;code&gt;next(action)&lt;/code&gt;, the action will actually travel the whole middleware chain again, including the current middleware. This is useful for asynchronous middleware, as we have seen &lt;a href=&quot;asyncactions&quot;&gt;previously&lt;/a&gt;.</source>
          <target state="translated">Он использует небольшую хитрость, чтобы убедиться, что если вы вызываете &lt;code&gt;store.dispatch(action)&lt;/code&gt; из промежуточного программного обеспечения вместо &lt;code&gt;next(action)&lt;/code&gt; , действие фактически снова пройдет всю цепочку промежуточного программного обеспечения, включая текущее промежуточное программное обеспечение. Это полезно для асинхронного промежуточного программного обеспечения, как мы видели &lt;a href=&quot;asyncactions&quot;&gt;ранее&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c838975ff8bc1485249cfc27d4ffd7a7c7eba961" translate="yes" xml:space="preserve">
          <source>It does not require a build system or a view framework and exists to show the raw Redux API used with ES5.</source>
          <target state="translated">Он не требует системы сборки или фреймворка представлений и существует для показа сырого Redux API,используемого с ES5.</target>
        </trans-unit>
        <trans-unit id="72186694410e16c516c9d596656e81807bdc0ee2" translate="yes" xml:space="preserve">
          <source>It does so because the props object is actually a hash of prop names and their values (or selector functions that are used to retrieve or generate the values), such as in this example:</source>
          <target state="translated">Это происходит потому,что объект реквизита на самом деле является хэшем из имен реквизиторов и их значений (или селекторных функций,которые используются для получения или генерации значений),как,например,в данном примере:</target>
        </trans-unit>
        <trans-unit id="cd40f9379225350f73c28d7d8b350321206fccb5" translate="yes" xml:space="preserve">
          <source>It does this by performing a shallow equality check on each value within the object individually, and will only trigger a re-render if one of those checks fails.</source>
          <target state="translated">Он делает это,выполняя поверхностную проверку равенства каждого значения внутри объекта в отдельности,и будет вызывать повторный запрос только в том случае,если одна из этих проверок не удастся.</target>
        </trans-unit>
        <trans-unit id="cc8c262fccc1fd13b37e15839544d8f0e42b7f17" translate="yes" xml:space="preserve">
          <source>It doesn't work because your action creator is just a function that &lt;em&gt;returns&lt;/em&gt; an action. It is up to you to actually dispatch it. We can't bind your action creators to a particular Store instance during the definition because apps that render on the server need a separate Redux store for every request.</source>
          <target state="translated">Это не работает, потому что ваш создатель действия - это просто функция, &lt;em&gt;возвращающая&lt;/em&gt; действие. Вы действительно должны его отправить. Мы не можем привязать ваших создателей действий к конкретному экземпляру Store во время определения, потому что приложениям, которые отображаются на сервере, требуется отдельное хранилище Redux для каждого запроса.</target>
        </trans-unit>
        <trans-unit id="50bdebff8f75748e8eb5b1028b6f9e739d1e11eb" translate="yes" xml:space="preserve">
          <source>It helps keep the naming consistent because all action types are gathered in a single place.</source>
          <target state="translated">Это помогает сохранить последовательность именования,потому что все типы действий собраны в одном месте.</target>
        </trans-unit>
        <trans-unit id="79e39e70b7c42af694874a6eb695630593111193" translate="yes" xml:space="preserve">
          <source>It helps you write applications that behave consistently, run in different environments (client, server, and native), and are easy to test. On top of that, it provides a great developer experience, such as &lt;a href=&quot;https://github.com/gaearon/redux-devtools&quot;&gt;live code editing combined with a time traveling debugger&lt;/a&gt;.</source>
          <target state="translated">Он помогает вам писать приложения, которые ведут себя согласованно, работают в разных средах (клиентских, серверных и собственных) и легко тестируются. Вдобавок ко всему, он предоставляет отличные возможности для разработчиков, такие как &lt;a href=&quot;https://github.com/gaearon/redux-devtools&quot;&gt;редактирование кода&lt;/a&gt; в реальном времени в сочетании с отладчиком, путешествующим во времени .</target>
        </trans-unit>
        <trans-unit id="94502169236559f86f242ead05d16d88d3912a58" translate="yes" xml:space="preserve">
          <source>It is a common convention that actions have a constant type that helps reducers (or Stores in Flux) identify them. We recommend that you use strings and not &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Symbol&quot;&gt;Symbols&lt;/a&gt; for action types, because strings are serializable, and by using Symbols you make recording and replaying harder than it needs to be.</source>
          <target state="translated">Принято считать, что действия имеют постоянный тип, который помогает редукторам (или Stores in Flux) их идентифицировать. Мы рекомендуем вам использовать строки, а не &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Symbol&quot;&gt;символы&lt;/a&gt; для типов действий, потому что строки сериализуемы, а с помощью символов вы усложняете запись и воспроизведение, чем это должно быть.</target>
        </trans-unit>
        <trans-unit id="61c76ff225751e91aabc5dfc794a50b75a44444c" translate="yes" xml:space="preserve">
          <source>It is a low-level API. Most likely, instead of using it directly, you'll use React (or other) bindings. If you commonly use the callback as a hook to react to state changes, you might want to &lt;a href=&quot;https://github.com/reactjs/redux/issues/303#issuecomment-125184409&quot;&gt;write a custom &lt;code&gt;observeStore&lt;/code&gt; utility&lt;/a&gt;. The &lt;code&gt;Store&lt;/code&gt; is also an &lt;a href=&quot;https://github.com/zenparsing/es-observable&quot;&gt;&lt;code&gt;Observable&lt;/code&gt;&lt;/a&gt;, so you can &lt;code&gt;subscribe&lt;/code&gt; to changes with libraries like &lt;a href=&quot;https://github.com/ReactiveX/RxJS&quot;&gt;RxJS&lt;/a&gt;.</source>
          <target state="translated">Это низкоуровневый API. Скорее всего, вместо того, чтобы использовать его напрямую, вы будете использовать привязки React (или другие). Если вы обычно используете обратный вызов как ловушку для реакции на изменения состояния, вы можете &lt;a href=&quot;https://github.com/reactjs/redux/issues/303#issuecomment-125184409&quot;&gt;написать собственную утилиту &lt;code&gt;observeStore&lt;/code&gt; &lt;/a&gt; . &lt;code&gt;Store&lt;/code&gt; также &lt;a href=&quot;https://github.com/zenparsing/es-observable&quot;&gt; &lt;code&gt;Observable&lt;/code&gt; &lt;/a&gt; , так что вы можете &lt;code&gt;subscribe&lt;/code&gt; на изменения с библиотеками , как &lt;a href=&quot;https://github.com/ReactiveX/RxJS&quot;&gt;RxJS&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="018b00e74a0acae9e7da52a47b45a777f33a4762" translate="yes" xml:space="preserve">
          <source>It is a low-level API. Most likely, instead of using it directly, you'll use React (or other) bindings. If you commonly use the callback as a hook to react to state changes, you might want to &lt;a href=&quot;https://github.com/reduxjs/redux/issues/303#issuecomment-125184409&quot;&gt;write a custom &lt;code&gt;observeStore&lt;/code&gt; utility&lt;/a&gt;. The &lt;code&gt;Store&lt;/code&gt; is also an &lt;a href=&quot;https://github.com/zenparsing/es-observable&quot;&gt;&lt;code&gt;Observable&lt;/code&gt;&lt;/a&gt;, so you can &lt;code&gt;subscribe&lt;/code&gt; to changes with libraries like &lt;a href=&quot;https://github.com/ReactiveX/RxJS&quot;&gt;RxJS&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b86f7926b42042d8d9540bde7f55a9d1fbef0e9" translate="yes" xml:space="preserve">
          <source>It is also possible to do the reverse and migrate from Redux to any of these libraries following the same steps.</source>
          <target state="translated">Также можно сделать обратный ход и мигрировать из Redux в любую из этих библиотек,следуя тем же шагам.</target>
        </trans-unit>
        <trans-unit id="f367ba512c5331d9b1a4dc415838a8c2dbcc6d80" translate="yes" xml:space="preserve">
          <source>It is also up to us whether to keep a single top-level history:</source>
          <target state="translated">Также от нас зависит,сохранить ли хоть одну историю на высшем уровне:</target>
        </trans-unit>
        <trans-unit id="837f9f9a88a29e4f25a6eaa8ea75e703183100af" translate="yes" xml:space="preserve">
          <source>It is an advanced API. You might need this if your app implements code splitting, and you want to load some of the reducers dynamically. You might also need this if you implement a hot reloading mechanism for Redux.</source>
          <target state="translated">Это продвинутый API.Он может понадобиться,если ваше приложение реализует разделение кода,и вы хотите загрузить некоторые редукторы динамически.Он также может понадобиться,если вы реализуете механизм горячей перезагрузки для Redux.</target>
        </trans-unit>
        <trans-unit id="79971d102866cc7813eb74dfec64bdc730b286c2" translate="yes" xml:space="preserve">
          <source>It is another common convention that, instead of creating action objects inline in the places where you dispatch the actions, you would create functions generating them.</source>
          <target state="translated">Другая распространенная конвенция заключается в том,что вместо создания объектов действий в местах,куда вы отправляете действия,вы будете создавать функции,генерирующие их.</target>
        </trans-unit>
        <trans-unit id="249542e851b7d943285bfc44e6d5f0e85e9977ed" translate="yes" xml:space="preserve">
          <source>It is equal to the last value returned by the store's reducer.</source>
          <target state="translated">Оно равно последнему значению,возвращаемому редуктором магазина.</target>
        </trans-unit>
        <trans-unit id="312b7c808648f4df7cabafd144e579400360a08e" translate="yes" xml:space="preserve">
          <source>It is essential to chaining middleware!</source>
          <target state="translated">Это необходимо для приковывания промежуточного оборудования!</target>
        </trans-unit>
        <trans-unit id="dda50451faae254a9269dbf26176ea6006fc9b9e" translate="yes" xml:space="preserve">
          <source>It is highly recommended that you only put plain serializable objects, arrays, and primitives into your store. It's &lt;em&gt;technically&lt;/em&gt; possible to insert non-serializable items into the store, but doing so can break the ability to persist and rehydrate the contents of a store, as well as interfere with time-travel debugging.</source>
          <target state="translated">Настоятельно рекомендуется размещать в магазине только простые сериализуемые объекты, массивы и примитивы. Это &lt;em&gt;технически&lt;/em&gt; возможно вставить несериализуемая элементы в магазине, но это может нарушить способность сохраняться и регидратации содержимое магазина, а также мешать отладки путешествия во времени.</target>
        </trans-unit>
        <trans-unit id="0d99f22665bd7c5155d03f21570bcb486fa6b3cf" translate="yes" xml:space="preserve">
          <source>It is important for it to be separate from &lt;code&gt;SELECT_SUBREDDIT&lt;/code&gt; or &lt;code&gt;INVALIDATE_SUBREDDIT&lt;/code&gt;. While they may occur one after another, as the app grows more complex, you might want to fetch some data independently of the user action (for example, to prefetch the most popular subreddits, or to refresh stale data once in a while). You may also want to fetch in response to a route change, so it's not wise to couple fetching to some particular UI event early on.</source>
          <target state="translated">Важно, чтобы он был отделен от &lt;code&gt;SELECT_SUBREDDIT&lt;/code&gt; или &lt;code&gt;INVALIDATE_SUBREDDIT&lt;/code&gt; . Хотя они могут происходить один за другим, по мере того, как приложение становится более сложным, вы можете захотеть получить некоторые данные независимо от действий пользователя (например, для предварительной выборки наиболее популярных субреддитов или для обновления устаревших данных время от времени). Вы также можете захотеть выполнить выборку в ответ на изменение маршрута, поэтому нецелесообразно сразу связывать выборку с каким-либо конкретным событием пользовательского интерфейса.</target>
        </trans-unit>
        <trans-unit id="22e208a1f7d32f64abf692053d9b4ade71eacca6" translate="yes" xml:space="preserve">
          <source>It is reasonable to suggest that our state shape should change to answer these questions:</source>
          <target state="translated">Разумно предположить,что наш государственный строй должен измениться,чтобы ответить на эти вопросы:</target>
        </trans-unit>
        <trans-unit id="2826728cd3002c85132f865368ccf2dfda1f035c" translate="yes" xml:space="preserve">
          <source>It is tempting to modify the &lt;code&gt;state&lt;/code&gt; or &lt;code&gt;action&lt;/code&gt; passed to you by Redux. Don't do this!</source>
          <target state="translated">Заманчиво изменить &lt;code&gt;state&lt;/code&gt; или &lt;code&gt;action&lt;/code&gt; переданное вам Redux. Не делай этого!</target>
        </trans-unit>
        <trans-unit id="d8e2ea8d61178d3cf1c5299a500dca66ebcdf724" translate="yes" xml:space="preserve">
          <source>It is tiny (2kB, including dependencies).</source>
          <target state="translated">Он крошечный (2 кБ,включая зависимости).</target>
        </trans-unit>
        <trans-unit id="c1c823da484f24ab1a299266700f4f493b22a5d4" translate="yes" xml:space="preserve">
          <source>It is up to you to choose the conventions for your project. You may start by using inline strings, and later transition to constants, and maybe later group them into a single file. Redux does not have any opinion here, so use your best judgment.</source>
          <target state="translated">Вы сами выбираете конвенции для своего проекта.Вы можете начать с использования строк в строке,а затем перейти к константам,и,возможно,позже сгруппировать их в один файл.Redux не имеет здесь никакого мнения,так что используйте свои лучшие суждения.</target>
        </trans-unit>
        <trans-unit id="05093663f45944f4c69e8ddf69de181df8a06f66" translate="yes" xml:space="preserve">
          <source>It is up to you to choose the state format. You can use plain objects or something like &lt;a href=&quot;http://facebook.github.io/immutable-js/&quot;&gt;Immutable&lt;/a&gt;. If you're not sure, start with plain objects.</source>
          <target state="translated">Вам решать, в каком формате находится состояние. Вы можете использовать простые объекты или что-то вроде &lt;a href=&quot;http://facebook.github.io/immutable-js/&quot;&gt;Immutable&lt;/a&gt; . Если вы не уверены, начните с простых предметов.</target>
        </trans-unit>
        <trans-unit id="40839b1c8a38e69ec4218f19c9a385d95915a832" translate="yes" xml:space="preserve">
          <source>It is up to you to try a few options, choose a convention you like, and follow it, whether with, or without the middleware.</source>
          <target state="translated">Вы можете попробовать несколько вариантов,выбрать понравившуюся вам конвенцию и следовать ей,как с промежуточным ПО,так и без него.</target>
        </trans-unit>
        <trans-unit id="b392f0ed8ea05e547e964224687831827c136e29" translate="yes" xml:space="preserve">
          <source>It is vital that these Prerequisite Concepts are &lt;strong&gt;thoroughly understood&lt;/strong&gt; before moving on to more advanced and Redux-specific techniques. A recommended reading list is available at:</source>
          <target state="translated">Жизненно важно, чтобы эти предварительные концепции были &lt;strong&gt;полностью поняты,&lt;/strong&gt; прежде чем переходить к более продвинутым и специфичным для Redux методам. Список рекомендованной литературы доступен по адресу:</target>
        </trans-unit>
        <trans-unit id="d5fa6252549b34d2727aeeb1fe8e3c816a3d8827" translate="yes" xml:space="preserve">
          <source>It may be helpful to see examples of what the different types of sub-reducer functions look like and how they fit together. Let's look at a demonstration of how a large single reducer function can be refactored into a composition of several smaller functions.</source>
          <target state="translated">Может быть полезно посмотреть примеры того,как выглядят различные типы функций редуктора и как они подходят друг другу.Давайте посмотрим на демонстрацию того,как большая одна функция редуктора может быть рефакторизована в композицию из нескольких более мелких функций.</target>
        </trans-unit>
        <trans-unit id="e02627810b718b477472f1f76a7b34ecc56b8eb7" translate="yes" xml:space="preserve">
          <source>It must never return &lt;code&gt;undefined&lt;/code&gt;. It is too easy to do this by mistake via an early &lt;code&gt;return&lt;/code&gt; statement, so &lt;code&gt;combineReducers&lt;/code&gt; throws if you do that instead of letting the error manifest itself somewhere else.</source>
          <target state="translated">Он никогда не должен возвращать значение &lt;code&gt;undefined&lt;/code&gt; . Слишком легко сделать это по ошибке с помощью раннего оператора &lt;code&gt;return&lt;/code&gt; , &lt;code&gt;combineReducers&lt;/code&gt; выбрасывает, если вы это делаете, вместо того, чтобы позволить ошибке проявиться где-то еще.</target>
        </trans-unit>
        <trans-unit id="b1440628c9081aad68267a2e66c7ba0b0ef6cf7d" translate="yes" xml:space="preserve">
          <source>It needs to be rewritten like this:</source>
          <target state="translated">Его нужно переписать вот так:</target>
        </trans-unit>
        <trans-unit id="2003fb7b90831988d1d806aec866ee85ca010393" translate="yes" xml:space="preserve">
          <source>It needs to look at the previous state and the dispatched action, and determine what kind of work needs to be done</source>
          <target state="translated">Ему необходимо посмотреть на предыдущее состояние и отправленную операцию,а также определить,какую работу необходимо проделать.</target>
        </trans-unit>
        <trans-unit id="5761524a50c8fdeeafeab8c5ae63d8a8423998ef" translate="yes" xml:space="preserve">
          <source>It only exposes a subset of the &lt;a href=&quot;../api/store&quot;&gt;store API&lt;/a&gt; to the middleware: &lt;a href=&quot;../api/store#dispatch&quot;&gt;&lt;code&gt;dispatch(action)&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../api/store#getState&quot;&gt;&lt;code&gt;getState()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Он предоставляет промежуточному программному обеспечению только подмножество &lt;a href=&quot;../api/store&quot;&gt;API магазина&lt;/a&gt; : &lt;a href=&quot;../api/store#dispatch&quot;&gt; &lt;code&gt;dispatch(action)&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;../api/store#getState&quot;&gt; &lt;code&gt;getState()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c914355546b42c63de745bfcca2aaeb3e2313f74" translate="yes" xml:space="preserve">
          <source>It seems that reducer isn't the right abstraction, but we're very close.</source>
          <target state="translated">Похоже,что редуктор не является правильной абстракцией,но мы очень близки.</target>
        </trans-unit>
        <trans-unit id="beb2e2454ed95b3107fe31d45f50cecc81a6856f" translate="yes" xml:space="preserve">
          <source>It then runs a shallow equality check on its reference to the root state object and the state object passed to it, and a separate series of shallow checks on each reference to the props object&amp;rsquo;s values and those that are returned from running the &lt;code&gt;mapStateToProps&lt;/code&gt; function again.</source>
          <target state="translated">Затем он запускает неглубокую проверку на равенство своей ссылки на корневой объект состояния и переданный ему объект состояния, а также отдельную серию неглубоких проверок для каждой ссылки на значения объекта реквизита и тех, которые возвращаются при &lt;code&gt;mapStateToProps&lt;/code&gt; функции mapStateToProps .</target>
        </trans-unit>
        <trans-unit id="7396f0cc913742a2329483587f6bde1029a53425" translate="yes" xml:space="preserve">
          <source>It will then combine both sets of results into a single state tree:</source>
          <target state="translated">Затем он объединит оба набора результатов в единое дерево состояний:</target>
        </trans-unit>
        <trans-unit id="fe6fecbba3b0b6d0528af6e5ce21a171dd9d1cfb" translate="yes" xml:space="preserve">
          <source>It's a &lt;a href=&quot;http://knowyourmeme.com/memes/we-need-to-go-deeper&quot;&gt;&amp;ldquo;we need to go deeper&amp;rdquo;&lt;/a&gt; kind of moment, so it might take a while for this to make sense. The function cascade feels intimidating. ES6 arrow functions make this &lt;a href=&quot;https://en.wikipedia.org/wiki/Currying&quot;&gt;currying&lt;/a&gt; easier on eyes:</source>
          <target state="translated">Это момент &lt;a href=&quot;http://knowyourmeme.com/memes/we-need-to-go-deeper&quot;&gt;&amp;laquo;нам нужно пойти глубже&amp;raquo;&lt;/a&gt; , поэтому может потребоваться время, чтобы это обрело смысл. Каскад функций пугает. Функции стрелок ES6 упрощают &lt;a href=&quot;https://en.wikipedia.org/wiki/Currying&quot;&gt;каррирование&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="53bb5e1d4ed878477f0cfe96c4cca984251e5713" translate="yes" xml:space="preserve">
          <source>It's a good idea to pass as little data in each action as possible. For example, it's better to pass &lt;code&gt;index&lt;/code&gt; than the whole todo object.</source>
          <target state="translated">Рекомендуется передавать в каждое действие как можно меньше данных. Например, лучше передать &lt;code&gt;index&lt;/code&gt; , чем весь объект todo.</target>
        </trans-unit>
        <trans-unit id="66564241e2f2072f8ffd6342ef4d5f057cfbf2e9" translate="yes" xml:space="preserve">
          <source>It's also important to note that some of these suggestions may or may not be directly applicable based on architectural decisions in a specific application. For example, an application using Immutable.js Maps to store data would likely have its reducer logic structured at least somewhat differently than an application using plain Javascript objects. This documentation primarily assumes use of plain Javascript objects, but many of the principles would still apply if using other tools.</source>
          <target state="translated">Важно также отметить,что некоторые из этих предложений могут непосредственно применяться или не применяться на основе архитектурных решений в конкретной заявке.Например,приложение,использующее Immutable.js Maps для хранения данных,скорее всего,будет иметь свою редукционную логику,по крайней мере,несколько отличную от приложения,использующего простые объекты на Javascript.Эта документация в основном предполагает использование простых объектов на Javascript,но многие из принципов все равно будут применяться при использовании других инструментов.</target>
        </trans-unit>
        <trans-unit id="1d8a4e5e3006a924b03ad0f0eb598b2f0f5eaed6" translate="yes" xml:space="preserve">
          <source>It's best not to mix this approach with standard Redux reducer composition. For typical web apps, stick with reducer composition. For &amp;ldquo;product hubs&amp;rdquo;, &amp;ldquo;dashboards&amp;rdquo;, or enterprise software that groups disparate tools into a unified package, give the sub-app approach a try.</source>
          <target state="translated">Лучше не смешивать этот подход со стандартной композицией редуктора Redux. Для типичных веб-приложений придерживайтесь состава редуктора. Для &amp;laquo;концентраторов продуктов&amp;raquo;, &amp;laquo;информационных панелей&amp;raquo; или корпоративного программного обеспечения, которое объединяет разрозненные инструменты в единый пакет, попробуйте использовать подход субприложения.</target>
        </trans-unit>
        <trans-unit id="252a3efbc077a7d5a93fd6d1dbfedaa2d2669df6" translate="yes" xml:space="preserve">
          <source>It's called a reducer because it's the type of function you would pass to &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce&quot;&gt;&lt;code&gt;Array.prototype.reduce(reducer, ?initialValue)&lt;/code&gt;&lt;/a&gt;. It's very important that the reducer stays pure. Things you should &lt;strong&gt;never&lt;/strong&gt; do inside a reducer:</source>
          <target state="translated">Он называется редуктором, потому что это тип функции, которую вы передаете в &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce&quot;&gt; &lt;code&gt;Array.prototype.reduce(reducer, ?initialValue)&lt;/code&gt; &lt;/a&gt; . Очень важно, чтобы редуктор оставался чистым. Что &lt;strong&gt;никогда&lt;/strong&gt; не следует делать внутри редуктора:</target>
        </trans-unit>
        <trans-unit id="6a58a3a8e0f482a446b06f379efada2fd4c57438" translate="yes" xml:space="preserve">
          <source>It's easy to create a store if you have a reducer. In the &lt;a href=&quot;reducers&quot;&gt;previous section&lt;/a&gt;, we used &lt;a href=&quot;../api/combinereducers&quot;&gt;&lt;code&gt;combineReducers()&lt;/code&gt;&lt;/a&gt; to combine several reducers into one. We will now import it, and pass it to &lt;a href=&quot;../api/createstore&quot;&gt;&lt;code&gt;createStore()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Если у вас есть редуктор, создать магазин просто. В &lt;a href=&quot;reducers&quot;&gt;предыдущем разделе&lt;/a&gt; мы использовали &lt;a href=&quot;../api/combinereducers&quot;&gt; &lt;code&gt;combineReducers()&lt;/code&gt; &lt;/a&gt; для объединения нескольких редукторов в один. Теперь мы импортируем его и передадим в &lt;a href=&quot;../api/createstore&quot;&gt; &lt;code&gt;createStore()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="fb4ae669548f27a4108b547b46fa2c12ac612f32" translate="yes" xml:space="preserve">
          <source>It's for this improvement in performance that Redux uses shallow equality checking.</source>
          <target state="translated">Именно для такого улучшения производительности Redux использует мелкую проверку равенства.</target>
        </trans-unit>
        <trans-unit id="98dcf0d417fbe43fd9477364b70c4f9d857c65e0" translate="yes" xml:space="preserve">
          <source>It's generally suggested that selectors are defined alongside reducers and exported, and then reused elsewhere (such as in &lt;code&gt;mapStateToProps&lt;/code&gt; functions, in async action creators, or sagas) to colocate all the code that knows about the actual shape of the state tree in the reducer files.</source>
          <target state="translated">Обычно предполагается, что селекторы определяются вместе с редукторами и экспортируются, а затем повторно используются в других местах (например, в &lt;code&gt;mapStateToProps&lt;/code&gt; , в создателях асинхронных действий или в сагах) для размещения всего кода, который знает о фактической форме дерева состояний в файлах редуктора. .</target>
        </trans-unit>
        <trans-unit id="9a8921bdd4ecd237805498907dc4327f0981b88e" translate="yes" xml:space="preserve">
          <source>It's important to note that a Redux store really only has a single reducer function. The store passes the current state and dispatched action to that one reducer function, and lets the reducer handle things appropriately.</source>
          <target state="translated">Важно отметить,что в магазине Redux действительно есть только одна функция редуктора.Магазин передает текущее состояние и посылает действия одной из функций редуктора и позволяет редуктору корректно работать с вещами.</target>
        </trans-unit>
        <trans-unit id="c36768ba51d801006d900629e7ac3f3a13e90bcd" translate="yes" xml:space="preserve">
          <source>It's important to note that you'll only have a single store in a Redux application. When you want to split your data handling logic, you'll use &lt;a href=&quot;reducers#splitting-reducers&quot;&gt;reducer composition&lt;/a&gt; instead of many stores.</source>
          <target state="translated">Важно отметить, что у вас будет только одно хранилище в приложении Redux. Если вы хотите разделить логику обработки данных, вы будете использовать &lt;a href=&quot;reducers#splitting-reducers&quot;&gt;композицию редуктора&lt;/a&gt; вместо множества хранилищ.</target>
        </trans-unit>
        <trans-unit id="61d4dad8daf83a3b27a53b849070082ed3ffa990" translate="yes" xml:space="preserve">
          <source>It's important to remember that whenever you update a nested value, you must also return new copies of anything above it in your state tree. If you have &lt;code&gt;state.a.b.c.d&lt;/code&gt;, and you want to make an update to &lt;code&gt;d&lt;/code&gt;, you would also need to return new copies of &lt;code&gt;c&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt;, &lt;code&gt;a&lt;/code&gt;, and &lt;code&gt;state&lt;/code&gt;. This &lt;a href=&quot;http://arqex.com/wp-content/uploads/2015/02/trees.png&quot;&gt;state tree mutation diagram&lt;/a&gt; demonstrates how a change deep in a tree requires changes all the way up.</source>
          <target state="translated">Важно помнить, что всякий раз, когда вы обновляете вложенное значение, вы также должны возвращать новые копии всего, что находится над ним в дереве состояний. Если у вас есть &lt;code&gt;state.a.b.c.d&lt;/code&gt; и вы хотите обновить &lt;code&gt;d&lt;/code&gt; , вам также нужно будет вернуть новые копии &lt;code&gt;c&lt;/code&gt; , &lt;code&gt;b&lt;/code&gt; , &lt;code&gt;a&lt;/code&gt; и &lt;code&gt;state&lt;/code&gt; . Эта &lt;a href=&quot;http://arqex.com/wp-content/uploads/2015/02/trees.png&quot;&gt;диаграмма мутации дерева состояний&lt;/a&gt; демонстрирует, как изменение в глубине дерева требует изменений на всем его протяжении.</target>
        </trans-unit>
        <trans-unit id="c339b6732e0d2b2a42a0ddd93251b26fe3ad96b4" translate="yes" xml:space="preserve">
          <source>It's more code, but it's exactly what makes Redux predictable and efficient. If you want to have less code, you can use a helper like &lt;a href=&quot;https://facebook.github.io/react/docs/update.html&quot;&gt;&lt;code&gt;React.addons.update&lt;/code&gt;&lt;/a&gt; to write immutable transformations with a terse syntax:</source>
          <target state="translated">Это больше кода, но именно это делает Redux предсказуемым и эффективным. Если вы хотите иметь меньше кода, вы можете использовать помощник, например &lt;a href=&quot;https://facebook.github.io/react/docs/update.html&quot;&gt; &lt;code&gt;React.addons.update&lt;/code&gt; ,&lt;/a&gt; для написания неизменяемых преобразований с кратким синтаксисом:</target>
        </trans-unit>
        <trans-unit id="6f3ca2b8ee117276e54d75838be64e770429f6ba" translate="yes" xml:space="preserve">
          <source>It's not always immediately clear how these two approaches interact. Fortunately, the process does follow some predictable rules. Here's how the pieces fit together.</source>
          <target state="translated">Не всегда сразу понятно,как эти два подхода взаимодействуют.К счастью,процесс действительно следует некоторым предсказуемым правилам.Вот как эти части подходят друг другу.</target>
        </trans-unit>
        <trans-unit id="d0ab78e0353e7cd035a999d2fa8e5af4c2f963ef" translate="yes" xml:space="preserve">
          <source>It's possible you're correctly dispatching an action and applying your reducer but the corresponding state is not being correctly translated into props.</source>
          <target state="translated">Возможно,вы правильно распределяете действие и применяете редуктор,но соответствующее состояние неправильно трансформируется в реквизит.</target>
        </trans-unit>
        <trans-unit id="4543176cfbe02cd87a4507bdb08d9c22f1859120" translate="yes" xml:space="preserve">
          <source>It's unfortunate that many still choose Flux framework based on whether it uses &lt;code&gt;switch&lt;/code&gt; statements in the documentation. If you don't like &lt;code&gt;switch&lt;/code&gt;, you can solve this with a single function, as we show below.</source>
          <target state="translated">К сожалению, многие по-прежнему выбирают фреймворк Flux в зависимости от того, использует ли он в документации операторы &lt;code&gt;switch&lt;/code&gt; . Если вам не нравится &lt;code&gt;switch&lt;/code&gt; , вы можете решить эту проблему с помощью одной функции, как показано ниже.</target>
        </trans-unit>
        <trans-unit id="7e539fa93863f712b20c2f16d75b4287d6434876" translate="yes" xml:space="preserve">
          <source>It's unfortunate that many still choose a framework based on whether it uses &lt;code&gt;switch&lt;/code&gt; statements in the documentation. If you don't like &lt;code&gt;switch&lt;/code&gt;, you can use a custom &lt;code&gt;createReducer&lt;/code&gt; function that accepts a handler map, as shown in &lt;a href=&quot;../recipes/reducingboilerplate#reducers&quot;&gt;&amp;ldquo;reducing boilerplate&amp;rdquo;&lt;/a&gt;.</source>
          <target state="translated">К сожалению, многие по-прежнему выбирают фреймворк в зависимости от того, используются ли в документации операторы &lt;code&gt;switch&lt;/code&gt; . Если вам не нравится &lt;code&gt;switch&lt;/code&gt; , вы можете использовать настраиваемую функцию &lt;code&gt;createReducer&lt;/code&gt; , которая принимает карту обработчика, как показано в &lt;a href=&quot;../recipes/reducingboilerplate#reducers&quot;&gt;разделе &amp;laquo;сокращение шаблона&amp;raquo;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2bb2765277319f208309e2db82a727dcbfdec808" translate="yes" xml:space="preserve">
          <source>JavaScript Application Architecture On The Road To 2015</source>
          <target state="translated">Архитектура приложений JavaScript на пути к 2015 г.</target>
        </trans-unit>
        <trans-unit id="5663d16ece82a891feaade5f2800177cdbd06bf0" translate="yes" xml:space="preserve">
          <source>JavaScript Immutability presentation (PDF - see slide 12 for benefits)</source>
          <target state="translated">Презентация JavaScript Непрерывность (PDF-см.преимущества в слайде 12).</target>
        </trans-unit>
        <trans-unit id="5686c8f6acca3473e05ae8e791a2b0127eaac9e5" translate="yes" xml:space="preserve">
          <source>JavaScript and Immutability</source>
          <target state="translated">JavaScript и Непреложность</target>
        </trans-unit>
        <trans-unit id="48e85cf4e700b35b1170cf47611de9569a23efdc" translate="yes" xml:space="preserve">
          <source>JavaScript does not provide immutable data structures. As such, for Immutable.JS to provide its immutable guarantees, your data must be encapsulated within an Immutable.JS object (such as a &lt;code&gt;Map&lt;/code&gt; or a &lt;code&gt;List&lt;/code&gt;, etc.). Once it&amp;rsquo;s contained in this way, it&amp;rsquo;s hard for that data to then interoperate with other, plain JavaScript objects.</source>
          <target state="translated">JavaScript не предоставляет неизменяемых структур данных. Таким образом, чтобы Immutable.JS предоставлял свои неизменяемые гарантии, ваши данные должны быть инкапсулированы в объект Immutable.JS (например, &lt;code&gt;Map&lt;/code&gt; или &lt;code&gt;List&lt;/code&gt; и т. Д.). После того, как они содержатся таким образом, этим данным будет трудно взаимодействовать с другими простыми объектами JavaScript.</target>
        </trans-unit>
        <trans-unit id="db1e7af6d4d988f37e8c96dfd9be6dd7f8c52667" translate="yes" xml:space="preserve">
          <source>JavaScript was never designed to provide guaranteed immutable operations. Accordingly, there are several issues you need to be aware of if you choose to use it for your immutable operations in your Redux app.</source>
          <target state="translated">JavaScript никогда не был разработан для обеспечения гарантированной непрерывности операций.Соответственно,есть несколько проблем,о которых вы должны знать,если вы решите использовать его для своих неизменяемых операций в вашем приложении Redux.</target>
        </trans-unit>
        <trans-unit id="e4f9a7a1a37cb18678bb27808982a0fab518f2bf" translate="yes" xml:space="preserve">
          <source>Javascript and Immutability</source>
          <target state="translated">Яваскрипт и Непреложность</target>
        </trans-unit>
        <trans-unit id="8190845a1ebdd8d76968f6c6f761a6be3b93edae" translate="yes" xml:space="preserve">
          <source>Jing Chen, creator of Flux</source>
          <target state="translated">Цзин Чен,создатель &quot;Флюса&quot;...</target>
        </trans-unit>
        <trans-unit id="951a42e3bc90a6103cf2aad8fcbde2477e07ad4f" translate="yes" xml:space="preserve">
          <source>Join the &lt;a href=&quot;https://discord.gg/0ZcbPKXt5bZ6au5t&quot;&gt;#redux&lt;/a&gt; channel of the &lt;a href=&quot;http://www.reactiflux.com&quot;&gt;Reactiflux&lt;/a&gt; Discord community.</source>
          <target state="translated">Присоединяйтесь к &lt;a href=&quot;https://discord.gg/0ZcbPKXt5bZ6au5t&quot;&gt;#redux&lt;/a&gt; канала &lt;a href=&quot;http://www.reactiflux.com&quot;&gt;Reactiflux&lt;/a&gt; сообщества раздора.</target>
        </trans-unit>
        <trans-unit id="e399f1c349f8769ebbb0daf23b23eccbf46daf27" translate="yes" xml:space="preserve">
          <source>Just like before, we never write directly to &lt;code&gt;state&lt;/code&gt; or its fields, and instead we return new objects. The new &lt;code&gt;todos&lt;/code&gt; is equal to the old &lt;code&gt;todos&lt;/code&gt; concatenated with a single new item at the end. The fresh todo was constructed using the data from the action.</source>
          <target state="translated">Как и раньше, мы никогда не пишем напрямую в &lt;code&gt;state&lt;/code&gt; или его поля, а вместо этого возвращаем новые объекты. Новые &lt;code&gt;todos&lt;/code&gt; равны старым &lt;code&gt;todos&lt;/code&gt; объединенным с одним новым элементом в конце. Новое задание было построено с использованием данных из действия.</target>
        </trans-unit>
        <trans-unit id="4775133d954dab5abc63710e9c6e38a2239ee177" translate="yes" xml:space="preserve">
          <source>Just like in the basic tutorial, you'll need to &lt;a href=&quot;../basics/reducers#designing-the-state-shape&quot;&gt;design the shape of your application's state&lt;/a&gt; before rushing into the implementation. With asynchronous code, there is more state to take care of, so we need to think it through.</source>
          <target state="translated">Как и в базовом руководстве, вам нужно будет &lt;a href=&quot;../basics/reducers#designing-the-state-shape&quot;&gt;спроектировать форму состояния вашего приложения,&lt;/a&gt; прежде чем приступать к реализации. В асинхронном коде нужно позаботиться о большем количестве состояний, поэтому нам нужно все продумать.</target>
        </trans-unit>
        <trans-unit id="c6df178ca4d41674a93e54d6ff850afe3eceb958" translate="yes" xml:space="preserve">
          <source>Laurence Roberts</source>
          <target state="translated">Лоуренс Робертс</target>
        </trans-unit>
        <trans-unit id="a8e78fb63e60ac2949bd5cbbb13dfecd20351939" translate="yes" xml:space="preserve">
          <source>Learn Redux from Its Creator</source>
          <target state="translated">Учись Редукс у его создателя</target>
        </trans-unit>
        <trans-unit id="815813ef04db0611309243e056689002bfca2f51" translate="yes" xml:space="preserve">
          <source>Learning Functional Programming in Javascript</source>
          <target state="translated">Обучение функциональному программированию на Javascript</target>
        </trans-unit>
        <trans-unit id="204c47c7f7b6077c5cc66fb4275cccc654adf5ff" translate="yes" xml:space="preserve">
          <source>Learning Redux</source>
          <target state="translated">Learning Redux</target>
        </trans-unit>
        <trans-unit id="f18ace0f4dc5ebb1cb3f958d948cec6b1bfd54fc" translate="yes" xml:space="preserve">
          <source>Lee Byron on Twitter: &amp;ldquo;Perf tip for #immutablejs&amp;hellip;&amp;rdquo;</source>
          <target state="translated">Ли Байрон в Twitter: &amp;laquo;Совет от разработчиков для # immutablejs&amp;hellip;&amp;raquo;</target>
        </trans-unit>
        <trans-unit id="0d516f563abbe7f29a4e3ee915a4a5746abb4a29" translate="yes" xml:space="preserve">
          <source>Let's consider a different scenario:</source>
          <target state="translated">Давайте рассмотрим другой сценарий:</target>
        </trans-unit>
        <trans-unit id="30e9663293d38e3d33c344fc2983eb83f3e158b6" translate="yes" xml:space="preserve">
          <source>Let's create a function named &lt;code&gt;makeGetVisibleTodos&lt;/code&gt; that returns a new copy of the &lt;code&gt;getVisibleTodos&lt;/code&gt; selector each time it is called:</source>
          <target state="translated">Давайте создадим функцию с именем &lt;code&gt;makeGetVisibleTodos&lt;/code&gt; , которая возвращает новую копию селектора &lt;code&gt;getVisibleTodos&lt;/code&gt; каждый раз, когда он вызывается:</target>
        </trans-unit>
        <trans-unit id="fd130845bbec5d16d12cb399e0c3cbfeb2c430a7" translate="yes" xml:space="preserve">
          <source>Let's define a memoized selector named &lt;code&gt;getVisibleTodos&lt;/code&gt; to replace the non-memoized version above:</source>
          <target state="translated">Давайте определим мемоизированный селектор с именем &lt;code&gt;getVisibleTodos&lt;/code&gt; , чтобы заменить немомоизированную версию выше:</target>
        </trans-unit>
        <trans-unit id="c3a4dc14b145305dfe293196d07e8aa73560d7a5" translate="yes" xml:space="preserve">
          <source>Let's explore reducer composition more. Can we also extract a reducer managing just &lt;code&gt;visibilityFilter&lt;/code&gt;? We can.</source>
          <target state="translated">Давайте подробнее рассмотрим состав редуктора. Можем ли мы также извлечь редуктор, управляющий только &lt;code&gt;visibilityFilter&lt;/code&gt; ? Мы можем.</target>
        </trans-unit>
        <trans-unit id="3d63428074244e2479b8e425262f560268ac5f43" translate="yes" xml:space="preserve">
          <source>Let's recall what the combined reducer does:</source>
          <target state="translated">Давайте вспомним,что делает комбинированный редуктор:</target>
        </trans-unit>
        <trans-unit id="384774d8dbe43962eb49ce001e2d96e26d96ea07" translate="yes" xml:space="preserve">
          <source>Let's revisit the &lt;a href=&quot;../basics/usagewithreact&quot;&gt;Todos List example&lt;/a&gt;:</source>
          <target state="translated">Вернемся к &lt;a href=&quot;../basics/usagewithreact&quot;&gt;примеру со списком Todos&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="ed19a0e0fde116aef33b7018b7a9bbcce6346bdc" translate="yes" xml:space="preserve">
          <source>Let's say a designer comes back to us after reviewing our prototype, and tells us that we need to allow three todos maximum. We can enforce this by rewriting our action creator to a callback form with &lt;a href=&quot;https://github.com/gaearon/redux-thunk&quot;&gt;redux-thunk&lt;/a&gt; middleware and adding an early exit:</source>
          <target state="translated">Допустим, дизайнер возвращается к нам после просмотра нашего прототипа и говорит, что нам нужно разрешить максимум три задачи. Мы можем добиться этого, переписав нашего создателя действий в форму обратного вызова с промежуточным программным обеспечением &lt;a href=&quot;https://github.com/gaearon/redux-thunk&quot;&gt;redux-thunk&lt;/a&gt; и добавив ранний выход:</target>
        </trans-unit>
        <trans-unit id="d23a5d0451ec5d5abafa771961468240b19ed964" translate="yes" xml:space="preserve">
          <source>Let's say that our initial reducer looks like this:</source>
          <target state="translated">Скажем так,наш первоначальный редуктор выглядит вот так:</target>
        </trans-unit>
        <trans-unit id="a42244fb104feca9e7eb72186a85fa8a258a8b6f" translate="yes" xml:space="preserve">
          <source>Let's start by defining the several synchronous action types and action creators we need in our example app. Here, the user can select a subreddit to display:</source>
          <target state="translated">Давайте начнем с определения нескольких синхронных типов действий и создателей действий,которые нам нужны в нашем примере приложения.Здесь пользователь может выбрать подвыборку для отображения:</target>
        </trans-unit>
        <trans-unit id="6be34e2837216ea61f99fc5d5668808369bc5adc" translate="yes" xml:space="preserve">
          <source>Let's take a look at our new client file:</source>
          <target state="translated">Давайте взглянем на наш новый файл клиента:</target>
        </trans-unit>
        <trans-unit id="b409b71e81ab2b58978b981a343bc5bce51dcd92" translate="yes" xml:space="preserve">
          <source>Let's talk through the algorithm to manipulate the state shape described above. We can define two actions to operate on this state: &lt;code&gt;UNDO&lt;/code&gt; and &lt;code&gt;REDO&lt;/code&gt;. In our reducer, we will do the following steps to handle these actions:</source>
          <target state="translated">Давайте обсудим алгоритм управления формой состояния, описанный выше. Мы можем определить два действия для работы с этим состоянием: &lt;code&gt;UNDO&lt;/code&gt; и &lt;code&gt;REDO&lt;/code&gt; . В нашем редукторе мы сделаем следующие шаги для обработки этих действий:</target>
        </trans-unit>
        <trans-unit id="dd3902ab0d1d59de82883d31a36cdd78b461122c" translate="yes" xml:space="preserve">
          <source>Let's write a function that lets us express reducers as an object mapping from action types to handlers. For example, if we want our &lt;code&gt;todos&lt;/code&gt; reducers to be defined like this:</source>
          <target state="translated">Давайте напишем функцию, которая позволяет нам выражать редукторы как отображение объектов от типов действий к обработчикам. Например, если мы хотим, чтобы наши редукторы &lt;code&gt;todos&lt;/code&gt; были определены следующим образом:</target>
        </trans-unit>
        <trans-unit id="e72eaffd3ac1dcb5208c2d6ea7b42f2173627e6a" translate="yes" xml:space="preserve">
          <source>Let's write the components! We begin with the presentational components so we don't need to think about binding to Redux yet.</source>
          <target state="translated">Давайте напишем компоненты! Мы начинаем с презентационных компонентов,так что нам пока не нужно думать о привязке к Redux.</target>
        </trans-unit>
        <trans-unit id="4642d8e2bbb9a67ffddd44f6258e15948144b9a5" translate="yes" xml:space="preserve">
          <source>Leveling Up with React: Redux</source>
          <target state="translated">Выравнивание с помощью реакции:Redux</target>
        </trans-unit>
        <trans-unit id="3229609e15436ec51bcf00818a69a84dbc58a0c2" translate="yes" xml:space="preserve">
          <source>License</source>
          <target state="translated">License</target>
        </trans-unit>
        <trans-unit id="58fd3b1b83cc7fc933d72fe934bdb6e534441281" translate="yes" xml:space="preserve">
          <source>Licensed under the MIT License.</source>
          <target state="translated">Лицензия MIT.</target>
        </trans-unit>
        <trans-unit id="ef7dd92b3bad02dfcc7661e876c8b68c18ebfc35" translate="yes" xml:space="preserve">
          <source>Limit your use of &lt;code&gt;toJS()&lt;/code&gt;</source>
          <target state="translated">Ограничьте использование &lt;code&gt;toJS()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="83fce8327410848c9eb609acb21732c7c0fec96a" translate="yes" xml:space="preserve">
          <source>Logo</source>
          <target state="translated">Logo</target>
        </trans-unit>
        <trans-unit id="89690ac571dcf4c9c40c842efed3f11171d07b29" translate="yes" xml:space="preserve">
          <source>MIT</source>
          <target state="translated">MIT</target>
        </trans-unit>
        <trans-unit id="17367293ad2021231bf611dd0dd27a355d38e2d6" translate="yes" xml:space="preserve">
          <source>Make sure mapStateToProps is correct</source>
          <target state="translated">Убедитесь,что mapStateToProps верна.</target>
        </trans-unit>
        <trans-unit id="9f370227bbf65772938b3d8e358e2ce2218a1a54" translate="yes" xml:space="preserve">
          <source>Make sure that you use &lt;code&gt;Object.assign&lt;/code&gt; correctly. For example, instead of returning something like &lt;code&gt;Object.assign(state, newData)&lt;/code&gt; from your reducers, return &lt;code&gt;Object.assign({}, state, newData)&lt;/code&gt;. This way you don't override the previous &lt;code&gt;state&lt;/code&gt;.</source>
          <target state="translated">Убедитесь, что вы правильно используете &lt;code&gt;Object.assign&lt;/code&gt; . Например, вместо того, чтобы возвращать что-то вроде &lt;code&gt;Object.assign(state, newData)&lt;/code&gt; из редукторов, верните &lt;code&gt;Object.assign({}, state, newData)&lt;/code&gt; . Таким образом, вы не переопределите предыдущее &lt;code&gt;state&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5d8418eedd0d6a2db483537e4446820ce1952555" translate="yes" xml:space="preserve">
          <source>Make your entire Redux state tree an Immutable.JS object</source>
          <target state="translated">Сделайте все ваше дерево состояния Redux неизменяемым.JS объектом.</target>
        </trans-unit>
        <trans-unit id="91529d50836c68b2f85612f8480c39828f101131" translate="yes" xml:space="preserve">
          <source>Managing Normalized Data</source>
          <target state="translated">Управление нормализованными данными</target>
        </trans-unit>
        <trans-unit id="b8cfd188b6fb6ef58e95265e7bee55786bad588a" translate="yes" xml:space="preserve">
          <source>Managing this ever-changing state is hard. If a model can update another model, then a view can update a model, which updates another model, and this, in turn, might cause another view to update. At some point, you no longer understand what happens in your app as you have &lt;strong&gt;lost control over the when, why, and how of its state.&lt;/strong&gt; When a system is opaque and non-deterministic, it's hard to reproduce bugs or add new features.</source>
          <target state="translated">Управлять этим постоянно меняющимся состоянием сложно. Если модель может обновлять другую модель, тогда представление может обновлять модель, которая обновляет другую модель, а это, в свою очередь, может вызвать обновление другого представления. В какой-то момент вы больше не понимаете, что происходит в вашем приложении, поскольку &lt;strong&gt;теряете контроль над его состоянием, когда, почему и как. &lt;/strong&gt;Когда система непрозрачна и недетерминирована, трудно воспроизводить ошибки или добавлять новые функции.</target>
        </trans-unit>
        <trans-unit id="770e69d1c946703f5c3589b40d2b5d1f60424fb5" translate="yes" xml:space="preserve">
          <source>Many applications deal with data that is nested or relational in nature. For example, a blog editor could have many Posts, each Post could have many Comments, and both Posts and Comments would be written by a User. Data for this kind of application might look like:</source>
          <target state="translated">Многие приложения работают с данными,которые являются вложенными или реляционными по своей природе.Например,в редакторе блога может быть много Папок,в каждой Папке может быть много Комментариев,и Папки,и Комментарии будут написаны Пользователем.Данные для такого рода приложений могут выглядеть так:</target>
        </trans-unit>
        <trans-unit id="d062b20c46aa58461072521c5ff06fd5c22eadb2" translate="yes" xml:space="preserve">
          <source>Many users later want to try to share data between two reducers, but find that &lt;code&gt;combineReducers&lt;/code&gt; does not allow them to do so. There are several approaches that can be used:</source>
          <target state="translated">Многие пользователи позже захотят попытаться разделить данные между двумя редукторами, но обнаруживают, что &lt;code&gt;combineReducers&lt;/code&gt; не позволяет им это делать. Можно использовать несколько подходов:</target>
        </trans-unit>
        <trans-unit id="1f7bcd6c888e6b88d0545bc697de285055397b49" translate="yes" xml:space="preserve">
          <source>Maybe we want to be able to run multiple instances of it in the same &amp;ldquo;bigger&amp;rdquo; app and keep it as a complete black box, with Redux being an implementation detail.</source>
          <target state="translated">Возможно, мы хотим иметь возможность запускать несколько его экземпляров в одном и том же &amp;laquo;большом&amp;raquo; приложении и хранить его как полный черный ящик, а Redux - это деталь реализации.</target>
        </trans-unit>
        <trans-unit id="99890f553cee2767e33647e04645b77191093369" translate="yes" xml:space="preserve">
          <source>Meet Reducer Enhancers</source>
          <target state="translated">Знакомьтесь,Редюцер Расширители</target>
        </trans-unit>
        <trans-unit id="1335c9d05ff6249a581b2af47d8ca262af71f878" translate="yes" xml:space="preserve">
          <source>Meet some of the outstanding companies that made it possible:</source>
          <target state="translated">Познакомьтесь с некоторыми выдающимися компаниями,которые сделали это возможным:</target>
        </trans-unit>
        <trans-unit id="eb8978ed84b5906ad4191a0b252828be64701bfa" translate="yes" xml:space="preserve">
          <source>Middleware</source>
          <target state="translated">Middleware</target>
        </trans-unit>
        <trans-unit id="4de8569a40d6be412d5f73fc6d679fbd847a1bc7" translate="yes" xml:space="preserve">
          <source>Middleware functions wrap behavior of &lt;code&gt;dispatch&lt;/code&gt; calls in Redux, so to test this modified behavior we need to mock the behavior of the &lt;code&gt;dispatch&lt;/code&gt; call.</source>
          <target state="translated">Функции промежуточного программного обеспечения обертывают поведение &lt;code&gt;dispatch&lt;/code&gt; вызовов в Redux, поэтому для тестирования этого измененного поведения нам нужно имитировать поведение &lt;code&gt;dispatch&lt;/code&gt; вызова.</target>
        </trans-unit>
        <trans-unit id="4cfdea7cdd9cbecf25a5a88942621957d5c3dd05" translate="yes" xml:space="preserve">
          <source>Middleware is composable using function composition. It is useful for logging actions, performing side effects like routing, or turning an asynchronous API call into a series of synchronous actions.</source>
          <target state="translated">Среднее программное обеспечение является композитным с использованием функционального состава.Она полезна для протоколирования действий,выполнения побочных эффектов,таких как маршрутизация,или превращения асинхронного вызова API в серию синхронных действий.</target>
        </trans-unit>
        <trans-unit id="b3958295af5cb6ac63c96e1bbd5629db43b83e95" translate="yes" xml:space="preserve">
          <source>Middleware is created by the community and does not ship with Redux by default. You need to explicitly install packages like &lt;a href=&quot;https://github.com/gaearon/redux-thunk&quot;&gt;redux-thunk&lt;/a&gt; or &lt;a href=&quot;https://github.com/acdlite/redux-promise&quot;&gt;redux-promise&lt;/a&gt; to use it. You may also create your own middleware.</source>
          <target state="translated">Промежуточное ПО создается сообществом и по умолчанию не поставляется с Redux. Вам необходимо явно установить пакеты, такие как &lt;a href=&quot;https://github.com/gaearon/redux-thunk&quot;&gt;redux-thunk&lt;/a&gt; или &lt;a href=&quot;https://github.com/acdlite/redux-promise&quot;&gt;redux-prom,&lt;/a&gt; чтобы использовать его. Вы также можете создать свое собственное промежуточное ПО.</target>
        </trans-unit>
        <trans-unit id="709ac9c564fa8004f1018815a013faace4ceaf9b" translate="yes" xml:space="preserve">
          <source>Middleware is not baked into &lt;a href=&quot;createstore&quot;&gt;&lt;code&gt;createStore&lt;/code&gt;&lt;/a&gt; and is not a fundamental part of the Redux architecture, but we consider it useful enough to be supported right in the core. This way, there is a single standard way to extend &lt;a href=&quot;store#dispatch&quot;&gt;&lt;code&gt;dispatch&lt;/code&gt;&lt;/a&gt; in the ecosystem, and different middleware may compete in expressiveness and utility.</source>
          <target state="translated">&lt;a href=&quot;createstore&quot;&gt; &lt;code&gt;createStore&lt;/code&gt; &lt;/a&gt; ПО не встроено в createStore и не является фундаментальной частью архитектуры Redux, но мы считаем его достаточно полезным, чтобы поддерживать его прямо в ядре. Таким образом, существует единственный стандартный способ расширения &lt;a href=&quot;store#dispatch&quot;&gt; &lt;code&gt;dispatch&lt;/code&gt; &lt;/a&gt; в экосистеме, а различные промежуточные программы могут конкурировать в выразительности и полезности.</target>
        </trans-unit>
        <trans-unit id="44bb138a9d25525c5ea6b439a580ee67fd5a1ee9" translate="yes" xml:space="preserve">
          <source>Middleware is not baked into &lt;a href=&quot;createstore&quot;&gt;&lt;code&gt;createStore&lt;/code&gt;&lt;/a&gt; and is not a fundamental part of the Redux architecture, but we consider it useful enough to be supported right in the core. This way, there is a single standard way to extend &lt;a href=&quot;store#dispatchaction&quot;&gt;&lt;code&gt;dispatch&lt;/code&gt;&lt;/a&gt; in the ecosystem, and different middleware may compete in expressiveness and utility.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00c8a7e2c0f9e6b20fe14442f77d182a03eebb64" translate="yes" xml:space="preserve">
          <source>Middleware is the suggested way to extend Redux with custom functionality. Middleware lets you wrap the store's &lt;a href=&quot;store#dispatch&quot;&gt;&lt;code&gt;dispatch&lt;/code&gt;&lt;/a&gt; method for fun and profit. The key feature of middleware is that it is composable. Multiple middleware can be combined together, where each middleware requires no knowledge of what comes before or after it in the chain.</source>
          <target state="translated">Промежуточное ПО - это предлагаемый способ расширения Redux с помощью настраиваемых функций. Промежуточное ПО позволяет обернуть метод &lt;a href=&quot;store#dispatch&quot;&gt; &lt;code&gt;dispatch&lt;/code&gt; &lt;/a&gt; магазина для развлечения и получения прибыли. Ключевой особенностью промежуточного программного обеспечения является то, что его можно компоновать. Несколько промежуточных программ могут быть объединены вместе, при этом каждое промежуточное программное обеспечение не требует знания того, что находится до или после него в цепочке.</target>
        </trans-unit>
        <trans-unit id="39238a8d7919adb7f2defae4e78aa73bb9a0fc2f" translate="yes" xml:space="preserve">
          <source>Middleware is the suggested way to extend Redux with custom functionality. Middleware lets you wrap the store's &lt;a href=&quot;store#dispatchaction&quot;&gt;&lt;code&gt;dispatch&lt;/code&gt;&lt;/a&gt; method for fun and profit. The key feature of middleware is that it is composable. Multiple middleware can be combined together, where each middleware requires no knowledge of what comes before or after it in the chain.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9772321b9da9e355cae92c8995bc9b6d9b873c30" translate="yes" xml:space="preserve">
          <source>Middleware only wraps the store's &lt;a href=&quot;store#dispatch&quot;&gt;&lt;code&gt;dispatch&lt;/code&gt;&lt;/a&gt; function. Technically, anything a middleware can do, you can do manually by wrapping every &lt;code&gt;dispatch&lt;/code&gt; call, but it's easier to manage this in a single place and define action transformations on the scale of the whole project.</source>
          <target state="translated">ПО промежуточного слоя только обертывает функцию &lt;a href=&quot;store#dispatch&quot;&gt; &lt;code&gt;dispatch&lt;/code&gt; &lt;/a&gt; магазина . Технически все, что может делать промежуточное ПО, можно делать вручную, упаковывая каждый вызов &lt;code&gt;dispatch&lt;/code&gt; , но проще управлять этим в одном месте и определять преобразования действий в масштабе всего проекта.</target>
        </trans-unit>
        <trans-unit id="da1c87b8d7e2336732bb5e2c32e20b95e5a52fd5" translate="yes" xml:space="preserve">
          <source>Middleware only wraps the store's &lt;a href=&quot;store#dispatchaction&quot;&gt;&lt;code&gt;dispatch&lt;/code&gt;&lt;/a&gt; function. Technically, anything a middleware can do, you can do manually by wrapping every &lt;code&gt;dispatch&lt;/code&gt; call, but it's easier to manage this in a single place and define action transformations on the scale of the whole project.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="904b42b851f9aa103d834460d3e42948c262c785" translate="yes" xml:space="preserve">
          <source>Middleware sounds much more complicated than it really is. The only way to really understand middleware is to see how the existing middleware works, and try to write your own. The function nesting can be intimidating, but most of the middleware you'll find are, in fact, 10-liners, and the nesting and composability is what makes the middleware system powerful.</source>
          <target state="translated">Среднее программное обеспечение звучит намного сложнее,чем есть на самом деле.Единственный способ по-настоящему понять промежуточное программное обеспечение-это увидеть,как работает существующее промежуточное программное обеспечение,и попытаться написать свое собственное.Вложение функций может быть пугающим,но большая часть промежуточного программного обеспечения,которое вы найдете,на самом деле,10 лайнеров,и именно вложенность и композитивность-это то,что делает систему промежуточного программного обеспечения мощной.</target>
        </trans-unit>
        <trans-unit id="9302feee19404010fcac9af350604fe588e01046" translate="yes" xml:space="preserve">
          <source>Migrating to Redux</source>
          <target state="translated">Миграция в Редукс</target>
        </trans-unit>
        <trans-unit id="5f2cbd107037ed23248e5058a7a64cd6bae05468" translate="yes" xml:space="preserve">
          <source>Miscellaneous</source>
          <target state="translated">Miscellaneous</target>
        </trans-unit>
        <trans-unit id="7cc7d31118fe440474864da8b1d74f693cb0f866" translate="yes" xml:space="preserve">
          <source>Modular Reducers and Selectors</source>
          <target state="translated">Модульные редукторы и селекторы</target>
        </trans-unit>
        <trans-unit id="4e7b0b1e9c0a61f16b9a2611a1aa537d440279de" translate="yes" xml:space="preserve">
          <source>Monkeypatching is a hack. &amp;ldquo;Replace any method you like&amp;rdquo;, what kind of API is that? Let's figure out the essence of it instead. Previously, our functions replaced &lt;code&gt;store.dispatch&lt;/code&gt;. What if they &lt;em&gt;returned&lt;/em&gt; the new &lt;code&gt;dispatch&lt;/code&gt; function instead?</source>
          <target state="translated">Monkeypatching - это хитрость. &amp;laquo;Замени любой метод, который тебе нравится&amp;raquo;, что это за API? Давайте вместо этого разберемся в его сути. Ранее наши функции заменяли &lt;code&gt;store.dispatch&lt;/code&gt; . Что, если вместо этого они &lt;em&gt;вернут&lt;/em&gt; новую функцию &lt;code&gt;dispatch&lt;/code&gt; ?</target>
        </trans-unit>
        <trans-unit id="4bab2d8fe13fa6ab57f80098b414f0f734c5dd25" translate="yes" xml:space="preserve">
          <source>More</source>
          <target state="translated">More</target>
        </trans-unit>
        <trans-unit id="65607507695dbb68853f7200e33956e39fd6a15d" translate="yes" xml:space="preserve">
          <source>More Examples</source>
          <target state="translated">Другие примеры</target>
        </trans-unit>
        <trans-unit id="fbb1457de42e260b67aaf3c234080db729e6567f" translate="yes" xml:space="preserve">
          <source>Most applications deal with multiple types of data, which can be broadly divided into three categories:</source>
          <target state="translated">Большинство приложений работают с несколькими типами данных,которые можно условно разделить на три категории:</target>
        </trans-unit>
        <trans-unit id="89d03ee4b54b44641100dd50cccd338fa1f41b27" translate="yes" xml:space="preserve">
          <source>Most commonly people consume Redux as a collection of &lt;a href=&quot;http://webpack.github.io/docs/commonjs.html&quot;&gt;CommonJS&lt;/a&gt; modules. These modules are what you get when you import &lt;code&gt;redux&lt;/code&gt; in a &lt;a href=&quot;https://webpack.js.org/&quot;&gt;Webpack&lt;/a&gt;, &lt;a href=&quot;http://browserify.org/&quot;&gt;Browserify&lt;/a&gt;, or a Node environment. If you like to live on the edge and use &lt;a href=&quot;http://rollupjs.org&quot;&gt;Rollup&lt;/a&gt;, we support that as well.</source>
          <target state="translated">Чаще всего люди используют Redux как набор модулей &lt;a href=&quot;http://webpack.github.io/docs/commonjs.html&quot;&gt;CommonJS&lt;/a&gt; . Эти модули - это то, что вы получаете, когда импортируете &lt;code&gt;redux&lt;/code&gt; в &lt;a href=&quot;https://webpack.js.org/&quot;&gt;Webpack&lt;/a&gt; , &lt;a href=&quot;http://browserify.org/&quot;&gt;Browserify&lt;/a&gt; или среду Node. Если вам нравится жить на грани и использовать &lt;a href=&quot;http://rollupjs.org&quot;&gt;Rollup&lt;/a&gt; , мы также поддерживаем это.</target>
        </trans-unit>
        <trans-unit id="09f0cc4aec4d47d93c4e8a96edd682217c9476ac" translate="yes" xml:space="preserve">
          <source>Most likely you'll never write a store enhancer, but you may use the one provided by the &lt;a href=&quot;https://github.com/gaearon/redux-devtools&quot;&gt;developer tools&lt;/a&gt;. It is what makes time travel possible without the app being aware it is happening. Amusingly, the &lt;a href=&quot;api/applymiddleware&quot;&gt;Redux middleware implementation&lt;/a&gt; is itself a store enhancer.</source>
          <target state="translated">Скорее всего, вы никогда не напишете усилитель магазина, но вы можете использовать тот, который предоставляется &lt;a href=&quot;https://github.com/gaearon/redux-devtools&quot;&gt;инструментами разработчика&lt;/a&gt; . Это то, что делает возможным путешествия во времени без ведома приложения. Забавно, но &lt;a href=&quot;api/applymiddleware&quot;&gt;реализация промежуточного программного обеспечения Redux&lt;/a&gt; сама по себе улучшает хранилище.</target>
        </trans-unit>
        <trans-unit id="390f7c239e26365aa378c0e0495e19cfea627097" translate="yes" xml:space="preserve">
          <source>Most likely, you'll also need &lt;a href=&quot;https://github.com/reactjs/react-redux&quot;&gt;the React bindings&lt;/a&gt; and &lt;a href=&quot;https://github.com/gaearon/redux-devtools&quot;&gt;the developer tools&lt;/a&gt;.</source>
          <target state="translated">Скорее всего, вам также понадобятся &lt;a href=&quot;https://github.com/reactjs/react-redux&quot;&gt;привязки React&lt;/a&gt; и &lt;a href=&quot;https://github.com/gaearon/redux-devtools&quot;&gt;инструменты разработчика&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7e3a3d184b0b6d4dfa96e5964033c932e00274c5" translate="yes" xml:space="preserve">
          <source>Most of the components we'll write will be presentational, but we'll need to generate a few container components to connect them to the Redux store. This and the design brief below do not imply container components must be near the top of the component tree. If a container component becomes too complex (i.e. it has heavily nested presentional components with countless callbacks being passed down), introduce another container within the component tree as noted in the &lt;a href=&quot;../faq/reactredux#react-multiple-components&quot;&gt;FAQ&lt;/a&gt;.</source>
          <target state="translated">Большинство компонентов, которые мы напишем, будут презентационными, но нам нужно будет создать несколько компонентов-контейнеров, чтобы подключить их к хранилищу Redux. Это и приведенное ниже краткое описание проекта не подразумевают, что компоненты контейнера должны находиться в верхней части дерева компонентов. Если компонент-контейнер становится слишком сложным (т.е. он имеет сильно вложенные презентальные компоненты с бесчисленными обратными вызовами, передаваемыми вниз), добавьте другой контейнер в дерево компонентов, как указано в &lt;a href=&quot;../faq/reactredux#react-multiple-components&quot;&gt;FAQ&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4fd704d00a4e5a0c3b40b38e9218c4cbbf210bcc" translate="yes" xml:space="preserve">
          <source>Most of the functionality Baobab provides is related to updating the data with cursors, but Redux enforces that the only way to update the data is to dispatch an action. Therefore they solve the same problem differently, and don't complement each other.</source>
          <target state="translated">Большая часть функциональности,предоставляемой Baobab,связана с обновлением данных с помощью курсоров,но Redux обеспечивает,что единственный способ обновления данных-это отправка действия.Поэтому они решают одну и ту же проблему по-разному и не дополняют друг друга.</target>
        </trans-unit>
        <trans-unit id="d6a06199cc127e571d3588aef63c79108675eabc" translate="yes" xml:space="preserve">
          <source>Motivation</source>
          <target state="translated">Motivation</target>
        </trans-unit>
        <trans-unit id="723bf632acd68a56f2a8abd2cb40c71cceac0c0d" translate="yes" xml:space="preserve">
          <source>Motivation for Memoized Selectors</source>
          <target state="translated">Мотивация для запоминаемых селекторов</target>
        </trans-unit>
        <trans-unit id="552b006eca5b663e553068321aa1dddaf3b1befb" translate="yes" xml:space="preserve">
          <source>Mozilla's experimental browser testbed</source>
          <target state="translated">экспериментальная тестовая площадка браузера Mozilla</target>
        </trans-unit>
        <trans-unit id="d88a4a071f039297bbb69db92ff026e19cea735d" translate="yes" xml:space="preserve">
          <source>Mutability vs immutability</source>
          <target state="translated">Подвижность против непреложности</target>
        </trans-unit>
        <trans-unit id="efd8a68660022a43293fd5a672afacaf4b2ee1a5" translate="yes" xml:space="preserve">
          <source>Mutate its arguments;</source>
          <target state="translated">Мутируй его аргументы;</target>
        </trans-unit>
        <trans-unit id="654f242c8a1a04fd78d46a2eed456576101047e8" translate="yes" xml:space="preserve">
          <source>Mutation is discouraged because it generally breaks time-travel debugging, and React Redux's &lt;code&gt;connect&lt;/code&gt; function:</source>
          <target state="translated">Мутация не рекомендуется, потому что она обычно нарушает отладку во времени и функцию &lt;code&gt;connect&lt;/code&gt; React Redux :</target>
        </trans-unit>
        <trans-unit id="14131d656db4b7bdd8f8e3f363d86fcd460046b5" translate="yes" xml:space="preserve">
          <source>My journey towards a maintainable project structure for React/Redux</source>
          <target state="translated">Мой путь к поддерживаемой проектной структуре для React/Redux</target>
        </trans-unit>
        <trans-unit id="7b24ea7fdf4c6ff696c569545bd59b1ddc1a2075" translate="yes" xml:space="preserve">
          <source>Navigating with React Router</source>
          <target state="translated">Навигация с помощью маршрутизатора</target>
        </trans-unit>
        <trans-unit id="ffb832014d4614f14ecdf3023143c63e959c339a" translate="yes" xml:space="preserve">
          <source>Nested data means that the corresponding reducer logic has to be more nested or more complex. In particular, trying to update a deeply nested field can become very ugly very fast.</source>
          <target state="translated">Вложенные данные означают,что соответствующая логика редуктора должна быть более вложенной или более сложной.В частности,попытка обновления глубоко вложенного поля может стать очень неприятной очень быстро.</target>
        </trans-unit>
        <trans-unit id="80a420ddf85790605c162653ce53a583b0952bbf" translate="yes" xml:space="preserve">
          <source>Never let a plain JavaScript object contain Immutable.JS properties. Equally, never let an Immutable.JS object contain a plain JavaScript object.</source>
          <target state="translated">Никогда не позволяйте обычному объекту JavaScript содержать свойства Immutable.JS.Точно так же,никогда не позволяйте объекту Immutable.JS содержать обычный объект JavaScript.</target>
        </trans-unit>
        <trans-unit id="a430ed54fb612f337f2ab8273ec4cbf9b6644bd7" translate="yes" xml:space="preserve">
          <source>Never mix plain JavaScript objects with Immutable.JS</source>
          <target state="translated">Никогда не смешивайте обычные объекты JavaScript с Immutable.JS.</target>
        </trans-unit>
        <trans-unit id="5a34cbfaae2d3943f4277799da4593a9d4e8866b" translate="yes" xml:space="preserve">
          <source>Never mutate reducer arguments</source>
          <target state="translated">Никогда не мутируйте аргументы редуктора</target>
        </trans-unit>
        <trans-unit id="d5c80dd926f59c776bb8a92ea2761368f2163c20" translate="yes" xml:space="preserve">
          <source>Never use &lt;code&gt;toJS()&lt;/code&gt; in &lt;code&gt;mapStateToProps&lt;/code&gt;</source>
          <target state="translated">Никогда не используйте &lt;code&gt;toJS()&lt;/code&gt; в &lt;code&gt;mapStateToProps&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="880eef8459e455b9917669c0f642e566841426d2" translate="yes" xml:space="preserve">
          <source>Never use Immutable.JS in your Dumb Components</source>
          <target state="translated">Никогда не используйте Immutable.JS в Ваших немых компонентах.</target>
        </trans-unit>
        <trans-unit id="3f170caead65df254d786032a409a6f6d204bca6" translate="yes" xml:space="preserve">
          <source>Next Steps</source>
          <target state="translated">Следующие шаги</target>
        </trans-unit>
        <trans-unit id="0264cc83b356bb6ea59a462a975e062d839151d9" translate="yes" xml:space="preserve">
          <source>Next, we can split each specific case into its own function:</source>
          <target state="translated">Далее мы можем разделить каждый конкретный случай на свои функции:</target>
        </trans-unit>
        <trans-unit id="841e4eea113da2949d5aa791e51d64a552200a40" translate="yes" xml:space="preserve">
          <source>Next, we'll explore how to &lt;a href=&quot;store&quot;&gt;create a Redux store&lt;/a&gt; that holds the state and takes care of calling your reducer when you dispatch an action.</source>
          <target state="translated">Далее мы рассмотрим, как &lt;a href=&quot;store&quot;&gt;создать хранилище Redux,&lt;/a&gt; которое хранит состояние и заботится о вызове вашего редуктора при отправке действия.</target>
        </trans-unit>
        <trans-unit id="816c52fd2bdd94a63cd0944823a6c0aa9384c103" translate="yes" xml:space="preserve">
          <source>No</source>
          <target state="translated">No</target>
        </trans-unit>
        <trans-unit id="00e1f82b828451acc6eb547238db43005cf32c21" translate="yes" xml:space="preserve">
          <source>No Destructuring or Spread Operators</source>
          <target state="translated">Отсутствие деструктуризации или разбрасывания операторов</target>
        </trans-unit>
        <trans-unit id="45a97bbdd6d1c0b59be783757a1880b3f98ba017" translate="yes" xml:space="preserve">
          <source>No. We suggest you write independent small reducer functions that are each responsible for updates to a specific slice of state. We call this pattern &amp;ldquo;reducer composition&amp;rdquo;. A given action could be handled by all, some, or none of them. This keeps components decoupled from the actual data changes, as one action may affect different parts of the state tree, and there is no need for the component to be aware of this. Some users do choose to bind them more tightly together, such as the &amp;ldquo;ducks&amp;rdquo; file structure, but there is definitely no one-to-one mapping by default, and you should break out of such a paradigm any time you feel you want to handle an action in many reducers.</source>
          <target state="translated">Нет. Мы предлагаем вам написать небольшие независимые функции-редукторы, каждая из которых отвечает за обновления определенного фрагмента состояния. Мы называем этот паттерн &amp;laquo;композиция редуктора&amp;raquo;. Данное действие может выполняться всеми, некоторыми или никем из них. Благодаря этому компоненты не связаны с фактическими изменениями данных, поскольку одно действие может влиять на разные части дерева состояний, и компоненту не нужно знать об этом. Некоторые пользователи предпочитают связывать их более плотно, например файловую структуру &amp;laquo;уток&amp;raquo;, но по умолчанию однозначного сопоставления определенно нет, и вам следует отказываться от такой парадигмы всякий раз, когда вы чувствуете, что хотите обрабатывать действие во многих редукторах.</target>
        </trans-unit>
        <trans-unit id="2d55eda060d4abd9e941e61eac1c5a4760b4b7fb" translate="yes" xml:space="preserve">
          <source>No. You are welcome to use any approach you'd like to respond to an action in a reducer. The &lt;code&gt;switch&lt;/code&gt; statement is the most common approach, but it's fine to use &lt;code&gt;if&lt;/code&gt; statements, a lookup table of functions, or to create a function that abstracts this away. In fact, while Redux does require that action objects contain a &lt;code&gt;type&lt;/code&gt; field, your reducer logic doesn't even have to rely on that to handle the action. That said, the standard approach is definitely using a switch statement or a lookup table based on &lt;code&gt;type&lt;/code&gt;.</source>
          <target state="translated">Нет. Вы можете использовать любой подход, который хотите отреагировать на действие в редюсере. Оператор &lt;code&gt;switch&lt;/code&gt; - наиболее распространенный подход, но можно использовать операторы &lt;code&gt;if&lt;/code&gt; , справочную таблицу функций или создать функцию, которая абстрагирует это. Фактически, хотя Redux действительно требует, чтобы объекты действия содержали поле &lt;code&gt;type&lt;/code&gt; , вашей логике редуктора даже не нужно полагаться на это для обработки действия. Тем не менее, стандартный подход определенно использует оператор switch или таблицу поиска на основе &lt;code&gt;type&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0e0d7b6b9e9168e473b1803957df55eb87b2031d" translate="yes" xml:space="preserve">
          <source>Nope, it's just HTML, some artisanal &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; tags, and plain old DOM manipulation. Enjoy!</source>
          <target state="translated">Нет, это просто HTML, несколько кустарных тегов &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; и старые простые манипуляции с DOM. Наслаждайтесь!</target>
        </trans-unit>
        <trans-unit id="327c34539b30a346bec5ad81c0c1b3f68e1bdeed" translate="yes" xml:space="preserve">
          <source>Normalizing Data</source>
          <target state="translated">Нормализация данных</target>
        </trans-unit>
        <trans-unit id="24e6df000cfc0eae18573e3ca083b23c0599cf6a" translate="yes" xml:space="preserve">
          <source>Normalizing Nested Data</source>
          <target state="translated">Нормализация вложенных данных</target>
        </trans-unit>
        <trans-unit id="dcd338fb8e5bd8068c0c2b43bfce9d5de3e8a57c" translate="yes" xml:space="preserve">
          <source>Normalizing State Shape</source>
          <target state="translated">Нормализующая форма государства</target>
        </trans-unit>
        <trans-unit id="eb23cc3f5afc902e5be043420e1d724b51659962" translate="yes" xml:space="preserve">
          <source>Normalizr Documentation</source>
          <target state="translated">Нормативная документация</target>
        </trans-unit>
        <trans-unit id="335b95f34a7df1f471d9e66d848a822638f18b4c" translate="yes" xml:space="preserve">
          <source>Normally you should just call &lt;a href=&quot;store#dispatch&quot;&gt;&lt;code&gt;dispatch&lt;/code&gt;&lt;/a&gt; directly on your &lt;a href=&quot;store&quot;&gt;&lt;code&gt;Store&lt;/code&gt;&lt;/a&gt; instance. If you use Redux with React, &lt;a href=&quot;https://github.com/gaearon/react-redux&quot;&gt;react-redux&lt;/a&gt; will provide you with the &lt;a href=&quot;store#dispatch&quot;&gt;&lt;code&gt;dispatch&lt;/code&gt;&lt;/a&gt; function so you can call it directly, too.</source>
          <target state="translated">Обычно вы должны просто вызвать &lt;a href=&quot;store#dispatch&quot;&gt; &lt;code&gt;dispatch&lt;/code&gt; &lt;/a&gt; прямо в экземпляре &lt;a href=&quot;store&quot;&gt; &lt;code&gt;Store&lt;/code&gt; &lt;/a&gt; . Если вы используете Redux с React, &lt;a href=&quot;https://github.com/gaearon/react-redux&quot;&gt;response-redux&lt;/a&gt; предоставит вам функцию &lt;a href=&quot;store#dispatch&quot;&gt; &lt;code&gt;dispatch&lt;/code&gt; &lt;/a&gt; чтобы вы также могли вызывать ее напрямую.</target>
        </trans-unit>
        <trans-unit id="26c3f41f979e0141ba2295989bb6b08208506c7a" translate="yes" xml:space="preserve">
          <source>Normally you should just call &lt;a href=&quot;store#dispatchaction&quot;&gt;&lt;code&gt;dispatch&lt;/code&gt;&lt;/a&gt; directly on your &lt;a href=&quot;store&quot;&gt;&lt;code&gt;Store&lt;/code&gt;&lt;/a&gt; instance. If you use Redux with React, &lt;a href=&quot;https://github.com/gaearon/react-redux&quot;&gt;react-redux&lt;/a&gt; will provide you with the &lt;a href=&quot;store#dispatchaction&quot;&gt;&lt;code&gt;dispatch&lt;/code&gt;&lt;/a&gt; function so you can call it directly, too.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c4e5332959aece0b47c0b738573f9bd470cb893" translate="yes" xml:space="preserve">
          <source>Normally, a Javascript array's contents are modified using mutative functions like &lt;code&gt;push&lt;/code&gt;, &lt;code&gt;unshift&lt;/code&gt;, and &lt;code&gt;splice&lt;/code&gt;. Since we don't want to mutate state directly in reducers, those should normally be avoided. Because of that, you might see &quot;insert&quot; or &quot;remove&quot; behavior written like this:</source>
          <target state="translated">Обычно содержимое массива Javascript модифицируется с помощью мутирующих функций, таких как &lt;code&gt;push&lt;/code&gt; , &lt;code&gt;unshift&lt;/code&gt; и &lt;code&gt;splice&lt;/code&gt; . Поскольку мы не хотим изменять состояние непосредственно в редукторах, обычно этого следует избегать. Из-за этого вы можете увидеть поведение &amp;laquo;вставить&amp;raquo; или &amp;laquo;удалить&amp;raquo;, написанное следующим образом:</target>
        </trans-unit>
        <trans-unit id="5bf716978826f82f5c2d71096281b5d3d023f9c8" translate="yes" xml:space="preserve">
          <source>Not suitable for small values that change often</source>
          <target state="translated">Не подходит для малых значений,которые часто меняются</target>
        </trans-unit>
        <trans-unit id="2c924e3088204ee77ba681f72be3444357932fca" translate="yes" xml:space="preserve">
          <source>Note</source>
          <target state="translated">Note</target>
        </trans-unit>
        <trans-unit id="eb86ccd5312e5081a352de1334537a0b4650d54d" translate="yes" xml:space="preserve">
          <source>Note About Other Routing Libraries</source>
          <target state="translated">Замечание о других маршрутных библиотеках</target>
        </trans-unit>
        <trans-unit id="6bbf18fa1a59b4aceea2d7935084a5984b1e6199" translate="yes" xml:space="preserve">
          <source>Note about Server Rendering</source>
          <target state="translated">Заметка о Рендеринге сервера</target>
        </trans-unit>
        <trans-unit id="4c76dccbb579daeff6d19eccfc8338e7cf2dfdca" translate="yes" xml:space="preserve">
          <source>Note for Advanced Users</source>
          <target state="translated">Примечание для продвинутых пользователей</target>
        </trans-unit>
        <trans-unit id="0e1755ef6326ca3fc737a66979bb10b7fe7587af" translate="yes" xml:space="preserve">
          <source>Note for ES6 Savvy Users</source>
          <target state="translated">Примечание для пользователей ES6 Savvy</target>
        </trans-unit>
        <trans-unit id="4bfd422b1acf7ab6bcc2d683c3dcc9593e8dfe47" translate="yes" xml:space="preserve">
          <source>Note on &lt;code&gt;Object.assign&lt;/code&gt;</source>
          <target state="translated">Примечание к &lt;code&gt;Object.assign&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="759269df6e82649e8ad3a46ac965bc2b1dbc225c" translate="yes" xml:space="preserve">
          <source>Note on &lt;code&gt;fetch&lt;/code&gt;</source>
          <target state="translated">Примечание при &lt;code&gt;fetch&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4191e14191dc73a177c536b0008fd934e599f6c0" translate="yes" xml:space="preserve">
          <source>Note on &lt;code&gt;switch&lt;/code&gt; and Boilerplate</source>
          <target state="translated">Примечание по &lt;code&gt;switch&lt;/code&gt; и Boilerplate</target>
        </trans-unit>
        <trans-unit id="ae1778afee8eaabfaf5e882ffee86fd7dfad1748" translate="yes" xml:space="preserve">
          <source>Note on Boilerplate</source>
          <target state="translated">Примечание на котельной</target>
        </trans-unit>
        <trans-unit id="f520e769580a42a8ec1ab5c7de5b32126ab034fd" translate="yes" xml:space="preserve">
          <source>Note on Create React App</source>
          <target state="translated">Примечание о создании реактивного приложения</target>
        </trans-unit>
        <trans-unit id="0dba1d6300344edb76956054e6c0d4c05d8a5923" translate="yes" xml:space="preserve">
          <source>Note on Error Handling</source>
          <target state="translated">Примечание по обработке ошибок</target>
        </trans-unit>
        <trans-unit id="226b6e169b44973eab9a3a7d4ce9abe63d0c7f07" translate="yes" xml:space="preserve">
          <source>Note on Nested Entities</source>
          <target state="translated">Примечание о вложенных юридических лицах</target>
        </trans-unit>
        <trans-unit id="f85a104fce56d4fdf589c3dd1d9c7b40327d3c8b" translate="yes" xml:space="preserve">
          <source>Note on Reducer Composition</source>
          <target state="translated">Примечание по составу редукторов</target>
        </trans-unit>
        <trans-unit id="4d5561853fa6b8c8692a5c30631ba7770fde7366" translate="yes" xml:space="preserve">
          <source>Note on Relationships</source>
          <target state="translated">Заметка о взаимоотношениях</target>
        </trans-unit>
        <trans-unit id="0b2ca83fd75e901aec616d782b23314502061cce" translate="yes" xml:space="preserve">
          <source>Note on immutability, side effects, and mutation</source>
          <target state="translated">Примечание о неизменности,побочных эффектах и мутации</target>
        </trans-unit>
        <trans-unit id="068f9eefaa044d6807c7bf4c8c0f32ef9489c02e" translate="yes" xml:space="preserve">
          <source>Note that &amp;ldquo;updating data immutably&amp;rdquo; does &lt;em&gt;not&lt;/em&gt; mean that you must use &lt;a href=&quot;https://facebook.github.io/immutable-js/&quot;&gt;Immutable.js&lt;/a&gt;, although that is certainly an option. You can do immutable updates to plain JS objects and arrays using several different approaches:</source>
          <target state="translated">Обратите внимание, что &amp;laquo;неизменное обновление данных&amp;raquo; &lt;em&gt;не&lt;/em&gt; означает, что вы должны использовать &lt;a href=&quot;https://facebook.github.io/immutable-js/&quot;&gt;Immutable.js&lt;/a&gt; , хотя это, безусловно, вариант. Вы можете выполнять неизменяемые обновления простых объектов и массивов JS, используя несколько различных подходов:</target>
        </trans-unit>
        <trans-unit id="03a447c3fbe3d52e5d3b4ec4eb5f4cbd98b4d07a" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;combineReducers&lt;/code&gt; doesn't know or care that there's anything special about the reducer function that's responsible for managing &lt;code&gt;a&lt;/code&gt;. We didn't need to modify &lt;code&gt;combineReducers&lt;/code&gt; to specifically know how to undo things - we just built up the pieces we needed into a new composed function.</source>
          <target state="translated">Обратите внимание , что &lt;code&gt;combineReducers&lt;/code&gt; не знает или ухода , что нет ничего особенного в функции редуктора , которое отвечает за управление . Нам не нужно было изменять &lt;code&gt;combineReducers&lt;/code&gt; чтобы точно знать, как что-то отменять - мы просто собрали нужные части в новую составную функцию. &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b8cedc1c11fc5e0b2729544aacc4a299dcef1a86" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;todos&lt;/code&gt; also accepts &lt;code&gt;state&lt;/code&gt;&amp;mdash;but it's an array! Now &lt;code&gt;todoApp&lt;/code&gt; just gives it the slice of the state to manage, and &lt;code&gt;todos&lt;/code&gt; knows how to update just that slice. &lt;strong&gt;This is called &lt;em&gt;reducer composition&lt;/em&gt;, and it's the fundamental pattern of building Redux apps.&lt;/strong&gt;</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;todos&lt;/code&gt; также принимает &lt;code&gt;state&lt;/code&gt; - но это массив! Теперь &lt;code&gt;todoApp&lt;/code&gt; просто дает ему часть состояния для управления, и &lt;code&gt;todos&lt;/code&gt; знает, как обновить именно этот фрагмент. &lt;strong&gt;Это называется &lt;em&gt;композицией редуктора&lt;/em&gt; , и это фундаментальный образец построения приложений Redux.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1f8b0362b0a282b6bc627b26a9692c8cb48f4d7f" translate="yes" xml:space="preserve">
          <source>Note that Immutable.JS objects do have a &lt;code&gt;toJS()&lt;/code&gt; method, which returns the data as a plain JavaScript data structure, but this method is extremely slow, and using it extensively will negate the performance benefits that Immutable.JS provides</source>
          <target state="translated">Обратите внимание, что у объектов &lt;code&gt;toJS()&lt;/code&gt; метод toJS () , который возвращает данные в виде простой структуры данных JavaScript, но этот метод очень медленный, и его широкое использование сведет на нет преимущества в производительности, предоставляемые Immutable.JS.</target>
        </trans-unit>
        <trans-unit id="453c35dfa0c302d121b3eadd02c225634676ef9a" translate="yes" xml:space="preserve">
          <source>Note that a normalized state structure generally implies that more components are connected and each component is responsible for looking up its own data, as opposed to a few connected components looking up large amounts of data and passing all that data downwards. As it turns out, having connected parent components simply pass item IDs to connected children is a good pattern for optimizing UI performance in a React Redux application, so keeping state normalized plays a key role in improving performance.</source>
          <target state="translated">Обратите внимание,что нормализованная структура состояния обычно подразумевает,что подключено больше компонентов,и каждый из них отвечает за поиск собственных данных,в отличие от нескольких подключенных компонентов,которые ищут большие объемы данных и передают все эти данные вниз.Как оказалось,просто передача родительских компонентов подключенным дочерним процессорам является хорошей моделью для оптимизации производительности пользовательского интерфейса в приложении React Redux,поэтому поддержание нормального состояния играет ключевую роль в улучшении производительности.</target>
        </trans-unit>
        <trans-unit id="bd5f79bd2131ac43e4417a0d7a6aaff0b70dafa1" translate="yes" xml:space="preserve">
          <source>Note that a reducer is a pure function. It only &lt;em&gt;computes&lt;/em&gt; the next state. It should be completely predictable: calling it with the same inputs many times should produce the same outputs. It shouldn't perform any side effects like API calls or router transitions. These should happen before an action is dispatched.</source>
          <target state="translated">Обратите внимание, что редуктор - это чистая функция. Он только &lt;em&gt;вычисляет&lt;/em&gt; следующее состояние. Он должен быть полностью предсказуемым: вызов его с одними и теми же входами много раз должен давать одни и те же выходные данные. Он не должен вызывать никаких побочных эффектов, таких как вызовы API или переходы маршрутизатора. Это должно произойти до отправки действия.</target>
        </trans-unit>
        <trans-unit id="dce445ddd99a63b5841226d22eed33b3bf5571f8" translate="yes" xml:space="preserve">
          <source>Note that experimental language features are subject to change.</source>
          <target state="translated">Обратите внимание,что экспериментальные возможности языка могут быть изменены.</target>
        </trans-unit>
        <trans-unit id="6b9f2be80295a73b990bda31c5fcc186d2c3fd08" translate="yes" xml:space="preserve">
          <source>Note that if you use &lt;code&gt;reduceReducers&lt;/code&gt;, you should make sure that the first reducer in the list is able to define the initial state, since the later reducers will generally assume that the entire state already exists and not try to provide defaults.</source>
          <target state="translated">Обратите внимание: если вы используете &lt;code&gt;reduceReducers&lt;/code&gt; , вы должны убедиться, что первый редуктор в списке может определить начальное состояние, поскольку более поздние редукторы обычно предполагают, что все состояние уже существует, и не пытаются предоставить значения по умолчанию.</target>
        </trans-unit>
        <trans-unit id="3299e9657e0599957e5ab9cd478270d217e7c17c" translate="yes" xml:space="preserve">
          <source>Note that this is equivalent to:</source>
          <target state="translated">Обратите внимание,что это эквивалентно:</target>
        </trans-unit>
        <trans-unit id="e53104dd9201201207a0d3f3e75f9194a7e7bc6e" translate="yes" xml:space="preserve">
          <source>Note that this is still an experimental language feature proposal so it may change in the future. Nevertheless some large projects such as &lt;a href=&quot;https://github.com/facebook/react-native&quot;&gt;React Native&lt;/a&gt; already use it extensively so it is safe to say that there will be a good automated migration path if it changes.</source>
          <target state="translated">Обратите внимание, что это все еще экспериментальное предложение языковой функции, поэтому в будущем оно может измениться. Тем не менее, некоторые крупные проекты, такие как &lt;a href=&quot;https://github.com/facebook/react-native&quot;&gt;React Native,&lt;/a&gt; уже широко используют его, поэтому можно с уверенностью сказать, что в случае его изменения будет хороший путь автоматической миграции.</target>
        </trans-unit>
        <trans-unit id="83b83325ce50b1549fdb9a559ec6487d2af3c6cb" translate="yes" xml:space="preserve">
          <source>Note that unlike Redux itself, many packages in the Redux ecosystem don't provide UMD builds, so we recommend using CommonJS module bundlers like &lt;a href=&quot;https://webpack.js.org/&quot;&gt;Webpack&lt;/a&gt; and &lt;a href=&quot;http://browserify.org/&quot;&gt;Browserify&lt;/a&gt; for the most comfortable development experience.</source>
          <target state="translated">Обратите внимание, что в отличие от самого Redux, многие пакеты в экосистеме Redux не предоставляют сборки UMD, поэтому мы рекомендуем использовать сборщики модулей CommonJS, такие как &lt;a href=&quot;https://webpack.js.org/&quot;&gt;Webpack&lt;/a&gt; и &lt;a href=&quot;http://browserify.org/&quot;&gt;Browserify,&lt;/a&gt; для наиболее комфортного процесса разработки.</target>
        </trans-unit>
        <trans-unit id="62f695305f86349d2a0577aa88e353229236d1f1" translate="yes" xml:space="preserve">
          <source>Note that we are using &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment&quot;&gt;ES6 destructuring&lt;/a&gt; on the properties to pass in &lt;code&gt;params&lt;/code&gt; to &lt;code&gt;&amp;lt;VisibleTodoList /&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Обратите внимание, что мы используем &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment&quot;&gt;деструктуризацию ES6&lt;/a&gt; для свойств для передачи &lt;code&gt;params&lt;/code&gt; в &lt;code&gt;&amp;lt;VisibleTodoList /&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1618ff7b8e1c0dbfdbf2def8e4b7d2220f232032" translate="yes" xml:space="preserve">
          <source>Note that your &lt;code&gt;combineReducers()&lt;/code&gt; call will stay exactly as it was, but the &lt;code&gt;todos&lt;/code&gt; reducer will now refer to the reducer enhanced with Redux Undo:</source>
          <target state="translated">Обратите внимание, что ваш &lt;code&gt;combineReducers()&lt;/code&gt; останется таким же, как и был, но редуктор &lt;code&gt;todos&lt;/code&gt; теперь будет ссылаться на редуктор, улучшенный с помощью Redux Undo:</target>
        </trans-unit>
        <trans-unit id="727f3c121140693e9689630208289bf9c864cbb3" translate="yes" xml:space="preserve">
          <source>Note that, conversely, if an &lt;em&gt;immutable&lt;/em&gt; object is used, the &lt;a href=&quot;#immutability-issues-with-react-redux&quot;&gt;component may re-render when it should not&lt;/a&gt;.</source>
          <target state="translated">Обратите внимание, что, наоборот, если используется &lt;em&gt;неизменяемый&lt;/em&gt; объект, &lt;a href=&quot;#immutability-issues-with-react-redux&quot;&gt;компонент может повторно&lt;/a&gt; выполнить рендеринг, когда этого не следует делать .</target>
        </trans-unit>
        <trans-unit id="b863cfb1b4dca7e52579f1008befc33963aff3ba" translate="yes" xml:space="preserve">
          <source>Note that, conversely, if the values in your props object refer to mutable objects, &lt;a href=&quot;#shallow-checking-stops-component-re-rendering&quot;&gt;your component may not render when it should&lt;/a&gt;.</source>
          <target state="translated">Обратите внимание, что, наоборот, если значения в вашем объекте props относятся к изменяемым объектам, &lt;a href=&quot;#shallow-checking-stops-component-re-rendering&quot;&gt;ваш компонент может не отображаться, когда он должен&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e99340e9e77003c33d3f85a388e8f45942421146" translate="yes" xml:space="preserve">
          <source>Note that, even if your immutable library supports cursors, you shouldn't use them in a Redux app. The whole state tree should be considered read-only, and you should use Redux for updating the state, and subscribing to the updates. Therefore writing via cursor doesn't make sense for Redux. &lt;strong&gt;If your only use case for cursors is decoupling the state tree from the UI tree and gradually refining the cursors, you should look at selectors instead.&lt;/strong&gt; Selectors are composable getter functions. See &lt;a href=&quot;http://github.com/faassen/reselect&quot;&gt;reselect&lt;/a&gt; for a really great and concise implementation of composable selectors.</source>
          <target state="translated">Обратите внимание: даже если ваша неизменяемая библиотека поддерживает курсоры, вы не должны использовать их в приложении Redux. Все дерево состояний должно рассматриваться только для чтения, и вы должны использовать Redux для обновления состояния и подписки на обновления. Поэтому запись с помощью курсора не имеет смысла для Redux. &lt;strong&gt;Если ваш единственный вариант использования курсоров - это отделение дерева состояний от дерева пользовательского интерфейса и постепенное уточнение курсоров, вам следует вместо этого взглянуть на селекторы.&lt;/strong&gt; Селекторы - это составные функции получения. Смотрите &lt;a href=&quot;http://github.com/faassen/reselect&quot;&gt;Reselect&lt;/a&gt; для действительно большой и лаконичной реализации компонуемых селекторов.</target>
        </trans-unit>
        <trans-unit id="285f98e8d01e4962eff6724b78a3c6724d0931e6" translate="yes" xml:space="preserve">
          <source>Note that:</source>
          <target state="translated">Обратите внимание:</target>
        </trans-unit>
        <trans-unit id="9b3033c3ffc250f6cdbccd213236b9854f6e17c7" translate="yes" xml:space="preserve">
          <source>Note, however, that this does not apply to the Redux state tree, which is (usually) represented as a large collection of data.</source>
          <target state="translated">Обратите внимание,однако,что это не относится к дереву состояний Redux,которое (обычно)представлено в виде большой коллекции данных.</target>
        </trans-unit>
        <trans-unit id="70440046a3dc2e079f23ee1c57dfa76669b732aa" translate="yes" xml:space="preserve">
          <source>Notes</source>
          <target state="translated">Notes</target>
        </trans-unit>
        <trans-unit id="401d2785d679a18987a35eba32cda5b4c90664ab" translate="yes" xml:space="preserve">
          <source>Nothing happens when I dispatch an action</source>
          <target state="translated">Ничего не происходит,когда я отправляю действие</target>
        </trans-unit>
        <trans-unit id="f2f081e8fb2d918d664c68f1b3afaafa905dc9ec" translate="yes" xml:space="preserve">
          <source>Notice that because the two &quot;slice of state&quot; reducers are now getting only their own part of the whole state as arguments, they no longer need to return complex nested state objects, and are now simpler as a result.</source>
          <target state="translated">Заметьте,что поскольку два редуктора &quot;кусочка состояния&quot; теперь получают в качестве аргументов только свою собственную часть всего состояния,им больше не нужно возвращать сложные вложенные объекты состояния,и в результате все проще.</target>
        </trans-unit>
        <trans-unit id="259bf730b245ab69768be3ff064b89e550ad7e24" translate="yes" xml:space="preserve">
          <source>Notice that because we used the ES6 shorthand for defining an object literal, the key names in the resulting state are the same as the variable names from the imports. This may not always be the desired behavior, and is often a cause of confusion for those who aren't as familiar with ES6 syntax.</source>
          <target state="translated">Обратите внимание,что поскольку мы использовали сокращение ES6 для определения буквы объекта,имена ключей в результирующем состоянии совпадают с именами переменных из импорта.Это не всегда может быть желаемым поведением,и часто является причиной путаницы для тех,кто не так хорошо знаком с синтаксисом ES6.</target>
        </trans-unit>
        <trans-unit id="c55d1d53bcc6077be7393d548df6e69409007456" translate="yes" xml:space="preserve">
          <source>Notice that the structure of the data is a bit complex, and some of the data is repeated. This is a concern for several reasons:</source>
          <target state="translated">Обратите внимание,что структура данных немного сложна,а некоторые данные повторяются.Это связано с несколькими причинами:</target>
        </trans-unit>
        <trans-unit id="31c43966210d015eb458a0c29218a03e52a64682" translate="yes" xml:space="preserve">
          <source>Notice that this simple function fulfills all the basic requirements. It returns a default value if none exists, initializing the store; it determines what sort of update needs to be done based on the type of the action, and returns new values; and it returns the previous state if no work needs to be done.</source>
          <target state="translated">Обратите внимание,что эта простая функция удовлетворяет всем основным требованиям.Она возвращает значение по умолчанию,если его нет,инициализируя хранилище;она определяет,какое обновление необходимо выполнить,исходя из типа действия,и возвращает новые значения;она возвращает предыдущее состояние,если работы не требуется.</target>
        </trans-unit>
        <trans-unit id="2f594ca01c521a947b3e348a3910ebef9ac4949d" translate="yes" xml:space="preserve">
          <source>Now I specified the &lt;code&gt;preloadedState&lt;/code&gt; as the argument to &lt;code&gt;createStore()&lt;/code&gt;. The state returned from the combined reducer &lt;em&gt;combines&lt;/em&gt; the initial state I specified for the &lt;code&gt;a&lt;/code&gt; reducer with the &lt;code&gt;'wat'&lt;/code&gt; default argument specified that &lt;code&gt;b&lt;/code&gt; reducer chose itself.</source>
          <target state="translated">Теперь я указал &lt;code&gt;preloadedState&lt;/code&gt; в качестве аргумента &lt;code&gt;createStore()&lt;/code&gt; . Состояние, возвращаемое комбинированным редуктором, &lt;em&gt;объединяет&lt;/em&gt; начальное состояние, которое я указал для редуктора &lt;code&gt;a&lt;/code&gt; , с аргументом по умолчанию &lt;code&gt;'wat'&lt;/code&gt; , указанным, что редуктор &lt;code&gt;b&lt;/code&gt; выбрал сам.</target>
        </trans-unit>
        <trans-unit id="2b89cc88436f6b137ad4a9f780f72e731b9b03e7" translate="yes" xml:space="preserve">
          <source>Now all that's left to do is to port the UI to &lt;a href=&quot;../basics/usagewithreact&quot;&gt;use react-redux&lt;/a&gt; or equivalent.</source>
          <target state="translated">Теперь все, что осталось сделать, это портировать пользовательский интерфейс для &lt;a href=&quot;../basics/usagewithreact&quot;&gt;использования response-redux&lt;/a&gt; или аналогичного.</target>
        </trans-unit>
        <trans-unit id="eb64c52d4e3660f6e76a49dcb8eecf7480f674ab" translate="yes" xml:space="preserve">
          <source>Now all you need to do is add the buttons for the Undo and Redo actions.</source>
          <target state="translated">Теперь все,что вам нужно сделать,это добавить кнопки для действий &quot;Отмена&quot; и &quot;Повтор&quot;.</target>
        </trans-unit>
        <trans-unit id="a13470744cb184c27b6870ae352da0030e60cab7" translate="yes" xml:space="preserve">
          <source>Now if you click on &lt;code&gt;&amp;lt;FilterLink /&amp;gt;&lt;/code&gt; you will see that your URL will change between &lt;code&gt;'/SHOW_COMPLETED'&lt;/code&gt;, &lt;code&gt;'/SHOW_ACTIVE'&lt;/code&gt;, and &lt;code&gt;'/'&lt;/code&gt;. Even if you are going back with your browser, it will use your browser's history and effectively go to your previous URL.</source>
          <target state="translated">Теперь, если вы нажмете на &lt;code&gt;&amp;lt;FilterLink /&amp;gt;&lt;/code&gt; , вы увидите, что ваш URL изменится между &lt;code&gt;'/SHOW_COMPLETED'&lt;/code&gt; , &lt;code&gt;'/SHOW_ACTIVE'&lt;/code&gt; и &lt;code&gt;'/'&lt;/code&gt; . Даже если вы вернетесь в свой браузер, он будет использовать историю вашего браузера и фактически перейдет к вашему предыдущему URL-адресу.</target>
        </trans-unit>
        <trans-unit id="b5c5b26561c588a93e62173562a3ad6868edb589" translate="yes" xml:space="preserve">
          <source>Now it's &lt;em&gt;very&lt;/em&gt; clear what's happening in each case. We can also start to see some patterns emerging.</source>
          <target state="translated">Теперь &lt;em&gt;очень&lt;/em&gt; ясно, что происходит в каждом конкретном случае. Мы также можем увидеть появление некоторых закономерностей.</target>
        </trans-unit>
        <trans-unit id="039958ecab3a233f66de07e31ed5de4247ff1cc6" translate="yes" xml:space="preserve">
          <source>Now it's time to hook up those presentational components to Redux by creating some containers. Technically, a container component is just a React component that uses &lt;a href=&quot;../api/store#subscribe&quot;&gt;&lt;code&gt;store.subscribe()&lt;/code&gt;&lt;/a&gt; to read a part of the Redux state tree and supply props to a presentational component it renders. You could write a container component by hand, but we suggest instead generating container components with the React Redux library's &lt;a href=&quot;https://github.com/reactjs/react-redux/blob/master/docs/api.md#connectmapstatetoprops-mapdispatchtoprops-mergeprops-options&quot;&gt;&lt;code&gt;connect()&lt;/code&gt;&lt;/a&gt; function, which provides many useful optimizations to prevent unnecessary re-renders. (One result of this is that you shouldn't have to worry about the &lt;a href=&quot;https://facebook.github.io/react/docs/advanced-performance.html&quot;&gt;React performance suggestion&lt;/a&gt; of implementing &lt;code&gt;shouldComponentUpdate&lt;/code&gt; yourself.)</source>
          <target state="translated">Теперь пришло время подключить эти презентационные компоненты к Redux, создав несколько контейнеров. Технически компонент-контейнер - это просто компонент React, который использует &lt;a href=&quot;../api/store#subscribe&quot;&gt; &lt;code&gt;store.subscribe()&lt;/code&gt; &lt;/a&gt; для чтения части дерева состояний Redux и предоставления свойств визуализируемому компоненту представления. Вы можете написать компонент контейнера вручную, но мы предлагаем вместо этого генерировать компоненты контейнера с помощью функции &lt;a href=&quot;https://github.com/reactjs/react-redux/blob/master/docs/api.md#connectmapstatetoprops-mapdispatchtoprops-mergeprops-options&quot;&gt; &lt;code&gt;connect()&lt;/code&gt; &lt;/a&gt; библиотеки React Redux , которая обеспечивает множество полезных оптимизаций для предотвращения ненужных повторных отрисовок. (Одним из результатов этого является то, что вам не нужно беспокоиться о &lt;a href=&quot;https://facebook.github.io/react/docs/advanced-performance.html&quot;&gt;предложении производительности React&lt;/a&gt; о реализации &lt;code&gt;shouldComponentUpdate&lt;/code&gt; самостоятельно.)</target>
        </trans-unit>
        <trans-unit id="9e400bbf3cbd513fc16c8f3c4354394f2d6dfefd" translate="yes" xml:space="preserve">
          <source>Now let's &lt;a href=&quot;reducers&quot;&gt;define some reducers&lt;/a&gt; to specify how the state updates when you dispatch these actions!</source>
          <target state="translated">Теперь давайте &lt;a href=&quot;reducers&quot;&gt;определим несколько редукторов,&lt;/a&gt; чтобы указать, как обновляется состояние при отправке этих действий!</target>
        </trans-unit>
        <trans-unit id="a861289e4760b669f41d014c314ded1b05995e5c" translate="yes" xml:space="preserve">
          <source>Now let's consider a case where you use &lt;code&gt;combineReducers()&lt;/code&gt;.</source>
          <target state="translated">Теперь давайте рассмотрим случай, когда вы используете &lt;code&gt;combineReducers()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="25793e0576f1da9e1c2bfbfd26f6e9946bceb3cb" translate="yes" xml:space="preserve">
          <source>Now let's handle &lt;code&gt;SET_VISIBILITY_FILTER&lt;/code&gt;. All it needs to do is to change &lt;code&gt;visibilityFilter&lt;/code&gt; on the state. Easy:</source>
          <target state="translated">Теперь &lt;code&gt;SET_VISIBILITY_FILTER&lt;/code&gt; . Все, что ему нужно сделать, это изменить &lt;code&gt;visibilityFilter&lt;/code&gt; в состоянии. Легко:</target>
        </trans-unit>
        <trans-unit id="f7f2dcd080c7438e503e2c14d7c5e936c3fb8edb" translate="yes" xml:space="preserve">
          <source>Now let's say you create a store with it.</source>
          <target state="translated">Допустим,ты создашь из него магазин.</target>
        </trans-unit>
        <trans-unit id="29c32e5fc4131c9dccec8ae29eeeaccbf917ea78" translate="yes" xml:space="preserve">
          <source>Now middleware takes the &lt;code&gt;next()&lt;/code&gt; dispatch function, and returns a dispatch function, which in turn serves as &lt;code&gt;next()&lt;/code&gt; to the middleware to the left, and so on. It's still useful to have access to some store methods like &lt;code&gt;getState()&lt;/code&gt;, so &lt;code&gt;store&lt;/code&gt; stays available as the top-level argument.</source>
          <target state="translated">Теперь промежуточное ПО принимает функцию диспетчеризации &lt;code&gt;next()&lt;/code&gt; и возвращает функцию диспетчеризации, которая, в свою очередь, выполняет роль &lt;code&gt;next()&lt;/code&gt; для промежуточного ПО слева и т. Д. По-прежнему полезно иметь доступ к некоторым методам &lt;code&gt;getState()&lt;/code&gt; , таким как getState () , поэтому &lt;code&gt;store&lt;/code&gt; остается доступным как аргумент верхнего уровня.</target>
        </trans-unit>
        <trans-unit id="382b9eb84610aaa6ea11db467333f8d6953604ec" translate="yes" xml:space="preserve">
          <source>Now that we have a better understanding of reducer enhancers, we can see that this is exactly what &lt;code&gt;undoable&lt;/code&gt; should have been:</source>
          <target state="translated">Теперь, когда мы лучше понимаем усилители редуктора, мы можем видеть, что это именно то, что должно было быть &lt;code&gt;undoable&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="a5a09e1de7d9c9396b8d34429449e39f8bd9943d" translate="yes" xml:space="preserve">
          <source>Now that we have created a store, let's verify our program works! Even without any UI, we can already test the update logic.</source>
          <target state="translated">Теперь,когда мы создали магазин,давайте проверим работу нашей программы! Даже не имея никакого пользовательского интерфейса,мы уже можем проверить логику обновления.</target>
        </trans-unit>
        <trans-unit id="b286277222e0bb8486e6265c655c4d0a7094d7a9" translate="yes" xml:space="preserve">
          <source>Now that we've decided what our state object looks like, we're ready to write a reducer for it. The reducer is a pure function that takes the previous state and an action, and returns the next state.</source>
          <target state="translated">Теперь,когда мы решили,как выглядит наш государственный объект,мы готовы написать для него редуктор.Редуктор-это чистая функция,которая принимает предыдущее состояние и действие и возвращает следующее состояние.</target>
        </trans-unit>
        <trans-unit id="c21e7038b2cfa1d79db9097dffc1cae32ab8eff6" translate="yes" xml:space="preserve">
          <source>Now that you know how Redux works, let's &lt;a href=&quot;usagewithreact&quot;&gt;connect it to a React app&lt;/a&gt;.</source>
          <target state="translated">Теперь, когда вы знаете, как работает Redux, давайте &lt;a href=&quot;usagewithreact&quot;&gt;подключим его к приложению React&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="04bd1420551bdec742d2330183e8fe0464300fae" translate="yes" xml:space="preserve">
          <source>Now that you know how to do basic routing, you can learn more about &lt;a href=&quot;https://github.com/reactjs/react-router/tree/v3/docs/&quot;&gt;React Router API&lt;/a&gt;</source>
          <target state="translated">Теперь, когда вы знаете, как выполнять базовую маршрутизацию, вы можете узнать больше о &lt;a href=&quot;https://github.com/reactjs/react-router/tree/v3/docs/&quot;&gt;React Router API.&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="df198929b555d3f025b9f4c6dce1d531c1c5ab85" translate="yes" xml:space="preserve">
          <source>Now the &lt;code&gt;&amp;lt;App /&amp;gt;&lt;/code&gt; component will be rendered if the URL matches '/'. Additionally, we will add the optional &lt;code&gt;(:filter)&lt;/code&gt; parameter to &lt;code&gt;/&lt;/code&gt;, because we will need it further on when we try to read the parameter &lt;code&gt;(:filter)&lt;/code&gt; from the URL.</source>
          <target state="translated">Теперь компонент &lt;code&gt;&amp;lt;App /&amp;gt;&lt;/code&gt; будет отображаться, если URL-адрес соответствует '/'. Кроме того, мы добавим необязательный параметр &lt;code&gt;(:filter)&lt;/code&gt; в &lt;code&gt;/&lt;/code&gt; , потому что он нам понадобится в дальнейшем, когда мы попытаемся прочитать параметр &lt;code&gt;(:filter)&lt;/code&gt; из URL-адреса.</target>
        </trans-unit>
        <trans-unit id="5d916cc36e1dd4f19a7f89bff47aaabeb96451f9" translate="yes" xml:space="preserve">
          <source>Now the &lt;code&gt;todos&lt;/code&gt; part of the state looks like this:</source>
          <target state="translated">Теперь часть состояния &lt;code&gt;todos&lt;/code&gt; выглядит так:</target>
        </trans-unit>
        <trans-unit id="d942270816eb39d5e0deb26630ac877f7158718d" translate="yes" xml:space="preserve">
          <source>Now we can rewrite the main reducer as a function that calls the reducers managing parts of the state, and combines them into a single object. It also doesn't need to know the complete initial state anymore. It's enough that the child reducers return their initial state when given &lt;code&gt;undefined&lt;/code&gt; at first.</source>
          <target state="translated">Теперь мы можем переписать основной редуктор как функцию, которая вызывает редукторы, управляющие частями состояния, и объединяет их в один объект. Также ему больше не нужно знать полное начальное состояние. Достаточно того, что дочерние редукторы возвращают свое начальное состояние, если сначала задано &lt;code&gt;undefined&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a667ae6de0b7dc9eab910e5e9d0c63d6e4240965" translate="yes" xml:space="preserve">
          <source>Now you can add &lt;code&gt;UndoRedo&lt;/code&gt; component to the &lt;code&gt;App&lt;/code&gt; component:</source>
          <target state="translated">Теперь вы можете добавить компонент &lt;code&gt;UndoRedo&lt;/code&gt; в компонент &lt;code&gt;App&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="c2b05aac713becd3e746ad95aee7b78fc6182e91" translate="yes" xml:space="preserve">
          <source>Now you saw an example of what middleware can do in Redux, it's time to learn how it actually works, and how you can create your own. Go on to the next detailed section about &lt;a href=&quot;middleware&quot;&gt;Middleware&lt;/a&gt;.</source>
          <target state="translated">Теперь вы увидели пример того, что промежуточное ПО может делать в Redux, пришло время узнать, как оно работает на самом деле и как вы можете создать свое собственное. Перейдите к следующему подробному разделу о &lt;a href=&quot;middleware&quot;&gt;промежуточном программном обеспечении&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="65dfb2a3456a6347a253e5df887084ce9d5bc969" translate="yes" xml:space="preserve">
          <source>Now you'll be able to call them directly:</source>
          <target state="translated">Теперь ты сможешь позвонить им напрямую:</target>
        </trans-unit>
        <trans-unit id="e7d7d4bdf1f24961ac2cd4648199d9fca2b39f7d" translate="yes" xml:space="preserve">
          <source>Now, if user presses &amp;ldquo;Undo&amp;rdquo;, we want it to change to move into the past:</source>
          <target state="translated">Теперь, если пользователь нажимает &amp;laquo;Отменить&amp;raquo;, мы хотим, чтобы он изменился, чтобы вернуться в прошлое:</target>
        </trans-unit>
        <trans-unit id="9f0f0f51df5136b797764eade8b49d76aa9d3def" translate="yes" xml:space="preserve">
          <source>Now, the UI can be updated to reflect the new state. If you use bindings like &lt;a href=&quot;https://github.com/gaearon/react-redux&quot;&gt;React Redux&lt;/a&gt;, this is the point at which &lt;code&gt;component.setState(newState)&lt;/code&gt; is called.</source>
          <target state="translated">Теперь пользовательский интерфейс можно обновить, чтобы отразить новое состояние. Если вы используете привязки, такие как &lt;a href=&quot;https://github.com/gaearon/react-redux&quot;&gt;React Redux&lt;/a&gt; , это точка, в которой &lt;code&gt;component.setState(newState)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="238539b34511566c52f015ab4f02c6eba84442e7" translate="yes" xml:space="preserve">
          <source>Now, the problem is what to put in the action creator and what in the reducer, the choice between fat and thin action objects. If you put all the logic in the action creator, you end up with fat action objects that basically declare the updates to the state. Reducers become pure, dumb, add-this, remove that, update these functions. They will be easy to compose. But not much of your business logic will be there. If you put more logic in the reducer, you end up with nice, thin action objects, most of your data logic in one place, but your reducers are harder to compose since you might need info from other branches. You end up with large reducers or reducers that take additional arguments from higher up in the state.</source>
          <target state="translated">Теперь проблема в том,что вложить в создателя действия и что в редуктор,выбор между жирными и тонкими объектами действия.Если вы поместите всю логику в создателя действия,то в конечном итоге получите жирные объекты действия,которые в основном декларируют обновление состояния.Редукторы становятся чистыми,немыми,добавляют их,удаляют их,обновляют эти функции.Их будет легко составить.Но не так уж и много вашей бизнес-логики будет.Если вы поместите больше логики в редуктор,то в итоге получите красивые,тонкие объекты действия,большую часть логики данных в одном месте,но ваши редукторы сложнее составить,т.к.вам может понадобиться информация из других ветвей.В итоге вы получаете большие редукторы или редукторы,которые принимают дополнительные аргументы от вышестоящего состояния.</target>
        </trans-unit>
        <trans-unit id="dd811c18dfe3457c25b793431983374970c1dbff" translate="yes" xml:space="preserve">
          <source>Object spread lets us simplify the above &lt;code&gt;map&lt;/code&gt; call to:</source>
          <target state="translated">Распространение объектов позволяет нам упростить приведенный выше вызов &lt;code&gt;map&lt;/code&gt; чтобы:</target>
        </trans-unit>
        <trans-unit id="f2d82a77c6f21355d9167707cd08b4acf80faac7" translate="yes" xml:space="preserve">
          <source>Obviously, each layer of nesting makes this harder to read, and gives more chances to make mistakes. This is one of several reasons why you are encouraged to keep your state flattened, and compose reducers as much as possible.</source>
          <target state="translated">Очевидно,что каждый слой вложенности затрудняет чтение и дает больше шансов на ошибку.Это одна из нескольких причин,по которым вам рекомендуется поддерживать свое состояние сплющенным и составлять редукторы как можно больше.</target>
        </trans-unit>
        <trans-unit id="99059fe3a8c10ea3a773517b2809c9d604ee1753" translate="yes" xml:space="preserve">
          <source>Obviously, trying to handle every possible action in a single function does not scale well, simply in terms of function size and readability, so it makes sense to split the actual work into separate functions that can be called by the top-level reducer. In particular, the common suggested pattern is to have a separate sub-reducer function that is responsible for managing updates to a particular slice of state at a specific key. The &lt;code&gt;combineReducers()&lt;/code&gt; that comes with Redux is one of the many possible ways to achieve this. It's also highly suggested to keep your store state as flat and as normalized as possible. Ultimately, though, you are in charge of organizing your reducer logic any way you want.</source>
          <target state="translated">Очевидно, что попытка обработать все возможные действия в одной функции плохо масштабируется просто с точки зрения размера функции и удобочитаемости, поэтому имеет смысл разделить фактическую работу на отдельные функции, которые могут быть вызваны редуктором верхнего уровня. В частности, общий предлагаемый шаблон состоит в том, чтобы иметь отдельную функцию суб-редуктора, которая отвечает за управление обновлениями определенного фрагмента состояния для определенного ключа. В &lt;code&gt;combineReducers()&lt;/code&gt; , который поставляется с Redux является одним из многих возможных способов достижения этой цели. Также настоятельно рекомендуется сохранять состояние вашего магазина как можно более ровным и максимально нормализованным. Тем не менее, в конечном итоге вы отвечаете за организацию своей логики редуктора любым удобным для вас способом.</target>
        </trans-unit>
        <trans-unit id="0cc135e616ba1be37c0cfabb241f9c97c73b5f08" translate="yes" xml:space="preserve">
          <source>On the client side, a new Redux store will be created and initialized with the state provided from the server.</source>
          <target state="translated">На клиентской стороне будет создано новое Redux-магазин и инициализировано с помощью состояния,предоставляемого сервером.</target>
        </trans-unit>
        <trans-unit id="c6f42b17ddf866ba0ef881ccab2d5ac7ea6bba3a" translate="yes" xml:space="preserve">
          <source>On the server side, we simply wrap our existing code in the &lt;code&gt;fetchCounter&lt;/code&gt; and receive the result in the callback:</source>
          <target state="translated">На стороне сервера мы просто оборачиваем существующий код в &lt;code&gt;fetchCounter&lt;/code&gt; и получаем результат в обратном вызове :</target>
        </trans-unit>
        <trans-unit id="abb297d24ed9dbaa92d7ae801845e13d9a8c7d96" translate="yes" xml:space="preserve">
          <source>On this page we will only feature a few of them that the Redux maintainers have vetted personally. Don't let this discourage you from trying the rest of them! The ecosystem is growing too fast, and we have a limited time to look at everything. Consider these the &amp;ldquo;staff picks&amp;rdquo;, and don't hesitate to submit a PR if you've built something wonderful with Redux.</source>
          <target state="translated">На этой странице мы представим только некоторые из них, которые разработчики Redux проверили лично. Не позволяйте этому препятствовать вам попробовать остальные из них! Экосистема растет слишком быстро, и у нас мало времени, чтобы все рассмотреть. Считайте это &amp;laquo;подбором персонала&amp;raquo; и не стесняйтесь отправлять PR, если вы создали что-то замечательное с Redux.</target>
        </trans-unit>
        <trans-unit id="00a57ab237ca0a42b345eb1574324e493eaac905" translate="yes" xml:space="preserve">
          <source>Once used, Immutable.JS will spread throughout your codebase</source>
          <target state="translated">После использования Immutable.JS распространится по всей вашей кодовой базе.</target>
        </trans-unit>
        <trans-unit id="e388b344448bc1c302e673361dcd29e30a20c835" translate="yes" xml:space="preserve">
          <source>Once you encapsulate your data with Immutable.JS, you have to use Immutable.JS&amp;rsquo;s &lt;code&gt;get()&lt;/code&gt; or &lt;code&gt;getIn()&lt;/code&gt; property accessors to access it.</source>
          <target state="translated">После того, как вы инкапсулируете свои данные с помощью Immutable.JS, вы должны использовать &lt;code&gt;getIn()&lt;/code&gt; доступа к свойствам &lt;code&gt;get()&lt;/code&gt; или getIn () Immutable.JS для доступа к ним.</target>
        </trans-unit>
        <trans-unit id="99e18cc195c97bd7e16b2c5c00f317c2ee608dad" translate="yes" xml:space="preserve">
          <source>One approach is to merge the contents of the action in to the existing state. In this case, we need to do a deep recursive merge, not just a shallow copy. The Lodash &lt;code&gt;merge&lt;/code&gt; function can handle this for us:</source>
          <target state="translated">Один из подходов - объединить содержимое действия с существующим состоянием. В этом случае нам нужно выполнить глубокое рекурсивное слияние, а не просто мелкую копию. Функция &lt;code&gt;merge&lt;/code&gt; Lodash может справиться с этим за нас:</target>
        </trans-unit>
        <trans-unit id="d0a9b8df0f4b63915decda672bef5db25fe34cfb" translate="yes" xml:space="preserve">
          <source>One frequently asked question is whether Redux &quot;calls all reducers&quot; when dispatching an action. Since there really is only one root reducer function, the default answer is &quot;no, it does not&quot;. However, &lt;code&gt;combineReducers&lt;/code&gt; has specific behavior that &lt;em&gt;does&lt;/em&gt; work that way. In order to assemble the new state tree, &lt;code&gt;combineReducers&lt;/code&gt; will call each slice reducer with its current slice of state and the current action, giving the slice reducer a chance to respond and update its slice of state if needed. So, in that sense, using &lt;code&gt;combineReducers&lt;/code&gt;&lt;em&gt;does&lt;/em&gt; &quot;call all reducers&quot;, or at least all of the slice reducers it is wrapping.</source>
          <target state="translated">Один из часто задаваемых вопросов: &quot;вызывает ли Redux все редукторы&quot; при отправке действия. Поскольку на самом деле существует только одна функция корневого редуктора, ответ по умолчанию - &amp;laquo;нет, не работает&amp;raquo;. Однако &lt;code&gt;combineReducers&lt;/code&gt; имеет определенное поведение , что &lt;em&gt;делает&lt;/em&gt; работу таким образом. Чтобы собрать новое дерево состояний, &lt;code&gt;combineReducers&lt;/code&gt; вызовет каждый редуктор среза с его текущим срезом состояния и текущим действием, давая редуктору среза возможность ответить и обновить свой фрагмент состояния, если это необходимо. Таким образом, в этом смысле использование &lt;code&gt;combineReducers&lt;/code&gt; &lt;em&gt;действительно&lt;/em&gt; &amp;laquo;вызывает все редукторы&amp;raquo; или, по крайней мере, все редукторы фрагментов, которые оно обертывает.</target>
        </trans-unit>
        <trans-unit id="a4284542792cb9fd32437214931abfe8482da4b0" translate="yes" xml:space="preserve">
          <source>One neat trick is to use the &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Functions/default_parameters&quot;&gt;ES6 default arguments syntax&lt;/a&gt; to write this in a more compact way:</source>
          <target state="translated">Один из &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Functions/default_parameters&quot;&gt;приемов&lt;/a&gt; - использовать синтаксис аргументов по умолчанию ES6, чтобы записать это более компактно:</target>
        </trans-unit>
        <trans-unit id="da5b8fcb37f2ad97d55411d18f4f50a8acf81489" translate="yes" xml:space="preserve">
          <source>One of the benefits of Redux is that it makes state changes predictable and transparent. Every time an action is dispatched, the new state is computed and saved. The state cannot change by itself, it can only change as a consequence of a specific action.</source>
          <target state="translated">Одним из преимуществ &quot;Редукса&quot; является то,что он делает государственные изменения предсказуемыми и прозрачными.Каждый раз,когда действие отправляется,новое состояние вычисляется и сохраняется.Состояние не может измениться само по себе,оно может измениться только в результате конкретного действия.</target>
        </trans-unit>
        <trans-unit id="b05c40a81c382d7e1e4c5eb83c383c8c7dded6ae" translate="yes" xml:space="preserve">
          <source>One of the key advantages of immutability is that it enables shallow equality checking, which dramatically improves performance.</source>
          <target state="translated">Одним из ключевых преимуществ непреложности является то,что она позволяет проводить поверхностную проверку равенства,что значительно улучшает производительность.</target>
        </trans-unit>
        <trans-unit id="850c598dddd960ff8dafd82d078c789192dada81" translate="yes" xml:space="preserve">
          <source>Operating on JavaScript objects and arrays in an immutable way can be slow, particularly as your state tree grows larger.</source>
          <target state="translated">Работа с объектами и массивами JavaScript может быть медленной,особенно при увеличении дерева состояний.</target>
        </trans-unit>
        <trans-unit id="af6c37b39bb6ed10d58088845d5a93da150bef3c" translate="yes" xml:space="preserve">
          <source>Operations like &quot;Look up all books by this author&quot; can then accomplished with a single loop over the join table. Given the typical amounts of data in a client application and the speed of Javascript engines, this kind of operation is likely to have sufficiently fast performance for most use cases.</source>
          <target state="translated">Такие операции,как &quot;Посмотрите все книги этого автора&quot;,могут быть выполнены с помощью одного цикла над таблицей соединений.Учитывая типичные объемы данных в клиентском приложении и скорость Javascript-движков,этот вид операций,скорее всего,будет иметь достаточно высокую производительность для большинства случаев использования.</target>
        </trans-unit>
        <trans-unit id="0d7d7275da2d9aaca178d7f0589e207de7175f18" translate="yes" xml:space="preserve">
          <source>Or check out the &lt;a href=&quot;https://codesandbox.io/s/github/reactjs/redux/tree/master/examples/async&quot;&gt;sandbox&lt;/a&gt;.</source>
          <target state="translated">Или загляните в &lt;a href=&quot;https://codesandbox.io/s/github/reactjs/redux/tree/master/examples/async&quot;&gt;песочницу&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9a59e4840cfb59b6c79325bf664a6e38968716f6" translate="yes" xml:space="preserve">
          <source>Or check out the &lt;a href=&quot;https://codesandbox.io/s/github/reactjs/redux/tree/master/examples/counter&quot;&gt;sandbox&lt;/a&gt;.</source>
          <target state="translated">Или загляните в &lt;a href=&quot;https://codesandbox.io/s/github/reactjs/redux/tree/master/examples/counter&quot;&gt;песочницу&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1b1b65f5915920208d15bbc3e393183be7f4d31d" translate="yes" xml:space="preserve">
          <source>Or check out the &lt;a href=&quot;https://codesandbox.io/s/github/reactjs/redux/tree/master/examples/real-world&quot;&gt;sandbox&lt;/a&gt;.</source>
          <target state="translated">Или загляните в &lt;a href=&quot;https://codesandbox.io/s/github/reactjs/redux/tree/master/examples/real-world&quot;&gt;песочницу&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e36463d35299a6a01ac3b467e7d9564b1281179e" translate="yes" xml:space="preserve">
          <source>Or check out the &lt;a href=&quot;https://codesandbox.io/s/github/reactjs/redux/tree/master/examples/shopping-cart&quot;&gt;sandbox&lt;/a&gt;.</source>
          <target state="translated">Или загляните в &lt;a href=&quot;https://codesandbox.io/s/github/reactjs/redux/tree/master/examples/shopping-cart&quot;&gt;песочницу&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7b45aa8dcd97522495289719a1a18c6bc3300442" translate="yes" xml:space="preserve">
          <source>Or check out the &lt;a href=&quot;https://codesandbox.io/s/github/reactjs/redux/tree/master/examples/todomvc&quot;&gt;sandbox&lt;/a&gt;.</source>
          <target state="translated">Или загляните в &lt;a href=&quot;https://codesandbox.io/s/github/reactjs/redux/tree/master/examples/todomvc&quot;&gt;песочницу&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d0e47b777f4c49cec0992d3e10c918d3a72df107" translate="yes" xml:space="preserve">
          <source>Or check out the &lt;a href=&quot;https://codesandbox.io/s/github/reactjs/redux/tree/master/examples/todos&quot;&gt;sandbox&lt;/a&gt;.</source>
          <target state="translated">Или загляните в &lt;a href=&quot;https://codesandbox.io/s/github/reactjs/redux/tree/master/examples/todos&quot;&gt;песочницу&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="238eb2632136a6f032d42bfad2c07321a67db57b" translate="yes" xml:space="preserve">
          <source>Or check out the &lt;a href=&quot;https://codesandbox.io/s/github/reactjs/redux/tree/master/examples/todos-with-undo&quot;&gt;sandbox&lt;/a&gt;.</source>
          <target state="translated">Или загляните в &lt;a href=&quot;https://codesandbox.io/s/github/reactjs/redux/tree/master/examples/todos-with-undo&quot;&gt;песочницу&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6685195fe8e2bc04892759da1650e9052a5de4a3" translate="yes" xml:space="preserve">
          <source>Or check out the &lt;a href=&quot;https://codesandbox.io/s/github/reactjs/redux/tree/master/examples/tree-view&quot;&gt;sandbox&lt;/a&gt;.</source>
          <target state="translated">Или загляните в &lt;a href=&quot;https://codesandbox.io/s/github/reactjs/redux/tree/master/examples/tree-view&quot;&gt;песочницу&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8370968834196c749ed73b6cfe92801e8117ab54" translate="yes" xml:space="preserve">
          <source>Or many granular histories so user can undo and redo actions in them independently:</source>
          <target state="translated">Или много гранулированных историй,поэтому пользователь может отменить и повторить действия в них самостоятельно:</target>
        </trans-unit>
        <trans-unit id="0b392c8838a1573058a955eb668416b3dbbd0f9f" translate="yes" xml:space="preserve">
          <source>Or you can define separate types for them:</source>
          <target state="translated">Или вы можете определить для них отдельные типы:</target>
        </trans-unit>
        <trans-unit id="a0da4144d426fe2efff7bea61cbf27a014d43a17" translate="yes" xml:space="preserve">
          <source>Organizing Large React Applications</source>
          <target state="translated">Организация крупномасштабных реактивных применений</target>
        </trans-unit>
        <trans-unit id="8ca854d46781915131c4b8db35d1de91075f652b" translate="yes" xml:space="preserve">
          <source>Organizing Normalized Data in State</source>
          <target state="translated">Организация нормализованных данных в состоянии</target>
        </trans-unit>
        <trans-unit id="34d16c8765f577c8baee06d396d90415855ba54d" translate="yes" xml:space="preserve">
          <source>Organizing State</source>
          <target state="translated">Государство-организатор</target>
        </trans-unit>
        <trans-unit id="077be78f1b3e88543b41122cb8c6c6f77f12b367" translate="yes" xml:space="preserve">
          <source>Other Approaches</source>
          <target state="translated">Другие подходы</target>
        </trans-unit>
        <trans-unit id="eebb2f9cdc2951c739e98100dec8f3363c3a726b" translate="yes" xml:space="preserve">
          <source>Other Components</source>
          <target state="translated">Прочие компоненты</target>
        </trans-unit>
        <trans-unit id="0b72b54d734e499b1f158ae8c13378ee3157b18a" translate="yes" xml:space="preserve">
          <source>Other side effects like generating unique IDs or timestamps in a reducer also make the code unpredictable and harder to debug and test.</source>
          <target state="translated">Другие побочные эффекты,такие как генерация уникальных идентификаторов или временных меток в редукторе,также делают код непредсказуемым и затрудняют отладку и тестирование.</target>
        </trans-unit>
        <trans-unit id="fb937a0b9fb7519cc10c3b20032625261018ed28" translate="yes" xml:space="preserve">
          <source>Other than &lt;code&gt;type&lt;/code&gt;, the structure of an action object is really up to you. If you're interested, check out &lt;a href=&quot;https://github.com/acdlite/flux-standard-action&quot;&gt;Flux Standard Action&lt;/a&gt; for recommendations on how actions could be constructed.</source>
          <target state="translated">Кроме &lt;code&gt;type&lt;/code&gt; , структура объекта действия действительно зависит от вас. Если вам интересно, ознакомьтесь с рекомендациями по созданию &lt;a href=&quot;https://github.com/acdlite/flux-standard-action&quot;&gt;действий&lt;/a&gt; в Flux Standard Action .</target>
        </trans-unit>
        <trans-unit id="6536268ad716d89a65f56ced3b4cc69350c48fb9" translate="yes" xml:space="preserve">
          <source>Other than &lt;code&gt;type&lt;/code&gt;, the structure of an action object is really up to you. If you're interested, check out &lt;a href=&quot;https://github.com/acdlite/flux-standard-action&quot;&gt;Flux Standard Action&lt;/a&gt; for recommendations on how actions should be constructed.</source>
          <target state="translated">Кроме &lt;code&gt;type&lt;/code&gt; , структура объекта действия действительно зависит от вас. Если вам интересно, ознакомьтесь с рекомендациями по построению действий в &lt;a href=&quot;https://github.com/acdlite/flux-standard-action&quot;&gt;Flux Standard Action&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d77d9e8f5844c5c74da60395774b58f7d3f5387d" translate="yes" xml:space="preserve">
          <source>Others, like &lt;a href=&quot;https://github.com/kolodny/immutability-helper&quot;&gt;immutability-helper&lt;/a&gt; (a fork of the now-deprecated React Immutability Helpers addon), use nested values and helper functions:</source>
          <target state="translated">Другие, такие как &lt;a href=&quot;https://github.com/kolodny/immutability-helper&quot;&gt;immutability-helper&lt;/a&gt; (ветвь устаревшего надстройки React Immutability Helpers), используют вложенные значения и вспомогательные функции:</target>
        </trans-unit>
        <trans-unit id="dda0bb30409a978c6095e977bd09a407e7ec0ccd" translate="yes" xml:space="preserve">
          <source>Our app reducer is still aware of all the different cases for our application. Let's try splitting things up so that the filter logic and the todo logic are separated:</source>
          <target state="translated">Наш редуктор приложений все еще знает о различных случаях нашего применения.Давайте попробуем разделить все так,чтобы логика фильтра и логика todo были разделены:</target>
        </trans-unit>
        <trans-unit id="57d76ff70a2b8d5f74ef5118abd52ad01b3bb657" translate="yes" xml:space="preserve">
          <source>Our design brief is simple. We want to show a list of todo items. On click, a todo item is crossed out as completed. We want to show a field where the user may add a new todo. In the footer, we want to show a toggle to show all, only completed, or only active todos.</source>
          <target state="translated">Наш дизайн-бюллетень прост.Мы хотим показать список предметов тодо.Нажав на кнопку,тодо-элемент зачеркивается как завершенный.Мы хотим показать поле,в которое пользователь может добавить новую todo.В нижнем колонтитуле мы хотим показать переключатель,чтобы показать все,только завершенные или только активные тодо.</target>
        </trans-unit>
        <trans-unit id="53d2ee76615e0933562a889f329ff05a0a727e4c" translate="yes" xml:space="preserve">
          <source>Overall, Redux-ORM provides a very useful set of abstractions for defining relations between data types, creating the &quot;tables&quot; in our state, retrieving and denormalizing relational data, and applying immutable updates to relational data.</source>
          <target state="translated">В целом,Redux-ORM предоставляет очень полезный набор абстракций для определения отношений между типами данных,создания &quot;таблиц&quot; в нашем состоянии,извлечения и денормализации реляционных данных,а также применения к реляционным данным незыблемых обновлений.</target>
        </trans-unit>
        <trans-unit id="31d482d1d287457cca90cae82978407bee745dc3" translate="yes" xml:space="preserve">
          <source>PDF: JavaScript Immutability - Don&amp;rsquo;t go changing</source>
          <target state="translated">PDF: Неизменяемость JavaScript - Не меняйся</target>
        </trans-unit>
        <trans-unit id="a975eea30db9fa05003e3b5097688bd49ec7e01b" translate="yes" xml:space="preserve">
          <source>Parameters</source>
          <target state="translated">Parameters</target>
        </trans-unit>
        <trans-unit id="430ea9730cf326c3cf262aa3e00acbc94a6af33d" translate="yes" xml:space="preserve">
          <source>Passing the Store</source>
          <target state="translated">Проходя мимо магазина</target>
        </trans-unit>
        <trans-unit id="acae9ab8b8cf95f09e38c1fb61c7e7375972f22f" translate="yes" xml:space="preserve">
          <source>Patrons</source>
          <target state="translated">Patrons</target>
        </trans-unit>
        <trans-unit id="d9b870a4eca18252d7bd7d9da857129a2bd3ed18" translate="yes" xml:space="preserve">
          <source>Perform side effects like API calls and routing transitions;</source>
          <target state="translated">Выполняйте побочные эффекты,такие как вызовы API и маршрутизация переходов;</target>
        </trans-unit>
        <trans-unit id="63c904559993935c470f516c8b549ca7f3640dbb" translate="yes" xml:space="preserve">
          <source>Performance</source>
          <target state="translated">Performance</target>
        </trans-unit>
        <trans-unit id="09c0613fe519089a7fc506820537146b438f0dc9" translate="yes" xml:space="preserve">
          <source>Pete Hunt, one of the early contributors to React, says:</source>
          <target state="translated">Пит Хант,один из ранних участников &quot;Реакции&quot;,говорит:</target>
        </trans-unit>
        <trans-unit id="518776dd7f483eb0d4df7b1bd43c6cdb73104192" translate="yes" xml:space="preserve">
          <source>Poor Performance</source>
          <target state="translated">Плохая производительность</target>
        </trans-unit>
        <trans-unit id="9993816052f22041086b70cb5e1a32b14dfbb33d" translate="yes" xml:space="preserve">
          <source>Practical Redux, Part 6: Connected Lists, Forms, and Performance</source>
          <target state="translated">Практическое воссоздание,Часть 6:Связанные списки,формы и производительность</target>
        </trans-unit>
        <trans-unit id="738c6f9450a7465416076aa7cb2f7dbc8ca7bcb4" translate="yes" xml:space="preserve">
          <source>Preparing the Initial State</source>
          <target state="translated">Подготовка начального состояния</target>
        </trans-unit>
        <trans-unit id="02510af1c9e56dc9bd70dc87dc84e81b435ad642" translate="yes" xml:space="preserve">
          <source>Prerequisite Concepts</source>
          <target state="translated">Предпосылки Концепции</target>
        </trans-unit>
        <trans-unit id="69ac187c979012e887601c19566c66ee6ab15258" translate="yes" xml:space="preserve">
          <source>Prerequisite Concepts for Writing Reducers</source>
          <target state="translated">Предпосылки для написания редукторов</target>
        </trans-unit>
        <trans-unit id="1c55cdda21f1ad5ea1b98437db0236145dd69099" translate="yes" xml:space="preserve">
          <source>Prerequisite Reducer Concepts</source>
          <target state="translated">Преимущества концепции редуктора</target>
        </trans-unit>
        <trans-unit id="b3ed0c728475ae7dfeea9ed4c1bc0af7c27941d6" translate="yes" xml:space="preserve">
          <source>Presentational Components</source>
          <target state="translated">Презентационные компоненты</target>
        </trans-unit>
        <trans-unit id="69e7885b45c24e48f26b3abc065d13744594de0a" translate="yes" xml:space="preserve">
          <source>Presentational and Container Components</source>
          <target state="translated">Презентационные и контейнерные компоненты</target>
        </trans-unit>
        <trans-unit id="f184d44b598b788adde29d493e92a5c25b0ed0b5" translate="yes" xml:space="preserve">
          <source>Prior Art</source>
          <target state="translated">Приоритетное искусство</target>
        </trans-unit>
        <trans-unit id="9cb3636454de25708139a72d5a8daebcbab292a1" translate="yes" xml:space="preserve">
          <source>Problem: Crash Reporting</source>
          <target state="translated">Проблема:Сообщение об аварии</target>
        </trans-unit>
        <trans-unit id="4367434447e2cee1f6e98eeb1e8d7bc393e9ff67" translate="yes" xml:space="preserve">
          <source>Problem: Logging</source>
          <target state="translated">Проблема:Протоколирование</target>
        </trans-unit>
        <trans-unit id="55ebe517b50c8c6c3d52435b9681b506cd9eed36" translate="yes" xml:space="preserve">
          <source>Processing Request Parameters</source>
          <target state="translated">Параметры запроса на обработку</target>
        </trans-unit>
        <trans-unit id="71d526269be49e8a2200a08466e2a7f151fbcce6" translate="yes" xml:space="preserve">
          <source>Pros and Cons of Using Immutability With React</source>
          <target state="translated">Плюсы и минусы использования непреложности с реакцией</target>
        </trans-unit>
        <trans-unit id="4be452a463fb3cf62c5a4a03fdd906246f9e80cd" translate="yes" xml:space="preserve">
          <source>Pros and Cons of Using Immutability with React</source>
          <target state="translated">Плюсы и минусы использования непреложности с реакцией</target>
        </trans-unit>
        <trans-unit id="dc98b8947b98b64aa54d5357f558ae0935c47d87" translate="yes" xml:space="preserve">
          <source>Pros and Cons of using immutability with React.js</source>
          <target state="translated">Плюсы и минусы использования неизменяемости с React.js</target>
        </trans-unit>
        <trans-unit id="d6e73fb000c8b75a17c1069b0079cbf4bdde15b6" translate="yes" xml:space="preserve">
          <source>Pros and Cons of using immutability with React.js - React Kung Fu</source>
          <target state="translated">Плюсы и минусы использования неизменяемости с React.js-React Kung Fu</target>
        </trans-unit>
        <trans-unit id="21cf88ab38b25368d2f9cb3c579e6a17bc644483" translate="yes" xml:space="preserve">
          <source>Pure Functions and Side Effects</source>
          <target state="translated">Чистые функции и побочные эффекты</target>
        </trans-unit>
        <trans-unit id="86a07cd587b106a4018fbf8dbee2dbdcf791f1eb" translate="yes" xml:space="preserve">
          <source>Pure functionality and side effects in Redux</source>
          <target state="translated">Чистая функциональность и побочные эффекты в Redux</target>
        </trans-unit>
        <trans-unit id="82a325d136b15dd1db828b5e748b6d37453db386" translate="yes" xml:space="preserve">
          <source>Pure functions</source>
          <target state="translated">Чистые функции</target>
        </trans-unit>
        <trans-unit id="a0fb821bdaf93ed9a1f1e920acfb2840eff5b153" translate="yes" xml:space="preserve">
          <source>Purpose</source>
          <target state="translated">Purpose</target>
        </trans-unit>
        <trans-unit id="ea644ff66049122da6969531a96ca0fe72184b08" translate="yes" xml:space="preserve">
          <source>Querying a Redux Store</source>
          <target state="translated">Запрос в магазин &quot;Редюкс</target>
        </trans-unit>
        <trans-unit id="55075a14cfbfc51a035aba7e61a80df40309acdd" translate="yes" xml:space="preserve">
          <source>Rails-style: separate folders for &amp;ldquo;actions&amp;rdquo;, &amp;ldquo;constants&amp;rdquo;, &amp;ldquo;reducers&amp;rdquo;, &amp;ldquo;containers&amp;rdquo;, and &amp;ldquo;components&amp;rdquo;</source>
          <target state="translated">В стиле Rails: отдельные папки для &amp;laquo;действий&amp;raquo;, &amp;laquo;констант&amp;raquo;, &amp;laquo;редюсеров&amp;raquo;, &amp;laquo;контейнеров&amp;raquo; и &amp;laquo;компонентов&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="45a38418ad120f3d535295f729a198b3b7c6c8d7" translate="yes" xml:space="preserve">
          <source>React Boilerplate #27: Application Structure</source>
          <target state="translated">Реакционная котельная №27:Структура применения</target>
        </trans-unit>
        <trans-unit id="efc78471488cf3d2e323b930c4ab2275310bd60b" translate="yes" xml:space="preserve">
          <source>React Forums: Redux and global state vs local state</source>
          <target state="translated">Реакционные форумы:Редукс и глобальный штат против местного штата</target>
        </trans-unit>
        <trans-unit id="214641af7b84dcf096934eb2a695cb6d024aae3a" translate="yes" xml:space="preserve">
          <source>React Higher Order Components in depth</source>
          <target state="translated">Глубоко реагируйте на компоненты более высокого порядка</target>
        </trans-unit>
        <trans-unit id="01d8e1cb3dcc43b6aac331fa4ddc4ac02aff9465" translate="yes" xml:space="preserve">
          <source>React How-To</source>
          <target state="translated">Как реагировать</target>
        </trans-unit>
        <trans-unit id="c00f59a0285f84558e8d0d48133c22e6b6f706e6" translate="yes" xml:space="preserve">
          <source>React Redux</source>
          <target state="translated">Реакция Редукс</target>
        </trans-unit>
        <trans-unit id="e9ec3cce75743443bbba2142d270fc34d79b7599" translate="yes" xml:space="preserve">
          <source>React Redux #145: consider always passing down dispatch regardless of what mapDispatchToProps does</source>
          <target state="translated">React Redux #145:рассмотреть возможность всегда передавать диспетчерскую,независимо от того,что делает картаDispatchToProps.</target>
        </trans-unit>
        <trans-unit id="732e7a5dfabaa54435e980f9e805a54c93e2dd29" translate="yes" xml:space="preserve">
          <source>React Redux #235: Predicate function for updating component</source>
          <target state="translated">Реакция Редукс №235:Предикатная функция для обновления компонента</target>
        </trans-unit>
        <trans-unit id="01a98dba508a8efb62a16078cc6efb83597ba734" translate="yes" xml:space="preserve">
          <source>React Redux #255: this.props.dispatch is undefined if using mapDispatchToProps</source>
          <target state="translated">React Redux #255:this.props.dispefined if using mapDispatchToProps is undefined if using mapDispatchToProps</target>
        </trans-unit>
        <trans-unit id="287e83661d0b0ace70aa4b2e7cbc6e6a0b50d186" translate="yes" xml:space="preserve">
          <source>React Redux #263: Huge performance issue when dispatching hundreds of actions</source>
          <target state="translated">React Redux #263:Огромная проблема производительности при отправке сотен действий</target>
        </trans-unit>
        <trans-unit id="2aea4e5f490054875b5d85d349369a3658b249ef" translate="yes" xml:space="preserve">
          <source>React Redux #269: Connect could be used with a custom subscribe method</source>
          <target state="translated">React Redux #269:Соединение может быть использовано с индивидуальным методом подписки.</target>
        </trans-unit>
        <trans-unit id="bbdb52200c9c3640fa284dd7801b308c292acc73" translate="yes" xml:space="preserve">
          <source>React Redux #291: Should mapStateToProps be called every time an action is dispatched?</source>
          <target state="translated">React Redux #291:Должен ли mapStateToProps вызываться каждый раз при отправке действия?</target>
        </trans-unit>
        <trans-unit id="ca17da9174a409f3ef37d08c9748a93925d108fc" translate="yes" xml:space="preserve">
          <source>React Redux #407: Rewrite connect to offer an advanced API</source>
          <target state="translated">React Redux #407:Перезаписать соединение,чтобы предложить расширенный API</target>
        </trans-unit>
        <trans-unit id="4e611799527e4e43143ed34634f793cd5a162cf1" translate="yes" xml:space="preserve">
          <source>React Redux #416: Rewrite connect for better performance and extensibility</source>
          <target state="translated">React Redux #416:Перезапись соединения для лучшей производительности и расширяемости</target>
        </trans-unit>
        <trans-unit id="3f31b465a1a05e3ab0e22b96c59d09ee25c33ef2" translate="yes" xml:space="preserve">
          <source>React Redux #89: can i wrap multi actionCreators into one props with name?</source>
          <target state="translated">React Redux #89:могу ли я обернуть несколько ActionCreators в один реквизит с именем?</target>
        </trans-unit>
        <trans-unit id="fa04ceff7eca5e570aecaefd3ee71f236ce6eb9f" translate="yes" xml:space="preserve">
          <source>React Redux API: connect()</source>
          <target state="translated">React Redux API:connect()</target>
        </trans-unit>
        <trans-unit id="5fffe16c96023bbe3dd9abec1447678a45a147c0" translate="yes" xml:space="preserve">
          <source>React Redux implements several optimizations to ensure your actual component only re-renders when actually necessary. One of those is a shallow equality check on the combined props object generated by the &lt;code&gt;mapStateToProps&lt;/code&gt; and &lt;code&gt;mapDispatchToProps&lt;/code&gt; arguments passed to &lt;code&gt;connect&lt;/code&gt;. Unfortunately, shallow equality does not help in cases where new array or object instances are created each time &lt;code&gt;mapStateToProps&lt;/code&gt; is called. A typical example might be mapping over an array of IDs and returning the matching object references, such as:</source>
          <target state="translated">React Redux реализует несколько оптимизаций, чтобы ваш фактический компонент повторно отображался только тогда, когда это действительно необходимо. Одним из них является неглубокая проверка равенства для объединенного объекта &lt;code&gt;mapStateToProps&lt;/code&gt; &lt;code&gt;mapDispatchToProps&lt;/code&gt; аргументами mapStateToProps и mapDispatchToProps, переданными для &lt;code&gt;connect&lt;/code&gt; . К сожалению, поверхностное равенство не помогает в случаях, когда новые экземпляры массива или объекта создаются при каждом &lt;code&gt;mapStateToProps&lt;/code&gt; . Типичным примером может быть сопоставление массива идентификаторов и возврат соответствующих ссылок на объекты, например:</target>
        </trans-unit>
        <trans-unit id="4b3923afd4f9b76fbadb161e5309fe47c5935c89" translate="yes" xml:space="preserve">
          <source>React Redux: Troubleshooting</source>
          <target state="translated">Реакция Редукс:устранение неполадок</target>
        </trans-unit>
        <trans-unit id="7cf84f305d9b4ae3d2e5899504cef59f17174eb6" translate="yes" xml:space="preserve">
          <source>React Router comes with a &lt;a href=&quot;https://github.com/ReactTraining/react-router/blob/v3/docs/API.md#link&quot;&gt;&lt;code&gt;&amp;lt;Link /&amp;gt;&lt;/code&gt;&lt;/a&gt; component that lets you navigate around your application. In our example, we can wrap &lt;code&gt;&amp;lt;Link /&amp;gt;&lt;/code&gt; with a new container component &lt;code&gt;&amp;lt;FilterLink /&amp;gt;&lt;/code&gt; so as to dynamically change the URL. The &lt;code&gt;activeStyle={}&lt;/code&gt; property lets us apply a style on the active state.</source>
          <target state="translated">React Router поставляется с компонентом &lt;a href=&quot;https://github.com/ReactTraining/react-router/blob/v3/docs/API.md#link&quot;&gt; &lt;code&gt;&amp;lt;Link /&amp;gt;&lt;/code&gt; ,&lt;/a&gt; который позволяет вам перемещаться по вашему приложению. В нашем примере мы можем обернуть &lt;code&gt;&amp;lt;Link /&amp;gt;&lt;/code&gt; новым компонентом контейнера &lt;code&gt;&amp;lt;FilterLink /&amp;gt;&lt;/code&gt; , чтобы динамически изменять URL-адрес. Свойство &lt;code&gt;activeStyle={}&lt;/code&gt; позволяет нам применить стиль к активному состоянию.</target>
        </trans-unit>
        <trans-unit id="679ef62ec4985a413831aad6d5f132c1e1b0074f" translate="yes" xml:space="preserve">
          <source>React bindings for Redux embrace the idea of &lt;strong&gt;separating presentational and container components&lt;/strong&gt;. If you're not familiar with these terms, &lt;a href=&quot;https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0&quot;&gt;read about them first&lt;/a&gt;, and then come back. They are important, so we'll wait!</source>
          <target state="translated">Привязки React для Redux включают идею &lt;strong&gt;разделения презентационных и контейнерных компонентов&lt;/strong&gt; . Если вы не знакомы с этими терминами, &lt;a href=&quot;https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0&quot;&gt;сначала прочтите о них&lt;/a&gt; , а затем возвращайтесь. Они важны, так что подождем!</target>
        </trans-unit>
        <trans-unit id="cd703ea889752160be52204476a7e5217587c640" translate="yes" xml:space="preserve">
          <source>React-Redux Bindings</source>
          <target state="translated">Крепления React-Redux</target>
        </trans-unit>
        <trans-unit id="720534ae4ea5a2a18f4bb7bfe9ed16ef3bef02de" translate="yes" xml:space="preserve">
          <source>React-Redux performs a shallow equality check on on each &lt;em&gt;value&lt;/em&gt; within the props object, not on the props object itself.</source>
          <target state="translated">React-Redux выполняет поверхностную проверку равенства для каждого &lt;em&gt;значения&lt;/em&gt; в объекте props, а не для самого объекта props.</target>
        </trans-unit>
        <trans-unit id="9a3b307a7afe13dcc2d2b56d385f6e7fcdd89e12" translate="yes" xml:space="preserve">
          <source>React-Redux therefore maintains separate references to each &lt;em&gt;value&lt;/em&gt; in the returned props object.</source>
          <target state="translated">Поэтому React-Redux поддерживает отдельные ссылки на каждое &lt;em&gt;значение&lt;/em&gt; в возвращаемом объекте props.</target>
        </trans-unit>
        <trans-unit id="a84961e51f0e9045534f55ef19c9b890ec0454dc" translate="yes" xml:space="preserve">
          <source>React-Redux uses shallow equality checking to determine whether the component it&amp;rsquo;s wrapping needs to be re-rendered.</source>
          <target state="translated">React-Redux использует поверхностную проверку равенства, чтобы определить, нужно ли повторно визуализировать компонент, который он обертывает.</target>
        </trans-unit>
        <trans-unit id="25f69fafc4d53ef37a01d27855717f1b910c32ee" translate="yes" xml:space="preserve">
          <source>React-Redux's &lt;code&gt;connect&lt;/code&gt; method generates components that &lt;a href=&quot;#how-react-redux-uses-shallow-checking&quot;&gt;shallowly check reference changes to the root state&lt;/a&gt;, and the return values from the &lt;code&gt;mapStateToProps&lt;/code&gt; function to see if the wrapped components actually need to re-render. Such &lt;a href=&quot;#redux-shallow-checking-requires-immutability&quot;&gt;shallow checking requires immutability&lt;/a&gt; to function correctly.</source>
          <target state="translated">Метод &lt;code&gt;connect&lt;/code&gt; React-Redux генерирует компоненты, которые &lt;a href=&quot;#how-react-redux-uses-shallow-checking&quot;&gt;неглубоко проверяют ссылочные изменения на корневое состояние&lt;/a&gt; и возвращаемые значения из функции &lt;code&gt;mapStateToProps&lt;/code&gt; , чтобы увидеть, действительно ли упакованные компоненты нуждаются в повторной визуализации. Такая &lt;a href=&quot;#redux-shallow-checking-requires-immutability&quot;&gt;поверхностная проверка требует неизменности&lt;/a&gt; для правильного функционирования.</target>
        </trans-unit>
        <trans-unit id="7f4f4a56fd030dcfc889dad10f3ba7abdeb9bf09" translate="yes" xml:space="preserve">
          <source>React.js Pure Render Performance Anti-Pattern</source>
          <target state="translated">Реакция.js Чистая анти-контактная модель производительности рейнджера</target>
        </trans-unit>
        <trans-unit id="efcf558b2b7ed1ce931d4bbaf10d10e4a81b9190" translate="yes" xml:space="preserve">
          <source>React.js pure render performance anti-pattern</source>
          <target state="translated">React.js чистое исполнение рендеринга против шаблонов</target>
        </trans-unit>
        <trans-unit id="a6c84930df2d0caae45068e630cc45ccf1245b86" translate="yes" xml:space="preserve">
          <source>React/Redux Links: &quot;Redux Side Effects&quot; category</source>
          <target state="translated">React/Redux Links:Категория &quot;Побочные эффекты Редукса&quot;</target>
        </trans-unit>
        <trans-unit id="e7b97ce28bebc20ce4023d4d1544d8ca708ac055" translate="yes" xml:space="preserve">
          <source>React/Redux Links: Architecture - Project File Structure</source>
          <target state="translated">React/Redux Links:Архитектура-Структура файла проекта</target>
        </trans-unit>
        <trans-unit id="799adc6d5d994e504c2c138e4ff53248644d5147" translate="yes" xml:space="preserve">
          <source>React/Redux Links: Architecture - Redux Architecture</source>
          <target state="translated">Ссылки React/Redux:Архитектура-Редукс Архитектура</target>
        </trans-unit>
        <trans-unit id="f700891537e9332e39007ef543a0c7005ac696ee" translate="yes" xml:space="preserve">
          <source>React/Redux Links: Immutable Data</source>
          <target state="translated">React/Redux Links:Неизменяемые данные</target>
        </trans-unit>
        <trans-unit id="fce00908db372392230a5dc59966f0556c9a96b3" translate="yes" xml:space="preserve">
          <source>React/Redux Links: Performance - Redux</source>
          <target state="translated">React/Redux Links:Производительность-Редукс</target>
        </trans-unit>
        <trans-unit id="ea6624400dd0619a4028a0782161b341f95b9bf3" translate="yes" xml:space="preserve">
          <source>React/Redux Links: Performance - Redux Performance</source>
          <target state="translated">Ссылки React/Redux:Производительность-производительность Redux</target>
        </trans-unit>
        <trans-unit id="11abaa387b4e1d4c6df486f331bca1593b96648d" translate="yes" xml:space="preserve">
          <source>React/Redux Links: React/Redux Performance</source>
          <target state="translated">React/Redux Links:Реакция/редукс производительность</target>
        </trans-unit>
        <trans-unit id="86308254ca58c32a4b48e2e7a927c0057319908d" translate="yes" xml:space="preserve">
          <source>React: Higher-Order Components</source>
          <target state="translated">Реакция:Компоненты вышестоящего уровня</target>
        </trans-unit>
        <trans-unit id="2d90bde2bec2c8fa094a1d2200ae82033494cad5" translate="yes" xml:space="preserve">
          <source>React: Optimizing Performance</source>
          <target state="translated">Реагируй:Оптимизация производительности</target>
        </trans-unit>
        <trans-unit id="7d9c1b09aeb1d155202a538eba6d9a3492931ad1" translate="yes" xml:space="preserve">
          <source>Read &lt;a href=&quot;asyncflow&quot;&gt;Async Flow&lt;/a&gt; to recap how async actions fit into the Redux flow.</source>
          <target state="translated">Прочтите &lt;a href=&quot;asyncflow&quot;&gt;Async Flow,&lt;/a&gt; чтобы узнать, как асинхронные действия вписываются в поток Redux.</target>
        </trans-unit>
        <trans-unit id="b607ca1ed943113b8bd40acd28ee479c753558db" translate="yes" xml:space="preserve">
          <source>Read data from props</source>
          <target state="translated">Считать данные из реквизита</target>
        </trans-unit>
        <trans-unit id="99172ffcab6825648dfba7e3fc262a9a5fbe7648" translate="yes" xml:space="preserve">
          <source>Read the &lt;a href=&quot;exampletodolist&quot;&gt;complete source code for this tutorial&lt;/a&gt; to better internalize the knowledge you have gained. Then, head straight to the &lt;a href=&quot;../advanced/index&quot;&gt;advanced tutorial&lt;/a&gt; to learn how to handle network requests and routing!</source>
          <target state="translated">Прочтите &lt;a href=&quot;exampletodolist&quot;&gt;полный исходный код этого руководства,&lt;/a&gt; чтобы лучше усвоить полученные знания. Затем перейдите прямо к &lt;a href=&quot;../advanced/index&quot;&gt;расширенному руководству,&lt;/a&gt; чтобы узнать, как обрабатывать сетевые запросы и маршрутизацию!</target>
        </trans-unit>
        <trans-unit id="b21e1ed4d5217309315f564ff74b9eea1936e93c" translate="yes" xml:space="preserve">
          <source>Reading From the URL</source>
          <target state="translated">Чтение с URL-адреса</target>
        </trans-unit>
        <trans-unit id="095c451a2e9ce2021d38bf795774b05403fc75f1" translate="yes" xml:space="preserve">
          <source>Real World</source>
          <target state="translated">Реальный мир</target>
        </trans-unit>
        <trans-unit id="a49698c20a1d19a475a3edf8be8f8f8b30ec65ca" translate="yes" xml:space="preserve">
          <source>Recap</source>
          <target state="translated">Recap</target>
        </trans-unit>
        <trans-unit id="9fb1092f32d4fcbf9e061ffd718d4ec689c6c95e" translate="yes" xml:space="preserve">
          <source>Recipes</source>
          <target state="translated">Recipes</target>
        </trans-unit>
        <trans-unit id="42624a20e6e4c1562537410bf82ff591ce07f160" translate="yes" xml:space="preserve">
          <source>Recipes: Computed Derived Data</source>
          <target state="translated">Рецепты:Вычисленные полученные данные</target>
        </trans-unit>
        <trans-unit id="b6d39d52a5e86324ade1d44e7e08ce0b5387e017" translate="yes" xml:space="preserve">
          <source>Recipes: Computing Derived Data</source>
          <target state="translated">Рецепты:Производные данные для вычислений</target>
        </trans-unit>
        <trans-unit id="5effb0f63ab3eb21c89f18e6368e7c1d5f17c3ac" translate="yes" xml:space="preserve">
          <source>Recipes: Immutable Update Patterns</source>
          <target state="translated">Рецепты:Неизменяемые шаблоны обновления</target>
        </trans-unit>
        <trans-unit id="cbeb9b0f5422b15a6d088c47aaf6e528d0350c4c" translate="yes" xml:space="preserve">
          <source>Recipes: Prerequisite Reducer Concepts</source>
          <target state="translated">Рецепты:Концепции редукторов</target>
        </trans-unit>
        <trans-unit id="49a1f34779a5afe85e05cff662577501366300bb" translate="yes" xml:space="preserve">
          <source>Recipes: Reducing Boilerplate</source>
          <target state="translated">Рецепты:Уменьшающий котел</target>
        </trans-unit>
        <trans-unit id="8c1f469e59e4322a9cb07ef58ade84919608d01c" translate="yes" xml:space="preserve">
          <source>Recipes: Structuring Reducers</source>
          <target state="translated">Рецепты:Редукторы структурирования</target>
        </trans-unit>
        <trans-unit id="29196f40d836acaf77c762f6f7580bf65b85cab3" translate="yes" xml:space="preserve">
          <source>Recipes: Structuring Reducers - Immutable Update Patterns</source>
          <target state="translated">Рецепты:Редукторы структуры-Неизменяемые шаблоны обновления</target>
        </trans-unit>
        <trans-unit id="cb76eaeb79f5b86547d0360e4948f5f88d59b72d" translate="yes" xml:space="preserve">
          <source>Recipes: Structuring Reducers - Normalizing State Shape</source>
          <target state="translated">Рецепты:Редукторы Структурирования-Нормализующая Форма Состояния</target>
        </trans-unit>
        <trans-unit id="e9e51b9812b2e58af4823344e551de6481db8b1b" translate="yes" xml:space="preserve">
          <source>Recipes: Structuring Reducers - Prerequisite Concepts</source>
          <target state="translated">Рецепты:Редукторы структуры-необходимые концепции</target>
        </trans-unit>
        <trans-unit id="d8db7ccea3429c3219a46b29a7fb105658ffffce" translate="yes" xml:space="preserve">
          <source>Recipes: Structuring Reducers - Splitting Reducer Logic</source>
          <target state="translated">Рецепты:Логика структурирования редукторов-Разделение логики редукторов</target>
        </trans-unit>
        <trans-unit id="e29b3bc65e2933e5a918d6357b2967374e89998f" translate="yes" xml:space="preserve">
          <source>Recipes: Using the Object Spread Operator</source>
          <target state="translated">Рецепты:Использование Оператора Распространения Объектов</target>
        </trans-unit>
        <trans-unit id="3b66d7a1f117e84d49ce190a144bfa4013537819" translate="yes" xml:space="preserve">
          <source>Recipes: immutability, side effects and mutation</source>
          <target state="translated">Рецепты:неизменяемость,побочные эффекты и мутация</target>
        </trans-unit>
        <trans-unit id="f0284a396b98e7ed88f256c52e6515c77bb1b45d" translate="yes" xml:space="preserve">
          <source>Reddit: &quot;When should I put something into my Redux store?&quot;</source>
          <target state="translated">Реддит:&quot;Когда я должен положить что-нибудь в мой магазин Redux?&quot;</target>
        </trans-unit>
        <trans-unit id="daca44adc4ef60f42583641246276d004e688c4b" translate="yes" xml:space="preserve">
          <source>Reddit: Help designing Redux state for a single page app</source>
          <target state="translated">Реддит:Справка по проектированию состояния Redux для одностраничного приложения</target>
        </trans-unit>
        <trans-unit id="afe887e317c898f703e24f7d827235e7f21d4918" translate="yes" xml:space="preserve">
          <source>Reddit: Help performing Async API calls with Redux-Promise Middleware.</source>
          <target state="translated">Реддит:Помощь в выполнении Async API-вызовов с Redux-Promise Middleware.</target>
        </trans-unit>
        <trans-unit id="15ccb05f9d496bf9727d87cee8b1f71f8bdbfba0" translate="yes" xml:space="preserve">
          <source>Reddit: Large open source react/redux projects?</source>
          <target state="translated">Реддит:Большие проекты с открытым исходным кодом?</target>
        </trans-unit>
        <trans-unit id="31b5fcaedfa00391f0da82305fa9d9c465e145ba" translate="yes" xml:space="preserve">
          <source>Reddit: React/Redux for Ultra Large Scale apps</source>
          <target state="translated">Реддит:Реакция/редактирование для ультра-больших приложений.</target>
        </trans-unit>
        <trans-unit id="dc41eb745ff0afdeef230ca621cfd49d330d77d6" translate="yes" xml:space="preserve">
          <source>Reddit: Redux performance issues with a large state object?</source>
          <target state="translated">Реддит:Проблемы с исполнением Redux с большим государственным объектом?</target>
        </trans-unit>
        <trans-unit id="ad1dcdbc206f62d81049e1fbbc24d1b99f39b065" translate="yes" xml:space="preserve">
          <source>Reddit: What's the best place to keep initial state?</source>
          <target state="translated">Реддит:Какое лучшее место для сохранения исходного состояния?</target>
        </trans-unit>
        <trans-unit id="216d6244581ce722d2b213f82dbff87a6148139c" translate="yes" xml:space="preserve">
          <source>Reddit: What's the best place to keep the initial state?</source>
          <target state="translated">Реддит:Какое лучшее место для сохранения исходного состояния?</target>
        </trans-unit>
        <trans-unit id="6473c3e5bd0f3e386d368c764bc6cec02354577e" translate="yes" xml:space="preserve">
          <source>Reddit: Why Redux Needs Reducers To Be Pure Functions</source>
          <target state="translated">Реддит:Почему Redux нуждается в редукторах,чтобы быть чистыми функциями.</target>
        </trans-unit>
        <trans-unit id="05ce1169a192ae766ca0f1d7c50a759c7c51974e" translate="yes" xml:space="preserve">
          <source>Reddit: You don't need Redux if your app just fetches something on a single page</source>
          <target state="translated">Реддит:Вам не нужен Redux,если ваше приложение просто получит что-то на одной странице.</target>
        </trans-unit>
        <trans-unit id="cffbc53fcadf1ea0dddef2d232230038efb6dd3c" translate="yes" xml:space="preserve">
          <source>Reddit: acemarke and cpsubrian comments on Dan Abramov: Redux is not an architecture or design pattern, it is just a library.</source>
          <target state="translated">Reddit:acemarke и cpsubrian комментарии к Дану Абрамову:Redux-это не архитектурный или дизайнерский шаблон,это просто библиотека.</target>
        </trans-unit>
        <trans-unit id="59ce6f6beebd57025f07ecd7d9c06fc4781ffca1" translate="yes" xml:space="preserve">
          <source>Reducer</source>
          <target state="translated">Reducer</target>
        </trans-unit>
        <trans-unit id="1b526057cc1ef5812f4ada08c7de94063561f436" translate="yes" xml:space="preserve">
          <source>Reducer Concepts and Techniques</source>
          <target state="translated">Концепции и технологии редукторов</target>
        </trans-unit>
        <trans-unit id="dda31a027bfa36f4ca8585837d08aaa1912d41bf" translate="yes" xml:space="preserve">
          <source>Reducers</source>
          <target state="translated">Reducers</target>
        </trans-unit>
        <trans-unit id="840f7767cb01214ba0a12025998a85422ab6e283" translate="yes" xml:space="preserve">
          <source>Reducers are just pure functions that take the previous state and an action, and return the next state. Remember to return new state objects, instead of mutating the previous state. You can start with a single reducer, and as your app grows, split it off into smaller reducers that manage specific parts of the state tree. Because reducers are just functions, you can control the order in which they are called, pass additional data, or even make reusable reducers for common tasks such as pagination.</source>
          <target state="translated">Редукторы-это просто чистые функции,которые принимают предыдущее состояние и действие,и возвращают следующее состояние.Не забудьте вернуть новые объекты состояния,вместо того,чтобы мутировать предыдущее состояние.Вы можете начать с одного редуктора,и по мере роста приложения разбивать его на более мелкие редукторы,которые управляют определенными частями дерева состояний.Поскольку редукторы-это всего лишь функции,вы можете управлять порядком их вызова,передавать дополнительные данные или даже делать редукторы многоразового использования для таких обычных задач,как разбивка по страницам.</target>
        </trans-unit>
        <trans-unit id="96a29cc7551675123cb7f5294dd805e57df90ca1" translate="yes" xml:space="preserve">
          <source>Reducers are not unique to Redux&amp;mdash;they are a fundamental concept in functional programming. Even most non-functional languages, like JavaScript, have a built-in API for reducing. In JavaScript, it's &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce&quot;&gt;&lt;code&gt;Array.prototype.reduce()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Редукторы не уникальны для Redux - они являются фундаментальной концепцией функционального программирования. Даже у большинства нефункциональных языков, таких как JavaScript, есть встроенный API для сокращения. В JavaScript это &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce&quot;&gt; &lt;code&gt;Array.prototype.reduce()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="693d4ec3dd35d12c94a5cb25d408b2e71be3d5b1" translate="yes" xml:space="preserve">
          <source>Reducers are the most important concept in Redux.</source>
          <target state="translated">Редукторы-самая важная концепция в &quot;Редуксе&quot;.</target>
        </trans-unit>
        <trans-unit id="493c42af719ab1cd4cc31be798bcf7e6648293eb" translate="yes" xml:space="preserve">
          <source>Reducing Boilerplate</source>
          <target state="translated">Уменьшающий котел</target>
        </trans-unit>
        <trans-unit id="1a5dd83d686967dbee491e598c66e203e42c8bea" translate="yes" xml:space="preserve">
          <source>Redux</source>
          <target state="translated">Redux</target>
        </trans-unit>
        <trans-unit id="ec290bd2917cc3416af368d34f3c085a675f09e6" translate="yes" xml:space="preserve">
          <source>Redux Addons Catalog: Component State</source>
          <target state="translated">Каталог Редукс Аддонс:Состояние компонентов</target>
        </trans-unit>
        <trans-unit id="8290cc030aab4b8babf95fab40608d602458690f" translate="yes" xml:space="preserve">
          <source>Redux Addons Catalog: DevTools - Component Update Monitoring</source>
          <target state="translated">Каталог Редукс Аддонс:DevTools-Мониторинг обновления компонентов</target>
        </trans-unit>
        <trans-unit id="f07485fcebaac4a393292df3922516fc30d4bbca" translate="yes" xml:space="preserve">
          <source>Redux Addons Catalog: Store - Change Subscriptions</source>
          <target state="translated">Каталог Редукс Аддонс:Магазин-Изменить подписку</target>
        </trans-unit>
        <trans-unit id="a577b901e78ea650452597a6b1059b8084d2ebcb" translate="yes" xml:space="preserve">
          <source>Redux Addons Catalog: Store Change Subscriptions</source>
          <target state="translated">Каталог Редукс Аддонс:Сменные подписки в магазине</target>
        </trans-unit>
        <trans-unit id="a6d683688573717dedb09bb8c524dd092308d6bd" translate="yes" xml:space="preserve">
          <source>Redux Addons Catalog: Use Cases - Authentication</source>
          <target state="translated">Каталог Редукс Аддонс:Использовать случаи-Аутентификация</target>
        </trans-unit>
        <trans-unit id="9344d1305fa4b38f64ad8cebd9635fa2921b0e1a" translate="yes" xml:space="preserve">
          <source>Redux Best Practices</source>
          <target state="translated">Редюкс Лучшие практики</target>
        </trans-unit>
        <trans-unit id="bfac34990e02b9e66cd0d6829d754be59da6a26f" translate="yes" xml:space="preserve">
          <source>Redux Docs: &lt;code&gt;combineReducers&lt;/code&gt;</source>
          <target state="translated">Redux Docs: &lt;code&gt;combineReducers&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="114c170f090803b3e9b2bcc5c3a6e50beaeed134" translate="yes" xml:space="preserve">
          <source>Redux Docs: Implementing Undo History</source>
          <target state="translated">Редукс Докс:История внедрения Отмены</target>
        </trans-unit>
        <trans-unit id="9e6cb1adf2efb90cb6a27ea6a72f98f7ab473f85" translate="yes" xml:space="preserve">
          <source>Redux Docs: Reducers</source>
          <target state="translated">Редукс Докс:Редукторы</target>
        </trans-unit>
        <trans-unit id="9d40a9cd844cea91b94b47ac94fa5330e9011c46" translate="yes" xml:space="preserve">
          <source>Redux Docs: Reducing Boilerplate</source>
          <target state="translated">Редукс Докс:Уменьшение котельной</target>
        </trans-unit>
        <trans-unit id="726708480591ce54144dc3645deedfceb6e02a27" translate="yes" xml:space="preserve">
          <source>Redux Docs: Using the Object Spread Operator</source>
          <target state="translated">Редукс Докс:Использование Оператора Распространения Объектов</target>
        </trans-unit>
        <trans-unit id="43b86674da50a6ae9dfb143b4ed6cba4221221fc" translate="yes" xml:space="preserve">
          <source>Redux Egghead Course Notes</source>
          <target state="translated">Заметки к курсу Redux Egghead</target>
        </trans-unit>
        <trans-unit id="4428f96db39ca62c1587ebeaa693e35a74b127e5" translate="yes" xml:space="preserve">
          <source>Redux FAQ</source>
          <target state="translated">Часто задаваемые вопросы Redux</target>
        </trans-unit>
        <trans-unit id="d41715c0d155a118b9497d660d8d8ce21d26b4a2" translate="yes" xml:space="preserve">
          <source>Redux FAQ - How do I share state between two reducers? do I have to use &lt;code&gt;combineReducers&lt;/code&gt;?</source>
          <target state="translated">Redux FAQ - Как разделить состояние между двумя редукторами? мне нужно использовать &lt;code&gt;combineReducers&lt;/code&gt; ?</target>
        </trans-unit>
        <trans-unit id="c491bee4fced1d7081108b5ad804a138bbbbd52e" translate="yes" xml:space="preserve">
          <source>Redux FAQ: Actions</source>
          <target state="translated">Часто задаваемые вопросы:Действия</target>
        </trans-unit>
        <trans-unit id="d4e401fc452061ae23c6d3ded639c0139571e70a" translate="yes" xml:space="preserve">
          <source>Redux FAQ: Code Structure</source>
          <target state="translated">Часто задаваемые вопросы:структурный код</target>
        </trans-unit>
        <trans-unit id="b9dd7213b027596f3629ad531290ad9920e77526" translate="yes" xml:space="preserve">
          <source>Redux FAQ: General</source>
          <target state="translated">Часто задаваемые вопросы:Общие сведения</target>
        </trans-unit>
        <trans-unit id="0d53c1155526d25e48dcd19338cae9548715d564" translate="yes" xml:space="preserve">
          <source>Redux FAQ: Immutable Data</source>
          <target state="translated">Часто задаваемые вопросы:Непрерывные данные</target>
        </trans-unit>
        <trans-unit id="af79a6a6e3a5246c79d316570a87b7cf700c435e" translate="yes" xml:space="preserve">
          <source>Redux FAQ: Miscellaneous</source>
          <target state="translated">Часто задаваемые вопросы:Разное</target>
        </trans-unit>
        <trans-unit id="ac2ba19db266451829b5648e7675c23413cb2290" translate="yes" xml:space="preserve">
          <source>Redux FAQ: Organizing State</source>
          <target state="translated">Часто задаваемые вопросы:Государство-организатор</target>
        </trans-unit>
        <trans-unit id="b775beb138a1c3fb7195b5b0df10ccb6b82fa87d" translate="yes" xml:space="preserve">
          <source>Redux FAQ: Performance</source>
          <target state="translated">Часто задаваемые вопросы:Производительность</target>
        </trans-unit>
        <trans-unit id="a5b614caad88c44f368607bba25481b521bd85c6" translate="yes" xml:space="preserve">
          <source>Redux FAQ: React Redux</source>
          <target state="translated">Часто задаваемые вопросы:React Redux</target>
        </trans-unit>
        <trans-unit id="ef49df474a3cc851a7439d8e67a8e396e5ccf5d5" translate="yes" xml:space="preserve">
          <source>Redux FAQ: Reducers</source>
          <target state="translated">Часто задаваемые вопросы:Редукторы</target>
        </trans-unit>
        <trans-unit id="24a41d53bd26e4da6f09186f3361b234ecd45560" translate="yes" xml:space="preserve">
          <source>Redux FAQ: Store Setup</source>
          <target state="translated">Часто задаваемые вопросы:Настройка магазина</target>
        </trans-unit>
        <trans-unit id="0102181826c0cb7d859681534988eee33484e834" translate="yes" xml:space="preserve">
          <source>Redux Patterns and Anti-Patterns</source>
          <target state="translated">Редукс-шаблоны и анти-шаблоны</target>
        </trans-unit>
        <trans-unit id="e73b59699c981c999e9ca3504f30fe27527addd7" translate="yes" xml:space="preserve">
          <source>Redux Reducer Basics</source>
          <target state="translated">Редукторные основы</target>
        </trans-unit>
        <trans-unit id="56891cb67a23a2b058baaee611e9e76e2ced8ffb" translate="yes" xml:space="preserve">
          <source>Redux Reducer/Selector Asymmetry</source>
          <target state="translated">Редуктор/селекторная асимметрия Редуктор/селекторная асимметрия</target>
        </trans-unit>
        <trans-unit id="d7f6bdcedeb4f02ba8baec4a6f623462b01e41d1" translate="yes" xml:space="preserve">
          <source>Redux Side-Effects and You</source>
          <target state="translated">Redux Sidux Side-Effects и ты...</target>
        </trans-unit>
        <trans-unit id="ec9ae2589e9681b8d5b9a2330255a41898aa3398" translate="yes" xml:space="preserve">
          <source>Redux Tutorial</source>
          <target state="translated">Учебное пособие Редукс</target>
        </trans-unit>
        <trans-unit id="d6c0eff7c8b338ccc1a25decaa770c2ce1222c1c" translate="yes" xml:space="preserve">
          <source>Redux Without Profanity: Normalizr</source>
          <target state="translated">Redux Without Profanity:Нормализатор</target>
        </trans-unit>
        <trans-unit id="37f4f3e1befc5ff99eacec66375e5105a07bde1d" translate="yes" xml:space="preserve">
          <source>Redux architecture revolves around a &lt;strong&gt;strict unidirectional data flow&lt;/strong&gt;.</source>
          <target state="translated">Архитектура Redux основана на &lt;strong&gt;строгом однонаправленном потоке данных&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="ca8fd39e0f583c4771e3b7ab47147f9b7250d1ac" translate="yes" xml:space="preserve">
          <source>Redux assumes that you never mutate the objects it gives to you in the reducer. &lt;strong&gt;Every single time, you must return the new state object.&lt;/strong&gt; Even if you don't use a library like &lt;a href=&quot;https://facebook.github.io/immutable-js/&quot;&gt;Immutable&lt;/a&gt;, you need to completely avoid mutation.</source>
          <target state="translated">Redux предполагает, что вы никогда не изменяете объекты, которые он дает вам в редукторе. &lt;strong&gt;Каждый раз вы должны возвращать новый объект состояния. &lt;/strong&gt;Даже если вы не используете такую ​​библиотеку, как &lt;a href=&quot;https://facebook.github.io/immutable-js/&quot;&gt;Immutable&lt;/a&gt; , вам нужно полностью избегать мутации.</target>
        </trans-unit>
        <trans-unit id="d9b13f4fc65014317fe6e4b9892befedf11af3bc" translate="yes" xml:space="preserve">
          <source>Redux can be described in three fundamental principles:</source>
          <target state="translated">Редукс&quot; можно описать в трех основополагающих принципах:</target>
        </trans-unit>
        <trans-unit id="325d0a3329fe90a45278bb0a0417bd084002d235" translate="yes" xml:space="preserve">
          <source>Redux can be used as a data store for any UI layer. The most common usage is with React and React Native, but there are bindings available for Angular, Angular 2, Vue, Mithril, and more. Redux simply provides a subscription mechanism which can be used by any other code. That said, it is most useful when combined with a declarative view implementation that can infer the UI updates from the state changes, such as React or one of the similar libraries available.</source>
          <target state="translated">Redux может использоваться в качестве хранилища данных для любого слоя пользовательского интерфейса.Наиболее часто используется с React and React Native,но есть привязки,доступные для Angular,Angular 2,Vue,Mithril и многих других.Redux просто предоставляет механизм подписки,который может быть использован любым другим кодом.Тем не менее,он наиболее полезен в сочетании с реализацией декларативного представления,которое может выводить обновления пользовательского интерфейса из изменений состояния,таких как React или одна из доступных подобных библиотек.</target>
        </trans-unit>
        <trans-unit id="b52d3f31e7f26a9796dbdf1e3a68c3e4fb5e3992" translate="yes" xml:space="preserve">
          <source>Redux does not store a history of actions itself. However, the Redux DevTools do store actions so they can be replayed, but those are generally only enabled during development, and not used in production.</source>
          <target state="translated">Редукс сам по себе не хранит историю действий.Тем не менее,Redux DevTools хранит действия,чтобы их можно было воспроизвести,но они,как правило,включаются только во время разработки и не используются в производстве.</target>
        </trans-unit>
        <trans-unit id="5dbbf7352cc48a4f94b3a8d8faa33290b580cd67" translate="yes" xml:space="preserve">
          <source>Redux encourages you to think about your application in terms of the data you need to manage. The data at any given point in time is the &quot;&lt;em&gt;state&lt;/em&gt;&quot; of your application, and the structure and organization of that state is typically referred to as its &quot;&lt;em&gt;shape&lt;/em&gt;&quot;. The shape of your state plays a major role in how you structure your reducer logic.</source>
          <target state="translated">Redux побуждает вас думать о своем приложении с точки зрения данных, которыми вы должны управлять. Данные в любой заданный момент времени - это &amp;laquo; &lt;em&gt;состояние&lt;/em&gt; &amp;raquo; вашего приложения, а структура и организация этого состояния обычно упоминаются как его &amp;laquo; &lt;em&gt;форма&lt;/em&gt; &amp;raquo;. Форма вашего состояния играет важную роль в том, как вы структурируете логику редуктора.</target>
        </trans-unit>
        <trans-unit id="0516f1b49c0332831cef6d046aead301f5a49142" translate="yes" xml:space="preserve">
          <source>Redux evolves the ideas of &lt;a href=&quot;http://facebook.github.io/flux/&quot;&gt;Flux&lt;/a&gt;, but avoids its complexity by taking cues from &lt;a href=&quot;https://github.com/evancz/elm-architecture-tutorial/&quot;&gt;Elm&lt;/a&gt;.</source>
          <target state="translated">Redux развивает идеи &lt;a href=&quot;http://facebook.github.io/flux/&quot;&gt;Flux&lt;/a&gt; , но избегает его сложности, беря реплики от &lt;a href=&quot;https://github.com/evancz/elm-architecture-tutorial/&quot;&gt;Elm&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e3d9d039526eff2bcbbc1e2bb2c6ef489f1116bd" translate="yes" xml:space="preserve">
          <source>Redux has a mixed heritage. It is similar to some patterns and technologies, but is also different from them in important ways. We'll explore some of the similarities and the differences below.</source>
          <target state="translated">У &quot;Редукса&quot; смешанное наследие.Он похож на некоторые модели и технологии,но также отличается от них по важным параметрам.Мы рассмотрим некоторые сходства и различия ниже.</target>
        </trans-unit>
        <trans-unit id="08c2c8d16a217b7f149595bcdd911d990cf837d5" translate="yes" xml:space="preserve">
          <source>Redux is a predictable state container for JavaScript apps.</source>
          <target state="translated">Redux является контейнером предсказуемого состояния для JavaScript-приложений.</target>
        </trans-unit>
        <trans-unit id="1658730b992fc25b0e570963398f980bbbac8597" translate="yes" xml:space="preserve">
          <source>Redux is a tiny library, but its contracts and APIs are carefully chosen to spawn an ecosystem of tools and extensions.</source>
          <target state="translated">Redux-крошечная библиотека,но ее контракты и API тщательно подобраны,чтобы породить экосистему инструментов и расширений.</target>
        </trans-unit>
        <trans-unit id="d0def49afc1d69e709f05c3918091a08540604e3" translate="yes" xml:space="preserve">
          <source>Redux is distributed with a few examples in its &lt;a href=&quot;https://github.com/reactjs/redux/tree/master/examples&quot;&gt;source code&lt;/a&gt;. Most of these examples are also on &lt;a href=&quot;https://codesandbox.io&quot;&gt;CodeSandbox&lt;/a&gt;, this is an online editor that lets you play with the examples online.</source>
          <target state="translated">Redux распространяется с несколькими примерами в &lt;a href=&quot;https://github.com/reactjs/redux/tree/master/examples&quot;&gt;исходном коде&lt;/a&gt; . Большинство этих примеров также есть на &lt;a href=&quot;https://codesandbox.io&quot;&gt;CodeSandbox&lt;/a&gt; , это онлайн-редактор, который позволяет вам играть с примерами онлайн.</target>
        </trans-unit>
        <trans-unit id="2bc1ca81429d291e4da182d33067adbc2146a5ff" translate="yes" xml:space="preserve">
          <source>Redux is in part &lt;a href=&quot;../introduction/priorart&quot;&gt;inspired by Flux&lt;/a&gt;, and the most common complaint about Flux is how it makes you write a lot of boilerplate. In this recipe, we will consider how Redux lets us choose how verbose we'd like our code to be, depending on personal style, team preferences, longer term maintainability, and so on.</source>
          <target state="translated">Redux частично &lt;a href=&quot;../introduction/priorart&quot;&gt;вдохновлен Flux&lt;/a&gt; , и наиболее частая жалоба на Flux заключается в том, что он заставляет вас писать много шаблонов. В этом рецепте мы рассмотрим, как Redux позволяет нам выбирать, насколько подробным мы хотели бы, чтобы наш код был, в зависимости от личного стиля, предпочтений команды, удобства обслуживания в долгосрочной перспективе и так далее.</target>
        </trans-unit>
        <trans-unit id="8ca9a51778106939cd3dfebf9551abdc4b16988e" translate="yes" xml:space="preserve">
          <source>Redux is inspired by functional programming, and out of the box, has no place for side effects to be executed. In particular, reducer functions &lt;em&gt;must&lt;/em&gt; always be pure functions of &lt;code&gt;(state, action) =&amp;gt; newState&lt;/code&gt;. However, Redux's middleware makes it possible to intercept dispatched actions and add additional complex behavior around them, including side effects.</source>
          <target state="translated">Redux вдохновлен функциональным программированием, и в нем нет места для выполнения побочных эффектов. В частности, функции-редукторы всегда &lt;em&gt;должны&lt;/em&gt; быть чистыми функциями от &lt;code&gt;(state, action) =&amp;gt; newState&lt;/code&gt; . Однако промежуточное ПО Redux позволяет перехватывать отправленные действия и добавлять к ним дополнительное сложное поведение, включая побочные эффекты.</target>
        </trans-unit>
        <trans-unit id="2e51cf296aaae20f776d432b753a50cb2d012fba" translate="yes" xml:space="preserve">
          <source>Redux is not a monolithic framework, but a set of contracts and a &lt;a href=&quot;../api/index&quot;&gt;few functions that make them work together&lt;/a&gt;. The majority of your &amp;ldquo;Redux code&amp;rdquo; will not even use Redux APIs, as most of the time you'll be writing functions.</source>
          <target state="translated">Redux - это не монолитная структура, а набор контрактов и &lt;a href=&quot;../api/index&quot;&gt;несколько функций, которые заставляют их работать вместе&lt;/a&gt; . Большая часть вашего &amp;laquo;кода Redux&amp;raquo; даже не будет использовать API-интерфейсы Redux, так как большую часть времени вы будете писать функции.</target>
        </trans-unit>
        <trans-unit id="5fa50b0cdd3b8374bae86ce4f34e3e66331618ca" translate="yes" xml:space="preserve">
          <source>Redux is originally written in ES6 and transpiled for production into ES5 with Webpack and Babel. You should be able to use it regardless of your JavaScript build process. Redux also offers a UMD build that can be used directly without any build process at all. The &lt;a href=&quot;https://github.com/reactjs/redux/tree/master/examples/counter-vanilla&quot;&gt;counter-vanilla&lt;/a&gt; example demonstrates basic ES5 usage with Redux included as a &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; tag. As the relevant pull request says:</source>
          <target state="translated">Redux изначально написан на ES6 и перенесен для производства в ES5 с помощью Webpack и Babel. Вы должны иметь возможность использовать его независимо от процесса сборки JavaScript. Redux также предлагает сборку UMD, которую можно использовать напрямую, без какого-либо процесса сборки. &lt;a href=&quot;https://github.com/reactjs/redux/tree/master/examples/counter-vanilla&quot;&gt;Встречное ваниль&lt;/a&gt; пример демонстрирует основы использования ES5 с Redux включены как &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; тега. Как говорится в соответствующем запросе на перенос:</target>
        </trans-unit>
        <trans-unit id="34fee0109b88a277c57526193a6d212f3a10d90d" translate="yes" xml:space="preserve">
          <source>Redux itself is very simple.</source>
          <target state="translated">Сам Редукс очень прост.</target>
        </trans-unit>
        <trans-unit id="42dce762d39e68e2336c77e1bc865792d15451f7" translate="yes" xml:space="preserve">
          <source>Redux may not be as efficient out of the box when compared to other libraries. For maximum rendering performance in a React application, state should be stored in a normalized shape, many individual components should be connected to the store instead of just a few, and connected list components should pass item IDs to their connected child list items (allowing the list items to look up their own data by ID). This minimizes the overall amount of rendering to be done. Use of memoized selector functions is also an important performance consideration.</source>
          <target state="translated">Редукс может быть не так эффективен по сравнению с другими библиотеками.Для максимальной производительности рендеринга в React-приложении,состояние должно храниться в нормализованном виде,многие отдельные компоненты должны быть подключены к хранилищу вместо нескольких,а подключенные компоненты списка должны передавать идентификаторы элементов своим подключенным дочерним элементам списка (позволяя элементам списка искать свои собственные данные по идентификаторам).Это минимизирует общий объем рендеринга.Использование запоминаемых функций селектора также является важным фактором производительности.</target>
        </trans-unit>
        <trans-unit id="3d50c81abd53c840945ee2fdbaa44b7467c60100" translate="yes" xml:space="preserve">
          <source>Redux middleware act like a linked list. Each middleware function can either call &lt;code&gt;next(action)&lt;/code&gt; to pass an action along to the next middleware in line, call &lt;code&gt;dispatch(action)&lt;/code&gt; to restart the processing at the beginning of the list, or do nothing at all to stop the action from being processed further.</source>
          <target state="translated">Промежуточное ПО Redux действует как связанный список. Каждая функция промежуточного программного обеспечения может либо вызвать &lt;code&gt;next(action)&lt;/code&gt; для передачи действия следующему промежуточному программному обеспечению в строке, либо вызвать &lt;code&gt;dispatch(action)&lt;/code&gt; чтобы перезапустить обработку в начале списка, либо вообще ничего не делать, чтобы остановить обработку действия. дальше.</target>
        </trans-unit>
        <trans-unit id="66a12ac42dd9b817c0a1c7e67e3311842a1c46e9" translate="yes" xml:space="preserve">
          <source>Redux middleware solves different problems than Express or Koa middleware, but in a conceptually similar way. &lt;strong&gt;It provides a third-party extension point between dispatching an action, and the moment it reaches the reducer.&lt;/strong&gt; People use Redux middleware for logging, crash reporting, talking to an asynchronous API, routing, and more.</source>
          <target state="translated">Промежуточное ПО Redux решает другие проблемы, чем промежуточное ПО Express или Koa, но концептуально аналогичным образом. &lt;strong&gt;Он обеспечивает стороннюю точку расширения между отправкой действия и моментом его достижения редуктором. &lt;/strong&gt;Люди используют промежуточное ПО Redux для ведения журналов, отчетов о сбоях, взаимодействия с асинхронным API, маршрутизации и многого другого.</target>
        </trans-unit>
        <trans-unit id="63d4a8adb65aae837c51967b76d09fff2ff98328" translate="yes" xml:space="preserve">
          <source>Redux notifies subscribers after each successfully dispatched action (i.e. an action reached the store and was handled by reducers). In some cases, it may be useful to cut down on the number of times subscribers are called, particularly if an action creator dispatches multiple distinct actions in a row.</source>
          <target state="translated">Redux уведомляет абонентов о каждом успешно отправленном действии (т.е.действие дошло до магазина и было обработано редукторами).В некоторых случаях может быть полезно сократить количество обращений к подписчикам,особенно если создатель действия отправляет несколько различных действий подряд.</target>
        </trans-unit>
        <trans-unit id="5e36bd6fb2ddfb9b618b443d363e9df585734103" translate="yes" xml:space="preserve">
          <source>Redux on the Server</source>
          <target state="translated">Редукс на сервере</target>
        </trans-unit>
        <trans-unit id="321a21760687e7864fd03dec217ad326b52df5ef" translate="yes" xml:space="preserve">
          <source>Redux provides a single &lt;code&gt;store.subscribe&lt;/code&gt; method for notifying listeners that the store has updated. Listener callbacks do not receive the current state as an argument&amp;mdash;it is simply an indication that &lt;em&gt;something&lt;/em&gt; has changed. The subscriber logic can then call &lt;code&gt;getState()&lt;/code&gt; to get the current state value.</source>
          <target state="translated">Redux предоставляет единственный метод &lt;code&gt;store.subscribe&lt;/code&gt; для уведомления слушателей об обновлении хранилища. Обратные вызовы слушателя не получают текущее состояние в качестве аргумента - это просто признак того, &lt;em&gt;что&lt;/em&gt; что- &lt;em&gt;то&lt;/em&gt; изменилось. Затем логика подписчика может вызвать &lt;code&gt;getState()&lt;/code&gt; чтобы получить значение текущего состояния.</target>
        </trans-unit>
        <trans-unit id="4319c52fd7a20695a4bdd02b2e2cc58d73b86bdf" translate="yes" xml:space="preserve">
          <source>Redux puts some basic constraints on how that write logic function should work. As described in &lt;a href=&quot;../basics/reducers&quot;&gt;Reducers&lt;/a&gt;, it has to have a signature of &lt;code&gt;(previousState, action) =&amp;gt; newState&lt;/code&gt;, is known as a &lt;strong&gt;&lt;em&gt;reducer function&lt;/em&gt;&lt;/strong&gt;, and must be &lt;em&gt;pure&lt;/em&gt; and predictable.</source>
          <target state="translated">Redux накладывает некоторые базовые ограничения на то, как должна работать эта функция логики записи. Как описано в &lt;a href=&quot;../basics/reducers&quot;&gt;разделе &amp;laquo;Редукторы&amp;raquo;&lt;/a&gt; , он должен иметь сигнатуру &lt;code&gt;(previousState, action) =&amp;gt; newState&lt;/code&gt; , известен как &lt;strong&gt;&lt;em&gt;функция-редуктор&lt;/em&gt;&lt;/strong&gt; и должен быть &lt;em&gt;чистым&lt;/em&gt; и предсказуемым.</target>
        </trans-unit>
        <trans-unit id="59977664d77ebcee933d545dac412554294aeaf2" translate="yes" xml:space="preserve">
          <source>Redux reduces the boilerplate of Flux stores considerably by describing the update logic as a function. A function is simpler than an object, and much simpler than a class.</source>
          <target state="translated">Redux значительно уменьшает шаблон накопителей Flux,описывая логику обновления как функцию.Функция проще объекта и намного проще класса.</target>
        </trans-unit>
        <trans-unit id="402da21959ad1b00c3d1ab6f8adf5613dbe09688" translate="yes" xml:space="preserve">
          <source>Redux uses shallow equality checking in its &lt;code&gt;combineReducers&lt;/code&gt; function to return either a new mutated copy of the root state object, or, if no mutations have been made, the current root state object.</source>
          <target state="translated">Redux использует неглубокую проверку равенства в своей функции &lt;code&gt;combineReducers&lt;/code&gt; для возврата либо новой измененной копии объекта корневого состояния, либо, если никаких изменений не было сделано, текущего объекта корневого состояния.</target>
        </trans-unit>
        <trans-unit id="fc4318e83cc01aa898dd245b381a161bc5966ecd" translate="yes" xml:space="preserve">
          <source>Redux vs MobX TodoMVC Benchmark: #1</source>
          <target state="translated">Redux против MobX TodoMVC Benchmark:#1</target>
        </trans-unit>
        <trans-unit id="6ad6e121085cd64eb499597e7144d3ad136b11ac" translate="yes" xml:space="preserve">
          <source>Redux was inspired by several important qualities of Flux. Like Flux, Redux prescribes that you concentrate your model update logic in a certain layer of your application (&amp;ldquo;stores&amp;rdquo; in Flux, &amp;ldquo;reducers&amp;rdquo; in Redux). Instead of letting the application code directly mutate the data, both tell you to describe every mutation as a plain object called an &amp;ldquo;action&amp;rdquo;.</source>
          <target state="translated">Redux был вдохновлен несколькими важными качествами Flux. Как и Flux, Redux предписывает вам сконцентрировать логику обновления вашей модели на определенном уровне вашего приложения (&amp;laquo;хранилища&amp;raquo; в Flux, &amp;laquo;редукторы&amp;raquo; в Redux). Вместо того, чтобы позволять коду приложения напрямую изменять данные, оба говорят вам описывать каждую мутацию как простой объект, называемый &amp;laquo;действием&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="fdbb1f1c5606597f48f095414e66742812988218" translate="yes" xml:space="preserve">
          <source>Redux's &lt;code&gt;combineReducers&lt;/code&gt; utility &lt;a href=&quot;#how-redux-uses-shallow-checking&quot;&gt;shallowly checks for reference changes&lt;/a&gt; caused by the reducers that it calls.</source>
          <target state="translated">Утилита Redux &lt;code&gt;combineReducers&lt;/code&gt; &lt;a href=&quot;#how-redux-uses-shallow-checking&quot;&gt;неглубоко проверяет ссылки на изменения,&lt;/a&gt; вызванные вызываемыми редукторами.</target>
        </trans-unit>
        <trans-unit id="88595cd44ffbc83a4871c93314b71b115c573390" translate="yes" xml:space="preserve">
          <source>Redux's &lt;strong&gt;&lt;em&gt;only&lt;/em&gt;&lt;/strong&gt; job on the server side is to provide the &lt;strong&gt;initial state&lt;/strong&gt; of our app.</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;Единственная&lt;/em&gt;&lt;/strong&gt; задача Redux на стороне сервера - обеспечить &lt;strong&gt;начальное состояние&lt;/strong&gt; нашего приложения.</target>
        </trans-unit>
        <trans-unit id="d7eb32f60e5c70f3bc2c26ceb6005796e8b88abe" translate="yes" xml:space="preserve">
          <source>Redux's use of shallow equality checking requires immutability if any connected components are to be updated correctly. To see why, we need to understand the difference between shallow and deep equality checking in JavaScript.</source>
          <target state="translated">Использование компанией Redux поверхностной проверки равенства требует неизменности,если какие-либо подключенные компоненты должны быть обновлены корректно.Чтобы понять почему,нужно понимать разницу между поверхностной и глубокой проверкой равенства в JavaScript.</target>
        </trans-unit>
        <trans-unit id="143302841cb0d7dca0440bc31869328f76d81e32" translate="yes" xml:space="preserve">
          <source>Redux-ORM</source>
          <target state="translated">Redux-ORM</target>
        </trans-unit>
        <trans-unit id="7367376eab7e449568c0adff1f6f05f157d89179" translate="yes" xml:space="preserve">
          <source>Reduxible #8: Reducers and action creators aren't a one-to-one mapping</source>
          <target state="translated">Reduxible #8:Редукторы и создатели экшена-это не карта один к одному.</target>
        </trans-unit>
        <trans-unit id="1ccd2c30250c1777fda07e84c391cdb978d5d1e8" translate="yes" xml:space="preserve">
          <source>Refactoring Reducer Logic Using Functional Decomposition and Reducer Composition</source>
          <target state="translated">Логика рефакторинга редуктора с использованием функционального разложения и состава редуктора</target>
        </trans-unit>
        <trans-unit id="7b4c884acfadf4ccd7e8f7f80505e0cb44517215" translate="yes" xml:space="preserve">
          <source>Refactoring Reducers Example</source>
          <target state="translated">Рефакторинг редукторов Пример</target>
        </trans-unit>
        <trans-unit id="e0710cd8e6f7d93aaa10c5bd0b7c50d5a6a0ac74" translate="yes" xml:space="preserve">
          <source>Referring to items by IDs</source>
          <target state="translated">Ссылка на пункты по идентификаторам</target>
        </trans-unit>
        <trans-unit id="35a045863630981b0a8f647ab7457dcd879ee624" translate="yes" xml:space="preserve">
          <source>Regardless of the specific data type, the shape of the undo history state is the same:</source>
          <target state="translated">Независимо от конкретного типа данных,форма состояния истории отмены одинакова:</target>
        </trans-unit>
        <trans-unit id="c899eec73f6b556d4b90d92d6ad1d39154a4b74c" translate="yes" xml:space="preserve">
          <source>Registers listeners via &lt;a href=&quot;../api/store#subscribe&quot;&gt;&lt;code&gt;subscribe(listener)&lt;/code&gt;&lt;/a&gt;;</source>
          <target state="translated">Регистрирует слушателей через &lt;a href=&quot;../api/store#subscribe&quot;&gt; &lt;code&gt;subscribe(listener)&lt;/code&gt; &lt;/a&gt; ;</target>
        </trans-unit>
        <trans-unit id="07072abd45ba7236bb3989cbd897b07eeac1c93b" translate="yes" xml:space="preserve">
          <source>Relationships and Tables</source>
          <target state="translated">Отношения и таблицы</target>
        </trans-unit>
        <trans-unit id="f9da905dbbbb2d63041deb7197b587a590301a7b" translate="yes" xml:space="preserve">
          <source>Remember how we &lt;a href=&quot;reducers&quot;&gt;designed the shape of the root state object&lt;/a&gt;? It's time we design the UI hierarchy to match it. This is not a Redux-specific task. &lt;a href=&quot;https://facebook.github.io/react/docs/thinking-in-react.html&quot;&gt;Thinking in React&lt;/a&gt; is a great tutorial that explains the process.</source>
          <target state="translated">Помните, как мы &lt;a href=&quot;reducers&quot;&gt;проектировали форму объекта корневого состояния&lt;/a&gt; ? Пришло время разработать иерархию пользовательского интерфейса в соответствии с ней. Это не специфическая задача Redux. &lt;a href=&quot;https://facebook.github.io/react/docs/thinking-in-react.html&quot;&gt;Thinking in React&lt;/a&gt; - отличный учебник, который объясняет этот процесс.</target>
        </trans-unit>
        <trans-unit id="956f2f6dcc69fefbba147a07801daf0bec3cb1a6" translate="yes" xml:space="preserve">
          <source>Remember that reducers are just functions, so you can use functional composition and higher-order functions as much as you feel comfortable.</source>
          <target state="translated">Помните,что редукторы-это всего лишь функции,поэтому вы можете использовать функциональный состав и функции более высокого порядка так,как вам удобно.</target>
        </trans-unit>
        <trans-unit id="186767200c580a2653e26a568dd78d79172ed4ba" translate="yes" xml:space="preserve">
          <source>Remember, to change an immutable object, you must mutate a &lt;em&gt;copy&lt;/em&gt; of it, and copying large objects can be slow as every property must be copied.</source>
          <target state="translated">Помните, чтобы изменить неизменяемый объект, вы должны изменить его &lt;em&gt;копию&lt;/em&gt; , а копирование больших объектов может быть медленным, так как каждое свойство должно быть скопировано.</target>
        </trans-unit>
        <trans-unit id="d14133871ccbb6d27982d438fb7486a531414b6e" translate="yes" xml:space="preserve">
          <source>Remove the &lt;em&gt;first&lt;/em&gt; element from the &lt;code&gt;future&lt;/code&gt;.</source>
          <target state="translated">Удалите &lt;em&gt;первый&lt;/em&gt; элемент из &lt;code&gt;future&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8db23b2ef380238e2a9332bbe7bb7805acafcd6f" translate="yes" xml:space="preserve">
          <source>Remove the &lt;em&gt;last&lt;/em&gt; element from the &lt;code&gt;past&lt;/code&gt;.</source>
          <target state="translated">Удалите &lt;em&gt;последний&lt;/em&gt; элемент из &lt;code&gt;past&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d6bae9950e29a13f58e366e00739630628accfbd" translate="yes" xml:space="preserve">
          <source>Replaces the reducer currently used by the store to calculate the state.</source>
          <target state="translated">Заменяет редуктор,используемый в настоящее время магазином для расчета состояния.</target>
        </trans-unit>
        <trans-unit id="e267d53c29587c8cde50b829af85bdaecdc01bb5" translate="yes" xml:space="preserve">
          <source>Reselect #47: Memoizing Hierarchical Selectors</source>
          <target state="translated">Повторный выбор #47:Запомнить иерархические селекторы</target>
        </trans-unit>
        <trans-unit id="d0e0bcc2864b7d77b721a68ce1600fd8bd2214df" translate="yes" xml:space="preserve">
          <source>Reselect Documentation: How do I use Reselect with Immutable.js?</source>
          <target state="translated">Переизбрать документацию:Как использовать функцию переизбрания с Immutable.js?</target>
        </trans-unit>
        <trans-unit id="c338cf732b237c24b1f0506400e28357d0f15bd3" translate="yes" xml:space="preserve">
          <source>Reselect provides a function &lt;code&gt;createSelector&lt;/code&gt; for creating memoized selectors. &lt;code&gt;createSelector&lt;/code&gt; takes an array of input-selectors and a transform function as its arguments. If the Redux state tree is mutated in a way that causes the value of an input-selector to change, the selector will call its transform function with the values of the input-selectors as arguments and return the result. If the values of the input-selectors are the same as the previous call to the selector, it will return the previously computed value instead of calling the transform function.</source>
          <target state="translated">Reselect предоставляет функцию &lt;code&gt;createSelector&lt;/code&gt; для создания мемоизированных селекторов. &lt;code&gt;createSelector&lt;/code&gt; принимает в качестве аргументов массив селекторов ввода и функцию преобразования. Если дерево состояний Redux изменено таким образом, что вызывает изменение значения селектора ввода, селектор вызовет свою функцию преобразования со значениями селекторов ввода в качестве аргументов и вернет результат. Если значения селекторов ввода такие же, как и при предыдущем вызове селектора, он вернет ранее вычисленное значение вместо вызова функции преобразования.</target>
        </trans-unit>
        <trans-unit id="9c51b3f2e5f8258e6431cab2fcee20d079a2248f" translate="yes" xml:space="preserve">
          <source>Reselect: Selector library for Redux</source>
          <target state="translated">Переизбирай:Библиотека выбора для Redux</target>
        </trans-unit>
        <trans-unit id="9582a02f141fc4b345b2936eba691cd0654efebc" translate="yes" xml:space="preserve">
          <source>Returns</source>
          <target state="translated">Returns</target>
        </trans-unit>
        <trans-unit id="9845b29c661b5f09755c1a2c1a4a6d8ac8f795eb" translate="yes" xml:space="preserve">
          <source>Returns the current state tree of your application.</source>
          <target state="translated">Возвращает дерево текущего состояния вашего приложения.</target>
        </trans-unit>
        <trans-unit id="c935f384c6e4b3d5772f231b8837bf4689621ec3" translate="yes" xml:space="preserve">
          <source>Returns the current state tree of your application. It is equal to the last value returned by the store's reducer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be483740a1e90670b770a1abe4ce081d261c0d0a" translate="yes" xml:space="preserve">
          <source>Returns&lt;a href=&quot;#returns-2&quot;&gt;#&lt;/a&gt;</source>
          <target state="translated">Returns&lt;a href=&quot;#returns-2&quot;&gt;#&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b78505f9e7ca9beb942dcc8131c9189c9eeb998a" translate="yes" xml:space="preserve">
          <source>Reusing Reducer Logic</source>
          <target state="translated">Логика повторного использования редуктора</target>
        </trans-unit>
        <trans-unit id="0966cd2fd5d2cb35f03ce6b1bce5d1e7251e6744" translate="yes" xml:space="preserve">
          <source>Rich API</source>
          <target state="translated">богатый API</target>
        </trans-unit>
        <trans-unit id="a245bc64c38d63184404dacd3bd9f275e513df5f" translate="yes" xml:space="preserve">
          <source>Right now we are not passing anything to &lt;code&gt;&amp;lt;App /&amp;gt;&lt;/code&gt; so &lt;code&gt;ownProps&lt;/code&gt; is an empty object. To filter our todos according to the URL, we want to pass the URL params to &lt;code&gt;&amp;lt;VisibleTodoList /&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Прямо сейчас мы ничего не передаем в &lt;code&gt;&amp;lt;App /&amp;gt;&lt;/code&gt; , поэтому &lt;code&gt;ownProps&lt;/code&gt; - пустой объект. Чтобы отфильтровать наши задачи по URL-адресу, мы хотим передать параметры URL-адреса в &lt;code&gt;&amp;lt;VisibleTodoList /&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7d15dd1bec2e055c5b177c9f869305ae6c54c9bb" translate="yes" xml:space="preserve">
          <source>Routing</source>
          <target state="translated">Routing</target>
        </trans-unit>
        <trans-unit id="c9f8b56b323ff1d67c59f2e6a12b4f9fd24bb536" translate="yes" xml:space="preserve">
          <source>Rules For Structuring (Redux) Applications</source>
          <target state="translated">Правила для структурирования (Redux)приложений</target>
        </trans-unit>
        <trans-unit id="432cd1e0e18bce42cdef21bc0e2bf47d9952aaae" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/reactjs/redux/tree/master/examples/async&quot;&gt;Async&lt;/a&gt; example:</source>
          <target state="translated">Запустите пример &lt;a href=&quot;https://github.com/reactjs/redux/tree/master/examples/async&quot;&gt;Async&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="c8f9990ca1ff84f660e4614ac28b5a1202d83be9" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/reactjs/redux/tree/master/examples/counter&quot;&gt;Counter&lt;/a&gt; example:</source>
          <target state="translated">Запустите пример &lt;a href=&quot;https://github.com/reactjs/redux/tree/master/examples/counter&quot;&gt;счетчика&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="02bc6e8d90233a64557847335ed8fd0a2138380c" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/reactjs/redux/tree/master/examples/counter-vanilla&quot;&gt;Counter Vanilla&lt;/a&gt; example:</source>
          <target state="translated">Запустите пример &lt;a href=&quot;https://github.com/reactjs/redux/tree/master/examples/counter-vanilla&quot;&gt;Counter Vanilla&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="ff2baf0af3858008f9b05583c2312fb090bd1e5d" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/reactjs/redux/tree/master/examples/real-world&quot;&gt;Real World&lt;/a&gt; example:</source>
          <target state="translated">Запустите пример из &lt;a href=&quot;https://github.com/reactjs/redux/tree/master/examples/real-world&quot;&gt;реального мира&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="a0e8812bdf4fabf867445d42be0aa6d8b7c05486" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/reactjs/redux/tree/master/examples/shopping-cart&quot;&gt;Shopping Cart&lt;/a&gt; example:</source>
          <target state="translated">Запустите пример &lt;a href=&quot;https://github.com/reactjs/redux/tree/master/examples/shopping-cart&quot;&gt;корзины покупок&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="d299f4e9292980bd1533a8b98ddf4a548b317e3d" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/reactjs/redux/tree/master/examples/todomvc&quot;&gt;TodoMVC&lt;/a&gt; example:</source>
          <target state="translated">Запустите пример &lt;a href=&quot;https://github.com/reactjs/redux/tree/master/examples/todomvc&quot;&gt;TodoMVC&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="0a20317121271e18a234a5efdad9fa25e4ae9ccb" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/reactjs/redux/tree/master/examples/todos&quot;&gt;Todos&lt;/a&gt; example:</source>
          <target state="translated">Запустите пример &lt;a href=&quot;https://github.com/reactjs/redux/tree/master/examples/todos&quot;&gt;Todos&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="abfea29e9c7baf9015d33caddf86571e5480eee7" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/reactjs/redux/tree/master/examples/todos-with-undo&quot;&gt;Todos with Undo&lt;/a&gt; example:</source>
          <target state="translated">Запустите &lt;a href=&quot;https://github.com/reactjs/redux/tree/master/examples/todos-with-undo&quot;&gt;Todos с&lt;/a&gt; примером отмены :</target>
        </trans-unit>
        <trans-unit id="3419ab9b88258855aae8167ab6392ff99bc35318" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/reactjs/redux/tree/master/examples/tree-view&quot;&gt;Tree View&lt;/a&gt; example:</source>
          <target state="translated">Запустите пример &lt;a href=&quot;https://github.com/reactjs/redux/tree/master/examples/tree-view&quot;&gt;Tree View&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="eaf774d91e164852adb76afadeea254ddd1b6e1d" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/reactjs/redux/tree/master/examples/universal&quot;&gt;Universal&lt;/a&gt; example:</source>
          <target state="translated">Запустите &lt;a href=&quot;https://github.com/reactjs/redux/tree/master/examples/universal&quot;&gt;универсальный&lt;/a&gt; пример:</target>
        </trans-unit>
        <trans-unit id="297ff09ad1fee6372badff1acb02a01184e1b455" translate="yes" xml:space="preserve">
          <source>RxJS</source>
          <target state="translated">RxJS</target>
        </trans-unit>
        <trans-unit id="f5c8e7496f807cd64744816fba01dc672fea8b3c" translate="yes" xml:space="preserve">
          <source>Sandrino Di Mattia</source>
          <target state="translated">Сандрино Ди Маттиа</target>
        </trans-unit>
        <trans-unit id="06c1e2b042f09a95936f43d636e7a9cfe06fa2c4" translate="yes" xml:space="preserve">
          <source>Say, you call this when creating a todo:</source>
          <target state="translated">Скажем,ты называешь это,когда создаешь тодо:</target>
        </trans-unit>
        <trans-unit id="e86aae6b5aebceaa76af1cce53d3199d645e9dcb" translate="yes" xml:space="preserve">
          <source>Screencasts</source>
          <target state="translated">Screencasts</target>
        </trans-unit>
        <trans-unit id="abf418e07a2bb8523e609c6622f0ee30e20593e9" translate="yes" xml:space="preserve">
          <source>Second Attempt: Writing a Reducer Enhancer</source>
          <target state="translated">Вторая попытка:Написать улучшенный редуктор</target>
        </trans-unit>
        <trans-unit id="325c723ca2b67b9b7f5ba09ec5687e02ae1b0279" translate="yes" xml:space="preserve">
          <source>Secure Your React and Redux App with JWT Authentication</source>
          <target state="translated">Защитите свое приложение React and Redux с помощью JWT-аутентификации.</target>
        </trans-unit>
        <trans-unit id="402cc3b6686cd294cb10dd3f5bccbebd0edd8a9b" translate="yes" xml:space="preserve">
          <source>Security Considerations</source>
          <target state="translated">Соображения безопасности</target>
        </trans-unit>
        <trans-unit id="919870200d649a13066b3447ce0f0c25022cc8f6" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;api/applymiddleware&quot;&gt;&lt;code&gt;applyMiddleware(...middlewares)&lt;/code&gt;&lt;/a&gt; for a detailed look at middleware.</source>
          <target state="translated">См. &lt;a href=&quot;api/applymiddleware&quot;&gt; &lt;code&gt;applyMiddleware(...middlewares)&lt;/code&gt; &lt;/a&gt; для подробного ознакомления с промежуточным ПО.</target>
        </trans-unit>
        <trans-unit id="94f2d6b880adb72fb73adf9d3a1c8276271ee55a" translate="yes" xml:space="preserve">
          <source>See also &lt;a href=&quot;#async-action&quot;&gt;async action&lt;/a&gt; below.</source>
          <target state="translated">См. Также &lt;a href=&quot;#async-action&quot;&gt;асинхронное действие&lt;/a&gt; ниже.</target>
        </trans-unit>
        <trans-unit id="22ce2ecd3395a41aaf7f8cf591c10dd2e971bbd0" translate="yes" xml:space="preserve">
          <source>See the complete &lt;a href=&quot;api/store#dispatch&quot;&gt;store API reference&lt;/a&gt; for more details.</source>
          <target state="translated">Подробную информацию см. В полной &lt;a href=&quot;api/store#dispatch&quot;&gt;справке&lt;/a&gt; по API магазина .</target>
        </trans-unit>
        <trans-unit id="1664d8a03fa57f4c8be0067b9d13327134f1e58a" translate="yes" xml:space="preserve">
          <source>Separating Data Handling by Domain</source>
          <target state="translated">Разделение обработки данных по доменам</target>
        </trans-unit>
        <trans-unit id="4ff6540c25bde7085cf0d2d1e9575cb74d3e0915" translate="yes" xml:space="preserve">
          <source>Server Rendering</source>
          <target state="translated">Рендеринг сервера</target>
        </trans-unit>
        <trans-unit id="25c47193088be9016d58e256803985285406a208" translate="yes" xml:space="preserve">
          <source>Set the &lt;code&gt;present&lt;/code&gt; to the element we removed in the previous step.</source>
          <target state="translated">Установите &lt;code&gt;present&lt;/code&gt; на элемент, который мы удалили на предыдущем шаге.</target>
        </trans-unit>
        <trans-unit id="d0b36286cd9781f93bd06e4cc2ba9bd4a1ae46eb" translate="yes" xml:space="preserve">
          <source>Set the &lt;code&gt;present&lt;/code&gt; to the new state after handling the action.</source>
          <target state="translated">Установите для &lt;code&gt;present&lt;/code&gt; новое состояние после обработки действия.</target>
        </trans-unit>
        <trans-unit id="d60b0890a431be3750d67b0f7fe70b5f3af16d7e" translate="yes" xml:space="preserve">
          <source>Setting Up</source>
          <target state="translated">Настройка</target>
        </trans-unit>
        <trans-unit id="6ef3f0bd0914407afe72f32d7220011189833964" translate="yes" xml:space="preserve">
          <source>Seven Examples</source>
          <target state="translated">Семь примеров</target>
        </trans-unit>
        <trans-unit id="bceef6abe99285193523d99d3503c8cbe59abd17" translate="yes" xml:space="preserve">
          <source>Shallow equality checking (or &lt;em&gt;reference equality&lt;/em&gt;) simply checks that two different &lt;em&gt;variables&lt;/em&gt; reference the same object; in contrast, deep equality checking (or &lt;em&gt;value equality&lt;/em&gt;) must check every &lt;em&gt;value&lt;/em&gt; of two objects' properties.</source>
          <target state="translated">Неглубокая проверка равенства (или &lt;em&gt;ссылочного равенства&lt;/em&gt; ) просто проверяет, ссылаются ли две разные &lt;em&gt;переменные&lt;/em&gt; на один и тот же объект; напротив, глубокая проверка равенства (или &lt;em&gt;равенство значений&lt;/em&gt; ) должна проверять каждое &lt;em&gt;значение&lt;/em&gt; свойств двух объектов.</target>
        </trans-unit>
        <trans-unit id="c1af20867da7a30bee30fa39bc87d4d6bf5086c5" translate="yes" xml:space="preserve">
          <source>Shallow equality checking cannot be used to detect if a function mutates an object passed into it if that object is mutable.</source>
          <target state="translated">Незначительная проверка равенства не может быть использована для определения,мутирует ли функция переданный в нее объект,если этот объект является мутируемым.</target>
        </trans-unit>
        <trans-unit id="9a3368201d828a558753e74bfb641b78ef4ebe17" translate="yes" xml:space="preserve">
          <source>Shallow equality checking with a mutable object will not cause problems with Redux, but &lt;a href=&quot;#shallow-checking-problems-with-react-redux&quot;&gt;it will cause problems with libraries that depend on the store, such as React-Redux&lt;/a&gt;.</source>
          <target state="translated">Неглубокая проверка равенства с помощью изменяемого объекта не вызовет проблем с Redux, но &lt;a href=&quot;#shallow-checking-problems-with-react-redux&quot;&gt;вызовет проблемы с библиотеками, которые зависят от хранилища, такими как React-Redux&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="54774f0c2c7e8f191039f8359b7b19ab53fad9f2" translate="yes" xml:space="preserve">
          <source>Sharing Selectors Across Multiple Components</source>
          <target state="translated">Совместное использование селекторов по нескольким компонентам</target>
        </trans-unit>
        <trans-unit id="192f8cbb6f5871d94ba5fb03d97db29c7de825cd" translate="yes" xml:space="preserve">
          <source>Sharing State Between Redux Reducers</source>
          <target state="translated">Разделение государства между редукторами &quot;Редукс</target>
        </trans-unit>
        <trans-unit id="b89a118c798fa4a35e3c16cccb58dae4801140ac" translate="yes" xml:space="preserve">
          <source>Sharing data between slice reducers</source>
          <target state="translated">Обмен данными между редукторами срезов</target>
        </trans-unit>
        <trans-unit id="90d67309aeeeaf7718677d90e2400596d8e164bd" translate="yes" xml:space="preserve">
          <source>Shopping Cart</source>
          <target state="translated">Корзина</target>
        </trans-unit>
        <trans-unit id="36fe368c9da0c4844911eb85a837f68dcae6c653" translate="yes" xml:space="preserve">
          <source>Should I dispatch multiple actions in a row from one action creator?</source>
          <target state="translated">Должен ли я посылать несколько действий подряд от одного создателя действия?</target>
        </trans-unit>
        <trans-unit id="e5b09d329a9d354e9f3fa021df3644b2917c4096" translate="yes" xml:space="preserve">
          <source>Should I only connect my top component, or can I connect multiple components in my tree?</source>
          <target state="translated">Следует ли подключать только верхний компонент,или можно подключить несколько компонентов в дереве?</target>
        </trans-unit>
        <trans-unit id="1737c8bf68fcf64ccfaf2774ab797e55426baaa7" translate="yes" xml:space="preserve">
          <source>Should be &quot;pure&quot;, which means the reducer:</source>
          <target state="translated">Должен быть &quot;чистым&quot;,что означает редуктор:</target>
        </trans-unit>
        <trans-unit id="e9fdc92b96e07741038b0992e2225ba1bf7f6560" translate="yes" xml:space="preserve">
          <source>Should have a signature of &lt;code&gt;(previousState, action) =&amp;gt; newState&lt;/code&gt;, similar to the type of function you would pass to &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce&quot;&gt;&lt;code&gt;Array.prototype.reduce(reducer, ?initialValue)&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Должен иметь сигнатуру &lt;code&gt;(previousState, action) =&amp;gt; newState&lt;/code&gt; , аналогично типу функции, которую вы &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce&quot;&gt; &lt;code&gt;Array.prototype.reduce(reducer, ?initialValue)&lt;/code&gt; &lt;/a&gt; бы в Array.prototype.reduce (reducer,? InitialValue)</target>
        </trans-unit>
        <trans-unit id="f9b9f5929894997ad56cc3c83383ff218a8e4e68" translate="yes" xml:space="preserve">
          <source>Side effects</source>
          <target state="translated">Побочные эффекты</target>
        </trans-unit>
        <trans-unit id="2bdc602c5e4f77691c4cf05236ccbfb9a3a7d6cd" translate="yes" xml:space="preserve">
          <source>Similarly, Dan Abramov, one of the creators of Redux, says:</source>
          <target state="translated">Точно так же говорит Дэн Абрамов,один из создателей &quot;Редукса&quot;:</target>
        </trans-unit>
        <trans-unit id="a8d94bc8e96596ebe8e2c196ec3465a016861842" translate="yes" xml:space="preserve">
          <source>Similarly, if &lt;code&gt;sliceReducerA&lt;/code&gt; happens to need some data from &lt;code&gt;sliceReducerB&lt;/code&gt;'s slice of state in order to handle a particular action, or &lt;code&gt;sliceReducerB&lt;/code&gt; happens to need the entire state as an argument, &lt;code&gt;combineReducers&lt;/code&gt; does not handle that itself. This could be resolved by writing a custom function that knows to pass the needed data as an additional argument in those specific cases, such as:</source>
          <target state="translated">Точно так же, если &lt;code&gt;sliceReducerA&lt;/code&gt; потребуются некоторые данные из фрагмента состояния &lt;code&gt;sliceReducerB&lt;/code&gt; для обработки определенного действия, или &lt;code&gt;sliceReducerB&lt;/code&gt; требуется все состояние в качестве аргумента, &lt;code&gt;combineReducers&lt;/code&gt; не обрабатывает их самостоятельно. Эту проблему можно решить, написав настраиваемую функцию, которая знает, как передавать необходимые данные в качестве дополнительного аргумента в этих конкретных случаях, например:</target>
        </trans-unit>
        <trans-unit id="442aad2b9dae61af274e1b5ffcce14c8db98f18c" translate="yes" xml:space="preserve">
          <source>Similarly, while you &lt;em&gt;can&lt;/em&gt; reference your store instance by importing it directly, this is not a recommended pattern in Redux. If you create a store instance and export it from a module, it will become a singleton. This means it will be harder to isolate a Redux app as a component of a larger app, if this is ever necessary, or to enable server rendering, because on the server you want to create separate store instances for every request.</source>
          <target state="translated">Точно так же, хотя вы &lt;em&gt;можете&lt;/em&gt; ссылаться на свой экземпляр магазина, импортировав его напрямую, это не рекомендуемый шаблон в Redux. Если вы создадите экземпляр магазина и экспортируете его из модуля, он станет синглтоном. Это означает, что будет сложнее изолировать приложение Redux как компонент более крупного приложения, если это когда-либо понадобится, или включить серверный рендеринг, потому что на сервере вы хотите создавать отдельные экземпляры хранилища для каждого запроса.</target>
        </trans-unit>
        <trans-unit id="4f6c75f4d537fefd2d55e1099d473ae02742b468" translate="yes" xml:space="preserve">
          <source>Similarly, you can compose different asynchronous streams to turn them into actions before feeding them to &lt;code&gt;store.dispatch()&lt;/code&gt;.</source>
          <target state="translated">Точно так же вы можете составлять разные асинхронные потоки, чтобы превратить их в действия, прежде чем &lt;code&gt;store.dispatch()&lt;/code&gt; их в store.dispatch () .</target>
        </trans-unit>
        <trans-unit id="0b1172b53a0feb7a9bb295b5a660a2ffbcb58fc3" translate="yes" xml:space="preserve">
          <source>Simple Merging</source>
          <target state="translated">Простое слияние</target>
        </trans-unit>
        <trans-unit id="2070eaef74ea9323409e358647e9ae6ca53c37cd" translate="yes" xml:space="preserve">
          <source>Since &lt;code&gt;combineReducers&lt;/code&gt; currently only works with plain Javascript objects, an application that uses an Immutable.js Map object for the top of its state tree could not use &lt;code&gt;combineReducers&lt;/code&gt; to manage that Map. Since many developers do use Immutable.js, there are a number of published utilities that provide equivalent functionality, such as &lt;a href=&quot;https://github.com/gajus/redux-immutable&quot;&gt;redux-immutable&lt;/a&gt;. This package provides its own implementation of &lt;code&gt;combineReducers&lt;/code&gt; that knows how to iterate over an Immutable Map instead of a plain Javascript object.</source>
          <target state="translated">Поскольку в настоящее время &lt;code&gt;combineReducers&lt;/code&gt; работает только с простыми объектами Javascript, приложение, использующее объект карты &lt;code&gt;combineReducers&lt;/code&gt; в верхней части своего дерева состояний, не может использовать combReducers для управления этой картой. Поскольку многие разработчики действительно используют Immutable.js, существует ряд опубликованных утилит, которые обеспечивают эквивалентную функциональность, например, &lt;a href=&quot;https://github.com/gajus/redux-immutable&quot;&gt;redux-immutable&lt;/a&gt; . Этот пакет предоставляет свою собственную реализацию &lt;code&gt;combineReducers&lt;/code&gt; которая знает, как перебирать неизменяемую карту вместо простого объекта Javascript.</target>
        </trans-unit>
        <trans-unit id="81feae1ade917069a12cf9aa7539b91da9719215" translate="yes" xml:space="preserve">
          <source>Since Redux is just a data store library, it has no direct opinion on how your project should be structured. However, there are a few common patterns that most Redux developers tend to use:</source>
          <target state="translated">Так как Redux-это всего лишь библиотека хранилища данных,у него нет прямого мнения о том,как должен быть структурирован ваш проект.Тем не менее,есть несколько общих шаблонов,которые большинство разработчиков Redux склонны использовать:</target>
        </trans-unit>
        <trans-unit id="ec6d8987b40f3810e89420d79f0a03ad196ea3a0" translate="yes" xml:space="preserve">
          <source>Since a Redux reducer is &lt;em&gt;just&lt;/em&gt; a function, the same concept applies. You can split some of your reducer logic out into another function, and call that new function from the parent function.</source>
          <target state="translated">Поскольку редуктор Redux - это &lt;em&gt;просто&lt;/em&gt; функция, применяется та же концепция. Вы можете разделить часть своей логики редуктора на другую функцию и вызвать эту новую функцию из родительской функции.</target>
        </trans-unit>
        <trans-unit id="c7004cb2a5422c7e3364434a15f16aaad43e92c0" translate="yes" xml:space="preserve">
          <source>Since each data type is separated, an update like changing the text of a comment would only require new copies of the &quot;comments &amp;gt; byId &amp;gt; comment&quot; portion of the tree. This will generally mean fewer portions of the UI that need to update because their data has changed. In contrast, updating a comment in the original nested shape would have required updating the comment object, the parent post object, the array of all post objects, and likely have caused &lt;em&gt;all&lt;/em&gt; of the Post components and Comment components in the UI to re-render themselves.</source>
          <target state="translated">Поскольку каждый тип данных разделен, обновление, такое как изменение текста комментария, потребует только новых копий части дерева &amp;laquo;comments&amp;gt; byId&amp;gt; comment&amp;raquo;. Обычно это означает меньшее количество частей пользовательского интерфейса, которые необходимо обновить, поскольку их данные изменились. Напротив, обновление комментария в исходной вложенной форме потребовало бы обновления объекта комментария, родительского объекта сообщения, массива всех объектов сообщения и, вероятно, привело &lt;em&gt;бы&lt;/em&gt; к повторной визуализации &lt;em&gt;всех&lt;/em&gt; компонентов сообщения и компонентов комментария в пользовательском интерфейсе. самих себя.</target>
        </trans-unit>
        <trans-unit id="3378207602b38cf49f27093860fe75762bdd12fe" translate="yes" xml:space="preserve">
          <source>Since immutable data updates require all ancestors in the state tree to be copied and updated as well, and new object references will cause connected UI components to re-render, an update to a deeply nested data object could force totally unrelated UI components to re-render even if the data they're displaying hasn't actually changed.</source>
          <target state="translated">Поскольку непреложные обновления данных требуют копирования и обновления всех предков в дереве состояний,а новые ссылки на объекты приведут к переотправке подключенных компонентов пользовательского интерфейса,обновление глубоко вложенного объекта данных может заставить полностью не подключенные компоненты пользовательского интерфейса переотправки,даже если отображаемые ими данные на самом деле не изменились.</target>
        </trans-unit>
        <trans-unit id="bc174df1294758024d3aa9d37156a3b1ea508c4a" translate="yes" xml:space="preserve">
          <source>Since one of the core tenets of Redux is to never mutate state, you'll often find yourself using &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/assign&quot;&gt;&lt;code&gt;Object.assign()&lt;/code&gt;&lt;/a&gt; to create copies of objects with new or updated values. For example, in the &lt;code&gt;todoApp&lt;/code&gt; below &lt;code&gt;Object.assign()&lt;/code&gt; is used to return a new &lt;code&gt;state&lt;/code&gt; object with an updated &lt;code&gt;visibilityFilter&lt;/code&gt; property:</source>
          <target state="translated">Поскольку один из основных принципов Redux - никогда не изменять состояние, вы часто будете использовать &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/assign&quot;&gt; &lt;code&gt;Object.assign()&lt;/code&gt; &lt;/a&gt; для создания копий объектов с новыми или обновленными значениями. Например, в &lt;code&gt;todoApp&lt;/code&gt; ниже &lt;code&gt;Object.assign()&lt;/code&gt; используется для возврата нового объекта &lt;code&gt;state&lt;/code&gt; с обновленным свойством &lt;code&gt;visibilityFilter&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="751750d4cb79c6a8466b2981d8a7c11a9b335b87" translate="yes" xml:space="preserve">
          <source>Since reducers are just functions, there's an infinite number of ways to split up this logic. While using slice reducers is obviously the most common, it's also possible to organize behavior in a more task-oriented structure. Because this will often involve more nested updates, you may want to use an immutable update utility library like &lt;a href=&quot;https://github.com/debitoor/dot-prop-immutable&quot;&gt;dot-prop-immutable&lt;/a&gt; or &lt;a href=&quot;https://github.com/mariocasciaro/object-path-immutable&quot;&gt;object-path-immutable&lt;/a&gt; to simplify the update statements. Here's an example of what that might look like:</source>
          <target state="translated">Поскольку редукторы - это просто функции, существует бесконечное количество способов разделить эту логику. Хотя использование редукторов слайсов, очевидно, является наиболее распространенным, также можно организовать поведение в более ориентированной на задачи структуре. Поскольку это часто связано с большим количеством вложенных обновлений, вы можете использовать неизменяемую служебную библиотеку обновления, такую ​​как &lt;a href=&quot;https://github.com/debitoor/dot-prop-immutable&quot;&gt;dot-prop-immutable&lt;/a&gt; или &lt;a href=&quot;https://github.com/mariocasciaro/object-path-immutable&quot;&gt;object-path-immutable,&lt;/a&gt; чтобы упростить операторы обновления. Вот пример того, как это может выглядеть:</target>
        </trans-unit>
        <trans-unit id="9524f9ed1b2581f0acc17e64cde44a8908d2e14e" translate="yes" xml:space="preserve">
          <source>Since the default export is still the decorated component, the import statement pictured above will work as before so you won't have to change your application code. However, you can now import the undecorated &lt;code&gt;App&lt;/code&gt; components in your test file like this:</source>
          <target state="translated">Поскольку экспорт по умолчанию по-прежнему является декорированным компонентом, оператор импорта, изображенный выше, будет работать, как и раньше, поэтому вам не придется изменять код приложения. Однако теперь вы можете импортировать недекорированные компоненты &lt;code&gt;App&lt;/code&gt; в свой тестовый файл следующим образом:</target>
        </trans-unit>
        <trans-unit id="1fb6dcac04c2641afe5f5ceba2752f16941c0489" translate="yes" xml:space="preserve">
          <source>Since the object spread syntax is still a &lt;a href=&quot;https://github.com/sebmarkbage/ecmascript-rest-spread#status-of-this-proposal&quot;&gt;Stage 3&lt;/a&gt; proposal for ECMAScript you'll need to use a transpiler such as &lt;a href=&quot;http://babeljs.io/&quot;&gt;Babel&lt;/a&gt; to use it in production. You can use your existing &lt;code&gt;es2015&lt;/code&gt; preset, install &lt;a href=&quot;http://babeljs.io/docs/plugins/transform-object-rest-spread/&quot;&gt;&lt;code&gt;babel-plugin-transform-object-rest-spread&lt;/code&gt;&lt;/a&gt; and add it individually to the &lt;code&gt;plugins&lt;/code&gt; array in your &lt;code&gt;.babelrc&lt;/code&gt;.</source>
          <target state="translated">Поскольку синтаксис объекта распространение еще &lt;a href=&quot;https://github.com/sebmarkbage/ecmascript-rest-spread#status-of-this-proposal&quot;&gt;Этап 3&lt;/a&gt; Предложение для ECMAScript вам нужно использовать transpiler такой , как &lt;a href=&quot;http://babeljs.io/&quot;&gt;Бабель&lt;/a&gt; , чтобы использовать его в производстве. Вы можете использовать существующий пресет &lt;code&gt;es2015&lt;/code&gt; , установить &lt;a href=&quot;http://babeljs.io/docs/plugins/transform-object-rest-spread/&quot;&gt; &lt;code&gt;babel-plugin-transform-object-rest-spread&lt;/code&gt; &lt;/a&gt; и добавить его индивидуально в массив &lt;code&gt;plugins&lt;/code&gt; в вашем &lt;code&gt;.babelrc&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8ca51516913ff8c686b4181a9850b407d585f33e" translate="yes" xml:space="preserve">
          <source>Single Simple Reducer</source>
          <target state="translated">Единый простой редуктор</target>
        </trans-unit>
        <trans-unit id="c3607f5a3395346db279c8631885ad76c32cdec0" translate="yes" xml:space="preserve">
          <source>Single source of truth</source>
          <target state="translated">Единственный источник правды</target>
        </trans-unit>
        <trans-unit id="3d0ddd2467b9b23c1a85abd5a68ac4b84b509998" translate="yes" xml:space="preserve">
          <source>Slice Reducer Composition</source>
          <target state="translated">Композиция редуктора слайса</target>
        </trans-unit>
        <trans-unit id="6f8966ee06a6a598a66e68a6f2128780e130ca9a" translate="yes" xml:space="preserve">
          <source>Small utility functions containing some reusable chunk of logic that is needed in multiple places (which may or may not be actually related to the specific business logic)</source>
          <target state="translated">Небольшие утилитные функции,содержащие некоторый многократно используемый фрагмент логики,который необходим в нескольких местах (которые на самом деле могут быть или не быть связаны с конкретной бизнес-логикой)</target>
        </trans-unit>
        <trans-unit id="712ac3fdb33cc95ff1f79708b05bdbf85fc873a3" translate="yes" xml:space="preserve">
          <source>Smart and Dumb Components in React</source>
          <target state="translated">Умные и немые компоненты в реакции</target>
        </trans-unit>
        <trans-unit id="dd67eec5e031f2788f993ce1a20a1c919e9f1589" translate="yes" xml:space="preserve">
          <source>Smart components that access the store via React Redux&amp;rsquo;s &lt;code&gt;connect&lt;/code&gt; function must use the Immutable.JS values returned by your selectors. Make sure you avoid the potential issues this can cause with unnecessary component re-rendering. Memoize your selectors using a library such as reselect if necessary.</source>
          <target state="translated">Умные компоненты, которые обращаются к хранилищу через функцию &lt;code&gt;connect&lt;/code&gt; React Redux, должны использовать значения Immutable.JS, возвращаемые вашими селекторами. Убедитесь, что вы избегаете потенциальных проблем, которые могут возникнуть из-за ненужного повторного рендеринга компонентов. Запомните свои селекторы, используя библиотеку, например, при необходимости повторно выберите.</target>
        </trans-unit>
        <trans-unit id="0fa28ccaea98dae4e7adc0d2f21a6688416f5c11" translate="yes" xml:space="preserve">
          <source>So far we have only seen selectors receive the Redux store state as an argument, but a selector can receive props too.</source>
          <target state="translated">До сих пор мы видели только то,что селекторы получают состояние магазина Redux в качестве аргумента,но селектор может получать и реквизит.</target>
        </trans-unit>
        <trans-unit id="7c7e37241e1ba9e69dbbe9b4a4d92f9d4db7b97e" translate="yes" xml:space="preserve">
          <source>So now &lt;code&gt;getVisibleTodos&lt;/code&gt; has access to &lt;code&gt;props&lt;/code&gt;, and everything seems to be working fine.</source>
          <target state="translated">Итак, теперь &lt;code&gt;getVisibleTodos&lt;/code&gt; имеет доступ к &lt;code&gt;props&lt;/code&gt; , и, похоже, все работает нормально.</target>
        </trans-unit>
        <trans-unit id="d7a8e420420cf895d7c454a61b1d5cb20007fa2a" translate="yes" xml:space="preserve">
          <source>So you want to do routing with your Redux app. You can use it with &lt;a href=&quot;https://github.com/reactjs/react-router&quot;&gt;React Router&lt;/a&gt;. Redux will be the source of truth for your data and React Router will be the source of truth for your URL. In most of the cases, &lt;strong&gt;it is fine&lt;/strong&gt; to have them separate unless you need to time travel and rewind actions that triggers the change URL.</source>
          <target state="translated">Итак, вы хотите выполнить маршрутизацию с помощью приложения Redux. Вы можете использовать его с &lt;a href=&quot;https://github.com/reactjs/react-router&quot;&gt;React Router&lt;/a&gt; . Redux будет источником правды для ваших данных, а React Router будет источником правды для вашего URL. В большинстве случаев, &lt;strong&gt;это нормально&lt;/strong&gt; , чтобы иметь их отдельно , если вам не нужно путешествие во время и перемотать действия, запускающее URL изменения.</target>
        </trans-unit>
        <trans-unit id="2fc8fe9a73edd4d111843f389431f4101d5d9c17" translate="yes" xml:space="preserve">
          <source>So, for example, if your state shape is &lt;code&gt;{ todos, counter }&lt;/code&gt;, the call to &lt;code&gt;combineReducers&lt;/code&gt; would be:</source>
          <target state="translated">Так, например, если ваша форма состояния - &lt;code&gt;{ todos, counter }&lt;/code&gt; , вызов &lt;code&gt;combineReducers&lt;/code&gt; будет таким:</target>
        </trans-unit>
        <trans-unit id="ccb9fbf6736643b0e42418e768268b9cd0d29f5f" translate="yes" xml:space="preserve">
          <source>So, what are you waiting for?</source>
          <target state="translated">Так чего ты ждешь?</target>
        </trans-unit>
        <trans-unit id="aaba548cf058bc58a2b9e6247d0f30696c87f137" translate="yes" xml:space="preserve">
          <source>Solving a performance issue caused by too frequent updates of some part of the state, when confirmed by profiling the app.</source>
          <target state="translated">Решение проблемы производительности,вызванной слишком частыми обновлениями некоторой части состояния,когда это подтверждается профилированием приложения.</target>
        </trans-unit>
        <trans-unit id="d49f0c1ce0f85599fd62bed378620cb762c1e648" translate="yes" xml:space="preserve">
          <source>Some Reasons Why Redux is Useful in a React App</source>
          <target state="translated">Некоторые причины,почему Redux полезен в реактивном приложении.</target>
        </trans-unit>
        <trans-unit id="67effe7198ec1da2c9351c8b657b35336537bffb" translate="yes" xml:space="preserve">
          <source>Some common rules of thumb for determining what kind of data should be put into Redux:</source>
          <target state="translated">Некоторые общие правила для определения того,какие данные должны быть помещены в Redux:</target>
        </trans-unit>
        <trans-unit id="fce335731003088c209cd9b37e95f6128c05deb1" translate="yes" xml:space="preserve">
          <source>Some frameworks like &lt;a href=&quot;https://github.com/acdlite/flummox&quot;&gt;Flummox&lt;/a&gt; generate action type constants automatically from the action creator function definitions. The idea is that you don't need to both define &lt;code&gt;ADD_TODO&lt;/code&gt; constant and &lt;code&gt;addTodo()&lt;/code&gt; action creator. Under the hood, such solutions still generate action type constants, but they're created implicitly so it's a level of indirection and can cause confusion. We recommend creating your action type constants explicitly.</source>
          <target state="translated">Некоторые фреймворки, такие как &lt;a href=&quot;https://github.com/acdlite/flummox&quot;&gt;Flummox, автоматически&lt;/a&gt; генерируют константы типов действий из определений функций создателей действий. Идея заключается в том , что вам не нужно как определить &lt;code&gt;ADD_TODO&lt;/code&gt; постоянной и &lt;code&gt;addTodo()&lt;/code&gt; действия создателя. Под капотом такие решения по-прежнему генерируют константы типа действия, но они создаются неявно, так что это косвенный уровень и может вызвать путаницу. Мы рекомендуем явно создавать константы типа действия.</target>
        </trans-unit>
        <trans-unit id="11a2735a6d7891b97c7769374cd7a4c5a0bb87e0" translate="yes" xml:space="preserve">
          <source>Some of these concepts are already described elsewhere in the Redux documentation. Others are generic and applicable outside of Redux itself, and there are numerous existing articles that cover these concepts in detail. These concepts and techniques form the foundation of writing solid Redux reducer logic.</source>
          <target state="translated">Некоторые из этих концепций уже описаны в других разделах документации Redux.Другие являются общими и применимы за пределами самого Redux,и существует множество существующих статей,которые подробно описывают эти понятия.Эти понятия и техники образуют основу для написания солидной редукционной логики Redux.</target>
        </trans-unit>
        <trans-unit id="f81aa5aa34cf8b3e24fa1aaf08e9c45c13b0947d" translate="yes" xml:space="preserve">
          <source>Some valid reasons for using multiple stores in Redux might include:</source>
          <target state="translated">Некоторые веские причины для использования нескольких магазинов в Redux могут включать в себя:</target>
        </trans-unit>
        <trans-unit id="a0393764cde3422b70bb25ef444a0fd2f0c54e31" translate="yes" xml:space="preserve">
          <source>Something else doesn't work</source>
          <target state="translated">Что-то другое не работает</target>
        </trans-unit>
        <trans-unit id="cb49415fd84ba99d743a94724fc704b532a5abb2" translate="yes" xml:space="preserve">
          <source>Something needs to map the Immutable.JS props in your Smart Component to the pure JavaScript props used in your Dumb Component. That something is a Higher Order Component (HOC) that simply takes the Immutable.JS props from your Smart Component, and converts them using &lt;code&gt;toJS()&lt;/code&gt; to plain JavaScript props, which are then passed to your Dumb Component.</source>
          <target state="translated">Что-то должно сопоставить свойства Immutable.JS в вашем интеллектуальном компоненте с чистыми реквизитами JavaScript, используемыми в вашем немом компоненте. Это что-то - компонент более высокого порядка (HOC), который просто берет реквизиты Immutable.JS из вашего смарт-компонента и преобразует их с помощью &lt;code&gt;toJS()&lt;/code&gt; в простые реквизиты JavaScript, которые затем передаются вашему немому компоненту.</target>
        </trans-unit>
        <trans-unit id="82c027e36202d6dbe2e05d86322f925c7f839e11" translate="yes" xml:space="preserve">
          <source>Sometimes it's hard to tell if some component should be a presentational component or a container. For example, sometimes form and function are really coupled together, such as in case of this tiny component:</source>
          <target state="translated">Иногда трудно сказать,должен ли какой-то компонент быть презентационным или контейнером.Например,иногда форма и функция действительно связаны друг с другом,как,например,в случае с этим крошечным компонентом:</target>
        </trans-unit>
        <trans-unit id="d627c00cc83e8506e9cca85f44caed1d800c8c74" translate="yes" xml:space="preserve">
          <source>Sometimes you want to see all existing actions before working on a new feature. It may be that the action you need was already added by somebody on the team, but you didn't know.</source>
          <target state="translated">Иногда перед началом работы над новой функцией необходимо просмотреть все существующие действия.Может оказаться,что нужное действие уже было добавлено кем-то из команды,но вы не знали.</target>
        </trans-unit>
        <trans-unit id="268852f5aa4bf3dafae464e32161ca334e3c609b" translate="yes" xml:space="preserve">
          <source>Sometimes, you are trying to dispatch an action, but your view does not update. Why does this happen? There may be several reasons for this.</source>
          <target state="translated">Иногда вы пытаетесь отправить действие,но ваше мнение не обновляется.Почему это происходит? Для этого может быть несколько причин.</target>
        </trans-unit>
        <trans-unit id="7b37110e5b01350732eac4676af2611966b9ccef" translate="yes" xml:space="preserve">
          <source>Source Code</source>
          <target state="translated">Исходный код</target>
        </trans-unit>
        <trans-unit id="f7919286c635d777ca9b544031e60fec3b718ae8" translate="yes" xml:space="preserve">
          <source>Special thanks to &lt;a href=&quot;http://jdpaton.github.io&quot;&gt;Jamie Paton&lt;/a&gt; for handing over the &lt;code&gt;redux&lt;/code&gt; NPM package name.</source>
          <target state="translated">Особая благодарность &lt;a href=&quot;http://jdpaton.github.io&quot;&gt;Джейми Пэтону&lt;/a&gt; за передачу имени пакета &lt;code&gt;redux&lt;/code&gt; NPM.</target>
        </trans-unit>
        <trans-unit id="56c91bc14a02e8f889305106eb782729b8dd411c" translate="yes" xml:space="preserve">
          <source>Specifically, at each stage of the iteration, &lt;code&gt;combineReducers&lt;/code&gt; performs a shallow equality check on the current state slice and the state slice returned from the reducer. If the reducer returns a new object, the shallow equality check will fail, and &lt;code&gt;combineReducers&lt;/code&gt; will set a &lt;code&gt;hasChanged&lt;/code&gt; flag to true.</source>
          <target state="translated">В частности, на каждом этапе итерации &lt;code&gt;combineReducers&lt;/code&gt; выполняет неглубокую проверку на равенство среза текущего состояния и среза состояния, возвращенного редуктором. Если редуктор возвращает новый объект, проверка неглубокого равенства завершится неудачно, &lt;code&gt;combineReducers&lt;/code&gt; установит флаг &lt;code&gt;hasChanged&lt;/code&gt; в значение true.</target>
        </trans-unit>
        <trans-unit id="00a3d8825c5eff03d86ea087a0b53050c94c3f8c" translate="yes" xml:space="preserve">
          <source>Specifically, if the state slice passed to a reducer by &lt;code&gt;combineReducers&lt;/code&gt; is a mutable object, the reducer can modify it directly and return it.</source>
          <target state="translated">В частности, если срез состояния, переданный редуктору с помощью &lt;code&gt;combineReducers&lt;/code&gt; является изменяемым объектом, редуктор может изменить его напрямую и вернуть.</target>
        </trans-unit>
        <trans-unit id="479e7df6db27bd135fe0142b00903715ac33068a" translate="yes" xml:space="preserve">
          <source>Splitting Reducer Logic</source>
          <target state="translated">Логика расщепления редуктора</target>
        </trans-unit>
        <trans-unit id="0b815e2bedf75de31f11e6b703026f6acada0f6e" translate="yes" xml:space="preserve">
          <source>Splitting Reducers</source>
          <target state="translated">Разделительные редукторы</target>
        </trans-unit>
        <trans-unit id="63a2a0cb21e82fc3b8d2808aae5b0cbb52a99600" translate="yes" xml:space="preserve">
          <source>Splitting Up Reducer Logic</source>
          <target state="translated">Разделение логики редуктора</target>
        </trans-unit>
        <trans-unit id="d329a5765000192b22c2d117af29d9bee7c6537b" translate="yes" xml:space="preserve">
          <source>Splitting relational/nested data up into separate tables</source>
          <target state="translated">Разделение реляционных/вложенных данных на отдельные таблицы</target>
        </trans-unit>
        <trans-unit id="1230663d5b652e72592a5cdc4822bd583ada50c6" translate="yes" xml:space="preserve">
          <source>Stack Overflow: Accessing Redux state in an action creator</source>
          <target state="translated">Переполнение стека:Доступ к состоянию Редукса в создателе действия</target>
        </trans-unit>
        <trans-unit id="af2ce625671f1ad526f0f824992d40592fc65945" translate="yes" xml:space="preserve">
          <source>Stack Overflow: Accessing Redux state in an action creator?</source>
          <target state="translated">Переполнение стека:Доступ в состояние &quot;Редукс&quot; у создателя экшена?</target>
        </trans-unit>
        <trans-unit id="cc4a21e47f70cd2f23b0f2c342d8b431463d5d43" translate="yes" xml:space="preserve">
          <source>Stack Overflow: Accessing other parts of the state when using combined reducers?</source>
          <target state="translated">Переполнение стека:Доступ к другим частям состояния при использовании комбинированных редукторов?</target>
        </trans-unit>
        <trans-unit id="b04783e3f6d9939621df25d5e278f88f85d40f4e" translate="yes" xml:space="preserve">
          <source>Stack Overflow: Can I dispatch multiple actions without Redux Thunk middleware?</source>
          <target state="translated">Переполнение стека:Могу ли я отправить несколько действий без промежуточного программного обеспечения Redux Thunk?</target>
        </trans-unit>
        <trans-unit id="48da126c64af14eeff2ddf00eef38c1862600c5d" translate="yes" xml:space="preserve">
          <source>Stack Overflow: Can a React Redux app scale as well as Backbone?</source>
          <target state="translated">Переполнение стека:Может ли приложение React Redux масштабироваться так же хорошо,как Backbone?</target>
        </trans-unit>
        <trans-unit id="4dfaf2359aff2ab31c33a3dbf21369953e0929ed" translate="yes" xml:space="preserve">
          <source>Stack Overflow: Can a Redux store lead to a memory leak?</source>
          <target state="translated">Переполнение стека:Может ли Redux-накопитель привести к утечке памяти?</target>
        </trans-unit>
        <trans-unit id="988abe0fa36c2ebb4e0cbf914b4d5fe269cc989b" translate="yes" xml:space="preserve">
          <source>Stack Overflow: Cleaner/shorter way to update nested state in Redux?</source>
          <target state="translated">Переполнение стека:Очистить/короче обновить вложенное состояние в Redux?</target>
        </trans-unit>
        <trans-unit id="5b1e48bcacf1979014102c6547e344589cfc1043" translate="yes" xml:space="preserve">
          <source>Stack Overflow: Do events and actions have a 1:1 relationship in Redux?</source>
          <target state="translated">Переполнение стека:Имеют ли события и действия отношение 1:1 в Redux?</target>
        </trans-unit>
        <trans-unit id="ebddfda346f9cc1931bdaef9cad513e27fe3e4da" translate="yes" xml:space="preserve">
          <source>Stack Overflow: How does Redux deal with deeply nested models?</source>
          <target state="translated">Переполнение стека:Как Redux работает с глубоко вложенными моделями?</target>
        </trans-unit>
        <trans-unit id="94b70dfefdce48458a92962024bd2e39922329c0" translate="yes" xml:space="preserve">
          <source>Stack Overflow: How to dispatch a Redux action with a timeout?</source>
          <target state="translated">Переполнение стека:Как отправить действие &quot;Редукс&quot; с тайм-аутом?</target>
        </trans-unit>
        <trans-unit id="b44a8af5f0a70fd30e935dc3f76e87f077627bbd" translate="yes" xml:space="preserve">
          <source>Stack Overflow: How to fire AJAX calls in response to the state changes with Redux?</source>
          <target state="translated">Переполнение стека:Как уволить звонки AJAX в ответ на изменение состояния с помощью Redux?</target>
        </trans-unit>
        <trans-unit id="3e47386ec6016dd7f3fc367e6cffa3cf96cda35c" translate="yes" xml:space="preserve">
          <source>Stack Overflow: How to get simple dispatch from this.props using connect w/ Redux?</source>
          <target state="translated">Переполнение стека:Как получить простую отправку от this.props,используя соединение w/Redux?</target>
        </trans-unit>
        <trans-unit id="2165fe78c71949f8e9b453c57e11f6841bdc5b4c" translate="yes" xml:space="preserve">
          <source>Stack Overflow: How to handle complex side-effects in Redux?</source>
          <target state="translated">Переполнение стека:Как справиться со сложными побочными эффектами в Redux?</target>
        </trans-unit>
        <trans-unit id="28f22a2146692414a69f910d533939bac7f855eb" translate="yes" xml:space="preserve">
          <source>Stack Overflow: How to handle tree-shaped entities in Redux reducers?</source>
          <target state="translated">Переполнение стека:Как работать с древовидными сущностями в редукторах Redux?</target>
        </trans-unit>
        <trans-unit id="9d4b50a3426c2e7c8b83c7f6061b71189fc4ad4d" translate="yes" xml:space="preserve">
          <source>Stack Overflow: How to optimize small updates to props of nested components in React + Redux?</source>
          <target state="translated">Переполнение стека:Как оптимизировать небольшие обновления реквизитов вложенных компонентов в React+Redux?</target>
        </trans-unit>
        <trans-unit id="4d918cb89f55a87fe62b679dfe98194482be59ff" translate="yes" xml:space="preserve">
          <source>Stack Overflow: How to optimize small updates to props of nested components?</source>
          <target state="translated">Переполнение стека:Как оптимизировать небольшие обновления реквизитов вложенных компонентов?</target>
        </trans-unit>
        <trans-unit id="acba72b3df5c830d1b5aba0a48d173bc22d8fc32" translate="yes" xml:space="preserve">
          <source>Stack Overflow: How to structure Redux components/containers</source>
          <target state="translated">Переполнение стека:Как структурировать компоненты/контейнеры Redux</target>
        </trans-unit>
        <trans-unit id="e3eccf206103856b93ecbd37ce4f41620479a06a" translate="yes" xml:space="preserve">
          <source>Stack Overflow: How to unit test async Redux actions to mock ajax response</source>
          <target state="translated">Переполнение стека:Как протестировать асинхронные действия Redux,чтобы высмеять реакцию аякса.</target>
        </trans-unit>
        <trans-unit id="4927a93f0a45155d14400120ebde30fcac96c00b" translate="yes" xml:space="preserve">
          <source>Stack Overflow: Is there any way to &quot;commit&quot; the state in Redux to free memory?</source>
          <target state="translated">Переполнение стека:Есть ли способ &quot;зафиксировать&quot; состояние в Redux,чтобы освободить память?</target>
        </trans-unit>
        <trans-unit id="8a704c1a402b4c7a231139affcc8b80dae9a39bc" translate="yes" xml:space="preserve">
          <source>Stack Overflow: Memory Usage Concern with Controlled Components</source>
          <target state="translated">Переполнение стека:Использование памяти с контролируемыми компонентами</target>
        </trans-unit>
        <trans-unit id="dee2e567cd35803ebf7a0cd85960b6e1c5f84ae0" translate="yes" xml:space="preserve">
          <source>Stack Overflow: Reducing an entire subtree with redux combineReducers</source>
          <target state="translated">Переполнение стека:Уменьшение всего поддерева с помощью резервных комбайновReducers</target>
        </trans-unit>
        <trans-unit id="f5c28dc373c45c187ad94b9e7c8d28a1a1e19e92" translate="yes" xml:space="preserve">
          <source>Stack Overflow: Redux and ALL the application state</source>
          <target state="translated">Переполнение стека:Редукс и ВСЕ состояние приложения</target>
        </trans-unit>
        <trans-unit id="c804eaac1de7836c4167b4c7ce22081a3aecc375" translate="yes" xml:space="preserve">
          <source>Stack Overflow: Redux multiple stores, why not?</source>
          <target state="translated">Переполнение стека:Несколько магазинов &quot;Редукс&quot;,почему бы и нет?</target>
        </trans-unit>
        <trans-unit id="b7e9dc84c7d9700ead6d04e9e5ccc4ca7533584c" translate="yes" xml:space="preserve">
          <source>Stack Overflow: Redux vs plain React?</source>
          <target state="translated">Переполнение стека:Redux vs plain React?</target>
        </trans-unit>
        <trans-unit id="105923b79101b77a45fa4c3b2354a35798f4c76b" translate="yes" xml:space="preserve">
          <source>Stack Overflow: Should I use one or several action types to represent this async action?</source>
          <target state="translated">Переполнение стека:Должен ли я использовать один или несколько типов действий для представления этого асинхронного действия?</target>
        </trans-unit>
        <trans-unit id="31fdb0827c84ebe2269807c61132bfaba82d6831" translate="yes" xml:space="preserve">
          <source>Stack Overflow: Should actions be handled by reducers to related actions or generated by action creators themselves?</source>
          <target state="translated">Переполнение стека:Должны ли действия быть обработаны редукторами к соответствующим действиям или сгенерированы самими создателями действий?</target>
        </trans-unit>
        <trans-unit id="65014c400549c8612072befc0adf72ed3b081d64" translate="yes" xml:space="preserve">
          <source>Stack Overflow: Should all component state be kept in Redux store?</source>
          <target state="translated">Переполнение стека:Должно ли все компоненты быть сохранены в магазине Redux?</target>
        </trans-unit>
        <trans-unit id="b98acfbe9a6b5556936b1fc7e937ef42e8da0b73" translate="yes" xml:space="preserve">
          <source>Stack Overflow: State in Redux app has the name of the reducer</source>
          <target state="translated">Переполнение стека:State in Redux app имеет имя редуктора.</target>
        </trans-unit>
        <trans-unit id="c9bb052748fb6d9f95b232931f6b7ce0b330d741" translate="yes" xml:space="preserve">
          <source>Stack Overflow: State key names and &lt;code&gt;combineReducers&lt;/code&gt;</source>
          <target state="translated">Переполнение стека: имена ключей состояния и &lt;code&gt;combineReducers&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="70cc3d889ceeb8e34d6f3922754c47f23bd9be8d" translate="yes" xml:space="preserve">
          <source>Stack Overflow: Store initial state and &lt;code&gt;combineReducers&lt;/code&gt;</source>
          <target state="translated">Переполнение стека: &lt;code&gt;combineReducers&lt;/code&gt; исходное состояние и объединитьReducers</target>
        </trans-unit>
        <trans-unit id="6c38c53a8386528fdbcdcab4494d509416d698fc" translate="yes" xml:space="preserve">
          <source>Stack Overflow: What could be the downsides of using Redux instead of Flux?</source>
          <target state="translated">Переполнение стека:Каковы могут быть недостатки использования Redux вместо Flux?</target>
        </trans-unit>
        <trans-unit id="895ded7294588881bb7fc95054edf3c3db5d4e96" translate="yes" xml:space="preserve">
          <source>Stack Overflow: What is the point of the constants in Redux?</source>
          <target state="translated">Переполнение стека:Какой смысл в константах в Редуксе?</target>
        </trans-unit>
        <trans-unit id="658846fec2f949984f29281c5ad5f8e0b3afe04d" translate="yes" xml:space="preserve">
          <source>Stack Overflow: When should I add Redux to a React app?</source>
          <target state="translated">Переполнение стека:Когда я должен добавить Redux в приложение React?</target>
        </trans-unit>
        <trans-unit id="49f9fa997616236334bab1f021f4d95a98961d28" translate="yes" xml:space="preserve">
          <source>Stack Overflow: Where should I put synchronous side effects linked to actions in redux?</source>
          <target state="translated">Переполнение стека:Куда помещать синхронные побочные эффекты,связанные с действиями,в избытке?</target>
        </trans-unit>
        <trans-unit id="936266740da7540850a532833e6a2df525b2a8b5" translate="yes" xml:space="preserve">
          <source>Stack Overflow: Why do we need middleware for async flow in Redux?</source>
          <target state="translated">Переполнение стека:Зачем нам промежуточное программное обеспечение для асинхронного потока в Redux?</target>
        </trans-unit>
        <trans-unit id="9bba3ac3bd12027bb6ac452b12ce38c7e56b122a" translate="yes" xml:space="preserve">
          <source>Stack Overflow: Why do you need 'Actions' as data in Redux?</source>
          <target state="translated">Переполнение стека:Зачем нужны &quot;Действия&quot; в качестве данных в Redux?</target>
        </trans-unit>
        <trans-unit id="18756cef85dbd29ab28641afa6772d3fefa20cc2" translate="yes" xml:space="preserve">
          <source>Stack Overflow: Why is state all in one place, even state that isn't global?</source>
          <target state="translated">Переполнение стека:Почему государство все в одном месте,даже государство,которое не является глобальным?</target>
        </trans-unit>
        <trans-unit id="7d2d7c0b7e20393e0c17c7eab1c82b6b5fc50426" translate="yes" xml:space="preserve">
          <source>Stack Overflow: Why should I use Redux in this example?</source>
          <target state="translated">Переполнение стека:Почему я должен использовать Redux в этом примере?</target>
        </trans-unit>
        <trans-unit id="a0364f6c9c8a113f92fdf913bbb551039a9724ed" translate="yes" xml:space="preserve">
          <source>Stack Overflow: Why use Redux over Facebook Flux?</source>
          <target state="translated">Переполнение стека:Почему Redux используется над Facebook Flux?</target>
        </trans-unit>
        <trans-unit id="10aa1b0c136f369eeefa163ced6c37c7c591e72e" translate="yes" xml:space="preserve">
          <source>Stack Overflow: can a dumb component use a Redux container?</source>
          <target state="translated">Переполнение стека:может ли тупой компонент использовать контейнер Redux?</target>
        </trans-unit>
        <trans-unit id="4b161211956de081a873933a4c8a044abab7e0fb" translate="yes" xml:space="preserve">
          <source>Standard Approaches</source>
          <target state="translated">Стандартные подходы</target>
        </trans-unit>
        <trans-unit id="a72502067518684f9deeec70cf119fd26326cd33" translate="yes" xml:space="preserve">
          <source>State</source>
          <target state="translated">State</target>
        </trans-unit>
        <trans-unit id="d587c099b9773435ddc0261ea9851ea406674dcf" translate="yes" xml:space="preserve">
          <source>State is read-only</source>
          <target state="translated">State is read-only</target>
        </trans-unit>
        <trans-unit id="88bdda40b1f54211bc74c1e437fac5cd7bd92718" translate="yes" xml:space="preserve">
          <source>Still, this isn't nice.</source>
          <target state="translated">Все равно,это нехорошо.</target>
        </trans-unit>
        <trans-unit id="0d8a7046c8d39d9cbd86abcdfb704b161a601f9e" translate="yes" xml:space="preserve">
          <source>Store</source>
          <target state="translated">Store</target>
        </trans-unit>
        <trans-unit id="6bd6be2595d77f48a33fbcd6f117fa074b3dc576" translate="yes" xml:space="preserve">
          <source>Store API</source>
          <target state="translated">API магазина</target>
        </trans-unit>
        <trans-unit id="2ae5ce622a7b9cf0a55280ae39f15ebca3636999" translate="yes" xml:space="preserve">
          <source>Store Methods</source>
          <target state="translated">Методы хранения</target>
        </trans-unit>
        <trans-unit id="755c0688d517f4d1f3befaef9cbffed1a12611b7" translate="yes" xml:space="preserve">
          <source>Store Setup</source>
          <target state="translated">Настройка магазина</target>
        </trans-unit>
        <trans-unit id="46284619675b8370e43c07e07ae7f90f0dc58a68" translate="yes" xml:space="preserve">
          <source>Store creator</source>
          <target state="translated">Создатель магазина</target>
        </trans-unit>
        <trans-unit id="8ce0b798e0d4896a15608877012298d37342e347" translate="yes" xml:space="preserve">
          <source>Store enhancer</source>
          <target state="translated">Магазинный усилитель</target>
        </trans-unit>
        <trans-unit id="e142a8c534381fae47d56a5e16a0f2235b158282" translate="yes" xml:space="preserve">
          <source>Store enhancers are much the same concept as higher-order components in React, which are also occasionally called &amp;ldquo;component enhancers&amp;rdquo;.</source>
          <target state="translated">Улучшители хранилища - это во многом та же концепция, что и компоненты более высокого порядка в React, которые также иногда называют &amp;laquo;усилителями компонентов&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="9416c1d5086bab5c721ad43af63fa3ab63c0a122" translate="yes" xml:space="preserve">
          <source>Store#dispatch()</source>
          <target state="translated">Store#dispatch()</target>
        </trans-unit>
        <trans-unit id="114eacc705a7df0e8c46ba7b192ea5316ba2c4ac" translate="yes" xml:space="preserve">
          <source>Store#getState()</source>
          <target state="translated">Store#getState()</target>
        </trans-unit>
        <trans-unit id="df99ee9fbf8a2efc5c7ed00b4492bf6b553163b9" translate="yes" xml:space="preserve">
          <source>Store#replaceReducer()</source>
          <target state="translated">Store#replaceReducer()</target>
        </trans-unit>
        <trans-unit id="013d0660eaa2690e6a9f899d36b23e021b36d850" translate="yes" xml:space="preserve">
          <source>Store#subscribe()</source>
          <target state="translated">Store#subscribe()</target>
        </trans-unit>
        <trans-unit id="71b541e49eef296d8df0cc8c719be0338a66cc03" translate="yes" xml:space="preserve">
          <source>Storing a single definition for a given item</source>
          <target state="translated">Хранение единого определения для данного пункта</target>
        </trans-unit>
        <trans-unit id="92eb6223892f134972ff80efa523a2000d6d1189" translate="yes" xml:space="preserve">
          <source>Structuring Reducers</source>
          <target state="translated">Редукторы структурирования</target>
        </trans-unit>
        <trans-unit id="2ff01fd753f588ce2cd880cdb10c47db54dde5a5" translate="yes" xml:space="preserve">
          <source>Subscribe to Redux state</source>
          <target state="translated">Подписаться на штат Редукс</target>
        </trans-unit>
        <trans-unit id="a54bde2350739858cdd0b5bc888eeb8620d23e6e" translate="yes" xml:space="preserve">
          <source>Such a dependency renders the component impure, makes testing the component more difficult, and makes reusing and refactoring the component unnecessarily difficult.</source>
          <target state="translated">Такая зависимость делает компонент загрязненным,затрудняет тестирование компонента,а также неоправданно затрудняет повторное использование и рефакторинг компонента.</target>
        </trans-unit>
        <trans-unit id="12b71c3e0fe5f7c0b8d17cc03186e281412da4a8" translate="yes" xml:space="preserve">
          <source>Summary</source>
          <target state="translated">Summary</target>
        </trans-unit>
        <trans-unit id="0fe97fb0406402fb59fa412b3bbeb9b60ac9262c" translate="yes" xml:space="preserve">
          <source>Synchronous Action Creators</source>
          <target state="translated">Создатели синхронных действий</target>
        </trans-unit>
        <trans-unit id="9730d4326a7b8a0d13c2be3b7fe29b80ad152bf6" translate="yes" xml:space="preserve">
          <source>Table of Contents</source>
          <target state="translated">Содержание</target>
        </trans-unit>
        <trans-unit id="15c674d7738210d0c5965059a30efc2059314bf7" translate="yes" xml:space="preserve">
          <source>Talks</source>
          <target state="translated">Talks</target>
        </trans-unit>
        <trans-unit id="2b65f913df556f349b0a7873cfdb7a6a8dd462a1" translate="yes" xml:space="preserve">
          <source>Task-Based Updates</source>
          <target state="translated">Обновления на основе задач</target>
        </trans-unit>
        <trans-unit id="d95c7170ec15da472e1fc16a1b3628b7692d766d" translate="yes" xml:space="preserve">
          <source>Technically we could split it into two components but it might be too early at this stage. It's fine to mix presentation and logic in a component that is very small. As it grows, it will be more obvious how to split it, so we'll leave it mixed.</source>
          <target state="translated">Технически мы могли бы разделить его на две части,но на данном этапе может быть слишком рано.Хорошо смешивать презентацию и логику в очень маленьком компоненте.По мере роста будет более очевидно,как его разделить,поэтому мы оставим его смешанным.</target>
        </trans-unit>
        <trans-unit id="97405b706d923beb562a978445f95da1784f550e" translate="yes" xml:space="preserve">
          <source>Technically you could write the container components by hand using &lt;a href=&quot;../api/store#subscribe&quot;&gt;&lt;code&gt;store.subscribe()&lt;/code&gt;&lt;/a&gt;. We don't advise you to do this because React Redux makes many performance optimizations that are hard to do by hand. For this reason, rather than write container components, we will generate them using the &lt;a href=&quot;https://github.com/reactjs/react-redux/blob/master/docs/api.md#connectmapstatetoprops-mapdispatchtoprops-mergeprops-options&quot;&gt;&lt;code&gt;connect()&lt;/code&gt;&lt;/a&gt; function provided by React Redux, as you will see below.</source>
          <target state="translated">Технически вы можете написать компоненты контейнера вручную, используя &lt;a href=&quot;../api/store#subscribe&quot;&gt; &lt;code&gt;store.subscribe()&lt;/code&gt; &lt;/a&gt; . Мы не советуем вам это делать, потому что React Redux выполняет множество оптимизаций производительности, которые сложно сделать вручную. По этой причине, вместо того, чтобы писать компоненты контейнера, мы будем генерировать их с помощью функции &lt;a href=&quot;https://github.com/reactjs/react-redux/blob/master/docs/api.md#connectmapstatetoprops-mapdispatchtoprops-mergeprops-options&quot;&gt; &lt;code&gt;connect()&lt;/code&gt; &lt;/a&gt; предоставляемой React Redux, как вы увидите ниже.</target>
        </trans-unit>
        <trans-unit id="2c2cd2ae8ff170115855201664f8bc10a106aa1d" translate="yes" xml:space="preserve">
          <source>Testimonials</source>
          <target state="translated">Testimonials</target>
        </trans-unit>
        <trans-unit id="97cba4858411c435e526dd651157aac20178222c" translate="yes" xml:space="preserve">
          <source>Thanks</source>
          <target state="translated">Thanks</target>
        </trans-unit>
        <trans-unit id="09191f5d1ae35f788275b3791134e5c6cc9695f6" translate="yes" xml:space="preserve">
          <source>That function is fairly short, but already becoming overly complex. We're dealing with two different areas of concern (filtering vs managing our list of todos), the nesting is making the update logic harder to read, and it's not exactly clear what's going on everywhere.</source>
          <target state="translated">Эта функция довольно коротка,но уже становится слишком сложной.Мы имеем дело с двумя различными областями (фильтрация против управления списком тодос),вложенность делает логику обновления более сложной для чтения,и не совсем понятно,что происходит везде.</target>
        </trans-unit>
        <trans-unit id="532f0a532fc0a678855d599bf7ec4ac18d1963d4" translate="yes" xml:space="preserve">
          <source>That reduced the duplication and made things a bit easier to read.</source>
          <target state="translated">Это уменьшило дублирование и сделало вещи немного проще для чтения.</target>
        </trans-unit>
        <trans-unit id="3d029300dc585308627967e2bccdc91655721462" translate="yes" xml:space="preserve">
          <source>That said, Redux works especially well with libraries like &lt;a href=&quot;http://facebook.github.io/react/&quot;&gt;React&lt;/a&gt; and &lt;a href=&quot;https://github.com/dekujs/deku&quot;&gt;Deku&lt;/a&gt; because they let you describe UI as a function of state, and Redux emits state updates in response to actions.</source>
          <target state="translated">Тем не менее, Redux особенно хорошо работает с такими библиотеками, как &lt;a href=&quot;http://facebook.github.io/react/&quot;&gt;React&lt;/a&gt; и &lt;a href=&quot;https://github.com/dekujs/deku&quot;&gt;Deku,&lt;/a&gt; потому что они позволяют описывать пользовательский интерфейс как функцию состояния, а Redux генерирует обновления состояния в ответ на действия.</target>
        </trans-unit>
        <trans-unit id="ba443c628e5456614af4a08cbb732b49948515da" translate="yes" xml:space="preserve">
          <source>That&amp;rsquo;s perfectly OK when you mutate the copy, but in the context of a reducer, if you return a copy that &lt;em&gt;hasn&amp;rsquo;t&lt;/em&gt; been mutated, Redux&amp;rsquo;s &lt;code&gt;combineReducers&lt;/code&gt; function will still think that the state needs to be updated, as you're returning an entirely different object from the state slice object that was passed in.</source>
          <target state="translated">Это нормально, когда вы изменяете копию, но в контексте редуктора, если вы возвращаете копию, &lt;em&gt;которая не&lt;/em&gt; была &lt;code&gt;combineReducers&lt;/code&gt; функция combReducers Redux все равно будет думать, что состояние необходимо обновить, поскольку вы возвращаете полностью объект отличается от переданного объекта среза состояния.</target>
        </trans-unit>
        <trans-unit id="e93f4cf2c16977aa0828b84202ee64df60519c65" translate="yes" xml:space="preserve">
          <source>That's it!</source>
          <target state="translated">Вот так!</target>
        </trans-unit>
        <trans-unit id="695a585b3252ff564ab700e0286c7c4e8dfbd47b" translate="yes" xml:space="preserve">
          <source>That's it! Now any actions dispatched to the store instance will flow through &lt;code&gt;logger&lt;/code&gt; and &lt;code&gt;crashReporter&lt;/code&gt;:</source>
          <target state="translated">Это оно! Теперь любые действия, отправленные экземпляру магазина, будут проходить через &lt;code&gt;logger&lt;/code&gt; и &lt;code&gt;crashReporter&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="62c0daeb24847642ed1a353245f2da0b5ca7faa7" translate="yes" xml:space="preserve">
          <source>That's it! Now you know what Redux is all about.</source>
          <target state="translated">Вот так! Теперь ты знаешь,что такое &quot;Редукс&quot;.</target>
        </trans-unit>
        <trans-unit id="9c632b918c1b5cb3e6e028274046e1a0dbd5fac5" translate="yes" xml:space="preserve">
          <source>The 5 Types of React Application State</source>
          <target state="translated">5 Типы состояния применения реактора</target>
        </trans-unit>
        <trans-unit id="8082f45d35153e13c48e541bd18a7f65d42e1b2f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://github.com/tommikaikkonen/redux-orm&quot;&gt;Redux-ORM&lt;/a&gt; library provides a very useful abstraction layer for managing normalized data in a Redux store. It allows you to declare Model classes and define relations between them. It can then generate the empty &quot;tables&quot; for your data types, act as a specialized selector tool for looking up the data, and perform immutable updates on that data.</source>
          <target state="translated">Библиотека &lt;a href=&quot;https://github.com/tommikaikkonen/redux-orm&quot;&gt;Redux-ORM&lt;/a&gt; предоставляет очень полезный уровень абстракции для управления нормализованными данными в хранилище Redux. Он позволяет вам объявлять классы модели и определять отношения между ними. Затем он может генерировать пустые &amp;laquo;таблицы&amp;raquo; для ваших типов данных, действовать как специализированный инструмент выбора для поиска данных и выполнять неизменяемые обновления этих данных.</target>
        </trans-unit>
        <trans-unit id="a1c005dfb17d1e5ad9227170c4331db15898fd97" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;reducers#reducers-share-state&quot;&gt;suggested structure&lt;/a&gt; for a Redux store is to split the state object into multiple &quot;slices&quot; or &quot;domains&quot; by key, and provide a separate reducer function to manage each individual data slice.</source>
          <target state="translated">&lt;a href=&quot;reducers#reducers-share-state&quot;&gt;Предлагаемая структура&lt;/a&gt; для магазина Redux, чтобы разбить объект состояния на несколько &amp;laquo;срезов&amp;raquo; или &amp;laquo;домены&amp;raquo; с помощью ключа, а также обеспечить отдельную функцию редуктора для управления каждого отдельного среза данных.</target>
        </trans-unit>
        <trans-unit id="b9a0e951a049ef97cd89a4e10f26e1e463b189ef" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;store&quot;&gt;store&lt;/a&gt; will pass two arguments to the &lt;a href=&quot;reducers&quot;&gt;reducer&lt;/a&gt;: the current state tree and the action. For example, in the todo app, the root reducer might receive something like this:</source>
          <target state="translated">&lt;a href=&quot;store&quot;&gt;Магазин&lt;/a&gt; будет проходить два аргумента в &lt;a href=&quot;reducers&quot;&gt;редуктор&lt;/a&gt; : текущее состоянии дерева и действие. Например, в приложении todo корневой редуктор может получить что-то вроде этого:</target>
        </trans-unit>
        <trans-unit id="738fb16f4a3da86b179b5fd2928c5cc0c8706445" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;combineReducers&lt;/code&gt; helper function turns an object whose values are different reducing functions into a single reducing function you can pass to &lt;a href=&quot;createstore&quot;&gt;&lt;code&gt;createStore&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;combineReducers&lt;/code&gt; вспомогательная функция превращает объект, значение которого отличается сокращением функций в одном восстанавливающей функцию вы можете перейти к &lt;a href=&quot;createstore&quot;&gt; &lt;code&gt;createStore&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a78fbb758be2a28c07a8ce0abb4a2f572f7c0bf8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;combineReducers&lt;/code&gt; utility included with Redux is very useful, but is deliberately limited to handle a single common use case: updating a state tree that is a plain Javascript object, by delegating the work of updating each slice of state to a specific slice reducer. It does &lt;em&gt;not&lt;/em&gt; handle other use cases, such as a state tree made up of Immutable.js Maps, trying to pass other portions of the state tree as an additional argument to a slice reducer, or performing &quot;ordering&quot; of slice reducer calls. It also does not care how a given slice reducer does its work.</source>
          <target state="translated">&lt;code&gt;combineReducers&lt;/code&gt; утилиты в комплекте с Redux очень полезно, но намеренно ограничивается обрабатывать один общий случай использования: обновление состояния дерева , которое является простым объектом Javascript, делегируя работу по обновлению каждого кусочка состояния в конкретном срезе редуктор. Он &lt;em&gt;не&lt;/em&gt; обрабатывает другие варианты использования, такие как дерево состояний, состоящее из карт Immutable.js, попытки передать другие части дерева состояний в качестве дополнительного аргумента редуктору фрагментов или выполнение &amp;laquo;упорядочивания&amp;raquo; вызовов редуктора фрагментов. Ему также безразлично, как данный редуктор срезов выполняет свою работу.</target>
        </trans-unit>
        <trans-unit id="48d1690c6f2d0e9c8b98b4f655fb56dfcdddc0d3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;connect()&lt;/code&gt; function takes two primary arguments, both optional. The first, &lt;code&gt;mapStateToProps&lt;/code&gt;, is a function you provide to pull data from the store when it changes, and pass those values as props to your component. The second, &lt;code&gt;mapDispatchToProps&lt;/code&gt;, is a function you provide to make use of the store's &lt;code&gt;dispatch&lt;/code&gt; function, usually by creating pre-bound versions of action creators that will automatically dispatch their actions as soon as they are called.</source>
          <target state="translated">Функция &lt;code&gt;connect()&lt;/code&gt; принимает два основных аргумента, оба необязательные. Первая, &lt;code&gt;mapStateToProps&lt;/code&gt; , - это функция, которую вы предоставляете для извлечения данных из хранилища при их изменении и передачи этих значений в качестве свойств вашему компоненту. Вторая, &lt;code&gt;mapDispatchToProps&lt;/code&gt; , - это функция, которую вы предоставляете для использования функции &lt;code&gt;dispatch&lt;/code&gt; хранилища , обычно путем создания предварительно привязанных версий создателей действий, которые будут автоматически отправлять свои действия, как только они будут вызваны.</target>
        </trans-unit>
        <trans-unit id="a1f724426f5bed59b6fcff9c426308b18d862500" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;dispatch()&lt;/code&gt; function can be accessed directly from the store as &lt;a href=&quot;../api/store#dispatch&quot;&gt;&lt;code&gt;store.dispatch()&lt;/code&gt;&lt;/a&gt;, but more likely you'll access it using a helper like &lt;a href=&quot;http://github.com/gaearon/react-redux&quot;&gt;react-redux&lt;/a&gt;'s &lt;code&gt;connect()&lt;/code&gt;. You can use &lt;a href=&quot;../api/bindactioncreators&quot;&gt;&lt;code&gt;bindActionCreators()&lt;/code&gt;&lt;/a&gt; to automatically bind many action creators to a &lt;code&gt;dispatch()&lt;/code&gt; function.</source>
          <target state="translated">&lt;code&gt;dispatch()&lt;/code&gt; функция может быть доступна непосредственно из магазина , как &lt;a href=&quot;../api/store#dispatch&quot;&gt; &lt;code&gt;store.dispatch()&lt;/code&gt; &lt;/a&gt; , но более вероятно , что вы будете к нему доступ с помощью помощника , как &lt;a href=&quot;http://github.com/gaearon/react-redux&quot;&gt;реагировать-Redux&lt;/a&gt; &amp;laquo;ы &lt;code&gt;connect()&lt;/code&gt; . Вы можете использовать &lt;a href=&quot;../api/bindactioncreators&quot;&gt; &lt;code&gt;bindActionCreators()&lt;/code&gt; &lt;/a&gt; для автоматической привязки многих создателей действий к функции &lt;code&gt;dispatch()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0cc5ef634bd494a2bcb0eba3ea9aacd39c49c13b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;distinctState()&lt;/code&gt; filter serves to ignore the actions that didn't result in a state change. There are &lt;a href=&quot;https://github.com/omnidan/redux-undo#configuration&quot;&gt;many other options&lt;/a&gt; to configure your undoable reducer, like setting the action type for Undo and Redo actions.</source>
          <target state="translated">&lt;code&gt;distinctState()&lt;/code&gt; фильтр служит игнорировать действия , которые не приводят к изменению состояния. Есть &lt;a href=&quot;https://github.com/omnidan/redux-undo#configuration&quot;&gt;много других параметров&lt;/a&gt; для настройки отменяемого редуктора, например, установка типа действия для действий Отменить и Вернуть.</target>
        </trans-unit>
        <trans-unit id="c7e69fb3a56cc38e559d99f56a4e63839a609eb9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;preloadedState&lt;/code&gt; will then be available on the client side by accessing &lt;code&gt;window.__PRELOADED_STATE__&lt;/code&gt;.</source>
          <target state="translated">После этого &lt;code&gt;preloadedState&lt;/code&gt; станет доступным на стороне клиента при доступе к &lt;code&gt;window.__PRELOADED_STATE__&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="454736cedd126ee22b50a1ed19c0f4bfc6ed98d8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;switch&lt;/code&gt; statement is &lt;em&gt;not&lt;/em&gt; the real boilerplate. The real boilerplate of Flux is conceptual: the need to emit an update, the need to register the Store with a Dispatcher, the need for the Store to be an object (and the complications that arise when you want a universal app).</source>
          <target state="translated">&lt;code&gt;switch&lt;/code&gt; заявление &lt;em&gt;не&lt;/em&gt; реальный шаблонный. Настоящий шаблон Flux концептуален: необходимость генерировать обновление, необходимость регистрировать Store с помощью Dispatcher, необходимость того, чтобы Store было объектом (и сложности, которые возникают, когда вам нужно универсальное приложение).</target>
        </trans-unit>
        <trans-unit id="5dfd028dd21b9e32d0060e5d401ade9a104ea3fe" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;switch&lt;/code&gt; statement is &lt;em&gt;not&lt;/em&gt; the real boilerplate. The real boilerplate of Flux is conceptual: the need to emit an update, the need to register the Store with a Dispatcher, the need for the Store to be an object (and the complications that arise when you want a universal app). Redux solves these problems by using pure reducers instead of event emitters.</source>
          <target state="translated">&lt;code&gt;switch&lt;/code&gt; заявление &lt;em&gt;не&lt;/em&gt; реальный шаблонный. Настоящий шаблон Flux концептуален: необходимость генерировать обновление, необходимость регистрировать Store с помощью Dispatcher, необходимость того, чтобы Store было объектом (и сложности, которые возникают, когда вам нужно универсальное приложение). Redux решает эти проблемы, используя чистые редукторы вместо эмиттеров событий.</target>
        </trans-unit>
        <trans-unit id="3e916ef3dceacc26ab023c93511c4a41b777908e" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;Store&lt;/strong&gt; is the object that brings them together. The store has the following responsibilities:</source>
          <target state="translated">&lt;strong&gt;Магазин&lt;/strong&gt; является объектом , который сводит их вместе. У магазина есть следующие обязанности:</target>
        </trans-unit>
        <trans-unit id="0dfb0a89f92611bca64f034a94a2f962e4ebd962" translate="yes" xml:space="preserve">
          <source>The Case for Flux</source>
          <target state="translated">Случай для Флюса</target>
        </trans-unit>
        <trans-unit id="2be97967a036b4704b556ca385f3d427bc4090d4" translate="yes" xml:space="preserve">
          <source>The Client Side</source>
          <target state="translated">Клиентская сторона</target>
        </trans-unit>
        <trans-unit id="8d8895e86bbb9fcbb32585f22afa4849467be15b" translate="yes" xml:space="preserve">
          <source>The Final Approach</source>
          <target state="translated">Окончательный подход</target>
        </trans-unit>
        <trans-unit id="2ec2a8c85e269f721fc1b0c962b89cc607899b26" translate="yes" xml:space="preserve">
          <source>The Gist</source>
          <target state="translated">Сущность</target>
        </trans-unit>
        <trans-unit id="de9191847383c1842749d836c1147436f76724d9" translate="yes" xml:space="preserve">
          <source>The HyperTerm terminal application</source>
          <target state="translated">Терминальное приложение HyperTerm</target>
        </trans-unit>
        <trans-unit id="d571c123a7cfe23b3bbf561d3957e3c00ed11319" translate="yes" xml:space="preserve">
          <source>The Little Idea of Functional Programming</source>
          <target state="translated">Маленькая идея функционального программирования...</target>
        </trans-unit>
        <trans-unit id="dfb1aa70710a03922941317888e0b7cc0c028c48" translate="yes" xml:space="preserve">
          <source>The Power of Higher-Order Reducers</source>
          <target state="translated">Мощность редукторов высшей категории</target>
        </trans-unit>
        <trans-unit id="79913e28740ae0370c83c1b4c15cfb9703563d49" translate="yes" xml:space="preserve">
          <source>The Redux API surface is tiny. Redux defines a set of contracts for you to implement (such as &lt;a href=&quot;../glossary#reducer&quot;&gt;reducers&lt;/a&gt;) and provides a few helper functions to tie these contracts together.</source>
          <target state="translated">Поверхность Redux API крошечная. Redux определяет набор контрактов, которые вы должны реализовать (например, &lt;a href=&quot;../glossary#reducer&quot;&gt;редукторы&lt;/a&gt; ), и предоставляет несколько вспомогательных функций для связывания этих контрактов вместе.</target>
        </trans-unit>
        <trans-unit id="fb0e273e2c9f9b6f01da6a08131796d0f995d9f2" translate="yes" xml:space="preserve">
          <source>The Redux API surface is tiny. Redux defines a set of contracts for you to implement (such as &lt;a href=&quot;https://redux.js.org/understanding/thinking-in-redux/glossary#reducer&quot;&gt;reducers&lt;/a&gt;) and provides a few helper functions to tie these contracts together.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5c1e3f8c2dd5838d397dba36b04c9a62e93369f" translate="yes" xml:space="preserve">
          <source>The Redux reducer API is &lt;code&gt;(state, action) =&amp;gt; state&lt;/code&gt;, but how you create those reducers is up to you.</source>
          <target state="translated">API редуктора Redux - это &lt;code&gt;(state, action) =&amp;gt; state&lt;/code&gt; , но то, как вы создаете эти редукторы, зависит от вас.</target>
        </trans-unit>
        <trans-unit id="4558623f708d5c23e2aa2461d3125df5fcd82d4a" translate="yes" xml:space="preserve">
          <source>The Redux source code is written in ES2015 but we precompile both CommonJS and UMD builds to ES5 so they work in &lt;a href=&quot;http://caniuse.com/#feat=es5&quot;&gt;any modern browser&lt;/a&gt;. You don't need to use Babel or a module bundler to &lt;a href=&quot;https://github.com/reactjs/redux/blob/master/examples/counter-vanilla/index.html&quot;&gt;get started with Redux&lt;/a&gt;.</source>
          <target state="translated">Исходный код Redux написан на ES2015, но мы предварительно компилируем сборки CommonJS и UMD в ES5, чтобы они работали в &lt;a href=&quot;http://caniuse.com/#feat=es5&quot;&gt;любом современном браузере&lt;/a&gt; . Вам не нужно использовать Babel или сборщик модулей, чтобы &lt;a href=&quot;https://github.com/reactjs/redux/blob/master/examples/counter-vanilla/index.html&quot;&gt;начать работу с Redux&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ecc1a1a17b3429a96287b0bd69b636f5a14dc84c" translate="yes" xml:space="preserve">
          <source>The Redux-ORM library maintains an internal queue of updates to be applied. Those updates are then applied immutably, simplifying the update process.</source>
          <target state="translated">Библиотека Redux-ORM поддерживает внутреннюю очередь обновлений для применения.Эти обновления затем применяются безостановочно,упрощая процесс обновления.</target>
        </trans-unit>
        <trans-unit id="478f0f344043467133811ff0c84e58dc576376c2" translate="yes" xml:space="preserve">
          <source>The Server Side</source>
          <target state="translated">Сторона сервера</target>
        </trans-unit>
        <trans-unit id="6a5fcafa1bd7939d8a0603992e21bd96c7692240" translate="yes" xml:space="preserve">
          <source>The Tao of Redux, Part 2 - Practice and Philosophy. Thick and thin reducers.</source>
          <target state="translated">Дао Редукского,часть 2-Практика и философия.Толстые и тонкие редукторы.</target>
        </trans-unit>
        <trans-unit id="9b46572db1b8dfcd7649cde9229d79fb8affd4f2" translate="yes" xml:space="preserve">
          <source>The actual list of todos.</source>
          <target state="translated">Настоящий список тодос.</target>
        </trans-unit>
        <trans-unit id="5aef95989e50df9f820f46a8576b4cdb580a5dd4" translate="yes" xml:space="preserve">
          <source>The advantage of using the object spread syntax becomes more apparent when you're composing complex objects. Below &lt;code&gt;getAddedIds&lt;/code&gt; maps an array of &lt;code&gt;id&lt;/code&gt; values to an array of objects with values returned from &lt;code&gt;getProduct&lt;/code&gt; and &lt;code&gt;getQuantity&lt;/code&gt;.</source>
          <target state="translated">Преимущество использования синтаксиса распределения объектов становится более очевидным, когда вы составляете сложные объекты. Ниже &lt;code&gt;getAddedIds&lt;/code&gt; сопоставляет массив значений &lt;code&gt;id&lt;/code&gt; с массивом объектов со значениями, возвращаемыми из &lt;code&gt;getProduct&lt;/code&gt; и &lt;code&gt;getQuantity&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1e2c53398d8416bc804266234b36f940f2c701d5" translate="yes" xml:space="preserve">
          <source>The array spread operator in ES6, and the similar object spread operator that is proposed for a future version of JavaScript</source>
          <target state="translated">Оператор распространения массива в ES6,и аналогичный оператор распространения объекта,который предлагается для будущей версии JavaScript</target>
        </trans-unit>
        <trans-unit id="e3bc116f9668143f3ac5c44b58f1126b54a0f5a3" translate="yes" xml:space="preserve">
          <source>The articles listed in &lt;a href=&quot;prerequisiteconcepts#immutable-data-management&quot;&gt;Prerequisite Concepts#Immutable Data Management&lt;/a&gt; give a number of good examples for how to perform basic update operations immutably, such as updating a field in an object or adding an item to the end of an array. However, reducers will often need to use those basic operations in combination to perform more complicated tasks. Here are some examples for some of the more common tasks you might have to implement.</source>
          <target state="translated">В статьях, перечисленных в &lt;a href=&quot;prerequisiteconcepts#immutable-data-management&quot;&gt;разделе Необходимые концепции # Неизменяемое управление данными,&lt;/a&gt; приводится ряд хороших примеров того, как выполнять базовые операции обновления неизменяемо, например, обновление поля в объекте или добавление элемента в конец массива. Однако редукторам часто необходимо использовать эти базовые операции в сочетании для выполнения более сложных задач. Вот несколько примеров некоторых наиболее распространенных задач, которые вам, возможно, придется реализовать.</target>
        </trans-unit>
        <trans-unit id="6c3850419731a888edfb498c6aaa6ebf75a3a7c1" translate="yes" xml:space="preserve">
          <source>The base dispatch function &lt;em&gt;always&lt;/em&gt; synchronously sends an action to the store's reducer, along with the previous state returned by the store, to calculate a new state. It expects actions to be plain objects ready to be consumed by the reducer.</source>
          <target state="translated">Базовая функция диспетчеризации &lt;em&gt;всегда&lt;/em&gt; синхронно отправляет действие редуктору хранилища вместе с предыдущим состоянием, возвращенным хранилищем, для вычисления нового состояния. Ожидается, что действия будут простыми объектами, готовыми к использованию редуктором.</target>
        </trans-unit>
        <trans-unit id="b132326ede652b0ef3bcc14eb28b705253858136" translate="yes" xml:space="preserve">
          <source>The basic concepts of normalizing data are:</source>
          <target state="translated">Основные концепции нормализации данных:</target>
        </trans-unit>
        <trans-unit id="4e52a5e9fc4db9bd1340d6ab9bc0823d57fe77ab" translate="yes" xml:space="preserve">
          <source>The client side is very straightforward. All we need to do is grab the initial state from &lt;code&gt;window.__PRELOADED_STATE__&lt;/code&gt;, and pass it to our &lt;a href=&quot;../api/createstore&quot;&gt;&lt;code&gt;createStore()&lt;/code&gt;&lt;/a&gt; function as the initial state.</source>
          <target state="translated">Клиентская сторона очень проста. Все, что нам нужно сделать, это получить начальное состояние из &lt;code&gt;window.__PRELOADED_STATE__&lt;/code&gt; и передать его нашей функции &lt;a href=&quot;../api/createstore&quot;&gt; &lt;code&gt;createStore()&lt;/code&gt; &lt;/a&gt; в качестве начального состояния.</target>
        </trans-unit>
        <trans-unit id="cf2d52f1f096bfa92fc770873878e027f7266621" translate="yes" xml:space="preserve">
          <source>The code reads from the Express &lt;code&gt;Request&lt;/code&gt; object passed into our server middleware. The parameter is parsed into a number and then set in the initial state. If you visit &lt;a href=&quot;http://localhost:3000/?counter=100&quot;&gt;http://localhost:3000/?counter=100&lt;/a&gt; in your browser, you'll see the counter starts at 100. In the rendered HTML, you'll see the counter output as 100 and the &lt;code&gt;__PRELOADED_STATE__&lt;/code&gt; variable has the counter set in it.</source>
          <target state="translated">Код считывается из объекта Express &lt;code&gt;Request&lt;/code&gt; , переданного в промежуточное ПО нашего сервера. Параметр преобразуется в число и затем устанавливается в исходное состояние. Если вы зайдете по &lt;a href=&quot;http://localhost:3000/?counter=100&quot;&gt;адресу http: // localhost: 3000 /? Counter = 100&lt;/a&gt; в своем браузере, вы увидите, что счетчик начинается с 100. В обработанном HTML вы увидите, что результат счетчика &lt;code&gt;__PRELOADED_STATE__&lt;/code&gt; 100, а переменная __PRELOADED_STATE__ имеет счетчик. установить в нем.</target>
        </trans-unit>
        <trans-unit id="4826495f8f747fbdf0f71e9d47d5be2bf0b9040a" translate="yes" xml:space="preserve">
          <source>The common question, then, is &quot;How can I use &lt;code&gt;combineReducers&lt;/code&gt; to handle these other use cases?&quot;. The answer to that is simply: &quot;you don't - you probably need to use something else&quot;. &lt;strong&gt;Once you go past the core use case for &lt;code&gt;combineReducers&lt;/code&gt;, it's time to use more &quot;custom&quot; reducer logic&lt;/strong&gt;, whether it be specific logic for a one-off use case, or a reusable function that could be widely shared. Here's some suggestions for dealing with a couple of these typical use cases, but feel free to come up with your own approaches.</source>
          <target state="translated">Таким образом, часто возникает вопрос: &amp;laquo;Как я могу использовать &lt;code&gt;combineReducers&lt;/code&gt; для обработки других вариантов использования?&amp;raquo;. Ответ на этот вопрос прост: &amp;laquo;вы не делаете - вам, вероятно, нужно использовать что-то еще&amp;raquo;. &lt;strong&gt;Как только вы &lt;code&gt;combineReducers&lt;/code&gt; мимо основного варианта использования combReducers , пора использовать более &amp;laquo;настраиваемую&amp;raquo; логику редуктора&lt;/strong&gt; , будь то конкретная логика для одноразового использования или многоразовая функция, которая может быть широко распространена. Вот несколько советов по работе с парой из этих типичных случаев использования, но не стесняйтесь придумывать свои собственные подходы.</target>
        </trans-unit>
        <trans-unit id="1c5f1c9e6c8f5bdeafe0125ff96ed215a380912f" translate="yes" xml:space="preserve">
          <source>The current suggested best practice is to categorize your components as &amp;ldquo;presentational&amp;rdquo; or &amp;ldquo;container&amp;rdquo; components, and extract a connected container component wherever it makes sense:</source>
          <target state="translated">В настоящее время рекомендуется классифицировать ваши компоненты как &amp;laquo;презентационные&amp;raquo; или &amp;laquo;контейнерные&amp;raquo; и извлекать связанный компонент-контейнер везде, где это имеет смысл:</target>
        </trans-unit>
        <trans-unit id="89bd096d9d762c82ef72e28c42515ef633264780" translate="yes" xml:space="preserve">
          <source>The currently selected visibility filter;</source>
          <target state="translated">Выбранный в данный момент фильтр видимости;</target>
        </trans-unit>
        <trans-unit id="edf1af83e4170e21d0f26a22f25cf9daa7c8184e" translate="yes" xml:space="preserve">
          <source>The data lifecycle in any Redux app follows these 4 steps:</source>
          <target state="translated">Жизненный цикл данных в любом приложении Redux следует следующим 4 этапам:</target>
        </trans-unit>
        <trans-unit id="62b467d39a23989592c09583e8808c4f173188dd" translate="yes" xml:space="preserve">
          <source>The easiest way to do this is to pass through some callback back to your synchronous code. In this case, that will be a function that will reference the response object and send back our rendered HTML to the client. Don't worry, it's not as hard as it may sound.</source>
          <target state="translated">Самый простой способ сделать это-пройти через некоторый обратный вызов обратно к синхронному коду.В этом случае,это будет функция,которая будет ссылаться на объект ответа и отправить обратно наш оказанный HTML к клиенту.Не волнуйтесь,это не так сложно,как может показаться.</target>
        </trans-unit>
        <trans-unit id="e4ce871b16323b1c0bb886336edf356b3878eb0d" translate="yes" xml:space="preserve">
          <source>The example is a bit long, because it's showing how all the different slice reducers and case reducers fit together. Note the delegation involved here. The &lt;code&gt;postsById&lt;/code&gt; slice reducer delegates the work for this case to &lt;code&gt;addComment&lt;/code&gt;, which inserts the new Comment's ID into the correct Post item. Meanwhile, both the &lt;code&gt;commentsById&lt;/code&gt; and &lt;code&gt;allComments&lt;/code&gt; slice reducers have their own case reducers, which update the Comments lookup table and list of all Comment IDs appropriately.</source>
          <target state="translated">Пример немного длинный, потому что он показывает, как все разные редукторы срезов и редукторы case подходят друг к другу. Обратите внимание на задействованную здесь делегацию. В &lt;code&gt;postsById&lt;/code&gt; ломтика редуктор делегирует работу для этого случая к &lt;code&gt;addComment&lt;/code&gt; , который вставляет идентификатор нового комментария в правильном сообщение пункт. Между тем, как редукторы срезов &lt;code&gt;commentsById&lt;/code&gt; ,так и &lt;code&gt;allComments&lt;/code&gt; имеют свои собственные редукторы case, которые обновляют таблицу поиска комментариев и список всех идентификаторов комментариев соответствующим образом.</target>
        </trans-unit>
        <trans-unit id="779dfe0ad26c982a1de5c2e0e8649831bf366e55" translate="yes" xml:space="preserve">
          <source>The examples in this section require React Redux v4.3.0 or greater</source>
          <target state="translated">Примеры в этом разделе требуют React Redux v4.3.0 или выше.</target>
        </trans-unit>
        <trans-unit id="e75214fea4fb1a9ffce832f2c35732c7381684ab" translate="yes" xml:space="preserve">
          <source>The examples use React, but you should still find them useful if you use something else.</source>
          <target state="translated">Примеры используют React,но вы все равно должны найти их полезными,если вы используете что-то другое.</target>
        </trans-unit>
        <trans-unit id="5ea635408bd084da5b7ab91bad09e779b2cf750c" translate="yes" xml:space="preserve">
          <source>The extra re-renders could be resolved by saving the array of objects into the state using a reducer, caching the mapped array using &lt;a href=&quot;https://github.com/reactjs/reselect&quot;&gt;Reselect&lt;/a&gt;, or implementing &lt;code&gt;shouldComponentUpdate&lt;/code&gt; in the component by hand and doing a more in-depth props comparison using a function such as &lt;code&gt;_.isEqual&lt;/code&gt;. Be careful to not make your custom &lt;code&gt;shouldComponentUpdate()&lt;/code&gt; more expensive than the rendering itself! Always use a profiler to check your assumptions about performance.</source>
          <target state="translated">Дополнительные повторные оказывает может быть решен путем сохранения массивов объектов в состояние с помощью редуктора, кэширования отображенного массива с помощью &lt;a href=&quot;https://github.com/reactjs/reselect&quot;&gt;Reselect&lt;/a&gt; или реализации &lt;code&gt;shouldComponentUpdate&lt;/code&gt; в компоненте вручную и делает более глубоким сравнение реквизита с использованием функции , такие как &lt;code&gt;_.isEqual&lt;/code&gt; . Будьте осторожны, чтобы не сделать ваш собственный &lt;code&gt;shouldComponentUpdate()&lt;/code&gt; дороже, чем сам рендеринг! Всегда используйте профилировщик, чтобы проверить свои предположения о производительности.</target>
        </trans-unit>
        <trans-unit id="0da3ed8f89bdb310cc912494206553bc1426d386" translate="yes" xml:space="preserve">
          <source>The fact that we hide it inside the library doesn't alter this fact.</source>
          <target state="translated">Тот факт,что мы прячем его внутри библиотеки,не меняет этого факта.</target>
        </trans-unit>
        <trans-unit id="1de0392a7f8331d8c01e93cc6658a1acbeb1d36b" translate="yes" xml:space="preserve">
          <source>The final step on the server side is to inject our initial component HTML and initial state into a template to be rendered on the client side. To pass along the state, we add a &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; tag that will attach &lt;code&gt;preloadedState&lt;/code&gt; to &lt;code&gt;window.__PRELOADED_STATE__&lt;/code&gt;.</source>
          <target state="translated">Последним шагом на стороне сервера является внедрение нашего исходного HTML-компонента и начального состояния в шаблон, который будет отображаться на стороне клиента. Для того, чтобы передать состояние, мы добавляем &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; тег , который будет прикрепить &lt;code&gt;preloadedState&lt;/code&gt; к &lt;code&gt;window.__PRELOADED_STATE__&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dba272babae41e9f815da394011efbc9abd976d3" translate="yes" xml:space="preserve">
          <source>The first thing that we need to do on every request is create a new Redux store instance. The only purpose of this store instance is to provide the initial state of our application.</source>
          <target state="translated">Первое,что нам нужно сделать по каждому запросу,это создать новый экземпляр магазина Redux.Единственная цель этого экземпляра хранилища-предоставить исходное состояние нашего приложения.</target>
        </trans-unit>
        <trans-unit id="437ff180e90b483ac82f3a0b997133834d4da2f7" translate="yes" xml:space="preserve">
          <source>The first time the reducer is called, the &lt;code&gt;state&lt;/code&gt; value will be &lt;code&gt;undefined&lt;/code&gt;. The reducer needs to handle this case by supplying a default state value before handling the incoming action.</source>
          <target state="translated">При первом вызове редуктора значение &lt;code&gt;state&lt;/code&gt; будет &lt;code&gt;undefined&lt;/code&gt; . Редуктору необходимо обработать этот случай, предоставив значение состояния по умолчанию перед обработкой входящего действия.</target>
        </trans-unit>
        <trans-unit id="3a95e0198d37edafccaeec5cfcad513398e60156" translate="yes" xml:space="preserve">
          <source>The fix is to call &lt;a href=&quot;api/store#dispatch&quot;&gt;&lt;code&gt;dispatch()&lt;/code&gt;&lt;/a&gt; method on the &lt;a href=&quot;api/store&quot;&gt;store&lt;/a&gt; instance:</source>
          <target state="translated">Исправление - вызвать метод &lt;a href=&quot;api/store#dispatch&quot;&gt; &lt;code&gt;dispatch()&lt;/code&gt; &lt;/a&gt; в экземпляре &lt;a href=&quot;api/store&quot;&gt;магазина&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="9cbc5ae45e711e0e52c905a6773d8d1b1935dc93" translate="yes" xml:space="preserve">
          <source>The fixed code looks like this:</source>
          <target state="translated">Исправленный код выглядит так:</target>
        </trans-unit>
        <trans-unit id="023789ed8635b6b65d05d6a4ac33fe464c661c24" translate="yes" xml:space="preserve">
          <source>The following is the outline for what our server side is going to look like. We are going to set up an &lt;a href=&quot;http://expressjs.com/guide/using-middleware.html&quot;&gt;Express middleware&lt;/a&gt; using &lt;a href=&quot;http://expressjs.com/api.html#app.use&quot;&gt;app.use&lt;/a&gt; to handle all requests that come in to our server. If you're unfamiliar with Express or middleware, just know that our handleRender function will be called every time the server receives a request.</source>
          <target state="translated">Ниже приводится схема того, как будет выглядеть наша серверная часть. Мы собираемся настроить &lt;a href=&quot;http://expressjs.com/guide/using-middleware.html&quot;&gt;промежуточное ПО Express&lt;/a&gt; с помощью &lt;a href=&quot;http://expressjs.com/api.html#app.use&quot;&gt;app.use&lt;/a&gt; для обработки всех запросов, поступающих на наш сервер. Если вы не знакомы с Express или промежуточным программным обеспечением, просто знайте, что наша функция handleRender будет вызываться каждый раз, когда сервер получает запрос.</target>
        </trans-unit>
        <trans-unit id="4316b779bf18bece5b0ccea09756426fce5c6d7c" translate="yes" xml:space="preserve">
          <source>The implementation of &lt;a href=&quot;../api/applymiddleware&quot;&gt;&lt;code&gt;applyMiddleware()&lt;/code&gt;&lt;/a&gt; that ships with Redux is similar, but &lt;strong&gt;different in three important aspects&lt;/strong&gt;:</source>
          <target state="translated">Реализация &lt;a href=&quot;../api/applymiddleware&quot;&gt; &lt;code&gt;applyMiddleware()&lt;/code&gt; &lt;/a&gt; , поставляемая с Redux, похожа, но &lt;strong&gt;отличается по трем важным аспектам&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="a9eb650209f72859301cebd361ec76ff3db6f6bc" translate="yes" xml:space="preserve">
          <source>The initial state is zero. Why? Because the second argument to &lt;code&gt;createStore&lt;/code&gt; was &lt;code&gt;undefined&lt;/code&gt;. This is the &lt;code&gt;state&lt;/code&gt; passed to your reducer the first time. When Redux initializes it dispatches a &quot;dummy&quot; action to fill the state. So your &lt;code&gt;counter&lt;/code&gt; reducer was called with &lt;code&gt;state&lt;/code&gt; equal to &lt;code&gt;undefined&lt;/code&gt;. &lt;strong&gt;This is exactly the case that &quot;activates&quot; the default argument.&lt;/strong&gt; Therefore, &lt;code&gt;state&lt;/code&gt; is now &lt;code&gt;0&lt;/code&gt; as per the default &lt;code&gt;state&lt;/code&gt; value (&lt;code&gt;state = 0&lt;/code&gt;). This state (&lt;code&gt;0&lt;/code&gt;) will be returned.</source>
          <target state="translated">Начальное состояние равно нулю. Зачем? Потому что второй аргумент &lt;code&gt;createStore&lt;/code&gt; не &lt;code&gt;undefined&lt;/code&gt; . Это &lt;code&gt;state&lt;/code&gt; переданное вашему редуктору в первый раз. Когда Redux инициализируется, он отправляет &amp;laquo;фиктивное&amp;raquo; действие для заполнения состояния. Итак, ваш &lt;code&gt;counter&lt;/code&gt; редуктор был вызван с &lt;code&gt;state&lt;/code&gt; равным &lt;code&gt;undefined&lt;/code&gt; . &lt;strong&gt;Это как раз тот случай, когда &quot;активируется&quot; аргумент по умолчанию.&lt;/strong&gt; Таким образом, &lt;code&gt;state&lt;/code&gt; теперь &lt;code&gt;0&lt;/code&gt; в соответствии с по умолчанию &lt;code&gt;state&lt;/code&gt; значения ( &lt;code&gt;state = 0&lt;/code&gt; ). Это состояние ( &lt;code&gt;0&lt;/code&gt; ) будет возвращено.</target>
        </trans-unit>
        <trans-unit id="f1870e4c91c65906a132e8ab3a09c561bb5d7c0e" translate="yes" xml:space="preserve">
          <source>The interesting part here is that it does not matter whether we want to keep an undo stack of numbers, strings, arrays, or objects. The structure will always be the same:</source>
          <target state="translated">Интересная часть здесь заключается в том,что не имеет значения,хотим ли мы сохранить отмену стопки чисел,строк,массивов или объектов.Структура всегда будет одинаковой:</target>
        </trans-unit>
        <trans-unit id="aced1e5fb79ae68b6eba1085040abdf61e8e93fd" translate="yes" xml:space="preserve">
          <source>The invoke function runs our middleware in the same way Redux does.</source>
          <target state="translated">Функция вызова запускает наше промежуточное программное обеспечение так же,как и Redux.</target>
        </trans-unit>
        <trans-unit id="d2e2db63b16b97293e72fee9e740a81bd129896c" translate="yes" xml:space="preserve">
          <source>The key step in server side rendering is to render the initial HTML of our component &lt;em&gt;&lt;strong&gt;before&lt;/strong&gt;&lt;/em&gt; we send it to the client side. To do this, we use &lt;a href=&quot;https://facebook.github.io/react/docs/react-dom-server.html#rendertostring&quot;&gt;ReactDOMServer.renderToString()&lt;/a&gt;.</source>
          <target state="translated">Ключевым этапом рендеринга на стороне сервера является отрисовка исходного HTML-кода нашего компонента &lt;em&gt;&lt;strong&gt;перед&lt;/strong&gt;&lt;/em&gt; его отправкой на клиентскую сторону. Для этого мы используем &lt;a href=&quot;https://facebook.github.io/react/docs/react-dom-server.html#rendertostring&quot;&gt;ReactDOMServer.renderToString ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ebf3991556cfed7c3eed26e9a4ebee92564c0c2e" translate="yes" xml:space="preserve">
          <source>The key to updating nested data is &lt;strong&gt;that &lt;em&gt;every&lt;/em&gt; level of nesting must be copied and updated appropriately&lt;/strong&gt;. This is often a difficult concept for those learning Redux, and there are some specific problems that frequently occur when trying to update nested objects. These lead to accidental direct mutation, and should be avoided.</source>
          <target state="translated">Ключом к обновлению вложенных данных является &lt;strong&gt;то, что &lt;em&gt;каждый&lt;/em&gt; уровень вложенности должен копироваться и обновляться соответствующим образом&lt;/strong&gt; . Это часто является сложной концепцией для тех, кто изучает Redux, и есть некоторые специфические проблемы, которые часто возникают при попытке обновить вложенные объекты. Это приводит к случайной прямой мутации, и этого следует избегать.</target>
        </trans-unit>
        <trans-unit id="a1f13b41716a56d3a6b663d8adeef0fbfebcd6da" translate="yes" xml:space="preserve">
          <source>The list of action types that were added, removed, and changed in a Pull Request helps everyone on the team keep track of scope and implementation of new features.</source>
          <target state="translated">Список типов действий,которые были добавлены,удалены и изменены в Pull Request,помогает всем членам команды следить за масштабом и реализацией новых возможностей.</target>
        </trans-unit>
        <trans-unit id="7a909efdb80760679c43fc5e7380d281a27aa83b" translate="yes" xml:space="preserve">
          <source>The listener should not expect to see all state changes, as the state might have been updated multiple times during a nested &lt;a href=&quot;#dispatch&quot;&gt;&lt;code&gt;dispatch()&lt;/code&gt;&lt;/a&gt; before the listener is called. It is, however, guaranteed that all subscribers registered before the &lt;a href=&quot;#dispatch&quot;&gt;&lt;code&gt;dispatch()&lt;/code&gt;&lt;/a&gt; started will be called with the latest state by the time it exits.</source>
          <target state="translated">Слушателю не следует ожидать увидеть все изменения состояния, так как состояние могло обновляться несколько раз во время вложенной &lt;a href=&quot;#dispatch&quot;&gt; &lt;code&gt;dispatch()&lt;/code&gt; &lt;/a&gt; перед вызовом слушателя. Однако гарантируется, что все подписчики, зарегистрированные до запуска &lt;a href=&quot;#dispatch&quot;&gt; &lt;code&gt;dispatch()&lt;/code&gt; &lt;/a&gt; будут вызываться с самым последним состоянием к моменту выхода.</target>
        </trans-unit>
        <trans-unit id="c8d57f0dc666d6c5ce99071844c64516efa85351" translate="yes" xml:space="preserve">
          <source>The listener should not expect to see all state changes, as the state might have been updated multiple times during a nested &lt;a href=&quot;#dispatchaction&quot;&gt;&lt;code&gt;dispatch()&lt;/code&gt;&lt;/a&gt; before the listener is called. It is, however, guaranteed that all subscribers registered before the &lt;a href=&quot;#dispatchaction&quot;&gt;&lt;code&gt;dispatch()&lt;/code&gt;&lt;/a&gt; started will be called with the latest state by the time it exits.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dfc2ce49bb9fba9f11cb4c299cb527330ef38e0b" translate="yes" xml:space="preserve">
          <source>The listener should only call &lt;a href=&quot;#dispatch&quot;&gt;&lt;code&gt;dispatch()&lt;/code&gt;&lt;/a&gt; either in response to user actions or under specific conditions (e. g. dispatching an action when the store has a specific field). Calling &lt;a href=&quot;#dispatch&quot;&gt;&lt;code&gt;dispatch()&lt;/code&gt;&lt;/a&gt; without any conditions is technically possible, however it leads to an infinite loop as every &lt;a href=&quot;#dispatch&quot;&gt;&lt;code&gt;dispatch()&lt;/code&gt;&lt;/a&gt; call usually triggers the listener again.</source>
          <target state="translated">Слушатель должен вызывать &lt;a href=&quot;#dispatch&quot;&gt; &lt;code&gt;dispatch()&lt;/code&gt; &lt;/a&gt; в ответ на действия пользователя или при определенных условиях (например, отправка действия, когда в магазине есть определенное поле). Вызов &lt;a href=&quot;#dispatch&quot;&gt; &lt;code&gt;dispatch()&lt;/code&gt; &lt;/a&gt; без каких-либо условий технически возможен, однако это приводит к бесконечному циклу, поскольку каждый вызов &lt;a href=&quot;#dispatch&quot;&gt; &lt;code&gt;dispatch()&lt;/code&gt; &lt;/a&gt; обычно снова запускает слушателя.</target>
        </trans-unit>
        <trans-unit id="488cee853ee8f2ee1b7b34adadde5165f8f7a005" translate="yes" xml:space="preserve">
          <source>The listener should only call &lt;a href=&quot;#dispatchaction&quot;&gt;&lt;code&gt;dispatch()&lt;/code&gt;&lt;/a&gt; either in response to user actions or under specific conditions (e. g. dispatching an action when the store has a specific field). Calling &lt;a href=&quot;#dispatchaction&quot;&gt;&lt;code&gt;dispatch()&lt;/code&gt;&lt;/a&gt; without any conditions is technically possible, however it leads to an infinite loop as every &lt;a href=&quot;#dispatchaction&quot;&gt;&lt;code&gt;dispatch()&lt;/code&gt;&lt;/a&gt; call usually triggers the listener again.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1a0911c22c72f7c2742cacaf4dc763e35a23b3f" translate="yes" xml:space="preserve">
          <source>The logic for retrieving or updating a given item is now fairly simple and consistent. Given an item's type and its ID, we can directly look it up in a couple simple steps, without having to dig through other objects to find it.</source>
          <target state="translated">Логика извлечения или обновления данного элемента теперь довольно проста и последовательна.Учитывая тип элемента и его ID,мы можем напрямую искать его за пару простых шагов,без необходимости копаться в других объектах,чтобы найти его.</target>
        </trans-unit>
        <trans-unit id="ea3c8144b116952a7e48b511c8b6726d8e7f3ef8" translate="yes" xml:space="preserve">
          <source>The middleware that interprets such actions could look like this:</source>
          <target state="translated">Промежуточное программное обеспечение,интерпретирующее такие действия,может выглядеть так:</target>
        </trans-unit>
        <trans-unit id="d682e36630596f87baf92e1be74cab220ee7bbc6" translate="yes" xml:space="preserve">
          <source>The most common issue with server side rendering is dealing with state that comes in asynchronously. Rendering on the server is synchronous by nature, so it's necessary to map any asynchronous fetches into a synchronous operation.</source>
          <target state="translated">Самой распространенной проблемой при рендеринге на стороне сервера является работа с состоянием,которое приходит асинхронно.Рендеринг на сервере по своей природе является синхронным,поэтому необходимо сопоставить любые асинхронные получения в синхронную операцию.</target>
        </trans-unit>
        <trans-unit id="8bd487c6f173028a7534d7c66f721bcbc1a7152f" translate="yes" xml:space="preserve">
          <source>The most common state shape for a Redux app is a plain Javascript object containing &quot;slices&quot; of domain-specific data at each top-level key. Similarly, the most common approach to writing reducer logic for that state shape is to have &quot;slice reducer&quot; functions, each with the same &lt;code&gt;(state, action)&lt;/code&gt; signature, and each responsible for managing all updates to that specific slice of state. Multiple slice reducers can respond to the same action, independently update their own slice as needed, and the updated slices are combined into the new state object.</source>
          <target state="translated">Наиболее распространенная форма состояния для приложения Redux - это простой объект Javascript, содержащий &amp;laquo;срезы&amp;raquo; данных, зависящих от домена, на каждом ключе верхнего уровня. Точно так же наиболее распространенный подход к написанию логики редуктора для этой формы состояния состоит в том, чтобы иметь функции &amp;laquo;редуктора среза&amp;raquo;, каждая с одной и той же сигнатурой &lt;code&gt;(state, action)&lt;/code&gt; , и каждая отвечает за управление всеми обновлениями этого конкретного среза состояния. Несколько редукторов срезов могут реагировать на одно и то же действие, независимо обновлять свой собственный срез по мере необходимости, и обновленные срезы объединяются в новый объект состояния.</target>
        </trans-unit>
        <trans-unit id="93bd18e049d16d78b6a4f2d8ab6b83aaccc924a2" translate="yes" xml:space="preserve">
          <source>The most common use case for middleware is to support asynchronous actions without much boilerplate code or a dependency on a library like &lt;a href=&quot;https://github.com/Reactive-Extensions/RxJS&quot;&gt;Rx&lt;/a&gt;. It does so by letting you dispatch &lt;a href=&quot;../glossary#async-action&quot;&gt;async actions&lt;/a&gt; in addition to normal actions.</source>
          <target state="translated">Наиболее распространенный вариант использования промежуточного программного обеспечения - поддержка асинхронных действий без большого количества шаблонного кода или зависимости от библиотеки, такой как &lt;a href=&quot;https://github.com/Reactive-Extensions/RxJS&quot;&gt;Rx&lt;/a&gt; . Он делает это, позволяя отправлять &lt;a href=&quot;../glossary#async-action&quot;&gt;асинхронные действия&lt;/a&gt; в дополнение к обычным действиям.</target>
        </trans-unit>
        <trans-unit id="eabd6d6748896987c05d969d3d0db08e988f3bce" translate="yes" xml:space="preserve">
          <source>The most common use case for middleware is to support asynchronous actions without much boilerplate code or a dependency on a library like &lt;a href=&quot;https://github.com/Reactive-Extensions/RxJS&quot;&gt;Rx&lt;/a&gt;. It does so by letting you dispatch &lt;a href=&quot;https://redux.js.org/understanding/thinking-in-redux/glossary#async-action&quot;&gt;async actions&lt;/a&gt; in addition to normal actions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ca5c9f8c9076592f848e34b0f4212ad6547c204" translate="yes" xml:space="preserve">
          <source>The most common use case for server-side rendering is to handle the &lt;em&gt;initial render&lt;/em&gt; when a user (or search engine crawler) first requests our app. When the server receives the request, it renders the required component(s) into an HTML string, and then sends it as a response to the client. From that point on, the client takes over rendering duties.</source>
          <target state="translated">Наиболее распространенный вариант использования рендеринга на стороне сервера - обработка &lt;em&gt;начального рендеринга,&lt;/em&gt; когда пользователь (или сканер поисковой системы) впервые запрашивает наше приложение. Когда сервер получает запрос, он преобразует требуемые компоненты в строку HTML, а затем отправляет их в качестве ответа клиенту. С этого момента клиент берет на себя обязанности по визуализации.</target>
        </trans-unit>
        <trans-unit id="24ae76922e0a16060847d467d7cc8498c8e8fd41" translate="yes" xml:space="preserve">
          <source>The most na&amp;iuml;ve solution is just to log the action and the next state yourself every time you call &lt;a href=&quot;../api/store#dispatch&quot;&gt;&lt;code&gt;store.dispatch(action)&lt;/code&gt;&lt;/a&gt;. It's not really a solution, but just a first step towards understanding the problem.</source>
          <target state="translated">Самое наивное решение - просто регистрировать действие и следующее состояние самостоятельно каждый раз, когда вы вызываете &lt;a href=&quot;../api/store#dispatch&quot;&gt; &lt;code&gt;store.dispatch(action)&lt;/code&gt; &lt;/a&gt; . На самом деле это не решение, а всего лишь первый шаг к пониманию проблемы.</target>
        </trans-unit>
        <trans-unit id="c28210a81ca17cd5297b553285382ceab58a3637" translate="yes" xml:space="preserve">
          <source>The new Counter Vanilla example is aimed to dispel the myth that Redux requires Webpack, React, hot reloading, sagas, action creators, constants, Babel, npm, CSS modules, decorators, fluent Latin, an Egghead subscription, a PhD, or an Exceeds Expectations O.W.L. level.</source>
          <target state="translated">Новый пример Counter Vanilla призван развеять миф о том,что Redux требует Webpack,React,горячую перезагрузку,саги,создателей действий,константы,Babel,npm,CSS модули,декораторы,свободно владеющие латынью,подписку на Egghead,докторскую степень или уровень O.W.L.Exceeds Expectations.</target>
        </trans-unit>
        <trans-unit id="93fb65536a0476327978e11533ea1a5d24a10c81" translate="yes" xml:space="preserve">
          <source>The new state is not passed to the listeners in order to simplify implementing store enhancers such as the Redux DevTools. In addition, subscribers are intended to react to the state value itself, not the action. Middleware can be used if the action is important and needs to be handled specifically.</source>
          <target state="translated">Новое состояние не передается слушателям,чтобы упростить внедрение усилителей магазина,таких как Redux DevTools.Кроме того,абоненты должны реагировать на само значение состояния,а не на действие.Промежуточное программное обеспечение может быть использовано,если действие важно и должно быть обработано специально.</target>
        </trans-unit>
        <trans-unit id="5e78ce3d1d64476af75b7e5f41d5be781a323a4c" translate="yes" xml:space="preserve">
          <source>The nice thing about thunks is that they can dispatch results of each other:</source>
          <target state="translated">Приятно то,что они могут посылать результаты друг другу:</target>
        </trans-unit>
        <trans-unit id="6d99c20eac2d1658b7df0891305cdca243a9af62" translate="yes" xml:space="preserve">
          <source>The only input for server side code is the request made when loading up a page in your app in your browser. You may choose to configure the server during its boot (such as when you are running in a development vs. production environment), but that configuration is static.</source>
          <target state="translated">Единственным вводом кода серверной стороны является запрос,сделанный при загрузке страницы в вашем приложении в браузере.Вы можете выбрать конфигурацию сервера во время его загрузки (например,когда вы работаете в среде разработки против производственной),но эта конфигурация является статической.</target>
        </trans-unit>
        <trans-unit id="0f86933dcbbe66c8f04e7c9fc359e8fa49b3f7f3" translate="yes" xml:space="preserve">
          <source>The only use case for &lt;code&gt;bindActionCreators&lt;/code&gt; is when you want to pass some action creators down to a component that isn't aware of Redux, and you don't want to pass &lt;a href=&quot;store#dispatch&quot;&gt;&lt;code&gt;dispatch&lt;/code&gt;&lt;/a&gt; or the Redux store to it.</source>
          <target state="translated">Единственный вариант использования &lt;code&gt;bindActionCreators&lt;/code&gt; - это когда вы хотите передать некоторых создателей действий компоненту, который не знает Redux, и вы не хотите передавать ему &lt;a href=&quot;store#dispatch&quot;&gt; &lt;code&gt;dispatch&lt;/code&gt; &lt;/a&gt; или хранилище Redux.</target>
        </trans-unit>
        <trans-unit id="11679d519383db9e97765680c1c087a4c5d58e4d" translate="yes" xml:space="preserve">
          <source>The only use case for &lt;code&gt;bindActionCreators&lt;/code&gt; is when you want to pass some action creators down to a component that isn't aware of Redux, and you don't want to pass &lt;a href=&quot;store#dispatchaction&quot;&gt;&lt;code&gt;dispatch&lt;/code&gt;&lt;/a&gt; or the Redux store to it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66b4d49e553bb0efa470bbe85e68619297117596" translate="yes" xml:space="preserve">
          <source>The only way to change the state inside it is to dispatch an &lt;a href=&quot;../glossary#action&quot;&gt;action&lt;/a&gt; on it.</source>
          <target state="translated">Единственный способ изменить состояние внутри него - это отправить над ним &lt;a href=&quot;../glossary#action&quot;&gt;действие&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3d51f5c9be0da0a1475d839514b718722284186c" translate="yes" xml:space="preserve">
          <source>The only way to change the state tree is to emit an &lt;em&gt;action&lt;/em&gt;, an object describing what happened.</source>
          <target state="translated">Единственный способ изменить дерево состояний - испустить &lt;em&gt;действие&lt;/em&gt; , объект, описывающий, что произошло.</target>
        </trans-unit>
        <trans-unit id="c24d16d7147d4d6eb8c10527b6a9d45b0beb9c87" translate="yes" xml:space="preserve">
          <source>The option we recommend is to use a special React Redux component called &lt;a href=&quot;https://github.com/reactjs/react-redux/blob/master/docs/api.md#provider-store&quot;&gt;&lt;code&gt;&amp;lt;Provider&amp;gt;&lt;/code&gt;&lt;/a&gt; to &lt;a href=&quot;https://facebook.github.io/react/docs/context.html&quot;&gt;magically&lt;/a&gt; make the store available to all container components in the application without passing it explicitly. You only need to use it once when you render the root component:</source>
          <target state="translated">Мы рекомендуем использовать специальный компонент React Redux под названием &lt;a href=&quot;https://github.com/reactjs/react-redux/blob/master/docs/api.md#provider-store&quot;&gt; &lt;code&gt;&amp;lt;Provider&amp;gt;&lt;/code&gt; ,&lt;/a&gt; чтобы &lt;a href=&quot;https://facebook.github.io/react/docs/context.html&quot;&gt;волшебным образом&lt;/a&gt; сделать хранилище доступным для всех компонентов контейнера в приложении, не передавая его явно. Вам нужно использовать его только один раз при рендеринге корневого компонента:</target>
        </trans-unit>
        <trans-unit id="648fab04f4ba80945b0b8fe210f400cb5cd99721" translate="yes" xml:space="preserve">
          <source>The original Flux pattern describes having multiple &amp;ldquo;stores&amp;rdquo; in an app, each one holding a different area of domain data. This can introduce issues such as needing to have one store &amp;ldquo;&lt;code&gt;waitFor&lt;/code&gt;&amp;rdquo; another store to update. This is not necessary in Redux because the separation between data domains is already achieved by splitting a single reducer into smaller reducers.</source>
          <target state="translated">Исходный шаблон Flux описывает наличие нескольких &amp;laquo;хранилищ&amp;raquo; в приложении, в каждом из которых хранится отдельная область данных домена. Это может вызвать такие проблемы, как необходимость иметь одно хранилище &amp;laquo; &lt;code&gt;waitFor&lt;/code&gt; &amp;raquo; для обновления другого магазина. В Redux это не обязательно, потому что разделение между доменами данных уже достигнуто путем разделения одного редуктора на меньшие редукторы.</target>
        </trans-unit>
        <trans-unit id="62ee23332a72fc3750f78243b123043b65f95888" translate="yes" xml:space="preserve">
          <source>The question is: do you really need Redux if you already use Rx? Maybe not. It's not hard to &lt;a href=&quot;https://github.com/jas-chen/rx-redux&quot;&gt;re-implement Redux in Rx&lt;/a&gt;. Some say it's a two-liner using Rx &lt;code&gt;.scan()&lt;/code&gt; method. It may very well be!</source>
          <target state="translated">Вопрос в том, действительно ли вам нужен Redux, если вы уже используете Rx? Может быть нет. &lt;a href=&quot;https://github.com/jas-chen/rx-redux&quot;&gt;Реализовать Redux в Rx&lt;/a&gt; несложно . Некоторые говорят, что это &lt;code&gt;.scan()&lt;/code&gt; с использованием метода Rx .scan () . Вполне может быть!</target>
        </trans-unit>
        <trans-unit id="b112f1eaa085df10f0fb3a949e7c7d0512123ef7" translate="yes" xml:space="preserve">
          <source>The reducer &lt;code&gt;(state, action) =&amp;gt; state&lt;/code&gt; signature makes it natural to implement generic &amp;ldquo;reducer enhancers&amp;rdquo; or &amp;ldquo;higher order reducers&amp;rdquo;. They are functions that take your reducer and enhance it with some additional functionality while preserving its signature. Undo history is exactly such a case.</source>
          <target state="translated">Редуктор &lt;code&gt;(state, action) =&amp;gt; state&lt;/code&gt; подпись состояния делает естественным реализацию универсальных &amp;laquo;редукторов-усилителей&amp;raquo; или &amp;laquo;редукторов более высокого порядка&amp;raquo;. Это функции, которые берут ваш редуктор и улучшают его некоторыми дополнительными функциями, сохраняя при этом его сигнатуру. История отмен как раз такой случай.</target>
        </trans-unit>
        <trans-unit id="831cdccd0fe29b2292b102e71a67a95df749f9a5" translate="yes" xml:space="preserve">
          <source>The reducer generated by &lt;code&gt;combineReducers({ a, b })&lt;/code&gt; looks like this:</source>
          <target state="translated">Редуктор, созданный &lt;code&gt;combineReducers({ a, b })&lt;/code&gt; выглядит следующим образом:</target>
        </trans-unit>
        <trans-unit id="579bccc1a8ba0deb299c67fd02b66c1a0bde82b3" translate="yes" xml:space="preserve">
          <source>The reducer logic doesn't have to deal with deep levels of nesting, so it will probably be much simpler.</source>
          <target state="translated">Логика редуктора не должна иметь дело с глубокими уровнями гнездования,так что,вероятно,она будет намного проще.</target>
        </trans-unit>
        <trans-unit id="8b251f78a3911e16c890bcff055432910c7e244e" translate="yes" xml:space="preserve">
          <source>The reducers may handle this action by merging the new data into the state they manage and resetting &lt;code&gt;isFetching&lt;/code&gt;. The UI would hide the spinner, and display the fetched data.</source>
          <target state="translated">Редукторы могут обрабатывать это действие, объединяя новые данные в состояние, которым они управляют, и сбрасывая &lt;code&gt;isFetching&lt;/code&gt; . Пользовательский интерфейс скрывал счетчик и отображал полученные данные.</target>
        </trans-unit>
        <trans-unit id="ef702e159de1a7ac56e685ea8e6312a6d8a5ae0e" translate="yes" xml:space="preserve">
          <source>The reducers may handle this action by resetting &lt;code&gt;isFetching&lt;/code&gt;. Additionally, some reducers may want to store the error message so the UI can display it.</source>
          <target state="translated">Редукторы могут обработать это действие, сбросив &lt;code&gt;isFetching&lt;/code&gt; . Кроме того, некоторые редукторы могут захотеть сохранить сообщение об ошибке, чтобы пользовательский интерфейс мог его отобразить.</target>
        </trans-unit>
        <trans-unit id="e3589533d63065a42192671f978f7884a00c50eb" translate="yes" xml:space="preserve">
          <source>The reducers may handle this action by toggling an &lt;code&gt;isFetching&lt;/code&gt; flag in the state. This way the UI knows it's time to show a spinner.</source>
          <target state="translated">Редукторы могут обрабатывать это действие, переключая флаг &lt;code&gt;isFetching&lt;/code&gt; в состоянии. Таким образом пользовательский интерфейс знает, что пора показать счетчик.</target>
        </trans-unit>
        <trans-unit id="fb415aec3abf5f69e7a7dbc95599da2a8b59bb09" translate="yes" xml:space="preserve">
          <source>The remove function could also be implemented as:</source>
          <target state="translated">Функция удаления также может быть реализована как:</target>
        </trans-unit>
        <trans-unit id="34eee3e75bb47e88848e238f22d63bbf7668e6ee" translate="yes" xml:space="preserve">
          <source>The request contains information about the URL requested, including any query parameters, which will be useful when using something like &lt;a href=&quot;https://github.com/reactjs/react-router&quot;&gt;React Router&lt;/a&gt;. It can also contain headers with inputs like cookies or authorization, or POST body data. Let's see how we can set the initial counter state based on a query parameter.</source>
          <target state="translated">Запрос содержит информацию о запрошенном URL, включая любые параметры запроса, которые будут полезны при использовании чего-то вроде &lt;a href=&quot;https://github.com/reactjs/react-router&quot;&gt;React Router&lt;/a&gt; . Он также может содержать заголовки с входными данными, такими как файлы cookie или авторизация, или данные тела POST. Давайте посмотрим, как мы можем установить начальное состояние счетчика на основе параметра запроса.</target>
        </trans-unit>
        <trans-unit id="cb8346bc09abdc2bdbbd4e730bada908b5a84b2e" translate="yes" xml:space="preserve">
          <source>The resulting reducer calls every child reducer, and gathers their results into a single state object. &lt;strong&gt;The shape of the state object matches the keys of the passed &lt;code&gt;reducers&lt;/code&gt;&lt;/strong&gt;.</source>
          <target state="translated">Результирующий редуктор вызывает каждый дочерний редуктор и собирает их результаты в один объект состояния. &lt;strong&gt;Форма объекта состояния соответствует ключам переданных &lt;code&gt;reducers&lt;/code&gt; &lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="bebc73dea03ed82f283ad8c04dfdcbf094d7911a" translate="yes" xml:space="preserve">
          <source>The resulting reducer calls every child reducer, and gathers their results into a single state object. &lt;strong&gt;The state produced by &lt;code&gt;combineReducers()&lt;/code&gt; namespaces the states of each reducer under their keys as passed to &lt;code&gt;combineReducers()&lt;/code&gt;&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="191b4037dec326d03a76e5e3d99a324826c75a29" translate="yes" xml:space="preserve">
          <source>The shallow check of &lt;code&gt;param&lt;/code&gt; and &lt;code&gt;returnValue&lt;/code&gt; simply checks whether both variables reference the same object, which they do.&lt;code&gt;mutateObj()&lt;/code&gt; may return a mutated version of &lt;code&gt;obj&lt;/code&gt;, but it's still the same object as that passed in. The fact that its values have been changed within &lt;code&gt;mutateObj&lt;/code&gt; matters not at all to a shallow check.</source>
          <target state="translated">Неглубокая проверка &lt;code&gt;param&lt;/code&gt; и &lt;code&gt;returnValue&lt;/code&gt; просто проверяет, ссылаются ли обе переменные на один и тот же объект, что они и делают. &lt;code&gt;mutateObj()&lt;/code&gt; может возвращать измененную версию &lt;code&gt;obj&lt;/code&gt; , но это все тот же объект, что и переданный. Тот факт, что его значения были изменены в &lt;code&gt;mutateObj&lt;/code&gt; ,вообще не имеет значения для поверхностной проверки.</target>
        </trans-unit>
        <trans-unit id="bc6715934729123df24e127a2b31fa31c6f3d1d9" translate="yes" xml:space="preserve">
          <source>The simplest and most common way to do this is to add the &lt;a href=&quot;https://github.com/gaearon/redux-thunk&quot;&gt;Redux Thunk&lt;/a&gt; middleware that lets you write action creators with more complex and asynchronous logic. Another widely-used method is &lt;a href=&quot;https://github.com/yelouafi/redux-saga&quot;&gt;Redux Saga&lt;/a&gt; which lets you write more synchronous-looking code using generators, and can act like &amp;ldquo;background threads&amp;rdquo; or &amp;ldquo;daemons&amp;rdquo; in a Redux app. Yet another approach is &lt;a href=&quot;https://github.com/raisemarketplace/redux-loop&quot;&gt;Redux Loop&lt;/a&gt;, which inverts the process by allowing your reducers to declare side effects in response to state changes and have them executed separately. Beyond that, there are &lt;em&gt;many&lt;/em&gt; other community-developed libraries and ideas, each with their own take on how side effects should be managed.</source>
          <target state="translated">Самый простой и наиболее распространенный способ сделать это - добавить промежуточное ПО &lt;a href=&quot;https://github.com/gaearon/redux-thunk&quot;&gt;Redux Thunk,&lt;/a&gt; которое позволяет вам писать создателей действий с более сложной и асинхронной логикой. Другой широко используемый метод - &lt;a href=&quot;https://github.com/yelouafi/redux-saga&quot;&gt;Redux Saga,&lt;/a&gt; который позволяет писать более синхронно выглядящий код с помощью генераторов и может действовать как &amp;laquo;фоновые потоки&amp;raquo; или &amp;laquo;демоны&amp;raquo; в приложении Redux. Еще один подход - &lt;a href=&quot;https://github.com/raisemarketplace/redux-loop&quot;&gt;Redux Loop&lt;/a&gt; , который инвертирует процесс, позволяя вашим редукторам объявлять побочные эффекты в ответ на изменения состояния и выполнять их отдельно. Помимо этого, существует &lt;em&gt;множество&lt;/em&gt; других библиотек и идей, разработанных сообществом, каждая со своим собственным подходом к управлению побочными эффектами.</target>
        </trans-unit>
        <trans-unit id="a1ef44d7beed8bc507d7e3d3fa102d8a5af7a998" translate="yes" xml:space="preserve">
          <source>The simplest example of middleware is &lt;a href=&quot;https://github.com/gaearon/redux-thunk&quot;&gt;redux-thunk&lt;/a&gt;. &lt;strong&gt;&amp;ldquo;Thunk&amp;rdquo; middleware lets you write action creators as &amp;ldquo;thunks&amp;rdquo;, that is, functions returning functions.&lt;/strong&gt; This inverts the control: you will get &lt;code&gt;dispatch&lt;/code&gt; as an argument, so you can write an action creator that dispatches many times.</source>
          <target state="translated">Самый простой пример промежуточного программного обеспечения - это &lt;a href=&quot;https://github.com/gaearon/redux-thunk&quot;&gt;redux-thunk&lt;/a&gt; . &lt;strong&gt;Промежуточное ПО &amp;laquo;Thunk&amp;raquo; позволяет писать создателей действий как &amp;laquo;преобразователи&amp;raquo;, то есть функции, возвращающие функции. &lt;/strong&gt;Это инвертирует управление: вы получите &lt;code&gt;dispatch&lt;/code&gt; в качестве аргумента, так что вы можете написать создателя действия, который отправляет много раз.</target>
        </trans-unit>
        <trans-unit id="a224c5bb5c7b0257b4abc9573a41ae755e11d225" translate="yes" xml:space="preserve">
          <source>The simplest possible approach to writing reducer logic is to put everything into a single function declaration, like this:</source>
          <target state="translated">Самый простой подход к написанию логики редуктора заключается в том,чтобы поместить все в одно функциональное объявление,подобное этому:</target>
        </trans-unit>
        <trans-unit id="df00019572e1d526628ee1357601871796c2e3aa" translate="yes" xml:space="preserve">
          <source>The state is already immutable, and mutations are already described as discrete actions, which is close to the undo stack mental model.</source>
          <target state="translated">Состояние уже является непреложным,а мутации уже описаны как дискретные действия,близкие к ментальной модели стека отката.</target>
        </trans-unit>
        <trans-unit id="4e2a0df854ac3a6ba67f8bf8af131bbbadf64b8c" translate="yes" xml:space="preserve">
          <source>The store will still be updated with the new values for the root state, but because the root state object itself is still the same object, libraries that bind to Redux, such as React-Redux, will not be aware of the state&amp;rsquo;s mutation, and so will not trigger a wrapped component&amp;rsquo;s re-rendering.</source>
          <target state="translated">Хранилище по-прежнему будет обновляться новыми значениями для корневого состояния, но поскольку сам объект корневого состояния остается тем же самым объектом, библиотеки, которые связываются с Redux, такие как React-Redux, не будут знать о мутации состояния, и поэтому не вызовет повторный рендеринг обернутого компонента.</target>
        </trans-unit>
        <trans-unit id="4f3016ca7583094ba4738ed1d27a81993f9cabc7" translate="yes" xml:space="preserve">
          <source>The store's reducing function will be called with the current &lt;a href=&quot;#getState&quot;&gt;&lt;code&gt;getState()&lt;/code&gt;&lt;/a&gt; result and the given &lt;code&gt;action&lt;/code&gt; synchronously. Its return value will be considered the next state. It will be returned from &lt;a href=&quot;#getState&quot;&gt;&lt;code&gt;getState()&lt;/code&gt;&lt;/a&gt; from now on, and the change listeners will immediately be notified.</source>
          <target state="translated">Функция уменьшения хранилища будет вызываться синхронно с текущим результатом &lt;a href=&quot;#getState&quot;&gt; &lt;code&gt;getState()&lt;/code&gt; &lt;/a&gt; и заданным &lt;code&gt;action&lt;/code&gt; . Его возвращаемое значение будет считаться следующим состоянием. С этого &lt;a href=&quot;#getState&quot;&gt; &lt;code&gt;getState()&lt;/code&gt; &lt;/a&gt; он будет возвращаться из getState () , и слушатели изменений будут немедленно уведомлены.</target>
        </trans-unit>
        <trans-unit id="cea20ac25d592424eac6b0baa84b4cb2827c5999" translate="yes" xml:space="preserve">
          <source>The sub-app approach is also useful for large teams that are divided by product or feature verticals. These teams can ship sub-apps independently or in combination with an enclosing &amp;ldquo;app shell&amp;rdquo;.</source>
          <target state="translated">Подход с использованием дополнительных приложений также полезен для больших команд, которые разделены по вертикали продуктов или функций. Эти команды могут поставлять субприложения независимо или в сочетании с прилагаемой &amp;laquo;оболочкой приложения&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="375db8357be87b44ec99ec266964bcb0566ca944" translate="yes" xml:space="preserve">
          <source>The subscriptions are snapshotted just before every &lt;a href=&quot;#dispatch&quot;&gt;&lt;code&gt;dispatch()&lt;/code&gt;&lt;/a&gt; call. If you subscribe or unsubscribe while the listeners are being invoked, this will not have any effect on the &lt;a href=&quot;#dispatch&quot;&gt;&lt;code&gt;dispatch()&lt;/code&gt;&lt;/a&gt; that is currently in progress. However, the next &lt;a href=&quot;#dispatch&quot;&gt;&lt;code&gt;dispatch()&lt;/code&gt;&lt;/a&gt; call, whether nested or not, will use a more recent snapshot of the subscription list.</source>
          <target state="translated">Моментальные снимки подписок создаются непосредственно перед каждым вызовом метода &lt;a href=&quot;#dispatch&quot;&gt; &lt;code&gt;dispatch()&lt;/code&gt; &lt;/a&gt; . Если вы подписываетесь или отказываетесь от подписки во время вызова слушателей, это не повлияет на выполняемую в данный момент &lt;a href=&quot;#dispatch&quot;&gt; &lt;code&gt;dispatch()&lt;/code&gt; &lt;/a&gt; . Однако следующий вызов &lt;a href=&quot;#dispatch&quot;&gt; &lt;code&gt;dispatch()&lt;/code&gt; &lt;/a&gt; , вложенный или нет, будет использовать более свежий снимок списка подписок.</target>
        </trans-unit>
        <trans-unit id="80feb06d33ae82b791c73d4ad38cfd11b702fe4b" translate="yes" xml:space="preserve">
          <source>The subscriptions are snapshotted just before every &lt;a href=&quot;#dispatchaction&quot;&gt;&lt;code&gt;dispatch()&lt;/code&gt;&lt;/a&gt; call. If you subscribe or unsubscribe while the listeners are being invoked, this will not have any effect on the &lt;a href=&quot;#dispatchaction&quot;&gt;&lt;code&gt;dispatch()&lt;/code&gt;&lt;/a&gt; that is currently in progress. However, the next &lt;a href=&quot;#dispatchaction&quot;&gt;&lt;code&gt;dispatch()&lt;/code&gt;&lt;/a&gt; call, whether nested or not, will use a more recent snapshot of the subscription list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3fcb31aa94b0e76b32e4908a5de1c115f3b15a7" translate="yes" xml:space="preserve">
          <source>The suggested structure for a Redux store is to split the state object into multiple &amp;ldquo;slices&amp;rdquo; or &amp;ldquo;domains&amp;rdquo; by key, and provide a separate reducer function to manage each individual data slice. This is similar to how the standard Flux pattern has multiple independent stores, and Redux provides the &lt;a href=&quot;../api/combinereducers&quot;&gt;&lt;code&gt;combineReducers&lt;/code&gt;&lt;/a&gt; utility function to make this pattern easier. However, it's important to note that &lt;code&gt;combineReducers&lt;/code&gt; is &lt;em&gt;not&lt;/em&gt; required&amp;mdash;it is simply a utility function for the common use case of having a single reducer function per state slice, with plain JavaScript objects for the data.</source>
          <target state="translated">Предлагаемая структура для хранилища Redux состоит в том, чтобы разделить объект состояния на несколько &amp;laquo;фрагментов&amp;raquo; или &amp;laquo;доменов&amp;raquo; по ​​ключу и предоставить отдельную функцию редуктора для управления каждым отдельным фрагментом данных. Это похоже на то, как стандартный шаблон Flux имеет несколько независимых хранилищ, а Redux предоставляет служебную функцию &lt;a href=&quot;../api/combinereducers&quot;&gt; &lt;code&gt;combineReducers&lt;/code&gt; &lt;/a&gt; чтобы упростить этот шаблон. Тем не менее, важно отметить , что &lt;code&gt;combineReducers&lt;/code&gt; является &lt;em&gt;не&lt;/em&gt; требуется, это просто функция полезности для общего пользования случае наличия одной функции редуктора каждого состояния ломтика, с объектами равнины JavaScript для данных.</target>
        </trans-unit>
        <trans-unit id="19890ee5401ad9b13da13113d9a0a8f02936561b" translate="yes" xml:space="preserve">
          <source>The term &quot;&lt;em&gt;sub-reducer&lt;/em&gt;&quot; has also been used in various discussions to mean any function that is not the root reducer, although the term is not very precise. Some people may also refer to some functions as &quot;&lt;em&gt;business logic&lt;/em&gt;&quot; (functions that relate to application-specific behavior) or &quot;&lt;em&gt;utility functions&lt;/em&gt;&quot; (generic functions that are not application-specific).</source>
          <target state="translated">Термин &amp;laquo; &lt;em&gt;суб-редуктор&lt;/em&gt; &amp;raquo; также использовался в различных обсуждениях для обозначения любой функции, которая не является корневым редуктором, хотя этот термин не очень точен. Некоторые люди могут также называть некоторые функции &amp;laquo; &lt;em&gt;бизнес-логикой&lt;/em&gt; &amp;raquo; (функции, относящиеся к поведению, зависящим от приложения) или &amp;laquo; &lt;em&gt;служебными функциями&lt;/em&gt; &amp;raquo; (общие функции, не зависящие от приложения).</target>
        </trans-unit>
        <trans-unit id="4efb799026840b45f617b41420282694075bcbb5" translate="yes" xml:space="preserve">
          <source>The two most common ways to specialize a reducer are to generate new action constants with a given prefix or suffix, or to attach additional info inside the action object. Here's what those might look like:</source>
          <target state="translated">Два наиболее распространенных способа специализации редуктора-генерация новых констант действия с заданным префиксом или суффиксом,либо прикрепление дополнительной информации внутри объекта действия.Вот как это может выглядеть:</target>
        </trans-unit>
        <trans-unit id="8244d8d3077f561bcd0f5377b25ede16bd17a723" translate="yes" xml:space="preserve">
          <source>The whole state of your app is stored in an object tree inside a single &lt;em&gt;store&lt;/em&gt;.</source>
          <target state="translated">Все состояние вашего приложения хранится в дереве объектов внутри одного &lt;em&gt;хранилища&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="b55a43c532a7c8e9947bf52f67dd941ff93ac2e5" translate="yes" xml:space="preserve">
          <source>The work done by Redux generally falls into a few areas: processing actions in middleware and reducers (including object duplication for immutable updates), notifying subscribers after actions are dispatched, and updating UI components based on the state changes. While it's certainly &lt;em&gt;possible&lt;/em&gt; for each of these to become a performance concern in sufficiently complex situations, there's nothing inherently slow or inefficient about how Redux is implemented. In fact, React Redux in particular is heavily optimized to cut down on unnecessary re-renders, and React-Redux v5 shows noticeable improvements over earlier versions.</source>
          <target state="translated">Работа, выполняемая Redux, обычно делится на несколько областей: обработка действий в промежуточном программном обеспечении и редукторах (включая дублирование объектов для неизменяемых обновлений), уведомление подписчиков после отправки действий и обновление компонентов пользовательского интерфейса на основе изменений состояния. Хотя каждый из них , безусловно, &lt;em&gt;может&lt;/em&gt; стать проблемой для производительности в достаточно сложных ситуациях, нет ничего медленного или неэффективного в том, как реализован Redux. Фактически, React Redux, в частности, сильно оптимизирован для сокращения ненужных повторных рендеров, а React-Redux v5 демонстрирует заметные улучшения по сравнению с более ранними версиями.</target>
        </trans-unit>
        <trans-unit id="e621bbd33e777ec7ef3871509510242d1781c64a" translate="yes" xml:space="preserve">
          <source>The work on Redux was &lt;a href=&quot;https://www.patreon.com/reactdx&quot;&gt;funded by the community&lt;/a&gt;.</source>
          <target state="translated">Работа над Redux &lt;a href=&quot;https://www.patreon.com/reactdx&quot;&gt;финансировалась сообществом&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0e58a6fbd2c7776a43fa3f20f5482c786c5abf51" translate="yes" xml:space="preserve">
          <source>Then your reducer might look like this:</source>
          <target state="translated">Тогда твой редуктор может выглядеть вот так:</target>
        </trans-unit>
        <trans-unit id="b0b64fceb751659a715e3ef58186964669c75267" translate="yes" xml:space="preserve">
          <source>Then, add this to &lt;code&gt;scripts&lt;/code&gt; in your &lt;code&gt;package.json&lt;/code&gt;:</source>
          <target state="translated">Затем добавьте это в &lt;code&gt;scripts&lt;/code&gt; в &lt;code&gt;package.json&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="2304d640a16ae9bfebc931161006126d186e787e" translate="yes" xml:space="preserve">
          <source>Then:</source>
          <target state="translated">Then:</target>
        </trans-unit>
        <trans-unit id="e96f86541d1773854c7bcc0e179868209a9a8589" translate="yes" xml:space="preserve">
          <source>There are a few important bits here:</source>
          <target state="translated">Здесь есть несколько важных кусочков:</target>
        </trans-unit>
        <trans-unit id="5d06a233fcb86cede2504f1d8109e3efa70aa46c" translate="yes" xml:space="preserve">
          <source>There are a number of community packages that implement various approaches for storing per-component state in a Redux store instead, such as &lt;a href=&quot;https://github.com/tonyhb/redux-ui&quot;&gt;redux-ui&lt;/a&gt;, &lt;a href=&quot;https://github.com/tomchentw/redux-component&quot;&gt;redux-component&lt;/a&gt;, &lt;a href=&quot;https://github.com/threepointone/redux-react-local&quot;&gt;redux-react-local&lt;/a&gt;, and more. It's also possible to apply Redux's principles and concept of reducers to the task of updating local component state as well, along the lines of &lt;code&gt;this.setState( (previousState) =&amp;gt; reducer(previousState, someAction))&lt;/code&gt;.</source>
          <target state="translated">Существует ряд пакетов сообщества, которые реализуют различные подходы для хранения состояния каждого компонента в хранилище Redux, такие как &lt;a href=&quot;https://github.com/tonyhb/redux-ui&quot;&gt;redux-ui&lt;/a&gt; , &lt;a href=&quot;https://github.com/tomchentw/redux-component&quot;&gt;redux-component&lt;/a&gt; , &lt;a href=&quot;https://github.com/threepointone/redux-react-local&quot;&gt;redux-react-local&lt;/a&gt; и другие. Также возможно применить принципы Redux и концепцию редукторов к задаче обновления состояния локального компонента, в соответствии со строками &lt;code&gt;this.setState( (previousState) =&amp;gt; reducer(previousState, someAction))&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0014d11cb95b6c4884244108322b1ff44ccf44a1" translate="yes" xml:space="preserve">
          <source>There are also utility libraries to aid in generating action creators, such as &lt;a href=&quot;https://github.com/pauldijou/redux-act&quot;&gt;redux-act&lt;/a&gt; and &lt;a href=&quot;https://github.com/acdlite/redux-actions&quot;&gt;redux-actions&lt;/a&gt;. These can help reduce boilerplate code and enforce adherence to standards such as &lt;a href=&quot;https://github.com/acdlite/flux-standard-action&quot;&gt;Flux Standard Action (FSA)&lt;/a&gt;.</source>
          <target state="translated">Существуют также служебные библиотеки для помощи в создании создателей действий, таких как &lt;a href=&quot;https://github.com/pauldijou/redux-act&quot;&gt;redux-act&lt;/a&gt; и &lt;a href=&quot;https://github.com/acdlite/redux-actions&quot;&gt;redux-actions&lt;/a&gt; . Это может помочь сократить шаблонный код и обеспечить соблюдение таких стандартов, как &lt;a href=&quot;https://github.com/acdlite/flux-standard-action&quot;&gt;Flux Standard Action (FSA)&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6d7c3fb839d1de9f174190d1095682848236da15" translate="yes" xml:space="preserve">
          <source>There are frameworks claiming to be similar to Flux, but without a concept of action objects. In terms of being predictable, this is a step backwards from Flux or Redux. If there are no serializable plain object actions, it is impossible to record and replay user sessions, or to implement &lt;a href=&quot;https://www.youtube.com/watch?v=xsSnOQynTHs&quot;&gt;hot reloading with time travel&lt;/a&gt;. If you'd rather modify data directly, you don't need Redux.</source>
          <target state="translated">Есть фреймворки, утверждающие, что они похожи на Flux, но без концепции объектов действий. С точки зрения предсказуемости это шаг назад от Flux или Redux. Если нет сериализуемых действий простого объекта, невозможно записать и воспроизвести пользовательские сеансы или реализовать &lt;a href=&quot;https://www.youtube.com/watch?v=xsSnOQynTHs&quot;&gt;горячую перезагрузку с путешествием во времени&lt;/a&gt; . Если вы предпочитаете напрямую изменять данные, Redux вам не понадобится.</target>
        </trans-unit>
        <trans-unit id="cfa801b0cb8664a9ae599fb04c53df6ce12bf658" translate="yes" xml:space="preserve">
          <source>There are no multiple models&amp;mdash;just a state subtree that you want to keep track of.</source>
          <target state="translated">Не существует множественных моделей - только поддерево состояний, которое вы хотите отслеживать.</target>
        </trans-unit>
        <trans-unit id="420577e78b88dd5a407cd7bcfca83fee052024be" translate="yes" xml:space="preserve">
          <source>There are several important ideas to be aware of when using &lt;code&gt;combineReducers&lt;/code&gt;:</source>
          <target state="translated">При использовании &lt;code&gt;combineReducers&lt;/code&gt; следует помнить о нескольких важных моментах :</target>
        </trans-unit>
        <trans-unit id="31dadb8b332eafb541ac48d1ad1b0591872b1ba8" translate="yes" xml:space="preserve">
          <source>There are some simple tweaks that can be made to this reducer. First, repeated &lt;code&gt;if&lt;/code&gt;/&lt;code&gt;else&lt;/code&gt; statements quickly grow tiresome, so it's very common to use &lt;code&gt;switch&lt;/code&gt; statements instead. Second, we can use ES6's default parameter values to handle the initial &quot;no existing data&quot; case. With those changes, the reducer would look like:</source>
          <target state="translated">Есть несколько простых настроек, которые можно внести в этот редуктор. Во-первых, повторяющиеся операторы &lt;code&gt;if&lt;/code&gt; / &lt;code&gt;else&lt;/code&gt; быстро утомляют, поэтому вместо них очень часто используются операторы &lt;code&gt;switch&lt;/code&gt; . Во-вторых, мы можем использовать значения параметров ES6 по умолчанию для обработки начального случая &amp;laquo;нет существующих данных&amp;raquo;. С этими изменениями редуктор будет выглядеть так:</target>
        </trans-unit>
        <trans-unit id="a0306be0f55c35417f1fb94a7a6a33b60158cc20" translate="yes" xml:space="preserve">
          <source>There are two main ways to initialize state for your application. The &lt;code&gt;createStore&lt;/code&gt; method can accept an optional &lt;code&gt;preloadedState&lt;/code&gt; value as its second argument. Reducers can also specify an initial value by looking for an incoming state argument that is &lt;code&gt;undefined&lt;/code&gt;, and returning the value they'd like to use as a default. This can either be done with an explicit check inside the reducer, or by using the ES6 default argument value syntax: &lt;code&gt;function myReducer(state = someDefaultValue, action)&lt;/code&gt;.</source>
          <target state="translated">Есть два основных способа инициализировать состояние вашего приложения. &lt;code&gt;createStore&lt;/code&gt; метод может принимать необязательный &lt;code&gt;preloadedState&lt;/code&gt; значение в качестве второго аргумента. Редукторы также могут указывать начальное значение, ища аргумент входящего состояния, который не &lt;code&gt;undefined&lt;/code&gt; , и возвращая значение, которое они хотели бы использовать по умолчанию. Это можно сделать либо с помощью явной проверки внутри редуктора, либо с помощью синтаксиса значения аргумента по умолчанию ES6: &lt;code&gt;function myReducer(state = someDefaultValue, action)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="597620fe64267cbabf96711d555ec9adca761b24" translate="yes" xml:space="preserve">
          <source>There are two ways to define the initial shape and contents of your store's state. First, the &lt;code&gt;createStore&lt;/code&gt; function can take &lt;code&gt;preloadedState&lt;/code&gt; as its second argument. This is primarily intended for initializing the store with state that was previously persisted elsewhere, such as the browser's localStorage. The other way is for the root reducer to return the initial state value when the state argument is &lt;code&gt;undefined&lt;/code&gt;. These two approaches are described in more detail in &lt;a href=&quot;initializingstate&quot;&gt;Initializing State&lt;/a&gt;, but there are some additional concerns to be aware of when using &lt;code&gt;combineReducers&lt;/code&gt;.</source>
          <target state="translated">Есть два способа определить начальную форму и содержимое состояния вашего магазина. Во- первых, &lt;code&gt;createStore&lt;/code&gt; функция может принимать &lt;code&gt;preloadedState&lt;/code&gt; в качестве второго аргумента. Это в первую очередь предназначено для инициализации хранилища с состоянием, которое ранее сохранялось в другом месте, например в localStorage браузера. Другой способ заключается в том, чтобы корневой редуктор возвращал значение начального состояния, когда аргумент состояния не &lt;code&gt;undefined&lt;/code&gt; . Эти два подхода более подробно описаны в &lt;a href=&quot;initializingstate&quot;&gt;разделе &amp;laquo;Состояние инициализации&amp;raquo;&lt;/a&gt; , но есть некоторые дополнительные проблемы, о которых следует помнить при использовании &lt;code&gt;combineReducers&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="56409b9a5183b19808817fe73374f07883b83a73" translate="yes" xml:space="preserve">
          <source>There is an important gotcha: you need to remember to append &lt;code&gt;.present&lt;/code&gt; to the current state when you retrieve it. You may also check &lt;code&gt;.past.length&lt;/code&gt; and &lt;code&gt;.future.length&lt;/code&gt; to determine whether to enable or to disable the Undo and Redo buttons, respectively.</source>
          <target state="translated">Есть важная проблема: вам нужно не забыть добавить &lt;code&gt;.present&lt;/code&gt; к текущему состоянию, когда вы его извлекаете. Вы также можете проверить &lt;code&gt;.past.length&lt;/code&gt; и &lt;code&gt;.future.length&lt;/code&gt; , чтобы определить, включать или отключать кнопки Undo и Redo соответственно.</target>
        </trans-unit>
        <trans-unit id="f5f4b92d40c5193a89ef2d973b4dea0cf41db580" translate="yes" xml:space="preserve">
          <source>There is no &amp;ldquo;right&amp;rdquo; answer for this. Some users prefer to keep every single piece of data in Redux, to maintain a fully serializable and controlled version of their application at all times. Others prefer to keep non-critical or UI state, such as &amp;ldquo;is this dropdown currently open&amp;rdquo;, inside a component's internal state.</source>
          <target state="translated">На это нет &amp;laquo;правильного&amp;raquo; ответа. Некоторые пользователи предпочитают хранить все данные в Redux, чтобы всегда поддерживать полностью сериализуемую и контролируемую версию своего приложения. Другие предпочитают сохранять некритическое состояние или состояние пользовательского интерфейса, например &amp;laquo;открыт ли этот раскрывающийся список&amp;raquo;, внутри внутреннего состояния компонента.</target>
        </trans-unit>
        <trans-unit id="90170588b4fa6d7f622136b2c7f8e6e07e225db6" translate="yes" xml:space="preserve">
          <source>There should only be a single store in a Redux app, as the composition happens on the reducer level.</source>
          <target state="translated">В приложении Redux должен быть только один магазин,так как композиция происходит на уровне редуктора.</target>
        </trans-unit>
        <trans-unit id="992aa1eaaf62b5438b3953fb40feec345ca3edf1" translate="yes" xml:space="preserve">
          <source>There should only be a single store in your app.</source>
          <target state="translated">В вашем приложении должен быть только один магазин.</target>
        </trans-unit>
        <trans-unit id="168b0114042369684de79c5fdf6b3e093b40d171" translate="yes" xml:space="preserve">
          <source>There will &lt;em&gt;rarely&lt;/em&gt; be a 1-to-1 correspondence between your UI tree and your state shape. The exception to that might be if you are explicitly tracking various aspects of UI data in your Redux store as well, but even then the shape of the UI data and the shape of the domain data would likely be different.</source>
          <target state="translated">Там будет &lt;em&gt;редко&lt;/em&gt; быть соответствие 1-к-1 между деревом UI и вашей государственной формой. Исключением может быть ситуация, когда вы явно отслеживаете различные аспекты данных пользовательского интерфейса в своем хранилище Redux, но даже тогда форма данных пользовательского интерфейса и форма данных домена, вероятно, будут другими.</target>
        </trans-unit>
        <trans-unit id="f1d2ef296166ce0ecc73c05efc95f385ad2e7495" translate="yes" xml:space="preserve">
          <source>There's a couple ways Redux-ORM can be used to perform updates. First, the Redux-ORM docs suggest defining reducer functions on each Model subclass, then including the auto-generated combined reducer function into your store:</source>
          <target state="translated">Есть пара способов использования Redux-ORM для выполнения обновлений.Сначала в документах Redux-ORM предлагается определить функции редуктора для каждого подкласса Модели,а затем включить в ваш магазин автоматически генерируемую комбинированную функцию редуктора:</target>
        </trans-unit>
        <trans-unit id="51018a56e34b691dd014441eabce29bdbcbc8652" translate="yes" xml:space="preserve">
          <source>There's no single clear answer to exactly what pieces of logic should go in a reducer or an action creator. Some developers prefer to have &amp;ldquo;fat&amp;rdquo; action creators, with &amp;ldquo;thin&amp;rdquo; reducers that simply take the data in an action and blindly merge it into the corresponding state. Others try to emphasize keeping actions as small as possible, and minimize the usage of &lt;code&gt;getState()&lt;/code&gt; in an action creator. (For purposes of this question, other async approaches such as sagas and observables fall in the &quot;action creator&quot; category.)</source>
          <target state="translated">Нет однозначного ответа на вопрос, какие именно элементы логики должны входить в редьюсер или создатель действий. Некоторые разработчики предпочитают иметь &amp;laquo;толстых&amp;raquo; создателей действий с &amp;laquo;тонкими&amp;raquo; редукторами, которые просто берут данные в действии и слепо объединяют их в соответствующее состояние. Другие пытаются сделать акцент на минимальном возможном размере &lt;code&gt;getState()&lt;/code&gt; и минимизировать использование getState () в создателе действий. (Для целей этого вопроса другие асинхронные подходы, такие как саги и наблюдаемые объекты, относятся к категории &amp;laquo;создателей действий&amp;raquo;.)</target>
        </trans-unit>
        <trans-unit id="28edc5708a2301951ec09979956f382164d459ec" translate="yes" xml:space="preserve">
          <source>There's no specific rule for how you should structure your actions. Using an async middleware like Redux Thunk certainly enables scenarios such as dispatching multiple distinct but related actions in a row, dispatching actions to represent progression of an AJAX request, dispatching actions conditionally based on state, or even dispatching an action and checking the updated state immediately afterwards.</source>
          <target state="translated">Нет конкретного правила,как вы должны структурировать свои действия.Использование асинхронного промежуточного программного обеспечения,такого как Redux Thunk,безусловно,позволяет использовать такие сценарии,как отправка нескольких различных,но связанных между собой действий подряд,отправка действий,представляющих собой прогрессирование AJAX-запроса,отправка действий в зависимости от состояния,или даже отправка действия и проверка обновленного состояния сразу же после этого.</target>
        </trans-unit>
        <trans-unit id="3919f394ea7f45a742af3ee7c733b38c93a6700c" translate="yes" xml:space="preserve">
          <source>These &lt;code&gt;&amp;lt;SubApp&amp;gt;&lt;/code&gt;s will be completely independent. They won't share data or actions, and won't see or communicate with each other.</source>
          <target state="translated">Эти &lt;code&gt;&amp;lt;SubApp&amp;gt;&lt;/code&gt; будут полностью независимыми. Они не будут делиться данными или действиями, не будут видеть или общаться друг с другом.</target>
        </trans-unit>
        <trans-unit id="7403f67d70c46d230048ba2241787084beea6a95" translate="yes" xml:space="preserve">
          <source>These are all normal React components, so we won't examine them in detail. We write functional stateless components unless we need to use local state or the lifecycle methods. This doesn't mean that presentational components &lt;em&gt;have to&lt;/em&gt; be functions&amp;mdash;it's just easier to define them this way. If and when you need to add local state, lifecycle methods, or performance optimizations, you can convert them to classes.</source>
          <target state="translated">Все это обычные компоненты React, поэтому мы не будем их подробно рассматривать. Мы пишем функциональные компоненты без состояния, если нам не нужно использовать локальное состояние или методы жизненного цикла. Это не означает, что презентационные компоненты &lt;em&gt;должны&lt;/em&gt; быть функциями - просто так их проще определить. Если и когда вам нужно добавить локальное состояние, методы жизненного цикла или оптимизацию производительности, вы можете преобразовать их в классы.</target>
        </trans-unit>
        <trans-unit id="ad42b9f4f6a7ded866b5edd040dee5736736ad79" translate="yes" xml:space="preserve">
          <source>These are some use cases and code snippets to get you started with Redux in a real app. They assume you understand the topics in &lt;a href=&quot;../basics/index&quot;&gt;basic&lt;/a&gt; and &lt;a href=&quot;../advanced/index&quot;&gt;advanced&lt;/a&gt; tutorials.</source>
          <target state="translated">Это несколько вариантов использования и фрагменты кода, которые помогут вам начать работу с Redux в реальном приложении. Они предполагают, что вы разбираетесь в темах &lt;a href=&quot;../basics/index&quot;&gt;базовых&lt;/a&gt; и &lt;a href=&quot;../advanced/index&quot;&gt;расширенных&lt;/a&gt; руководств.</target>
        </trans-unit>
        <trans-unit id="d704feeae1991cd907524cb1c0f7f6fcf0575629" translate="yes" xml:space="preserve">
          <source>These are the basics of the React Redux API, but there are a few shortcuts and power options so we encourage you to check out &lt;a href=&quot;https://github.com/reactjs/react-redux&quot;&gt;its documentation&lt;/a&gt; in detail. In case you are worried about &lt;code&gt;mapStateToProps&lt;/code&gt; creating new objects too often, you might want to learn about &lt;a href=&quot;../recipes/computingderiveddata&quot;&gt;computing derived data&lt;/a&gt; with &lt;a href=&quot;https://github.com/reactjs/reselect&quot;&gt;reselect&lt;/a&gt;.</source>
          <target state="translated">Это основы React Redux API, но есть несколько ярлыков и параметров питания, поэтому мы рекомендуем вам подробно ознакомиться с &lt;a href=&quot;https://github.com/reactjs/react-redux&quot;&gt;его документацией&lt;/a&gt; . Если вы беспокоитесь о том, что &lt;code&gt;mapStateToProps&lt;/code&gt; слишком часто создает новые объекты, вы можете узнать о &lt;a href=&quot;../recipes/computingderiveddata&quot;&gt;вычислении производных данных&lt;/a&gt; с &lt;a href=&quot;https://github.com/reactjs/reselect&quot;&gt;повторным выбором&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4c26d64685238ce4dbcec18d03116138fa0bb9a0" translate="yes" xml:space="preserve">
          <source>These basic patterns allow you to do things like having multiple instances of a smart connected component within the UI, or reuse common logic for generic capabilities such as pagination or sorting.</source>
          <target state="translated">Эти базовые шаблоны позволяют вам делать такие вещи,как наличие нескольких экземпляров интеллектуально подключенных компонентов в пользовательском интерфейсе или повторное использование общей логики для общих возможностей,таких как разбивка по страницам или сортировка.</target>
        </trans-unit>
        <trans-unit id="c558d4ebff40066937cf4fb4becc7cf460cf85d8" translate="yes" xml:space="preserve">
          <source>These new functions would typically fall into one of three categories:</source>
          <target state="translated">Эти новые функции,как правило,относятся к одной из трех категорий:</target>
        </trans-unit>
        <trans-unit id="84e2759c050a4d6ddff70ba97270b913483ea299" translate="yes" xml:space="preserve">
          <source>These were the actions governed by the user interaction. We will also have another kind of action, governed by the network requests. We will see how to dispatch them later, but for now, we just want to define them.</source>
          <target state="translated">Это были действия,регулируемые взаимодействием пользователей.Мы также будем иметь другой вид действий,регулируемых сетевыми запросами.Мы посмотрим,как их отправить позже,а пока просто хотим их определить.</target>
        </trans-unit>
        <trans-unit id="734284615f4837016bf49d7e82571425d6842e5d" translate="yes" xml:space="preserve">
          <source>They can also press a &amp;ldquo;refresh&amp;rdquo; button to update it:</source>
          <target state="translated">Они также могут нажать кнопку &amp;laquo;Обновить&amp;raquo;, чтобы обновить его:</target>
        </trans-unit>
        <trans-unit id="0d52a5e55f55bac64300f695ab9f42bb206bbca5" translate="yes" xml:space="preserve">
          <source>They can provide a useful alternative to writing manual immutable update logic.</source>
          <target state="translated">Они могут стать полезной альтернативой написанию логики обновления в ручном режиме.</target>
        </trans-unit>
        <trans-unit id="19c5827cb1612ac05aed827f421dec6e57380bb2" translate="yes" xml:space="preserve">
          <source>They describe the &lt;em&gt;look&lt;/em&gt; but don't know &lt;em&gt;where&lt;/em&gt; the data comes from, or &lt;em&gt;how&lt;/em&gt; to change it. They only render what's given to them. If you migrate from Redux to something else, you'll be able to keep all these components exactly the same. They have no dependency on Redux.</source>
          <target state="translated">Они описывают &lt;em&gt;внешний вид,&lt;/em&gt; но не знают, &lt;em&gt;откуда&lt;/em&gt; берутся данные и &lt;em&gt;как&lt;/em&gt; их изменить. Они воспроизводят только то, что им дано. Если вы перейдете с Redux на что-то еще, вы сможете сохранить все эти компоненты одинаковыми. Они не зависят от Redux.</target>
        </trans-unit>
        <trans-unit id="b1159323b5c6aa9389a4540485a8db710c7036ca" translate="yes" xml:space="preserve">
          <source>Think of an action as a very brief snippet of news. &amp;ldquo;Mary liked article 42.&amp;rdquo; or &amp;ldquo;&amp;lsquo;Read the Redux docs.' was added to the list of todos.&amp;rdquo;</source>
          <target state="translated">Думайте о действии как о очень коротком отрывке новостей. &amp;laquo;Мэри понравилась статья 42&amp;raquo;. или &amp;laquo;Прочтите документацию Redux&amp;raquo;. был добавлен в список задач &amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="b4665b478e044391de06bdde9d3e79d16edd37cb" translate="yes" xml:space="preserve">
          <source>Thinking in terms of state and state shape</source>
          <target state="translated">Мышление с точки зрения состояния и формы государства</target>
        </trans-unit>
        <trans-unit id="91e52043da589de141b602e3e454bd09930f4ace" translate="yes" xml:space="preserve">
          <source>This API is intended as a low-level primitive with no dependencies or complications, and can be used to build higher-level subscription logic. UI bindings such as React Redux can create a subscription for each connected component. It is also possible to write functions that can intelligently compare the old state vs the new state, and execute additional logic if certain pieces have changed. Examples include &lt;a href=&quot;https://github.com/jprichardson/redux-watch&quot;&gt;redux-watch&lt;/a&gt;, &lt;a href=&quot;https://github.com/ashaffer/redux-subscribe&quot;&gt;redux-subscribe&lt;/a&gt; and &lt;a href=&quot;https://github.com/ivantsov/redux-subscriber&quot;&gt;redux-subscriber&lt;/a&gt; which offer different approaches to specifying subscriptions and handling changes.</source>
          <target state="translated">Этот API задуман как низкоуровневый примитив без зависимостей или сложностей и может использоваться для построения логики подписки более высокого уровня. Привязки пользовательского интерфейса, такие как React Redux, могут создавать подписку для каждого подключенного компонента. Также возможно написать функции, которые могут разумно сравнивать старое состояние с новым состоянием и выполнять дополнительную логику, если некоторые части изменились. Примеры включают &lt;a href=&quot;https://github.com/jprichardson/redux-watch&quot;&gt;redux-watch&lt;/a&gt; , &lt;a href=&quot;https://github.com/ashaffer/redux-subscribe&quot;&gt;redux-subscribe&lt;/a&gt; и &lt;a href=&quot;https://github.com/ivantsov/redux-subscriber&quot;&gt;redux-subscriber,&lt;/a&gt; которые предлагают разные подходы к определению подписок и обработке изменений.</target>
        </trans-unit>
        <trans-unit id="b5bc9835804c7bf5d69285a0788d4ec1618aaf13" translate="yes" xml:space="preserve">
          <source>This allows you to gradually rewrite every Flux Store in your app as a reducer, but still export &lt;code&gt;createFluxStore(reducer)&lt;/code&gt; so the rest of your app is not aware that this is happening and sees the Flux stores.</source>
          <target state="translated">Это позволяет вам постепенно переписывать каждое хранилище Flux в вашем приложении в качестве редуктора, но при этом экспортировать &lt;code&gt;createFluxStore(reducer)&lt;/code&gt; чтобы остальная часть вашего приложения не знала, что это происходит, и видела хранилища Flux.</target>
        </trans-unit>
        <trans-unit id="a519a41d84a5c9b747a85285b24fa851ba29b4a3" translate="yes" xml:space="preserve">
          <source>This approach makes it very clear what's happening for the &lt;code&gt;&quot;ADD_COMMENTS&quot;&lt;/code&gt; case, but it does require nested updating logic, and some specific knowledge of the state tree shape. Depending on how you want to compose your reducer logic, this may or may not be desired.</source>
          <target state="translated">Этот подход очень ясно показывает, что происходит в случае &lt;code&gt;&quot;ADD_COMMENTS&quot;&lt;/code&gt; , но он требует вложенной логики обновления и некоторых конкретных знаний о форме дерева состояний. В зависимости от того, как вы хотите составить логику редуктора, это может быть, а может и не быть желательным.</target>
        </trans-unit>
        <trans-unit id="e5b98104ccad15391aa66227a6551d8fc9f45bc0" translate="yes" xml:space="preserve">
          <source>This architecture might seem like an overkill for a counter app, but the beauty of this pattern is how well it scales to large and complex apps. It also enables very powerful developer tools, because it is possible to trace every mutation to the action that caused it. You can record user sessions and reproduce them just by replaying every action.</source>
          <target state="translated">Такая архитектура может показаться излишеством для встречного приложения,но красота этого шаблона в том,насколько хорошо он масштабируется до больших и сложных приложений.Она также позволяет использовать очень мощные инструменты для разработчиков,потому что можно отследить каждую мутацию до того действия,которое ее вызвало.Вы можете записывать пользовательские сессии и воспроизводить их,просто переигрывая каждое действие.</target>
        </trans-unit>
        <trans-unit id="af9a7125c23f1d9f99cfc569936c1de486169781" translate="yes" xml:space="preserve">
          <source>This article is divided into an in-depth intro to help you grok the concept, and &lt;a href=&quot;#seven-examples&quot;&gt;a few practical examples&lt;/a&gt; to show the power of middleware at the very end. You may find it helpful to switch back and forth between them, as you flip between feeling bored and inspired.</source>
          <target state="translated">Эта статья разделена на углубленное введение, которое поможет вам разобраться в концепции, и &lt;a href=&quot;#seven-examples&quot;&gt;несколько практических примеров,&lt;/a&gt; демонстрирующих возможности промежуточного программного обеспечения в самом конце. Возможно, вам будет полезно переключаться между ними, когда вы переключаетесь между чувством скуки и вдохновением.</target>
        </trans-unit>
        <trans-unit id="8cbc20dacc9ba008323bf48c00c65d6371405cdd" translate="yes" xml:space="preserve">
          <source>This assumes you are using &lt;a href=&quot;https://www.npmjs.com/&quot;&gt;npm&lt;/a&gt; as your package manager.</source>
          <target state="translated">Предполагается, что вы используете &lt;a href=&quot;https://www.npmjs.com/&quot;&gt;npm в&lt;/a&gt; качестве диспетчера пакетов.</target>
        </trans-unit>
        <trans-unit id="36abb8e476a11a68638ccf33afca7adf0759ffbc" translate="yes" xml:space="preserve">
          <source>This can be prevented by using &lt;code&gt;toJS()&lt;/code&gt; in a Higher Order Component, as discussed in the &lt;a href=&quot;#immutable-js-best-practices&quot;&gt;Best Practices section&lt;/a&gt; below.</source>
          <target state="translated">Этого можно избежать, используя &lt;code&gt;toJS()&lt;/code&gt; в компоненте более высокого порядка, как описано в разделе &amp;laquo; &lt;a href=&quot;#immutable-js-best-practices&quot;&gt;Лучшие практики&amp;raquo;&lt;/a&gt; ниже.</target>
        </trans-unit>
        <trans-unit id="80afa0a6f3a3ec186233802f8708789e06fce0fb" translate="yes" xml:space="preserve">
          <source>This chain of middleware is defined by the arguments passed to the &lt;code&gt;applyMiddleware&lt;/code&gt; function used when creating a store. Defining multiple chains will not work correctly, as they would have distinctly different &lt;code&gt;dispatch&lt;/code&gt; references and the different chains would effectively be disconnected.</source>
          <target state="translated">Эта цепочка промежуточного программного обеспечения определяется аргументами, переданными в функцию &lt;code&gt;applyMiddleware&lt;/code&gt; , используемую при создании хранилища. Определение нескольких цепочек не будет работать правильно, поскольку они будут иметь явно разные ссылки на &lt;code&gt;dispatch&lt;/code&gt; и разные цепочки будут фактически отключены.</target>
        </trans-unit>
        <trans-unit id="e1fe353295b682382d86ef4ed3fc4f643382d4c5" translate="yes" xml:space="preserve">
          <source>This comment sums up the dichotomy nicely:</source>
          <target state="translated">Этот комментарий прекрасно подводит итог дихотомии:</target>
        </trans-unit>
        <trans-unit id="324ca41cb1e96cbdc6d22ac4f0dc0ea7baff76ab" translate="yes" xml:space="preserve">
          <source>This complexity is difficult to handle as &lt;strong&gt;we're mixing two concepts&lt;/strong&gt; that are very hard for the human mind to reason about: &lt;strong&gt;mutation and asynchronicity.&lt;/strong&gt; I call them &lt;a href=&quot;https://en.wikipedia.org/wiki/Diet_Coke_and_Mentos_eruption&quot;&gt;Mentos and Coke&lt;/a&gt;. Both can be great in separation, but together they create a mess. Libraries like &lt;a href=&quot;http://facebook.github.io/react&quot;&gt;React&lt;/a&gt; attempt to solve this problem in the view layer by removing both asynchrony and direct DOM manipulation. However, managing the state of your data is left up to you. This is where Redux enters.</source>
          <target state="translated">С этой сложностью трудно справиться, поскольку &lt;strong&gt;мы смешиваем два понятия,&lt;/strong&gt; о которых человеческому разуму очень трудно рассуждать: &lt;strong&gt;мутация и асинхронность. &lt;/strong&gt;Я называю их &lt;a href=&quot;https://en.wikipedia.org/wiki/Diet_Coke_and_Mentos_eruption&quot;&gt;Mentos и Coke&lt;/a&gt; . Оба могут быть хороши в разлуке, но вместе они создают беспорядок. Такие библиотеки, как &lt;a href=&quot;http://facebook.github.io/react&quot;&gt;React,&lt;/a&gt; пытаются решить эту проблему на уровне представления, удаляя как асинхронность, так и прямые манипуляции с DOM. Однако управление состоянием ваших данных остается на ваше усмотрение. Вот где появляется Redux.</target>
        </trans-unit>
        <trans-unit id="bed55034327edcc9ff177976049dde9f1a8518bf" translate="yes" xml:space="preserve">
          <source>This could be expanded in a number of ways. For example, an application that does a lot of editing of entities might want to keep two sets of &quot;tables&quot; in the state, one for the &quot;current&quot; item values and one for the &quot;work-in-progress&quot; item values. When an item is edited, its values could be copied into the &quot;work-in-progress&quot; section, and any actions that update it would be applied to the &quot;work-in-progress&quot; copy, allowing the editing form to be controlled by that set of data while another part of the UI still refers to the original version. &quot;Resetting&quot; the edit form would simply require removing the item from the &quot;work-in-progress&quot; section and re-copying the original data from &quot;current&quot; to &quot;work-in-progress&quot;, while &quot;applying&quot; the edits would involve copying the values from the &quot;work-in-progress&quot; section to the &quot;current&quot; section.</source>
          <target state="translated">Это может быть расширено различными способами.Например,приложение,которое много редактирует сущности,может захотеть сохранить в состоянии два набора &quot;таблиц&quot;,один для &quot;текущих&quot; значений элементов,а другой-для &quot;незавершенных&quot;.При редактировании элемента его значения могут быть скопированы в раздел &quot;work-in-progress&quot;,а любые действия по его обновлению будут применены к копии &quot;work-in-progress&quot;,что позволит управлять формой редактирования этим набором данных,в то время как другая часть пользовательского интерфейса все равно будет ссылаться на исходную версию.&quot;Сброс&quot; формы редактирования потребовал бы просто удаления элемента из раздела &quot;незавершенное производство&quot; и повторного копирования исходных данных из &quot;текущей&quot; в &quot;незавершенное производство&quot;,в то время как &quot;применение&quot; редакций потребовало бы копирования значений из раздела &quot;незавершенное производство&quot; в &quot;текущую&quot; секцию.</target>
        </trans-unit>
        <trans-unit id="707c74a21f1746d2a960832a6b8a8cb90405d2f5" translate="yes" xml:space="preserve">
          <source>This ensures that neither the views nor the network callbacks will ever write directly to the state. Instead, they express an intent to transform the state. Because all changes are centralized and happen one by one in a strict order, there are no subtle race conditions to watch out for. As actions are just plain objects, they can be logged, serialized, stored, and later replayed for debugging or testing purposes.</source>
          <target state="translated">Это гарантирует,что ни просмотры,ни сетевые обратные вызовы никогда не будут записываться непосредственно в состояние.Вместо этого они выражают намерение преобразовать государство.Поскольку все изменения централизованы и происходят один за другим в строгом порядке,нет никаких тонких расовых условий,на которые следует обращать внимание.Так как действия являются обычными объектами,они могут регистрироваться,сериализоваться,храниться,а затем воспроизводиться в целях отладки или тестирования.</target>
        </trans-unit>
        <trans-unit id="9210dbb4de5b40a1c13ddea412dbce790a6977d8" translate="yes" xml:space="preserve">
          <source>This example demonstrates how to use &lt;code&gt;compose&lt;/code&gt; to enhance a &lt;a href=&quot;store&quot;&gt;store&lt;/a&gt; with &lt;a href=&quot;applymiddleware&quot;&gt;&lt;code&gt;applyMiddleware&lt;/code&gt;&lt;/a&gt; and a few developer tools from the &lt;a href=&quot;https://github.com/gaearon/redux-devtools&quot;&gt;redux-devtools&lt;/a&gt; package.</source>
          <target state="translated">В этом примере показано, как использовать &lt;code&gt;compose&lt;/code&gt; для улучшения &lt;a href=&quot;store&quot;&gt;магазина&lt;/a&gt; с помощью &lt;a href=&quot;applymiddleware&quot;&gt; &lt;code&gt;applyMiddleware&lt;/code&gt; &lt;/a&gt; и нескольких инструментов разработчика из пакета &lt;a href=&quot;https://github.com/gaearon/redux-devtools&quot;&gt;redux-devtools&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="370e39616b24bac8573bee9b7a0a5bf7ef9116fb" translate="yes" xml:space="preserve">
          <source>This example demonstrates how to use &lt;code&gt;compose&lt;/code&gt; to enhance a &lt;a href=&quot;store&quot;&gt;store&lt;/a&gt; with &lt;a href=&quot;applymiddleware&quot;&gt;&lt;code&gt;applyMiddleware&lt;/code&gt;&lt;/a&gt; and a few developer tools from the &lt;a href=&quot;https://github.com/reduxjs/redux-devtools&quot;&gt;redux-devtools&lt;/a&gt; package.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6a4f9f87221d4ef2187fb40a3e81e24b1380c59" translate="yes" xml:space="preserve">
          <source>This example demonstrates rendering a deeply nested tree view and representing its state in a normalized form so it is easy to update from reducers. Good rendering performance is achieved by the container components granularly subscribing only to the tree nodes that they render.</source>
          <target state="translated">Этот пример демонстрирует отрисовку глубоко вложенного вида дерева и представление его состояния в нормализованном виде,чтобы его можно было легко обновить из редукторов.Хорошая производительность рендеринга достигается за счет гранулярной подписки компонентов контейнера только на вершины дерева,которые они рендерируют.</target>
        </trans-unit>
        <trans-unit id="23160794e888b31513354f69f0e10e67f1dfbb27" translate="yes" xml:space="preserve">
          <source>This example includes reading from an asynchronous API, fetching data in response to user input, showing loading indicators, caching the response, and invalidating the cache. It uses &lt;a href=&quot;https://github.com/gaearon/redux-thunk&quot;&gt;Redux Thunk&lt;/a&gt; middleware to encapsulate asynchronous side effects.</source>
          <target state="translated">Этот пример включает чтение из асинхронного API, выборку данных в ответ на ввод пользователя, отображение индикаторов загрузки, кэширование ответа и аннулирование кеша. Он использует промежуточное ПО &lt;a href=&quot;https://github.com/gaearon/redux-thunk&quot;&gt;Redux Thunk&lt;/a&gt; для инкапсуляции асинхронных побочных эффектов.</target>
        </trans-unit>
        <trans-unit id="6057ac5d12f923863450854603485d162d2c570a" translate="yes" xml:space="preserve">
          <source>This example includes tests.</source>
          <target state="translated">Этот пример включает в себя тесты.</target>
        </trans-unit>
        <trans-unit id="41942bb35c722938329a0363bb8f7775d2d0a267" translate="yes" xml:space="preserve">
          <source>This example shows important idiomatic Redux patterns that become important as your app grows. In particular, it shows how to store entities in a normalized way by their IDs, how to compose reducers on several levels, and how to define selectors alongside the reducers so the knowledge about the state shape is encapsulated. It also demonstrates logging with &lt;a href=&quot;https://github.com/fcomb/redux-logger&quot;&gt;Redux Logger&lt;/a&gt; and conditional dispatching of actions with &lt;a href=&quot;https://github.com/gaearon/redux-thunk&quot;&gt;Redux Thunk&lt;/a&gt; middleware.</source>
          <target state="translated">В этом примере показаны важные идиоматические шаблоны Redux, которые становятся важными по мере роста вашего приложения. В частности, он показывает, как хранить сущности нормализованным образом по их идентификаторам, как составлять редукторы на нескольких уровнях и как определять селекторы вместе с редукторами, чтобы информация о форме состояния была инкапсулирована. Он также демонстрирует ведение журнала с помощью &lt;a href=&quot;https://github.com/fcomb/redux-logger&quot;&gt;Redux Logger&lt;/a&gt; и условную отправку действий с &lt;a href=&quot;https://github.com/gaearon/redux-thunk&quot;&gt;помощью&lt;/a&gt; промежуточного программного обеспечения Redux Thunk .</target>
        </trans-unit>
        <trans-unit id="5a2efc02036a88d2c881bcfa8505561b220da980" translate="yes" xml:space="preserve">
          <source>This function does correctly return a shallow copy of the top-level state object, but because the &lt;code&gt;nestedState&lt;/code&gt; variable was still pointing at the existing object, the state was directly mutated.</source>
          <target state="translated">Эта функция правильно возвращает неглубокую копию объекта состояния верхнего уровня, но поскольку переменная &lt;code&gt;nestedState&lt;/code&gt; все еще указывала на существующий объект, состояние было напрямую изменено.</target>
        </trans-unit>
        <trans-unit id="25186369f150cbdf9cc822a9194a9d16061eb99f" translate="yes" xml:space="preserve">
          <source>This function helps you organize your reducers to manage their own slices of state, similar to how you would have different Flux Stores to manage different state. With Redux, there is just one store, but &lt;code&gt;combineReducers&lt;/code&gt; helps you keep the same logical division between reducers.</source>
          <target state="translated">Эта функция помогает вам организовать ваши редукторы для управления их собственными срезами состояния, подобно тому, как у вас были бы разные хранилища Flux для управления различным состоянием. В Redux есть только одно хранилище, но &lt;code&gt;combineReducers&lt;/code&gt; помогает сохранить такое же логическое разделение между редукторами.</target>
        </trans-unit>
        <trans-unit id="1b6fed5d5eb1e62767d1062998c1daeac688f17a" translate="yes" xml:space="preserve">
          <source>This function is mildly opinionated and is skewed towards helping beginners avoid common pitfalls. This is why it attempts to enforce some rules that you don't have to follow if you write the root reducer manually.</source>
          <target state="translated">Эта функция слегка сумасбродна и склонна помочь новичкам избежать распространенных подводных камней.Поэтому она пытается внедрить некоторые правила,которым не нужно следовать,если вы пишете корневой редуктор вручную.</target>
        </trans-unit>
        <trans-unit id="bd18efd9ce822617a56ac05dccc19791483c2b46" translate="yes" xml:space="preserve">
          <source>This has the effect of spreading Immutable.JS across your entire codebase, including potentially your components, where you may prefer not to have such external dependencies. Your entire codebase must know what is, and what is not, an Immutable.JS object. It also makes removing Immutable.JS from your app difficult in the future, should you ever need to.</source>
          <target state="translated">Это приводит к распространению Immutable.JS по всей вашей кодовой базе,включая потенциально ваши компоненты,где вы,возможно,предпочтете не иметь таких внешних зависимостей.Вся ваша кодовая база должна знать,что является,а что нет Immutable.JS объектом.Это также затрудняет удаление Immutable.JS из вашего приложения в будущем,если вам когда-нибудь понадобится.</target>
        </trans-unit>
        <trans-unit id="452cdbd1b5122ca3249e3d165f402ca90ca1b7d3" translate="yes" xml:space="preserve">
          <source>This helper is just a convenience! You can write your own &lt;code&gt;combineReducers&lt;/code&gt; that &lt;a href=&quot;https://github.com/acdlite/reduce-reducers&quot;&gt;works differently&lt;/a&gt;, or even assemble the state object from the child reducers manually and write a root reducing function explicitly, like you would write any other function.</source>
          <target state="translated">Этот помощник - просто удобство! Вы можете написать свои собственные &lt;code&gt;combineReducers&lt;/code&gt; которые &lt;a href=&quot;https://github.com/acdlite/reduce-reducers&quot;&gt;работают по-другому&lt;/a&gt; , или даже вручную собрать объект состояния из дочерних редукторов и явно написать корневую функцию сокращения, как если бы вы написали любую другую функцию.</target>
        </trans-unit>
        <trans-unit id="ebc9476c901cfaf7607621afa617534b0f6a0851" translate="yes" xml:space="preserve">
          <source>This implementation isn't usable because it leaves out three important questions:</source>
          <target state="translated">Эта реализация нецелесообразна,потому что в ней отсутствуют три важных вопроса:</target>
        </trans-unit>
        <trans-unit id="5af3f9d227b391b86b28a8a3163dbc7f9de3e1f6" translate="yes" xml:space="preserve">
          <source>This installs the package that provides the &lt;code&gt;undoable&lt;/code&gt; reducer enhancer.</source>
          <target state="translated">При этом устанавливается пакет, который предоставляет &lt;code&gt;undoable&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="930f0e45185d6f76c2ee37901cdc264e626e46fc" translate="yes" xml:space="preserve">
          <source>This is a basic demonstration of &lt;a href=&quot;../recipes/serverrendering&quot;&gt;server rendering&lt;/a&gt; with Redux and React. It shows how to prepare the initial store state on the server, and pass it down to the client so the client store can boot up from an existing state.</source>
          <target state="translated">Это базовая демонстрация &lt;a href=&quot;../recipes/serverrendering&quot;&gt;серверного рендеринга&lt;/a&gt; с помощью Redux и React. Он показывает, как подготовить начальное состояние хранилища на сервере и передать его клиенту, чтобы клиентское хранилище могло загрузиться из существующего состояния.</target>
        </trans-unit>
        <trans-unit id="b54fe358811791887040e3628c693b0d5817b4bb" translate="yes" xml:space="preserve">
          <source>This is a functional programming utility, and is included in Redux as a convenience.</source>
          <target state="translated">Это функциональная утилита для программирования,которая входит в состав Redux для удобства.</target>
        </trans-unit>
        <trans-unit id="70ffc3c7d398f7588925b4181068f9ae044df7c9" translate="yes" xml:space="preserve">
          <source>This is a functional programming utility, and is included in Redux as a convenience. You might want to use it to apply several &lt;a href=&quot;https://redux.js.org/understanding/thinking-in-redux/glossary#store-enhancer&quot;&gt;store enhancers&lt;/a&gt; in a row.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="902e57be6eebfba5d7e76929983c6c6258e9c271" translate="yes" xml:space="preserve">
          <source>This is a glossary of the core terms in Redux, along with their type signatures. The types are documented using &lt;a href=&quot;http://flowtype.org/docs/quick-reference.html&quot;&gt;Flow notation&lt;/a&gt;.</source>
          <target state="translated">Это глоссарий основных терминов Redux вместе с их типами. Типы документируются с использованием &lt;a href=&quot;http://flowtype.org/docs/quick-reference.html&quot;&gt;нотации потока&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6257b5ee434e5a7cbdec29bbbff466cb0f6850ea" translate="yes" xml:space="preserve">
          <source>This is a long and complex topic, with a wide variety of opinions on how code should be organized and what approaches should be used.</source>
          <target state="translated">Это длинная и сложная тема,с большим разнообразием мнений о том,как должен быть организован код и какие подходы следует использовать.</target>
        </trans-unit>
        <trans-unit id="e6d24f497bb054862fa8e8a2557607b7b064ec7c" translate="yes" xml:space="preserve">
          <source>This is a particular issue if you use &lt;code&gt;toJS()&lt;/code&gt; in a wrapped component&amp;rsquo;s &lt;code&gt;mapStateToProps&lt;/code&gt; function, as React-Redux shallowly compares each value in the returned props object. For example, the value referenced by the &lt;code&gt;todos&lt;/code&gt; prop returned from &lt;code&gt;mapStateToProps&lt;/code&gt; below will always be a different object, and so will fail a shallow equality check.</source>
          <target state="translated">Это особая проблема, если вы используете &lt;code&gt;toJS()&lt;/code&gt; в функции &lt;code&gt;mapStateToProps&lt;/code&gt; обернутого компонента , поскольку React-Redux неглубоко сравнивает каждое значение в возвращаемом объекте props . Например, значение, на которое ссылается &lt;code&gt;mapStateToProps&lt;/code&gt; &lt;code&gt;todos&lt;/code&gt; , возвращаемое из mapStateToProps ниже, всегда будет другим объектом, и поэтому неглубокая проверка равенства не удастся.</target>
        </trans-unit>
        <trans-unit id="cf9d83f291ff6e78c4b43b491bded250a9eb9edd" translate="yes" xml:space="preserve">
          <source>This is a place to share common problems and solutions to them.</source>
          <target state="translated">Это место,где можно поделиться общими проблемами и решениями.</target>
        </trans-unit>
        <trans-unit id="a195446956524ddebe615c6b4dea2d58bc44adbd" translate="yes" xml:space="preserve">
          <source>This is a variation on the previous example. It is almost identical, but additionally shows how wrapping your reducer with &lt;a href=&quot;https://github.com/omnidan/redux-undo&quot;&gt;Redux Undo&lt;/a&gt; lets you add a Undo/Redo functionality to your app with a few lines of code.</source>
          <target state="translated">Это вариант предыдущего примера. Он почти идентичен, но дополнительно показывает, как упаковка вашего редуктора с помощью &lt;a href=&quot;https://github.com/omnidan/redux-undo&quot;&gt;Redux Undo&lt;/a&gt; позволяет вам добавить в приложение функцию Undo / Redo с помощью нескольких строк кода.</target>
        </trans-unit>
        <trans-unit id="0b62f6d500da56c6baedf79190677dba7f4254d1" translate="yes" xml:space="preserve">
          <source>This is all we need to know for now. The particular mechanism to dispatch these actions together with network requests will be discussed later.</source>
          <target state="translated">Пока это все,что нам нужно знать.Конкретный механизм отправки этих действий вместе с сетевыми запросами будет обсужден позже.</target>
        </trans-unit>
        <trans-unit id="eb3caec81383b1f746ae38119a27f33a05999d77" translate="yes" xml:space="preserve">
          <source>This is already closer to what we want! No matter where we dispatch an action, it is guaranteed to be logged. Monkeypatching never feels right, but we can live with this for now.</source>
          <target state="translated">Это уже ближе к тому,чего мы хотим! Независимо от того,куда мы отправляем действие,оно гарантированно регистрируется.Обезьянник никогда не чувствует себя правильно,но мы можем жить с этим пока что.</target>
        </trans-unit>
        <trans-unit id="f9084a2b0e6567c9efcaf4f6cafe694a18afbf28" translate="yes" xml:space="preserve">
          <source>This is already looking good! When the app is larger, we can split the reducers into separate files and keep them completely independent and managing different data domains.</source>
          <target state="translated">Это уже хорошо выглядит! Когда приложение больше,мы можем разделить редукторы на отдельные файлы и держать их полностью независимыми и управлять различными доменами данных.</target>
        </trans-unit>
        <trans-unit id="6e84b6d20c865b455ea1e36d59bd6ef0bdf66609" translate="yes" xml:space="preserve">
          <source>This is basically the whole idea of Redux. Note that we haven&amp;rsquo;t used any Redux APIs. It comes with a few utilities to facilitate this pattern, but the main idea is that you describe how your state is updated over time in response to action objects, and 90% of the code you write is just plain JavaScript, with no use of Redux itself, its APIs, or any magic.</source>
          <target state="translated">В этом, по сути, и вся идея Redux. Обратите внимание, что мы не использовали Redux API. Он поставляется с несколькими утилитами для облегчения этого шаблона, но основная идея заключается в том, что вы описываете, как ваше состояние обновляется с течением времени в ответ на объекты действия, а 90% кода, который вы пишете, представляет собой простой JavaScript, без использования Redux. самого себя, его API или какой-либо магии.</target>
        </trans-unit>
        <trans-unit id="1d949a0761f2189999f3ad52f3288abf9de3a495" translate="yes" xml:space="preserve">
          <source>This is because two variables that reference the same object will &lt;em&gt;always&lt;/em&gt; be equal, regardless of whether the object&amp;rsquo;s values changes or not, as they're both referencing the same object. Thus, the following will always return true:</source>
          <target state="translated">Это связано с тем, что две переменные, которые ссылаются на один и тот же объект, &lt;em&gt;всегда&lt;/em&gt; будут равны, независимо от того, изменяются ли значения объекта или нет, поскольку они обе ссылаются на один и тот же объект. Таким образом, следующее всегда будет возвращать истину:</target>
        </trans-unit>
        <trans-unit id="fc3fc2dfb4922ecd32a6e14514c4b08ea0d0030f" translate="yes" xml:space="preserve">
          <source>This is it! Run &lt;code&gt;npm install&lt;/code&gt; and &lt;code&gt;npm start&lt;/code&gt; in the &lt;a href=&quot;https://github.com/reactjs/redux/tree/master/examples/todos-with-undo&quot;&gt;example folder&lt;/a&gt; and try it out!</source>
          <target state="translated">Это оно! Запустите &lt;code&gt;npm install&lt;/code&gt; и &lt;code&gt;npm start&lt;/code&gt; в &lt;a href=&quot;https://github.com/reactjs/redux/tree/master/examples/todos-with-undo&quot;&gt;папке&lt;/a&gt; с примерами и попробуйте!</target>
        </trans-unit>
        <trans-unit id="7e796128df0ba3814b3885d8d0519693c9b9ad24" translate="yes" xml:space="preserve">
          <source>This is much less typing! If you'd like, you can still have &amp;ldquo;vanilla&amp;rdquo; action creators like &lt;code&gt;loadPostsSuccess&lt;/code&gt; which you'd use from a container &lt;code&gt;loadPosts&lt;/code&gt; action creator.</source>
          <target state="translated">Это гораздо меньше печатать! При желании у вас все еще могут быть &amp;laquo;ванильные&amp;raquo; создатели действий, такие как &lt;code&gt;loadPostsSuccess&lt;/code&gt; , которые вы бы использовали из создателя действий &lt;code&gt;loadPosts&lt;/code&gt; контейнера .</target>
        </trans-unit>
        <trans-unit id="eb9aca90fe801173ceb6b822d63183ddbc28a375" translate="yes" xml:space="preserve">
          <source>This is the basic structure that a typical Redux reducer function uses.</source>
          <target state="translated">Это основная структура,которую использует типичная функция редуктора Redux.</target>
        </trans-unit>
        <trans-unit id="368280f7bdb144d919f7347598b1d6a5599ac6c1" translate="yes" xml:space="preserve">
          <source>This is the best example to get a deeper understanding of how the state updates work together with components in Redux. It shows how reducers can delegate handling actions to other reducers, and how you can use &lt;a href=&quot;https://github.com/reactjs/react-redux&quot;&gt;React Redux&lt;/a&gt; to generate container components from your presentational components.</source>
          <target state="translated">Это лучший пример для более глубокого понимания того, как обновления состояния работают вместе с компонентами в Redux. Он показывает, как редукторы могут делегировать действия по обработке другим редукторам и как вы можете использовать &lt;a href=&quot;https://github.com/reactjs/react-redux&quot;&gt;React Redux&lt;/a&gt; для создания компонентов контейнера из ваших презентационных компонентов.</target>
        </trans-unit>
        <trans-unit id="7c0930eaef048e02ff0d006be39c4d3167f83671" translate="yes" xml:space="preserve">
          <source>This is the classical &lt;a href=&quot;http://todomvc.com/&quot;&gt;TodoMVC&lt;/a&gt; example. It's here for the sake of comparison, but it covers the same points as the Todos example.</source>
          <target state="translated">Это классический пример &lt;a href=&quot;http://todomvc.com/&quot;&gt;TodoMVC&lt;/a&gt; . Он здесь для сравнения, но он охватывает те же вопросы, что и пример Todos.</target>
        </trans-unit>
        <trans-unit id="881a664225fae7f2e081dcac2b6413fc1deac116" translate="yes" xml:space="preserve">
          <source>This is the complete source code of the Reddit headline fetching example we built during the &lt;a href=&quot;index&quot;&gt;advanced tutorial&lt;/a&gt;.</source>
          <target state="translated">Это полный исходный код примера получения заголовка Reddit, который мы создали во время &lt;a href=&quot;index&quot;&gt;расширенного руководства&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b128d306a5e5a953daf8f443d8e01801093f1c92" translate="yes" xml:space="preserve">
          <source>This is the complete source code of the tiny todo app we built during the &lt;a href=&quot;index&quot;&gt;basics tutorial&lt;/a&gt;.</source>
          <target state="translated">Это полный исходный код крошечного приложения для задач, которое мы создали во время &lt;a href=&quot;index&quot;&gt;обучения основам&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="bc3837809c1d7850b463c21cec48fd076bd0bf1f" translate="yes" xml:space="preserve">
          <source>This is the most advanced example. It is dense by design. It covers keeping fetched entities in a normalized cache, implementing a custom middleware for API calls, rendering partially loaded data, pagination, caching responses, displaying error messages, and routing. Additionally, it includes Redux DevTools.</source>
          <target state="translated">Это самый передовой пример.Он плотный по дизайну.Он охватывает хранение извлекаемых сущностей в нормализованном кэше,реализацию пользовательского промежуточного программного обеспечения для вызовов API,отрисовку частично загруженных данных,разбивку по страницам,кэширование ответов,отображение сообщений об ошибках и маршрутизацию.Кроме того,он включает Redux DevTools.</target>
        </trans-unit>
        <trans-unit id="2c30e411c7f43679e4c0b5f0869178bc002c0cf5" translate="yes" xml:space="preserve">
          <source>This is the most basic example of using Redux together with React. For simplicity, it re-renders the React component manually when the store changes. In real projects, you will likely want to use the highly performant &lt;a href=&quot;https://github.com/reactjs/react-redux&quot;&gt;React Redux&lt;/a&gt; bindings instead.</source>
          <target state="translated">Это самый простой пример использования Redux вместе с React. Для простоты он повторно отрисовывает компонент React вручную при изменении хранилища. В реальных проектах вы, вероятно, захотите вместо этого использовать высокопроизводительные привязки &lt;a href=&quot;https://github.com/reactjs/react-redux&quot;&gt;React Redux&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="45b51f5c0e7ff3cf14ba10063daa88c68ff8ff42" translate="yes" xml:space="preserve">
          <source>This is worth emphasising: &lt;em&gt;If the reducers all return the same &lt;code&gt;state&lt;/code&gt; object passed to them, then &lt;code&gt;combineReducers&lt;/code&gt; will return the &lt;em&gt;current&lt;/em&gt; root state object, not the newly updated one.&lt;/em&gt;</source>
          <target state="translated">Это стоит подчеркнуть: &lt;em&gt;если все редукторы возвращают один и тот же объект &lt;code&gt;state&lt;/code&gt; переданный им, то &lt;code&gt;combineReducers&lt;/code&gt; вернет &lt;em&gt;текущий&lt;/em&gt; объект корневого состояния, а не вновь обновленный.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="903f50f13ad03393a3f2547dd8b1848ec4cbcd1e" translate="yes" xml:space="preserve">
          <source>This issue can be avoided by &lt;a href=&quot;https://medium.com/@dtinth/immutable-js-persistent-data-structures-and-structural-sharing-6d163fbd73d2#.z1g1ofrsi&quot;&gt;uncoupling your application logic from your data structures&lt;/a&gt;, as outlined in the &lt;a href=&quot;#immutable-js-best-practices&quot;&gt;best practices section&lt;/a&gt; below.</source>
          <target state="translated">Этой проблемы можно избежать, &lt;a href=&quot;https://medium.com/@dtinth/immutable-js-persistent-data-structures-and-structural-sharing-6d163fbd73d2#.z1g1ofrsi&quot;&gt;отделив логику приложения от структур данных&lt;/a&gt; , как описано в разделе &lt;a href=&quot;#immutable-js-best-practices&quot;&gt;передовых практик&lt;/a&gt; ниже.</target>
        </trans-unit>
        <trans-unit id="584dbd560993face7c721c8a75c7abf6bb57ad23" translate="yes" xml:space="preserve">
          <source>This lets us write more sophisticated async control flow gradually, while the consuming code can stay pretty much the same:</source>
          <target state="translated">Это позволяет нам писать более сложный поток асинхронного управления постепенно,в то время как потребляющий код может остаться практически неизменным:</target>
        </trans-unit>
        <trans-unit id="f2f3d7f982ac8af695c62a8985d12ce4b3081ba8" translate="yes" xml:space="preserve">
          <source>This makes it awkward to interoperate not just with your own code, but also with other libraries, such as lodash or ramda, that expect plain JavaScript objects.</source>
          <target state="translated">Это делает неудобным взаимодействие не только с вашим собственным кодом,но и с другими библиотеками,такими как lodash или ramda,которые ожидают простых JavaScript-объектов.</target>
        </trans-unit>
        <trans-unit id="8150ebb2edf39875f24f4fc61c627e5d2769703b" translate="yes" xml:space="preserve">
          <source>This makes it easier for bundling tools to cut out unneeded modules and reduces the size of your builds.</source>
          <target state="translated">Это облегчает группировку инструментов для вырезания ненужных модулей и уменьшает размер ваших сборок.</target>
        </trans-unit>
        <trans-unit id="cf383b9f03a180ee3b947f3cafa81eed01efef2e" translate="yes" xml:space="preserve">
          <source>This makes it easy to create universal apps, as the state from your server can be serialized and hydrated into the client with no extra coding effort. A single state tree also makes it easier to debug or inspect an application; it also enables you to persist your app's state in development, for a faster development cycle. Some functionality which has been traditionally difficult to implement - Undo/Redo, for example - can suddenly become trivial to implement, if all of your state is stored in a single tree.</source>
          <target state="translated">Это облегчает создание универсальных приложений,так как состояние с вашего сервера может быть сериализовано и гидратировано в клиента без дополнительных усилий по кодированию.Единое дерево состояний также упрощает отладку или осмотр приложения;оно также позволяет сохранить состояние вашего приложения в процессе разработки,для более быстрого цикла разработки.Некоторые функциональные возможности,которые традиционно было трудно реализовать-например,Отмена/Редо-могут внезапно стать тривиальными для реализации,если все ваши состояния хранятся в одном дереве.</target>
        </trans-unit>
        <trans-unit id="a7a113870425edd65d4dff2ca88a4e416744f63a" translate="yes" xml:space="preserve">
          <source>This makes it easy to migrate both to and from Redux.</source>
          <target state="translated">Это облегчает миграцию как в Редукс,так и из него.</target>
        </trans-unit>
        <trans-unit id="6870275e1cdc117fad62310af9bce1130ddad1e5" translate="yes" xml:space="preserve">
          <source>This makes them portable and easy to test.</source>
          <target state="translated">Это делает их портативными и легкими в тестировании.</target>
        </trans-unit>
        <trans-unit id="0117d509de0b7ec1b99dd909691fb32267c2c284" translate="yes" xml:space="preserve">
          <source>This means that all data in an application follows the same lifecycle pattern, making the logic of your app more predictable and easier to understand. It also encourages data normalization, so that you don't end up with multiple, independent copies of the same data that are unaware of one another.</source>
          <target state="translated">Это означает,что все данные в приложении следуют одной и той же схеме жизненного цикла,что делает логику вашего приложения более предсказуемой и легкой для понимания.Это также способствует нормализации данных,чтобы в конечном итоге вы не получили несколько независимых копий одних и тех же данных,которые не знают друг о друге.</target>
        </trans-unit>
        <trans-unit id="f34593a4e623dbcb3f458552c5cd1622e7dfef63" translate="yes" xml:space="preserve">
          <source>This means that implementing Undo and Redo in an MVC application usually forces you to rewrite parts of your application to use a specific data mutation pattern like &lt;a href=&quot;https://en.wikipedia.org/wiki/Command_pattern&quot;&gt;Command&lt;/a&gt;.</source>
          <target state="translated">Это означает, что реализация Undo и Redo в приложении MVC обычно заставляет вас переписывать части вашего приложения для использования определенного шаблона мутации данных, такого как &lt;a href=&quot;https://en.wikipedia.org/wiki/Command_pattern&quot;&gt;Command&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="fc5b85dff1510174b626939c1704dc6629908600" translate="yes" xml:space="preserve">
          <source>This means that we could also write the insert and remove functions like this:</source>
          <target state="translated">Это означает,что мы также можем записывать и удалять такие функции,как эта:</target>
        </trans-unit>
        <trans-unit id="cbde7ae30a809fab338b95f7689a7203a8a17b4d" translate="yes" xml:space="preserve">
          <source>This means you need to access your state with &lt;code&gt;state.todos.present&lt;/code&gt; instead of just &lt;code&gt;state.todos&lt;/code&gt;:</source>
          <target state="translated">Это означает, что вам нужно получить доступ к своему состоянию с помощью &lt;code&gt;state.todos.present&lt;/code&gt; , а не просто &lt;code&gt;state.todos&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="386fbee61a70c4b922b5caaee2907587414b6c05" translate="yes" xml:space="preserve">
          <source>This mutated copy is a &lt;em&gt;separate&lt;/em&gt; object from that passed into the function, and so when it is returned, a shallow check will identify it as being a different object from that passed in, and so will fail.</source>
          <target state="translated">Эта измененная копия является &lt;em&gt;отдельным&lt;/em&gt; объектом от переданного в функцию, поэтому, когда он будет возвращен, неглубокая проверка определит его как объект, отличный от переданного, и поэтому потерпит неудачу.</target>
        </trans-unit>
        <trans-unit id="ca74d22b1244f1a72be0424378b1b4d590fc1e51" translate="yes" xml:space="preserve">
          <source>This new tree is now the next state of your app! Every listener registered with &lt;a href=&quot;../api/store#subscribe&quot;&gt;&lt;code&gt;store.subscribe(listener)&lt;/code&gt;&lt;/a&gt; will now be invoked; listeners may call &lt;a href=&quot;../api/store#getState&quot;&gt;&lt;code&gt;store.getState()&lt;/code&gt;&lt;/a&gt; to get the current state.</source>
          <target state="translated">Это новое дерево теперь является следующим состоянием вашего приложения! Теперь будет вызываться каждый прослушиватель, зарегистрированный в &lt;a href=&quot;../api/store#subscribe&quot;&gt; &lt;code&gt;store.subscribe(listener)&lt;/code&gt; &lt;/a&gt; ; слушатели могут вызвать &lt;a href=&quot;../api/store#getState&quot;&gt; &lt;code&gt;store.getState()&lt;/code&gt; &lt;/a&gt; чтобы получить текущее состояние.</target>
        </trans-unit>
        <trans-unit id="375420430845c3b31d4e0a7e67b9eb12e1e064ee" translate="yes" xml:space="preserve">
          <source>This object is like a &amp;ldquo;model&amp;rdquo; except that there are no setters. This is so that different parts of the code can&amp;rsquo;t change the state arbitrarily, causing hard-to-reproduce bugs.</source>
          <target state="translated">Этот объект похож на &amp;laquo;модель&amp;raquo;, за исключением того, что здесь нет сеттеров. Это сделано для того, чтобы различные части кода не могли произвольно изменять состояние, вызывая трудно воспроизводимые ошибки.</target>
        </trans-unit>
        <trans-unit id="10b96d7bed30bd18afc4040b966809bdd54e8f1c" translate="yes" xml:space="preserve">
          <source>This part is often confusing to beginners, because it is not immediately clear what information describes the state of an asynchronous application, and how to organize it in a single tree.</source>
          <target state="translated">Эта часть часто сбивает с толку новичков,поскольку не сразу понятно,какая информация описывает состояние асинхронного приложения и как его организовать в единое дерево.</target>
        </trans-unit>
        <trans-unit id="726e2aa43c64e8c49eac59a956f48c4350c3da4d" translate="yes" xml:space="preserve">
          <source>This pattern is &lt;em&gt;not&lt;/em&gt; recommended for parts of the same app that share data. However, it can be useful when the bigger app has zero access to the smaller apps' internals, and we'd like to keep the fact that they are implemented with Redux as an implementation detail. Each component instance will have its own store, so they won't &amp;ldquo;know&amp;rdquo; about each other.</source>
          <target state="translated">Этот шаблон &lt;em&gt;не&lt;/em&gt; рекомендуется для частей одного и того же приложения, которые совместно используют данные. Однако это может быть полезно, когда более крупное приложение не имеет доступа к внутреннему устройству более мелких приложений, и мы хотели бы сохранить тот факт, что они реализованы с помощью Redux, как деталь реализации. Каждый экземпляр компонента будет иметь собственное хранилище, поэтому они не будут &amp;laquo;знать&amp;raquo; друг о друге.</target>
        </trans-unit>
        <trans-unit id="4797209ab61d0cba555b0ba999e5df76ff770f2a" translate="yes" xml:space="preserve">
          <source>This problem is caused predominantly by returning a mutated state object from a Redux reducer. With Immutable.JS, this problem simply does not exist, thereby removing a whole class of bugs from your app.</source>
          <target state="translated">Эта проблема вызвана главным образом возвращением объекта с мутированным состоянием из редуктора Redux.С Immutable.JS,эта проблема просто не существует,тем самым удаляя целый класс ошибок из вашего приложения.</target>
        </trans-unit>
        <trans-unit id="faee56a051b54fbdf7c577f45ce201c8fd514250" translate="yes" xml:space="preserve">
          <source>This produces the desired effect, but you wouldn't want to do it every time.</source>
          <target state="translated">Это производит желаемый эффект,но вы не захотите делать это каждый раз.</target>
        </trans-unit>
        <trans-unit id="112bf8b2448707863e70924e561703fd39856861" translate="yes" xml:space="preserve">
          <source>This project adheres to &lt;a href=&quot;http://semver.org/&quot;&gt;Semantic Versioning&lt;/a&gt;.</source>
          <target state="translated">Этот проект придерживается &lt;a href=&quot;http://semver.org/&quot;&gt;семантического управления версиями&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9ca436d5a0e732efb5749020024d046800e0f232" translate="yes" xml:space="preserve">
          <source>This requires the least amount of work on the reducer side, but does require that the action creator potentially do a fair amount of work to organize the data into the correct shape before the action is dispatched. It also doesn't handle trying to delete an item.</source>
          <target state="translated">Это требует наименьшего объема работы со стороны редуктора,но при этом требует от создателя действия потенциально выполнить достаточный объем работы,чтобы систематизировать данные в правильную форму до отправки действия.Он также не обрабатывает попытки удалить элемент.</target>
        </trans-unit>
        <trans-unit id="2e32344333ff16130ad1fc8d8911f91949fab05e" translate="yes" xml:space="preserve">
          <source>This section documents the complete Redux API. Keep in mind that Redux is only concerned with managing the state. In a real app, you'll also want to use UI bindings like &lt;a href=&quot;https://github.com/gaearon/react-redux&quot;&gt;react-redux&lt;/a&gt;.</source>
          <target state="translated">Этот раздел документирует полный API Redux. Имейте в виду, что Redux занимается только управлением состоянием. В реальном приложении вы также захотите использовать привязки пользовательского интерфейса, такие как &lt;a href=&quot;https://github.com/gaearon/react-redux&quot;&gt;response-redux&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8e4e2606978c9371c54128bb24c749164cec9f04" translate="yes" xml:space="preserve">
          <source>This section introduces a hypothetical extension to our app that allows it to support multiple Todo Lists. Please note that a full implementation of this extension requires changes to the reducers, components, actions etc. that aren't directly relevant to the topics discussed and have been omitted for brevity.</source>
          <target state="translated">Этот раздел представляет гипотетическое расширение нашего приложения,которое позволяет ему поддерживать несколько Todo Lists.Пожалуйста,обратите внимание,что полная реализация этого расширения требует внесения изменений в редукторы,компоненты,действия и т.д.,которые не имеют прямого отношения к обсуждаемым темам и были пропущены для краткости.</target>
        </trans-unit>
        <trans-unit id="d91b745838a2d3e64174d93a13b4a7f1adc65cd3" translate="yes" xml:space="preserve">
          <source>This state shape better reflects the data involved, because we took care to set up the keys we passed to &lt;code&gt;combineReducers&lt;/code&gt;.</source>
          <target state="translated">Эта форма состояния лучше отражает задействованные данные, потому что мы позаботились о настройке ключей, которые передали в &lt;code&gt;combineReducers&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="125428949dd664c2936fb5646d4a4a0944ef542f" translate="yes" xml:space="preserve">
          <source>This state structure is much flatter overall. Compared to the original nested format, this is an improvement in several ways:</source>
          <target state="translated">Эта государственная структура в целом гораздо более плоская.По сравнению с исходным вложенным форматом,это является улучшением по нескольким параметрам:</target>
        </trans-unit>
        <trans-unit id="94ba4d7a3e72dccff4a9100d843bda3c33581bff" translate="yes" xml:space="preserve">
          <source>This was all very informative, but can't we just drop a library and use it instead of implementing &lt;code&gt;undoable&lt;/code&gt; ourselves? Sure, we can! Meet &lt;a href=&quot;https://github.com/omnidan/redux-undo&quot;&gt;Redux Undo&lt;/a&gt;, a library that provides simple Undo and Redo functionality for any part of your Redux tree.</source>
          <target state="translated">Все это было очень информативно, но нельзя ли просто отбросить библиотеку и использовать ее вместо того, &lt;code&gt;undoable&lt;/code&gt; самостоятельно реализовать отменяемое действие ? Мы можем точно! Познакомьтесь с &lt;a href=&quot;https://github.com/omnidan/redux-undo&quot;&gt;Redux Undo&lt;/a&gt; , библиотекой, которая предоставляет простые функции Undo и Redo для любой части вашего Redux-дерева.</target>
        </trans-unit>
        <trans-unit id="96ab6b14f2ef0811b01a8fd50008edc6febd0745" translate="yes" xml:space="preserve">
          <source>This wasn't difficult, was it? Redux doesn't provide such a helper function by default because there are many ways to write it. Maybe you want it to automatically convert plain JS objects to Immutable objects to hydrate the server state. Maybe you want to merge the returned state with the current state. There may be different approaches to a &amp;ldquo;catch all&amp;rdquo; handler. All of this depends on the conventions you choose for your team on a specific project.</source>
          <target state="translated">Это было несложно, правда? Redux не предоставляет такую ​​вспомогательную функцию по умолчанию, потому что есть много способов ее написать. Возможно, вы хотите, чтобы он автоматически преобразовывал простые объекты JS в неизменяемые объекты, чтобы гидратировать состояние сервера. Возможно, вы хотите объединить возвращенное состояние с текущим состоянием. К обработчику &amp;laquo;улова всех&amp;raquo; могут быть разные подходы. Все это зависит от соглашений, которые вы выбираете для своей команды над конкретным проектом.</target>
        </trans-unit>
        <trans-unit id="445c1e6f198a1adb4c272f78fb177f8661af0686" translate="yes" xml:space="preserve">
          <source>This way every instance will be independent.</source>
          <target state="translated">Таким образом,каждая инстанция будет независимой.</target>
        </trans-unit>
        <trans-unit id="92e38ef43aaabbe31217e626c55343afb37a1c0f" translate="yes" xml:space="preserve">
          <source>This, together with its performance and rich API for data manipulation, is why Immutable.JS is worth the effort.</source>
          <target state="translated">Вот почему Immutable.JS стоит того,чтобы приложить усилия,в сочетании с его производительностью и богатым API для манипулирования данными.</target>
        </trans-unit>
        <trans-unit id="a60662bb0cf6dca00077914648ad22d8b2ebadfe" translate="yes" xml:space="preserve">
          <source>Three Principles</source>
          <target state="translated">Три принципа</target>
        </trans-unit>
        <trans-unit id="45a585aa3738a0a8dc2ee89ca5d822a00a010018" translate="yes" xml:space="preserve">
          <source>Thunk middleware is just one example of middleware. Middleware is not about &amp;ldquo;letting you dispatch functions&amp;rdquo;. It's about letting you dispatch anything that the particular middleware you use knows how to handle. Thunk middleware adds a specific behavior when you dispatch functions, but it really depends on the middleware you use.</source>
          <target state="translated">Промежуточное ПО Thunk - это лишь один пример промежуточного программного обеспечения. Промежуточное ПО - это не &amp;laquo;возможность диспетчеризации функций&amp;raquo;. Речь идет о том, чтобы позволить вам отправлять все, что конкретное промежуточное ПО, которое вы используете, умеет обрабатывать. Промежуточное ПО Thunk добавляет определенное поведение при отправке функций, но на самом деле оно зависит от используемого промежуточного программного обеспечения.</target>
        </trans-unit>
        <trans-unit id="031dd77e620cd8fc8065335ff0e03be8cb20884f" translate="yes" xml:space="preserve">
          <source>Time-travel debugging requires that reducers be pure functions with no side effects, so that you can correctly jump between different states.</source>
          <target state="translated">Отладка во времени требует,чтобы редукторы были чистыми функциями без побочных эффектов,чтобы вы могли корректно переходить из одного состояния в другое.</target>
        </trans-unit>
        <trans-unit id="4cf1b54b003a59c279d1ba0b615a8a5f3459ca8c" translate="yes" xml:space="preserve">
          <source>Tips</source>
          <target state="translated">Tips</target>
        </trans-unit>
        <trans-unit id="ee1f5ebc6cc52d4f51b113f5097b8455a407c4ed" translate="yes" xml:space="preserve">
          <source>Tips For a Better Redux Architecture: Lessons for Enterprise Scale</source>
          <target state="translated">Советы по лучшей архитектуре Редукса:Уроки для масштаба предприятия</target>
        </trans-unit>
        <trans-unit id="901c769f8e578666848aa3aae81fe0b1028b6236" translate="yes" xml:space="preserve">
          <source>Tips to Handle Authentication in Redux</source>
          <target state="translated">Советы по аутентификации в Redux</target>
        </trans-unit>
        <trans-unit id="e74f240f49222ea150d6391c54e16b213cd2b1cd" translate="yes" xml:space="preserve">
          <source>To apply multiple store enhancers, you may use &lt;a href=&quot;compose&quot;&gt;&lt;code&gt;compose()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Чтобы применить несколько усилителей магазина, вы можете использовать &lt;a href=&quot;compose&quot;&gt; &lt;code&gt;compose()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6e0f538cbe1b062d76f03414cbe7f487e9b2e5a6" translate="yes" xml:space="preserve">
          <source>To avoid these issues, ensure you follow the recommended &lt;a href=&quot;../recipes/reducers/immutableupdatepatterns&quot;&gt;immutable update patterns for ES6&lt;/a&gt;.</source>
          <target state="translated">Чтобы избежать этих проблем, убедитесь, что вы следуете рекомендуемым &lt;a href=&quot;../recipes/reducers/immutableupdatepatterns&quot;&gt;неизменным шаблонам обновления для ES6&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2f92fd6720446a22647fac455b49ebc045cfee8c" translate="yes" xml:space="preserve">
          <source>To change data</source>
          <target state="translated">Для изменения данных</target>
        </trans-unit>
        <trans-unit id="6565dc46b441e1305f44f9389c074e1086ac2ba7" translate="yes" xml:space="preserve">
          <source>To change something in the state, you need to dispatch an action. An action is a plain JavaScript object (notice how we don&amp;rsquo;t introduce any magic?) that describes what happened. Here are a few example actions:</source>
          <target state="translated">Чтобы что-то изменить в состоянии, вам нужно отправить действие. Действие - это простой объект JavaScript (заметьте, мы не вводим никакой магии?), Который описывает, что произошло. Вот несколько примеров действий:</target>
        </trans-unit>
        <trans-unit id="eda24989c78e46dab8c06cd8412d3b18d2d68eab" translate="yes" xml:space="preserve">
          <source>To create it, pass your root &lt;a href=&quot;../glossary#reducer&quot;&gt;reducing function&lt;/a&gt; to &lt;a href=&quot;createstore&quot;&gt;&lt;code&gt;createStore&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Чтобы создать его, передать свой корень &lt;a href=&quot;../glossary#reducer&quot;&gt;восстанавливающий функцию&lt;/a&gt; в &lt;a href=&quot;createstore&quot;&gt; &lt;code&gt;createStore&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ac7a33667ce69790c31c3c6959a00eb15d3762e3" translate="yes" xml:space="preserve">
          <source>To do this, it assumes that the wrapped component is pure; that is, that the component will produce the &lt;a href=&quot;https://github.com/reactjs/react-redux/blob/f4d55840a14601c3a5bdc0c3d741fc5753e87f66/docs/troubleshooting.md#my-views-arent-updating-when-something-changes-outside-of-redux&quot;&gt;same results given the same props and state&lt;/a&gt;.</source>
          <target state="translated">Для этого предполагается, что обернутый компонент чистый; то есть компонент будет давать &lt;a href=&quot;https://github.com/reactjs/react-redux/blob/f4d55840a14601c3a5bdc0c3d741fc5753e87f66/docs/troubleshooting.md#my-views-arent-updating-when-something-changes-outside-of-redux&quot;&gt;одинаковые результаты при тех же свойствах и состоянии&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="29e591a3897c0d0b177067748378b071109328ac" translate="yes" xml:space="preserve">
          <source>To ensure that you may only apply middleware once, it operates on &lt;code&gt;createStore()&lt;/code&gt; rather than on &lt;code&gt;store&lt;/code&gt; itself. Instead of &lt;code&gt;(store, middlewares) =&amp;gt; store&lt;/code&gt;, its signature is &lt;code&gt;(...middlewares) =&amp;gt; (createStore) =&amp;gt; createStore&lt;/code&gt;.</source>
          <target state="translated">Чтобы гарантировать, что вы можете применить промежуточное ПО только один раз, оно работает с &lt;code&gt;createStore()&lt;/code&gt; а не с самим &lt;code&gt;store&lt;/code&gt; . Вместо &lt;code&gt;(store, middlewares) =&amp;gt; store&lt;/code&gt; его подпись: &lt;code&gt;(...middlewares) =&amp;gt; (createStore) =&amp;gt; createStore&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6b6f0480002ee862ea4e286d796db8dca014c865" translate="yes" xml:space="preserve">
          <source>To hide Redux behind a React API, we can wrap it in a special component that initializes the store in the constructor:</source>
          <target state="translated">Чтобы спрятать Redux за React API,мы можем завернуть его в специальный компонент,который инициализирует магазин в конструкторе:</target>
        </trans-unit>
        <trans-unit id="3a523db44ce0192bb638d90e57a1f49df365f204" translate="yes" xml:space="preserve">
          <source>To install the stable version:</source>
          <target state="translated">Для установки стабильной версии:</target>
        </trans-unit>
        <trans-unit id="598097c2e73e4e488253e6050c3375112c094ef7" translate="yes" xml:space="preserve">
          <source>To learn how to describe asynchronous API calls, read the current state inside action creators, perform side effects, or chain them to execute in a sequence, see the examples for &lt;a href=&quot;applymiddleware&quot;&gt;&lt;code&gt;applyMiddleware&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Чтобы узнать, как описывать асинхронные вызовы API, читать текущее состояние внутри создателей действий, выполнять побочные эффекты или &lt;a href=&quot;applymiddleware&quot;&gt; &lt;code&gt;applyMiddleware&lt;/code&gt; &lt;/a&gt; их для выполнения в последовательности, см. Примеры для applyMiddleware .</target>
        </trans-unit>
        <trans-unit id="6ed8cb192b488a31ce6935bdfe7a74665d721d67" translate="yes" xml:space="preserve">
          <source>To log the action and state, you can change it to something like this:</source>
          <target state="translated">Чтобы записать действие и состояние,вы можете изменить его на нечто подобное:</target>
        </trans-unit>
        <trans-unit id="a5f1cce2ba9b1ff85191ae7e2687f49081a21c5b" translate="yes" xml:space="preserve">
          <source>To prevent this from happening, you must &lt;em&gt;always return the state slice object that&amp;rsquo;s passed into a reducer if the reducer does not mutate the state.&lt;/em&gt;</source>
          <target state="translated">Чтобы этого не произошло, вы &lt;em&gt;всегда&lt;/em&gt; должны &lt;em&gt;возвращать объект среза состояния, который передан редуктору, если редуктор не изменяет состояние.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="89ea208e2cc969561f1309636abe373b57da32a9" translate="yes" xml:space="preserve">
          <source>To read data</source>
          <target state="translated">Чтобы прочитать данные</target>
        </trans-unit>
        <trans-unit id="eed3ad29a679d760cf82b7215bd55f2febaeba23" translate="yes" xml:space="preserve">
          <source>To resolve this issue, use a browser extension such as the &lt;a href=&quot;https://chrome.google.com/webstore/detail/immutablejs-object-format/hgldghadipiblonfkkicmgcbbijnpeog&quot;&gt;Immutable.js Object Formatter&lt;/a&gt;, which surfaces your data in Chrome Dev Tools, and hides Immutable.JS&amp;rsquo;s properties when inspecting your data.</source>
          <target state="translated">Чтобы решить эту проблему, используйте расширение браузера, такое как &lt;a href=&quot;https://chrome.google.com/webstore/detail/immutablejs-object-format/hgldghadipiblonfkkicmgcbbijnpeog&quot;&gt;Immutable.js Object Formatter&lt;/a&gt; , которое отображает ваши данные в Chrome Dev Tools и скрывает свойства Immutable.JS при проверке ваших данных.</target>
        </trans-unit>
        <trans-unit id="2401479a503b53af9fbceea514e83457e1c292ef" translate="yes" xml:space="preserve">
          <source>To send the data down to the client, we need to:</source>
          <target state="translated">Чтобы отправить данные клиенту,нам нужно:</target>
        </trans-unit>
        <trans-unit id="2ab24a1445cfb045dd93cf66376dc281c3f5f6bd" translate="yes" xml:space="preserve">
          <source>To specify how the actions transform the state tree, you write pure &lt;em&gt;reducers&lt;/em&gt;.</source>
          <target state="translated">Чтобы указать, как действия преобразуют дерево состояний, вы пишете чистые &lt;em&gt;редукторы&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="50ef1b259d84757adca29f3df1d2d641b6eec11c" translate="yes" xml:space="preserve">
          <source>To sum this up, if you stick to Redux conventions and return the initial state from reducers when they're called with &lt;code&gt;undefined&lt;/code&gt; as the &lt;code&gt;state&lt;/code&gt; argument (the easiest way to implement this is to specify the &lt;code&gt;state&lt;/code&gt; ES6 default argument value), you're going to have a nice useful behavior for combined reducers. &lt;strong&gt;They will prefer the corresponding value in the &lt;code&gt;preloadedState&lt;/code&gt; object you pass to the &lt;code&gt;createStore()&lt;/code&gt; function, but if you didn't pass any, or if the corresponding field is not set, the default &lt;code&gt;state&lt;/code&gt; argument specified by the reducer is chosen instead.&lt;/strong&gt; This approach works well because it provides both initialization and hydration of existing data, but lets individual reducers reset their state if their data was not preserved. Of course you can apply this pattern recursively, as you can use &lt;code&gt;combineReducers()&lt;/code&gt; on many levels, or even compose reducers manually by calling reducers and giving them the relevant part of the state tree.</source>
          <target state="translated">Подводя итог, если вы придерживаетесь соглашений Redux и возвращаете начальное состояние из редукторов, когда они вызываются с &lt;code&gt;undefined&lt;/code&gt; в качестве аргумента &lt;code&gt;state&lt;/code&gt; (самый простой способ реализовать это - указать значение аргумента &lt;code&gt;state&lt;/code&gt; ES6 по умолчанию), вы будет иметь хорошее полезное поведение для комбинированных редукторов. &lt;strong&gt;Они предпочтут соответствующее значение в &lt;code&gt;preloadedState&lt;/code&gt; объекте, переходит к &lt;code&gt;createStore()&lt;/code&gt; функции, но если вы не прошли какие - либо, или если соответствующее поле не задано, по умолчанию &lt;code&gt;state&lt;/code&gt; аргумент задается редуктор выбран вместо этого.&lt;/strong&gt;Этот подход работает хорошо, поскольку он обеспечивает как инициализацию, так и гидратацию существующих данных, но позволяет отдельным редукторам сбрасывать свое состояние, если их данные не были сохранены. Конечно, вы можете применить этот шаблон рекурсивно, так как вы можете использовать &lt;code&gt;combineReducers()&lt;/code&gt; на многих уровнях или даже составлять редукторы вручную, вызывая редукторы и передавая им соответствующую часть дерева состояний.</target>
        </trans-unit>
        <trans-unit id="d8cdb0c4afd8333274d4833966816662659fdba2" translate="yes" xml:space="preserve">
          <source>To test the components we make a &lt;code&gt;setup()&lt;/code&gt; helper that passes the stubbed callbacks as props and renders the component with &lt;a href=&quot;http://airbnb.io/enzyme/docs/api/shallow.html&quot;&gt;shallow rendering&lt;/a&gt;. This lets individual tests assert on whether the callbacks were called when expected.</source>
          <target state="translated">Чтобы протестировать компоненты, мы создаем помощник &lt;code&gt;setup()&lt;/code&gt; который передает заглушенные обратные вызовы как свойства и визуализирует компонент с &lt;a href=&quot;http://airbnb.io/enzyme/docs/api/shallow.html&quot;&gt;неглубокой визуализацией&lt;/a&gt; . Это позволяет отдельным тестам утверждать, были ли обратные вызовы вызваны, когда ожидалось.</target>
        </trans-unit>
        <trans-unit id="511c9087c67a4a067c397c7eec06e3c3e446f664" translate="yes" xml:space="preserve">
          <source>To unsubscribe the change listener, invoke the function returned by &lt;code&gt;subscribe&lt;/code&gt;.</source>
          <target state="translated">Чтобы отменить подписку на слушателя изменений, вызовите функцию, возвращаемую функцией &lt;code&gt;subscribe&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="898034cb5cc5c4fc7410f57fc7be8100ebeae451" translate="yes" xml:space="preserve">
          <source>To use &lt;code&gt;connect()&lt;/code&gt;, you need to define a special function called &lt;code&gt;mapStateToProps&lt;/code&gt; that tells how to transform the current Redux store state into the props you want to pass to a presentational component you are wrapping. For example, &lt;code&gt;VisibleTodoList&lt;/code&gt; needs to calculate &lt;code&gt;todos&lt;/code&gt; to pass to the &lt;code&gt;TodoList&lt;/code&gt;, so we define a function that filters the &lt;code&gt;state.todos&lt;/code&gt; according to the &lt;code&gt;state.visibilityFilter&lt;/code&gt;, and use it in its &lt;code&gt;mapStateToProps&lt;/code&gt;:</source>
          <target state="translated">Чтобы использовать &lt;code&gt;connect()&lt;/code&gt; , вам необходимо определить специальную функцию с именем &lt;code&gt;mapStateToProps&lt;/code&gt; , которая сообщает, как преобразовать текущее состояние хранилища Redux в свойства, которые вы хотите передать в упаковываемый вами презентационный компонент. Например, &lt;code&gt;VisibleTodoList&lt;/code&gt; необходимо вычислить &lt;code&gt;todos&lt;/code&gt; для передачи в &lt;code&gt;TodoList&lt;/code&gt; , поэтому мы определяем функцию, которая фильтрует &lt;code&gt;state.todos&lt;/code&gt; в соответствии с &lt;code&gt;state.visibilityFilter&lt;/code&gt; и используем ее в своем &lt;code&gt;mapStateToProps&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="9b84ac1ca067a403df64cc26ea17e56c8180c71f" translate="yes" xml:space="preserve">
          <source>To use it together with &lt;a href=&quot;http://babeljs.io&quot;&gt;Babel&lt;/a&gt;, you will need to install &lt;code&gt;babel-jest&lt;/code&gt;:</source>
          <target state="translated">Чтобы использовать его вместе с &lt;a href=&quot;http://babeljs.io&quot;&gt;Babel&lt;/a&gt; , вам необходимо установить &lt;code&gt;babel-jest&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="717cd30aec4dd5a323fdb13aff5182c806d12d1b" translate="yes" xml:space="preserve">
          <source>TodoMVC</source>
          <target state="translated">TodoMVC</target>
        </trans-unit>
        <trans-unit id="a4114a83f4c6b03e326fda4a57471ca7c2d9fa96" translate="yes" xml:space="preserve">
          <source>Todos</source>
          <target state="translated">Todos</target>
        </trans-unit>
        <trans-unit id="6426098ad9410ea40ed780712b90e9b1ee4b090c" translate="yes" xml:space="preserve">
          <source>Todos with Undo</source>
          <target state="translated">Тодос с Отменой</target>
        </trans-unit>
        <trans-unit id="11dbf4818429dd1d9ae43c9b6f0078f50d78eca5" translate="yes" xml:space="preserve">
          <source>Top-Level Exports</source>
          <target state="translated">Экспорт высшего уровня</target>
        </trans-unit>
        <trans-unit id="8ad8302d110b05d7e02330dac58628134fdcff02" translate="yes" xml:space="preserve">
          <source>Translations</source>
          <target state="translated">Translations</target>
        </trans-unit>
        <trans-unit id="c579263052bf20f3a459fb334a149d298234c3f6" translate="yes" xml:space="preserve">
          <source>Tree View</source>
          <target state="translated">Вид на дерево</target>
        </trans-unit>
        <trans-unit id="285ec850c11d78bac10f6bfa31b69a37f1b257c9" translate="yes" xml:space="preserve">
          <source>Troubleshooting</source>
          <target state="translated">Troubleshooting</target>
        </trans-unit>
        <trans-unit id="63ae2d8b43c9bd5c5d9a4a0152b1f52dd71f01f5" translate="yes" xml:space="preserve">
          <source>Troubleshooting: My views aren&amp;rsquo;t updating when something changes outside of Redux</source>
          <target state="translated">Устранение неполадок: мои представления не обновляются, когда что-то меняется вне Redux</target>
        </trans-unit>
        <trans-unit id="c5984c35d0b5720f5ededf659b1e4bb94f25efcc" translate="yes" xml:space="preserve">
          <source>Troubleshooting: Never mutate reducer arguments</source>
          <target state="translated">Устранение неполадок:Никогда не мутировать редуктор аргументы</target>
        </trans-unit>
        <trans-unit id="f2569e4c2636e5cc4f4bc61ec91ab96c592717fa" translate="yes" xml:space="preserve">
          <source>Troubleshooting: Nothing happens when I dispatch an action</source>
          <target state="translated">Устранение неполадок:Ничего не происходит,когда я отправляю действие</target>
        </trans-unit>
        <trans-unit id="5c79bb1da81bc4cdf1612625ab31bb11eaf51494" translate="yes" xml:space="preserve">
          <source>Try to avoid dispatching several times synchronously in a row in the places where you're concerned about performance. There are a number of addons and approaches that can batch up dispatches as well.</source>
          <target state="translated">Постарайтесь не отправлять несколько раз подряд синхронно в местах,где вас беспокоит производительность.Существует ряд дополнений и подходов,которые могут также дозировать отправки.</target>
        </trans-unit>
        <trans-unit id="72970471e5d1f5bed9e5c8dccde351d73710853a" translate="yes" xml:space="preserve">
          <source>Turns an object whose values are &lt;a href=&quot;../glossary#action-creator&quot;&gt;action creators&lt;/a&gt;, into an object with the same keys, but with every action creator wrapped into a &lt;a href=&quot;store#dispatch&quot;&gt;&lt;code&gt;dispatch&lt;/code&gt;&lt;/a&gt; call so they may be invoked directly.</source>
          <target state="translated">Превращает объект, значения которого являются &lt;a href=&quot;../glossary#action-creator&quot;&gt;создателями действий&lt;/a&gt; , в объект с теми же ключами, но с каждым создателем действия, заключенным в вызов &lt;a href=&quot;store#dispatch&quot;&gt; &lt;code&gt;dispatch&lt;/code&gt; &lt;/a&gt; чтобы их можно было вызывать напрямую.</target>
        </trans-unit>
        <trans-unit id="8a7b143d4c5f841fa87b3ffa44b1a514a798acb9" translate="yes" xml:space="preserve">
          <source>Turns an object whose values are &lt;a href=&quot;https://redux.js.org/understanding/thinking-in-redux/glossary#action-creator&quot;&gt;action creators&lt;/a&gt;, into an object with the same keys, but with every action creator wrapped into a &lt;a href=&quot;store#dispatchaction&quot;&gt;&lt;code&gt;dispatch&lt;/code&gt;&lt;/a&gt; call so they may be invoked directly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1733ad2a0216b6de85e1fcd35dfdee394e2afa0" translate="yes" xml:space="preserve">
          <source>Tutorials and Articles</source>
          <target state="translated">Учебники и статьи</target>
        </trans-unit>
        <trans-unit id="606fbca55ef1c11f19a4f936a99beb986380cf17" translate="yes" xml:space="preserve">
          <source>Twitter's mobile site</source>
          <target state="translated">мобильный сайт Twitter</target>
        </trans-unit>
        <trans-unit id="9404d68c02ebdd30a4a808a24f9060471b759192" translate="yes" xml:space="preserve">
          <source>Twitter: Don't use Redux unless you're unhappy with local component state</source>
          <target state="translated">Твиттер:Не используйте Redux,если вы недовольны состоянием местных компонентов.</target>
        </trans-unit>
        <trans-unit id="d2affd0dcee2425ca66385d0faf980e7f7ecdf02" translate="yes" xml:space="preserve">
          <source>Twitter: Don't use Redux until...</source>
          <target state="translated">Твиттер:Не используйте Redux,пока...</target>
        </trans-unit>
        <trans-unit id="d7fb782e77a8b9b4edadf5251f4fd4a2b65f0b1b" translate="yes" xml:space="preserve">
          <source>Twitter: If your reducer looks boring, don't use redux</source>
          <target state="translated">Твиттер:Если ваш редуктор выглядит скучным,не используйте лишние...</target>
        </trans-unit>
        <trans-unit id="ee9af1a3c185fc74743f29130b1e126141719508" translate="yes" xml:space="preserve">
          <source>Twitter: Redux is a platform for developers to build customized state management with reusable things</source>
          <target state="translated">Твиттер:Redux-это платформа для разработчиков,позволяющая создавать настраиваемое управление состоянием с помощью вещей многоразового использования.</target>
        </trans-unit>
        <trans-unit id="c1674978f90c098b4d6e689712105d7a768088c7" translate="yes" xml:space="preserve">
          <source>Twitter: Redux is designed to be predictable, not concise</source>
          <target state="translated">Твиттер:Redux спроектирован так,чтобы быть предсказуемым,а не лаконичным.</target>
        </trans-unit>
        <trans-unit id="6df45452576b437fd3a9fe2fc716cd66dddc4433" translate="yes" xml:space="preserve">
          <source>Twitter: Redux is useful to eliminate deep prop passing</source>
          <target state="translated">Твиттер:Редукс полезен для устранения глубокой прокладки</target>
        </trans-unit>
        <trans-unit id="66661fb38bd97dedfe9248a69ac48fe3658b604e" translate="yes" xml:space="preserve">
          <source>Twitter: Redux scaling</source>
          <target state="translated">Twitter:масштабирование Redux</target>
        </trans-unit>
        <trans-unit id="ecc8be1c9df1cfaf1fb1dfafd8fc3b52bba36bca" translate="yes" xml:space="preserve">
          <source>Twitter: Redux vs MobX benchmark graph - Redux state shape matters</source>
          <target state="translated">Твиттер:Redux против эталонного графика MobX-форма состояния Redux имеет значение</target>
        </trans-unit>
        <trans-unit id="129f727416c8f720bb392b36e9ceac07d9339857" translate="yes" xml:space="preserve">
          <source>Twitter: Should I keep something in React component state?</source>
          <target state="translated">Твиттер:Должен ли я держать что-то в состоянии реактивного компонента?</target>
        </trans-unit>
        <trans-unit id="1951b46de5200e3cec6a0f10d24bc32b95efcec1" translate="yes" xml:space="preserve">
          <source>Twitter: There is no ultimate file structure for Redux</source>
          <target state="translated">Твиттер:Нет окончательной файловой структуры для Redux</target>
        </trans-unit>
        <trans-unit id="a5ab467d2f0669472526a676c4046e4696c17a6a" translate="yes" xml:space="preserve">
          <source>Twitter: Using a reducer to update a component</source>
          <target state="translated">Твиттер:Использование редуктора для обновления компонента</target>
        </trans-unit>
        <trans-unit id="cd42d6934051561b9a42541c428d37e9a49eefd7" translate="yes" xml:space="preserve">
          <source>Twitter: You don't need Redux if your data never changes</source>
          <target state="translated">Твиттер:Вам не нужен Redux,если ваши данные никогда не меняются.</target>
        </trans-unit>
        <trans-unit id="65143436c2a655126e87e9283def5be8f1f1d3d7" translate="yes" xml:space="preserve">
          <source>Twitter: common misconception - deep cloning</source>
          <target state="translated">Твиттер:распространенное заблуждение-глубокое клонирование</target>
        </trans-unit>
        <trans-unit id="f7449ca3dc33732cd2745f1868991eecc95eeb34" translate="yes" xml:space="preserve">
          <source>Twitter: emphasizing &amp;ldquo;one container&amp;rdquo; was a mistake</source>
          <target state="translated">Twitter: акцент на &amp;laquo;один контейнер&amp;raquo; был ошибкой</target>
        </trans-unit>
        <trans-unit id="94f434b5b79b7481ac06603cc2fe9a2a75efff91" translate="yes" xml:space="preserve">
          <source>Twitter: most common Redux misconception</source>
          <target state="translated">Твиттер:наиболее распространенное заблуждение Redux</target>
        </trans-unit>
        <trans-unit id="dec8b9c8b688102b7c98c2e00ef8f8e810be3a8d" translate="yes" xml:space="preserve">
          <source>Twitter: possible comparison between sagas, loops, and other approaches</source>
          <target state="translated">Twitter:возможное сравнение между сагами,петлями и другими подходами.</target>
        </trans-unit>
        <trans-unit id="eb2d03183352dc0e1406c06a363bec69ab899d18" translate="yes" xml:space="preserve">
          <source>Twitter: state shape should be normalized</source>
          <target state="translated">Твиттер:форма состояния должна быть нормализована</target>
        </trans-unit>
        <trans-unit id="0fc31910b305d54661578ccc6703279eccabacfc" translate="yes" xml:space="preserve">
          <source>Understanding Middleware</source>
          <target state="translated">Понимание промежуточного программного обеспечения</target>
        </trans-unit>
        <trans-unit id="aa44a604eeec984741a16fa1f77345805911c705" translate="yes" xml:space="preserve">
          <source>Understanding Programmatic Side-Effects</source>
          <target state="translated">Понимание программных побочных эффектов</target>
        </trans-unit>
        <trans-unit id="5f8aabc2d6ab53ecb7bf65fd5b21232c2d632dbb" translate="yes" xml:space="preserve">
          <source>Understanding Redux</source>
          <target state="translated">Понимание Редукса</target>
        </trans-unit>
        <trans-unit id="da9a514a65a385fa6f49e9ff3ac2134dd5049f72" translate="yes" xml:space="preserve">
          <source>Understanding Redux Middleware</source>
          <target state="translated">Понимание Middleware компании Redux</target>
        </trans-unit>
        <trans-unit id="1126940f0f175f3010de4d728fe1b602fc4c7c2e" translate="yes" xml:space="preserve">
          <source>Understanding Undo History</source>
          <target state="translated">Понимание истории отмены</target>
        </trans-unit>
        <trans-unit id="29149689e59122b80c1e38105a1193a813f6026c" translate="yes" xml:space="preserve">
          <source>Undo history is also part of your app's state, and there is no reason why we should approach it differently. Regardless of the type of the state changing over time, when you implement Undo and Redo, you want to keep track of the &lt;em&gt;history&lt;/em&gt; of this state at different points in time.</source>
          <target state="translated">История отмен также является частью состояния вашего приложения, и нет причин, по которым мы должны подходить к ней по-другому. Независимо от типа изменения состояния с течением времени, когда вы реализуете Undo и Redo, вы хотите отслеживать &lt;em&gt;историю&lt;/em&gt; этого состояния в разные моменты времени.</target>
        </trans-unit>
        <trans-unit id="64a01a0c422c934a7950b6881de9ff78984dfa04" translate="yes" xml:space="preserve">
          <source>Unfortunately, the process of correctly applying immutable updates to deeply nested state can easily become verbose and hard to read. Here's what an example of updating &lt;code&gt;state.first.second[someId].fourth&lt;/code&gt; might look like:</source>
          <target state="translated">К сожалению, процесс правильного применения неизменяемых обновлений к глубоко вложенному состоянию может легко стать многословным и трудным для чтения. Вот как может выглядеть пример обновления &lt;code&gt;state.first.second[someId].fourth&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="e9541a9acaaaf0a817940ec4f10e5183c2dd8e50" translate="yes" xml:space="preserve">
          <source>Unfortunately, this setup has a problem. Because &lt;code&gt;combineReducers&lt;/code&gt; will call each slice reducer with the same action, dispatching &lt;code&gt;{type : 'INCREMENT'}&lt;/code&gt; will actually cause &lt;em&gt;all three&lt;/em&gt; counter values to be incremented, not just one of them. We need some way to wrap the &lt;code&gt;counter&lt;/code&gt; logic so that we can ensure that only the counter we care about is updated.</source>
          <target state="translated">К сожалению, в этой настройке есть проблема. Поскольку &lt;code&gt;combineReducers&lt;/code&gt; будет вызывать каждый редуктор среза с одним и тем же действием, диспетчеризация &lt;code&gt;{type : 'INCREMENT'}&lt;/code&gt; фактически приведет к увеличению &lt;em&gt;всех трех&lt;/em&gt; значений счетчика, а не только одного из них. Нам нужен какой-то способ обернуть логику &lt;code&gt;counter&lt;/code&gt; чтобы мы могли гарантировать, что обновляется только счетчик, который нам нужен .</target>
        </trans-unit>
        <trans-unit id="d02603176f8822a40aaa5b4270e49934a7f83824" translate="yes" xml:space="preserve">
          <source>Universal</source>
          <target state="translated">Universal</target>
        </trans-unit>
        <trans-unit id="994fe41b283ff02621f9c7dc77840d41dc98c31d" translate="yes" xml:space="preserve">
          <source>Unless you are targeting old browsers like IE9, you can always use &lt;code&gt;browserHistory&lt;/code&gt;.</source>
          <target state="translated">Если вы не ориентируетесь на старые браузеры, такие как IE9, вы всегда можете использовать &lt;code&gt;browserHistory&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2b1ae928f14271308acdf16284c1c3318ffccaac" translate="yes" xml:space="preserve">
          <source>Unlike Flux, &lt;strong&gt;Redux does not have the concept of a Dispatcher&lt;/strong&gt;. This is because it relies on pure functions instead of event emitters, and pure functions are easy to compose and don't need an additional entity managing them. Depending on how you view Flux, you may see this as either a deviation or an implementation detail. Flux has often been &lt;a href=&quot;https://speakerdeck.com/jmorrell/jsconf-uy-flux-those-who-forget-the-past-dot-dot-dot-1&quot;&gt;described as &lt;code&gt;(state, action) =&amp;gt; state&lt;/code&gt;&lt;/a&gt;. In this sense, Redux is true to the Flux architecture, but makes it simpler thanks to pure functions.</source>
          <target state="translated">В отличие от Flux, &lt;strong&gt;Redux не имеет концепции диспетчера&lt;/strong&gt; . Это потому, что он полагается на чистые функции, а не на эмиттеры событий, а чистые функции легко составлять и не нуждаются в дополнительной сущности, управляющей ими. В зависимости от того, как вы рассматриваете Flux, вы можете рассматривать это либо как отклонение, либо как деталь реализации. Поток часто &lt;a href=&quot;https://speakerdeck.com/jmorrell/jsconf-uy-flux-those-who-forget-the-past-dot-dot-dot-1&quot;&gt;описывается как &lt;code&gt;(state, action) =&amp;gt; state&lt;/code&gt; &lt;/a&gt; . В этом смысле Redux соответствует архитектуре Flux, но упрощает ее благодаря чистым функциям.</target>
        </trans-unit>
        <trans-unit id="369afc8b01a8d03d314e492b4f13b9436b7f3540" translate="yes" xml:space="preserve">
          <source>Unlike Immutable, Baobab doesn't yet implement any special efficient data structures under the hood, so you don't really win anything from using it together with Redux. It's easier to just use plain objects in this case.</source>
          <target state="translated">В отличие от Immutable,Baobab пока не реализует специальные эффективные структуры данных под капотом,так что вы ничего не выиграете,если будете использовать его вместе с Redux.В этом случае проще просто использовать простые объекты.</target>
        </trans-unit>
        <trans-unit id="dafc7d2108e005fe79487a219c36098fea188c9e" translate="yes" xml:space="preserve">
          <source>Unlike Redux, Elm is a language, so it is able to benefit from many things like enforced purity, static typing, out of the box immutability, and pattern matching (using the &lt;code&gt;case&lt;/code&gt; expression). Even if you don't plan to use Elm, you should read about the Elm architecture, and play with it. There is an interesting &lt;a href=&quot;https://github.com/paldepind/noname-functional-frontend-framework&quot;&gt;JavaScript library playground implementing similar ideas&lt;/a&gt;. We should look there for inspiration on Redux! One way that we can get closer to the static typing of Elm is by &lt;a href=&quot;https://github.com/reactjs/redux/issues/290&quot;&gt;using a gradual typing solution like Flow&lt;/a&gt;.</source>
          <target state="translated">В отличие от Redux, Elm - это язык, поэтому он может извлекать выгоду из многих вещей, таких как принудительная чистота, статическая типизация, нестандартная неизменность и сопоставление с образцом (с использованием выражения &lt;code&gt;case&lt;/code&gt; ). Даже если вы не планируете использовать Elm, вам следует прочитать об архитектуре Elm и поиграть с ней. Есть интересная &lt;a href=&quot;https://github.com/paldepind/noname-functional-frontend-framework&quot;&gt;площадка для библиотеки JavaScript, реализующая похожие идеи&lt;/a&gt; . Мы должны искать там вдохновение в Redux! Один из способов приблизиться к статической типизации Elm - это &lt;a href=&quot;https://github.com/reactjs/redux/issues/290&quot;&gt;использовать решение для постепенной типизации, такое как Flow&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="fb573dae642cd298a26b5ad3f7d8a6aa2a22ab64" translate="yes" xml:space="preserve">
          <source>Updating Nested Objects</source>
          <target state="translated">Обновление вложенных объектов</target>
        </trans-unit>
        <trans-unit id="ba005750a992aac6711d42039081d7dea24565c8" translate="yes" xml:space="preserve">
          <source>Updating Normalized Data</source>
          <target state="translated">Обновление нормализованных данных</target>
        </trans-unit>
        <trans-unit id="34a615077aef7febb310a581aba6ddb1f4573a22" translate="yes" xml:space="preserve">
          <source>Updating an Item in an Array</source>
          <target state="translated">Обновление элемента в массиве</target>
        </trans-unit>
        <trans-unit id="38f356713eaa6d37ea438e2f8aa17840c5f0c625" translate="yes" xml:space="preserve">
          <source>Updating complex nested state trees can lead to verbose code that is tedious to write and difficult to debug.</source>
          <target state="translated">Обновление сложных вложенных деревьев состояний может привести к появлению многословного кода,который утомительно писать и сложно отлаживать.</target>
        </trans-unit>
        <trans-unit id="692659407b3b434cf95e2a7e004744aa8b983be9" translate="yes" xml:space="preserve">
          <source>Updating one item in an array can be accomplished by using &lt;code&gt;Array.map&lt;/code&gt;, returning a new value for the item we want to update, and returning the existing values for all other items:</source>
          <target state="translated">Обновление одного элемента в массиве может быть выполнено с помощью &lt;code&gt;Array.map&lt;/code&gt; , возвращая новое значение для элемента, который мы хотим обновить, и возвращая существующие значения для всех других элементов:</target>
        </trans-unit>
        <trans-unit id="46dd59ad0b98ced1d4302c19c79265603a50b5a9" translate="yes" xml:space="preserve">
          <source>Updating the Selectors</source>
          <target state="translated">Обновление селекторов</target>
        </trans-unit>
        <trans-unit id="59dca19d5e82666b029e887367ee83ee76a6cde5" translate="yes" xml:space="preserve">
          <source>Usage with React</source>
          <target state="translated">Использование с реакцией</target>
        </trans-unit>
        <trans-unit id="4bd635c7ecaee77c3a25d970afecbab5846b8de6" translate="yes" xml:space="preserve">
          <source>Usage with React Router</source>
          <target state="translated">Использование с маршрутизатором</target>
        </trans-unit>
        <trans-unit id="f27c1c781c4770c2582ae4093ae556d8904e293c" translate="yes" xml:space="preserve">
          <source>Use Immutable.JS everywhere except your dumb components</source>
          <target state="translated">Используйте Immutable.JS везде,кроме ваших немых компонентов.</target>
        </trans-unit>
        <trans-unit id="9cd0943012b7d196bcc304b78eaf4d76beb5b078" translate="yes" xml:space="preserve">
          <source>Use Immutable.JS objects in your Smart Components</source>
          <target state="translated">Используйте объекты Immutable.JS в &quot;умных&quot; компонентах.</target>
        </trans-unit>
        <trans-unit id="14a99c911eb8f6fe086d95ec62a6192b50d4564c" translate="yes" xml:space="preserve">
          <source>Use a Higher Order Component to convert your Smart Component&amp;rsquo;s Immutable.JS props to your Dumb Component&amp;rsquo;s JavaScript props</source>
          <target state="translated">Используйте компонент более высокого порядка, чтобы преобразовать свойства Immutable.JS вашего смарт-компонента в свойства JavaScript вашего немого компонента.</target>
        </trans-unit>
        <trans-unit id="5f88c0684b6236b23ff1f689452822f930944d64" translate="yes" xml:space="preserve">
          <source>Use an Immutable.JS-aware version of the &lt;code&gt;combineReducers&lt;/code&gt; function, such as the one in &lt;a href=&quot;https://www.npmjs.com/package/redux-immutable&quot;&gt;redux-immutable&lt;/a&gt;, as Redux itself expects the state tree to be a plain JavaScript object.</source>
          <target state="translated">Используйте Immutable.JS-совместимую версию функции &lt;code&gt;combineReducers&lt;/code&gt; , например, в &lt;a href=&quot;https://www.npmjs.com/package/redux-immutable&quot;&gt;redux-immutable&lt;/a&gt; , поскольку сам Redux ожидает, что дерево состояний будет простым объектом JavaScript.</target>
        </trans-unit>
        <trans-unit id="3e7660e3d84caaf8d0d389dd1aa86ddb2e25f9d1" translate="yes" xml:space="preserve">
          <source>Use the Immutable Object Formatter Chrome Extension to Aid Debugging</source>
          <target state="translated">Используйте хромовое расширение непреложного формата объекта для помощи в отладке.</target>
        </trans-unit>
        <trans-unit id="f02307698aa7f146036376ea5c566843affb0cce" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;combineReducers&lt;/code&gt;</source>
          <target state="translated">Использование &lt;code&gt;combineReducers&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f08b702827057616968fd391c82f707b1a5a2d8f" translate="yes" xml:space="preserve">
          <source>Using Immutable.JS everywhere keeps your code performant. Use it in your smart components, your selectors, your sagas or thunks, action creators, and especially your reducers.</source>
          <target state="translated">Использование Immutable.JS везде держит ваш код работоспособным.Используй его в своих умных компонентах,селекторах,сагах или дубинках,создателях экшенов и особенно в редукторах.</target>
        </trans-unit>
        <trans-unit id="f7293e4f3b5e035630a5bc60b64f59c693251afd" translate="yes" xml:space="preserve">
          <source>Using Immutable.JS with Redux</source>
          <target state="translated">Использование Immutable.JS с Redux</target>
        </trans-unit>
        <trans-unit id="67ca03c7a7625d155b3a537ee064c3e9d484c709" translate="yes" xml:space="preserve">
          <source>Using Object Spread Operator</source>
          <target state="translated">Использование Оператора Распространения Объектов</target>
        </trans-unit>
        <trans-unit id="ac6f51d94e4af12a8acd288d8eb407840de3df95" translate="yes" xml:space="preserve">
          <source>Using Redux</source>
          <target state="translated">Использование Redux</target>
        </trans-unit>
        <trans-unit id="fe5bda3640263724e1162e68bdb4f3f60a23f165" translate="yes" xml:space="preserve">
          <source>Using Redux Undo</source>
          <target state="translated">Используя Redux Undo</target>
        </trans-unit>
        <trans-unit id="4350d0f8a60fb29773b2696fff9bb5c97e53d8b5" translate="yes" xml:space="preserve">
          <source>Using combineReducers</source>
          <target state="translated">Использование комбинированных редукторов</target>
        </trans-unit>
        <trans-unit id="7d518ee67915b609a1dd9ff6c8af1cfadb6c6da1" translate="yes" xml:space="preserve">
          <source>Using objects keyed by item IDs as lookup tables, and arrays of IDs to track ordering</source>
          <target state="translated">Использование в качестве таблиц просмотра объектов,клавиатура которых задана по идентификаторам элементов,и массивов идентификаторов для отслеживания порядка их расположения</target>
        </trans-unit>
        <trans-unit id="8ed1d4412e834bf938d3923e0b8f3cc5b2463506" translate="yes" xml:space="preserve">
          <source>Using redux-saga To Simplify Your Growing React Native Codebase</source>
          <target state="translated">Использование саги избыточности,чтобы упростить вашу растущую реакцию родной кодовой базы</target>
        </trans-unit>
        <trans-unit id="021b423143ef7a73f92d60003574a87608876b96" translate="yes" xml:space="preserve">
          <source>Using slice reducers with Immutable.js objects</source>
          <target state="translated">Использование редукторов с объектами Immutable.js.</target>
        </trans-unit>
        <trans-unit id="b97756d7719f737231f86a444a2d68e775b67e86" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;getVisibleTodos&lt;/code&gt; selector with multiple instances of the &lt;code&gt;visibleTodoList&lt;/code&gt; container will not correctly memoize:</source>
          <target state="translated">Использование селектора &lt;code&gt;getVisibleTodos&lt;/code&gt; с несколькими экземплярами контейнера &lt;code&gt;visibleTodoList&lt;/code&gt; не приведет к правильной мемоизации:</target>
        </trans-unit>
        <trans-unit id="4df7fb586380ea5e7c187fb0014d6c3d49e85d05" translate="yes" xml:space="preserve">
          <source>Usually generated by React Redux</source>
          <target state="translated">Обычно генерируется React Redux</target>
        </trans-unit>
        <trans-unit id="18fdc5ee8b1f8fba8dabaa933373c0483ab7fad7" translate="yes" xml:space="preserve">
          <source>Utilities</source>
          <target state="translated">Utilities</target>
        </trans-unit>
        <trans-unit id="3b6bce0bc82ec87711aba57c2f985407b17ac4e1" translate="yes" xml:space="preserve">
          <source>Utility libraries that wrap immutable update logic into simpler functions</source>
          <target state="translated">Библиотеки утилит,которые обёртывают непреложную логику обновления в более простые функции.</target>
        </trans-unit>
        <trans-unit id="a83ddc10110955dee4bc01b56024b22edcbf4ac4" translate="yes" xml:space="preserve">
          <source>Verbose Code</source>
          <target state="translated">Многословный код</target>
        </trans-unit>
        <trans-unit id="306838c8867984c3b915bde4dd3f78004f4ca086" translate="yes" xml:space="preserve">
          <source>Watch the 30 Free Videos!</source>
          <target state="translated">Смотрите 30 бесплатных видео!</target>
        </trans-unit>
        <trans-unit id="0483b60e25b0c25edcc348bff84793a3d91be49a" translate="yes" xml:space="preserve">
          <source>We also include our bundle file for the client-side application via a script tag. This is whatever output your bundling tool provides for your client entry point. It may be a static file or a URL to a hot reloading development server.</source>
          <target state="translated">Мы также включаем наш файл пакета для клиентского приложения через тег сценария.Это все,что выводит ваш инструмент комплектации обеспечивает для вашего клиента пункт входа.Это может быть статический файл или URL к горячему перезагрузке сервера разработки.</target>
        </trans-unit>
        <trans-unit id="10bbc3b0c569fe69fdd473c376b8f564d7a80d0e" translate="yes" xml:space="preserve">
          <source>We also need a way to give each instance of a container access to its own private selector. The &lt;code&gt;mapStateToProps&lt;/code&gt; argument of &lt;code&gt;connect&lt;/code&gt; can help with this.</source>
          <target state="translated">Нам также нужен способ предоставить каждому экземпляру контейнера доступ к его собственному частному селектору. В &lt;code&gt;mapStateToProps&lt;/code&gt; может помочь аргумент mapStateToProps команды &lt;code&gt;connect&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fdaefd698de230a2f7c12c50f1c7217019df8d31" translate="yes" xml:space="preserve">
          <source>We can now wrap any reducer into &lt;code&gt;undoable&lt;/code&gt; reducer enhancer to teach it to react to &lt;code&gt;UNDO&lt;/code&gt; and &lt;code&gt;REDO&lt;/code&gt; actions.</source>
          <target state="translated">Теперь мы можем превратить любой редуктор в &lt;code&gt;undoable&lt;/code&gt; усилитель редуктора, чтобы научить его реагировать на действия &lt;code&gt;UNDO&lt;/code&gt; и &lt;code&gt;REDO&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9c827f05d5a3cbe83f760b9cd2939ca0c33269a0" translate="yes" xml:space="preserve">
          <source>We can still define these special thunk action creators inside our &lt;code&gt;actions.js&lt;/code&gt; file:</source>
          <target state="translated">Мы все еще можем определить этих специальных создателей действий преобразователя в нашем файле &lt;code&gt;actions.js&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="938b765a6a181b2876b551536787a61427ae0513" translate="yes" xml:space="preserve">
          <source>We can write the following helper to accomplish this:</source>
          <target state="translated">Мы можем написать следующего помощника:</target>
        </trans-unit>
        <trans-unit id="c8360b823356a1165aff2dcb5acddb15d0faf8a6" translate="yes" xml:space="preserve">
          <source>We can't reliably enforce serializable actions for performance reasons, so Redux only checks that every action is a plain object, and that the &lt;code&gt;type&lt;/code&gt; is defined. The rest is up to you, but you might find that keeping everything serializable helps debug and reproduce issues.</source>
          <target state="translated">Мы не можем надежно обеспечить сериализуемые действия по соображениям производительности, поэтому Redux проверяет только то, что каждое действие является простым объектом и что &lt;code&gt;type&lt;/code&gt; определен. Остальное зависит от вас, но вы можете обнаружить, что сохранение всего сериализуемого помогает отлаживать и воспроизводить проблемы.</target>
        </trans-unit>
        <trans-unit id="00855934fc4901f8d981dcebd3bffdd698a1fcbf" translate="yes" xml:space="preserve">
          <source>We could also vary the approach somewhat, and create a more generic higher-order reducer that accepts both a given reducer function and a name or identifier:</source>
          <target state="translated">Мы также можем несколько разнообразить подход и создать более общий редуктор более высокого порядка,который будет принимать как данную функцию редуктора,так и имя или идентификатор:</target>
        </trans-unit>
        <trans-unit id="f190e4360534b4c5d20b45090414be9e9e50cea0" translate="yes" xml:space="preserve">
          <source>We could end this here, but it's not very convenient to import a special function every time.</source>
          <target state="translated">Мы могли бы закончить на этом,но не очень удобно каждый раз импортировать специальную функцию.</target>
        </trans-unit>
        <trans-unit id="05ab24ad4034d462a58f7bf871314f5e1296bcbc" translate="yes" xml:space="preserve">
          <source>We could provide a helper inside Redux that would apply the actual monkeypatching as an implementation detail:</source>
          <target state="translated">Мы могли бы предоставить помощника внутри Redux,который применял бы фактическое обезьянопокрытие в качестве детали реализации:</target>
        </trans-unit>
        <trans-unit id="9014512e14daf5d56a7fc1c2a33ed8ae10444137" translate="yes" xml:space="preserve">
          <source>We could use it to apply multiple middleware like this:</source>
          <target state="translated">Мы могли бы использовать его для применения нескольких промежуточных программ,как это:</target>
        </trans-unit>
        <trans-unit id="62783244d2f4a7054a2bb285d688f4cb5a60d38f" translate="yes" xml:space="preserve">
          <source>We don't want to lock you in!</source>
          <target state="translated">Мы не хотим запирать тебя!</target>
        </trans-unit>
        <trans-unit id="8a9e7b213f0799be76b21fa0d3f91f45192784f7" translate="yes" xml:space="preserve">
          <source>We extracted &lt;code&gt;posts(state, action)&lt;/code&gt; that manages the state of a specific post list. This is just &lt;a href=&quot;../basics/reducers#splitting-reducers&quot;&gt;reducer composition&lt;/a&gt;! It is our choice how to split the reducer into smaller reducers, and in this case, we're delegating updating items inside an object to a &lt;code&gt;posts&lt;/code&gt; reducer. The &lt;a href=&quot;../introduction/examples#real-world&quot;&gt;real world example&lt;/a&gt; goes even further, showing how to create a reducer factory for parameterized pagination reducers.</source>
          <target state="translated">Мы извлекли &lt;code&gt;posts(state, action)&lt;/code&gt; которые управляют состоянием определенного списка сообщений. Это просто &lt;a href=&quot;../basics/reducers#splitting-reducers&quot;&gt;состав редуктора&lt;/a&gt; ! Мы сами выбираем, как разделить редуктор на меньшие редукторы, и в этом случае мы делегируем обновление элементов внутри объекта редуктору &lt;code&gt;posts&lt;/code&gt; . &lt;a href=&quot;../introduction/examples#real-world&quot;&gt;Реальный пример&lt;/a&gt; идет еще дальше, показывая , как создать редуктор завод для параметризованных постраничных редукторов.</target>
        </trans-unit>
        <trans-unit id="f2ba230f751c2afe5d48e98a148b40dba74b740d" translate="yes" xml:space="preserve">
          <source>We have two more actions to handle! Just like we did with &lt;code&gt;SET_VISIBILITY_FILTER&lt;/code&gt;, we'll import the &lt;code&gt;ADD_TODO&lt;/code&gt; and &lt;code&gt;TOGGLE_TODO&lt;/code&gt; actions and then extend our reducer to handle &lt;code&gt;ADD_TODO&lt;/code&gt;.</source>
          <target state="translated">У нас есть еще два действия! Как и в случае с &lt;code&gt;SET_VISIBILITY_FILTER&lt;/code&gt; , мы импортируем действия &lt;code&gt;ADD_TODO&lt;/code&gt; и &lt;code&gt;TOGGLE_TODO&lt;/code&gt; , а затем расширим наш редуктор для обработки &lt;code&gt;ADD_TODO&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="937d04010c34a1830de25cf054cedd314fd77775" translate="yes" xml:space="preserve">
          <source>We just modified how the &lt;code&gt;addTodo&lt;/code&gt; action creator behaves, completely invisible to the calling code. &lt;strong&gt;We don't have to worry about looking at each place where todos are being added, to make sure they have this check.&lt;/strong&gt; Action creators let you decouple additional logic around dispatching an action, from the actual components emitting those actions. It's very handy when the application is under heavy development, and the requirements change often.</source>
          <target state="translated">Мы просто изменили &lt;code&gt;addTodo&lt;/code&gt; создателя действия addTodo , полностью невидимое для вызывающего кода. &lt;strong&gt;Нам не нужно беспокоиться о просмотре каждого места, куда добавляются задачи, чтобы убедиться, что у них есть эта проверка. &lt;/strong&gt;Создатели действий позволяют вам отделить дополнительную логику, связанную с отправкой действия, от фактических компонентов, генерирующих эти действия. Это очень удобно, когда приложение находится в стадии активной разработки и требования часто меняются.</target>
        </trans-unit>
        <trans-unit id="727029cc06658123c8225de825d04ad8f8957f5b" translate="yes" xml:space="preserve">
          <source>We must distinguish between dispatching functions in general and the base &lt;a href=&quot;api/store#dispatch&quot;&gt;&lt;code&gt;dispatch&lt;/code&gt;&lt;/a&gt; function provided by the store instance without any middleware.</source>
          <target state="translated">Мы должны различать функции диспетчеризации в целом и базовую функцию &lt;a href=&quot;api/store#dispatch&quot;&gt; &lt;code&gt;dispatch&lt;/code&gt; &lt;/a&gt; предоставляемую экземпляром магазина без какого-либо промежуточного программного обеспечения.</target>
        </trans-unit>
        <trans-unit id="44bbe40c8a0e33b691c1b061d98660259d085213" translate="yes" xml:space="preserve">
          <source>We need to create a fake &lt;code&gt;getState&lt;/code&gt;, &lt;code&gt;dispatch&lt;/code&gt;, and &lt;code&gt;next&lt;/code&gt; functions. We use &lt;code&gt;jest.fn()&lt;/code&gt; to create stubs, but with other test frameworks you would likely use sinon.</source>
          <target state="translated">Нам нужно создать поддельные функции &lt;code&gt;getState&lt;/code&gt; , &lt;code&gt;dispatch&lt;/code&gt; и &lt;code&gt;next&lt;/code&gt; . Мы используем &lt;code&gt;jest.fn()&lt;/code&gt; для создания заглушек, но с другими тестовыми фреймворками вы, вероятно, использовали бы sinon.</target>
        </trans-unit>
        <trans-unit id="299e4ddfafdfef1e85fc435e6d7114d6525ef4bd" translate="yes" xml:space="preserve">
          <source>We now have examples of several kinds of split-up reducer functions: helper utilities like &lt;code&gt;updateObject&lt;/code&gt; and &lt;code&gt;createReducer&lt;/code&gt;, handlers for specific cases like &lt;code&gt;setVisibilityFilter&lt;/code&gt; and &lt;code&gt;addTodo&lt;/code&gt;, and slice-of-state handlers like &lt;code&gt;visibilityReducer&lt;/code&gt; and &lt;code&gt;todosReducer&lt;/code&gt;. We also can see that &lt;code&gt;appReducer&lt;/code&gt; is an example of a &quot;root reducer&quot;.</source>
          <target state="translated">Теперь у нас есть примеры нескольких видов разделенных функций редуктора: вспомогательные утилиты, такие как &lt;code&gt;updateObject&lt;/code&gt; и &lt;code&gt;createReducer&lt;/code&gt; , обработчики для конкретных случаев, такие как &lt;code&gt;setVisibilityFilter&lt;/code&gt; и &lt;code&gt;addTodo&lt;/code&gt; , и обработчики фрагментов состояния, такие как &lt;code&gt;visibilityReducer&lt;/code&gt; и &lt;code&gt;todosReducer&lt;/code&gt; . Мы также можем видеть, что &lt;code&gt;appReducer&lt;/code&gt; является примером &amp;laquo;корневого редуктора&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="f931773a23d44ef9110cfd8557dfc7aa1e3202fa" translate="yes" xml:space="preserve">
          <source>We recommend &lt;a href=&quot;http://facebook.github.io/jest/&quot;&gt;Jest&lt;/a&gt; as the testing engine. Note that it runs in a Node environment, so you won't have access to the DOM.</source>
          <target state="translated">Мы рекомендуем &lt;a href=&quot;http://facebook.github.io/jest/&quot;&gt;Jest&lt;/a&gt; в качестве движка тестирования. Обратите внимание, что он работает в среде Node, поэтому у вас не будет доступа к DOM.</target>
        </trans-unit>
        <trans-unit id="c48c28638a818ee714914dc38026f386ac75db5b" translate="yes" xml:space="preserve">
          <source>We should now be able to use either of these to generate our specialized counter reducers, and then dispatch actions that will affect the portion of the state that we care about:</source>
          <target state="translated">Теперь мы должны иметь возможность использовать любой из них для генерации наших специализированных контр-редукторов,а затем рассылать действия,которые повлияют на ту часть государства,которая нам не безразлична:</target>
        </trans-unit>
        <trans-unit id="c89ee6942601c0a301153e30e9c58b2f5d8ec40b" translate="yes" xml:space="preserve">
          <source>We specified the behavior of our app before we even started writing the UI. We won't do this in this tutorial, but at this point you can write tests for your reducers and action creators. You won't need to mock anything because they are just &lt;a href=&quot;../introduction/threeprinciples#changes-are-made-with-pure-functions&quot;&gt;pure&lt;/a&gt; functions. Call them, and make assertions on what they return.</source>
          <target state="translated">Мы указали поведение нашего приложения еще до того, как начали писать пользовательский интерфейс. Мы не будем делать этого в этом руководстве, но на этом этапе вы можете написать тесты для своих редукторов и создателей действий. Вам не нужно ничего имитировать, потому что это просто &lt;a href=&quot;../introduction/threeprinciples#changes-are-made-with-pure-functions&quot;&gt;чистые&lt;/a&gt; функции. Позвоните им и заявите, что они вернут.</target>
        </trans-unit>
        <trans-unit id="c4470bb993a07bc6bfa269c5fb94507004598031" translate="yes" xml:space="preserve">
          <source>We store each subreddit's information separately so we can cache every subreddit. When the user switches between them the second time, the update will be instant, and we won't need to refetch unless we want to. Don't worry about all these items being in memory: unless you're dealing with tens of thousands of items, and your user rarely closes the tab, you won't need any sort of cleanup.</source>
          <target state="translated">Мы храним информацию о каждом субретдите отдельно,чтобы кэшировать каждый субретдит.Когда пользователь переключается между ними во второй раз,обновление будет мгновенным,и нам не понадобится рефетч,если мы этого не захотим.Не волнуйтесь о том,что все эти элементы останутся в памяти:если вы не имеете дело с десятками тысяч элементов,и ваш пользователь редко закрывает вкладку,вам не понадобится какая-либо очистка.</target>
        </trans-unit>
        <trans-unit id="1e50f981325b4d6e7b5e1ac94e3d14479ea909a5" translate="yes" xml:space="preserve">
          <source>We test that our middleware is calling the &lt;code&gt;getState&lt;/code&gt;, &lt;code&gt;dispatch&lt;/code&gt;, and &lt;code&gt;next&lt;/code&gt; functions at the right time.</source>
          <target state="translated">Мы проверяем, что наше промежуточное ПО вызывает функции &lt;code&gt;getState&lt;/code&gt; , &lt;code&gt;dispatch&lt;/code&gt; и &lt;code&gt;next&lt;/code&gt; в нужное время.</target>
        </trans-unit>
        <trans-unit id="75cf0f6e6b134023b61b31d405a78b8ef43ce618" translate="yes" xml:space="preserve">
          <source>We then get the initial state from our Redux store using &lt;a href=&quot;../api/store#getState&quot;&gt;&lt;code&gt;store.getState()&lt;/code&gt;&lt;/a&gt;. We will see how this is passed along in our &lt;code&gt;renderFullPage&lt;/code&gt; function.</source>
          <target state="translated">Затем мы получаем начальное состояние из нашего хранилища Redux с помощью &lt;a href=&quot;../api/store#getState&quot;&gt; &lt;code&gt;store.getState()&lt;/code&gt; &lt;/a&gt; . Мы увидим, как это передается в нашей функции &lt;code&gt;renderFullPage&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="319de368fdc28c8b195a6d2c03281f6821c69298" translate="yes" xml:space="preserve">
          <source>We use &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/API/Fetch_API&quot;&gt;&lt;code&gt;fetch&lt;/code&gt; API&lt;/a&gt; in the examples. It is a new API for making network requests that replaces &lt;code&gt;XMLHttpRequest&lt;/code&gt; for most common needs. Because most browsers don't yet support it natively, we suggest that you use &lt;a href=&quot;https://github.com/matthew-andrews/isomorphic-fetch&quot;&gt;&lt;code&gt;isomorphic-fetch&lt;/code&gt;&lt;/a&gt; library:</source>
          <target state="translated">В примерах мы используем &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/API/Fetch_API&quot;&gt; &lt;code&gt;fetch&lt;/code&gt; API&lt;/a&gt; . Это новый API для выполнения сетевых запросов, который заменяет &lt;code&gt;XMLHttpRequest&lt;/code&gt; для наиболее распространенных нужд. Поскольку большинство браузеров еще не поддерживают его изначально, мы предлагаем вам использовать библиотеку &lt;a href=&quot;https://github.com/matthew-andrews/isomorphic-fetch&quot;&gt; &lt;code&gt;isomorphic-fetch&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="a7b84a5beb3839d0cf7131fb4a2fbbb7aa5d2618" translate="yes" xml:space="preserve">
          <source>We use ES6 computed property syntax so we can update &lt;code&gt;state[action.subreddit]&lt;/code&gt; with &lt;code&gt;Object.assign()&lt;/code&gt; in a concise way. This:</source>
          <target state="translated">Мы используем синтаксис вычисляемых свойств ES6, поэтому мы можем &lt;code&gt;state[action.subreddit]&lt;/code&gt; обновить состояние [action.subreddit] с помощью &lt;code&gt;Object.assign()&lt;/code&gt; . Это:</target>
        </trans-unit>
        <trans-unit id="38db718a04799e7dc7479e35fa4bd78f62cd7909" translate="yes" xml:space="preserve">
          <source>We will also need some container components to connect the presentational components to Redux. For example, the presentational &lt;code&gt;TodoList&lt;/code&gt; component needs a container like &lt;code&gt;VisibleTodoList&lt;/code&gt; that subscribes to the Redux store and knows how to apply the current visibility filter. To change the visibility filter, we will provide a &lt;code&gt;FilterLink&lt;/code&gt; container component that renders a &lt;code&gt;Link&lt;/code&gt; that dispatches an appropriate action on click:</source>
          <target state="translated">Нам также понадобятся некоторые компоненты контейнера для подключения презентационных компонентов к Redux. Например, презентационному компоненту &lt;code&gt;TodoList&lt;/code&gt; нужен контейнер вроде &lt;code&gt;VisibleTodoList&lt;/code&gt; , который подписывается на хранилище Redux и знает, как применить текущий фильтр видимости. Чтобы изменить фильтр видимости, мы предоставим контейнерный компонент &lt;code&gt;FilterLink&lt;/code&gt; , который отображает &lt;code&gt;Link&lt;/code&gt; которая отправляет соответствующее действие при нажатии:</target>
        </trans-unit>
        <trans-unit id="cbe16722b5d079bcbcd195adcf84c0f8b9537578" translate="yes" xml:space="preserve">
          <source>We will also need to refactor &lt;code&gt;index.js&lt;/code&gt; to render the &lt;code&gt;&amp;lt;Root /&amp;gt;&lt;/code&gt; component to the DOM.</source>
          <target state="translated">Нам также потребуется рефакторинг &lt;code&gt;index.js&lt;/code&gt; , чтобы отобразить компонент &lt;code&gt;&amp;lt;Root /&amp;gt;&lt;/code&gt; в DOM.</target>
        </trans-unit>
        <trans-unit id="eed46c74461e18da655f49826f9bb4cec981c01c" translate="yes" xml:space="preserve">
          <source>We will see later how the approach we take lets us choose how granular Undo and Redo need to be.</source>
          <target state="translated">Позже мы увидим,как подход,который мы используем,позволяет нам выбрать,насколько гранулированным должно быть Undo и Redo.</target>
        </trans-unit>
        <trans-unit id="e48b8e0b74723fbbce7a038049b47d5983a8ab63" translate="yes" xml:space="preserve">
          <source>We will then import the &lt;code&gt;&amp;lt;Provider /&amp;gt;&lt;/code&gt; from React Redux:</source>
          <target state="translated">Затем мы импортируем &lt;code&gt;&amp;lt;Provider /&amp;gt;&lt;/code&gt; из React Redux:</target>
        </trans-unit>
        <trans-unit id="3dfe117d376bf6280908c658894a43c98efefd9b" translate="yes" xml:space="preserve">
          <source>We will use React in the examples below, but the same techniques can be used with other view frameworks that can render on the server.</source>
          <target state="translated">Мы будем использовать React в примерах ниже,но те же приемы можно использовать и с другими фреймворками представлений,которые могут рендерить на сервере.</target>
        </trans-unit>
        <trans-unit id="1cfc720c34e5f99bae08591a1d21b8028d872f1f" translate="yes" xml:space="preserve">
          <source>We will use React to build our simple todo app.</source>
          <target state="translated">Мы используем React для создания нашего простого приложения для тодо.</target>
        </trans-unit>
        <trans-unit id="77e9494b8c84b985dfa4f4d49ca2fb485e0d6cbd" translate="yes" xml:space="preserve">
          <source>We will wrap &lt;code&gt;&amp;lt;Router /&amp;gt;&lt;/code&gt; in &lt;code&gt;&amp;lt;Provider /&amp;gt;&lt;/code&gt; so that route handlers can get &lt;a href=&quot;../basics/usagewithreact#passing-the-store&quot;&gt;access to the &lt;code&gt;store&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Мы обернем &lt;code&gt;&amp;lt;Router /&amp;gt;&lt;/code&gt; в &lt;code&gt;&amp;lt;Provider /&amp;gt;&lt;/code&gt; , чтобы обработчики маршрутов могли получить &lt;a href=&quot;../basics/usagewithreact#passing-the-store&quot;&gt;доступ к &lt;code&gt;store&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1d2a4109058f0af68e149216b99cc33debbea027" translate="yes" xml:space="preserve">
          <source>We would like to replace &lt;code&gt;getVisibleTodos&lt;/code&gt; with a memoized selector that recalculates &lt;code&gt;todos&lt;/code&gt; when the value of &lt;code&gt;state.todos&lt;/code&gt; or &lt;code&gt;state.visibilityFilter&lt;/code&gt; changes, but not when changes occur in other (unrelated) parts of the state tree.</source>
          <target state="translated">Мы хотели бы заменить &lt;code&gt;getVisibleTodos&lt;/code&gt; мемоизированным селектором, который пересчитывает &lt;code&gt;todos&lt;/code&gt; при изменении значения &lt;code&gt;state.todos&lt;/code&gt; или &lt;code&gt;state.visibilityFilter&lt;/code&gt; , но не тогда, когда изменения происходят в других (не связанных) частях дерева состояний.</target>
        </trans-unit>
        <trans-unit id="6c0e7d729963aa201c31d1a06cb609fdf81434f4" translate="yes" xml:space="preserve">
          <source>We'll add one more action type to describe a user ticking off a todo as completed. We refer to a particular todo by &lt;code&gt;index&lt;/code&gt; because we store them in an array. In a real app, it is wiser to generate a unique ID every time something new is created.</source>
          <target state="translated">Мы добавим еще один тип действия, чтобы описать пользователя, отметившего задачу как выполненную. Мы ссылаемся на конкретную задачу по &lt;code&gt;index&lt;/code&gt; потому что храним их в массиве. В реальном приложении разумнее генерировать уникальный идентификатор каждый раз, когда создается что-то новое.</target>
        </trans-unit>
        <trans-unit id="070f3dc99d82df0afd700715eae9b841ac7a6b07" translate="yes" xml:space="preserve">
          <source>We'll explore how to perform side effects in the &lt;a href=&quot;../advanced/index&quot;&gt;advanced walkthrough&lt;/a&gt;. For now, just remember that the reducer must be pure. &lt;strong&gt;Given the same arguments, it should calculate the next state and return it. No surprises. No side effects. No API calls. No mutations. Just a calculation.&lt;/strong&gt;</source>
          <target state="translated">Мы рассмотрим, как выполнять побочные эффекты в &lt;a href=&quot;../advanced/index&quot;&gt;расширенном пошаговом руководстве&lt;/a&gt; . А пока просто помните, что редуктор должен быть чистым. &lt;strong&gt;Учитывая те же аргументы, он должен вычислить следующее состояние и вернуть его. Без сюрпризов. Никаких побочных эффектов. Никаких вызовов API. Никаких мутаций. Просто расчет.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="eaa545b7295152e58ab853f3d912b19f7b907eb9" translate="yes" xml:space="preserve">
          <source>We'll start by specifying the initial state. Redux will call our reducer with an &lt;code&gt;undefined&lt;/code&gt; state for the first time. This is our chance to return the initial state of our app:</source>
          <target state="translated">Начнем с определения начального состояния. Redux впервые вызовет наш редуктор с &lt;code&gt;undefined&lt;/code&gt; состоянием. Это наш шанс вернуть исходное состояние нашего приложения:</target>
        </trans-unit>
        <trans-unit id="a566f04c7bb96e3dad921f4e977a52579a6948e3" translate="yes" xml:space="preserve">
          <source>We'll start with the most common use case: lists. Web applications often show lists of things. For example, a list of posts, or a list of friends. You'll need to figure out what sorts of lists your app can show. You want to store them separately in the state, because this way you can cache them and only fetch again if necessary.</source>
          <target state="translated">Начнем с самого распространенного варианта использования:списков.Веб-приложения часто показывают списки.Например,список сообщений или список друзей.Вам нужно будет выяснить,какие списки может показывать ваше приложение.Вы хотите хранить их отдельно в состоянии,потому что таким образом вы можете кэшировать их и извлекать только при необходимости.</target>
        </trans-unit>
        <trans-unit id="bf88ce0d8fb03a1213e9e5aff6c740f652fabdf4" translate="yes" xml:space="preserve">
          <source>We'll use separate types in this tutorial.</source>
          <target state="translated">В этом учебнике мы будем использовать отдельные типы.</target>
        </trans-unit>
        <trans-unit id="6deda5b238140890ee6ed5f2e792c4827705c840" translate="yes" xml:space="preserve">
          <source>We're almost done. Since many people don't like switch statements, it's very common to use a function that creates a lookup table of action types to case functions. We'll use the &lt;code&gt;createReducer&lt;/code&gt; function described in &lt;a href=&quot;../reducingboilerplate#generating-reducers&quot;&gt;Reducing Boilerplate&lt;/a&gt;:</source>
          <target state="translated">Мы почти закончили. Поскольку многим людям не нравятся операторы switch, очень часто используется функция, которая создает таблицу поиска типов действий для функций case. Мы будем использовать функцию &lt;code&gt;createReducer&lt;/code&gt; , описанную в разделе &lt;a href=&quot;../reducingboilerplate#generating-reducers&quot;&gt;Уменьшение Boilerplate&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="cf8eb046053a065111d778fef4cfcdc223cb9816" translate="yes" xml:space="preserve">
          <source>Webflow</source>
          <target state="translated">Webflow</target>
        </trans-unit>
        <trans-unit id="cb59effde77f318efa4856b404dd72c191879fc1" translate="yes" xml:space="preserve">
          <source>What approaches are there for handling data immutably? Do I have to use Immutable.JS?</source>
          <target state="translated">Какие подходы существуют для бессрочной обработки данных? Должен ли я использовать Immutable.JS?</target>
        </trans-unit>
        <trans-unit id="2ec40d3e3697bdc90d47223d9a786375d4854093" translate="yes" xml:space="preserve">
          <source>What are some opinionated Best Practices for using Immutable.JS with Redux?</source>
          <target state="translated">Какова,по мнению некоторых,наилучшая практика использования Immutable.JS с Redux?</target>
        </trans-unit>
        <trans-unit id="4617f0a4931acbdece3479c94cd5d9b8a29ffbc4" translate="yes" xml:space="preserve">
          <source>What are the benefits of Immutability?</source>
          <target state="translated">Каковы преимущества Непреложности?</target>
        </trans-unit>
        <trans-unit id="60982d038a3233ff8e99646cab1b3f3181f09be8" translate="yes" xml:space="preserve">
          <source>What are the benefits of immutability?</source>
          <target state="translated">Каковы преимущества неизменности?</target>
        </trans-unit>
        <trans-unit id="de1352defc592755d5729188ff9c5931f975beca" translate="yes" xml:space="preserve">
          <source>What are the issues with using ES6 for immutable operations?</source>
          <target state="translated">Какие проблемы возникают при использовании ES6 для непреложных операций?</target>
        </trans-unit>
        <trans-unit id="87f7ec6d6c32ff8a62aada75fa88678bc51d6ac0" translate="yes" xml:space="preserve">
          <source>What are the issues with using Immutable.JS?</source>
          <target state="translated">Какие проблемы возникают при использовании Immutable.JS?</target>
        </trans-unit>
        <trans-unit id="7669cca5868cf84a7c911639d6206223bbfb9011" translate="yes" xml:space="preserve">
          <source>What are the issues with using JavaScript for immutable operations?</source>
          <target state="translated">Какие проблемы возникают при использовании JavaScript для непреложных операций?</target>
        </trans-unit>
        <trans-unit id="b6f105fcf428cb482f2dba1e64704d18ef939497" translate="yes" xml:space="preserve">
          <source>What are the issues with using plain JavaScript for immutable operations?</source>
          <target state="translated">Какие проблемы возникают при использовании простого JavaScript для непреложных операций?</target>
        </trans-unit>
        <trans-unit id="502931ac19eb7ad8e3a6b09a7f30f2039e70b8f9" translate="yes" xml:space="preserve">
          <source>What are the past (and future) states in the undo stack?</source>
          <target state="translated">Каково прошлое (и будущее)состояния в стопке отмен?</target>
        </trans-unit>
        <trans-unit id="7af9c4632a04865406facc7a09e8fff13bee6fa5" translate="yes" xml:space="preserve">
          <source>What if we just replace the &lt;code&gt;dispatch&lt;/code&gt; function on the store instance? The Redux store is just a plain object with &lt;a href=&quot;../api/store&quot;&gt;a few methods&lt;/a&gt;, and we're writing JavaScript, so we can just monkeypatch the &lt;code&gt;dispatch&lt;/code&gt; implementation:</source>
          <target state="translated">Что, если мы просто заменим функцию &lt;code&gt;dispatch&lt;/code&gt; в экземпляре магазина? Хранилище Redux - это простой объект с &lt;a href=&quot;../api/store&quot;&gt;несколькими методами&lt;/a&gt; , и мы пишем JavaScript, поэтому мы можем просто исправить реализацию &lt;code&gt;dispatch&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="da380f2420edcb4fe953f900cae3cd95adf19059" translate="yes" xml:space="preserve">
          <source>What if we want to apply &lt;strong&gt;more than one&lt;/strong&gt; such transformation to &lt;code&gt;dispatch&lt;/code&gt;?</source>
          <target state="translated">Что, если мы хотим применить &lt;strong&gt;более одного&lt;/strong&gt; такого преобразования к &lt;code&gt;dispatch&lt;/code&gt; ?</target>
        </trans-unit>
        <trans-unit id="8d5e21ca6d6c7949c97bbb82b6de23a8e86a90ba" translate="yes" xml:space="preserve">
          <source>What is the current state?</source>
          <target state="translated">Каково текущее состояние?</target>
        </trans-unit>
        <trans-unit id="ccdd9f0a8546e0e957522917e3028ad2fdff0b9e" translate="yes" xml:space="preserve">
          <source>What should my file structure look like? How should I group my action creators and reducers in my project? Where should my selectors go?</source>
          <target state="translated">Как должна выглядеть моя файловая структура? Как сгруппировать создателей и редукторов моих действий в моем проекте? Куда должны деваться мои селекторы?</target>
        </trans-unit>
        <trans-unit id="39b7e4ebfa46344ad4758dbb7c54ade6b182a09d" translate="yes" xml:space="preserve">
          <source>What the Flux?! Let's Redux.</source>
          <target state="translated">Что за флюс?! Давайте Редукс.</target>
        </trans-unit>
        <trans-unit id="7685a22848ac997a066fa32d4715b4fcb5b90efa" translate="yes" xml:space="preserve">
          <source>Whatever convention you choose, stick with it throughout the application.</source>
          <target state="translated">Какое бы соглашение вы ни выбрали,придерживайтесь его в течение всего заявления.</target>
        </trans-unit>
        <trans-unit id="7e44dc3bb557d164a1c8cd909a8179ffc29fe58f" translate="yes" xml:space="preserve">
          <source>When a piece of data is duplicated in several places, it becomes harder to make sure that it is updated appropriately.</source>
          <target state="translated">Когда часть данных дублируется в нескольких местах,становится труднее удостовериться в том,что она обновлена должным образом.</target>
        </trans-unit>
        <trans-unit id="c0b74de7e07b265987ff3765a92ea469eb3be3c6" translate="yes" xml:space="preserve">
          <source>When a store is created, Redux dispatches a dummy action to your reducer to populate the store with the initial state. You are not meant to handle the dummy action directly. Just remember that your reducer should return some kind of initial state if the state given to it as the first argument is &lt;code&gt;undefined&lt;/code&gt;, and you're all set.</source>
          <target state="translated">Когда создается хранилище, Redux отправляет фиктивное действие вашему редуктору, чтобы заполнить хранилище начальным состоянием. Вы не должны напрямую обрабатывать фиктивное действие. Просто помните, что ваш редуктор должен возвращать какое-то начальное состояние, если состояние, данное ему в качестве первого аргумента, не &lt;code&gt;undefined&lt;/code&gt; , и все готово.</target>
        </trans-unit>
        <trans-unit id="55f47f3d19e55c7f647cc1402dfe664e913c42b7" translate="yes" xml:space="preserve">
          <source>When adding JavaScript objects to an Immutable.JS Map or List using Immutable.JS&amp;rsquo;s &lt;code&gt;update&lt;/code&gt;, &lt;code&gt;merge&lt;/code&gt; or &lt;code&gt;set&lt;/code&gt; methods, ensure that the object being added is first converted to an Immutable object using &lt;code&gt;fromJS()&lt;/code&gt;.</source>
          <target state="translated">При добавлении объектов JavaScript в карту или список Immutable.JS с использованием методов &lt;code&gt;update&lt;/code&gt; , &lt;code&gt;merge&lt;/code&gt; или &lt;code&gt;set&lt;/code&gt; в &lt;code&gt;fromJS()&lt;/code&gt; убедитесь, что добавляемый объект сначала преобразован в объект Immutable с помощью fromJS () .</target>
        </trans-unit>
        <trans-unit id="5532214553b2a415074b0f39f2cead024233404a" translate="yes" xml:space="preserve">
          <source>When an action creator returns a function, that function will get executed by the Redux Thunk middleware. This function doesn't need to be pure; it is thus allowed to have side effects, including executing asynchronous API calls. The function can also dispatch actions&amp;mdash;like those synchronous actions we defined earlier.</source>
          <target state="translated">Когда создатель действия возвращает функцию, эта функция будет выполняться промежуточным программным обеспечением Redux Thunk. Эта функция не обязательно должна быть чистой; таким образом, разрешены побочные эффекты, включая выполнение асинхронных вызовов API. Функция также может отправлять действия, подобные тем синхронным действиям, которые мы определили ранее.</target>
        </trans-unit>
        <trans-unit id="d2b511652b6790f3eca5e3448a96b4a14c313d91" translate="yes" xml:space="preserve">
          <source>When it's time to fetch the posts for some subreddit, we will dispatch a &lt;code&gt;REQUEST_POSTS&lt;/code&gt; action:</source>
          <target state="translated">Когда пришло время получить сообщения для какого-то субреддита, мы отправим действие &lt;code&gt;REQUEST_POSTS&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="c552f80b72ecd37903e2d6ffce7bb1a0b3ba91ad" translate="yes" xml:space="preserve">
          <source>When previously we wrote: &lt;code&gt;&amp;lt;Route path=&quot;/(:filter)&quot; component={App} /&amp;gt;&lt;/code&gt;, it made available inside &lt;code&gt;App&lt;/code&gt; a &lt;code&gt;params&lt;/code&gt; property.</source>
          <target state="translated">Когда ранее мы писали: &lt;code&gt;&amp;lt;Route path=&quot;/(:filter)&quot; component={App} /&amp;gt;&lt;/code&gt; , она доступна в &lt;code&gt;App&lt;/code&gt; &lt;code&gt;params&lt;/code&gt; собственности.</target>
        </trans-unit>
        <trans-unit id="c55e37eb1a90ec0796f6a4f05992a64917889494" translate="yes" xml:space="preserve">
          <source>When rendering, we will wrap &lt;code&gt;&amp;lt;App /&amp;gt;&lt;/code&gt;, our root component, inside a &lt;code&gt;&amp;lt;Provider&amp;gt;&lt;/code&gt; to make the store available to all components in the component tree, as we saw in &lt;a href=&quot;../basics/usagewithreact&quot;&gt;Usage with React&lt;/a&gt;.</source>
          <target state="translated">При рендеринге мы обернем &lt;code&gt;&amp;lt;App /&amp;gt;&lt;/code&gt; , наш корневой компонент, внутри &lt;code&gt;&amp;lt;Provider&amp;gt;&lt;/code&gt; , чтобы сделать хранилище доступным для всех компонентов в дереве компонентов, как мы видели в &amp;laquo; &lt;a href=&quot;../basics/usagewithreact&quot;&gt;Использование с React&amp;raquo;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b8f09b0e83401e68e4c33132aa1b3b73a6d4dcd4" translate="yes" xml:space="preserve">
          <source>When should I use Redux?</source>
          <target state="translated">Когда я должен использовать &quot;Редукс&quot;?</target>
        </trans-unit>
        <trans-unit id="d794925cbdb0e31214ecfc88910755d33c4f0b10" translate="yes" xml:space="preserve">
          <source>When the last middleware in the chain dispatches an action, it has to be a plain object. This is when the &lt;a href=&quot;../basics/dataflow&quot;&gt;synchronous Redux data flow&lt;/a&gt; takes place.</source>
          <target state="translated">Когда последнее промежуточное ПО в цепочке отправляет действие, это должен быть простой объект. Это когда происходит &lt;a href=&quot;../basics/dataflow&quot;&gt;синхронный поток данных Redux&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d74a3e9748d787071d9c2fe4d73363cc68c2dcd3" translate="yes" xml:space="preserve">
          <source>When the page loads, the bundle file will be started up and &lt;a href=&quot;https://facebook.github.io/react/docs/top-level-api.html#reactdom.render&quot;&gt;&lt;code&gt;ReactDOM.render()&lt;/code&gt;&lt;/a&gt; will hook into the &lt;code&gt;data-react-id&lt;/code&gt; attributes from the server-rendered HTML. This will connect our newly-started React instance to the virtual DOM used on the server. Since we have the same initial state for our Redux store and used the same code for all our view components, the result will be the same real DOM.</source>
          <target state="translated">Когда страница загружается, файл пакета будет запущен, и &lt;a href=&quot;https://facebook.github.io/react/docs/top-level-api.html#reactdom.render&quot;&gt; &lt;code&gt;ReactDOM.render()&lt;/code&gt; &lt;/a&gt; подключится к атрибутам &lt;code&gt;data-react-id&lt;/code&gt; из HTML, отрендеренного сервером. Это подключит наш недавно запущенный экземпляр React к виртуальной DOM, используемой на сервере. Поскольку у нас одинаковое начальное состояние для нашего хранилища Redux и один и тот же код используется для всех наших компонентов представления, результатом будет тот же самый реальный DOM.</target>
        </trans-unit>
        <trans-unit id="fdc93b372187dd00b09c70c8f0349010aacbd69a" translate="yes" xml:space="preserve">
          <source>When the shallow check fails, React-Redux will cause the component to re-render. Using &lt;code&gt;toJS()&lt;/code&gt; in &lt;code&gt;mapStateToProps&lt;/code&gt; in this way, therefore, will always cause the component to re-render, even if the value never changes, impacting heavily on performance.</source>
          <target state="translated">Когда неглубокая проверка не удалась, React-Redux заставит компонент повторно отрисоваться. Таким образом, использование &lt;code&gt;toJS()&lt;/code&gt; в &lt;code&gt;mapStateToProps&lt;/code&gt; всегда будет вызывать повторный рендеринг компонента, даже если значение никогда не изменяется, что сильно влияет на производительность.</target>
        </trans-unit>
        <trans-unit id="4aa9765bfd105e5641e876f4bda241427a866bc5" translate="yes" xml:space="preserve">
          <source>When the user presses &amp;ldquo;Redo&amp;rdquo;, we want to move one step back into the future:</source>
          <target state="translated">Когда пользователь нажимает &amp;laquo;Повторить&amp;raquo;, мы хотим вернуться на шаг назад в будущее:</target>
        </trans-unit>
        <trans-unit id="6f1dc68360b35a018ee091fccfa401d6fad91461" translate="yes" xml:space="preserve">
          <source>When using Redux with server rendering, we must also send the state of our app along in our response, so the client can use it as the initial state. This is important because, if we preload any data before generating the HTML, we want the client to also have access to this data. Otherwise, the markup generated on the client won't match the server markup, and the client would have to load the data again.</source>
          <target state="translated">При использовании Redux с рендерингом сервера,мы также должны отправить состояние нашего приложения в нашем ответе,чтобы клиент мог использовать его в качестве начального состояния.Это важно,потому что,если мы предварительно загрузим какие-либо данные перед генерацией HTML,мы хотим,чтобы клиент также имел доступ к этим данным.В противном случае,разметка,сгенерированная на клиенте,не будет соответствовать разметке сервера,и клиенту придется загружать данные снова.</target>
        </trans-unit>
        <trans-unit id="08905f564cddc435b39d4746befbbfde05d56c89" translate="yes" xml:space="preserve">
          <source>When you call an asynchronous API, there are two crucial moments in time: the moment you start the call, and the moment when you receive an answer (or a timeout).</source>
          <target state="translated">При вызове асинхронного API есть два критических момента во времени:момент начала вызова и момент получения ответа (или таймаута).</target>
        </trans-unit>
        <trans-unit id="b17e363eb01279dd12d04917f1f023babea53839" translate="yes" xml:space="preserve">
          <source>When you emit an action, &lt;code&gt;todoApp&lt;/code&gt; returned by &lt;code&gt;combineReducers&lt;/code&gt; will call both reducers:</source>
          <target state="translated">Когда вы генерируете действие, &lt;code&gt;todoApp&lt;/code&gt; , возвращаемый &lt;code&gt;combineReducers&lt;/code&gt; , вызывает оба редуктора:</target>
        </trans-unit>
        <trans-unit id="9320a916b3e55e2e80a21708cceecfcf437cc640" translate="yes" xml:space="preserve">
          <source>When you have ported all of your Flux Stores to be implemented on top of reducers, you can replace the Flux library with a single Redux store, and combine those reducers you already have into one using &lt;a href=&quot;../api/combinereducers&quot;&gt;&lt;code&gt;combineReducers(reducers)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Когда вы портировали все свои хранилища Flux для реализации поверх редукторов, вы можете заменить библиотеку Flux одним хранилищем Redux и объединить те редукторы, которые у вас уже есть, в одно с помощью &lt;a href=&quot;../api/combinereducers&quot;&gt; &lt;code&gt;combineReducers(reducers)&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c0a2799ac8efd1f6499c6fb41130094d5c12a451" translate="yes" xml:space="preserve">
          <source>Where do I put my business logic in a React/Redux application?</source>
          <target state="translated">Куда поместить мою бизнес-логику в приложении React/Redux?</target>
        </trans-unit>
        <trans-unit id="8c07523b65b47a0ad36e94ad44e0e56dd3913c89" translate="yes" xml:space="preserve">
          <source>Where do we get the initial &lt;code&gt;present&lt;/code&gt; state from? We don't seem to know it beforehand.</source>
          <target state="translated">Откуда мы получаем начальное &lt;code&gt;present&lt;/code&gt; состояние? Кажется, мы этого не знаем заранее.</target>
        </trans-unit>
        <trans-unit id="2c79f8ed0107a7fe0a477df33c48d8c228e7eee0" translate="yes" xml:space="preserve">
          <source>Where do we react to the external actions to save the &lt;code&gt;present&lt;/code&gt; to the &lt;code&gt;past&lt;/code&gt;?</source>
          <target state="translated">Как мы реагируем на внешние действия, чтобы сохранить &lt;code&gt;present&lt;/code&gt; в &lt;code&gt;past&lt;/code&gt; ?</target>
        </trans-unit>
        <trans-unit id="6559f99fd936b0050a5d2a1fc16d0873490da574" translate="yes" xml:space="preserve">
          <source>Where to Hold React Component Data: state, store, static, and this</source>
          <target state="translated">Где удерживать реактивные данные компонентов:состояние,хранить,статические,и это</target>
        </trans-unit>
        <trans-unit id="03693bfdc7508d98809d55b857217f95caac409e" translate="yes" xml:space="preserve">
          <source>Whether you choose to use such a library, or stick with plain JavaScript, depends on how comfortable you are with adding another dependency to your app, or how sure you are that you can avoid the pitfalls inherent within JavaScript&amp;rsquo;s approach to immutability.</source>
          <target state="translated">Решите ли вы использовать такую ​​библиотеку или придерживаться простого JavaScript, зависит от того, насколько вам удобно добавлять другую зависимость в свое приложение или насколько вы уверены, что сможете избежать ошибок, присущих подходу JavaScript к неизменяемости.</target>
        </trans-unit>
        <trans-unit id="067c7d896d6446815e8315d7a4fcfafc8f8da43b" translate="yes" xml:space="preserve">
          <source>Whether you have used them or not, Redux only takes a few minutes to get started with.</source>
          <target state="translated">Независимо от того,использовали вы их или нет,Redux занимает всего несколько минут,чтобы начать работу.</target>
        </trans-unit>
        <trans-unit id="cbfecd927f559c2b5baf796e97b2ca728811bf43" translate="yes" xml:space="preserve">
          <source>Whichever option you choose, make sure you&amp;rsquo;re familiar with the concepts of &lt;a href=&quot;reducers/prerequisiteconcepts#note-on-immutability-side-effects-and-mutation&quot;&gt;immutability, side effects and mutation&lt;/a&gt;. In particular, ensure you have a deep understanding of what JavaScript does when updating and copying values in order to guard against accidental mutations that will degrade your app&amp;rsquo;s performance, or break it altogether.</source>
          <target state="translated">Какой бы вариант вы ни выбрали, убедитесь, что вы знакомы с концепциями &lt;a href=&quot;reducers/prerequisiteconcepts#note-on-immutability-side-effects-and-mutation&quot;&gt;неизменности, побочных эффектов и мутации&lt;/a&gt; . В частности, убедитесь, что у вас есть глубокое понимание того, что делает JavaScript при обновлении и копировании значений, чтобы защититься от случайных мутаций, которые ухудшат производительность вашего приложения или вообще нарушат его.</target>
        </trans-unit>
        <trans-unit id="03047acfd57571e8bdbc8135d9d15cea99035eb1" translate="yes" xml:space="preserve">
          <source>While &lt;a href=&quot;../api/combinereducers&quot;&gt;&lt;code&gt;combineReducers()&lt;/code&gt;&lt;/a&gt; is a handy helper utility, you don't have to use it; feel free to write your own root reducer!</source>
          <target state="translated">Хотя &lt;a href=&quot;../api/combinereducers&quot;&gt; &lt;code&gt;combineReducers()&lt;/code&gt; &lt;/a&gt; - удобная вспомогательная утилита, вам не обязательно ее использовать; не стесняйтесь писать свой собственный root-редуктор!</target>
        </trans-unit>
        <trans-unit id="4089c3ad2441e642d6adb86e7f9d112ea7103b43" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;combineReducers&lt;/code&gt; attempts to check that your reducers conform to some of these rules, you should remember them, and do your best to follow them. &lt;code&gt;combineReducers&lt;/code&gt; will check your reducers by passing &lt;code&gt;undefined&lt;/code&gt; to them; this is done even if you specify initial state to &lt;code&gt;Redux.createStore(combineReducers(...), initialState)&lt;/code&gt;. Therefore, you &lt;strong&gt;must&lt;/strong&gt; ensure your reducers work properly when receiving &lt;code&gt;undefined&lt;/code&gt; as state, even if you never intend for them to actually receive &lt;code&gt;undefined&lt;/code&gt; in your own code.</source>
          <target state="translated">В то время как &lt;code&gt;combineReducers&lt;/code&gt; пытается проверить, соответствуют ли ваши редукторы некоторым из этих правил, вы должны помнить их и делать все возможное, чтобы им следовать. &lt;code&gt;combineReducers&lt;/code&gt; проверит ваши редукторы, передав им &lt;code&gt;undefined&lt;/code&gt; ; это делается, даже если вы укажете начальное состояние для &lt;code&gt;Redux.createStore(combineReducers(...), initialState)&lt;/code&gt; . Следовательно, вы &lt;strong&gt;должны&lt;/strong&gt; убедиться, что ваши редукторы работают правильно при получении &lt;code&gt;undefined&lt;/code&gt; как состояние, даже если вы никогда не намереваетесь, чтобы они действительно получали &lt;code&gt;undefined&lt;/code&gt; в вашем собственном коде.</target>
        </trans-unit>
        <trans-unit id="1a1e65f5bf9037c5912b84c5835b30699b791739" translate="yes" xml:space="preserve">
          <source>While React Redux does work to minimize the number of times that your &lt;code&gt;mapStateToProps&lt;/code&gt; function is called, it's still a good idea to ensure that your &lt;code&gt;mapStateToProps&lt;/code&gt; runs quickly and also minimizes the amount of work it does. The common recommended approach is to create memoized &amp;ldquo;selector&amp;rdquo; functions using &lt;a href=&quot;https://github.com/reactjs/reselect&quot;&gt;Reselect&lt;/a&gt;. These selectors can be combined and composed together, and selectors later in a pipeline will only run if their inputs have changed. This means you can create selectors that do things like filtering or sorting, and ensure that the real work only happens if needed.</source>
          <target state="translated">Хотя React Redux действительно работает, чтобы минимизировать количество &lt;code&gt;mapStateToProps&lt;/code&gt; вашей функции mapStateToProps , по-прежнему рекомендуется убедиться, что ваш &lt;code&gt;mapStateToProps&lt;/code&gt; работает быстро, а также сводит к минимуму объем выполняемой работы. Обычно рекомендуется создавать мемоизированные функции &amp;laquo;селектора&amp;raquo; с помощью &lt;a href=&quot;https://github.com/reactjs/reselect&quot;&gt;Reselect&lt;/a&gt; . Эти селекторы можно комбинировать и составлять вместе, а селекторы позже в конвейере будут работать, только если их входные данные изменились. Это означает, что вы можете создавать селекторы, которые выполняют такие функции, как фильтрация или сортировка, и гарантируют, что реальная работа будет выполняться только в случае необходимости.</target>
        </trans-unit>
        <trans-unit id="040c756905d96ee1b18a17c4c17f4f0537e48ce8" translate="yes" xml:space="preserve">
          <source>While Redux itself is not opinionated about how your state is organized, &lt;code&gt;combineReducers&lt;/code&gt; enforces several rules to help users avoid common errors. (See &lt;a href=&quot;../../api/combinereducers&quot;&gt;&lt;code&gt;combineReducers&lt;/code&gt;&lt;/a&gt; for details.)</source>
          <target state="translated">Хотя сам Redux не придерживается мнения о том, как организовано ваше состояние , &lt;code&gt;combineReducers&lt;/code&gt; применяет несколько правил, чтобы помочь пользователям избежать распространенных ошибок. (Подробнее см. &lt;a href=&quot;../../api/combinereducers&quot;&gt; &lt;code&gt;combineReducers&lt;/code&gt; &lt;/a&gt; .)</target>
        </trans-unit>
        <trans-unit id="8dfc58574b33f1efddcb65068c1c7a976c89a49a" translate="yes" xml:space="preserve">
          <source>While effective, using &lt;code&gt;Object.assign()&lt;/code&gt; can quickly make simple reducers difficult to read given its rather verbose syntax.</source>
          <target state="translated">Несмотря на свою эффективность, использование &lt;code&gt;Object.assign()&lt;/code&gt; может быстро сделать простые редукторы трудными для чтения, учитывая его довольно подробный синтаксис.</target>
        </trans-unit>
        <trans-unit id="269ba06048a7e4e70129f1c6f218059f072f2367" translate="yes" xml:space="preserve">
          <source>While it is technically &lt;em&gt;possible&lt;/em&gt; to &lt;a href=&quot;https://github.com/reactjs/redux/issues/328#issuecomment-125035516&quot;&gt;write impure reducers&lt;/a&gt; that mutate the data for performance corner cases, we actively discourage you from doing this. Development features like time travel, record/replay, or hot reloading will break. Moreover it doesn't seem like immutability poses performance problems in most real apps, because, as &lt;a href=&quot;https://github.com/omcljs/om&quot;&gt;Om&lt;/a&gt; demonstrates, even if you lose out on object allocation, you still win by avoiding expensive re-renders and re-calculations, as you know exactly what changed thanks to reducer purity.</source>
          <target state="translated">Хотя технически это &lt;em&gt;возможно&lt;/em&gt; , чтобы &lt;a href=&quot;https://github.com/reactjs/redux/issues/328#issuecomment-125035516&quot;&gt;написать нечистый редукторы&lt;/a&gt; , которые мутируют данные для характеристики угловых случаев, мы активно препятствовать вам делать это. Функции разработки, такие как путешествие во времени, запись / воспроизведение или горячая перезагрузка, не работают. Более того, не похоже, что неизменяемость создает проблемы с производительностью в большинстве реальных приложений, потому что, как демонстрирует &lt;a href=&quot;https://github.com/omcljs/om&quot;&gt;Ом&lt;/a&gt; , даже если вы проиграете в распределении объектов, вы все равно выиграете, избегая дорогостоящих повторных рендерингов и пересчетов, поскольку вы точно знаете, что поменял благодаря чистоте редуктора.</target>
        </trans-unit>
        <trans-unit id="abcdc11df5ffeb4a687df7b1d5bbf50fd78fa63f" translate="yes" xml:space="preserve">
          <source>While it ultimately doesn't matter how you lay out your code on disk, it's important to remember that actions and reducers shouldn't be considered in isolation. It's entirely possible (and encouraged) for a reducer defined in one folder to respond to an action defined in another folder.</source>
          <target state="translated">Хотя в конечном итоге не имеет значения,как вы разместите свой код на диске,важно помнить,что действия и редукторы не должны рассматриваться в отрыве друг от друга.Редуктор,определенный в одной папке,вполне может (и поощряется)реагировать на действие,определенное в другой папке.</target>
        </trans-unit>
        <trans-unit id="d174eaad0823043371c5b288b8705217853f594b" translate="yes" xml:space="preserve">
          <source>While middleware can be used for a variety of things, including asynchronous API calls, it's really important that you understand where it comes from. We'll guide you through the thought process leading to middleware, by using logging and crash reporting as examples.</source>
          <target state="translated">Хотя промежуточное программное обеспечение можно использовать для различных вещей,включая асинхронные вызовы API,очень важно,чтобы вы понимали,откуда оно исходит.Мы проведем вас через процесс мышления,ведущий к промежуточному ПО,на примере ведения журналов и отчетов об аварийных ситуациях.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
