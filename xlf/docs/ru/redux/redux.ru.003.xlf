<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="redux">
    <body>
      <group id="redux">
        <trans-unit id="d174eaad0823043371c5b288b8705217853f594b" translate="yes" xml:space="preserve">
          <source>While middleware can be used for a variety of things, including asynchronous API calls, it's really important that you understand where it comes from. We'll guide you through the thought process leading to middleware, by using logging and crash reporting as examples.</source>
          <target state="translated">Хотя промежуточное программное обеспечение можно использовать для различных вещей,включая асинхронные вызовы API,очень важно,чтобы вы понимали,откуда оно исходит.Мы проведем вас через процесс мышления,ведущий к промежуточному ПО,на примере ведения журналов и отчетов об аварийных ситуациях.</target>
        </trans-unit>
        <trans-unit id="5ad63caddc89503ad9515ff6b17c9b9ddad8c44b" translate="yes" xml:space="preserve">
          <source>While there's no single definitive answer to this, most of the time this should not be a concern in either case.</source>
          <target state="translated">Хотя нет единого окончательного ответа на этот вопрос,в большинстве случаев это не должно вызывать беспокойства в любом случае.</target>
        </trans-unit>
        <trans-unit id="baecaba85a30f210b6df40e0df3b4579a527b679" translate="yes" xml:space="preserve">
          <source>Why do we even overwrite &lt;code&gt;dispatch&lt;/code&gt;? Of course, to be able to call it later, but there's also another reason: so that every middleware can access (and call) the previously wrapped &lt;code&gt;store.dispatch&lt;/code&gt;:</source>
          <target state="translated">Почему мы вообще перезаписываем &lt;code&gt;dispatch&lt;/code&gt; ? Конечно, чтобы иметь возможность вызвать его позже, но есть и другая причина: чтобы каждое промежуточное ПО могло получить доступ (и вызвать) ранее упакованный &lt;code&gt;store.dispatch&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="8f16b35538e53672818a41ec6538a37dcb3ab3da" translate="yes" xml:space="preserve">
          <source>Why does React-Redux shallowly check each value within the props object returned from &lt;code&gt;mapStateToProp&lt;/code&gt;?</source>
          <target state="translated">Почему React-Redux неглубоко проверяет каждое значение в объекте &lt;code&gt;mapStateToProp&lt;/code&gt; возвращаемом из mapStateToProp ?</target>
        </trans-unit>
        <trans-unit id="94db3c68fc052fe95a3526f89400cbf7608c18b8" translate="yes" xml:space="preserve">
          <source>Why does Redux&amp;rsquo;s use of shallow equality checking require immutability?</source>
          <target state="translated">Почему использование Redux неглубокой проверки равенства требует неизменности?</target>
        </trans-unit>
        <trans-unit id="1e3c854da8974033215e1fa6680270278cfeb926" translate="yes" xml:space="preserve">
          <source>Why does a reducer mutating the state prevent React-Redux from re-rendering a wrapped component?</source>
          <target state="translated">Почему редуктор,мутирующий состояние,не позволяет React-Redux переделать оберточную деталь?</target>
        </trans-unit>
        <trans-unit id="8ee3c091a66db76035f8a4ca74463446e1e64e6a" translate="yes" xml:space="preserve">
          <source>Why does a selector mutating and returning a persistent object to &lt;code&gt;mapStateToProps&lt;/code&gt; prevent React-Redux from re-rendering a wrapped component?</source>
          <target state="translated">Почему изменяющийся селектор и возвращающий постоянный объект в &lt;code&gt;mapStateToProps&lt;/code&gt; не позволяет React-Redux повторно визуализировать обернутый компонент?</target>
        </trans-unit>
        <trans-unit id="644fb85f7f965c72f4406c2ac164f794580f3172" translate="yes" xml:space="preserve">
          <source>Why don't I have &lt;code&gt;this.props.dispatch&lt;/code&gt; available in my connected component?</source>
          <target state="translated">Почему в моем подключенном компоненте нет &lt;code&gt;this.props.dispatch&lt;/code&gt; ?</target>
        </trans-unit>
        <trans-unit id="9070dbd8c65265905f9ee4a7b2376e7eafe21a53" translate="yes" xml:space="preserve">
          <source>Why don't I have this.props.dispatch available in my connected component?</source>
          <target state="translated">Почему у меня нет этого реквизита в подключенном компоненте?</target>
        </trans-unit>
        <trans-unit id="187fff4819a25361b7b72220761e6b7a66afabd9" translate="yes" xml:space="preserve">
          <source>Why is immutability required by Redux?</source>
          <target state="translated">Почему &quot;Редукс&quot; требует непреложности?</target>
        </trans-unit>
        <trans-unit id="ef930e2cf88a5db6b834d3fe1be3317cae525972" translate="yes" xml:space="preserve">
          <source>Why is immutability required in Redux?</source>
          <target state="translated">Почему в Редуксе требуется непреложность?</target>
        </trans-unit>
        <trans-unit id="8bcdba5809f1620e1841e83e3768ab2d2842bcd2" translate="yes" xml:space="preserve">
          <source>Why is it &lt;code&gt;42&lt;/code&gt;, and not &lt;code&gt;0&lt;/code&gt;, this time? Because &lt;code&gt;createStore&lt;/code&gt; was called with &lt;code&gt;42&lt;/code&gt; as the second argument. This argument becomes the &lt;code&gt;state&lt;/code&gt; passed to your reducer along with the dummy action. &lt;strong&gt;This time, &lt;code&gt;state&lt;/code&gt; is not undefined (it's &lt;code&gt;42&lt;/code&gt;!), so ES6 default argument syntax has no effect.&lt;/strong&gt; The &lt;code&gt;state&lt;/code&gt; is &lt;code&gt;42&lt;/code&gt;, and &lt;code&gt;42&lt;/code&gt; is returned from the reducer.</source>
          <target state="translated">Почему на этот раз &lt;code&gt;42&lt;/code&gt; , а не &lt;code&gt;0&lt;/code&gt; ? Потому что &lt;code&gt;createStore&lt;/code&gt; был вызван со вторым аргументом &lt;code&gt;42&lt;/code&gt; . Этот аргумент становится &lt;code&gt;state&lt;/code&gt; переданным вашему редуктору вместе с фиктивным действием. &lt;strong&gt;На этот раз &lt;code&gt;state&lt;/code&gt; не является неопределенным (оно &lt;code&gt;42&lt;/code&gt; !), Поэтому синтаксис аргумента по умолчанию ES6 не имеет никакого эффекта. &lt;/strong&gt; &lt;code&gt;state&lt;/code&gt; является &lt;code&gt;42&lt;/code&gt; и &lt;code&gt;42&lt;/code&gt; возвращаются из редуктора.</target>
        </trans-unit>
        <trans-unit id="6d09f931d0864d72b3013ba7e135c68d6b2c0d13" translate="yes" xml:space="preserve">
          <source>Why is my component re-rendering too often?</source>
          <target state="translated">Почему мой компонент слишком часто переделывается?</target>
        </trans-unit>
        <trans-unit id="77273d55a2a0fbeee2220902bad56163a526b540" translate="yes" xml:space="preserve">
          <source>Why is this beneficial? &lt;strong&gt;It is often claimed that constants are unnecessary, and for small projects, this might be correct.&lt;/strong&gt; For larger projects, there are some benefits to defining action types as constants:</source>
          <target state="translated">Почему это выгодно? &lt;strong&gt;Часто утверждают, что константы не нужны, и для небольших проектов это может быть правильным. &lt;/strong&gt;Для более крупных проектов определение типов действий как констант дает некоторые преимущества:</target>
        </trans-unit>
        <trans-unit id="ff0296d28f6b024408ea92b7c1ed963cf8a64adf" translate="yes" xml:space="preserve">
          <source>Why isn't my component re-rendering, or my mapStateToProps running?</source>
          <target state="translated">Почему мой компонент не переименовывается,или моя картаStateToProps не работает?</target>
        </trans-unit>
        <trans-unit id="67ac165008f4be935481141e41f5ad4f0e445971" translate="yes" xml:space="preserve">
          <source>Why should &lt;code&gt;type&lt;/code&gt; be a string, or at least serializable? Why should my action types be constants?</source>
          <target state="translated">Почему &lt;code&gt;type&lt;/code&gt; должен быть строкой или, по крайней мере, сериализуемым? Почему мои типы действий должны быть константами?</target>
        </trans-unit>
        <trans-unit id="6250d26c1c06d76575d238d1fd90a39d732b6647" translate="yes" xml:space="preserve">
          <source>Why should I choose Immutable.JS as an immutable library?</source>
          <target state="translated">Почему в качестве непреложной библиотеки следует выбрать &quot;Immutable.JS&quot;?</target>
        </trans-unit>
        <trans-unit id="36a89fdc5d2eadc3e614ad18a6f439b16e06ba2e" translate="yes" xml:space="preserve">
          <source>Why should I use an immutable-focused library such as Immutable.JS?</source>
          <target state="translated">Почему я должен использовать такую библиотеку,как Immutable.JS?</target>
        </trans-unit>
        <trans-unit id="f9c9ff5d2aa97da2f3c187af80701dfecc789475" translate="yes" xml:space="preserve">
          <source>Why should type be a string, or at least serializable? Why should my action types be constants?</source>
          <target state="translated">Зачем набирать строку,или,по крайней мере,сериализуемую? Почему мои типы действий должны быть константами?</target>
        </trans-unit>
        <trans-unit id="dab3df4bfeab70c04e3398ba91567702008bac36" translate="yes" xml:space="preserve">
          <source>Why will shallow equality checking not work with mutable objects?</source>
          <target state="translated">Почему поверхностная проверка равенства не работает с мутирующими объектами?</target>
        </trans-unit>
        <trans-unit id="478cc11a21f0ce66c20e68a01399e12557bac4a6" translate="yes" xml:space="preserve">
          <source>Wikipedia: Associative Entity</source>
          <target state="translated">Википедия:Ассоциированная структура</target>
        </trans-unit>
        <trans-unit id="923fc7415b6af8016333316d63e41417d9181e99" translate="yes" xml:space="preserve">
          <source>Will having &amp;ldquo;one state tree&amp;rdquo; cause memory problems? Will dispatching many actions take up memory?</source>
          <target state="translated">Приведет ли &amp;laquo;одно дерево состояний&amp;raquo; к проблемам с памятью? Будет ли отправка большого количества действий занимать память?</target>
        </trans-unit>
        <trans-unit id="1ca4941ae83a69d23ea4d39fc06d98dc6f0b9802" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;https://github.com/reactjs/react-redux&quot;&gt;React Redux&lt;/a&gt;, the wrapper classes generated by the &lt;code&gt;connect()&lt;/code&gt; function do actually look for &lt;code&gt;props.store&lt;/code&gt; if it exists, but it's best if you wrap your root component in &lt;code&gt;&amp;lt;Provider store={store}&amp;gt;&lt;/code&gt; and let React Redux worry about passing the store down. This way components don't need to worry about importing a store module, and isolating a Redux app or enabling server rendering is much easier to do later.</source>
          <target state="translated">В &lt;a href=&quot;https://github.com/reactjs/react-redux&quot;&gt;React Redux&lt;/a&gt; классы-оболочки, сгенерированные функцией &lt;code&gt;connect()&lt;/code&gt; , действительно ищут &lt;code&gt;props.store&lt;/code&gt; , если он существует, но лучше всего, если вы обернете свой корневой компонент в &lt;code&gt;&amp;lt;Provider store={store}&amp;gt;&lt;/code&gt; и позволите React Redux беспокоиться о передаче магазин вниз. Таким образом, компонентам не нужно беспокоиться об импорте модуля магазина, а изолировать приложение Redux или включить серверный рендеринг намного проще позже.</target>
        </trans-unit>
        <trans-unit id="fb5a653a3a5bc160a77a07e48c7fddec333e9161" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;combineReducers()&lt;/code&gt; the behavior is more nuanced. Those reducers whose state is specified in &lt;code&gt;preloadedState&lt;/code&gt; will receive that state. Other reducers will receive &lt;code&gt;undefined&lt;/code&gt;&lt;em&gt;and because of that&lt;/em&gt; will fall back to the &lt;code&gt;state = ...&lt;/code&gt; default argument they specify.</source>
          <target state="translated">С &lt;code&gt;combineReducers()&lt;/code&gt; поведение более тонкое. Редукторы, состояние которых указано в &lt;code&gt;preloadedState&lt;/code&gt; , получат это состояние. Другие редукторы получат &lt;code&gt;undefined&lt;/code&gt; &lt;em&gt;и из-за этого&lt;/em&gt; вернутся к указанному ими аргументу &lt;code&gt;state = ...&lt;/code&gt; default.</target>
        </trans-unit>
        <trans-unit id="dcb12ee583209b8bb9b311e92be2aa73c59c20e7" translate="yes" xml:space="preserve">
          <source>With JavaScript, you can accidentally mutate an object (such as the Redux state tree) quite easily without realising it. For example, updating deeply nested properties, creating a new &lt;em&gt;reference&lt;/em&gt; to an object instead of a new object, or performing a shallow copy rather than a deep copy, can all lead to inadvertent object mutations, and can trip up even the most experienced JavaScript coder.</source>
          <target state="translated">С помощью JavaScript вы можете легко случайно изменить объект (например, дерево состояний Redux), даже не осознавая этого. Например, обновление глубоко вложенных свойств, создание новой &lt;em&gt;ссылки&lt;/em&gt; на объект вместо нового объекта или выполнение неглубокой копии, а не полной копии, все это может привести к непреднамеренным мутациям объекта и может сбить с толку даже самого опытного кодировщика JavaScript. .</target>
        </trans-unit>
        <trans-unit id="c279bb3233aaa1e17c77c8a143b0f1883f9cd4d7" translate="yes" xml:space="preserve">
          <source>With Redux, however, implementing undo history is a breeze. There are three reasons for this:</source>
          <target state="translated">Однако,с Redux внедрение истории отмены-это ветер.Этому есть три причины:</target>
        </trans-unit>
        <trans-unit id="30a10f999841101d22cd135f2d787dcfd7a220dd" translate="yes" xml:space="preserve">
          <source>With Redux, the same update logic can be described as a reducing function:</source>
          <target state="translated">В Redux та же самая логика обновления может быть описана как восстановительная функция:</target>
        </trans-unit>
        <trans-unit id="c60d5cf0665575903c5afa25eb7d3eed7b4fc200" translate="yes" xml:space="preserve">
          <source>With this out of the way, let's start writing our reducer by gradually teaching it to understand the &lt;a href=&quot;actions&quot;&gt;actions&lt;/a&gt; we defined earlier.</source>
          <target state="translated">Разобравшись с этим, давайте начнем писать наш редюсер, постепенно обучая его понимать &lt;a href=&quot;actions&quot;&gt;действия, которые&lt;/a&gt; мы определили ранее.</target>
        </trans-unit>
        <trans-unit id="fee9030454f12e22bef2b8be7208f6154da76739" translate="yes" xml:space="preserve">
          <source>Without &lt;a href=&quot;middleware&quot;&gt;middleware&lt;/a&gt;, Redux store only supports &lt;a href=&quot;../basics/dataflow&quot;&gt;synchronous data flow&lt;/a&gt;. This is what you get by default with &lt;a href=&quot;../api/createstore&quot;&gt;&lt;code&gt;createStore()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Без &lt;a href=&quot;middleware&quot;&gt;промежуточного программного обеспечения&lt;/a&gt; хранилище Redux поддерживает только &lt;a href=&quot;../basics/dataflow&quot;&gt;синхронный поток данных&lt;/a&gt; . Это то, что вы получаете по умолчанию с &lt;a href=&quot;../api/createstore&quot;&gt; &lt;code&gt;createStore()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b879db99111e27d801d9201a249f4ff8dadbc225" translate="yes" xml:space="preserve">
          <source>Without &lt;code&gt;combineReducers()&lt;/code&gt; or similar manual code, &lt;code&gt;preloadedState&lt;/code&gt; always wins over &lt;code&gt;state = ...&lt;/code&gt; in the reducer because the &lt;code&gt;state&lt;/code&gt; passed to the reducer &lt;em&gt;is&lt;/em&gt;&lt;code&gt;preloadedState&lt;/code&gt; and &lt;em&gt;is not&lt;/em&gt;&lt;code&gt;undefined&lt;/code&gt;, so the ES6 argument syntax doesn't apply.</source>
          <target state="translated">Без &lt;code&gt;combineReducers()&lt;/code&gt; или аналогичного ручного кода &lt;code&gt;preloadedState&lt;/code&gt; всегда побеждает &lt;code&gt;state = ...&lt;/code&gt; в редукторе, потому что &lt;code&gt;state&lt;/code&gt; передаваемое редуктору, &lt;em&gt;является &lt;/em&gt; &lt;code&gt;preloadedState&lt;/code&gt; и &lt;em&gt;не является &lt;/em&gt; &lt;code&gt;undefined&lt;/code&gt; , поэтому синтаксис аргумента ES6 не применяется.</target>
        </trans-unit>
        <trans-unit id="93111501bb024fd914d89cdba95cef4a48a41268" translate="yes" xml:space="preserve">
          <source>Without any middleware, &lt;a href=&quot;../api/store#dispatch&quot;&gt;&lt;code&gt;dispatch&lt;/code&gt;&lt;/a&gt; only accepts a plain object, so we have to perform AJAX calls inside our components:</source>
          <target state="translated">Без промежуточного программного обеспечения &lt;a href=&quot;../api/store#dispatch&quot;&gt; &lt;code&gt;dispatch&lt;/code&gt; &lt;/a&gt; принимает только простой объект, поэтому мы должны выполнять вызовы AJAX внутри наших компонентов:</target>
        </trans-unit>
        <trans-unit id="3eaee8c6d91975cebb24c4050db09591d953bf58" translate="yes" xml:space="preserve">
          <source>Won't calling &amp;ldquo;all my reducers&amp;rdquo; for each action be slow?</source>
          <target state="translated">Разве вызов &amp;laquo;всех моих редукторов&amp;raquo; для каждого действия не будет медленным?</target>
        </trans-unit>
        <trans-unit id="6136c4a62a84feac2443e18a9f39e199c0a98340" translate="yes" xml:space="preserve">
          <source>Wordpress's new admin page</source>
          <target state="translated">Новая страница администрирования Wordpress</target>
        </trans-unit>
        <trans-unit id="69c79c2885e8ffba979a60fb509366f84a77cc7d" translate="yes" xml:space="preserve">
          <source>Working with VK API (in Russian)</source>
          <target state="translated">Работа с ВК АПИ.</target>
        </trans-unit>
        <trans-unit id="1a31d58278381294346a4e44a8fa95eea8b2e991" translate="yes" xml:space="preserve">
          <source>Wouldn't it be nice if we logged every action that happens in the app, together with the state computed after it? When something goes wrong, we can look back at our log, and figure out which action corrupted the state.</source>
          <target state="translated">Разве не было бы хорошо,если бы мы записывали в журнал каждое действие,которое происходит в приложении,вместе с состоянием,вычисленным после него? Когда что-то идет не так,мы можем оглянуться на наш журнал,и выяснить,какое действие испортило состояние.</target>
        </trans-unit>
        <trans-unit id="287cf4a678ff4e9d1ea3555ab140fc6d89ea8b80" translate="yes" xml:space="preserve">
          <source>Wouldn't it be useful if, any time an error is thrown as a result of dispatching an action, we would send it to a crash reporting service like &lt;a href=&quot;https://getsentry.com/welcome/&quot;&gt;Sentry&lt;/a&gt; with the stack trace, the action that caused the error, and the current state? This way it's much easier to reproduce the error in development.</source>
          <target state="translated">Разве не было бы полезно, если бы каждый раз, когда в результате отправки действия возникает ошибка, мы отправляли бы ее в службу отчетов о сбоях, такую ​​как &lt;a href=&quot;https://getsentry.com/welcome/&quot;&gt;Sentry,&lt;/a&gt; с трассировкой стека, действием, вызвавшим ошибку, и текущим состоянием? Таким образом, гораздо проще воспроизвести ошибку в разработке.</target>
        </trans-unit>
        <trans-unit id="411ddc1bcac2f709ddb631f9805e03c11ac7e355" translate="yes" xml:space="preserve">
          <source>Wrapping the Reducer</source>
          <target state="translated">Упаковка редуктора</target>
        </trans-unit>
        <trans-unit id="ba0e9312c8cb9cd6ef1a61e5d88575514a7ba12b" translate="yes" xml:space="preserve">
          <source>Writing Tests</source>
          <target state="translated">Тесты на написание</target>
        </trans-unit>
        <trans-unit id="e92ef945f3ed541f8b7064bd91824ad741ef1405" translate="yes" xml:space="preserve">
          <source>Writing simple action creators can be tiresome and often ends up generating redundant boilerplate code:</source>
          <target state="translated">Написание простых действий создателей может быть утомительным и часто заканчивается генерацией избыточного кода шаблона:</target>
        </trans-unit>
        <trans-unit id="80dc0881b1c90b466a5ebf41c749b8683c142f76" translate="yes" xml:space="preserve">
          <source>Ximedes</source>
          <target state="translated">Ximedes</target>
        </trans-unit>
        <trans-unit id="5397e0583f14f6c88de06b1ef28f460a1fb5b0ae" translate="yes" xml:space="preserve">
          <source>Yes</source>
          <target state="translated">Yes</target>
        </trans-unit>
        <trans-unit id="885f3940d9ce7913d6e6d671fe072b2efd348d82" translate="yes" xml:space="preserve">
          <source>Yes, lots of them! To name just a few:</source>
          <target state="translated">Да,много! Назовем лишь несколько:</target>
        </trans-unit>
        <trans-unit id="677676d61dff082b230a183ba82de368a4fd2ae9" translate="yes" xml:space="preserve">
          <source>You Might Not Need Redux</source>
          <target state="translated">Тебе не нужен Редукс.</target>
        </trans-unit>
        <trans-unit id="b5debd85103d524869a8aafb925b357862c1933e" translate="yes" xml:space="preserve">
          <source>You can also enable the &lt;a href=&quot;recipes/usingobjectspreadoperator&quot;&gt;object spread operator proposal&lt;/a&gt; for a more succinct syntax:</source>
          <target state="translated">Вы также можете включить &lt;a href=&quot;recipes/usingobjectspreadoperator&quot;&gt;предложение оператора распространения объекта&lt;/a&gt; для более лаконичного синтаксиса:</target>
        </trans-unit>
        <trans-unit id="ea3d01095c6b6725a225b7568204932eba587586" translate="yes" xml:space="preserve">
          <source>You can always write a function that generates an action creator:</source>
          <target state="translated">Вы всегда можете написать функцию,которая генерирует создателя действия:</target>
        </trans-unit>
        <trans-unit id="ebedd29e20c0b181d70ffe15f5988d119d67516f" translate="yes" xml:space="preserve">
          <source>You can call &lt;a href=&quot;../api/store#dispatch&quot;&gt;&lt;code&gt;store.dispatch(action)&lt;/code&gt;&lt;/a&gt; from anywhere in your app, including components and XHR callbacks, or even at scheduled intervals.</source>
          <target state="translated">Вы можете вызвать &lt;a href=&quot;../api/store#dispatch&quot;&gt; &lt;code&gt;store.dispatch(action)&lt;/code&gt; &lt;/a&gt; из любого места в вашем приложении, включая компоненты и обратные вызовы XHR, или даже через запланированные интервалы.</target>
        </trans-unit>
        <trans-unit id="870b3b70e7feab01dc48305e33a3f7b71d9e003a" translate="yes" xml:space="preserve">
          <source>You can control state key names by using different keys for the reducers in the passed object. For example, you may call &lt;code&gt;combineReducers({ todos: myTodosReducer, counter: myCounterReducer })&lt;/code&gt; for the state shape to be &lt;code&gt;{ todos, counter }&lt;/code&gt;.</source>
          <target state="translated">Вы можете управлять именами ключей состояния, используя разные ключи для редукторов в переданном объекте. Например, вы можете вызвать &lt;code&gt;combineReducers({ todos: myTodosReducer, counter: myCounterReducer })&lt;/code&gt; чтобы форма состояния была &lt;code&gt;{ todos, counter }&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="84b80aff840c6b3c2cb0814711f2e90fb9add9aa" translate="yes" xml:space="preserve">
          <source>You can even write a custom middleware to describe calls to your API, like the &lt;a href=&quot;../introduction/examples#real-world&quot;&gt;real world example&lt;/a&gt; does.</source>
          <target state="translated">Вы даже можете написать собственное промежуточное ПО для описания вызовов вашего API, как это делается в &lt;a href=&quot;../introduction/examples#real-world&quot;&gt;реальном примере&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1bcfc87ae98655e6e4c23b31a5690541a13ff642" translate="yes" xml:space="preserve">
          <source>You can extract logging into a function:</source>
          <target state="translated">Вы можете извлечь вход в функцию:</target>
        </trans-unit>
        <trans-unit id="1306a831686a52c567f5d3446dae27226d983c27" translate="yes" xml:space="preserve">
          <source>You can find more examples in &lt;a href=&quot;https://github.com/xgrommx/awesome-redux&quot;&gt;Awesome Redux&lt;/a&gt;.</source>
          <target state="translated">Вы можете найти больше примеров в &lt;a href=&quot;https://github.com/xgrommx/awesome-redux&quot;&gt;Awesome Redux&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1db4cdd68a98570c03ba8a576e981e8641ef738b" translate="yes" xml:space="preserve">
          <source>You can find the official logo &lt;a href=&quot;https://github.com/reactjs/redux/tree/master/logo&quot;&gt;on GitHub&lt;/a&gt;.</source>
          <target state="translated">Вы можете найти официальный логотип &lt;a href=&quot;https://github.com/reactjs/redux/tree/master/logo&quot;&gt;на GitHub&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8fb1259c8d739932d68e05103d65deeafc4b13b1" translate="yes" xml:space="preserve">
          <source>You can see how this causes the state held by the store to change:</source>
          <target state="translated">Вы можете увидеть,как это приводит к изменению состояния магазина:</target>
        </trans-unit>
        <trans-unit id="a4eddcb9e81b002608a7bf4ef875c82738729233" translate="yes" xml:space="preserve">
          <source>You can set up your build tool of choice (Webpack, Browserify, etc.) to compile a bundle file into &lt;code&gt;static/bundle.js&lt;/code&gt;.</source>
          <target state="translated">Вы можете настроить любой инструмент сборки (Webpack, Browserify и т. Д.) Для компиляции файла пакета в &lt;code&gt;static/bundle.js&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="23310ba75752c6caee4c2c18e21c9fe454bf81a2" translate="yes" xml:space="preserve">
          <source>You can then pass &lt;code&gt;dispatch&lt;/code&gt; down to other components manually, if you want to.</source>
          <target state="translated">Затем вы можете передать &lt;code&gt;dispatch&lt;/code&gt; другим компонентам вручную, если хотите.</target>
        </trans-unit>
        <trans-unit id="f95f737abcdb30e78aa13a25f5076e2ef6dc3676" translate="yes" xml:space="preserve">
          <source>You can then use it everywhere instead of &lt;code&gt;store.dispatch()&lt;/code&gt;:</source>
          <target state="translated">Затем вы можете использовать его везде вместо &lt;code&gt;store.dispatch()&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="bfbaa58ba5417a98c5d0d32b5ce14eba1d4e2fef" translate="yes" xml:space="preserve">
          <source>You can use &lt;a href=&quot;https://github.com/acdlite/redux-promise&quot;&gt;redux-promise&lt;/a&gt; or &lt;a href=&quot;https://github.com/pburtchaell/redux-promise-middleware&quot;&gt;redux-promise-middleware&lt;/a&gt; to dispatch Promises instead of functions.</source>
          <target state="translated">Вы можете использовать &lt;a href=&quot;https://github.com/acdlite/redux-promise&quot;&gt;redux-prom&lt;/a&gt; или &lt;a href=&quot;https://github.com/pburtchaell/redux-promise-middleware&quot;&gt;redux-prom-middleware&lt;/a&gt; для отправки обещаний вместо функций.</target>
        </trans-unit>
        <trans-unit id="9d98266f375d43672febffb46f3ed5355675dc5b" translate="yes" xml:space="preserve">
          <source>You can use &lt;a href=&quot;https://github.com/redux-observable/redux-observable&quot;&gt;redux-observable&lt;/a&gt; to dispatch Observables.</source>
          <target state="translated">Вы можете использовать &lt;a href=&quot;https://github.com/redux-observable/redux-observable&quot;&gt;redux-observable&lt;/a&gt; для отправки Observables.</target>
        </trans-unit>
        <trans-unit id="8d9c266f69d53ba1763af2ada1d6653210151773" translate="yes" xml:space="preserve">
          <source>You can use Redux together with &lt;a href=&quot;https://facebook.github.io/react/&quot;&gt;React&lt;/a&gt;, or with any other view library.</source>
          <target state="translated">Вы можете использовать Redux вместе с &lt;a href=&quot;https://facebook.github.io/react/&quot;&gt;React&lt;/a&gt; или с любой другой библиотекой представлений.</target>
        </trans-unit>
        <trans-unit id="28d3cd95f0d488448a63a6b338cb50068a95d5d9" translate="yes" xml:space="preserve">
          <source>You can use it at all levels of your reducer structure, not just to create the root reducer. It's very common to have multiple combined reducers in various places, which are composed together to create the root reducer.</source>
          <target state="translated">Вы можете использовать его на всех уровнях структуры редуктора,а не только для создания корневого редуктора.Очень часто для создания корневого редуктора используется несколько комбинированных редукторов в разных местах,которые собираются вместе.</target>
        </trans-unit>
        <trans-unit id="490b5a07e2c5aad3ad0c9fd7a27a52665898f60e" translate="yes" xml:space="preserve">
          <source>You can use the &lt;a href=&quot;https://github.com/lelandrichardson/redux-pack&quot;&gt;redux-pack&lt;/a&gt; middleware to dispatch promise-based asynchronous actions.</source>
          <target state="translated">Вы можете использовать промежуточное ПО &lt;a href=&quot;https://github.com/lelandrichardson/redux-pack&quot;&gt;redux-pack&lt;/a&gt; для отправки асинхронных действий на основе обещаний.</target>
        </trans-unit>
        <trans-unit id="df0e299c97c2207cdace456ccd47c72d8b63f087" translate="yes" xml:space="preserve">
          <source>You can use the &lt;a href=&quot;https://github.com/yelouafi/redux-saga/&quot;&gt;redux-saga&lt;/a&gt; middleware to build more complex asynchronous actions.</source>
          <target state="translated">Вы можете использовать промежуточное ПО &lt;a href=&quot;https://github.com/yelouafi/redux-saga/&quot;&gt;redux-saga&lt;/a&gt; для создания более сложных асинхронных действий.</target>
        </trans-unit>
        <trans-unit id="2be61aa399225330ac3c7c8f8b6d9263d4b58435" translate="yes" xml:space="preserve">
          <source>You cannot mutate an immutable object; instead, you must mutate a copy of it, leaving the original intact.</source>
          <target state="translated">Вы не можете мутировать непреложный объект;вместо этого вы должны мутировать копию,оставляя оригинал нетронутым.</target>
        </trans-unit>
        <trans-unit id="9002cfc3dd43f6e0951811e8e815e8e77752e185" translate="yes" xml:space="preserve">
          <source>You could also give them different keys, or call functions differently. These two ways to write a combined reducer are equivalent:</source>
          <target state="translated">Вы также можете дать им различные клавиши или вызвать функции по-другому.Эти два способа написания комбинированного редуктора эквивалентны:</target>
        </trans-unit>
        <trans-unit id="1be388744a3e109fec6dfea1a28f5eb27d9ed9a9" translate="yes" xml:space="preserve">
          <source>You could even go as far as to make a generic filtering higher-order reducer:</source>
          <target state="translated">Можно даже сделать общий редуктор фильтрации более высокого порядка:</target>
        </trans-unit>
        <trans-unit id="1e73413f8379bbd8e9bb56a500c7eb3c5f375e13" translate="yes" xml:space="preserve">
          <source>You do not need to use Immutable.JS with Redux. Plain JavaScript, if written correctly, is perfectly capable of providing immutability without having to use an immutable-focused library.</source>
          <target state="translated">Вам не нужно использовать Immutable.JS с Redux.Простой JavaScript,если он написан корректно,вполне способен обеспечить неизменяемость без необходимости использования библиотеки с неизменяемым фокусом.</target>
        </trans-unit>
        <trans-unit id="9581e0ed51066ff103253aa77beee1d1478416ea" translate="yes" xml:space="preserve">
          <source>You don't have to define action type constants in a separate file, or even to define them at all. For a small project, it might be easier to just use string literals for action types. However, there are some benefits to explicitly declaring constants in larger codebases. Read &lt;a href=&quot;../recipes/reducingboilerplate&quot;&gt;Reducing Boilerplate&lt;/a&gt; for more practical tips on keeping your codebase clean.</source>
          <target state="translated">Вам не нужно определять константы типа действия в отдельном файле или даже определять их вообще. Для небольшого проекта может быть проще просто использовать строковые литералы для типов действий. Однако явное объявление констант в более крупных кодовых базах дает некоторые преимущества. Прочтите &lt;a href=&quot;../recipes/reducingboilerplate&quot;&gt;Reducing Boilerplate,&lt;/a&gt; чтобы получить больше практических советов по поддержанию чистоты вашей кодовой базы.</target>
        </trans-unit>
        <trans-unit id="199448d814bc5e9584035a52d2115857f50dad49" translate="yes" xml:space="preserve">
          <source>You have two reducers:</source>
          <target state="translated">У тебя два редуктора:</target>
        </trans-unit>
        <trans-unit id="192eb5ae977897417943647ddbcb6a6f3d4104d2" translate="yes" xml:space="preserve">
          <source>You may call &lt;a href=&quot;#dispatch&quot;&gt;&lt;code&gt;dispatch()&lt;/code&gt;&lt;/a&gt; from a change listener, with the following caveats:</source>
          <target state="translated">Вы можете вызвать &lt;a href=&quot;#dispatch&quot;&gt; &lt;code&gt;dispatch()&lt;/code&gt; &lt;/a&gt; из слушателя изменений со следующими оговорками:</target>
        </trans-unit>
        <trans-unit id="b929863aa2c2de96072c024f0b1ab365c66cfa6b" translate="yes" xml:space="preserve">
          <source>You may call &lt;a href=&quot;#dispatchaction&quot;&gt;&lt;code&gt;dispatch()&lt;/code&gt;&lt;/a&gt; from a change listener, with the following caveats:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ebca9d5f96869ed296e545e937054edc0f8c94d" translate="yes" xml:space="preserve">
          <source>You may call &lt;code&gt;combineReducers&lt;/code&gt; at any level of the reducer hierarchy. It doesn't have to happen at the top. In fact you may use it again to split the child reducers that get too complicated into independent grandchildren, and so on.</source>
          <target state="translated">Вы можете вызвать &lt;code&gt;combineReducers&lt;/code&gt; на любом уровне иерархии редюсеров . Это не обязательно должно происходить наверху. Фактически, вы можете использовать его снова, чтобы разделить слишком сложные дочерние редукторы на независимых внуков и так далее.</target>
        </trans-unit>
        <trans-unit id="3644afb1fd9b1feb972c2dc856f2ca012f2fd6b3" translate="yes" xml:space="preserve">
          <source>You may enhance &lt;a href=&quot;../api/createstore&quot;&gt;&lt;code&gt;createStore()&lt;/code&gt;&lt;/a&gt; with &lt;a href=&quot;../api/applymiddleware&quot;&gt;&lt;code&gt;applyMiddleware()&lt;/code&gt;&lt;/a&gt;. It is not required, but it lets you &lt;a href=&quot;asyncactions&quot;&gt;express asynchronous actions in a convenient way&lt;/a&gt;.</source>
          <target state="translated">Вы можете улучшить &lt;a href=&quot;../api/createstore&quot;&gt; &lt;code&gt;createStore()&lt;/code&gt; &lt;/a&gt; с помощью &lt;a href=&quot;../api/applymiddleware&quot;&gt; &lt;code&gt;applyMiddleware()&lt;/code&gt; &lt;/a&gt; . Это не обязательно, но позволяет &lt;a href=&quot;asyncactions&quot;&gt;удобно выражать асинхронные действия&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d912b7407f7325b0f1291dd95c400a5024e9614d" translate="yes" xml:space="preserve">
          <source>You may need to write some custom functions for handling some of these actions. This may require replacing &lt;code&gt;combineReducers&lt;/code&gt; with your own top-level reducer function. You can also use a utility such as &lt;a href=&quot;https://github.com/acdlite/reduce-reducers&quot;&gt;reduce-reducers&lt;/a&gt; to run &lt;code&gt;combineReducers&lt;/code&gt; to handle most actions, but also run a more specialized reducer for specific actions that cross state slices.</source>
          <target state="translated">Возможно, вам потребуется написать несколько пользовательских функций для обработки некоторых из этих действий. Это может потребовать замены &lt;code&gt;combineReducers&lt;/code&gt; вашей собственной функцией редуктора верхнего уровня. Вы также можете использовать такую ​​утилиту, как &lt;a href=&quot;https://github.com/acdlite/reduce-reducers&quot;&gt;reduce- &lt;/a&gt; &lt;code&gt;combineReducers&lt;/code&gt; для запуска combReducers для обработки большинства действий, но также можете запустить более специализированный reducer для определенных действий, которые пересекают срезы состояний.</target>
        </trans-unit>
        <trans-unit id="09059cc37b1193dbc15c30252c07daa76e286f64" translate="yes" xml:space="preserve">
          <source>You may optionally specify the initial state as the second argument to &lt;a href=&quot;../api/createstore&quot;&gt;&lt;code&gt;createStore()&lt;/code&gt;&lt;/a&gt;. This is useful for hydrating the state of the client to match the state of a Redux application running on the server.</source>
          <target state="translated">Вы можете дополнительно указать начальное состояние в качестве второго аргумента &lt;a href=&quot;../api/createstore&quot;&gt; &lt;code&gt;createStore()&lt;/code&gt; &lt;/a&gt; . Это полезно для гидратации состояния клиента, чтобы оно соответствовало состоянию приложения Redux, запущенного на сервере.</target>
        </trans-unit>
        <trans-unit id="3ee0e53b45fb2fa831d9c837168e8230281cd9d8" translate="yes" xml:space="preserve">
          <source>You may use a dedicated &lt;code&gt;status&lt;/code&gt; field in your actions:</source>
          <target state="translated">Вы можете использовать специальное поле &lt;code&gt;status&lt;/code&gt; в своих действиях:</target>
        </trans-unit>
        <trans-unit id="db87382954c55c5d2ee83adf7f38146a50266b8e" translate="yes" xml:space="preserve">
          <source>You may want to read &lt;a href=&quot;../advanced/asyncactions&quot;&gt;Async Actions&lt;/a&gt; to learn more about expressing asynchronous flow in Redux with async primitives such as Promises and thunks. Keep in mind that anything you learn there can also be applied to universal rendering.</source>
          <target state="translated">Вы можете прочитать &lt;a href=&quot;../advanced/asyncactions&quot;&gt;Асинхронные действия,&lt;/a&gt; чтобы узнать больше о выражении асинхронного потока в Redux с помощью асинхронных примитивов, таких как промисы и переходы. Имейте в виду, что все, что вы там узнаете, также можно применить к универсальному рендерингу.</target>
        </trans-unit>
        <trans-unit id="ec6c69e4ca4e0cce6a488148dc045be49daaf6a8" translate="yes" xml:space="preserve">
          <source>You may wrap one or more reducers in &lt;code&gt;undoable&lt;/code&gt; at any level of the reducer composition hierarchy. We choose to wrap &lt;code&gt;todos&lt;/code&gt; instead of the top-level combined reducer so that changes to &lt;code&gt;visibilityFilter&lt;/code&gt; are not reflected in the undo history.</source>
          <target state="translated">Вы можете обернуть один или несколько редукторов в &lt;code&gt;undoable&lt;/code&gt; на любом уровне иерархии состава редукторов. Мы выбираем , чтобы обернуть &lt;code&gt;todos&lt;/code&gt; вместо верхнего уровня комбинированный редуктор таким образом , что изменения в &lt;code&gt;visibilityFilter&lt;/code&gt; не отражены в истории отмен.</target>
        </trans-unit>
        <trans-unit id="b5dbd93add81c61b1e16815b79f40079a123eba8" translate="yes" xml:space="preserve">
          <source>You might ask: why don't we bind the action creators to the store instance right away, like in classical Flux? The problem is that this won't work well with universal apps that need to render on the server. Most likely you want to have a separate store instance per request so you can prepare them with different data, but binding action creators during their definition means you're stuck with a single store instance for all requests.</source>
          <target state="translated">Вы можете спросить:почему бы нам сразу не привязать создателей экшена к экземпляру магазина,как в классическом фильме Flux? Проблема в том,что это не сработает с универсальными приложениями,которые нужно рендерить на сервере.Скорее всего,вы захотите иметь отдельный экземпляр хранилища для каждого запроса,чтобы можно было подготовить их с разными данными,но привязка создателей экшенов во время их определения означает,что вы застряли с одним экземпляром хранилища для всех запросов.</target>
        </trans-unit>
        <trans-unit id="2896f8f64f8c4e00e8362d43f027ff694ea34032" translate="yes" xml:space="preserve">
          <source>You might be familiar with &lt;a href=&quot;https://en.wikipedia.org/wiki/Higher-order_function&quot;&gt;higher order functions&lt;/a&gt;. If you use React, you might be familiar with &lt;a href=&quot;https://medium.com/@dan_abramov/mixins-are-dead-long-live-higher-order-components-94a0d2f9e750&quot;&gt;higher order components&lt;/a&gt;. Here is a variation on the same pattern, applied to reducers.</source>
          <target state="translated">Возможно, вы знакомы с &lt;a href=&quot;https://en.wikipedia.org/wiki/Higher-order_function&quot;&gt;функциями высшего порядка&lt;/a&gt; . Если вы используете React, возможно, вы знакомы с &lt;a href=&quot;https://medium.com/@dan_abramov/mixins-are-dead-long-live-higher-order-components-94a0d2f9e750&quot;&gt;компонентами более высокого порядка&lt;/a&gt; . Вот вариант того же шаблона, примененный к редукторам.</target>
        </trans-unit>
        <trans-unit id="fc80378efa78f4250982b149969a4e4206388634" translate="yes" xml:space="preserve">
          <source>You might have heard that Redux was influenced by &lt;a href=&quot;https://github.com/evancz/elm-architecture-tutorial/&quot;&gt;Elm Architecture&lt;/a&gt;. It shouldn't come as a surprise that this example is very similar to &lt;a href=&quot;http://package.elm-lang.org/packages/TheSeamau5/elm-undo-redo/2.0.0&quot;&gt;elm-undo-redo package&lt;/a&gt;.</source>
          <target state="translated">Возможно, вы слышали, что Redux находился под влиянием &lt;a href=&quot;https://github.com/evancz/elm-architecture-tutorial/&quot;&gt;Elm Architecture&lt;/a&gt; . Неудивительно, что этот пример очень похож на &lt;a href=&quot;http://package.elm-lang.org/packages/TheSeamau5/elm-undo-redo/2.0.0&quot;&gt;пакет elm-undo-redo&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="be8f897b9ef506870651387b41362b89ab366329" translate="yes" xml:space="preserve">
          <source>You might want to use it to apply several &lt;a href=&quot;../glossary#store-enhancer&quot;&gt;store enhancers&lt;/a&gt; in a row.</source>
          <target state="translated">Возможно, вы захотите использовать его для применения нескольких &lt;a href=&quot;../glossary#store-enhancer&quot;&gt;усилителей магазина&lt;/a&gt; подряд.</target>
        </trans-unit>
        <trans-unit id="cb8edb49caaa697733e02d643699b140e0476f6b" translate="yes" xml:space="preserve">
          <source>You might write an action creator in a separate file, and import it into your component:</source>
          <target state="translated">Вы можете написать создателя действия в отдельном файле и импортировать его в свой компонент:</target>
        </trans-unit>
        <trans-unit id="5012c361d888ca9c67b230342b72327b08a9b0ab" translate="yes" xml:space="preserve">
          <source>You never see this, of course - the data you give to an Immutable.JS object is never mutated. Rather, it&amp;rsquo;s the &lt;em&gt;intermediate&lt;/em&gt; data generated within Immutable.JS from a chained sequence of method calls that is free to be mutated. You therefore get all the benefits of immutable data structures with none (or very little) of the potential performance hits.</source>
          <target state="translated">Вы, конечно, никогда этого не увидите - данные, которые вы передаете объекту Immutable.JS, никогда не изменяются. Скорее, это &lt;em&gt;промежуточные&lt;/em&gt; данные, сгенерированные в Immutable.JS из связанной последовательности вызовов методов, которые могут быть изменены. Таким образом, вы получаете все преимущества неизменяемых структур данных без какого-либо (или очень небольшого) снижения производительности.</target>
        </trans-unit>
        <trans-unit id="536f6105b2c796a51f197bb3552df6076809a08a" translate="yes" xml:space="preserve">
          <source>You will need to wrap the reducer you wish to enhance with &lt;code&gt;undoable&lt;/code&gt; function. For example, if you exported a &lt;code&gt;todos&lt;/code&gt; reducer from a dedicated file, you will want to change it to export the result of calling &lt;code&gt;undoable()&lt;/code&gt; with the reducer you wrote:</source>
          <target state="translated">Вам нужно будет обернуть редуктор, который вы хотите улучшить, с функцией &lt;code&gt;undoable&lt;/code&gt; . Например, если вы экспортировали редуктор &lt;code&gt;todos&lt;/code&gt; из специального файла, вы захотите изменить его, чтобы экспортировать результат вызова &lt;code&gt;undoable()&lt;/code&gt; с помощью написанного вами редуктора:</target>
        </trans-unit>
        <trans-unit id="0d71f702363520e8d52cd5cf66c6865dbac24253" translate="yes" xml:space="preserve">
          <source>You will probably want to remove the hash from the URL (e.g: &lt;code&gt;http://localhost:3000/#/?_k=4sbb0i&lt;/code&gt;). For doing this, you will need to also import &lt;code&gt;browserHistory&lt;/code&gt; from React Router:</source>
          <target state="translated">Вероятно, вы захотите удалить хеш из URL-адреса (например, &lt;code&gt;http://localhost:3000/#/?_k=4sbb0i&lt;/code&gt; ). Для этого вам также нужно будет импортировать &lt;code&gt;browserHistory&lt;/code&gt; из React Router:</target>
        </trans-unit>
        <trans-unit id="847e7a43a897e6825651ba6a7171789bd4f8c993" translate="yes" xml:space="preserve">
          <source>You will use &lt;code&gt;connect()&lt;/code&gt; from &lt;a href=&quot;https://github.com/reactjs/react-redux&quot;&gt;React Redux&lt;/a&gt; to generate a container component. To determine whether to enable Undo and Redo buttons, you can check &lt;code&gt;state.todos.past.length&lt;/code&gt; and &lt;code&gt;state.todos.future.length&lt;/code&gt;. You won't need to write action creators for performing undo and redo because Redux Undo already provides them:</source>
          <target state="translated">Вы будете использовать &lt;code&gt;connect()&lt;/code&gt; из &lt;a href=&quot;https://github.com/reactjs/react-redux&quot;&gt;React Redux&lt;/a&gt; для создания компонента контейнера. Чтобы определить, следует ли включать кнопки &amp;laquo;Отменить&amp;raquo; и &amp;laquo;Вернуть&amp;raquo;, вы можете проверить &lt;code&gt;state.todos.past.length&lt;/code&gt; и &lt;code&gt;state.todos.future.length&lt;/code&gt; . Вам не нужно писать создателей действий для выполнения отмены и повтора, потому что Redux Undo уже предоставляет их:</target>
        </trans-unit>
        <trans-unit id="ced3f60087b9c7dc7b64e901bea63d5a41a88099" translate="yes" xml:space="preserve">
          <source>You would only use the named export for tests.</source>
          <target state="translated">Вы бы использовали именованный экспорт только для тестов.</target>
        </trans-unit>
        <trans-unit id="f002654c7b958bdea2528eaaa9c1e1ce5d2cfe9d" translate="yes" xml:space="preserve">
          <source>You'll know when you need Flux. If you aren't sure if you need it, you don't need it.</source>
          <target state="translated">Ты узнаешь,когда тебе понадобится Флюс.Если ты не уверен,что он тебе нужен,он тебе не нужен.</target>
        </trans-unit>
        <trans-unit id="9e4884b4000a8d2ac41ed531bf7a37bd6a9faaa2" translate="yes" xml:space="preserve">
          <source>You'll often find that you need to store some data, as well as some UI state, in the state tree. This is fine, but try to keep the data separate from the UI state.</source>
          <target state="translated">Часто можно обнаружить,что в дереве состояний необходимо хранить некоторые данные,а также некоторое состояние пользовательского интерфейса.Это нормально,но постарайтесь хранить данные отдельно от состояния пользовательского интерфейса.</target>
        </trans-unit>
        <trans-unit id="483dc0e6baee4af78f1c3f12ab8f28dda9a34453" translate="yes" xml:space="preserve">
          <source>You've seen middleware in action in the &lt;a href=&quot;asyncactions&quot;&gt;Async Actions&lt;/a&gt; example. If you've used server-side libraries like &lt;a href=&quot;http://expressjs.com/&quot;&gt;Express&lt;/a&gt; and &lt;a href=&quot;http://koajs.com/&quot;&gt;Koa&lt;/a&gt;, you were also probably already familiar with the concept of &lt;em&gt;middleware&lt;/em&gt;. In these frameworks, middleware is some code you can put between the framework receiving a request, and the framework generating a response. For example, Express or Koa middleware may add CORS headers, logging, compression, and more. The best feature of middleware is that it's composable in a chain. You can use multiple independent third-party middleware in a single project.</source>
          <target state="translated">Вы видели промежуточное ПО в действии в примере с &lt;a href=&quot;asyncactions&quot;&gt;асинхронными действиями&lt;/a&gt; . Если вы использовали серверные библиотеки, такие как &lt;a href=&quot;http://expressjs.com/&quot;&gt;Express&lt;/a&gt; и &lt;a href=&quot;http://koajs.com/&quot;&gt;Koa&lt;/a&gt; , вы, вероятно, уже были знакомы с концепцией &lt;em&gt;промежуточного программного обеспечения&lt;/em&gt; . В этих фреймворках промежуточное ПО - это некоторый код, который вы можете поместить между фреймворком, получающим запрос, и фреймворком, генерирующим ответ. Например, промежуточное ПО Express или Koa может добавлять заголовки CORS, ведение журнала, сжатие и многое другое. Лучшая особенность промежуточного программного обеспечения заключается в том, что его можно компоновать в цепочку. В одном проекте можно использовать несколько независимых сторонних промежуточных программ.</target>
        </trans-unit>
        <trans-unit id="7028f3891ebf7e4827d5eaddfa0e16584b0b4466" translate="yes" xml:space="preserve">
          <source>Your dumb components should be pure; that is, they should produce the same output given the same input, and have no external dependencies. If you pass such a component an Immutable.JS object as a prop, you make it dependent upon Immutable.JS to extract the prop&amp;rsquo;s value and otherwise manipulate it.</source>
          <target state="translated">Ваши тупые компоненты должны быть чистыми; то есть они должны выдавать один и тот же результат при одном и том же вводе и не иметь внешних зависимостей. Если вы передадите такому компоненту объект Immutable.JS в качестве опоры, вы сделаете ее зависимой от Immutable.JS для извлечения значения опоры и других манипуляций с ней.</target>
        </trans-unit>
        <trans-unit id="395dd2fb0c94aec217ae48791e24ace04816fc89" translate="yes" xml:space="preserve">
          <source>Your process will look like this:</source>
          <target state="translated">Ваш процесс будет выглядеть так:</target>
        </trans-unit>
        <trans-unit id="2b13a159884d03a53c5b0abbb9540e28b3419ef7" translate="yes" xml:space="preserve">
          <source>Your selectors should return Immutable.JS objects</source>
          <target state="translated">Ваши селекторы должны возвращать объекты Immutable.JS.</target>
        </trans-unit>
        <trans-unit id="281e35c0465b8b3d761e36f053ead41086e72367" translate="yes" xml:space="preserve">
          <source>[&lt;code&gt;enhancer&lt;/code&gt;] &lt;em&gt;(Function)&lt;/em&gt;: The store enhancer. You may optionally specify it to enhance the store with third-party capabilities such as middleware, time travel, persistence, etc. The only store enhancer that ships with Redux is &lt;a href=&quot;applymiddleware&quot;&gt;&lt;code&gt;applyMiddleware()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">[ &lt;code&gt;enhancer&lt;/code&gt; ] &lt;em&gt;(Функция)&lt;/em&gt; : Усилитель хранилища. При желании вы можете указать его для расширения магазина с помощью сторонних возможностей, таких как промежуточное ПО, путешествия во времени, постоянство и т. Д. Единственный усилитель хранилища, который поставляется с Redux, - это &lt;a href=&quot;applymiddleware&quot;&gt; &lt;code&gt;applyMiddleware()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="87286375e4668a58823fba92d2b07b7a44fc0be4" translate="yes" xml:space="preserve">
          <source>[&lt;code&gt;preloadedState&lt;/code&gt;] &lt;em&gt;(any)&lt;/em&gt;: The initial state. You may optionally specify it to hydrate the state from the server in universal apps, or to restore a previously serialized user session. If you produced &lt;code&gt;reducer&lt;/code&gt; with &lt;a href=&quot;combinereducers&quot;&gt;&lt;code&gt;combineReducers&lt;/code&gt;&lt;/a&gt;, this must be a plain object with the same shape as the keys passed to it. Otherwise, you are free to pass anything that your &lt;code&gt;reducer&lt;/code&gt; can understand.</source>
          <target state="translated">[ &lt;code&gt;preloadedState&lt;/code&gt; ] &lt;em&gt;(любой)&lt;/em&gt; : начальное состояние. При желании вы можете указать его для гидратации состояния с сервера в универсальных приложениях или для восстановления ранее сериализованного сеанса пользователя. Если производится &lt;code&gt;reducer&lt;/code&gt; с &lt;a href=&quot;combinereducers&quot;&gt; &lt;code&gt;combineReducers&lt;/code&gt; &lt;/a&gt; , это должно быть простым объектом с такой же формой , как и ключи , переданных ему. В противном случае вы можете передать все, что может понять ваш &lt;code&gt;reducer&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c70c7e915a4a2b3601daa15f9ed309a470505e50" translate="yes" xml:space="preserve">
          <source>and configure it to use ES2015 features in &lt;code&gt;.babelrc&lt;/code&gt;:</source>
          <target state="translated">и настройте его для использования функций &lt;code&gt;.babelrc&lt;/code&gt; в .babelrc :</target>
        </trans-unit>
        <trans-unit id="fd3ab734b4fb4c62257230890e59143d0e998962" translate="yes" xml:space="preserve">
          <source>and pass it to the &lt;code&gt;&amp;lt;Router /&amp;gt;&lt;/code&gt; in order to remove the hash from the URL:</source>
          <target state="translated">и передайте его &lt;code&gt;&amp;lt;Router /&amp;gt;&lt;/code&gt; , чтобы удалить хеш из URL:</target>
        </trans-unit>
        <trans-unit id="5f432ecbf9e6a7a5c1f170d992e60626ab120d96" translate="yes" xml:space="preserve">
          <source>and run &lt;code&gt;npm test&lt;/code&gt; to run it once, or &lt;code&gt;npm run test:watch&lt;/code&gt; to test on every file change.</source>
          <target state="translated">и запустите &lt;code&gt;npm test&lt;/code&gt; , чтобы запустить его один раз, или &lt;code&gt;npm run test:watch&lt;/code&gt; , чтобы проверять каждое изменение файла.</target>
        </trans-unit>
        <trans-unit id="f81edf81cd89734f8439987c58e09f5451875a46" translate="yes" xml:space="preserve">
          <source>and then pass the state along to the client.</source>
          <target state="translated">а затем передать состояние клиенту.</target>
        </trans-unit>
        <trans-unit id="f3894228d526596c3cf53c57bbed5aae8b11537a" translate="yes" xml:space="preserve">
          <source>applyMiddleware()</source>
          <target state="translated">applyMiddleware()</target>
        </trans-unit>
        <trans-unit id="b6ad41cdd6bf4c2b18169a773d483861384cd204" translate="yes" xml:space="preserve">
          <source>applyMiddleware(...middleware)</source>
          <target state="translated">applyMiddleware(...middleware)</target>
        </trans-unit>
        <trans-unit id="7fedb9730abc492e1bcf1596264f044b04661aab" translate="yes" xml:space="preserve">
          <source>applyMiddleware(...middlewares)</source>
          <target state="translated">applyMiddleware(...middlewares)</target>
        </trans-unit>
        <trans-unit id="3f5c37526331395762baf88047f99e6d8b619f94" translate="yes" xml:space="preserve">
          <source>bindActionCreators()</source>
          <target state="translated">bindActionCreators()</target>
        </trans-unit>
        <trans-unit id="88e632a0686333c0fcc1b71ebd9b524a2ddd992d" translate="yes" xml:space="preserve">
          <source>bindActionCreators(actionCreators, dispatch)</source>
          <target state="translated">bindActionCreators(actionCreators,диспетчерская)</target>
        </trans-unit>
        <trans-unit id="3042d6bd02c4ca7273effadee7e63bf42bed16c9" translate="yes" xml:space="preserve">
          <source>calls the appropriate reducer and passes it the slice;</source>
          <target state="translated">звонит соответствующему редуктору и передает ему кусочек;</target>
        </trans-unit>
        <trans-unit id="c3cf4ce11b3b5577a3871fe5b3cd80587b04a46c" translate="yes" xml:space="preserve">
          <source>can be tested like:</source>
          <target state="translated">может быть проверено как:</target>
        </trans-unit>
        <trans-unit id="991b9417df7c9c174211ba006b7edc0195725286" translate="yes" xml:space="preserve">
          <source>combineReducers()</source>
          <target state="translated">combineReducers()</target>
        </trans-unit>
        <trans-unit id="50f164696008c84fbdf8d8f93fe6bbfa9b14e143" translate="yes" xml:space="preserve">
          <source>combineReducers(reducers)</source>
          <target state="translated">combineReducers(reducers)</target>
        </trans-unit>
        <trans-unit id="c8dc852570744e8e3067cca75ce9fe7af17afec8" translate="yes" xml:space="preserve">
          <source>compose()</source>
          <target state="translated">compose()</target>
        </trans-unit>
        <trans-unit id="5745a141fb4592e3d9eb885924e51235574f61c6" translate="yes" xml:space="preserve">
          <source>compose(...functions)</source>
          <target state="translated">compose(...functions)</target>
        </trans-unit>
        <trans-unit id="112d9f2631778cd8a08a4296c2ccbf312712f2b3" translate="yes" xml:space="preserve">
          <source>cpsubrian: React decorators for redux/react-router/immutable &amp;lsquo;smart&amp;rsquo; components</source>
          <target state="translated">cpsubrian: декораторы React для redux / response-router / неизменяемые 'умные' компоненты</target>
        </trans-unit>
        <trans-unit id="94ba045109577a1f4ae2fedc6ca6e16e7cec8d37" translate="yes" xml:space="preserve">
          <source>create a fresh, new Redux store instance on every request;</source>
          <target state="translated">создавать свежий,новый экземпляр магазина Redux по каждому запросу;</target>
        </trans-unit>
        <trans-unit id="b44915cfa2285ca11f257a840e99d4d3f28fc3a7" translate="yes" xml:space="preserve">
          <source>createStore()</source>
          <target state="translated">createStore()</target>
        </trans-unit>
        <trans-unit id="6ab01e2a484c9683cca2393d2ba3c93180699ee0" translate="yes" xml:space="preserve">
          <source>createStore(reducer, [preloadedState], [enhancer])</source>
          <target state="translated">createStore(редуктор,[предустановленное состояние],[усилитель]).</target>
        </trans-unit>
        <trans-unit id="8fa33131b6a660bc8d77fd4bb48a66d021301526" translate="yes" xml:space="preserve">
          <source>creates a reference to the current state slice referred to by each key;</source>
          <target state="translated">создает ссылку на фрагмент текущего состояния,на который ссылается каждый ключ;</target>
        </trans-unit>
        <trans-unit id="e3a4682977bb863d850d9eae5d719e2585e731e5" translate="yes" xml:space="preserve">
          <source>creates a reference to the possibly-mutated state slice that's returned by the reducer.</source>
          <target state="translated">создает ссылку на возможно мутированный срез состояния,который возвращается редуктором.</target>
        </trans-unit>
        <trans-unit id="280c1cc5f52574880ff013357b30094632bcbd78" translate="yes" xml:space="preserve">
          <source>dispatch(action)</source>
          <target state="translated">dispatch(action)</target>
        </trans-unit>
        <trans-unit id="b6e86cff86751f0236e17d84f44ac6dc44060213" translate="yes" xml:space="preserve">
          <source>for scale, we have ~500 action types, ~400 reducer cases, ~150 components, 5 middlewares, ~200 actions, ~2300 tests</source>
          <target state="translated">для шкалы у нас есть ~500 типов действия,~400 корпусов редукторов,~150 компонентов,5 промежуточных устройств,~200 действий,~2300 тестов.</target>
        </trans-unit>
        <trans-unit id="5fe375f56e9a0fa7dc88b61b3c4b3425c5636e79" translate="yes" xml:space="preserve">
          <source>getState()</source>
          <target state="translated">getState()</target>
        </trans-unit>
        <trans-unit id="5cffe5ee80305aeabc52048276f1acf872533639" translate="yes" xml:space="preserve">
          <source>is equivalent to this:</source>
          <target state="translated">эквивалентно этому:</target>
        </trans-unit>
        <trans-unit id="1c0bbc97bd6780fb3baf83d4730c736904a39e76" translate="yes" xml:space="preserve">
          <source>optionally dispatch some actions;</source>
          <target state="translated">по желанию отправить некоторые действия;</target>
        </trans-unit>
        <trans-unit id="e7916345e570f1bcf19d018b0792a5db68935506" translate="yes" xml:space="preserve">
          <source>pull the state out of store;</source>
          <target state="translated">вытащить штат из магазина;</target>
        </trans-unit>
        <trans-unit id="71ad63d785b9b9fdb536fac77ce747b9c5a69bc1" translate="yes" xml:space="preserve">
          <source>react-redux-jwt-auth-example</source>
          <target state="translated">react-redux-jwt-auth-example</target>
        </trans-unit>
        <trans-unit id="52295e92a7867dd2bf6e329dcebd064d09c14653" translate="yes" xml:space="preserve">
          <source>redux-immutable</source>
          <target state="translated">redux-immutable</target>
        </trans-unit>
        <trans-unit id="a88f184d5bfff1ab2b78bc41b8b30999ba677a10" translate="yes" xml:space="preserve">
          <source>replaceReducer(nextReducer)</source>
          <target state="translated">replaceReducer(nextReducer)</target>
        </trans-unit>
        <trans-unit id="9a9bbe4119c43d2a84a043196b4690c761b01d0a" translate="yes" xml:space="preserve">
          <source>subscribe(listener)</source>
          <target state="translated">subscribe(listener)</target>
        </trans-unit>
        <trans-unit id="26c8253fda7262249d6aacde189c2d069461b383" translate="yes" xml:space="preserve">
          <source>the keys &lt;code&gt;todos&lt;/code&gt; and &lt;code&gt;counter&lt;/code&gt; each refer to a separate state slice;</source>
          <target state="translated">каждая из клавиш &lt;code&gt;todos&lt;/code&gt; и &lt;code&gt;counter&lt;/code&gt; относится к отдельному срезу состояния;</target>
        </trans-unit>
        <trans-unit id="afd2b6bf0fb616dda82e8ec1df11d135e0adf003" translate="yes" xml:space="preserve">
          <source>the values &lt;code&gt;myTodosReducer&lt;/code&gt; and &lt;code&gt;myCounterReducer&lt;/code&gt; are reducer functions, with each acting on the state slice identified by the respective key.</source>
          <target state="translated">значения &lt;code&gt;myTodosReducer&lt;/code&gt; и &lt;code&gt;myCounterReducer&lt;/code&gt; являются функциями-редукторами, каждая из которых действует на срез состояния, идентифицированный соответствующим ключом.</target>
        </trans-unit>
        <trans-unit id="365862a50c0682caa8baa6f30edca76e3e5f81ed" translate="yes" xml:space="preserve">
          <source>where:</source>
          <target state="translated">where:</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
