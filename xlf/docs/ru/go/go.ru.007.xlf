<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="go">
    <body>
      <group id="go">
        <trans-unit id="9d2d10677b59853b34c04edbc18da2141f6ef823" translate="yes" xml:space="preserve">
          <source>ParseCertificates parses one or more certificates from the given ASN.1 DER data. The certificates must be concatenated with no intermediate padding.</source>
          <target state="translated">ParseCertificates анализирует один или несколько сертификатов из предоставленных данных ASN.1 DER.Сертификаты должны быть объединены без промежуточной набивки.</target>
        </trans-unit>
        <trans-unit id="0fa30c63d37bc2001c3a764872c0890c61f8acf6" translate="yes" xml:space="preserve">
          <source>ParseDERCRL parses a DER encoded CRL from the given bytes.</source>
          <target state="translated">ParseDERCRL разбирает CRL в кодировке DER из заданных байтов.</target>
        </trans-unit>
        <trans-unit id="f3ec2edc0774eff41258539b91058f5d4cf9cd35" translate="yes" xml:space="preserve">
          <source>ParseDate parses an RFC 5322 date string.</source>
          <target state="translated">ParseDate анализирует строку даты RFC 5322.</target>
        </trans-unit>
        <trans-unit id="758fe9e9cbf2d56e3666f652d8acda7c98141564" translate="yes" xml:space="preserve">
          <source>ParseDir calls ParseFile for all files with names ending in &quot;.go&quot; in the directory specified by path and returns a map of package name -&amp;gt; package AST with all the packages found.</source>
          <target state="translated">ParseDir вызывает ParseFile для всех файлов с именами, заканчивающимися на &quot;.go&quot;, в каталоге, указанном в пути, и возвращает карту имени пакета -&amp;gt; пакет AST со всеми найденными пакетами.</target>
        </trans-unit>
        <trans-unit id="047621ddb91e82c184423e2a73f8e0cee328837e" translate="yes" xml:space="preserve">
          <source>ParseDirent parses up to max directory entries in buf, appending the names to names. It returns the number of bytes consumed from buf, the number of entries added to names, and the new names slice.</source>
          <target state="translated">ParseDirent анализирует максимум записей каталога в buf,добавляя имена к именам.Возвращает количество байт,потребляемых из buf,количество записей,добавленных в имена,и новый ломтик имён.</target>
        </trans-unit>
        <trans-unit id="ba15ad44a0d5b5aa5c04df3157000d88065b3088" translate="yes" xml:space="preserve">
          <source>ParseDuration</source>
          <target state="translated">ParseDuration</target>
        </trans-unit>
        <trans-unit id="0ccdc47cbfb062465c3ce4028258bbb8cace970b" translate="yes" xml:space="preserve">
          <source>ParseDuration parses a duration string. A duration string is a possibly signed sequence of decimal numbers, each with optional fraction and a unit suffix, such as &quot;300ms&quot;, &quot;-1.5h&quot; or &quot;2h45m&quot;. Valid time units are &quot;ns&quot;, &quot;us&quot; (or &quot;&amp;micro;s&quot;), &quot;ms&quot;, &quot;s&quot;, &quot;m&quot;, &quot;h&quot;.</source>
          <target state="translated">ParseDuration анализирует строку продолжительности. Строка продолжительности - это возможная последовательность десятичных чисел со знаком, каждое с необязательной дробью и суффиксом единицы измерения, например &amp;laquo;300 мс&amp;raquo;, &amp;laquo;-1,5 ч&amp;raquo; или &amp;laquo;2 ч 45 мин&amp;raquo;. Допустимые единицы времени: &amp;laquo;нс&amp;raquo;, &amp;laquo;нас&amp;raquo; (или &amp;laquo;мкс&amp;raquo;), &amp;laquo;мс&amp;raquo;, &amp;laquo;с&amp;raquo;, &amp;laquo;м&amp;raquo;, &amp;laquo;ч&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="6665378bb888147fd38985161b70b786f3c21803" translate="yes" xml:space="preserve">
          <source>ParseECPrivateKey parses an EC public key in SEC 1, ASN.1 DER form.</source>
          <target state="translated">ParseECPrivateKey анализирует открытый ключ ЕС в форме SEC 1,ASN.1 DER.</target>
        </trans-unit>
        <trans-unit id="892fbba930b3566d06f9df2030763cda6ce95827" translate="yes" xml:space="preserve">
          <source>ParseError describes a problem parsing a time string.</source>
          <target state="translated">ParseError описывает проблему разбора временной строки.</target>
        </trans-unit>
        <trans-unit id="9a582c1b02184d48074757655b946996d9f55882" translate="yes" xml:space="preserve">
          <source>ParseExpr is a convenience function for obtaining the AST of an expression x. The position information recorded in the AST is undefined. The filename used in error messages is the empty string.</source>
          <target state="translated">ParseExpr является удобной функцией для получения АСТ выражения x.Информация о позиции,записанная в АСТ,является неопределенной.Имя файла,используемое в сообщениях об ошибках-пустая строка.</target>
        </trans-unit>
        <trans-unit id="4fb56e49503c8edcde61d5f7c76a772eeec3484c" translate="yes" xml:space="preserve">
          <source>ParseExprFrom is a convenience function for parsing an expression. The arguments have the same meaning as for ParseFile, but the source must be a valid Go (type or value) expression. Specifically, fset must not be nil.</source>
          <target state="translated">ParseExprFrom-удобная функция для разбора выражения.Аргументы имеют то же значение,что и ParseFile,но источником должно быть корректное выражение Go (тип или значение).В частности,fset не должен быть нулевым.</target>
        </trans-unit>
        <trans-unit id="1451f0a6821c5b4b2901efe0f3d53819e7c6a483" translate="yes" xml:space="preserve">
          <source>ParseFile</source>
          <target state="translated">ParseFile</target>
        </trans-unit>
        <trans-unit id="8e9f94dbd4c4295f5a413cdec1747ee6881cd1da" translate="yes" xml:space="preserve">
          <source>ParseFile parses the source code of a single Go source file and returns the corresponding ast.File node. The source code may be provided via the filename of the source file, or via the src parameter.</source>
          <target state="translated">ParseFile разбирает исходный код одного Go файла и возвращает соответствующий ast.File узел.Исходный код может быть предоставлен через имя файла или через параметр src.</target>
        </trans-unit>
        <trans-unit id="af492bad6c90c31471d746324ef2632bf8eb772d" translate="yes" xml:space="preserve">
          <source>ParseFiles creates a new Template and parses the template definitions from the named files. The returned template's name will have the (base) name and (parsed) contents of the first file. There must be at least one file. If an error occurs, parsing stops and the returned *Template is nil.</source>
          <target state="translated">ParseFiles создает новый Шаблон и анализирует определения шаблонов из именованных файлов.Имя возвращаемого шаблона будет иметь (базовое)имя и (анализируется)содержимое первого файла.Должен быть как минимум один файл.Если происходит ошибка,парсинг прекращается и возвращаемый *Шаблон равен нулю.</target>
        </trans-unit>
        <trans-unit id="8327ff213ed2179b27e0e16f606053c1fb04d28d" translate="yes" xml:space="preserve">
          <source>ParseFiles creates a new Template and parses the template definitions from the named files. The returned template's name will have the base name and parsed contents of the first file. There must be at least one file. If an error occurs, parsing stops and the returned *Template is nil.</source>
          <target state="translated">ParseFiles создает новый Шаблон и анализирует определения шаблонов из именованных файлов.Имя возвращаемого шаблона будет иметь базовое имя и разобранное содержимое первого файла.Должен быть как минимум один файл.Если возникает ошибка,парсинг останавливается и возвращаемый *Шаблон равен нулю.</target>
        </trans-unit>
        <trans-unit id="ce6f3fc6adf60ff33bcdf40a608ef536cc90aa22" translate="yes" xml:space="preserve">
          <source>ParseFiles parses the named files and associates the resulting templates with t. If an error occurs, parsing stops and the returned template is nil; otherwise it is t. There must be at least one file.</source>
          <target state="translated">ParseFiles разбирает именованные файлы и связывает полученные шаблоны с t.При возникновении ошибки парсинг останавливается и возвращаемый шаблон равен нулю;в противном случае это t.Должен быть хотя бы один файл.</target>
        </trans-unit>
        <trans-unit id="79c733c837a6ce524269772c4ef5bf48fb11ea5a" translate="yes" xml:space="preserve">
          <source>ParseFiles parses the named files and associates the resulting templates with t. If an error occurs, parsing stops and the returned template is nil; otherwise it is t. There must be at least one file. Since the templates created by ParseFiles are named by the base names of the argument files, t should usually have the name of one of the (base) names of the files. If it does not, depending on t's contents before calling ParseFiles, t.Execute may fail. In that case use t.ExecuteTemplate to execute a valid template.</source>
          <target state="translated">ParseFiles разбирает именованные файлы и связывает полученные шаблоны с t.При возникновении ошибки парсинг останавливается и возвращаемый шаблон равен нулю;в противном случае это t.Должен быть хотя бы один файл.Поскольку шаблоны,создаваемые ParseFiles,именуются базовыми именами файлов-аргументов,t обычно должно иметь имя одного из (базовых)имен файлов.В противном случае,в зависимости от содержимого t перед вызовом ParseFiles,t.Execute может не сработать.В этом случае используйте t.ExecuteTemplate для выполнения действующего шаблона.</target>
        </trans-unit>
        <trans-unit id="91b51eccc60ebf92659e48c7256549a53f281cf8" translate="yes" xml:space="preserve">
          <source>ParseFiles returns an error if t or any associated template has already been executed.</source>
          <target state="translated">ParseFiles возвращает ошибку,если t или любой связанный с ним шаблон уже был выполнен.</target>
        </trans-unit>
        <trans-unit id="6b854a59dfcaea7000b265f3f7af7b0441340249" translate="yes" xml:space="preserve">
          <source>ParseFloat</source>
          <target state="translated">ParseFloat</target>
        </trans-unit>
        <trans-unit id="a968f6b35cbd445c2c3e17a676a673ab0f036e6d" translate="yes" xml:space="preserve">
          <source>ParseFloat accepts decimal and hexadecimal floating-point number syntax. If s is well-formed and near a valid floating-point number, ParseFloat returns the nearest floating-point number rounded using IEEE754 unbiased rounding. (Parsing a hexadecimal floating-point value only rounds when there are more bits in the hexadecimal representation than will fit in the mantissa.)</source>
          <target state="translated">ParseFloat принимает синтаксис десятичных и шестнадцатеричных чисел с плавающей точкой.Если s хорошо сформировано и близко к действительному числу с плавающей точкой,ParseFloat возвращает ближайшее число с плавающей точкой,округленное с помощью несмещенного округления по IEEE754.(Парсинг шестнадцатеричного числа с плавающей точкой округляется только тогда,когда в шестнадцатеричном представлении больше битов,чем поместится в мантиссу).</target>
        </trans-unit>
        <trans-unit id="af48529cc69b2749ba1cfbd0072a925bc4216cca" translate="yes" xml:space="preserve">
          <source>ParseFloat converts the string s to a floating-point number with the precision specified by bitSize: 32 for float32, or 64 for float64. When bitSize=32, the result still has type float64, but it will be convertible to float32 without changing its value.</source>
          <target state="translated">ParseFloat преобразует строку s в число с плавающей точкой с точностью,заданной в bitSize:32 для float32 или 64 для float64.Когда bitSize=32,результат все равно имеет тип float64,но он будет конвертирован в число с плавающей точкой float32 без изменения его значения.</target>
        </trans-unit>
        <trans-unit id="f8f279e3e47cdc9cf9d872e61192822459d62d17" translate="yes" xml:space="preserve">
          <source>ParseFloat is like f.Parse(s, base) with f set to the given precision and rounding mode.</source>
          <target state="translated">ParseFloat похож на f.Parse(s,base)с установкой f на заданную точность и режим округления.</target>
        </trans-unit>
        <trans-unit id="fd5ce5b41aa64ac617d720e123321224a7f4d140" translate="yes" xml:space="preserve">
          <source>ParseFloat recognizes the strings &quot;NaN&quot;, &quot;+Inf&quot;, and &quot;-Inf&quot; as their respective special floating point values. It ignores case when matching.</source>
          <target state="translated">ParseFloat распознает строки &quot;NaN&quot;,&quot;+Inf&quot; и &quot;-Inf&quot; как их соответствующие специальные значения с плавающей точкой.При совпадении игнорируется случай.</target>
        </trans-unit>
        <trans-unit id="7da060a59d225b78f860ce3acdb64ab957496796" translate="yes" xml:space="preserve">
          <source>ParseForm populates r.Form and r.PostForm.</source>
          <target state="translated">ParseForm заполняет r.Form и r.PostForm.</target>
        </trans-unit>
        <trans-unit id="07f8973752a66d43b70ef7fb0a84b494aed23663" translate="yes" xml:space="preserve">
          <source>ParseGlob creates a new Template and parses the template definitions from the files identified by the pattern. The files are matched according to the semantics of filepath.Match, and the pattern must match at least one file. The returned template will have the (base) name and (parsed) contents of the first file matched by the pattern. ParseGlob is equivalent to calling ParseFiles with the list of files matched by the pattern.</source>
          <target state="translated">ParseGlob создает новый шаблон и анализирует определения шаблонов из файлов,идентифицированных шаблоном.Файлы сопоставляются согласно семантике filepath.Match,и шаблон должен совпадать как минимум с одним файлом.Возвращаемый шаблон будет иметь (базовое)имя и (разобранное)содержимое первого файла,совпадающее с шаблоном.ParseGlob эквивалентен вызову ParseFiles со списком файлов,соответствующих шаблону.</target>
        </trans-unit>
        <trans-unit id="0041d2aedbde4c39f613a021a871fa8b33bebd33" translate="yes" xml:space="preserve">
          <source>ParseGlob parses the template definitions in the files identified by the pattern and associates the resulting templates with t. The files are matched according to the semantics of filepath.Match, and the pattern must match at least one file. ParseGlob is equivalent to calling t.ParseFiles with the list of files matched by the pattern.</source>
          <target state="translated">ParseGlob разбирает определения шаблонов в файлах,идентифицированных шаблоном,и связывает полученные шаблоны с t.Файлы сопоставляются согласно семантике filepath.Match,и шаблон должен совпадать как минимум с одним файлом.ParseGlob эквивалентен вызову t.ParseFiles со списком файлов,совпадающих по шаблону.</target>
        </trans-unit>
        <trans-unit id="57508561e68db8f352026127277c4527c06f1494" translate="yes" xml:space="preserve">
          <source>ParseGlob returns an error if t or any associated template has already been executed.</source>
          <target state="translated">ParseGlob возвращает ошибку,если t или любой связанный с ним шаблон уже был выполнен.</target>
        </trans-unit>
        <trans-unit id="1c95736c9372d59f539bafb6f91f3448c1e25ac0" translate="yes" xml:space="preserve">
          <source>ParseHTTPVersion parses a HTTP version string. &quot;HTTP/1.0&quot; returns (1, 0, true).</source>
          <target state="translated">ParseHTTPVersion анализирует строку версии HTTP.Возвращается &quot;HTTP/1.0&quot; (1,0,true).</target>
        </trans-unit>
        <trans-unit id="6238bd01ff6944e78dfd936bd2b841304ebe18fe" translate="yes" xml:space="preserve">
          <source>ParseIP</source>
          <target state="translated">ParseIP</target>
        </trans-unit>
        <trans-unit id="e5c3f7806dc6261b34a424f0eac37be19bc2181d" translate="yes" xml:space="preserve">
          <source>ParseIP parses s as an IP address, returning the result. The string s can be in dotted decimal (&quot;192.0.2.1&quot;) or IPv6 (&quot;2001:db8::68&quot;) form. If s is not a valid textual representation of an IP address, ParseIP returns nil.</source>
          <target state="translated">ParseIP разбирает s как IP-адрес,возвращая результат.Строка s может быть пунктирной десятичной (&quot;192.0.2.1&quot;)или IPv6 (&quot;2001:db8::68&quot;).Если s не является действительным текстовым представлением IP-адреса,ParseIP возвращает ноль.</target>
        </trans-unit>
        <trans-unit id="c329eecfda46c75a2f5a9732976e5ca2eab67b96" translate="yes" xml:space="preserve">
          <source>ParseInLocation</source>
          <target state="translated">ParseInLocation</target>
        </trans-unit>
        <trans-unit id="b946980b6995c0bdde650965df500396097ee47e" translate="yes" xml:space="preserve">
          <source>ParseInLocation is like Parse but differs in two important ways. First, in the absence of time zone information, Parse interprets a time as UTC; ParseInLocation interprets the time as in the given location. Second, when given a zone offset or abbreviation, Parse tries to match it against the Local location; ParseInLocation uses the given location.</source>
          <target state="translated">ParseInLocation похож на Parse,но отличается двумя важными способами.Во-первых,при отсутствии информации о часовом поясе Parse интерпретирует время как UTC;ParseInLocation интерпретирует время как в данном местоположении.Во-вторых,когда задано смещение или аббревиатура часового пояса,Parse пытается сопоставить его с локальным местоположением;ParseInLocation использует данное местоположение.</target>
        </trans-unit>
        <trans-unit id="fd43b39f1cc6436ed26bf5ddd12e6461d48a315e" translate="yes" xml:space="preserve">
          <source>ParseInt</source>
          <target state="translated">ParseInt</target>
        </trans-unit>
        <trans-unit id="da8e97b7f44fd2f5e3e7756990fdef1ef6036785" translate="yes" xml:space="preserve">
          <source>ParseInt interprets a string s in the given base (0, 2 to 36) and bit size (0 to 64) and returns the corresponding value i.</source>
          <target state="translated">ParseInt интерпретирует строку s в заданной базе (0,2-36)и размер бита (0-64)и возвращает соответствующее значение i.</target>
        </trans-unit>
        <trans-unit id="da7fc45328cc9114fb2744e73272d12d929fea5f" translate="yes" xml:space="preserve">
          <source>ParseList parses the given string as a list of comma-separated addresses of the form &quot;Gogh Fir &amp;lt;gf@example.com&amp;gt;&quot; or &quot;foo@example.com&quot;.</source>
          <target state="translated">ParseList анализирует данную строку как список адресов, разделенных запятыми, в форме &amp;laquo;Gogh Fir &amp;lt;gf@example.com&amp;gt;&amp;raquo; или &amp;laquo;foo@example.com&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="721a0c1b5d6d1ee41cb2e1ce2ccd8399686328dd" translate="yes" xml:space="preserve">
          <source>ParseMAC parses s as an IEEE 802 MAC-48, EUI-48, EUI-64, or a 20-octet IP over InfiniBand link-layer address using one of the following formats:</source>
          <target state="translated">ParseMAC анализируется как IEEE 802 MAC-48,EUI-48,EUI-64 или 20-октетовый IP-адрес линкового уровня InfiniBand с использованием одного из следующих форматов:</target>
        </trans-unit>
        <trans-unit id="76d8884907e134cde6d1ae2f450cf0d83b8102aa" translate="yes" xml:space="preserve">
          <source>ParseMediaType parses a media type value and any optional parameters, per RFC 1521. Media types are the values in Content-Type and Content-Disposition headers (RFC 2183). On success, ParseMediaType returns the media type converted to lowercase and trimmed of white space and a non-nil map. If there is an error parsing the optional parameter, the media type will be returned along with the error ErrInvalidMediaParameter. The returned map, params, maps from the lowercase attribute to the attribute value with its case preserved.</source>
          <target state="translated">ParseMediaType анализирует значение типа носителя и любые дополнительные параметры,согласно RFC 1521.Типы медиа-это значения в заголовках Content-Type и Content-Disposition (RFC 2183).При успешном разборе ParseMediaType возвращает тип медиа,преобразованный в нижний регистр и обрезанный из белого пространства и ненулевой карты.В случае ошибки при разборе дополнительного параметра возвращается тип носителя вместе с ошибкой ErrInvalidMediaParameter.Возвращаемая карта,параметры,карты из строчного атрибута в значение атрибута с сохранением его регистра.</target>
        </trans-unit>
        <trans-unit id="bb8befc3cebb8742e6d50cfeac64769f0a3fff7a" translate="yes" xml:space="preserve">
          <source>ParseMultipartForm calls ParseForm automatically. ParseForm is idempotent.</source>
          <target state="translated">ParseMultipartForm вызывает ParseForm автоматически.ParseForm является idempotent.</target>
        </trans-unit>
        <trans-unit id="4205ffb0814fbcba9218830e9ad58589fcb016f6" translate="yes" xml:space="preserve">
          <source>ParseMultipartForm parses a request body as multipart/form-data. The whole request body is parsed and up to a total of maxMemory bytes of its file parts are stored in memory, with the remainder stored on disk in temporary files. ParseMultipartForm calls ParseForm if necessary. After one call to ParseMultipartForm, subsequent calls have no effect.</source>
          <target state="translated">ParseMultipartForm разбирает тело запроса как многокомпонентные/формальные данные.Разбирается все тело запроса и в памяти хранится до суммарных байт maxMemory его файловых частей,а оставшаяся часть хранится на диске во временных файлах.При необходимости ParseMultipartForm вызывает ParseForm.После одного вызова ParseMultipartForm последующие вызовы не дают никакого эффекта.</target>
        </trans-unit>
        <trans-unit id="eecdedc3b85cbbe7f7cb2f75d45c36832c9b2317" translate="yes" xml:space="preserve">
          <source>ParseNetlinkMessage parses b as an array of netlink messages and returns the slice containing the NetlinkMessage structures.</source>
          <target state="translated">ParseNetlinkMessage разбирает b как массив сообщений netlink и возвращает фрагмент,содержащий структуры NetlinkMessage.</target>
        </trans-unit>
        <trans-unit id="2f0d8e60be2a0b26156f23d2b913830f42953f1b" translate="yes" xml:space="preserve">
          <source>ParseNetlinkRouteAttr parses m's payload as an array of netlink route attributes and returns the slice containing the NetlinkRouteAttr structures.</source>
          <target state="translated">ParseNetlinkRouteAttr анализирует мою полезную нагрузку как массив атрибутов маршрута Netlink и возвращает фрагмент,содержащий структуры NetlinkRouteAttr.</target>
        </trans-unit>
        <trans-unit id="ca8ea4136f1532755b07a48dc5268d78ecf1507c" translate="yes" xml:space="preserve">
          <source>ParsePKCS1PrivateKey parses an RSA private key in PKCS#1, ASN.1 DER form.</source>
          <target state="translated">ParsePKCS1PrivateKey анализирует частный ключ RSA в форме PKCS#1,ASN.1 DER.</target>
        </trans-unit>
        <trans-unit id="37bf10698677a842cf4d973614d5f0307c9b4ece" translate="yes" xml:space="preserve">
          <source>ParsePKCS1PublicKey parses an RSA public key in PKCS#1, ASN.1 DER form.</source>
          <target state="translated">ParsePKCS1PublicKey анализирует открытый ключ RSA в форме PKCS#1,ASN.1 DER.</target>
        </trans-unit>
        <trans-unit id="585855469081df34619bcab57c0395b99ac9b879" translate="yes" xml:space="preserve">
          <source>ParsePKCS8PrivateKey parses an unencrypted private key in PKCS#8, ASN.1 DER form.</source>
          <target state="translated">ParsePKCS8PrivateKey разбирает незашифрованный приватный ключ в форме PKCS#8,ASN.1 DER.</target>
        </trans-unit>
        <trans-unit id="53e14792de36ed6cd3349fb2645358e6cd29fbb8" translate="yes" xml:space="preserve">
          <source>ParsePKIXPublicKey</source>
          <target state="translated">ParsePKIXPublicKey</target>
        </trans-unit>
        <trans-unit id="6a4599b4f783a30e67850f302db74a263e5ed679" translate="yes" xml:space="preserve">
          <source>ParsePKIXPublicKey parses a public key in PKIX, ASN.1 DER form.</source>
          <target state="translated">ParsePKIXPublicKey анализирует открытый ключ в PKIX,ASN.1 DER форме.</target>
        </trans-unit>
        <trans-unit id="9e247d1a303dadeb36ebb627b0c5ca3e52bc27fd" translate="yes" xml:space="preserve">
          <source>ParseQuery</source>
          <target state="translated">ParseQuery</target>
        </trans-unit>
        <trans-unit id="7c00812498355c3d782c270a326950a437297e57" translate="yes" xml:space="preserve">
          <source>ParseQuery parses the URL-encoded query string and returns a map listing the values specified for each key. ParseQuery always returns a non-nil map containing all the valid query parameters found; err describes the first decoding error encountered, if any.</source>
          <target state="translated">ParseQuery анализирует закодированную по URL строку запроса и возвращает карту со значениями,указанными для каждого ключа.ParseQuery всегда возвращает неоткрытую карту,содержащую все найденные корректные параметры запроса;ошибка описывает первую встреченную ошибку декодирования,если таковая имеется.</target>
        </trans-unit>
        <trans-unit id="3d5fafc8859915dea1eca90debdb2203d7081d9e" translate="yes" xml:space="preserve">
          <source>ParseRequestURI parses rawurl into a URL structure. It assumes that rawurl was received in an HTTP request, so the rawurl is interpreted only as an absolute URI or an absolute path. The string rawurl is assumed not to have a #fragment suffix. (Web browsers strip #fragment before sending the URL to a web server.)</source>
          <target state="translated">ParseRequestURI разбирает rawurl в структуру URL.Предполагается,что rawurl был получен в HTTP-запросе,поэтому rawurl интерпретируется только как абсолютный URI или абсолютный путь.Предполагается,что строковая сырая ошибка не имеет суффикса #fragment.(Веб-браузеры снимают #fragment перед отправкой URL на веб-сервер).</target>
        </trans-unit>
        <trans-unit id="303cbaa0aec4b7b4cb545ea3bdd253a60da46165" translate="yes" xml:space="preserve">
          <source>ParseSocketControlMessage parses b as an array of socket control messages.</source>
          <target state="translated">ParseSocketControlMessage разбирает b как массив управляющих сообщений сокета.</target>
        </trans-unit>
        <trans-unit id="68f8375ee4255e9bdd0c3030df2260150e5493b0" translate="yes" xml:space="preserve">
          <source>ParseTime parses a time header (such as the Date: header), trying each of the three formats allowed by HTTP/1.1: TimeFormat, time.RFC850, and time.ANSIC.</source>
          <target state="translated">ParseTime анализирует временной заголовок (например,заголовок Date:),пробуя каждый из трех форматов,разрешенных HTTP/1.1:TimeFormat,time.RFC850,and time.ANSIC.</target>
        </trans-unit>
        <trans-unit id="d09c9d04f1ff3f62cff402b66559957826b67ae1" translate="yes" xml:space="preserve">
          <source>ParseUint</source>
          <target state="translated">ParseUint</target>
        </trans-unit>
        <trans-unit id="7c5c32fd6cd92c39f679dc5ed50b80a4f8a1e92b" translate="yes" xml:space="preserve">
          <source>ParseUint is like ParseInt but for unsigned numbers.</source>
          <target state="translated">ParseUint похож на ParseInt,но для неподписанных номеров.</target>
        </trans-unit>
        <trans-unit id="5bf4d74ce6c1b340caf3e896ab5b84ef49cf1719" translate="yes" xml:space="preserve">
          <source>ParseUnixCredentials decodes a socket control message that contains credentials in a Ucred structure. To receive such a message, the SO_PASSCRED option must be enabled on the socket.</source>
          <target state="translated">ParseUnixCredentials расшифровывает управляющее сообщение сокета,содержащее учетные данные в структуре Ucred.Для получения такого сообщения необходимо включить опцию SO_PASSCRED на сокет.</target>
        </trans-unit>
        <trans-unit id="f2cd01c6af8de29d78551fd8726d012bba380c6c" translate="yes" xml:space="preserve">
          <source>ParseUnixRights decodes a socket control message that contains an integer array of open file descriptors from another process.</source>
          <target state="translated">ParseUnixRights декодирует управляющее сообщение сокета,содержащее целый массив открытых файловых дескрипторов другого процесса.</target>
        </trans-unit>
        <trans-unit id="32ac0722953b3173953c3c4db2a050c68e2bace4" translate="yes" xml:space="preserve">
          <source>Parsed reports whether f.Parse has been called.</source>
          <target state="translated">Парсед сообщает,был ли вызван Ф.Парсе.</target>
        </trans-unit>
        <trans-unit id="3448f815420bc7428adf585d197c1f125467f90e" translate="yes" xml:space="preserve">
          <source>Parsed reports whether the command-line flags have been parsed.</source>
          <target state="translated">Обработан отчет о том,были ли обработаны флаги командной строки.</target>
        </trans-unit>
        <trans-unit id="dc2eb8678f8e8ede0972857e44c6282f328cc1fa" translate="yes" xml:space="preserve">
          <source>Passing skip=0 begins the stack trace at the call to Add inside rpc.NewClient. Passing skip=1 begins the stack trace at the call to NewClient inside mypkg.Run.</source>
          <target state="translated">Passing skip=0 начинает трассировку стека при вызове функции Add внутри rpc.NewClient.Passing skip=1 начинает трассировку стека при вызове в NewClient внутри mypkg.Run.</target>
        </trans-unit>
        <trans-unit id="bc137142636c80e92c407f2aa46fcdf54313c790" translate="yes" xml:space="preserve">
          <source>Password returns the password in case it is set, and whether it is set.</source>
          <target state="translated">Пароль возвращает пароль в том случае,если он установлен,а также в случае,если он установлен.</target>
        </trans-unit>
        <trans-unit id="2c6302867f847fe663bbe8d220f8e92a48796687" translate="yes" xml:space="preserve">
          <source>Path returns the package path.</source>
          <target state="translated">Путь возвращает путь пакета.</target>
        </trans-unit>
        <trans-unit id="d0506b7bdb505a3150b81c4c616dee83d176fcfa" translate="yes" xml:space="preserve">
          <source>PathError records an error and the operation and file path that caused it.</source>
          <target state="translated">PathError записывает ошибку и вызвавшую ее операцию и путь к файлу.</target>
        </trans-unit>
        <trans-unit id="e7599081a40b17f0e8c56bbb5dfa806da5a30888" translate="yes" xml:space="preserve">
          <source>PathEscape escapes the string so it can be safely placed inside a URL path segment, replacing special characters (including /) with %XX sequences as needed.</source>
          <target state="translated">PathEscape экранирует строку,чтобы ее можно было безопасно разместить внутри сегмента пути URL,заменяя специальные символы (включая /)на последовательности %XX по мере необходимости.</target>
        </trans-unit>
        <trans-unit id="5c3a77b47b5350edac8b6dbc79888f216cc42e3c" translate="yes" xml:space="preserve">
          <source>PathUnescape does the inverse transformation of PathEscape, converting each 3-byte encoded substring of the form &quot;%AB&quot; into the hex-decoded byte 0xAB. It returns an error if any % is not followed by two hexadecimal digits.</source>
          <target state="translated">PathUnescape выполняет обратное преобразование PathEscape,преобразуя каждую 3-байтовую закодированную подстроку формы &quot;%AB&quot; в шестнадцатеричный дешифрованный байт 0xAB.Возвращает ошибку,если за любым % не следуют две шестнадцатеричные цифры.</target>
        </trans-unit>
        <trans-unit id="40463bc26e83c862cf3b0e60286130df1ab877d6" translate="yes" xml:space="preserve">
          <source>PathUnescape is identical to QueryUnescape except that it does not unescape '+' to ' ' (space).</source>
          <target state="translated">PathUnescape идентичен QueryUnescape за исключением того,что он не отбрасывает символ '+' к '' (пробел).</target>
        </trans-unit>
        <trans-unit id="cda78fe9f7d0595a1e181ce1981b7483036ab29c" translate="yes" xml:space="preserve">
          <source>Patterns may optionally begin with a host name, restricting matches to URLs on that host only. Host-specific patterns take precedence over general patterns, so that a handler might register for the two patterns &quot;/codesearch&quot; and &quot;codesearch.google.com/&quot; without also taking over requests for &quot;&lt;a href=&quot;http://www.google.com/&quot;&gt;http://www.google.com/&lt;/a&gt;&quot;.</source>
          <target state="translated">Шаблоны могут необязательно начинаться с имени хоста, ограничивая совпадение URL-адресами только на этом хосте. Шаблоны, специфичные для хоста, имеют приоритет над общими шаблонами, так что обработчик может зарегистрироваться для двух шаблонов &quot;/ codesearch&quot; и &quot;codesearch.google.com/&quot;, не принимая также запросы для &quot; &lt;a href=&quot;http://www.google.com/&quot;&gt;http://www.google.com/&quot;&lt;/a&gt; &amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="c47c55adf239beb3a291abbb9f63d307ef60c16f" translate="yes" xml:space="preserve">
          <source>Patterns name fixed, rooted paths, like &quot;/favicon.ico&quot;, or rooted subtrees, like &quot;/images/&quot; (note the trailing slash). Longer patterns take precedence over shorter ones, so that if there are handlers registered for both &quot;/images/&quot; and &quot;/images/thumbnails/&quot;, the latter handler will be called for paths beginning &quot;/images/thumbnails/&quot; and the former will receive requests for any other paths in the &quot;/images/&quot; subtree.</source>
          <target state="translated">Фиксированное имя шаблона,корневые пути,например &quot;/favicon.ico&quot;,или корневые поддеревья,например &quot;/images/&quot; (обратите внимание на трейлинговую косую черту).Более длинные шаблоны имеют приоритет над более короткими,так что если зарегистрированы обработчики и для &quot;/images/&quot;,и для &quot;/images/thumbnails/&quot;,то второй обработчик будет вызван для путей,начинающихся с &quot;/images/thumbnails/&quot;,а первый получит запросы для любых других путей в поддереве &quot;/images/&quot;.</target>
        </trans-unit>
        <trans-unit id="f28eb62c201920349ad82fd89183cea2a77fc0ce" translate="yes" xml:space="preserve">
          <source>Peek returns the next Unicode character in the source without advancing the scanner. It returns EOF if the scanner's position is at the last character of the source.</source>
          <target state="translated">Peek возвращает следующий символ Юникода в исходном коде без продвижения сканера.Он возвращает EOF,если положение сканера находится на последнем символе источника.</target>
        </trans-unit>
        <trans-unit id="2959c1935503c7a46c0b1958e9d8a81763a0ed6a" translate="yes" xml:space="preserve">
          <source>Peek returns the next n bytes without advancing the reader. The bytes stop being valid at the next read call. If Peek returns fewer than n bytes, it also returns an error explaining why the read is short. The error is ErrBufferFull if n is larger than b's buffer size.</source>
          <target state="translated">Peek возвращает следующие n байтов,не продвигая читателя.Байты перестают быть действительными при следующем вызове считывателя.Если Peek возвращает меньше n байт,он также возвращает ошибку,объясняющую,почему чтение короткое.Ошибкой является ErrBufferFull,если n больше,чем размер буфера b.</target>
        </trans-unit>
        <trans-unit id="eb621fcca2c83af4eb20df9787fc904ec33fe0d9" translate="yes" xml:space="preserve">
          <source>Pending returns the number of unanswered requests that have been received on the connection.</source>
          <target state="translated">Pending возвращает количество запросов без ответа,которые были получены при соединении.</target>
        </trans-unit>
        <trans-unit id="c6855a32465d5bf0f448eaa4af31e378ea6b4379" translate="yes" xml:space="preserve">
          <source>Pending returns the number of unanswered requests that have been sent on the connection.</source>
          <target state="translated">Pending возвращает количество запросов без ответа,которые были отправлены при соединении.</target>
        </trans-unit>
        <trans-unit id="c7ceccb01b416098f13eef5c65da35dd4ef29c59" translate="yes" xml:space="preserve">
          <source>Perl character classes (all ASCII-only):</source>
          <target state="translated">Классы перловых символов (все только для ASCII):</target>
        </trans-unit>
        <trans-unit id="327a2b8cad2b9a6ef158a641755a49d69b9cc93f" translate="yes" xml:space="preserve">
          <source>Perm</source>
          <target state="translated">Perm</target>
        </trans-unit>
        <trans-unit id="b4cbc1d379695fc60a43435dd6614970bc7cf1c8" translate="yes" xml:space="preserve">
          <source>Perm returns the Unix permission bits in m.</source>
          <target state="translated">Perm возвращает биты разрешения Unix в m.</target>
        </trans-unit>
        <trans-unit id="6ed0eddcb867d78e7678ca142786b03c98fcc1cf" translate="yes" xml:space="preserve">
          <source>Perm returns, as a slice of n ints, a pseudo-random permutation of the integers [0,n) from the default Source.</source>
          <target state="translated">Пермь возвращает в виде кусочка n ints псевдослучайные перестановки целых чисел [0,n]из источника по умолчанию.</target>
        </trans-unit>
        <trans-unit id="62a4f6eab662c10e8c22fcd7a13a5adce4b9aeef" translate="yes" xml:space="preserve">
          <source>Perm returns, as a slice of n ints, a pseudo-random permutation of the integers [0,n).</source>
          <target state="translated">Пермь возвращает,в виде среза n ints,псевдослучайное перестановление целых чисел [0,n].</target>
        </trans-unit>
        <trans-unit id="2eb6560251a01ddeba6819d546ca94bf5106de3c" translate="yes" xml:space="preserve">
          <source>Phase returns the phase (also called the argument) of x. The returned value is in the range [-Pi, Pi].</source>
          <target state="translated">Фаза возвращает фазу (также называемую аргументом)x.Возвращаемое значение находится в диапазоне [-Pi,Pi].</target>
        </trans-unit>
        <trans-unit id="c62187a44c4849f243c0d01a0cd965d235c59c18" translate="yes" xml:space="preserve">
          <source>Pid returns the process id of the exited process.</source>
          <target state="translated">Pid возвращает идентификатор завершенного процесса.</target>
        </trans-unit>
        <trans-unit id="aaf942e54daedd7cb953cee036ee4e01d73e3a05" translate="yes" xml:space="preserve">
          <source>Ping verifies a connection to the database is still alive, establishing a connection if necessary.</source>
          <target state="translated">Ping проверяет соединение с БД,при необходимости устанавливая его.</target>
        </trans-unit>
        <trans-unit id="1616a118fdcaf54f337c10d117d16aaa99fd0b14" translate="yes" xml:space="preserve">
          <source>PingContext verifies a connection to the database is still alive, establishing a connection if necessary.</source>
          <target state="translated">PingContext проверяет соединение с БД,при необходимости устанавливая его.</target>
        </trans-unit>
        <trans-unit id="8c943ad1575fde013a5e267aa7a5a04d105d169b" translate="yes" xml:space="preserve">
          <source>PingContext verifies the connection to the database is still alive.</source>
          <target state="translated">PingContext проверяет,что соединение с базой данных все еще живое.</target>
        </trans-unit>
        <trans-unit id="7a788a1af96c8d9977c69732be97c930615c2f24" translate="yes" xml:space="preserve">
          <source>Pinger is an optional interface that may be implemented by a Conn.</source>
          <target state="translated">Пингер является дополнительным интерфейсом,который может быть реализован с помощью коннектора.</target>
        </trans-unit>
        <trans-unit id="00dae071c082bb73eaed17b4bb3429280e110e8c" translate="yes" xml:space="preserve">
          <source>Pipe</source>
          <target state="translated">Pipe</target>
        </trans-unit>
        <trans-unit id="e40f59609b56b44e5054b6b92f52ff52a16d5fa3" translate="yes" xml:space="preserve">
          <source>Pipe creates a synchronous in-memory pipe. It can be used to connect code expecting an io.Reader with code expecting an io.Writer.</source>
          <target state="translated">Труба создает синхронную трубу в памяти.Она может быть использована для соединения кода,ожидающего io.Reader,с кодом,ожидающим io.Writer.</target>
        </trans-unit>
        <trans-unit id="da50f6a47a89e9218a08186e61e447aeaa977683" translate="yes" xml:space="preserve">
          <source>Pipe creates a synchronous, in-memory, full duplex network connection; both ends implement the Conn interface. Reads on one end are matched with writes on the other, copying data directly between the two; there is no internal buffering.</source>
          <target state="translated">Pipe создает синхронное,внутрипамятное,полнодуплексное сетевое соединение;оба конца реализуют интерфейс Conn.Чтения на одном конце сопоставляются с записями на другом,копируя данные непосредственно между ними;отсутствует внутренняя буферизация.</target>
        </trans-unit>
        <trans-unit id="2a31ea2b0e32b3e571d1bceba86196d7bad1fcb8" translate="yes" xml:space="preserve">
          <source>Pipe returns a connected pair of Files; reads from r return bytes written to w. It returns the files and an error, if any.</source>
          <target state="translated">Pipe возвращает подключенную пару Файлов;читает из r возвращаемых байтов,записанных в w.Возвращает файлы и ошибку,если таковая имеется.</target>
        </trans-unit>
        <trans-unit id="20f3a37d20161b0046bc712fcc1c973a57a664dc" translate="yes" xml:space="preserve">
          <source>PipeNode holds a pipeline with optional declaration</source>
          <target state="translated">Трубный узел держит трубопровод с дополнительным декларированием</target>
        </trans-unit>
        <trans-unit id="f28715a2c22fba2d801918b67be067614e3917c8" translate="yes" xml:space="preserve">
          <source>Pipeline, to manage pipelined requests and responses in a client.</source>
          <target state="translated">Трубопровод,для управления конвейерными запросами и ответами в клиенте.</target>
        </trans-unit>
        <trans-unit id="c5df1e14fdba13b1a3f9690f736bcb2aac132e72" translate="yes" xml:space="preserve">
          <source>Pipelines</source>
          <target state="translated">Pipelines</target>
        </trans-unit>
        <trans-unit id="06fc1a48588c809599455a2829c6d8c93dab2807" translate="yes" xml:space="preserve">
          <source>PixOffset returns the index of the first element of Pix that corresponds to the pixel at (x, y).</source>
          <target state="translated">PixOffset возвращает индекс первого элемента Pix,который соответствует пикселю на (x,y).</target>
        </trans-unit>
        <trans-unit id="bf14eb94c114379d054dbd030d4c5c1a50c1bc82" translate="yes" xml:space="preserve">
          <source>Pkg returns the package to which the object belongs. The result is nil for labels and objects in the Universe scope.</source>
          <target state="translated">Pkg возвращает пакет,к которому принадлежит объект.Результат равен нулю для меток и объектов во Вселенной.</target>
        </trans-unit>
        <trans-unit id="6b25672d57f482ab04e1df337de0aebb92458d0d" translate="yes" xml:space="preserve">
          <source>PlainAuth</source>
          <target state="translated">PlainAuth</target>
        </trans-unit>
        <trans-unit id="0e0cce6c4e84e3f28344ac03eb2bbf3c7be04c28" translate="yes" xml:space="preserve">
          <source>PlainAuth returns an Auth that implements the PLAIN authentication mechanism as defined in RFC 4616. The returned Auth uses the given username and password to authenticate to host and act as identity. Usually identity should be the empty string, to act as username.</source>
          <target state="translated">PlainAuth возвращает Auth,который реализует механизм аутентификации PLAIN,как определено в RFC 4616.Возвращаемый Auth использует заданное имя пользователя и пароль для аутентификации на хосте и действия в качестве идентификации.Обычно идентификатором должна быть пустая строка,чтобы действовать в качестве имени пользователя.</target>
        </trans-unit>
        <trans-unit id="32488aca0b25b337080ddc28faef0ad97faab0e7" translate="yes" xml:space="preserve">
          <source>PlainAuth will only send the credentials if the connection is using TLS or is connected to localhost. Otherwise authentication will fail with an error, without sending the credentials.</source>
          <target state="translated">PlainAuth отправит учетные данные только в том случае,если соединение использует TLS или подключено к localhost.В противном случае аутентификация завершится ошибкой,без отправки учетных данных.</target>
        </trans-unit>
        <trans-unit id="b8996c869faa8282ed1dc0af722f7f384a441369" translate="yes" xml:space="preserve">
          <source>Plan 9</source>
          <target state="translated">План 9</target>
        </trans-unit>
        <trans-unit id="fcc50dd97b375efa9e5795002087751fd071d726" translate="yes" xml:space="preserve">
          <source>Plan9 is a 256-color palette that partitions the 24-bit RGB space into 4&amp;times;4&amp;times;4 subdivision, with 4 shades in each subcube. Compared to the WebSafe, the idea is to reduce the color resolution by dicing the color cube into fewer cells, and to use the extra space to increase the intensity resolution. This results in 16 gray shades (4 gray subcubes with 4 samples in each), 13 shades of each primary and secondary color (3 subcubes with 4 samples plus black) and a reasonable selection of colors covering the rest of the color cube. The advantage is better representation of continuous tones.</source>
          <target state="translated">Plan9 - это 256-цветная палитра, которая разделяет 24-битное пространство RGB на подразделения 4 &amp;times; 4 &amp;times; 4 с 4 оттенками в каждом подкубе. По сравнению с WebSafe идея состоит в том, чтобы уменьшить цветовое разрешение, разделив цветной куб на меньшее количество ячеек, и использовать дополнительное пространство для увеличения разрешения по интенсивности. В результате получается 16 оттенков серого (4 субкубика серого по 4 образца в каждом), 13 оттенков каждого основного и вторичного цвета (3 субкуба с 4 образцами плюс черный) и разумный выбор цветов, покрывающих остальную часть цветового куба. Преимущество заключается в лучшем воспроизведении непрерывных тонов.</target>
        </trans-unit>
        <trans-unit id="9d8a06b24fa70984798bf322daaec557c2b6f1b4" translate="yes" xml:space="preserve">
          <source>Playable Examples must be in a package whose name ends in &quot;_test&quot;. An Example is &quot;playable&quot; (the Play field is non-nil) in either of these circumstances:</source>
          <target state="translated">Воспроизводимые примеры должны быть в пакете,имя которого заканчивается на &quot;_test&quot;.Пример является &quot;воспроизводимым&quot; (игровое поле не является нулевым)в любом из этих случаев:</target>
        </trans-unit>
        <trans-unit id="2c6beabd4a6c27d664359314bb0b7be1a4bee461" translate="yes" xml:space="preserve">
          <source>Plugin is a loaded Go plugin.</source>
          <target state="translated">Плагин-это загруженный плагин Go.</target>
        </trans-unit>
        <trans-unit id="79d975c909286257ed2dc841463cf2221331b8a7" translate="yes" xml:space="preserve">
          <source>Pointer represents a pointer to an arbitrary type. There are four special operations available for type Pointer that are not available for other types:</source>
          <target state="translated">Указатель представляет собой указатель на произвольный тип.Для типа Pointer доступны четыре специальные операции,которые недоступны для других типов:</target>
        </trans-unit>
        <trans-unit id="c0c031e92d2b285f06539e450cbc88db48ddddac" translate="yes" xml:space="preserve">
          <source>Pointer returns v's value as a uintptr. It returns uintptr instead of unsafe.Pointer so that code using reflect cannot obtain unsafe.Pointers without importing the unsafe package explicitly. It panics if v's Kind is not Chan, Func, Map, Ptr, Slice, or UnsafePointer.</source>
          <target state="translated">Указатель возвращает значение v как uintptr.Он возвращает uintptr вместо опасного.Pointer,чтобы код,использующий reflect,не мог получить опасные.Pointers без явного импорта опасного пакета.Он паникует,если v's Kind не является Chan,Func,Map,Ptr,Slice или UnsafePointer.</target>
        </trans-unit>
        <trans-unit id="baef0ef34fa58ab846963eb42f08d22cc0916958" translate="yes" xml:space="preserve">
          <source>Pointer therefore allows a program to defeat the type system and read and write arbitrary memory. It should be used with extreme care.</source>
          <target state="translated">Таким образом,указатель позволяет программе побеждать систему типов,а также читать и записывать произвольную память.Его следует использовать с крайней осторожностью.</target>
        </trans-unit>
        <trans-unit id="c228a838e9e7815109b6016259a9375cc32a3ee5" translate="yes" xml:space="preserve">
          <source>Pointer values are deeply equal if they are equal using Go's == operator or if they point to deeply equal values.</source>
          <target state="translated">Значения указателей глубоко равны,если они равны с помощью оператора Go's ==или если они указывают на глубоко равные значения.</target>
        </trans-unit>
        <trans-unit id="ab46185459d2a7d78c59879c795ee53dd26dd358" translate="yes" xml:space="preserve">
          <source>Pointer values encode as the value pointed to. A nil pointer encodes as the null JSON value.</source>
          <target state="translated">Значения указателей кодируются как указанное значение.Нулевой указатель кодируется как нулевое значение JSON.</target>
        </trans-unit>
        <trans-unit id="d2cde07b059e3c084c9da753efae9fdd148fa375" translate="yes" xml:space="preserve">
          <source>Pointer:</source>
          <target state="translated">Pointer:</target>
        </trans-unit>
        <trans-unit id="b64fba6378c386a82e71d5a623e279c432da4e08" translate="yes" xml:space="preserve">
          <source>Polar</source>
          <target state="translated">Polar</target>
        </trans-unit>
        <trans-unit id="a5fb429c2bb667a352c2046e02293fc421f8310b" translate="yes" xml:space="preserve">
          <source>Polar returns the absolute value r and phase &amp;theta; of x, such that x = r * e**&amp;theta;i. The phase is in the range [-Pi, Pi].</source>
          <target state="translated">Polar возвращает абсолютное значение r и фазу &amp;theta; x, так что x = r * e ** &amp;theta;i. Фаза находится в диапазоне [-Pi, Pi].</target>
        </trans-unit>
        <trans-unit id="8e6bda38a58104dfd742e2b251475f4fc7ad35e0" translate="yes" xml:space="preserve">
          <source>Polynomials are represented in LSB-first form also known as reversed representation.</source>
          <target state="translated">Полиномы представлены в LSB-первой форме,также известной как обратное представление.</target>
        </trans-unit>
        <trans-unit id="778627418cb4b30cdfe47281afdbf30f1a173700" translate="yes" xml:space="preserve">
          <source>Pool</source>
          <target state="translated">Pool</target>
        </trans-unit>
        <trans-unit id="62976d6c6dce665baf19823706626b87a619028b" translate="yes" xml:space="preserve">
          <source>Pool's purpose is to cache allocated but unused items for later reuse, relieving pressure on the garbage collector. That is, it makes it easy to build efficient, thread-safe free lists. However, it is not suitable for all free lists.</source>
          <target state="translated">Назначение пула-кэшировать выделенные,но неиспользуемые предметы для последующего повторного использования,снижая давление на сборщик мусора.То есть,это облегчает построение эффективных,потокобезопасных,свободных списков.Однако,это подходит не для всех свободных списков.</target>
        </trans-unit>
        <trans-unit id="a894961424546348d9d455a430167c6470d0b453" translate="yes" xml:space="preserve">
          <source>Pop removes and returns the minimum element (according to Less) from the heap. The complexity is O(log n) where n = h.Len(). Pop is equivalent to Remove(h, 0).</source>
          <target state="translated">Pop удаляет и возвращает минимальный элемент (согласно Less)из кучи.Сложность-O(log n),где n=h.Len().Pop эквивалентен Remove(h,0).</target>
        </trans-unit>
        <trans-unit id="1c331ce3bd04c4d21d66fc2ae1a5de46dd73eec8" translate="yes" xml:space="preserve">
          <source>Port returns the port part of u.Host, without the leading colon.</source>
          <target state="translated">Порт возвращает портовую часть хозяина,без ведущей двоеточия.</target>
        </trans-unit>
        <trans-unit id="42cb37e41618d46d1d0e8d0bf5e059552b858cb3" translate="yes" xml:space="preserve">
          <source>Portable analogs of some common system call errors.</source>
          <target state="translated">Портативные аналоги некоторых распространенных ошибок системных вызовов.</target>
        </trans-unit>
        <trans-unit id="97e4fd0d08cb7c58f4698b53bcfb9441c857ebec" translate="yes" xml:space="preserve">
          <source>Pos and End describe the scope's source code extent [pos, end). The results are guaranteed to be valid only if the type-checked AST has complete position information. The extent is undefined for Universe and package scopes.</source>
          <target state="translated">В позициях и в конце описывается объем исходного кода области [поз,конец].Гарантируется,что результаты будут действительными только в том случае,если проверенная по типу AST информация о позиции является полной.Степень охвата не определена для Вселенной и диапазонов пакетов.</target>
        </trans-unit>
        <trans-unit id="4c60ba97a8cb410a549bfe181eeaa63408b55cba" translate="yes" xml:space="preserve">
          <source>Pos computes the source position of the declaration of an object name. The result may be an invalid position if it cannot be computed (obj.Decl may be nil or not correct).</source>
          <target state="translated">Pos вычисляет исходную позицию объявления имени объекта.Результатом может быть недействительная позиция,если ее невозможно вычислить (obj.Decl может быть нулевой или неверной).</target>
        </trans-unit>
        <trans-unit id="a0ec3702b899c2917ee8242be4cbe0bff05b9658" translate="yes" xml:space="preserve">
          <source>Pos is a compact encoding of a source position within a file set. It can be converted into a Position for a more convenient, but much larger, representation.</source>
          <target state="translated">Позиция представляет собой компактную кодировку исходной позиции в наборе файлов.Она может быть преобразована в позицию для более удобного,но гораздо большего представления.</target>
        </trans-unit>
        <trans-unit id="1b9fa7b2eba24dae9008da03956b9fa4fe5bac8a" translate="yes" xml:space="preserve">
          <source>Pos represents a byte position in the original input text from which this template was parsed.</source>
          <target state="translated">Позиция представляет собой позицию байта в исходном входном тексте,из которого был разобран этот шаблон.</target>
        </trans-unit>
        <trans-unit id="edf92f1280756c43fc75532da3d73537cdede740" translate="yes" xml:space="preserve">
          <source>Pos returns the Pos value for the given file offset; the offset must be &amp;lt;= f.Size(). f.Pos(f.Offset(p)) == p.</source>
          <target state="translated">Pos возвращает значение Pos для заданного смещения файла; смещение должно быть &amp;lt;= f.Size (). f.Pos (f.Offset (p)) == p.</target>
        </trans-unit>
        <trans-unit id="5ff010dde5f69bdb9f99370ef921975c8f9209ff" translate="yes" xml:space="preserve">
          <source>Pos returns the declaration position of the object's identifier.</source>
          <target state="translated">Поз возвращает позицию объявления идентификатора объекта.</target>
        </trans-unit>
        <trans-unit id="cd367287d957f8b0726b9d88a222f0d52b30fd66" translate="yes" xml:space="preserve">
          <source>Pos returns the position of the character immediately after the character or token returned by the last call to Next or Scan. Use the Scanner's Position field for the start position of the most recently scanned token.</source>
          <target state="translated">Позиция возвращает позицию символа сразу после символа или токена,возвращенного при последнем вызове на Next или Scan.Используйте поле Position (Положение)сканера для начальной позиции последнего отсканированного токена.</target>
        </trans-unit>
        <trans-unit id="e31be0876f71b9f08f689f98e0ab92c2ffe225b9" translate="yes" xml:space="preserve">
          <source>Pos values can be compared directly with the usual comparison operators: If two Pos values p and q are in the same file, comparing p and q is equivalent to comparing the respective source file offsets. If p and q are in different files, p &amp;lt; q is true if the file implied by p was added to the respective file set before the file implied by q.</source>
          <target state="translated">Значения Pos можно сравнивать напрямую с помощью обычных операторов сравнения: если два значения Pos p и q находятся в одном файле, сравнение p и q эквивалентно сравнению смещений соответствующих исходных файлов. Если p и q находятся в разных файлах, p &amp;lt;q истинно, если файл, подразумеваемый p, был добавлен в соответствующий набор файлов перед файлом, подразумеваемым q.</target>
        </trans-unit>
        <trans-unit id="5fc2fa994bbd914263ceb34efcf25eb956fe5e38" translate="yes" xml:space="preserve">
          <source>Position converts a Pos p in the fileset into a Position value. Calling s.Position(p) is equivalent to calling s.PositionFor(p, true).</source>
          <target state="translated">Position преобразует значение позиции p в файле в значение позиции.Вызов s.Position(p)эквивалентен вызову s.PositionFor(p,true).</target>
        </trans-unit>
        <trans-unit id="b93209a85028bf6019382a8729f55ac8145e29b1" translate="yes" xml:space="preserve">
          <source>Position describes an arbitrary source position including the file, line, and column location. A Position is valid if the line number is &amp;gt; 0.</source>
          <target state="translated">Позиция описывает произвольную исходную позицию, включая расположение файла, строки и столбца. Позиция действительна, если номер строки&amp;gt; 0.</target>
        </trans-unit>
        <trans-unit id="d1086db7e34e995911902270435427be7e528699" translate="yes" xml:space="preserve">
          <source>Position returns the Position value for the given file position p. Calling f.Position(p) is equivalent to calling f.PositionFor(p, true).</source>
          <target state="translated">Position возвращает значение Position для данной позиции файла p.Вызов f.Position(p)эквивалентен вызову f.PositionFor(p,true).</target>
        </trans-unit>
        <trans-unit id="9bee67f02828c19ef6ab2c5867d78daacd16a5b6" translate="yes" xml:space="preserve">
          <source>PositionFor converts a Pos p in the fileset into a Position value. If adjusted is set, the position may be adjusted by position-altering //line comments; otherwise those comments are ignored. p must be a Pos value in s or NoPos.</source>
          <target state="translated">PositionFor преобразует значение позиции p в файле в значение позиции.Если установлено,позиция может быть скорректирована путем изменения позиции //линейных комментариев,в противном случае эти комментарии игнорируются.p должно быть значение позиции в s или NoPos.</target>
        </trans-unit>
        <trans-unit id="3d4ffd5f491d5a7cdece709329d95542f519d748" translate="yes" xml:space="preserve">
          <source>PositionFor returns the Position value for the given file position p. If adjusted is set, the position may be adjusted by position-altering //line comments; otherwise those comments are ignored. p must be a Pos value in f or NoPos.</source>
          <target state="translated">PositionFor возвращает значение Position для данной позиции файла p.Если установлено,то позицию можно отрегулировать путем изменения позиции //строчных комментариев;в противном случае эти комментарии игнорируются.p должно быть значение позиции в f или NoPos.</target>
        </trans-unit>
        <trans-unit id="9ac52c588d2d22788d46da883fda78a4165f3071" translate="yes" xml:space="preserve">
          <source>Possible values for the EncryptPEMBlock encryption algorithm.</source>
          <target state="translated">Возможные значения для алгоритма шифрования EncryptPEMBlock.</target>
        </trans-unit>
        <trans-unit id="e039b08aed18ef386a63d77f040148c0406ea827" translate="yes" xml:space="preserve">
          <source>Post is a wrapper around DefaultClient.Post.</source>
          <target state="translated">Post-это обёртка вокруг DefaultClient.Post.</target>
        </trans-unit>
        <trans-unit id="4ccc94f360bffe8b14b21c70371bc08f8fc85aba" translate="yes" xml:space="preserve">
          <source>Post issues a POST to the specified URL.</source>
          <target state="translated">Отправьте POST на указанный URL.</target>
        </trans-unit>
        <trans-unit id="cf67d20c1f3d564f229d45c7bbe51d8dd1d5c4f9" translate="yes" xml:space="preserve">
          <source>PostForm is a wrapper around DefaultClient.PostForm.</source>
          <target state="translated">PostForm-это обёртка вокруг DefaultClient.PostForm.</target>
        </trans-unit>
        <trans-unit id="44be7db278a3bb23e34b6df9cf0308f04a22ef65" translate="yes" xml:space="preserve">
          <source>PostForm issues a POST to the specified URL, with data's keys and values URL-encoded as the request body.</source>
          <target state="translated">PostForm выдает POST к указанному URL,с ключами данных и значениями URL,закодированными как тело запроса.</target>
        </trans-unit>
        <trans-unit id="be4e82ca926447e7fa579fe9a0de6822470bae52" translate="yes" xml:space="preserve">
          <source>PostFormValue returns the first value for the named component of the POST, PATCH, or PUT request body. URL query parameters are ignored. PostFormValue calls ParseMultipartForm and ParseForm if necessary and ignores any errors returned by these functions. If key is not present, PostFormValue returns the empty string.</source>
          <target state="translated">PostFormValue возвращает первое значение для именованного компонента тела запроса POST,PATCH или PUT.Параметры запроса URL игнорируются.PostFormValue при необходимости вызывает ParseMultipartForm и ParseForm и игнорирует ошибки,возвращаемые этими функциями.Если ключ отсутствует,PostFormValue возвращает пустую строку.</target>
        </trans-unit>
        <trans-unit id="be28cb761efe315e0e552f0578874dbad93fb2dd" translate="yes" xml:space="preserve">
          <source>Pow</source>
          <target state="translated">Pow</target>
        </trans-unit>
        <trans-unit id="f475da806450b4216a6a39ef8f751e26584a0aa3" translate="yes" xml:space="preserve">
          <source>Pow returns x**y, the base-x exponential of y.</source>
          <target state="translated">Pow возвращает x**y,базовый x экспоненциальный y.</target>
        </trans-unit>
        <trans-unit id="6d31ee5908c32da0243ccfa92f5fe1c7b3e3aeaf" translate="yes" xml:space="preserve">
          <source>Pow returns x**y, the base-x exponential of y. For generalized compatibility with math.Pow:</source>
          <target state="translated">Pow возвращает x**y,базовый x экспоненциальный y.Для обобщенной совместимости с математикой.Pow:</target>
        </trans-unit>
        <trans-unit id="f348c46b140ea99d08517640a0cfa8eff3f40986" translate="yes" xml:space="preserve">
          <source>Pow10</source>
          <target state="translated">Pow10</target>
        </trans-unit>
        <trans-unit id="aee903bac5380775ed6f4d539640fd38f8839815" translate="yes" xml:space="preserve">
          <source>Pow10 returns 10**n, the base-10 exponential of n.</source>
          <target state="translated">Pow10 возвращает 10**n,базовый 10 экспоненциальный коэффициент n.</target>
        </trans-unit>
        <trans-unit id="5411be6b25a0cd127e0815f04ee1c12c71a3cf9d" translate="yes" xml:space="preserve">
          <source>Prec returns the mantissa precision of x in bits. The result may be 0 for |x| == 0 and |x| == Inf.</source>
          <target state="translated">Prec возвращает точность мантиссы x в битах.Результат может быть 0 для |x| ==0 и |x| ==Inf.</target>
        </trans-unit>
        <trans-unit id="012c1f9cb43bafa38c87d810c24d42b2a0e95129" translate="yes" xml:space="preserve">
          <source>Precedence returns the operator precedence of the binary operator op. If op is not a binary operator, the result is LowestPrecedence.</source>
          <target state="translated">Приоритет возвращает приоритет оператора двоичной операции.Если оператор op не является двоичным оператором,то возвращается приоритет оператора LowestPrecedence.</target>
        </trans-unit>
        <trans-unit id="06b7f0534bb083dff059cb7b1d374b3c3f1e0a29" translate="yes" xml:space="preserve">
          <source>Precompute performs some calculations that speed up private key operations in the future.</source>
          <target state="translated">Precompute выполняет некоторые вычисления,которые ускоряют операции с приватными ключами в будущем.</target>
        </trans-unit>
        <trans-unit id="34240aca8e0c8b909225cdb2f4dfdd60a5391649" translate="yes" xml:space="preserve">
          <source>Precondition: the Uses and Defs maps are populated.</source>
          <target state="translated">Предусловие:заполняются карты &quot;Uses&quot; и &quot;Defs&quot;.</target>
        </trans-unit>
        <trans-unit id="7070c5f6250bbd470fe7f73bafbee45d2955ddb3" translate="yes" xml:space="preserve">
          <source>Predefined global functions are named as follows.</source>
          <target state="translated">Предопределенные глобальные функции именуются следующим образом.</target>
        </trans-unit>
        <trans-unit id="e21e54618fe5bb45663e64ef56fb6717d24f3e6f" translate="yes" xml:space="preserve">
          <source>Predefined layouts ANSIC, UnixDate, RFC3339 and others describe standard and convenient representations of the reference time. For more information about the formats and the definition of the reference time, see the documentation for ANSIC and the other constants defined by this package.</source>
          <target state="translated">Предварительно определенные компоновки ANSIC,UnixDate,RFC3339 и другие описывают стандартные и удобные представления эталонного времени.Более подробную информацию о форматах и определении эталонного времени смотрите в документации по ANSIC и другим константам,определяемым данным пакетом.</target>
        </trans-unit>
        <trans-unit id="19d40016f56bfc80ec50dda03a3f66d54afe65d3" translate="yes" xml:space="preserve">
          <source>Predefined layouts ANSIC, UnixDate, RFC3339 and others describe standard and convenient representations of the reference time. For more information about the formats and the definition of the reference time, see the documentation for ANSIC and the other constants defined by this package. Also, the executable example for Time.Format demonstrates the working of the layout string in detail and is a good reference.</source>
          <target state="translated">Предварительно определенные компоновки ANSIC,UnixDate,RFC3339 и другие описывают стандартные и удобные представления эталонного времени.Более подробную информацию о форматах и определении эталонного времени смотрите в документации по ANSIC и другим константам,определяемым данным пакетом.Кроме того,исполняемый пример для Time.Format подробно демонстрирует работу строки компоновки и является хорошей ссылкой.</target>
        </trans-unit>
        <trans-unit id="019d3598b39c078722d988d313bff8da4d9cf574" translate="yes" xml:space="preserve">
          <source>Predefined mode bits to control recognition of tokens. For instance, to configure a Scanner such that it only recognizes (Go) identifiers, integers, and skips comments, set the Scanner's Mode field to:</source>
          <target state="translated">Заранее заданные биты режима для управления распознаванием токенов.Например,чтобы настроить сканер таким образом,чтобы он распознавал только идентификаторы (Go),целые числа и пропускал комментарии,установите в поле Режим сканера значение Mode (Режим сканера):</target>
        </trans-unit>
        <trans-unit id="0eea29821ab0f93a1960c9475350fbefcdab3d2f" translate="yes" xml:space="preserve">
          <source>Predefined polynomials.</source>
          <target state="translated">Предопределенные полиномы.</target>
        </trans-unit>
        <trans-unit id="0d4a9c1b8dc6a14ced81402c9c52d4cba69192f5" translate="yes" xml:space="preserve">
          <source>Prefix returns a literal string that all matches for the regexp must start with. Complete is true if the prefix is the entire match.</source>
          <target state="translated">Префикс возвращает строку литерала,с которой должны начинаться все совпадения для регенерала.Полное значение является истинным,если префиксом является полное совпадение.</target>
        </trans-unit>
        <trans-unit id="07aedbb616a135989fac4d8d72b5c4a5c5d60c82" translate="yes" xml:space="preserve">
          <source>Prefix returns the output prefix for the logger.</source>
          <target state="translated">Префикс возвращает префикс выхода для регистратора.</target>
        </trans-unit>
        <trans-unit id="d115a4bd5d23f67905e010343d63485a225c3e87" translate="yes" xml:space="preserve">
          <source>Prefix returns the output prefix for the standard logger.</source>
          <target state="translated">Префикс возвращает префикс выхода для стандартного регистратора.</target>
        </trans-unit>
        <trans-unit id="8a0ad1efe973aa121d35889249f93a7d412bb0f0" translate="yes" xml:space="preserve">
          <source>Prepare creates a prepared statement for later queries or executions. Multiple queries or executions may be run concurrently from the returned statement. The caller must call the statement's Close method when the statement is no longer needed.</source>
          <target state="translated">Подготовка создает подготовленное заявление для последующих запросов или казней.Из возвращаемого оператора можно одновременно выполнить несколько запросов или выполнить несколько операций.Звонящий должен вызвать метод Close оператора,когда оператор больше не нужен.</target>
        </trans-unit>
        <trans-unit id="a2f69751c5da712872417f2a510b17bd5264a134" translate="yes" xml:space="preserve">
          <source>Prepare creates a prepared statement for use within a transaction.</source>
          <target state="translated">Подготовка создает подготовленный отчет для использования в рамках сделки.</target>
        </trans-unit>
        <trans-unit id="19c3c9a0f98a28102c0e736d9c3bf4d64087898f" translate="yes" xml:space="preserve">
          <source>PrepareContext creates a prepared statement for later queries or executions. Multiple queries or executions may be run concurrently from the returned statement. The caller must call the statement's Close method when the statement is no longer needed.</source>
          <target state="translated">PrepareContext создает подготовленное заявление для последующих запросов или исполнения.Из возвращаемого оператора можно одновременно выполнить несколько запросов или выполнить несколько операций.Звонящий должен вызвать метод Close оператора,когда оператор больше не нужен.</target>
        </trans-unit>
        <trans-unit id="a6597b9664b9651bf9f54fe07c6db1a86396a5f0" translate="yes" xml:space="preserve">
          <source>PrepareContext creates a prepared statement for use within a transaction.</source>
          <target state="translated">PrepareContext создает подготовленное заявление для использования в рамках сделки.</target>
        </trans-unit>
        <trans-unit id="152856201f7dfb04864788231e3dca46c0bc77c0" translate="yes" xml:space="preserve">
          <source>Prev returns the previous list element or nil.</source>
          <target state="translated">Прев возвращает предыдущий элемент списка или ноль.</target>
        </trans-unit>
        <trans-unit id="c4d145ba4ec6ded69ec8461fe1ea7b2b7ec58ca2" translate="yes" xml:space="preserve">
          <source>Prev returns the previous ring element. r must not be empty.</source>
          <target state="translated">Прев возвращает предыдущий кольцевой элемент.r не должен быть пустым.</target>
        </trans-unit>
        <trans-unit id="88971ab7b2fead8d5aa7c50c15f575453db641e4" translate="yes" xml:space="preserve">
          <source>Prime returns a number, p, of the given size, such that p is prime with high probability. Prime will return error for any error returned by rand.Read or if bits &amp;lt; 2.</source>
          <target state="translated">Prime возвращает число p заданного размера, так что p является простым с высокой вероятностью. Prime вернет ошибку для любой ошибки, возвращенной rand.Read или если биты &amp;lt;2.</target>
        </trans-unit>
        <trans-unit id="5b221e9c2a451799d8f37e2b9874409d5e03ab05" translate="yes" xml:space="preserve">
          <source>Print</source>
          <target state="translated">Print</target>
        </trans-unit>
        <trans-unit id="f10e9ffa0b7bfc2f4378fe30b103cef0c696cbab" translate="yes" xml:space="preserve">
          <source>Print calls Output to print to the standard logger. Arguments are handled in the manner of fmt.Print.</source>
          <target state="translated">Печать вызовов Вывод на печать для стандартного регистратора.Аргументы обрабатываются способом fmt.Print.</target>
        </trans-unit>
        <trans-unit id="da7a32afaab2e92c2ad95514fe5016080d044d92" translate="yes" xml:space="preserve">
          <source>Print calls l.Output to print to the logger. Arguments are handled in the manner of fmt.Print.</source>
          <target state="translated">Печать вызовов l.Выход для печати в регистратор.Аргументы обрабатываются способом fmt.Print.</target>
        </trans-unit>
        <trans-unit id="ef0199bdcf8fc8fa33bd7d6ab92875f9706a01bd" translate="yes" xml:space="preserve">
          <source>Print formats using the default formats for its operands and writes to standard output. Spaces are added between operands when neither is a string. It returns the number of bytes written and any write error encountered.</source>
          <target state="translated">Печатает в форматах по умолчанию для своих операндов и записывает в стандартный вывод.Пробелы добавляются между операндами,когда ни один из них не является строкой.Возвращается количество записанных байтов и любая ошибка при записи.</target>
        </trans-unit>
        <trans-unit id="5d837aa33f1404ff26202e67efb03427b1d31566" translate="yes" xml:space="preserve">
          <source>Print prints x to standard output, skipping nil fields. Print(fset, x) is the same as Fprint(os.Stdout, fset, x, NotNilFilter).</source>
          <target state="translated">Печать отпечатков x к стандартному выводу,пропуская нулевые поля.Печать(fset,x)такая же,как и Fprint(os.Stdout,fset,x,NotNilFilter).</target>
        </trans-unit>
        <trans-unit id="fff8914dcd8a6ac6b5cf34d89aeea00386da1b24" translate="yes" xml:space="preserve">
          <source>Print, Println, and Printf lay out their arguments differently. In this example we can compare their behaviors. Println always adds blanks between the items it prints, while Print adds blanks only between non-string arguments and Printf does exactly what it is told. Sprint, Sprintln, Sprintf, Fprint, Fprintln, and Fprintf behave the same as their corresponding Print, Println, and Printf functions shown here.</source>
          <target state="translated">Печать,Принтльн и Принтф излагают свои аргументы по-разному.В этом примере мы можем сравнить их поведение.Println всегда добавляет пробелы между элементами,которые он печатает,в то время как Println добавляет пробелы только между нестроковыми аргументами,а Printf делает именно то,что ему сказано.Print,Sprintln,Sprintf,Fprint,Fprintln и Fprintf ведут себя так же,как их соответствующие функции Print,Println и Printf,показанные здесь.</target>
        </trans-unit>
        <trans-unit id="809bcd004fc9b80aebb7cc5d33f0d171da74d5a1" translate="yes" xml:space="preserve">
          <source>PrintDefaults prints, to standard error unless configured otherwise, a usage message showing the default settings of all defined command-line flags. For an integer valued flag x, the default output has the form</source>
          <target state="translated">PrintDefaults выводит на печать стандартную ошибку,если не указано иное,сообщение об использовании,показывающее настройки всех заданных флагов командной строки по умолчанию.Для флага x,имеющего целое значение,вывод по умолчанию имеет форму</target>
        </trans-unit>
        <trans-unit id="66f194d8340d19b81ae4cbbaf04b180769f0bc50" translate="yes" xml:space="preserve">
          <source>PrintDefaults prints, to standard error unless configured otherwise, the default values of all defined command-line flags in the set. See the documentation for the global function PrintDefaults for more information.</source>
          <target state="translated">PrintDefaults выводит на печать стандартную ошибку,если не указано иное,значения по умолчанию всех заданных флагов командной строки в наборе.Дополнительные сведения см.в документации к глобальной функции PrintDefaults.</target>
        </trans-unit>
        <trans-unit id="0413304ebeab6806f19cc2877f7f0a8ff6c54cbc" translate="yes" xml:space="preserve">
          <source>PrintError is a utility function that prints a list of errors to w, one error per line, if the err parameter is an ErrorList. Otherwise it prints the err string.</source>
          <target state="translated">PrintError-это утилита,которая печатает список ошибок в w,по одной ошибке на строку,если параметр errorList-ErrorList.В противном случае она печатает строку err.</target>
        </trans-unit>
        <trans-unit id="ebb2a34b39577c89ac6bbac4cad20176461fcd0b" translate="yes" xml:space="preserve">
          <source>PrintRanges defines the set of printable characters according to Go. ASCII space, U+0020, is handled separately.</source>
          <target state="translated">PrintRanges определяет набор символов для печати в соответствии с Go.ASCII пространство,U+0020,обрабатывается отдельно.</target>
        </trans-unit>
        <trans-unit id="e979fdd38cfa18a2850ab6725519f82f13a4893f" translate="yes" xml:space="preserve">
          <source>PrintStack prints to standard error the stack trace returned by runtime.Stack.</source>
          <target state="translated">PrintStack печатает с стандартной ошибкой трассу укладки,возвращаемую во время выполнения.Stack.</target>
        </trans-unit>
        <trans-unit id="49c6710eb43a270c0d99f60d369594f6b1f09d42" translate="yes" xml:space="preserve">
          <source>Printf</source>
          <target state="translated">Printf</target>
        </trans-unit>
        <trans-unit id="d092eac8d8c7315f01318a4675b38dcda90f6b2f" translate="yes" xml:space="preserve">
          <source>Printf calls Output to print to the standard logger. Arguments are handled in the manner of fmt.Printf.</source>
          <target state="translated">Вызовы Printf Вывод на печать для стандартного регистратора.Аргументы обрабатываются способом fmt.Printf.</target>
        </trans-unit>
        <trans-unit id="d34579b37294eb8c93cd5f76572f924816678d0e" translate="yes" xml:space="preserve">
          <source>Printf calls l.Output to print to the logger. Arguments are handled in the manner of fmt.Printf.</source>
          <target state="translated">Printf вызывает l.Output для печати в регистратор.Аргументы обрабатываются таким образом,как fmt.Printf.</target>
        </trans-unit>
        <trans-unit id="e063c30289e6b7981e882f4697ef852c1f482795" translate="yes" xml:space="preserve">
          <source>Printf formats according to a format specifier and writes to standard output. It returns the number of bytes written and any write error encountered.</source>
          <target state="translated">Форматы Printf в соответствии со спецификатором формата и записывается в стандартный вывод.Он возвращает количество записанных байтов и любую ошибку при записи.</target>
        </trans-unit>
        <trans-unit id="28fa9c40e9ffd74bb5b4f094116329456de9f692" translate="yes" xml:space="preserve">
          <source>PrintfLine writes the formatted output followed by \r\n.</source>
          <target state="translated">PrintfLine пишет отформатированный вывод,за которым следует \r\n.</target>
        </trans-unit>
        <trans-unit id="f16eadab2a72ff13044cc806dbcf2c117b32244f" translate="yes" xml:space="preserve">
          <source>Printing</source>
          <target state="translated">Printing</target>
        </trans-unit>
        <trans-unit id="9be957a1debff697aafdc7801a3e8785262f0c15" translate="yes" xml:space="preserve">
          <source>Println</source>
          <target state="translated">Println</target>
        </trans-unit>
        <trans-unit id="29f11f56c6deffe1a15f67edc9a4aa4f5e39f28b" translate="yes" xml:space="preserve">
          <source>Println calls Output to print to the standard logger. Arguments are handled in the manner of fmt.Println.</source>
          <target state="translated">Вызовы печати Вывод на печать в стандартный регистратор.Аргументы обрабатываются способом fmt.Println.</target>
        </trans-unit>
        <trans-unit id="cddfe7aeafd7792bfbbf9d5f8715705f967fa901" translate="yes" xml:space="preserve">
          <source>Println calls l.Output to print to the logger. Arguments are handled in the manner of fmt.Println.</source>
          <target state="translated">Печать вызывает l.Output для печати в регистратор.Аргументы обрабатываются таким образом,как fmt.Println.</target>
        </trans-unit>
        <trans-unit id="811e4464a94616bb8d26e71f2e575488ec162b1d" translate="yes" xml:space="preserve">
          <source>Println formats using the default formats for its operands and writes to standard output. Spaces are always added between operands and a newline is appended. It returns the number of bytes written and any write error encountered.</source>
          <target state="translated">Форматы печати,использующие форматы по умолчанию для своих операндов,и записывает в стандартный вывод.Пробелы всегда добавляются между операндами и добавляется новая строка.Она возвращает количество записанных байтов и любую ошибку при записи.</target>
        </trans-unit>
        <trans-unit id="ca8881cd0811d2e92d6c86ae2702d8e81b20152f" translate="yes" xml:space="preserve">
          <source>PrivateKey is the type of Ed25519 private keys. It implements crypto.Signer.</source>
          <target state="translated">PrivateKey-это тип закрытых ключей Ed25519.Он реализует crypto.Signer.</target>
        </trans-unit>
        <trans-unit id="0a4394946d56678a7614480ff518a3bad620dfd6" translate="yes" xml:space="preserve">
          <source>PrivateKey represents a DSA private key.</source>
          <target state="translated">PrivateKey представляет собой частный ключ DSA.</target>
        </trans-unit>
        <trans-unit id="5828291a45f65d96ddf669061359c25c2c15c6d0" translate="yes" xml:space="preserve">
          <source>PrivateKey represents a private key using an unspecified algorithm.</source>
          <target state="translated">PrivateKey представляет собой закрытый ключ,использующий неопределенный алгоритм.</target>
        </trans-unit>
        <trans-unit id="6a98b6c2702640d21b9c48b8d270c3e30325339a" translate="yes" xml:space="preserve">
          <source>PrivateKey represents an ECDSA private key.</source>
          <target state="translated">PrivateKey представляет собой частный ключ ECDSA.</target>
        </trans-unit>
        <trans-unit id="5d801231cb01d152413f0eb3fd1b96b8b8b32f86" translate="yes" xml:space="preserve">
          <source>ProbablyPrime is 100% accurate for inputs less than 2⁶⁴. See Menezes et al., Handbook of Applied Cryptography, 1997, pp. 145-149, and FIPS 186-4 Appendix F for further discussion of the error probabilities.</source>
          <target state="translated">ProbablePrime на 100% точна для входов меньше,чем 2⁶⁴.Более подробное обсуждение вероятности ошибок см.в Menezes et al.,Handbook of Applied Cryptography,1997,pp.145-149,и FIPS 186-4 Annex F.</target>
        </trans-unit>
        <trans-unit id="442fffca41b5ff8be9e7d3c5a0d5bb3bcdd79c79" translate="yes" xml:space="preserve">
          <source>ProbablyPrime is not suitable for judging primes that an adversary may have crafted to fool the test.</source>
          <target state="translated">ProhapsPrime не подходит для оценки праймов,которые противник,возможно,создал,чтобы обмануть тест.</target>
        </trans-unit>
        <trans-unit id="c5acf5649dd4748b450f268e217b8fc03d7e5d83" translate="yes" xml:space="preserve">
          <source>ProbablyPrime reports whether x is probably prime, applying the Miller-Rabin test with n pseudorandomly chosen bases as well as a Baillie-PSW test.</source>
          <target state="translated">ProbablePrime сообщает,является ли x,вероятно,основным,применяя тест Миллера-Рабина с n псевдослучайно выбранных баз,а также тест Baillie-PSW.</target>
        </trans-unit>
        <trans-unit id="f565348ea6c07ff9cfffba23f4ddef524854d6c5" translate="yes" xml:space="preserve">
          <source>ProcAttr holds attributes that will be applied to a new process started by StartProcess.</source>
          <target state="translated">ProcAttr содержит атрибуты,которые будут применены к новому процессу,запущенному StartProcess.</target>
        </trans-unit>
        <trans-unit id="e12810a35fd4b52423e92a433b314e79f5156c70" translate="yes" xml:space="preserve">
          <source>ProcAttr holds the attributes that will be applied to a new process started by StartProcess.</source>
          <target state="translated">ProcAttr содержит атрибуты,которые будут применены к новому процессу,запущенному StartProcess.</target>
        </trans-unit>
        <trans-unit id="5373df2ffeb91866eef2c38e2502d77f1e33d970" translate="yes" xml:space="preserve">
          <source>Process stores the information about a process created by StartProcess.</source>
          <target state="translated">Процесс хранит информацию о процессе,созданном StartProcess.</target>
        </trans-unit>
        <trans-unit id="7be9488d8073639c8b5c8f975d63715a76c9482d" translate="yes" xml:space="preserve">
          <source>ProcessEnv returns FastCGI environment variables associated with the request r for which no effort was made to be included in the request itself - the data is hidden in the request's context. As an example, if REMOTE_USER is set for a request, it will not be found anywhere in r, but it will be included in ProcessEnv's response (via r's context).</source>
          <target state="translated">ProcessEnv возвращает переменные окружения FastCGI,связанные с запросом r,для которых не было предпринято никаких усилий,чтобы быть включенными в сам запрос-данные скрыты в контексте запроса.Например,если REMOTE_USER задан для запроса,то его нигде не будет найдено в r,но он будет включен в ответ ProcessEnv (через контекст r).</target>
        </trans-unit>
        <trans-unit id="9471e4ecfd3d8f84d8e198229a6e563cc60bb5bd" translate="yes" xml:space="preserve">
          <source>ProcessState stores information about a process, as reported by Wait.</source>
          <target state="translated">ProcessState хранит информацию о процессе,как сообщает Wait.</target>
        </trans-unit>
        <trans-unit id="1ccb21389489c4ce498c4e53d4d69158c5c216b7" translate="yes" xml:space="preserve">
          <source>Profile responds with the pprof-formatted cpu profile. Profiling lasts for duration specified in seconds GET parameter, or for 30 seconds if not specified. The package initialization registers it as /debug/pprof/profile.</source>
          <target state="translated">Профиль отвечает профилем pprof-формата cpu.Профилирование длится в течение указанного в секундах GET-параметра или в течение 30 секунд,если он не указан.Инициализация пакета регистрирует его как /debug/pprof/профиль.</target>
        </trans-unit>
        <trans-unit id="a111deba4cb386ad7d27a3a5da110f46f90e53f3" translate="yes" xml:space="preserve">
          <source>Profiles are only as good as the kernel support used to generate them. See &lt;a href=&quot;https://golang.org/issue/13841&quot;&gt;https://golang.org/issue/13841&lt;/a&gt; for details about known problems.</source>
          <target state="translated">Профили хороши настолько, насколько хороша поддержка ядра, используемая для их создания. См. &lt;a href=&quot;https://golang.org/issue/13841&quot;&gt;Https://golang.org/issue/13841&lt;/a&gt; для получения подробной информации об известных проблемах.</target>
        </trans-unit>
        <trans-unit id="f633a064ff1568b947a4aec717cb8ff7b8d5f4c3" translate="yes" xml:space="preserve">
          <source>Profiles can then be visualized with the pprof tool:</source>
          <target state="translated">Профили можно визуализировать с помощью инструмента pprof:</target>
        </trans-unit>
        <trans-unit id="f43cf39e026d58fac3cfa9c9d78bd864d77127ed" translate="yes" xml:space="preserve">
          <source>Profiles returns a slice of all the known profiles, sorted by name.</source>
          <target state="translated">Профили возвращает кусок всех известных профилей,отсортированных по имени.</target>
        </trans-unit>
        <trans-unit id="e204c80d31036e0e024c0b7ffd8999a887af815c" translate="yes" xml:space="preserve">
          <source>Profiling a Go program</source>
          <target state="translated">Профилирование программы Go</target>
        </trans-unit>
        <trans-unit id="cd24f23a82cfebc48d38726d6b4c3ec7db051af8" translate="yes" xml:space="preserve">
          <source>Prog.Flag</source>
          <target state="translated">Prog.Flag</target>
        </trans-unit>
        <trans-unit id="48f3611555518363414a9b1db2fa49f474f76e67" translate="yes" xml:space="preserve">
          <source>Prog.Type</source>
          <target state="translated">Prog.Type</target>
        </trans-unit>
        <trans-unit id="2301ced48f29c8456865c04cd47334c707828d9b" translate="yes" xml:space="preserve">
          <source>Programs that use Contexts should follow these rules to keep interfaces consistent across packages and enable static analysis tools to check context propagation:</source>
          <target state="translated">Программы,использующие Contexts,должны следовать этим правилам,чтобы обеспечить согласованность интерфейсов между пакетами и позволить инструментам статического анализа проверять распространение контекста:</target>
        </trans-unit>
        <trans-unit id="3ac27ec45d4018361c7d594bf7eaa91a1292edd0" translate="yes" xml:space="preserve">
          <source>Programs using times should typically store and pass them as values, not pointers. That is, time variables and struct fields should be of type time.Time, not *time.Time.</source>
          <target state="translated">Программы,использующие время,как правило,должны хранить и передавать их как значения,а не как указатели.То есть переменные времени и поля структуры должны быть типа time.Time,а не *time.Time.</target>
        </trans-unit>
        <trans-unit id="c9ee0039dcc32da9c4cde1d419e8461ac1dfbdc7" translate="yes" xml:space="preserve">
          <source>Properties is the set of Unicode property tables.</source>
          <target state="translated">Свойства-это набор таблиц свойств Unicode.</target>
        </trans-unit>
        <trans-unit id="8768305a872da3684ae4bda3f68612735ba56c08" translate="yes" xml:space="preserve">
          <source>Properties of basic types.</source>
          <target state="translated">Свойства основных типов.</target>
        </trans-unit>
        <trans-unit id="8a0d90b2918aadcefa0c95820abf21b6534492f2" translate="yes" xml:space="preserve">
          <source>ProtoAtLeast reports whether the HTTP protocol used in the request is at least major.minor.</source>
          <target state="translated">ProtoAtLeast сообщает,является ли протокол HTTP,используемый в запросе,как минимум major.minor.</target>
        </trans-unit>
        <trans-unit id="ff9e390e5de482119dc42236df206efa900791fc" translate="yes" xml:space="preserve">
          <source>ProtoAtLeast reports whether the HTTP protocol used in the response is at least major.minor.</source>
          <target state="translated">ProtoAtLeast сообщает,является ли протокол HTTP,используемый в ответе,по крайней мере,major.minor.</target>
        </trans-unit>
        <trans-unit id="5829d5d1675f9485036e8bdae05dd67dac955b66" translate="yes" xml:space="preserve">
          <source>ProtocolError represents an HTTP protocol error.</source>
          <target state="translated">ProtocolError представляет собой ошибку протокола HTTP.</target>
        </trans-unit>
        <trans-unit id="c78f3a99754e80287f834beff8dcfd502a6d93a8" translate="yes" xml:space="preserve">
          <source>Provided that T2 is no larger than T1 and that the two share an equivalent memory layout, this conversion allows reinterpreting data of one type as data of another type. An example is the implementation of math.Float64bits:</source>
          <target state="translated">При условии,что T2 не больше T1 и что они имеют общую эквивалентную схему памяти,такое преобразование позволяет заново интерпретировать данные одного типа как данные другого типа.Примером может служить реализация math.Float64bits:</target>
        </trans-unit>
        <trans-unit id="2667527e2309cea50315245bf9e96ef013a2321b" translate="yes" xml:space="preserve">
          <source>ProxyFromEnvironment returns the URL of the proxy to use for a given request, as indicated by the environment variables HTTP_PROXY, HTTPS_PROXY and NO_PROXY (or the lowercase versions thereof). HTTPS_PROXY takes precedence over HTTP_PROXY for https requests.</source>
          <target state="translated">ProxyFromEnvironment возвращает URL прокси,который будет использоваться для данного запроса,как указано в переменных окружения HTTP_PROXY,HTTPS_PROXY и NO_PROXY (или их младших версиях).Для https запросов HTTPS_PROXY имеет приоритет над HTTP_PROXY.</target>
        </trans-unit>
        <trans-unit id="ce1c8acc8d3a18105ad805c3050485bfd7af1196" translate="yes" xml:space="preserve">
          <source>ProxyURL returns a proxy function (for use in a Transport) that always returns the same URL.</source>
          <target state="translated">ProxyURL возвращает прокси-функцию (для использования на транспорте),которая всегда возвращает один и тот же URL.</target>
        </trans-unit>
        <trans-unit id="256df6693e9938b002805ef141a169ee9b0517c0" translate="yes" xml:space="preserve">
          <source>Pt is shorthand for Point{X, Y}.</source>
          <target state="translated">Pt-это сокращение от Point{X,Y}.</target>
        </trans-unit>
        <trans-unit id="72df9c957a8f34680bd544544cf16bd450f7c686" translate="yes" xml:space="preserve">
          <source>PtrTo returns the pointer type with element t. For example, if t represents type Foo, PtrTo(t) represents *Foo.</source>
          <target state="translated">PtrTo возвращает тип указателя с элементом t.Например,если t представляет тип Foo,то PtrTo(t)представляет *Foo.</target>
        </trans-unit>
        <trans-unit id="1b89d49d722a1ef7d3c4ddfb234a1400f1a92cf6" translate="yes" xml:space="preserve">
          <source>Public returns the PublicKey corresponding to priv.</source>
          <target state="translated">Публичный возвращает Публичный ключ,соответствующий частному.</target>
        </trans-unit>
        <trans-unit id="2649f0278f57fd7af2dbdfb64c901b42e9d9789a" translate="yes" xml:space="preserve">
          <source>Public returns the public key corresponding to priv.</source>
          <target state="translated">Публично возвращает публичный ключ,соответствующий частному.</target>
        </trans-unit>
        <trans-unit id="0d04adf8945e312c7d47fec2108c21b2684c9af5" translate="yes" xml:space="preserve">
          <source>PublicKey is the type of Ed25519 public keys.</source>
          <target state="translated">PublicKey-это тип Ed25519 public keys.</target>
        </trans-unit>
        <trans-unit id="5001eedc91686ba11ee390e67cd1a676465f5d14" translate="yes" xml:space="preserve">
          <source>PublicKey represents a DSA public key.</source>
          <target state="translated">PublicKey представляет публичный ключ от DSA.</target>
        </trans-unit>
        <trans-unit id="3acd186c84de8cd73322d4669ae9a4bf40b59d13" translate="yes" xml:space="preserve">
          <source>PublicKey represents a public key using an unspecified algorithm.</source>
          <target state="translated">PublicKey представляет собой открытый ключ,использующий неустановленный алгоритм.</target>
        </trans-unit>
        <trans-unit id="2f28570f8dc7131bd19dca1ee8af4ed1f0eeb1b5" translate="yes" xml:space="preserve">
          <source>PublicKey represents an ECDSA public key.</source>
          <target state="translated">PublicKey представляет публичный ключ ECDSA.</target>
        </trans-unit>
        <trans-unit id="b2140dd5a5a558ac28d58aa5d36d6a21620f906f" translate="yes" xml:space="preserve">
          <source>PublicSuffixList provides the public suffix of a domain. For example:</source>
          <target state="translated">PublicSuffixList предоставляет открытый суффикс домена.Например:</target>
        </trans-unit>
        <trans-unit id="edb82c4a8bbcf78c8a1448e29c8d98e501e15f1e" translate="yes" xml:space="preserve">
          <source>Publish declares a named exported variable. This should be called from a package's init function when it creates its Vars. If the name is already registered then this will log.Panic.</source>
          <target state="translated">Publish объявляет именованную экспортируемую переменную.Она должна быть вызвана из init-функции пакета,когда он создает свои Vars.Если имя уже зарегистрировано,то это вызовет лог.Panic.</target>
        </trans-unit>
        <trans-unit id="2bf5378cf82463ae57e7e9a30e9ba5b326dba3d6" translate="yes" xml:space="preserve">
          <source>Push pushes the element x onto the heap. The complexity is O(log n) where n = h.Len().</source>
          <target state="translated">Толчок толкает элемент Х на кучу.Сложность заключается в O(log n),где n=h.Len().</target>
        </trans-unit>
        <trans-unit id="f4b202999ae2b93ddb6f5cd751aefdf3cb3293cf" translate="yes" xml:space="preserve">
          <source>PushBack inserts a new element e with value v at the back of list l and returns e.</source>
          <target state="translated">PushBack вставляет новый элемент e со значением v в конце списка l и возвращает e.</target>
        </trans-unit>
        <trans-unit id="a50f3f664eb834d0bdb9f4d025dcb754c041066d" translate="yes" xml:space="preserve">
          <source>PushBackList inserts a copy of an other list at the back of list l. The lists l and other may be the same. They must not be nil.</source>
          <target state="translated">PushBackList вставляет копию другого списка в задней части списка l.Списки l и другие могут быть одинаковыми.Они не должны быть нулевыми.</target>
        </trans-unit>
        <trans-unit id="a8c99a25179d82d5afa3406e22b548a0252f1474" translate="yes" xml:space="preserve">
          <source>PushFront inserts a new element e with value v at the front of list l and returns e.</source>
          <target state="translated">PushFront вставляет новый элемент e со значением v в начале списка l и возвращает e.</target>
        </trans-unit>
        <trans-unit id="13a7ef38dc8b3d5639e9784f576b7dc8f0a8b795" translate="yes" xml:space="preserve">
          <source>PushFrontList inserts a copy of an other list at the front of list l. The lists l and other may be the same. They must not be nil.</source>
          <target state="translated">PushFrontList вставляет копию другого списка перед списком l.Списки l и другие могут быть одинаковыми.Они не должны быть нулевыми.</target>
        </trans-unit>
        <trans-unit id="5520408cb4fcced642940bef6746727866edb323" translate="yes" xml:space="preserve">
          <source>PushOptions describes options for Pusher.Push.</source>
          <target state="translated">PushOptions описывает опции для Pusher.Push.</target>
        </trans-unit>
        <trans-unit id="192422b7c0ce1637e319052ddc27aa0f79641ec0" translate="yes" xml:space="preserve">
          <source>Pusher is the interface implemented by ResponseWriters that support HTTP/2 server push. For more background, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7540#section-8.2&quot;&gt;https://tools.ietf.org/html/rfc7540#section-8.2&lt;/a&gt;.</source>
          <target state="translated">Pusher - это интерфейс, реализованный ResponseWriters, который поддерживает push-сервер HTTP / 2. Для получения дополнительной информации см. &lt;a href=&quot;https://tools.ietf.org/html/rfc7540#section-8.2&quot;&gt;Https://tools.ietf.org/html/rfc7540#section-8.2&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5810d2cea2c4c839a1cbc6f93eed06050e059bdc" translate="yes" xml:space="preserve">
          <source>Put adds x to the pool.</source>
          <target state="translated">Положите добавку &quot;Х&quot; в бассейн.</target>
        </trans-unit>
        <trans-unit id="6b32dae99e29878f191b30318e13ee160e3e9c11" translate="yes" xml:space="preserve">
          <source>PutUvarint</source>
          <target state="translated">PutUvarint</target>
        </trans-unit>
        <trans-unit id="d471216e431bf21e4cd2b9153a740d7d8a93b34a" translate="yes" xml:space="preserve">
          <source>PutUvarint encodes a uint64 into buf and returns the number of bytes written. If the buffer is too small, PutUvarint will panic.</source>
          <target state="translated">PutUvarint кодирует uint64 в buf и возвращает количество записанных байт.Если буфер слишком мал,то PutUvarint запаникует.</target>
        </trans-unit>
        <trans-unit id="88299e1b8aa44f2b22e86375ae77e2d6a8112536" translate="yes" xml:space="preserve">
          <source>PutVarint</source>
          <target state="translated">PutVarint</target>
        </trans-unit>
        <trans-unit id="bd00eee1df8f0b67019e2ad70e9156e5fa1de99c" translate="yes" xml:space="preserve">
          <source>PutVarint encodes an int64 into buf and returns the number of bytes written. If the buffer is too small, PutVarint will panic.</source>
          <target state="translated">PutVarint кодирует int64 в buf и возвращает количество записанных байт.Если буфер слишком мал,PutVarint запаникует.</target>
        </trans-unit>
        <trans-unit id="95ab58079356ed9aa8893c2df192745f32d71297" translate="yes" xml:space="preserve">
          <source>Quantizer produces a palette for an image.</source>
          <target state="translated">Квантизер производит палитру для изображения.</target>
        </trans-unit>
        <trans-unit id="05437837ec4647b7c23a7c5944b51f3ac43e58c7" translate="yes" xml:space="preserve">
          <source>Query executes a prepared query statement with the given arguments and returns the query results as a *Rows.</source>
          <target state="translated">Запрос выполняет подготовленный запрос с заданными аргументами и возвращает результаты запроса в виде *Rows.</target>
        </trans-unit>
        <trans-unit id="d610ca285b8521b4fbaa375322142cf95d05446a" translate="yes" xml:space="preserve">
          <source>Query executes a query that returns rows, typically a SELECT.</source>
          <target state="translated">Запрос выполняет запрос,возвращающий строки,обычно SELECT.</target>
        </trans-unit>
        <trans-unit id="e1388b391779ee3280bdae6ba4b75470fb85b182" translate="yes" xml:space="preserve">
          <source>Query executes a query that returns rows, typically a SELECT. The args are for any placeholder parameters in the query.</source>
          <target state="translated">Запрос выполняет запрос,возвращающий строки,обычно SELECT.Аргументами являются любые параметры плейсхолдеров в запросе.</target>
        </trans-unit>
        <trans-unit id="73ccd82bfd6eca331cabb2dba278895a7773c1c8" translate="yes" xml:space="preserve">
          <source>Query is expected to be a list of key=value settings separated by ampersands or semicolons. A setting without an equals sign is interpreted as a key set to an empty value.</source>
          <target state="translated">Предполагается,что запрос будет представлять собой список настроек key=value,разделенных амперсандами или точкой с запятой.Установка без знака равно интерпретируется как набор ключей с пустым значением.</target>
        </trans-unit>
        <trans-unit id="4501151d792df2b730db74682f29db9657ef7ffb" translate="yes" xml:space="preserve">
          <source>Query may return ErrSkip.</source>
          <target state="translated">Запрос может вернуть ErrSkip.</target>
        </trans-unit>
        <trans-unit id="e1b497d6ece5d419609d5ec0635dc46c1d21b395" translate="yes" xml:space="preserve">
          <source>Query parses RawQuery and returns the corresponding values. It silently discards malformed value pairs. To check errors use ParseQuery.</source>
          <target state="translated">Запрос анализирует RawQuery и возвращает соответствующие значения.Он бесшумно отбрасывает пары неправильных значений.Для проверки ошибок используйте ParseQuery.</target>
        </trans-unit>
        <trans-unit id="8a08387889457a5be56952e049ecbbf787ca1008" translate="yes" xml:space="preserve">
          <source>QueryContext executes a prepared query statement with the given arguments and returns the query results as a *Rows.</source>
          <target state="translated">QueryContext выполняет подготовленный запрос с заданными аргументами и возвращает результаты запроса в виде *Rows.</target>
        </trans-unit>
        <trans-unit id="90f64cb7930640d89ee4991b926e5cee52278a6e" translate="yes" xml:space="preserve">
          <source>QueryContext executes a query that returns rows, typically a SELECT.</source>
          <target state="translated">QueryContext выполняет запрос,который возвращает строки,обычно SELECT.</target>
        </trans-unit>
        <trans-unit id="610270ccdd5f9415ac6596bb377b874f11fadbf3" translate="yes" xml:space="preserve">
          <source>QueryContext executes a query that returns rows, typically a SELECT. The args are for any placeholder parameters in the query.</source>
          <target state="translated">QueryContext выполняет запрос,который возвращает строки,обычно SELECT.Аргументы предназначены для любых параметров в запросе.</target>
        </trans-unit>
        <trans-unit id="7370d9d4f8639b69a2498dbee7578b05f64c38fb" translate="yes" xml:space="preserve">
          <source>QueryEscape escapes the string so it can be safely placed inside a URL query.</source>
          <target state="translated">QueryEscape экранирует строку,чтобы ее можно было безопасно поместить внутри URL запроса.</target>
        </trans-unit>
        <trans-unit id="4ddc8a6f5079b6c63ba14548ae3605122eaf2692" translate="yes" xml:space="preserve">
          <source>QueryRow executes a prepared query statement with the given arguments. If an error occurs during the execution of the statement, that error will be returned by a call to Scan on the returned *Row, which is always non-nil. If the query selects no rows, the *Row's Scan will return ErrNoRows. Otherwise, the *Row's Scan scans the first selected row and discards the rest.</source>
          <target state="translated">QueryRow выполняет подготовленный запрос с заданными аргументами.Если во время выполнения оператора произойдет ошибка,то эта ошибка будет возвращена вызовом Scan на возвращаемом *Row,который всегда будет нулевым.Если запрос не выберет ни одной строки,то *Row's Scan вернет ErrNoRows.В противном случае,*Row's Scan сканирует первую выбранную строку и отбрасывает остальные.</target>
        </trans-unit>
        <trans-unit id="0573144afbb38c9c195cafc127ff8c5f7fcc98f1" translate="yes" xml:space="preserve">
          <source>QueryRow executes a query that is expected to return at most one row. QueryRow always returns a non-nil value. Errors are deferred until Row's Scan method is called. If the query selects no rows, the *Row's Scan will return ErrNoRows. Otherwise, the *Row's Scan scans the first selected row and discards the rest.</source>
          <target state="translated">QueryRow выполняет запрос,который,как ожидается,вернется не более чем в одну строку.QueryRow всегда возвращает нулевое значение.Ошибки откладываются до вызова метода Row's Scan.Если запрос не выберет ни одной строки,то *Row's Scan вернет ErrNoRows.В противном случае,*Row's Scan сканирует первую выбранную строку и отбрасывает остальные.</target>
        </trans-unit>
        <trans-unit id="5b9f01963f310c9b55f64de5af1de9e922ab703a" translate="yes" xml:space="preserve">
          <source>QueryRowContext executes a prepared query statement with the given arguments. If an error occurs during the execution of the statement, that error will be returned by a call to Scan on the returned *Row, which is always non-nil. If the query selects no rows, the *Row's Scan will return ErrNoRows. Otherwise, the *Row's Scan scans the first selected row and discards the rest.</source>
          <target state="translated">QueryRowContext выполняет подготовленный запрос с заданными аргументами.Если во время выполнения оператора произойдет ошибка,то эта ошибка будет возвращена вызовом Scan на возвращаемом *Row,который всегда будет нулевым.Если в запросе не будет выбрано ни одного строки,то *Row's Scan вернет ErrNoRows.В противном случае,*Row's Scan сканирует первую выбранную строку и отбрасывает остальные.</target>
        </trans-unit>
        <trans-unit id="297d4c57ac1fe022d65f3f9afe2a0b04f607cea7" translate="yes" xml:space="preserve">
          <source>QueryRowContext executes a query that is expected to return at most one row. QueryRowContext always returns a non-nil value. Errors are deferred until Row's Scan method is called. If the query selects no rows, the *Row's Scan will return ErrNoRows. Otherwise, the *Row's Scan scans the first selected row and discards the rest.</source>
          <target state="translated">QueryRowContext выполняет запрос,который,как ожидается,вернётся не более чем в одну строку.QueryRowContext всегда возвращает нулевое значение.Ошибки откладываются до вызова метода Row's Scan.Если запрос не выберет ни одной строки,метод *Row's Scan вернет ErrNoRows.В противном случае,*Row's Scan сканирует первую выбранную строку и отбрасывает остальные.</target>
        </trans-unit>
        <trans-unit id="dcdd15a746401ad098faa59578b02f667ab6f1ed" translate="yes" xml:space="preserve">
          <source>QueryUnescape does the inverse transformation of QueryEscape, converting each 3-byte encoded substring of the form &quot;%AB&quot; into the hex-decoded byte 0xAB. It returns an error if any % is not followed by two hexadecimal digits.</source>
          <target state="translated">QueryUnescape выполняет обратное преобразование QueryEscape,преобразуя каждую 3-байтовую закодированную подстроку формы &quot;%AB&quot; в шестнадцатеричный дешифрованный байт 0xAB.Возвращает ошибку,если за любым % не следуют две шестнадцатеричные цифры.</target>
        </trans-unit>
        <trans-unit id="02d2728197191f99f0589563ffe142aff0d31057" translate="yes" xml:space="preserve">
          <source>Queryer is an optional interface that may be implemented by a Conn.</source>
          <target state="translated">Queryer является дополнительным интерфейсом,который может быть реализован с помощью Conn.</target>
        </trans-unit>
        <trans-unit id="1c47ac983cb47637ae28fbb6e2c18b4b8c42e06e" translate="yes" xml:space="preserve">
          <source>QueryerContext is an optional interface that may be implemented by a Conn.</source>
          <target state="translated">QueryerContext-это дополнительный интерфейс,который может быть реализован с помощью Conn.</target>
        </trans-unit>
        <trans-unit id="0013523fcda039d68ac4ad5f69b453c942a978cf" translate="yes" xml:space="preserve">
          <source>QueryerContext may return ErrSkip.</source>
          <target state="translated">QueryerContext может вернуть ErrSkip.</target>
        </trans-unit>
        <trans-unit id="c63975c9274fd71acb9468b157e86657fe44318f" translate="yes" xml:space="preserve">
          <source>QueryerContext must honor the context timeout and return when the context is canceled.</source>
          <target state="translated">QueryerContext должен учитывать таймаут контекста и возвращаться,когда контекст отменяется.</target>
        </trans-unit>
        <trans-unit id="9769d5fe0c55a8ef8d81aaad984f657373379c37" translate="yes" xml:space="preserve">
          <source>Quit sends the QUIT command and closes the connection to the server.</source>
          <target state="translated">Quit посылает команду QUIT и закрывает соединение с сервером.</target>
        </trans-unit>
        <trans-unit id="7e1aae2dbf075bb68d93d724ad6566e5e4a1c5e3" translate="yes" xml:space="preserve">
          <source>Quo sets z to the quotient x/y and returns z. If y == 0, a division-by-zero run-time panic occurs.</source>
          <target state="translated">Кво устанавливает z в коэффициент x/y и возвращает z.Если y ==0,то происходит паника при делении на ноль.</target>
        </trans-unit>
        <trans-unit id="a7929eb506dd3242d50cf4b52d276a4b8cb9c07b" translate="yes" xml:space="preserve">
          <source>Quo sets z to the quotient x/y for y != 0 and returns z. If y == 0, a division-by-zero run-time panic occurs. Quo implements truncated division (like Go); see QuoRem for more details.</source>
          <target state="translated">Кво устанавливает z в коэффициент x/y для y !=0 и возвращает z.Если y ==0,то происходит паника при делении на ноль.Quo реализует усеченное деление (как Go);подробнее см.в QuoRem.</target>
        </trans-unit>
        <trans-unit id="1572bc36f1694a28504f4543686c15ca4cc42af5" translate="yes" xml:space="preserve">
          <source>Quo sets z to the rounded quotient x/y and returns z. Precision, rounding, and accuracy reporting are as for Add. Quo panics with ErrNaN if both operands are zero or infinities. The value of z is undefined in that case.</source>
          <target state="translated">Кво устанавливает z в округлый коэффициент x/y и возвращает z.Точность,округление и точность отчетов как для Добавить.Quo panics с ErrNaN,если оба операнда нулевые или бесконечные.Значение z в этом случае не определено.</target>
        </trans-unit>
        <trans-unit id="99e212957f2d4b215b9b3d9954ca4d24b4f7b7f8" translate="yes" xml:space="preserve">
          <source>QuoRem implements T-division and modulus (like Go):</source>
          <target state="translated">QuoRem реализует T-разделение и модуль (как Go):</target>
        </trans-unit>
        <trans-unit id="c9ddbdd15bfd376c21e0a62b9370cde6334dc1f4" translate="yes" xml:space="preserve">
          <source>QuoRem sets z to the quotient x/y and r to the remainder x%y and returns the pair (z, r) for y != 0. If y == 0, a division-by-zero run-time panic occurs.</source>
          <target state="translated">QuoRem устанавливает z в коэффициент x/y и r в остаток x%y и возвращает пару (z,r)для y !=0.Если y ==0,то происходит паника при делении на ноль.</target>
        </trans-unit>
        <trans-unit id="309028a9e01273ac7a88142bf26446f3f2a8f06c" translate="yes" xml:space="preserve">
          <source>Quote</source>
          <target state="translated">Quote</target>
        </trans-unit>
        <trans-unit id="02a6b721c3cbad5a2ac35c25089d53ad320899bd" translate="yes" xml:space="preserve">
          <source>Quote and QuoteToASCII convert strings to quoted Go string literals. The latter guarantees that the result is an ASCII string, by escaping any non-ASCII Unicode with \u:</source>
          <target state="translated">Quote и QuoteToASCII преобразуют строки в кавычки строковых литералов Go.Последний гарантирует,что результатом будет ASCII-строка,экранируя любой не-ASCII-юникод с \u:</target>
        </trans-unit>
        <trans-unit id="3617a988d68c2550b56a0533be32b6f532f0c980" translate="yes" xml:space="preserve">
          <source>Quote returns a double-quoted Go string literal representing s. The returned string uses Go escape sequences (\t, \n, \xFF, \u0100) for control characters and non-printable characters as defined by IsPrint.</source>
          <target state="translated">Цитата возвращает двойные кавычки Go string литерала,представляющего s.Возвращаемая строка использует Go escape последовательности (\t,\n,\xFF,\u0100)для управляющих символов и непечатаемых символов,как определено IsPrint.</target>
        </trans-unit>
        <trans-unit id="6f31dc77f679cfa7aaf16ecb978ab9c3d8982f6f" translate="yes" xml:space="preserve">
          <source>QuoteMeta</source>
          <target state="translated">QuoteMeta</target>
        </trans-unit>
        <trans-unit id="37da03d2f50ceab91ce8002d89f395e8b70d32e3" translate="yes" xml:space="preserve">
          <source>QuoteMeta returns a string that escapes all regular expression metacharacters inside the argument text; the returned string is a regular expression matching the literal text.</source>
          <target state="translated">QuoteMeta возвращает строку,которая экранирует все метахарические символы регулярных выражений внутри текста аргумента;возвращаемая строка является регулярным выражением,соответствующим буквальному тексту.</target>
        </trans-unit>
        <trans-unit id="e4b2ad9113103116d841b51eb9a5a4bb79d43dd5" translate="yes" xml:space="preserve">
          <source>QuoteRune</source>
          <target state="translated">QuoteRune</target>
        </trans-unit>
        <trans-unit id="642db102936be1179d9fd316324babf33d424684" translate="yes" xml:space="preserve">
          <source>QuoteRune and QuoteRuneToASCII are similar but accept runes and return quoted Go rune literals.</source>
          <target state="translated">QuoteRune и QuoteRuneToASCII похожи,но принимают руны и возвращают процитированные литералы Go rune.</target>
        </trans-unit>
        <trans-unit id="279cda9da221d3eced1baaee13fb941915b0ad94" translate="yes" xml:space="preserve">
          <source>QuoteRune returns a single-quoted Go character literal representing the rune. The returned string uses Go escape sequences (\t, \n, \xFF, \u0100) for control characters and non-printable characters as defined by IsPrint.</source>
          <target state="translated">QuoteRune возвращает буквальный символ &quot;Go&quot;,обозначающий руну,в единственной кавычке.Возвращаемая строка использует экранирующие последовательности Go (\t,\n,\xFF,\u0100)для управляющих и непечатаемых символов,как определено в IsPrint.</target>
        </trans-unit>
        <trans-unit id="c3b760977eead2353634f7488bfbfd8e6f53c7d3" translate="yes" xml:space="preserve">
          <source>QuoteRuneToASCII</source>
          <target state="translated">QuoteRuneToASCII</target>
        </trans-unit>
        <trans-unit id="53e2d039ada874ffb648eee9f937362314f5598e" translate="yes" xml:space="preserve">
          <source>QuoteRuneToASCII returns a single-quoted Go character literal representing the rune. The returned string uses Go escape sequences (\t, \n, \xFF, \u0100) for non-ASCII characters and non-printable characters as defined by IsPrint.</source>
          <target state="translated">QuoteRuneToASCII возвращает одноцифровой символ Go,представляющий руну.Возвращаемая строка использует экранирующие последовательности Go (\t,\n,\xFF,\u0100)для не-ASCII символов и непечатаемых символов,как определено в IsPrint.</target>
        </trans-unit>
        <trans-unit id="0b7fc6950d658f88c7fbca21f506d8678210ba4b" translate="yes" xml:space="preserve">
          <source>QuoteRuneToGraphic</source>
          <target state="translated">QuoteRuneToGraphic</target>
        </trans-unit>
        <trans-unit id="d7acc4ec0f4c890982546aed330f635d958aaa08" translate="yes" xml:space="preserve">
          <source>QuoteRuneToGraphic returns a single-quoted Go character literal representing the rune. The returned string uses Go escape sequences (\t, \n, \xFF, \u0100) for non-ASCII characters and non-printable characters as defined by IsGraphic.</source>
          <target state="translated">QuoteRuneToGraphic возвращает одноцифровой символ Go,представляющий руну.Возвращаемая строка использует экранирующие последовательности Go (\t,\n,\xFF,\u0100)для не-ASCII символов и непечатаемых символов в соответствии с определением IsGraphic.</target>
        </trans-unit>
        <trans-unit id="1c5941bc9d5a3819ff2354cecea7900bb16d81ce" translate="yes" xml:space="preserve">
          <source>QuoteToASCII</source>
          <target state="translated">QuoteToASCII</target>
        </trans-unit>
        <trans-unit id="1903845d523cb092b2910db9e417c9681642b306" translate="yes" xml:space="preserve">
          <source>QuoteToASCII returns a double-quoted Go string literal representing s. The returned string uses Go escape sequences (\t, \n, \xFF, \u0100) for non-ASCII characters and non-printable characters as defined by IsPrint.</source>
          <target state="translated">QuoteToASCII возвращает двузначный литерал Go string,представляющий s.Возвращаемая строка использует экранирующие последовательности Go (\t,\n,\xFF,\u0100)для не-ASCII-символов и непечатаемых символов,как определено IsPrint.</target>
        </trans-unit>
        <trans-unit id="4621ad4d6c0a75793529926b49a9e0ff472d7a25" translate="yes" xml:space="preserve">
          <source>QuoteToGraphic</source>
          <target state="translated">QuoteToGraphic</target>
        </trans-unit>
        <trans-unit id="29d4d4e582c2a53b8be9f8063c3bfb0f71cbfd71" translate="yes" xml:space="preserve">
          <source>QuoteToGraphic returns a double-quoted Go string literal representing s. The returned string uses Go escape sequences (\t, \n, \xFF, \u0100) for non-ASCII characters and non-printable characters as defined by IsGraphic.</source>
          <target state="translated">QuoteToGraphic возвращает двузначный литерал Go string,представляющий s.Возвращаемая строка использует экранирующие последовательности Go (\t,\n,\xFF,\u0100)для не-ASCII-символов и непечатаемых символов в соответствии с определением IsGraphic.</target>
        </trans-unit>
        <trans-unit id="fd12f86a63d23d37e2246e2c7fa6e414286f5f3b" translate="yes" xml:space="preserve">
          <source>RC4 is cryptographically broken and should not be used for secure applications.</source>
          <target state="translated">RC4 криптографически сломан и не должен использоваться для безопасного применения.</target>
        </trans-unit>
        <trans-unit id="bc475e86eb000cdc90e36723f96df5f3d9198891" translate="yes" xml:space="preserve">
          <source>RGBA is an in-memory image whose At method returns color.RGBA values.</source>
          <target state="translated">RGBA-это изображение в памяти,которое в At-методе возвращает значения color.RGBA.</target>
        </trans-unit>
        <trans-unit id="04d387f558acb0866f18159db1f3ea813711e9ce" translate="yes" xml:space="preserve">
          <source>RGBA represents a traditional 32-bit alpha-premultiplied color, having 8 bits for each of red, green, blue and alpha.</source>
          <target state="translated">RGBA представляет собой традиционный 32-битный альфа-цвет,имеющий по 8 бит для каждого из красного,зеленого,синего и альфа.</target>
        </trans-unit>
        <trans-unit id="46da93f2d89b5f7316108ef78fe128ccbb04c72c" translate="yes" xml:space="preserve">
          <source>RGBA64 is an in-memory image whose At method returns color.RGBA64 values.</source>
          <target state="translated">RGBA64-это изображение в памяти,которое в At-методе возвращает значения color.RGBA64.</target>
        </trans-unit>
        <trans-unit id="dd5b935255bb5c16c695e848211ad0d21f5142a6" translate="yes" xml:space="preserve">
          <source>RGBA64 represents a 64-bit alpha-premultiplied color, having 16 bits for each of red, green, blue and alpha.</source>
          <target state="translated">RGBA64 представляет собой 64-битный альфа-цвет,имеющий по 16 бит для каждого из красного,зеленого,синего и альфа.</target>
        </trans-unit>
        <trans-unit id="33f4c44fe26c52f4a8501dd0d6638972bee0c02a" translate="yes" xml:space="preserve">
          <source>RGBToCMYK converts an RGB triple to a CMYK quadruple.</source>
          <target state="translated">RGBToCMYK преобразует RGB-тройку в CMYK-четверку.</target>
        </trans-unit>
        <trans-unit id="b770a15a910f2bcdc5fe9614ef9593fa435bc817" translate="yes" xml:space="preserve">
          <source>RGBToYCbCr converts an RGB triple to a Y'CbCr triple.</source>
          <target state="translated">RGBToYCbCr преобразует тройку RGB в тройку Y'CbCr.</target>
        </trans-unit>
        <trans-unit id="80bfa68e1e388f84eb032cb18125580dfa1ad40c" translate="yes" xml:space="preserve">
          <source>RLock locks rw for reading.</source>
          <target state="translated">RLock замки rw для чтения.</target>
        </trans-unit>
        <trans-unit id="437fa597804ed80cc48e0b7bbfe7afd323e52a8f" translate="yes" xml:space="preserve">
          <source>RLocker returns a Locker interface that implements the Lock and Unlock methods by calling rw.RLock and rw.RUnlock.</source>
          <target state="translated">RLocker возвращает интерфейс Блокировщика,который реализует методы Блокировки и Разблокировки,вызывая rw.RLock и rw.RUnlock.</target>
        </trans-unit>
        <trans-unit id="e9e1378ed0c7150ba139600e4e6dab65e5c1015c" translate="yes" xml:space="preserve">
          <source>RSA is a single, fundamental operation that is used in this package to implement either public-key encryption or public-key signatures.</source>
          <target state="translated">RSA-это единственная,фундаментальная операция,которая используется в данном пакете для реализации либо шифрования с открытым ключом,либо подписей с открытым ключом.</target>
        </trans-unit>
        <trans-unit id="c5491899defb867c4967ebbebdd0bd5970a6aab7" translate="yes" xml:space="preserve">
          <source>RSA is able to encrypt only a very limited amount of data. In order to encrypt reasonable amounts of data a hybrid scheme is commonly used: RSA is used to encrypt a key for a symmetric primitive like AES-GCM. Before encrypting, data is &amp;ldquo;padded&amp;rdquo; by embedding it in a known structure. This is done for a number of reasons, but the most obvious is to ensure that the value is large enough that the exponentiation is larger than the modulus. (Otherwise it could be decrypted with a square-root.) In these designs, when using PKCS#1 v1.5, it's vitally important to avoid disclosing whether the received RSA message was well-formed (that is, whether the result of decrypting is a correctly padded message) because this leaks secret information. DecryptPKCS1v15SessionKey is designed for this situation and copies the decrypted, symmetric key (if well-formed) in constant-time over a buffer that contains a random key. Thus, if the RSA result isn't well-formed, the implementation uses a random key in constant time.</source>
          <target state="translated">RSA может зашифровать только очень ограниченный объем данных. Для шифрования разумных объемов данных обычно используется гибридная схема: RSA используется для шифрования ключа для симметричного примитива, такого как AES-GCM. Перед шифрованием данные &amp;laquo;дополняются&amp;raquo; путем встраивания их в известную структуру. Это делается по ряду причин, но наиболее очевидным является обеспечение того, чтобы значение было достаточно большим, чтобы возведение в степень было больше модуля. (В противном случае его можно было бы расшифровать с помощью квадратного корня.) В этих проектах при использовании PKCS # 1 v1.5 жизненно важно избегать раскрытия того, было ли полученное сообщение RSA правильно сформировано (то есть, является ли результат дешифрования это сообщение с правильно заполненным кодом), потому что это приводит к утечке секретной информации. DecryptPKCS1v15SessionKey предназначен для этой ситуации и копирует расшифрованные,симметричный ключ (если он правильно сформирован) с постоянным временем в буфере, который содержит случайный ключ. Таким образом, если результат RSA сформирован некорректно, реализация использует случайный ключ за постоянное время.</target>
        </trans-unit>
        <trans-unit id="0d73a3a42eb35fcb3f1a5896de985a3713b16b03" translate="yes" xml:space="preserve">
          <source>RUnlock undoes a single RLock call; it does not affect other simultaneous readers. It is a run-time error if rw is not locked for reading on entry to RUnlock.</source>
          <target state="translated">RUnlock отменяет одиночный вызов RLock;это не влияет на другие одновременные считыватели.Ошибка во время выполнения,если rw не заблокирован для чтения при входе в RUnlock.</target>
        </trans-unit>
        <trans-unit id="b74aed63ef335b4d50b7ff503e63deda9fc37c24" translate="yes" xml:space="preserve">
          <source>Rand sets z to a pseudo-random number in [0, n) and returns z.</source>
          <target state="translated">Rand устанавливает z в псевдослучайное число в [0,n]и возвращает z.</target>
        </trans-unit>
        <trans-unit id="cd54bd9d380c9fc6a34adb64461692fb6d87443f" translate="yes" xml:space="preserve">
          <source>Random numbers are generated by a Source. Top-level functions, such as Float64 and Int, use a default shared Source that produces a deterministic sequence of values each time a program is run. Use the Seed function to initialize the default Source if different behavior is required for each run. The default Source is safe for concurrent use by multiple goroutines, but Sources created by NewSource are not.</source>
          <target state="translated">Случайные числа генерируются Источником.Функции верхнего уровня,такие как Float64 и Int,используют общий источник по умолчанию,который генерирует детерминированную последовательность значений при каждом запуске программы.Используйте функцию Seed для инициализации Источника по умолчанию,если для каждого выполнения программы требуется разное поведение.Источник по умолчанию безопасен для одновременного использования несколькими goroutines,но Источники,созданные NewSource,таковыми не являются.</target>
        </trans-unit>
        <trans-unit id="8185befebe4b99fc7f08cc0f98bec64eff9d397b" translate="yes" xml:space="preserve">
          <source>Range calls f sequentially for each key and value present in the map. If f returns false, range stops the iteration.</source>
          <target state="translated">Диапазон вызовов f последовательно для каждой клавиши и значения,представленного на карте.Если f возвращает false,диапазон останавливает итерацию.</target>
        </trans-unit>
        <trans-unit id="e20ffc43a19a831487646a9ec91a15662b93326d" translate="yes" xml:space="preserve">
          <source>Range does not necessarily correspond to any consistent snapshot of the Map's contents: no key will be visited more than once, but if the value for any key is stored or deleted concurrently, Range may reflect any mapping for that key from any point during the Range call.</source>
          <target state="translated">Range не обязательно соответствует какому-либо последовательному снимку содержимого карты:ни один ключ не будет посещен более одного раза,но если значение для любого ключа хранится или удаляется одновременно,Range может отражать любую привязку для этого ключа с любой точки во время вызова Range.</target>
        </trans-unit>
        <trans-unit id="faec537bfdedcf391dd6afc93a601559afbe0c69" translate="yes" xml:space="preserve">
          <source>Range may be O(N) with the number of elements in the map even if f returns false after a constant number of calls.</source>
          <target state="translated">Диапазон может быть O(N)с количеством элементов на карте,даже если f возвращает false после постоянного количества вызовов.</target>
        </trans-unit>
        <trans-unit id="dc094bef8459881bcfd6a354dcd57e410a9ea71d" translate="yes" xml:space="preserve">
          <source>Range16 represents of a range of 16-bit Unicode code points. The range runs from Lo to Hi inclusive and has the specified stride.</source>
          <target state="translated">Диапазон16 представляет собой диапазон 16-битных точек кода Юникода.Диапазон простирается от Lo до Hi включительно и имеет заданный шаг.</target>
        </trans-unit>
        <trans-unit id="8ceb0b8d7c66b188254058f3e47e0188e8c2c9ca" translate="yes" xml:space="preserve">
          <source>Range32 represents of a range of Unicode code points and is used when one or more of the values will not fit in 16 bits. The range runs from Lo to Hi inclusive and has the specified stride. Lo and Hi must always be &amp;gt;= 1&amp;lt;&amp;lt;16.</source>
          <target state="translated">Range32 представляет собой диапазон кодовых точек Unicode и используется, когда одно или несколько значений не помещаются в 16 бит. Диапазон составляет от Lo до Hi включительно и имеет указанный шаг. Lo и Hi всегда должны быть&amp;gt; = 1 &amp;lt;&amp;lt; 16.</target>
        </trans-unit>
        <trans-unit id="3c231e0e20b34ad9b3302a62e18606f8e55490f0" translate="yes" xml:space="preserve">
          <source>RangeNode represents a {{range}} action and its commands.</source>
          <target state="translated">RangeNode представляет собой действие {{диапазон}}и его команды.</target>
        </trans-unit>
        <trans-unit id="abf434f30dd2288f852577f0e6ac91164ff1a3d8" translate="yes" xml:space="preserve">
          <source>RangeTable defines a set of Unicode code points by listing the ranges of code points within the set. The ranges are listed in two slices to save space: a slice of 16-bit ranges and a slice of 32-bit ranges. The two slices must be in sorted order and non-overlapping. Also, R32 should contain only values &amp;gt;= 0x10000 (1&amp;lt;&amp;lt;16).</source>
          <target state="translated">RangeTable определяет набор кодовых точек Unicode, перечисляя диапазоны кодовых точек в наборе. Диапазоны перечислены в двух частях для экономии места: часть из 16-битных диапазонов и часть из 32-битных диапазонов. Два фрагмента должны быть отсортированы и не пересекаться. Кроме того, R32 должен содержать только значения&amp;gt; = 0x10000 (1 &amp;lt;&amp;lt; 16).</target>
        </trans-unit>
        <trans-unit id="c2ee87a3ff54a0745b9a4a39ad5daff79dc82bc0" translate="yes" xml:space="preserve">
          <source>Ranges returns the PC ranges covered by e, a slice of [low,high) pairs. Only some entry types, such as TagCompileUnit or TagSubprogram, have PC ranges; for others, this will return nil with no error.</source>
          <target state="translated">Диапазоны возвращают диапазоны ПК,покрытые e,ломтиком [низкой,высокой]пары.Только некоторые типы записей,такие как TagCompileUnit или TagSubprogram,имеют диапазоны ПК;для других,это вернет ноль без ошибок.</target>
        </trans-unit>
        <trans-unit id="81de462dc83f2812dc32eb06897fa3d4b38ae7e7" translate="yes" xml:space="preserve">
          <source>Rat returns the rational number corresponding to x; or nil if x is an infinity. The result is Exact if x is not an Inf. If a non-nil *Rat argument z is provided, Rat stores the result in z instead of allocating a new Rat.</source>
          <target state="translated">Крыса возвращает рациональное число,соответствующее x;или ноль,если x-бесконечность.Результатом будет Exact,если x не является Inf.Если аргумент z не равен нулю *Крыса,то Крыса сохраняет результат в z вместо выделения новой Крысы.</target>
        </trans-unit>
        <trans-unit id="50ea5863423e0f2515585dcf8c4cb2e31c788a51" translate="yes" xml:space="preserve">
          <source>Rat.Scan</source>
          <target state="translated">Rat.Scan</target>
        </trans-unit>
        <trans-unit id="c5f08baa94ad88996a91c67be38be8fe61b40881" translate="yes" xml:space="preserve">
          <source>Rat.SetString</source>
          <target state="translated">Rat.SetString</target>
        </trans-unit>
        <trans-unit id="ef746adb638d3b60d53628e5d2f1455b1d2e8157" translate="yes" xml:space="preserve">
          <source>RatString returns a string representation of x in the form &quot;a/b&quot; if b != 1, and in the form &quot;a&quot; if b == 1.</source>
          <target state="translated">RatString возвращает строковое представление x в виде &quot;a/b&quot;,если b !=1,и в виде &quot;a&quot;,если b ==1.</target>
        </trans-unit>
        <trans-unit id="641d010f14e2f18c1619afc2268deaff20c97455" translate="yes" xml:space="preserve">
          <source>Raw executes f exposing the underlying driver connection for the duration of f. The driverConn must not be used outside of f.</source>
          <target state="translated">Сырье выполняет f,разоблачая соединение с водителем в течение f.ВодительConn не должен использоваться за пределами f.</target>
        </trans-unit>
        <trans-unit id="26c83b72700cdd4952e72476a8d6589b2a87a210" translate="yes" xml:space="preserve">
          <source>RawBytes is a byte slice that holds a reference to memory owned by the database itself. After a Scan into a RawBytes, the slice is only valid until the next call to Next, Scan, or Close.</source>
          <target state="translated">RawBytes-это срез байта,который содержит ссылку на память,принадлежащую самой базе данных.После Сканирования в RawBytes этот срез действителен только до следующего вызова Next,Scan или Close.</target>
        </trans-unit>
        <trans-unit id="3e2984f789eabe0509843f2607db31c184bddf19" translate="yes" xml:space="preserve">
          <source>RawContent is used to signal that the undecoded, DER data needs to be preserved for a struct. To use it, the first field of the struct must have this type. It's an error for any of the other fields to have this type.</source>
          <target state="translated">RawContent используется для сигнала о том,что не декодированные,DER-данные должны быть сохранены для структуры.Для его использования первое поле структуры должно иметь такой тип.Ошибкой является то,что любое из других полей должно иметь этот тип.</target>
        </trans-unit>
        <trans-unit id="40ee0825120347a6625b948e8e5d6cf21e430f3f" translate="yes" xml:space="preserve">
          <source>RawMessage (Marshal)</source>
          <target state="translated">RawMessage (Маршал)</target>
        </trans-unit>
        <trans-unit id="d988676cc711a8df55ed7c79d1c3ecdfedc6d2cd" translate="yes" xml:space="preserve">
          <source>RawMessage (Unmarshal)</source>
          <target state="translated">RawMessage (Unmarshal)</target>
        </trans-unit>
        <trans-unit id="1b6da1274d970ef16e862ce3a549bfc22e374a82" translate="yes" xml:space="preserve">
          <source>RawMessage is a raw encoded JSON value. It implements Marshaler and Unmarshaler and can be used to delay JSON decoding or precompute a JSON encoding.</source>
          <target state="translated">RawMessage-это необработанное кодированное JSON-значение.Оно реализует функции Marshaler и Unmarshaler и может быть использовано для задержки декодирования JSON или прекомпиляции кодировки JSON.</target>
        </trans-unit>
        <trans-unit id="b92ccd29d9bf661a3766af996d8af025383bbfe8" translate="yes" xml:space="preserve">
          <source>RawStdEncoding is the standard raw, unpadded base64 encoding, as defined in RFC 4648 section 3.2. This is the same as StdEncoding but omits padding characters.</source>
          <target state="translated">RawStdEncoding является стандартной необработанной кодировкой base64,как определено в разделе 3.2 RFC 4648.Это то же самое,что и StdEncoding,но в нем опущены символы подстановки.</target>
        </trans-unit>
        <trans-unit id="6e753058a412394f90ee90228dcf31c4e858e385" translate="yes" xml:space="preserve">
          <source>RawToken is like Token but does not verify that start and end elements match and does not translate name space prefixes to their corresponding URLs.</source>
          <target state="translated">RawToken похож на Token,но не проверяет,совпадают ли начальный и конечный элементы,и не переводит префиксы пространства имён на соответствующие URL.</target>
        </trans-unit>
        <trans-unit id="166fbd6be28a6fdfe4f94b440b329268727101a8" translate="yes" xml:space="preserve">
          <source>RawURLEncoding is the unpadded alternate base64 encoding defined in RFC 4648. It is typically used in URLs and file names. This is the same as URLEncoding but omits padding characters.</source>
          <target state="translated">RawURLEncoding-это недобавленная альтернативная кодировка base64,определенная в RFC 4648.Обычно она используется в URL-адресах и именах файлов.Это то же самое,что и URLE-кодировка,но в ней опущены символы подстановки.</target>
        </trans-unit>
        <trans-unit id="b05c645148a5f30bf1ff0257be7322f1e5b30562" translate="yes" xml:space="preserve">
          <source>Rcpt issues a RCPT command to the server using the provided email address. A call to Rcpt must be preceded by a call to Mail and may be followed by a Data call or another Rcpt call.</source>
          <target state="translated">Rcpt выдает команду RCPT на сервер,используя предоставленный адрес электронной почты.Вызову Rcpt должен предшествовать вызов Mail,за которым может последовать вызов Data или другой вызов Rcpt.</target>
        </trans-unit>
        <trans-unit id="852b438f91ad9eb2cdd84419a675a216d543c687" translate="yes" xml:space="preserve">
          <source>Read</source>
          <target state="translated">Read</target>
        </trans-unit>
        <trans-unit id="1fab142ac33b47994d5f7bd4bebd0d391e21aa89" translate="yes" xml:space="preserve">
          <source>Read (Multi)</source>
          <target state="translated">Чтение (Мульти)</target>
        </trans-unit>
        <trans-unit id="7d9a4bfe253412dcb5fa31eea7ed6b71a69c4521" translate="yes" xml:space="preserve">
          <source>Read calls decode to deserialize a file set into s; s must not be nil.</source>
          <target state="translated">Чтение расшифровки вызовов для десериализации набора файлов в s;s не должно быть нулевым.</target>
        </trans-unit>
        <trans-unit id="cf8ca129127382252f21178b2e38598c4c8bdae5" translate="yes" xml:space="preserve">
          <source>Read can be made to time out and return a net.Error with Timeout() == true after a fixed time limit; see SetDeadline and SetReadDeadline.</source>
          <target state="translated">Чтение можно сделать до тайм-аута и вернуть net.Error с функцией Timeout()==true по истечении фиксированного времени;смотрите SetDeadline и SetReadDeadline.</target>
        </trans-unit>
        <trans-unit id="f1410843edc88c2b9c942b455b313f9ec9a6aa42" translate="yes" xml:space="preserve">
          <source>Read generates len(p) random bytes and writes them into p. It always returns len(p) and a nil error. Read should not be called concurrently with any other Rand method.</source>
          <target state="translated">Read генерирует случайные байты len(p)и записывает их в p.Он всегда возвращает len(p)и нулевую ошибку.Чтение не должно вызываться одновременно с любым другим методом Rand.</target>
        </trans-unit>
        <trans-unit id="1059017001f226c432850be91279c7915ab436ce" translate="yes" xml:space="preserve">
          <source>Read generates len(p) random bytes from the default Source and writes them into p. It always returns len(p) and a nil error. Read, unlike the Rand.Read method, is safe for concurrent use.</source>
          <target state="translated">Read генерирует случайные байты len(p)из источника по умолчанию и записывает их в p.Он всегда возвращает len(p)и нулевую ошибку.Чтение,в отличие от метода Rand.Read,безопасно для одновременного использования.</target>
        </trans-unit>
        <trans-unit id="a6208c052d923f9826a6caa2665b94a206f4ce81" translate="yes" xml:space="preserve">
          <source>Read implements io.Reader, reading uncompressed bytes from its underlying Reader.</source>
          <target state="translated">Read реализует io.Reader,читая несжатые байты из своего базового Reader.</target>
        </trans-unit>
        <trans-unit id="702bfd00bb1c14225a9197a21d99befbae954266" translate="yes" xml:space="preserve">
          <source>Read implements the Conn Read method.</source>
          <target state="translated">Считывание реализует метод Conn Read.</target>
        </trans-unit>
        <trans-unit id="516c851188aa6fc002db294d7651c5ec750120d8" translate="yes" xml:space="preserve">
          <source>Read implements the io.Reader interface.</source>
          <target state="translated">Read реализует интерфейс io.Reader.</target>
        </trans-unit>
        <trans-unit id="13632ff4ca176eb49e2ded2120c8bd44145f6430" translate="yes" xml:space="preserve">
          <source>Read implements the standard Read interface: it reads data from the pipe, blocking until a writer arrives or the write end is closed. If the write end is closed with an error, that error is returned as err; otherwise err is EOF.</source>
          <target state="translated">Read реализует стандартный интерфейс Read:он считывает данные из трубы,блокируя их до тех пор,пока не появится записывающее устройство или не будет закрыт конец записи.Если конец записи закрыт с ошибкой,то эта ошибка возвращается как ошибочная,в противном случае ошибочная-EOF.</target>
        </trans-unit>
        <trans-unit id="852b19fc6db1a887a68fe0a33719da8f3df7f6a7" translate="yes" xml:space="preserve">
          <source>Read is a helper function that calls Reader.Read using io.ReadFull. On return, n == len(b) if and only if err == nil.</source>
          <target state="translated">Read-это вспомогательная функция,которая вызывает Reader.Read с помощью io.ReadFull.При возврате n ==len(b)if и только если err ==nil.</target>
        </trans-unit>
        <trans-unit id="6027400201b1aeffebb229f97e47437dd5103716" translate="yes" xml:space="preserve">
          <source>Read reads and decodes quoted-printable data from the underlying reader.</source>
          <target state="translated">Читает и расшифровывает данные,которые можно прочитать в кавычках,с помощью соответствующего считывающего устройства.</target>
        </trans-unit>
        <trans-unit id="099ba490bf08acc0d4ea27ba7af0e8caf12990cd" translate="yes" xml:space="preserve">
          <source>Read reads data into p. It returns the number of bytes read into p. The bytes are taken from at most one Read on the underlying Reader, hence n may be less than len(p). To read exactly len(p) bytes, use io.ReadFull(b, p). At EOF, the count will be zero and err will be io.EOF.</source>
          <target state="translated">Считывание данных в p.Возвращает количество байт,считанных в p.Байты берутся максимум из одного Считывания на соответствующем считывающем устройстве,поэтому n может быть меньше len(p).Для точного считывания байтов len(p)используйте io.ReadFull(b,p).В EOF счет будет равен нулю,а ошибка-io.EOF.</target>
        </trans-unit>
        <trans-unit id="16ce634004d504a55e55d47a3800c80b22768a4e" translate="yes" xml:space="preserve">
          <source>Read reads from the current file in the tar archive. It returns (0, io.EOF) when it reaches the end of that file, until Next is called to advance to the next file.</source>
          <target state="translated">Читает из текущего файла в tar-архиве.Возвращает (0,io.EOF),когда достигает конца этого файла,до тех пор,пока не будет вызван Next для перехода к следующему файлу.</target>
        </trans-unit>
        <trans-unit id="8672c69a1ddaf5ba6848a36cbea552f79e4309ae" translate="yes" xml:space="preserve">
          <source>Read reads one record (a slice of fields) from r. If the record has an unexpected number of fields, Read returns the record along with the error ErrFieldCount. Except for that case, Read always returns either a non-nil record or a non-nil error, but not both. If there is no data left to be read, Read returns nil, io.EOF. If ReuseRecord is true, the returned slice may be shared between multiple calls to Read.</source>
          <target state="translated">Читается одна запись (кусок поля)из r.Если запись имеет неожиданное количество полей,Read возвращает запись вместе с ошибкой ErrFieldCount.За исключением этого случая,Read всегда возвращает либо ненужную запись,либо ненужную ошибку,но не обе.Если данных для чтения не осталось,Read возвращает ноль,т.е.EOF.Если ReuseRecord верна,возвращаемый фрагмент может быть разделен между несколькими вызовами Read.</target>
        </trans-unit>
        <trans-unit id="2a7ebad97783211e0c50dee195a81d2fcc00a21a" translate="yes" xml:space="preserve">
          <source>Read reads structured binary data from r into data. Data must be a pointer to a fixed-size value or a slice of fixed-size values. Bytes read from r are decoded using the specified byte order and written to successive fields of the data. When decoding boolean values, a zero byte is decoded as false, and any other non-zero byte is decoded as true. When reading into structs, the field data for fields with blank (_) field names is skipped; i.e., blank field names may be used for padding. When reading into a struct, all non-blank fields must be exported or Read may panic.</source>
          <target state="translated">Чтение структурированных двоичных данных из r в данные.Данные должны быть указателем на значение с фиксированным размером или куском значений с фиксированным размером.Байты,считанные из r,декодируются по указанному порядку байт и записываются в последовательные поля данных.При декодировании булевых значений нулевой байт декодируется как false,а любой другой ненулевой байт-как true.При чтении в структурах пропускаются данные полей с пустыми (_)именами полей,т.е.пустые имена полей могут быть использованы для заполнения.При чтении в структуру все незаполненные поля должны быть экспортированы,иначе при чтении может возникнуть паника.</target>
        </trans-unit>
        <trans-unit id="13d3208ebb1aa7a1ba1e0de8a255452e3b6f8318" translate="yes" xml:space="preserve">
          <source>Read reads the body of a part, after its headers and before the next part (if any) begins.</source>
          <target state="translated">Читает тело части,после ее заголовков и до начала следующей части (если таковая имеется).</target>
        </trans-unit>
        <trans-unit id="bbca8871624a3fc59330b4b25dd8f3ecce95f77a" translate="yes" xml:space="preserve">
          <source>Read reads the index from r into x; x must not be nil.</source>
          <target state="translated">Читается индекс из r в x;x не должен быть нулевым.</target>
        </trans-unit>
        <trans-unit id="f50cd5c21ed9fed72a69eacf7363def3849c51d8" translate="yes" xml:space="preserve">
          <source>Read reads the next len(p) bytes from the buffer or until the buffer is drained. The return value n is the number of bytes read. If the buffer has no data to return, err is io.EOF (unless len(p) is zero); otherwise it is nil.</source>
          <target state="translated">Читает следующие len(p)байты из буфера или до тех пор,пока буфер не будет очищен.Возвращаемое значение n-это количество прочитанных байтов.Если буфер не имеет данных для возврата,err равен io.EOF (если только len(p)не равен нулю);в противном случае равен нулю.</target>
        </trans-unit>
        <trans-unit id="dd7574617c7b02af539a5115f14c74adf24afa51" translate="yes" xml:space="preserve">
          <source>Read reads the next response from the wire. A valid response might be returned together with an ErrPersistEOF, which means that the remote requested that this be the last request serviced. Read can be called concurrently with Write, but not with another Read.</source>
          <target state="translated">Считывает следующий ответ с провода.Действительный ответ может быть возвращен вместе с ErrPersistEOF,что означает,что удаленный запрос является последним обслуживаемым.Чтение может быть вызвано одновременно с Записью,но не с другим Чтением.</target>
        </trans-unit>
        <trans-unit id="e877852fb33acd1c13bf6498df79e2e968ae525c" translate="yes" xml:space="preserve">
          <source>Read reads up to len(b) bytes from the File. It returns the number of bytes read and any error encountered. At end of file, Read returns 0, io.EOF.</source>
          <target state="translated">Читает до len(b)байт из Файла.Возвращает количество прочитанных байт и обнаруженную ошибку.В конце файла Read возвращает 0,io.EOF.</target>
        </trans-unit>
        <trans-unit id="5d839b22857eca34207c84ba0a055c6ee9c74ec5" translate="yes" xml:space="preserve">
          <source>Read reads up to len(p) bytes into p. It returns the number of bytes read (0 &amp;lt;= n &amp;lt;= len(p)) and any error encountered. Even if Read returns n &amp;lt; len(p), it may use all of p as scratch space during the call. If some data is available but not len(p) bytes, Read conventionally returns what is available instead of waiting for more.</source>
          <target state="translated">Чтение читает до len (p) байтов в p. Он возвращает количество прочитанных байтов (0 &amp;lt;= n &amp;lt;= len (p)) и любую обнаруженную ошибку. Даже если Read возвращает n &amp;lt;len (p), он может использовать все p как временное пространство во время вызова. Если доступны некоторые данные, но нет байтов len (p), Read обычно возвращает то, что доступно, вместо того, чтобы ждать дополнительных.</target>
        </trans-unit>
        <trans-unit id="232135a13eb14d8c77efc7e8763b8a54f14d853d" translate="yes" xml:space="preserve">
          <source>Read returns the next request on the wire. An ErrPersistEOF is returned if it is gracefully determined that there are no more requests (e.g. after the first request on an HTTP/1.0 connection, or after a Connection:close on a HTTP/1.1 connection).</source>
          <target state="translated">Считывание возвращает следующий запрос по проводу.ErrPersistEOF возвращается,если было определено,что больше нет запросов (например,после первого запроса при подключении по HTTP/1.0 или после Connection:close при подключении по HTTP/1.1).</target>
        </trans-unit>
        <trans-unit id="8577ab4df6483a129452d0551a62e50aac1ada00" translate="yes" xml:space="preserve">
          <source>ReadAll</source>
          <target state="translated">ReadAll</target>
        </trans-unit>
        <trans-unit id="c220dc4ba473358c1d6061cf0c9c7708ee93e92a" translate="yes" xml:space="preserve">
          <source>ReadAll reads all the remaining records from r. Each record is a slice of fields. A successful call returns err == nil, not err == io.EOF. Because ReadAll is defined to read until EOF, it does not treat end of file as an error to be reported.</source>
          <target state="translated">ReadAll читает все оставшиеся записи из r.Каждая запись-это кусок поля.Успешный вызов возвращает err ==nil,not err ==io.EOF.Поскольку ReadAll определено как читать до EOF,он не рассматривает конец файла как ошибку,о которой следует сообщить.</target>
        </trans-unit>
        <trans-unit id="a2e746d4cfb2608d3ae0cefc64ac787887ba2c28" translate="yes" xml:space="preserve">
          <source>ReadAll reads from r until an error or EOF and returns the data it read. A successful call returns err == nil, not err == EOF. Because ReadAll is defined to read from src until EOF, it does not treat an EOF from Read as an error to be reported.</source>
          <target state="translated">ReadAll считывает с r до ошибки или EOF и возвращает прочитанные данные.Успешный вызов возвращает err ==nil,not err ==EOF.Поскольку ReadAll определено как чтение из src до EOF,он не рассматривает EOF из Read как ошибку,о которой нужно сообщить.</target>
        </trans-unit>
        <trans-unit id="f4cbf689398d7442e9b49d9483e3d4cc75c10fd1" translate="yes" xml:space="preserve">
          <source>ReadAt implements the io.ReaderAt interface.</source>
          <target state="translated">ReadAt реализует интерфейс io.ReaderAt.</target>
        </trans-unit>
        <trans-unit id="64ae50d9b868e0114af3da28a0f440e42207678f" translate="yes" xml:space="preserve">
          <source>ReadAt reads len(b) bytes from the File starting at byte offset off. It returns the number of bytes read and the error, if any. ReadAt always returns a non-nil error when n &amp;lt; len(b). At end of file, that error is io.EOF.</source>
          <target state="translated">ReadAt читает len (b) байтов из файла, начиная со смещения байта off. Он возвращает количество прочитанных байтов и ошибку, если таковая имеется. ReadAt всегда возвращает ошибку, отличную от нуля, если n &amp;lt;len (b). В конце файла эта ошибка - io.EOF.</target>
        </trans-unit>
        <trans-unit id="c0bb2352984c400f258aa80aba0c3141b53cce96" translate="yes" xml:space="preserve">
          <source>ReadAt reads len(p) bytes into p starting at offset off in the underlying input source. It returns the number of bytes read (0 &amp;lt;= n &amp;lt;= len(p)) and any error encountered.</source>
          <target state="translated">ReadAt считывает len (p) байтов в p, начиная со смещения off в базовом источнике ввода. Он возвращает количество прочитанных байтов (0 &amp;lt;= n &amp;lt;= len (p)) и любую обнаруженную ошибку.</target>
        </trans-unit>
        <trans-unit id="e76e529805447d2ff346a5397f1147a3e02108f4" translate="yes" xml:space="preserve">
          <source>ReadAtLeast</source>
          <target state="translated">ReadAtLeast</target>
        </trans-unit>
        <trans-unit id="dde64f711702d58fa68344cc075ded7169e93092" translate="yes" xml:space="preserve">
          <source>ReadAtLeast reads from r into buf until it has read at least min bytes. It returns the number of bytes copied and an error if fewer bytes were read. The error is EOF only if no bytes were read. If an EOF happens after reading fewer than min bytes, ReadAtLeast returns ErrUnexpectedEOF. If min is greater than the length of buf, ReadAtLeast returns ErrShortBuffer. On return, n &amp;gt;= min if and only if err == nil. If r returns an error having read at least min bytes, the error is dropped.</source>
          <target state="translated">ReadAtLeast читает из r в buf, пока не прочитает не менее min байтов. Он возвращает количество скопированных байтов и ошибку, если было прочитано меньшее количество байтов. Ошибка - EOF только в том случае, если байты не были прочитаны. Если EOF происходит после чтения менее min байтов, ReadAtLeast возвращает ErrUnexpectedEOF. Если min больше, чем длина buf, ReadAtLeast возвращает ErrShortBuffer. При возврате n&amp;gt; = min тогда и только тогда, когда err == nil. Если r возвращает ошибку, прочитав не менее min байтов, ошибка сбрасывается.</target>
        </trans-unit>
        <trans-unit id="5eb984a81bf137b794c952d3bb6893f123d7859e" translate="yes" xml:space="preserve">
          <source>ReadBuildInfo returns the build information embedded in the running binary. The information is available only in binaries built with module support.</source>
          <target state="translated">ReadBuildInfo возвращает информацию о сборке,встроенную в работающий бинарный файл.Информация доступна только в бинарных файлах,собранных с поддержкой модулей.</target>
        </trans-unit>
        <trans-unit id="b60f1ee86705e93ab48e53804a8b6eaae8d1a5a6" translate="yes" xml:space="preserve">
          <source>ReadByte implements the io.ByteReader interface.</source>
          <target state="translated">ReadByte реализует интерфейс io.ByteReader.</target>
        </trans-unit>
        <trans-unit id="88fc89f806641e6821f93c159732d09d121182a0" translate="yes" xml:space="preserve">
          <source>ReadByte reads and returns a single byte. If no byte is available, returns an error.</source>
          <target state="translated">ReadByte читает и возвращает один байт.Если байт недоступен,возвращает ошибку.</target>
        </trans-unit>
        <trans-unit id="8ccc7f3f4551a8da89db7d7f4659a2bcc7f6f5b1" translate="yes" xml:space="preserve">
          <source>ReadByte reads and returns the next byte from the buffer. If no byte is available, it returns error io.EOF.</source>
          <target state="translated">ReadByte читает и возвращает следующий байт из буфера.Если байт недоступен,возвращается ошибка io.EOF.</target>
        </trans-unit>
        <trans-unit id="159679671477045d937418ced34fc2e8ac5df5f4" translate="yes" xml:space="preserve">
          <source>ReadByte reads and returns the next byte from the input or any error encountered. If ReadByte returns an error, no input byte was consumed, and the returned byte value is undefined.</source>
          <target state="translated">ReadByte читает и возвращает следующий байт из входа или любую ошибку.Если ReadByte возвращает ошибку,то входной байт не был использован,а возвращаемое значение байта не определено.</target>
        </trans-unit>
        <trans-unit id="3d347b2a2e7f91e4c72a8f8310b1aba11bc78e6c" translate="yes" xml:space="preserve">
          <source>ReadBytes reads until the first occurrence of delim in the input, returning a slice containing the data up to and including the delimiter. If ReadBytes encounters an error before finding a delimiter, it returns the data read before the error and the error itself (often io.EOF). ReadBytes returns err != nil if and only if the returned data does not end in delim.</source>
          <target state="translated">ReadBytes читает до первого появления разделителя во входных данных,возвращая фрагмент,содержащий данные до разделителя включительно.Если ReadBytes сталкивается с ошибкой до нахождения разделителя,он возвращает данные,прочитанные до ошибки,и саму ошибку (часто io.EOF).ReadBytes возвращает err !=ноль,если и только если возвращаемые данные не заканчиваются на разделителе.</target>
        </trans-unit>
        <trans-unit id="aba4d297566c98e6e0d191f056016ef94b731d93" translate="yes" xml:space="preserve">
          <source>ReadBytes reads until the first occurrence of delim in the input, returning a slice containing the data up to and including the delimiter. If ReadBytes encounters an error before finding a delimiter, it returns the data read before the error and the error itself (often io.EOF). ReadBytes returns err != nil if and only if the returned data does not end in delim. For simple uses, a Scanner may be more convenient.</source>
          <target state="translated">ReadBytes читает до первого появления разделителя во входных данных,возвращая фрагмент,содержащий данные до разделителя включительно.Если ReadBytes сталкивается с ошибкой до нахождения разделителя,он возвращает данные,прочитанные до ошибки,и саму ошибку (часто io.EOF).ReadBytes возвращает err !=ноль,если и только если возвращаемые данные не заканчиваются на разделителе.Для простоты использования,сканер может быть более удобным.</target>
        </trans-unit>
        <trans-unit id="2f66b132ca8c3970b58c8bfa0ea1a17d65ac03b4" translate="yes" xml:space="preserve">
          <source>ReadCloser is the interface that groups the basic Read and Close methods.</source>
          <target state="translated">ReadCloser-это интерфейс,который группирует основные методы Read и Close.</target>
        </trans-unit>
        <trans-unit id="db676df84bb4b6b56dfdcd9f6b6ecaede84207b6" translate="yes" xml:space="preserve">
          <source>ReadCodeLine reads a response code line of the form</source>
          <target state="translated">ReadCodeLine считывает строку кода ответа формы</target>
        </trans-unit>
        <trans-unit id="8ff6713d1fd28b36b70ff99ddd8c0b4506ace228" translate="yes" xml:space="preserve">
          <source>ReadContinuedLine reads a possibly continued line from r, eliding the final trailing ASCII white space. Lines after the first are considered continuations if they begin with a space or tab character. In the returned data, continuation lines are separated from the previous line only by a single space: the newline and leading white space are removed.</source>
          <target state="translated">ReadContinuedLine читает возможно продолженную линию от r,ускользая от конечного трейлингового ASCII белого пространства.Строки после первой считаются продолжениями,если они начинаются с пробела или символа табуляции.В возвращаемых данных линии продолжения отделяются от предыдущей только одним пробелом:новая линия и ведущий белый пробел удаляются.</target>
        </trans-unit>
        <trans-unit id="1e5b6ed6dd4e790ba932357704f154ece64c0736" translate="yes" xml:space="preserve">
          <source>ReadContinuedLineBytes is like ReadContinuedLine but returns a []byte instead of a string.</source>
          <target state="translated">ReadContinuedLineBytes похоже на ReadContinuedLine,но возвращает []байт вместо строки.</target>
        </trans-unit>
        <trans-unit id="5967a3c48bcceae8eab866aea588318eebdf12d2" translate="yes" xml:space="preserve">
          <source>ReadDir</source>
          <target state="translated">ReadDir</target>
        </trans-unit>
        <trans-unit id="72f7f069b44009fbb8ef194258dfcf70cde80055" translate="yes" xml:space="preserve">
          <source>ReadDir reads the directory named by dirname and returns a list of directory entries sorted by filename.</source>
          <target state="translated">ReadDir считывает каталог с именем по dirname и возвращает список записей каталога,отсортированных по имени файла.</target>
        </trans-unit>
        <trans-unit id="e66536e5f97de59d6908b95e869d13fc9d1ef4b6" translate="yes" xml:space="preserve">
          <source>ReadDotBytes reads a dot-encoding and returns the decoded data.</source>
          <target state="translated">ReadDotBytes читает точечное кодирование и возвращает декодированные данные.</target>
        </trans-unit>
        <trans-unit id="9fa4950dafc4de63dd721dcb4ac0ca1c8418dcbe" translate="yes" xml:space="preserve">
          <source>ReadDotLines reads a dot-encoding and returns a slice containing the decoded lines, with the final \r\n or \n elided from each.</source>
          <target state="translated">ReadDotLines читает точечное кодирование и возвращает фрагмент,содержащий декодированные строки,с конечного \r\n или \n.</target>
        </trans-unit>
        <trans-unit id="d7fd01a502310e8357802950d90a33ad1c88b094" translate="yes" xml:space="preserve">
          <source>ReadFile</source>
          <target state="translated">ReadFile</target>
        </trans-unit>
        <trans-unit id="e3227226a36d1c67d762cccdcef04ee8eaa0dc15" translate="yes" xml:space="preserve">
          <source>ReadFile reads the file named by filename and returns the contents. A successful call returns err == nil, not err == EOF. Because ReadFile reads the whole file, it does not treat an EOF from Read as an error to be reported.</source>
          <target state="translated">ReadFile читает файл с именем и возвращает его содержимое.Успешный вызов возвращает err ==nil,not err ==EOF.Поскольку ReadFile считывает весь файл,он не рассматривает EOF из Read как ошибку,о которой следует сообщить.</target>
        </trans-unit>
        <trans-unit id="af2c9d5288821671fae0d9ea11877f8aa4dfd64b" translate="yes" xml:space="preserve">
          <source>ReadForm parses an entire multipart message whose parts have a Content-Disposition of &quot;form-data&quot;. It stores up to maxMemory bytes + 10MB (reserved for non-file parts) in memory. File parts which can't be stored in memory will be stored on disk in temporary files. It returns ErrMessageTooLarge if all non-file parts can't be stored in memory.</source>
          <target state="translated">ReadForm анализирует целое сообщение из нескольких частей,части которого имеют Контент-диспозицию &quot;форма-данные&quot;.Он хранит в памяти до макс.байт памяти+10 МБ (зарезервировано для не-файловых частей).Части файла,которые не могут быть сохранены в памяти,будут храниться на диске во временных файлах.Возвращает ErrMessageTooLarge,если все нефайловые части не могут быть сохранены в памяти.</target>
        </trans-unit>
        <trans-unit id="0e93b4927342ab7184e8df9a62d919ab56aa652d" translate="yes" xml:space="preserve">
          <source>ReadFrom implements io.ReaderFrom. If the underlying writer supports the ReadFrom method, and b has no buffered data yet, this calls the underlying ReadFrom without buffering.</source>
          <target state="translated">ReadFrom реализует io.ReaderFrom.Если основной записывающее устройство поддерживает метод ReadFrom,и b еще не имеет буферизированных данных,это вызывает основной ReadFrom без буферизации.</target>
        </trans-unit>
        <trans-unit id="deeb7efc315fb646ef56c6fc1f93867b106373b0" translate="yes" xml:space="preserve">
          <source>ReadFrom implements the PacketConn ReadFrom method.</source>
          <target state="translated">ReadFrom реализует метод PacketConn ReadFrom.</target>
        </trans-unit>
        <trans-unit id="f608142e8cc80b99bfcbe865eecfbb0322dd6e96" translate="yes" xml:space="preserve">
          <source>ReadFrom implements the io.ReaderFrom ReadFrom method.</source>
          <target state="translated">ReadFrom реализует метод io.ReaderFrom ReadFrom.</target>
        </trans-unit>
        <trans-unit id="00b3806bd8fc8bcfbcad0f6f7f7286cb5b8785f4" translate="yes" xml:space="preserve">
          <source>ReadFrom reads data from r until EOF and appends it to the buffer, growing the buffer as needed. The return value n is the number of bytes read. Any error except io.EOF encountered during the read is also returned. If the buffer becomes too large, ReadFrom will panic with ErrTooLarge.</source>
          <target state="translated">ReadFrom считывает данные с r до EOF и добавляет их в буфер,увеличивая буфер по мере необходимости.Возвращаемое значение n-это количество прочитанных байт.Возвращается также любая ошибка,кроме ошибки io.EOF,возникшей во время чтения.Если буфер станет слишком большим,ReadFrom начнет паниковать с ErrTooLarge.</target>
        </trans-unit>
        <trans-unit id="454fdea2d34a8c45cb668b5c543dbc3f7058787c" translate="yes" xml:space="preserve">
          <source>ReadFrom reads data from r until EOF or error. The return value n is the number of bytes read. Any error except io.EOF encountered during the read is also returned.</source>
          <target state="translated">ReadFrom считывает данные с r до EOF или ошибку.Возвращаемое значение n-это количество прочитанных байтов.Возвращается также любая ошибка,кроме ошибки io.EOF,возникшей во время считывания.</target>
        </trans-unit>
        <trans-unit id="ea32f98cbdf74be7e58789bf5c2555022985c09b" translate="yes" xml:space="preserve">
          <source>ReadFromIP acts like ReadFrom but returns an IPAddr.</source>
          <target state="translated">ReadFromIP действует как ReadFrom,но возвращает IPAddr.</target>
        </trans-unit>
        <trans-unit id="95ff932341b82ae81f7960462c1442dddf49af3c" translate="yes" xml:space="preserve">
          <source>ReadFromUDP acts like ReadFrom but returns a UDPAddr.</source>
          <target state="translated">ReadFromUDP действует как ReadFrom,но возвращает UDPAddr.</target>
        </trans-unit>
        <trans-unit id="715d754a562178b348b7a0a9528cfbf66635230e" translate="yes" xml:space="preserve">
          <source>ReadFromUnix acts like ReadFrom but returns a UnixAddr.</source>
          <target state="translated">ReadFromUnix действует как ReadFrom,но возвращает UnixAddr.</target>
        </trans-unit>
        <trans-unit id="6b877746bfc4fdb60829d292eb383e9e72074e71" translate="yes" xml:space="preserve">
          <source>ReadFull</source>
          <target state="translated">ReadFull</target>
        </trans-unit>
        <trans-unit id="f41363ee55bdca4d655d8c43955b9b66f37cac52" translate="yes" xml:space="preserve">
          <source>ReadFull reads exactly len(buf) bytes from r into buf. It returns the number of bytes copied and an error if fewer bytes were read. The error is EOF only if no bytes were read. If an EOF happens after reading some but not all the bytes, ReadFull returns ErrUnexpectedEOF. On return, n == len(buf) if and only if err == nil. If r returns an error having read at least len(buf) bytes, the error is dropped.</source>
          <target state="translated">ReadFull точно читает байты len(buf)из r в buf.Возвращает количество скопированных байт и ошибку,если было прочитано меньше байт.Ошибка EOF только в том случае,если не было прочитано ни одного байта.Если EOF происходит после считывания нескольких,но не всех байтов,ReadFull возвращает ErrUnexpectedEOF.При возврате n ==len(buf)if and only if err ==nil.Если r возвращает ошибку,прочитав хотя бы байт len(buf),то ошибка сбрасывается.</target>
        </trans-unit>
        <trans-unit id="4528be7d31ac119b15adb0d44e8e10acc6a61277" translate="yes" xml:space="preserve">
          <source>ReadGCStats reads statistics about garbage collection into stats. The number of entries in the pause history is system-dependent; stats.Pause slice will be reused if large enough, reallocated otherwise. ReadGCStats may use the full capacity of the stats.Pause slice. If stats.PauseQuantiles is non-empty, ReadGCStats fills it with quantiles summarizing the distribution of pause time. For example, if len(stats.PauseQuantiles) is 5, it will be filled with the minimum, 25%, 50%, 75%, and maximum pause times.</source>
          <target state="translated">ReadGCStats читает статистику по сбору мусора в статистику.Количество записей в истории пауз зависит от системы;срез stats.Pause будет использован повторно,если он достаточно большой,переместится в другое место.ReadGCStats может использовать всю мощность среза stats.Pause.Если stats.PauseQuantiles не пуст,ReadGCStats заполняет его квантилями,суммирующими распределение времени паузы.Например,если len(stats.PauseQuantiles)равен 5,он будет заполнен с минимальным,25%,50%,75% и максимальным временем паузы.</target>
        </trans-unit>
        <trans-unit id="a6882fab97e53a8d3c4b1deb078269fff567ed19" translate="yes" xml:space="preserve">
          <source>ReadLine is a low-level line-reading primitive. Most callers should use ReadBytes('\n') or ReadString('\n') instead or use a Scanner.</source>
          <target state="translated">ReadLine-это низкоуровневый примитив для чтения линий.Большинство вызывающих абонентов должны использовать ReadBytes('\n')или ReadString('\n')вместо него или использовать сканер.</target>
        </trans-unit>
        <trans-unit id="70e3e4d68a5bd26786fe6816067d028f52581c71" translate="yes" xml:space="preserve">
          <source>ReadLine reads a single line from r, eliding the final \n or \r\n from the returned string.</source>
          <target state="translated">ReadLine читает одну строку из r,скрывая итоговую \n или \r\n из возвращаемой строки.</target>
        </trans-unit>
        <trans-unit id="d5bdeff155b2aec65cb49ea2eabeba1181d7c31c" translate="yes" xml:space="preserve">
          <source>ReadLine tries to return a single line, not including the end-of-line bytes. If the line was too long for the buffer then isPrefix is set and the beginning of the line is returned. The rest of the line will be returned from future calls. isPrefix will be false when returning the last fragment of the line. The returned buffer is only valid until the next call to ReadLine. ReadLine either returns a non-nil line or it returns an error, never both.</source>
          <target state="translated">ReadLine пытается вернуть одну строку,не включая байты конца строки.Если строка была слишком длинной для буфера,то устанавливается значение isPrefix и возвращается начало строки.Остальная часть линии будет возвращена из последующих вызовов.isPrefix будет false при возврате последнего фрагмента линии.Возвращаемый буфер действителен только до следующего вызова ReadLine.ReadLine либо возвращает ненулевую линию,либо возвращает ошибку,никогда и то и другое.</target>
        </trans-unit>
        <trans-unit id="30af98b166430a4d07ac11a60a37dce8c9897d44" translate="yes" xml:space="preserve">
          <source>ReadLineBytes is like ReadLine but returns a []byte instead of a string.</source>
          <target state="translated">ReadLineBytes похож на ReadLine,но возвращает []байт вместо строки.</target>
        </trans-unit>
        <trans-unit id="34955aedc1edab445c06914ea85435c83aa1659d" translate="yes" xml:space="preserve">
          <source>ReadMIMEHeader reads a MIME-style header from r. The header is a sequence of possibly continued Key: Value lines ending in a blank line. The returned map m maps CanonicalMIMEHeaderKey(key) to a sequence of values in the same order encountered in the input.</source>
          <target state="translated">ReadMIMEHeader читает заголовок в стиле MIME из r.Заголовок представляет собой последовательность возможных продолжений ключа:Строки значений,заканчивающиеся пустой строкой.Возвращаемая карта m отображает CanonicalMIMEHeaderKey(key)на последовательность значений в том же порядке,который встречается на входе.</target>
        </trans-unit>
        <trans-unit id="e81ba86f59e436daff158e41fbec08f65b2c4f42" translate="yes" xml:space="preserve">
          <source>ReadMemStats populates m with memory allocator statistics.</source>
          <target state="translated">ReadMemStats заполняет m статистикой выделения памяти.</target>
        </trans-unit>
        <trans-unit id="acb49a6f36fe4a7034527475afbfe7647980d6b9" translate="yes" xml:space="preserve">
          <source>ReadMessage</source>
          <target state="translated">ReadMessage</target>
        </trans-unit>
        <trans-unit id="1551b34da55e8d458cfae44e4a334da9f414dea8" translate="yes" xml:space="preserve">
          <source>ReadMessage reads a message from r. The headers are parsed, and the body of the message will be available for reading from msg.Body.</source>
          <target state="translated">ReadMessage читает сообщение из r.Заголовки разобраны,а тело сообщения будет доступно для чтения из msg.Body.</target>
        </trans-unit>
        <trans-unit id="6f05b0c16954598270f35347bda5383a6c522b11" translate="yes" xml:space="preserve">
          <source>ReadMsgIP reads a message from c, copying the payload into b and the associated out-of-band data into oob. It returns the number of bytes copied into b, the number of bytes copied into oob, the flags that were set on the message and the source address of the message.</source>
          <target state="translated">ReadMsgIP читает сообщение из c,копируя полезную нагрузку в b и связанные с ним внеполосные данные в oob.Возвращает количество байт,скопированных в b,количество байт,скопированных в oob,флаги,установленные в сообщении и исходный адрес сообщения.</target>
        </trans-unit>
        <trans-unit id="47bd88248b7a6aeb9fe7003935965fcbc4c14b6e" translate="yes" xml:space="preserve">
          <source>ReadMsgUDP reads a message from c, copying the payload into b and the associated out-of-band data into oob. It returns the number of bytes copied into b, the number of bytes copied into oob, the flags that were set on the message and the source address of the message.</source>
          <target state="translated">ReadMsgUDP читает сообщение из c,копируя полезную нагрузку в b и связанные с ним внеполосные данные в oob.Возвращает количество байт,скопированных в b,количество байт,скопированных в oob,флаги,установленные в сообщении,и исходный адрес сообщения.</target>
        </trans-unit>
        <trans-unit id="f80f0770ba07805dfad9fed9021802994b16c79f" translate="yes" xml:space="preserve">
          <source>ReadMsgUnix reads a message from c, copying the payload into b and the associated out-of-band data into oob. It returns the number of bytes copied into b, the number of bytes copied into oob, the flags that were set on the message and the source address of the message.</source>
          <target state="translated">ReadMsgUnix читает сообщение из c,копируя полезную нагрузку в b и соответствующие внеполосные данные в oob.Возвращает количество байт,скопированных в b,количество байт,скопированных в oob,флаги,установленные в сообщении и исходный адрес сообщения.</target>
        </trans-unit>
        <trans-unit id="25bb46ad3055b508b0608be3bcb05d4dc7a218ac" translate="yes" xml:space="preserve">
          <source>ReadRequest is a low-level function and should only be used for specialized applications; most code should use the Server to read requests and handle them via the Handler interface. ReadRequest only supports HTTP/1.x requests. For HTTP/2, use golang.org/x/net/http2.</source>
          <target state="translated">ReadRequest является низкоуровневой функцией и должен использоваться только для специализированных приложений;большинство кода должно использовать сервер для чтения запросов и обработки их через интерфейс обработчика.ReadRequest поддерживает только запросы HTTP/1.x.Для HTTP/2 используйте golang.org/x/net/http2.</target>
        </trans-unit>
        <trans-unit id="b1b66f29f0f459c92aabcbebb68a77d5a6970744" translate="yes" xml:space="preserve">
          <source>ReadRequest reads and parses an incoming request from b.</source>
          <target state="translated">ReadRequest читает и анализирует входящий запрос от b.</target>
        </trans-unit>
        <trans-unit id="25d27159145d0774b1fadc397fe48b995c46c5de" translate="yes" xml:space="preserve">
          <source>ReadResponse reads a multi-line response of the form:</source>
          <target state="translated">ReadResponse считывает многострочный ответ формы:</target>
        </trans-unit>
        <trans-unit id="ee99ce8c11934415337cdc7bec2e604ef18e71ae" translate="yes" xml:space="preserve">
          <source>ReadResponse reads and returns an HTTP response from r. The req parameter optionally specifies the Request that corresponds to this Response. If nil, a GET request is assumed. Clients must call resp.Body.Close when finished reading resp.Body. After that call, clients can inspect resp.Trailer to find key/value pairs included in the response trailer.</source>
          <target state="translated">ReadResponse считывает и возвращает HTTP-ответ от r.Параметр req опционально определяет запрос,соответствующий этому ответу.Если нет,то предполагается GET-запрос.Клиенты должны вызывать resp.Body.Close по окончании чтения resp.Body.После этого вызова клиенты могут проверить resp.Trailer,чтобы найти пары ключ/значение,включенные в трейлер ответа.</target>
        </trans-unit>
        <trans-unit id="476255423e82d011c96cc157a1f2c1336b3b2a0a" translate="yes" xml:space="preserve">
          <source>ReadRune implements the io.RuneReader interface.</source>
          <target state="translated">ReadRune реализует интерфейс io.RuneReader.</target>
        </trans-unit>
        <trans-unit id="2149703d832b9af2c76dd9abfe510fdf6ec21b40" translate="yes" xml:space="preserve">
          <source>ReadRune reads a single UTF-8 encoded Unicode character and returns the rune and its size in bytes. If no character is available, err will be set.</source>
          <target state="translated">ReadRune считывает один символ в кодировке UTF-8 Unicode и возвращает руну и ее размер в байтах.Если символ недоступен,будет установлена ошибка.</target>
        </trans-unit>
        <trans-unit id="6414ea883495287275cdc53b35ffd14e0008ac3b" translate="yes" xml:space="preserve">
          <source>ReadRune reads a single UTF-8 encoded Unicode character and returns the rune and its size in bytes. If the encoded rune is invalid, it consumes one byte and returns unicode.ReplacementChar (U+FFFD) with a size of 1.</source>
          <target state="translated">ReadRune считывает один символ в кодировке UTF-8 Unicode и возвращает руну и ее размер в байтах.Если кодированная руна недействительна,то она потребляет один байт и возвращает юникод.ReplacementChar (U+FFFD)размером 1.</target>
        </trans-unit>
        <trans-unit id="6486828e56b295be35e03a3674dd21e96b49a79c" translate="yes" xml:space="preserve">
          <source>ReadRune reads and returns the next UTF-8-encoded Unicode code point from the buffer. If no bytes are available, the error returned is io.EOF. If the bytes are an erroneous UTF-8 encoding, it consumes one byte and returns U+FFFD, 1.</source>
          <target state="translated">ReadRune считывает и возвращает из буфера следующую точку кода Юникода в кодировке UTF-8.Если байт недоступен,возвращается ошибка io.EOF.Если байты являются ошибочной кодировкой UTF-8,то она потребляет один байт и возвращает U+FFFD,1.</target>
        </trans-unit>
        <trans-unit id="78176debea1a291ba3e7ca916182c7ec7d43ab66" translate="yes" xml:space="preserve">
          <source>ReadSeeker is the interface that groups the basic Read and Seek methods.</source>
          <target state="translated">ReadSeeker-это интерфейс,который группирует основные методы Read и Seek.</target>
        </trans-unit>
        <trans-unit id="6f83dddca1aa94fb6e401f10df5bd11c4e328c97" translate="yes" xml:space="preserve">
          <source>ReadSlice reads until the first occurrence of delim in the input, returning a slice pointing at the bytes in the buffer. The bytes stop being valid at the next read. If ReadSlice encounters an error before finding a delimiter, it returns all the data in the buffer and the error itself (often io.EOF). ReadSlice fails with error ErrBufferFull if the buffer fills without a delim. Because the data returned from ReadSlice will be overwritten by the next I/O operation, most clients should use ReadBytes or ReadString instead. ReadSlice returns err != nil if and only if line does not end in delim.</source>
          <target state="translated">ReadSlice читает до первого появления разделителя на входе,возвращая фрагмент,указывающий на байты в буфере.Байты перестают быть действительными при следующем чтении.Если ReadSlice встречает ошибку до нахождения разделителя,он возвращает все данные в буфере и саму ошибку (часто io.EOF).ReadSlice терпит неудачу с ошибкой ErrBufferFull,если буфер заполняется без разделителя.Поскольку данные,возвращаемые из ReadSlice,будут перезаписаны следующей операцией ввода/вывода,большинство клиентов должны использовать ReadBytes или ReadString вместо этого.ReadSlice возвращает err !=nil если и только если строка не заканчивается на разделителе.</target>
        </trans-unit>
        <trans-unit id="396715e6dd5c32bdbbf83af9027e47c30dc1faa8" translate="yes" xml:space="preserve">
          <source>ReadString reads until the first occurrence of delim in the input, returning a string containing the data up to and including the delimiter. If ReadString encounters an error before finding a delimiter, it returns the data read before the error and the error itself (often io.EOF). ReadString returns err != nil if and only if the returned data does not end in delim.</source>
          <target state="translated">ReadString читает до первого появления разделителя во входных данных,возвращая строку,содержащую данные до разделителя включительно.Если ReadString встречает ошибку до нахождения разделителя,он возвращает прочитанные данные до ошибки и саму ошибку (часто io.EOF).ReadString возвращает err !=nil если и только если возвращаемые данные не заканчиваются на разделителе.</target>
        </trans-unit>
        <trans-unit id="aaa3e0c7b34f04c5ff175180dbf3748d0757b57f" translate="yes" xml:space="preserve">
          <source>ReadString reads until the first occurrence of delim in the input, returning a string containing the data up to and including the delimiter. If ReadString encounters an error before finding a delimiter, it returns the data read before the error and the error itself (often io.EOF). ReadString returns err != nil if and only if the returned data does not end in delim. For simple uses, a Scanner may be more convenient.</source>
          <target state="translated">ReadString читает до первого появления разделителя во входных данных,возвращая строку,содержащую данные до разделителя включительно.Если ReadString встречает ошибку до нахождения разделителя,он возвращает прочитанные данные до ошибки и саму ошибку (часто io.EOF).ReadString возвращает err !=nil если и только если возвращаемые данные не заканчиваются на разделителе.Для простоты использования,сканер может быть более удобным.</target>
        </trans-unit>
        <trans-unit id="24714d7c8185be718fff60550f6b7e029b2b159c" translate="yes" xml:space="preserve">
          <source>ReadTrace returns the next chunk of binary tracing data, blocking until data is available. If tracing is turned off and all the data accumulated while it was on has been returned, ReadTrace returns nil. The caller must copy the returned data before calling ReadTrace again. ReadTrace must be called from one goroutine at a time.</source>
          <target state="translated">ReadTrace возвращает следующий фрагмент двоичных данных трассировки,блокируя их до тех пор,пока данные не станут доступны.Если трассировка выключена и все данные,накопленные во время ее включения,возвращены,ReadTrace возвращает ноль.Перед повторным вызовом ReadTrace вызывающий абонент должен скопировать возвращенные данные.ReadTrace необходимо вызывать с одного горутина за раз.</target>
        </trans-unit>
        <trans-unit id="989bf43b9a2dfe020990e99dd409325328b3ade3" translate="yes" xml:space="preserve">
          <source>ReadUvarint reads an encoded unsigned integer from r and returns it as a uint64.</source>
          <target state="translated">ReadUvarint читает из r кодированное беззнаковое целое число и возвращает его как uint64.</target>
        </trans-unit>
        <trans-unit id="675541f596de4c802da653f83b46f8b7718858d0" translate="yes" xml:space="preserve">
          <source>ReadVarint reads an encoded signed integer from r and returns it as an int64.</source>
          <target state="translated">ReadVarint читает из r закодированное знаковое целое число и возвращает его как int64.</target>
        </trans-unit>
        <trans-unit id="069fcaa32c060bf9bd8bfac5e82274aaead1bc50" translate="yes" xml:space="preserve">
          <source>ReadWriteCloser is the interface that groups the basic Read, Write and Close methods.</source>
          <target state="translated">ReadWriteCloser-это интерфейс,который группирует основные методы Read,Write и Close.</target>
        </trans-unit>
        <trans-unit id="341b30c9c3b78089bcaa44b8a26a94b9bc0c8ea6" translate="yes" xml:space="preserve">
          <source>ReadWriteSeeker is the interface that groups the basic Read, Write and Seek methods.</source>
          <target state="translated">ReadWriteSeeker-это интерфейс,объединяющий основные методы Read,Write и Seek.</target>
        </trans-unit>
        <trans-unit id="eb7ce11fb3f6f0101cd6b5288463e8de90a96b51" translate="yes" xml:space="preserve">
          <source>ReadWriter is the interface that groups the basic Read and Write methods.</source>
          <target state="translated">ReadWriter-это интерфейс,объединяющий основные методы чтения и записи.</target>
        </trans-unit>
        <trans-unit id="dfaac4087d8cb10eb5b8f29ddefebdcafd42a5af" translate="yes" xml:space="preserve">
          <source>ReadWriter stores pointers to a Reader and a Writer. It implements io.ReadWriter.</source>
          <target state="translated">ReadWriter хранит указатели на Читатель и Программисту.Он реализует io.ReadWriter.</target>
        </trans-unit>
        <trans-unit id="79f16a4d9874784deac866dfbd0ce6545be6e239" translate="yes" xml:space="preserve">
          <source>Readdir reads the contents of the directory associated with file and returns a slice of up to n FileInfo values, as would be returned by Lstat, in directory order. Subsequent calls on the same file will yield further FileInfos.</source>
          <target state="translated">Readdir читает содержимое директории,связанной с файлом,и возвращает фрагмент до n значений FileInfo,которые будут возвращены Lstat,в порядке каталогов.Последующие обращения к этому же файлу приведут к дальнейшему получению FileInfos.</target>
        </trans-unit>
        <trans-unit id="501d22e73b2af73a4cd2cda27f0147a879d2d29f" translate="yes" xml:space="preserve">
          <source>Readdirnames reads the contents of the directory associated with file and returns a slice of up to n names of files in the directory, in directory order. Subsequent calls on the same file will yield further names.</source>
          <target state="translated">Readdirnames читает содержимое директории,связанной с файлом,и возвращает фрагмент до n имен файлов в директории,в порядке их следования.Последующие вызовы того же файла дают дополнительные имена.</target>
        </trans-unit>
        <trans-unit id="ac5bbe8292ed1b69e0f95e5bdaa035569a295fd7" translate="yes" xml:space="preserve">
          <source>Reader</source>
          <target state="translated">Reader</target>
        </trans-unit>
        <trans-unit id="a764e12131a971febc3401d23317f0234b4049b8" translate="yes" xml:space="preserve">
          <source>Reader (Options)</source>
          <target state="translated">Читатель (Опции)</target>
        </trans-unit>
        <trans-unit id="df3472ca3dd5a57262b56d74dcad15e820ebf2eb" translate="yes" xml:space="preserve">
          <source>Reader implements buffering for an io.Reader object.</source>
          <target state="translated">Читатель реализует буферизацию для объекта io.Reader.</target>
        </trans-unit>
        <trans-unit id="96784a034a712bc8c815b4587872dbfdfd0582a9" translate="yes" xml:space="preserve">
          <source>Reader is a global, shared instance of a cryptographically secure random number generator.</source>
          <target state="translated">Считыватель-это глобальный,общий экземпляр криптографически безопасного генератора случайных чисел.</target>
        </trans-unit>
        <trans-unit id="bf613e0e0a803852368392b2dfe7b4682657c458" translate="yes" xml:space="preserve">
          <source>Reader is a quoted-printable decoder.</source>
          <target state="translated">Читатель-это декодер,который может печататься в кавычках.</target>
        </trans-unit>
        <trans-unit id="b49691ad8407ed7de43e614957e75ec4095c4b28" translate="yes" xml:space="preserve">
          <source>Reader is an iterator over parts in a MIME multipart body. Reader's underlying parser consumes its input as needed. Seeking isn't supported.</source>
          <target state="translated">Считыватель-это итератор над деталями в корпусе из нескольких частей MIME.Считывающий анализатор,лежащий в основе,потребляет свой ввод по мере необходимости.Поиск не поддерживается.</target>
        </trans-unit>
        <trans-unit id="21dadd14b38a36c18741cf2c47ad38cb0675eedf" translate="yes" xml:space="preserve">
          <source>Reader is the interface that wraps the basic Read method.</source>
          <target state="translated">Reader-это интерфейс,обертывающий базовый метод чтения.</target>
        </trans-unit>
        <trans-unit id="9bdf18ff83881db62f68bf47e6ac4c6f41d55f66" translate="yes" xml:space="preserve">
          <source>Reader provides sequential access to the contents of a tar archive. Reader.Next advances to the next file in the archive (including the first), and then Reader can be treated as an io.Reader to access the file's data.</source>
          <target state="translated">Считыватель обеспечивает последовательный доступ к содержимому архива смолы.Reader.далее переходит к следующему файлу в архиве (включая первый),а затем Reader может быть обработан как io.Reader для доступа к данным файла.</target>
        </trans-unit>
        <trans-unit id="cac70aa62b26f1281fbe4d19090a262412eed7e3" translate="yes" xml:space="preserve">
          <source>Reader returns a new Reader for Data. The reader is positioned at byte offset 0 in the DWARF &amp;ldquo;info&amp;rdquo; section.</source>
          <target state="translated">Reader возвращает новый Reader for Data. Считыватель располагается по байтовому смещению 0 в разделе &amp;laquo;информация&amp;raquo; DWARF.</target>
        </trans-unit>
        <trans-unit id="8049ec93e81c7083091b44ed801d9d9d92c309d9" translate="yes" xml:space="preserve">
          <source>Reader, to read numeric response code lines, key: value headers, lines wrapped with leading spaces on continuation lines, and whole text blocks ending with a dot on a line by itself.</source>
          <target state="translated">Читатель,для чтения строк кода числового ответа,ключ:заголовки значений,строки,обернутые лидирующими пробелами на продолжении строк,и целые текстовые блоки,заканчивающиеся точкой на самой строке.</target>
        </trans-unit>
        <trans-unit id="d0009a603321ffa4322fc5ace74c08013f3502dc" translate="yes" xml:space="preserve">
          <source>Reader.Len</source>
          <target state="translated">Reader.Len</target>
        </trans-unit>
        <trans-unit id="52b9ae6b2c685e2a877bd9bbf8defead7e5d5ac7" translate="yes" xml:space="preserve">
          <source>Reader.Multistream</source>
          <target state="translated">Reader.Multistream</target>
        </trans-unit>
        <trans-unit id="23e9cef150e9609032f02dcc6e3ec9a05ca806c3" translate="yes" xml:space="preserve">
          <source>Reader.ReadAll</source>
          <target state="translated">Reader.ReadAll</target>
        </trans-unit>
        <trans-unit id="976c7b59d336efab6bbe07f071aa8d432cb7a047" translate="yes" xml:space="preserve">
          <source>ReaderAt is the interface that wraps the basic ReadAt method.</source>
          <target state="translated">ReaderAt-это интерфейс,обертывающий базовый метод ReadAt.</target>
        </trans-unit>
        <trans-unit id="29ae6f40e1ba95a55db0a9760f63eada1ab4e398" translate="yes" xml:space="preserve">
          <source>ReaderFrom is the interface that wraps the ReadFrom method.</source>
          <target state="translated">ReaderFrom-это интерфейс,обёртывающий метод ReadFrom.</target>
        </trans-unit>
        <trans-unit id="b5bdadfe357edf2d398dc3767642063de731a14c" translate="yes" xml:space="preserve">
          <source>Readlink returns the destination of the named symbolic link. If there is an error, it will be of type *PathError.</source>
          <target state="translated">Ссылка на чтение возвращает место назначения именованной символической ссылки.В случае ошибки она будет иметь тип *PathError.</target>
        </trans-unit>
        <trans-unit id="3680e45cb759e7b231139c55beb835dcb36f290f" translate="yes" xml:space="preserve">
          <source>Reads and Writes on the pipe are matched one to one except when multiple Reads are needed to consume a single Write. That is, each Write to the PipeWriter blocks until it has satisfied one or more Reads from the PipeReader that fully consume the written data. The data is copied directly from the Write to the corresponding Read (or Reads); there is no internal buffering.</source>
          <target state="translated">Чтения и записи на трубе сопоставляются один к одному,за исключением тех случаев,когда для потребления одной записи требуется несколько Чтений.Т.е.каждая запись в PipeWriter блокируется до тех пор,пока не будет выполнено одно или несколько Чтений с PipeReader,которые полностью поглощают записанные данные.Данные копируются непосредственно из Write на соответствующий Read (или Reads);внутренней буферизации нет.</target>
        </trans-unit>
        <trans-unit id="96964e0a893395e3b89017fa3370fe50203e0f58" translate="yes" xml:space="preserve">
          <source>Real returns the real part of x, which must be a numeric or unknown value. If x is Unknown, the result is Unknown.</source>
          <target state="translated">Реальный возвращает вещественную часть x,которая должна быть числовым или неизвестным значением.Если x равно Неизвестно,то результат будет Неизвестен.</target>
        </trans-unit>
        <trans-unit id="a4e7e73832091a1dd0eb45c5e3535f9fc0bb0385" translate="yes" xml:space="preserve">
          <source>ReceiverName returns the receiver type name of this symbol, or the empty string if there is none.</source>
          <target state="translated">ReceiverName возвращает имя типа приемника этого символа,или пустую строку,если ее нет.</target>
        </trans-unit>
        <trans-unit id="76042968d1a5f484d7ec99013213446b06dc9be8" translate="yes" xml:space="preserve">
          <source>Receivers should be careful to use Equal to compare MACs in order to avoid timing side-channels:</source>
          <target state="translated">Приемники должны быть осторожны в использовании КИПов Equal для сравнения,чтобы избежать синхронизации боковых каналов:</target>
        </trans-unit>
        <trans-unit id="baede57b4fd75bbaf39e019c76771e5b57cbf06e" translate="yes" xml:space="preserve">
          <source>RecordHeaderError is returned when a TLS record header is invalid.</source>
          <target state="translated">RecordHeaderError возвращается,когда заголовок записи TLS недействителен.</target>
        </trans-unit>
        <trans-unit id="2614b13193f400f1a9992deddc528f2f896c1029" translate="yes" xml:space="preserve">
          <source>Rect is shorthand for Rectangle{Pt(x0, y0), Pt(x1, y1)}. The returned rectangle has minimum and maximum coordinates swapped if necessary so that it is well-formed.</source>
          <target state="translated">Прямоугольник-это сокращение для Прямоугольника{Pt(x0,y0),Pt(x1,y1)}.Возвращаемый прямоугольник имеет минимальную и максимальную координаты,при необходимости поменянные таким образом,чтобы он был хорошо сформирован.</target>
        </trans-unit>
        <trans-unit id="1937bfd09178388c39ec43cf08d134d3d9d1898f" translate="yes" xml:space="preserve">
          <source>Rect returns the complex number x with polar coordinates r, &amp;theta;.</source>
          <target state="translated">Rect возвращает комплексное число x с полярными координатами r, &amp;theta;.</target>
        </trans-unit>
        <trans-unit id="94dab483158e13564ee6a455c353913588b6dbd1" translate="yes" xml:space="preserve">
          <source>Recv receives and returns a value from the channel v. It panics if v's Kind is not Chan. The receive blocks until a value is ready. The boolean value ok is true if the value x corresponds to a send on the channel, false if it is a zero value received because the channel is closed.</source>
          <target state="translated">Recv получает и возвращает значение из канала v.Он паникует,если v's Kind не является Chan.Прием блокируется до тех пор,пока значение не будет готово.Булевое значение ok истинно,если значение x соответствует отправлению по каналу,false,если это нулевое значение,полученное из-за того,что канал закрыт.</target>
        </trans-unit>
        <trans-unit id="03b8f406324956c22ef3f439d41bfd0bef6159ba" translate="yes" xml:space="preserve">
          <source>Recv returns the receiver of signature s (if a method), or nil if a function. It is ignored when comparing signatures for identity.</source>
          <target state="translated">Recv возвращает приемник сигнатуры s (если метод),или nil,если функция.Оно игнорируется при сравнении подписей для идентификации.</target>
        </trans-unit>
        <trans-unit id="5ae5c546dd23f367221f8f4d367950523d9cf3bb" translate="yes" xml:space="preserve">
          <source>Recv returns the type of x in x.f.</source>
          <target state="translated">Recv возвращает тип x в x.f.</target>
        </trans-unit>
        <trans-unit id="9250d7c2a971eb24cc4eedcfff481ae3439946cf" translate="yes" xml:space="preserve">
          <source>Redirect replies to the request with a redirect to url, which may be a path relative to the request path.</source>
          <target state="translated">Перенаправление ответов на запрос с перенаправлением на url,которым может быть путь относительно пути запроса.</target>
        </trans-unit>
        <trans-unit id="c909a75a26a89b05691be1108e0ab3c2e1bcdb1a" translate="yes" xml:space="preserve">
          <source>RedirectHandler returns a request handler that redirects each request it receives to the given url using the given status code.</source>
          <target state="translated">RedirectHandler возвращает обработчик запроса,который перенаправляет каждый полученный им запрос в заданный url,используя заданный код статуса.</target>
        </trans-unit>
        <trans-unit id="d6ec8155461c38d823e4b635ac46022ba360bb68" translate="yes" xml:space="preserve">
          <source>Referer is misspelled as in the request itself, a mistake from the earliest days of HTTP. This value can also be fetched from the Header map as Header[&quot;Referer&quot;]; the benefit of making it available as a method is that the compiler can diagnose programs that use the alternate (correct English) spelling req.Referrer() but cannot diagnose programs that use Header[&quot;Referrer&quot;].</source>
          <target state="translated">Referer написан с ошибкой,как в самом запросе,ошибка с самых первых дней HTTP.Это значение также может быть извлечено из карты заголовков как Header[&quot;Referer&quot;];преимущество предоставления его в качестве метода заключается в том,что компилятор может диагностировать программы,использующие альтернативный (правильный английский)орфографический req.Referrer(),но не может диагностировать программы,использующие Header[&quot;Referrer&quot;].</target>
        </trans-unit>
        <trans-unit id="07d5e3dfcd70520a1bbdb2fa9dbe2bae91c99a57" translate="yes" xml:space="preserve">
          <source>Referer returns the referring URL, if sent in the request.</source>
          <target state="translated">Референт возвращает URL-адрес ссылки,если он был отправлен в запросе.</target>
        </trans-unit>
        <trans-unit id="6ac251dfde6b7c655d39dbc21c40c658e7f0e5ba" translate="yes" xml:space="preserve">
          <source>Regardless of the verb, if an operand is an interface value, the internal concrete value is used, not the interface itself. Thus:</source>
          <target state="translated">Независимо от глагола,если операнд является значением интерфейса,используется внутреннее конкретное значение,а не сам интерфейс.Таким образом:</target>
        </trans-unit>
        <trans-unit id="ae8b91c59ed7a48ada5b7396ec353e27cc7c57cd" translate="yes" xml:space="preserve">
          <source>Regexp is the representation of a compiled regular expression. A Regexp is safe for concurrent use by multiple goroutines, except for configuration methods, such as Longest.</source>
          <target state="translated">Regexp-это представление скомпилированного регулярного выражения.Regexp безопасен для одновременного использования несколькими goroutines,за исключением методов конфигурации,таких как Longest.</target>
        </trans-unit>
        <trans-unit id="b84f40722bc57d5dce890a8a11e5c4fee08f3c9c" translate="yes" xml:space="preserve">
          <source>Regexp.Expand</source>
          <target state="translated">Regexp.Expand</target>
        </trans-unit>
        <trans-unit id="3dd017106e6cb747b2a0cd305e5bb9fdade3a8d1" translate="yes" xml:space="preserve">
          <source>Regexp.ExpandString</source>
          <target state="translated">Regexp.ExpandString</target>
        </trans-unit>
        <trans-unit id="ec3956758c005d81eaf9415a4c61a2390b4ec0f2" translate="yes" xml:space="preserve">
          <source>Regexp.Find</source>
          <target state="translated">Regexp.Find</target>
        </trans-unit>
        <trans-unit id="5a4d1168fbbea65dfa0185be8ce3c71cdc597f4b" translate="yes" xml:space="preserve">
          <source>Regexp.FindAll</source>
          <target state="translated">Regexp.FindAll</target>
        </trans-unit>
        <trans-unit id="9a7a55d789a0b84db34a38b56a2f4242a4cf127c" translate="yes" xml:space="preserve">
          <source>Regexp.FindAllString</source>
          <target state="translated">Regexp.FindAllString</target>
        </trans-unit>
        <trans-unit id="f7e56583e4dcc297ccf2aa23c322191411764c7e" translate="yes" xml:space="preserve">
          <source>Regexp.FindAllStringSubmatch</source>
          <target state="translated">Regexp.FindAllStringSubmatch</target>
        </trans-unit>
        <trans-unit id="e4337ecbd053cf4beaa55b4111d3d25165c547a3" translate="yes" xml:space="preserve">
          <source>Regexp.FindAllStringSubmatchIndex</source>
          <target state="translated">Regexp.FindAllStringSubmatchIndex</target>
        </trans-unit>
        <trans-unit id="55182b4c005261d0e66f0c8c4df35946648e43bd" translate="yes" xml:space="preserve">
          <source>Regexp.FindAllSubmatch</source>
          <target state="translated">Regexp.FindAllSubmatch</target>
        </trans-unit>
        <trans-unit id="752406799d805cf76b21ac4473155fcd9c435cf1" translate="yes" xml:space="preserve">
          <source>Regexp.FindAllSubmatchIndex</source>
          <target state="translated">Regexp.FindAllSubmatchIndex</target>
        </trans-unit>
        <trans-unit id="ca21e70b0b76817fc6bc10e7f6cc4170f855d5aa" translate="yes" xml:space="preserve">
          <source>Regexp.FindIndex</source>
          <target state="translated">Regexp.FindIndex</target>
        </trans-unit>
        <trans-unit id="21fdf1e48587944dc1c11b68645cfe5138e0b116" translate="yes" xml:space="preserve">
          <source>Regexp.FindString</source>
          <target state="translated">Regexp.FindString</target>
        </trans-unit>
        <trans-unit id="dc52dbc2324ccd5021b173c341b811e2472a4206" translate="yes" xml:space="preserve">
          <source>Regexp.FindStringIndex</source>
          <target state="translated">Regexp.FindStringIndex</target>
        </trans-unit>
        <trans-unit id="a2b5fabc1cf5de45d659c3142098c4fde4339cdc" translate="yes" xml:space="preserve">
          <source>Regexp.FindStringSubmatch</source>
          <target state="translated">Regexp.FindStringSubmatch</target>
        </trans-unit>
        <trans-unit id="e27002b196cee520413e84f76c97dc77b353b852" translate="yes" xml:space="preserve">
          <source>Regexp.FindSubmatch</source>
          <target state="translated">Regexp.FindSubmatch</target>
        </trans-unit>
        <trans-unit id="0008582d6bb9067aadd263f03da910a66e6e0e19" translate="yes" xml:space="preserve">
          <source>Regexp.Match</source>
          <target state="translated">Regexp.Match</target>
        </trans-unit>
        <trans-unit id="2c0eada8b9cfbb5d24aadca2e8fa445cbe3b7e2b" translate="yes" xml:space="preserve">
          <source>Regexp.MatchString</source>
          <target state="translated">Regexp.MatchString</target>
        </trans-unit>
        <trans-unit id="4c687a2a42e7f3d60c9f98f0993362b9c2735490" translate="yes" xml:space="preserve">
          <source>Regexp.ReplaceAllLiteralString</source>
          <target state="translated">Regexp.ReplaceAllLiteralString</target>
        </trans-unit>
        <trans-unit id="9fececaf13096d7dc9ffe3d2d93e25169cf762e1" translate="yes" xml:space="preserve">
          <source>Regexp.ReplaceAllString</source>
          <target state="translated">Regexp.ReplaceAllString</target>
        </trans-unit>
        <trans-unit id="5f97458d8e33d7f5f2c52b953c172d5ccb890b23" translate="yes" xml:space="preserve">
          <source>Regexp.ReplaceAllStringFunc</source>
          <target state="translated">Regexp.ReplaceAllStringFunc</target>
        </trans-unit>
        <trans-unit id="60f05fd13196ffa4dd89663cf41abb4f862a263c" translate="yes" xml:space="preserve">
          <source>Regexp.Split</source>
          <target state="translated">Regexp.Split</target>
        </trans-unit>
        <trans-unit id="b36b7852ff6e5f89fe309ce0324c7c9f6dac2ab6" translate="yes" xml:space="preserve">
          <source>Regexp.SubexpNames</source>
          <target state="translated">Regexp.SubexpNames</target>
        </trans-unit>
        <trans-unit id="96a2105b6d183387bea55013dc84567e629210a2" translate="yes" xml:space="preserve">
          <source>Region is a region of code whose execution time interval is traced.</source>
          <target state="translated">Регион-регион кода,временной интервал выполнения которого отслеживается.</target>
        </trans-unit>
        <trans-unit id="95c213e4f5521f3f5195554245abca05424ff590" translate="yes" xml:space="preserve">
          <source>Register makes a database driver available by the provided name. If Register is called twice with the same name or if driver is nil, it panics.</source>
          <target state="translated">Регистрация делает драйвер базы данных доступным под указанным именем.Если Регистр вызывается дважды с одним и тем же именем или если драйвер равен нулю,он паникует.</target>
        </trans-unit>
        <trans-unit id="64aef767785d208425e3e70c5d2194fcd9c84c85" translate="yes" xml:space="preserve">
          <source>Register publishes in the server the set of methods of the receiver value that satisfy the following conditions:</source>
          <target state="translated">Регистр публикует на сервере набор методов получения значения,которые удовлетворяют следующим условиям:</target>
        </trans-unit>
        <trans-unit id="cbe295e9d864bc0bca7f28c205cb5395eba55d05" translate="yes" xml:space="preserve">
          <source>Register publishes the receiver's methods in the DefaultServer.</source>
          <target state="translated">Регистр публикует методы приемника в DefaultServer.</target>
        </trans-unit>
        <trans-unit id="c181d095749a9fa33757c1798befea770ef8d4eb" translate="yes" xml:space="preserve">
          <source>Register records a type, identified by a value for that type, under its internal type name. That name will identify the concrete type of a value sent or received as an interface variable. Only types that will be transferred as implementations of interface values need to be registered. Expecting to be used only during initialization, it panics if the mapping between types and names is not a bijection.</source>
          <target state="translated">Регистр записывает тип,идентифицируемый значением для этого типа,под своим внутренним названием типа.Это имя будет идентифицировать конкретный тип отправленного или полученного значения в качестве интерфейсной переменной.Регистрация нужна только тем типам,которые будут передаваться в качестве реализаций значений интерфейса.Ожидая использования только во время инициализации,он паникует,если отображение между типами и именами не является бижексией.</target>
        </trans-unit>
        <trans-unit id="fceb2cf0f9b16aaaaa6d86b667b93fcaf25ae6c9" translate="yes" xml:space="preserve">
          <source>RegisterCompressor registers custom compressors for a specified method ID. The common methods Store and Deflate are built in.</source>
          <target state="translated">RegisterCompressor регистрирует пользовательские компрессоры для заданного идентификатора метода.Общие методы Store и Deflate встроены.</target>
        </trans-unit>
        <trans-unit id="4a803c7a9e0d15c2a5bd92b06180759964dddc4a" translate="yes" xml:space="preserve">
          <source>RegisterCompressor registers or overrides a custom compressor for a specific method ID. If a compressor for a given method is not found, Writer will default to looking up the compressor at the package level.</source>
          <target state="translated">RegisterCompressor регистрирует или переопределяет пользовательский компрессор для определенного идентификатора метода.Если компрессор для данного метода не найден,Writer по умолчанию будет искать компрессор на уровне пакета.</target>
        </trans-unit>
        <trans-unit id="75b2829cabbf108c3c7f621e80ccf782333f2745" translate="yes" xml:space="preserve">
          <source>RegisterCover records the coverage data accumulators for the tests. NOTE: This function is internal to the testing infrastructure and may change. It is not covered (yet) by the Go 1 compatibility guidelines.</source>
          <target state="translated">RegisterCover записывает аккумуляторы данных покрытия для тестов.ПРИМЕЧАНИЕ:Эта функция является внутренней для инфраструктуры тестирования и может измениться.Она не покрывается (пока)руководством по совместимости Go 1.</target>
        </trans-unit>
        <trans-unit id="0efe5941ddd4024eca3486bcfdaa1b04b1d68c96" translate="yes" xml:space="preserve">
          <source>RegisterDecompressor allows custom decompressors for a specified method ID. The common methods Store and Deflate are built in.</source>
          <target state="translated">RegisterDecompressor позволяет использовать пользовательские декомпрессоры для заданного идентификатора метода.Общие методы Store и Deflate встроены.</target>
        </trans-unit>
        <trans-unit id="f8201de27600ded04eed1497b03a93af78ab1356" translate="yes" xml:space="preserve">
          <source>RegisterDecompressor registers or overrides a custom decompressor for a specific method ID. If a decompressor for a given method is not found, Reader will default to looking up the decompressor at the package level.</source>
          <target state="translated">RegisterDecompressor регистрирует или переопределяет пользовательский декомпрессор для конкретного идентификатора метода.Если декомпрессор для данного метода не найден,Reader по умолчанию будет искать декомпрессор на уровне пакета.</target>
        </trans-unit>
        <trans-unit id="9306a2a96e5923311a823aa140641259832a6493" translate="yes" xml:space="preserve">
          <source>RegisterFormat registers an image format for use by Decode. Name is the name of the format, like &quot;jpeg&quot; or &quot;png&quot;. Magic is the magic prefix that identifies the format's encoding. The magic string can contain &quot;?&quot; wildcards that each match any one byte. Decode is the function that decodes the encoded image. DecodeConfig is the function that decodes just its configuration.</source>
          <target state="translated">RegisterFormat регистрирует формат изображения для использования Decode.Название-это название формата,например,&quot;jpeg&quot; или &quot;png&quot;.Магия-это волшебный префикс,который идентифицирует кодировку формата.Волшебная строка может содержать подстановочные знаки &quot;?&quot;,каждый из которых соответствует любому байту.Декодирование-это функция,которая декодирует закодированное изображение.DecodeConfig-это функция,которая декодирует только его конфигурацию.</target>
        </trans-unit>
        <trans-unit id="d2728f688707b63db693060d8790bf4683f92102" translate="yes" xml:space="preserve">
          <source>RegisterHash registers a function that returns a new instance of the given hash function. This is intended to be called from the init function in packages that implement hash functions.</source>
          <target state="translated">RegisterHash регистрирует функцию,которая возвращает новый экземпляр данной хэш-функции.Она предназначена для вызова из init-функции в пакетах,реализующих хэш-функции.</target>
        </trans-unit>
        <trans-unit id="f205fffb3fe13999a49ce9f8f1c25ec589135c4d" translate="yes" xml:space="preserve">
          <source>RegisterName is like Register but uses the provided name for the type instead of the receiver's concrete type.</source>
          <target state="translated">RegisterName похоже на Register,но использует предоставленное имя для типа вместо конкретного типа приемника.</target>
        </trans-unit>
        <trans-unit id="25332b231573649cd9dd5719e7982ea3f0248d42" translate="yes" xml:space="preserve">
          <source>RegisterName is like Register but uses the provided name rather than the type's default.</source>
          <target state="translated">RegisterName похоже на Register,но использует предоставленное имя,а не тип по умолчанию.</target>
        </trans-unit>
        <trans-unit id="50c9507f9819b5006da79dc0a05071eebeda3b66" translate="yes" xml:space="preserve">
          <source>RegisterOnShutdown registers a function to call on Shutdown. This can be used to gracefully shutdown connections that have undergone NPN/ALPN protocol upgrade or that have been hijacked. This function should start protocol-specific graceful shutdown, but should not wait for shutdown to complete.</source>
          <target state="translated">RegisterOnShutdown регистрирует функцию для вызова при выключении.Она может быть использована для плавного выключения соединений,которые прошли обновление протокола NPN/ALPN или были перехвачены.Эта функция должна запускать специфическое для протокола постепенное выключение,но не должна ждать завершения выключения.</target>
        </trans-unit>
        <trans-unit id="f09b3e8729145f382cce24a789165716e1f6f581" translate="yes" xml:space="preserve">
          <source>RegisterProtocol can be used by other packages to provide implementations of protocol schemes like &quot;ftp&quot; or &quot;file&quot;.</source>
          <target state="translated">RegisterProtocol может быть использован другими пакетами для обеспечения реализации протокольной схемы типа &quot;ftp&quot; или &quot;file&quot;.</target>
        </trans-unit>
        <trans-unit id="dbed30c09a7f4317da85a08f890897f3a240daa9" translate="yes" xml:space="preserve">
          <source>RegisterProtocol registers a new protocol with scheme. The Transport will pass requests using the given scheme to rt. It is rt's responsibility to simulate HTTP request semantics.</source>
          <target state="translated">RegisterProtocol регистрирует новый протокол со схемой.Транспорт будет передавать запросы по заданной схеме в rt.Ответственность за симуляцию семантики HTTP-запросов лежит на rt.</target>
        </trans-unit>
        <trans-unit id="95f136e8903a5338ba8f8a6eba4b4b48f4b69ff6" translate="yes" xml:space="preserve">
          <source>Regs386 is the Mach-O 386 register structure.</source>
          <target state="translated">Regs386-это структура регистра Mach-O 386.</target>
        </trans-unit>
        <trans-unit id="2fcecaafbea673f4dcd43eda2b8e308980d372b2" translate="yes" xml:space="preserve">
          <source>RegsAMD64 is the Mach-O AMD64 register structure.</source>
          <target state="translated">RegsAMD64-это структура регистра Mach-O AMD64.</target>
        </trans-unit>
        <trans-unit id="e042b10a368397c92fb60dbef856be3d5a1c4f5c" translate="yes" xml:space="preserve">
          <source>Rel</source>
          <target state="translated">Rel</target>
        </trans-unit>
        <trans-unit id="1fb867ac152e76d351e8dfda8aca4022a73396b3" translate="yes" xml:space="preserve">
          <source>Rel returns a relative path that is lexically equivalent to targpath when joined to basepath with an intervening separator. That is, Join(basepath, Rel(basepath, targpath)) is equivalent to targpath itself. On success, the returned path will always be relative to basepath, even if basepath and targpath share no elements. An error is returned if targpath can't be made relative to basepath or if knowing the current working directory would be necessary to compute it. Rel calls Clean on the result.</source>
          <target state="translated">Rel возвращает относительный путь,который лексически эквивалентен targpath при соединении с базовым путем с помощью промежуточного разделителя.То есть,Join(basepath,Rel(basepath,targpath))эквивалентен самому targpath.В случае успеха,возвращаемый путь всегда будет относительно basepath,даже если basepath и targpath не имеют общих элементов.Возвращается ошибка,если targpath нельзя сделать относительно basepath или если для вычисления необходимо знать текущий рабочий каталог.Вызовы реле Очистите результат.</target>
        </trans-unit>
        <trans-unit id="c91ec177ba02dafca5c024ef643b47566dd89ce7" translate="yes" xml:space="preserve">
          <source>Relationship between Tok value and Specs element type:</source>
          <target state="translated">Соотношение между значением Tok и типом элемента Specs:</target>
        </trans-unit>
        <trans-unit id="b6abe7b7ff14b910183c9aec85ce50c4ba39a8a2" translate="yes" xml:space="preserve">
          <source>RelativeTo returns a Qualifier that fully qualifies members of all packages other than pkg.</source>
          <target state="translated">RelativeTo возвращает Квалификатор,который полностью квалифицирует членов всех пакетов,кроме pkg.</target>
        </trans-unit>
        <trans-unit id="97b37138ea9a73172899c8018d830214258b5899" translate="yes" xml:space="preserve">
          <source>Release frees up resources allocated for the function. The function must not be invoked after calling Release.</source>
          <target state="translated">Релиз высвобождает ресурсы,выделенные на эту функцию.После вызова Release функция не должна вызываться.</target>
        </trans-unit>
        <trans-unit id="c955e9bb05dd10804916da733d223f9b35d93831" translate="yes" xml:space="preserve">
          <source>Release releases any resources associated with the Process p, rendering it unusable in the future. Release only needs to be called if Wait is not.</source>
          <target state="translated">Освободите все ресурсы,связанные с Process p,что сделает его непригодным для использования в будущем.Релиз должен быть вызван только в том случае,если Wait нет.</target>
        </trans-unit>
        <trans-unit id="74b4353ac8d321669700f92b4b41fd9bf3c282ea" translate="yes" xml:space="preserve">
          <source>Reloc represents a PE COFF relocation. Each section contains its own relocation list.</source>
          <target state="translated">Перемещение представляет собой перемещение PE COFF.Каждый раздел содержит свой собственный список перемещений.</target>
        </trans-unit>
        <trans-unit id="06f15fe6a2a2d8aaac59472278e750857f76ab13" translate="yes" xml:space="preserve">
          <source>Relocation types for 386.</source>
          <target state="translated">Типы перераспределения для 386.</target>
        </trans-unit>
        <trans-unit id="d75a9d4eea543b3382ef4c2ebb9e3847ab91fd45" translate="yes" xml:space="preserve">
          <source>Relocation types for 64-bit PowerPC or Power Architecture processors.</source>
          <target state="translated">Типы перераспределения для 64-битных процессоров PowerPC или Power Architecture.</target>
        </trans-unit>
        <trans-unit id="cf64299a5f4f83507314f139a3920dac3975ef27" translate="yes" xml:space="preserve">
          <source>Relocation types for AArch64 (aka arm64)</source>
          <target state="translated">Типы перераспределения для AArch64 (он же arm64)</target>
        </trans-unit>
        <trans-unit id="ef97dc2ae262d8f689d2dbae4ceb64c7c62edcc6" translate="yes" xml:space="preserve">
          <source>Relocation types for ARM.</source>
          <target state="translated">Типы перераспределения для ARM.</target>
        </trans-unit>
        <trans-unit id="2557c954121a635ff74fb9af9fe06dc80e27b715" translate="yes" xml:space="preserve">
          <source>Relocation types for Alpha.</source>
          <target state="translated">Типы перераспределения для Альфа.</target>
        </trans-unit>
        <trans-unit id="1a1e40660756b62ef3239b6ced113d0caf0dbeda" translate="yes" xml:space="preserve">
          <source>Relocation types for MIPS.</source>
          <target state="translated">Типы перераспределения для MIPS.</target>
        </trans-unit>
        <trans-unit id="37b372c8b8cafc23d3fe71c2d91eeb8c48e4e130" translate="yes" xml:space="preserve">
          <source>Relocation types for PowerPC.</source>
          <target state="translated">Типы перераспределения для PowerPC.</target>
        </trans-unit>
        <trans-unit id="515822ec7faf1b82351dd8cb58bc45abc27332b8" translate="yes" xml:space="preserve">
          <source>Relocation types for RISC-V processors.</source>
          <target state="translated">Типы перераспределения для процессоров RISC-V.</target>
        </trans-unit>
        <trans-unit id="28595645ef003fbc741125cd77426e420a3c93bb" translate="yes" xml:space="preserve">
          <source>Relocation types for SPARC.</source>
          <target state="translated">Типы перераспределения для SPARC.</target>
        </trans-unit>
        <trans-unit id="c8eeb8ad932e590ca3c9a184613db792a1b7d221" translate="yes" xml:space="preserve">
          <source>Relocation types for s390x processors.</source>
          <target state="translated">Типы перераспределения для процессоров s390x.</target>
        </trans-unit>
        <trans-unit id="65d84f2017b766a2f893b1d9391a10aba054030c" translate="yes" xml:space="preserve">
          <source>Relocation types for x86-64.</source>
          <target state="translated">Типы перераспределения для x86-64.</target>
        </trans-unit>
        <trans-unit id="f46f12d749f237f3883c4c5a62ab9b4f4409ae12" translate="yes" xml:space="preserve">
          <source>Rem sets z to the remainder x%y for y != 0 and returns z. If y == 0, a division-by-zero run-time panic occurs. Rem implements truncated modulus (like Go); see QuoRem for more details.</source>
          <target state="translated">Rem устанавливает z в остаток x%y для y !=0 и возвращает z.Если y ==0,то происходит паника при делении на ноль.Rem реализует усечённый модуль (как Go);подробнее см.в QuoRem.</target>
        </trans-unit>
        <trans-unit id="5a90835af9526ee1f92955fe811ed706ded57897" translate="yes" xml:space="preserve">
          <source>Remainder returns the IEEE 754 floating-point remainder of x/y.</source>
          <target state="translated">Остаток возвращает IEEE 754 остаток x/y с плавающей точкой.</target>
        </trans-unit>
        <trans-unit id="2dbe95bdd28a0d327a2826a1eef6ea3b725d6372" translate="yes" xml:space="preserve">
          <source>RemoteAddr returns the remote network address.</source>
          <target state="translated">RemoteAddr возвращает адрес удаленной сети.</target>
        </trans-unit>
        <trans-unit id="8f214e8a0c44c6dd9e0f980e84dc95f63540d94a" translate="yes" xml:space="preserve">
          <source>RemoteAddr returns the remote network address. The Addr returned is shared by all invocations of RemoteAddr, so do not modify it.</source>
          <target state="translated">RemoteAddr возвращает адрес удаленной сети.Возвращаемый Addr разделяется всеми вызовами RemoteAddr,поэтому не изменяйте его.</target>
        </trans-unit>
        <trans-unit id="90f28a6964f1d3561d308698fa02c4f609406cc1" translate="yes" xml:space="preserve">
          <source>Remove removes and returns the element at index i from the heap. The complexity is O(log n) where n = h.Len().</source>
          <target state="translated">Удаляет и возвращает элемент с индексом i из кучи.Сложность-O(log n),где n=h.Len().</target>
        </trans-unit>
        <trans-unit id="63f1e9035000ecf346c434c7cac5dc81f24b1fd9" translate="yes" xml:space="preserve">
          <source>Remove removes e from l if e is an element of list l. It returns the element value e.Value. The element must not be nil.</source>
          <target state="translated">Удалить удаляет e из l,если e является элементом списка l.Возвращает значение элемента e.Value.Элемент не должен быть нулевым.</target>
        </trans-unit>
        <trans-unit id="e157d0f3ede189bf26b7e5070547dae063fd8af3" translate="yes" xml:space="preserve">
          <source>Remove removes the execution stack associated with value from the profile. It is a no-op if the value is not in the profile.</source>
          <target state="translated">Удалить удаляет из профиля стек исполнения,связанный со значением.Если значение не находится в профиле,то оно не действует.</target>
        </trans-unit>
        <trans-unit id="737a090d3844bc76afa279471870777ff484d715" translate="yes" xml:space="preserve">
          <source>Remove removes the named file or (empty) directory. If there is an error, it will be of type *PathError.</source>
          <target state="translated">Удалить удаляет именованный файл или (пустой)каталог.Если есть ошибка,то она будет иметь тип *PathError.</target>
        </trans-unit>
        <trans-unit id="2570a819a5c470bfe2d2d19b6aafa9194f77567b" translate="yes" xml:space="preserve">
          <source>RemoveAll removes any temporary files associated with a Form.</source>
          <target state="translated">RemoveAll удаляет все временные файлы,связанные с формой.</target>
        </trans-unit>
        <trans-unit id="4fad214b70e3f0d318c435f74dd889aca7ef4dce" translate="yes" xml:space="preserve">
          <source>RemoveAll removes path and any children it contains. It removes everything it can but returns the first error it encounters. If the path does not exist, RemoveAll returns nil (no error). If there is an error, it will be of type *PathError.</source>
          <target state="translated">RemoveAll удаляет путь и всех детей,которые в нем содержатся.Он удаляет все,что может,но возвращает первую ошибку,с которой сталкивается.Если путь не существует,RemoveAll возвращает ноль (ошибки нет).Если ошибка есть,то она будет иметь тип *PathError.</target>
        </trans-unit>
        <trans-unit id="a4df6c6f5aeda6e3a5e7e46422d0e2c2213a3c07" translate="yes" xml:space="preserve">
          <source>RemoveMultiples sorts an ErrorList and removes all but the first error per line.</source>
          <target state="translated">RemoveMultiples сортирует ErrorList и удаляет все ошибки на строку,кроме первой.</target>
        </trans-unit>
        <trans-unit id="c2642ac096483cfaf0dfa99c4fbd35ae36daa1eb" translate="yes" xml:space="preserve">
          <source>Rename renames (moves) oldpath to newpath. If newpath already exists and is not a directory, Rename replaces it. OS-specific restrictions may apply when oldpath and newpath are in different directories. If there is an error, it will be of type *LinkError.</source>
          <target state="translated">Переименовать (переименовать)старый путь на новый.Если newpath уже существует и не является каталогом,то его заменяет Rename.Ограничения,специфичные для операционной системы,могут применяться,когда oldpath и newpath находятся в разных каталогах.Если есть ошибка,то она будет иметь тип *LinkError.</target>
        </trans-unit>
        <trans-unit id="fdd5e93217a24d0127aee52fa57edae8bdb219bf" translate="yes" xml:space="preserve">
          <source>Renegotiation is not defined in TLS 1.3.</source>
          <target state="translated">Переговоры не определены в TLS 1.3.</target>
        </trans-unit>
        <trans-unit id="592ed73cf658d5bb06fa571424af0b382c1c93a8" translate="yes" xml:space="preserve">
          <source>RenegotiationSupport enumerates the different levels of support for TLS renegotiation. TLS renegotiation is the act of performing subsequent handshakes on a connection after the first. This significantly complicates the state machine and has been the source of numerous, subtle security issues. Initiating a renegotiation is not supported, but support for accepting renegotiation requests may be enabled.</source>
          <target state="translated">RenegotiationSupport перечисляет различные уровни поддержки при пересмотре TLS.Пересмотр TLS-это акт выполнения последующих хендшейков при соединении после первого.Это значительно усложняет государственную машину и является источником многочисленных,тонких вопросов безопасности.Инициирование перезагрузки не поддерживается,но поддержка принятия запросов на перезагрузку может быть включена.</target>
        </trans-unit>
        <trans-unit id="659eba121958f4a29fab3d29d61cedc55a892334" translate="yes" xml:space="preserve">
          <source>Repeat</source>
          <target state="translated">Repeat</target>
        </trans-unit>
        <trans-unit id="599d1421a3d35ed387e2145047d3b7a4416981b0" translate="yes" xml:space="preserve">
          <source>Repeat returns a new byte slice consisting of count copies of b.</source>
          <target state="translated">Повторяю,возвращается новый кусочек байта,состоящий из копий отсчета b.</target>
        </trans-unit>
        <trans-unit id="0843316565926f24e0d78b098353e903c702fd32" translate="yes" xml:space="preserve">
          <source>Repeat returns a new string consisting of count copies of the string s.</source>
          <target state="translated">Repeat возвращает новую строку,состоящую из копий счетчика строк s.</target>
        </trans-unit>
        <trans-unit id="b93ec95436616b79bd94ec117ace8a646628d209" translate="yes" xml:space="preserve">
          <source>Repetitions:</source>
          <target state="translated">Repetitions:</target>
        </trans-unit>
        <trans-unit id="a7cf7b25a703b308887c7f1d100c4326ef20ac46" translate="yes" xml:space="preserve">
          <source>Replace</source>
          <target state="translated">Replace</target>
        </trans-unit>
        <trans-unit id="14a86b576c43d99c7af38126a244d77d20b45014" translate="yes" xml:space="preserve">
          <source>Replace returns a copy of s with all replacements performed.</source>
          <target state="translated">Замена возвращает копию s со всеми выполненными заменами.</target>
        </trans-unit>
        <trans-unit id="486c15b931366bdf03143c243ee2b4d97be57dd7" translate="yes" xml:space="preserve">
          <source>Replace returns a copy of the slice s with the first n non-overlapping instances of old replaced by new. If old is empty, it matches at the beginning of the slice and after each UTF-8 sequence, yielding up to k+1 replacements for a k-rune slice. If n &amp;lt; 0, there is no limit on the number of replacements.</source>
          <target state="translated">Replace возвращает копию среза s с первыми n неперекрывающимися экземплярами старого, замененного новым. Если old пуст, он соответствует в начале фрагмента и после каждой последовательности UTF-8, что дает до k + 1 замен для k-рунного фрагмента. Если n &amp;lt;0, нет ограничения на количество замен.</target>
        </trans-unit>
        <trans-unit id="db4d7af1ecfbb4c54ae4d472073701051302c13a" translate="yes" xml:space="preserve">
          <source>Replace returns a copy of the string s with the first n non-overlapping instances of old replaced by new. If old is empty, it matches at the beginning of the string and after each UTF-8 sequence, yielding up to k+1 replacements for a k-rune string. If n &amp;lt; 0, there is no limit on the number of replacements.</source>
          <target state="translated">Replace возвращает копию строки s с первыми n неперекрывающимися экземплярами старого, замененного новым. Если old пуст, он соответствует в начале строки и после каждой последовательности UTF-8, что дает до k + 1 замен для k-рунной строки. Если n &amp;lt;0, нет ограничения на количество замен.</target>
        </trans-unit>
        <trans-unit id="6eadb25ec304f683e79d867595086d352904b5b3" translate="yes" xml:space="preserve">
          <source>ReplaceAll</source>
          <target state="translated">ReplaceAll</target>
        </trans-unit>
        <trans-unit id="73ca5d06cabf37b075a8580fb5101f87650ad229" translate="yes" xml:space="preserve">
          <source>ReplaceAll returns a copy of src, replacing matches of the Regexp with the replacement text repl. Inside repl, $ signs are interpreted as in Expand, so for instance $1 represents the text of the first submatch.</source>
          <target state="translated">ReplaceAll возвращает копию src,заменяя совпадения Regexp на замену текста.Внутри реплики знаки $ интерпретируются как в Expand,поэтому,например,$1 представляет собой текст первого подмножества.</target>
        </trans-unit>
        <trans-unit id="506447353e7b3822dcf4613a0f93ab71e29d1735" translate="yes" xml:space="preserve">
          <source>ReplaceAll returns a copy of the slice s with all non-overlapping instances of old replaced by new. If old is empty, it matches at the beginning of the slice and after each UTF-8 sequence, yielding up to k+1 replacements for a k-rune slice.</source>
          <target state="translated">ReplaceAll возвращает копию среза,при этом все непересекающиеся экземпляры старого среза заменяются на новый.Если старый пустой,то он совпадает в начале среза и после каждой последовательности UTF-8,что дает до k+1 замены для среза k-руны.</target>
        </trans-unit>
        <trans-unit id="435dc323288417e80211f8927c3695e3ce359257" translate="yes" xml:space="preserve">
          <source>ReplaceAll returns a copy of the string s with all non-overlapping instances of old replaced by new. If old is empty, it matches at the beginning of the string and after each UTF-8 sequence, yielding up to k+1 replacements for a k-rune string.</source>
          <target state="translated">ReplaceAll возвращает копию строки s со всеми не перекрывающимися экземплярами старого,замененными новым.Если старое пусто,то оно совпадает в начале строки и после каждой последовательности UTF-8,что дает до k+1 замены для строки k-rune.</target>
        </trans-unit>
        <trans-unit id="3d66ecd6da17fab5c8cd96769f904257ef13a398" translate="yes" xml:space="preserve">
          <source>ReplaceAllFunc returns a copy of src in which all matches of the Regexp have been replaced by the return value of function repl applied to the matched byte slice. The replacement returned by repl is substituted directly, without using Expand.</source>
          <target state="translated">ReplaceAllFunc возвращает копию src,в которой все совпадения Regexp были заменены на возвращаемое значение repl функции,примененной к совпадающему срезу байта.Замена,возвращаемая функцией ReplaceAllFunc,заменяется непосредственно,без использования Expand.</target>
        </trans-unit>
        <trans-unit id="2a17131c7994cd05d7daea07beea0ef31e257581" translate="yes" xml:space="preserve">
          <source>ReplaceAllLiteral returns a copy of src, replacing matches of the Regexp with the replacement bytes repl. The replacement repl is substituted directly, without using Expand.</source>
          <target state="translated">ReplaceAllLiteral возвращает копию src,заменяя совпадения Regexp на замену байтов.Заменяемая реплика заменяется напрямую,без использования Expand.</target>
        </trans-unit>
        <trans-unit id="87232f03b040c072f8f75219db9d85c61ff38e7c" translate="yes" xml:space="preserve">
          <source>ReplaceAllLiteralString returns a copy of src, replacing matches of the Regexp with the replacement string repl. The replacement repl is substituted directly, without using Expand.</source>
          <target state="translated">ReplaceAllLiteralString возвращает копию src,заменяя совпадения Regexp на замену строки замены.Заменяемая реплика заменяется напрямую,без использования Expand.</target>
        </trans-unit>
        <trans-unit id="bef70f919214d0f77e4d3a42c824dfffa5202cf4" translate="yes" xml:space="preserve">
          <source>ReplaceAllString returns a copy of src, replacing matches of the Regexp with the replacement string repl. Inside repl, $ signs are interpreted as in Expand, so for instance $1 represents the text of the first submatch.</source>
          <target state="translated">ReplaceAllString возвращает копию src,заменяя совпадения Regexp на замену строки замены.Внутри реплики знаки $ интерпретируются как в Expand,поэтому,например,$1 представляет собой текст первого подмножества.</target>
        </trans-unit>
        <trans-unit id="a3e275047465f9460cb043d0b2093b457293bb06" translate="yes" xml:space="preserve">
          <source>ReplaceAllStringFunc returns a copy of src in which all matches of the Regexp have been replaced by the return value of function repl applied to the matched substring. The replacement returned by repl is substituted directly, without using Expand.</source>
          <target state="translated">ReplaceAllStringFunc возвращает копию src,в которой все совпадения Regexp были заменены на возвращаемое значение функции replace,примененной к соответствующей подстроке.Замена,возвращаемая репликой,подставляется напрямую,без использования Expand.</target>
        </trans-unit>
        <trans-unit id="15e8ece6d83eb79a1b1a825152f49a545610894e" translate="yes" xml:space="preserve">
          <source>Replacer replaces a list of strings with replacements. It is safe for concurrent use by multiple goroutines.</source>
          <target state="translated">Replacer заменяет список строк заменами.Он безопасен для одновременного использования несколькими горутинами.</target>
        </trans-unit>
        <trans-unit id="5cf96ab71fbe348ef9fe46121c7813b382500496" translate="yes" xml:space="preserve">
          <source>Replacing the sign in the format with a Z triggers the ISO 8601 behavior of printing Z instead of an offset for the UTC zone. Thus:</source>
          <target state="translated">Замена знака в формате Z вызывает поведение ISO 8601 при печати Z вместо офсета для UTC-зоны.Таким образом:</target>
        </trans-unit>
        <trans-unit id="4b4d5cf4e6e2109de9a6b60e939d3a3fb07ec141" translate="yes" xml:space="preserve">
          <source>ReportAllocs enables malloc statistics for this benchmark. It is equivalent to setting -test.benchmem, but it only affects the benchmark function that calls ReportAllocs.</source>
          <target state="translated">ReportAllocs позволяет использовать статистику malloc для этого бенчмарка.Это эквивалентно установке -test.benchmem,но влияет только на функцию бенчмарка,которая вызывает ReportAllocs.</target>
        </trans-unit>
        <trans-unit id="ca2f164e5206d2fe2c80e762a870dbd7b150154b" translate="yes" xml:space="preserve">
          <source>ReportMetric adds &quot;n unit&quot; to the reported benchmark results. If the metric is per-iteration, the caller should divide by b.N, and by convention units should end in &quot;/op&quot;. ReportMetric overrides any previously reported value for the same unit. ReportMetric panics if unit is the empty string or if unit contains any whitespace. If unit is a unit normally reported by the benchmark framework itself (such as &quot;allocs/op&quot;), ReportMetric will override that metric. Setting &quot;ns/op&quot; to 0 will suppress that built-in metric.</source>
          <target state="translated">ReportMetric добавляет &quot;n единиц&quot; к отчетным результатам.Если метрика является per-iteration,то вызывающий абонент должен разделиться на b.N,а по условным единицам должен оканчиваться на &quot;/op&quot;.ReportMetric отменяет любое ранее сообщенное значение для той же единицы.ReportMetric паникует,если единицей измерения является пустая строка или если единица измерения содержит пробелы.Если единица-это единица,о которой обычно сообщает сама эталонная структура (например,&quot;allocs/op&quot;),ReportMetric отменяет эту метрику.Установка &quot;ns/op&quot; в 0 отменяет эту встроенную метрику.</target>
        </trans-unit>
        <trans-unit id="bbfd1ef8b32af00f36af4ce56ffc90aaec2642df" translate="yes" xml:space="preserve">
          <source>Representations of a Time value saved by the GobEncode, MarshalBinary, MarshalJSON, and MarshalText methods store the Time.Location's offset, but not the location name. They therefore lose information about Daylight Saving Time.</source>
          <target state="translated">Представления значения Времени,сохраненные методами GobEncode,MarshalBinary,MarshalJSON и MarshalText,хранят смещение Time.Location,но не имя местоположения.Поэтому они теряют информацию о летнем времени.</target>
        </trans-unit>
        <trans-unit id="034f490ecab4d9730ca1969131b6a78b84d524bf" translate="yes" xml:space="preserve">
          <source>Request is a header written before every RPC call. It is used internally but documented here as an aid to debugging, such as when analyzing network traffic.</source>
          <target state="translated">Запрос-это заголовок,написанный перед каждым вызовом RPC.Он используется внутри организации,но документируется здесь в качестве помощи при отладке,например,при анализе сетевого трафика.</target>
        </trans-unit>
        <trans-unit id="7fe490925acca7c7d2d43d098e092cfd78223216" translate="yes" xml:space="preserve">
          <source>Request returns the HTTP request as represented in the current environment. This assumes the current program is being run by a web server in a CGI environment. The returned Request's Body is populated, if applicable.</source>
          <target state="translated">Запрос возвращает HTTP-запрос в том виде,в каком он представлен в текущей среде.Это предполагает,что текущая программа выполняется веб-сервером в CGI-окружении.Возвращаемое тело запроса заполняется,если применимо.</target>
        </trans-unit>
        <trans-unit id="d122cdaacba1573bfe57f160ca47386cbda87132" translate="yes" xml:space="preserve">
          <source>RequestFromMap creates an http.Request from CGI variables. The returned Request's Body field is not populated.</source>
          <target state="translated">RequestFromMap создает http.Request из CGI-переменных.Возвращаемое поле тела запроса не заполняется.</target>
        </trans-unit>
        <trans-unit id="27b1cff1ae1ef7bb8ea746c0ebbfe176f573422d" translate="yes" xml:space="preserve">
          <source>RequestURI returns the encoded path?query or opaque?query string that would be used in an HTTP request for u.</source>
          <target state="translated">RequestURI возвращает закодированный путь или непрозрачную строку запроса,которая будет использоваться в HTTP-запросе для u.</target>
        </trans-unit>
        <trans-unit id="3b21fedf00a3371e3f28d17145c5a692c6831e7c" translate="yes" xml:space="preserve">
          <source>Reset changes the timer to expire after duration d. It returns true if the timer had been active, false if the timer had expired or been stopped.</source>
          <target state="translated">Сброс изменений таймера истекает по истечении срока d.Он возвращает true,если таймер был активен,false,если таймер истек или был остановлен.</target>
        </trans-unit>
        <trans-unit id="1eaa7c3f868073620d91cca86ce9b81e6921a9e0" translate="yes" xml:space="preserve">
          <source>Reset clears the state of the Writer z such that it is equivalent to its initial state from NewWriterLevel or NewWriterLevelDict, but instead writing to w.</source>
          <target state="translated">Сброс очищает состояние Writer z таким образом,что оно эквивалентно его исходному состоянию из NewWriterLevel или NewWriterLevelDict,но вместо этого пишет в w.</target>
        </trans-unit>
        <trans-unit id="8fad0a06171db3d325d00805f309209741be9985" translate="yes" xml:space="preserve">
          <source>Reset discards any buffered data, resets all state, and switches the buffered reader to read from r.</source>
          <target state="translated">Сбрасывает все буферизованные данные,сбрасывает все состояние и переключает буферизованный считыватель на чтение с r.</target>
        </trans-unit>
        <trans-unit id="ddec4089b2023a9f5966b6899a6d86b3c6ba6d0e" translate="yes" xml:space="preserve">
          <source>Reset discards any unflushed buffered data, clears any error, and resets b to write its output to w.</source>
          <target state="translated">Сброс сбрасывает любые немытые буферизованные данные,очищает от ошибок и сбрасывает b для записи его вывода в w.</target>
        </trans-unit>
        <trans-unit id="0f6193249698e8c1cc414024f184ff9d63a0b799" translate="yes" xml:space="preserve">
          <source>Reset discards the Reader z's state and makes it equivalent to the result of its original state from NewReader, but reading from r instead. This permits reusing a Reader rather than allocating a new one.</source>
          <target state="translated">Сброс сбрасывает состояние Читателя z и делает его эквивалентным результату исходного состояния из NewReader,а чтение из r вместо этого.Это позволяет повторно использовать Читатель,а не выделять новый.</target>
        </trans-unit>
        <trans-unit id="d8366944feb20881339d2bc39051aaaff11ba2e7" translate="yes" xml:space="preserve">
          <source>Reset discards the Writer z's state and makes it equivalent to the result of its original state from NewWriter or NewWriterLevel, but writing to w instead. This permits reusing a Writer rather than allocating a new one.</source>
          <target state="translated">Сброс сбрасывает состояние Writer z и делает его эквивалентным результату исходного состояния из NewWriter или NewWriterLevel,но записывает его в w,вместо этого.Это позволяет использовать Writer повторно,а не выделять новый.</target>
        </trans-unit>
        <trans-unit id="1192ba3cfdd5644c337b189600cac9374ed9f399" translate="yes" xml:space="preserve">
          <source>Reset discards the writer's state and makes it equivalent to the result of NewWriter or NewWriterDict called with dst and w's level and dictionary.</source>
          <target state="translated">Сброс отбрасывает состояние писателя и делает его эквивалентным результату NewWriter или NewWriterDict,вызываемого с уровнем dst и w и словарем.</target>
        </trans-unit>
        <trans-unit id="f44016b53cb6e5efb7b07f97bdd7a58a3f9acd27" translate="yes" xml:space="preserve">
          <source>Reset repositions the line table reader at the beginning of the line table.</source>
          <target state="translated">Сброс настроек считывателя строчной таблицы в начале строчной таблицы.</target>
        </trans-unit>
        <trans-unit id="fc5e1e89a723101da37c5f7cdde61464338d0205" translate="yes" xml:space="preserve">
          <source>Reset resets an ErrorList to no errors.</source>
          <target state="translated">Сброс сбрасывает ErrorList на отсутствие ошибок.</target>
        </trans-unit>
        <trans-unit id="06a254b1693f024953c4504eb0ab4b1efccfe485" translate="yes" xml:space="preserve">
          <source>Reset resets the Builder to be empty.</source>
          <target state="translated">Сброс сбрасывает строителя на пустое место.</target>
        </trans-unit>
        <trans-unit id="e5afd25b08aea0811ed90f3f30191e4fc43f9115" translate="yes" xml:space="preserve">
          <source>Reset resets the Reader to be reading from b.</source>
          <target state="translated">Сброс сбрасывает чтение с b.</target>
        </trans-unit>
        <trans-unit id="15670331b1298dacd5ea205176b1269922b3d2b5" translate="yes" xml:space="preserve">
          <source>Reset resets the Reader to be reading from s.</source>
          <target state="translated">Сброс сбрасывает показания считывающего устройства на s.</target>
        </trans-unit>
        <trans-unit id="170c10bab8e54e5cf030eb670497e5196563378e" translate="yes" xml:space="preserve">
          <source>Reset resets the buffer to be empty, but it retains the underlying storage for use by future writes. Reset is the same as Truncate(0).</source>
          <target state="translated">Сброс сбрасывает буфер,чтобы он был пустым,но сохраняет базовое хранилище для использования при последующих записях.Сброс такой же,как и Truncate(0).</target>
        </trans-unit>
        <trans-unit id="1cf78ba3d25ca4518fc926a9a64e46d873a5c2b0" translate="yes" xml:space="preserve">
          <source>Reset sends the RSET command to the server, aborting the current mail transaction.</source>
          <target state="translated">Reset посылает команду RSET на сервер,прерывая текущую почтовую транзакцию.</target>
        </trans-unit>
        <trans-unit id="a8bd7c2aca0a58855a450ef3c393b7f8dd845541" translate="yes" xml:space="preserve">
          <source>Reset should be invoked only on stopped or expired timers with drained channels. If a program has already received a value from t.C, the timer is known to have expired and the channel drained, so t.Reset can be used directly. If a program has not yet received a value from t.C, however, the timer must be stopped and&amp;mdash;if Stop reports that the timer expired before being stopped&amp;mdash;the channel explicitly drained:</source>
          <target state="translated">Сброс следует вызывать только для остановленных или истекших таймеров с истощенными каналами. Если программа уже получила значение от tC, известно, что таймер истек и канал опустошен, поэтому t.Reset можно использовать напрямую. Однако, если программа еще не получила значение от tC, таймер должен быть остановлен и - если Stop сообщает, что таймер истек до того, как был остановлен - канал явно осушается:</target>
        </trans-unit>
        <trans-unit id="c62db3fae7c3e711fbf34aadc1b1afc1b9253c1a" translate="yes" xml:space="preserve">
          <source>Reset undoes the effect of any prior calls to Notify for the provided signals. If no signals are provided, all signal handlers will be reset.</source>
          <target state="translated">Сброс отменяет эффект любых предыдущих вызовов,чтобы Уведомить о предоставленных сигналах.Если сигналы не поступают,все обработчики сигналов сбрасываются.</target>
        </trans-unit>
        <trans-unit id="27fa1b9793c51dfd946a69a14c0ddb57c10ad547" translate="yes" xml:space="preserve">
          <source>Reset zeros the key data and makes the Cipher unusable.</source>
          <target state="translated">Сброс нулей ключевых данных и делает Шифр непригодным для использования.</target>
        </trans-unit>
        <trans-unit id="f310c59e5a0084054073df7b5f573d812cdd0fd8" translate="yes" xml:space="preserve">
          <source>ResetTimer zeroes the elapsed benchmark time and memory allocation counters and deletes user-reported metrics. It does not affect whether the timer is running.</source>
          <target state="translated">ResetTimer обнуляет прошедшее время бенчмарка и счетчики распределения памяти,а также удаляет метрики,зарегистрированные пользователем.Это не влияет на то,запущен ли таймер.</target>
        </trans-unit>
        <trans-unit id="33ee9712ca346c749995f4d74bcd18ae6c0b0650" translate="yes" xml:space="preserve">
          <source>Resetter resets a ReadCloser returned by NewReader or NewReaderDict to switch to a new underlying Reader. This permits reusing a ReadCloser instead of allocating a new one.</source>
          <target state="translated">Сброс Resetter сбрасывает ReadCloser,возвращенный NewReader или NewReaderDict,для переключения на новый базовый Reader.Это позволяет повторно использовать ReadCloser вместо назначения нового.</target>
        </trans-unit>
        <trans-unit id="7007d754cde94120e44343157ab76b14a831c26c" translate="yes" xml:space="preserve">
          <source>ResolveIPAddr returns an address of IP end point.</source>
          <target state="translated">ResolveIPAddr возвращает адрес конечной точки IP.</target>
        </trans-unit>
        <trans-unit id="07b69306928a5a3a0b8c2314c2531e10de93c9cf" translate="yes" xml:space="preserve">
          <source>ResolveReference resolves a URI reference to an absolute URI from an absolute base URI u, per RFC 3986 Section 5.2. The URI reference may be relative or absolute. ResolveReference always returns a new URL instance, even if the returned URL is identical to either the base or reference. If ref is an absolute URL, then ResolveReference ignores base and returns a copy of ref.</source>
          <target state="translated">ResolveReference разрешает ссылку URI на абсолютный URI из абсолютного базового URI u,в соответствии с разделом 5.2 RFC 3986.Ссылка на URI может быть относительной или абсолютной.ResolveReference всегда возвращает новый экземпляр URL,даже если возвращаемый URL идентичен базовому или ссылке.Если ссылка является абсолютным URL,то ResolveReference игнорирует базу и возвращает копию ссылки.</target>
        </trans-unit>
        <trans-unit id="3273804861eaad79df80c3d22cf109398eb595c4" translate="yes" xml:space="preserve">
          <source>ResolveTCPAddr returns an address of TCP end point.</source>
          <target state="translated">ResolveTCPAddr возвращает адрес конечной точки TCP.</target>
        </trans-unit>
        <trans-unit id="d940491c716336f4aaf080189bdb0c28cf1b6ec4" translate="yes" xml:space="preserve">
          <source>ResolveUDPAddr returns an address of UDP end point.</source>
          <target state="translated">ResolveUDPAddr возвращает адрес конечной точки UDP.</target>
        </trans-unit>
        <trans-unit id="2928800c224397786b541e4886439dcdc0ecfc66" translate="yes" xml:space="preserve">
          <source>ResolveUnixAddr returns an address of Unix domain socket end point.</source>
          <target state="translated">ResolveUnixAddr возвращает адрес конечной точки доменного сокета Unix.</target>
        </trans-unit>
        <trans-unit id="3dd3f1ec80ee28cb3dd53e5b932daca2d3fdd951" translate="yes" xml:space="preserve">
          <source>Response is a header written before every RPC return. It is used internally but documented here as an aid to debugging, such as when analyzing network traffic.</source>
          <target state="translated">Ответ-это заголовок,записанный перед каждым RPC возвращением.Он используется внутри организации,но документируется здесь в качестве помощи при отладке,например,при анализе сетевого трафика.</target>
        </trans-unit>
        <trans-unit id="78fa8e7076763a708a759f35e6fdf9c8c2792c3e" translate="yes" xml:space="preserve">
          <source>Response represents the response from an HTTP request.</source>
          <target state="translated">Ответ представляет собой ответ на запрос HTTP.</target>
        </trans-unit>
        <trans-unit id="2c870a02afd7772b1a5c1104af64d975949d9837" translate="yes" xml:space="preserve">
          <source>ResponseRecorder</source>
          <target state="translated">ResponseRecorder</target>
        </trans-unit>
        <trans-unit id="294d856644ce3293fbb784b42f79f661b3d60595" translate="yes" xml:space="preserve">
          <source>ResponseRecorder is an implementation of http.ResponseWriter that records its mutations for later inspection in tests.</source>
          <target state="translated">ResponseRecorder представляет собой реализацию http.ResponseWriter,которая записывает его мутации для последующей проверки в тестах.</target>
        </trans-unit>
        <trans-unit id="d0d0da2350df38e89f18eec0c8c277a390ef8032" translate="yes" xml:space="preserve">
          <source>ResponseWriter (Trailers)</source>
          <target state="translated">ResponseWriter (Прицепы)</target>
        </trans-unit>
        <trans-unit id="3f9f60a3d963394dba2b9af5ad21d7cf9b8efc40" translate="yes" xml:space="preserve">
          <source>Responses with status codes in the 1xx range are either handled automatically (100 expect-continue) or ignored. The one exception is HTTP status code 101 (Switching Protocols), which is considered a terminal status and returned by RoundTrip. To see the ignored 1xx responses, use the httptrace trace package's ClientTrace.Got1xxResponse.</source>
          <target state="translated">Ответы с кодами состояния в диапазоне 1xx обрабатываются автоматически (100 ожидаемое продолжение)или игнорируются.Единственным исключением является код состояния HTTP 101 (Switching Protocols),который считается статусом терминала и возвращается по циклу.Для просмотра игнорируемых 1xx ответов используйте ClientTrace.Got1xxResponse пакета трассировки httptrace.</target>
        </trans-unit>
        <trans-unit id="c92c6b4dd981d78fca3ec0b5b13d22c3c7e3c9ff" translate="yes" xml:space="preserve">
          <source>Result is the result of a query execution.</source>
          <target state="translated">Результатом является результат выполнения запроса.</target>
        </trans-unit>
        <trans-unit id="1f4d7bab508f22f797e449d5f6998b16e4434cbe" translate="yes" xml:space="preserve">
          <source>Result must only be called after the handler has finished running.</source>
          <target state="translated">Результат должен быть вызван только после того,как обработчик закончит работу.</target>
        </trans-unit>
        <trans-unit id="1b5febf7558713f1ecb2fbd2c227fbc55af9bbed" translate="yes" xml:space="preserve">
          <source>Result returns the response generated by the handler.</source>
          <target state="translated">Результат возвращает ответ,сгенерированный обработчиком.</target>
        </trans-unit>
        <trans-unit id="2d5559e8af761fd8963b92d10b52cc8627380cc7" translate="yes" xml:space="preserve">
          <source>ResultNoRows is a pre-defined Result for drivers to return when a DDL command (such as a CREATE TABLE) succeeds. It returns an error for both LastInsertId and RowsAffected.</source>
          <target state="translated">ResultNoRows-это предопределенный Result для драйверов,который возвращается при успешном выполнении команды DDL (например,CREATE TABLE).Она возвращает ошибку как для LastInsertId,так и для RowsAffected.</target>
        </trans-unit>
        <trans-unit id="c3b838adfac99fd155c663831ad38556581e0407" translate="yes" xml:space="preserve">
          <source>Results returns the results of signature s, or nil.</source>
          <target state="translated">Результаты возвращают результаты подписи s,или nil.</target>
        </trans-unit>
        <trans-unit id="962f14cb7eca51d5151fcfbeb4ab3ed937db54aa" translate="yes" xml:space="preserve">
          <source>Return the most recent call to Scan as a []byte.</source>
          <target state="translated">Возврат последнего вызова на Сканирование в виде []байта.</target>
        </trans-unit>
        <trans-unit id="57f9933768794f845d000833d367d5698393211d" translate="yes" xml:space="preserve">
          <source>Reverse</source>
          <target state="translated">Reverse</target>
        </trans-unit>
        <trans-unit id="902e55a122fa4891a6dae083e18230ea968dc9a3" translate="yes" xml:space="preserve">
          <source>Reverse returns the reverse order for data.</source>
          <target state="translated">Обратный порядок возвращает обратный порядок для данных.</target>
        </trans-unit>
        <trans-unit id="78b0b4cb759dec2da3c6713767fbf6f4bc040c4d" translate="yes" xml:space="preserve">
          <source>Reverse returns the value of x with its bits in reversed order.</source>
          <target state="translated">Обратный ход возвращает значение x с его битами в обратном порядке.</target>
        </trans-unit>
        <trans-unit id="92de4737778eb41e55ca2f7a627a47fd6ba4a889" translate="yes" xml:space="preserve">
          <source>Reverse16</source>
          <target state="translated">Reverse16</target>
        </trans-unit>
        <trans-unit id="b383f837c66d7bdba479cd898a8ff90df6a54bdc" translate="yes" xml:space="preserve">
          <source>Reverse16 returns the value of x with its bits in reversed order.</source>
          <target state="translated">Реверс16 возвращает значение x с его битами в обратном порядке.</target>
        </trans-unit>
        <trans-unit id="bc5bc5fb62f24a53fcf7486ea47cb526c49ed16b" translate="yes" xml:space="preserve">
          <source>Reverse32</source>
          <target state="translated">Reverse32</target>
        </trans-unit>
        <trans-unit id="31e983ab5d2fdae281f62da27af16c6410c88366" translate="yes" xml:space="preserve">
          <source>Reverse32 returns the value of x with its bits in reversed order.</source>
          <target state="translated">Reverse32 возвращает значение x со своими битами в обратном порядке.</target>
        </trans-unit>
        <trans-unit id="4b8d738bc3f5b572852bef49d9d1b74649451478" translate="yes" xml:space="preserve">
          <source>Reverse64</source>
          <target state="translated">Reverse64</target>
        </trans-unit>
        <trans-unit id="0a95ddc6b008b1c60668050345ad2bbd0048d26d" translate="yes" xml:space="preserve">
          <source>Reverse64 returns the value of x with its bits in reversed order.</source>
          <target state="translated">Reverse64 возвращает значение x со своими битами в обратном порядке.</target>
        </trans-unit>
        <trans-unit id="8b7d623b04231c73d009937cc199213fab60a116" translate="yes" xml:space="preserve">
          <source>Reverse8</source>
          <target state="translated">Reverse8</target>
        </trans-unit>
        <trans-unit id="4e2cfa80f1f3211b8d7b8f97b9c866dc8e5602ee" translate="yes" xml:space="preserve">
          <source>Reverse8 returns the value of x with its bits in reversed order.</source>
          <target state="translated">Reverse8 возвращает значение x с его битами в обратном порядке.</target>
        </trans-unit>
        <trans-unit id="be39e968e6f8b02161cf145a91c2242f8ac3e738" translate="yes" xml:space="preserve">
          <source>ReverseBytes returns the value of x with its bytes in reversed order.</source>
          <target state="translated">ReverseBytes возвращает значение x с его байтами в обратном порядке.</target>
        </trans-unit>
        <trans-unit id="b3a8220fbdce3c882a295efbc513cc8d73cb1a7a" translate="yes" xml:space="preserve">
          <source>ReverseBytes16</source>
          <target state="translated">ReverseBytes16</target>
        </trans-unit>
        <trans-unit id="2a7c652af5267d559395a2d601cef862d0dc08f3" translate="yes" xml:space="preserve">
          <source>ReverseBytes16 returns the value of x with its bytes in reversed order.</source>
          <target state="translated">ReverseBytes16 возвращает значение x с его байтами в обратном порядке.</target>
        </trans-unit>
        <trans-unit id="0b3b6869428b45a4008a611a88e1d858c7f82ca5" translate="yes" xml:space="preserve">
          <source>ReverseBytes32</source>
          <target state="translated">ReverseBytes32</target>
        </trans-unit>
        <trans-unit id="bd4bbc4dc35b34c8851580c4ed26f1553540d805" translate="yes" xml:space="preserve">
          <source>ReverseBytes32 returns the value of x with its bytes in reversed order.</source>
          <target state="translated">ReverseBytes32 возвращает значение x с его байтами в обратном порядке.</target>
        </trans-unit>
        <trans-unit id="27b3c718307e25ebd0df6355d5ba2181fe72066f" translate="yes" xml:space="preserve">
          <source>ReverseBytes64</source>
          <target state="translated">ReverseBytes64</target>
        </trans-unit>
        <trans-unit id="2bfe4d5fab882bedb4ed52db5659be4b630cad79" translate="yes" xml:space="preserve">
          <source>ReverseBytes64 returns the value of x with its bytes in reversed order.</source>
          <target state="translated">ReverseBytes64 возвращает значение x с его байтами в обратном порядке.</target>
        </trans-unit>
        <trans-unit id="08e888d81afdf833be45fe65662c8198e86a5832" translate="yes" xml:space="preserve">
          <source>ReverseProxy</source>
          <target state="translated">ReverseProxy</target>
        </trans-unit>
        <trans-unit id="9bfcf9ccffddea8678782d891a9bd8387a2cdb0f" translate="yes" xml:space="preserve">
          <source>ReverseProxy is an HTTP Handler that takes an incoming request and sends it to another server, proxying the response back to the client.</source>
          <target state="translated">ReverseProxy-это HTTP обработчик,который принимает входящий запрос и отправляет его другому серверу,проксируя ответ обратно клиенту.</target>
        </trans-unit>
        <trans-unit id="36bf57062b0695082d5c3ab1cea707663eb8d688" translate="yes" xml:space="preserve">
          <source>RevokedCertificate represents the ASN.1 structure of the same name. See RFC 5280, section 5.1.</source>
          <target state="translated">Аннулированный сертификат представляет собой одноименную структуру ASN.1.См.RFC 5280,раздел 5.1.</target>
        </trans-unit>
        <trans-unit id="1dbb08e5127fb312affa46a438163965fc7ebf23" translate="yes" xml:space="preserve">
          <source>RightAlign returns a slice where the padding bits are at the beginning. The slice may share memory with the BitString.</source>
          <target state="translated">RightAlign возвращает фрагмент,в котором биты набивки находятся в начале.Фрагмент может совместно использовать память с BitString.</target>
        </trans-unit>
        <trans-unit id="86681d4d51562a20e98b2b7ff856763c761235e0" translate="yes" xml:space="preserve">
          <source>Ring.Do</source>
          <target state="translated">Ring.Do</target>
        </trans-unit>
        <trans-unit id="c3de3d65f1bf374c9d07b4dfcda75c2206063f2b" translate="yes" xml:space="preserve">
          <source>Ring.Len</source>
          <target state="translated">Ring.Len</target>
        </trans-unit>
        <trans-unit id="ef738e03a934b3cea0ed8b70a7545fe51b5d290c" translate="yes" xml:space="preserve">
          <source>Ring.Link</source>
          <target state="translated">Ring.Link</target>
        </trans-unit>
        <trans-unit id="7fd8ab417197e9dee9db859427b5d7f544203d42" translate="yes" xml:space="preserve">
          <source>Ring.Move</source>
          <target state="translated">Ring.Move</target>
        </trans-unit>
        <trans-unit id="0851656843c7ec1e30ec39e3f0f5e84ae6a75fcd" translate="yes" xml:space="preserve">
          <source>Ring.Next</source>
          <target state="translated">Ring.Next</target>
        </trans-unit>
        <trans-unit id="61b297ba7e636a60d4221303b63f5d9cc41422d9" translate="yes" xml:space="preserve">
          <source>Ring.Prev</source>
          <target state="translated">Ring.Prev</target>
        </trans-unit>
        <trans-unit id="d7d905b26d8d9e9d4ae570e8e8161e643805b969" translate="yes" xml:space="preserve">
          <source>Ring.Unlink</source>
          <target state="translated">Ring.Unlink</target>
        </trans-unit>
        <trans-unit id="1a9da6de639f9bb2699bfe42d158358d7d6e5dc9" translate="yes" xml:space="preserve">
          <source>Rollback aborts the transaction.</source>
          <target state="translated">Откат отменяет сделку.</target>
        </trans-unit>
        <trans-unit id="b1d06a98df3a5bd7537bc07af57648fbe210073d" translate="yes" xml:space="preserve">
          <source>RotateLeft returns the value of x rotated left by (k mod UintSize) bits. To rotate x right by k bits, call RotateLeft(x, -k).</source>
          <target state="translated">RotateLeft возвращает значение x,повернутое влево битами (k mod UintSize).Для поворота x вправо на k битов вызывается RotateLeft(x,-k).</target>
        </trans-unit>
        <trans-unit id="761f01b6be4cc6f5188ea10477b0dc7cd1161d8c" translate="yes" xml:space="preserve">
          <source>RotateLeft16</source>
          <target state="translated">RotateLeft16</target>
        </trans-unit>
        <trans-unit id="d66c06db349417bfddd607ad14fa9bf5a5638d62" translate="yes" xml:space="preserve">
          <source>RotateLeft16 returns the value of x rotated left by (k mod 16) bits. To rotate x right by k bits, call RotateLeft16(x, -k).</source>
          <target state="translated">RotateLeft16 возвращает значение x,повернутое влево битами (k mod 16).Для поворота x вправо на k битов вызывается RotateLeft16(x,-k).</target>
        </trans-unit>
        <trans-unit id="60bcbc4fb2bbce0ec43078cea8be747ff9281e19" translate="yes" xml:space="preserve">
          <source>RotateLeft32</source>
          <target state="translated">RotateLeft32</target>
        </trans-unit>
        <trans-unit id="c60016746c6ad6b197ec5092101071fc87f7021a" translate="yes" xml:space="preserve">
          <source>RotateLeft32 returns the value of x rotated left by (k mod 32) bits. To rotate x right by k bits, call RotateLeft32(x, -k).</source>
          <target state="translated">RotateLeft32 возвращает значение x,повернутое влево битами (k mod 32).Для поворота x вправо на k битов вызывается RotateLeft32(x,-k).</target>
        </trans-unit>
        <trans-unit id="6dc01719e1f445b08ee2ebc7136ef6822502932a" translate="yes" xml:space="preserve">
          <source>RotateLeft64</source>
          <target state="translated">RotateLeft64</target>
        </trans-unit>
        <trans-unit id="c0ff555090cb3bc9a90815cda1f96719ce3d40be" translate="yes" xml:space="preserve">
          <source>RotateLeft64 returns the value of x rotated left by (k mod 64) bits. To rotate x right by k bits, call RotateLeft64(x, -k).</source>
          <target state="translated">RotateLeft64 возвращает значение x,повернутое влево на биты (k mod 64).Для поворота x вправо на k бит необходимо вызвать RotateLeft64(x,-k).</target>
        </trans-unit>
        <trans-unit id="fdef633274845494879cbf0afeac8f854e3ba879" translate="yes" xml:space="preserve">
          <source>RotateLeft8</source>
          <target state="translated">RotateLeft8</target>
        </trans-unit>
        <trans-unit id="26ebe86c57d1d128d3a27bb9fd4358573f445da7" translate="yes" xml:space="preserve">
          <source>RotateLeft8 returns the value of x rotated left by (k mod 8) bits. To rotate x right by k bits, call RotateLeft8(x, -k).</source>
          <target state="translated">RotateLeft8 возвращает значение x,повернутое влево битами (k mod 8).Для поворота x вправо на k битов вызывается RotateLeft8(x,-k).</target>
        </trans-unit>
        <trans-unit id="ec7b59833520bb2b53fd4d44b3d581720b55c442" translate="yes" xml:space="preserve">
          <source>Round</source>
          <target state="translated">Round</target>
        </trans-unit>
        <trans-unit id="000868eccd1432acf77f6949a96b4844d59b1fce" translate="yes" xml:space="preserve">
          <source>Round operates on the time as an absolute duration since the zero time; it does not operate on the presentation form of the time. Thus, Round(Hour) may return a time with a non-zero minute, depending on the time's Location.</source>
          <target state="translated">Круг работает по времени как абсолютная продолжительность с нулевого времени;он не работает по форме представления времени.Таким образом,Round(Hour)может возвращать время с ненулевой минутой,в зависимости от местоположения времени.</target>
        </trans-unit>
        <trans-unit id="b948ea2f553b57093a9dabad37c8d45230573ca2" translate="yes" xml:space="preserve">
          <source>Round returns the nearest integer, rounding half away from zero.</source>
          <target state="translated">Округление возвращает ближайшее целое число,округляя половину от нуля.</target>
        </trans-unit>
        <trans-unit id="09b508228bc941d31ad58d40d683a414360f74b0" translate="yes" xml:space="preserve">
          <source>Round returns the result of rounding d to the nearest multiple of m. The rounding behavior for halfway values is to round away from zero. If the result exceeds the maximum (or minimum) value that can be stored in a Duration, Round returns the maximum (or minimum) duration. If m &amp;lt;= 0, Round returns d unchanged.</source>
          <target state="translated">Round возвращает результат округления d до ближайшего кратного m. Поведение округления для половинных значений - округление от нуля. Если результат превышает максимальное (или минимальное) значение, которое может быть сохранено в Duration, Round возвращает максимальную (или минимальную) продолжительность. Если m &amp;lt;= 0, Round возвращает d без изменений.</target>
        </trans-unit>
        <trans-unit id="46948003a0f2b7ed98f113a7c6a561fd40784b4d" translate="yes" xml:space="preserve">
          <source>Round returns the result of rounding t to the nearest multiple of d (since the zero time). The rounding behavior for halfway values is to round up. If d &amp;lt;= 0, Round returns t stripped of any monotonic clock reading but otherwise unchanged.</source>
          <target state="translated">Round возвращает результат округления t до ближайшего кратного d (с нулевого времени). Поведение для округления половинных значений - округление в большую сторону. Если d &amp;lt;= 0, Round возвращает t без каких-либо монотонных показаний часов, но в остальном без изменений.</target>
        </trans-unit>
        <trans-unit id="bd8a6768cc1684f5b293529415380ca31ee44b5b" translate="yes" xml:space="preserve">
          <source>RoundToEven</source>
          <target state="translated">RoundToEven</target>
        </trans-unit>
        <trans-unit id="721a33257fa34d285056f870605bb51c3b9a00a0" translate="yes" xml:space="preserve">
          <source>RoundToEven returns the nearest integer, rounding ties to even.</source>
          <target state="translated">RoundToEven возвращает ближайшее целое число,округляя связи с четными.</target>
        </trans-unit>
        <trans-unit id="31fa67ead55ff94cd48d5e48d25e6ab30cbcca05" translate="yes" xml:space="preserve">
          <source>RoundTrip implements the RoundTripper interface.</source>
          <target state="translated">RoundTrip реализует интерфейс RoundTripper.</target>
        </trans-unit>
        <trans-unit id="aef4d01bc99ecc3d07fd6dbc9d4b0127aaa57cd4" translate="yes" xml:space="preserve">
          <source>RoundTripper is an interface representing the ability to execute a single HTTP transaction, obtaining the Response for a given Request.</source>
          <target state="translated">RoundTripper представляет собой интерфейс,представляющий собой возможность выполнить одну HTTP-транзакцию,получив ответ на заданный запрос.</target>
        </trans-unit>
        <trans-unit id="14ab950eb98caa165c8e3b8a580c9eeda3c87fc0" translate="yes" xml:space="preserve">
          <source>RoundingMode</source>
          <target state="translated">RoundingMode</target>
        </trans-unit>
        <trans-unit id="e0448d85da96897c679953ae05b1d33acf337b63" translate="yes" xml:space="preserve">
          <source>RoundingMode determines how a Float value is rounded to the desired precision. Rounding may change the Float value; the rounding error is described by the Float's Accuracy.</source>
          <target state="translated">Режим округления определяет,как значение параметра Float округляется до нужной точности.Округление может изменить значение Float;погрешность округления описывается точностью Float.</target>
        </trans-unit>
        <trans-unit id="b1898ce5b72c9fe9acbd96617227555ca58001da" translate="yes" xml:space="preserve">
          <source>Row is the result of calling QueryRow to select a single row.</source>
          <target state="translated">Строка-это результат вызова QueryRow для выбора одной строки.</target>
        </trans-unit>
        <trans-unit id="52d0b35277ee4b2b66ec4016620c658d99c7b57a" translate="yes" xml:space="preserve">
          <source>Rows</source>
          <target state="translated">Rows</target>
        </trans-unit>
        <trans-unit id="40bc6f7b056d7162e958bb7c34f2141aad10960f" translate="yes" xml:space="preserve">
          <source>Rows are always in order of increasing entry.Address, but entry.Line may go forward or backward.</source>
          <target state="translated">Строки всегда располагаются в порядке возрастания входа,но запись может идти вперед или назад.</target>
        </trans-unit>
        <trans-unit id="136224253b0a1cede998fd8310adbf37059cd8b9" translate="yes" xml:space="preserve">
          <source>Rows is an iterator over an executed query's results.</source>
          <target state="translated">Строки-это итератор над результатами выполненного запроса.</target>
        </trans-unit>
        <trans-unit id="5bf0da8d1e143c858970004b1d4e4fc2c3190c46" translate="yes" xml:space="preserve">
          <source>Rows is the result of a query. Its cursor starts before the first row of the result set. Use Next to advance from row to row.</source>
          <target state="translated">Строки-это результат запроса.Его курсор запускается перед первой строкой результирующего набора.Для перехода из строки в строку используйте кнопку Далее.</target>
        </trans-unit>
        <trans-unit id="c7e43ca77abe23e5cf32ea7c3a359b9f55d612a0" translate="yes" xml:space="preserve">
          <source>RowsAffected implements Result for an INSERT or UPDATE operation which mutates a number of rows.</source>
          <target state="translated">RowsAffected орудия Результат для операции INSERT или UPDATE,которая мутирует несколько рядов.</target>
        </trans-unit>
        <trans-unit id="ef8ccf0ef3b6629b0198be9228cd5d4456951fd1" translate="yes" xml:space="preserve">
          <source>RowsColumnTypeDatabaseTypeName may be implemented by Rows. It should return the database system type name without the length. Type names should be uppercase. Examples of returned types: &quot;VARCHAR&quot;, &quot;NVARCHAR&quot;, &quot;VARCHAR2&quot;, &quot;CHAR&quot;, &quot;TEXT&quot;, &quot;DECIMAL&quot;, &quot;SMALLINT&quot;, &quot;INT&quot;, &quot;BIGINT&quot;, &quot;BOOL&quot;, &quot;[]BIGINT&quot;, &quot;JSONB&quot;, &quot;XML&quot;, &quot;TIMESTAMP&quot;.</source>
          <target state="translated">RowsColumnTypeDatabaseTypeName может быть реализован с помощью Rows.Оно должно возвращать имя системного типа БД без длины.Имена типов должны быть заглавными.Примеры возвращаемых типов:&quot;VARCHAR&quot;,&quot;NVARCHAR&quot;,&quot;VARCHAR2&quot;,&quot;CHAR&quot;,&quot;TEXT&quot;,&quot;DECIMAL&quot;,&quot;SMALLINT&quot;,&quot;INT&quot;,&quot;BIGINT&quot;,&quot;BOOL&quot;,&quot;[]BIGINT&quot;,&quot;JSONB&quot;,&quot;XML&quot;,&quot;TIMESTAMP&quot;.</target>
        </trans-unit>
        <trans-unit id="3c91b4c84603ef829584c3342618f9e341f34eef" translate="yes" xml:space="preserve">
          <source>RowsColumnTypeLength may be implemented by Rows. It should return the length of the column type if the column is a variable length type. If the column is not a variable length type ok should return false. If length is not limited other than system limits, it should return math.MaxInt64. The following are examples of returned values for various types:</source>
          <target state="translated">RowsColumnTypeLength может быть реализован с помощью Rows.Она должна возвращать длину типа столбца,если столбец является типом переменной длины.Если столбец не является типом длины переменной,ok должен возвращать false.Если длина не ограничена,кроме системных ограничений,возвращается math.MaxInt64.Ниже приведены примеры возвращаемых значений для различных типов:</target>
        </trans-unit>
        <trans-unit id="e25b9be843083730384947899329e16d7e8ce2ee" translate="yes" xml:space="preserve">
          <source>RowsColumnTypeNullable may be implemented by Rows. The nullable value should be true if it is known the column may be null, or false if the column is known to be not nullable. If the column nullability is unknown, ok should be false.</source>
          <target state="translated">RowsColumnTypeNullable может быть реализован с помощью Rows.Нулевое значение должно быть true,если известно,что колонка может быть null,или false,если известно,что колонка не является nullable.Если nullability колонки неизвестно,ok должно быть false.</target>
        </trans-unit>
        <trans-unit id="11e1119cb21771faadd92c0fac63385e0fabd647" translate="yes" xml:space="preserve">
          <source>RowsColumnTypePrecisionScale may be implemented by Rows. It should return the precision and scale for decimal types. If not applicable, ok should be false. The following are examples of returned values for various types:</source>
          <target state="translated">RowsColumnTypePrecisionScale может быть реализован с помощью Rows.Она должна возвращать точность и масштаб для десятичных типов.Если это неприменимо,то ok должен быть ложным.Ниже приведены примеры возвращаемых значений для различных типов:</target>
        </trans-unit>
        <trans-unit id="c4ef56c355e3d98c76299376ceea4adea3479a58" translate="yes" xml:space="preserve">
          <source>RowsColumnTypeScanType may be implemented by Rows. It should return the value type that can be used to scan types into. For example, the database column type &quot;bigint&quot; this should return &quot;reflect.TypeOf(int64(0))&quot;.</source>
          <target state="translated">RowsColumnTypeScanType может быть реализован с помощью Rows.Он должен возвращать тип значения,которое может быть использовано для сканирования типов.Например,тип столбца базы данных &quot;bigint&quot;,который должен возвращать &quot;reflect.TypeOf(int64(0))&quot;.</target>
        </trans-unit>
        <trans-unit id="7efce4893f3ac361f87721da26fe098b878a1c27" translate="yes" xml:space="preserve">
          <source>RowsNextResultSet extends the Rows interface by providing a way to signal the driver to advance to the next result set.</source>
          <target state="translated">RowsNextResultSet расширяет интерфейс Rows,обеспечивая способ сигнализации драйвера для перехода к следующему результирующему набору результатов.</target>
        </trans-unit>
        <trans-unit id="1ab76c953a9e273e85fb13e73235ab1aa106b9cd" translate="yes" xml:space="preserve">
          <source>Rsh sets z = x &amp;gt;&amp;gt; n and returns z.</source>
          <target state="translated">Rsh устанавливает z = x &amp;gt;&amp;gt; n и возвращает z.</target>
        </trans-unit>
        <trans-unit id="64578d8b2d51c5abcc22005302c8d44dd6d930ad" translate="yes" xml:space="preserve">
          <source>Run benchmarks f as a subbenchmark with the given name. It reports whether there were any failures.</source>
          <target state="translated">Запустите бенчмаркинг f в качестве подмножества с заданным именем.Он сообщает,были ли какие-нибудь сбои.</target>
        </trans-unit>
        <trans-unit id="872b6e9fc5c925d028b4808b5136d4cf35164f22" translate="yes" xml:space="preserve">
          <source>Run does not return until parallel subtests have completed, providing a way to clean up after a group of parallel tests:</source>
          <target state="translated">Запуск не возвращается до тех пор,пока не будут завершены параллельные подтесты,обеспечивая возможность очистки после группы параллельных тестов:</target>
        </trans-unit>
        <trans-unit id="f8c556db4b76966a7511e9f2b360cd616f36f626" translate="yes" xml:space="preserve">
          <source>Run may be called simultaneously from multiple goroutines, but all such calls must return before the outer test function for t returns.</source>
          <target state="translated">Запуск может быть вызван одновременно у нескольких горутинов,но все такие вызовы должны вернуться до того,как функция внешнего теста для t вернется.</target>
        </trans-unit>
        <trans-unit id="d90bfc177fd90c93bbd1a663aa066ee65d25e1b1" translate="yes" xml:space="preserve">
          <source>Run runs f as a subtest of t called name. It runs f in a separate goroutine and blocks until f returns or calls t.Parallel to become a parallel test. Run reports whether f succeeded (or at least did not fail before calling t.Parallel).</source>
          <target state="translated">Run бежит f,как тончайший из t,называемый именем.Он пробегает f в отдельном горутине и блокируется до тех пор,пока f не вернется или не вызовет t.Parallel,чтобы стать параллельным тестом.Выполняется отчет о том,удалось ли f (или,по крайней мере,не вышло из строя до вызова t.Parallel).</target>
        </trans-unit>
        <trans-unit id="53e0451894d3b3781ea079b9077c47afbf558128" translate="yes" xml:space="preserve">
          <source>Run runs the tests. It returns an exit code to pass to os.Exit.</source>
          <target state="translated">Запускай тесты.Он возвращает код выхода для передачи в os.Exit.</target>
        </trans-unit>
        <trans-unit id="48c893a581570ffe26dfe952410c12f6cdc2e260" translate="yes" xml:space="preserve">
          <source>Run starts the specified command and waits for it to complete.</source>
          <target state="translated">Запуск запускает указанную команду и ждет ее завершения.</target>
        </trans-unit>
        <trans-unit id="452df5dd646b599a67dd36e4b5527c206ddf15e5" translate="yes" xml:space="preserve">
          <source>RunParallel runs a benchmark in parallel. It creates multiple goroutines and distributes b.N iterations among them. The number of goroutines defaults to GOMAXPROCS. To increase parallelism for non-CPU-bound benchmarks, call SetParallelism before RunParallel. RunParallel is usually used with the go test -cpu flag.</source>
          <target state="translated">RunParallel параллельно запускает бенчмарк.Он создает несколько горутинов и распределяет между ними b.N итерации.Количество goroutines по умолчанию для GOMAXPROCS.Для увеличения параллелизма для бенчмарков,не связанных с CPU,перед запуском RunParallel следует обратиться к SetParallelism.RunParallel обычно используется с флагом go test -cpu.</target>
        </trans-unit>
        <trans-unit id="c1304d4ae46895f99bd865fe49bce5376fb7e0b6" translate="yes" xml:space="preserve">
          <source>RuneCount</source>
          <target state="translated">RuneCount</target>
        </trans-unit>
        <trans-unit id="ed1038ffbfe375ac70c3f1a1ca67f29234afffbf" translate="yes" xml:space="preserve">
          <source>RuneCount returns the number of runes in p. Erroneous and short encodings are treated as single runes of width 1 byte.</source>
          <target state="translated">RuneCount возвращает количество рун в п.Ошибочные и короткие кодировки рассматриваются как единичные руны шириной 1 байт.</target>
        </trans-unit>
        <trans-unit id="78c4e1dde9ab6b8f5586f9612a115ee5d698d2fb" translate="yes" xml:space="preserve">
          <source>RuneCountInString</source>
          <target state="translated">RuneCountInString</target>
        </trans-unit>
        <trans-unit id="f740d84fa32707ddc183ab07c7c8f221a896cf18" translate="yes" xml:space="preserve">
          <source>RuneCountInString is like RuneCount but its input is a string.</source>
          <target state="translated">RuneCountInString похож на RuneCount,но его входом является строка.</target>
        </trans-unit>
        <trans-unit id="7f39387ee01e0d6561f94fb1cc196d068d979052" translate="yes" xml:space="preserve">
          <source>RuneLen</source>
          <target state="translated">RuneLen</target>
        </trans-unit>
        <trans-unit id="da827d364b8d785022152482b581a5b08129882b" translate="yes" xml:space="preserve">
          <source>RuneLen returns the number of bytes required to encode the rune. It returns -1 if the rune is not a valid value to encode in UTF-8.</source>
          <target state="translated">RuneLen возвращает количество байт,необходимое для кодирования руны.Возвращает -1,если руна не является действительным значением для кодирования в UTF-8.</target>
        </trans-unit>
        <trans-unit id="cf36c219da8d056dc79efd005cdbeaf40198de2a" translate="yes" xml:space="preserve">
          <source>RuneReader is the interface that wraps the ReadRune method.</source>
          <target state="translated">RuneReader-это интерфейс,обёртывающий метод ReadRune.</target>
        </trans-unit>
        <trans-unit id="8dce52bc0fa438508ccfe7940691e478794d8014" translate="yes" xml:space="preserve">
          <source>RuneScanner is the interface that adds the UnreadRune method to the basic ReadRune method.</source>
          <target state="translated">RuneScanner-это интерфейс,который добавляет метод UnreadRune к основному методу ReadRune.</target>
        </trans-unit>
        <trans-unit id="48c879258018813f4ec13050feaaab65a67d910b" translate="yes" xml:space="preserve">
          <source>RuneStart</source>
          <target state="translated">RuneStart</target>
        </trans-unit>
        <trans-unit id="6b79de7db8117808de36133366c8ef414e9c5c82" translate="yes" xml:space="preserve">
          <source>RuneStart reports whether the byte could be the first byte of an encoded, possibly invalid rune. Second and subsequent bytes always have the top two bits set to 10.</source>
          <target state="translated">RuneStart сообщает,может ли байт быть первым байтом закодированной,возможно,недействительной руны.Второй и последующие байты всегда имеют два верхних бита,установленных в 10.</target>
        </trans-unit>
        <trans-unit id="6756bd3e1a442e2ce0d16a235b1d5c8c2882b1e6" translate="yes" xml:space="preserve">
          <source>Runes</source>
          <target state="translated">Runes</target>
        </trans-unit>
        <trans-unit id="9a62b7b5f90f9e424bb04160b8de2eb558ee92a9" translate="yes" xml:space="preserve">
          <source>Runes interprets s as a sequence of UTF-8-encoded code points. It returns a slice of runes (Unicode code points) equivalent to s.</source>
          <target state="translated">Руны интерпретируют s как последовательность точек кода,закодированных в UTF-8.Она возвращает кусок руны (точки кода Юникода),эквивалентный s.</target>
        </trans-unit>
        <trans-unit id="f5d45a3fe840544aad462798c4e4ed8942f7ef58" translate="yes" xml:space="preserve">
          <source>Running &quot;go vet&quot; can help find uses of Pointer that do not conform to these patterns, but silence from &quot;go vet&quot; is not a guarantee that the code is valid.</source>
          <target state="translated">Запуск &quot;go vet&quot; может помочь найти использование указателя,который не соответствует этим шаблонам,но молчание от &quot;go vet&quot; не является гарантией того,что код действителен.</target>
        </trans-unit>
        <trans-unit id="aeacdbd801cd3a6c88be9cbc91df0dca2b46aba8" translate="yes" xml:space="preserve">
          <source>SHA-1 is cryptographically broken and should not be used for secure applications.</source>
          <target state="translated">SHA-1 криптографически сломан и не должен использоваться в защищенных приложениях.</target>
        </trans-unit>
        <trans-unit id="7b3caa78fa594eb19ef5d1955f9e6f4a06aac1d4" translate="yes" xml:space="preserve">
          <source>SIGPIPE</source>
          <target state="translated">SIGPIPE</target>
        </trans-unit>
        <trans-unit id="91d8535876524df724c0df972b3fd914eb03fb2f" translate="yes" xml:space="preserve">
          <source>SameFile reports whether fi1 and fi2 describe the same file. For example, on Unix this means that the device and inode fields of the two underlying structures are identical; on other systems the decision may be based on the path names. SameFile only applies to results returned by this package's Stat. It returns false in other cases.</source>
          <target state="translated">SameFile сообщает,описывают ли fi1 и fi2 один и тот же файл.Например,в Unix это означает,что поля устройства и входные поля двух базовых структур идентичны;в других системах решение может быть основано на именах путей.SameFile применяется только к результатам,возвращаемым в этом пакете Stat.В других случаях он возвращает false.</target>
        </trans-unit>
        <trans-unit id="9f57e34c6960ba52fd743b2bc0ff1557eb707bd2" translate="yes" xml:space="preserve">
          <source>SameSite allows a server to define a cookie attribute making it impossible for the browser to send this cookie along with cross-site requests. The main goal is to mitigate the risk of cross-origin information leakage, and provide some protection against cross-site request forgery attacks.</source>
          <target state="translated">SameSite позволяет серверу определить атрибут cookie,что делает невозможной отправку браузером этого cookie вместе с межсайтовыми запросами.Главной целью является снижение риска утечки информации межсайтового характера,а также обеспечение некоторой защиты от атак типа &quot;подделка&quot; межсайтовых запросов.</target>
        </trans-unit>
        <trans-unit id="b8abf172daab8b3ea3c6865151b033d1cd5e837c" translate="yes" xml:space="preserve">
          <source>Scan adds line information to the file added to the file set with Init. Token positions are relative to that file and thus relative to the file set.</source>
          <target state="translated">Сканирование добавляет информацию о строках к файлу,добавленному в набор файлов с помощью Init.Позиции токена относительно этого файла и,следовательно,относительно набора файлов.</target>
        </trans-unit>
        <trans-unit id="e4ac4597c96634ebcbf4b7a158793f756f373f9c" translate="yes" xml:space="preserve">
          <source>Scan advances the Scanner to the next token, which will then be available through the Bytes or Text method. It returns false when the scan stops, either by reaching the end of the input or an error. After Scan returns false, the Err method will return any error that occurred during scanning, except that if it was io.EOF, Err will return nil. Scan panics if the split function returns too many empty tokens without advancing the input. This is a common error mode for scanners.</source>
          <target state="translated">Сканер перейдет к следующему маркеру,который будет доступен через байтовый или текстовый метод.Он возвращает false,когда сканирование останавливается,либо по достижении конца входа,либо по ошибке.После того,как Scan возвращает false,метод Err вернет любую ошибку,которая произошла во время сканирования,за исключением того,что если это был io.EOF,Err вернет ноль.Сканирование паники,если функция split возвращает слишком много пустых маркеров без продвижения входа.Это обычный режим ошибки для сканеров.</target>
        </trans-unit>
        <trans-unit id="19b1c6ecbd861a4833fc5e32bbb8df547210090f" translate="yes" xml:space="preserve">
          <source>Scan also converts between string and numeric types, as long as no information would be lost. While Scan stringifies all numbers scanned from numeric database columns into *string, scans into numeric types are checked for overflow. For example, a float64 with value 300 or a string with value &quot;300&quot; can scan into a uint16, but not into a uint8, though float64(255) or &quot;255&quot; can scan into a uint8. One exception is that scans of some float64 numbers to strings may lose information when stringifying. In general, scan floating point columns into *float64.</source>
          <target state="translated">Сканирование также преобразует между строковыми и числовыми типами до тех пор,пока информация не будет потеряна.В то время как строка Scan проверяет все числа,отсканированные из столбцов числовой базы данных на *строку,сканирование на числовые типы проверяется на переполнение.Например,float64 со значением 300 или строка со значением &quot;300&quot; может сканировать в uint16,но не в uint8,хотя float64(255)или &quot;255&quot; может сканировать в uint8.Исключением является то,что при сканировании некоторых чисел с плавающей точкой float64 в строки может теряться информация при строковой обработке.В общем случае,сканирование столбцов с плавающей точкой в *float64.</target>
        </trans-unit>
        <trans-unit id="feb542d2e67b91b0880c1fd1b4cf7b50af77bd5b" translate="yes" xml:space="preserve">
          <source>Scan can also convert a cursor returned from a query, such as &quot;select cursor(select * from my_table) from dual&quot;, into a *Rows value that can itself be scanned from. The parent select query will close any cursor *Rows if the parent *Rows is closed.</source>
          <target state="translated">Сканирование также может преобразовать курсор,возвращаемый из запроса,например,&quot;select cursor(select*from my_table)from double&quot;,в *Rows значение,которое само по себе может быть отсканировано.Родительский выборный запрос закроет любой курсор *Rows,если родительский *Rows закрыт.</target>
        </trans-unit>
        <trans-unit id="48ec4d9dec15d05d875f1baa84e9dcd1d7cc9f07" translate="yes" xml:space="preserve">
          <source>Scan converts columns read from the database into the following common Go types and special types provided by the sql package:</source>
          <target state="translated">Сканирование преобразует колонки,считанные из базы данных,в следующие распространенные типы Go и специальные типы,предоставляемые пакетом sql:</target>
        </trans-unit>
        <trans-unit id="2677a1f2dd5662fd0ec43cba40359a57293f1867" translate="yes" xml:space="preserve">
          <source>Scan copies the columns from the matched row into the values pointed at by dest. See the documentation on Rows.Scan for details. If more than one row matches the query, Scan uses the first row and discards the rest. If no row matches the query, Scan returns ErrNoRows.</source>
          <target state="translated">Сканирование копирует колонки из соответствующей строки в значения,на которые указывает пункт назначения.Подробнее см.документацию на Rows.Scan.Если запрос совпадает более чем с одной строкой,Сканировать использует первую строку,а остальные отбрасывает.Если ни одна строка не соответствует запросу,Сканировать возвращает ErrNoRows.</target>
        </trans-unit>
        <trans-unit id="d701545494296850286215953fde0ddf540061d1" translate="yes" xml:space="preserve">
          <source>Scan copies the columns in the current row into the values pointed at by dest. The number of values in dest must be the same as the number of columns in Rows.</source>
          <target state="translated">Сканирование копирует столбцы в текущей строке в значения,на которые указывает пункт назначения.Количество значений в dest должно совпадать с количеством столбцов в строках.</target>
        </trans-unit>
        <trans-unit id="0a799e57e8d283a9aa1ec133950cd6bd3e127332" translate="yes" xml:space="preserve">
          <source>Scan implements the Scanner interface.</source>
          <target state="translated">Сканер реализует интерфейс сканера.</target>
        </trans-unit>
        <trans-unit id="bd92cac731a36521f9119e135b2c47485aabb150" translate="yes" xml:space="preserve">
          <source>Scan is a support routine for fmt.Scanner. It accepts the formats 'e', 'E', 'f', 'F', 'g', 'G', and 'v'. All formats are equivalent.</source>
          <target state="translated">Сканирование является рутиной поддержки fmt.Scanner.Он принимает форматы 'e','E','f','F','g','G' и 'v'.Все форматы эквивалентны.</target>
        </trans-unit>
        <trans-unit id="d953d557a4046bfc8df6c55ce44c304f6ff14a59" translate="yes" xml:space="preserve">
          <source>Scan is a support routine for fmt.Scanner; it sets z to the value of the scanned number. It accepts formats whose verbs are supported by fmt.Scan for floating point values, which are: 'b' (binary), 'e', 'E', 'f', 'F', 'g' and 'G'. Scan doesn't handle &amp;plusmn;Inf.</source>
          <target state="translated">Сканирование - это процедура поддержки fmt.Scanner; он устанавливает z равным значению отсканированного числа. Он принимает форматы, глаголы которых поддерживаются fmt.Scan для значений с плавающей запятой, а именно: 'b' (двоичный), 'e', ​​'E', 'f', 'F', 'g' и 'G'. Сканирование не обрабатывает &amp;plusmn; Инф.</target>
        </trans-unit>
        <trans-unit id="ac6efbbbf8b516bb14977cb03cef43746936b2f5" translate="yes" xml:space="preserve">
          <source>Scan is a support routine for fmt.Scanner; it sets z to the value of the scanned number. It accepts the formats 'b' (binary), 'o' (octal), 'd' (decimal), 'x' (lowercase hexadecimal), and 'X' (uppercase hexadecimal).</source>
          <target state="translated">Сканирование-это вспомогательная рутина для fmt.Scanner;она устанавливает z в значение отсканированного числа.Он принимает форматы 'b' (двоичный),'o' (восьмеричный),'d' (десятичный),'x' (строчный шестнадцатеричный)и 'X' (прописной шестнадцатеричный).</target>
        </trans-unit>
        <trans-unit id="386a7678b7de663dffac69cf7ab3e1a7092be8f9" translate="yes" xml:space="preserve">
          <source>Scan reads the next token or Unicode character from source and returns it. It only recognizes tokens t for which the respective Mode bit (1&amp;lt;&amp;lt;-t) is set. It returns EOF at the end of the source. It reports scanner errors (read and token errors) by calling s.Error, if not nil; otherwise it prints an error message to os.Stderr.</source>
          <target state="translated">Сканирование считывает следующий токен или символ Unicode из источника и возвращает его. Он распознает только токены t, для которых установлен соответствующий бит режима (1 &amp;lt;&amp;lt; - t). Он возвращает EOF в конце источника. Он сообщает об ошибках сканера (ошибки чтения и токена), вызывая s.Error, если не nil; в противном случае он выводит сообщение об ошибке в os.Stderr.</target>
        </trans-unit>
        <trans-unit id="981608b22833d116739df1bad639bfec043f4338" translate="yes" xml:space="preserve">
          <source>Scan scans text read from standard input, storing successive space-separated values into successive arguments. Newlines count as space. It returns the number of items successfully scanned. If that is less than the number of arguments, err will report why.</source>
          <target state="translated">Сканирование сканирует текст,считанный со стандартного входа,сохраняя последовательные значения,разделенные пробелами,в последовательных аргументах.Новые строки считаются пробелами.Возвращает количество успешно отсканированных элементов.Если это меньше,чем количество аргументов,то err сообщит почему.</target>
        </trans-unit>
        <trans-unit id="9421db6432c3608ab7d6333584635bf58a2d9300" translate="yes" xml:space="preserve">
          <source>Scan scans the next token and returns the token position, the token, and its literal string if applicable. The source end is indicated by token.EOF.</source>
          <target state="translated">Сканирование сканирует следующий маркер и возвращает позицию маркера,маркер и его буквальную строку,если это применимо.Конец исходного текста обозначается token.EOF.</target>
        </trans-unit>
        <trans-unit id="b3d5e9556bfff0957b67d0485be76ef988e69293" translate="yes" xml:space="preserve">
          <source>Scan, Fscan, Sscan treat newlines in the input as spaces.</source>
          <target state="translated">Сканирование,Fscan,Sscan рассматривают новые строки на входе как пробелы.</target>
        </trans-unit>
        <trans-unit id="f2ef262aa067e44dfcde945e7bebf0433b1baaed" translate="yes" xml:space="preserve">
          <source>ScanBytes is a split function for a Scanner that returns each byte as a token.</source>
          <target state="translated">ScanBytes-это разделенная функция для сканера,которая возвращает каждый байт в качестве маркера.</target>
        </trans-unit>
        <trans-unit id="d509b35e48ef6a5d396ee01678b179a959774867" translate="yes" xml:space="preserve">
          <source>ScanLines is a split function for a Scanner that returns each line of text, stripped of any trailing end-of-line marker. The returned line may be empty. The end-of-line marker is one optional carriage return followed by one mandatory newline. In regular expression notation, it is `\r?\n`. The last non-empty line of input will be returned even if it has no newline.</source>
          <target state="translated">ScanLines-это разделенная функция для сканера,которая возвращает каждую строку текста,отсеченную от любого маркера конца строки.Возвращаемая строка может быть пустой.Маркер концевой линии-это один дополнительный возврат каретки,за которым следует одна обязательная новая линия.В обозначении регулярных выражений это `\r?\n`.Последняя непустая строка ввода будет возвращена,даже если в ней нет новой строки.</target>
        </trans-unit>
        <trans-unit id="b4049bc82d2e16ae520fd9c175cc98d3e8214592" translate="yes" xml:space="preserve">
          <source>ScanRunes is a split function for a Scanner that returns each UTF-8-encoded rune as a token. The sequence of runes returned is equivalent to that from a range loop over the input as a string, which means that erroneous UTF-8 encodings translate to U+FFFD = &quot;\xef\xbf\xbd&quot;. Because of the Scan interface, this makes it impossible for the client to distinguish correctly encoded replacement runes from encoding errors.</source>
          <target state="translated">ScanRunes-это разделенная функция для сканера,которая возвращает каждую руну в кодировке UTF-8 в качестве токена.Последовательность возвращаемых рун эквивалентна циклу из диапазона по входу в виде строки,что означает,что ошибочные кодировки в кодировке UTF-8 переводятся в U+FFFD=&quot;\xef\xbf\xbd&quot;.Из-за интерфейса Scan это делает невозможным для клиента отличить правильно закодированные заменяющие руны от ошибок кодирования.</target>
        </trans-unit>
        <trans-unit id="f4641d488fdcb83f61b3c11fd542f4c6a3c4ffa5" translate="yes" xml:space="preserve">
          <source>ScanState represents the scanner state passed to custom scanners. Scanners may do rune-at-a-time scanning or ask the ScanState to discover the next space-delimited token.</source>
          <target state="translated">ScanState представляет собой состояние сканера,переданное пользовательским сканерам.Сканеры могут выполнять сканирование по расписанию или запрашивать ScanState,чтобы обнаружить следующий маркер,разделенный пробелом.</target>
        </trans-unit>
        <trans-unit id="59161b57fccdcbdd902cc6d57c2979e0dc44f79e" translate="yes" xml:space="preserve">
          <source>ScanType returns a Go type suitable for scanning into using Rows.Scan. If a driver does not support this property ScanType will return the type of an empty interface.</source>
          <target state="translated">ScanType возвращает тип Go,подходящий для сканирования с использованием Rows.Scan.Если драйвер не поддерживает это свойство,ScanType вернет тип пустого интерфейса.</target>
        </trans-unit>
        <trans-unit id="faa25d7e517bfa0b7ebed36b40faf73e8faf8ace" translate="yes" xml:space="preserve">
          <source>ScanWords is a split function for a Scanner that returns each space-separated word of text, with surrounding spaces deleted. It will never return an empty string. The definition of space is set by unicode.IsSpace.</source>
          <target state="translated">ScanWords-это разделенная функция для сканера,которая возвращает каждое слово текста,разделенное пробелами,с удалением окружающих пробелов.Она никогда не вернет пустую строку.Определение пробела задается юникодом.IsSpace.</target>
        </trans-unit>
        <trans-unit id="bc0d545831527f222a939e3851bf7f5c1605d659" translate="yes" xml:space="preserve">
          <source>Scanf scans text read from standard input, storing successive space-separated values into successive arguments as determined by the format. It returns the number of items successfully scanned. If that is less than the number of arguments, err will report why. Newlines in the input must match newlines in the format. The one exception: the verb %c always scans the next rune in the input, even if it is a space (or tab etc.) or newline.</source>
          <target state="translated">Scanf сканирует текст,считанный со стандартного входа,сохраняя последовательные значения,разделенные пробелами,в последовательных аргументах,определяемых форматом.Возвращает количество успешно отсканированных элементов.Если это меньше,чем количество аргументов,то err сообщит почему.Новые строки во входном тексте должны совпадать с новыми строками в формате.Единственное исключение:глагол %c всегда сканирует следующую руну во входных данных,даже если это пробел (или закладка и т.д.)или новая строка.</target>
        </trans-unit>
        <trans-unit id="6f640beb056a4e8e9aa6bfcd8d1f5bf1b4feaaee" translate="yes" xml:space="preserve">
          <source>Scanf, Fscanf, and Sscanf parse the arguments according to a format string, analogous to that of Printf. In the text that follows, 'space' means any Unicode whitespace character except newline.</source>
          <target state="translated">Scanf,Fscanf и Sscanf разбирают аргументы в соответствии со строкой формата,аналогичной Printf.В следующем тексте 'пробел' означает любой символ пробела Юникода,кроме newline.</target>
        </trans-unit>
        <trans-unit id="c8ed7e72e9070ffbdd1df56f018a211791f2dcc9" translate="yes" xml:space="preserve">
          <source>Scanln is similar to Scan, but stops scanning at a newline and after the final item there must be a newline or EOF.</source>
          <target state="translated">Scanln аналогичен Scanln,но останавливает сканирование на новой строке и после конечного элемента должна быть новая строка или EOF.</target>
        </trans-unit>
        <trans-unit id="22a932411390fa7368633b6d040508332e0196e9" translate="yes" xml:space="preserve">
          <source>Scanln, Fscanln and Sscanln stop scanning at a newline and require that the items be followed by a newline or EOF.</source>
          <target state="translated">Scanln,Fscanln и Sscanln останавливают сканирование на новой строке и требуют,чтобы за этими пунктами следовала новая строка или EOF.</target>
        </trans-unit>
        <trans-unit id="01c8580ef4911b472b2f5804014f5bd82d1af7aa" translate="yes" xml:space="preserve">
          <source>Scanner (Custom)</source>
          <target state="translated">Сканер (пользовательский)</target>
        </trans-unit>
        <trans-unit id="1d4892a40553aaa21bb91693fe76c51b9f51e530" translate="yes" xml:space="preserve">
          <source>Scanner (EmptyFinalToken)</source>
          <target state="translated">Сканер (EmptyFinalToken)</target>
        </trans-unit>
        <trans-unit id="d1ca38099d8459b3cc3f6b48eaf9fc6b340ae9b4" translate="yes" xml:space="preserve">
          <source>Scanner (Lines)</source>
          <target state="translated">Сканер (Lines)</target>
        </trans-unit>
        <trans-unit id="ab67b93c24c839ac0830f79b29ad7b412a9dc7b4" translate="yes" xml:space="preserve">
          <source>Scanner (Words)</source>
          <target state="translated">Сканер (Слова)</target>
        </trans-unit>
        <trans-unit id="2192924325d3946492271abc8671373e1f38daa1" translate="yes" xml:space="preserve">
          <source>Scanner is an interface used by Scan.</source>
          <target state="translated">Сканер-это интерфейс,используемый сканером.</target>
        </trans-unit>
        <trans-unit id="16f1f8a9cae9f1e07478a7953ec158b0c2b03d9c" translate="yes" xml:space="preserve">
          <source>Scanner is implemented by any value that has a Scan method, which scans the input for the representation of a value and stores the result in the receiver, which must be a pointer to be useful. The Scan method is called for any argument to Scan, Scanf, or Scanln that implements it.</source>
          <target state="translated">Сканер реализован любым значением,которое имеет метод сканирования,который сканирует вход на предмет представления значения и сохраняет результат в приемнике,который должен быть указателем,чтобы быть полезным.Метод Scan вызывается для любого аргумента Scan,Scanf или Scanln,который его реализует.</target>
        </trans-unit>
        <trans-unit id="76f47cb3079e4595ce1c03abbd158345ae636c90" translate="yes" xml:space="preserve">
          <source>Scanner provides a convenient interface for reading data such as a file of newline-delimited lines of text. Successive calls to the Scan method will step through the 'tokens' of a file, skipping the bytes between the tokens. The specification of a token is defined by a split function of type SplitFunc; the default split function breaks the input into lines with line termination stripped. Split functions are defined in this package for scanning a file into lines, bytes, UTF-8-encoded runes, and space-delimited words. The client may instead provide a custom split function.</source>
          <target state="translated">Сканер предоставляет удобный интерфейс для чтения данных,например,файла строк текста,разделенных на новые строки.Последовательные вызовы метода Сканирование будут проходить через &quot;маркеры&quot; файла,пропуская байты между маркерами.Спецификация лексемы определяется функцией разделения типа SplitFunc;функция разделения по умолчанию разбивает входные данные на строки с обрывом окончания строки.Функции разделения определяются в данном пакете для сканирования файла на строки,байты,руны в кодировке UTF-8 и слова,разделенные пробелами.Вместо этого клиент может предоставить пользовательскую функцию разделения.</target>
        </trans-unit>
        <trans-unit id="221c21d253261d097c5eddd34e07f0e854f9f8be" translate="yes" xml:space="preserve">
          <source>Scanner.Bytes</source>
          <target state="translated">Scanner.Bytes</target>
        </trans-unit>
        <trans-unit id="db2650dfa50b9653ed3b24b83e400aa246e21e57" translate="yes" xml:space="preserve">
          <source>Scanner.Scan</source>
          <target state="translated">Scanner.Scan</target>
        </trans-unit>
        <trans-unit id="e230f66cb2480e61c70e7940e1168e3d3dc1b2cf" translate="yes" xml:space="preserve">
          <source>Scanning</source>
          <target state="translated">Scanning</target>
        </trans-unit>
        <trans-unit id="0e43a71fd5dc304b08b8c37610739914b52545a4" translate="yes" xml:space="preserve">
          <source>Scanning stops if the function returns an error, in which case some of the input may be discarded.</source>
          <target state="translated">Сканирование прекращается,если функция возвращает ошибку,в этом случае часть входа может быть отброшена.</target>
        </trans-unit>
        <trans-unit id="d3672319a15266023841ffc344b2b9ae68437119" translate="yes" xml:space="preserve">
          <source>Scanning stops unrecoverably at EOF, the first I/O error, or a token too large to fit in the buffer. When a scan stops, the reader may have advanced arbitrarily far past the last token. Programs that need more control over error handling or large tokens, or must run sequential scans on a reader, should use bufio.Reader instead.</source>
          <target state="translated">Сканирование останавливается неустранимо при EOF,первой ошибке ввода/вывода или слишком большом токене,чтобы поместиться в буфер.Когда сканирование останавливается,считыватель,возможно,произвольно продвинулся дальше последнего токена.Программы,которые нуждаются в большем контроле над обработкой ошибок или больших токенов,или должны выполнять последовательное сканирование на считывателе,должны использовать вместо этого bufio.Reader.</target>
        </trans-unit>
        <trans-unit id="4651a34e4df9619783ad372f905d6d3b84e9d76d" translate="yes" xml:space="preserve">
          <source>Scope</source>
          <target state="translated">Scope</target>
        </trans-unit>
        <trans-unit id="2ebfb1a9903c43a33373f64197eeaf8911c9f134" translate="yes" xml:space="preserve">
          <source>Scope returns the (complete or incomplete) package scope holding the objects declared at package level (TypeNames, Consts, Vars, and Funcs).</source>
          <target state="translated">Scope возвращает (полный или неполный)объем пакета,содержащий объекты,объявленные на уровне пакета (TypeNames,Consts,Vars,Funcs).</target>
        </trans-unit>
        <trans-unit id="f31d3986ec66463fe9a83dfd9a2accc1b70877c7" translate="yes" xml:space="preserve">
          <source>Scope returns the scope of the function's body block.</source>
          <target state="translated">Scope возвращает объем блока тела функции.</target>
        </trans-unit>
        <trans-unit id="caf135bc624d4b0feb9650ec0d00441eafcdc77d" translate="yes" xml:space="preserve">
          <source>Scripts is the set of Unicode script tables.</source>
          <target state="translated">Скрипты-это набор таблиц скриптов Юникода.</target>
        </trans-unit>
        <trans-unit id="bce06414177f72ab70e6387b6af9f8ceef0d6049" translate="yes" xml:space="preserve">
          <source>Search</source>
          <target state="translated">Search</target>
        </trans-unit>
        <trans-unit id="f3e40d362f51c406a8e1778fc061f0dd3ad57de4" translate="yes" xml:space="preserve">
          <source>Search (DescendingOrder)</source>
          <target state="translated">Поиск (DescendingOrder)</target>
        </trans-unit>
        <trans-unit id="fdbb604a543d329419799366cc3a9af7390d3bcf" translate="yes" xml:space="preserve">
          <source>Search returns the result of applying SearchFloat64s to the receiver and x.</source>
          <target state="translated">Поиск возвращает результат применения SearchFloat64s к приемнику и x.</target>
        </trans-unit>
        <trans-unit id="1ab6c8f0fd768a91b3e79c036cb01cc452193fe2" translate="yes" xml:space="preserve">
          <source>Search returns the result of applying SearchInts to the receiver and x.</source>
          <target state="translated">Поиск возвращает результат применения SearchInts к приемнику и x.</target>
        </trans-unit>
        <trans-unit id="1c4f638fca65e5a738654ac393880f806f3b7f65" translate="yes" xml:space="preserve">
          <source>Search returns the result of applying SearchStrings to the receiver and x.</source>
          <target state="translated">Поиск возвращает результат применения SearchStrings к приемнику и x.</target>
        </trans-unit>
        <trans-unit id="794b977a863a1d9dc8d7b0fd80d6eef6736bd69e" translate="yes" xml:space="preserve">
          <source>Search uses binary search to find and return the smallest index i in [0, n) at which f(i) is true, assuming that on the range [0, n), f(i) == true implies f(i+1) == true. That is, Search requires that f is false for some (possibly empty) prefix of the input range [0, n) and then true for the (possibly empty) remainder; Search returns the first true index. If there is no such index, Search returns n. (Note that the &quot;not found&quot; return value is not -1 as in, for instance, strings.Index.) Search calls f(i) only for i in the range [0, n).</source>
          <target state="translated">Поиск использует двоичный поиск,чтобы найти и вернуть наименьший индекс i в [0,n),при котором f(i)истинен,предполагая,что в диапазоне [0,n),f(i)==true подразумевает f(i+1)==true.То есть,Search требует,чтобы f было false для некоторого (возможно пустого)префикса входного диапазона [0,n),а затем true для (возможно пустого)остатка;Search возвращает первый истинный индекс.Если такого индекса нет,Search возвращает n.(Обратите внимание,что возвращаемое &quot;не найдено&quot; значение не равно -1,как,например,в string.Index).Поиск вызывает f(i)только для i в диапазоне [0,n).</target>
        </trans-unit>
        <trans-unit id="895f11590a6ed175f7bac01b38c2ec5640f6fc28" translate="yes" xml:space="preserve">
          <source>SearchFloat64s searches for x in a sorted slice of float64s and returns the index as specified by Search. The return value is the index to insert x if x is not present (it could be len(a)). The slice must be sorted in ascending order.</source>
          <target state="translated">SearchFloat64s ищет x в отсортированном срезе float64s и возвращает индекс,заданный Search.Возвращаемое значение-индекс для вставки x,если x отсутствует (это может быть len(a)).Кусок должен быть отсортирован в порядке возрастания.</target>
        </trans-unit>
        <trans-unit id="b48f643546b25f6e6918e845a0e8a3ab0175ad09" translate="yes" xml:space="preserve">
          <source>SearchInts searches for x in a sorted slice of ints and returns the index as specified by Search. The return value is the index to insert x if x is not present (it could be len(a)). The slice must be sorted in ascending order.</source>
          <target state="translated">SearchInts ищет x в отсортированном куске чернил и возвращает индекс,заданный Search.Возвращаемое значение-это индекс для вставки x,если x отсутствует (это может быть len(a)).Кусок должен быть отсортирован в порядке возрастания.</target>
        </trans-unit>
        <trans-unit id="ed762c6e866455b20a9bc0ff477d563626862413" translate="yes" xml:space="preserve">
          <source>SearchStrings searches for x in a sorted slice of strings and returns the index as specified by Search. The return value is the index to insert x if x is not present (it could be len(a)). The slice must be sorted in ascending order.</source>
          <target state="translated">SearchStrings ищет x в отсортированном куске строк и возвращает индекс,заданный Search.Возвращаемое значение-это индекс для вставки x,если x отсутствует (это может быть len(a)).Фрагмент должен быть отсортирован в порядке возрастания.</target>
        </trans-unit>
        <trans-unit id="d1110c735a627c55e67957485addfcd1740c3fa1" translate="yes" xml:space="preserve">
          <source>Searching data sorted in descending order would use the &amp;lt;= operator instead of the &amp;gt;= operator.</source>
          <target state="translated">При поиске данных, отсортированных в порядке убывания, вместо оператора&amp;gt; = используется оператор &amp;lt;=.</target>
        </trans-unit>
        <trans-unit id="0feecc756efff0f52e43fa2ad18e92887874359a" translate="yes" xml:space="preserve">
          <source>Second returns the second offset within the minute specified by t, in the range [0, 59].</source>
          <target state="translated">Секунда возвращает смещение секунды в пределах минуты,указанной t,в диапазоне [0,59].</target>
        </trans-unit>
        <trans-unit id="aec1eca3aa532659c858922be555e4b78f91472b" translate="yes" xml:space="preserve">
          <source>Seconds returns the duration as a floating point number of seconds.</source>
          <target state="translated">Секунды возвращают продолжительность в виде числа секунд с плавающей запятой.</target>
        </trans-unit>
        <trans-unit id="883d7225a5feea9c004792c2e5762e5e8b90b937" translate="yes" xml:space="preserve">
          <source>Section compression type.</source>
          <target state="translated">Тип сжатия секции.</target>
        </trans-unit>
        <trans-unit id="23c76af95b6f5d08de2ecfd9a9b5758fd241b4b6" translate="yes" xml:space="preserve">
          <source>Section flags.</source>
          <target state="translated">Флаги секций.</target>
        </trans-unit>
        <trans-unit id="62f89d87896d7ef06a64cbb776d3fd356378e295" translate="yes" xml:space="preserve">
          <source>Section provides access to PE COFF section.</source>
          <target state="translated">Секция предоставляет доступ к секции PE COFF.</target>
        </trans-unit>
        <trans-unit id="0a9d0e16d038258c30fb66c2551ff2e94b6e8ab2" translate="yes" xml:space="preserve">
          <source>Section returns a section with the given name, or nil if no such section exists.</source>
          <target state="translated">Секция возвращает секцию с заданным названием,или ноль,если такой секции не существует.</target>
        </trans-unit>
        <trans-unit id="fc54ab0b090fa88e8cee7f8d9e554c227fd11b85" translate="yes" xml:space="preserve">
          <source>Section returns the first section with the given name, or nil if no such section exists.</source>
          <target state="translated">Секция возвращает первую секцию с заданным названием,или ноль,если такой секции не существует.</target>
        </trans-unit>
        <trans-unit id="8743382bf5087384ab8d5b7b47a198bf1c224282" translate="yes" xml:space="preserve">
          <source>Section type.</source>
          <target state="translated">Тип секции.</target>
        </trans-unit>
        <trans-unit id="d498edd9cfc2fe612ccd52dd5a6b59dfb6cad8e5" translate="yes" xml:space="preserve">
          <source>SectionByType returns the first section in f with the given type, or nil if there is no such section.</source>
          <target state="translated">SectionByType возвращает первую секцию в f с заданным типом,или nil,если такой секции нет.</target>
        </trans-unit>
        <trans-unit id="dbabe3978d24b41c968a7e3b657294f716964e11" translate="yes" xml:space="preserve">
          <source>SectionHeader is similar to SectionHeader32 with Name field replaced by Go string.</source>
          <target state="translated">SectionHeader похож на SectionHeader32,в котором поле Name заменено на Go string.</target>
        </trans-unit>
        <trans-unit id="236a39825c17abffb62d175c97b2ff1d1ddf6257" translate="yes" xml:space="preserve">
          <source>SectionHeader32 represents real PE COFF section header.</source>
          <target state="translated">SectionHeader32 представляет собой настоящий заголовок секции PE COFF.</target>
        </trans-unit>
        <trans-unit id="36fac8b648a8b963f174eff7d8e38ad8b061b47f" translate="yes" xml:space="preserve">
          <source>SectionReader</source>
          <target state="translated">SectionReader</target>
        </trans-unit>
        <trans-unit id="7c71d38d1e94fa11b5d9d25b519a23c96d399f77" translate="yes" xml:space="preserve">
          <source>SectionReader implements Read, Seek, and ReadAt on a section of an underlying ReaderAt.</source>
          <target state="translated">SectionReader реализует Read,Seek и ReadAt в разделе,лежащем в основе ReaderAt.</target>
        </trans-unit>
        <trans-unit id="559bf9fc1a7e8d17f180e11f63d09376be0206a5" translate="yes" xml:space="preserve">
          <source>SectionReader.ReadAt</source>
          <target state="translated">SectionReader.ReadAt</target>
        </trans-unit>
        <trans-unit id="665de6075b0f11336eab3dd46baf160774a5a70d" translate="yes" xml:space="preserve">
          <source>SectionReader.Seek</source>
          <target state="translated">SectionReader.Seek</target>
        </trans-unit>
        <trans-unit id="0f309ea1521bd5ca8e406b86f34f3a7a0ebff642" translate="yes" xml:space="preserve">
          <source>Security Model</source>
          <target state="translated">Модель безопасности</target>
        </trans-unit>
        <trans-unit id="01953de86431ce77344577ae5495196d927df9a0" translate="yes" xml:space="preserve">
          <source>See &quot;Gobs of data&quot; for a design discussion of the gob wire format: &lt;a href=&quot;https://blog.golang.org/gobs-of-data&quot;&gt;https://blog.golang.org/gobs-of-data&lt;/a&gt;</source>
          <target state="translated">См. &amp;laquo;Куски данных&amp;raquo; для обсуждения дизайна формата проводов капель: &lt;a href=&quot;https://blog.golang.org/gobs-of-data&quot;&gt;https://blog.golang.org/gobs-of-data&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3774cda758049661070b6c5a6625f40ce94f1003" translate="yes" xml:space="preserve">
          <source>See &quot;JSON and Go&quot; for an introduction to this package: &lt;a href=&quot;https://golang.org/doc/articles/json_and_go.html&quot;&gt;https://golang.org/doc/articles/json_and_go.html&lt;/a&gt;</source>
          <target state="translated">См. &amp;laquo;JSON and Go&amp;raquo; для ознакомления с этим пакетом: &lt;a href=&quot;https://golang.org/doc/articles/json_and_go.html&quot;&gt;https://golang.org/doc/articles/json_and_go.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="2434441ee0019a17c985accfc44984c0fc83f78c" translate="yes" xml:space="preserve">
          <source>See &quot;The Go image package&quot; for more details: &lt;a href=&quot;https://golang.org/doc/articles/image_package.html&quot;&gt;https://golang.org/doc/articles/image_package.html&lt;/a&gt;</source>
          <target state="translated">См. &amp;laquo;Пакет изображений Go&amp;raquo; для получения дополнительных сведений: &lt;a href=&quot;https://golang.org/doc/articles/image_package.html&quot;&gt;https://golang.org/doc/articles/image_package.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f5ff28b5d6f4a465abbce4a3d8096187a236d24e" translate="yes" xml:space="preserve">
          <source>See &quot;The Go image/draw package&quot; for an introduction to this package: &lt;a href=&quot;https://golang.org/doc/articles/image_draw.html&quot;&gt;https://golang.org/doc/articles/image_draw.html&lt;/a&gt;</source>
          <target state="translated">См. &amp;laquo;Пакет Go image / draw&amp;raquo; для ознакомления с этим пакетом: &lt;a href=&quot;https://golang.org/doc/articles/image_draw.html&quot;&gt;https://golang.org/doc/articles/image_draw.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f837700d9a3417d92fc3f9f0548fd849b9aa7119" translate="yes" xml:space="preserve">
          <source>See &quot;The Laws of Reflection&quot; for an introduction to reflection in Go: &lt;a href=&quot;https://golang.org/doc/articles/laws_of_reflection.html&quot;&gt;https://golang.org/doc/articles/laws_of_reflection.html&lt;/a&gt;</source>
          <target state="translated">См. &amp;laquo;Законы отражения&amp;raquo; для введения в отражение в Go: &lt;a href=&quot;https://golang.org/doc/articles/laws_of_reflection.html&quot;&gt;https://golang.org/doc/articles/laws_of_reflection.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="cd38865133cd9a5c006edfe52fb23197b681651e" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://blog.golang.org/context&quot;&gt;https://blog.golang.org/context&lt;/a&gt; for example code for a server that uses Contexts.</source>
          <target state="translated">См. &lt;a href=&quot;https://blog.golang.org/context&quot;&gt;Https://blog.golang.org/context&lt;/a&gt; для примера кода для сервера, который использует контексты.</target>
        </trans-unit>
        <trans-unit id="f8fa4b86ca7a1947812b5144ad80bb7923b98b76" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://blog.golang.org/http-tracing&quot;&gt;https://blog.golang.org/http-tracing&lt;/a&gt; for more.</source>
          <target state="translated">См. &lt;a href=&quot;https://blog.golang.org/http-tracing&quot;&gt;Https://blog.golang.org/http-tracing&lt;/a&gt; для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="55fd6381c1e6f556a9d9a122b9ddab024cd5623c" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://en.wikipedia.org/wiki/Isolation_(database_systems)#Isolation_levels&quot;&gt;https://en.wikipedia.org/wiki/Isolation_(database_systems)#Isolation_levels&lt;/a&gt;.</source>
          <target state="translated">См. &lt;a href=&quot;https://en.wikipedia.org/wiki/Isolation_(database_systems)#Isolation_levels&quot;&gt;Https://en.wikipedia.org/wiki/Isolation_(database_systems)#Isolation_levels&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5b6207cb402edce8d859bdca9debb6fc32598a7f" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://en.wikipedia.org/wiki/Mathematics_of_cyclic_redundancy_checks#Reversed_representations_and_reciprocal_polynomials&quot;&gt;https://en.wikipedia.org/wiki/Mathematics_of_cyclic_redundancy_checks#Reversed_representations_and_reciprocal_polynomials&lt;/a&gt; for information.</source>
          <target state="translated">Для получения информации см. &lt;a href=&quot;https://en.wikipedia.org/wiki/Mathematics_of_cyclic_redundancy_checks#Reversed_representations_and_reciprocal_polynomials&quot;&gt;Https://en.wikipedia.org/wiki/Mat&lt;/a&gt; Mathematics_of_cyclic_redundancy_checks# Reversed_presentations_and_reciprocal_polynomials .</target>
        </trans-unit>
        <trans-unit id="822defb6e38c1c8b51e3bd857cd8e75be7930a08" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://en.wikipedia.org/wiki/Web_colors#Web-safe_colors&quot;&gt;https://en.wikipedia.org/wiki/Web_colors#Web-safe_colors&lt;/a&gt; for details.</source>
          <target state="translated">Подробнее см. &lt;a href=&quot;https://en.wikipedia.org/wiki/Web_colors#Web-safe_colors&quot;&gt;Https://en.wikipedia.org/wiki/Web_colors#Web-safe_colors&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="012d19a411e4e0484271ae09bcb7f34da4a9a591" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://fast-cgi.github.io/&quot;&gt;https://fast-cgi.github.io/&lt;/a&gt; for an unofficial mirror of the original documentation.</source>
          <target state="translated">См. &lt;a href=&quot;https://fast-cgi.github.io/&quot;&gt;Https://fast-cgi.github.io/&lt;/a&gt; для получения неофициального зеркала исходной документации.</target>
        </trans-unit>
        <trans-unit id="c591b3698d1803b8997f519f5ea5ff42b510cd7a" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://tools.ietf.org/html/draft-ietf-httpbis-cookie-same-site-00&quot;&gt;https://tools.ietf.org/html/draft-ietf-httpbis-cookie-same-site-00&lt;/a&gt; for details.</source>
          <target state="translated">Подробности см. На &lt;a href=&quot;https://tools.ietf.org/html/draft-ietf-httpbis-cookie-same-site-00&quot;&gt;https://tools.ietf.org/html/draft-ietf-httpbis-cookie-same-site-00&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ebe2d422131406c7b8b8363b0278a5d60f19e086" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://tools.ietf.org/html/rfc6265&quot;&gt;https://tools.ietf.org/html/rfc6265&lt;/a&gt; for details.</source>
          <target state="translated">Подробнее см. &lt;a href=&quot;https://tools.ietf.org/html/rfc6265&quot;&gt;Https://tools.ietf.org/html/rfc6265&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="cfeb891e01c83428f5fff33780366881bea259da" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://www.w3.org/TR/css3-syntax/#parsing&quot;&gt;https://www.w3.org/TR/css3-syntax/#parsing&lt;/a&gt; and &lt;a href=&quot;https://web.archive.org/web/20090211114933/http://w3.org/TR/css3-syntax#style&quot;&gt;https://web.archive.org/web/20090211114933/http://w3.org/TR/css3-syntax#style&lt;/a&gt;</source>
          <target state="translated">См. &lt;a href=&quot;https://www.w3.org/TR/css3-syntax/#parsing&quot;&gt;Https://www.w3.org/TR/css3-syntax/#parsing&lt;/a&gt; и &lt;a href=&quot;https://web.archive.org/web/20090211114933/http://w3.org/TR/css3-syntax#style&quot;&gt;https://web.archive.org/web/20090211114933/http://w3.org/TR/css3-syntax#style.&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b12c5bb65217a01227ad162d33c3fed71b0401c9" translate="yes" xml:space="preserve">
          <source>See MarshalIndent for an example.</source>
          <target state="translated">См.пример с Маршалом Индентом.</target>
        </trans-unit>
        <trans-unit id="4a1e97ca1a62398cd193e09c77540d6a3a116112" translate="yes" xml:space="preserve">
          <source>See also &amp;ldquo;A Layman's Guide to a Subset of ASN.1, BER, and DER,&amp;rdquo; &lt;a href=&quot;http://luca.ntop.org/Teaching/Appunti/asn1.html&quot;&gt;http://luca.ntop.org/Teaching/Appunti/asn1.html&lt;/a&gt;.</source>
          <target state="translated">См. Также &amp;laquo;Руководство непрофессионала по подмножеству ASN.1, BER и DER&amp;raquo;, &lt;a href=&quot;http://luca.ntop.org/Teaching/Appunti/asn1.html&quot;&gt;http://luca.ntop.org/Teaching/Appunti/asn1.html&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f35fe0b7c2e4d6b79cc655771a00378e8038d6ad" translate="yes" xml:space="preserve">
          <source>See also Rob Pike, &amp;ldquo;Lexical File Names in Plan 9 or Getting Dot-Dot Right,&amp;rdquo; &lt;a href=&quot;https://9p.io/sys/doc/lexnames.html&quot;&gt;https://9p.io/sys/doc/lexnames.html&lt;/a&gt;</source>
          <target state="translated">См. Также Роб Пайк, &amp;laquo;Лексические имена файлов в Plan 9 или получение правильных точек&amp;raquo;, &lt;a href=&quot;https://9p.io/sys/doc/lexnames.html&quot;&gt;https://9p.io/sys/doc/lexnames.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c57c543e703b305eac0e44a135198463dbeead16" translate="yes" xml:space="preserve">
          <source>See func Dial for a description of the host and port parameters.</source>
          <target state="translated">Описание параметров хоста и порта см.в разделе Функция Dial.</target>
        </trans-unit>
        <trans-unit id="b9538b240ebef42fb9902c82f39f4d8fe015d462" translate="yes" xml:space="preserve">
          <source>See func Dial for a description of the hostport parameter, and host and port results.</source>
          <target state="translated">Описание параметра хостпорта,а также результатов работы хоста и порта смотрите в разделе Функция Dial.</target>
        </trans-unit>
        <trans-unit id="f55bd52960d8a9b74f8c169b63b303f83068df0d" translate="yes" xml:space="preserve">
          <source>See func Dial for a description of the network and address parameters.</source>
          <target state="translated">Описание параметров сети и адреса см.в разделе Функция Dial.</target>
        </trans-unit>
        <trans-unit id="27af5de3a2347f6faceaa84c4b1f14ae1dbd0c9d" translate="yes" xml:space="preserve">
          <source>See func Listen for a description of the network and address parameters.</source>
          <target state="translated">Описание параметров сети и адреса см.в разделе Функция Прослушать.</target>
        </trans-unit>
        <trans-unit id="6b6b3dee4908b79bcc47570b27eb5ceec2a78402" translate="yes" xml:space="preserve">
          <source>See func ListenPacket for a description of the network and address parameters.</source>
          <target state="translated">Описание параметров сети и адреса см.в разделе функционала ListenPacket.</target>
        </trans-unit>
        <trans-unit id="ad4f4bb8708490d77806cbbb7379b205b4ed91be" translate="yes" xml:space="preserve">
          <source>See package json to understand how non-string content is marshaled for embedding in JavaScript contexts.</source>
          <target state="translated">См.пакет json,чтобы понять,как маршируется нестрочное содержимое для встраивания в контекст JavaScript.</target>
        </trans-unit>
        <trans-unit id="6e66c2f2a3fcd4dca444d07ce7d1a4b916782623" translate="yes" xml:space="preserve">
          <source>See page 36 of RFC 959 (&lt;a href=&quot;https://www.ietf.org/rfc/rfc959.txt&quot;&gt;https://www.ietf.org/rfc/rfc959.txt&lt;/a&gt;) for details of another form of response accepted:</source>
          <target state="translated">См. Страницу 36 RFC 959 ( &lt;a href=&quot;https://www.ietf.org/rfc/rfc959.txt&quot;&gt;https://www.ietf.org/rfc/rfc959.txt&lt;/a&gt; ) для получения подробной информации о другой форме принятого ответа:</target>
        </trans-unit>
        <trans-unit id="89753a3f5bb64713c93e9dd202de0a7448a21cee" translate="yes" xml:space="preserve">
          <source>See the Client.Do method documentation for details on how redirects are handled.</source>
          <target state="translated">Подробнее о том,как обрабатываются перенаправления,смотрите документацию по методу Client.Do.</target>
        </trans-unit>
        <trans-unit id="ca6b0bd4889c5a06e76626f48ec79733e1fde8b5" translate="yes" xml:space="preserve">
          <source>See the Decoder.Strict and Decoder.Entity fields' documentation.</source>
          <target state="translated">См.документацию по полям Decoder.Strict и Decoder.Entity.</target>
        </trans-unit>
        <trans-unit id="69633a7324ac73d11db8887864a0a74fd2f5588f" translate="yes" xml:space="preserve">
          <source>See the documentation for Marshal for details about the conversion of Go values to JSON.</source>
          <target state="translated">Подробнее о преобразовании значений Go в JSON см.в документации для маршала.</target>
        </trans-unit>
        <trans-unit id="45c89cab840adb83eec8d88d66bfe51744007d64" translate="yes" xml:space="preserve">
          <source>See the documentation for Marshal for details about the conversion of Go values to XML.</source>
          <target state="translated">Подробнее о преобразовании значений Go в XML см.в документации для Маршала.</target>
        </trans-unit>
        <trans-unit id="f6ad8d64ce7abf48e48759b114cf5bbde1ec1217" translate="yes" xml:space="preserve">
          <source>See the documentation for Reader's DotReader method for details about dot-encoding.</source>
          <target state="translated">Подробнее о точечном кодировании см.в документации к методу DotReader.</target>
        </trans-unit>
        <trans-unit id="07bb2782143cae54efbc20f97e601c6258fdfa3a" translate="yes" xml:space="preserve">
          <source>See the documentation for Unmarshal for details about the conversion of JSON into a Go value.</source>
          <target state="translated">Подробнее о преобразовании JSON в Go см.в документации для Unmarshal.</target>
        </trans-unit>
        <trans-unit id="5b7d9e398b9767ef1472ee8144b5fcbf7154f428" translate="yes" xml:space="preserve">
          <source>See the documentation for the DotReader method for details about dot-encoding.</source>
          <target state="translated">См.документацию по методу DotReader для получения подробной информации о точечном кодировании.</target>
        </trans-unit>
        <trans-unit id="20a56feb05a514c49115ca9854f4e8b6ab081007" translate="yes" xml:space="preserve">
          <source>See the documentation of ErrorCode for details.</source>
          <target state="translated">Подробнее см.документацию по ErrorCode.</target>
        </trans-unit>
        <trans-unit id="130b144345eef54088939126445f2041356e9967" translate="yes" xml:space="preserve">
          <source>See the net/http/pprof package for more details about all of the debug endpoints installed by this import.</source>
          <target state="translated">Более подробную информацию обо всех отладочных конечных точках,установленных данным импортом,можно найти в пакете net/http/pprof.</target>
        </trans-unit>
        <trans-unit id="8ea13af2c476fd8c34b53410467a8c4eec967244" translate="yes" xml:space="preserve">
          <source>See the net/http/pprof package for more details.</source>
          <target state="translated">Подробности см.в пакете net/http/pprof.</target>
        </trans-unit>
        <trans-unit id="d95f74a97d247876324f75dbbfb30fd3fdf53de6" translate="yes" xml:space="preserve">
          <source>See: &lt;a href=&quot;https://www.pkware.com/appnote&quot;&gt;https://www.pkware.com/appnote&lt;/a&gt;</source>
          <target state="translated">См .: &lt;a href=&quot;https://www.pkware.com/appnote&quot;&gt;https://www.pkware.com/appnote&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="421cab07939e4ef921a875d22fec2c50b6b26cc4" translate="yes" xml:space="preserve">
          <source>Seed returns the private key seed corresponding to priv. It is provided for interoperability with RFC 8032. RFC 8032's private keys correspond to seeds in this package.</source>
          <target state="translated">Посевной материал возвращает посевной материал приватного ключа,соответствующий приватному.Предусмотрена функциональная совместимость с RFC 8032.Частные ключи RFC 8032 соответствуют семенам в этом пакете.</target>
        </trans-unit>
        <trans-unit id="a2daea0c21550e6b91614c2942780e2e38582d89" translate="yes" xml:space="preserve">
          <source>Seed uses the provided seed value to initialize the default Source to a deterministic state. If Seed is not called, the generator behaves as if seeded by Seed(1). Seed values that have the same remainder when divided by 2^31-1 generate the same pseudo-random sequence. Seed, unlike the Rand.Seed method, is safe for concurrent use.</source>
          <target state="translated">Посевной материал использует предоставленное начальное значение для инициализации источника по умолчанию Источник до детерминированного состояния.Если Seed не вызывается,генератор ведет себя так,как если бы его посылал Seed(1).Значения посылки,которые при делении на 2^31-1 имеют одинаковый остаток,генерируют одну и ту же псевдослучайную последовательность.Seed,в отличие от метода Rand.Seed,безопасен для одновременного использования.</target>
        </trans-unit>
        <trans-unit id="06599ffd87d9ecfcc5955a8a8f6f2e80af71b779" translate="yes" xml:space="preserve">
          <source>Seed uses the provided seed value to initialize the generator to a deterministic state. Seed should not be called concurrently with any other Rand method.</source>
          <target state="translated">Посевной материал использует предоставленную посевную величину для инициализации генератора до детерминированного состояния.Зерно не должно называться одновременно с любым другим методом Rand.</target>
        </trans-unit>
        <trans-unit id="63eada0c1ee90c191cced8ff6a478d23ec01c7bb" translate="yes" xml:space="preserve">
          <source>Seek implements the io.Seeker interface.</source>
          <target state="translated">Seek реализует интерфейс io.Seeker.</target>
        </trans-unit>
        <trans-unit id="410f9d629b5b2020b5303452364dec83676d0a30" translate="yes" xml:space="preserve">
          <source>Seek positions the Reader at offset off in the encoded entry stream. Offset 0 can be used to denote the first entry.</source>
          <target state="translated">Ищите позиции считывателя со смещением в кодированном потоке входных данных.Смещение 0 может быть использовано для обозначения первой записи.</target>
        </trans-unit>
        <trans-unit id="73550a62d2076f2c392030c22ea826a5948745a2" translate="yes" xml:space="preserve">
          <source>Seek restores the line table reader to a position returned by Tell.</source>
          <target state="translated">Seek восстанавливает чтение строчной таблицы в положение,возвращенное Tell.</target>
        </trans-unit>
        <trans-unit id="6d637ad9eaafe14fbed4d5e3bc3eb33df03f11cb" translate="yes" xml:space="preserve">
          <source>Seek sets the offset for the next Read or Write on file to offset, interpreted according to whence: 0 means relative to the origin of the file, 1 means relative to the current offset, and 2 means relative to the end. It returns the new offset and an error, if any. The behavior of Seek on a file opened with O_APPEND is not specified.</source>
          <target state="translated">Seek устанавливает смещение для следующего Чтения или записи в файл,интерпретируемое в соответствии с этим:0 означает относительно начала файла,1 означает относительно текущего смещения и 2 означает относительно конца.Возвращает новое смещение и ошибку,если таковая имеется.Поведение Seek на файле,открытом с O_APPEND,не определено.</target>
        </trans-unit>
        <trans-unit id="e00a273e91af976fc6df810663ccae8e6326bc28" translate="yes" xml:space="preserve">
          <source>Seek sets the offset for the next Read or Write to offset, interpreted according to whence: SeekStart means relative to the start of the file, SeekCurrent means relative to the current offset, and SeekEnd means relative to the end. Seek returns the new offset relative to the start of the file and an error, if any.</source>
          <target state="translated">Seek устанавливает смещение для следующего Чтения или Запись в смещение,интерпретируемое в соответствии с интерпретацией:SeekStart означает относительно начала файла,SeekCurrent означает относительно текущего смещения,а SeekEnd означает относительно конца.Seek возвращает новое смещение относительно начала файла и ошибку,если таковая имеется.</target>
        </trans-unit>
        <trans-unit id="f2691430f4c04cd93d687e7abb0ccf591170c83f" translate="yes" xml:space="preserve">
          <source>Seek whence values.</source>
          <target state="translated">Ищите откуда значения.</target>
        </trans-unit>
        <trans-unit id="69cfaf772b14f0b576e9cb0bbd8f02155636d19d" translate="yes" xml:space="preserve">
          <source>SeekPC returns the Entry for the compilation unit that includes pc, and positions the reader to read the children of that unit. If pc is not covered by any unit, SeekPC returns ErrUnknownPC and the position of the reader is undefined.</source>
          <target state="translated">SeekPC возвращает Entry для модуля компиляции,включающего pc,и позиционирует устройство чтения для чтения дочерних элементов этого модуля.Если ПК не покрыт никаким модулем,SeekPC возвращает ErrUnknownPC и положение считывающего устройства не определено.</target>
        </trans-unit>
        <trans-unit id="ce674d68613294249c458dda3fd950d087fbda52" translate="yes" xml:space="preserve">
          <source>SeekPC sets *entry to the LineEntry that includes pc and positions the reader on the next entry in the line table. If necessary, this will seek backwards to find pc.</source>
          <target state="translated">SeekPC устанавливает *вход в LineEntry,который включает pc и позиционирует читателя на следующей записи в таблице строк.При необходимости,он будет искать в обратном направлении,чтобы найти pc.</target>
        </trans-unit>
        <trans-unit id="9d91685eee68f0702fc5f565a2ad58bdb01cbd6c" translate="yes" xml:space="preserve">
          <source>Seeker is the interface that wraps the basic Seek method.</source>
          <target state="translated">Seeker-это интерфейс,обертывающий основной метод Seek.</target>
        </trans-unit>
        <trans-unit id="c221b3bf48536c91e36f1aa582e0e6ad14671a86" translate="yes" xml:space="preserve">
          <source>Seeking to an offset before the start of the file is an error. Seeking to any positive offset is legal, but the behavior of subsequent I/O operations on the underlying object is implementation-dependent.</source>
          <target state="translated">Поиск смещения до запуска файла является ошибкой.Поиск любого положительного смещения легален,но поведение последующих операций ввода/вывода над лежащим в основе объектом зависит от реализации.</target>
        </trans-unit>
        <trans-unit id="d283b12149f88184eedb3514ba9c006d88d9d635" translate="yes" xml:space="preserve">
          <source>Segment returns the first Segment with the given name, or nil if no such segment exists.</source>
          <target state="translated">Сегмент возвращает первый Сегмент с заданным именем,или нулевой,если такого сегмента не существует.</target>
        </trans-unit>
        <trans-unit id="4ee9c170709717ea62d8ec2ac63808bf3b81d532" translate="yes" xml:space="preserve">
          <source>Select executes a select operation described by the list of cases. Like the Go select statement, it blocks until at least one of the cases can proceed, makes a uniform pseudo-random choice, and then executes that case. It returns the index of the chosen case and, if that case was a receive operation, the value received and a boolean indicating whether the value corresponds to a send on the channel (as opposed to a zero value received because the channel is closed).</source>
          <target state="translated">Выбор выполняет операцию выбора,описанную в списке случаев.Как и оператор Go select,он блокирует до тех пор,пока,по крайней мере,один из случаев не может быть продолжен,делает единообразный псевдослучайный выбор,а затем выполняет этот случай.Он возвращает индекс выбранного случая и,если этот случай был операцией приема,полученное значение и булевую индикацию,показывающую,соответствует ли значение отправлению по каналу (в противоположность полученному нулевому значению,поскольку канал закрыт).</target>
        </trans-unit>
        <trans-unit id="7716a94c0a405511b91cc23c646dfce03e542371" translate="yes" xml:space="preserve">
          <source>SelectionKind describes the kind of a selector expression x.f (excluding qualified identifiers).</source>
          <target state="translated">SelectionKind описывает вид селекторного выражения x.f (исключая квалифицированные идентификаторы).</target>
        </trans-unit>
        <trans-unit id="656dfc577aeb6e9f277a9a8820fcfc6e5db75f21" translate="yes" xml:space="preserve">
          <source>SelectionString returns the string form of s. The Qualifier controls the printing of package-level objects, and may be nil.</source>
          <target state="translated">SelectionString возвращает строковую форму s.Квалификатор управляет распечаткой объектов на уровне пакетов и может быть нулевым.</target>
        </trans-unit>
        <trans-unit id="edad40365c9764afdd964f9245649f6856af2d11" translate="yes" xml:space="preserve">
          <source>Send sends x on the channel v. It panics if v's kind is not Chan or if x's type is not the same type as v's element type. As in Go, x's value must be assignable to the channel's element type.</source>
          <target state="translated">Отправка отправляет x на канал v.Он паникует,если тип v не Chan или если тип x не совпадает с типом v элемента.Как и в Go,значение x должно быть присвоено типу элемента канала.</target>
        </trans-unit>
        <trans-unit id="2750b0f06411195ed08fefe45f59d520ab6f8353" translate="yes" xml:space="preserve">
          <source>SendMail</source>
          <target state="translated">SendMail</target>
        </trans-unit>
        <trans-unit id="1a5bbac84e0744da338847af3ed794816ef236ce" translate="yes" xml:space="preserve">
          <source>SendMail connects to the server at addr, switches to TLS if possible, authenticates with the optional mechanism a if possible, and then sends an email from address from, to addresses to, with message msg. The addr must include a port, as in &quot;mail.example.com:smtp&quot;.</source>
          <target state="translated">SendMail подключается к серверу по адресу addr,по возможности переключается на TLS,аутентифицируется с помощью опционального механизма a,если это возможно,а затем отправляет электронное сообщение с адреса,с адреса,на адрес,с сообщением msg.Аддр должен включать порт,как в &quot;mail.example.com:smtp&quot;.</target>
        </trans-unit>
        <trans-unit id="9866b4faed06fd643cf801f0e203a46a3fe6c756" translate="yes" xml:space="preserve">
          <source>Serve accepts incoming FastCGI connections on the listener l, creating a new goroutine for each. The goroutine reads requests and then calls handler to reply to them. If l is nil, Serve accepts connections from os.Stdin. If handler is nil, http.DefaultServeMux is used.</source>
          <target state="translated">Подача принимает входящие FastCGI соединения на слушателе l,создавая новый горутин для каждого.Горутин читает запросы,а затем звонит обработчику,чтобы тот ответил на них.Если l равен нулю,Serve принимает соединения от os.Stdin.Если обработчик равен нулю,используется http.DefaultServeMux.</target>
        </trans-unit>
        <trans-unit id="d8de44e0fb5292324dadb958bb0ec67283e1e920" translate="yes" xml:space="preserve">
          <source>Serve accepts incoming HTTP connections on the listener l, creating a new service goroutine for each. The service goroutines read requests and then call handler to reply to them.</source>
          <target state="translated">Serve принимает входящие HTTP соединения на слушателе l,создавая новый горутин сервиса для каждого.Горутины службы читают запросы,а затем звонят обработчику,чтобы тот ответил на них.</target>
        </trans-unit>
        <trans-unit id="fb2fbb4a3d173feafc83e986b5d91f4c043b98cd" translate="yes" xml:space="preserve">
          <source>Serve accepts incoming connections on the Listener l, creating a new service goroutine for each. The service goroutines read requests and then call srv.Handler to reply to them.</source>
          <target state="translated">Serve принимает входящие соединения на Listener l,создавая новый горутин услуг для каждого.Горутины сервиса читают запросы,а затем звонят srv.Handler,чтобы ответить на них.</target>
        </trans-unit>
        <trans-unit id="f65496b12ef6ef062ca261d02fdcc1afec4ce5ea" translate="yes" xml:space="preserve">
          <source>Serve always returns a non-nil error and closes l. After Shutdown or Close, the returned error is ErrServerClosed.</source>
          <target state="translated">Serve всегда возвращает нулевую ошибку и закрывает l.После выключения или закрытия возвращается ошибка ErrServerClosed.</target>
        </trans-unit>
        <trans-unit id="4671511496e9d853a658f8c526e4dbf184a2c34c" translate="yes" xml:space="preserve">
          <source>Serve always returns a non-nil error.</source>
          <target state="translated">Подача всегда возвращает ошибку без нулевой отметки.</target>
        </trans-unit>
        <trans-unit id="497078ba977bfc095dad2477b3172dcb26f1c0ab" translate="yes" xml:space="preserve">
          <source>Serve executes the provided Handler on the currently active CGI request, if any. If there's no current CGI environment an error is returned. The provided handler may be nil to use http.DefaultServeMux.</source>
          <target state="translated">Serve выполняет предоставленный обработчик по текущему активному запросу CGI,если таковой имеется.Если текущее CGI окружение отсутствует,возвращается ошибка.Прилагаемый обработчик может быть равен нулю для использования http.DefaultServeMux.</target>
        </trans-unit>
        <trans-unit id="dbfb7d2b5b789e7fe76f3c2462b4817839783a1b" translate="yes" xml:space="preserve">
          <source>ServeCodec is like ServeConn but uses the specified codec to decode requests and encode responses.</source>
          <target state="translated">ServeCodec похож на ServeConn,но использует указанный кодек для декодирования запросов и кодирования ответов.</target>
        </trans-unit>
        <trans-unit id="09ac76223546ffdd3d100d24b6bc49c0b7956df0" translate="yes" xml:space="preserve">
          <source>ServeConn runs the DefaultServer on a single connection. ServeConn blocks, serving the connection until the client hangs up. The caller typically invokes ServeConn in a go statement. ServeConn uses the gob wire format (see package gob) on the connection. To use an alternate codec, use ServeCodec. See NewClient's comment for information about concurrent access.</source>
          <target state="translated">ServeConn запускает DefaultServer на одном соединении.ServeConn блокирует,обслуживая соединение до тех пор,пока клиент не повесит трубку.Звонящий обычно вызывает ServeConn в заявлении на ходу.ServeConn использует формат провода валика (см.пакет валика)при соединении.Чтобы использовать альтернативный кодек,используйте ServeCodec.См.комментарий NewClient для получения информации о параллельном доступе.</target>
        </trans-unit>
        <trans-unit id="d136d0992046f83551cea5f2576de13dc7e39384" translate="yes" xml:space="preserve">
          <source>ServeConn runs the JSON-RPC server on a single connection. ServeConn blocks, serving the connection until the client hangs up. The caller typically invokes ServeConn in a go statement.</source>
          <target state="translated">ServeConn запускает JSON-RPC-сервер на одном соединении.ServeConn блокирует,обслуживая соединение до тех пор,пока клиент не повесит трубку.Звонящий обычно вызывает ServeConn в заявлении о переходе.</target>
        </trans-unit>
        <trans-unit id="2f01374418f76760c6cb616cbabd675e38909787" translate="yes" xml:space="preserve">
          <source>ServeConn runs the server on a single connection. ServeConn blocks, serving the connection until the client hangs up. The caller typically invokes ServeConn in a go statement. ServeConn uses the gob wire format (see package gob) on the connection. To use an alternate codec, use ServeCodec. See NewClient's comment for information about concurrent access.</source>
          <target state="translated">ServeConn запускает сервер на одном соединении.ServeConn блокирует,обслуживая соединение до тех пор,пока клиент не повесит трубку.Звонящий обычно вызывает ServeConn в заявлении о выходе.ServeConn использует формат провода валика (см.пакет валика)при соединении.Чтобы использовать альтернативный кодек,используйте ServeCodec.См.комментарий NewClient для получения информации о параллельном доступе.</target>
        </trans-unit>
        <trans-unit id="ef53643ab98faf2b116983a1f327c585aaa8a435" translate="yes" xml:space="preserve">
          <source>ServeContent replies to the request using the content in the provided ReadSeeker. The main benefit of ServeContent over io.Copy is that it handles Range requests properly, sets the MIME type, and handles If-Match, If-Unmodified-Since, If-None-Match, If-Modified-Since, and If-Range requests.</source>
          <target state="translated">ServeContent отвечает на запрос,используя содержимое предоставленного ReadSeeker.Основным преимуществом ServeContent перед io.Copy является то,что он правильно обрабатывает запросы на диапазон,устанавливает тип MIME и обрабатывает If-Match,If-Unemodified-Since,If-None-Match,If-Modified-Since и If-Range запросы.</target>
        </trans-unit>
        <trans-unit id="cfd658fe667ad1d964897018a5c4cf11bec05335" translate="yes" xml:space="preserve">
          <source>ServeFile replies to the request with the contents of the named file or directory.</source>
          <target state="translated">ServeFile отвечает на запрос содержимым именованного файла или директории.</target>
        </trans-unit>
        <trans-unit id="049197d23952867737fe7bc77daa12a248c70057" translate="yes" xml:space="preserve">
          <source>ServeHTTP calls f(w, r).</source>
          <target state="translated">ServeHTTP вызывает f(w,r).</target>
        </trans-unit>
        <trans-unit id="4c4916bc850460672f4222f24dda17f824b214d6" translate="yes" xml:space="preserve">
          <source>ServeHTTP dispatches the request to the handler whose pattern most closely matches the request URL.</source>
          <target state="translated">ServeHTTP посылает запрос обработчику,чей шаблон наиболее точно соответствует URL запроса.</target>
        </trans-unit>
        <trans-unit id="21deb32922a44f4fb534ed8afc10e377cb3ed92e" translate="yes" xml:space="preserve">
          <source>ServeHTTP implements an http.Handler that answers RPC requests.</source>
          <target state="translated">ServeHTTP реализует http.Handler,отвечающий на запросы RPC.</target>
        </trans-unit>
        <trans-unit id="6b5f212880feffc9d4b20ece24bb964f1dfe9a0e" translate="yes" xml:space="preserve">
          <source>ServeHTTP should write reply headers and data to the ResponseWriter and then return. Returning signals that the request is finished; it is not valid to use the ResponseWriter or read from the Request.Body after or concurrently with the completion of the ServeHTTP call.</source>
          <target state="translated">ServeHTTP должен записать заголовки ответов и данные в ResponseWriter,а затем вернуть их.Возврат сигнализирует об окончании запроса,использование ResponseWriter или чтение из тела запроса после или одновременно с завершением вызова ServeHTTP не допустимо.</target>
        </trans-unit>
        <trans-unit id="643b76d4394a8e8ca4ec7165cbad824736ed0dab" translate="yes" xml:space="preserve">
          <source>ServeMux also takes care of sanitizing the URL request path and the Host header, stripping the port number and redirecting any request containing . or .. elements or repeated slashes to an equivalent, cleaner URL.</source>
          <target state="translated">ServeMux также заботится о дезинфекции пути запроса URL и заголовка Host,удаляя номер порта и перенаправляя любой запрос,содержащий ...или ...элементы или повторяющиеся косые черты,на эквивалентный,более чистый URL.</target>
        </trans-unit>
        <trans-unit id="c2c623da8699103087cc62f3c47b54b0c6fbdef4" translate="yes" xml:space="preserve">
          <source>ServeMux is an HTTP request multiplexer. It matches the URL of each incoming request against a list of registered patterns and calls the handler for the pattern that most closely matches the URL.</source>
          <target state="translated">ServeMux является мультиплексором HTTP-запросов.Он сопоставляет URL каждого входящего запроса со списком зарегистрированных шаблонов и вызывает обработчика для шаблона,который наиболее точно соответствует URL.</target>
        </trans-unit>
        <trans-unit id="d57d6d29bc00d69dcb5016e00c29678f29b25c20" translate="yes" xml:space="preserve">
          <source>ServeMux.Handle</source>
          <target state="translated">ServeMux.Handle</target>
        </trans-unit>
        <trans-unit id="a2ccb85e8b555a7018f6848932b3cf1638f89e04" translate="yes" xml:space="preserve">
          <source>ServeRequest is like ServeCodec but synchronously serves a single request. It does not close the codec upon completion.</source>
          <target state="translated">ServeRequest похож на ServeCodec,но синхронно обслуживает один запрос.Он не закрывает кодек по его завершению.</target>
        </trans-unit>
        <trans-unit id="914b527f3acbaa5705eeffe44b971ef90f12446b" translate="yes" xml:space="preserve">
          <source>ServeTLS accepts incoming HTTPS connections on the listener l, creating a new service goroutine for each. The service goroutines read requests and then call handler to reply to them.</source>
          <target state="translated">ServeTLS принимает входящие соединения HTTPS на слушателе l,создавая новый горутин услуг для каждого.Служебные гориллы читают запросы,а затем звонят обработчику,чтобы тот ответил на них.</target>
        </trans-unit>
        <trans-unit id="0a96e454a3074cfb2a672bba732fc55cf3ace063" translate="yes" xml:space="preserve">
          <source>ServeTLS accepts incoming connections on the Listener l, creating a new service goroutine for each. The service goroutines perform TLS setup and then read requests, calling srv.Handler to reply to them.</source>
          <target state="translated">ServeTLS принимает входящие соединения на Listener l,создавая новый горутин услуг для каждого.Горутины сервиса выполняют настройку TLS,а затем считывают запросы,вызывая srv.Handler для ответа на них.</target>
        </trans-unit>
        <trans-unit id="5d05c42df2acb99153f40488ff8b30bf621e7c31" translate="yes" xml:space="preserve">
          <source>ServeTLS always returns a non-nil error.</source>
          <target state="translated">ServeTLS всегда возвращает ошибку без нулевой отметки.</target>
        </trans-unit>
        <trans-unit id="49b6a1abd7e8e016f95152133848467bef1659cf" translate="yes" xml:space="preserve">
          <source>ServeTLS always returns a non-nil error. After Shutdown or Close, the returned error is ErrServerClosed.</source>
          <target state="translated">ServeTLS всегда возвращает ошибку без нулевой отметки.После выключения или закрытия возвращается ошибка ErrServerClosed.</target>
        </trans-unit>
        <trans-unit id="cb0cb170d106f8e8d5af1e05bbdbd3a96a7de197" translate="yes" xml:space="preserve">
          <source>Server</source>
          <target state="translated">Server</target>
        </trans-unit>
        <trans-unit id="4ddf4403b77024142dd6473786b6571dc8b196f9" translate="yes" xml:space="preserve">
          <source>Server represents an RPC Server.</source>
          <target state="translated">Сервер представляет собой RPC-сервер.</target>
        </trans-unit>
        <trans-unit id="313ac33490fd78320856fae075839a276bcab472" translate="yes" xml:space="preserve">
          <source>Server returns a new TLS server side connection using conn as the underlying transport. The configuration config must be non-nil and must include at least one certificate or else set GetCertificate.</source>
          <target state="translated">Сервер возвращает новое соединение на стороне сервера TLS,используя коннектор в качестве основного транспорта.Конфигурация конфигурации не должна быть нулевой и должна включать в себя как минимум один сертификат или другой набор GetCertificate.</target>
        </trans-unit>
        <trans-unit id="e0b4e659e40eb8a8a1e289fa3271bf98ef6e2706" translate="yes" xml:space="preserve">
          <source>Server.Shutdown</source>
          <target state="translated">Server.Shutdown</target>
        </trans-unit>
        <trans-unit id="e8983457da1ab21a6c85c2a9507e94af92a8934d" translate="yes" xml:space="preserve">
          <source>ServerConn is an artifact of Go's early HTTP implementation. It is low-level, old, and unused by Go's current HTTP stack. We should have deleted it before Go 1.</source>
          <target state="translated">ServerConn-это артефакт ранней реализации Go HTTP.Он является низкоуровневым,старым и неиспользуемым текущим HTTP-стеком Go.Мы должны были удалить его перед Go 1.</target>
        </trans-unit>
        <trans-unit id="e48e77ca43f54c7c217d619efb9bd95f1a1f8aba" translate="yes" xml:space="preserve">
          <source>ServerError represents an error that has been returned from the remote side of the RPC connection.</source>
          <target state="translated">ServerError представляет собой ошибку,которая была возвращена с удаленной стороны RPC соединения.</target>
        </trans-unit>
        <trans-unit id="547b92e886182f3f71367607ff47558fb0fe8029" translate="yes" xml:space="preserve">
          <source>ServerInfo records information about an SMTP server.</source>
          <target state="translated">ServerInfo записывает информацию о SMTP-сервере.</target>
        </trans-unit>
        <trans-unit id="870594a7b5d015bba7a8d2c0875c56f2fce85f71" translate="yes" xml:space="preserve">
          <source>SessionResetter may be implemented by Conn to allow drivers to reset the session state associated with the connection and to signal a bad connection.</source>
          <target state="translated">NetworkResetter может быть реализован с помощью Conn,чтобы позволить драйверам сбросить состояние сеанса,связанное с соединением,и сигнализировать о плохом соединении.</target>
        </trans-unit>
        <trans-unit id="aab8e5c4d0aeae85893fd621bc37db1b1a73696a" translate="yes" xml:space="preserve">
          <source>Set assigns x to the value v. It panics if CanSet returns false. As in Go, x's value must be assignable to v's type.</source>
          <target state="translated">Установка присваивает x значению v.Она паникует,если CanSet возвращает false.Как и в &quot;Go&quot;,значение x должно быть присвоено типу &quot;v&quot;.</target>
        </trans-unit>
        <trans-unit id="1d2a8709f5b7f411cc9ba583a652581b21b6d185" translate="yes" xml:space="preserve">
          <source>Set is called once, in command line order, for each flag present. The flag package may call the String method with a zero-valued receiver, such as a nil pointer.</source>
          <target state="translated">Набор вызывается один раз,в порядке командной строки,для каждого присутствующего флага.Пакет флагов может вызвать метод String с нулевым значением приемника,например,нулевой указатель.</target>
        </trans-unit>
        <trans-unit id="e8fb40cfeae3d73e6b30e01495ac2c9fe7ff8cc2" translate="yes" xml:space="preserve">
          <source>Set sets the JavaScript property p of value v to ValueOf(x). It panics if v is not a JavaScript object.</source>
          <target state="translated">Установка устанавливает свойство JavaScript p значения v в значение ValueOf(x).Если v не является JavaScript-объектом,начнется паника.</target>
        </trans-unit>
        <trans-unit id="87f6096d8457ac4b04a70faa68ba0c62c9f61ecc" translate="yes" xml:space="preserve">
          <source>Set sets the header entries associated with key to the single element value. It replaces any existing values associated with key.</source>
          <target state="translated">Установка устанавливает значения заголовков,связанных с ключом,на единичное значение элемента.Он заменяет любые существующие значения,связанные с ключом.</target>
        </trans-unit>
        <trans-unit id="82fcf24728ab76cc9481c998a3f5414cead1eb36" translate="yes" xml:space="preserve">
          <source>Set sets the header entries associated with key to the single element value. It replaces any existing values associated with key. The key is case insensitive; it is canonicalized by textproto.CanonicalMIMEHeaderKey. To use non-canonical keys, assign to the map directly.</source>
          <target state="translated">Установка устанавливает значения заголовков,связанных с ключом,на единичное значение элемента.Он заменяет любые существующие значения,связанные с ключом.Клавиша не чувствительна к регистру;она канонизирована textproto.CanonicalMIMEHeaderKey.Чтобы использовать неканонические ключи,назначьте их непосредственно на карту.</target>
        </trans-unit>
        <trans-unit id="ac88d8d813ac589b26e82c68ebe23a65cc8513a6" translate="yes" xml:space="preserve">
          <source>Set sets the key to value. It replaces any existing values.</source>
          <target state="translated">Установите значение клавиши.Он заменяет любые существующие значения.</target>
        </trans-unit>
        <trans-unit id="03d2da815b81b3b89a818437487ee57f67fe7d66" translate="yes" xml:space="preserve">
          <source>Set sets the value of the named command-line flag.</source>
          <target state="translated">Устанавливает значение флага именованной командной строки.</target>
        </trans-unit>
        <trans-unit id="f73f9638b07619a017d2f6dac015fd0d243d8333" translate="yes" xml:space="preserve">
          <source>Set sets the value of the named flag.</source>
          <target state="translated">Установка устанавливает значение именованного флага.</target>
        </trans-unit>
        <trans-unit id="2c301753363dd5c13e85e87be14b65f72e0bdbb9" translate="yes" xml:space="preserve">
          <source>Set sets v to value.</source>
          <target state="translated">Установите значение v.</target>
        </trans-unit>
        <trans-unit id="0e0649c67f5fc5e092366b50d2ec623dd85834a8" translate="yes" xml:space="preserve">
          <source>Set sets z to the (possibly rounded) value of x and returns z. If z's precision is 0, it is changed to the precision of x before setting z (and rounding will have no effect). Rounding is performed according to z's precision and rounding mode; and z's accuracy reports the result error relative to the exact (not rounded) result.</source>
          <target state="translated">Установите z в значение (возможно,округленное)x и верните z.Если точность z равна 0,то перед установкой z она будет изменена на точность x (и округление не будет иметь никакого эффекта).Скругление выполняется в соответствии с точностью z и режимом округления;а точность z сообщает о погрешности результата относительно точного (не округленного)результата.</target>
        </trans-unit>
        <trans-unit id="74c097d8a8db6198a9f30d1da9cc40810faf97ea" translate="yes" xml:space="preserve">
          <source>Set sets z to x (by making a copy of x) and returns z.</source>
          <target state="translated">Установите z в x (сделав копию x)и верните z.</target>
        </trans-unit>
        <trans-unit id="2de2c16a0340db2bee0118ccf9d1587fd704cd50" translate="yes" xml:space="preserve">
          <source>Set sets z to x and returns z.</source>
          <target state="translated">Установите z в x и верните z.</target>
        </trans-unit>
        <trans-unit id="fd19264e05439f601808981687979a9cbd55329f" translate="yes" xml:space="preserve">
          <source>SetBasicAuth sets the request's Authorization header to use HTTP Basic Authentication with the provided username and password.</source>
          <target state="translated">SetBasicAuth устанавливает заголовок Авторизации запроса для использования базовой HTTP-аутентификации с предоставленными именем пользователя и паролем.</target>
        </trans-unit>
        <trans-unit id="22bdae472d3db85cab5c57989c6be910d803a01e" translate="yes" xml:space="preserve">
          <source>SetBit sets z to x, with x's i'th bit set to b (0 or 1). That is, if b is 1 SetBit sets z = x | (1 &amp;lt;&amp;lt; i); if b is 0 SetBit sets z = x &amp;amp;^ (1 &amp;lt;&amp;lt; i). If b is not 0 or 1, SetBit will panic.</source>
          <target state="translated">SetBit устанавливает z равным x, а i-й бит x установлен в b (0 или 1). То есть, если b равно 1, SetBit устанавливает z = x | (1 &amp;lt;&amp;lt; i); если b равно 0, SetBit устанавливает z = x &amp;amp; ^ (1 &amp;lt;&amp;lt; i). Если b не равно 0 или 1, SetBit запаникует.</target>
        </trans-unit>
        <trans-unit id="feba31f1e1635889b9235c6993fbb340077ba325" translate="yes" xml:space="preserve">
          <source>SetBits provides raw (unchecked but fast) access to z by setting its value to abs, interpreted as a little-endian Word slice, and returning z. The result and abs share the same underlying array. SetBits is intended to support implementation of missing low-level Int functionality outside this package; it should be avoided otherwise.</source>
          <target state="translated">SetBits обеспечивает необработанный (неотмеченный,но быстрый)доступ к z,устанавливая его значение в abs,интерпретируемый как младший срез Word,и возвращая z.Результат и abs разделяют один и тот же базовый массив.SetBits предназначен для поддержки реализации недостающей низкоуровневой Int-функциональности вне данного пакета;в противном случае этого следует избегать.</target>
        </trans-unit>
        <trans-unit id="f0a90ede61cca8ba0e26af9fe2c3c6480079bf80" translate="yes" xml:space="preserve">
          <source>SetBlockProfileRate controls the fraction of goroutine blocking events that are reported in the blocking profile. The profiler aims to sample an average of one blocking event per rate nanoseconds spent blocked.</source>
          <target state="translated">SetBlockProfileRate управляет долей событий блокировки гортани,которые сообщаются в профиле блокировки.Профилировщик нацелен на выборку среднего значения одного блокирующего события на скорость в наносекунды,потраченную на блокировку.</target>
        </trans-unit>
        <trans-unit id="459d3a69d65d385fb3b3fbe398bb9c85138ddcc2" translate="yes" xml:space="preserve">
          <source>SetBool sets v's underlying value. It panics if v's Kind is not Bool or if CanSet() is false.</source>
          <target state="translated">SetBool устанавливает базовое значение v.Она паникует,если v's Kind не является Bool или если CanSet()является false.</target>
        </trans-unit>
        <trans-unit id="7e2455227631da0419c37dea6613f51644e9e03d" translate="yes" xml:space="preserve">
          <source>SetBoundary must be called before any parts are created, may only contain certain ASCII characters, and must be non-empty and at most 70 bytes long.</source>
          <target state="translated">Граница SetBoundary должна быть вызвана перед созданием любой части,может содержать только определенные ASCII-символы,должна быть непустой и иметь длину не более 70 байт.</target>
        </trans-unit>
        <trans-unit id="b06cf4ca1fda2091c2541de19f0b4a515ade4ba9" translate="yes" xml:space="preserve">
          <source>SetBoundary overrides the Writer's default randomly-generated boundary separator with an explicit value.</source>
          <target state="translated">SetBoundary переопределяет случайно сгенерированный по умолчанию в Writer разделитель границ с явным значением.</target>
        </trans-unit>
        <trans-unit id="6106f2ae31464af3b2e7f9b63e64b76356750152" translate="yes" xml:space="preserve">
          <source>SetBytes interprets buf as the bytes of a big-endian unsigned integer, sets z to that value, and returns z.</source>
          <target state="translated">SetBytes интерпретирует buf как байты большого беззнакового целого,устанавливает z в это значение и возвращает z.</target>
        </trans-unit>
        <trans-unit id="7a0583b12bc86b9434e36c34c4ce6e8b5c26ba75" translate="yes" xml:space="preserve">
          <source>SetBytes records the number of bytes processed in a single operation. If this is called, the benchmark will report ns/op and MB/s.</source>
          <target state="translated">SetBytes записывает количество байт,обработанных за одну операцию.При вызове этой записи эталонный тест выдаст отчет ns/op и MB/s.</target>
        </trans-unit>
        <trans-unit id="bba92654aa999e9512f4dfa6313cb2838144dfe3" translate="yes" xml:space="preserve">
          <source>SetBytes sets v's underlying value. It panics if v's underlying value is not a slice of bytes.</source>
          <target state="translated">SetBytes устанавливает базовое значение v.Она паникует,если базовое значение v не является кусочком байта.</target>
        </trans-unit>
        <trans-unit id="344d8ddf2a696d0cf0cc16a1825af1241c772a89" translate="yes" xml:space="preserve">
          <source>SetCPUProfileRate sets the CPU profiling rate to hz samples per second. If hz &amp;lt;= 0, SetCPUProfileRate turns off profiling. If the profiler is on, the rate cannot be changed without first turning it off.</source>
          <target state="translated">SetCPUProfileRate устанавливает частоту профилирования ЦП в Гц выборок в секунду. Если hz &amp;lt;= 0, SetCPUProfileRate отключает профилирование. Если профилировщик включен, скорость нельзя изменить, не выключив его предварительно.</target>
        </trans-unit>
        <trans-unit id="1afcde63337e23e05a9b84c1c7b85f57c0092cd7" translate="yes" xml:space="preserve">
          <source>SetCap sets v's capacity to n. It panics if v's Kind is not Slice or if n is smaller than the length or greater than the capacity of the slice.</source>
          <target state="translated">SetCap устанавливает емкость v на n.Она паникует,если v's Kind не является Slice или если n меньше длины или больше емкости ломтика.</target>
        </trans-unit>
        <trans-unit id="44731bc16b3d80516224c7c852f64732d07d62c1" translate="yes" xml:space="preserve">
          <source>SetCgoTraceback records three C functions to use to gather traceback information from C code and to convert that traceback information into symbolic information. These are used when printing stack traces for a program that uses cgo.</source>
          <target state="translated">SetCgoTraceback записывает три функции C для сбора информации о трассировке из кода C и преобразования этой информации в символическую информацию.Они используются при печати трасс в стеке для программы,использующей Cgo.</target>
        </trans-unit>
        <trans-unit id="348727b9cf484ab1b9762cea6ba0daa8dde8a933" translate="yes" xml:space="preserve">
          <source>SetCgoTraceback should be called only once, ideally from an init function.</source>
          <target state="translated">SetCgoTraceback должен вызываться только один раз,в идеале из функции init.</target>
        </trans-unit>
        <trans-unit id="67fdfbbba9d56846727e0eb32ef8332c0bf20f53" translate="yes" xml:space="preserve">
          <source>SetComment sets the end-of-central-directory comment field. It can only be called before Close.</source>
          <target state="translated">SetComment устанавливает поле комментария в конце центрального каталога.Оно может быть вызвано только перед закрытием.</target>
        </trans-unit>
        <trans-unit id="64f03250bccb0b87aeb45d79cb945d1dd0319cb9" translate="yes" xml:space="preserve">
          <source>SetComplex sets v's underlying value to x. It panics if v's Kind is not Complex64 or Complex128, or if CanSet() is false.</source>
          <target state="translated">SetComplex устанавливает базовое значение v в x.Он паникует,если v's Kind не является Complex64 или Complex128,или если CanSet()является false.</target>
        </trans-unit>
        <trans-unit id="ac6f79734771b4e3adca460b8931ae634206e20f" translate="yes" xml:space="preserve">
          <source>SetConnMaxLifetime sets the maximum amount of time a connection may be reused.</source>
          <target state="translated">SetConnMaxLifetime устанавливает максимальное время,в течение которого соединение может быть использовано повторно.</target>
        </trans-unit>
        <trans-unit id="cdfc398e60b71e846a0a56ba3b1860f275a8c713" translate="yes" xml:space="preserve">
          <source>SetCookie adds a Set-Cookie header to the provided ResponseWriter's headers. The provided cookie must have a valid Name. Invalid cookies may be silently dropped.</source>
          <target state="translated">SetCookie добавляет заголовок Set-Cookie к предоставленным заголовкам ResponseWriter.Предоставленный файл cookie должен иметь правильное Имя.Недействительные куки-файлы могут быть незаметно удалены.</target>
        </trans-unit>
        <trans-unit id="b1b53737e17baa71a51a0e5ede6a121ccba30720" translate="yes" xml:space="preserve">
          <source>SetCookies implements the SetCookies method of the http.CookieJar interface.</source>
          <target state="translated">SetCookies реализует метод SetCookies интерфейса http.CookieJar.</target>
        </trans-unit>
        <trans-unit id="d3cec8d8761e8a9c75efaa51883455428c208775" translate="yes" xml:space="preserve">
          <source>SetDeadline implements the Conn SetDeadline method.</source>
          <target state="translated">SetDeadline реализует метод Conn SetDeadline.</target>
        </trans-unit>
        <trans-unit id="c0b50695667af085ed75f6ae0d7d496b50008cd3" translate="yes" xml:space="preserve">
          <source>SetDeadline sets the deadline associated with the listener. A zero time value disables the deadline.</source>
          <target state="translated">SetDeadline устанавливает крайний срок,связанный со слушателем.Значение нулевого времени отключает срок.</target>
        </trans-unit>
        <trans-unit id="a7b4723a8859169359d85b5290587d68a0fc3307" translate="yes" xml:space="preserve">
          <source>SetDeadline sets the read and write deadlines associated with the connection. A zero value for t means Read and Write will not time out. After a Write has timed out, the TLS state is corrupt and all future writes will return the same error.</source>
          <target state="translated">SetDeadline устанавливает сроки чтения и записи,связанные с подключением.Нулевое значение для t означает,что Read and Write (Чтение и запись)не будет тайм-аутом.После тайм-аута Write (Запись)состояние TLS повреждено,и все последующие операции записи возвращают ту же ошибку.</target>
        </trans-unit>
        <trans-unit id="883b1167470e9a9bc17df175940ef7113ec71b15" translate="yes" xml:space="preserve">
          <source>SetDeadline sets the read and write deadlines for a File. It is equivalent to calling both SetReadDeadline and SetWriteDeadline.</source>
          <target state="translated">SetDeadline устанавливает сроки чтения и записи Файла.Это эквивалентно вызову как SetReadDeadline,так и SetWriteDeadline.</target>
        </trans-unit>
        <trans-unit id="7aad8c47d1ea7eb52b60d62c5b63c9894a7f6a08" translate="yes" xml:space="preserve">
          <source>SetEscapeHTML specifies whether problematic HTML characters should be escaped inside JSON quoted strings. The default behavior is to escape &amp;amp;, &amp;lt;, and &amp;gt; to \u0026, \u003c, and \u003e to avoid certain safety problems that can arise when embedding JSON in HTML.</source>
          <target state="translated">SetEscapeHTML указывает, следует ли экранировать проблемные символы HTML внутри строк в кавычках JSON. По умолчанию символы &amp;amp;, &amp;lt;и&amp;gt; заменяются на \ u0026, \ u003c и&amp;gt;, чтобы избежать некоторых проблем безопасности, которые могут возникнуть при встраивании JSON в HTML.</target>
        </trans-unit>
        <trans-unit id="dd27241a174aea4c1fb70802e55de9c35c7e1aca" translate="yes" xml:space="preserve">
          <source>SetFinalizer sets the finalizer associated with obj to the provided finalizer function. When the garbage collector finds an unreachable block with an associated finalizer, it clears the association and runs finalizer(obj) in a separate goroutine. This makes obj reachable again, but now without an associated finalizer. Assuming that SetFinalizer is not called again, the next time the garbage collector sees that obj is unreachable, it will free obj.</source>
          <target state="translated">SetFinalizer устанавливает финализатор,связанный с объектом функции предоставляемого финализатора.Когда сборщик мусора находит недоступный блок с ассоциированным финализатором,он очищает ассоциацию и запускает финализатор(объект)в отдельном goroutine.Это снова делает объект доступным,но теперь без связанного с ним финализатора.Если предположить,что SetFinalizer не будет вызван снова,то в следующий раз,когда сборщик мусора увидит,что объект недоступен,он освободит объект.</target>
        </trans-unit>
        <trans-unit id="516de8a9b6e7300def0c0d80a14119cce09c9af1" translate="yes" xml:space="preserve">
          <source>SetFinalizer(obj, nil) clears any finalizer associated with obj.</source>
          <target state="translated">SetFinalizer(obj,nil)очищает любой финализатор,связанный с объектом.</target>
        </trans-unit>
        <trans-unit id="fce6aef209330cc8b12176816b79927fb4cacd60" translate="yes" xml:space="preserve">
          <source>SetFlags sets the output flags for the logger.</source>
          <target state="translated">SetFlags устанавливает выходные флаги для регистратора.</target>
        </trans-unit>
        <trans-unit id="dd0ec7930cc082a2a1ef8ed98443be56c5746d85" translate="yes" xml:space="preserve">
          <source>SetFlags sets the output flags for the standard logger.</source>
          <target state="translated">SetFlags устанавливает флаги вывода для стандартного регистратора.</target>
        </trans-unit>
        <trans-unit id="a44e49f661219c769f20780167a6964483f17f7a" translate="yes" xml:space="preserve">
          <source>SetFloat sets v's underlying value to x. It panics if v's Kind is not Float32 or Float64, or if CanSet() is false.</source>
          <target state="translated">SetFloat устанавливает базовое значение v в x.Он паникует,если Kind v не Float32 или Float64,или если CanSet()ложна.</target>
        </trans-unit>
        <trans-unit id="8e47d96a49d3af2841a8dc184d5134cb1a32de48" translate="yes" xml:space="preserve">
          <source>SetFloat64 sets z to exactly f and returns z. If f is not finite, SetFloat returns nil.</source>
          <target state="translated">SetFloat64 устанавливает z точно в f и возвращает z.Если f не конечен,SetFloat возвращает ноль.</target>
        </trans-unit>
        <trans-unit id="7d8e2534e02690c3fed1859413bf2f8f63c436f1" translate="yes" xml:space="preserve">
          <source>SetFloat64 sets z to the (possibly rounded) value of x and returns z. If z's precision is 0, it is changed to 53 (and rounding will have no effect). SetFloat64 panics with ErrNaN if x is a NaN.</source>
          <target state="translated">SetFloat64 устанавливает z в (возможно,округленное)значение x и возвращает z.Если точность z равна 0,то она изменяется на 53 (и округление не будет иметь эффекта).SetFloat64 паникует с ErrNaN,если x является NaN.</target>
        </trans-unit>
        <trans-unit id="7b801568b0fa82e3d000c6cfdb98f7b328836a9b" translate="yes" xml:space="preserve">
          <source>SetFrac sets z to a/b and returns z.</source>
          <target state="translated">SetFrac устанавливает z в a/b и возвращает z.</target>
        </trans-unit>
        <trans-unit id="45fde5eac415722d6b8394ea7547d400d1373021" translate="yes" xml:space="preserve">
          <source>SetFrac64 sets z to a/b and returns z.</source>
          <target state="translated">SetFrac64 устанавливает z в a/b и возвращает z.</target>
        </trans-unit>
        <trans-unit id="805636f93a7dd0b6aa2183e35b0d00ca6d7104e9" translate="yes" xml:space="preserve">
          <source>SetGCPercent sets the garbage collection target percentage: a collection is triggered when the ratio of freshly allocated data to live data remaining after the previous collection reaches this percentage. SetGCPercent returns the previous setting. The initial setting is the value of the GOGC environment variable at startup, or 100 if the variable is not set. A negative percentage disables garbage collection.</source>
          <target state="translated">SetGCPercent задает целевой процент сбора мусора:сбор срабатывает,когда отношение свежих выделенных данных к живым данным,оставшимся после предыдущей сборки,достигает этого процента.SetGCPercent возвращает предыдущую установку.Исходной установкой является значение переменной окружения GOGC при запуске или 100,если переменная не установлена.Отрицательный процент отключает сбор мусора.</target>
        </trans-unit>
        <trans-unit id="906978195b1fb386902e36080f453c88d02f6211" translate="yes" xml:space="preserve">
          <source>SetGoroutineLabels sets the current goroutine's labels to match ctx. A new goroutine inherits the labels of the goroutine that created it. This is a lower-level API than Do, which should be used instead when possible.</source>
          <target state="translated">SetGoroutineLabels устанавливает метки текущего goroutine в соответствии с ctx.Новый горутин наследует метки создавшего его горутина.Это API более низкого уровня,чем Do,который следует использовать вместо него,когда это возможно.</target>
        </trans-unit>
        <trans-unit id="7c95fdd46823686f50f0d15060d185e4b4e5d563" translate="yes" xml:space="preserve">
          <source>SetImports sets the list of explicitly imported packages to list. It is the caller's responsibility to make sure list elements are unique.</source>
          <target state="translated">SetImports устанавливает список явно импортированных пакетов.Ответственность за уникальность элементов списка лежит на вызывающем абоненте.</target>
        </trans-unit>
        <trans-unit id="e7fb2cb55e4274d490452e6757d30cb84eb70855" translate="yes" xml:space="preserve">
          <source>SetIndent instructs the encoder to format each subsequent encoded value as if indented by the package-level function Indent(dst, src, prefix, indent). Calling SetIndent(&quot;&quot;, &quot;&quot;) disables indentation.</source>
          <target state="translated">SetIndent предписывает кодировщику форматировать каждое последующее кодированное значение так,как будто оно имеет отступ от функции на уровне пакетов Indent(dst,src,префикс,отступ).Вызов SetIndent(&quot;,&quot;&quot;)отключает отступ.</target>
        </trans-unit>
        <trans-unit id="17d73d2c7105e3ec880ec1de340daf4f290af178" translate="yes" xml:space="preserve">
          <source>SetIndex sets the JavaScript index i of value v to ValueOf(x). It panics if v is not a JavaScript object.</source>
          <target state="translated">SetIndex устанавливает индекс JavaScript i значения v в значение ValueOf(x).Он паникует,если v не является объектом JavaScript.</target>
        </trans-unit>
        <trans-unit id="cea11721fc2a69428fc01f2bd7212d126248c97a" translate="yes" xml:space="preserve">
          <source>SetInf sets z to the infinite Float -Inf if signbit is set, or +Inf if signbit is not set, and returns z. The precision of z is unchanged and the result is always Exact.</source>
          <target state="translated">SetInf устанавливает z в бесконечный Float -Inf,если значок установлен,или +Inf,если значок не установлен,и возвращает z.Точность z остается неизменной,а результат всегда Точный.</target>
        </trans-unit>
        <trans-unit id="7fbe79d67709b54bb947c5fb56d1678d22a06e68" translate="yes" xml:space="preserve">
          <source>SetInt sets v's underlying value to x. It panics if v's Kind is not Int, Int8, Int16, Int32, or Int64, or if CanSet() is false.</source>
          <target state="translated">SetInt устанавливает базовое значение v в x.Он паникует,если Kind v не является Int,Int8,Int16,Int32 или Int64,или если CanSet()ложна.</target>
        </trans-unit>
        <trans-unit id="e9791f172aed7c20562244430ee2933689079ec7" translate="yes" xml:space="preserve">
          <source>SetInt sets z to the (possibly rounded) value of x and returns z. If z's precision is 0, it is changed to the larger of x.BitLen() or 64 (and rounding will have no effect).</source>
          <target state="translated">SetInt устанавливает z в (возможно,округленное)значение x и возвращает z.Если точность z равна 0,то она изменяется на большую из x.BitLen()или 64 (и округление не будет иметь эффекта).</target>
        </trans-unit>
        <trans-unit id="512491a3910b089e941ff0967a1c4600d38512e1" translate="yes" xml:space="preserve">
          <source>SetInt sets z to x (by making a copy of x) and returns z.</source>
          <target state="translated">SetInt устанавливает z в x (делая копию x)и возвращает z.</target>
        </trans-unit>
        <trans-unit id="e98bca88644a6b411de0d879f43c3dc3a73ef347" translate="yes" xml:space="preserve">
          <source>SetInt64 sets z to the (possibly rounded) value of x and returns z. If z's precision is 0, it is changed to 64 (and rounding will have no effect).</source>
          <target state="translated">SetInt64 устанавливает z в (возможно,округленное)значение x и возвращает z.Если точность z равна 0,то она изменяется на 64 (и округление не будет иметь эффекта).</target>
        </trans-unit>
        <trans-unit id="b8bc149266ba57391034d803e65399926af1a382" translate="yes" xml:space="preserve">
          <source>SetInt64 sets z to x and returns z.</source>
          <target state="translated">SetInt64 устанавливает z в x и возвращает z.</target>
        </trans-unit>
        <trans-unit id="d8ce7465b1093a7258c6cd344217beee671aa978" translate="yes" xml:space="preserve">
          <source>SetKeepAlive sets whether the operating system should send keep-alive messages on the connection.</source>
          <target state="translated">SetKeepAlive устанавливает,должна ли операционная система посылать сообщения о соединении в режиме реального времени.</target>
        </trans-unit>
        <trans-unit id="89bf3d4dd275ff44ab7379e669050fce6f5a7eee" translate="yes" xml:space="preserve">
          <source>SetKeepAlivePeriod sets period between keep-alives.</source>
          <target state="translated">SetKeepAlivePeriod задает период между сохранением жизни.</target>
        </trans-unit>
        <trans-unit id="582102a7fa3d8dd186ee22dfa213a701e54c1846" translate="yes" xml:space="preserve">
          <source>SetKeepAlivesEnabled controls whether HTTP keep-alives are enabled. By default, keep-alives are always enabled. Only very resource-constrained environments or servers in the process of shutting down should disable them.</source>
          <target state="translated">SetKeepAlivesEnabled контролирует,включены ли HTTP keep-alives.По умолчанию keep-alives всегда включен.Только очень ограниченные ресурсы окружения или серверы,находящиеся в процессе выключения,должны их отключать.</target>
        </trans-unit>
        <trans-unit id="26dfe6afebdd675610dd8f1d4858b29cc7ee92db" translate="yes" xml:space="preserve">
          <source>SetLen sets v's length to n. It panics if v's Kind is not Slice or if n is negative or greater than the capacity of the slice.</source>
          <target state="translated">SetLen устанавливает длину v в n.Она паникует,если v's Kind не является Slice или если n отрицательно или больше емкости среза.</target>
        </trans-unit>
        <trans-unit id="549c2b676df9b698394503e0fb62c18e8fa20e0b" translate="yes" xml:space="preserve">
          <source>SetLines sets the line offsets for a file and reports whether it succeeded. The line offsets are the offsets of the first character of each line; for instance for the content &quot;ab\nc\n&quot; the line offsets are {0, 3}. An empty file has an empty line offset table. Each line offset must be larger than the offset for the previous line and smaller than the file size; otherwise SetLines fails and returns false. Callers must not mutate the provided slice after SetLines returns.</source>
          <target state="translated">SetLines устанавливает смещение строки для файла и сообщает,удалось ли это сделать.Смещения строк-это смещения первого символа каждой строки;например,для содержимого &quot;ab\nc\n&quot; смещения строк-{0,3}.Пустой файл имеет пустую таблицу смещения строк.Каждое смещение строки должно быть больше,чем смещение для предыдущей строки и меньше,чем размер файла;в противном случае SetLines терпит неудачу и возвращает false.После возврата SetLines вызывающие абоненты не должны мутировать предоставленный фрагмент.</target>
        </trans-unit>
        <trans-unit id="d21966bc8423cbdfca9062e709a1e1bfe2b23f9c" translate="yes" xml:space="preserve">
          <source>SetLinesForContent sets the line offsets for the given file content. It ignores position-altering //line comments.</source>
          <target state="translated">SetLinesForContent устанавливает смещение строки для данного содержимого файла.Игнорирует изменение позиции //комментарий к строке.</target>
        </trans-unit>
        <trans-unit id="7ead5ff3e458c012090db0e3e46dd956293c59f9" translate="yes" xml:space="preserve">
          <source>SetLinger sets the behavior of Close on a connection which still has data waiting to be sent or to be acknowledged.</source>
          <target state="translated">SetLinger устанавливает поведение Close (Закрыть)при соединении,данные которого все еще ожидают отправки или квитирования.</target>
        </trans-unit>
        <trans-unit id="be9cec1a054bdf6dae13515b712cb92bca8f03d8" translate="yes" xml:space="preserve">
          <source>SetMantExp sets z to mant &amp;times; 2**exp and returns z. The result z has the same precision and rounding mode as mant. SetMantExp is an inverse of MantExp but does not require 0.5 &amp;lt;= |mant| &amp;lt; 1.0. Specifically:</source>
          <target state="translated">SetMantExp устанавливает z равным mant &amp;times; 2 ** exp и возвращает z. Результат z имеет ту же точность и режим округления, что и mant. SetMantExp является инверсией MantExp, но не требует 0,5 &amp;lt;= | mant | &amp;lt;1.0. В частности:</target>
        </trans-unit>
        <trans-unit id="e756f252cafbddbad755f1c06583ad4489564d92" translate="yes" xml:space="preserve">
          <source>SetMapIndex sets the element associated with key in the map v to elem. It panics if v's Kind is not Map. If elem is the zero Value, SetMapIndex deletes the key from the map. Otherwise if v holds a nil map, SetMapIndex will panic. As in Go, key's elem must be assignable to the map's key type, and elem's value must be assignable to the map's elem type.</source>
          <target state="translated">SetMapIndex устанавливает элемент,связанный с ключом на карте v в elem.Он паникует,если v's Kind не является Map.Если элем-нулевое значение,SetMapIndex удаляет ключ с карты.В противном случае,если v держит карту с нулевым значением,SetMapIndex запаникует.Как и в Go,элем ключа должен быть присвоен типу ключа на карте,а значение элемента должно быть присвоено типу элемента на карте.</target>
        </trans-unit>
        <trans-unit id="b83dfa89acb5e3c977158b5fc2760de63b71e48b" translate="yes" xml:space="preserve">
          <source>SetMaxIdleConns sets the maximum number of connections in the idle connection pool.</source>
          <target state="translated">SetMaxIdleConns устанавливает максимальное количество соединений в пуле соединений в режиме ожидания.</target>
        </trans-unit>
        <trans-unit id="aa3863aa142a9c48791c290f00a7c4c3d76f3b6e" translate="yes" xml:space="preserve">
          <source>SetMaxOpenConns sets the maximum number of open connections to the database.</source>
          <target state="translated">SetMaxOpenConns устанавливает максимальное количество открытых подключений к БД.</target>
        </trans-unit>
        <trans-unit id="f71d21e95f096f232e72fff30f80b920b1e3f9f5" translate="yes" xml:space="preserve">
          <source>SetMaxStack is useful mainly for limiting the damage done by goroutines that enter an infinite recursion. It only limits future stack growth.</source>
          <target state="translated">SetMaxStack полезен главным образом для ограничения ущерба,наносимого гориллами,входящими в бесконечную рекурсию.Она ограничивает только будущий рост стека.</target>
        </trans-unit>
        <trans-unit id="eeacbe78a8fd0d4396f1b6456e34f5857612c565" translate="yes" xml:space="preserve">
          <source>SetMaxStack sets the maximum amount of memory that can be used by a single goroutine stack. If any goroutine exceeds this limit while growing its stack, the program crashes. SetMaxStack returns the previous setting. The initial setting is 1 GB on 64-bit systems, 250 MB on 32-bit systems.</source>
          <target state="translated">SetMaxStack устанавливает максимальный объем памяти,который может быть использован одним горутинным стеком.Если при выращивании стека какой-нибудь горутин превысит этот предел,программа аварийно завершает свою работу.SetMaxStack возвращает предыдущую установку.Начальная установка составляет 1 Гб на 64-битных системах,250 Мб на 32-битных системах.</target>
        </trans-unit>
        <trans-unit id="67aff5f59d34d3ecd519adad914c8c6423eaf752" translate="yes" xml:space="preserve">
          <source>SetMaxThreads is useful mainly for limiting the damage done by programs that create an unbounded number of threads. The idea is to take down the program before it takes down the operating system.</source>
          <target state="translated">SetMaxThreads полезен в основном для ограничения ущерба,наносимого программами,создающими неограниченное количество потоков.Идея заключается в том,чтобы снести программу до того,как она снесет операционную систему.</target>
        </trans-unit>
        <trans-unit id="c6d8bc8cae003fe5d78cf6cda31fbae67e36c482" translate="yes" xml:space="preserve">
          <source>SetMaxThreads sets the maximum number of operating system threads that the Go program can use. If it attempts to use more than this many, the program crashes. SetMaxThreads returns the previous setting. The initial setting is 10,000 threads.</source>
          <target state="translated">SetMaxThreads устанавливает максимальное количество потоков операционной системы,которые может использовать программа Go.Если она попытается использовать больше этого количества,программа аварийно завершает работу.SetMaxThreads возвращает предыдущую установку.Исходной установкой является 10 000 потоков.</target>
        </trans-unit>
        <trans-unit id="806ff185f3a93cc6a21f24b12259c49de358388c" translate="yes" xml:space="preserve">
          <source>SetModTime sets the Modified, ModifiedTime, and ModifiedDate fields to the given time in UTC.</source>
          <target state="translated">SetModTime устанавливает поля Modified,ModifiedTime и ModifiedDate на заданное время по UTC.</target>
        </trans-unit>
        <trans-unit id="e9c592771061ffaaa3d588fb3aae3da84d0635b8" translate="yes" xml:space="preserve">
          <source>SetMode changes the permission and mode bits for the FileHeader.</source>
          <target state="translated">SetMode изменяет биты разрешения и режима для FileHeader.</target>
        </trans-unit>
        <trans-unit id="de45da11e316c622a3816956315a15e8817585f9" translate="yes" xml:space="preserve">
          <source>SetMode sets z's rounding mode to mode and returns an exact z. z remains unchanged otherwise. z.SetMode(z.Mode()) is a cheap way to set z's accuracy to Exact.</source>
          <target state="translated">SetMode устанавливает режим округления z в режим и возвращает точное z.z остается неизменным в противном случае.z.SetMode(z.Mode())-это дешевый способ установить точность z в Точность.</target>
        </trans-unit>
        <trans-unit id="b01a08220867d2b1a3c66f3bf6f8b7ca7ea5c1ae" translate="yes" xml:space="preserve">
          <source>SetMutexProfileFraction controls the fraction of mutex contention events that are reported in the mutex profile. On average 1/rate events are reported. The previous rate is returned.</source>
          <target state="translated">SetMutexProfileFraction управляет долей событий соприкосновения мьютекса,которые сообщаются в профиле мьютекса.В среднем сообщается о событиях 1/статистики.Возвращается предыдущая ставка.</target>
        </trans-unit>
        <trans-unit id="8c38b4a404d96b417f171861cd9ebaba18b51eaf" translate="yes" xml:space="preserve">
          <source>SetName sets the package name.</source>
          <target state="translated">SetName задает имя пакета.</target>
        </trans-unit>
        <trans-unit id="d31306f3f7eb161aa0c0b28fdb6eed5363c589c3" translate="yes" xml:space="preserve">
          <source>SetNoDelay controls whether the operating system should delay packet transmission in hopes of sending fewer packets (Nagle's algorithm). The default is true (no delay), meaning that data is sent as soon as possible after a Write.</source>
          <target state="translated">SetNoDelay контролирует,должна ли операционная система задерживать передачу пакетов в надежде отправить меньше пакетов (алгоритм Nagle).Значение по умолчанию равно true (отсутствие задержки),что означает,что данные передаются как можно быстрее после Write.</target>
        </trans-unit>
        <trans-unit id="27a3c03ba54fb2a44f36a6c425cfa58520c56752" translate="yes" xml:space="preserve">
          <source>SetOffset sets the offset of the beginning of the zip data within the underlying writer. It should be used when the zip data is appended to an existing file, such as a binary executable. It must be called before any data is written.</source>
          <target state="translated">SetOffset устанавливает смещение начала zip-данных внутри базового записывающего устройства.Его следует использовать,когда zip-данные добавляются к существующему файлу,например,к двоичному исполняемому файлу.Он должен быть вызван перед записью любых данных.</target>
        </trans-unit>
        <trans-unit id="004613f6cff6f004aabdb462fd19757cc3df0edb" translate="yes" xml:space="preserve">
          <source>SetOutput sets the destination for usage and error messages. If output is nil, os.Stderr is used.</source>
          <target state="translated">SetOutput устанавливает место назначения для сообщений об использовании и ошибках.Если вывод нулевой,используется os.Stderr.</target>
        </trans-unit>
        <trans-unit id="36faf63cafa162e1ef49476325f422ab20f856dd" translate="yes" xml:space="preserve">
          <source>SetOutput sets the output destination for the logger.</source>
          <target state="translated">SetOutput устанавливает выходной пункт назначения для регистратора.</target>
        </trans-unit>
        <trans-unit id="76988d10d7783ed1525981a82207c054e24adba8" translate="yes" xml:space="preserve">
          <source>SetOutput sets the output destination for the standard logger.</source>
          <target state="translated">SetOutput устанавливает выходной пункт назначения для стандартного регистратора.</target>
        </trans-unit>
        <trans-unit id="2547ce0f12468d65a113d53c2cfbf0ddbb6dc9bb" translate="yes" xml:space="preserve">
          <source>SetPanicOnFault controls the runtime's behavior when a program faults at an unexpected (non-nil) address. Such faults are typically caused by bugs such as runtime memory corruption, so the default response is to crash the program. Programs working with memory-mapped files or unsafe manipulation of memory may cause faults at non-nil addresses in less dramatic situations; SetPanicOnFault allows such programs to request that the runtime trigger only a panic, not a crash. SetPanicOnFault applies only to the current goroutine. It returns the previous setting.</source>
          <target state="translated">SetPanicOnFault управляет поведением во время выполнения программы при сбое по неожиданному (нулевому)адресу.Такие сбои обычно вызваны такими ошибками,как повреждение памяти во время выполнения,поэтому по умолчанию программа аварийно завершает свою работу.Программы,работающие с файлами,отображенными в памяти,или небезопасное манипулирование памятью могут вызывать сбои по нулевым адресам в менее драматичных ситуациях;SetPanicOnFault позволяет таким программам запросить,чтобы время выполнения вызывало только панику,а не аварийное завершение работы.SetPanicOnFault применяется только к текущему goroutine.Он возвращает предыдущую установку.</target>
        </trans-unit>
        <trans-unit id="72fac8e6222bd170971f1f697af6f11d0715e763" translate="yes" xml:space="preserve">
          <source>SetParallelism sets the number of goroutines used by RunParallel to p*GOMAXPROCS. There is usually no need to call SetParallelism for CPU-bound benchmarks. If p is less than 1, this call will have no effect.</source>
          <target state="translated">SetParallelism устанавливает количество goroutines,используемых RunParallel для p*GOMAXPROCS.Обычно нет необходимости вызывать SetParallelism для CPU-ориентированных бенчмарков.Если p меньше 1,то этот вызов не даст никакого эффекта.</target>
        </trans-unit>
        <trans-unit id="8bcdfe56d7b7abb5a2feda191bae07f8cec5d4b8" translate="yes" xml:space="preserve">
          <source>SetPointer sets the unsafe.Pointer value v to x. It panics if v's Kind is not UnsafePointer.</source>
          <target state="translated">SetPointer устанавливает значение опасного.Pointer v в x.Он паникует,если v's Kind не является UnsafePointer.</target>
        </trans-unit>
        <trans-unit id="59bd457f6414829faae9decbaede734f70a9845c" translate="yes" xml:space="preserve">
          <source>SetPos sets the position. NewIdentifier is a public method so we can't modify its signature. Chained for convenience. TODO: fix one day?</source>
          <target state="translated">SetPos устанавливает положение.NewIdentifier является публичным методом,поэтому мы не можем изменить его сигнатуру.Цепной для удобства.TODO:исправить один день?</target>
        </trans-unit>
        <trans-unit id="d6d5511f09814008767ff9cfe0f77abca174ef5c" translate="yes" xml:space="preserve">
          <source>SetPrec sets z's precision to prec and returns the (possibly) rounded value of z. Rounding occurs according to z's rounding mode if the mantissa cannot be represented in prec bits without loss of precision. SetPrec(0) maps all finite values to &amp;plusmn;0; infinite values remain unchanged. If prec &amp;gt; MaxPrec, it is set to MaxPrec.</source>
          <target state="translated">SetPrec устанавливает точность z в Prec и возвращает (возможно) округленное значение z. Округление происходит в соответствии с режимом округления z, если мантисса не может быть представлена ​​в предварительных битах без потери точности. SetPrec (0) отображает все конечные значения в &amp;plusmn; 0; бесконечные значения остаются неизменными. Если Prec&amp;gt; MaxPrec, устанавливается значение MaxPrec.</target>
        </trans-unit>
        <trans-unit id="d2d0c71771db3b5022796766d08921a2f8600461" translate="yes" xml:space="preserve">
          <source>SetPrefix sets the output prefix for the logger.</source>
          <target state="translated">SetPrefix устанавливает префикс выхода для регистратора.</target>
        </trans-unit>
        <trans-unit id="6bbad9fae1ec236892af0fd5032d525acd1599d4" translate="yes" xml:space="preserve">
          <source>SetPrefix sets the output prefix for the standard logger.</source>
          <target state="translated">SetPrefix устанавливает префикс выхода для стандартного регистратора.</target>
        </trans-unit>
        <trans-unit id="ad88a7e02a294ade703b1e817a40a72d93a7117f" translate="yes" xml:space="preserve">
          <source>SetRat sets z to the (possibly rounded) value of x and returns z. If z's precision is 0, it is changed to the largest of a.BitLen(), b.BitLen(), or 64; with x = a/b.</source>
          <target state="translated">SetRat устанавливает z в (возможно,округленное)значение x и возвращает z.Если точность z равна 0,то она изменяется на наибольшую из a.BitLen(),b.BitLen(),или 64;с x=a/b.</target>
        </trans-unit>
        <trans-unit id="6d4064f9d933c367ae2ed00ed675edff7a545a0e" translate="yes" xml:space="preserve">
          <source>SetReadBuffer sets the size of the operating system's receive buffer associated with the connection.</source>
          <target state="translated">SetReadBuffer задаёт размер буфера приёма операционной системы,связанного с подключением.</target>
        </trans-unit>
        <trans-unit id="ccd6113cf88478a21eac0a31572f18b8edd4bad3" translate="yes" xml:space="preserve">
          <source>SetReadDeadline implements the Conn SetReadDeadline method.</source>
          <target state="translated">SetReadDeadline реализует метод Conn SetReadDeadline.</target>
        </trans-unit>
        <trans-unit id="73112eb9e955bd18073b2a5d03cd0dc0569c7e77" translate="yes" xml:space="preserve">
          <source>SetReadDeadline sets the deadline for future Read calls and any currently-blocked Read call. A zero value for t means Read will not time out. Not all files support setting deadlines; see SetDeadline.</source>
          <target state="translated">SetReadDeadline устанавливает крайний срок для будущих Чтение вызовов и любого текущего заблокированного Чтение вызова.Нулевое значение для t означает,что Read не будет тайм-аутом.Не все файлы поддерживают установку сроков;см.раздел SetDeadline.</target>
        </trans-unit>
        <trans-unit id="fed46b093271b3a5ec6430ef1d4235557caf69e8" translate="yes" xml:space="preserve">
          <source>SetReadDeadline sets the read deadline on the underlying connection. A zero value for t means Read will not time out.</source>
          <target state="translated">SetReadDeadline устанавливает срок считывания для базового соединения.Нулевое значение для t означает,что Read не будет тайм-аутом.</target>
        </trans-unit>
        <trans-unit id="c85e891cbcac943a2a1c3092ec5cc6bdcd4ebc48" translate="yes" xml:space="preserve">
          <source>SetSessionTicketKeys updates the session ticket keys for a server. The first key will be used when creating new tickets, while all keys can be used for decrypting tickets. It is safe to call this function while the server is running in order to rotate the session ticket keys. The function will panic if keys is empty.</source>
          <target state="translated">SetSessionTicketKeys обновляет ключи билета сессии для сервера.Первый ключ будет использоваться при создании новых билетов,а все ключи можно использовать для расшифровки билетов.Эту функцию можно безопасно вызывать во время работы сервера,чтобы вращать тикет ключей сеанса.Функция будет паниковать,если ключи пустые.</target>
        </trans-unit>
        <trans-unit id="8a945e442cacd2fa72eff38e8c9f6290d8ddbda2" translate="yes" xml:space="preserve">
          <source>SetString sets v's underlying value to x. It panics if v's Kind is not String or if CanSet() is false.</source>
          <target state="translated">SetString устанавливает базовое значение v в x.Она паникует,если v's Kind не является String или если CanSet()является false.</target>
        </trans-unit>
        <trans-unit id="e889ea521a067b34dab32ac1ec6528fffbf097cc" translate="yes" xml:space="preserve">
          <source>SetString sets z to the value of s and returns z and a boolean indicating success. s can be given as a (possibly signed) fraction &quot;a/b&quot;, or as a floating-point number optionally followed by an exponent. If a fraction is provided, both the dividend and the divisor may be a decimal integer or independently use a prefix of &amp;ldquo;0b&amp;rdquo;, &amp;ldquo;0&amp;rdquo; or &amp;ldquo;0o&amp;rdquo;, or &amp;ldquo;0x&amp;rdquo; (or their upper-case variants) to denote a binary, octal, or hexadecimal integer, respectively. The divisor may not be signed. If a floating-point number is provided, it may be in decimal form or use any of the same prefixes as above but for &amp;ldquo;0&amp;rdquo; to denote a non-decimal mantissa. A leading &amp;ldquo;0&amp;rdquo; is considered a decimal leading 0; it does not indicate octal representation in this case. An optional base-10 &amp;ldquo;e&amp;rdquo; or base-2 &amp;ldquo;p&amp;rdquo; (or their upper-case variants) exponent may be provided as well, except for hexadecimal floats which only accept an (optional) &amp;ldquo;p&amp;rdquo; exponent (because an &amp;ldquo;e&amp;rdquo; or &amp;ldquo;E&amp;rdquo; cannot be distinguished from a mantissa digit). The entire string, not just a prefix, must be valid for success. If the operation failed, the value of z is undefined but the returned value is nil.</source>
          <target state="translated">SetString устанавливает z в значение s и возвращает z и логическое значение, указывающее на успех. s может быть задано как дробная часть (возможно, со знаком) &amp;laquo;a / b&amp;raquo; или как число с плавающей запятой, за которым может следовать показатель степени. Если предоставляется дробная часть, и делимое, и делитель могут быть десятичным целым числом или независимо использовать префикс &amp;laquo;0b&amp;raquo;, &amp;laquo;0&amp;raquo; или &amp;laquo;0o&amp;raquo; или &amp;laquo;0x&amp;raquo; (или их варианты в верхнем регистре) для обозначения двоичное, восьмеричное или шестнадцатеричное целое число соответственно. Делитель не может быть подписан. Если указано число с плавающей запятой, оно может быть в десятичной форме или использовать любой из тех же префиксов, что и выше, но для обозначения &amp;laquo;0&amp;raquo; недесятичной мантиссы. Ведущий &amp;laquo;0&amp;raquo; считается ведущим десятичным 0; в этом случае он не указывает восьмеричное представление. Также может быть предоставлен необязательный показатель степени с основанием 10 &amp;laquo;e&amp;raquo; или основанием 2 &amp;laquo;p&amp;raquo; (или их варианты в верхнем регистре),за исключением шестнадцатеричных чисел с плавающей запятой, которые принимают только (необязательный) показатель степени &amp;laquo;p&amp;raquo; (потому что &amp;laquo;e&amp;raquo; или &amp;laquo;E&amp;raquo; нельзя отличить от цифры мантиссы). Для успеха должна быть действительна вся строка, а не только префикс. Если операция завершилась неудачно, значение z не определено, но возвращаемое значение равно нулю.</target>
        </trans-unit>
        <trans-unit id="efbb232582df792d37509713c9b27b267d546a58" translate="yes" xml:space="preserve">
          <source>SetString sets z to the value of s and returns z and a boolean indicating success. s must be a floating-point number of the same format as accepted by Parse, with base argument 0. The entire string (not just a prefix) must be valid for success. If the operation failed, the value of z is undefined but the returned value is nil.</source>
          <target state="translated">SetString устанавливает z в значение s и возвращает z и булевую индикацию успеха.s должно быть числом с плавающей точкой того же формата,что и принятый Parse,с базовым аргументом 0.Вся строка (а не только префикс)должна быть действительна для успеха.Если операция не увенчалась успехом,значение z не определено,но возвращаемое значение равно нулю.</target>
        </trans-unit>
        <trans-unit id="63e18202e9d9aea4fa241b783984e3dc354de835" translate="yes" xml:space="preserve">
          <source>SetString sets z to the value of s, interpreted in the given base, and returns z and a boolean indicating success. The entire string (not just a prefix) must be valid for success. If SetString fails, the value of z is undefined but the returned value is nil.</source>
          <target state="translated">SetString устанавливает z в значение s,интерпретируемое в данной базе,и возвращает z и булевую индикацию успеха.Вся строка (а не только префикс)должна быть действительна для успеха.Если SetString терпит неудачу,значение z не определено,но возвращаемое значение равно нулю.</target>
        </trans-unit>
        <trans-unit id="38dbbaefe7e4a783f76cb46c7ca92c9417de8b66" translate="yes" xml:space="preserve">
          <source>SetTraceback sets the amount of detail printed by the runtime in the traceback it prints before exiting due to an unrecovered panic or an internal runtime error. The level argument takes the same values as the GOTRACEBACK environment variable. For example, SetTraceback(&quot;all&quot;) ensure that the program prints all goroutines when it crashes. See the package runtime documentation for details. If SetTraceback is called with a level lower than that of the environment variable, the call is ignored.</source>
          <target state="translated">SetTraceback устанавливает количество деталей,распечатанных по времени выполнения,в трассировочной ленте,которую он распечатал,перед выходом из системы в связи с необнаруженной паникой или внутренней ошибкой во время выполнения.Аргумент уровня принимает те же значения,что и переменная окружения GOTRACEBACK.Например,SetTraceback(&quot;все&quot;)гарантирует,что программа распечатает все горизонты при сбое.Подробности смотрите в документации по запуску пакета.Если SetTraceback вызывается с уровнем ниже,чем уровень переменной окружения,то вызов игнорируется.</target>
        </trans-unit>
        <trans-unit id="2fefbf475ce2643229d0cfdbfe83dace76ec0745" translate="yes" xml:space="preserve">
          <source>SetTree sets the parent tree for the node. NewIdentifier is a public method so we can't modify its signature. Chained for convenience. TODO: fix one day?</source>
          <target state="translated">SetTree устанавливает родительское дерево для узла.NewIdentifier является публичным методом,поэтому мы не можем изменить его сигнатуру.Цепи для удобства.TODO:исправить один день?</target>
        </trans-unit>
        <trans-unit id="c67115f13df235c71277ca4e4cc4cdf9edef929f" translate="yes" xml:space="preserve">
          <source>SetUint sets v's underlying value to x. It panics if v's Kind is not Uint, Uintptr, Uint8, Uint16, Uint32, or Uint64, or if CanSet() is false.</source>
          <target state="translated">SetUint устанавливает базовое значение v на x.Паникует,если v's Kind не является Uint,Uintptr,Uint8,Uint16,Uint32 или Uint64,или если CanSet()является ложным.</target>
        </trans-unit>
        <trans-unit id="a0d44c574be3e0563cede63a8860a8c3c9c0ea08" translate="yes" xml:space="preserve">
          <source>SetUint64 sets z to the (possibly rounded) value of x and returns z. If z's precision is 0, it is changed to 64 (and rounding will have no effect).</source>
          <target state="translated">SetUint64 устанавливает z в (возможно,округленное)значение x и возвращает z.Если точность z равна 0,то она изменяется на 64 (и округление не будет иметь эффекта).</target>
        </trans-unit>
        <trans-unit id="0241edc0d224ec2868d9f80a9b9550102e93ffe8" translate="yes" xml:space="preserve">
          <source>SetUint64 sets z to x and returns z.</source>
          <target state="translated">SetUint64 устанавливает z в x и возвращает z.</target>
        </trans-unit>
        <trans-unit id="d938745882d5a8df95a9972a3a9bbbee174d3301" translate="yes" xml:space="preserve">
          <source>SetUnderlying sets the underlying type and marks t as complete.</source>
          <target state="translated">SetUnderlying устанавливает тип,лежащий в основе,и метки t как полные.</target>
        </trans-unit>
        <trans-unit id="6743e47079d741cfccfdce2738e02e6efcdc6dc1" translate="yes" xml:space="preserve">
          <source>SetUnlinkOnClose sets whether the underlying socket file should be removed from the file system when the listener is closed.</source>
          <target state="translated">SetUnlinkOnClose устанавливает,следует ли удалить базовый файл сокета из файловой системы,когда слушатель закрыт.</target>
        </trans-unit>
        <trans-unit id="3a7d70c082a7c060c7f1583bead1a8cb995d2129" translate="yes" xml:space="preserve">
          <source>SetWriteBuffer sets the size of the operating system's transmit buffer associated with the connection.</source>
          <target state="translated">SetWriteBuffer задает размер связанного с соединением буфера передачи операционной системы.</target>
        </trans-unit>
        <trans-unit id="ce72366b97c1e87523bdc3b4986d2a5ed5efea78" translate="yes" xml:space="preserve">
          <source>SetWriteDeadline implements the Conn SetWriteDeadline method.</source>
          <target state="translated">SetWriteDeadline реализует метод Conn SetWriteDeadline.</target>
        </trans-unit>
        <trans-unit id="94da0323d7e4b44c2641176fd8ed70132d7e560c" translate="yes" xml:space="preserve">
          <source>SetWriteDeadline sets the deadline for any future Write calls and any currently-blocked Write call. Even if Write times out, it may return n &amp;gt; 0, indicating that some of the data was successfully written. A zero value for t means Write will not time out. Not all files support setting deadlines; see SetDeadline.</source>
          <target state="translated">SetWriteDeadline устанавливает крайний срок для любых будущих вызовов записи и любых заблокированных в настоящее время вызовов записи. Даже если время записи истекло, он может вернуть n&amp;gt; 0, указывая на то, что некоторые данные были успешно записаны. Нулевое значение t означает, что время записи не истечет. Не все файлы поддерживают установку крайних сроков; см. SetDeadline.</target>
        </trans-unit>
        <trans-unit id="e383d386b9651b389cbae33232566bb47ae2af13" translate="yes" xml:space="preserve">
          <source>SetWriteDeadline sets the write deadline on the underlying connection. A zero value for t means Write will not time out. After a Write has timed out, the TLS state is corrupt and all future writes will return the same error.</source>
          <target state="translated">SetWriteDeadline устанавливает срок записи для базового соединения.Нулевое значение для t означает,что Write не будет таймаутом.После таймаута Write (Запись)состояние TLS повреждено и все последующие записи будут возвращать одну и ту же ошибку.</target>
        </trans-unit>
        <trans-unit id="308be1977132bdbc81c0f89a2767dd32da76c702" translate="yes" xml:space="preserve">
          <source>Setenv sets the value of the environment variable named by the key. It returns an error, if any.</source>
          <target state="translated">Setenv устанавливает значение переменной окружения,именованной ключом.Возвращает ошибку,если она есть.</target>
        </trans-unit>
        <trans-unit id="509f2c6d0467d5d83c9526f638c505af46797567" translate="yes" xml:space="preserve">
          <source>Setters, numeric operations and predicates are represented as methods of the form:</source>
          <target state="translated">Установки,числовые операции и предикаты представлены в виде методов формы:</target>
        </trans-unit>
        <trans-unit id="8b84f9f04ca185b4b399c76c8fc7c01ef4f564e3" translate="yes" xml:space="preserve">
          <source>Shift returns the result of the shift expression x op s with op == token.SHL or token.SHR (&amp;lt;&amp;lt; or &amp;gt;&amp;gt;). x must be an Int or an Unknown. If x is Unknown, the result is x.</source>
          <target state="translated">Shift возвращает результат выражения сдвига x op s с op == token.SHL или token.SHR (&amp;lt;&amp;lt; или &amp;gt;&amp;gt;). x должен быть Int или Unknown. Если x неизвестно, результатом будет x.</target>
        </trans-unit>
        <trans-unit id="fde43f2305da307b56958af17198c21e47808653" translate="yes" xml:space="preserve">
          <source>Short reports whether the -test.short flag is set.</source>
          <target state="translated">Короткие сообщения о том,установлен ли флаг -test.short.</target>
        </trans-unit>
        <trans-unit id="5b772b7bfd0a43273fb7c5f49a6c16d837261f35" translate="yes" xml:space="preserve">
          <source>Shuffle</source>
          <target state="translated">Shuffle</target>
        </trans-unit>
        <trans-unit id="79a2c163367d393e517ed372229f5d310534a9d9" translate="yes" xml:space="preserve">
          <source>Shuffle (SlicesInUnison)</source>
          <target state="translated">Шаффл (SlicesInUnison)</target>
        </trans-unit>
        <trans-unit id="732d9d1b7fa9ce160a254c0eec34ec29c54e1b79" translate="yes" xml:space="preserve">
          <source>Shuffle pseudo-randomizes the order of elements using the default Source. n is the number of elements. Shuffle panics if n &amp;lt; 0. swap swaps the elements with indexes i and j.</source>
          <target state="translated">Shuffle псевдослучайно изменяет порядок элементов, используя Source по умолчанию. n - количество элементов. Shuffle вызывает панику, если n &amp;lt;0. swap меняет местами элементы с индексами i и j.</target>
        </trans-unit>
        <trans-unit id="6d3cd15e0fd6a7a5b1756b9af5c51872006c475b" translate="yes" xml:space="preserve">
          <source>Shuffle pseudo-randomizes the order of elements. n is the number of elements. Shuffle panics if n &amp;lt; 0. swap swaps the elements with indexes i and j.</source>
          <target state="translated">Shuffle псевдослучайно изменяет порядок элементов. n - количество элементов. Shuffle вызывает панику, если n &amp;lt;0. swap меняет местами элементы с индексами i и j.</target>
        </trans-unit>
        <trans-unit id="8e0c7b7cdf248102d52e5f44dcd474d4d82c359e" translate="yes" xml:space="preserve">
          <source>Shutdown does not attempt to close nor wait for hijacked connections such as WebSockets. The caller of Shutdown should separately notify such long-lived connections of shutdown and wait for them to close, if desired. See RegisterOnShutdown for a way to register shutdown notification functions.</source>
          <target state="translated">Отключение не является попыткой закрыть или дождаться перехваченных соединений,таких как WebSockets.Звонящий в Shutdown должен отдельно уведомить о завершении работы таких долгоживущих соединений и при желании дождаться их закрытия.Способ регистрации функций уведомления о выключении см.в RegisterOnShutdown.</target>
        </trans-unit>
        <trans-unit id="38dcf86ad76a9ad474561d4239201b3f812c81b9" translate="yes" xml:space="preserve">
          <source>Shutdown gracefully shuts down the server without interrupting any active connections. Shutdown works by first closing all open listeners, then closing all idle connections, and then waiting indefinitely for connections to return to idle and then shut down. If the provided context expires before the shutdown is complete, Shutdown returns the context's error, otherwise it returns any error returned from closing the Server's underlying Listener(s).</source>
          <target state="translated">Выключение изящно завершает работу сервера,не прерывая никаких активных соединений.Выключение работает следующим образом:сначала закрываются все открытые слушатели,затем закрываются все незадействованные соединения,а затем бессрочно ждут,когда соединения вернутся в состояние покоя,а затем выключаются.Если предоставленный контекст истекает до завершения выключения,то Shutdown возвращает ошибку контекста,в противном случае он возвращает любую ошибку,возвращенную после закрытия сервера,лежащего в основе слушателя (слушателей).</target>
        </trans-unit>
        <trans-unit id="8b3d8d665a765918b70a3f5f0378d51df00b92dd" translate="yes" xml:space="preserve">
          <source>Sign</source>
          <target state="translated">Sign</target>
        </trans-unit>
        <trans-unit id="4dc2181e93ae969f803429357fe579abd176b4b4" translate="yes" xml:space="preserve">
          <source>Sign returns -1, 0, or 1 depending on whether x &amp;lt; 0, x == 0, or x &amp;gt; 0; x must be numeric or Unknown. For complex values x, the sign is 0 if x == 0, otherwise it is != 0. If x is Unknown, the result is 1.</source>
          <target state="translated">Знак возвращает -1, 0 или 1 в зависимости от того, x &amp;lt;0, x == 0 или x&amp;gt; 0; x должен быть числовым или неизвестным. Для комплексных значений x знак равен 0, если x == 0, в противном случае -! = 0. Если x - Неизвестно, результатом будет 1.</target>
        </trans-unit>
        <trans-unit id="b52aac6f1207124113d4a678eb49a1b5cf712f7a" translate="yes" xml:space="preserve">
          <source>Sign returns:</source>
          <target state="translated">Знак возвращается:</target>
        </trans-unit>
        <trans-unit id="6589591f2f20ffb39adee81e8ba10edbe7dacc2e" translate="yes" xml:space="preserve">
          <source>Sign signs a hash (which should be the result of hashing a larger message) using the private key, priv. If the hash is longer than the bit-length of the private key's curve order, the hash will be truncated to that length. It returns the signature as a pair of integers. The security of the private key depends on the entropy of rand.</source>
          <target state="translated">Подпись подписывает хэш (который должен быть результатом хэширования более крупного сообщения),используя закрытый ключ,приватный.Если хэш длиннее битовой длины кривой закрытого ключа,то хэш будет усечен до этой длины.Он возвращает сигнатуру как пару целых чисел.Безопасность закрытого ключа зависит от энтропии rand.</target>
        </trans-unit>
        <trans-unit id="311212195f2e7e53bfbdc1974b3a767400f6e3ff" translate="yes" xml:space="preserve">
          <source>Sign signs an arbitrary length hash (which should be the result of hashing a larger message) using the private key, priv. It returns the signature as a pair of integers. The security of the private key depends on the entropy of rand.</source>
          <target state="translated">Знак обозначает хэш произвольной длины (который должен быть результатом хэширования сообщения большей длины)с использованием закрытого ключа,private.Он возвращает сигнатуру как пару целых чисел.Безопасность закрытого ключа зависит от энтропии rand.</target>
        </trans-unit>
        <trans-unit id="cd714756dfd32673e7a5fdf4e7a7d3f4c1f0476c" translate="yes" xml:space="preserve">
          <source>Sign signs digest with priv, reading randomness from rand. If opts is a *PSSOptions then the PSS algorithm will be used, otherwise PKCS#1 v1.5 will be used.</source>
          <target state="translated">Подпись знаков дайджест с рядовым,читая случайность из Рэнда.Если опция *PSSOptions,то будет использован алгоритм PSS,иначе PKCS#1 v1.5.</target>
        </trans-unit>
        <trans-unit id="725a324c83bff5484063c9fb79ed06b1a642a7c9" translate="yes" xml:space="preserve">
          <source>Sign signs digest with priv, reading randomness from rand. The opts argument is not currently used but, in keeping with the crypto.Signer interface, should be the hash function used to digest the message.</source>
          <target state="translated">Подпись знаков дайджест с рядовым,читая случайность из Рэнда.Аргумент opts в настоящее время не используется,но,в соответствии с интерфейсом crypto.Signer,должен быть хэш-функцией,используемой для дайджеста сообщения.</target>
        </trans-unit>
        <trans-unit id="cb5cc6baa9959aae2928064eeabac37026d1fdd3" translate="yes" xml:space="preserve">
          <source>Sign signs the given message with priv. Ed25519 performs two passes over messages to be signed and therefore cannot handle pre-hashed messages. Thus opts.HashFunc() must return zero to indicate the message hasn't been hashed. This can be achieved by passing crypto.Hash(0) as the value for opts.</source>
          <target state="translated">Подпись подписывает данное сообщение личным сообщением.Ed25519 выполняет два прохода над сообщениями,подлежащими подписанию,и поэтому не может обрабатывать предварительно хэшированные сообщения.Таким образом,opts.HashFunc()должна возвращать ноль,чтобы показать,что сообщение не было хэшировано.Это может быть достигнуто передачей crypto.Hash(0)в качестве значения opts.</target>
        </trans-unit>
        <trans-unit id="8d9bc9097d624689f3abd051873c0827e390ddd8" translate="yes" xml:space="preserve">
          <source>Sign signs the message with privateKey and returns a signature. It will panic if len(privateKey) is not PrivateKeySize.</source>
          <target state="translated">Подпись подписывает сообщение privateKey и возвращает подпись.Он будет паниковать,если len(privateKey)не является PrivateKeySize.</target>
        </trans-unit>
        <trans-unit id="73058d5661f51255d2d044bad5e22d1dbeb1615f" translate="yes" xml:space="preserve">
          <source>SignPKCS1v15</source>
          <target state="translated">SignPKCS1v15</target>
        </trans-unit>
        <trans-unit id="76a7f1a903c9bd79d05146e331e0afbf510916e4" translate="yes" xml:space="preserve">
          <source>SignPKCS1v15 calculates the signature of hashed using RSASSA-PKCS1-V1_5-SIGN from RSA PKCS#1 v1.5. Note that hashed must be the result of hashing the input message using the given hash function. If hash is zero, hashed is signed directly. This isn't advisable except for interoperability.</source>
          <target state="translated">SignPKCS1v15 вычисляет сигнатуру хэширования с помощью RSASSA-PKCS1-V1_5-SIGN из RSA PKCS#1 v1.5.Обратите внимание,что хэширование должно быть результатом хэширования входного сообщения с помощью данной хэш-функции.Если хэш равен нулю,то хэш подписывается непосредственно.Это не рекомендуется,за исключением интероперабельности.</target>
        </trans-unit>
        <trans-unit id="4dc02ffb85c827150cad191cf75b74252c850c11" translate="yes" xml:space="preserve">
          <source>SignPSS calculates the signature of hashed using RSASSA-PSS [1]. Note that hashed must be the result of hashing the input message using the given hash function. The opts argument may be nil, in which case sensible defaults are used.</source>
          <target state="translated">SignPSS рассчитывает подпись хэширования с помощью RSASSA-PSS [1].Обратите внимание,что хэширование должно быть результатом хэширования входного сообщения с помощью данной функции хэширования.Аргументом opts может быть nil,в этом случае используются разумные значения по умолчанию.</target>
        </trans-unit>
        <trans-unit id="456ecb37c3fc5855213ab977448f009637d487e9" translate="yes" xml:space="preserve">
          <source>Signal sends a signal to the Process. Sending Interrupt on Windows is not implemented.</source>
          <target state="translated">Сигнал посылает сигнал Процессу.Отправка прерывания в Windows не реализована.</target>
        </trans-unit>
        <trans-unit id="113054b65e3d478c55ce8ee9e7136eef91adbb6a" translate="yes" xml:space="preserve">
          <source>Signal wakes one goroutine waiting on c, if there is any.</source>
          <target state="translated">Сигнал пробуждает одну горутину,ожидающую на С,если она есть.</target>
        </trans-unit>
        <trans-unit id="2346a18ea3002ff04eca3a130c7f40e65c56f0c9" translate="yes" xml:space="preserve">
          <source>Signals</source>
          <target state="translated">Signals</target>
        </trans-unit>
        <trans-unit id="9a761dffcc7f2df5b531ae01c6e9c1d10354c3aa" translate="yes" xml:space="preserve">
          <source>Signals are primarily used on Unix-like systems. For the use of this package on Windows and Plan 9, see below.</source>
          <target state="translated">Сигналы в основном используются на Unix-подобных системах.Использование этого пакета в Windows и Плане 9,см.ниже.</target>
        </trans-unit>
        <trans-unit id="be08fe4d5181cd9a339446858cf8e98d5d370ad9" translate="yes" xml:space="preserve">
          <source>SignatureScheme identifies a signature algorithm supported by TLS. See RFC 8446, Section 4.2.3.</source>
          <target state="translated">SignatureScheme идентифицирует алгоритм подписи,поддерживаемый TLS.См.RFC 8446,раздел 4.2.3.</target>
        </trans-unit>
        <trans-unit id="72364e765319ca6184606bdfcbeaf4bae3efe083" translate="yes" xml:space="preserve">
          <source>Signbit reports whether x is negative or negative zero.</source>
          <target state="translated">Знак сообщает,является ли x отрицательным или отрицательным нулем.</target>
        </trans-unit>
        <trans-unit id="06f0622cc55ee3b1ba8ef5291dd67f388a633bbf" translate="yes" xml:space="preserve">
          <source>Signed integers may be received into any signed integer variable: int, int16, etc.; unsigned integers may be received into any unsigned integer variable; and floating point values may be received into any floating point variable. However, the destination variable must be able to represent the value or the decode operation will fail.</source>
          <target state="translated">Подписанные целые числа могут быть приняты в любую знаковую целую переменную:int,int16 и т.д.;беззнаковые целые числа могут быть приняты в любую беззнаковую целую переменную;и значения с плавающей точкой могут быть приняты в любую переменную с плавающей точкой.Однако переменная назначения должна быть способна представлять значение,иначе операция декодирования завершится неудачно.</target>
        </trans-unit>
        <trans-unit id="ae900b849a1bf306b492bb9034be4bb3bc19b163" translate="yes" xml:space="preserve">
          <source>Signer is an interface for an opaque private key that can be used for signing operations. For example, an RSA key kept in a hardware module.</source>
          <target state="translated">Signer-это интерфейс для непрозрачного частного ключа,который может быть использован для подписания операций.Например,RSA ключ хранится в аппаратном модуле.</target>
        </trans-unit>
        <trans-unit id="38f4531ed194c331b7b23a6d3502ef6906c2f74a" translate="yes" xml:space="preserve">
          <source>SignerOpts contains options for signing with a Signer.</source>
          <target state="translated">SignerOpts содержит опции для подписания с подписантом.</target>
        </trans-unit>
        <trans-unit id="966d50452c96c3fa11f316a011f44cf776d22a17" translate="yes" xml:space="preserve">
          <source>SimpleFold</source>
          <target state="translated">SimpleFold</target>
        </trans-unit>
        <trans-unit id="8bf97e6e8efa121264307227008493331dea504d" translate="yes" xml:space="preserve">
          <source>SimpleFold iterates over Unicode code points equivalent under the Unicode-defined simple case folding. Among the code points equivalent to rune (including rune itself), SimpleFold returns the smallest rune &amp;gt; r if one exists, or else the smallest rune &amp;gt;= 0. If r is not a valid Unicode code point, SimpleFold(r) returns r.</source>
          <target state="translated">SimpleFold выполняет итерацию по кодовым точкам Unicode, эквивалентным определенному в Unicode простому сворачиванию регистра. Среди кодовых точек, эквивалентных руне (включая саму руну), SimpleFold возвращает наименьшую руну&amp;gt; r, если она существует, или наименьшую руну&amp;gt; = 0. Если r не является допустимой кодовой точкой Unicode, SimpleFold (r) возвращает r.</target>
        </trans-unit>
        <trans-unit id="b27adf68197f928a987f44243ba3dcfcda229444" translate="yes" xml:space="preserve">
          <source>Simplify returns a regexp equivalent to re but without counted repetitions and with various other simplifications, such as rewriting /(?:a+)+/ to /a+/. The resulting regexp will execute correctly but its string representation will not produce the same parse tree, because capturing parentheses may have been duplicated or removed. For example, the simplified form for /(x){1,2}/ is /(x)(x)?/ but both parentheses capture as $1. The returned regexp may share structure with or be the original.</source>
          <target state="translated">Упрощение возвращает регеxp,эквивалентный ре,но без учёта повторений и с различными другими упрощениями,такими как переписывание /(?:a+)+/в /a+/.Результирующий регеxp будет выполняться корректно,но его строковое представление не будет производить того же самого дерева разбора,потому что захватывающие скобки могли быть дублированы или удалены.Например,упрощенная форма для /(x){1,2}/-это /(x)(x)?/,но обе скобки захватывают как $1.Возвращаемый регеxp может разделять структуру с оригиналом или быть оригиналом.</target>
        </trans-unit>
        <trans-unit id="1baaf4288309b641acaf8ca1164546c4028a35a7" translate="yes" xml:space="preserve">
          <source>Sin</source>
          <target state="translated">Sin</target>
        </trans-unit>
        <trans-unit id="60fef841296be9ebf7de4bce978c61ea99668ac2" translate="yes" xml:space="preserve">
          <source>Sin returns the sine of the radian argument x.</source>
          <target state="translated">Грех возвращает синусоидальный аргумент радиан x.</target>
        </trans-unit>
        <trans-unit id="2d7deeeba21d579c050c2a33e2db608612f16ced" translate="yes" xml:space="preserve">
          <source>Sin returns the sine of x.</source>
          <target state="translated">Грех возвращает синус икса.</target>
        </trans-unit>
        <trans-unit id="032d0e9143af25fee0463a47b08e83403e61fbe1" translate="yes" xml:space="preserve">
          <source>Since os.FileInfo's Name method only returns the base name of the file it describes, it may be necessary to modify Header.Name to provide the full path name of the file.</source>
          <target state="translated">Поскольку метод os.FileInfo's Name возвращает только базовое имя описываемого файла,может потребоваться изменить Header.Name,чтобы указать полное имя пути к файлу.</target>
        </trans-unit>
        <trans-unit id="b67e676cda98cae04b5ce1604ab8e9db4fbb0636" translate="yes" xml:space="preserve">
          <source>Since returns the time elapsed since t. It is shorthand for time.Now().Sub(t).</source>
          <target state="translated">Так как возвращает время,прошедшее с t.Это сокращение для time.Now().Sub(t).</target>
        </trans-unit>
        <trans-unit id="4aada6d4483746dcd60dcf298d86136630d9cd91" translate="yes" xml:space="preserve">
          <source>Sincos</source>
          <target state="translated">Sincos</target>
        </trans-unit>
        <trans-unit id="602eea7f1523e01bb1b745122d12becc2cb4a99c" translate="yes" xml:space="preserve">
          <source>Sincos returns Sin(x), Cos(x).</source>
          <target state="translated">Синкос возвращает Sin(x),Cos(x).</target>
        </trans-unit>
        <trans-unit id="bc9965f20c0e26db0501d3424c1430869ed3389f" translate="yes" xml:space="preserve">
          <source>Single characters:</source>
          <target state="translated">Одиночные символы:</target>
        </trans-unit>
        <trans-unit id="e5d65368cdcef8d43d81f8b1167171bcc9e4d453" translate="yes" xml:space="preserve">
          <source>Sinh</source>
          <target state="translated">Sinh</target>
        </trans-unit>
        <trans-unit id="f35b8f7d99b41bcac88dc066f89ded4a25031767" translate="yes" xml:space="preserve">
          <source>Sinh returns the hyperbolic sine of x.</source>
          <target state="translated">Синь возвращает гиперболический синус Х.</target>
        </trans-unit>
        <trans-unit id="9d9b9bb8ffbb101e667ceeb0c6df4b2d00eca63e" translate="yes" xml:space="preserve">
          <source>Size returns how many bytes Write would generate to encode the value v, which must be a fixed-size value or a slice of fixed-size values, or a pointer to such data. If v is neither of these, Size returns -1.</source>
          <target state="translated">Размер возвращает,сколько байт будет сгенерировано Write для кодирования значения v,которое должно быть фиксированным размером или куском фиксированных значений,или указателем на такие данные.Если v не является ни тем,ни другим,Size возвращает -1.</target>
        </trans-unit>
        <trans-unit id="07f99b9766acbd34a40dce6ae52199b1df82e565" translate="yes" xml:space="preserve">
          <source>Size returns r's width and height.</source>
          <target state="translated">Размер возвращает ширину и высоту r.</target>
        </trans-unit>
        <trans-unit id="08603885cb8f4581e6caff80c9587384030d6fb2" translate="yes" xml:space="preserve">
          <source>Size returns the length, in bytes, of a digest resulting from the given hash function. It doesn't require that the hash function in question be linked into the program.</source>
          <target state="translated">Размер возвращает длину в байтах дайджеста,полученную с помощью заданной хэш-функции.Для этого не требуется,чтобы хэш-функция,о которой идет речь,была привязана к программе.</target>
        </trans-unit>
        <trans-unit id="e25ab5f340eca2d7c5b223c77e15ee75cde585ef" translate="yes" xml:space="preserve">
          <source>Size returns the modulus size in bytes. Raw signatures and ciphertexts for or by this public key will have the same size.</source>
          <target state="translated">Размер возвращает размер модуля в байтах.Сырые подписи и шифротексты для или по этому открытому ключу будут иметь одинаковый размер.</target>
        </trans-unit>
        <trans-unit id="e670e1a5854b86fb3e790eec7802ceb4072867ce" translate="yes" xml:space="preserve">
          <source>Size returns the number of leading ones and total bits in the mask. If the mask is not in the canonical form--ones followed by zeros--then Size returns 0, 0.</source>
          <target state="translated">Размер возвращает количество лидирующих и суммарных битов в маске.Если маска не в канонической форме-тоны,за которыми следуют нули-тогда Size возвращает 0,0.</target>
        </trans-unit>
        <trans-unit id="e50e49a71b6948817b0c75a5802d436dcfbbd3d4" translate="yes" xml:space="preserve">
          <source>Size returns the original length of the underlying byte slice. Size is the number of bytes available for reading via ReadAt. The returned value is always the same and is not affected by calls to any other method.</source>
          <target state="translated">Размер возвращает исходную длину ломтика байта,лежащего в основе.Размер-это количество байтов,доступных для чтения через ReadAt.Возвращаемое значение всегда одинаково и не изменяется при вызове любого другого метода.</target>
        </trans-unit>
        <trans-unit id="20090954ae229cf40fcf85ad90018bc0a50c14a6" translate="yes" xml:space="preserve">
          <source>Size returns the original length of the underlying string. Size is the number of bytes available for reading via ReadAt. The returned value is always the same and is not affected by calls to any other method.</source>
          <target state="translated">Размер возвращает исходную длину строки,лежащей в основе.Размер-это количество байт,доступное для чтения через ReadAt.Возвращаемое значение всегда одинаково и не зависит от обращения к любому другому методу.</target>
        </trans-unit>
        <trans-unit id="5a0d609fe825a666e200f379bb9b290e727375b4" translate="yes" xml:space="preserve">
          <source>Size returns the size of file f as registered with AddFile.</source>
          <target state="translated">Размер возвращает размер файла f,зарегистрированного в AddFile.</target>
        </trans-unit>
        <trans-unit id="5716d3e163196d9c451e87a39bff7287017defa9" translate="yes" xml:space="preserve">
          <source>Size returns the size of the section in bytes.</source>
          <target state="translated">Размер возвращает размер секции в байтах.</target>
        </trans-unit>
        <trans-unit id="33687cc2c12d65398be28bdfb49be5c9af20dea4" translate="yes" xml:space="preserve">
          <source>Size returns the size of the underlying buffer in bytes.</source>
          <target state="translated">Размер возвращает размер базового буфера в байтах.</target>
        </trans-unit>
        <trans-unit id="ad326c620cb25aa3f6f88fe50584af3756cb7137" translate="yes" xml:space="preserve">
          <source>Sizeof takes an expression x of any type and returns the size in bytes of a hypothetical variable v as if v was declared via var v = x. The size does not include any memory possibly referenced by x. For instance, if x is a slice, Sizeof returns the size of the slice descriptor, not the size of the memory referenced by the slice. The return value of Sizeof is a Go constant.</source>
          <target state="translated">Sizeof принимает выражение x любого типа и возвращает размер в байтах гипотетической переменной v,как если бы v была объявлена через var v=x.Размер не включает в себя память,на которую может ссылаться x.Например,если x-срез,Sizeof возвращает размер дескриптора среза,а не размер памяти,на которую ссылается срез.Возвращаемое значение Sizeof является константой Go.</target>
        </trans-unit>
        <trans-unit id="b19905df7d36355c364fc4d465be7029063705c6" translate="yes" xml:space="preserve">
          <source>Sizes defines the sizing functions for package unsafe.</source>
          <target state="translated">Размеры определяют функции определения размеров для опасного пакета.</target>
        </trans-unit>
        <trans-unit id="58588dd4d69fcc2bebbb32cb3311a65197ef6d80" translate="yes" xml:space="preserve">
          <source>SizesFor returns the Sizes used by a compiler for an architecture. The result is nil if a compiler/architecture pair is not known.</source>
          <target state="translated">SizeFor возвращает размеры,используемые компилятором для архитектуры.Результат равен нулю,если неизвестна пара компилятор/архитектура.</target>
        </trans-unit>
        <trans-unit id="f2bf90f6b1f23cb7aca2de8f99806d297f79d8f6" translate="yes" xml:space="preserve">
          <source>Skip is equivalent to Log followed by SkipNow.</source>
          <target state="translated">Пропуск эквивалентен Журналу,за которым следует SkipNow.</target>
        </trans-unit>
        <trans-unit id="16403f951a4dfc8a1c243a0f8eb301e145aaacf2" translate="yes" xml:space="preserve">
          <source>Skip reads tokens until it has consumed the end element matching the most recent start element already consumed. It recurs if it encounters a start element, so it can be used to skip nested structures. It returns nil if it finds an end element matching the start element; otherwise it returns an error describing the problem.</source>
          <target state="translated">Пропустить чтение маркеров до тех пор,пока не будет потреблен конечный элемент,соответствующий самому последнему начальному элементу,который уже был потреблен.Он возвращается назад,если встречает стартовый элемент,поэтому может быть использован для пропуска вложенных структур.Возвращает ноль,если находит конечный элемент,соответствующий стартовому элементу;в противном случае возвращает ошибку,описывающую проблему.</target>
        </trans-unit>
        <trans-unit id="70514769bf0cf43aa1fd9a8170e861cfc268114d" translate="yes" xml:space="preserve">
          <source>SkipChildren skips over the child entries associated with the last Entry returned by Next. If that Entry did not have children or Next has not been called, SkipChildren is a no-op.</source>
          <target state="translated">SkipChildren пропускает дочерние записи,связанные с последней записью,возвращенной Next.Если у этой записи не было детей или не был вызван Next,пропускать детей нельзя.</target>
        </trans-unit>
        <trans-unit id="306f2cf9cd44bb1158534a5fe5beb03317afa4af" translate="yes" xml:space="preserve">
          <source>SkipDir is used as a return value from WalkFuncs to indicate that the directory named in the call is to be skipped. It is not returned as an error by any function.</source>
          <target state="translated">SkipDir используется в качестве возвращаемого значения из WalkFuncs,чтобы указать,что каталог,названный в вызове,должен быть пропущен.Оно не возвращается по ошибке ни одной из функций.</target>
        </trans-unit>
        <trans-unit id="a9f977172633094ba7da3e08af3ab05c0c517aa4" translate="yes" xml:space="preserve">
          <source>SkipNow marks the test as having been skipped and stops its execution by calling runtime.Goexit. If a test fails (see Error, Errorf, Fail) and is then skipped, it is still considered to have failed. Execution will continue at the next test or benchmark. See also FailNow. SkipNow must be called from the goroutine running the test, not from other goroutines created during the test. Calling SkipNow does not stop those other goroutines.</source>
          <target state="translated">SkipNow помечает тест как пропущенный и останавливает его выполнение вызовом runtime.Goexit.Если тест не удаётся (см.Ошибка,ошибка,сбой),а затем пропускается,он всё равно считается неудачным.Выполнение будет продолжено на следующем тесте или бенчмарке.См.также FailNow.SkipNow должен быть вызван из гортани,запущенной во время теста,а не из других гортаней,созданных во время теста.Вызов SkipNow не останавливает этих других goroutine.</target>
        </trans-unit>
        <trans-unit id="332b0733aeb219d3842af5da1737b4332e8bb58a" translate="yes" xml:space="preserve">
          <source>Skipf is equivalent to Logf followed by SkipNow.</source>
          <target state="translated">Skipf эквивалентен Logf,за которым следует SkipNow.</target>
        </trans-unit>
        <trans-unit id="416b07f26916aed7cb9e2ecd9aa8ab976885e47e" translate="yes" xml:space="preserve">
          <source>Skipped reports whether the test was skipped.</source>
          <target state="translated">Пропущенные отчеты о том,был ли пропущен тест.</target>
        </trans-unit>
        <trans-unit id="22c22c92516b167e48a8850862fd9d43b049ad6a" translate="yes" xml:space="preserve">
          <source>Skipping</source>
          <target state="translated">Skipping</target>
        </trans-unit>
        <trans-unit id="3cac34e674464c2b62286054cd9a2d2c81149efc" translate="yes" xml:space="preserve">
          <source>Sleep</source>
          <target state="translated">Sleep</target>
        </trans-unit>
        <trans-unit id="53bb6e499b626b0d907f8d7f80059af55f685b40" translate="yes" xml:space="preserve">
          <source>Sleep pauses the current goroutine for at least the duration d. A negative or zero duration causes Sleep to return immediately.</source>
          <target state="translated">Сон приостанавливает текущий гортань,по крайней мере,на время d.Отрицательная или нулевая продолжительность вызывает немедленный возврат к спящему.</target>
        </trans-unit>
        <trans-unit id="0c8525a31f225d6db84222cdc68f43cb8c6c18bf" translate="yes" xml:space="preserve">
          <source>Slice</source>
          <target state="translated">Slice</target>
        </trans-unit>
        <trans-unit id="4972372ab292852581dde17e7410c1a0a34536d2" translate="yes" xml:space="preserve">
          <source>Slice returns v[i:j]. It panics if v's Kind is not Array, Slice or String, or if v is an unaddressable array, or if the indexes are out of bounds.</source>
          <target state="translated">Slice возвращает v[i:j].Она паникует,если v's Kind не является массивом,срезом или строкой,или v является неадрессируемым массивом,или если индексы выходят за рамки.</target>
        </trans-unit>
        <trans-unit id="f664f65e07ee83c0603b67c75f98aa98e653bee6" translate="yes" xml:space="preserve">
          <source>Slice sorts the provided slice given the provided less function.</source>
          <target state="translated">Кусок сортирует предоставленный кусок с учетом меньшей функции.</target>
        </trans-unit>
        <trans-unit id="c9c2b1fb38f90f114fb07f736146472316c1fd01" translate="yes" xml:space="preserve">
          <source>Slice values are deeply equal when all of the following are true: they are both nil or both non-nil, they have the same length, and either they point to the same initial entry of the same underlying array (that is, &amp;amp;x[0] == &amp;amp;y[0]) or their corresponding elements (up to length) are deeply equal. Note that a non-nil empty slice and a nil slice (for example, []byte{} and []byte(nil)) are not deeply equal.</source>
          <target state="translated">Значения срезов полностью равны, если все следующие верны: они оба равны нулю или оба не равны нулю, они имеют одинаковую длину и либо они указывают на одну и ту же начальную запись одного и того же базового массива (то есть &amp;amp; x [0 ] == &amp;amp; y [0]) или их соответствующие элементы (до длины) глубоко равны. Обратите внимание, что пустой фрагмент, отличный от nil, и пустой фрагмент (например, [] byte {} и [] byte (nil)) не полностью равны.</target>
        </trans-unit>
        <trans-unit id="187ce922ba02cf6f5feb1dc1495c357805a44a28" translate="yes" xml:space="preserve">
          <source>Slice3 is the 3-index form of the slice operation: it returns v[i:j:k]. It panics if v's Kind is not Array or Slice, or if v is an unaddressable array, or if the indexes are out of bounds.</source>
          <target state="translated">Slice3-это 3-индексная форма операции со срезом:она возвращает v[i:j:k].Она паникует,если v's Kind не является массивом или Slice,или v является неадрессируемым массивом,или если индексы выходят за рамки.</target>
        </trans-unit>
        <trans-unit id="036571bfad79ab866cb35b30d706649dfea91e3e" translate="yes" xml:space="preserve">
          <source>Slice:</source>
          <target state="translated">Slice:</target>
        </trans-unit>
        <trans-unit id="0294a1ce63eca0958f1a3380376dd5b3772daeaa" translate="yes" xml:space="preserve">
          <source>SliceHeader is the runtime representation of a slice. It cannot be used safely or portably and its representation may change in a later release. Moreover, the Data field is not sufficient to guarantee the data it references will not be garbage collected, so programs must keep a separate, correctly typed pointer to the underlying data.</source>
          <target state="translated">SliceHeader-это представление среза во время выполнения.Он не может быть использован безопасно или портативно,и его представление может измениться в более поздней версии.Более того,поля Data недостаточно для того,чтобы гарантировать,что данные,на которые оно ссылается,не будут собраны в мусор,поэтому программы должны хранить отдельный,правильно набранный указатель на лежащие в основе данные.</target>
        </trans-unit>
        <trans-unit id="c22ee253fc38582e76e1a487b795c3ec911e294a" translate="yes" xml:space="preserve">
          <source>SliceIsSorted tests whether a slice is sorted.</source>
          <target state="translated">SliceISorted проверяет,отсортирован ли кусок.</target>
        </trans-unit>
        <trans-unit id="45eaaaf070f6c38ebb684650d2e76ac52a7e3905" translate="yes" xml:space="preserve">
          <source>SliceOf returns the slice type with element type t. For example, if t represents int, SliceOf(t) represents []int.</source>
          <target state="translated">SliceOf возвращает тип среза с типом элемента t.Например,если t представляет int,то SliceOf(t)представляет []int.</target>
        </trans-unit>
        <trans-unit id="d3f5d8267a68290ad1478266ac0100b64a9ec9d9" translate="yes" xml:space="preserve">
          <source>SlicePtrFromStrings converts a slice of strings to a slice of pointers to NUL-terminated byte arrays. If any string contains a NUL byte, it returns (nil, EINVAL).</source>
          <target state="translated">SlicePtrFromStrings преобразует срез строк в срез указателей в NUL-терминированные массивы байтов.Если какая-либо строка содержит NUL-байт,то она возвращается (nil,EINVAL).</target>
        </trans-unit>
        <trans-unit id="1c864d92c212ef8abfd9b5a7229b7d9cb38de7a2" translate="yes" xml:space="preserve">
          <source>SliceStable</source>
          <target state="translated">SliceStable</target>
        </trans-unit>
        <trans-unit id="291aafdf1861d62c9bc50f1c83d1800a3cb0913c" translate="yes" xml:space="preserve">
          <source>SliceStable sorts the provided slice given the provided less function while keeping the original order of equal elements.</source>
          <target state="translated">SliceStable сортирует предоставленный ломтик с меньшим количеством функций при сохранении исходного порядка одинаковых элементов.</target>
        </trans-unit>
        <trans-unit id="24220363f4bcd3c6462dbe1e7e4afff4012817f0" translate="yes" xml:space="preserve">
          <source>Slices of bytes in the returned token data refer to the parser's internal buffer and remain valid only until the next call to Token. To acquire a copy of the bytes, call CopyToken or the token's Copy method.</source>
          <target state="translated">Фрагменты байтов в возвращаемых токеновых данных относятся к внутреннему буферу парсера и остаются действительными только до следующего вызова Token.Для получения копии байтов необходимо обратиться к CopyToken или к методу Copy токена.</target>
        </trans-unit>
        <trans-unit id="fc7f681747838baecdc0ee29795205530bc0b270" translate="yes" xml:space="preserve">
          <source>SocketControlMessage represents a socket control message.</source>
          <target state="translated">SocketControlMessage представляет собой управляющее сообщение сокета.</target>
        </trans-unit>
        <trans-unit id="4457c2edf950c3c3e9063b3a5f5427cad62d71ba" translate="yes" xml:space="preserve">
          <source>Some protocols may impose additional requirements on pre-escaping the username and password. For instance, when used with OAuth2, both arguments must be URL encoded first with url.QueryEscape.</source>
          <target state="translated">Некоторые протоколы могут предъявлять дополнительные требования к предварительному вводу имени пользователя и пароля.Например,при использовании с OAuth2 оба аргумента должны быть сначала закодированы в URL с помощью url.QueryEscape.</target>
        </trans-unit>
        <trans-unit id="0b8c5ca797beb6df3a3a7d32f3dea277a5bafd3c" translate="yes" xml:space="preserve">
          <source>Some valid layouts are invalid time values for time.Parse, due to formats such as _ for space padding and Z for zone information.</source>
          <target state="translated">Некоторые действительные компоновки являются недействительными значениями времени.Parse,из-за таких форматов,как_для заполнения пространства и Z для информации о зоне.</target>
        </trans-unit>
        <trans-unit id="89fbdcfdf1cfcd667a49cfe3f7c3c0bdc4ce5124" translate="yes" xml:space="preserve">
          <source>Sort is a convenience method.</source>
          <target state="translated">Сортировка-это удобный метод.</target>
        </trans-unit>
        <trans-unit id="f520ad1ca9ea89523277ded79bfeb4e271e735a8" translate="yes" xml:space="preserve">
          <source>Sort sorts an ErrorList. *Error entries are sorted by position, other errors are sorted by error message, and before any *Error entry.</source>
          <target state="translated">Сортировка сортирует ErrorList.*Записи об ошибках сортируются по позиции,другие ошибки сортируются по сообщению об ошибке и перед любым *записью об ошибке.</target>
        </trans-unit>
        <trans-unit id="f8bf7dfcfaee16c58648d64101d25f3215cc22e2" translate="yes" xml:space="preserve">
          <source>Sort sorts data. It makes one call to data.Len to determine n, and O(n*log(n)) calls to data.Less and data.Swap. The sort is not guaranteed to be stable.</source>
          <target state="translated">Сортировка сортирует данные.Он делает один вызов data.Len для определения n,а O(n*log(n))вызывает data.Less и data.Swap.Сортировка не гарантируется.</target>
        </trans-unit>
        <trans-unit id="decd49ac7a46241d55346a11f6d2fb74335dc7a9" translate="yes" xml:space="preserve">
          <source>SortImports sorts runs of consecutive import lines in import blocks in f. It also removes duplicate imports when it is possible to do so without data loss.</source>
          <target state="translated">SortImports сортирует строки последовательного импорта в блоках импорта в f.Также удаляет дубликаты импорта,когда это возможно без потери данных.</target>
        </trans-unit>
        <trans-unit id="6e2693fb2fa2b916dd95d972bbcb32b0b6b566ec" translate="yes" xml:space="preserve">
          <source>Source formats src in canonical gofmt style and returns the result or an (I/O or syntax) error. src is expected to be a syntactically correct Go source file, or a list of Go declarations or statements.</source>
          <target state="translated">Source форматирует src в каноническом стиле gofmt и возвращает результат или ошибку (I/O или синтаксис).src должен быть синтаксически корректным исходным файлом Go,или списком деклараций или утверждений Go.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
