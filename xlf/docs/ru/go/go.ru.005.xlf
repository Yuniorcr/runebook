<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="go">
    <body>
      <group id="go">
        <trans-unit id="b05ffc1d15462ca6f99d23dad5504fcb24e01652" translate="yes" xml:space="preserve">
          <source>Filenames containing a certificate and matching private key for the server must be provided if neither the Server's TLSConfig.Certificates nor TLSConfig.GetCertificate are populated. If the certificate is signed by a certificate authority, the certFile should be the concatenation of the server's certificate, any intermediates, and the CA's certificate.</source>
          <target state="translated">Имена файлов,содержащих сертификат и соответствующий частный ключ сервера,должны быть предоставлены,если ни TLSConfig.Certificates сервера,ни TLSConfig.GetCertificate сервера не заполнены.Если сертификат подписан центром сертификации,то certFile должен быть конкатеннацией сертификата сервера,любых посредников и сертификата центра сертификации.</target>
        </trans-unit>
        <trans-unit id="73595851a6091a7492042c8776979e91c6d3c91f" translate="yes" xml:space="preserve">
          <source>Files checks the provided files as part of the checker's package.</source>
          <target state="translated">Файлы проверяют предоставленные файлы как часть пакета проверки.</target>
        </trans-unit>
        <trans-unit id="f2677f06472fc0feb492ada82a2c4649c4e1df36" translate="yes" xml:space="preserve">
          <source>Files containing a certificate and matching private key for the server must be provided if neither the Server's TLSConfig.Certificates nor TLSConfig.GetCertificate are populated. If the certificate is signed by a certificate authority, the certFile should be the concatenation of the server's certificate, any intermediates, and the CA's certificate.</source>
          <target state="translated">Файлы,содержащие сертификат и соответствующий частный ключ сервера,должны быть предоставлены,если ни TLSConfig.Certificates сервера,ни TLSConfig.GetCertificate сервера не заполнены.Если сертификат подписан центром сертификации,то certFile должен быть конкатеннацией сертификата сервера,любых посредников и сертификата центра сертификации.</target>
        </trans-unit>
        <trans-unit id="5e509fe0addedea68b64c5b0175672be70d59e89" translate="yes" xml:space="preserve">
          <source>Files returns the file name table of this compilation unit as of the current position in the line table. The file name table may be referenced from attributes in this compilation unit such as AttrDeclFile.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32b9b62ab260f2308e9b093a7911d09a04032958" translate="yes" xml:space="preserve">
          <source>FillBytes sets buf to the absolute value of x, storing it as a zero-extended big-endian byte slice, and returns buf.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="916600c69a73c67f62481a2e3b48aac8b70b5d49" translate="yes" xml:space="preserve">
          <source>FillFromRDNSequence populates n from the provided RDNSequence. Multi-entry RDNs are flattened, all entries are added to the relevant n fields, and the grouping is not preserved.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c30ef34cd44738f2300a9d1c8d2644305bfe659" translate="yes" xml:space="preserve">
          <source>Filter eliminates documentation for names that don't pass through the filter f. TODO(gri): Recognize &quot;Type.Method&quot; as a name.</source>
          <target state="translated">Фильтр устраняет документацию для имен,которые не проходят через фильтр f.TODO(gri):Распознает &quot;Type.Method&quot; как имя.</target>
        </trans-unit>
        <trans-unit id="8fe9542ddb9636eaf7f6d18a2a5c93cd3e032943" translate="yes" xml:space="preserve">
          <source>Filter returns a new comment map consisting of only those entries of cmap for which a corresponding node exists in the AST specified by node.</source>
          <target state="translated">Фильтр возвращает новую карту комментариев,состоящую только из тех записей cmap,для которых в заданном узлом AST существует соответствующий узел.</target>
        </trans-unit>
        <trans-unit id="99334f5ff24d09e0e43146c7ab17eed8e9e83ed8" translate="yes" xml:space="preserve">
          <source>FilterDecl reports whether there are any declared names left after filtering.</source>
          <target state="translated">FilterDecl сообщает,остались ли после фильтрации объявленные имена.</target>
        </trans-unit>
        <trans-unit id="a98ad9f1ce33b85f6650faa2d18060284cd00443" translate="yes" xml:space="preserve">
          <source>FilterDecl trims the AST for a Go declaration in place by removing all names (including struct field and interface method names, but not from parameter lists) that don't pass through the filter f.</source>
          <target state="translated">FilterDecl убирает AST для объявления Go,удаляя все имена (включая имена структурных полей и методов интерфейса,но не из списков параметров),которые не проходят через фильтр f.</target>
        </trans-unit>
        <trans-unit id="c1ed367ffc6ba55dd5b60bff81664a2c439a8484" translate="yes" xml:space="preserve">
          <source>FilterFile reports whether there are any top-level declarations left after filtering.</source>
          <target state="translated">FilterFile сообщает,остались ли после фильтрации какие-либо декларации верхнего уровня.</target>
        </trans-unit>
        <trans-unit id="7a9fa766ec80d5d59f245ed962a927a61c070075" translate="yes" xml:space="preserve">
          <source>FilterFile trims the AST for a Go file in place by removing all names from top-level declarations (including struct field and interface method names, but not from parameter lists) that don't pass through the filter f. If the declaration is empty afterwards, the declaration is removed from the AST. Import declarations are always removed. The File.Comments list is not changed.</source>
          <target state="translated">FilterFile убирает AST для Go файла,удаляя все имена из деклараций верхнего уровня (включая имена структурных полей и методов интерфейса,но не из списков параметров),которые не проходят через фильтр f.Если после этого декларация пуста,то она удаляется из AST.Импортные декларации всегда удаляются.Список File.Comments не изменяется.</target>
        </trans-unit>
        <trans-unit id="616d0d4a74fcef85e72d4edac004eabd14b32293" translate="yes" xml:space="preserve">
          <source>FilterPackage reports whether there are any top-level declarations left after filtering.</source>
          <target state="translated">FilterPackage сообщает,остались ли после фильтрации какие-либо декларации верхнего уровня.</target>
        </trans-unit>
        <trans-unit id="cc812cc8b170b6479d3dcdf5fdfae2947c9e732a" translate="yes" xml:space="preserve">
          <source>FilterPackage trims the AST for a Go package in place by removing all names from top-level declarations (including struct field and interface method names, but not from parameter lists) that don't pass through the filter f. If the declaration is empty afterwards, the declaration is removed from the AST. The pkg.Files list is not changed, so that file names and top-level package comments don't get lost.</source>
          <target state="translated">FilterPackage убирает AST для пакета Go,удаляя все имена из деклараций верхнего уровня (включая имена полей структуры и методов интерфейса,но не из списков параметров),которые не проходят через фильтр f.Если после этого декларация пуста,то она удаляется из AST.Список файлов pkg.Files не изменяется,поэтому имена файлов и комментарии к пакетам верхнего уровня не теряются.</target>
        </trans-unit>
        <trans-unit id="64167db3c8ee867d45eebbc9c53b064e2bb836d4" translate="yes" xml:space="preserve">
          <source>Finalizers are run in dependency order: if A points at B, both have finalizers, and they are otherwise unreachable, only the finalizer for A runs; once A is freed, the finalizer for B can run. If a cyclic structure includes a block with a finalizer, that cycle is not guaranteed to be garbage collected and the finalizer is not guaranteed to run, because there is no ordering that respects the dependencies.</source>
          <target state="translated">Финишизаторы выполняются в порядке зависимости:если точки A в точке B,у обоих есть финишизаторы,и в противном случае они недоступны,то запускается только финишизатор для прогонов A;как только A освобождается,может запуститься финишизатор для прогонов B.Если в циклическую структуру входит блок с финализатором,то этот цикл не гарантированно будет собрать мусор,а финализатор не гарантированно будет запущен,потому что нет порядка следования,который бы учитывал зависимости.</target>
        </trans-unit>
        <trans-unit id="04c286b7e901d165a790bb4d85625ee624e6c5de" translate="yes" xml:space="preserve">
          <source>Finally, *Int, *Rat, and *Float satisfy the fmt package's Scanner interface for scanning and (except for *Rat) the Formatter interface for formatted printing.</source>
          <target state="translated">Наконец,*Int,*Rat и *Float удовлетворяют интерфейсу сканера fmt пакета для сканирования и (за исключением *Rat)интерфейсу форматирования для форматированной печати.</target>
        </trans-unit>
        <trans-unit id="26ec87dd2b9f83faa210cf241d5b474c8a62da6b" translate="yes" xml:space="preserve">
          <source>Finally, any occurrences of slash are replaced by Separator.</source>
          <target state="translated">Наконец,любые случаи косой черты заменяются на Separator.</target>
        </trans-unit>
        <trans-unit id="2e283acb4f254ad8296a8a754d3d7b44acc43a52" translate="yes" xml:space="preserve">
          <source>Finally, each message created by a call to Encode is preceded by an encoded unsigned integer count of the number of bytes remaining in the message. After the initial type name, interface values are wrapped the same way; in effect, the interface value acts like a recursive invocation of Encode.</source>
          <target state="translated">Наконец,каждому сообщению,созданному в результате вызова Encode,предшествует кодированное неподписанное целое число байт,оставшихся в сообщении.После первоначального имени типа,значения интерфейса обертываются таким же образом;по сути,значение интерфейса действует как рекурсивный вызов Encode.</target>
        </trans-unit>
        <trans-unit id="26fb85ce34e42f69c76353a6f2b051f404c7f2c9" translate="yes" xml:space="preserve">
          <source>Find returns a slice holding the text of the leftmost match in b of the regular expression. A return value of nil indicates no match.</source>
          <target state="translated">Find возвращает фрагмент,удерживающий текст самого левого совпадения в регулярном выражении b.Возвращаемое значение nil указывает на отсутствие совпадения.</target>
        </trans-unit>
        <trans-unit id="3939b43a8656fedf8c713b119be8032947dc3ecd" translate="yes" xml:space="preserve">
          <source>FindAll is the 'All' version of Find; it returns a slice of all successive matches of the expression, as defined by the 'All' description in the package comment. A return value of nil indicates no match.</source>
          <target state="translated">FindAll-это 'All' версия Find;она возвращает часть всех последовательных совпадений выражения,как определено описанием 'All' в комментарии к пакету.Возвращаемое значение nil указывает на отсутствие совпадения.</target>
        </trans-unit>
        <trans-unit id="36cb8b2ff6a76516bc1c892450ee61ae3139b098" translate="yes" xml:space="preserve">
          <source>FindAllIndex is the 'All' version of FindIndex; it returns a slice of all successive matches of the expression, as defined by the 'All' description in the package comment. A return value of nil indicates no match.</source>
          <target state="translated">FindAllIndex-это версия FindIndex 'All';она возвращает часть всех последовательных совпадений выражения,как определено описанием 'All' в комментарии к пакету.Возвращаемое значение nil указывает на отсутствие совпадения.</target>
        </trans-unit>
        <trans-unit id="f5f37301641ba46ce0b020d50232dcdae9f0dad0" translate="yes" xml:space="preserve">
          <source>FindAllIndex returns a sorted list of non-overlapping matches of the regular expression r, where a match is a pair of indices specifying the matched slice of x.Bytes(). If n &amp;lt; 0, all matches are returned in successive order. Otherwise, at most n matches are returned and they may not be successive. The result is nil if there are no matches, or if n == 0.</source>
          <target state="translated">FindAllIndex возвращает отсортированный список неперекрывающихся совпадений регулярного выражения r, где совпадение - это пара индексов, определяющих согласованный фрагмент x.Bytes (). Если n &amp;lt;0, все совпадения возвращаются в последовательном порядке. В противном случае возвращается не более n совпадений, и они могут быть непоследовательными. Результат равен нулю, если совпадений нет или если n == 0.</target>
        </trans-unit>
        <trans-unit id="9de88adfecc3f20e0c2ffdbb0f036f7a79d80f3b" translate="yes" xml:space="preserve">
          <source>FindAllString is the 'All' version of FindString; it returns a slice of all successive matches of the expression, as defined by the 'All' description in the package comment. A return value of nil indicates no match.</source>
          <target state="translated">FindAllString-это 'All' версия FindString;она возвращает часть всех последовательных совпадений выражения,как определено описанием 'All' в комментарии к пакету.Возвращаемое значение nil указывает на отсутствие совпадения.</target>
        </trans-unit>
        <trans-unit id="50f5df0a72b99ef5ef4ba48205043bd703872dd1" translate="yes" xml:space="preserve">
          <source>FindAllStringIndex is the 'All' version of FindStringIndex; it returns a slice of all successive matches of the expression, as defined by the 'All' description in the package comment. A return value of nil indicates no match.</source>
          <target state="translated">FindAllStringIndex-это версия FindStringIndex 'All';она возвращает часть всех последовательных совпадений выражения,как определено описанием 'All' в комментарии к пакету.Возвращаемое значение nil указывает на отсутствие совпадения.</target>
        </trans-unit>
        <trans-unit id="fd030004e8ba710e67858c9136cb59800b720d8e" translate="yes" xml:space="preserve">
          <source>FindAllStringSubmatch is the 'All' version of FindStringSubmatch; it returns a slice of all successive matches of the expression, as defined by the 'All' description in the package comment. A return value of nil indicates no match.</source>
          <target state="translated">FindAllStringSubmatch-это версия FindStringSubmatch 'All';она возвращает кусок всех последовательных совпадений выражения,как определено описанием 'All' в комментарии к пакету.Возвращаемое значение nil указывает на отсутствие совпадения.</target>
        </trans-unit>
        <trans-unit id="866672036e7565c5590c34ec3cdc6d2f77a921c5" translate="yes" xml:space="preserve">
          <source>FindAllStringSubmatchIndex is the 'All' version of FindStringSubmatchIndex; it returns a slice of all successive matches of the expression, as defined by the 'All' description in the package comment. A return value of nil indicates no match.</source>
          <target state="translated">FindAllStringSubmatchIndex-это 'Все' версия FindStringSubmatchIndex;он возвращает кусок всех последовательных совпадений выражения,как определено описанием 'Все' в комментарии к пакету.Возвращаемое значение nil указывает на отсутствие совпадения.</target>
        </trans-unit>
        <trans-unit id="3be6622b78b7a355447dee918503ed5111144cd3" translate="yes" xml:space="preserve">
          <source>FindAllSubmatch is the 'All' version of FindSubmatch; it returns a slice of all successive matches of the expression, as defined by the 'All' description in the package comment. A return value of nil indicates no match.</source>
          <target state="translated">FindAllSubmatch-это 'Все' версия FindSubmatch;она возвращает кусок всех последовательных совпадений выражения,как определено описанием 'Все' в комментарии к пакету.Возвращаемое значение nil указывает на отсутствие совпадения.</target>
        </trans-unit>
        <trans-unit id="c52ee6c792ee96296da432c07ce6bac841f99f98" translate="yes" xml:space="preserve">
          <source>FindAllSubmatchIndex is the 'All' version of FindSubmatchIndex; it returns a slice of all successive matches of the expression, as defined by the 'All' description in the package comment. A return value of nil indicates no match.</source>
          <target state="translated">FindAllSubmatchIndex-это 'Все' версия FindSubmatchIndex;он возвращает кусок всех последовательных совпадений выражения,как определено описанием 'Все' в комментарии к пакету.Возвращаемое значение nil указывает на отсутствие совпадения.</target>
        </trans-unit>
        <trans-unit id="42e5b0dfb84ada5e535dcd7bb2807e917d046ce8" translate="yes" xml:space="preserve">
          <source>FindIndex returns a two-element slice of integers defining the location of the leftmost match in b of the regular expression. The match itself is at b[loc[0]:loc[1]]. A return value of nil indicates no match.</source>
          <target state="translated">FindIndex возвращает двухэлементный срез целых чисел,определяющий местоположение самого левого совпадения в b регулярного выражения.Само совпадение находится в b[loc[0]:loc[1]].Возвращаемое значение nil указывает на отсутствие совпадения.</target>
        </trans-unit>
        <trans-unit id="5e8a7de41165a099a274921bab815b24b2852407" translate="yes" xml:space="preserve">
          <source>FindProcess looks for a running process by its pid.</source>
          <target state="translated">FindProcess ищет запущенный процесс по своему пиду.</target>
        </trans-unit>
        <trans-unit id="4911a1ccdd694282d198f0794f5539db98ac7df1" translate="yes" xml:space="preserve">
          <source>FindReaderIndex returns a two-element slice of integers defining the location of the leftmost match of the regular expression in text read from the RuneReader. The match text was found in the input stream at byte offset loc[0] through loc[1]-1. A return value of nil indicates no match.</source>
          <target state="translated">FindReaderIndex возвращает двухэлементный срез целых чисел,определяющий расположение крайнего левого совпадения регулярного выражения в тексте,читаемом из RuneReader.Соответствующий текст найден во входном потоке при смещении байтов loc[0]через loc[1]-1.Возвращаемое значение nil указывает на отсутствие совпадения.</target>
        </trans-unit>
        <trans-unit id="1d35aea7e01a3055400cfb5abc273aa2a48d9a9f" translate="yes" xml:space="preserve">
          <source>FindReaderSubmatchIndex returns a slice holding the index pairs identifying the leftmost match of the regular expression of text read by the RuneReader, and the matches, if any, of its subexpressions, as defined by the 'Submatch' and 'Index' descriptions in the package comment. A return value of nil indicates no match.</source>
          <target state="translated">FindReaderSubmatchIndex возвращает фрагмент,содержащий индексные пары,идентифицирующие самое левое совпадение регулярного выражения текста,прочитанного RuneReader,и совпадения,если таковые имеются,его подвыражения,как это определено описаниями 'Submatch' и 'Index' в комментарии к пакету.Возвращаемое значение nil указывает на отсутствие совпадения.</target>
        </trans-unit>
        <trans-unit id="e9a327cf77fbaf9bbe1a604d4bcf583f4d07fb1a" translate="yes" xml:space="preserve">
          <source>FindString returns a string holding the text of the leftmost match in s of the regular expression. If there is no match, the return value is an empty string, but it will also be empty if the regular expression successfully matches an empty string. Use FindStringIndex or FindStringSubmatch if it is necessary to distinguish these cases.</source>
          <target state="translated">FindString возвращает строку,удерживающую текст самого левого совпадения в s регулярного выражения.Если совпадений нет,возвращаемое значение является пустой строкой,но оно также будет пустым,если регулярное выражение успешно совпадет с пустой строкой.Используйте FindStringIndex или FindStringSubmatch,если необходимо различать эти случаи.</target>
        </trans-unit>
        <trans-unit id="531bff01dd38db5d072dffaff07b7a369f4e48aa" translate="yes" xml:space="preserve">
          <source>FindStringIndex returns a two-element slice of integers defining the location of the leftmost match in s of the regular expression. The match itself is at s[loc[0]:loc[1]]. A return value of nil indicates no match.</source>
          <target state="translated">FindStringIndex возвращает двухэлементный срез целых чисел,определяющий расположение крайнего левого совпадения в s регулярного выражения.Само совпадение находится в s[loc[0]:loc[1]].Возвращаемое значение nil указывает на отсутствие совпадения.</target>
        </trans-unit>
        <trans-unit id="a789ded76b89d56fcfc993f95abd7a8461164bf2" translate="yes" xml:space="preserve">
          <source>FindStringSubmatch returns a slice of strings holding the text of the leftmost match of the regular expression in s and the matches, if any, of its subexpressions, as defined by the 'Submatch' description in the package comment. A return value of nil indicates no match.</source>
          <target state="translated">FindStringSubmatch возвращает кусок строки,содержащей текст самого левого совпадения регулярного выражения в s и совпадения,если таковые имеются,его подвыражения,как определено описанием 'Submatch' в комментарии к пакету.Возвращаемое значение nil указывает на отсутствие совпадения.</target>
        </trans-unit>
        <trans-unit id="716a3ff38a9d712fef426438e6f03f83ab81e7b5" translate="yes" xml:space="preserve">
          <source>FindStringSubmatchIndex returns a slice holding the index pairs identifying the leftmost match of the regular expression in s and the matches, if any, of its subexpressions, as defined by the 'Submatch' and 'Index' descriptions in the package comment. A return value of nil indicates no match.</source>
          <target state="translated">FindStringSubmatchIndex возвращает фрагмент,содержащий пары индексов,идентифицирующие самое левое совпадение регулярного выражения в s и совпадения,если таковые имеются,его подвыражения,как это определено описаниями 'Submatch' и 'Index' в комментарии к пакету.Возвращаемое значение nil указывает на отсутствие совпадения.</target>
        </trans-unit>
        <trans-unit id="ffa69da36fb7ee45dba39b18243a0f710f826bb2" translate="yes" xml:space="preserve">
          <source>FindSubmatch returns a slice of slices holding the text of the leftmost match of the regular expression in b and the matches, if any, of its subexpressions, as defined by the 'Submatch' descriptions in the package comment. A return value of nil indicates no match.</source>
          <target state="translated">FindSubmatch возвращает фрагмент фрагментов,содержащих текст самого левого совпадения регулярного выражения в b и совпадения,если таковые имеются,его подвыражения,как определено описанием 'Submatch' в комментарии к пакету.Возвращаемое значение nil указывает на отсутствие совпадения.</target>
        </trans-unit>
        <trans-unit id="7965df00e3cbe474d92d31bb0bd5221f067573f7" translate="yes" xml:space="preserve">
          <source>FindSubmatchIndex returns a slice holding the index pairs identifying the leftmost match of the regular expression in b and the matches, if any, of its subexpressions, as defined by the 'Submatch' and 'Index' descriptions in the package comment. A return value of nil indicates no match.</source>
          <target state="translated">FindSubmatchIndex возвращает фрагмент,содержащий пары индексов,идентифицирующие самое левое совпадение регулярного выражения в b и совпадения,если таковые имеются,его подвыражения,как это определено описаниями 'Submatch' и 'Index' в комментарии к пакету.Возвращаемое значение nil указывает на отсутствие совпадения.</target>
        </trans-unit>
        <trans-unit id="156ee4c1a5140190bfb3141b9e1f8498489f2c44" translate="yes" xml:space="preserve">
          <source>First, if an os.Lstat on the root directory or any directory or file in the tree fails, Walk calls the function with path set to that directory or file's path, info set to nil, and err set to the error from os.Lstat.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6469fd45880f3c8255beb2244dc0bd626a3c8ad4" translate="yes" xml:space="preserve">
          <source>First, if the initial fs.Stat on the root directory fails, WalkDir calls the function with path set to root, d set to nil, and err set to the error from fs.Stat.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="316c8fcfd0429ed17b8857dd6ccdd403f5640491" translate="yes" xml:space="preserve">
          <source>Fix re-establishes the heap ordering after the element at index i has changed its value. Changing the value of the element at index i and then calling Fix is equivalent to, but less expensive than, calling Remove(h, i) followed by a Push of the new value. The complexity is O(log n) where n = h.Len().</source>
          <target state="translated">Исправление восстанавливает порядок кучи после того,как элемент в индексе i изменил свое значение.Изменение значения элемента в индексе i и последующий вызов Fix эквивалентны,но дешевле,чем вызов Remove(h,i)с последующим толчком нового значения.Сложность заключается в O(log n),где n=h.Len().</target>
        </trans-unit>
        <trans-unit id="3d7cfcda1db5ca5e3bcb0a9677bf0dd4d80ac6e4" translate="yes" xml:space="preserve">
          <source>FixedZone</source>
          <target state="translated">FixedZone</target>
        </trans-unit>
        <trans-unit id="d8dd9f2c3ea7d8b26856edf904ee0771c7d5fc47" translate="yes" xml:space="preserve">
          <source>FixedZone returns a Location that always uses the given zone name and offset (seconds east of UTC).</source>
          <target state="translated">FixedZone возвращает Местоположение,которое всегда использует заданное имя зоны и смещение (в секундах к востоку от UTC).</target>
        </trans-unit>
        <trans-unit id="08425e752eb21d741faf32b7c85e71d44fa0561c" translate="yes" xml:space="preserve">
          <source>Flag names must be unique within a FlagSet. An attempt to define a flag whose name is already in use will cause a panic.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c7a643e1bb2320ed4f231588740bf7ac2e291cd" translate="yes" xml:space="preserve">
          <source>Flag parsing stops just before the first non-flag argument (&quot;-&quot; is a non-flag argument) or after the terminator &quot;--&quot;.</source>
          <target state="translated">Разбор флага прекращается непосредственно перед первым нефлаговым аргументом (&quot;-&quot;-это нефлаговый аргумент)или после терминатора &quot;--&quot;.</target>
        </trans-unit>
        <trans-unit id="6fdd311ef8e9ef566cf48b8fece102302ba2cc48" translate="yes" xml:space="preserve">
          <source>Flags are ignored by verbs that do not expect them. For example there is no alternate decimal format, so %#d and %d behave identically.</source>
          <target state="translated">Флаги игнорируются глаголами,которые их не ожидают.Например,нет альтернативного десятичного формата,поэтому %#d и %d ведут себя одинаково.</target>
        </trans-unit>
        <trans-unit id="af3386ff8f43c1696f153b0da6ee0a837cb1976a" translate="yes" xml:space="preserve">
          <source>Flags control the behavior of the parser and record information about regexp context.</source>
          <target state="translated">Флаги контролируют поведение синтаксического анализатора и записывают информацию о контексте регенерации.</target>
        </trans-unit>
        <trans-unit id="16c488a94448ea7f6f8bcea47a1cbbb9b2216fc9" translate="yes" xml:space="preserve">
          <source>Flags may then be used directly. If you're using the flags themselves, they are all pointers; if you bind to variables, they're values.</source>
          <target state="translated">Флаги можно использовать непосредственно.Если вы используете сами флаги,то все они являются указателями;если вы привязываете их к переменным,то это значения.</target>
        </trans-unit>
        <trans-unit id="8b5f3f5f47f0c72df0bc10a5003e3c8534841d99" translate="yes" xml:space="preserve">
          <source>Flags returns the output flags for the logger.</source>
          <target state="translated">Флаги возвращают выходные флаги для регистратора.</target>
        </trans-unit>
        <trans-unit id="f6c4e9587ed10cf97056188e5fee0abe91201a63" translate="yes" xml:space="preserve">
          <source>Flags returns the output flags for the logger. The flag bits are Ldate, Ltime, and so on.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab784ad102a2c124d297f0684145d0588e53e2ce" translate="yes" xml:space="preserve">
          <source>Flags returns the output flags for the standard logger.</source>
          <target state="translated">Флаги возвращают флаги вывода для стандартного регистратора.</target>
        </trans-unit>
        <trans-unit id="2fc6ca1c2bb40c98076e96a0885f4d91179665d9" translate="yes" xml:space="preserve">
          <source>Flags returns the output flags for the standard logger. The flag bits are Ldate, Ltime, and so on.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49886552d225c91289351966a030fb2ce1479645" translate="yes" xml:space="preserve">
          <source>Flags to OpenFile wrapping those of the underlying system. Not all flags may be implemented on a given system.</source>
          <target state="translated">Флаги к OpenFile,обертывающие флаги базовой системы.Не все флаги могут быть реализованы в данной системе.</target>
        </trans-unit>
        <trans-unit id="e4dce7c8ab9c22a7b9475e937cb3027b98a99140" translate="yes" xml:space="preserve">
          <source>Float (Shift)</source>
          <target state="translated">Поплавок (Shift)</target>
        </trans-unit>
        <trans-unit id="44e98719e5ce5b2d4401b4abb5dc0f8819be8a88" translate="yes" xml:space="preserve">
          <source>Float is a 64-bit float variable that satisfies the Var interface.</source>
          <target state="translated">Float-64-битная переменная с плавающей запятой,удовлетворяющая интерфейсу Var.</target>
        </trans-unit>
        <trans-unit id="10efe1f5142078fa491d28fd6eb4b8558bc300d7" translate="yes" xml:space="preserve">
          <source>Float returns the value v as a float64. It panics if v is not a JavaScript number.</source>
          <target state="translated">Float возвращает значение v как float64.Он паникует,если v не является JavaScript номером.</target>
        </trans-unit>
        <trans-unit id="8ce5b8413e70edd589cd645e2e4c3403f1aae941" translate="yes" xml:space="preserve">
          <source>Float returns v's underlying value, as a float64. It panics if v's Kind is not Float32 or Float64</source>
          <target state="translated">Float возвращает базовое значение v,как float64.Он паникует,если v's Kind не является Float32 или Float64.</target>
        </trans-unit>
        <trans-unit id="eeec2beb5f657aee9f544ee180ec6e738a4d2d1a" translate="yes" xml:space="preserve">
          <source>Float.Add</source>
          <target state="translated">Float.Add</target>
        </trans-unit>
        <trans-unit id="ad02b5997c5669d53745f3d1c236de0ca407890e" translate="yes" xml:space="preserve">
          <source>Float.Cmp</source>
          <target state="translated">Float.Cmp</target>
        </trans-unit>
        <trans-unit id="fec48acd5df26f0383b2951f8c9e9ae9c4ff8998" translate="yes" xml:space="preserve">
          <source>Float.Scan</source>
          <target state="translated">Float.Scan</target>
        </trans-unit>
        <trans-unit id="27a60da3c6927b3e7808077db5c420b80b923197" translate="yes" xml:space="preserve">
          <source>Float.SetString</source>
          <target state="translated">Float.SetString</target>
        </trans-unit>
        <trans-unit id="b29933c6b53142cadd8d7b922f23fae52793b020" translate="yes" xml:space="preserve">
          <source>Float32 returns the float32 value nearest to x. If x is too small to be represented by a float32 (|x| &amp;lt; math.SmallestNonzeroFloat32), the result is (0, Below) or (-0, Above), respectively, depending on the sign of x. If x is too large to be represented by a float32 (|x| &amp;gt; math.MaxFloat32), the result is (+Inf, Above) or (-Inf, Below), depending on the sign of x.</source>
          <target state="translated">Float32 возвращает ближайшее к x значение float32. Если x слишком мало для представления float32 (| x | &amp;lt;math.SmallestNonzeroFloat32), результатом будет (0, Ниже) или (-0, Выше), соответственно, в зависимости от знака x. Если x слишком велик для представления float32 (| x |&amp;gt; math.MaxFloat32), результатом будет (+ Inf, Above) или (-Inf, Lower), в зависимости от знака x.</target>
        </trans-unit>
        <trans-unit id="f0d283c114b964a75d4c408e464182f402cb0b18" translate="yes" xml:space="preserve">
          <source>Float32 returns the nearest float32 value for x and a bool indicating whether f represents x exactly. If the magnitude of x is too large to be represented by a float32, f is an infinity and exact is false. The sign of f always matches the sign of x, even if f == 0.</source>
          <target state="translated">Float32 возвращает ближайшее значение float32 для x и шерсть,указывающую,точно ли f представляет x.Если величина x слишком велика,чтобы быть представленным с плавающей точкой32,то f-это бесконечность,а точность-ложь.Знак f всегда совпадает со знаком x,даже если f ==0.</target>
        </trans-unit>
        <trans-unit id="eb048248df2600ce9ef5e83d147f9a17ca26adc9" translate="yes" xml:space="preserve">
          <source>Float32 returns, as a float32, a pseudo-random number in [0.0,1.0) from the default Source.</source>
          <target state="translated">Float32 возвращает в качестве float32 псевдослучайное число в [0.0,1.0]из источника по умолчанию.</target>
        </trans-unit>
        <trans-unit id="119557e6710e4b086bbd4a2b0b1939505b2ba07f" translate="yes" xml:space="preserve">
          <source>Float32 returns, as a float32, a pseudo-random number in [0.0,1.0).</source>
          <target state="translated">Float32 возвращает,как float32,псевдослучайное число в [0.0,1.0].</target>
        </trans-unit>
        <trans-unit id="4b84b66f83430db58763aa54b8b6d03936e54bbe" translate="yes" xml:space="preserve">
          <source>Float32Val is like Float64Val but for float32 instead of float64.</source>
          <target state="translated">Float32Val похож на Float64Val,но для float32 вместо float64.</target>
        </trans-unit>
        <trans-unit id="105737d03460ae3ded6de0ef2ecd36f638e30d1b" translate="yes" xml:space="preserve">
          <source>Float32bits returns the IEEE 754 binary representation of f, with the sign bit of f and the result in the same bit position. Float32bits(Float32frombits(x)) == x.</source>
          <target state="translated">Float32bits возвращает в IEEE 754 двоичное представление f,со знаковым битом f и результатом в той же самой позиции бита.Float32bits(Float32frombits(x))==x.</target>
        </trans-unit>
        <trans-unit id="7a6760b22e35a08f8123f6341f83087ea51bc753" translate="yes" xml:space="preserve">
          <source>Float32frombits returns the floating-point number corresponding to the IEEE 754 binary representation b, with the sign bit of b and the result in the same bit position. Float32frombits(Float32bits(x)) == x.</source>
          <target state="translated">Float32frombits возвращает число с плавающей точкой,соответствующее двоичному представлению IEEE 754 b,со знаковым битом b и результатом в той же самой позиции бита.Float32frombits(Float32bits(x))==x.</target>
        </trans-unit>
        <trans-unit id="e33f8d6b4fe7a74df8d041793f6b8728167aa373" translate="yes" xml:space="preserve">
          <source>Float64 defines a float64 flag with specified name, default value, and usage string. The return value is the address of a float64 variable that stores the value of the flag.</source>
          <target state="translated">Float64 определяет флаг float64 с указанным именем,значением по умолчанию и строкой использования.Возвращаемое значение-это адрес переменной float64,в которой хранится значение флага.</target>
        </trans-unit>
        <trans-unit id="932e539e33ca068476000955a48af619cccb5721" translate="yes" xml:space="preserve">
          <source>Float64 returns the float64 value nearest to x. If x is too small to be represented by a float64 (|x| &amp;lt; math.SmallestNonzeroFloat64), the result is (0, Below) or (-0, Above), respectively, depending on the sign of x. If x is too large to be represented by a float64 (|x| &amp;gt; math.MaxFloat64), the result is (+Inf, Above) or (-Inf, Below), depending on the sign of x.</source>
          <target state="translated">Float64 возвращает значение float64, ближайшее к x. Если x слишком мало для представления float64 (| x | &amp;lt;math.SmallestNonzeroFloat64), результатом будет (0, Ниже) или (-0, Выше), соответственно, в зависимости от знака x. Если x слишком велик для представления float64 (| x |&amp;gt; math.MaxFloat64), результатом будет (+ Inf, Above) или (-Inf, Lower), в зависимости от знака x.</target>
        </trans-unit>
        <trans-unit id="dc045688c2b10e541f35cd8fc5a73c8305f2eb7e" translate="yes" xml:space="preserve">
          <source>Float64 returns the internal float64 value for the metric.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9246cdfb5427d2669759af0d644a975a43bcf09a" translate="yes" xml:space="preserve">
          <source>Float64 returns the nearest float64 value for x and a bool indicating whether f represents x exactly. If the magnitude of x is too large to be represented by a float64, f is an infinity and exact is false. The sign of f always matches the sign of x, even if f == 0.</source>
          <target state="translated">Float64 возвращает ближайшее значение float64 для x и bool,указывающее,точно ли f представляет x.Если величина x слишком велика,чтобы быть представленным с плавающей точкой,то f-это бесконечность,а точность-ложь.Знак f всегда совпадает со знаком x,даже если f ==0.</target>
        </trans-unit>
        <trans-unit id="fb72db19ea2b309695153285bf2c38294276e222" translate="yes" xml:space="preserve">
          <source>Float64 returns the number as a float64.</source>
          <target state="translated">Float64 возвращает число как float64.</target>
        </trans-unit>
        <trans-unit id="20e645bfba6b519f6d6f9f504b9c2a836ed66b68" translate="yes" xml:space="preserve">
          <source>Float64 returns, as a float64, a pseudo-random number in [0.0,1.0) from the default Source.</source>
          <target state="translated">Float64 возвращает,как float64,псевдослучайное число в [0.0,1.0)из источника по умолчанию.</target>
        </trans-unit>
        <trans-unit id="39abd5b0f47630ce640acfdfa7a56a26bd48772c" translate="yes" xml:space="preserve">
          <source>Float64 returns, as a float64, a pseudo-random number in [0.0,1.0).</source>
          <target state="translated">Float64 возвращает,как float64,псевдослучайное число в [0.0,1.0).</target>
        </trans-unit>
        <trans-unit id="3044c9d35d4c2e395ec952bd2c1f124b00a34e5a" translate="yes" xml:space="preserve">
          <source>Float64Histogram represents a distribution of float64 values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e78d2601d317a5e13ee64826b30b75657ca96c0e" translate="yes" xml:space="preserve">
          <source>Float64Histogram returns the internal *Float64Histogram value for the metric.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="653daf75fab3a49fdd7213b2a24c9eb000e8f80b" translate="yes" xml:space="preserve">
          <source>Float64Slice attaches the methods of Interface to []float64, sorting in increasing order (not-a-number values are treated as less than other values).</source>
          <target state="translated">Float64Slice присоединяет методы интерфейса к []float64,сортируя в порядке возрастания (значения не-а числа рассматриваются как меньшие,чем другие значения).</target>
        </trans-unit>
        <trans-unit id="f906cc84916bc0dd00d17ca51f9d5dd6448fa3ef" translate="yes" xml:space="preserve">
          <source>Float64Slice implements Interface for a []float64, sorting in increasing order, with not-a-number (NaN) values ordered before other values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d5aaf48b420a680701da91064c2099910f7a459" translate="yes" xml:space="preserve">
          <source>Float64Val returns the nearest Go float64 value of x and whether the result is exact; x must be numeric or an Unknown, but not Complex. For values too small (too close to 0) to represent as float64, Float64Val silently underflows to 0. The result sign always matches the sign of x, even for 0. If x is Unknown, the result is (0, false).</source>
          <target state="translated">Float64Val возвращает ближайшее к Go float64 значение x и точный ли результат;x должен быть числовым или Неизвестным,но не Сложным.Для значений слишком маленьких (слишком близких к 0),чтобы представлять как float64,Float64Val молчаливо опускается ниже 0.Знак результата всегда совпадает со знаком x,даже для 0.Если x неизвестен,то результат будет (0,false).</target>
        </trans-unit>
        <trans-unit id="f480bc564117c47157609272dad009564b4f9701" translate="yes" xml:space="preserve">
          <source>Float64Var defines a float64 flag with specified name, default value, and usage string. The argument p points to a float64 variable in which to store the value of the flag.</source>
          <target state="translated">Float64Var определяет флаг float64 с указанным именем,значением по умолчанию и строкой использования.Аргумент p указывает на переменную float64,в которой будет храниться значение флага.</target>
        </trans-unit>
        <trans-unit id="5b76d09c27fdfd38a6732c012baed4272833ca08" translate="yes" xml:space="preserve">
          <source>Float64bits returns the IEEE 754 binary representation of f, with the sign bit of f and the result in the same bit position, and Float64bits(Float64frombits(x)) == x.</source>
          <target state="translated">Float64bits возвращает в IEEE 754 двоичное представление f,со знаковым битом f и результатом в той же битовой позиции,а Float64bits(Float64frombits(x))==x.</target>
        </trans-unit>
        <trans-unit id="13821cdc42fa2ea9b35bbae95ee0c4f0016322fc" translate="yes" xml:space="preserve">
          <source>Float64frombits returns the floating-point number corresponding to the IEEE 754 binary representation b, with the sign bit of b and the result in the same bit position. Float64frombits(Float64bits(x)) == x.</source>
          <target state="translated">Float64frombits возвращает число с плавающей точкой,соответствующее двоичному представлению IEEE 754 b,со знаковым битом b и результатом в той же самой позиции бита.Float64frombits(Float64bits(x))==x.</target>
        </trans-unit>
        <trans-unit id="9528abfae7394b5c9ba7f685b93bd097bf04d6fb" translate="yes" xml:space="preserve">
          <source>Float64s</source>
          <target state="translated">Float64s</target>
        </trans-unit>
        <trans-unit id="6d807816d1f16d759e0177078b58ba0a3f78cc89" translate="yes" xml:space="preserve">
          <source>Float64s sorts a slice of float64s in increasing order (not-a-number values are treated as less than other values).</source>
          <target state="translated">Float64s сортирует кусочек float64s в порядке возрастания (значения без номера рассматриваются как меньшие по сравнению с другими значениями).</target>
        </trans-unit>
        <trans-unit id="e76c800c50d12be0d0ffe3d12ab4347b885eba2b" translate="yes" xml:space="preserve">
          <source>Float64s sorts a slice of float64s in increasing order. Not-a-number (NaN) values are ordered before other values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="423599a7986fad94bdc1d6990e093d25432d1712" translate="yes" xml:space="preserve">
          <source>Float64sAreSorted</source>
          <target state="translated">Float64sAreSorted</target>
        </trans-unit>
        <trans-unit id="7420edb10083ef184106f9d40b1aeb6592603e4a" translate="yes" xml:space="preserve">
          <source>Float64sAreSorted reports whether the slice x is sorted in increasing order, with not-a-number (NaN) values before any other values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b88d9ca0f421f91022935615e41cacbe0162795" translate="yes" xml:space="preserve">
          <source>Float64sAreSorted tests whether a slice of float64s is sorted in increasing order (not-a-number values are treated as less than other values).</source>
          <target state="translated">Float64sAreSorted проверяет,отсортирован ли кусок float64s в порядке возрастания (значения не по нулям рассматриваются как меньшие,чем другие значения).</target>
        </trans-unit>
        <trans-unit id="2d47ae20529c410d30f8acaae289ca9d51484938" translate="yes" xml:space="preserve">
          <source>FloatString returns a string representation of x in decimal form with prec digits of precision after the radix point. The last digit is rounded to nearest, with halves rounded away from zero.</source>
          <target state="translated">FloatString возвращает строковое представление x в десятичном виде с прецизионными разрядами точности после точки радиуса.Последняя цифра округляется до ближайшей,половина округляется от нуля.</target>
        </trans-unit>
        <trans-unit id="05a1f94d542ff10ae04a25aa8e277a76154c76d0" translate="yes" xml:space="preserve">
          <source>FloatType is here for the purposes of documentation only. It is a stand-in for either float type: float32 or float64.</source>
          <target state="translated">FloatType здесь только для документации.Он является дублером для любого типа float:float32 или float64.</target>
        </trans-unit>
        <trans-unit id="062cea8bd0e8167673b6851fa82870b7db8d7c76" translate="yes" xml:space="preserve">
          <source>Floating point, integer, and Number values encode as JSON numbers.</source>
          <target state="translated">Значения с плавающей точкой,целое и число кодируются как JSON-номера.</target>
        </trans-unit>
        <trans-unit id="d8d6ee865f2a29fd1629088910ea491c9698ff5c" translate="yes" xml:space="preserve">
          <source>Floating-point and complex constituents:</source>
          <target state="translated">Плавучая точка и сложные составляющие:</target>
        </trans-unit>
        <trans-unit id="b844d202032ef470ba06e9916c2c520ac0ae8998" translate="yes" xml:space="preserve">
          <source>Floating-point limit values. Max is the largest finite value representable by the type. SmallestNonzero is the smallest positive, non-zero value representable by the type.</source>
          <target state="translated">Предельные значения с плавающей точкой.Макс-наибольшее конечное значение,представляемое по типу.Наименьшее ненулевое значение-наименьшее положительное,ненулевое значение,представляемое по типу.</target>
        </trans-unit>
        <trans-unit id="58315571a008eb8b389dc1e86460decd0968399f" translate="yes" xml:space="preserve">
          <source>Floating-point numbers are always sent as a representation of a float64 value. That value is converted to a uint64 using math.Float64bits. The uint64 is then byte-reversed and sent as a regular unsigned integer. The byte-reversal means the exponent and high-precision part of the mantissa go first. Since the low bits are often zero, this can save encoding bytes. For instance, 17.0 is encoded in only three bytes (FE 31 40).</source>
          <target state="translated">Числа с плавающей точкой всегда посылаются как представление значения с плавающей точкой64.Это значение преобразуется в uint64 с помощью math.Float64bits.Затем uint64 перепроверяется байтами и передается как обычное беззнаковое целое число.Байт-обратный перевод означает,что сначала идет экспонента и высокоточная часть мантиссы.Так как младшие биты часто равны нулю,то это может сэкономить байты кодировки.Например,17.0 кодируется всего в трех байтах (FE 31 40).</target>
        </trans-unit>
        <trans-unit id="7db82f74092fc3160e6bc0d9e9bd4849c5c06c0f" translate="yes" xml:space="preserve">
          <source>Floor</source>
          <target state="translated">Floor</target>
        </trans-unit>
        <trans-unit id="ecdffd0cc36f2aad9aef8da98d7fbdd7cd3a98c8" translate="yes" xml:space="preserve">
          <source>Floor returns the greatest integer value less than or equal to x.</source>
          <target state="translated">Floor возвращает наибольшее целое значение меньше или равное x.</target>
        </trans-unit>
        <trans-unit id="563e65b909d8ae6e49711cd799a32c5eb753dc00" translate="yes" xml:space="preserve">
          <source>FloydSteinberg is a Drawer that is the Src Op with Floyd-Steinberg error diffusion.</source>
          <target state="translated">FloydSteinberg-это Drawer,который является Src Op с диффузией ошибок Floyd-Steinberg.</target>
        </trans-unit>
        <trans-unit id="589b0d2e5704bd529f61be95ef5544d324be7a14" translate="yes" xml:space="preserve">
          <source>Flush finishes writing the current file's block padding. The current file must be fully written before Flush can be called.</source>
          <target state="translated">Флеш заканчивает запись блока блока текущего файла.Текущий файл должен быть полностью записан перед вызовом Flush.</target>
        </trans-unit>
        <trans-unit id="843ff9ecc07dad8fd240920fbaff659c8bd3b2af" translate="yes" xml:space="preserve">
          <source>Flush flushes any buffered XML to the underlying writer. See the EncodeToken documentation for details about when it is necessary.</source>
          <target state="translated">Промойте любой буферизованный XML к основному пишущему устройству.Подробнее о том,когда это необходимо,смотрите документацию EncodeToken.</target>
        </trans-unit>
        <trans-unit id="7757e81dddaaa31ce1e5de4d9b235a8f3a0853cd" translate="yes" xml:space="preserve">
          <source>Flush flushes any buffered data to the underlying writer. Calling Flush is not normally necessary; calling Close is sufficient.</source>
          <target state="translated">Промойте все буферизованные данные к базовому пишущему устройству.Вызов Flush обычно не требуется,достаточно вызова Close.</target>
        </trans-unit>
        <trans-unit id="96dda344b5d691957686f7fdb72b5295f5fa20bb" translate="yes" xml:space="preserve">
          <source>Flush flushes any pending compressed data to the underlying writer.</source>
          <target state="translated">Промойте все отложенные сжатые данные в соответствующий записывающее устройство.</target>
        </trans-unit>
        <trans-unit id="3d5ed753caad4196a8e88cd94331064662192c20" translate="yes" xml:space="preserve">
          <source>Flush flushes any pending data to the underlying writer. It is useful mainly in compressed network protocols, to ensure that a remote reader has enough data to reconstruct a packet. Flush does not return until the data has been written. Calling Flush when there is no pending data still causes the Writer to emit a sync marker of at least 4 bytes. If the underlying writer returns an error, Flush returns that error.</source>
          <target state="translated">Промойте все отложенные данные в соответствующий записывающее устройство.Это полезно в основном в сжатых сетевых протоколах,чтобы гарантировать,что удаленный читатель имеет достаточно данных для восстановления пакета.Flush не возвращается до тех пор,пока данные не будут записаны.Вызов Flush,когда отложенные данные все еще отсутствуют,приводит к тому,что записывающее устройство выдает маркер синхронизации размером не менее 4 байт.Если записывающее устройство возвращает ошибку,Flush возвращает ее.</target>
        </trans-unit>
        <trans-unit id="18258ea43eb9026bfa3ba6a07c0a3a31739171f2" translate="yes" xml:space="preserve">
          <source>Flush flushes the Writer to its underlying io.Writer.</source>
          <target state="translated">Промойте Писателя к его основному io.Writer.</target>
        </trans-unit>
        <trans-unit id="729311d07e8c1334af4a5f862a0dd14b0dd93238" translate="yes" xml:space="preserve">
          <source>Flush implements http.Flusher. To test whether Flush was called, see rw.Flushed.</source>
          <target state="translated">Флеш-орудия http.Flushher.Чтобы проверить,назывался ли Flush,см.rw.Flush.</target>
        </trans-unit>
        <trans-unit id="5d24f3ea0b3c10e2043b05ee2cd79df1306cedcb" translate="yes" xml:space="preserve">
          <source>Flush should be called after the last call to Write to ensure that any data buffered in the Writer is written to output. Any incomplete escape sequence at the end is considered complete for formatting purposes.</source>
          <target state="translated">Flush следует вызывать после последнего вызова Write,чтобы убедиться,что все данные,заложенные в Writer,будут записаны на вывод.Любая неполная экранирующая последовательность в конце считается полной для целей форматирования.</target>
        </trans-unit>
        <trans-unit id="ea94514228dc595c44d2b25610d0fa2d54b246e4" translate="yes" xml:space="preserve">
          <source>Flush writes any buffered data to the underlying io.Writer.</source>
          <target state="translated">Flush записывает любые буферизованные данные в основной io.Writer.</target>
        </trans-unit>
        <trans-unit id="ae89e3b744d5bf8ef751ee2c788427617846f85a" translate="yes" xml:space="preserve">
          <source>Flush writes any buffered data to the underlying io.Writer. To check if an error occurred during the Flush, call Error.</source>
          <target state="translated">Flush записывает любые буферизованные данные в основной io.Writer.Чтобы проверить,не произошла ли ошибка во время Flush,вызовите Error.</target>
        </trans-unit>
        <trans-unit id="9f472a0c2c904654bddc286404214aebce731987" translate="yes" xml:space="preserve">
          <source>FlushAfterChunkWriter signals from the caller of NewChunkedWriter that each chunk should be followed by a flush. It is used by the http.Transport code to keep the buffering behavior for headers and trailers, but flush out chunks aggressively in the middle for request bodies which may be generated slowly. See Issue 6574.</source>
          <target state="translated">FlushAfterChunkWriter сигнализирует вызывающему абоненту NewChunkedWriter,что за каждым фрагментом должен следовать флеш.Он используется http.Transport кодом для сохранения поведения буферизации для заголовков и трейлеров,но агрессивно вымывает куски посередине для тел запросов,которые могут генерироваться медленно.См.выпуск 6574.</target>
        </trans-unit>
        <trans-unit id="772a9c77dc26ab2b684cccb97da47b2e2cdf95ac" translate="yes" xml:space="preserve">
          <source>FoldCategory maps a category name to a table of code points outside the category that are equivalent under simple case folding to code points inside the category. If there is no entry for a category name, there are no such points.</source>
          <target state="translated">FoldCategory сопоставляет название категории с таблицей кодовых точек вне категории,которые эквивалентны при простом сворачивании в регистр кодовых точек внутри категории.Если для названия категории нет записи,то таких точек нет.</target>
        </trans-unit>
        <trans-unit id="3df43e93d81327f2c6837f681b29802a81ed9d8c" translate="yes" xml:space="preserve">
          <source>FoldScript maps a script name to a table of code points outside the script that are equivalent under simple case folding to code points inside the script. If there is no entry for a script name, there are no such points.</source>
          <target state="translated">FoldScript отображает имя скрипта в таблицу кодовых точек за пределами скрипта,которые эквивалентны при простом сворачивании в регистр кодовых точек внутри скрипта.Если для имени скрипта нет записи,то таких точек нет.</target>
        </trans-unit>
        <trans-unit id="2a306a62652b9cfbec638f004e0203911d315836" translate="yes" xml:space="preserve">
          <source>For IP networks, the network must be &quot;ip&quot;, &quot;ip4&quot; or &quot;ip6&quot; followed by a colon and a literal protocol number or a protocol name, and the address has the form &quot;host&quot;. The host must be a literal IP address or a literal IPv6 address with zone. It depends on each operating system how the operating system behaves with a non-well known protocol number such as &quot;0&quot; or &quot;255&quot;.</source>
          <target state="translated">Для IP-сетей сеть должна быть &quot;ip&quot;,&quot;ip4&quot; или &quot;ip6&quot;,за которым следует двоеточие и буквальный номер протокола или имя протокола,а адрес имеет форму &quot;host&quot;.Хост должен быть буквальным IP-адресом или буквальным IPv6-адресом с зоной.Это зависит от каждой операционной системы,как операционная система ведет себя с не очень известным номером протокола,таким как &quot;0&quot; или &quot;255&quot;.</target>
        </trans-unit>
        <trans-unit id="a986939ec86bd91233d7b82449d187d316efcfcb" translate="yes" xml:space="preserve">
          <source>For POST, PUT, and PATCH requests, it also parses the request body as a form and puts the results into both r.PostForm and r.Form. Request body parameters take precedence over URL query string values in r.Form.</source>
          <target state="translated">Для POST,PUT и PATCH запросов он также разбирает тело запроса как форму и помещает результаты в r.PostForm и r.Form.Параметры тела запроса имеют приоритет над значениями строки URL запроса в r.Form.</target>
        </trans-unit>
        <trans-unit id="225b1c801f3e5dbb06167528a23dd7b472f86786" translate="yes" xml:space="preserve">
          <source>For POST, PUT, and PATCH requests, it also reads the request body, parses it as a form and puts the results into both r.PostForm and r.Form. Request body parameters take precedence over URL query string values in r.Form.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="961435f4e8342868021020dbf9e49c6cd0fb855a" translate="yes" xml:space="preserve">
          <source>For TCP and UDP networks, the address has the form &quot;host:port&quot;. The host must be a literal IP address, or a host name that can be resolved to IP addresses. The port must be a literal port number or a service name. If the host is a literal IPv6 address it must be enclosed in square brackets, as in &quot;[2001:db8::1]:80&quot; or &quot;[fe80::1%zone]:80&quot;. The zone specifies the scope of the literal IPv6 address as defined in RFC 4007. The functions JoinHostPort and SplitHostPort manipulate a pair of host and port in this form. When using TCP, and the host resolves to multiple IP addresses, Dial will try each IP address in order until one succeeds.</source>
          <target state="translated">Для TCP и UDP сетей адрес имеет форму &quot;host:port&quot;.Хост должен быть буквальным IP-адресом или именем хоста,которое может быть преобразовано в IP-адрес.Порт должен быть буквальным номером порта или именем службы.Если хост является буквальным IPv6 адресом,то он должен быть заключен в квадратные скобки,как в &quot;[2001:db8::1]:80&quot; или &quot;[fe80::1%-зона]:80&quot;.Зона задает границы буквального IPv6-адреса,как определено в RFC 4007.Функции JoinHostPort и SplitHostPort манипулируют парой хостов и портов в этом виде.При использовании TCP,и хост разрешает несколько IP-адресов,Dial будет пробовать каждый IP-адрес в порядке до тех пор,пока один из них не завершится успешно.</target>
        </trans-unit>
        <trans-unit id="03c81916838d3414948e1c22f701e5ce4a3a4855" translate="yes" xml:space="preserve">
          <source>For TCP networks, if the host in the address parameter is empty or a literal unspecified IP address, Listen listens on all available unicast and anycast IP addresses of the local system. To only use IPv4, use network &quot;tcp4&quot;. The address can use a host name, but this is not recommended, because it will create a listener for at most one of the host's IP addresses. If the port in the address parameter is empty or &quot;0&quot;, as in &quot;127.0.0.1:&quot; or &quot;[::1]:0&quot;, a port number is automatically chosen. The Addr method of Listener can be used to discover the chosen port.</source>
          <target state="translated">Для TCP сетей,если хост в параметре адреса пустой или буквально неопределенный IP-адрес,Listen прослушивает все доступные одноадресные и широковещательные IP-адреса локальной системы.Чтобы использовать только IPv4,используйте сеть &quot;tcp4&quot;.Адрес может использовать имя хоста,но это не рекомендуется,так как это создаст слушателя для большинства IP-адресов хостов.Если порт в параметре адреса пустой или &quot;0&quot;,как в &quot;127.0.0.1:&quot; или &quot;[::1]:0&quot;,то номер порта выбирается автоматически.Для обнаружения выбранного порта можно использовать метод Addr Listener.</target>
        </trans-unit>
        <trans-unit id="bc11a7bec3f66f8d391db1eaf65bf359662c3096" translate="yes" xml:space="preserve">
          <source>For TCP, UDP and IP networks, if the host is empty or a literal unspecified IP address, as in &quot;:80&quot;, &quot;0.0.0.0:80&quot; or &quot;[::]:80&quot; for TCP and UDP, &quot;&quot;, &quot;0.0.0.0&quot; or &quot;::&quot; for IP, the local system is assumed.</source>
          <target state="translated">Для TCP,UDP и IP сетей,если хост пуст или буквально не указан IP-адрес,как в &quot;:80&quot;,&quot;0.0.0.0:80&quot; или &quot;[::]:80&quot; для TCP и UDP,&quot;&quot;,&quot;0.0.0.0&quot; или &quot;::&quot; для IP,то предполагается,что локальная система.</target>
        </trans-unit>
        <trans-unit id="f2ddf19f5cd72f2d3b549235c60d91767535d03b" translate="yes" xml:space="preserve">
          <source>For UDP and IP networks, if the host in the address parameter is empty or a literal unspecified IP address, ListenPacket listens on all available IP addresses of the local system except multicast IP addresses. To only use IPv4, use network &quot;udp4&quot; or &quot;ip4:proto&quot;. The address can use a host name, but this is not recommended, because it will create a listener for at most one of the host's IP addresses. If the port in the address parameter is empty or &quot;0&quot;, as in &quot;127.0.0.1:&quot; or &quot;[::1]:0&quot;, a port number is automatically chosen. The LocalAddr method of PacketConn can be used to discover the chosen port.</source>
          <target state="translated">Для UDP и IP сетей,если хост в параметре адреса пуст или буквально неопределенный IP-адрес,ListenPacket прослушивает все доступные IP-адреса локальной системы,за исключением многоадресных IP-адресов.Чтобы использовать только IPv4,используйте сеть &quot;udp4&quot; или &quot;ip4:proto&quot;.Адрес может использовать имя хоста,но это не рекомендуется,так как это создаст прослушиватель для большинства IP-адресов хостов.Если порт в параметре адреса пустой или &quot;0&quot;,как в &quot;127.0.0.1:&quot; или &quot;[::1]:0&quot;,то номер порта выбирается автоматически.Для обнаружения выбранного порта можно использовать метод LocalAddr PacketConn.</target>
        </trans-unit>
        <trans-unit id="4aa2c0bd0a7ad04b8f9986a2d00cc56ef314d18a" translate="yes" xml:space="preserve">
          <source>For Unix networks, the address must be a file system path.</source>
          <target state="translated">Для сетей Unix адрес должен быть указан как путь к файловой системе.</target>
        </trans-unit>
        <trans-unit id="55388abcc16d920a08a97c993d2242d3821d48ea" translate="yes" xml:space="preserve">
          <source>For a Timer created with AfterFunc(d, f), Reset either reschedules when f will run, in which case Reset returns true, or schedules f to run again, in which case it returns false. When Reset returns false, Reset neither waits for the prior f to complete before returning nor does it guarantee that the subsequent goroutine running f does not run concurrently with the prior one. If the caller needs to know whether the prior execution of f is completed, it must coordinate with f explicitly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="abbce471eb362731eac46a382c7b5f3c54982be7" translate="yes" xml:space="preserve">
          <source>For a Timer created with NewTimer, Reset should be invoked only on stopped or expired timers with drained channels.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6cd90d9b68fe83f1b691af955f9ccbfffd46f969" translate="yes" xml:space="preserve">
          <source>For a description of the testing flags, see &lt;a href=&quot;https://golang.org/cmd/go/#hdr-Testing_flags&quot;&gt;https://golang.org/cmd/go/#hdr-Testing_flags&lt;/a&gt;</source>
          <target state="translated">Описание флагов тестирования см. На &lt;a href=&quot;https://golang.org/cmd/go/#hdr-Testing_flags&quot;&gt;https://golang.org/cmd/go/#hdr-Testing_flags.&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="73db7630962b7d9bfe80901d992afe02ab8d444e" translate="yes" xml:space="preserve">
          <source>For a more concise way to create NamedArg values, see the Named function.</source>
          <target state="translated">Более краткий способ создания значений NamedArg см.в разделе Функция NamedArg.</target>
        </trans-unit>
        <trans-unit id="2e93a7b63c6c1c22251cdfa7d2125bbcb4c1d807" translate="yes" xml:space="preserve">
          <source>For a study of the facility in action, visit</source>
          <target state="translated">Для изучения объекта в действии посетите</target>
        </trans-unit>
        <trans-unit id="ea8b0e15d8c10094163cd876f62393b64628d456" translate="yes" xml:space="preserve">
          <source>For a timer created with AfterFunc(d, f), if t.Stop returns false, then the timer has already expired and the function f has been started in its own goroutine; Stop does not wait for f to complete before returning. If the caller needs to know whether f is completed, it must coordinate with f explicitly.</source>
          <target state="translated">Для таймера,созданного с помощью AfterFunc(d,f),если t.Stop возвращает false,то таймер уже истек и функция f была запущена в своем собственном goroutine;Stop не ждет завершения f перед возвращением.Если вызывающему абоненту необходимо знать,завершена ли функция f,то он должен явно согласовывать ее с f.</target>
        </trans-unit>
        <trans-unit id="adbed43366f7734c782e1358f999b46beb1e3fca" translate="yes" xml:space="preserve">
          <source>For a tutorial, see &lt;a href=&quot;https://golang.org/s/types-tutorial&quot;&gt;https://golang.org/s/types-tutorial&lt;/a&gt;.</source>
          <target state="translated">Учебное пособие см. На &lt;a href=&quot;https://golang.org/s/types-tutorial&quot;&gt;https://golang.org/s/types-tutorial&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e18ade19ed4a3115a9d9e3c880c80a5a49514530" translate="yes" xml:space="preserve">
          <source>For all requests, ParseForm parses the raw query from the URL and updates r.Form.</source>
          <target state="translated">Для всех запросов ParseForm разбирает исходный запрос с URL и обновляет r.Form.</target>
        </trans-unit>
        <trans-unit id="a78bb4acd6502d15dc3957871fac3c0be9d9b00b" translate="yes" xml:space="preserve">
          <source>For an abstract method, Recv returns the enclosing interface either as a *Named or an *Interface. Due to embedding, an interface may contain methods whose receiver type is a different interface.</source>
          <target state="translated">Для абстрактного метода Recv возвращает интерфейс в виде *Named или *Interface.Из-за встраивания интерфейс может содержать методы,тип приемника которых отличается от интерфейса.</target>
        </trans-unit>
        <trans-unit id="4e330719ad337b4c9602641929cab60cae09925d" translate="yes" xml:space="preserve">
          <source>For an outgoing client request, the context controls the entire lifetime of a request and its response: obtaining a connection, sending the request, and reading the response headers and body.</source>
          <target state="translated">Для запроса исходящего клиента контекст контролирует весь срок жизни запроса и его ответа:получение соединения,отправка запроса и чтение заголовков и тела ответа.</target>
        </trans-unit>
        <trans-unit id="d8c341cebb2371fc4554d9fb0c6e54c2c5900936" translate="yes" xml:space="preserve">
          <source>For base 0, an underscore character &amp;ldquo;_&amp;rdquo; may appear between a base prefix and an adjacent digit, and between successive digits; such underscores do not change the value of the number, or the returned digit count. Incorrect placement of underscores is reported as an error if there are no other errors. If base != 0, underscores are not recognized and thus terminate scanning like any other character that is not a valid radix point or digit.</source>
          <target state="translated">Для базового 0 символ подчеркивания &amp;laquo;_&amp;raquo; может появляться между базовым префиксом и соседней цифрой, а также между последовательными цифрами; такие подчеркивания не изменяют ни значение числа, ни количество возвращаемых цифр. Неправильное размещение подчеркиваний сообщается как ошибка, если нет других ошибок. Если base! = 0, символы подчеркивания не распознаются и, таким образом, завершают сканирование, как любой другой символ, который не является действительной точкой или цифрой системы счисления.</target>
        </trans-unit>
        <trans-unit id="e5942b37cf590ae4aabd1b760f075ef90fd1c294" translate="yes" xml:space="preserve">
          <source>For base 0, an underscore character &amp;ldquo;_&amp;rdquo; may appear between a base prefix and an adjacent digit, and between successive digits; such underscores do not change the value of the number. Incorrect placement of underscores is reported as an error if there are no other errors. If base != 0, underscores are not recognized and act like any other character that is not a valid digit.</source>
          <target state="translated">Для базового 0 символ подчеркивания &amp;laquo;_&amp;raquo; может появляться между базовым префиксом и соседней цифрой, а также между последовательными цифрами; такие подчеркивания не изменяют значение числа. Неправильное размещение подчеркиваний сообщается как ошибка, если нет других ошибок. Если base! = 0, символы подчеркивания не распознаются и действуют как любой другой символ, который не является допустимой цифрой.</target>
        </trans-unit>
        <trans-unit id="5f1ac8df1f8e77c9fdc27bc0637f8b872484b6a1" translate="yes" xml:space="preserve">
          <source>For base 0, the number prefix determines the actual base: A prefix of &amp;ldquo;0b&amp;rdquo; or &amp;ldquo;0B&amp;rdquo; selects base 2, &amp;ldquo;0o&amp;rdquo; or &amp;ldquo;0O&amp;rdquo; selects base 8, and &amp;ldquo;0x&amp;rdquo; or &amp;ldquo;0X&amp;rdquo; selects base 16. Otherwise, the actual base is 10 and no prefix is accepted. The octal prefix &quot;0&quot; is not supported (a leading &quot;0&quot; is simply considered a &quot;0&quot;).</source>
          <target state="translated">Для базы 0 префикс числа определяет фактическую базу: префикс &amp;laquo;0b&amp;raquo; или &amp;laquo;0B&amp;raquo; выбирает базу 2, &amp;laquo;0o&amp;raquo; или &amp;laquo;0O&amp;raquo; выбирает базу 8, а &amp;laquo;0x&amp;raquo; или &amp;laquo;0X&amp;raquo; выбирает базу 16. В противном случае , фактическое основание - 10, префикс не принимается. Восьмеричный префикс &amp;laquo;0&amp;raquo; не поддерживается (начальный &amp;laquo;0&amp;raquo; просто считается &amp;laquo;0&amp;raquo;).</target>
        </trans-unit>
        <trans-unit id="8da96f7777bef60314c708eb513a45527fc86e1a" translate="yes" xml:space="preserve">
          <source>For bases &amp;lt;= 36, lower and upper case letters are considered the same: The letters 'a' to 'z' and 'A' to 'Z' represent digit values 10 to 35. For bases &amp;gt; 36, the upper case letters 'A' to 'Z' represent the digit values 36 to 61.</source>
          <target state="translated">Для оснований &amp;lt;= 36 строчные и прописные буквы считаются одинаковыми: буквы от &amp;laquo;a&amp;raquo; до &amp;laquo;z&amp;raquo; и от &amp;laquo;A&amp;raquo; до &amp;laquo;Z&amp;raquo; представляют собой цифровые значения от 10 до 35. Для оснований&amp;gt; 36 буквы верхнего регистра &amp;raquo; Буквы от A до Z представляют собой цифровые значения от 36 до 61.</target>
        </trans-unit>
        <trans-unit id="1cda30f1e34e7fc3ab26bca0abe9bc827de94de0" translate="yes" xml:space="preserve">
          <source>For calls ForCompiler with a new FileSet.</source>
          <target state="translated">Для звонков в ForCompiler с новым FileSet.</target>
        </trans-unit>
        <trans-unit id="7777ccd24b8bd654eee8980ccc52774364f6122b" translate="yes" xml:space="preserve">
          <source>For compatibility with Go 1.0, Symbols omits the null symbol at index 0. After retrieving the symbols as symtab, an externally supplied index x corresponds to symtab[x-1], not symtab[x].</source>
          <target state="translated">Для совместимости с Go 1.0,Symbols опускает нулевой символ в индексе 0.После получения символов в виде симтаба,внешне поставляемый индекс x соответствует симтабу[x-1],а не симтабу[x].</target>
        </trans-unit>
        <trans-unit id="bd3f39afacd60fc39b35ccda1637af8ff2e8c205" translate="yes" xml:space="preserve">
          <source>For compatibility with Symbols, DynamicSymbols omits the null symbol at index 0. After retrieving the symbols as symtab, an externally supplied index x corresponds to symtab[x-1], not symtab[x].</source>
          <target state="translated">Для совместимости с Symbols,DynamicSymbols опускает нулевой символ в индексе 0.После получения символов в виде симтаба,внешне поставляемый индекс x соответствует симтабу[x-1],а не симтабу[x].</target>
        </trans-unit>
        <trans-unit id="ceff07027a0562aae7bcfc8fafd438b3054bb3ea" translate="yes" xml:space="preserve">
          <source>For complex numbers, the width and precision apply to the two components independently and the result is parenthesized, so %f applied to 1.2+3.4i produces (1.200000+3.400000i).</source>
          <target state="translated">Для комплексных чисел ширина и точность применяются к двум компонентам независимо друг от друга,а результат получается в скобках,поэтому %f применяется к 1.2+3.4i производит (1.200000+3.400000i).</target>
        </trans-unit>
        <trans-unit id="9b540b6ad368c9fd7ce41d2cd5a4983671593e81" translate="yes" xml:space="preserve">
          <source>For compound objects, the elements are printed using these rules, recursively, laid out like this:</source>
          <target state="translated">Для составных объектов элементы распечатываются по этим правилам,рекурсивно,выкладываются таким образом:</target>
        </trans-unit>
        <trans-unit id="33fb692c25f138c6447e3086029bcccc81bc7da5" translate="yes" xml:space="preserve">
          <source>For compound operands such as slices and structs, the format applies to the elements of each operand, recursively, not to the operand as a whole. Thus %q will quote each element of a slice of strings, and %6.2f will control formatting for each element of a floating-point array.</source>
          <target state="translated">Для составных операндов,таких как фрагменты и структуры,формат применяется к элементам каждого операнда,рекурсивно,а не к операнду в целом.Таким образом,%q процитирует каждый элемент среза строки,а %6.2f будет управлять форматированием для каждого элемента массива с плавающей точкой.</target>
        </trans-unit>
        <trans-unit id="5cab5826d638fdbcb2ad7a5200731c473b3d7274" translate="yes" xml:space="preserve">
          <source>For control over HTTP client headers, redirect policy, and other settings, create a Client:</source>
          <target state="translated">Для управления заголовками HTTP-клиента,политикой перенаправления и другими параметрами создайте Клиента:</target>
        </trans-unit>
        <trans-unit id="c05d2d3e27ddcc721da61cee1a36f988089cfb17" translate="yes" xml:space="preserve">
          <source>For control over canceling or setting a timeout on a handshake, use the Dialer's DialContext method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0c2ce00eb37f48324b8088e1562b15a52ee733a" translate="yes" xml:space="preserve">
          <source>For control over proxies, TLS configuration, keep-alives, compression, and other settings, create a Transport:</source>
          <target state="translated">Для контроля над прокси,настройки TLS,keep-alives,сжатия и других параметров создайте Transport:</target>
        </trans-unit>
        <trans-unit id="993c8adfef972ba1b068a5731b030b2c3e0c3fdb" translate="yes" xml:space="preserve">
          <source>For correct printing of source code containing comments (using packages go/format and go/printer), special care must be taken to update comments when a File's syntax tree is modified: For printing, comments are interspersed between tokens based on their position. If syntax tree nodes are removed or moved, relevant comments in their vicinity must also be removed (from the File.Comments list) or moved accordingly (by updating their positions). A CommentMap may be used to facilitate some of these operations.</source>
          <target state="translated">Для корректной печати исходного кода,содержащего комментарии (с использованием пакетов go/format и go/printer),необходимо уделять особое внимание обновлению комментариев при изменении синтаксического дерева Файла:Для печати комментарии перемежаются между маркерами в зависимости от их положения.Если узлы синтаксического дерева удалены или перемещены,соответствующие комментарии в их окрестностях также должны быть удалены (из списка File.Comments)или перемещены соответствующим образом (путем обновления их положения).Для облегчения некоторых из этих операций может быть использована карта CommentMap.</target>
        </trans-unit>
        <trans-unit id="483fb4b25526c306ca9ffc7060d999d1af757359" translate="yes" xml:space="preserve">
          <source>For debugging, the result of t.String does include the monotonic clock reading if present. If t != u because of different monotonic clock readings, that difference will be visible when printing t.String() and u.String().</source>
          <target state="translated">Для отладки результат t.String включает в себя чтение монотонных часов,если они присутствуют.Если t !=u из-за различных показаний монотонных часов,то эта разница будет видна при печати t.String()и u.String().</target>
        </trans-unit>
        <trans-unit id="c8abfac368bfa911449148a175097af24838350b" translate="yes" xml:space="preserve">
          <source>For each Printf-like function, there is also a Print function that takes no format and is equivalent to saying %v for every operand. Another variant Println inserts blanks between operands and appends a newline.</source>
          <target state="translated">Для каждой функции типа Printf также существует функция Print,которая не принимает формат и эквивалентна произнесению %v для каждого операнда.Другой вариант Println вставляет пробелы между операндами и добавляет новую строку.</target>
        </trans-unit>
        <trans-unit id="2a2f4f1a729ce7677e5cf80bd12ad7a79baf850c" translate="yes" xml:space="preserve">
          <source>For embedding a single file, a variable of type string or []byte is often best. The FS type enables embedding a tree of files, such as a directory of static web server content, as in the example above.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6db6725e9e7d5c088630e348048d1e73fc7657d3" translate="yes" xml:space="preserve">
          <source>For example,</source>
          <target state="translated">Например,</target>
        </trans-unit>
        <trans-unit id="0691fc88626f896c5b4d0c9d21eb150c4440f732" translate="yes" xml:space="preserve">
          <source>For example, a client might run a HELP command that returns a dot-body by using:</source>
          <target state="translated">Например,клиент может выполнить команду HELP,которая возвращает dot-body с помощью:</target>
        </trans-unit>
        <trans-unit id="d2c85d01a63eaf87fca388b5018e0aae0a907e1f" translate="yes" xml:space="preserve">
          <source>For example, a plugin defined as</source>
          <target state="translated">Например,плагин,определяемый как</target>
        </trans-unit>
        <trans-unit id="b604de3a3134fd6e14b1dedf12ca2289afcd00f8" translate="yes" xml:space="preserve">
          <source>For example, assume that we decided to froth milk, extract coffee, and mix milk and coffee in separate goroutines. With a task, the trace tool can identify the goroutines involved in a specific cappuccino order.</source>
          <target state="translated">Например,предположим,что мы решили вспенивать молоко,экстрагировать кофе и смешивать молоко и кофе в отдельных горутинах.С помощью инструмента для трассировки можно идентифицировать гориллы,участвующие в определенном заказе капучино.</target>
        </trans-unit>
        <trans-unit id="eb2f502c06edd8d48f9eb402147b9d0d02234fdf" translate="yes" xml:space="preserve">
          <source>For example, consider this input:</source>
          <target state="translated">Например,рассмотрим этот вход:</target>
        </trans-unit>
        <trans-unit id="32f7515ac15513dae926420ef8347c405e749ac1" translate="yes" xml:space="preserve">
          <source>For example, given the content variable in the example above, we can write:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e07ff3b2f7ec128082cb6d47f79493ae88ad678a" translate="yes" xml:space="preserve">
          <source>For example, here are three ways to embed a file named hello.txt and then print its contents at run time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c08416096093138a9f21f98db3e35296861799a" translate="yes" xml:space="preserve">
          <source>For example, if p points to a struct that contains a file descriptor d, and p has a finalizer that closes that file descriptor, and if the last use of p in a function is a call to syscall.Write(p.d, buf, size), then p may be unreachable as soon as the program enters syscall.Write. The finalizer may run at that moment, closing p.d, causing syscall.Write to fail because it is writing to a closed file descriptor (or, worse, to an entirely different file descriptor opened by a different goroutine). To avoid this problem, call runtime.KeepAlive(p) after the call to syscall.Write.</source>
          <target state="translated">Например,если p указывает на структуру,содержащую файловый дескриптор d,а p имеет финализатор,закрывающий этот файловый дескриптор,и если последнее использование p в функции является вызовом syscall.Write(p.d,buf,size),то p может быть недоступен,как только программа войдет в syscall.Write.Финализатор может запуститься в этот момент,закрыв p.d,что приведет к ошибке syscall.Write,потому что он записывает в закрытый файловый дескриптор (или,что еще хуже,в совершенно другой файловый дескриптор,открытый другим горутином).Чтобы избежать этой проблемы,после вызова syscall.Write вызовите runtime.KeepAlive(p).</target>
        </trans-unit>
        <trans-unit id="b7f27996d14898d381b2006768c093d3591a4f75" translate="yes" xml:space="preserve">
          <source>For example, if p points to a struct, such as os.File, that contains a file descriptor d, and p has a finalizer that closes that file descriptor, and if the last use of p in a function is a call to syscall.Write(p.d, buf, size), then p may be unreachable as soon as the program enters syscall.Write. The finalizer may run at that moment, closing p.d, causing syscall.Write to fail because it is writing to a closed file descriptor (or, worse, to an entirely different file descriptor opened by a different goroutine). To avoid this problem, call runtime.KeepAlive(p) after the call to syscall.Write.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="648df35862f0618dac59c24e1f3c2197d967fa5c" translate="yes" xml:space="preserve">
          <source>For example, pre-submit checks that use this package directly would behave differently depending on what Go version each developer uses, causing the check to be inherently fragile.</source>
          <target state="translated">Например,проверки перед отправкой,которые напрямую используют этот пакет,будут вести себя по-разному в зависимости от того,какую версию Go использует каждый разработчик,что приводит к тому,что проверка по своей природе является хрупкой.</target>
        </trans-unit>
        <trans-unit id="b70afa30fe71b5984e96c509da8feab3dc9a6c66" translate="yes" xml:space="preserve">
          <source>For example, this code always computes a positive elapsed time of approximately 20 milliseconds, even if the wall clock is changed during the operation being timed:</source>
          <target state="translated">Например,этот код всегда вычисляет положительное истекшее время примерно в 20 миллисекунд,даже если во время выполнения операции были изменены настенные часы:</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">Например:</target>
        </trans-unit>
        <trans-unit id="b900be25452bfa919448d61bc68d11256350e2d5" translate="yes" xml:space="preserve">
          <source>For floating-point values, width sets the minimum width of the field and precision sets the number of places after the decimal, if appropriate, except that for %g/%G precision sets the maximum number of significant digits (trailing zeros are removed). For example, given 12.345 the format %6.3f prints 12.345 while %.3g prints 12.3. The default precision for %e, %f and %#g is 6; for %g it is the smallest number of digits necessary to identify the value uniquely.</source>
          <target state="translated">Для значений с плавающей точкой ширина задает минимальную ширину поля,а точность задает количество мест после запятой,если это уместно,за исключением того,что для точности %g/%G задает максимальное количество значащих цифр (трейлинговые нули удаляются).Например,при 12.345 формат %6.3f печатает 12.345,в то время как %.3g печатает 12.3.Точность по умолчанию для %e,%f и %#g-6;для %g-наименьшее количество цифр,необходимое для однозначной идентификации значения.</target>
        </trans-unit>
        <trans-unit id="8acb9c872d25848ac32729a8857f27d0fe460ece" translate="yes" xml:space="preserve">
          <source>For forward compatibility, users that retrieve a Header from Reader.Next, mutate it in some ways, and then pass it back to Writer.WriteHeader should do so by creating a new Header and copying the fields that they are interested in preserving.</source>
          <target state="translated">Для прямой совместимости,пользователи,которые получают заголовок из Reader.Next,мутируют его каким-то образом,а затем передают его обратно в Writer.WriteHeader,должны сделать это,создав новый заголовок и скопировав поля,которые они заинтересованы в сохранении.</target>
        </trans-unit>
        <trans-unit id="e4409a51b04b7b882dd788481aa8d78b52daf5f6" translate="yes" xml:space="preserve">
          <source>For higher-level HTTP client support (such as handling of cookies and redirects), see Get, Post, and the Client type.</source>
          <target state="translated">Для получения информации о поддержке HTTP-клиентов более высокого уровня (например,обработка куки-файлов и перенаправление)см.раздел Получить,Отправить и тип клиента.</target>
        </trans-unit>
        <trans-unit id="ccf573cb88fa50261bc0cb844250e5c546113d3a" translate="yes" xml:space="preserve">
          <source>For incoming server requests, the context is canceled when the client's connection closes, the request is canceled (with HTTP/2), or when the ServeHTTP method returns.</source>
          <target state="translated">Для входящих запросов сервера контекст отменяется,когда соединение клиента закрывается,запрос отменяется (с HTTP/2),или когда возвращается метод ServeHTTP.</target>
        </trans-unit>
        <trans-unit id="fbc897ff158a8e45243f9b229fc5329d56c63ca4" translate="yes" xml:space="preserve">
          <source>For information about UTF-8 strings in Go, see &lt;a href=&quot;https://blog.golang.org/strings&quot;&gt;https://blog.golang.org/strings&lt;/a&gt;.</source>
          <target state="translated">Для получения информации о строках UTF-8 в Go см. &lt;a href=&quot;https://blog.golang.org/strings&quot;&gt;Https://blog.golang.org/strings&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="63fe9b03e1c707dfe354f7496b7b0ea1047361fe" translate="yes" xml:space="preserve">
          <source>For instance, NewInt(x) returns an *Int set to the value of the int64 argument x, NewRat(a, b) returns a *Rat set to the fraction a/b where a and b are int64 values, and NewFloat(f) returns a *Float initialized to the float64 argument f. More flexibility is provided with explicit setters, for instance:</source>
          <target state="translated">Например,NewInt(x)возвращает *Int set к значению аргумента int64 x,NewRat(a,b)возвращает *Rat set к дроби a/b,где a и b-значения int64,а NewFloat(f)возвращает *Float,инициализированный к аргументу float64 f.Большая гибкость обеспечивается,например,с помощью явных множеств:</target>
        </trans-unit>
        <trans-unit id="ef36fa9bc6685ceb9dbf97a5a5da2cffd6025d4b" translate="yes" xml:space="preserve">
          <source>For instance, given a slice data sorted in ascending order, the call Search(len(data), func(i int) bool { return data[i] &amp;gt;= 23 }) returns the smallest index i such that data[i] &amp;gt;= 23. If the caller wants to find whether 23 is in the slice, it must test data[i] == 23 separately.</source>
          <target state="translated">Например, для данных среза, отсортированных в порядке возрастания, вызов Search (len (data), func (i int) bool {return data [i]&amp;gt; = 23}) возвращает наименьший индекс i, такой что data [i]&amp;gt; = 23. Если вызывающий хочет определить, находится ли 23 в срезе, он должен отдельно проверить данные [i] == 23.</target>
        </trans-unit>
        <trans-unit id="c7dfa4cd456b849ced74b774ac752b76885a540c" translate="yes" xml:space="preserve">
          <source>For instance, the arguments for (*Int).Add are named x and y, and because the receiver specifies the result destination, it is called z:</source>
          <target state="translated">Например,аргументы для (*Int).Add называются x и y,а так как получатель указывает пункт назначения результата,он называется z:</target>
        </trans-unit>
        <trans-unit id="8f07f1d3d8e7f6b87f995e34e12a6b2b7256d6aa" translate="yes" xml:space="preserve">
          <source>For instance, when executing the template whose source is</source>
          <target state="translated">Например,при выполнении шаблона,источником которого является</target>
        </trans-unit>
        <trans-unit id="d7e0bab67441455c755b896ba0e2e68a1eb05350" translate="yes" xml:space="preserve">
          <source>For layouts specifying the two-digit year 06, a value NN &amp;gt;= 69 will be treated as 19NN and a value NN &amp;lt; 69 will be treated as 20NN.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9e462fa1286e4f10051fc8442af5645f8b6918a" translate="yes" xml:space="preserve">
          <source>For more details on the precise definition of the metric key's path and unit formats, see the documentation of the Name field of the Description struct.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6018681f8b36b5a67b809b220861a7e3eea4cf91" translate="yes" xml:space="preserve">
          <source>For more information about pprof, see &lt;a href=&quot;https://github.com/google/pprof/blob/master/doc/README.md&quot;&gt;https://github.com/google/pprof/blob/master/doc/README.md&lt;/a&gt;.</source>
          <target state="translated">Для получения дополнительной информации о pprof см. &lt;a href=&quot;https://github.com/google/pprof/blob/master/doc/README.md&quot;&gt;Https://github.com/google/pprof/blob/master/doc/README.md&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d996431a64b6bd8bf9d3bd0300d40b96d810b5b1" translate="yes" xml:space="preserve">
          <source>For more tolerant parsing, Scan will return a valid token if possible even if a syntax error was encountered. Thus, even if the resulting token sequence contains no illegal tokens, a client may not assume that no error occurred. Instead it must check the scanner's ErrorCount or the number of calls of the error handler, if there was one installed.</source>
          <target state="translated">Для более толерантного разбора,Scan вернет правильный маркер,если это возможно,даже если была обнаружена синтаксическая ошибка.Таким образом,даже если полученная последовательность токенов не содержит нелегальных токенов,клиент может не предполагать,что ошибки не произошло.Вместо этого он должен проверить ErrorCount сканера или количество вызовов обработчика ошибок,если он был установлен.</target>
        </trans-unit>
        <trans-unit id="ee92c8f279c1f6e92caa92b507d20eceb3f7bf2a" translate="yes" xml:space="preserve">
          <source>For most Unix systems, this package has two internal implementations of resolving user and group ids to names. One is written in pure Go and parses /etc/passwd and /etc/group. The other is cgo-based and relies on the standard C library (libc) routines such as getpwuid_r and getgrnam_r.</source>
          <target state="translated">Для большинства Unix-систем этот пакет имеет две внутренние реализации преобразования идентификаторов пользователей и групп в имена.Одна из них написана в чистом виде Go и анализирует /etc/passwd и /etc/group.Другая основана на Cgo и полагается на стандартные процедуры библиотеки C (libc),такие как getpwuid_r и getgrnam_r.</target>
        </trans-unit>
        <trans-unit id="c4cdb94c601192f951b8e3c2e58421475088397d" translate="yes" xml:space="preserve">
          <source>For most values, width is the minimum number of runes to output, padding the formatted form with spaces if necessary.</source>
          <target state="translated">Для большинства значений ширина-это минимальное количество выводимых рун,при необходимости заполняя отформатированную форму пробелами.</target>
        </trans-unit>
        <trans-unit id="515255bc358ef4ff5aa5412e1b66dcc8c403a8d9" translate="yes" xml:space="preserve">
          <source>For non-interface types V, or if static is set, V implements T if all methods of T are present in V. Otherwise (V is an interface and static is not set), MissingMethod only checks that methods of T which are also present in V have matching types (e.g., for a type assertion x.(T) where x is of interface type V).</source>
          <target state="translated">Для неинтерфейсных типов V,или если установлена статика,V реализует T,если все методы T присутствуют в V.В противном случае (V-интерфейс и статика не установлена),MissingMethod проверяет только то,что методы T,которые также присутствуют в V,имеют совпадающие типы (например,для утверждения типа x.(T),где x присутствует в интерфейсе типа V).</target>
        </trans-unit>
        <trans-unit id="b71be130422309f072d39771550fbade7a681c88" translate="yes" xml:space="preserve">
          <source>For other HTTP methods, or when the Content-Type is not application/x-www-form-urlencoded, the request Body is not read, and r.PostForm is initialized to a non-nil, empty value.</source>
          <target state="translated">Для других методов HTTP,или когда Content-Type не является приложением/x-www-form-urlencoded,тело запроса не читается,а r.PostForm инициализируется с нулевым,пустым значением.</target>
        </trans-unit>
        <trans-unit id="90fd7feae6eaa72525957265644b35d2d7178aab" translate="yes" xml:space="preserve">
          <source>For outgoing client request, the context controls the entire lifetime of a request and its response: obtaining a connection, sending the request, and reading the response headers and body.</source>
          <target state="translated">Для запроса исходящего клиента контекст управляет всем временем жизни запроса и его ответа:получением соединения,отправкой запроса и чтением заголовков и тела ответа.</target>
        </trans-unit>
        <trans-unit id="d9dd41b387dea5f2e387ef2638e22692d5781ada" translate="yes" xml:space="preserve">
          <source>For outgoing client requests, the context controls cancellation.</source>
          <target state="translated">Для исходящих запросов клиентов контекст контролирует отмену.</target>
        </trans-unit>
        <trans-unit id="a001fc47d27546732ba34a6c50953e3947ee9592" translate="yes" xml:space="preserve">
          <source>For parsing this time format, see ParseTime.</source>
          <target state="translated">Для разбора этого формата времени смотрите ParseTime.</target>
        </trans-unit>
        <trans-unit id="f71ccb724292b936b826fde518652933240dfacc" translate="yes" xml:space="preserve">
          <source>For portability, the status code should be in the range [0, 125].</source>
          <target state="translated">Для переносимости код состояния должен находиться в диапазоне [0,125].</target>
        </trans-unit>
        <trans-unit id="bf654bcdb4217ef6a979d8f651f736b1fbda2ae7" translate="yes" xml:space="preserve">
          <source>For random numbers suitable for security-sensitive work, see the crypto/rand package.</source>
          <target state="translated">Информацию о случайных числах,подходящих для работы,связанной с безопасностью,см.в пакете криптографических материалов/маркировки.</target>
        </trans-unit>
        <trans-unit id="8dac1d0bb1e2323543dc0dee447715c7804fe438" translate="yes" xml:space="preserve">
          <source>For scanning into *bool, the source may be true, false, 1, 0, or string inputs parseable by strconv.ParseBool.</source>
          <target state="translated">Для сканирования в *bool,источник может быть true,false,1,0,или строковые входы,разобранные strconv.ParseBool.</target>
        </trans-unit>
        <trans-unit id="22a8f63617a1059c9b07e1b34be114b05733ec0f" translate="yes" xml:space="preserve">
          <source>For simpler multi-way equality tests, eq (only) accepts two or more arguments and compares the second and subsequent to the first, returning in effect</source>
          <target state="translated">Для более простых многополосных тестов равенства,eq (только)принимает два или более аргументов и сравнивает второй и последующий за первым,возвращаясь в силу</target>
        </trans-unit>
        <trans-unit id="b0a480a0eda63e237a87664c806578f92d694410" translate="yes" xml:space="preserve">
          <source>For simplicity in setup, the connection is defined to understand these types a priori, as well as the basic gob types int, uint, etc. Their ids are:</source>
          <target state="translated">Для простоты настройки,соединение определяется для того,чтобы априори понимать эти типы,а также основные типы gob int,uint и др.Их идентификаторы:</target>
        </trans-unit>
        <trans-unit id="2a1206bb6c7f79687004103bffb38cbee66ebc60" translate="yes" xml:space="preserve">
          <source>For some arguments, such as a simple array expression, the result can be a constant. See the Go language specification's &quot;Length and capacity&quot; section for details.</source>
          <target state="translated">Для некоторых аргументов,например,для простого выражения массива,результатом может быть константа.Подробности см.в спецификации языка Go в разделе &quot;Длина и емкость&quot;.</target>
        </trans-unit>
        <trans-unit id="b73ee93bdb118cfdcf76b1431924d083213a9b9c" translate="yes" xml:space="preserve">
          <source>For some arguments, such as a string literal or a simple array expression, the result can be a constant. See the Go language specification's &quot;Length and capacity&quot; section for details.</source>
          <target state="translated">Для некоторых аргументов,таких как строковый литерал или простое выражение в массиве,результатом может быть константа.Подробности см.в спецификации языка Go в разделе &quot;Длина и ёмкость&quot;.</target>
        </trans-unit>
        <trans-unit id="6fd5303b38861cc1f75ea4005c27f0d0e4bc73ba" translate="yes" xml:space="preserve">
          <source>For strings, byte slices and byte arrays, however, precision limits the length of the input to be formatted (not the size of the output), truncating if necessary. Normally it is measured in runes, but for these types when formatted with the %x or %X format it is measured in bytes.</source>
          <target state="translated">Для строк,срезов байтов и массивов байтов,однако,точность ограничивает длину входного сигнала,который должен быть отформатирован (а не размер выходного сигнала),усекая его при необходимости.Обычно она измеряется в рунах,но для этих типов при форматировании в формате %x или %X она измеряется в байтах.</target>
        </trans-unit>
        <trans-unit id="751d670356e91a449ec7c80c4156cc58a03922ea" translate="yes" xml:space="preserve">
          <source>For such flags, the default value is just the initial value of the variable.</source>
          <target state="translated">Для таких флагов значением по умолчанию является только начальное значение переменной.</target>
        </trans-unit>
        <trans-unit id="fe319d30e4ff1d3bb9c9679e1d41b020cb9fc422" translate="yes" xml:space="preserve">
          <source>For testing: clients can set this flag to force creation of IPv6 sockets to return EAFNOSUPPORT.</source>
          <target state="translated">Для тестирования:клиенты могут установить этот флаг для принудительного создания IPv6 сокетов для возврата EAFNOSUPPORT.</target>
        </trans-unit>
        <trans-unit id="0d0e9615cbad5d104943c88a1e426bb41d0d3626" translate="yes" xml:space="preserve">
          <source>For the compiler to recognize this pattern, the conversion must appear in the argument list:</source>
          <target state="translated">Чтобы компилятор распознал этот шаблон,преобразование должно появиться в списке аргументов:</target>
        </trans-unit>
        <trans-unit id="13732a80c7c6067fbd8ddcc6a6ec2963b831f009" translate="yes" xml:space="preserve">
          <source>For the most part, LineTable's methods should be treated as an internal detail of the package; callers should use the methods on Table instead.</source>
          <target state="translated">По большей части методы LineTable следует рассматривать как внутреннюю деталь пакета;вместо них вызывающие абоненты должны использовать методы Table.</target>
        </trans-unit>
        <trans-unit id="82aa2e5faa1102c849b424650d24e3f7def76f8e" translate="yes" xml:space="preserve">
          <source>For the most part, this package follows the syntax as specified by RFC 5322 and extended by RFC 6532. Notable divergences:</source>
          <target state="translated">По большей части этот пакет следует синтаксису,указанному в RFC 5322 и расширенному в RFC 6532.Заметные расхождения:</target>
        </trans-unit>
        <trans-unit id="9dbc53494237ff152fc67f06045073fe509d54b4" translate="yes" xml:space="preserve">
          <source>For the power-of-two exponent formats, the mantissa is printed in normalized form:</source>
          <target state="translated">Для формата &quot;Power-of-two exponent&quot; мантисса печатается в нормализованном виде:</target>
        </trans-unit>
        <trans-unit id="f64016515259f77234a6cb253ce7855821350f37" translate="yes" xml:space="preserve">
          <source>For the synchronous signals and SIGPIPE, the Go runtime will install a signal handler. It will save any existing signal handler. If a synchronous signal arrives while executing non-Go code, the Go runtime will invoke the existing signal handler instead of the Go signal handler.</source>
          <target state="translated">Для синхронных сигналов и SIGPIPE во время выполнения Go устанавливается обработчик сигналов.Он сохранит любой существующий обработчик сигналов.Если синхронный сигнал поступает во время выполнения не-Go кода,время выполнения Go будет вызывать существующий обработчик сигналов вместо обработчика Go сигнала.</target>
        </trans-unit>
        <trans-unit id="cee851057097c0db5b5b8a9c0d45d60cedf064a6" translate="yes" xml:space="preserve">
          <source>For these internal escaping functions, if an action pipeline evaluates to a nil interface value, it is treated as though it were an empty string.</source>
          <target state="translated">Для этих внутренних экранирующих функций,если конвейер действий оценивает значение нулевого интерфейса,он рассматривается как пустая строка.</target>
        </trans-unit>
        <trans-unit id="94cdbab58de221c0845a1f0bccdc6ab6b9dfee7c" translate="yes" xml:space="preserve">
          <source>For this trimming, the definition of white space characters is the same as in Go: space, horizontal tab, carriage return, and newline.</source>
          <target state="translated">Для этой обрезки определение пробельных символов белого цвета такое же,как и в Go:пробел,горизонтальная закладка,возврат каретки и новая строка.</target>
        </trans-unit>
        <trans-unit id="c4dda3b24b75ceb8fb66edf8e6d50d204c1750ea" translate="yes" xml:space="preserve">
          <source>For unrecognized or vendor-defined attributes, Class may be ClassUnknown.</source>
          <target state="translated">Для нераспознанных атрибутов или атрибутов,определяемых производителем,Class может быть ClassUnknown.</target>
        </trans-unit>
        <trans-unit id="a2c58c0bacd7ac1887ab982a2597ef55f18dc028" translate="yes" xml:space="preserve">
          <source>For usage examples, see the wiki page at &lt;a href=&quot;https://golang.org/s/sqlwiki&quot;&gt;https://golang.org/s/sqlwiki&lt;/a&gt;.</source>
          <target state="translated">Примеры использования см. На вики-странице &lt;a href=&quot;https://golang.org/s/sqlwiki&quot;&gt;https://golang.org/s/sqlwiki&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="988918abc4e75847a40cae9d31b2ff0b26774a56" translate="yes" xml:space="preserve">
          <source>ForCompiler returns an Importer for importing from installed packages for the compilers &quot;gc&quot; and &quot;gccgo&quot;, or for importing directly from the source if the compiler argument is &quot;source&quot;. In this latter case, importing may fail under circumstances where the exported API is not entirely defined in pure Go source code (if the package API depends on cgo-defined entities, the type checker won't have access to those).</source>
          <target state="translated">ForCompiler возвращает Importer для импорта из установленных пакетов для компиляторов &quot;gc&quot; и &quot;gccgo&quot;,или для импорта непосредственно из исходных текстов,если аргумент компилятора является &quot;исходным&quot;.В последнем случае импорт может завершиться неудачей в условиях,когда экспортированный API не полностью определен в чистом исходном коде Go (если API пакета зависит от cgo-определенных сущностей,то проверка типа не будет иметь к ним доступа).</target>
        </trans-unit>
        <trans-unit id="133285841cd925c282a101cb331b225c1c71812e" translate="yes" xml:space="preserve">
          <source>ForLabels invokes f with each label set on the context. The function f should return true to continue iteration or false to stop iteration early.</source>
          <target state="translated">ForLabels вызывает f с каждым набором меток в контексте.Функция f должна возвращать true для продолжения итерации или false для ее досрочного прекращения.</target>
        </trans-unit>
        <trans-unit id="353aeb4085eb053c5afffba4c97380c4860aca38" translate="yes" xml:space="preserve">
          <source>Form is a parsed multipart form. Its File parts are stored either in memory or on disk, and are accessible via the *FileHeader's Open method. Its Value parts are stored as strings. Both are keyed by field name.</source>
          <target state="translated">Форма-это разобранная многочастная форма.Ее Файловые части хранятся либо в памяти,либо на диске,и доступны через метод *FileHeader's Open.Ее части Value хранятся в виде строк.Обе части имеют ключ по имени поля.</target>
        </trans-unit>
        <trans-unit id="eccde56e16564dc7c7df2c5cc1796440a15f9401" translate="yes" xml:space="preserve">
          <source>FormDataContentType returns the Content-Type for an HTTP multipart/form-data with this Writer's Boundary.</source>
          <target state="translated">FormDataContentType возвращает тип Content-Type для данных HTTP,состоящих из нескольких частей/форм,с этой Границей Писателя.</target>
        </trans-unit>
        <trans-unit id="a49e5a35587aa21155c47ca684122af3589d1687" translate="yes" xml:space="preserve">
          <source>FormFile returns the first file for the provided form key. FormFile calls ParseMultipartForm and ParseForm if necessary.</source>
          <target state="translated">FormFile возвращает первый файл для предоставленного ключа формы.При необходимости FormFile вызывает ParseMultipartForm и ParseForm.</target>
        </trans-unit>
        <trans-unit id="5d5c015330e69759a40946c508bd098ecc8416e4" translate="yes" xml:space="preserve">
          <source>FormName returns the name parameter if p has a Content-Disposition of type &quot;form-data&quot;. Otherwise it returns the empty string.</source>
          <target state="translated">FormName возвращает параметр имени,если p имеет Content-Disposition типа &quot;форма-данные&quot;.В противном случае возвращается пустая строка.</target>
        </trans-unit>
        <trans-unit id="445b64c2c00e9bf0c6abebdbd962d04b7f9f105c" translate="yes" xml:space="preserve">
          <source>FormValue returns the first value for the named component of the query. POST and PUT body parameters take precedence over URL query string values. FormValue calls ParseMultipartForm and ParseForm if necessary and ignores any errors returned by these functions. If key is not present, FormValue returns the empty string. To access multiple values of the same key, call ParseForm and then inspect Request.Form directly.</source>
          <target state="translated">FormValue возвращает первое значение для именованного компонента запроса.Параметры POST и PUT тела имеют приоритет над значениями строки запроса URL.FormValue вызывает ParseMultipartForm и ParseForm при необходимости и игнорирует любые ошибки,возвращаемые этими функциями.Если ключ отсутствует,FormValue возвращает пустую строку.Чтобы получить доступ к нескольким значениям одного и того же ключа,вызовите ParseForm,а затем непосредственно посмотрите на Request.Form.</target>
        </trans-unit>
        <trans-unit id="b90d813e4920205a13e7a3e3ea46b1033f09615e" translate="yes" xml:space="preserve">
          <source>Format errors:</source>
          <target state="translated">Ошибки формата:</target>
        </trans-unit>
        <trans-unit id="bd81fbee8cc623aef03682c00bd263e80dddfcaa" translate="yes" xml:space="preserve">
          <source>Format implements fmt.Formatter. It accepts all the regular formats for floating-point numbers ('b', 'e', 'E', 'f', 'F', 'g', 'G', 'x') as well as 'p' and 'v'. See (*Float).Text for the interpretation of 'p'. The 'v' format is handled like 'g'. Format also supports specification of the minimum precision in digits, the output field width, as well as the format flags '+' and ' ' for sign control, '0' for space or zero padding, and '-' for left or right justification. See the fmt package for details.</source>
          <target state="translated">Формат реализует fmt.Formatter.Он принимает все обычные форматы чисел с плавающей точкой ('b','e','E','f','F','g','G','x'),а также 'p' и 'v'.Смотрите (*Float).Текст для интерпретации 'p'.Формат 'v' обрабатывается как 'g'.Формат также поддерживает спецификацию минимальной точности в цифрах,ширину поля вывода,а также флаги формата '+' и ' ' для управления знаком,'0' для пробела или нулевой подкладки,и '-' для обоснования слева или справа.Подробности см.в пакете fmt.</target>
        </trans-unit>
        <trans-unit id="ddca00e8215628107f30d61b04b8094c67090fc1" translate="yes" xml:space="preserve">
          <source>Format implements fmt.Formatter. It accepts the formats 'b' (binary), 'o' (octal with 0 prefix), 'O' (octal with 0o prefix), 'd' (decimal), 'x' (lowercase hexadecimal), and 'X' (uppercase hexadecimal). Also supported are the full suite of package fmt's format flags for integral types, including '+' and ' ' for sign control, '#' for leading zero in octal and for hexadecimal, a leading &quot;0x&quot; or &quot;0X&quot; for &quot;%#x&quot; and &quot;%#X&quot; respectively, specification of minimum digits precision, output field width, space or zero padding, and '-' for left or right justification.</source>
          <target state="translated">Формат реализует fmt.Formatter.Он принимает форматы 'b' (двоичный),'o' (восьмеричный с префиксом 0),'O' (восьмеричный с префиксом 0o),'d' (десятичный),'x' (строчный шестнадцатеричный)и 'X' (прописной шестнадцатеричный).Также поддерживается полный набор флагов формата пакета fmt для интегральных типов,включая '+' и ' ' для управления знаком,'#' для ведущего нуля в восьмеричном и шестнадцатеричном числах,ведущего &quot;0x&quot; или &quot;0X&quot; для &quot;%#x&quot; и &quot;%#X&quot; соответственно,указание минимальной точности цифр,ширины поля вывода,пробела или нулевой подкладки,и '-' для обоснования слева или справа.</target>
        </trans-unit>
        <trans-unit id="81a5476108fadb465e67c178e260599d04ddc2e8" translate="yes" xml:space="preserve">
          <source>Format represents the tar archive format.</source>
          <target state="translated">Формат представляет собой формат архива tar.</target>
        </trans-unit>
        <trans-unit id="8d4885fbdac6d0d14accf79b985b4ce78e6bdd62" translate="yes" xml:space="preserve">
          <source>Format returns a textual representation of the time value formatted according to layout, which defines the format by showing how the reference time, defined to be</source>
          <target state="translated">Формат возвращает текстовое представление значения времени,отформатированного в соответствии с макетированием,которое определяет формат,показывая,каким должно быть опорное время.</target>
        </trans-unit>
        <trans-unit id="b3ee515426820c27b536513d4c839dfeda89b51d" translate="yes" xml:space="preserve">
          <source>FormatBool</source>
          <target state="translated">FormatBool</target>
        </trans-unit>
        <trans-unit id="1b75ed131650db00babc41765f3ab4d40a495482" translate="yes" xml:space="preserve">
          <source>FormatBool returns &quot;true&quot; or &quot;false&quot; according to the value of b.</source>
          <target state="translated">FormatBool возвращает &quot;true&quot; или &quot;false&quot; в соответствии со значением b.</target>
        </trans-unit>
        <trans-unit id="6afd52cbbbdc2288edb941b965e52c2fc0f3f529" translate="yes" xml:space="preserve">
          <source>FormatBool, FormatFloat, FormatInt, and FormatUint convert values to strings:</source>
          <target state="translated">FormatBool,FormatFloat,FormatInt и FormatUint преобразовывают значения в строки:</target>
        </trans-unit>
        <trans-unit id="7cde6838cd6d9db48f444c3319801df0ed449cfb" translate="yes" xml:space="preserve">
          <source>FormatComplex converts the complex number c to a string of the form (a+bi) where a and b are the real and imaginary parts, formatted according to the format fmt and precision prec.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf02981ef6c41fa3e9a421259a94865e8c2df157" translate="yes" xml:space="preserve">
          <source>FormatError is returned by some operations if the data does not have the correct format for an object file.</source>
          <target state="translated">FormatError возвращается некоторыми операциями,если данные не имеют правильного формата для объектного файла.</target>
        </trans-unit>
        <trans-unit id="9be4c97132e0f61e257dba73681e0455cf421f26" translate="yes" xml:space="preserve">
          <source>FormatError is unused. The type is retained for compatibility.</source>
          <target state="translated">FormatError не используется.Тип сохраняется для совместимости.</target>
        </trans-unit>
        <trans-unit id="66155c8335bf85f47e7201829386a88e599875d5" translate="yes" xml:space="preserve">
          <source>FormatFloat</source>
          <target state="translated">FormatFloat</target>
        </trans-unit>
        <trans-unit id="8ab806a123a3e3bc36a09fdd9698930a4aafbfb9" translate="yes" xml:space="preserve">
          <source>FormatFloat converts the floating-point number f to a string, according to the format fmt and precision prec. It rounds the result assuming that the original was obtained from a floating-point value of bitSize bits (32 for float32, 64 for float64).</source>
          <target state="translated">FormatFloat преобразует число с плавающей точкой f в строку,в соответствии с форматом fmt и точностью prec.Округляет результат,предполагая,что оригинал был получен из значения битов bitSize с плавающей точкой (32 для float32,64 для float64).</target>
        </trans-unit>
        <trans-unit id="54acac612d12c84fbb587187170a9d2f5002e9e1" translate="yes" xml:space="preserve">
          <source>FormatInt</source>
          <target state="translated">FormatInt</target>
        </trans-unit>
        <trans-unit id="ac942d8c471010cc2511b6465b29a4a4eaf7e487" translate="yes" xml:space="preserve">
          <source>FormatInt returns the string representation of i in the given base, for 2 &amp;lt;= base &amp;lt;= 36. The result uses the lower-case letters 'a' to 'z' for digit values &amp;gt;= 10.</source>
          <target state="translated">FormatInt возвращает строковое представление i в данной базе для 2 &amp;lt;= base &amp;lt;= 36. В результате используются строчные буквы от &amp;laquo;a&amp;raquo; до &amp;laquo;z&amp;raquo; для цифровых значений&amp;gt; = 10.</target>
        </trans-unit>
        <trans-unit id="7d726d8b9675ed9de10e3a267d41a3004b409192" translate="yes" xml:space="preserve">
          <source>FormatMediaType</source>
          <target state="translated">FormatMediaType</target>
        </trans-unit>
        <trans-unit id="7ffe85b478b1a8a795e300c5a2b13589a4aacd1b" translate="yes" xml:space="preserve">
          <source>FormatMediaType serializes mediatype t and the parameters param as a media type conforming to RFC 2045 and RFC 2616. The type and parameter names are written in lower-case. When any of the arguments result in a standard violation then FormatMediaType returns the empty string.</source>
          <target state="translated">FormatMediaType сериализует медиатип t и параметр параметра как тип носителя,соответствующий RFC 2045 и RFC 2616.Имена типов и параметров записываются в нижнем регистре.Когда любой из аргументов приводит к стандартному нарушению,FormatMediaType возвращает пустую строку.</target>
        </trans-unit>
        <trans-unit id="457b9a9d61506e909562e056e83daf32584b6e03" translate="yes" xml:space="preserve">
          <source>FormatUint</source>
          <target state="translated">FormatUint</target>
        </trans-unit>
        <trans-unit id="29e428f2dcc8699c0417730387a64fac7ddd1961" translate="yes" xml:space="preserve">
          <source>FormatUint returns the string representation of i in the given base, for 2 &amp;lt;= base &amp;lt;= 36. The result uses the lower-case letters 'a' to 'z' for digit values &amp;gt;= 10.</source>
          <target state="translated">FormatUint возвращает строковое представление i в данной базе для 2 &amp;lt;= base &amp;lt;= 36. В результате используются строчные буквы от &amp;laquo;a&amp;raquo; до &amp;laquo;z&amp;raquo; для цифровых значений&amp;gt; = 10.</target>
        </trans-unit>
        <trans-unit id="5c8097315c949db11f3c54f81dd03fc38d2dca5c" translate="yes" xml:space="preserve">
          <source>Formatter is implemented by any value that has a Format method. The implementation controls how State and rune are interpreted, and may call Sprint(f) or Fprint(f) etc. to generate its output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74de65e787a3b1e89f96cc3e3b260c1d5a19f78c" translate="yes" xml:space="preserve">
          <source>Formatter is the interface implemented by values with a custom formatter. The implementation of Format may call Sprint(f) or Fprint(f) etc. to generate its output.</source>
          <target state="translated">Форматтер-это интерфейс,реализованный значениями с помощью специального формата.Реализация Format может вызывать Sprint(f)или Fprint(f)и т.д.для генерации его вывода.</target>
        </trans-unit>
        <trans-unit id="d3a818c703590da441ab8fb9d8bac8b6144c0764" translate="yes" xml:space="preserve">
          <source>Formatting can be controlled with these flags.</source>
          <target state="translated">Форматирование можно контролировать с помощью этих флагов.</target>
        </trans-unit>
        <trans-unit id="75a6bd1d5df471e18e5ef09488e671afbb943a27" translate="yes" xml:space="preserve">
          <source>Fprint</source>
          <target state="translated">Fprint</target>
        </trans-unit>
        <trans-unit id="8c8522f1e4d59e7911ef9e37ddbccae99dbf77c6" translate="yes" xml:space="preserve">
          <source>Fprint &quot;pretty-prints&quot; an AST node to output for a given configuration cfg. Position information is interpreted relative to the file set fset. The node type must be *ast.File, *CommentedNode, []ast.Decl, []ast.Stmt, or assignment-compatible to ast.Expr, ast.Decl, ast.Spec, or ast.Stmt.</source>
          <target state="translated">Распечатайте &quot;красивые отпечатки&quot; узла AST для вывода для заданной конфигурации cfg.Информация о положении интерпретируется относительно набора файлов fset.Тип узла должен быть *ast.File,*CommentedNode,[]ast.Decl,[]ast.Stmt,или соответствовать назначению ast.Expr,ast.Decl,ast.Spec,или ast.Stmt.</target>
        </trans-unit>
        <trans-unit id="f8a539386d013173d33a590058d75eefbdb15fa6" translate="yes" xml:space="preserve">
          <source>Fprint &quot;pretty-prints&quot; an AST node to output. It calls Config.Fprint with default settings. Note that gofmt uses tabs for indentation but spaces for alignment; use format.Node (package go/format) for output that matches gofmt.</source>
          <target state="translated">Напечатайте &quot;красивые отпечатки&quot; узла AST для вывода.Он называет Config.Fprint с настройками по умолчанию.Обратите внимание,что gofmt использует табуляции для отступов,но пробелы для выравнивания;используйте format.Node (пакет go/format)для вывода,который соответствует gofmt.</target>
        </trans-unit>
        <trans-unit id="104c28c9f2550f07e8ce3bfa8162280f3f8c80ca" translate="yes" xml:space="preserve">
          <source>Fprint formats using the default formats for its operands and writes to w. Spaces are added between operands when neither is a string. It returns the number of bytes written and any write error encountered.</source>
          <target state="translated">Форматы печати,использующие форматы по умолчанию для своих операндов,и записывает в w.Пробелы добавляются между операндами,когда ни один из них не является строкой.Возвращается количество записанных байтов и любая ошибка при записи.</target>
        </trans-unit>
        <trans-unit id="6a536bd9e7bf91ae60cda20d0ea5db515bbd6c7b" translate="yes" xml:space="preserve">
          <source>Fprint prints the (sub-)tree starting at AST node x to w. If fset != nil, position information is interpreted relative to that file set. Otherwise positions are printed as integer values (file set specific offsets).</source>
          <target state="translated">Распечатка выводит (под)дерево,начинающееся в узле AST x-w.Если fset !=nil,то информация о положении интерпретируется относительно этого набора файлов.В противном случае позиции печатаются в виде целочисленных значений (смещения,определенные в наборе файлов).</target>
        </trans-unit>
        <trans-unit id="d20e1fe41e4983b3d1227303d39b1a75b7115f30" translate="yes" xml:space="preserve">
          <source>Fprintf</source>
          <target state="translated">Fprintf</target>
        </trans-unit>
        <trans-unit id="a13c0d787117a7941cdce4981a12d040db7f0953" translate="yes" xml:space="preserve">
          <source>Fprintf formats according to a format specifier and writes to w. It returns the number of bytes written and any write error encountered.</source>
          <target state="translated">Fprintf форматы в соответствии со спецификатором формата и записывает в w.Он возвращает количество записанных байтов и любую ошибку при записи.</target>
        </trans-unit>
        <trans-unit id="46197102442051b0256d5e8d44d3fa71b3e0ca3a" translate="yes" xml:space="preserve">
          <source>Fprintln</source>
          <target state="translated">Fprintln</target>
        </trans-unit>
        <trans-unit id="b390d66055f3fb09a9893ca4c02d4466e93e9f7e" translate="yes" xml:space="preserve">
          <source>Fprintln formats using the default formats for its operands and writes to w. Spaces are always added between operands and a newline is appended. It returns the number of bytes written and any write error encountered.</source>
          <target state="translated">Fprintln использует форматы по умолчанию для своих операндов и записывает в w.Пробелы всегда добавляются между операндами и добавляется новая строка.Она возвращает количество записанных байтов и любую ошибку при записи.</target>
        </trans-unit>
        <trans-unit id="c52284236b3cbc2d437f96673b062717eea95c7a" translate="yes" xml:space="preserve">
          <source>Frame is the information returned by Frames for each call frame.</source>
          <target state="translated">Фрейм-это информация,возвращаемая фреймами для каждого фрейма вызова.</target>
        </trans-unit>
        <trans-unit id="e3e7a3833d19706ebf33b2c3baf8e05deeed7bca" translate="yes" xml:space="preserve">
          <source>Frames</source>
          <target state="translated">Frames</target>
        </trans-unit>
        <trans-unit id="6a32e149e9d6773e4f6967f48bf708bb90588f99" translate="yes" xml:space="preserve">
          <source>Frames may be used to get function/file/line information for a slice of PC values returned by Callers.</source>
          <target state="translated">Кадры могут использоваться для получения информации о функции/файле/линии для части значений ПК,возвращаемых вызывающими абонентами.</target>
        </trans-unit>
        <trans-unit id="971e42ae8bcc68c1d3c0b0b0f45fd394dc7d0afe" translate="yes" xml:space="preserve">
          <source>FreeOSMemory forces a garbage collection followed by an attempt to return as much memory to the operating system as possible. (Even if this is not called, the runtime gradually returns memory to the operating system in a background task.)</source>
          <target state="translated">FreeOSMemory заставляет собирать мусор,а затем пытается вернуть операционной системе как можно больше памяти.(Даже если это не вызывается,время выполнения постепенно возвращает память операционной системе в фоновом режиме).</target>
        </trans-unit>
        <trans-unit id="2d6c189d92419208a8893cd5a97e05687d681927" translate="yes" xml:space="preserve">
          <source>Frexp breaks f into a normalized fraction and an integral power of two. It returns frac and exp satisfying f == frac &amp;times; 2**exp, with the absolute value of frac in the interval [&amp;frac12;, 1).</source>
          <target state="translated">Frexp разбивает f на нормализованную дробь и целую степень двойки. Он возвращает frac и exp, удовлетворяющие f == frac &amp;times; 2 ** exp, с абсолютным значением frac в интервале [&amp;frac12;, 1).</target>
        </trans-unit>
        <trans-unit id="fa23c274e14dd5cc1e7fa9a8a9b29bf34200b44f" translate="yes" xml:space="preserve">
          <source>FromSlash returns the result of replacing each slash ('/') character in path with a separator character. Multiple slashes are replaced by multiple separators.</source>
          <target state="translated">FromSlash возвращает результат замены каждого символа слеша ('/')в пути на символ разделителя.Несколько косых черт заменяются на несколько разделителей.</target>
        </trans-unit>
        <trans-unit id="164e0e9caa51bad7048b8f096c49d9b2c2ab5e89" translate="yes" xml:space="preserve">
          <source>Front returns the first element of list l or nil if the list is empty.</source>
          <target state="translated">Фронт возвращает первый элемент списка l или nil,если список пуст.</target>
        </trans-unit>
        <trans-unit id="52c1852fe9f31cf9deb2025a2022f1fc079a5aee" translate="yes" xml:space="preserve">
          <source>Fscan scans text read from r, storing successive space-separated values into successive arguments. Newlines count as space. It returns the number of items successfully scanned. If that is less than the number of arguments, err will report why.</source>
          <target state="translated">Fscan сканирует текст,считанный из r,сохраняя последовательные значения,разделенные пробелами,в последовательных аргументах.Новые строки считаются пробелами.Возвращает количество успешно отсканированных элементов.Если это меньше,чем количество аргументов,то err сообщит почему.</target>
        </trans-unit>
        <trans-unit id="554810832552956da9a7da2eee0a73593dca23e7" translate="yes" xml:space="preserve">
          <source>Fscanf</source>
          <target state="translated">Fscanf</target>
        </trans-unit>
        <trans-unit id="8bd3b6e023a616305dbe6b056ba1a191e7adb603" translate="yes" xml:space="preserve">
          <source>Fscanf scans text read from r, storing successive space-separated values into successive arguments as determined by the format. It returns the number of items successfully parsed. Newlines in the input must match newlines in the format.</source>
          <target state="translated">Fscanf сканирует текст,считанный из r,сохраняя последовательные значения,разделенные пробелами,в последовательных аргументах,определяемых форматом.Возвращает количество успешно разобранных элементов.Новые строки во входном тексте должны совпадать с новыми строками в формате.</target>
        </trans-unit>
        <trans-unit id="24ce0d47eda270ec1be1d5faf6933fc84f496fc9" translate="yes" xml:space="preserve">
          <source>Fscanln</source>
          <target state="translated">Fscanln</target>
        </trans-unit>
        <trans-unit id="6ba607f7da03e13291dee0bc0511128cd6a13033" translate="yes" xml:space="preserve">
          <source>Fscanln is similar to Fscan, but stops scanning at a newline and after the final item there must be a newline or EOF.</source>
          <target state="translated">Fscanln похож на Fscan,но останавливает сканирование на новой строке и после конечного пункта должна быть новая строка или EOF.</target>
        </trans-unit>
        <trans-unit id="18339496bb65d9199e22c7756d8d353de7e08bb1" translate="yes" xml:space="preserve">
          <source>FullName finds real name of symbol sym. Normally name is stored in sym.Name, but if it is longer then 8 characters, it is stored in COFF string table st instead.</source>
          <target state="translated">FullName находит настоящее имя символа sym.Обычно имя хранится в sym.Name,но если оно длиннее 8 символов,то оно хранится в строковой таблице COFF string table st.</target>
        </trans-unit>
        <trans-unit id="7902524eb980d3f158a430d41566b78e54c0f4a8" translate="yes" xml:space="preserve">
          <source>FullName returns the package- or receiver-type-qualified name of function or method obj.</source>
          <target state="translated">FullName возвращает имя функции или объекта метода,удовлетворяющего требованиям типа пакета или приемника.</target>
        </trans-unit>
        <trans-unit id="b3483c701e937232d5e060b21f7fb965b230aa71" translate="yes" xml:space="preserve">
          <source>FullRune</source>
          <target state="translated">FullRune</target>
        </trans-unit>
        <trans-unit id="81aa0878662ea86cc86d82ed1ab7992029d672d9" translate="yes" xml:space="preserve">
          <source>FullRune reports whether the bytes in p begin with a full UTF-8 encoding of a rune. An invalid encoding is considered a full Rune since it will convert as a width-1 error rune.</source>
          <target state="translated">FullRune сообщает,начинаются ли байты в p с полной кодировки руны в UTF-8.Некорректная кодировка считается полной руной,так как она будет преобразована как руна с ошибкой width-1.</target>
        </trans-unit>
        <trans-unit id="e05115514df90c085c4af490f89158b561b0d92c" translate="yes" xml:space="preserve">
          <source>FullRuneInString</source>
          <target state="translated">FullRuneInString</target>
        </trans-unit>
        <trans-unit id="95812f07b4917317402c5d2167338a188da0ce79" translate="yes" xml:space="preserve">
          <source>FullRuneInString is like FullRune but its input is a string.</source>
          <target state="translated">FullRuneInString похож на FullRune,но его вход-строка.</target>
        </trans-unit>
        <trans-unit id="d14c246c1269ccb4359c67583949d6908348f108" translate="yes" xml:space="preserve">
          <source>Func</source>
          <target state="translated">Func</target>
        </trans-unit>
        <trans-unit id="6f03ac155657e14e643cdb5dc79319887df7f634" translate="yes" xml:space="preserve">
          <source>Func defines a flag with the specified name and usage string. Each time the flag is seen, fn is called with the value of the flag. If fn returns a non-nil error, it will be treated as a flag value parsing error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="279955fd7d680432dfab90fbe069c9bfd8dc8495" translate="yes" xml:space="preserve">
          <source>Func implements Var by calling the function and formatting the returned value using JSON.</source>
          <target state="translated">Функция реализует Var путем вызова функции и форматирования возвращаемого значения с помощью JSON.</target>
        </trans-unit>
        <trans-unit id="524a0d206f4cbf19e946f5d4ed3f42690d7a8676" translate="yes" xml:space="preserve">
          <source>Func is a wrapped Go function to be called by JavaScript.</source>
          <target state="translated">Функция представляет собой завернутую функцию Go,которая вызывается JavaScript.</target>
        </trans-unit>
        <trans-unit id="9f43fd9d5faa1fad98bda7488e8199738c579a5f" translate="yes" xml:space="preserve">
          <source>Func is the documentation for a func declaration.</source>
          <target state="translated">Функция-это документация для объявления функции.</target>
        </trans-unit>
        <trans-unit id="1428a5974ab9a5d9bb8050c81e92e9a085606a0b" translate="yes" xml:space="preserve">
          <source>Func values are deeply equal if both are nil; otherwise they are not deeply equal.</source>
          <target state="translated">Функциональные значения глубоко равны,если оба равны нулю;в противном случае они глубоко не равны.</target>
        </trans-unit>
        <trans-unit id="c6b073315fc317c2d847f10bda8f819f0b734264" translate="yes" xml:space="preserve">
          <source>Func.Release must be called to free up resources when the function will not be invoked any more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b4c67efe336d8800eb50760aa412d1cd7318a96" translate="yes" xml:space="preserve">
          <source>Func.Release must be called to free up resources when the function will not be used any more.</source>
          <target state="translated">Func.Release должен быть вызван,чтобы освободить ресурсы,когда функция больше не будет использоваться.</target>
        </trans-unit>
        <trans-unit id="79c0844aa92a7c85df75b63db88d3ac85acf1947" translate="yes" xml:space="preserve">
          <source>FuncForPC returns a *Func describing the function that contains the given program counter address, or else nil.</source>
          <target state="translated">FuncForPC возвращает *Func,описывающую функцию,которая содержит заданный адрес счетчика программы,или нулевой.</target>
        </trans-unit>
        <trans-unit id="2f873cfa96e723fb817cda8756e298acee836d4d" translate="yes" xml:space="preserve">
          <source>FuncMap is the type of the map defining the mapping from names to functions. Each function must have either a single return value, or two return values of which the second has type error. In that case, if the second (error) argument evaluates to non-nil during execution, execution terminates and Execute returns that error. FuncMap has the same base type as FuncMap in &quot;text/template&quot;, copied here so clients need not import &quot;text/template&quot;.</source>
          <target state="translated">FuncMap-это тип карты,определяющий отображение от названий к функциям.Каждая функция должна иметь либо одно возвращаемое значение,либо два возвращаемых значения,второе из которых имеет ошибку типа.В этом случае,если второй (ошибочный)аргумент во время выполнения вычисляется как ненулевой,выполнение завершается и Execute возвращает эту ошибку.FuncMap имеет тот же базовый тип,что и FuncMap в &quot;text/template&quot;,скопированный здесь,поэтому клиентам не нужно импортировать &quot;text/template&quot;.</target>
        </trans-unit>
        <trans-unit id="c663a8fdf1b0c07a4b3a9bf988b2301d91e56916" translate="yes" xml:space="preserve">
          <source>FuncMap is the type of the map defining the mapping from names to functions. Each function must have either a single return value, or two return values of which the second has type error. In that case, if the second (error) return value evaluates to non-nil during execution, execution terminates and Execute returns that error.</source>
          <target state="translated">FuncMap-это тип карты,определяющий отображение от названий к функциям.Каждая функция должна иметь либо одно возвращаемое значение,либо два возвращаемых значения,второе из которых имеет ошибку типа.В этом случае,если второе (ошибочное)возвращаемое значение во время выполнения вычисляется как ненулевое,выполнение завершается и Execute возвращает эту ошибку.</target>
        </trans-unit>
        <trans-unit id="e6a6e8cadfebe9c4799e999d069f9213bb24bed9" translate="yes" xml:space="preserve">
          <source>FuncOf</source>
          <target state="translated">FuncOf</target>
        </trans-unit>
        <trans-unit id="727153d867d797c3632d8920f9ed42e20c01b542" translate="yes" xml:space="preserve">
          <source>FuncOf returns a function to be used by JavaScript.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d863a41e98edea4d63050f4d41d85e38ee53432a" translate="yes" xml:space="preserve">
          <source>FuncOf returns a wrapped function.</source>
          <target state="translated">FuncOf возвращает завернутую функцию.</target>
        </trans-unit>
        <trans-unit id="93a168211e34460ad795ada01d7598344ab1ff0e" translate="yes" xml:space="preserve">
          <source>FuncOf returns the function type with the given argument and result types. For example if k represents int and e represents string, FuncOf([]Type{k}, []Type{e}, false) represents func(int) string.</source>
          <target state="translated">FuncOf возвращает тип функции с заданным аргументом и типом результата.Например,если k представляет int и e представляет string,то FuncOf([]Type{k},[]Type{e},false)представляет строку func(int).</target>
        </trans-unit>
        <trans-unit id="e545c5b7597389c332937a417c6dbb10d7b9c2b9" translate="yes" xml:space="preserve">
          <source>Funcs adds the elements of the argument map to the template's function map. It must be called before the template is parsed. It panics if a value in the map is not a function with appropriate return type or if the name cannot be used syntactically as a function in a template. It is legal to overwrite elements of the map. The return value is the template, so calls can be chained.</source>
          <target state="translated">Funcs добавляет элементы карты аргументов в карту функций шаблона.Он должен быть вызван перед разбором шаблона.Он паникует,если значение на карте не является функцией с соответствующим типом возврата или если имя не может синтаксически использоваться как функция в шаблоне.Перезаписывать элементы карты разрешено.Возвращаемое значение является шаблоном,поэтому вызовы могут быть цепочечными.</target>
        </trans-unit>
        <trans-unit id="d356e92562acfcaf97196969d96dd79e05dacf25" translate="yes" xml:space="preserve">
          <source>Funcs adds the elements of the argument map to the template's function map. It must be called before the template is parsed. It panics if a value in the map is not a function with appropriate return type. However, it is legal to overwrite elements of the map. The return value is the template, so calls can be chained.</source>
          <target state="translated">Funcs добавляет элементы карты аргументов в карту функций шаблона.Он должен быть вызван перед разбором шаблона.Он паникует,если значение на карте не является функцией с соответствующим типом возврата.Однако перезаписывать элементы карты легально.Возвращаемое значение является шаблоном,поэтому вызовы могут быть цепочечными.</target>
        </trans-unit>
        <trans-unit id="2b961dea1dc0c60ddf9a2c8e9d090f6f7d082483" translate="yes" xml:space="preserve">
          <source>Functions</source>
          <target state="translated">Functions</target>
        </trans-unit>
        <trans-unit id="8c10d9660a016948a806bd8cbcad3722d8e6bc88" translate="yes" xml:space="preserve">
          <source>Functions and channels will not be sent in a gob. Attempting to encode such a value at the top level will fail. A struct field of chan or func type is treated exactly like an unexported field and is ignored.</source>
          <target state="translated">Функции и каналы не будут отправляться в кубок.Попытка кодирования такого значения на верхнем уровне будет безуспешной.Поле структуры типа chan или func в точности соответствует неисследованному полю и игнорируется.</target>
        </trans-unit>
        <trans-unit id="515fb65b2b3a55f3a5ea9024aecd183d10145a5b" translate="yes" xml:space="preserve">
          <source>Functions of the form</source>
          <target state="translated">Функции формы</target>
        </trans-unit>
        <trans-unit id="5bde1b79ff9cf2a64313aa293a07d05136a9d65d" translate="yes" xml:space="preserve">
          <source>Functions starting with &quot;Is&quot; can be used to inspect which table of range a rune belongs to. Note that runes may fit into more than one range.</source>
          <target state="translated">Функции,начинающиеся с &quot;Is&quot;,могут быть использованы для проверки,к какой таблице диапазона принадлежит руна.Обратите внимание,что руны могут входить в более чем один диапазон.</target>
        </trans-unit>
        <trans-unit id="14038939956e123c4daa0060310ed80bf1b7a49d" translate="yes" xml:space="preserve">
          <source>GC runs a garbage collection and blocks the caller until the garbage collection is complete. It may also block the entire program.</source>
          <target state="translated">GC запускает сбор мусора и блокирует вызывающего абонента до тех пор,пока сбор мусора не будет завершен.Он также может заблокировать всю программу.</target>
        </trans-unit>
        <trans-unit id="c7f87699bcc973fce315d8d3ae36debdf341faa6" translate="yes" xml:space="preserve">
          <source>GCD sets z to the greatest common divisor of a and b and returns z. If x or y are not nil, GCD sets their value such that z = a*x + b*y.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1dacc63b01c8608c5a77320640ce147950f96e1" translate="yes" xml:space="preserve">
          <source>GCD sets z to the greatest common divisor of a and b, which both must be &amp;gt; 0, and returns z. If x or y are not nil, GCD sets their value such that z = a*x + b*y. If either a or b is &amp;lt;= 0, GCD sets z = x = y = 0.</source>
          <target state="translated">GCD устанавливает z равным наибольшему общему делителю a и b, которые оба должны быть&amp;gt; 0, и возвращает z. Если x или y не равны нулю, GCD устанавливает их значение таким образом, что z = a * x + b * y. Если либо a, либо b равно &amp;lt;= 0, НОД устанавливает z = x = y = 0.</target>
        </trans-unit>
        <trans-unit id="19dd357da96d7272320f7fadf3fd2965c024dba5" translate="yes" xml:space="preserve">
          <source>GCStats collect information about recent garbage collections.</source>
          <target state="translated">GCStats собирает информацию о последних сборах мусора.</target>
        </trans-unit>
        <trans-unit id="d010209a0c3d0dee637f5259dfa34515f68772df" translate="yes" xml:space="preserve">
          <source>GIF represents the possibly multiple images stored in a GIF file.</source>
          <target state="translated">GIF представляет собой возможное множество изображений,сохраненных в GIF-файле.</target>
        </trans-unit>
        <trans-unit id="f62024646db1c94f452ef8c25337fad08f62d18e" translate="yes" xml:space="preserve">
          <source>GOARCH is the running program's architecture target: one of 386, amd64, arm, s390x, and so on.</source>
          <target state="translated">GOARCH-цель архитектуры запускаемой программы:одна из 386,amd64,arm,s390x и так далее.</target>
        </trans-unit>
        <trans-unit id="cb34b31ce447e79881d19460e35c7075fc05a81a" translate="yes" xml:space="preserve">
          <source>GOMAXPROCS sets the maximum number of CPUs that can be executing simultaneously and returns the previous setting. If n &amp;lt; 1, it does not change the current setting. The number of logical CPUs on the local machine can be queried with NumCPU. This call will go away when the scheduler improves.</source>
          <target state="translated">GOMAXPROCS устанавливает максимальное количество процессоров, которые могут работать одновременно, и возвращает предыдущую настройку. Если n &amp;lt;1, текущая настройка не меняется. Число логических процессоров на локальном компьютере можно запросить с помощью NumCPU. Этот вызов исчезнет, ​​когда планировщик улучшится.</target>
        </trans-unit>
        <trans-unit id="e0edbc08b54ba2717d6e63675d087628cd37bc2a" translate="yes" xml:space="preserve">
          <source>GOMAXPROCS sets the maximum number of CPUs that can be executing simultaneously and returns the previous setting. It defaults to the value of runtime.NumCPU. If n &amp;lt; 1, it does not change the current setting. This call will go away when the scheduler improves.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad65293e987b4a4c08430d0e000aecbc1854ac24" translate="yes" xml:space="preserve">
          <source>GOOS is the running program's operating system target: one of darwin, freebsd, linux, and so on. To view possible combinations of GOOS and GOARCH, run &quot;go tool dist list&quot;.</source>
          <target state="translated">ГСНО-это операционная система,на которую ориентирована программа:дарвин,фрибсд,линукс и так далее.Для просмотра возможных комбинаций GOOS и GOARCH запустите &quot;go tool dist list&quot;.</target>
        </trans-unit>
        <trans-unit id="7bb230fcc10199af1bb88085306db7998e9674cd" translate="yes" xml:space="preserve">
          <source>GOROOT returns the root of the Go tree. It uses the GOROOT environment variable, if set at process start, or else the root used during the Go build.</source>
          <target state="translated">GOROOT возвращает корень дерева Go.Он использует переменную окружения GOROOT,если она установлена при запуске процесса,или корень,используемый при сборке Go.</target>
        </trans-unit>
        <trans-unit id="3552a70e477a364f8e82a292dad18f46a2ad988b" translate="yes" xml:space="preserve">
          <source>Gamma returns the Gamma function of x.</source>
          <target state="translated">Гамма возвращает гамма-функцию x.</target>
        </trans-unit>
        <trans-unit id="a2672eb4dac0440844556fb66fa39b9edb2d2041" translate="yes" xml:space="preserve">
          <source>General:</source>
          <target state="translated">General:</target>
        </trans-unit>
        <trans-unit id="453efae49cba4a01a09c987414ab329ee6c4a305" translate="yes" xml:space="preserve">
          <source>Generally Get, Post, or PostForm will be used instead of Do.</source>
          <target state="translated">Обычно вместо Do будет использоваться Get,Post или PostForm.</target>
        </trans-unit>
        <trans-unit id="1c57b54aace051c9a60fd146f5087c013aa2d721" translate="yes" xml:space="preserve">
          <source>GenerateKey generates a public and private key pair.</source>
          <target state="translated">GenerateKey генерирует пару публичных и частных ключей.</target>
        </trans-unit>
        <trans-unit id="db1ff76045ebe9cc510f3c31601ddcbcd7fd57de" translate="yes" xml:space="preserve">
          <source>GenerateKey generates a public&amp;amp;private key pair. The Parameters of the PrivateKey must already be valid (see GenerateParameters).</source>
          <target state="translated">GenerateKey генерирует пару открытого и закрытого ключей. Параметры PrivateKey уже должны быть действительными (см. GenerateParameters).</target>
        </trans-unit>
        <trans-unit id="e650907b55be64a19300b70e59344d22b7245e9b" translate="yes" xml:space="preserve">
          <source>GenerateKey generates a public/private key pair using entropy from rand. If rand is nil, crypto/rand.Reader will be used.</source>
          <target state="translated">GenerateKey генерирует пару публичного/частного ключа,используя энтропию из rand.Если rand равен нулю,то будет использоваться crypto/rand.Reader.</target>
        </trans-unit>
        <trans-unit id="7f11f0f6942fab0ca9f944e5798d7d37395d774c" translate="yes" xml:space="preserve">
          <source>GenerateKey generates an RSA keypair of the given bit size using the random source random (for example, crypto/rand.Reader).</source>
          <target state="translated">GenerateKey генерирует пару ключей RSA заданного размера,используя случайный источник (например,crypto/rand.Reader).</target>
        </trans-unit>
        <trans-unit id="80806cb0e126f8dd45cfba36eccecc7429a61358" translate="yes" xml:space="preserve">
          <source>GenerateKey returns a public/private key pair. The private key is generated using the given reader, which must return random data.</source>
          <target state="translated">GenerateKey возвращает пару публичного/частного ключа.Приватный ключ генерируется с помощью заданного считывателя,который должен возвращать случайные данные.</target>
        </trans-unit>
        <trans-unit id="94cfc2c7f30a1879e413d8411b7005501c966655" translate="yes" xml:space="preserve">
          <source>GenerateMultiPrimeKey generates a multi-prime RSA keypair of the given bit size and the given random source, as suggested in [1]. Although the public keys are compatible (actually, indistinguishable) from the 2-prime case, the private keys are not. Thus it may not be possible to export multi-prime private keys in certain formats or to subsequently import them into other code.</source>
          <target state="translated">GenerateMultiPrimeKey генерирует мульти-премьерную пару ключей RSA заданного размера бита и заданного случайного источника,как предложено в [1].Несмотря на то,что открытые ключи совместимы (фактически,неотличимы)от 2-хrime case,закрытые ключи таковыми не являются.Таким образом,может оказаться невозможным экспортировать многопредметные закрытые ключи в определенных форматах или впоследствии импортировать их в другой код.</target>
        </trans-unit>
        <trans-unit id="51625703089c85c9211c0ab627055dec67c2bfaf" translate="yes" xml:space="preserve">
          <source>GenerateParameters puts a random, valid set of DSA parameters into params. This function can take many seconds, even on fast machines.</source>
          <target state="translated">GenerateParameters помещает случайный,корректный набор параметров DSA в параметры.Эта функция может занять много секунд,даже на быстрых машинах.</target>
        </trans-unit>
        <trans-unit id="4ebb3d9bf07301446af753fd8cfde6a2dbd2f25b" translate="yes" xml:space="preserve">
          <source>Generic file system errors. Errors returned by file systems can be tested against these errors using errors.Is.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bfffd736cddd08a4eee689949c3399cb61da773b" translate="yes" xml:space="preserve">
          <source>Get</source>
          <target state="translated">Get</target>
        </trans-unit>
        <trans-unit id="2fe964aa376032085805189a0397b3cdcf676226" translate="yes" xml:space="preserve">
          <source>Get gets the first value associated with the given key. If there are no values associated with the key, Get returns &quot;&quot;. It is case insensitive; textproto.CanonicalMIMEHeaderKey is used to canonicalize the provided key. To access multiple values of a key, or to use non-canonical keys, access the map directly.</source>
          <target state="translated">Get получает первое значение,связанное с данным ключом.Если нет значений,связанных с ключом,Get возвращает &quot;&quot;.Она не чувствительна к регистру;для канонизации предоставленного ключа используется textproto.CanonicalMIMEHeaderKey.Для доступа к нескольким значениям ключа,или для использования неканонических ключей,обращайтесь непосредственно к карте.</target>
        </trans-unit>
        <trans-unit id="3baa902f39cd83b30a85e419cba3b5af01d1e3ff" translate="yes" xml:space="preserve">
          <source>Get gets the first value associated with the given key. If there are no values associated with the key, Get returns &quot;&quot;. It is case insensitive; textproto.CanonicalMIMEHeaderKey is used to canonicalize the provided key. To use non-canonical keys, access the map directly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5819a3dfa32fe18b54e30756235c5c0b3e71efb0" translate="yes" xml:space="preserve">
          <source>Get gets the first value associated with the given key. If there are no values associated with the key, Get returns the empty string. To access multiple values, use the map directly.</source>
          <target state="translated">Get получает первое значение,связанное с данным ключом.Если с ключом не ассоциировано ни одного значения,Get возвращает пустую строку.Для доступа к нескольким значениям используйте карту напрямую.</target>
        </trans-unit>
        <trans-unit id="322573da1168297393f519b4b988bc100cbe0b6c" translate="yes" xml:space="preserve">
          <source>Get gets the first value associated with the given key. It is case insensitive; CanonicalMIMEHeaderKey is used to canonicalize the provided key. If there are no values associated with the key, Get returns &quot;&quot;. To access multiple values of a key, or to use non-canonical keys, access the map directly.</source>
          <target state="translated">Get получает первое значение,связанное с данным ключом.Оно не чувствительно к регистру;CanonicalMIMEHeaderKey используется для канонизации предоставленного ключа.Если значение,связанное с ключом,отсутствует,Get возвращает &quot;&quot;.Для доступа к нескольким значениям ключа,или для использования неканонических ключей,обращайтесь непосредственно к карте.</target>
        </trans-unit>
        <trans-unit id="70b433c8accfde2bcfff0de0db7ea43f32e215fb" translate="yes" xml:space="preserve">
          <source>Get gets the first value associated with the given key. It is case insensitive; CanonicalMIMEHeaderKey is used to canonicalize the provided key. If there are no values associated with the key, Get returns &quot;&quot;. To use non-canonical keys, access the map directly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec73d0c593dbece5412fe884185bdca68896527d" translate="yes" xml:space="preserve">
          <source>Get is a wrapper around DefaultClient.Get.</source>
          <target state="translated">Get-это обёртка вокруг DefaultClient.Get.</target>
        </trans-unit>
        <trans-unit id="e51f2ab7d6fbd0e2ffab583f80049b3cfc794ac8" translate="yes" xml:space="preserve">
          <source>Get issues a GET to the specified URL. If the response is one of the following redirect codes, Get follows the redirect after calling the Client's CheckRedirect function:</source>
          <target state="translated">Получить GET к указанному URL.Если ответ является одним из следующих кодов перенаправления,Get следует за перенаправлением после вызова функции Client's CheckRedirect:</target>
        </trans-unit>
        <trans-unit id="cff58f3ccfaec37f9252515e01360ee67558791b" translate="yes" xml:space="preserve">
          <source>Get issues a GET to the specified URL. If the response is one of the following redirect codes, Get follows the redirect, up to a maximum of 10 redirects:</source>
          <target state="translated">Получить GET к указанному URL.Если ответ является одним из следующих кодов перенаправления,Get следует за перенаправлением,максимум до 10 перенаправлений:</target>
        </trans-unit>
        <trans-unit id="4af41ae2934aaf3ecc571a5a758befaaf5dd46ec" translate="yes" xml:space="preserve">
          <source>Get retrieves a named exported variable. It returns nil if the name has not been registered.</source>
          <target state="translated">Получает именованную экспортируемую переменную.Возвращает ноль,если имя не было зарегистрировано.</target>
        </trans-unit>
        <trans-unit id="afa92ba06d138d5628558f74ba88a7e263aff277" translate="yes" xml:space="preserve">
          <source>Get returns the JavaScript property p of value v. It panics if v is not a JavaScript object.</source>
          <target state="translated">Get возвращает свойство JavaScript p значения v.Он паникует,если v не является объектом JavaScript.</target>
        </trans-unit>
        <trans-unit id="1f152948d80d4df7cedf020669e282541979aaff" translate="yes" xml:space="preserve">
          <source>Get returns the value associated with key in the tag string. If there is no such key in the tag, Get returns the empty string. If the tag does not have the conventional format, the value returned by Get is unspecified. To determine whether a tag is explicitly set to the empty string, use Lookup.</source>
          <target state="translated">Get возвращает значение,связанное с ключом в строке тега.Если в теге нет такого ключа,Get возвращает пустую строку.Если тег не имеет обычного формата,возвращаемое Get значение является неуказанным.Чтобы определить,установлен ли явно тег на пустую строку,используйте Lookup.</target>
        </trans-unit>
        <trans-unit id="1c95403f4621e18fe8ba30c67d76e285e8214f43" translate="yes" xml:space="preserve">
          <source>Get selects an arbitrary item from the Pool, removes it from the Pool, and returns it to the caller. Get may choose to ignore the pool and treat it as empty. Callers should not assume any relation between values passed to Put and the values returned by Get.</source>
          <target state="translated">Get выбирает произвольный элемент из пула,удаляет его из пула и возвращает вызывающему абоненту.Get может выбрать игнорирование пула и считать его пустым.Звонящий не должен предполагать никакой связи между значениями,переданными в Put и значениями,возвращаемыми Get.</target>
        </trans-unit>
        <trans-unit id="c21e6716a05006be2a3b33da22f790cc4dacbd14" translate="yes" xml:space="preserve">
          <source>Get, Head, Post, and PostForm make HTTP (or HTTPS) requests:</source>
          <target state="translated">Get,Head,Post и PostForm делают HTTP (или HTTPS)запросы:</target>
        </trans-unit>
        <trans-unit id="c5763aa4654b9f9e755a5247c7e85bd6431154eb" translate="yes" xml:space="preserve">
          <source>Getegid returns the numeric effective group id of the caller.</source>
          <target state="translated">Getegid возвращает числовой эффективный идентификатор группы вызывающего абонента.</target>
        </trans-unit>
        <trans-unit id="3ce86e952faaa112161293325cc18e1e8b1d1f86" translate="yes" xml:space="preserve">
          <source>Getenv</source>
          <target state="translated">Getenv</target>
        </trans-unit>
        <trans-unit id="83272f1d9be5d707a2abc299316ecf8c20c6572e" translate="yes" xml:space="preserve">
          <source>Getenv retrieves the value of the environment variable named by the key. It returns the value, which will be empty if the variable is not present. To distinguish between an empty value and an unset value, use LookupEnv.</source>
          <target state="translated">Getenv получает значение переменной окружения,названной ключом.Он возвращает значение,которое будет пустым,если переменной нет.Чтобы отличить пустое значение от неустановленного,используйте LookupEnv.</target>
        </trans-unit>
        <trans-unit id="fb87cd5bc3aee2814b4736bc86345f331ef466ad" translate="yes" xml:space="preserve">
          <source>Geteuid returns the numeric effective user id of the caller.</source>
          <target state="translated">Geteuid возвращает числовой эффективный идентификатор вызывающего абонента.</target>
        </trans-unit>
        <trans-unit id="ba1ccf148fadcaa5a423e416bb3b76de027035d5" translate="yes" xml:space="preserve">
          <source>Getgid returns the numeric group id of the caller.</source>
          <target state="translated">Getgid возвращает числовой идентификатор группы вызывающего абонента.</target>
        </trans-unit>
        <trans-unit id="1a0d3dfabc3d14d5473d84c935b43760abff4984" translate="yes" xml:space="preserve">
          <source>Getgroups returns a list of the numeric ids of groups that the caller belongs to.</source>
          <target state="translated">Getgroups возвращает список числовых идентификаторов групп,к которым принадлежит вызывающий абонент.</target>
        </trans-unit>
        <trans-unit id="cf37c04d335f6576ae2f027091318c6f433db063" translate="yes" xml:space="preserve">
          <source>Getpagesize returns the underlying system's memory page size.</source>
          <target state="translated">Getpagesize возвращает размер страницы памяти системы.</target>
        </trans-unit>
        <trans-unit id="98c30bd03388e6d00325569f2c09cb7a5c1f7d76" translate="yes" xml:space="preserve">
          <source>Getpid returns the process id of the caller.</source>
          <target state="translated">Гетпид возвращает идентификатор процесса вызывающего абонента.</target>
        </trans-unit>
        <trans-unit id="7d80618e0017c08138a1fb60fea1c4ec0dbcc585" translate="yes" xml:space="preserve">
          <source>Getppid returns the process id of the caller's parent.</source>
          <target state="translated">Гетппид возвращает идентификатор процесса родителя звонящего.</target>
        </trans-unit>
        <trans-unit id="0420495bba5effaa143906967bf722c4ac8e2224" translate="yes" xml:space="preserve">
          <source>Getter is an interface that allows the contents of a Value to be retrieved. It wraps the Value interface, rather than being part of it, because it appeared after Go 1 and its compatibility rules. All Value types provided by this package satisfy the Getter interface, except the type used by Func.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed660f2b70ea9d5fc73733f3c8d0fe3252a11e78" translate="yes" xml:space="preserve">
          <source>Getter is an interface that allows the contents of a Value to be retrieved. It wraps the Value interface, rather than being part of it, because it appeared after Go 1 and its compatibility rules. All Value types provided by this package satisfy the Getter interface.</source>
          <target state="translated">Getter-это интерфейс,позволяющий извлекать содержимое Value.Он обертывает интерфейс Value,а не является его частью,потому что появился после Go 1 и его правил совместимости.Все типы Value,предоставляемые этим пакетом,удовлетворяют интерфейсу Getter.</target>
        </trans-unit>
        <trans-unit id="87c5badfd378b66a2a7ada85f8b7415911742baa" translate="yes" xml:space="preserve">
          <source>Getuid returns the numeric user id of the caller.</source>
          <target state="translated">Getuid возвращает цифровой идентификатор вызывающего абонента.</target>
        </trans-unit>
        <trans-unit id="55e12168bb983e41918aba1691a9e5f495430b36" translate="yes" xml:space="preserve">
          <source>Getwd returns a rooted path name corresponding to the current directory. If the current directory can be reached via multiple paths (due to symbolic links), Getwd may return any one of them.</source>
          <target state="translated">Getwd возвращает корневое имя пути,соответствующее текущему каталогу.Если текущий каталог может быть доступен по нескольким путям (из-за символических связей),Getwd может вернуть любой из них.</target>
        </trans-unit>
        <trans-unit id="db8c30ea4bb862dc2beac406c90a324c6875e53e" translate="yes" xml:space="preserve">
          <source>Given that input, ReadMIMEHeader returns the map:</source>
          <target state="translated">Учитывая этот ввод,ReadMIMEHeader возвращает карту:</target>
        </trans-unit>
        <trans-unit id="0d7c5c492a7ddeb919966cbf89bf311a727d8ab3" translate="yes" xml:space="preserve">
          <source>Glob ignores file system errors such as I/O errors reading directories. The only possible returned error is ErrBadPattern, when pattern is malformed.</source>
          <target state="translated">Глобус игнорирует ошибки файловой системы,такие как ошибки чтения каталогов ввода/вывода.Единственная возможная возвращаемая ошибка-это ErrBadPattern,когда шаблон неправильно сформирован.</target>
        </trans-unit>
        <trans-unit id="ec233ed9cb1b9df5201fce35a0b5f94ec953239c" translate="yes" xml:space="preserve">
          <source>Glob ignores file system errors such as I/O errors reading directories. The only possible returned error is path.ErrBadPattern, reporting that the pattern is malformed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a57ea57c1f0982972dd2d2f408926f91cf67c45" translate="yes" xml:space="preserve">
          <source>Glob returns the names of all files matching pattern or nil if there is no matching file. The syntax of patterns is the same as in Match. The pattern may describe hierarchical names such as /usr/*/bin/ed (assuming the Separator is '/').</source>
          <target state="translated">Глобус возвращает имена всех файлов,совпадающих по шаблону,или ноль,если файл не совпадает.Синтаксис шаблонов совпадает с синтаксисом Match.Шаблон может описывать иерархические имена,такие как /usr/*/bin/ed (предполагая,что разделитель-это '/').</target>
        </trans-unit>
        <trans-unit id="59177559b687a2613d20fb79582001f540617ebd" translate="yes" xml:space="preserve">
          <source>Glob returns the names of all files matching pattern or nil if there is no matching file. The syntax of patterns is the same as in path.Match. The pattern may describe hierarchical names such as usr/*/bin/ed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="599aa1de3cf0d500e8e5f7d1a178d0ab1cc0a630" translate="yes" xml:space="preserve">
          <source>Global returns the JavaScript global object, usually &quot;window&quot; or &quot;global&quot;.</source>
          <target state="translated">Global возвращает глобальный объект JavaScript,обычно &quot;window&quot; или &quot;global&quot;.</target>
        </trans-unit>
        <trans-unit id="2e0b45f2a456e8db55f08d7b65e87593a3e9a140" translate="yes" xml:space="preserve">
          <source>Go</source>
          <target state="translated">Go</target>
        </trans-unit>
        <trans-unit id="e2b7859482bcbcd7f30181447cb1227d814aecb3" translate="yes" xml:space="preserve">
          <source>Go Path</source>
          <target state="translated">Путь истинный</target>
        </trans-unit>
        <trans-unit id="31c51be344c4f61c8aa40bf7e10aeaf5b3b1af91" translate="yes" xml:space="preserve">
          <source>Go Programming Language</source>
          <target state="translated">Язык программирования</target>
        </trans-unit>
        <trans-unit id="2c968e5f87e6cf184e435232ef5dd7937823c72a" translate="yes" xml:space="preserve">
          <source>Go code built with -buildmode=c-archive or -buildmode=c-shared will not install any other signal handlers by default. If there is an existing signal handler, the Go runtime will turn on the SA_ONSTACK flag and otherwise keep the signal handler. If Notify is called for an asynchronous signal, a Go signal handler will be installed for that signal. If, later, Reset is called for that signal, the original handling for that signal will be reinstalled, restoring the non-Go signal handler if any.</source>
          <target state="translated">Код Go,собранный с помощью -buildmode=c-archive или -buildmode=c-shared по умолчанию не устанавливает никаких других обработчиков сигналов.Если обработчик сигналов уже существует,то во время выполнения Go будет установлен флаг SA_ONSTACK,а в противном случае обработчик сигналов будет сохранен.Если для асинхронного сигнала вызывается Notify,то для этого сигнала будет установлен обработчик сигнала Go.Если позже будет вызван Reset для этого сигнала,то будет переустановлен исходный обработчик этого сигнала,восстанавливающий обработчик не-Go сигнала,если таковой имеется.</target>
        </trans-unit>
        <trans-unit id="799dd6ab824dcf093ff420451386c628fa2a9520" translate="yes" xml:space="preserve">
          <source>Go code built without -buildmode=c-archive or -buildmode=c-shared will install a signal handler for the asynchronous signals listed above, and save any existing signal handler. If a signal is delivered to a non-Go thread, it will act as described above, except that if there is an existing non-Go signal handler, that handler will be installed before raising the signal.</source>
          <target state="translated">Код Go,собранный без -buildmode=c-archive или -buildmode=c-shared,установит обработчик сигналов для асинхронных сигналов,перечисленных выше,и сохранит любой существующий обработчик сигналов.Если сигнал доставляется в не-Go поток,он будет действовать так,как описано выше,за исключением того,что если есть существующий не-Go обработчик сигналов,то этот обработчик будет установлен перед тем,как поднять сигнал.</target>
        </trans-unit>
        <trans-unit id="eb5d4b3ab79b5b09438ad686f6a173b50aeb10bd" translate="yes" xml:space="preserve">
          <source>Go identifiers that appear in the words map are italicized; if the corresponding map value is not the empty string, it is considered a URL and the word is converted into a link.</source>
          <target state="translated">Идентификаторы Go,которые появляются в словах map,выделяются курсивом;если соответствующее значение map не является пустой строкой,то оно считается URL,а слово преобразуется в ссылку.</target>
        </trans-unit>
        <trans-unit id="ea224aeb731dc78304c02f088e7a39cfe984c1f7" translate="yes" xml:space="preserve">
          <source>Go invokes the function asynchronously. It returns the Call structure representing the invocation. The done channel will signal when the call is complete by returning the same Call object. If done is nil, Go will allocate a new channel. If non-nil, done must be buffered or Go will deliberately crash.</source>
          <target state="translated">Иди вызывай функцию асинхронно.Она возвращает структуру вызова,представляющую вызов.По завершению вызова канал будет сигнализировать о завершении вызова,возвращая тот же объект вызова.Если выполненный вызов равен нулю,то Go назначит новый канал.Если ноль,то выполненный должен быть буферизован,иначе Go умышленно аварийно завершит работу.</target>
        </trans-unit>
        <trans-unit id="a7c304672885987fa9e2bc01caee3388d0b9796b" translate="yes" xml:space="preserve">
          <source>Go programs that use cgo or SWIG</source>
          <target state="translated">Вперед программы,использующие cgo или SWIG</target>
        </trans-unit>
        <trans-unit id="dd7dcac022db9d7876634d64e370d5b00e950d72" translate="yes" xml:space="preserve">
          <source>Go source files that import &quot;embed&quot; can use the //go:embed directive to initialize a variable of type string, []byte, or FS with the contents of files read from the package directory or subdirectories at compile time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f00375ef44991e7032fc680e2e8afc5d4b4ddcac" translate="yes" xml:space="preserve">
          <source>GoStringer</source>
          <target state="translated">GoStringer</target>
        </trans-unit>
        <trans-unit id="776ec360ea626f63aba6d19bf197cc0106f28f0c" translate="yes" xml:space="preserve">
          <source>GoStringer is implemented by any value that has a GoString method, which defines the Go syntax for that value. The GoString method is used to print values passed as an operand to a %#v format.</source>
          <target state="translated">GoStringer реализован любым значением,которое имеет метод GoString,определяющий синтаксис Go для этого значения.Метод GoString используется для печати значений,передаваемых в виде операнда в формате %#v.</target>
        </trans-unit>
        <trans-unit id="06664245ef1dbe050dbc75990b043c9e9da34427" translate="yes" xml:space="preserve">
          <source>GoWhitespace is the default value for the Scanner's Whitespace field. Its value selects Go's white space characters.</source>
          <target state="translated">GoWhitespace-это значение по умолчанию для поля Scanner's Whitespace.Его значение выбирает пробельные символы Go.</target>
        </trans-unit>
        <trans-unit id="13594eb4e63d05205c24ee0d18474bb09fad234a" translate="yes" xml:space="preserve">
          <source>Gob can decode a value of any type implementing the GobDecoder or encoding.BinaryUnmarshaler interfaces by calling the corresponding method, again in that order of preference.</source>
          <target state="translated">Джоб может декодировать значение любого типа,реализующего интерфейс GobDecoder или кодировку.BinaryUnmarshaler,обратившись к соответствующему методу,опять же в том же порядке предпочтений.</target>
        </trans-unit>
        <trans-unit id="7274c1618f0661ff86ead432a84f718728e78907" translate="yes" xml:space="preserve">
          <source>Gob can encode a value of any type implementing the GobEncoder or encoding.BinaryMarshaler interfaces by calling the corresponding method, in that order of preference.</source>
          <target state="translated">Gob может кодировать значение любого типа,реализующего интерфейс GobEncoder или кодирующий.BinaryMarshaler,вызывая соответствующий метод,в этом порядке предпочтений.</target>
        </trans-unit>
        <trans-unit id="3f0664b183bab943699d699e2b7fa06d50e41b1a" translate="yes" xml:space="preserve">
          <source>GobDecode implements the gob.GobDecoder interface.</source>
          <target state="translated">GobDecode реализует интерфейс gob.GobDecoder.</target>
        </trans-unit>
        <trans-unit id="d350a1211682bc77e1cf31df3df91c75eb68270c" translate="yes" xml:space="preserve">
          <source>GobDecode implements the gob.GobDecoder interface. The result is rounded per the precision and rounding mode of z unless z's precision is 0, in which case z is set exactly to the decoded value.</source>
          <target state="translated">GobDecode реализует интерфейс gob.GobDecoder.Результат округляется в режиме точности и округления z,если только точность z не равна 0,в этом случае z устанавливается точно на декодированное значение.</target>
        </trans-unit>
        <trans-unit id="dd719ca2cfb03b3cfba4caf011be5a1140872694" translate="yes" xml:space="preserve">
          <source>GobDecoder is the interface describing data that provides its own routine for decoding transmitted values sent by a GobEncoder.</source>
          <target state="translated">GobDecoder-это интерфейс,описывающий данные,который предоставляет собственную рутину для декодирования передаваемых значений,посылаемых GobEncoder.</target>
        </trans-unit>
        <trans-unit id="d5aa87ccb7988a5106efef8e6d2f9cae7932e9c6" translate="yes" xml:space="preserve">
          <source>GobEncode implements the gob.GobEncoder interface.</source>
          <target state="translated">GobEncode реализует интерфейс gob.GobEncoder.</target>
        </trans-unit>
        <trans-unit id="20cb90d239fa73b1f6938fdb92b390d973a1de7f" translate="yes" xml:space="preserve">
          <source>GobEncode implements the gob.GobEncoder interface. The Float value and all its attributes (precision, rounding mode, accuracy) are marshaled.</source>
          <target state="translated">GobEncode реализует интерфейс gob.GobEncoder.Значение Float и все его атрибуты (точность,режим округления,точность)маршируются.</target>
        </trans-unit>
        <trans-unit id="a019b8cdacb9fe6be4bcfe375ae2210cd1a4074d" translate="yes" xml:space="preserve">
          <source>GobEncoder is the interface describing data that provides its own representation for encoding values for transmission to a GobDecoder. A type that implements GobEncoder and GobDecoder has complete control over the representation of its data and may therefore contain things such as private fields, channels, and functions, which are not usually transmissible in gob streams.</source>
          <target state="translated">GobEncoder-это интерфейс,описывающий данные,который предоставляет собственное представление для кодирования значений для передачи в GobDecoder.Тип,реализующий GobEncoder и GobDecoder,имеет полный контроль над представлением своих данных и поэтому может содержать такие вещи,как приватные поля,каналы и функции,которые обычно не передаются в потоках gobDecoder.</target>
        </trans-unit>
        <trans-unit id="3af908c6818caa06d786a8ce4e61618d352da418" translate="yes" xml:space="preserve">
          <source>Goexit terminates the goroutine that calls it. No other goroutine is affected. Goexit runs all deferred calls before terminating the goroutine. Because Goexit is not a panic, any recover calls in those deferred functions will return nil.</source>
          <target state="translated">Гексит уничтожает горутина,который его называет.Никакой другой горутин не затронут.Гексит запускает все отложенные вызовы до прекращения горутина.Так как Goexit не паникует,все восстановительные вызовы в этих отложенных функциях возвращают ноль.</target>
        </trans-unit>
        <trans-unit id="92c1b5045c151c8351b05867329857d4da35385e" translate="yes" xml:space="preserve">
          <source>GoroutineProfile returns n, the number of records in the active goroutine stack profile. If len(p) &amp;gt;= n, GoroutineProfile copies the profile into p and returns n, true. If len(p) &amp;lt; n, GoroutineProfile does not change p and returns n, false.</source>
          <target state="translated">GoroutineProfile возвращает n - количество записей в активном профиле стека горутин. Если len (p)&amp;gt; = n, GoroutineProfile копирует профиль в p и возвращает n, true. Если len (p) &amp;lt;n, GoroutineProfile не изменяет p и возвращает n, false.</target>
        </trans-unit>
        <trans-unit id="62967be4b08298e25e7959a7cdc5602a2a2be72a" translate="yes" xml:space="preserve">
          <source>Gosched yields the processor, allowing other goroutines to run. It does not suspend the current goroutine, so execution resumes automatically.</source>
          <target state="translated">Gosched дает процессор,позволяя другим гориллам работать.Он не приостанавливает текущую работу гортани,поэтому выполнение возобновляется автоматически.</target>
        </trans-unit>
        <trans-unit id="1c2aaf1310e2e413d539667c1a3e7771e58933c6" translate="yes" xml:space="preserve">
          <source>GotConnInfo is the argument to the ClientTrace.GotConn function and contains information about the obtained connection.</source>
          <target state="translated">GotConnInfo является аргументом к функции ClientTrace.GotConn и содержит информацию о полученном соединении.</target>
        </trans-unit>
        <trans-unit id="8aa6da089a7b549e351002a5e03605264795ad2e" translate="yes" xml:space="preserve">
          <source>GraphicRanges defines the set of graphic characters according to Unicode.</source>
          <target state="translated">GraphicRanges определяет набор графических символов в соответствии с Юникодом.</target>
        </trans-unit>
        <trans-unit id="e7195fa4641b119dd2889d0a417f633c2b3c037d" translate="yes" xml:space="preserve">
          <source>Gray is an in-memory image whose At method returns color.Gray values.</source>
          <target state="translated">Серый-это изображение в памяти,которое по методу At возвращает значения color.Gray.</target>
        </trans-unit>
        <trans-unit id="8551691479e553fcfd58c230f9f1c7702a08e936" translate="yes" xml:space="preserve">
          <source>Gray represents an 8-bit grayscale color.</source>
          <target state="translated">Серый представляет собой 8-разрядный оттенок серого.</target>
        </trans-unit>
        <trans-unit id="8be44534e41a9fdc599304347782cb967b0bd62b" translate="yes" xml:space="preserve">
          <source>Gray16 is an in-memory image whose At method returns color.Gray16 values.</source>
          <target state="translated">Gray16-это изображение в памяти,которое по методу At возвращает значения color.Gray16.</target>
        </trans-unit>
        <trans-unit id="b7ee628ee7a9a7bf06c313fa8d8dc808a58abb8f" translate="yes" xml:space="preserve">
          <source>Gray16 represents a 16-bit grayscale color.</source>
          <target state="translated">Серый16 представляет собой 16-разрядный оттенок серого.</target>
        </trans-unit>
        <trans-unit id="6e09be6a83f7d3163e99081e0c679a65e139fc8d" translate="yes" xml:space="preserve">
          <source>Group represents a grouping of users.</source>
          <target state="translated">Группа представляет собой группу пользователей.</target>
        </trans-unit>
        <trans-unit id="7de1bb0487db53a77d3d5fa786aa26f9027ba7c1" translate="yes" xml:space="preserve">
          <source>GroupIds returns the list of group IDs that the user is a member of.</source>
          <target state="translated">GroupIds возвращает список идентификаторов групп,членом которых является пользователь.</target>
        </trans-unit>
        <trans-unit id="d0e679bf3eeb0246c0708b92532613618a2a5627" translate="yes" xml:space="preserve">
          <source>Grouping:</source>
          <target state="translated">Grouping:</target>
        </trans-unit>
        <trans-unit id="a3dd80da68d80e7f0e9f29bcc9f5cb31d2777884" translate="yes" xml:space="preserve">
          <source>Grow grows b's capacity, if necessary, to guarantee space for another n bytes. After Grow(n), at least n bytes can be written to b without another allocation. If n is negative, Grow panics.</source>
          <target state="translated">Растет способность b,при необходимости,гарантировать место для еще одного n байта.После Grow(n)как минимум n байт можно записать в b без другого выделения.Если n отрицательно,то Grow паникует.</target>
        </trans-unit>
        <trans-unit id="ea6ca3eab6713cfdabbbddc578b2358a70e4ccb7" translate="yes" xml:space="preserve">
          <source>Grow grows the buffer's capacity, if necessary, to guarantee space for another n bytes. After Grow(n), at least n bytes can be written to the buffer without another allocation. If n is negative, Grow will panic. If the buffer can't grow it will panic with ErrTooLarge.</source>
          <target state="translated">Grow увеличивает емкость буфера,если необходимо,чтобы гарантировать место для еще одного n байта.После Grow(n),как минимум,n байт можно записать в буфер без другого выделения.Если n будет отрицательным,Grow запаникует.Если буфер не сможет вырасти,он запаникует с помощью ErrTooLarge.</target>
        </trans-unit>
        <trans-unit id="fcfc665b9c38534864ef4c48c8a42633500c63ee" translate="yes" xml:space="preserve">
          <source>Gzip files store a length and checksum of the uncompressed data. The Reader will return an ErrChecksum when Read reaches the end of the uncompressed data if it does not have the expected length or checksum. Clients should treat data returned by Read as tentative until they receive the io.EOF marking the end of the data.</source>
          <target state="translated">Gzip-файлы хранят длину и контрольную сумму несжатых данных.Читатель возвращает ErrChecksum,когда Read достигает конца несжатых данных,если у него нет ожидаемой длины или контрольной суммы.Клиенты должны относиться к данным,возвращаемым с помощью Read,как к предварительным,до тех пор,пока они не получат io.EOF-маркировку конца данных.</target>
        </trans-unit>
        <trans-unit id="5d71851e777cb11c10615f1403f7831b2abdc279" translate="yes" xml:space="preserve">
          <source>HTML encapsulates a known safe HTML document fragment. It should not be used for HTML from a third-party, or HTML with unclosed tags or comments. The outputs of a sound HTML sanitizer and a template escaped by this package are fine for use with HTML.</source>
          <target state="translated">HTML инкапсулирует известный безопасный фрагмент HTML документа.Он не должен использоваться для HTML от третьих лиц или HTML с незакрытыми тегами или комментариями.Выводы звукового дезинфектанта HTML и шаблона,экранированного этим пакетом,прекрасно подходят для использования с HTML.</target>
        </trans-unit>
        <trans-unit id="b3eeeba32a88681f357c6658794b2cde0a1ffee1" translate="yes" xml:space="preserve">
          <source>HTML templates treat data values as plain text which should be encoded so they can be safely embedded in an HTML document. The escaping is contextual, so actions can appear within JavaScript, CSS, and URI contexts.</source>
          <target state="translated">Шаблоны HTML обрабатывают значения данных как обычный текст,который должен быть закодирован,чтобы его можно было безопасно встроить в HTML-документ.Экрапирование контекстуально,поэтому действия могут появляться в контекстах JavaScript,CSS и URI.</target>
        </trans-unit>
        <trans-unit id="9941fc69ceb0b7c4c9cd661ccc1d3296d53a1466" translate="yes" xml:space="preserve">
          <source>HTMLAttr encapsulates an HTML attribute from a trusted source, for example, ` dir=&quot;ltr&quot;`.</source>
          <target state="translated">HTMLAttr инкапсулирует атрибут HTML из доверенного источника,например,` dir=&quot;ltr&quot;`.</target>
        </trans-unit>
        <trans-unit id="56515df9ce780f70db2a14123d61a78cb0491ced" translate="yes" xml:space="preserve">
          <source>HTMLAutoClose is the set of HTML elements that should be considered to close automatically.</source>
          <target state="translated">HTMLAutoClose-это набор HTML-элементов,которые должны считаться автоматически закрывающимися.</target>
        </trans-unit>
        <trans-unit id="e3ae2c19a119f12f6bd7618bea966cc88fb1903b" translate="yes" xml:space="preserve">
          <source>HTMLEntity is an entity map containing translations for the standard HTML entity characters.</source>
          <target state="translated">HTMLEntity-это карта сущностей,содержащая переводы для стандартных символов сущностей HTML.</target>
        </trans-unit>
        <trans-unit id="0502b94bdac42557ec458b2bcfd7d81519bb7f5f" translate="yes" xml:space="preserve">
          <source>HTMLEscape</source>
          <target state="translated">HTMLEscape</target>
        </trans-unit>
        <trans-unit id="108bb0274697ed474af72c0af28941c4694cc443" translate="yes" xml:space="preserve">
          <source>HTMLEscape appends to dst the JSON-encoded src with &amp;lt;, &amp;gt;, &amp;amp;, U+2028 and U+2029 characters inside string literals changed to \u003c, \u003e, \u0026, \u2028, \u2029 so that the JSON will be safe to embed inside HTML &amp;lt;script&amp;gt; tags. For historical reasons, web browsers don't honor standard HTML escaping within &amp;lt;script&amp;gt; tags, so an alternative JSON encoding must be used.</source>
          <target state="translated">HTMLEscape добавляет в dst кодированный в JSON src с символами &amp;lt;,&amp;gt;, &amp;amp;, U + 2028 и U + 2029 внутри строковых литералов, измененными на \ u003c,&amp;gt;, \ u0026, \ u2028, \ u2029, чтобы JSON был безопасным для встраивания в теги HTML &amp;lt;script&amp;gt;. По историческим причинам веб-браузеры не поддерживают стандартное экранирование HTML в тегах &amp;lt;script&amp;gt;, поэтому необходимо использовать альтернативную кодировку JSON.</target>
        </trans-unit>
        <trans-unit id="eaa5eff89dbdb13500c068f0e84bf21b7f3be3fb" translate="yes" xml:space="preserve">
          <source>HTMLEscape writes to w the escaped HTML equivalent of the plain text data b.</source>
          <target state="translated">HTMLEscape записывает в w эквивалент экранированного HTML простого текста b.</target>
        </trans-unit>
        <trans-unit id="eba1f3f7ea429a820bedfa415a707d8da7ce1238" translate="yes" xml:space="preserve">
          <source>HTMLEscapeString returns the escaped HTML equivalent of the plain text data s.</source>
          <target state="translated">HTMLEscapeString возвращает эквивалент экранированного HTML к обычным текстовым данным s.</target>
        </trans-unit>
        <trans-unit id="8b2dbe52305b6c07dd244c27d634207753a8523e" translate="yes" xml:space="preserve">
          <source>HTMLEscaper returns the escaped HTML equivalent of the textual representation of its arguments.</source>
          <target state="translated">HTMLEscaper возвращает эквивалент экранированного HTML текстового представления его аргументов.</target>
        </trans-unit>
        <trans-unit id="9304c86e0fba62ba5daa5297c254f425c77df161" translate="yes" xml:space="preserve">
          <source>HTTP Trailers are a set of key/value pairs like headers that come after the HTTP response, instead of before.</source>
          <target state="translated">HTTP-трейлеры-это набор пар ключ/значение,таких как заголовки,которые приходят после ответа HTTP,а не после него.</target>
        </trans-unit>
        <trans-unit id="0f4dea56c9591992aae081556a866da7a62d7c76" translate="yes" xml:space="preserve">
          <source>HTTP status codes as registered with IANA. See: &lt;a href=&quot;https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml&quot;&gt;https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml&lt;/a&gt;</source>
          <target state="translated">Коды состояния HTTP, зарегистрированные в IANA. См. &lt;a href=&quot;https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml&quot;&gt;Https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ffb0634925a034a37cf81c8bf163966c760740e9" translate="yes" xml:space="preserve">
          <source>HTTP/2 support is only enabled if the Listener returns *tls.Conn connections and they were configured with &quot;h2&quot; in the TLS Config.NextProtos.</source>
          <target state="translated">Поддержка HTTP/2 включена только в том случае,если прослушиватель возвращает *tls.Conn соединения и они были сконфигурированы с &quot;h2&quot; в TLS Config.NextProtos.</target>
        </trans-unit>
        <trans-unit id="5ee0353f20802f9b3b832dc664b1cf16f1dd8c83" translate="yes" xml:space="preserve">
          <source>HalfReader returns a Reader that implements Read by reading half as many requested bytes from r.</source>
          <target state="translated">HalfReader возвращает Reader,который реализует Read путем считывания вдвое меньшего количества запрашиваемых байтов из r.</target>
        </trans-unit>
        <trans-unit id="c0392b2b1c472815ba8d1a1e3b20f4a279bf6c50" translate="yes" xml:space="preserve">
          <source>Handle</source>
          <target state="translated">Handle</target>
        </trans-unit>
        <trans-unit id="1f7743a2da5a9b87698980081ed0a9b4a848c67b" translate="yes" xml:space="preserve">
          <source>Handle registers the handler for the given pattern in the DefaultServeMux. The documentation for ServeMux explains how patterns are matched.</source>
          <target state="translated">Ручка регистрирует обработчик для данного шаблона в DefaultServeMux.Документация для ServeMux объясняет,каким образом шаблоны сопоставляются.</target>
        </trans-unit>
        <trans-unit id="adfb5ece7bb714f07a8d92f38ecaccd93eb91488" translate="yes" xml:space="preserve">
          <source>Handle registers the handler for the given pattern. If a handler already exists for pattern, Handle panics.</source>
          <target state="translated">Ручка регистрирует обработчика для данного шаблона.Если обработчик уже существует для шаблона,то выполните панику.</target>
        </trans-unit>
        <trans-unit id="9df709e02c4285ab3a3440b49e05002a1810c202" translate="yes" xml:space="preserve">
          <source>HandleFunc</source>
          <target state="translated">HandleFunc</target>
        </trans-unit>
        <trans-unit id="ba3631b03a8549831c70fb0b756b06eb4ccdf22e" translate="yes" xml:space="preserve">
          <source>HandleFunc registers the handler function for the given pattern in the DefaultServeMux. The documentation for ServeMux explains how patterns are matched.</source>
          <target state="translated">HandleFunc регистрирует функцию обработчика для данного шаблона в DefaultServeMux.Документация по ServeMux объясняет,как сопоставляются шаблоны.</target>
        </trans-unit>
        <trans-unit id="671e02c9111874e0dde4ea20673fb01320ed5a12" translate="yes" xml:space="preserve">
          <source>HandleFunc registers the handler function for the given pattern.</source>
          <target state="translated">HandleFunc регистрирует функцию обработчика для данного шаблона.</target>
        </trans-unit>
        <trans-unit id="b8bc0ae743c24154bab55e05ddac119f84a83a3e" translate="yes" xml:space="preserve">
          <source>HandleHTTP registers an HTTP handler for RPC messages on rpcPath, and a debugging handler on debugPath. It is still necessary to invoke http.Serve(), typically in a go statement.</source>
          <target state="translated">HandleHTTP регистрирует HTTP обработчик RPC сообщений на rpcPath,и отладочный обработчик на debugPath.Все равно необходимо вызывать http.Serve(),обычно в операторе go.</target>
        </trans-unit>
        <trans-unit id="104cf096656ffcb1565dfd1219d7035e43630f88" translate="yes" xml:space="preserve">
          <source>HandleHTTP registers an HTTP handler for RPC messages to DefaultServer on DefaultRPCPath and a debugging handler on DefaultDebugPath. It is still necessary to invoke http.Serve(), typically in a go statement.</source>
          <target state="translated">HandleHTTP регистрирует HTTP обработчик RPC сообщений для DefaultServer на DefaultRPCPath и отладочный обработчик на DefaultDebugPath.Все равно необходимо вызывать http.Serve(),обычно в операторе go.</target>
        </trans-unit>
        <trans-unit id="a62b57b0720d266ed6489a123759bbfe855bf88a" translate="yes" xml:space="preserve">
          <source>Handler also returns the registered pattern that matches the request or, in the case of internally-generated redirects, the pattern that will match after following the redirect.</source>
          <target state="translated">Обработчик также возвращает зарегистрированный шаблон,который соответствует запросу,или,в случае внутренних перенаправлений,шаблон,который будет соответствовать после перенаправления.</target>
        </trans-unit>
        <trans-unit id="0ddb06f6f85fc2ca7a7cc5302dfee4fc45947bee" translate="yes" xml:space="preserve">
          <source>Handler returns an HTTP handler that serves the named profile.</source>
          <target state="translated">Обработчик возвращает HTTP обработчик,который обслуживает именованный профиль.</target>
        </trans-unit>
        <trans-unit id="4065eef104a7b00ebd8ce9a91293334fd4bb0db9" translate="yes" xml:space="preserve">
          <source>Handler returns the expvar HTTP Handler.</source>
          <target state="translated">Обработчик возвращает обработчик expvar HTTP.</target>
        </trans-unit>
        <trans-unit id="e63273beb69f3454c447975682e44a2c5d4a0c1e" translate="yes" xml:space="preserve">
          <source>Handler returns the handler to use for the given request, consulting r.Method, r.Host, and r.URL.Path. It always returns a non-nil handler. If the path is not in its canonical form, the handler will be an internally-generated handler that redirects to the canonical path. If the host contains a port, it is ignored when matching handlers.</source>
          <target state="translated">Обработчик возвращает обработчик для использования для данного запроса,консультируясь с r.Method,r.Host и r.URL.Path.Он всегда возвращает обработчик без номера.Если путь не канонический,обработчик будет внутренне сгенерированным обработчиком,который перенаправляется на канонический путь.Если хост содержит порт,то при совпадении обработчиков он игнорируется.</target>
        </trans-unit>
        <trans-unit id="a812b2fb8f7451d8a9be630f8c521fc7613cf74d" translate="yes" xml:space="preserve">
          <source>Handler runs an executable in a subprocess with a CGI environment.</source>
          <target state="translated">Обработчик запускает исполняемый файл в подпроцессе с CGI окружением.</target>
        </trans-unit>
        <trans-unit id="612e8566dcf29030b3f86ae45fac3cd161070575" translate="yes" xml:space="preserve">
          <source>Handling of anonymous struct fields is new in Go 1.1. Prior to Go 1.1, anonymous struct fields were ignored. To force ignoring of an anonymous struct field in both current and earlier versions, give the field a JSON tag of &quot;-&quot;.</source>
          <target state="translated">Обработка анонимных полей структуры является новой в Go 1.1.До перехода 1.1 анонимные поля структуры игнорировались.Чтобы заставить игнорировать анонимные поля структуры как в текущей,так и в более ранних версиях,присвойте этому полю JSON-тег &quot;-&quot;.</target>
        </trans-unit>
        <trans-unit id="5bd11c3402a6253a1d760b097dca2d66d778e6dd" translate="yes" xml:space="preserve">
          <source>Handshake runs the client or server handshake protocol if it has not yet been run.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8bd5447a341844b0e1ee2ac00ed949437eac1c43" translate="yes" xml:space="preserve">
          <source>Handshake runs the client or server handshake protocol if it has not yet been run. Most uses of this package need not call Handshake explicitly: the first Read or Write will call it automatically.</source>
          <target state="translated">Ручное квитирование запускает протокол квитирования клиента или сервера,если он еще не был запущен.Большинству пользователей этого пакета не нужно явно вызывать Handshake:первое Чтение или Запись вызовет его автоматически.</target>
        </trans-unit>
        <trans-unit id="0bf39eaf505133458b930fe0c34986ca5b577cc9" translate="yes" xml:space="preserve">
          <source>HasExpired reports whether certList should have been updated by now.</source>
          <target state="translated">HasE истекли отчеты о том,должен ли certList быть обновлен к настоящему моменту.</target>
        </trans-unit>
        <trans-unit id="d390517d58b930cb269df7a0b32aa914bfb5311d" translate="yes" xml:space="preserve">
          <source>HasOk reports whether the corresponding expression may be used on the rhs of a comma-ok assignment.</source>
          <target state="translated">HasOk сообщает,может ли соответствующее выражение быть использовано в rhs задания через запятую.</target>
        </trans-unit>
        <trans-unit id="e53848ef4c6fc884ed74c95d3ab525fa42a2bbe7" translate="yes" xml:space="preserve">
          <source>HasPrefix</source>
          <target state="translated">HasPrefix</target>
        </trans-unit>
        <trans-unit id="8d314f541aff1011d7ddb318695b8f61b2af6ec2" translate="yes" xml:space="preserve">
          <source>HasPrefix exists for historical compatibility and should not be used.</source>
          <target state="translated">HasPrefix существует для исторической совместимости и не должен использоваться.</target>
        </trans-unit>
        <trans-unit id="2669e9427d4779bbc09f60c5ccfd3fe6d15b6c70" translate="yes" xml:space="preserve">
          <source>HasPrefix tests whether the byte slice s begins with prefix.</source>
          <target state="translated">HasPrefix проверяет,начинается ли срез байта s с префикса.</target>
        </trans-unit>
        <trans-unit id="5cd07ae1c7bc3b9ed87eb16cdb61e05184635090" translate="yes" xml:space="preserve">
          <source>HasPrefix tests whether the string s begins with prefix.</source>
          <target state="translated">HasPrefix проверяет,начинается ли строка s с префикса.</target>
        </trans-unit>
        <trans-unit id="117455f286c7643c45e4bb7a574dddee082000d6" translate="yes" xml:space="preserve">
          <source>HasSuffix</source>
          <target state="translated">HasSuffix</target>
        </trans-unit>
        <trans-unit id="0d84ad6d23e5d60c659894725feb80de1e5bc00b" translate="yes" xml:space="preserve">
          <source>HasSuffix tests whether the byte slice s ends with suffix.</source>
          <target state="translated">HasSuffix проверяет,заканчивается ли срез байта s суффиксом.</target>
        </trans-unit>
        <trans-unit id="71e6720e740d9f5d90d030cf5d260029a0041a76" translate="yes" xml:space="preserve">
          <source>HasSuffix tests whether the string s ends with suffix.</source>
          <target state="translated">HasSuffix проверяет,заканчивается ли строка s суффиксом.</target>
        </trans-unit>
        <trans-unit id="c07fb815b0dd23f98464b6c96ba0043996f42574" translate="yes" xml:space="preserve">
          <source>Hash identifies a cryptographic hash function that is implemented in another package.</source>
          <target state="translated">Hash определяет криптографическую хэш-функцию,которая реализуется в другом пакете.</target>
        </trans-unit>
        <trans-unit id="a8a4a81d7a93ec8ea6de29fca7e817e8b0ccf094" translate="yes" xml:space="preserve">
          <source>Hash implementations in the standard library (e.g. hash/crc32 and crypto/sha256) implement the encoding.BinaryMarshaler and encoding.BinaryUnmarshaler interfaces. Marshaling a hash implementation allows its internal state to be saved and used for additional processing later, without having to re-write the data previously written to the hash. The hash state may contain portions of the input in its original form, which users are expected to handle for any possible security implications.</source>
          <target state="translated">Хэш-реализации в стандартной библиотеке (например,hash/crc32 и crypto/sha256)реализуют интерфейсы encoding.BinaryMarshaler и encoding.BinaryUnmarshaler.Марширование реализации хэша позволяет сохранить его внутреннее состояние и использовать для дополнительной обработки позже,без необходимости перезаписи данных,ранее записанных в хэш.Хэш-состояние может содержать части входных данных в их первоначальном виде,которые пользователи должны обрабатывать при любых возможных последствиях для безопасности.</target>
        </trans-unit>
        <trans-unit id="afa3769866aaa8e9ccd0894bbb12db0f2a42b294" translate="yes" xml:space="preserve">
          <source>Hash is the common interface implemented by all hash functions.</source>
          <target state="translated">Хэш-это общий интерфейс,реализованный всеми хэш-функциями.</target>
        </trans-unit>
        <trans-unit id="bbb248d3e1082f71a91f55221f9ef1629bac5c92" translate="yes" xml:space="preserve">
          <source>Hash32 is the common interface implemented by all 32-bit hash functions.</source>
          <target state="translated">Hash32-это общий интерфейс,реализованный всеми 32-битными хэш-функциями.</target>
        </trans-unit>
        <trans-unit id="05bc44af5e367ef4fc60329373f6d1a44dbf5c85" translate="yes" xml:space="preserve">
          <source>Hash64 is the common interface implemented by all 64-bit hash functions.</source>
          <target state="translated">Hash64-это общий интерфейс,реализованный всеми 64-битными хэш-функциями.</target>
        </trans-unit>
        <trans-unit id="4aa2a3cc436464a090fd637734a2095043d7b259" translate="yes" xml:space="preserve">
          <source>HashFunc returns opts.Hash so that PSSOptions implements crypto.SignerOpts.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3959061e57c74057bbf958321e7f6031a26bba89" translate="yes" xml:space="preserve">
          <source>HashFunc returns pssOpts.Hash so that PSSOptions implements crypto.SignerOpts.</source>
          <target state="translated">HashFunc возвращает pssOpts.Hash,так что PSSOptions реализует crypto.SignerOpts.</target>
        </trans-unit>
        <trans-unit id="860155016136afc0d36dbbc3f9fc98412399783e" translate="yes" xml:space="preserve">
          <source>HashFunc simply returns the value of h so that Hash implements SignerOpts.</source>
          <target state="translated">HashFunc просто возвращает значение h,так что Hash реализует SignerOpts.</target>
        </trans-unit>
        <trans-unit id="2d042d0360cc7e1f18d91ae4331ed196e499f0e3" translate="yes" xml:space="preserve">
          <source>Hashes are intended to be collision-resistant, even for situations where an adversary controls the byte sequences being hashed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd2b2728ea1f997355e4a7e5005a26c5306f470a" translate="yes" xml:space="preserve">
          <source>Head is a wrapper around DefaultClient.Head</source>
          <target state="translated">Head-это обертка вокруг DefaultClient.Head.</target>
        </trans-unit>
        <trans-unit id="93e59ac29bb3c357b0f9c42db1f78e97e116c128" translate="yes" xml:space="preserve">
          <source>Head issues a HEAD to the specified URL. If the response is one of the following redirect codes, Head follows the redirect after calling the Client's CheckRedirect function:</source>
          <target state="translated">Голова выдает ГОЛОВКУ на указанный URL.Если ответ является одним из следующих кодов перенаправления,Head следует за перенаправлением после вызова функции CheckRedirect клиента:</target>
        </trans-unit>
        <trans-unit id="24094406af9408bd066ab26a0a1ef55bdcdead08" translate="yes" xml:space="preserve">
          <source>Head issues a HEAD to the specified URL. If the response is one of the following redirect codes, Head follows the redirect, up to a maximum of 10 redirects:</source>
          <target state="translated">Голова выдает ГОЛОВКУ на указанный URL.Если ответ является одним из следующих кодов перенаправления,Head следует за перенаправлением,максимум до 10 перенаправлений:</target>
        </trans-unit>
        <trans-unit id="a50c7cbf99b8cae529cf3d620f5022a1c82e8fca" translate="yes" xml:space="preserve">
          <source>Header implements http.ResponseWriter. It returns the response headers to mutate within a handler. To test the headers that were written after a handler completes, use the Result method and see the returned Response value's Header.</source>
          <target state="translated">Заголовок реализует http.ResponseWriter.Он возвращает заголовки ответа для мутации внутри обработчика.Для проверки заголовков,которые были записаны после завершения работы обработчика,используйте метод Result и посмотрите на заголовок возвращаемого значения ответа.</target>
        </trans-unit>
        <trans-unit id="2a403ca7fd2ae0865923ded1f911ee30d4fbde83" translate="yes" xml:space="preserve">
          <source>Hello sends a HELO or EHLO to the server as the given host name. Calling this method is only necessary if the client needs control over the host name used. The client will introduce itself as &quot;localhost&quot; automatically otherwise. If Hello is called, it must be called before any of the other methods.</source>
          <target state="translated">Hello посылает HELO или EHLO на сервер в качестве заданного имени хоста.Вызов этого метода необходим только в том случае,если клиенту необходим контроль над используемым именем хоста.В противном случае клиент автоматически представится как &quot;локальный хост&quot;.Если вызывается Hello,то он должен быть вызван перед любым из других методов.</target>
        </trans-unit>
        <trans-unit id="0aed41610e50a1818172a103900a5a6fdac5322e" translate="yes" xml:space="preserve">
          <source>Helper marks the calling function as a test helper function. When printing file and line information, that function will be skipped. Helper may be called simultaneously from multiple goroutines.</source>
          <target state="translated">Помощник отмечает вызывающую функцию как функцию помощника тестера.При печати файла и информации о строке эта функция будет пропущена.Помощник может быть вызван одновременно из нескольких горутинов.</target>
        </trans-unit>
        <trans-unit id="aa0b52b8a6b42d9b0905c653c010a924ae5e874a" translate="yes" xml:space="preserve">
          <source>Here are some example one-line templates demonstrating pipelines and variables. All produce the quoted word &quot;output&quot;:</source>
          <target state="translated">Вот некоторые примеры однолинейных шаблонов,демонстрирующих трубопроводы и переменные.Все они производят цитируемое слово &quot;вывод&quot;:</target>
        </trans-unit>
        <trans-unit id="89620d229387855063bd56a8e6d5a3250086c9f0" translate="yes" xml:space="preserve">
          <source>Here is a simple example, opening a file and reading some of it.</source>
          <target state="translated">Вот простой пример,открытие файла и чтение части его.</target>
        </trans-unit>
        <trans-unit id="2824caba6baa2187c9e56d7836920f8ff25bcc71" translate="yes" xml:space="preserve">
          <source>Here is a simple example. A server wishes to export an object of type Arith:</source>
          <target state="translated">Вот простой пример.Сервер хочет экспортировать объект типа Arith:</target>
        </trans-unit>
        <trans-unit id="2c22db98d01fc50d0681541a0b0caf2c4141f0f4" translate="yes" xml:space="preserve">
          <source>Here is a trivial example that prints &quot;17 items are made of wool&quot;.</source>
          <target state="translated">Вот тривиальный пример,в котором напечатано &quot;17 предметов сделаны из шерсти&quot;.</target>
        </trans-unit>
        <trans-unit id="dc0bea3647dd8635722162c3a9c56cc10d70b7ac" translate="yes" xml:space="preserve">
          <source>Here is the list of actions. &quot;Arguments&quot; and &quot;pipelines&quot; are evaluations of data, defined in detail in the corresponding sections that follow.</source>
          <target state="translated">Вот список действий.&quot;Аргументы&quot; и &quot;трубопроводы&quot;-это оценки данных,подробно описанные в последующих разделах.</target>
        </trans-unit>
        <trans-unit id="c3b612d75a40adadd01e188d1e2aba30e8b88d33" translate="yes" xml:space="preserve">
          <source>Here we demonstrate loading a set of templates from a directory.</source>
          <target state="translated">Здесь мы демонстрируем загрузку набора шаблонов из каталога.</target>
        </trans-unit>
        <trans-unit id="c18d789286c40d70b27c77faebcb174f22c85dbc" translate="yes" xml:space="preserve">
          <source>Here we demonstrate loading a set of templates from files in different directories</source>
          <target state="translated">Здесь мы демонстрируем загрузку набора шаблонов из файлов в различных каталогах</target>
        </trans-unit>
        <trans-unit id="bcef5f73d0a48aab25273d92f8664ff4fb80379d" translate="yes" xml:space="preserve">
          <source>Here's an example directory layout:</source>
          <target state="translated">Вот пример компоновки каталогов:</target>
        </trans-unit>
        <trans-unit id="35d5d6962be99793c34862b1061c8b5cacf67fc9" translate="yes" xml:space="preserve">
          <source>HexEncoding is the &amp;ldquo;Extended Hex Alphabet&amp;rdquo; defined in RFC 4648. It is typically used in DNS.</source>
          <target state="translated">HexEncoding - это &amp;laquo;расширенный шестнадцатеричный алфавит&amp;raquo;, определенный в RFC 4648. Обычно он используется в DNS.</target>
        </trans-unit>
        <trans-unit id="e23f68e03ccbc9812663415a4a25267a75156114" translate="yes" xml:space="preserve">
          <source>Hijack detaches the ClientConn and returns the underlying connection as well as the read-side bufio which may have some left over data. Hijack may be called before the user or Read have signaled the end of the keep-alive logic. The user should not call Hijack while Read or Write is in progress.</source>
          <target state="translated">Hijack отсоединяет ClientConn и возвращает базовое соединение,а также буфио на стороне чтения,в котором могут остаться некоторые данные.Захват может быть вызван до того,как пользователь или Read подадут сигнал об окончании логики keep-alive.Пользователь не должен звонить в Hijack во время Чтения или Запись.</target>
        </trans-unit>
        <trans-unit id="9150896df8944dbbb2d645bc78167fd76df1dc80" translate="yes" xml:space="preserve">
          <source>Hijack detaches the ServerConn and returns the underlying connection as well as the read-side bufio which may have some left over data. Hijack may be called before Read has signaled the end of the keep-alive logic. The user should not call Hijack while Read or Write is in progress.</source>
          <target state="translated">Hijack отсоединяет ServerConn и возвращает базовое соединение,а также буфио на стороне чтения,в котором могут остаться некоторые данные.Перехват может быть вызван до того,как Read подаст сигнал об окончании логики keep-alive.Пользователь не должен вызывать Hijack во время чтения или записи.</target>
        </trans-unit>
        <trans-unit id="4a56321e103f0a1a522b694db3cb8d2d733e26fd" translate="yes" xml:space="preserve">
          <source>Hijacker</source>
          <target state="translated">Hijacker</target>
        </trans-unit>
        <trans-unit id="162450ef640a1216b7486b356d2e0daf7f97ce1d" translate="yes" xml:space="preserve">
          <source>Hostname returns the host name reported by the kernel.</source>
          <target state="translated">Имя хоста возвращает имя хоста,сообщенное ядром.</target>
        </trans-unit>
        <trans-unit id="96c776e02774d643d6c9b2543ae4ea531e374ca6" translate="yes" xml:space="preserve">
          <source>Hostname returns u.Host, stripping any valid port number if present.</source>
          <target state="translated">Имя хоста возвращает u.Host,удаляя любой действительный номер порта,если он присутствует.</target>
        </trans-unit>
        <trans-unit id="c10a91f09a43d36b8c063665239759dddfc07545" translate="yes" xml:space="preserve">
          <source>HostnameError results when the set of authorized names doesn't match the requested name.</source>
          <target state="translated">HostnameError приводит к ошибке,когда набор авторизованных имен не совпадает с запрошенным именем.</target>
        </trans-unit>
        <trans-unit id="a732fe7ae23ec635b26f3cda289c15cbca4f3d8c" translate="yes" xml:space="preserve">
          <source>Hour returns the hour within the day specified by t, in the range [0, 23].</source>
          <target state="translated">Час возвращает час в течение дня,указанного t,в диапазоне [0,23].</target>
        </trans-unit>
        <trans-unit id="316afefe22138dc95ee9f3b2f4bc4164e8b8424e" translate="yes" xml:space="preserve">
          <source>Hours returns the duration as a floating point number of hours.</source>
          <target state="translated">Часы возвращают продолжительность как количество часов с плавающей запятой.</target>
        </trans-unit>
        <trans-unit id="29032d83edd3b2c57e81fe35f7063e01de42a614" translate="yes" xml:space="preserve">
          <source>However, there can be multiple leftmost-longest matches, with different submatch choices, and here this package diverges from POSIX. Among the possible leftmost-longest matches, this package chooses the one that a backtracking search would have found first, while POSIX specifies that the match be chosen to maximize the length of the first subexpression, then the second, and so on from left to right. The POSIX rule is computationally prohibitive and not even well-defined. See &lt;a href=&quot;https://swtch.com/~rsc/regexp/regexp2.html#posix&quot;&gt;https://swtch.com/~rsc/regexp/regexp2.html#posix&lt;/a&gt; for details.</source>
          <target state="translated">Однако может быть несколько совпадений крайнего левого и самого длинного с разными вариантами подсовпадений, и здесь этот пакет отличается от POSIX. Среди возможных наиболее левых совпадений этот пакет выбирает то, которое поиск с возвратом нашел бы первым, в то время как POSIX указывает, что совпадение должно быть выбрано, чтобы максимизировать длину первого подвыражения, затем второго и так далее слева направо. , Правило POSIX является недопустимым с точки зрения вычислений и даже не определено четко. Подробнее см. &lt;a href=&quot;https://swtch.com/~rsc/regexp/regexp2.html#posix&quot;&gt;Https://swtch.com/~rsc/regexp/regexp2.html#posix&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="40708df18a19eb4cd04fce64de3e8c9f00288cb2" translate="yes" xml:space="preserve">
          <source>However, to aid in formatting template source code, if an action's left delimiter (by default &quot;{{&quot;) is followed immediately by a minus sign and ASCII space character (&quot;{{- &quot;), all trailing white space is trimmed from the immediately preceding text. Similarly, if the right delimiter (&quot;}}&quot;) is preceded by a space and minus sign (&quot; -}}&quot;), all leading white space is trimmed from the immediately following text. In these trim markers, the ASCII space must be present; &quot;{{-3}}&quot; parses as an action containing the number -3.</source>
          <target state="translated">Однако,для облегчения форматирования исходного кода шаблона,если за левым разделителем действия (по умолчанию &quot;{{&quot;)сразу следует знак минуса и символ пробела ASCII (&quot;{{-&quot;)),то всё отстающее белое пространство обрезается от непосредственно предшествующего текста.Аналогично,если правому разделителю (&quot;}}&quot;)предшествует знак пробела и знак минуса (&quot; -}}&quot;),то весь ведущий белый пробел обрезается из непосредственно следующего текста.В этих обрезных маркерах должен присутствовать пробел ASCII;&quot;{{-3}}&quot; рассматривается как действие,содержащее число -3.</target>
        </trans-unit>
        <trans-unit id="865c5231eb19f03389b3d03b11a5fede2d02038c" translate="yes" xml:space="preserve">
          <source>However, to aid in formatting template source code, if an action's left delimiter (by default &quot;{{&quot;) is followed immediately by a minus sign and white space, all trailing white space is trimmed from the immediately preceding text. Similarly, if the right delimiter (&quot;}}&quot;) is preceded by white space and a minus sign, all leading white space is trimmed from the immediately following text. In these trim markers, the white space must be present: &quot;{{- 3}}&quot; is like &quot;{{3}}&quot; but trims the immediately preceding text, while &quot;{{-3}}&quot; parses as an action containing the number -3.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4e4742177e63cc124605c711f8542e79a9c655e" translate="yes" xml:space="preserve">
          <source>However, when printing a byte slice with a string-like verb (%s %q %x %X), it is treated identically to a string, as a single item.</source>
          <target state="translated">Однако при печати байтового среза со строковым глаголом (%s %q %x %X),он обрабатывается идентично строке,как один элемент.</target>
        </trans-unit>
        <trans-unit id="5c4cbffa6231f3b3c2514644d0fee825e224c80d" translate="yes" xml:space="preserve">
          <source>Hypot returns Sqrt(p*p + q*q), taking care to avoid unnecessary overflow and underflow.</source>
          <target state="translated">Hypot возвращает Sqrt(p*p+q*q),заботясь о том,чтобы избежать ненужного переполнения и недополнения.</target>
        </trans-unit>
        <trans-unit id="576b7847aead683e23b77c003ff6f222a841ef25" translate="yes" xml:space="preserve">
          <source>IEEETable is the table for the IEEE polynomial.</source>
          <target state="translated">IEEETable это таблица для IEEE полинома.</target>
        </trans-unit>
        <trans-unit id="a220db6c90383cf3092dacd6831c2890463d8ced" translate="yes" xml:space="preserve">
          <source>IMAGE_DIRECTORY_ENTRY constants</source>
          <target state="translated">IMAGE_DIRECTORY_ENTRY константы</target>
        </trans-unit>
        <trans-unit id="f585c9fe77a34e4b203ca7586560b165b3fa9e06" translate="yes" xml:space="preserve">
          <source>IP address lengths (bytes).</source>
          <target state="translated">Длина IP-адреса (байты).</target>
        </trans-unit>
        <trans-unit id="8f3823940310cc4dda7efac459317d31719ee534" translate="yes" xml:space="preserve">
          <source>IP addresses can be optionally enclosed in square brackets and are checked against the IPAddresses field. Other names are checked case insensitively against the DNSNames field. If the names are valid hostnames, the certificate fields can have a wildcard as the left-most label.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e746cf97286466a3ee7a6da22134f5658e5d9835" translate="yes" xml:space="preserve">
          <source>IP.DefaultMask</source>
          <target state="translated">IP.DefaultMask</target>
        </trans-unit>
        <trans-unit id="11cb3659b8e0ce7581cbb847a5c82b1c9f0fd371" translate="yes" xml:space="preserve">
          <source>IP.Mask</source>
          <target state="translated">IP.Mask</target>
        </trans-unit>
        <trans-unit id="afa88b5842f11425f491e338d7ab921fd1ba5273" translate="yes" xml:space="preserve">
          <source>IPAddr represents the address of an IP end point.</source>
          <target state="translated">IPAddr представляет собой адрес конечной точки IP.</target>
        </trans-unit>
        <trans-unit id="62bf2467f82c0177288446c3c53fcfe1388fdbf4" translate="yes" xml:space="preserve">
          <source>IPConn is the implementation of the Conn and PacketConn interfaces for IP network connections.</source>
          <target state="translated">IPConn-это реализация интерфейсов Conn и PacketConn для сетевых IP-соединений.</target>
        </trans-unit>
        <trans-unit id="f8a4e52fe170a6b87d8e8f324c9e46497e3e1a1e" translate="yes" xml:space="preserve">
          <source>IPv4</source>
          <target state="translated">IPv4</target>
        </trans-unit>
        <trans-unit id="01eafbb77fe2e5da4ec4f2fa2166e61bdbf17fda" translate="yes" xml:space="preserve">
          <source>IPv4 returns the IP address (in 16-byte form) of the IPv4 address a.b.c.d.</source>
          <target state="translated">IPv4 возвращает IP-адрес (в 16-байтовой форме)адреса IPv4 a.b.c.d.</target>
        </trans-unit>
        <trans-unit id="3e2065fb2c469f55091e83e0c17ec6c33b2ade3a" translate="yes" xml:space="preserve">
          <source>IPv4Mask</source>
          <target state="translated">IPv4Mask</target>
        </trans-unit>
        <trans-unit id="d0818e19fd482dbfdc092a8f03eecab69f4f02c6" translate="yes" xml:space="preserve">
          <source>IPv4Mask returns the IP mask (in 4-byte form) of the IPv4 mask a.b.c.d.</source>
          <target state="translated">IPv4Mask возвращает IP маску (в 4-байтовой форме)маски IPv4 a.b.c.d.</target>
        </trans-unit>
        <trans-unit id="84f775d13ea13d9914f862669240b386b5b2ce40" translate="yes" xml:space="preserve">
          <source>ISOWeek returns the ISO 8601 year and week number in which t occurs. Week ranges from 1 to 53. Jan 01 to Jan 03 of year n might belong to week 52 or 53 of year n-1, and Dec 29 to Dec 31 might belong to week 1 of year n+1.</source>
          <target state="translated">ISOWeek возвращает номер года и недели по ISO 8601,в котором встречается t.Неделя варьируется от 1 до 53.С 01 января по 03 января года n может относиться к 52-й или 53-й неделям года n-1,а с 29 декабря по 31 декабря-к 1-й неделе года n+1.</target>
        </trans-unit>
        <trans-unit id="08d6764cba419802272bb09d455c908144b957aa" translate="yes" xml:space="preserve">
          <source>Id is a wrapper for Id(obj.Pkg(), obj.Name()).</source>
          <target state="translated">Id-это обертка для Id(obj.Pkg(),obj.Name()).</target>
        </trans-unit>
        <trans-unit id="1d68ea4276c501cd9a850a1820a4a4d86fcccd10" translate="yes" xml:space="preserve">
          <source>Id returns name if it is exported, otherwise it returns the name qualified with the package path.</source>
          <target state="translated">Идентификатор возвращает имя,если оно экспортировано,в противном случае он возвращает имя,соответствующее пути к пакету.</target>
        </trans-unit>
        <trans-unit id="fa08cb5f856950ffd31e99879394c8d2ecd78b73" translate="yes" xml:space="preserve">
          <source>Identical reports whether x and y are identical types. Receivers of Signature types are ignored.</source>
          <target state="translated">Идентичные отчеты о том,являются ли x и y идентичными типами.Приемники типов подписей игнорируются.</target>
        </trans-unit>
        <trans-unit id="62582ea142e0c589620d5bd10a3675dc62d150bc" translate="yes" xml:space="preserve">
          <source>IdenticalIgnoreTags reports whether x and y are identical types if tags are ignored. Receivers of Signature types are ignored.</source>
          <target state="translated">IdenticalIgnoreTags сообщает,являются ли x и y идентичными типами,если теги игнорируются.Приемники типов сигнатур игнорируются.</target>
        </trans-unit>
        <trans-unit id="1b283807cc15b11d0882e9fd847033d20b983bd2" translate="yes" xml:space="preserve">
          <source>IdentifierNode holds an identifier.</source>
          <target state="translated">IdentifierNode содержит идентификатор.</target>
        </trans-unit>
        <trans-unit id="e3f7a148cc891203b5f7d36d2d9e45cad70d628a" translate="yes" xml:space="preserve">
          <source>If 'All' is present, the routine matches successive non-overlapping matches of the entire expression. Empty matches abutting a preceding match are ignored. The return value is a slice containing the successive return values of the corresponding non-'All' routine. These routines take an extra integer argument, n. If n &amp;gt;= 0, the function returns at most n matches/submatches; otherwise, it returns all of them.</source>
          <target state="translated">Если присутствует &amp;laquo;Все&amp;raquo;, процедура сопоставляет последовательные неперекрывающиеся совпадения всего выражения. Пустые совпадения, примыкающие к предыдущему, игнорируются. Возвращаемое значение - это фрагмент, содержащий последовательные возвращаемые значения соответствующей подпрограммы, отличной от &amp;laquo;Все&amp;raquo;. Эти процедуры принимают дополнительный целочисленный аргумент n. Если n&amp;gt; = 0, функция возвращает не более n совпадений / под совпадений; в противном случае он возвращает их все.</target>
        </trans-unit>
        <trans-unit id="4bc5ea7c2a0ba24905139043c1e06d713fc4b624" translate="yes" xml:space="preserve">
          <source>If 'Index' is present, matches and submatches are identified by byte index pairs within the input string: result[2*n:2*n+1] identifies the indexes of the nth submatch. The pair for n==0 identifies the match of the entire expression. If 'Index' is not present, the match is identified by the text of the match/submatch. If an index is negative or text is nil, it means that subexpression did not match any string in the input. For 'String' versions an empty string means either no match or an empty match.</source>
          <target state="translated">Если присутствует 'Index',то совпадения и подсоответствия идентифицируются по парам индексов байтов во входной строке:result[2*n:2*n+1]идентифицирует индексы n-го подмножества.Пара для n==0 идентифицирует соответствие всего выражения.Если 'Index' отсутствует,то соответствие идентифицируется по тексту совпадения/подпадения.Если индекс отрицательный или текст нулевой,это означает,что подвыражение не совпало ни с одной строкой во входном выражении.Для версий 'String' пустая строка означает либо отсутствие совпадения,либо пустое совпадение.</target>
        </trans-unit>
        <trans-unit id="750f20e67d15d8b15512065e634f8a04cd24649d" translate="yes" xml:space="preserve">
          <source>If 'String' is present, the argument is a string; otherwise it is a slice of bytes; return values are adjusted as appropriate.</source>
          <target state="translated">Если присутствует 'String',то аргумент-строка;в противном случае-кусок байта;возвращаемые значения настраиваются соответствующим образом.</target>
        </trans-unit>
        <trans-unit id="6b5422b81678b9d8d259a31067e6668262dc0a15" translate="yes" xml:space="preserve">
          <source>If 'Submatch' is present, the return value is a slice identifying the successive submatches of the expression. Submatches are matches of parenthesized subexpressions (also known as capturing groups) within the regular expression, numbered from left to right in order of opening parenthesis. Submatch 0 is the match of the entire expression, submatch 1 the match of the first parenthesized subexpression, and so on.</source>
          <target state="translated">Если присутствует 'Подсоответствие',возвращаемое значение представляет собой срез,идентифицирующий последовательные подсоответствия выражения.Подсоответствия-это совпадения подвыражений в скобках (также известных как группы захвата)внутри регулярного выражения,пронумерованные слева направо в порядке открывающей скобки.Подсоответствие 0-это совпадение всего выражения,подсоответствие 1-совпадение первого подвыражения в скобках и так далее.</target>
        </trans-unit>
        <trans-unit id="c8e129ec8b814ed3ea9bfb24aed18824a3379050" translate="yes" xml:space="preserve">
          <source>If Body is present, Content-Length is &amp;lt;= 0 and TransferEncoding hasn't been set to &quot;identity&quot;, Write adds &quot;Transfer-Encoding: chunked&quot; to the header. Body is closed after it is sent.</source>
          <target state="translated">Если присутствует Body, Content-Length &amp;lt;= 0 и TransferEncoding не установлен на &amp;laquo;identity&amp;raquo;, Write добавляет в заголовок &amp;laquo;Transfer-Encoding: chunked&amp;raquo;. После отправки тело закрывается.</target>
        </trans-unit>
        <trans-unit id="a4c660d2d836ce5011f39f208170601c14fc3f84" translate="yes" xml:space="preserve">
          <source>If CheckNamedValue returns ErrRemoveArgument, the NamedValue will not be included in the final query arguments. This may be used to pass special options to the query itself.</source>
          <target state="translated">Если CheckNamedValue возвращает ErrRemoveArgument,то значение NamedValue не будет включено в аргументы финального запроса.Это может быть использовано для передачи специальных опций самому запросу.</target>
        </trans-unit>
        <trans-unit id="16a03bedfc442181d888e7b8ec8eee1e7e8562bb" translate="yes" xml:space="preserve">
          <source>If Conn.Ping returns ErrBadConn, DB.Ping and DB.PingContext will remove the Conn from pool.</source>
          <target state="translated">Если Conn.Ping вернет ErrBadConn,DB.Ping и DB.PingContext удалит Conn из пула.</target>
        </trans-unit>
        <trans-unit id="9bf5fb8d1ebbb6dc425efaa4065a072560c9aaa0" translate="yes" xml:space="preserve">
          <source>If DIR is a directory listed in the Go path, a package with source in DIR/src/foo/bar can be imported as &quot;foo/bar&quot; and has its compiled form installed to &quot;DIR/pkg/GOOS_GOARCH/foo/bar.a&quot; (or, for gccgo, &quot;DIR/pkg/gccgo/foo/libbar.a&quot;).</source>
          <target state="translated">Если DIR-это каталог,перечисленный в пути Go,то пакет с исходниками в DIR/src/foo/bar можно импортировать как &quot;foo/bar&quot; и установить его скомпилированную форму в &quot;DIR/pkg/GOOS_GOARCH/foo/bar.a&quot; (или,для gccgo,&quot;DIR/pkg/gccgo/foo/libbar.a&quot;).</target>
        </trans-unit>
        <trans-unit id="626d82422a444f8260197f6a255b844b957560c9" translate="yes" xml:space="preserve">
          <source>If Dir is SelectDefault, the case represents a default case. Chan and Send must be zero Values.</source>
          <target state="translated">Если Dir имеет значение SelectDefault,регистр представляет собой регистр по умолчанию.Chan и Send должны быть нулевыми Значениями.</target>
        </trans-unit>
        <trans-unit id="b64c8a9a4dd6bc23186cb39d29f2d6a941b37467" translate="yes" xml:space="preserve">
          <source>If Dir is SelectRecv, the case represents a receive operation. Normally Chan's underlying value must be a channel and Send must be a zero Value. If Chan is a zero Value, then the case is ignored, but Send must still be a zero Value. When a receive operation is selected, the received Value is returned by Select.</source>
          <target state="translated">Если Dir-это SelectRecv,регистр представляет собой операцию приема.Обычно базовым значением Chan должен быть канал,а Send-нулевое значение.Если Chan является нулевым значением,то случай игнорируется,но Send все равно должна быть нулевым значением.Когда операция приема выбрана,полученное значение возвращается с помощью Select.</target>
        </trans-unit>
        <trans-unit id="fc3241471000ca543780e2776c12ce2c0f98b518" translate="yes" xml:space="preserve">
          <source>If Dir is SelectSend, the case represents a send operation. Normally Chan's underlying value must be a channel, and Send's underlying value must be assignable to the channel's element type. As a special case, if Chan is a zero Value, then the case is ignored, and the field Send will also be ignored and may be either zero or non-zero.</source>
          <target state="translated">Если Dir-это SelectSend,регистр представляет собой операцию отправки.Обычно базовая стоимость Chan должна быть каналом,а базовая стоимость Send должна быть присвоена типу элемента канала.В особом случае,если Chan является нулевым значением,то случай игнорируется,а поле Send также игнорируется и может быть как нулевым,так и ненулевым.</target>
        </trans-unit>
        <trans-unit id="3e5a9a392b54a0f9dbcf70e078d697829fda46e7" translate="yes" xml:space="preserve">
          <source>If Discard skips fewer than n bytes, it also returns an error. If 0 &amp;lt;= n &amp;lt;= b.Buffered(), Discard is guaranteed to succeed without reading from the underlying io.Reader.</source>
          <target state="translated">Если Discard пропускает менее n байтов, он также возвращает ошибку. Если 0 &amp;lt;= n &amp;lt;= b.Buffered (), Discard гарантированно завершится успешно без чтения из нижележащего io.Reader.</target>
        </trans-unit>
        <trans-unit id="5388f313bdebc1cd743073994620f637168dfccb" translate="yes" xml:space="preserve">
          <source>If DiscardEmptyColumns is set, empty columns that are terminated entirely by vertical (or &quot;soft&quot;) tabs are discarded. Columns terminated by horizontal (or &quot;hard&quot;) tabs are not affected by this flag.</source>
          <target state="translated">Если установлен параметр DiscardEmptyColumns,пустые столбцы,которые заканчиваются полностью вертикальными (или &quot;мягкими&quot;)вкладками,отбрасываются.На столбцы,заканчивающиеся горизонтальными (или &quot;жесткими&quot;)вкладками,этот флаг не действует.</target>
        </trans-unit>
        <trans-unit id="c9deb8e1a0cfa1d1825dc49ade2afa7eec850bd3" translate="yes" xml:space="preserve">
          <source>If ErrSkip is returned the column converter error checking path is used for the argument. Drivers may wish to return ErrSkip after they have exhausted their own special cases.</source>
          <target state="translated">Если возвращается ErrSkip,то для аргумента используется путь проверки ошибок преобразователя колонок.Драйверы могут захотеть вернуть ErrSkip после того,как они исчерпали свои специальные случаи.</target>
        </trans-unit>
        <trans-unit id="acb8bfb04c68aa06cf649fa65fe83fd0ec6ad99b" translate="yes" xml:space="preserve">
          <source>If Get would otherwise return nil and p.New is non-nil, Get returns the result of calling p.New.</source>
          <target state="translated">Если Get в противном случае вернет nil,а p.New-нет,то Get возвращает результат вызова p.New.</target>
        </trans-unit>
        <trans-unit id="cbb35dd622fd4fc40d747d7fe8a39806c85598b4" translate="yes" xml:space="preserve">
          <source>If MaxIdleConns is greater than 0 and the new MaxOpenConns is less than MaxIdleConns, then MaxIdleConns will be reduced to match the new MaxOpenConns limit.</source>
          <target state="translated">Если MaxIdleConns больше 0 и новый MaxOpenConns меньше,чем MaxIdleConns,то MaxIdleConns будет уменьшен до нового лимита MaxOpenConns.</target>
        </trans-unit>
        <trans-unit id="0566ce3b75e32de588395cc9db25a53062d79613" translate="yes" xml:space="preserve">
          <source>If MaxOpenConns is greater than 0 but less than the new MaxIdleConns, then the new MaxIdleConns will be reduced to match the MaxOpenConns limit.</source>
          <target state="translated">Если MaxOpenConns больше 0,но меньше,чем новый MaxIdleConns,то новые MaxIdleConns будут уменьшены до лимита MaxOpenConns.</target>
        </trans-unit>
        <trans-unit id="ba59fc6bf9458413409db5ff0b9045c64e756bcb" translate="yes" xml:space="preserve">
          <source>If ReadAt is reading from an input source with a seek offset, ReadAt should not affect nor be affected by the underlying seek offset.</source>
          <target state="translated">Если ReadAt считывается с источника входного сигнала со смещением поиска,на ReadAt не должно влиять смещение поиска,лежащее в основе.</target>
        </trans-unit>
        <trans-unit id="cc3d6766541295fe523ec22933263aa9a06c4657" translate="yes" xml:space="preserve">
          <source>If ServeHTTP panics, the server (the caller of ServeHTTP) assumes that the effect of the panic was isolated to the active request. It recovers the panic, logs a stack trace to the server error log, and either closes the network connection or sends an HTTP/2 RST_STREAM, depending on the HTTP protocol. To abort a handler so the client sees an interrupted response but the server doesn't log an error, panic with the value ErrAbortHandler.</source>
          <target state="translated">Если ServeHTTP паникует,то сервер (абонент ServeHTTP)предполагает,что эффект паники был изолирован на активный запрос.Он восстанавливает панику,регистрирует трассировку стека в журнал ошибок сервера и либо закрывает сетевое соединение,либо посылает HTTP/2 RST_STREAM,в зависимости от протокола HTTP.Чтобы прервать обработчик так,что клиент видит прерванный ответ,но сервер не регистрирует ошибку,паникует со значением ErrAbortHandler.</target>
        </trans-unit>
        <trans-unit id="c9df130ceb3ae952587ab322cca16f6a65e29d84" translate="yes" xml:space="preserve">
          <source>If Start returns successfully, the c.Process field will be set.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eed6a51dc00d92ad58016afb39e08c5356592608" translate="yes" xml:space="preserve">
          <source>If SubjectKeyId from template is empty and the template is a CA, SubjectKeyId will be generated from the hash of the public key.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03b743a2bf24014291b619ac4052a90413c15a39" translate="yes" xml:space="preserve">
          <source>If TestFS finds any misbehaviors, it returns an error reporting all of them. The error text spans multiple lines, one per detected misbehavior.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15b3f0511e9fa111d5eb85347847012bfb679dba" translate="yes" xml:space="preserve">
          <source>If TestReader finds any misbehaviors, it returns an error reporting them. The error text may span multiple lines.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c30ed6f837b3e7a9558eb599fa8c56e0e97063b" translate="yes" xml:space="preserve">
          <source>If Times t and u both contain monotonic clock readings, the operations t.After(u), t.Before(u), t.Equal(u), and t.Sub(u) are carried out using the monotonic clock readings alone, ignoring the wall clock readings. If either t or u contains no monotonic clock reading, these operations fall back to using the wall clock readings.</source>
          <target state="translated">Если Times t и u оба содержат показания монотонных часов,то операции t.After(u),t.Before(u),t.Equal(u)и t.Sub(u)выполняются с использованием одних только показаний монотонных часов,игнорируя показания настенных часов.Если t или u не содержат монотонных показаний часов,эти операции возвращаются к использованию показаний настенных часов.</target>
        </trans-unit>
        <trans-unit id="bc4d8baa4dbb3f1a94db59ec9aa34f357782809d" translate="yes" xml:space="preserve">
          <source>If Unmarshal encounters a field type that implements the Unmarshaler interface, Unmarshal calls its UnmarshalXML method to produce the value from the XML element. Otherwise, if the value implements encoding.TextUnmarshaler, Unmarshal calls that value's UnmarshalText method.</source>
          <target state="translated">Если Unmarshal встречает тип поля,реализующий интерфейс Unmarshaler,Unmarshal вызывает свой метод UnmarshalXML для получения значения из XML-элемента.В противном случае,если значение реализует кодировку.TextUnmarshaler,Unmarshal вызывает метод UnmarshalText этого значения.</target>
        </trans-unit>
        <trans-unit id="e7b1cef9234b9022f80f99b102d2ffde95658f55" translate="yes" xml:space="preserve">
          <source>If UseCRLF is true, the Writer ends each output line with \r\n instead of \n.</source>
          <target state="translated">Если значение параметра UseCRLF равно true,то в конце каждой выходной строки будет \r\n,а не \n.</target>
        </trans-unit>
        <trans-unit id="24f02297c63afdceb90dae9a889e378f8f5dc1c7" translate="yes" xml:space="preserve">
          <source>If WriteAt is writing to a destination with a seek offset, WriteAt should not affect nor be affected by the underlying seek offset.</source>
          <target state="translated">Если WriteAt пишет в пункт назначения со смещением поиска,то WriteAt не должен влиять и не должен быть затронут смещением поиска.</target>
        </trans-unit>
        <trans-unit id="93383c5ea1d8fe26c2febc3914b065857796c533" translate="yes" xml:space="preserve">
          <source>If a != 0 and b == 0, GCD sets z = |a|, x = sign(a) * 1, y = 0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01ec25dfc6204eb6897de5935b9779223b3cad13" translate="yes" xml:space="preserve">
          <source>If a &quot;range&quot; action initializes a variable, the variable is set to the successive elements of the iteration. Also, a &quot;range&quot; may declare two variables, separated by a comma:</source>
          <target state="translated">Если действие &quot;диапазон&quot; инициализирует переменную,то она устанавливается в последовательные элементы итерации.Кроме того,&quot;диапазон&quot; может объявить две переменные,разделенные запятой:</target>
        </trans-unit>
        <trans-unit id="630b98d4876b039ef4109d3fcef4537345f5b1cb" translate="yes" xml:space="preserve">
          <source>If a == 0 and b != 0, GCD sets z = |b|, x = 0, y = sign(b) * 1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64d609c4002ae17b5c018b505462be8ebae980f7" translate="yes" xml:space="preserve">
          <source>If a == b == 0, GCD sets z = x = y = 0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58d444ec12c7fa5d6e872ab50772870b5a393d01" translate="yes" xml:space="preserve">
          <source>If a Conn does not implement ExecerContext, the sql package's DB.Exec will fall back to Execer; if the Conn does not implement Execer either, DB.Exec will first prepare a query, execute the statement, and then close the statement.</source>
          <target state="translated">Если Conn не реализует ExecerContext,DB.Exec sql пакета возвращается обратно к Execer;если Conn также не реализует Execer,DB.Exec сначала подготовит запрос,выполнит оператор,а затем закроет оператор.</target>
        </trans-unit>
        <trans-unit id="44e6dfb38005e87694379cf1c0216f95562e9cfb" translate="yes" xml:space="preserve">
          <source>If a Conn does not implement Pinger, the sql package's DB.Ping and DB.PingContext will check if there is at least one Conn available.</source>
          <target state="translated">Если Conn не реализует Pinger,пакет sql DB.Ping и DB.PingContext проверит,есть ли хотя бы один доступный Conn.</target>
        </trans-unit>
        <trans-unit id="21128809a4ab46817c40f8b5969689593dcd6f72" translate="yes" xml:space="preserve">
          <source>If a Conn does not implement QueryerContext, the sql package's DB.Query will fall back to Queryer; if the Conn does not implement Queryer either, DB.Query will first prepare a query, execute the statement, and then close the statement.</source>
          <target state="translated">Если коннектор не реализует QueryerContext,sql-пакет DB.Query возвращается обратно в Queryer;если коннектор также не реализует Queryer,DB.Query сначала подготавливает запрос,выполняет оператор,а затем закрывает оператор.</target>
        </trans-unit>
        <trans-unit id="45c4be212f44031bede2b5276a4a3589a0dc2b98" translate="yes" xml:space="preserve">
          <source>If a Conn implements neither ExecerContext nor Execer, the sql package's DB.Exec will first prepare a query, execute the statement, and then close the statement.</source>
          <target state="translated">Если Conn не реализует ни ExecerContext,ни Execer,то DB.Exec sql пакета сначала подготовит запрос,выполнит оператор,а затем закроет оператор.</target>
        </trans-unit>
        <trans-unit id="1cb5d6dd6f4d516d1ae37935040abf369ba105f8" translate="yes" xml:space="preserve">
          <source>If a Conn implements neither QueryerContext nor Queryer, the sql package's DB.Query will first prepare a query, execute the statement, and then close the statement.</source>
          <target state="translated">Если Conn не реализует ни QueryerContext,ни Queryer,то DB.Query пакета sql сначала подготовит запрос,выполнит оператор,а затем закроет оператор.</target>
        </trans-unit>
        <trans-unit id="71c0f29e06c175a2adb537fdf47269746a601d0d" translate="yes" xml:space="preserve">
          <source>If a Driver implements DriverContext, then sql.DB will call OpenConnector to obtain a Connector and then invoke that Connector's Conn method to obtain each needed connection, instead of invoking the Driver's Open method for each connection. The two-step sequence allows drivers to parse the name just once and also provides access to per-Conn contexts.</source>
          <target state="translated">Если драйвер реализует DriverContext,то sql.DB будет вызывать OpenConnector для получения коннектора,а затем вызывать метод Connector's Connector для получения каждого нужного соединения,вместо того,чтобы вызывать метод Driver's Open для каждого соединения.Двухступенчатая последовательность позволяет драйверам разобрать имя только один раз,а также предоставляет доступ к контекстам для каждого-Conn.</target>
        </trans-unit>
        <trans-unit id="56a7870f9afac036630f51a12d5ce02b7331bec6" translate="yes" xml:space="preserve">
          <source>If a Driver implements DriverContext, then sql.DB will call OpenConnector to obtain a Connector and then invoke that Connector's Connect method to obtain each needed connection, instead of invoking the Driver's Open method for each connection. The two-step sequence allows drivers to parse the name just once and also provides access to per-Conn contexts.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="232b341436c8f9f54c10a5dba1cf92c214798814" translate="yes" xml:space="preserve">
          <source>If a JSON value is not appropriate for a given target type, or if a JSON number overflows the target type, Unmarshal skips that field and completes the unmarshaling as best it can. If no more serious errors are encountered, Unmarshal returns an UnmarshalTypeError describing the earliest such error. In any case, it's not guaranteed that all the remaining fields following the problematic one will be unmarshaled into the target object.</source>
          <target state="translated">Если JSON-значение не подходит для заданного типа цели,или если JSON-значение перекрывает тип цели,Unmarshal пропускает это поле и завершает unmarshaling как можно лучше.Если более серьезных ошибок нет,Unmarshal возвращает UnmarshalTypeError,описывающую самую раннюю такую ошибку.В любом случае,не гарантируется,что все остальные поля,следующие за проблемным,будут размартированы в целевой объект.</target>
        </trans-unit>
        <trans-unit id="07bd09bc1ed04a73b33dd796fe781c9034c95572" translate="yes" xml:space="preserve">
          <source>If a Stmt is prepared on a Tx or Conn, it will be bound to a single underlying connection forever. If the Tx or Conn closes, the Stmt will become unusable and all operations will return an error. If a Stmt is prepared on a DB, it will remain usable for the lifetime of the DB. When the Stmt needs to execute on a new underlying connection, it will prepare itself on the new connection automatically.</source>
          <target state="translated">Если Stmt подготавливается на Tx или Conn,он будет навсегда привязан к одному базовому соединению.Если Tx или Conn закрывается,то Stmt становится непригодным для использования,и все операции возвращают ошибку.Если Stmt подготавливается на БД,то он останется пригодным для использования в течение всего срока службы БД.Когда Stmt необходимо выполнить при новом базовом соединении,он автоматически подготовится к новому соединению.</target>
        </trans-unit>
        <trans-unit id="3b80dd32b6041fa4ef2f09439544647455bd33ab" translate="yes" xml:space="preserve">
          <source>If a Value has an IsBoolFlag() bool method returning true, the command-line parser makes -name equivalent to -name=true rather than using the next command-line argument.</source>
          <target state="translated">Если значение имеет метод IsBoolFlag()bool,возвращающий true,парсер командной строки делает -name эквивалентным -name=true вместо использования следующего аргумента командной строки.</target>
        </trans-unit>
        <trans-unit id="1d651c7c470bed2709ac735baaeec98dda753ea4" translate="yes" xml:space="preserve">
          <source>If a Writer is configured to filter HTML, HTML tags and entities are passed through. The widths of tags and entities are assumed to be zero (tags) and one (entities) for formatting purposes.</source>
          <target state="translated">Если пишущее устройство настроено на фильтрацию HTML,то HTML-теги и сущности будут проходить через него.Ширина тегов и сущностей принимается равной нулю (теги)и одной (сущности)для целей форматирования.</target>
        </trans-unit>
        <trans-unit id="52438c4d80c78ea57962cd3af33f715085501ef6" translate="yes" xml:space="preserve">
          <source>If a benchmark needs some expensive setup before running, the timer may be reset:</source>
          <target state="translated">Если перед запуском бенчмарка необходимо выполнить дорогостоящую настройку,таймер может быть сброшен:</target>
        </trans-unit>
        <trans-unit id="d7727dcc2593fe8b30c299beed7e6a6b86f7e22b" translate="yes" xml:space="preserve">
          <source>If a benchmark needs to test performance in a parallel setting, it may use the RunParallel helper function; such benchmarks are intended to be used with the go test -cpu flag:</source>
          <target state="translated">Если бенчмарку необходимо проверить производительность в параллельной установке,он может использовать вспомогательную функцию RunParallel,такие бенчмарки предназначены для использования с флагом go test -cpu:</target>
        </trans-unit>
        <trans-unit id="a54ff063e15dbe9b378b4160c9280c7409b22dcb" translate="yes" xml:space="preserve">
          <source>If a dest argument has type *[]byte, Scan saves in that argument a copy of the corresponding data. The copy is owned by the caller and can be modified and held indefinitely. The copy can be avoided by using an argument of type *RawBytes instead; see the documentation for RawBytes for restrictions on its use.</source>
          <target state="translated">Если аргумент dest имеет тип *[]байт,то Scan сохраняет в этом аргументе копию соответствующих данных.Копия принадлежит вызывающему абоненту и может быть изменена и храниться неограниченное количество раз.Копию можно избежать,используя вместо этого аргумент типа *RawBytes;об ограничениях на его использование см.документацию по RawBytes.</target>
        </trans-unit>
        <trans-unit id="20186d29e290366ced58a159801092dd58a776e3" translate="yes" xml:space="preserve">
          <source>If a field uses a tag &quot;a&amp;gt;b&amp;gt;c&quot;, then the element c will be nested inside parent elements a and b. Fields that appear next to each other that name the same parent will be enclosed in one XML element.</source>
          <target state="translated">Если в поле используется тег &amp;laquo;a&amp;gt; b&amp;gt; c&amp;raquo;, то элемент c будет вложен внутри родительских элементов a и b. Поля, которые появляются рядом друг с другом и имеют имя одного и того же родителя, будут заключены в один элемент XML.</target>
        </trans-unit>
        <trans-unit id="9df6c8e2aa87346f45992618c6d030de25253b4a" translate="yes" xml:space="preserve">
          <source>If a file's name, after stripping the extension and a possible _test suffix, matches any of the following patterns:</source>
          <target state="translated">Если имя файла после удаления расширения и возможного суффикса _test совпадает с любым из следующих шаблонов:</target>
        </trans-unit>
        <trans-unit id="d6c46042317668db3b232f00f55a1ab61b108925" translate="yes" xml:space="preserve">
          <source>If a goroutine holds a RWMutex for reading and another goroutine might call Lock, no goroutine should expect to be able to acquire a read lock until the initial read lock is released. In particular, this prohibits recursive read locking. This is to ensure that the lock eventually becomes available; a blocked Lock call excludes new readers from acquiring the lock.</source>
          <target state="translated">Если горутин держит RWMutex для чтения и другой горутин может назвать Lock,ни один горутин не должен ожидать,что сможет получить блокировку на чтение до тех пор,пока не будет снята первоначальная блокировка на чтение.В частности,это запрещает блокировку рекурсивного чтения.Это делается для того,чтобы гарантировать,что блокировка станет доступной;заблокированный вызов блокировки исключает получение блокировки новыми читателями.</target>
        </trans-unit>
        <trans-unit id="09dcc94416ba2854a88e6fecddf19b900c4d3599" translate="yes" xml:space="preserve">
          <source>If a pattern names a directory, all files in the subtree rooted at that directory are embedded (recursively), except that files with names beginning with &amp;lsquo;.&amp;rsquo; or &amp;lsquo;_&amp;rsquo; are excluded. So the variable in the above example is almost equivalent to:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54b696ffb9e87ece68a0d432b267874461da7b0c" translate="yes" xml:space="preserve">
          <source>If a pointer argument must be converted to uintptr for use as an argument, that conversion must appear in the call expression itself:</source>
          <target state="translated">Если аргумент указателя должен быть преобразован в uintptr для использования в качестве аргумента,то это преобразование должно появиться в самом выражении вызова:</target>
        </trans-unit>
        <trans-unit id="ad57bb6494bba356a620db6dbc5f566b04a58730" translate="yes" xml:space="preserve">
          <source>If a program has already received a value from t.C, the timer is known to have expired and the channel drained, so t.Reset can be used directly. If a program has not yet received a value from t.C, however, the timer must be stopped and&amp;mdash;if Stop reports that the timer expired before being stopped&amp;mdash;the channel explicitly drained:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7be185efba59538fbd160cb8d8144506dd7c57d" translate="yes" xml:space="preserve">
          <source>If a subtree has been registered and a request is received naming the subtree root without its trailing slash, ServeMux redirects that request to the subtree root (adding the trailing slash). This behavior can be overridden with a separate registration for the path without the trailing slash. For example, registering &quot;/images/&quot; causes ServeMux to redirect a request for &quot;/images&quot; to &quot;/images/&quot;, unless &quot;/images&quot; has been registered separately.</source>
          <target state="translated">Если поддерево было зарегистрировано и запрос получил имя корня поддерева без его трейлинговой косынки,ServeMux перенаправляет этот запрос к корню поддерева (добавляя трейлинговую косую косую косую косую косую косую косую косую косую косую косую косую косую косую косую косую косую косую косую косую косую косую косую косую косую косую косую косую косую косую косую косую).Такое поведение можно переопределить отдельной регистрацией пути без трейлинговой косынки.Например,регистрация &quot;/images/&quot; заставляет ServeMux перенаправлять запрос на &quot;/images&quot; на &quot;/images/&quot;,если только &quot;/images&quot; не был зарегистрирован отдельно.</target>
        </trans-unit>
        <trans-unit id="104ed2563a73defc4faea46be899a20063ec818c" translate="yes" xml:space="preserve">
          <source>If a template with the given name already exists, the new HTML template will replace it. The existing template will be reset and disassociated with t.</source>
          <target state="translated">Если шаблон с заданным именем уже существует,то его заменит новый шаблон HTML.Существующий шаблон будет сброшен и разделен на t.</target>
        </trans-unit>
        <trans-unit id="463d47c06a7100464461b73a8101f7660c223839" translate="yes" xml:space="preserve">
          <source>If a value is passed to Encode and the type is not a struct (or pointer to struct, etc.), for simplicity of processing it is represented as a struct of one field. The only visible effect of this is to encode a zero byte after the value, just as after the last field of an encoded struct, so that the decode algorithm knows when the top-level value is complete.</source>
          <target state="translated">Если значение передано в кодировку и тип не является структурой (или указателем на структуру и т.д.),то для простоты обработки оно представлено в виде структуры одного поля.Единственный видимый эффект от этого-кодирование нулевого байта после значения,как и после последнего поля закодированной структуры,чтобы алгоритм декодирования знал,когда значение верхнего уровня будет завершено.</target>
        </trans-unit>
        <trans-unit id="d7d467cb048cd5252bcf40b068f20c227a6c5268" translate="yes" xml:space="preserve">
          <source>If an Error or String method triggers a panic when called by a print routine, the fmt package reformats the error message from the panic, decorating it with an indication that it came through the fmt package. For example, if a String method calls panic(&quot;bad&quot;), the resulting formatted message will look like</source>
          <target state="translated">Если метод Error или String вызывает панику при вызове рутины печати,пакет fmt переформатирует сообщение об ошибке,украсив его сообщением о том,что оно поступило через пакет fmt.Например,если метод Строка вызывает панику (&quot;bad&quot;),то полученное сообщение в формате будет выглядеть следующим образом:&quot;Ошибка&quot;.</target>
        </trans-unit>
        <trans-unit id="cd5fac95dd3eef4d9d21db69e86463f17f12f02f" translate="yes" xml:space="preserve">
          <source>If an X-Forwarded-For header already exists, the client IP is appended to the existing values. As a special case, if the header exists in the Request.Header map but has a nil value (such as when set by the Director func), the X-Forwarded-For header is not modified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3278ea50ebebf5ea6289948b73b15f204c549e9" translate="yes" xml:space="preserve">
          <source>If an argument has type *interface{}, Scan copies the value provided by the underlying driver without conversion. When scanning from a source value of type []byte to *interface{}, a copy of the slice is made and the caller owns the result.</source>
          <target state="translated">Если аргумент имеет тип *interface{},то Scan копирует значение,предоставленное лежащим в основе драйвером,без преобразования.При сканировании из исходного значения типа []байт в *интерфейс{}делается копия среза и вызывающему абоненту принадлежит результат.</target>
        </trans-unit>
        <trans-unit id="4329d9c7e154311e6c7d29f0986dc75dbddb37fd" translate="yes" xml:space="preserve">
          <source>If an attribute has both a namespace and a &quot;data-&quot; prefix, only the namespace will be removed when determining the context. For example</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c7525fb96a9e6dded8b4dd1c94198523c01a7a6" translate="yes" xml:space="preserve">
          <source>If an error occurs, Import returns a non-nil error and a non-nil *Package containing partial information.</source>
          <target state="translated">При возникновении ошибки Импорт возвращает нулевую ошибку и нулевой *пакет,содержащий частичную информацию.</target>
        </trans-unit>
        <trans-unit id="22a8988276a496bd99d453fc14d11bfb8cde90f0" translate="yes" xml:space="preserve">
          <source>If an invalid argument is given for a verb, such as providing a string to %d, the generated string will contain a description of the problem, as in these examples:</source>
          <target state="translated">Если для глагола задан неверный аргумент,например,предоставление строки в %d,то сгенерированная строка будет содержать описание проблемы,как в этих примерах:</target>
        </trans-unit>
        <trans-unit id="2f5f672edd948d125f1a8e2164d6570e08508e2a" translate="yes" xml:space="preserve">
          <source>If any of c.Stdin, c.Stdout or c.Stderr are not an *os.File, Wait also waits for the respective I/O loop copying to or from the process to complete.</source>
          <target state="translated">Если любой из c.Stdin,c.Stdout или c.Stderr не является *os.File,подождите также,пока не завершится копирование соответствующего цикла ввода/вывода в или из процесса.</target>
        </trans-unit>
        <trans-unit id="1f5bbd150ddfb48c91c7cfee2c61e666fa277d7d" translate="yes" xml:space="preserve">
          <source>If any of the first arguments implementing Scanner returns an error, that error will be wrapped in the returned error</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d9be5ef14b069fbd8a903d2f2a5d631da093ef0" translate="yes" xml:space="preserve">
          <source>If any patterns are invalid or have invalid matches, the build will fail.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2c348eae7d177d9986e66ac0dbb1fa9c1c8eff2" translate="yes" xml:space="preserve">
          <source>If b has invalid headers and cannot be encoded, EncodeToMemory returns nil. If it is important to report details about this error case, use Encode instead.</source>
          <target state="translated">Если b имеет недопустимые заголовки и не может быть закодирован,EncodeToMemory возвращает ноль.Если важно сообщить подробности об этой ошибке,используйте вместо нее Encode.</target>
        </trans-unit>
        <trans-unit id="81446ee41b4f44409d6c98445688e2c9dc448484" translate="yes" xml:space="preserve">
          <source>If base == 0, the base is implied by the string's prefix: base 2 for &quot;0b&quot;, base 8 for &quot;0&quot; or &quot;0o&quot;, base 16 for &quot;0x&quot;, and base 10 otherwise. Also, for base == 0 only, underscore characters are permitted per the Go integer literal syntax. If base is below 0, is 1, or is above 36, an error is returned.</source>
          <target state="translated">Если база ==0,то база подразумевается префиксом строки:база 2 для &quot;0b&quot;,база 8 для &quot;0&quot; или &quot;0o&quot;,база 16 для &quot;0x&quot; и база 10 в противном случае.Также,для базы ==0 разрешены символы подчеркивания в синтаксисе Go целого литерала.Если база меньше 0,больше 1 или больше 36,возвращается ошибка.</target>
        </trans-unit>
        <trans-unit id="ff7cc9932856849c823dcd514ebeb18a3facfdc3" translate="yes" xml:space="preserve">
          <source>If body is of type *bytes.Buffer, *bytes.Reader, or *strings.Reader, the returned request's ContentLength is set to its exact value (instead of -1), GetBody is populated (so 307 and 308 redirects can replay the body), and Body is set to NoBody if the ContentLength is 0.</source>
          <target state="translated">Если тело имеет тип *bytes.Buffer,*bytes.Reader или *strings.Reader,то возвращаемому запросу ContentLength задается точное значение (вместо -1),заполняется GetBody (таким образом 307 и 308 перенаправлений могут переиграть тело),а Body задается NoBody,если длина ContentLength равна 0.</target>
        </trans-unit>
        <trans-unit id="07cc785c40dfb93b351fa360eaf5c11b3a687a2b" translate="yes" xml:space="preserve">
          <source>If body is true, DumpRequest also returns the body. To do so, it consumes req.Body and then replaces it with a new io.ReadCloser that yields the same bytes. If DumpRequest returns an error, the state of req is undefined.</source>
          <target state="translated">Если тело верно,DumpRequest также возвращает тело.Для этого он потребляет req.body,а затем заменяет его новым io.ReadCloser,который дает те же самые байты.Если DumpRequest возвращает ошибку,состояние req не определено.</target>
        </trans-unit>
        <trans-unit id="f6ca8f7ad0c62b57590e8d1aff231f008b51eef8" translate="yes" xml:space="preserve">
          <source>If d &amp;lt;= 0, connections are not closed due to a connection's age.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a796f4a07dcd83603a859bc99893a18fb6d4d814" translate="yes" xml:space="preserve">
          <source>If d &amp;lt;= 0, connections are not closed due to a connection's idle time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8579022b484933fe4198bbc194c8a61565aa3ef" translate="yes" xml:space="preserve">
          <source>If d &amp;lt;= 0, connections are reused forever.</source>
          <target state="translated">Если d &amp;lt;= 0, соединения используются повторно навсегда.</target>
        </trans-unit>
        <trans-unit id="11054b794a9e66d49b745938ef3b656c43f6d39e" translate="yes" xml:space="preserve">
          <source>If data is a reflect.Value, the template applies to the concrete value that the reflect.Value holds, as in fmt.Print.</source>
          <target state="translated">Если данные являются reflect.Value,шаблон применяется к конкретному значению,которое содержит reflect.Value,как в fmt.Print.</target>
        </trans-unit>
        <trans-unit id="f83ceb0ced26c1c764536b5ff1b4fa15e74b62ce" translate="yes" xml:space="preserve">
          <source>If dst implements the ReaderFrom interface, the copy is implemented using it.</source>
          <target state="translated">Если dst реализует интерфейс ReaderFrom,то копия реализуется с его помощью.</target>
        </trans-unit>
        <trans-unit id="6833b17cfcf75e1b486e6c702d0520e85f9b86a2" translate="yes" xml:space="preserve">
          <source>If e.Unwrap() returns a non-nil error w, then we say that e wraps w.</source>
          <target state="translated">Если функция e.Unwrap()возвращает n-il error w,то мы говорим,что e wrapped w.</target>
        </trans-unit>
        <trans-unit id="f550577a407a74d547ca6987c46308a4d94fb754" translate="yes" xml:space="preserve">
          <source>If either src implements WriterTo or dst implements ReaderFrom, buf will not be used to perform the copy.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81786ec59b1db1b26068cac6cb2b8f77c848e02c" translate="yes" xml:space="preserve">
          <source>If enabled (the default), the Reader expects the input to be a sequence of individually gzipped data streams, each with its own header and trailer, ending at EOF. The effect is that the concatenation of a sequence of gzipped files is treated as equivalent to the gzip of the concatenation of the sequence. This is standard behavior for gzip readers.</source>
          <target state="translated">Если включено (по умолчанию),Считыватель ожидает,что вход будет последовательностью отдельных потоков данных gzipped,каждый из которых имеет свой собственный заголовок и трейлер,заканчивающийся на EOF.В результате этого последовательность gzipped-файлов рассматривается как эквивалент gzip последовательности.Это стандартное поведение для gzip-ридеров.</target>
        </trans-unit>
        <trans-unit id="eddf53f9cf1fca82486b2bf4ab21846e817aba06" translate="yes" xml:space="preserve">
          <source>If f calls Run, the result will be an estimate of running all its subbenchmarks that don't call Run in sequence in a single benchmark.</source>
          <target state="translated">Если f вызывает Run,то результатом будет оценка выполнения всех его подмножеств,которые не вызывают Run последовательно в одном бенчмарке.</target>
        </trans-unit>
        <trans-unit id="24aa535ef0441b2f9dcbe0e4bbff395ed6067287" translate="yes" xml:space="preserve">
          <source>If f depends on testing flags, then Init must be used to register those flags before calling Benchmark and before calling flag.Parse.</source>
          <target state="translated">Если f зависит от тестовых флагов,то Init должен быть использован для регистрации этих флагов перед вызовом Benchmark и перед вызовом flag.Parse.</target>
        </trans-unit>
        <trans-unit id="08b53793b968ecc1f35e8cac439169b17517c834" translate="yes" xml:space="preserve">
          <source>If f has a symbol version table, the returned Symbols will have initialized Version and Library fields.</source>
          <target state="translated">Если f имеет таблицу версий символов,то возвращаемые символы будут иметь инициализированные поля Версия и Библиотека.</target>
        </trans-unit>
        <trans-unit id="c8478592007a3bacbc2da6cefaa1115496c485ee" translate="yes" xml:space="preserve">
          <source>If f is a directory, the behavior of Seek varies by operating system; you can seek to the beginning of the directory on Unix-like operating systems, but not on Windows.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8c9bcc7ac7c9df2b87a2dbabc8c6ec7964d0a03" translate="yes" xml:space="preserve">
          <source>If f panics, Do considers it to have returned; future calls of Do return without calling f.</source>
          <target state="translated">Если f паникует,Do считает,что он вернулся;будущие звонки Do возвращаются без вызова f.</target>
        </trans-unit>
        <trans-unit id="cfdf3a788dfda0a29c8d0cf447a4cec60c0bc739" translate="yes" xml:space="preserve">
          <source>If file was opened with the O_APPEND flag, WriteAt returns an error.</source>
          <target state="translated">Если файл был открыт с флагом O_APPEND,WriteAt возвращает ошибку.</target>
        </trans-unit>
        <trans-unit id="53e78446111b9259010cce70ef1e63ae6396cc68" translate="yes" xml:space="preserve">
          <source>If filter != nil, only the files with fs.FileInfo entries passing through the filter (and ending in &quot;.go&quot;) are considered. The mode bits are passed to ParseFile unchanged. Position information is recorded in fset, which must not be nil.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="822b75e4d85498d0d8696aa19251040ab86e6e90" translate="yes" xml:space="preserve">
          <source>If filter != nil, only the files with os.FileInfo entries passing through the filter (and ending in &quot;.go&quot;) are considered. The mode bits are passed to ParseFile unchanged. Position information is recorded in fset, which must not be nil.</source>
          <target state="translated">Если фильтр !=nil,то учитываются только файлы с записями os.FileInfo,проходящие через фильтр (и заканчивающиеся на &quot;.go&quot;).Биты режима работы передаются в ParseFile без изменений.Информация о позиции записывается в fset,который не должен быть нулевым.</target>
        </trans-unit>
        <trans-unit id="78e87476be473e05171bc062a52f2074d7a8ce2f" translate="yes" xml:space="preserve">
          <source>If flush is true, Decode assumes that src represents the end of the input stream and processes it completely rather than wait for the completion of another 32-bit block.</source>
          <target state="translated">Если flush верно,то Decode предполагает,что src представляет собой конец входного потока и обрабатывает его полностью,а не ждет завершения очередного 32-битного блока.</target>
        </trans-unit>
        <trans-unit id="abcd3e65f17be630b169b8e4f1f0e366085cdf18" translate="yes" xml:space="preserve">
          <source>If format is a different character, Text returns a &quot;%&quot; followed by the unrecognized format character.</source>
          <target state="translated">Если формат отличается от формата,то Текст возвращает &quot;%&quot;,за которым следует нераспознанный символ формата.</target>
        </trans-unit>
        <trans-unit id="15ac9863fd0dd8dccce7934858d51ea1256592ee" translate="yes" xml:space="preserve">
          <source>If fs implements GlobFS, Glob calls fs.Glob. Otherwise, Glob uses ReadDir to traverse the directory tree and look for matches for the pattern.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4626bc3890fe37988ea2510caab3c9814ba275ba" translate="yes" xml:space="preserve">
          <source>If fs implements ReadDirFS, ReadDir calls fs.ReadDir. Otherwise ReadDir calls fs.Open and uses ReadDir and Close on the returned file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31f13441b50b357733713ae237e9ae2397173768" translate="yes" xml:space="preserve">
          <source>If fs implements ReadFileFS, ReadFile calls fs.ReadFile. Otherwise ReadFile calls fs.Open and uses Read and Close on the returned file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ceb2c3429af8803daf0d90e52f7956a596fe7fa" translate="yes" xml:space="preserve">
          <source>If fs implements StatFS, Stat calls fs.Stat. Otherwise, Stat opens the file to stat it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3469f576be775bc4ec742d95d1dcbeceeba0ae6" translate="yes" xml:space="preserve">
          <source>If fs implements SubFS, Sub calls returns fsys.Sub(dir). Otherwise, if dir is &quot;.&quot;, Sub returns fsys unchanged. Otherwise, Sub returns a new FS implementation sub that, in effect, implements sub.Open(dir) as fsys.Open(path.Join(dir, name)). The implementation also translates calls to ReadDir, ReadFile, and Glob appropriately.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5da5429fa2e44a95884b22d9fe6c9389416883fa" translate="yes" xml:space="preserve">
          <source>If id is an embedded struct field, ObjectOf returns the field (*Var) it defines, not the type (*TypeName) it uses.</source>
          <target state="translated">Если id является встроенным полем структуры,ObjectOf возвращает поле (*Var),которое он определяет,а не тип (*TypeName),который он использует.</target>
        </trans-unit>
        <trans-unit id="94590e2c870c388ec6ffdc4a336f130561479132" translate="yes" xml:space="preserve">
          <source>If implemented, drivers may return the underlying error from queries, even if the connection should be discarded by the connection pool.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f15fee8dc8778902e45311fbf0205cb96dcffed" translate="yes" xml:space="preserve">
          <source>If inuseZero is true, the profile includes allocation records where r.AllocBytes &amp;gt; 0 but r.AllocBytes == r.FreeBytes. These are sites where memory was allocated, but it has all been released back to the runtime.</source>
          <target state="translated">Если inuseZero истинно, профиль включает записи распределения, где r.AllocBytes&amp;gt; 0, но r.AllocBytes == r.FreeBytes. Это сайты, на которых была выделена память, но все это было возвращено среде выполнения.</target>
        </trans-unit>
        <trans-unit id="892475b4c6ec1f9a63d5df678595d2602a01d9d3" translate="yes" xml:space="preserve">
          <source>If laddr is nil, a local address is automatically chosen. If the IP field of raddr is nil or an unspecified IP address, the local system is assumed.</source>
          <target state="translated">Если лестница равна нулю,автоматически выбирается локальный адрес.Если IP-адрес raddr равен нулю или не указанному IP-адресу,то предполагается,что локальная система.</target>
        </trans-unit>
        <trans-unit id="ba24dc1c2b3bf1cedb83b06f2414cb64ac15d1da" translate="yes" xml:space="preserve">
          <source>If laddr is non-nil, it is used as the local address for the connection.</source>
          <target state="translated">Если лестница не нулевая,она используется в качестве локального адреса для подключения.</target>
        </trans-unit>
        <trans-unit id="9842a555fc5ba63bad435c92db4ce21af1894ec3" translate="yes" xml:space="preserve">
          <source>If level is in the range [-2, 9] then the error returned will be nil. Otherwise the error returned will be non-nil.</source>
          <target state="translated">Если уровень находится в диапазоне [-2,9],то возвращаемая ошибка будет равна нулю.В противном случае возвращаемая ошибка будет равна нулю.</target>
        </trans-unit>
        <trans-unit id="550da103e5e342ac2c8eff3e35ca3b010db8375f" translate="yes" xml:space="preserve">
          <source>If modtime is not the zero time or Unix epoch, ServeContent includes it in a Last-Modified header in the response. If the request includes an If-Modified-Since header, ServeContent uses modtime to decide whether the content needs to be sent at all.</source>
          <target state="translated">Если modtime не является нулевым временем или Unix-эпохой,ServeContent включает его в Last-Modified заголовок в ответе.Если запрос включает в себя If-Modified-Since заголовок,ServeContent использует modtime,чтобы решить,нужно ли отправлять контент вообще.</target>
        </trans-unit>
        <trans-unit id="df0b7b2149e75e7925ff056e6fc4f402a865000a" translate="yes" xml:space="preserve">
          <source>If multiple result sets are supported, Rows should implement RowsNextResultSet. If the driver knows how to describe the types present in the returned result it should implement the following interfaces: RowsColumnTypeScanType, RowsColumnTypeDatabaseTypeName, RowsColumnTypeLength, RowsColumnTypeNullable, and RowsColumnTypePrecisionScale. A given row value may also return a Rows type, which may represent a database cursor value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c6876f56eb90009b843d2c55675ac1e4df7f277" translate="yes" xml:space="preserve">
          <source>If multiple servers are terminating connections for the same host they should all have the same session ticket keys. If the session ticket keys leaks, previously recorded and future TLS connections using those keys might be compromised.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb36c7496ab365e2e943be0f9148eadc4805b840" translate="yes" xml:space="preserve">
          <source>If n &amp;gt; 0, ReadDir returns at most n DirEntry records. In this case, if ReadDir returns an empty slice, it will return an error explaining why. At the end of a directory, the error is io.EOF.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4498ca26095d9f0afc17fc3d124ee10f9b929767" translate="yes" xml:space="preserve">
          <source>If n &amp;gt; 0, Readdir returns at most n FileInfo structures. In this case, if Readdir returns an empty slice, it will return a non-nil error explaining why. At the end of a directory, the error is io.EOF.</source>
          <target state="translated">Если n&amp;gt; 0, Readdir возвращает не более n структур FileInfo. В этом случае, если Readdir вернет пустой фрагмент, он вернет ошибку, отличную от нуля, с объяснением причины. В конце каталога появляется ошибка io.EOF.</target>
        </trans-unit>
        <trans-unit id="fc3b271d5f3a597b07b28cf1083fa8b465cfe35b" translate="yes" xml:space="preserve">
          <source>If n &amp;gt; 0, Readdirnames returns at most n names. In this case, if Readdirnames returns an empty slice, it will return a non-nil error explaining why. At the end of a directory, the error is io.EOF.</source>
          <target state="translated">Если n&amp;gt; 0, Readdirnames возвращает не более n имен. В этом случае, если Readdirnames вернет пустой фрагмент, он вернет ошибку, отличную от нуля, с объяснением причины. В конце каталога появляется ошибка io.EOF.</target>
        </trans-unit>
        <trans-unit id="027dd1e79aacbdc0d0cb972c4a1c88050114f175" translate="yes" xml:space="preserve">
          <source>If n &amp;lt;= 0, ReadDir returns all the DirEntry records remaining in the directory. When it succeeds, it returns a nil error (not io.EOF).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eac4c3ba5a8c94ad8cb8a4a397c8ee90135cea13" translate="yes" xml:space="preserve">
          <source>If n &amp;lt;= 0, Readdir returns all the FileInfo from the directory in a single slice. In this case, if Readdir succeeds (reads all the way to the end of the directory), it returns the slice and a nil error. If it encounters an error before the end of the directory, Readdir returns the FileInfo read until that point and a non-nil error.</source>
          <target state="translated">Если n &amp;lt;= 0, Readdir возвращает всю информацию о файле из каталога в одном фрагменте. В этом случае, если Readdir завершается успешно (читает до конца каталога), он возвращает срез и ошибку nil. Если он обнаруживает ошибку до конца каталога, Readdir возвращает FileInfo, прочитанный до этого момента, и ошибку, отличную от nil.</target>
        </trans-unit>
        <trans-unit id="c3cc55f92ff37a98b5144ea82d578410d2c8c458" translate="yes" xml:space="preserve">
          <source>If n &amp;lt;= 0, Readdirnames returns all the names from the directory in a single slice. In this case, if Readdirnames succeeds (reads all the way to the end of the directory), it returns the slice and a nil error. If it encounters an error before the end of the directory, Readdirnames returns the names read until that point and a non-nil error.</source>
          <target state="translated">Если n &amp;lt;= 0, Readdirnames возвращает все имена из каталога в одном фрагменте. В этом случае, если Readdirnames завершается успешно (считывается до конца каталога), он возвращает срез и ошибку nil. Если обнаруживается ошибка до конца каталога, Readdirnames возвращает имена, прочитанные до этого момента, и ошибку, отличную от нуля.</target>
        </trans-unit>
        <trans-unit id="2b903f7cf121247bf3e7b3aca6c7022dbb5df0e4" translate="yes" xml:space="preserve">
          <source>If n &amp;lt;= 0, no idle connections are retained.</source>
          <target state="translated">Если n &amp;lt;= 0, неактивные соединения не сохраняются.</target>
        </trans-unit>
        <trans-unit id="be61ba0537fe2779cebfab91a18a370978aeba0f" translate="yes" xml:space="preserve">
          <source>If n &amp;lt;= 0, then there is no limit on the number of open connections. The default is 0 (unlimited).</source>
          <target state="translated">Если n &amp;lt;= 0, то количество открытых соединений не ограничено. По умолчанию 0 (неограниченно).</target>
        </trans-unit>
        <trans-unit id="3ffbdba0310e5330b6e39ba21df32f4ec64c1673" translate="yes" xml:space="preserve">
          <source>If name contains no path separators, Command uses LookPath to resolve name to a complete path if possible. Otherwise it uses name directly as Path.</source>
          <target state="translated">Если имя не содержит разделителей путей,команда использует LookPath для преобразования имени в полный путь,если это возможно.В противном случае команда использует имя непосредственно как путь.</target>
        </trans-unit>
        <trans-unit id="bda6ab9657711e238f41fc5c82fabb4f059d8032" translate="yes" xml:space="preserve">
          <source>If named parameters or context are supported, the driver's Conn should implement: ExecerContext, QueryerContext, ConnPrepareContext, and ConnBeginTx.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e919c20774517f309335e67ee8266068c715cb69" translate="yes" xml:space="preserve">
          <source>If no entry is found, a nil object is returned. In this case, the returned index and indirect values have the following meaning:</source>
          <target state="translated">Если запись не найдена,возвращается нулевой объект.В этом случае возвращаемый индекс и косвенные значения имеют следующее значение:</target>
        </trans-unit>
        <trans-unit id="2a51e78e82aff9bdb39269ef8cd918a49b097d8e" translate="yes" xml:space="preserve">
          <source>If opts.Roots is nil and system roots are unavailable the returned error will be of type SystemRootsError.</source>
          <target state="translated">Если opts.Roots равен нулю и корни системы недоступны,возвращаемая ошибка будет иметь тип SystemRootsError.</target>
        </trans-unit>
        <trans-unit id="6ec80a61e5ca904701ff45ad5637a764d8777e22" translate="yes" xml:space="preserve">
          <source>If opts.Roots is nil, the platform verifier might be used, and verification details might differ from what is described below. If system roots are unavailable the returned error will be of type SystemRootsError.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93b29b6dd544ee070bf7867f11c38d0b30ce0f19" translate="yes" xml:space="preserve">
          <source>If p points into an allocated object, it can be advanced through the object by conversion to uintptr, addition of an offset, and conversion back to Pointer.</source>
          <target state="translated">Если p указывает на выделенный объект,то его можно продвинуть через объект путем преобразования в uintptr,добавления смещения и обратного преобразования в Pointer.</target>
        </trans-unit>
        <trans-unit id="9c4a4899af1972effe20bb6d4fb3e2cc68991f24" translate="yes" xml:space="preserve">
          <source>If pc is not covered by any entry in this line table, SeekPC returns ErrUnknownPC. In this case, *entry and the final seek position are unspecified.</source>
          <target state="translated">Если pc не покрыт ни одной записью в этой строковой таблице,SeekPC возвращает ErrUnknownPC.В этом случае *вход и конечная позиция поиска не определены.</target>
        </trans-unit>
        <trans-unit id="400c0cdcf2667212ffa50be895764e1b4992a8e1" translate="yes" xml:space="preserve">
          <source>If pc represents multiple functions because of inlining, it returns the *Func describing the innermost function, but with an entry of the outermost function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47b9ebf87a72a4fc29d6e9526a5e472474f83dfe" translate="yes" xml:space="preserve">
          <source>If pc represents multiple functions because of inlining, it returns the a *Func describing the innermost function, but with an entry of the outermost function.</source>
          <target state="translated">Если pc представляет несколько функций из-за вставки,он возвращает функцию *Func,описывающую самую внутреннюю функцию,но с записью самой внешней функции.</target>
        </trans-unit>
        <trans-unit id="8759c1ffe2421dc4e493bad121916d1c4a784268" translate="yes" xml:space="preserve">
          <source>If pkg == nil, the Universe scope is used and the provided position pos is ignored. If pkg != nil, and pos is invalid, the package scope is used. Otherwise, pos must belong to the package.</source>
          <target state="translated">Если pkg ==nil,то используется вселенский оптический прицел и предоставленная позиция pos игнорируется.Если pkg !=nil и pos недействительны,используется область видимости пакета.В противном случае pos должен принадлежать пакету.</target>
        </trans-unit>
        <trans-unit id="3b501d10f0b3315a0edcb0a3aa0bfa72db3f19b3" translate="yes" xml:space="preserve">
          <source>If pkg was loaded from export data, Imports includes packages that provide package-level objects referenced by pkg. This may be more or less than the set of packages directly imported by pkg's source code.</source>
          <target state="translated">Если pkg была загружена из экспортных данных,то импорт включает в себя пакеты,которые предоставляют объекты на уровне пакетов,на которые ссылаются pkg.Это может быть больше или меньше,чем набор пакетов,непосредственно импортированных по исходному коду pkg.</target>
        </trans-unit>
        <trans-unit id="a13dac68b11bffa0323115aff464b296dab14f09" translate="yes" xml:space="preserve">
          <source>If r and s point to different rings, linking them creates a single ring with the elements of s inserted after r. The result points to the element following the last element of s after insertion.</source>
          <target state="translated">Если r и s указывают на разные кольца,то их соединение создает единое кольцо с элементами s,вставленными после r.Результат указывает на элемент,следующий за последним элементом s после вставки.</target>
        </trans-unit>
        <trans-unit id="b045896c9ac0e612d840b26fdcd16f9492dfd688" translate="yes" xml:space="preserve">
          <source>If r and s point to the same ring, linking them removes the elements between r and s from the ring. The removed elements form a subring and the result is a reference to that subring (if no elements were removed, the result is still the original value for r.Next(), and not nil).</source>
          <target state="translated">Если r и s указывают на одно и то же кольцо,то их соединение удаляет элементы между r и s из кольца.Удаленные элементы образуют подкольцо,и результат является ссылкой на это подкольцо (если ни один элемент не был удален,результат остается исходным значением для r.Next(),а не нулевым).</target>
        </trans-unit>
        <trans-unit id="8848277c3a29719067a054c042f2cd449fd3596a" translate="yes" xml:space="preserve">
          <source>If rand is not nil then RSA blinding will be used to avoid timing side-channel attacks.</source>
          <target state="translated">Если рэнд не равен нулю,то для предотвращения временных атак по боковому каналу будет использоваться RSA-ослепление.</target>
        </trans-unit>
        <trans-unit id="a19e63938d7a0894376439e5599ffa43b250a5d4" translate="yes" xml:space="preserve">
          <source>If rt.RoundTrip returns ErrSkipAltProtocol, the Transport will handle the RoundTrip itself for that one request, as if the protocol were not registered.</source>
          <target state="translated">Если rt.RoundTrip вернет ErrSkipAltProtocol,Транспорт будет обрабатывать сам RoundTrip для этого одного запроса,как если бы протокол не был зарегистрирован.</target>
        </trans-unit>
        <trans-unit id="54ad40399e089deda52c88ae3ba4659988c86560" translate="yes" xml:space="preserve">
          <source>If s does not contain sep and sep is not empty, Split returns a slice of length 1 whose only element is s.</source>
          <target state="translated">Если s не содержит sep,а sep не пуст,то Split возвращает срез длиной 1,единственным элементом которого является s.</target>
        </trans-unit>
        <trans-unit id="9daee5dcf8a47681ddd5e5f835fb1dbed1f83aea" translate="yes" xml:space="preserve">
          <source>If s does not contain sep and sep is not empty, SplitAfter returns a slice of length 1 whose only element is s.</source>
          <target state="translated">Если s не содержит sep,а sep не пуст,то SplitAfter возвращает срез длиной 1,единственным элементом которого является s.</target>
        </trans-unit>
        <trans-unit id="9684a535d56fa8216893011aa4860380b4410933" translate="yes" xml:space="preserve">
          <source>If s is not syntactically well-formed, ParseComplex returns err.Err = ErrSyntax.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95759bb8e19ebcbb98672ac7fdd18943d4708775" translate="yes" xml:space="preserve">
          <source>If s is not syntactically well-formed, ParseFloat returns err.Err = ErrSyntax.</source>
          <target state="translated">Если s не синтаксически правильно сформирован,ParseFloat возвращает err.Err=ErrSyntax.</target>
        </trans-unit>
        <trans-unit id="07f06b052060daddabd04efc8e7cdb5992bfb2f4" translate="yes" xml:space="preserve">
          <source>If s is syntactically well-formed but either component is more than 1/2 ULP away from the largest floating point number of the given component's size, ParseComplex returns err.Err = ErrRange and c = &amp;plusmn;Inf for the respective component.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e257c93b527ddb828e688937de0ccc11edf5f79" translate="yes" xml:space="preserve">
          <source>If s is syntactically well-formed but is more than 1/2 ULP away from the largest floating point number of the given size, ParseFloat returns f = &amp;plusmn;Inf, err.Err = ErrRange.</source>
          <target state="translated">Если s синтаксически правильно сформирован, но более чем на 1/2 ULP от наибольшего числа с плавающей запятой заданного размера, ParseFloat возвращает f = &amp;plusmn; Inf, err.Err = ErrRange.</target>
        </trans-unit>
        <trans-unit id="2958c3475b5e1c01d3ef1742914960b9002f7a9e" translate="yes" xml:space="preserve">
          <source>If sec &amp;gt; 0, the data is sent in the background as with sec &amp;lt; 0. On some operating systems after sec seconds have elapsed any remaining unsent data may be discarded.</source>
          <target state="translated">Если sec&amp;gt; 0, данные отправляются в фоновом режиме, как при sec &amp;lt;0. В некоторых операционных системах по истечении sec секунд все оставшиеся неотправленные данные могут быть отброшены.</target>
        </trans-unit>
        <trans-unit id="f56f69cce6422c40a21ab01c5418cdbd4bf77063" translate="yes" xml:space="preserve">
          <source>If sec &amp;lt; 0 (the default), the operating system finishes sending the data in the background.</source>
          <target state="translated">Если sec &amp;lt;0 (по умолчанию), операционная система завершает отправку данных в фоновом режиме.</target>
        </trans-unit>
        <trans-unit id="d8d3489dffe9a7fe6c9ad9a620bad31395af4507" translate="yes" xml:space="preserve">
          <source>If sec == 0, the operating system discards any unsent or unacknowledged data.</source>
          <target state="translated">Если сек ==0,операционная система отбрасывает неопубликованные или неизвестные данные.</target>
        </trans-unit>
        <trans-unit id="be66aebe1a8866a8f4dc281f1bd57616b1f982bc" translate="yes" xml:space="preserve">
          <source>If sep is empty, Split splits after each UTF-8 sequence. If both s and sep are empty, Split returns an empty slice.</source>
          <target state="translated">Если sep пуст,то Split расщепляется после каждой последовательности UTF-8.Если и s,и sep пустые,Split возвращает пустой кусок.</target>
        </trans-unit>
        <trans-unit id="489ca1eca08b1f0a405730583d47d533fb4b076e" translate="yes" xml:space="preserve">
          <source>If sep is empty, SplitAfter splits after each UTF-8 sequence. If both s and sep are empty, SplitAfter returns an empty slice.</source>
          <target state="translated">Если sep пуст,то SplitAfter расщепляется после каждой последовательности UTF-8.Если и s,и sep пустые,SplitAfter возвращает пустой срез.</target>
        </trans-unit>
        <trans-unit id="2a3657d8164caf54f78f733fc8ef2ecda3905624" translate="yes" xml:space="preserve">
          <source>If src != nil, ParseFile parses the source from src and the filename is only used when recording position information. The type of the argument for the src parameter must be string, []byte, or io.Reader. If src == nil, ParseFile parses the file specified by filename.</source>
          <target state="translated">Если src !=nil,ParseFile разбирает источник из src и имя файла используется только при записи информации о позиции.Тип аргумента для параметра src должен быть string,[]byte,или io.Reader.Если src ==nil,ParseFile разбирает файл,указанный по имени файла.</target>
        </trans-unit>
        <trans-unit id="fe8d7fb1ea6082771e2bec41671407fae46d618e" translate="yes" xml:space="preserve">
          <source>If src implements the WriterTo interface, the copy is implemented by calling src.WriteTo(dst). Otherwise, if dst implements the ReaderFrom interface, the copy is implemented by calling dst.ReadFrom(src).</source>
          <target state="translated">Если src реализует интерфейс WriterTo,то копия реализуется вызовом src.WriteTo(dst).В противном случае,если dst реализует интерфейс ReaderFrom,то копия реализуется вызовом dst.ReadFrom(src).</target>
        </trans-unit>
        <trans-unit id="e40b342e6817ab9c3ac4432d840f11c1f0b22325" translate="yes" xml:space="preserve">
          <source>If src is a partial source file, the leading and trailing space of src is applied to the result (such that it has the same leading and trailing space as src), and the result is indented by the same amount as the first line of src containing code. Imports are not sorted for partial source files.</source>
          <target state="translated">Если src является неполным исходным файлом,то к результату применяется ведущее и трейлинговое пространство src (таким образом,чтобы у него было то же ведущее и трейлинговое пространство,что и у src),а результат отступает на ту же величину,что и первая строка src,содержащая код.Импорты не сортируются для частичных исходных файлов.</target>
        </trans-unit>
        <trans-unit id="7c67bad25cffc131c00d1eef36d585ec638c9170" translate="yes" xml:space="preserve">
          <source>If srv.Addr is blank, &quot;:http&quot; is used.</source>
          <target state="translated">Если srv.Addr пуст,то используется &quot;:http&quot;.</target>
        </trans-unit>
        <trans-unit id="f9e50e1a49136013b88aa780931a141882ea6f39" translate="yes" xml:space="preserve">
          <source>If srv.Addr is blank, &quot;:https&quot; is used.</source>
          <target state="translated">Если srv.Addr пуст,используется &quot;:https&quot;.</target>
        </trans-unit>
        <trans-unit id="ad0892d319e6dc448b8b5b8890782a44c3d82311" translate="yes" xml:space="preserve">
          <source>If successful, tmpl will now be injection-safe. Otherwise, err is an error defined in the docs for ErrorCode.</source>
          <target state="translated">В случае успеха,tmpl теперь будет безопасен для инъекций.В противном случае,ошибка-это ошибка,определенная в документации для ErrorCode.</target>
        </trans-unit>
        <trans-unit id="451a36f1b0a3d42a37ffc7ced9db73e72d35532d" translate="yes" xml:space="preserve">
          <source>If syntax errors were found, the result is a partial AST (with ast.Bad* nodes representing the fragments of erroneous source code). Multiple errors are returned via a scanner.ErrorList which is sorted by source position.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02f96dee5151e31c5e7cb8d54792d30a40798d8b" translate="yes" xml:space="preserve">
          <source>If that method exists, it returns the memory address which triggered the fault. The results of Addr are best-effort and the veracity of the result may depend on the platform. SetPanicOnFault applies only to the current goroutine. It returns the previous setting.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="178b407eef387370d388c8cfe01edb64789c6b52" translate="yes" xml:space="preserve">
          <source>If the Client's Transport does not have a CloseIdleConnections method then this method does nothing.</source>
          <target state="translated">Если у транспорта клиента нет метода CloseIdleConnections,то этот метод ничего не делает.</target>
        </trans-unit>
        <trans-unit id="a2836eacebc948128e4aa3ce4d8b1d3fc7d6a477" translate="yes" xml:space="preserve">
          <source>If the Content-Type header has not been set, Redirect sets it to &quot;text/html; charset=utf-8&quot; and writes a small HTML body. Setting the Content-Type header to any value, including nil, disables that behavior.</source>
          <target state="translated">Если заголовок Content-Type не установлен,Redirect устанавливает его в &quot;text/html;charset=utf-8&quot; и записывает небольшое тело HTML.Установка заголовка Content-Type в любое значение,включая nil,отключает такое поведение.</target>
        </trans-unit>
        <trans-unit id="3ae6135ca1107639811cd5daef71ae7fca79e2f6" translate="yes" xml:space="preserve">
          <source>If the Context field is 0, the context function is being called to record the current traceback context. It should record in the Context field whatever information is needed about the current point of execution to later produce a stack trace, probably the stack pointer and PC. In this case the context function will be called from C code.</source>
          <target state="translated">Если поле Context (Контекст)равно 0,то вызывается контекстная функция для записи текущего контекста трассировки.Она должна записать в Контекстное поле любую информацию о текущей точке выполнения для последующего создания трассы стека,вероятно,указателя стека и компьютера.В этом случае контекстная функция будет вызвана из кода на языке C.</target>
        </trans-unit>
        <trans-unit id="42011269501bbfe9917fe4565b51ba6a042b7ead" translate="yes" xml:space="preserve">
          <source>If the Context field is not 0, then it is a value returned by a previous call to the context function. This case is called when the context is no longer needed; that is, when the Go code is returning to its C code caller. This permits the context function to release any associated resources.</source>
          <target state="translated">Если Контекстное поле не равно 0,то это значение возвращается предыдущим вызовом контекстной функции.Этот случай вызывается,когда контекст больше не нужен,то есть когда код Go возвращается к своему вызывающему C-коду.Это позволяет контекстной функции освободить любые связанные с ней ресурсы.</target>
        </trans-unit>
        <trans-unit id="084a8ea923e025ba6d8130824462ac823dad2f19" translate="yes" xml:space="preserve">
          <source>If the Delta field of a CaseRange is UpperLower, it means this CaseRange represents a sequence of the form (say) Upper Lower Upper Lower.</source>
          <target state="translated">Если поле дельты CaseRange является Верхним Нижним,то это означает,что этот CaseRange представляет собой последовательность формы (скажем)Верхний Нижний Нижний Нижний.</target>
        </trans-unit>
        <trans-unit id="99155dad735e31c1f83383d55994a89a1d5b0d8e" translate="yes" xml:space="preserve">
          <source>If the Go program is started with a non-empty signal mask, that will generally be honored. However, some signals are explicitly unblocked: the synchronous signals, SIGILL, SIGTRAP, SIGSTKFLT, SIGCHLD, SIGPROF, and, on GNU/Linux, signals 32 (SIGCANCEL) and 33 (SIGSETXID) (SIGCANCEL and SIGSETXID are used internally by glibc). Subprocesses started by os.Exec, or by the os/exec package, will inherit the modified signal mask.</source>
          <target state="translated">Если программа &quot;Go&quot; запускается с непустой сигнальной маской,это,как правило,считается честью.Однако некоторые сигналы явно разблокированы:синхронные сигналы SIGILL,SIGTRAP,SIGSTKFLT,SIGCHLD,SIGPROF,а в GNU/Linux сигналы 32 (SIGCANCEL)и 33 (SIGSETXID)(SIGCANCEL и SIGSETXID используются внутри glibc).Подпроцессы,запущенные os.Exec или пакетом os/exec,наследуют измененную маску сигналов.</target>
        </trans-unit>
        <trans-unit id="9a19e7607fdf15201f487fc6adac4a654bb31d6b" translate="yes" xml:space="preserve">
          <source>If the Go program is started with either SIGHUP or SIGINT ignored (signal handler set to SIG_IGN), they will remain ignored.</source>
          <target state="translated">Если программа Go запускается с игнорированием либо SIGHUP,либо SIGINT (обработчик сигнала установлен в SIG_IGN),то они останутся игнорируемыми.</target>
        </trans-unit>
        <trans-unit id="bb2401bc392b8c040ae8577c33db0583e1939491" translate="yes" xml:space="preserve">
          <source>If the Go runtime sees an existing signal handler for the SIGCANCEL or SIGSETXID signals (which are used only on GNU/Linux), it will turn on the SA_ONSTACK flag and otherwise keep the signal handler.</source>
          <target state="translated">Если во время выполнения Go увидит существующий обработчик сигналов SIGCANCEL или SIGSETXID (которые используются только в GNU/Linux),то он включит флаг SA_ONSTACK и в противном случае сохранит обработчик сигналов.</target>
        </trans-unit>
        <trans-unit id="b8c9bbe3199fe348a3ebb3c33bad8f777f2557ca" translate="yes" xml:space="preserve">
          <source>If the Go signal handler is invoked on a non-Go thread not running Go code, the handler generally forwards the signal to the non-Go code, as follows. If the signal is SIGPROF, the Go handler does nothing. Otherwise, the Go handler removes itself, unblocks the signal, and raises it again, to invoke any non-Go handler or default system handler. If the program does not exit, the Go handler then reinstalls itself and continues execution of the program.</source>
          <target state="translated">Если обработчик сигнала Go вызывается в не-Go потоке,не выполняющем код Go,то,как правило,обработчик перенаправляет сигнал в не-Go код следующим образом.Если сигнал SIGPROF,обработчик Go ничего не делает.В противном случае,обработчик удаляет себя,разблокирует сигнал и поднимает его снова,чтобы вызвать любой не-Go обработчик или системный обработчик по умолчанию.Если программа не выходит,то обработчик переустанавливает себя и продолжает выполнение программы.</target>
        </trans-unit>
        <trans-unit id="d1450a83e799c9f838308f1831ad2410ca5837bc" translate="yes" xml:space="preserve">
          <source>If the IP field of laddr is nil or an unspecified IP address, ListenIP listens on all available IP addresses of the local system except multicast IP addresses.</source>
          <target state="translated">Если поле IP-адреса лестницы равно нулю или не указанному IP-адресу,ListenIP прослушивает все доступные IP-адреса локальной системы,за исключением многоадресных IP-адресов.</target>
        </trans-unit>
        <trans-unit id="af82767d02391b6e900db2816b87a4fb9f84a234" translate="yes" xml:space="preserve">
          <source>If the IP field of laddr is nil or an unspecified IP address, ListenTCP listens on all available unicast and anycast IP addresses of the local system. If the Port field of laddr is 0, a port number is automatically chosen.</source>
          <target state="translated">Если поле IP-адреса лестницы равно нулю или не указанному IP-адресу,ListenTCP прослушивает все доступные одноадресные и широковещательные IP-адреса локальной системы.Если в лестничной диаграмме поле Порт равно 0,то автоматически выбирается номер порта.</target>
        </trans-unit>
        <trans-unit id="af86e9317bf51d088cb071c3ee8a01bff50d7b6b" translate="yes" xml:space="preserve">
          <source>If the IP field of laddr is nil or an unspecified IP address, ListenUDP listens on all available IP addresses of the local system except multicast IP addresses. If the Port field of laddr is 0, a port number is automatically chosen.</source>
          <target state="translated">Если поле IP-адреса лестницы равно нулю или не указанному IP-адресу,ListenUDP прослушивает все доступные IP-адреса локальной системы,за исключением многоадресных IP-адресов.Если в лестничной диаграмме поле Порт равно 0,то автоматически выбирается номер порта.</target>
        </trans-unit>
        <trans-unit id="5b648936c52bc2fbcc7b753478ee856cc09da205" translate="yes" xml:space="preserve">
          <source>If the XML name for a struct field is defined by both the field tag and the struct's XMLName field, the names must match.</source>
          <target state="translated">Если XML-имя поля структуры определяется как тегом поля,так и полем XMLName структуры,то имена должны совпадать.</target>
        </trans-unit>
        <trans-unit id="5d4098baadc84b2ed5afee57ad7e0f2a2a2618b1" translate="yes" xml:space="preserve">
          <source>If the absolute value of x doesn't fit in buf, FillBytes will panic.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f2bd83aa910968ed65b7f3c442134176bd4b3dd" translate="yes" xml:space="preserve">
          <source>If the base argument is 0, the true base is implied by the string's prefix: 2 for &quot;0b&quot;, 8 for &quot;0&quot; or &quot;0o&quot;, 16 for &quot;0x&quot;, and 10 otherwise. Also, for argument base 0 only, underscore characters are permitted as defined by the Go syntax for integer literals.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ef1f744f6bc6158c837d3a4a05d2dd7419e3d5c" translate="yes" xml:space="preserve">
          <source>If the caller has set w's ETag header formatted per RFC 7232, section 2.3, ServeContent uses it to handle requests using If-Match, If-None-Match, or If-Range.</source>
          <target state="translated">Если вызывающий абонент установил заголовок w ETag,отформатированный в соответствии с RFC 7232,раздел 2.3,ServeContent использует его для обработки запросов с использованием If-Match,If-None-Match или If-Range.</target>
        </trans-unit>
        <trans-unit id="7fe34f55752121c99936b8403a6063a8914cb06e" translate="yes" xml:space="preserve">
          <source>If the calling goroutine has locked the operating system thread with runtime.LockOSThread and modified any inheritable OS-level thread state (for example, Linux or Plan 9 name spaces), the new process will inherit the caller's thread state.</source>
          <target state="translated">Если вызывающий goroutine заблокировал поток операционной системы с помощью runtime.LockOSThread и изменил любое наследуемое состояние потока на уровне операционной системы (например,пробелы имен Linux или Plan 9),новый процесс унаследует состояние потока вызывающего абонента.</target>
        </trans-unit>
        <trans-unit id="259a07efdd482c1e280dc36d61c76b7e373057fb" translate="yes" xml:space="preserve">
          <source>If the command fails to run or doesn't complete successfully, the error is of type *ExitError. Other error types may be returned for I/O problems.</source>
          <target state="translated">Если команда не выполняется или не завершается успешно,то ошибка имеет тип *ExitError.Для проблем ввода/вывода могут быть возвращены другие типы ошибок.</target>
        </trans-unit>
        <trans-unit id="b33403be418b27f91a2d42d554ef5c02f7c63947" translate="yes" xml:space="preserve">
          <source>If the command starts but does not complete successfully, the error is of type *ExitError. Other error types may be returned for other situations.</source>
          <target state="translated">Если команда запускается,но не завершается успешно,то ошибка имеет тип *ExitError.Для других ситуаций могут быть возвращены другие типы ошибок.</target>
        </trans-unit>
        <trans-unit id="5a122d2b8c97a37a880702f2a3fbe016e3749fd3" translate="yes" xml:space="preserve">
          <source>If the current file is sparse, then the regions marked as a hole are read back as NUL-bytes.</source>
          <target state="translated">Если текущий файл разрежен,то области,помеченные как дырки,считываются обратно как NUL-байты.</target>
        </trans-unit>
        <trans-unit id="3b03d20f1b9fd110420a18ed294f7f997d1375b2" translate="yes" xml:space="preserve">
          <source>If the deadline is exceeded a call to Read or Write or to other I/O methods will return an error that wraps ErrDeadlineExceeded. This can be tested using errors.Is(err, os.ErrDeadlineExceeded). That error implements the Timeout method, and calling the Timeout method will return true, but there are other possible errors for which the Timeout will return true even if the deadline has not been exceeded.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6253658c1bbbfe0517d9a4b3227473cd894d597c" translate="yes" xml:space="preserve">
          <source>If the directory couldn't be read, a nil map and the respective error are returned. If a parse error occurred, a non-nil but incomplete map and the first error encountered are returned.</source>
          <target state="translated">Если каталог не удалось прочитать,возвращается нулевая карта и соответствующая ошибка.Если произошла ошибка при разборе,возвращается нулевая,но неполная карта и первая обнаруженная ошибка.</target>
        </trans-unit>
        <trans-unit id="01b40bd5ac5583f9db3311853c6994966859d236" translate="yes" xml:space="preserve">
          <source>If the driver supports cursors, a returned Value may also implement the Rows interface in this package. This is used, for example, when a user selects a cursor such as &quot;select cursor(select * from my_table) from dual&quot;. If the Rows from the select is closed, the cursor Rows will also be closed.</source>
          <target state="translated">Если драйвер поддерживает курсоры,возвращаемое значение может также реализовать интерфейс Rows в данном пакете.Это используется,например,когда пользователь выбирает курсор,например,&quot;select cursor(select*from my_table)from dual&quot;.Если строки из выбранного будут закрыты,курсор Rows также будет закрыт.</target>
        </trans-unit>
        <trans-unit id="cf50ebb80b297da2b505a620be031cb25dcead76" translate="yes" xml:space="preserve">
          <source>If the format (which is implicitly %v for Println etc.) is valid for a string (%s %q %v %x %X), the following two rules apply:</source>
          <target state="translated">Если формат (неявно %v для Println и т.д.)действителен для строки (%s %q %v %x %X),применяются следующие два правила:</target>
        </trans-unit>
        <trans-unit id="0f42e25dba03dca0e51f87ed12e981c71373e332" translate="yes" xml:space="preserve">
          <source>If the format specifier includes a %w verb with an error operand, the returned error will implement an Unwrap method returning the operand. It is invalid to include more than one %w verb or to supply it with an operand that does not implement the error interface. The %w verb is otherwise a synonym for %v.</source>
          <target state="translated">Если спецификатор формата содержит глагол %w с операндом ошибки,то возвращаемая ошибка реализует метод Unwrap,возвращающий операнд.Недопустимо включать более одного %w глагола или снабжать его операндом,который не реализует интерфейс ошибки.В противном случае глагол %w является синонимом %v.</target>
        </trans-unit>
        <trans-unit id="b70a519f0eee1914e654572a47f9ae5a7a8a3889" translate="yes" xml:space="preserve">
          <source>If the host in the address parameter is not a literal IP address or the port is not a literal port number, ResolveTCPAddr resolves the address to an address of TCP end point. Otherwise, it parses the address as a pair of literal IP address and port number. The address parameter can use a host name, but this is not recommended, because it will return at most one of the host name's IP addresses.</source>
          <target state="translated">Если хост в параметре адреса не является буквальным IP-адресом или порт не является буквальным номером порта,ResolveTCPAddr преобразует адрес в адрес конечной точки TCP.В противном случае,он разбирает адрес как пару буквальных IP-адресов и номеров портов.Параметр &quot;Адрес&quot; может использовать имя хоста,но это не рекомендуется,так как он возвращает максимум один из IP-адресов имени хоста.</target>
        </trans-unit>
        <trans-unit id="60603d4b10b0e1d0e446fdae0a4a44c25a6c45b7" translate="yes" xml:space="preserve">
          <source>If the host in the address parameter is not a literal IP address or the port is not a literal port number, ResolveUDPAddr resolves the address to an address of UDP end point. Otherwise, it parses the address as a pair of literal IP address and port number. The address parameter can use a host name, but this is not recommended, because it will return at most one of the host name's IP addresses.</source>
          <target state="translated">Если хост в параметре адреса не является буквальным IP-адресом или порт не является буквальным номером порта,то ResolveUDPAddr преобразует адрес в адрес конечной точки UDP.В противном случае он разбирает адрес как пару буквальных IP-адресов и номеров портов.Параметр address может использовать имя хоста,но это не рекомендуется,так как он возвращает максимум один из IP-адресов имени хоста.</target>
        </trans-unit>
        <trans-unit id="cd0fc2990a9a9cf8fad81f64436555d3d6b35355" translate="yes" xml:space="preserve">
          <source>If the host in the address parameter is not a literal IP address, ResolveIPAddr resolves the address to an address of IP end point. Otherwise, it parses the address as a literal IP address. The address parameter can use a host name, but this is not recommended, because it will return at most one of the host name's IP addresses.</source>
          <target state="translated">Если узел в параметре адреса не является буквальным IP-адресом,то ResolveIPAddr преобразует адрес в адрес конечной точки IP.В противном случае,он разбирает адрес как буквальный IP-адрес.Параметр &quot;Адрес&quot; может использовать имя хоста,но это не рекомендуется,так как он возвращает максимум один из IP-адресов имени хоста.</target>
        </trans-unit>
        <trans-unit id="199da3dce7215d4cebc5f4fd0619e8dbc8fd6d9d" translate="yes" xml:space="preserve">
          <source>If the key type is not a valid map key type (that is, if it does not implement Go's == operator), MapOf panics.</source>
          <target state="translated">Если тип ключа не является допустимым типом карты (т.е.если он не реализует оператор Go's ==),то MapOf паникует.</target>
        </trans-unit>
        <trans-unit id="fdcae4b6d304718d87888a4b14792a984d6db584" translate="yes" xml:space="preserve">
          <source>If the location cannot be determined (for example, $HOME is not defined), then it will return an error.</source>
          <target state="translated">Если местоположение не может быть определено (например,$HOME не определено),то это вернет ошибку.</target>
        </trans-unit>
        <trans-unit id="83fc45c3d88185bce6b913b6fba87e76a3564c14" translate="yes" xml:space="preserve">
          <source>If the n = len(p) bytes returned by ReadAt are at the end of the input source, ReadAt may return either err == EOF or err == nil.</source>
          <target state="translated">Если байты n=len(p),возвращаемые ReadAt,находятся в конце источника входного сигнала,ReadAt может вернуть либо err ==EOF,либо err ==nil.</target>
        </trans-unit>
        <trans-unit id="96928e9a3e37cddefc97fd6808cb69e209a645f8" translate="yes" xml:space="preserve">
          <source>If the name is &quot;&quot; or &quot;UTC&quot;, LoadLocation returns UTC. If the name is &quot;Local&quot;, LoadLocation returns Local.</source>
          <target state="translated">Если название &quot;&quot; или &quot;UTC&quot;,LoadLocation возвращает UTC.Если имя &quot;Локальное&quot;,LoadLocation возвращает Локальное.</target>
        </trans-unit>
        <trans-unit id="c79b81e2eaa3eeb8ef94f0d473fa6a78b2eff61b" translate="yes" xml:space="preserve">
          <source>If the name of a slice type ends with &quot;SET&quot; then it's treated as if the &quot;set&quot; tag was set on it. This results in interpreting the type as a SET OF x rather than a SEQUENCE OF x. This can be used with nested slices where a struct tag cannot be given.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71bd5d676aea790d3104c9356a66a88a54f27219" translate="yes" xml:space="preserve">
          <source>If the non-Go code called by the Go program does not change any signal handlers or masks, then the behavior is the same as for a pure Go program.</source>
          <target state="translated">Если не-Go код,вызываемый программой Go,не изменяет никаких обработчиков сигналов или масок,то поведение будет таким же,как и для чистой программы Go.</target>
        </trans-unit>
        <trans-unit id="7ff28c4dacda2b677d57a006ed06c589035c4906" translate="yes" xml:space="preserve">
          <source>If the non-Go code installs a signal handler for any of the asynchronous signals, it may invoke the Go signal handler or not as it chooses. Naturally, if it does not invoke the Go signal handler, the Go behavior described above will not occur. This can be an issue with the SIGPROF signal in particular.</source>
          <target state="translated">Если не-Go код устанавливает обработчик сигнала для любого из асинхронных сигналов,он может вызывать обработчик Go сигнала или не вызывать его по своему выбору.Естественно,если он не вызовет обработчик Go-сигналов,поведение Go,описанное выше,не произойдет.В частности,это может быть проблема с сигналом SIGPROF.</target>
        </trans-unit>
        <trans-unit id="abd2048f2311a9e6d64b579961e64f72d37d33a6" translate="yes" xml:space="preserve">
          <source>If the non-Go code installs a signal handler for any of the synchronous signals (SIGBUS, SIGFPE, SIGSEGV), then it should record the existing Go signal handler. If those signals occur while executing Go code, it should invoke the Go signal handler (whether the signal occurs while executing Go code can be determined by looking at the PC passed to the signal handler). Otherwise some Go run-time panics will not occur as expected.</source>
          <target state="translated">Если не-Go код устанавливает обработчик сигналов для любого из синхронных сигналов (SIGBUS,SIGFPE,SIGSEGV),то он должен записать существующий обработчик Go сигнала.Если эти сигналы возникают во время выполнения Go-кода,он должен вызвать обработчик Go-сигнала (наличие сигнала во время выполнения Go-кода можно определить,посмотрев на ПК,переданный обработчику сигнала).В противном случае некоторые паники во время выполнения Go-сигнала произойдут не так,как ожидалось.</target>
        </trans-unit>
        <trans-unit id="bb19b115a2d359b987ea5bcb60343aca9ae430dd" translate="yes" xml:space="preserve">
          <source>If the non-Go code installs any signal handlers, it must use the SA_ONSTACK flag with sigaction. Failing to do so is likely to cause the program to crash if the signal is received. Go programs routinely run with a limited stack, and therefore set up an alternate signal stack. Also, the Go standard library expects that any signal handlers will use the SA_RESTART flag. Failing to do so may cause some library calls to return &quot;interrupted system call&quot; errors.</source>
          <target state="translated">Если не-Go код устанавливает обработчики сигналов,он должен использовать флаг SA_ONSTACK с сигналингом.Неспособность сделать это может привести к отказу программы,если сигнал получен.Входящие программы обычно запускаются с ограниченным стеком,и поэтому устанавливают альтернативный стек сигналов.Также стандартная библиотека Go ожидает,что любые обработчики сигналов будут использовать флаг SA_RESTART.Невыполнение этого требования может привести к тому,что некоторые вызовы библиотеки будут возвращать ошибки &quot;прерванного системного вызова&quot;.</target>
        </trans-unit>
        <trans-unit id="7e1d203998def7d0f58007e88176f92e21a64b50" translate="yes" xml:space="preserve">
          <source>If the non-Go code starts a new thread, changes the signal mask, and then invokes a Go function in that thread, the Go runtime will automatically unblock certain signals: the synchronous signals, SIGILL, SIGTRAP, SIGSTKFLT, SIGCHLD, SIGPROF, SIGCANCEL, and SIGSETXID. When the Go function returns, the non-Go signal mask will be restored.</source>
          <target state="translated">Если не-Go код запускает новый поток,изменяет маску сигналов,а затем вызывает функцию Go в этом потоке,запуск Go автоматически разблокирует определенные сигналы:синхронные сигналы,SIGILL,SIGTRAP,SIGSTKFLT,SIGCHLD,SIGPROF,SIGCANCEL и SIGSETXID.При возвращении функции &quot;Go&quot; маска сигналов,отличных от &quot;Go&quot;,будет восстановлена.</target>
        </trans-unit>
        <trans-unit id="91074ebc7a3334ebd4f37cdfabaa9ca32fd24f74" translate="yes" xml:space="preserve">
          <source>If the open fails, the error string will be self-explanatory, like</source>
          <target state="translated">Если открыть не удастся,то строка ошибки будет самообъясняющей,как например</target>
        </trans-unit>
        <trans-unit id="54fcc24f407eeb4900b5f210d5d49a96c53bb1c9" translate="yes" xml:space="preserve">
          <source>If the prefix of the status does not match the digits in expectCode, ReadCodeLine returns with err set to &amp;amp;Error{code, message}. For example, if expectCode is 31, an error will be returned if the status is not in the range [310,319].</source>
          <target state="translated">Если префикс статуса не соответствует цифрам в expectCode, ReadCodeLine возвращается с ошибкой, установленной на &amp;amp; Error {code, message}. Например, если expectCode равен 31, будет возвращена ошибка, если статус не находится в диапазоне [310,319].</target>
        </trans-unit>
        <trans-unit id="86837437a16860a8105279be00bffc491da5bba2" translate="yes" xml:space="preserve">
          <source>If the prefix of the status does not match the digits in expectCode, ReadResponse returns with err set to &amp;amp;Error{code, message}. For example, if expectCode is 31, an error will be returned if the status is not in the range [310,319].</source>
          <target state="translated">Если префикс статуса не соответствует цифрам в expectCode, ReadResponse возвращается с ошибкой, установленной на &amp;amp; Error {code, message}. Например, если expectCode равен 31, будет возвращена ошибка, если статус не находится в диапазоне [310,319].</target>
        </trans-unit>
        <trans-unit id="5ebf5ba32952d52f53e121ccb89f42cb9010f630" translate="yes" xml:space="preserve">
          <source>If the program has called Notify to receive SIGPIPE signals, the file descriptor number does not matter. The SIGPIPE signal will be delivered to the Notify channel, and the write will fail with an EPIPE error.</source>
          <target state="translated">Если программа вызвала Notify для получения сигналов SIGPIPE,то номер дескриптора файла не имеет значения.Сигнал SIGPIPE будет доставлен в канал Notify,и запись будет безуспешной с ошибкой EPIPE.</target>
        </trans-unit>
        <trans-unit id="7cf239f9c12fb938b9596c568e4f45900dce20bb" translate="yes" xml:space="preserve">
          <source>If the program has not called Notify to receive SIGPIPE signals, then the behavior depends on the file descriptor number. A write to a broken pipe on file descriptors 1 or 2 (standard output or standard error) will cause the program to exit with a SIGPIPE signal. A write to a broken pipe on some other file descriptor will take no action on the SIGPIPE signal, and the write will fail with an EPIPE error.</source>
          <target state="translated">Если программа не вызвала Notify для получения сигналов SIGPIPE,то поведение зависит от номера дескриптора файла.Запись в сломанную трубу по файловым дескрипторам 1 или 2 (стандартный вывод или стандартная ошибка)приведет к выходу программы с сигналом SIGPIPE.Запись в сломанную трубу на каком-нибудь другом файловом дескрипторе не предпримет никаких действий с сигналом SIGPIPE,и запись завершится неудачей с ошибкой EPIPE.</target>
        </trans-unit>
        <trans-unit id="111ef080bfe5d9de228261353c72d73b391743f0" translate="yes" xml:space="preserve">
          <source>If the program is started with a non-empty signal mask, some signals will be explicitly unblocked as described above. If Notify is called for a blocked signal, it will be unblocked. If, later, Reset is called for that signal, or Stop is called on all channels passed to Notify for that signal, the signal will once again be blocked.</source>
          <target state="translated">Если программа запускается с непустой сигнальной маской,то некоторые сигналы будут явно разблокированы,как описано выше.Если для заблокированного сигнала вызывается Notify,то он будет разблокирован.Если позже для этого сигнала будет вызван Сброс,или Stop будет вызван на всех каналах,переданных в Notify для этого сигнала,сигнал снова будет заблокирован.</target>
        </trans-unit>
        <trans-unit id="6b4f665c5cfb9144d49b7e1dcb5bc2df2bfa007a" translate="yes" xml:space="preserve">
          <source>If the program was started with SIGHUP or SIGINT ignored, and Notify is called for either signal, a signal handler will be installed for that signal and it will no longer be ignored. If, later, Reset or Ignore is called for that signal, or Stop is called on all channels passed to Notify for that signal, the signal will once again be ignored. Reset will restore the system default behavior for the signal, while Ignore will cause the system to ignore the signal entirely.</source>
          <target state="translated">Если программа была запущена с игнорированием SIGHUP или SIGINT,и для любого из сигналов был вызван Notify,то для этого сигнала будет установлен обработчик сигналов,который больше не будет игнорироваться.Если позже для этого сигнала будет вызван Reset или Ignore,или Stop на всех каналах,переданных в Notify для этого сигнала,сигнал будет снова проигнорирован.Сброс восстановит поведение системы по умолчанию для сигнала,а игнорирование приведет к тому,что система полностью проигнорирует сигнал.</target>
        </trans-unit>
        <trans-unit id="a50b71ad5f04ba376647400ad12d829202f07d7f" translate="yes" xml:space="preserve">
          <source>If the provided body is also an io.Closer, the returned Request.Body is set to body and will be closed by the Client methods Do, Post, and PostForm, and Transport.RoundTrip.</source>
          <target state="translated">Если предоставленный орган также является io.Closer,то возвращаемый Орган Запроса устанавливается в теле и будет закрыт Клиентом методами Do,Post,PostForm и Transport.RoundTrip.</target>
        </trans-unit>
        <trans-unit id="a90f0974cd32b46dcc6c15c91f94c9f93252ae8b" translate="yes" xml:space="preserve">
          <source>If the provided body is an io.Closer, it is closed after the request.</source>
          <target state="translated">Если предоставленный орган является io.Closer,он закрывается после запроса.</target>
        </trans-unit>
        <trans-unit id="76a4a3b11148dd18ae8c95298059edf28df076dc" translate="yes" xml:space="preserve">
          <source>If the provided file or directory name is a relative path, it is interpreted relative to the current directory and may ascend to parent directories. If the provided name is constructed from user input, it should be sanitized before calling ServeFile.</source>
          <target state="translated">Если имя предоставленного файла или директории является относительным путем,то оно интерпретируется относительно текущей директории и может восходить к родительским директориям.Если предоставленное имя построено из пользовательского ввода,оно должно быть дезинфицировано перед вызовом ServeFile.</target>
        </trans-unit>
        <trans-unit id="4e3cf22a6ffbc844d8cc7293fe5c88e56a31e62d" translate="yes" xml:space="preserve">
          <source>If the provided result precision is 0 (see below), it is set to the precision of the argument with the largest precision value before any rounding takes place, and the rounding mode remains unchanged. Thus, uninitialized Floats provided as result arguments will have their precision set to a reasonable value determined by the operands, and their mode is the zero value for RoundingMode (ToNearestEven).</source>
          <target state="translated">Если предоставленная точность результата равна 0 (см.ниже),то она устанавливается на точность аргумента с наибольшим значением точности до любого округления,и режим округления остается неизменным.Таким образом,неинициализированные поплавки,предоставленные в качестве аргументов результата,будут иметь точность,установленную операндами,в разумном значении,а их режим является нулевым значением для режима округления (ToNearestEven).</target>
        </trans-unit>
        <trans-unit id="2b88a75837ac44c3ec57492aadd63fbc336940cb" translate="yes" xml:space="preserve">
          <source>If the request Body's size has not already been limited by MaxBytesReader, the size is capped at 10MB.</source>
          <target state="translated">Если размер тела запроса еще не был ограничен MaxBytesReader,то размер ограничивается 10MB.</target>
        </trans-unit>
        <trans-unit id="202ca334b5c1306191933ea4f4be7458350d5dde" translate="yes" xml:space="preserve">
          <source>If the response is multi-line, ReadCodeLine returns an error.</source>
          <target state="translated">Если ответ является многострочным,ReadCodeLine возвращает ошибку.</target>
        </trans-unit>
        <trans-unit id="cca7e3754527e1fa0174f20268f5f2115cb686b6" translate="yes" xml:space="preserve">
          <source>If the response's Content-Type header is not set, ServeContent first tries to deduce the type from name's file extension and, if that fails, falls back to reading the first block of the content and passing it to DetectContentType. The name is otherwise unused; in particular it can be empty and is never sent in the response.</source>
          <target state="translated">Если заголовок Content-Type ответа не установлен,ServeContent сначала пытается вывести тип из расширения файла имени и,если это не удается,возвращается к чтению первого блока содержимого и передаче его в DetectContentType.В противном случае имя не используется;в частности,оно может быть пустым и никогда не отправляется в ответе.</target>
        </trans-unit>
        <trans-unit id="4adb610dc4446d1c29fb56aaef6e5c8a55dbd30c" translate="yes" xml:space="preserve">
          <source>If the result is enclosed in square brackets, as literal IPv6 addresses are, the square brackets are removed from the result.</source>
          <target state="translated">Если результат заключен в квадратные скобки,как буквальные IPv6 адреса,то квадратные скобки удаляются из результата.</target>
        </trans-unit>
        <trans-unit id="46d8ee162d5e124f43ba34e4b526da01d3ba6f66" translate="yes" xml:space="preserve">
          <source>If the result of this process is an empty string, Clean returns the string &quot;.&quot;.</source>
          <target state="translated">Если результатом этого процесса является пустая строка,то Clean возвращает строку &quot;.&quot;.</target>
        </trans-unit>
        <trans-unit id="63039cb93ec1523520a70aa02f8add44a72d2dcc" translate="yes" xml:space="preserve">
          <source>If the resulting type would be larger than the available address space, ArrayOf panics.</source>
          <target state="translated">Если результирующий тип будет больше доступного адресного пространства,ArrayOf паникует.</target>
        </trans-unit>
        <trans-unit id="49eb9c6b19926a8575c169e52f8df687a6338f21" translate="yes" xml:space="preserve">
          <source>If the returned error is nil, the Response will contain a non-nil Body which the user is expected to close. If the Body is not both read to EOF and closed, the Client's underlying RoundTripper (typically Transport) may not be able to re-use a persistent TCP connection to the server for a subsequent &quot;keep-alive&quot; request.</source>
          <target state="translated">Если возвращаемая ошибка равна нулю,то ответ будет содержать ненулевой корпус,который,как ожидается,будет закрыт пользователем.Если тело не считывается в EOF и не закрывается,то лежащий в основе клиента RoundTripper (обычно Transport)может быть не в состоянии повторно использовать постоянное TCP-соединение с сервером для последующего запроса &quot;keep-alive&quot;.</target>
        </trans-unit>
        <trans-unit id="2bd3e276f21c33ca258e2835ea6ef2502ea92047" translate="yes" xml:space="preserve">
          <source>If the returned token is a keyword, the literal string is the keyword.</source>
          <target state="translated">Если возвращаемая лексема является ключевым словом,то буквенная строка-это ключевое слово.</target>
        </trans-unit>
        <trans-unit id="d7865630a2cf1e24a8ed7ed472ba9beeb25fa193" translate="yes" xml:space="preserve">
          <source>If the returned token is a literal (token.IDENT, token.INT, token.FLOAT, token.IMAG, token.CHAR, token.STRING) or token.COMMENT, the literal string has the corresponding value.</source>
          <target state="translated">Если возвращаемый токен является литералом (token.IDENT,token.INT,token.FLOAT,token.IMAG,token.CHAR,token.STRING)или token.COMMENT,то строка литерала имеет соответствующее значение.</target>
        </trans-unit>
        <trans-unit id="7b330824cf4af38e2c2f1237e0044975056d896f" translate="yes" xml:space="preserve">
          <source>If the returned token is token.ILLEGAL, the literal string is the offending character.</source>
          <target state="translated">Если возвращаемая лексема является token.ILLEGAL,то буквенная строка является оскорбительным символом.</target>
        </trans-unit>
        <trans-unit id="f2065d9b79fae019bc66ef4f832603a41d2a079f" translate="yes" xml:space="preserve">
          <source>If the returned token is token.SEMICOLON, the corresponding literal string is &quot;;&quot; if the semicolon was present in the source, and &quot;\n&quot; if the semicolon was inserted because of a newline or at EOF.</source>
          <target state="translated">Если возвращаемый токен является token.SEMICOLON,то соответствующей строкой букв является &quot;;&quot;,если точка с запятой присутствовала в исходном тексте,и &quot;\n&quot;,если точка с запятой была вставлена из-за новой строки или в EOF.</target>
        </trans-unit>
        <trans-unit id="6d82694c27c567dcf0d737897e646720cd59f4a9" translate="yes" xml:space="preserve">
          <source>If the server replies with a redirect, the Client first uses the CheckRedirect function to determine whether the redirect should be followed. If permitted, a 301, 302, or 303 redirect causes subsequent requests to use HTTP method GET (or HEAD if the original request was HEAD), with no body. A 307 or 308 redirect preserves the original HTTP method and body, provided that the Request.GetBody function is defined. The NewRequest function automatically sets GetBody for common standard library body types.</source>
          <target state="translated">Если сервер отвечает перенаправлением,клиент сначала использует функцию CheckRedirect,чтобы определить,следует ли следовать перенаправлению.Если разрешено,301,302 или 303 перенаправление вызывает последующие запросы на использование HTTP метода GET (или HEAD,если исходный запрос был HEAD),без тела.307 или 308 перенаправление сохраняет оригинальный HTTP метод и тело,при условии,что функция Request.GetBody определена.Функция NewRequest автоматически устанавливает GetBody для общих стандартных типов тел библиотеки.</target>
        </trans-unit>
        <trans-unit id="8bef3b53d6d7bb99946b130aacd06c58001e65ba" translate="yes" xml:space="preserve">
          <source>If the source couldn't be read, the returned AST is nil and the error indicates the specific failure. If the source was read but syntax errors were found, the result is a partial AST (with ast.Bad* nodes representing the fragments of erroneous source code). Multiple errors are returned via a scanner.ErrorList which is sorted by file position.</source>
          <target state="translated">Если источник не мог быть прочитан,возвращаемый AST равен нулю,а ошибка указывает на конкретный сбой.Если источник был прочитан,но были найдены синтаксические ошибки,то в результате получается частичный AST (с аст.Bad*узлами,представляющими фрагменты ошибочного исходного кода).Многочисленные ошибки возвращаются через сканер.ErrorList,который сортируется по положению файла.</target>
        </trans-unit>
        <trans-unit id="0ea17fae18048ca3efef70d260f3befe5169300a" translate="yes" xml:space="preserve">
          <source>If the source couldn't be read, the returned AST is nil and the error indicates the specific failure. If the source was read but syntax errors were found, the result is a partial AST (with ast.Bad* nodes representing the fragments of erroneous source code). Multiple errors are returned via a scanner.ErrorList which is sorted by source position.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f66a139f57b43b60f302e27759bd0543bc9c0e26" translate="yes" xml:space="preserve">
          <source>If the time has a monotonic clock reading, the returned string includes a final field &quot;m=&amp;plusmn;&amp;lt;value&amp;gt;&quot;, where value is the monotonic clock reading formatted as a decimal number of seconds.</source>
          <target state="translated">Если время имеет монотонное показание часов, возвращаемая строка включает последнее поле &amp;laquo;m = &amp;plusmn; &amp;lt;значение&amp;gt;&amp;raquo;, где значение - это монотонное показание часов, отформатированное как десятичное число секунд.</target>
        </trans-unit>
        <trans-unit id="251f36d24e83127f4dd9319d7cdbc49677b94325" translate="yes" xml:space="preserve">
          <source>If the traceback function is called from a signal handler on a Unix system, SigContext will be the signal context argument passed to the signal handler (a C ucontext_t* cast to uintptr_t). This may be used to start tracing at the point where the signal occurred. If the traceback function is not called from a signal handler, SigContext will be zero.</source>
          <target state="translated">Если функция трассировки вызывается из обработчика сигналов на Unix-системе,то аргументом контекста сигнала,передаваемым обработчику сигнала,будет SigContext (C ucontext_t*,приведенный к uintptr_t).Это может быть использовано для начала трассировки в месте возникновения сигнала.Если функция трассировки не вызывается из обработчика сигнала,то SigContext будет равен нулю.</target>
        </trans-unit>
        <trans-unit id="07b1d78b08994662a459431d46bce8768415b25a" translate="yes" xml:space="preserve">
          <source>If the type name of a slice element ends with &quot;SET&quot; then it's treated as if the &quot;set&quot; tag was set on it. This can be used with nested slices where a struct tag cannot be given.</source>
          <target state="translated">Если имя типа элемента среза заканчивается на &quot;SET&quot;,то это рассматривается так,как если бы на нем был установлен тэг &quot;set&quot;.Это может быть использовано со вложенными срезами,где тег структуры не может быть задан.</target>
        </trans-unit>
        <trans-unit id="b1b298da75673ff2dc00ea6d79d2dbf4f6d4ad81" translate="yes" xml:space="preserve">
          <source>If the type of the first field of a structure is RawContent then the raw ASN1 contents of the struct will be stored in it.</source>
          <target state="translated">Если типом первого поля структуры является RawContent,то в нем будет храниться сырое содержимое структуры ASN1.</target>
        </trans-unit>
        <trans-unit id="94580cf18c0cdda91d151e0855e03334c0926847" translate="yes" xml:space="preserve">
          <source>If there are nested type ids, the types for all inner type ids must be defined before the top-level type id is used to describe an encoded-v.</source>
          <target state="translated">Если есть вложенные идентификаторы типов,то перед использованием идентификатора типа верхнего уровня для описания кодированного-v должны быть определены типы для всех внутренних идентификаторов типов.</target>
        </trans-unit>
        <trans-unit id="a4b08581fb59710f6d84824026b409a7e3fe2aea" translate="yes" xml:space="preserve">
          <source>If there is an error, it will be of type *PathError.</source>
          <target state="translated">Если есть ошибка,то она будет иметь тип *PathError.</target>
        </trans-unit>
        <trans-unit id="d59b10d118f91edc83c197a1ea597908270dd51e" translate="yes" xml:space="preserve">
          <source>If there is no registered handler that applies to the request, Handler returns a &amp;ldquo;page not found&amp;rdquo; handler and an empty pattern.</source>
          <target state="translated">Если нет зарегистрированного обработчика, который применяется к запросу, Handler возвращает обработчик &amp;laquo;страница не найдена&amp;raquo; и пустой шаблон.</target>
        </trans-unit>
        <trans-unit id="1a7ace82b8245bf4439307ba5dfdbd1b825dcfff" translate="yes" xml:space="preserve">
          <source>If there was a problem walking to the file or directory named by path, the incoming error will describe the problem and the function can decide how to handle that error (and Walk will not descend into that directory). In the case of an error, the info argument will be nil. If an error is returned, processing stops. The sole exception is when the function returns the special value SkipDir. If the function returns SkipDir when invoked on a directory, Walk skips the directory's contents entirely. If the function returns SkipDir when invoked on a non-directory file, Walk skips the remaining files in the containing directory.</source>
          <target state="translated">Если возникла проблема при переходе к файлу или каталогу,названному по пути,входящая ошибка будет описывать проблему,и функция может решить,как с ней справиться (и Walk не будет спускаться в этот каталог).В случае ошибки информационный аргумент будет равен нулю.В случае возврата ошибки обработка прекращается.Единственное исключение-когда функция возвращает специальное значение SkipDir.Если функция возвращает SkipDir при вызове в каталоге,Walk полностью пропускает содержимое каталога.Если функция возвращает SkipDir при вызове файла не из каталога,Walk пропускает оставшиеся файлы в содержащемся каталоге.</target>
        </trans-unit>
        <trans-unit id="b1b4c374c9ed31601280332f5174e595585d5e35" translate="yes" xml:space="preserve">
          <source>If this ClientHelloInfo was passed to a GetConfigForClient or GetCertificate callback, this method will take into account the associated Config. Note that if GetConfigForClient returns a different Config, the change can't be accounted for by this method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f28f83ac01122a6b8eb17da82fc365cf06db186" translate="yes" xml:space="preserve">
          <source>If this compilation unit has no line table, it returns nil, nil.</source>
          <target state="translated">Если этот компилятор не имеет строчной таблицы,он возвращает ноль,ноль.</target>
        </trans-unit>
        <trans-unit id="36cfd61621ceef678850032683735978215f2feb" translate="yes" xml:space="preserve">
          <source>If u.Host doesn't contain a valid numeric port, Port returns an empty string.</source>
          <target state="translated">Если u.Host не содержит правильного числового порта,порт возвращает пустую строку.</target>
        </trans-unit>
        <trans-unit id="1f16e20c1b2a3c0d7a413b8fa21221a527ff3a01" translate="yes" xml:space="preserve">
          <source>If u.Opaque is non-empty, String uses the first form; otherwise it uses the second form. Any non-ASCII characters in host are escaped. To obtain the path, String uses u.EscapedPath().</source>
          <target state="translated">Если u.Opaque не пустой,Строка использует первую форму,в противном случае-вторую.Любые не-ASCII символы в хосте экранируются.Для получения пути Строка использует u.EscapedPath().</target>
        </trans-unit>
        <trans-unit id="8013c9355c400aa79a6367baa057f4b9d4888841" translate="yes" xml:space="preserve">
          <source>If used in an unsafe context, then the value might be filtered out:</source>
          <target state="translated">При использовании в небезопасном контексте,значение может быть отфильтровано:</target>
        </trans-unit>
        <trans-unit id="169176f5802d140421e02d07f71892f55914e587" translate="yes" xml:space="preserve">
          <source>If v's Kind is Func, the returned pointer is an underlying code pointer, but not necessarily enough to identify a single function uniquely. The only guarantee is that the result is zero if and only if v is a nil func Value.</source>
          <target state="translated">Если v's Kind is Func,то возвращаемый указатель-это указатель,лежащий в основе кода,но не обязательно достаточный для однозначной идентификации одной функции.Единственная гарантия-результат равен нулю,если и только если v является нулевой функцией Value.</target>
        </trans-unit>
        <trans-unit id="ee9b69667b384fa6c8c1419304597f7a05f5dda4" translate="yes" xml:space="preserve">
          <source>If v's Kind is Slice, the returned pointer is to the first element of the slice. If the slice is nil the returned value is 0. If the slice is empty but non-nil the return value is non-zero.</source>
          <target state="translated">Если v's Kind-Slice,то возвращаемый указатель будет на первый элемент среза.Если ломтик равен нулю,возвращаемое значение равно 0,если ломтик пуст,но не равен нулю,возвращаемое значение ненулевое.</target>
        </trans-unit>
        <trans-unit id="c1a7d75eac6a2596c340ad7b921676eeff0e25d7" translate="yes" xml:space="preserve">
          <source>If v.Kind() != KindFloat64, this method panics.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c84cb549645a9f7d2d471fb47b82da9ad06c732f" translate="yes" xml:space="preserve">
          <source>If v.Kind() != KindFloat64Histogram, this method panics.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d38af9266598f3f9c2fc36f0c6cb6b077209017" translate="yes" xml:space="preserve">
          <source>If v.Kind() != KindUint64, this method panics.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ccce50575e90f1da7bb594b206672d76cc0b7fdc" translate="yes" xml:space="preserve">
          <source>If x is prime, ProbablyPrime returns true. If x is chosen randomly and not prime, ProbablyPrime probably returns false. The probability of returning true for a randomly chosen non-prime is at most &amp;frac14;ⁿ.</source>
          <target state="translated">Если x простое, ProbablyPrime возвращает true. Если x выбран случайным образом и не является простым, ProbablyPrime, вероятно, вернет false. Вероятность возврата true для случайно выбранного непростого числа составляет не более.</target>
        </trans-unit>
        <trans-unit id="e8a427ffc0c17926670bab4065e96207d4a28d2f" translate="yes" xml:space="preserve">
          <source>If you are not using DefaultServeMux, you will have to register handlers with the mux you are using.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf8bf41d1552e2a2314c86bbee51c546608c7502" translate="yes" xml:space="preserve">
          <source>If you like, you can bind the flag to a variable using the Var() functions.</source>
          <target state="translated">При желании можно привязать флаг к переменной с помощью функций Var().</target>
        </trans-unit>
        <trans-unit id="8a6f437f93f8b5dbc142b89b4316e10878736145" translate="yes" xml:space="preserve">
          <source>If your application is not already running an http server, you need to start one. Add &quot;net/http&quot; and &quot;log&quot; to your imports and the following code to your main function:</source>
          <target state="translated">Если ваше приложение еще не работает на http-сервере,необходимо его запустить.Добавьте &quot;net/http&quot; и &quot;log&quot; к вашему импорту и следующий код к вашей основной функции:</target>
        </trans-unit>
        <trans-unit id="e08bef57a6d48a73f233b8062ac1ffdd047f7ffe" translate="yes" xml:space="preserve">
          <source>If z's precision is 0, it is changed to x's precision before the operation. Rounding is performed according to z's precision and rounding mode, but z's accuracy is not computed. Specifically, the result of z.Acc() is undefined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7a7bb87f973e19b80ef2f0c235948e2ab80ca50" translate="yes" xml:space="preserve">
          <source>If z's precision is 0, it is changed to x's precision before the operation. Rounding is performed according to z's precision and rounding mode.</source>
          <target state="translated">Если точность z равна 0,то перед операцией она изменяется на точность x.Скругление выполняется в соответствии с точностью z и режимом скругления.</target>
        </trans-unit>
        <trans-unit id="bf3bdba69c06f396d015a2e68cfa8b8e0dc2a553" translate="yes" xml:space="preserve">
          <source>If {{.}} is the innocuous word, `left`, then it can appear more widely,</source>
          <target state="translated">Если это безобидное слово,&quot;левое&quot;,то оно может появиться шире,</target>
        </trans-unit>
        <trans-unit id="35dc1b1b93ecc62032ac0000d9cf5065af4bc463" translate="yes" xml:space="preserve">
          <source>IfNode represents an {{if}} action and its commands.</source>
          <target state="translated">IfNode представляет собой действие {{if}}и его команды.</target>
        </trans-unit>
        <trans-unit id="a40a74611ce76ddfa9aec134c7c4d57d7e7d1a0b" translate="yes" xml:space="preserve">
          <source>Ignore causes the provided signals to be ignored. If they are received by the program, nothing will happen. Ignore undoes the effect of any prior calls to Notify for the provided signals. If no signals are provided, all incoming signals will be ignored.</source>
          <target state="translated">Игнорирование приводит к тому,что предоставленные сигналы игнорируются.Если они будут получены программой,то ничего не произойдет.Проигнорировать отменяет эффект предыдущих звонков в Notify для предоставленных сигналов.Если сигналы не будут получены,все входящие сигналы будут проигнорированы.</target>
        </trans-unit>
        <trans-unit id="98d36857a614a1e009d79e216b4eb0d9115f0404" translate="yes" xml:space="preserve">
          <source>Ignored reports whether sig is currently ignored.</source>
          <target state="translated">Игнорируемые сообщения о том,игнорируется ли Зиг в настоящее время.</target>
        </trans-unit>
        <trans-unit id="4d88a112acad4eaba636cd685d95e848e229a4fb" translate="yes" xml:space="preserve">
          <source>Ilogb returns the binary exponent of x as an integer.</source>
          <target state="translated">Ilogb возвращает двоичный экспонент x в виде целого числа.</target>
        </trans-unit>
        <trans-unit id="44e069a8f4a7e1ac23418ede1f9fbec843a967dd" translate="yes" xml:space="preserve">
          <source>Imag returns the imaginary part of x, which must be a numeric or unknown value. If x is Unknown, the result is Unknown.</source>
          <target state="translated">Imag возвращает воображаемую часть x,которая должна быть числовым или неизвестным значением.Если x неизвестно,то результат будет Неизвестен.</target>
        </trans-unit>
        <trans-unit id="30d40b43edb0bdc3eabf2d534c36f9d06f964b6e" translate="yes" xml:space="preserve">
          <source>Image is a finite rectangular grid of color.Color values taken from a color model.</source>
          <target state="translated">Изображение представляет собой конечную прямоугольную сетку цвета.Значения цвета взяты из цветовой модели.</target>
        </trans-unit>
        <trans-unit id="26d71317c3ede5b3f54e923608b8db6326957a5e" translate="yes" xml:space="preserve">
          <source>Image is an image.Image with a Set method to change a single pixel.</source>
          <target state="translated">Изображение-это изображение с заданным методом изменения одного пикселя.</target>
        </trans-unit>
        <trans-unit id="b146748a0514484acff9fb056c40176e7e0d62af" translate="yes" xml:space="preserve">
          <source>Implementation restriction: The counting forms x{n,m}, x{n,}, and x{n} reject forms that create a minimum or maximum repetition count above 1000. Unlimited repetitions are not subject to this restriction.</source>
          <target state="translated">Ограничение на внедрение:Счетные формы x{n,m},x{n,}и x{n}отвергают формы,создающие минимальное или максимальное количество повторений,превышающее 1000.Неограниченные повторы не подпадают под это ограничение.</target>
        </trans-unit>
        <trans-unit id="75c9903908feb1732654db7dd3662c68681cf3c0" translate="yes" xml:space="preserve">
          <source>Implementations must not retain p.</source>
          <target state="translated">Вводы в эксплуатацию не должны сохранять p.</target>
        </trans-unit>
        <trans-unit id="baccfe949bd483e0aa453da0b286a6848971e885" translate="yes" xml:space="preserve">
          <source>Implementations of CookieJar must be safe for concurrent use by multiple goroutines.</source>
          <target state="translated">Введение CookieJar должно быть безопасным для одновременного использования несколькими горутинами.</target>
        </trans-unit>
        <trans-unit id="2496dd56381c55b51499d5f91502dcff20d2b771" translate="yes" xml:space="preserve">
          <source>Implementations of PublicSuffixList must be safe for concurrent use by multiple goroutines.</source>
          <target state="translated">Внедрение PublicSuffixList должно быть безопасным для одновременного использования несколькими горутинами.</target>
        </trans-unit>
        <trans-unit id="f73bf070b6238c284ef7b4d02061d370d3bb9d34" translate="yes" xml:space="preserve">
          <source>Implementations of Read are discouraged from returning a zero byte count with a nil error, except when len(p) == 0. Callers should treat a return of 0 and nil as indicating that nothing happened; in particular it does not indicate EOF.</source>
          <target state="translated">Не рекомендуется возвращать счетчик нулевых байтов с нулевой ошибкой,за исключением случаев,когда len(p)==0.Абоненты должны рассматривать возврат 0 и нуля как указание на то,что ничего не произошло;в частности,это не указывает на EOF.</target>
        </trans-unit>
        <trans-unit id="9c4eb58019f122cd6fcd79f868e42855509e5b17" translate="yes" xml:space="preserve">
          <source>Implementations of Token are discouraged from returning a nil token with a nil error. Callers should treat a return of nil, nil as indicating that nothing happened; in particular it does not indicate EOF.</source>
          <target state="translated">Не рекомендуется возвращать токен с ошибкой &quot;ноль&quot;.Звонящие должны относиться к возвращению ноль,ноль,как к указанию на то,что ничего не произошло;в частности,это не указывает на EOF.</target>
        </trans-unit>
        <trans-unit id="3b31ef7323ed3ca421b9bab6f7dbaab32c7ce726" translate="yes" xml:space="preserve">
          <source>Implements reports whether type V implements interface T.</source>
          <target state="translated">Вставляет отчеты о том,реализует ли тип V интерфейс T.</target>
        </trans-unit>
        <trans-unit id="5ba5f70840c67e6a055ce04e03bb2454bb162d9f" translate="yes" xml:space="preserve">
          <source>Import is shorthand for Default.Import.</source>
          <target state="translated">Импорт-это сокращение для Default.Import.</target>
        </trans-unit>
        <trans-unit id="6afc9b3e57abb6585be9561d376bdea28ca944ae" translate="yes" xml:space="preserve">
          <source>Import returns details about the Go package named by the import path, interpreting local import paths relative to the srcDir directory. If the path is a local import path naming a package that can be imported using a standard import path, the returned package will set p.ImportPath to that path.</source>
          <target state="translated">Импорт возвращает подробную информацию о пакете Go,названном по пути импорта,интерпретируя локальные пути импорта относительно каталога srcDir.Если путь-локальный путь импорта,именующий пакет,который может быть импортирован по стандартному пути импорта,возвращаемый пакет установит p.ImportPath в этот путь.</target>
        </trans-unit>
        <trans-unit id="93d88a517c9d75699c2e4045b6e3fc932cd88482" translate="yes" xml:space="preserve">
          <source>ImportDir is like Import but processes the Go package found in the named directory.</source>
          <target state="translated">ImportDir похож на Import,но обрабатывает пакет Go,находящийся в именованной директории.</target>
        </trans-unit>
        <trans-unit id="58d6f3af90d9fbc41be2c405bfa8615d93151250" translate="yes" xml:space="preserve">
          <source>ImportDir is shorthand for Default.ImportDir.</source>
          <target state="translated">ImportDir-сокращение от Default.ImportDir.</target>
        </trans-unit>
        <trans-unit id="2d321830ed77e3baaf4ac8b7f7efc36408c85002" translate="yes" xml:space="preserve">
          <source>ImportMode is reserved for future use.</source>
          <target state="translated">ImportMode зарезервирован для использования в будущем.</target>
        </trans-unit>
        <trans-unit id="81d5bfd42309b64b183f9701f930099193a14426" translate="yes" xml:space="preserve">
          <source>Imported returns the package that was imported. It is distinct from Pkg(), which is the package containing the import statement.</source>
          <target state="translated">Импортированная упаковка возвращает импортированную.Она отличается от Pkg(),которая является пакетом,содержащим заявление об импорте.</target>
        </trans-unit>
        <trans-unit id="98f8e071166bb5be3aecf52c0312f3d8e38c742a" translate="yes" xml:space="preserve">
          <source>ImportedLibraries returns the names of all libraries referred to by the binary f that are expected to be linked with the binary at dynamic link time.</source>
          <target state="translated">ImportedLibraries возвращает имена всех библиотек,на которые ссылается двоичный файл f и которые,как ожидается,будут связаны с двоичным файлом во время динамической связи.</target>
        </trans-unit>
        <trans-unit id="6d0d053d5be94190ae4125e53a45e74c9bfff903" translate="yes" xml:space="preserve">
          <source>ImportedLibraries returns the paths of all libraries referred to by the binary f that are expected to be linked with the binary at dynamic link time.</source>
          <target state="translated">ImportedLibraries возвращает пути всех библиотек,на которые ссылается двоичный файл f и которые,как ожидается,будут связаны с двоичным файлом во время динамической связи.</target>
        </trans-unit>
        <trans-unit id="27f49356d80e117cb6ff37f13e3b8dc616e332cb" translate="yes" xml:space="preserve">
          <source>ImportedSymbols returns the names of all symbols referred to by the binary f that are expected to be satisfied by other libraries at dynamic load time.</source>
          <target state="translated">ImportedSymbols возвращает имена всех символов,на которые ссылается двоичный файл f и которые,как ожидается,будут удовлетворяться другими библиотеками во время динамической загрузки.</target>
        </trans-unit>
        <trans-unit id="80301d15602072b275cf4e9d642684ee556fd2a0" translate="yes" xml:space="preserve">
          <source>ImportedSymbols returns the names of all symbols referred to by the binary f that are expected to be satisfied by other libraries at dynamic load time. It does not return weak symbols.</source>
          <target state="translated">ImportedSymbols возвращает имена всех символов,на которые ссылается двоичный файл f и которые,как ожидается,будут удовлетворяться другими библиотеками во время динамической загрузки.Не возвращает слабые символы.</target>
        </trans-unit>
        <trans-unit id="a7a177ffbe3a55cdc66a04d44c08bbd35566d366" translate="yes" xml:space="preserve">
          <source>Importing this package will increase the size of a program by about 450 KB.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5940cf724f4e1c9daed64775970e063932394d8" translate="yes" xml:space="preserve">
          <source>Importing this package will increase the size of a program by about 800 KB.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75eb201c4952cde504ceda9eb34765cbfc018641" translate="yes" xml:space="preserve">
          <source>Imports returns the list of packages directly imported by pkg; the list is in source order.</source>
          <target state="translated">Импорт возвращает список пакетов,непосредственно импортированных pkg;список находится в исходном порядке.</target>
        </trans-unit>
        <trans-unit id="cb7bc76d7380682c92ffb45e3be0edf510619c0c" translate="yes" xml:space="preserve">
          <source>In C syntax, this struct will be</source>
          <target state="translated">В синтаксисе C эта структура будет</target>
        </trans-unit>
        <trans-unit id="031e67b82062bc206ba16bfbb78969301350778f" translate="yes" xml:space="preserve">
          <source>In Go 1 and Go 1.1, each package produced one Obj for all Go sources and one Obj per C source file.</source>
          <target state="translated">В Go 1 и Go 1.1 каждый пакет создал один Объект для всех исходных текстов Go и один Объект для каждого исходного файла C.</target>
        </trans-unit>
        <trans-unit id="f1a4145c4d681021c6b688a748d3fd850af7e56f" translate="yes" xml:space="preserve">
          <source>In Go 1.1 and earlier, each function (represented by a Func) had its own LineTable, and the line number corresponded to a numbering of all source lines in the program, across all files. That absolute line number would then have to be converted separately to a file name and line number within the file.</source>
          <target state="translated">В Go 1.1 и более ранних версиях каждая функция (представленная функцией)имела свою собственную LineTable,а номер строки соответствовал нумерации всех исходных строк в программе,во всех файлах.Этот абсолютный номер строки затем должен был быть преобразован отдельно в имя файла и номер строки внутри файла.</target>
        </trans-unit>
        <trans-unit id="35c4a15e4a2e0d9709fe9d9d2d8891336f5119ee" translate="yes" xml:space="preserve">
          <source>In Go 1.12 and earlier, it was possible to distribute packages in binary form without including the source code used for compiling the package. The package was distributed with a source file not excluded by build constraints and containing a &quot;//go:binary-only-package&quot; comment. Like a build constraint, this comment appeared at the top of a file, preceded only by blank lines and other line comments and with a blank line following the comment, to separate it from the package documentation. Unlike build constraints, this comment is only recognized in non-test Go source files.</source>
          <target state="translated">В Go 1.12 и более ранних версиях было возможно распространять пакеты в двоичном виде без включения исходных текстов,использованных для компиляции пакета.Пакет распространялся с файлом исходного текста,не исключенным ограничениями на сборку,и содержащим комментарий &quot;//go:binary-only-package&quot;.Подобно ограничению на сборку,этот комментарий появлялся в верхней части файла,перед ним стояли только пустые строки и другие комментарии в виде строк,а также пустая строка после комментария,чтобы отделить его от документации по пакету.В отличие от ограничений на сборку,этот комментарий распознается только в нетестовых исходных файлах Go.</target>
        </trans-unit>
        <trans-unit id="cc8775c16cc6c9f67e9f67d2c4b9b38bd2343802" translate="yes" xml:space="preserve">
          <source>In Go 1.2, the format of the data changed so that there is a single LineTable for the entire program, shared by all Funcs, and there are no absolute line numbers, just line numbers within specific files.</source>
          <target state="translated">В Go 1.2 формат данных изменился таким образом,что существует одна LineTable для всей программы,общая для всех Funcs,и нет абсолютных номеров строк,только номера строк в конкретных файлах.</target>
        </trans-unit>
        <trans-unit id="94c3f9b8a2f1195c43f29bc6d1587c741d49bcbe" translate="yes" xml:space="preserve">
          <source>In Go 1.2, there is a single Obj for the entire program.</source>
          <target state="translated">В Go 1.2 есть один Объект для всей программы.</target>
        </trans-unit>
        <trans-unit id="fc1a1510c05c5e605f2bf42bab100aff6fd4f01e" translate="yes" xml:space="preserve">
          <source>In Printf, Sprintf, and Fprintf, the default behavior is for each formatting verb to format successive arguments passed in the call. However, the notation [n] immediately before the verb indicates that the nth one-indexed argument is to be formatted instead. The same notation before a '*' for a width or precision selects the argument index holding the value. After processing a bracketed expression [n], subsequent verbs will use arguments n+1, n+2, etc. unless otherwise directed.</source>
          <target state="translated">В Printf,Sprintf и Fprintf поведение по умолчанию заключается в том,чтобы для каждого глагола форматирования отформатировать последовательные аргументы,передаваемые при вызове.Однако,нотация [n]непосредственно перед глаголом указывает на то,что вместо него должен быть отформатирован n-й одноиндексированный аргумент.Та же самая нотация перед '*' для ширины или точности выбирает индекс аргумента,содержащий значение.После обработки выражения [n],заключенного в скобки,последующие глаголы будут использовать аргументы n+1,n+2 и т.д.,если не указано иное.</target>
        </trans-unit>
        <trans-unit id="6f69301b556dc9f571bc4bb3612422a63af49e86" translate="yes" xml:space="preserve">
          <source>In TLS 1.3, this type is called NamedGroup, but at this time this library only supports Elliptic Curve based groups. See RFC 8446, Section 4.2.7.</source>
          <target state="translated">В TLS 1.3 этот тип называется NamedGroup,но в настоящее время эта библиотека поддерживает только группы,основанные на эллиптических кривых.См.RFC 8446,Раздел 4.2.7.</target>
        </trans-unit>
        <trans-unit id="93a2aff531fe6a26d094463bdd12d8ce980726db" translate="yes" xml:space="preserve">
          <source>In a Go program that includes non-Go code, typically C/C++ code accessed using cgo or SWIG, Go's startup code normally runs first. It configures the signal handlers as expected by the Go runtime, before the non-Go startup code runs. If the non-Go startup code wishes to install its own signal handlers, it must take certain steps to keep Go working well. This section documents those steps and the overall effect changes to signal handler settings by the non-Go code can have on Go programs. In rare cases, the non-Go code may run before the Go code, in which case the next section also applies.</source>
          <target state="translated">В программе Go,которая включает в себя не-Go код,как правило,C/C++код,доступ к которому осуществляется с помощью cgo или SWIG,стартовый код Go обычно выполняется в первую очередь.Он настраивает обработчики сигналов так,как это ожидается во время выполнения программы Go,до того,как запустится код,отличный от Go.Если не-Go код запуска хочет установить свои собственные обработчики сигналов,он должен предпринять определенные шаги,чтобы Go работал хорошо.В этом разделе описываются эти шаги и общий эффект,который изменения в настройках обработчиков сигналов кодом,отличным от Go,могут оказать на программы Go.В редких случаях,не-Go код может выполняться перед Go кодом,в этом случае также применяется следующий раздел.</target>
        </trans-unit>
        <trans-unit id="b709a8b5c95be5a899a7612ec04af9fcd8c6fe68" translate="yes" xml:space="preserve">
          <source>In addition to adding the HTTP handler, this package registers the following variables:</source>
          <target state="translated">В дополнение к добавлению HTTP-обработчика,данный пакет регистрирует следующие переменные:</target>
        </trans-unit>
        <trans-unit id="c7232c786e65fae897885a5d1905f0858ffd2ae2" translate="yes" xml:space="preserve">
          <source>In addition to the required &amp;ldquo;wall clock&amp;rdquo; reading, a Time may contain an optional reading of the current process's monotonic clock, to provide additional precision for comparison or subtraction. See the &amp;ldquo;Monotonic Clocks&amp;rdquo; section in the package documentation for details.</source>
          <target state="translated">В дополнение к требуемому показанию &amp;laquo;настенных часов&amp;raquo;, Time может содержать необязательное показание монотонных часов текущего процесса, чтобы обеспечить дополнительную точность для сравнения или вычитания. См. Подробности в разделе &amp;laquo;Монотонные часы&amp;raquo; в документации по пакету.</target>
        </trans-unit>
        <trans-unit id="965439857efd394443e37d36ace60b7ac7d83473" translate="yes" xml:space="preserve">
          <source>In addition to the struct tags recognised by Unmarshal, the following can be used:</source>
          <target state="translated">В дополнение к структурным тегам,распознаваемым Unmarshal,могут быть использованы следующие:</target>
        </trans-unit>
        <trans-unit id="d07fa607208161c419b4aff2675e4f243b41086c" translate="yes" xml:space="preserve">
          <source>In all other cases, Scan returns an empty literal string.</source>
          <target state="translated">Во всех остальных случаях Scan возвращает пустую строку литерала.</target>
        </trans-unit>
        <trans-unit id="dc451d8d43456b62826bda28dfbc96cdb2eb2524" translate="yes" xml:space="preserve">
          <source>In all the scanning functions, a carriage return followed immediately by a newline is treated as a plain newline (\r\n means the same as \n).</source>
          <target state="translated">Во всех функциях сканирования возврат каретки с последующим немедленным переходом на новую строку рассматривается как обычная новая строка (\r\n означает то же самое,что и \n).</target>
        </trans-unit>
        <trans-unit id="fedccbf24f7f68d8101f599e3218a03c5ffaf765" translate="yes" xml:space="preserve">
          <source>In all the scanning functions, if an operand implements method Scan (that is, it implements the Scanner interface) that method will be used to scan the text for that operand. Also, if the number of arguments scanned is less than the number of arguments provided, an error is returned.</source>
          <target state="translated">Во всех функциях сканирования,если операнд реализует метод Scan (т.е.реализует интерфейс Scanner),этот метод будет использоваться для сканирования текста для данного операнда.Также,если количество отсканированных аргументов меньше,чем количество предоставленных аргументов,возвращается ошибка.</target>
        </trans-unit>
        <trans-unit id="a1bf502195aaabff9af8feae702eb1ba2c806b3d" translate="yes" xml:space="preserve">
          <source>In an ErrorList, an error is represented by an *Error. The position Pos, if valid, points to the beginning of the offending token, and the error condition is described by Msg.</source>
          <target state="translated">В ErrorList'е ошибка представлена в виде *ErrorList'а.Позиция Pos,если она верна,указывает на начало маркера-нарушителя,а состояние ошибки описывается Msg.</target>
        </trans-unit>
        <trans-unit id="c43ce5959f73c41a703ce648d64371023d38a1e1" translate="yes" xml:space="preserve">
          <source>In early versions of Go each source file became a different Obj.</source>
          <target state="translated">В ранних версиях Go каждый исходный файл становился отдельным объектом.</target>
        </trans-unit>
        <trans-unit id="42a68547a9dca9735cb7eba8147953340f09b72e" translate="yes" xml:space="preserve">
          <source>In effect, the method must look schematically like</source>
          <target state="translated">По сути,метод должен выглядеть схематично как</target>
        </trans-unit>
        <trans-unit id="b72051420981768a1127b1640516d07dc80b1c1a" translate="yes" xml:space="preserve">
          <source>In general DeepEqual is a recursive relaxation of Go's == operator. However, this idea is impossible to implement without some inconsistency. Specifically, it is possible for a value to be unequal to itself, either because it is of func type (uncomparable in general) or because it is a floating-point NaN value (not equal to itself in floating-point comparison), or because it is an array, struct, or interface containing such a value. On the other hand, pointer values are always equal to themselves, even if they point at or contain such problematic values, because they compare equal using Go's == operator, and that is a sufficient condition to be deeply equal, regardless of content. DeepEqual has been defined so that the same short-cut applies to slices and maps: if x and y are the same slice or the same map, they are deeply equal regardless of content.</source>
          <target state="translated">В общем DeepEqual-это рекурсивная релаксация оператора Go's ==.Однако эту идею невозможно реализовать без некоторой несогласованности.В частности,значение может быть неравнозначным самому себе,либо потому,что оно имеет тип func (вообще несопоставимо),либо потому,что это значение NaN с плавающей точкой (не равно самому себе при сравнении с плавающей точкой),либо потому,что это массив,структура или интерфейс,содержащий такое значение.С другой стороны,значения указателей всегда равны самим себе,даже если они указывают на такие проблемные значения или содержат их,потому что они сравнивают equal,используя оператор Go's ==,и это достаточное условие,чтобы быть глубоко равными,независимо от содержимого.DeepEqual был определен таким образом,что один и тот же короткий отрезок применяется к фрагментам и картам:если x и y-один и тот же фрагмент или одна и та же карта,то они глубоко равны,независимо от содержимого.</target>
        </trans-unit>
        <trans-unit id="07b960c708d879d40875264c73a08a0683383d6b" translate="yes" xml:space="preserve">
          <source>In general, a given attribute's value may take on one of several possible classes defined by DWARF, each of which leads to a slightly different interpretation of the attribute.</source>
          <target state="translated">В целом,значение данного атрибута может принимать один из нескольких возможных классов,определенных DWARF,каждый из которых приводит к несколько различной интерпретации атрибута.</target>
        </trans-unit>
        <trans-unit id="2e9ecaaf397056078378f799dda9c4e1072c7928" translate="yes" xml:space="preserve">
          <source>In general, a gzip file can be a concatenation of gzip files, each with its own header. Reads from the Reader return the concatenation of the uncompressed data of each. Only the first header is recorded in the Reader fields.</source>
          <target state="translated">В общем случае,gzip-файл может представлять собой конкатенцию gzip-файлов,каждый из которых имеет свой заголовок.Читая из Читателя,возвращаем конкатенуацию несжатых данных каждого из них.В поля Чтения записывается только первый заголовок.</target>
        </trans-unit>
        <trans-unit id="b6ffd0a95c8557850de7ace105d0c02e95a18d70" translate="yes" xml:space="preserve">
          <source>In general, if allocation is required, the decoder will allocate memory. If not, it will update the destination variables with values read from the stream. It does not initialize them first, so if the destination is a compound value such as a map, struct, or slice, the decoded values will be merged elementwise into the existing variables.</source>
          <target state="translated">В общем случае,если выделение необходимо,декодер выделит память.Если нет,то он будет обновлять целевые переменные значениями,считанными из потока.Он не инициализирует их сначала,поэтому,если назначение является составным значением,таким как карта,структура или срез,декодированные значения будут объединены по элементам в существующие переменные.</target>
        </trans-unit>
        <trans-unit id="d1a73603a88217147c68ec9c324a3f4cba1ebddc" translate="yes" xml:space="preserve">
          <source>In general, reflect.SliceHeader and reflect.StringHeader should be used only as *reflect.SliceHeader and *reflect.StringHeader pointing at actual slices or strings, never as plain structs. A program should not declare or allocate variables of these struct types.</source>
          <target state="translated">В целом,reflect.SliceHeader и reflect.StringHeader должны использоваться только как *reflect.SliceHeader и *reflect.StringHeader,указывающие на фактические срезы или строки,а не как простые структуры.Программа не должна объявлять или выделять переменные этих типов структур.</target>
        </trans-unit>
        <trans-unit id="99dc4b6fd44a858b786d20b64de92f5f16319ca0" translate="yes" xml:space="preserve">
          <source>In general, the GHASH operation performed by this implementation of GCM is not constant-time. An exception is when the underlying Block was created by aes.NewCipher on systems with hardware support for AES. See the crypto/aes package documentation for details.</source>
          <target state="translated">В целом,операция GHASH,выполняемая при данной реализации МОЦ,не является постоянной.Исключением является случай,когда базовый блок был создан aes.NewCipher на системах с аппаратной поддержкой AES.Подробности см.в документации к пакету crypto/aes.</target>
        </trans-unit>
        <trans-unit id="63a94d50c6e71995bfdddbf6d3b7ddbbd572fca1" translate="yes" xml:space="preserve">
          <source>In most cases, new(Buffer) (or just declaring a Buffer variable) is sufficient to initialize a Buffer.</source>
          <target state="translated">В большинстве случаев для инициализации буфера достаточно new(Buffer)(или просто объявления буферной переменной).</target>
        </trans-unit>
        <trans-unit id="ce6abe6e4a1757599621f3d92af6850089e3e51d" translate="yes" xml:space="preserve">
          <source>In non-HTML settings where the escaping interferes with the readability of the output, SetEscapeHTML(false) disables this behavior.</source>
          <target state="translated">В настройках,отличных от HTML,где экранирование препятствует читабельности вывода,SetEscapeHTML(false)отключает это поведение.</target>
        </trans-unit>
        <trans-unit id="7077ca93ebf4ef49120708550f14d220620ccf80" translate="yes" xml:space="preserve">
          <source>In panics if loc is nil.</source>
          <target state="translated">В панике,если Лок ноль.</target>
        </trans-unit>
        <trans-unit id="f52d38c87623b45c8b7767cba23884c87bb2c3a8" translate="yes" xml:space="preserve">
          <source>In particular, it implements LZW as used by the GIF and PDF file formats, which means variable-width codes up to 12 bits and the first two non-literal codes are a clear code and an EOF code.</source>
          <target state="translated">В частности,он реализует LZW в том виде,в котором он используется в форматах GIF и PDF,т.е.коды с переменной шириной до 12 бит,а первые два нелитеральных кода-это чистый код и код EOF.</target>
        </trans-unit>
        <trans-unit id="4026aa85ef00c786dfe0c796e4b667cd2644b68d" translate="yes" xml:space="preserve">
          <source>In performance critical applications, Reset can be used to discard the current compressor or decompressor state and reinitialize them quickly by taking advantage of previously allocated memory.</source>
          <target state="translated">В приложениях,критичных по производительности,Сброс может быть использован для сброса текущего состояния компрессора или декомпрессора и их быстрой повторной инициализации,используя преимущества ранее выделенной памяти.</target>
        </trans-unit>
        <trans-unit id="6db233d0c99db26b8c12c611c05604abfea98d46" translate="yes" xml:space="preserve">
          <source>In reports whether every point in r is in s.</source>
          <target state="translated">В отчетах о том,находится ли каждая точка в r в s.</target>
        </trans-unit>
        <trans-unit id="84fe4eae8d319a1913e35010d51f1271fd7ded56" translate="yes" xml:space="preserve">
          <source>In reports whether p is in r.</source>
          <target state="translated">В отчетах о том,находится ли p в r.</target>
        </trans-unit>
        <trans-unit id="0fd55e418f00485b3f2efc5b428b0418b6a94be8" translate="yes" xml:space="preserve">
          <source>In reports whether the rune is a member of one of the ranges.</source>
          <target state="translated">В отчетах сообщается,является ли руна членом одного из диапазонов.</target>
        </trans-unit>
        <trans-unit id="472b3dea5785c77ec21b439277ea93730e47a2be" translate="yes" xml:space="preserve">
          <source>In returns a copy of t representing the same time instant, but with the copy's location information set to loc for display purposes.</source>
          <target state="translated">Возвращает копию t,представляющую собой одно и то же мгновенное время,но с информацией о местоположении копии,установленной в целях отображения.</target>
        </trans-unit>
        <trans-unit id="711d8c9ceb05e3476e4192e2fd5e66ccc3b3ba1b" translate="yes" xml:space="preserve">
          <source>In slices and arrays, as well as maps, all elements, even zero-valued elements, are transmitted, even if all the elements are zero.</source>
          <target state="translated">В фрагментах и массивах,а также на картах передаются все элементы,даже элементы с нулевым значением,даже если все элементы равны нулю.</target>
        </trans-unit>
        <trans-unit id="9f17f1b7292d381dce79c4e2b9b83d7f1d5da96e" translate="yes" xml:space="preserve">
          <source>In summary, a gob stream looks like</source>
          <target state="translated">Подводя итог,можно сказать,что поток кусочков выглядит как</target>
        </trans-unit>
        <trans-unit id="2d78ddedbd337c0bea6888e7055a4838325b74f8" translate="yes" xml:space="preserve">
          <source>In the $name form, name is taken to be as long as possible: $1x is equivalent to ${1x}, not ${1}x, and, $10 is equivalent to ${10}, not ${1}0.</source>
          <target state="translated">В форме имени $,имя принимается как можно более длинным:$1x эквивалентно ${1x},а не ${1}x,и $10 эквивалентно ${10},а не ${1}0.</target>
        </trans-unit>
        <trans-unit id="37a0ec0d20103e0c83570c4610c7755ff7ac53c0" translate="yes" xml:space="preserve">
          <source>In the absence of a time zone indicator, Parse returns a time in UTC.</source>
          <target state="translated">При отсутствии индикатора часового пояса Parse возвращает время по UTC.</target>
        </trans-unit>
        <trans-unit id="b029486adc899e6b2e4bce186582f459ceb89a34" translate="yes" xml:space="preserve">
          <source>In the directory containing the package, .go, .c, .h, and .s files are considered part of the package except for:</source>
          <target state="translated">В каталоге,содержащем пакет,файлы .go,.c,.h и .s считаются частью пакета,за исключением файлов:</target>
        </trans-unit>
        <trans-unit id="fa1c6c88c18a52fe6d2731df7b2ac739dc65317f" translate="yes" xml:space="preserve">
          <source>In the format string, a verb introduced by the % character consumes and parses input; these verbs are described in more detail below. A character other than %, space, or newline in the format consumes exactly that input character, which must be present. A newline with zero or more spaces before it in the format string consumes zero or more spaces in the input followed by a single newline or the end of the input. A space following a newline in the format string consumes zero or more spaces in the input. Otherwise, any run of one or more spaces in the format string consumes as many spaces as possible in the input. Unless the run of spaces in the format string appears adjacent to a newline, the run must consume at least one space from the input or find the end of the input.</source>
          <target state="translated">В строке форматирования глагол,введенный символом %,потребляет и анализирует введенные глаголы;подробнее эти глаголы описаны ниже.Символ,отличный от %,пробела или новой строки в формате,потребляет именно тот входной символ,который должен присутствовать.Новую строку с нулем или большим количеством пробелов перед ней в строке формата потребляет ноль или большее количество пробелов во входных данных,за которым следует одна новая строка или конец входных данных.Пробел,следующий за новой строкой в строке формата,занимает на входе ноль или больше пробелов.В противном случае любой прогон одной или нескольких строк формата занимает во входном сигнале как можно больше пробелов.Если только пробег пробелов в строке формата не появляется рядом с новой строкой,пробег должен занимать не менее одного пробела на входе или находить конец входа.</target>
        </trans-unit>
        <trans-unit id="ed1a2050a365f5d52ef37144115d11517ff42bc2" translate="yes" xml:space="preserve">
          <source>In the most simple case, if the type of the value from the source column is an integer, bool or string type T and dest is of type *T, Scan simply assigns the value through the pointer.</source>
          <target state="translated">В самом простом случае,если тип значения из исходного столбца-целое число,bool или строковый тип T,а dest-тип *T,Scan просто присваивает значение через указатель.</target>
        </trans-unit>
        <trans-unit id="5c811352496639bcd7be1278e40839e6992f883a" translate="yes" xml:space="preserve">
          <source>In the second form, the following rules apply:</source>
          <target state="translated">Во второй форме применяются следующие правила:</target>
        </trans-unit>
        <trans-unit id="9ca6beb2058ca8ef81c9dbee1705e13b3578af1f" translate="yes" xml:space="preserve">
          <source>In the template, a variable is denoted by a substring of the form $name or ${name}, where name is a non-empty sequence of letters, digits, and underscores. A purely numeric name like $1 refers to the submatch with the corresponding index; other names refer to capturing parentheses named with the (?P&amp;lt;name&amp;gt;...) syntax. A reference to an out of range or unmatched index or a name that is not present in the regular expression is replaced with an empty slice.</source>
          <target state="translated">В шаблоне переменная обозначается подстрокой вида $ name или $ {name}, где name - это непустая последовательность букв, цифр и знаков подчеркивания. Чисто числовое имя, например $ 1, относится к подматчу с соответствующим индексом; другие имена относятся к захватывающим скобкам с синтаксисом (? P &amp;lt;name&amp;gt; ...). Ссылка на индекс вне допустимого диапазона, несоответствующий индекс или имя, отсутствующее в регулярном выражении, заменяется пустым срезом.</target>
        </trans-unit>
        <trans-unit id="5a1c160af25c73f96bab58b7ac18692fbbe1ffa1" translate="yes" xml:space="preserve">
          <source>In the terminology of the zlib library, Flush is equivalent to Z_SYNC_FLUSH.</source>
          <target state="translated">В терминологии библиотеки zlib Flush эквивалентен Z_SYNC_FLUSH.</target>
        </trans-unit>
        <trans-unit id="2dd7b02fa4aa241d6b5f4aad090e1521eaf7af73" translate="yes" xml:space="preserve">
          <source>In this usage hdr.Data is really an alternate way to refer to the underlying pointer in the string header, not a uintptr variable itself.</source>
          <target state="translated">При таком использовании hdr.Data действительно является альтернативным способом обращения к базовому указателю в заголовке строки,а не к самой переменной uintptr.</target>
        </trans-unit>
        <trans-unit id="b66dfbc84a8b6f209be163efb64c95ba40440449" translate="yes" xml:space="preserve">
          <source>InUseBytes returns the number of bytes in use (AllocBytes - FreeBytes).</source>
          <target state="translated">InUseBytes возвращает количество используемых байт (AllocBytes-FreeBytes).</target>
        </trans-unit>
        <trans-unit id="d6ed56286846a6cf59f0baa7c19dd1836590eeba" translate="yes" xml:space="preserve">
          <source>InUseObjects returns the number of objects in use (AllocObjects - FreeObjects).</source>
          <target state="translated">InUseObjects возвращает количество используемых объектов (AllocObjects-FreeObjects).</target>
        </trans-unit>
        <trans-unit id="dfe141017385b1d5692d01442e77119d4a1ae1e2" translate="yes" xml:space="preserve">
          <source>Incoming requests to a server should create a Context, and outgoing calls to servers should accept a Context. The chain of function calls between them must propagate the Context, optionally replacing it with a derived Context created using WithCancel, WithDeadline, WithTimeout, or WithValue. When a Context is canceled, all Contexts derived from it are also canceled.</source>
          <target state="translated">Входящие запросы к серверу должны создавать Контекст,а исходящие звонки к серверам должны принимать Контекст.Цепь вызовов функций между ними должна распространять Контекст,опционально заменяя его на производный Контекст,созданный с помощью WithCancel,WithDeadline,WithTimeout или WithValue.Когда Контекст отменяется,все производные от него Контексты также отменяются.</target>
        </trans-unit>
        <trans-unit id="f3527c443ffc9a19a79c9a5af60b69f82dd615d1" translate="yes" xml:space="preserve">
          <source>IncorrectPasswordError is returned when an incorrect password is detected.</source>
          <target state="translated">При обнаружении неверного пароля возвращается ошибкаPasswordError.</target>
        </trans-unit>
        <trans-unit id="aacf42132cce6cf5c1608a5d27f90fcbf93ae851" translate="yes" xml:space="preserve">
          <source>Indent</source>
          <target state="translated">Indent</target>
        </trans-unit>
        <trans-unit id="ffaaf5870213dda02bfcfd6086cb6c73c505917c" translate="yes" xml:space="preserve">
          <source>Indent appends to dst an indented form of the JSON-encoded src. Each element in a JSON object or array begins on a new, indented line beginning with prefix followed by one or more copies of indent according to the indentation nesting. The data appended to dst does not begin with the prefix nor any indentation, to make it easier to embed inside other formatted JSON data. Although leading space characters (space, tab, carriage return, newline) at the beginning of src are dropped, trailing space characters at the end of src are preserved and copied to dst. For example, if src has no trailing spaces, neither will dst; if src ends in a trailing newline, so will dst.</source>
          <target state="translated">Индент является дополнением к изрезанной форме кодированного на JSON src.Каждый элемент в JSON-объекте или массиве начинается с новой строки с отступом,начинающейся с префикса,за которым следует одна или несколько копий отступов в соответствии с отступом вложенности.Данные,добавляемые в dst,не начинаются ни с префикса,ни с любого отступа,чтобы облегчить встраивание в другие отформатированные JSON-данные.Хотя ведущие символы пробела (пробел,табуляция,возврат каретки,новая строка)в начале src опускаются,ведущие символы пробела в конце src сохраняются и копируются в dst.Например,если в src нет пробела,то и dst тоже не будет;если src заканчивается на новой строке,то будет dst.</target>
        </trans-unit>
        <trans-unit id="68e20af4dfa7d94d1e8e99b5a45a2168cf2653cc" translate="yes" xml:space="preserve">
          <source>Indent sets the encoder to generate XML in which each element begins on a new indented line that starts with prefix and is followed by one or more copies of indent according to the nesting depth.</source>
          <target state="translated">Отступ устанавливает энкодер для генерации XML,в котором каждый элемент начинается с новой строки с отступами,которая начинается с префикса и за которой следует одна или несколько копий отступа в зависимости от глубины вложенности.</target>
        </trans-unit>
        <trans-unit id="c2df9b932637fe9d32a0f16da1c11873398f873d" translate="yes" xml:space="preserve">
          <source>Index</source>
          <target state="translated">Index</target>
        </trans-unit>
        <trans-unit id="421722312ce68c9bf9eb41def321649c4712dbd6" translate="yes" xml:space="preserve">
          <source>Index describes the path from x to f in x.f. The last index entry is the field or method index of the type declaring f; either:</source>
          <target state="translated">Индекс описывает путь от x до f в x.f.Последняя запись индекса является полем или индексом метода типа,декларирующего f;либо:</target>
        </trans-unit>
        <trans-unit id="1d0b49853e61d44f4f8b07282b1903e9f2bc5158" translate="yes" xml:space="preserve">
          <source>Index implements a suffix array for fast substring search.</source>
          <target state="translated">Индекс реализует суффиксный массив для быстрого поиска подстрок.</target>
        </trans-unit>
        <trans-unit id="af573efacc3f6c1539d934e082a33b7c5805e74a" translate="yes" xml:space="preserve">
          <source>Index responds with the pprof-formatted profile named by the request. For example, &quot;/debug/pprof/heap&quot; serves the &quot;heap&quot; profile. Index responds to a request for &quot;/debug/pprof/&quot; with an HTML page listing the available profiles.</source>
          <target state="translated">Индекс отвечает pprof-форматированным профилем,названным в запросе.Например,&quot;/debug/pprof/heap&quot; обслуживает профиль &quot;куча&quot;.На запрос &quot;/debug/pprof/&quot; индекс отвечает HTML-страницей с перечнем доступных профилей.</target>
        </trans-unit>
        <trans-unit id="fd5b04a55e6c188f04225c052c3a4ebb3eecf806" translate="yes" xml:space="preserve">
          <source>Index returns JavaScript index i of value v. It panics if v is not a JavaScript object.</source>
          <target state="translated">Индекс возвращает индекс JavaScript i значения v.Он паникует,если v не является объектом JavaScript.</target>
        </trans-unit>
        <trans-unit id="41cc91c9bcf3f0a08fb627d21f4a77281aee4bad" translate="yes" xml:space="preserve">
          <source>Index returns the index of the first instance of sep in s, or -1 if sep is not present in s.</source>
          <target state="translated">Индекс возвращает индекс первой инстанции sep в s,или -1,если sep не присутствует в s.</target>
        </trans-unit>
        <trans-unit id="1f02d6f4db0fe2bb71d169a720ea48dacd4410f7" translate="yes" xml:space="preserve">
          <source>Index returns the index of the first instance of substr in s, or -1 if substr is not present in s.</source>
          <target state="translated">Индекс возвращает индекс первой инстанции подложки в s,или -1,если подложки нет в s.</target>
        </trans-unit>
        <trans-unit id="6672a7ad3732041777afcc9d59e94790fa08598a" translate="yes" xml:space="preserve">
          <source>Index returns the index of the palette color closest to c in Euclidean R,G,B,A space.</source>
          <target state="translated">Индекс возвращает индекс цвета палитры,наиболее близкой к c,в евклидовом пространстве R,G,B,A.</target>
        </trans-unit>
        <trans-unit id="08cc5090355bf36192f88d52e3809f63b35b1be3" translate="yes" xml:space="preserve">
          <source>Index returns v's i'th element. It panics if v's Kind is not Array, Slice, or String or i is out of range.</source>
          <target state="translated">Индекс возвращает V's i's элемент.Он паникует,если v's Kind не является массивом,срезом или строкой,или i находится вне диапазона.</target>
        </trans-unit>
        <trans-unit id="f604fe204d59450e53c6f0f981bb463a3da262fc" translate="yes" xml:space="preserve">
          <source>Index.Lookup</source>
          <target state="translated">Index.Lookup</target>
        </trans-unit>
        <trans-unit id="693f6afea6d2763baec63c4f683ab836809a8526" translate="yes" xml:space="preserve">
          <source>IndexAny</source>
          <target state="translated">IndexAny</target>
        </trans-unit>
        <trans-unit id="227cd6f0abdfd091813bf35b8fd1dcfbc25cecd9" translate="yes" xml:space="preserve">
          <source>IndexAny interprets s as a sequence of UTF-8-encoded Unicode code points. It returns the byte index of the first occurrence in s of any of the Unicode code points in chars. It returns -1 if chars is empty or if there is no code point in common.</source>
          <target state="translated">IndexAny интерпретирует s как последовательность кодированных в UTF-8 Unicode точек кода.Он возвращает индекс байта первого появления в s любой из точек кода Юникода в графиках.Возвращает -1,если символы пустые или если нет общей точки кода.</target>
        </trans-unit>
        <trans-unit id="1adf36d0e196212f2787325e2cb626ccc3228c3b" translate="yes" xml:space="preserve">
          <source>IndexAny returns the index of the first instance of any Unicode code point from chars in s, or -1 if no Unicode code point from chars is present in s.</source>
          <target state="translated">IndexAny возвращает индекс первой инстанции любой точки кода Юникода с символов в символах s,или -1,если в символах s нет точки кода Юникода с символов.</target>
        </trans-unit>
        <trans-unit id="91d007c3332e259ec2e02f981423ecacc90c6ee6" translate="yes" xml:space="preserve">
          <source>IndexByte</source>
          <target state="translated">IndexByte</target>
        </trans-unit>
        <trans-unit id="c4f06e8f47e53dedfca453887d03a95ac035b5de" translate="yes" xml:space="preserve">
          <source>IndexByte returns the index of the first instance of c in b, or -1 if c is not present in b.</source>
          <target state="translated">IndexByte возвращает индекс первой инстанции c в b,или -1,если c нет в b.</target>
        </trans-unit>
        <trans-unit id="c369952c4d2f42c9a51eabe33a7908d4c8f60ad4" translate="yes" xml:space="preserve">
          <source>IndexByte returns the index of the first instance of c in s, or -1 if c is not present in s.</source>
          <target state="translated">IndexByte возвращает индекс первой инстанции c в s,или -1,если c нет в s.</target>
        </trans-unit>
        <trans-unit id="4b29f4c46fd4242b96d7f6d96005476262ea25b4" translate="yes" xml:space="preserve">
          <source>IndexFunc</source>
          <target state="translated">IndexFunc</target>
        </trans-unit>
        <trans-unit id="fd5aa7f0734b2b2162a12de708cba7a93a1ba269" translate="yes" xml:space="preserve">
          <source>IndexFunc interprets s as a sequence of UTF-8-encoded code points. It returns the byte index in s of the first Unicode code point satisfying f(c), or -1 if none do.</source>
          <target state="translated">IndexFunc интерпретирует s как последовательность кодированных UTF-8 точек кода.Она возвращает индекс байта в s первой точки кода Юникода,удовлетворяющей f(c),или -1,если ни одна из них не удовлетворяет.</target>
        </trans-unit>
        <trans-unit id="67453fcd073346734a7503bb3d4207a4ffac0a81" translate="yes" xml:space="preserve">
          <source>IndexFunc returns the index into s of the first Unicode code point satisfying f(c), or -1 if none do.</source>
          <target state="translated">IndexFunc возвращает индекс в s первой точки кода Юникода,удовлетворяющей f(c),или -1,если ни одна из них не удовлетворяет.</target>
        </trans-unit>
        <trans-unit id="0404886738141ffe45c4d013ff978a64bde2ba63" translate="yes" xml:space="preserve">
          <source>IndexRune</source>
          <target state="translated">IndexRune</target>
        </trans-unit>
        <trans-unit id="f4318ccac75e1dd461aaa7a9c7842e97a421edce" translate="yes" xml:space="preserve">
          <source>IndexRune interprets s as a sequence of UTF-8-encoded code points. It returns the byte index of the first occurrence in s of the given rune. It returns -1 if rune is not present in s. If r is utf8.RuneError, it returns the first instance of any invalid UTF-8 byte sequence.</source>
          <target state="translated">IndexRune интерпретирует s как последовательность кодированных UTF-8 точек кода.Она возвращает индекс байта первого вхождения в s данной руны.Возвращает -1,если руна не присутствует в s.Если r-utf8.RuneError,возвращает первую инстанцию любой некорректной последовательности байт UTF-8.</target>
        </trans-unit>
        <trans-unit id="042bb768e6a79fc4f2a8939cb46f8d887178fb46" translate="yes" xml:space="preserve">
          <source>IndexRune returns the index of the first instance of the Unicode code point r, or -1 if rune is not present in s. If r is utf8.RuneError, it returns the first instance of any invalid UTF-8 byte sequence.</source>
          <target state="translated">IndexRune возвращает индекс первой инстанции Unicode code point r,или -1,если руна отсутствует в s.Если r-utf8.RuneError,то возвращается первая инстанция любой некорректной последовательности UTF-8 байт.</target>
        </trans-unit>
        <trans-unit id="a85d156f8eef16ea6fae8f47130c09e7ab738f38" translate="yes" xml:space="preserve">
          <source>Indexes into the Header.Ident array.</source>
          <target state="translated">Индексы в массив Header.Ident.</target>
        </trans-unit>
        <trans-unit id="bee82bdb7da751fd64eea7f5143956992f5aed77" translate="yes" xml:space="preserve">
          <source>Indices into the Delta arrays inside CaseRanges for case mapping.</source>
          <target state="translated">Индексы в дельта-массивах внутри CaseRanges для отображения случаев.</target>
        </trans-unit>
        <trans-unit id="22023c8031bf3535a364147cd1c4ebacba51eca8" translate="yes" xml:space="preserve">
          <source>Indirect reports whether any pointer indirection was required to get from x to f in x.f.</source>
          <target state="translated">Косвенные сообщения о том,требовалось ли какое-либо указание,чтобы попасть из x в f в x.f.</target>
        </trans-unit>
        <trans-unit id="1dbf2dfd2ac6c93be252e418d12775d2db6f53d8" translate="yes" xml:space="preserve">
          <source>Indirect returns the value that v points to. If v is a nil pointer, Indirect returns a zero Value. If v is not a pointer, Indirect returns v.</source>
          <target state="translated">Косвенный возвращает значение,на которое указывает v.Если v-нулевой указатель,Indirect возвращает нулевое значение.Если v не является указателем,Indirect возвращает v.</target>
        </trans-unit>
        <trans-unit id="fe7ad1fbee745b4ca3d08d7729476db7d9fb4fe9" translate="yes" xml:space="preserve">
          <source>Inf returns a complex infinity, complex(+Inf, +Inf).</source>
          <target state="translated">Inf возвращает сложную бесконечность,комплекс(+Inf,+Inf).</target>
        </trans-unit>
        <trans-unit id="0125073a5f3757f1dc62bea262918d4c5b3bae8e" translate="yes" xml:space="preserve">
          <source>Inf returns positive infinity if sign &amp;gt;= 0, negative infinity if sign &amp;lt; 0.</source>
          <target state="translated">Inf возвращает положительную бесконечность, если sign&amp;gt; = 0, отрицательную бесконечность, если sign &amp;lt;0.</target>
        </trans-unit>
        <trans-unit id="fd7feb1c61f7423453cbee79d9998496c4df75f3" translate="yes" xml:space="preserve">
          <source>Infinite recursion can also be triggered by self-referential data structures, such as a slice that contains itself as an element, if that type has a String method. Such pathologies are rare, however, and the package does not protect against them.</source>
          <target state="translated">Бесконечная рекурсия также может быть инициирована саморасполагающимися структурами данных,такими как срез,содержащий себя в качестве элемента,если этот тип имеет метод String.Однако такие патологии встречаются редко,и пакет не защищает от них.</target>
        </trans-unit>
        <trans-unit id="4b631f69842530d659306c8f06dbad594a6b1807" translate="yes" xml:space="preserve">
          <source>Info</source>
          <target state="translated">Info</target>
        </trans-unit>
        <trans-unit id="0e2ca261be59b2db86de1819fd95c5c62808d215" translate="yes" xml:space="preserve">
          <source>Info holds result type information for a type-checked package. Only the information for which a map is provided is collected. If the package has type errors, the collected information may be incomplete.</source>
          <target state="translated">Информация содержит информацию о типе результата для пакета,прошедшего типовую проверку.Собирается только та информация,для которой предоставлена карта.Если пакет содержит ошибки типа,собранная информация может быть неполной.</target>
        </trans-unit>
        <trans-unit id="829a6f4d1b71214eb93db4bdc76fb1b790f4e5d1" translate="yes" xml:space="preserve">
          <source>Info logs a message with severity LOG_INFO, ignoring the severity passed to New.</source>
          <target state="translated">Информация регистрирует сообщение со степенью тяжести LOG_INFO,игнорируя степень тяжести,переданную New.</target>
        </trans-unit>
        <trans-unit id="d0968061a8aa60c3762f0e765c2376d0827896c3" translate="yes" xml:space="preserve">
          <source>Info returns information about properties of basic type b.</source>
          <target state="translated">Информация возвращает информацию о свойствах базового типа b.</target>
        </trans-unit>
        <trans-unit id="4bebef89f6713b109d9329a6bfe51cba5fd0be4f" translate="yes" xml:space="preserve">
          <source>Init establishes the heap invariants required by the other routines in this package. Init is idempotent with respect to the heap invariants and may be called whenever the heap invariants may have been invalidated. The complexity is O(n) where n = h.Len().</source>
          <target state="translated">Init устанавливает инварианты кучи,требуемые другими подпрограммами в данном пакете.Init является идолопоклонным по отношению к инвариантам кучи и может быть вызван всякий раз,когда инварианты кучи могут быть признаны недействительными.Сложность заключается в O(n),где n=h.Len().</target>
        </trans-unit>
        <trans-unit id="e025530212d94f43014839edcd8664101cb1d082" translate="yes" xml:space="preserve">
          <source>Init has no effect if it was already called.</source>
          <target state="translated">Инит не имеет никакого эффекта,если он уже был назван.</target>
        </trans-unit>
        <trans-unit id="ab8a6a690d98493f29c3a7eded17da06a0fe4963" translate="yes" xml:space="preserve">
          <source>Init initializes a Scanner with a new source and returns s. Error is set to nil, ErrorCount is set to 0, Mode is set to GoTokens, and Whitespace is set to GoWhitespace.</source>
          <target state="translated">Init инициализирует сканер с новым источником и возвращает s.Ошибка установлена на ноль,ErrorCount-на 0,Mode-на GoTokens,Whitespace-на GoWhitespace.</target>
        </trans-unit>
        <trans-unit id="38f2f0576d19cc2c5fa27415d0b566e72a9f5fcc" translate="yes" xml:space="preserve">
          <source>Init initializes or clears list l.</source>
          <target state="translated">Init инициализирует или очищает список l.</target>
        </trans-unit>
        <trans-unit id="4828f42508fc3abcabc5d7577bba28e3151a2a20" translate="yes" xml:space="preserve">
          <source>Init prepares the scanner s to tokenize the text src by setting the scanner at the beginning of src. The scanner uses the file set file for position information and it adds line information for each line. It is ok to re-use the same file when re-scanning the same file as line information which is already present is ignored. Init causes a panic if the file size does not match the src size.</source>
          <target state="translated">Init подготавливает сканер s к маркировке текста src,установив сканер в начале src.Сканер использует файл набора файлов для получения информации о позиции и добавляет информацию о строке для каждой строки.Можно повторно использовать тот же файл,если при повторном сканировании тот же самый файл,информация о строках,которая уже присутствует,игнорируется.Init вызывает панику,если размер файла не совпадает с размером src.</target>
        </trans-unit>
        <trans-unit id="1ff5728fd1958fa03cc23f0615bd53c6b8512d71" translate="yes" xml:space="preserve">
          <source>Init registers testing flags. These flags are automatically registered by the &quot;go test&quot; command before running test functions, so Init is only needed when calling functions such as Benchmark without using &quot;go test&quot;.</source>
          <target state="translated">Init регистрирует флаги тестирования.Эти флаги автоматически регистрируются командой &quot;go test&quot; перед запуском функций тестирования,поэтому Init нужен только при вызове таких функций,как Benchmark без использования &quot;go test&quot;.</target>
        </trans-unit>
        <trans-unit id="e71fb65b44dd31464c3ab6d5dc9c1b767849af42" translate="yes" xml:space="preserve">
          <source>Init removes all keys from the map.</source>
          <target state="translated">Init удаляет все клавиши с карты.</target>
        </trans-unit>
        <trans-unit id="2f9d5d06290960b800b664c463e2749afea3e374" translate="yes" xml:space="preserve">
          <source>Init sets the name and error handling property for a flag set. By default, the zero FlagSet uses an empty name and the ContinueOnError error handling policy.</source>
          <target state="translated">Init устанавливает свойство обработки имени и ошибок для набора флагов.По умолчанию нулевой FlagSet использует пустое имя и политику обработки ошибок ContinueOnError.</target>
        </trans-unit>
        <trans-unit id="1ff277aa8c5f044965228237465cbaf43a54dec6" translate="yes" xml:space="preserve">
          <source>Initial magic number for ELF files.</source>
          <target state="translated">Начальное магическое число для ELF-файлов.</target>
        </trans-unit>
        <trans-unit id="7ceb1ca1dad4f40542d5a478441bc59f2f8873ca" translate="yes" xml:space="preserve">
          <source>Innermost returns the innermost (child) scope containing pos. If pos is not within any scope, the result is nil. The result is also nil for the Universe scope. The result is guaranteed to be valid only if the type-checked AST has complete position information.</source>
          <target state="translated">Внутренний возвращает самый внутренний (дочерний)объем,содержащий поз.Если pos не попадает в какую-либо область,то результат равен нулю.Результат равен нулю и для Вселенского диапазона.Результат гарантированно действителен только в том случае,если проверенная по типу AST информация о положении является полной.</target>
        </trans-unit>
        <trans-unit id="d3d677ba8b8fb62d3d734397c41c430f5735b25c" translate="yes" xml:space="preserve">
          <source>Input processed by verbs is implicitly space-delimited: the implementation of every verb except %c starts by discarding leading spaces from the remaining input, and the %s verb (and %v reading into a string) stops consuming input at the first space or newline character.</source>
          <target state="translated">Вход,обрабатываемый глаголами,неявно разделен пробелами:реализация каждого глагола,кроме %c,начинается с удаления лидирующих пробелов из оставшихся входных данных,а %s глагол (и %v чтение в строку)перестает потреблять входные данные при первом пробеле или символе новой строки.</target>
        </trans-unit>
        <trans-unit id="f2b998d9fdcbc1c4a3ffebeea1625f9214a80db4" translate="yes" xml:space="preserve">
          <source>InputOffset returns the input stream byte offset of the current decoder position. The offset gives the location of the end of the most recently returned token and the beginning of the next token.</source>
          <target state="translated">InputOffset возвращает смещение байт входного потока от текущей позиции декодера.Смещение дает местоположение конца последней возвращенной лексемы и начало следующей.</target>
        </trans-unit>
        <trans-unit id="e966ee10eb4ce3215fa8906700a612e44342e126" translate="yes" xml:space="preserve">
          <source>InsecureCipherSuites returns a list of cipher suites currently implemented by this package and which have security issues.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6bdbccac97746d550ea930e761dad7ffa800d06" translate="yes" xml:space="preserve">
          <source>Insert attempts to insert a named object obj into the scope s. If the scope already contains an object alt with the same name, Insert leaves the scope unchanged and returns alt. Otherwise it inserts obj and returns nil.</source>
          <target state="translated">Вставить попытки вставить именованный объект в область видимости s.Если область видимости уже содержит объект с таким же именем,то Insert оставляет область видимости без изменений и возвращает alt.В противном случае она вставляет объект и возвращает ноль.</target>
        </trans-unit>
        <trans-unit id="3c51f0bca7bc21285dde2f4365d66539c9045fbd" translate="yes" xml:space="preserve">
          <source>Insert attempts to insert an object obj into scope s. If s already contains an alternative object alt with the same name, Insert leaves s unchanged and returns alt. Otherwise it inserts obj, sets the object's parent scope if not already set, and returns nil.</source>
          <target state="translated">Вставить попытки вставить объект в область s.Если s уже содержит альтернативный объект alt с тем же именем,Insert оставляет s без изменений и возвращает alt.В противном случае он вставляет объект,устанавливает родительскую область объекта,если она еще не установлена,и возвращает ноль.</target>
        </trans-unit>
        <trans-unit id="e5d297ca4eb4122848b745777ba08d9e98e99026" translate="yes" xml:space="preserve">
          <source>InsertAfter inserts a new element e with value v immediately after mark and returns e. If mark is not an element of l, the list is not modified. The mark must not be nil.</source>
          <target state="translated">InsertAfter вставляет новый элемент e со значением v сразу после отметки и возвращает e.Если отметка не является элементом l,список не изменяется.Знак не должен быть нулевым.</target>
        </trans-unit>
        <trans-unit id="f8690dfd3964564996a8ec4c6a534ffd7d8cce51" translate="yes" xml:space="preserve">
          <source>InsertBefore inserts a new element e with value v immediately before mark and returns e. If mark is not an element of l, the list is not modified. The mark must not be nil.</source>
          <target state="translated">InsertBefore вставляет новый элемент e со значением v непосредственно перед отметкой и возвращает e.Если отметка не является элементом l,список не изменяется.Знак не должен быть нулевым.</target>
        </trans-unit>
        <trans-unit id="1a44ed1d9fdf3b19a9445ead705835b2d7701bba" translate="yes" xml:space="preserve">
          <source>Inset returns the rectangle r inset by n, which may be negative. If either of r's dimensions is less than 2*n then an empty rectangle near the center of r will be returned.</source>
          <target state="translated">Вставка возвращает прямоугольник r вставки по n,который может быть отрицательным.Если один из размеров r меньше 2*n,то возвращается пустой прямоугольник вблизи центра r.</target>
        </trans-unit>
        <trans-unit id="18ca87afec4298d9de864e32b4eeb6a31786e496" translate="yes" xml:space="preserve">
          <source>Inspect</source>
          <target state="translated">Inspect</target>
        </trans-unit>
        <trans-unit id="165da1fa673b9fd9a581f6c1c726cccbffc7e2ca" translate="yes" xml:space="preserve">
          <source>Inspect traverses an AST in depth-first order: It starts by calling f(node); node must not be nil. If f returns true, Inspect invokes f recursively for each of the non-nil children of node, followed by a call of f(nil).</source>
          <target state="translated">Осмотрите траверсы AST в первом порядке глубины:Он начинается с вызова f(node);узел не должен быть нулевым.Если f возвращает true,инспектор вызывает f рекурсивно для каждого из дочерних элементов узла,не имеющих нуля,с последующим вызовом f(nil).</target>
        </trans-unit>
        <trans-unit id="a6a380194dfce8d967bc921f5f0bd2558e839e1f" translate="yes" xml:space="preserve">
          <source>InstanceOf reports whether v is an instance of type t according to JavaScript's instanceof operator.</source>
          <target state="translated">InstanceOf сообщает,является ли v экземпляром типа t согласно оператору instanceof JavaScript.</target>
        </trans-unit>
        <trans-unit id="ebf808b93582c50b9dee098ffbc7851e8bbd1bc5" translate="yes" xml:space="preserve">
          <source>Int defines an int flag with specified name, default value, and usage string. The return value is the address of an int variable that stores the value of the flag.</source>
          <target state="translated">Int определяет флаг int с указанным именем,значением по умолчанию и строкой использования.Возвращаемое значение-это адрес переменной int,в которой хранится значение флага.</target>
        </trans-unit>
        <trans-unit id="4a82193f61167eeb73caee70b7d931807aee1e38" translate="yes" xml:space="preserve">
          <source>Int is a 64-bit integer variable that satisfies the Var interface.</source>
          <target state="translated">Int-64-битная целочисленная переменная,удовлетворяющая интерфейсу Var.</target>
        </trans-unit>
        <trans-unit id="af260c99fb6b16af9acf30bb7ef7c67bfd7f461c" translate="yes" xml:space="preserve">
          <source>Int returns a non-negative pseudo-random int from the default Source.</source>
          <target state="translated">Int возвращает неотрицательный псевдослучайный int из источника по умолчанию.</target>
        </trans-unit>
        <trans-unit id="381ad8d2cdfa2db4d632061cd5638bdb827c118f" translate="yes" xml:space="preserve">
          <source>Int returns a non-negative pseudo-random int.</source>
          <target state="translated">Int возвращает неотрицательный псевдослучайный int.</target>
        </trans-unit>
        <trans-unit id="78b2c6c511c1ed56b26a62f7cd24e23bebce41b7" translate="yes" xml:space="preserve">
          <source>Int returns a uniform random value in [0, max). It panics if max &amp;lt;= 0.</source>
          <target state="translated">Int возвращает равномерное случайное значение в [0, max). Паникает, если max &amp;lt;= 0.</target>
        </trans-unit>
        <trans-unit id="5333a3a7b26511027f14a3034f5b9a08970c91dc" translate="yes" xml:space="preserve">
          <source>Int returns the result of truncating x towards zero; or nil if x is an infinity. The result is Exact if x.IsInt(); otherwise it is Below for x &amp;gt; 0, and Above for x &amp;lt; 0. If a non-nil *Int argument z is provided, Int stores the result in z instead of allocating a new Int.</source>
          <target state="translated">Int возвращает результат усечения x до нуля; или nil, если x - бесконечность. Результат будет точным, если x.IsInt (); в противном случае это будет ниже для x&amp;gt; 0 и выше для x &amp;lt;0. Если задан аргумент z, отличный от nil * Int, Int сохраняет результат в z вместо выделения нового Int.</target>
        </trans-unit>
        <trans-unit id="b48fef275365436d3178b531a98b6df9140d4a4e" translate="yes" xml:space="preserve">
          <source>Int returns the value v truncated to an int. It panics if v is not a JavaScript number.</source>
          <target state="translated">Int возвращает усеченное значение в int.Она паникует,если v не является JavaScript-номером.</target>
        </trans-unit>
        <trans-unit id="7aeadc703783366afed8a63b0734b22311f2a7e4" translate="yes" xml:space="preserve">
          <source>Int returns v's underlying value, as an int64. It panics if v's Kind is not Int, Int8, Int16, Int32, or Int64.</source>
          <target state="translated">Int возвращает базовое значение v,как int64.Она паникует,если v's Kind не является Int,Int8,Int16,Int32 или Int64.</target>
        </trans-unit>
        <trans-unit id="53c091a9597bdba1f2ca46d491f5c108342e031f" translate="yes" xml:space="preserve">
          <source>Int.Scan</source>
          <target state="translated">Int.Scan</target>
        </trans-unit>
        <trans-unit id="5de699e08eb78e768e5b08ea65a2d2d995d6cca4" translate="yes" xml:space="preserve">
          <source>Int.SetString</source>
          <target state="translated">Int.SetString</target>
        </trans-unit>
        <trans-unit id="25863d22096f1ba104e899340881b4d53e78900e" translate="yes" xml:space="preserve">
          <source>Int31 returns a non-negative pseudo-random 31-bit integer as an int32 from the default Source.</source>
          <target state="translated">Int31 возвращает неотрицательное псевдослучайное 31-битное целое число в виде int32 из источника по умолчанию.</target>
        </trans-unit>
        <trans-unit id="8668fa86efe442ed5c0ddfb6799eac348a1585d9" translate="yes" xml:space="preserve">
          <source>Int31 returns a non-negative pseudo-random 31-bit integer as an int32.</source>
          <target state="translated">Int31 возвращает неотрицательное псевдослучайное 31-битное целое число в виде int32.</target>
        </trans-unit>
        <trans-unit id="4ef488a0ec898f126b9413bbb42319fb0eaeff13" translate="yes" xml:space="preserve">
          <source>Int31n returns, as an int32, a non-negative pseudo-random number in [0,n) from the default Source. It panics if n &amp;lt;= 0.</source>
          <target state="translated">Int31n возвращает в виде int32 неотрицательное псевдослучайное число в [0, n) из источника по умолчанию. Паникает, если n &amp;lt;= 0.</target>
        </trans-unit>
        <trans-unit id="90d847f9e26c6ab28ce7fd160e1218ad35e875d4" translate="yes" xml:space="preserve">
          <source>Int31n returns, as an int32, a non-negative pseudo-random number in [0,n). It panics if n &amp;lt;= 0.</source>
          <target state="translated">Int31n возвращает в виде int32 неотрицательное псевдослучайное число в [0, n). Паникает, если n &amp;lt;= 0.</target>
        </trans-unit>
        <trans-unit id="848b71a013b8e0169e247e647c756adf54d70a3d" translate="yes" xml:space="preserve">
          <source>Int32 is a ValueConverter that converts input values to int64, respecting the limits of an int32 value.</source>
          <target state="translated">Int32-это конвертер значений,который преобразует входные значения в int64,соблюдая границы значения int32.</target>
        </trans-unit>
        <trans-unit id="40feceb2effc4993d828a64f0bbc7bd4b65472d1" translate="yes" xml:space="preserve">
          <source>Int63 returns a non-negative pseudo-random 63-bit integer as an int64 from the default Source.</source>
          <target state="translated">Int63 возвращает неотрицательное псевдослучайное 63-битное целое число в виде int64 из источника по умолчанию.</target>
        </trans-unit>
        <trans-unit id="73b13ad335bd8c446e54125036bbdb60110b8a67" translate="yes" xml:space="preserve">
          <source>Int63 returns a non-negative pseudo-random 63-bit integer as an int64.</source>
          <target state="translated">Int63 возвращает неотрицательное псевдослучайное 63-битное целое число в виде int64.</target>
        </trans-unit>
        <trans-unit id="ccf199104b81302e6aa6420d9d53fbe6d1e5e481" translate="yes" xml:space="preserve">
          <source>Int63n returns, as an int64, a non-negative pseudo-random number in [0,n) from the default Source. It panics if n &amp;lt;= 0.</source>
          <target state="translated">Int63n возвращает как int64 неотрицательное псевдослучайное число в [0, n) из источника по умолчанию. Паникает, если n &amp;lt;= 0.</target>
        </trans-unit>
        <trans-unit id="adc50ec6888e251cb9eb8237744893f852c6674f" translate="yes" xml:space="preserve">
          <source>Int63n returns, as an int64, a non-negative pseudo-random number in [0,n). It panics if n &amp;lt;= 0.</source>
          <target state="translated">Int63n возвращает в виде int64 неотрицательное псевдослучайное число в [0, n). Паникает, если n &amp;lt;= 0.</target>
        </trans-unit>
        <trans-unit id="caf7332f4387883214a684cf486e59d1298af5e4" translate="yes" xml:space="preserve">
          <source>Int64 defines an int64 flag with specified name, default value, and usage string. The return value is the address of an int64 variable that stores the value of the flag.</source>
          <target state="translated">Int64 определяет флаг int64 с указанным именем,значением по умолчанию и строкой использования.Возвращаемое значение-адрес переменной int64,в которой хранится значение флага.</target>
        </trans-unit>
        <trans-unit id="5ea42bb5a91b0f37c1c104284dddf7aee6dd3d40" translate="yes" xml:space="preserve">
          <source>Int64 returns the int64 representation of x. If x cannot be represented in an int64, the result is undefined.</source>
          <target state="translated">Int64 возвращает int64 представление x.Если x не может быть представлено в int64,результат будет неопределен.</target>
        </trans-unit>
        <trans-unit id="024ee0329e5ac0182a79c3f0f817ea471b5da8f4" translate="yes" xml:space="preserve">
          <source>Int64 returns the integer resulting from truncating x towards zero. If math.MinInt64 &amp;lt;= x &amp;lt;= math.MaxInt64, the result is Exact if x is an integer, and Above (x &amp;lt; 0) or Below (x &amp;gt; 0) otherwise. The result is (math.MinInt64, Above) for x &amp;lt; math.MinInt64, and (math.MaxInt64, Below) for x &amp;gt; math.MaxInt64.</source>
          <target state="translated">Int64 возвращает целое число, полученное в результате усечения x до нуля. Если math.MinInt64 &amp;lt;= x &amp;lt;= math.MaxInt64, результат будет Exact, если x является целым числом, и Above (x &amp;lt;0) или Lower (x&amp;gt; 0) в противном случае. Результатом будет (math.MinInt64, Above) для x &amp;lt;math.MinInt64 и (math.MaxInt64, below) для x&amp;gt; math.MaxInt64.</target>
        </trans-unit>
        <trans-unit id="a7858f715e5515e9b11682c98c7e956884fa03d3" translate="yes" xml:space="preserve">
          <source>Int64 returns the number as an int64.</source>
          <target state="translated">Int64 возвращает число как int64.</target>
        </trans-unit>
        <trans-unit id="e87b1cbe8a7626b33b6c26f9454e9b97aa48ff20" translate="yes" xml:space="preserve">
          <source>Int64Val returns the Go int64 value of x and whether the result is exact; x must be an Int or an Unknown. If the result is not exact, its value is undefined. If x is Unknown, the result is (0, false).</source>
          <target state="translated">Int64Val возвращает Go int64 значение x и точный ли результат;x должен быть Int или Unknown.Если результат не точный,то его значение не определено.Если x неизвестно,то результат (0,ложь).</target>
        </trans-unit>
        <trans-unit id="e48ba0f308dabec3542a772cd98df7b4a194464a" translate="yes" xml:space="preserve">
          <source>Int64Var defines an int64 flag with specified name, default value, and usage string. The argument p points to an int64 variable in which to store the value of the flag.</source>
          <target state="translated">Int64Var определяет флаг int64 с указанным именем,значением по умолчанию и строкой использования.Аргумент p указывает на переменную int64,в которой будет храниться значение флага.</target>
        </trans-unit>
        <trans-unit id="826fdf675ec889637dd1607e0ecbc7b4617ed6b5" translate="yes" xml:space="preserve">
          <source>IntSize is the size in bits of an int or uint value.</source>
          <target state="translated">IntSize-это размер в битах значения int или uint.</target>
        </trans-unit>
        <trans-unit id="7d0ad3a5fc2c5562d1a3d5edaf660d5681e2e7dd" translate="yes" xml:space="preserve">
          <source>IntSlice attaches the methods of Interface to []int, sorting in increasing order.</source>
          <target state="translated">IntSlice присоединяет методы интерфейса к []int,сортируя по возрастанию.</target>
        </trans-unit>
        <trans-unit id="259cdcc1487407a0effb8761c09ff465d822351b" translate="yes" xml:space="preserve">
          <source>IntVar defines an int flag with specified name, default value, and usage string. The argument p points to an int variable in which to store the value of the flag.</source>
          <target state="translated">IntVar определяет флаг int с указанным именем,значением по умолчанию и строкой использования.Аргумент p указывает на переменную int,в которой будет храниться значение флага.</target>
        </trans-unit>
        <trans-unit id="e927198b4dfea79ca477c6ca320b7977e5f907d8" translate="yes" xml:space="preserve">
          <source>Integer flags accept 1234, 0664, 0x1234 and may be negative. Boolean flags may be:</source>
          <target state="translated">Целочисленные флаги принимают 1234,0664,0x1234 и могут быть отрицательными.Булевы флаги могут быть:</target>
        </trans-unit>
        <trans-unit id="d8d2cb0f1ba846253e8f8508e7b268037f761677" translate="yes" xml:space="preserve">
          <source>Integer limit values.</source>
          <target state="translated">Целочисленные предельные значения.</target>
        </trans-unit>
        <trans-unit id="8e6549b1b15bddbc7e4ca51ecb54082a0c50f802" translate="yes" xml:space="preserve">
          <source>Integer:</source>
          <target state="translated">Integer:</target>
        </trans-unit>
        <trans-unit id="8ef45f34654a956038b7d2e46f7b980bceca0a1e" translate="yes" xml:space="preserve">
          <source>IntegerType is here for the purposes of documentation only. It is a stand-in for any integer type: int, uint, int8 etc.</source>
          <target state="translated">IntegerType здесь только для документации.Он является дублером для любого целочисленного типа:int,uint,int8 и др.</target>
        </trans-unit>
        <trans-unit id="5a289c0331a1e2ae1cddd468bdbd08515a751488" translate="yes" xml:space="preserve">
          <source>Integers are transmitted two ways: arbitrary precision signed integers or arbitrary precision unsigned integers. There is no int8, int16 etc. discrimination in the gob format; there are only signed and unsigned integers. As described below, the transmitter sends the value in a variable-length encoding; the receiver accepts the value and stores it in the destination variable. Floating-point numbers are always sent using IEEE-754 64-bit precision (see below).</source>
          <target state="translated">Целые числа передаются двумя способами:целые числа произвольной точности со знаком или целые числа произвольной точности без знака.Дискриминация int8,int16 и т.д.в формате gob отсутствует;есть только знаковые и беззнаковые целые числа.Как описано ниже,передатчик посылает значение в кодировке переменной длины;приемник принимает значение и сохраняет его в переменной назначения.Числа с плавающей точкой всегда передаются с 64-битной точностью по стандарту IEEE-754 (см.ниже).</target>
        </trans-unit>
        <trans-unit id="7b4db7ef1fa23cfb5e115a2a2c89d46a6a2ebc4a" translate="yes" xml:space="preserve">
          <source>Interface</source>
          <target state="translated">Interface</target>
        </trans-unit>
        <trans-unit id="8a7e153030b338cdad7a41aa466f441af45e4a11" translate="yes" xml:space="preserve">
          <source>Interface represents a mapping between network interface name and index. It also represents network interface facility information.</source>
          <target state="translated">Интерфейс представляет собой отображение между именем сетевого интерфейса и индексом.Он также представляет информацию об объекте сетевого интерфейса.</target>
        </trans-unit>
        <trans-unit id="6da3607f32beaa93e64c1a37a2f36fbed997c327" translate="yes" xml:space="preserve">
          <source>Interface returns v's current value as an interface{}. It is equivalent to:</source>
          <target state="translated">Интерфейс возвращает текущее значение v в качестве интерфейса{}.Это эквивалентно:</target>
        </trans-unit>
        <trans-unit id="5ea5c3979b46b5a2713cc2d1786a81b1f8ec63c2" translate="yes" xml:space="preserve">
          <source>Interface types are not checked for compatibility; all interface types are treated, for transmission, as members of a single &quot;interface&quot; type, analogous to int or []byte - in effect they're all treated as interface{}. Interface values are transmitted as a string identifying the concrete type being sent (a name that must be pre-defined by calling Register), followed by a byte count of the length of the following data (so the value can be skipped if it cannot be stored), followed by the usual encoding of concrete (dynamic) value stored in the interface value. (A nil interface value is identified by the empty string and transmits no value.) Upon receipt, the decoder verifies that the unpacked concrete item satisfies the interface of the receiving variable.</source>
          <target state="translated">Типы интерфейсов не проверяются на совместимость;все типы интерфейсов обрабатываются,для передачи,как члены одного &quot;интерфейсного&quot; типа,аналогичного int или []байту-по сути,все они обрабатываются как interface{}.Значения интерфейса передаются как строка,идентифицирующая посылаемый конкретный тип (имя,которое должно быть предварительно определено вызывающим регистром),за которым следует счетчик байтов длины следующих данных (таким образом,значение может быть пропущено,если оно не может быть сохранено),за которым следует обычная кодировка конкретного (динамического)значения,сохраненного в значении интерфейса.(нулевое значение интерфейса идентифицируется пустой строкой и не передает никакого значения).При получении декодер проверяет,удовлетворяет ли распакованный конкретный элемент интерфейсу принимающей переменной.</target>
        </trans-unit>
        <trans-unit id="74b4a1f2cd95d6ac03afcfd27826497cd84b5ae7" translate="yes" xml:space="preserve">
          <source>Interface values are deeply equal if they hold deeply equal concrete values.</source>
          <target state="translated">Значения интерфейса глубоко равны,если они держат глубоко равные конкретные значения.</target>
        </trans-unit>
        <trans-unit id="09203e8778d59b495323467d890a95f5807f26bf" translate="yes" xml:space="preserve">
          <source>Interface values encode as the value contained in the interface. A nil interface value encodes as the null JSON value.</source>
          <target state="translated">Значения интерфейса кодируются как значение,содержащееся в интерфейсе.Ноль значений интерфейса кодируется как нулевое значение JSON.</target>
        </trans-unit>
        <trans-unit id="360b50370b24932254b26c7af3e111445c188db0" translate="yes" xml:space="preserve">
          <source>InterfaceAddrs returns a list of the system's unicast interface addresses.</source>
          <target state="translated">InterfaceAddrs возвращает список адресов одноадресного интерфейса системы.</target>
        </trans-unit>
        <trans-unit id="9ce937dfbe60c7ef5a110a8b5806627105e626f1" translate="yes" xml:space="preserve">
          <source>InterfaceByIndex returns the interface specified by index.</source>
          <target state="translated">InterfaceByIndex возвращает интерфейс,заданный индексом.</target>
        </trans-unit>
        <trans-unit id="4245d4428eaccf8da6182470aec7d558cea28a53" translate="yes" xml:space="preserve">
          <source>InterfaceByName returns the interface specified by name.</source>
          <target state="translated">InterfaceByName возвращает интерфейс,указанный по имени.</target>
        </trans-unit>
        <trans-unit id="a63d53fbc696efd4a28db884d8645a21dcabe121" translate="yes" xml:space="preserve">
          <source>InterfaceData returns the interface v's value as a uintptr pair. It panics if v's Kind is not Interface.</source>
          <target state="translated">InterfaceData возвращает значение v интерфейса в виде пары uintptr.Паникует,если v's Kind не является Interface.</target>
        </trans-unit>
        <trans-unit id="470a021de3b9df70021376a7834ee99ab5ab1f2e" translate="yes" xml:space="preserve">
          <source>Interfaces returns a list of the system's network interfaces.</source>
          <target state="translated">Интерфейсы возвращают список сетевых интерфейсов системы.</target>
        </trans-unit>
        <trans-unit id="faba134b29aa30840bd61a266830217b82a22fc4" translate="yes" xml:space="preserve">
          <source>InternalBenchmark is an internal type but exported because it is cross-package; it is part of the implementation of the &quot;go test&quot; command.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce46964418231d76007ec656366d43d02eb959b8" translate="yes" xml:space="preserve">
          <source>InternalTest is an internal type but exported because it is cross-package; it is part of the implementation of the &quot;go test&quot; command.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a60781d644f0c18cd790184e8cc93bbf04ff58fe" translate="yes" xml:space="preserve">
          <source>Intersect returns the largest rectangle contained by both r and s. If the two rectangles do not overlap then the zero rectangle will be returned.</source>
          <target state="translated">Пересечение возвращает самый большой прямоугольник,содержащийся как в r,так и в s.Если два прямоугольника не перекрываются,то возвращается нулевой прямоугольник.</target>
        </trans-unit>
        <trans-unit id="37b82affb5d88e1d235360ffb5b4876b9c358ef4" translate="yes" xml:space="preserve">
          <source>Intn</source>
          <target state="translated">Intn</target>
        </trans-unit>
        <trans-unit id="54d0c13534e6e00abbb2d04b4cb149c7d0ddea38" translate="yes" xml:space="preserve">
          <source>Intn returns, as an int, a non-negative pseudo-random number in [0,n) from the default Source. It panics if n &amp;lt;= 0.</source>
          <target state="translated">Intn возвращает в виде int неотрицательное псевдослучайное число в [0, n) из источника по умолчанию. Паникает, если n &amp;lt;= 0.</target>
        </trans-unit>
        <trans-unit id="8f26feb5337a07fc6e35ec73e1c6b06a4a8f7c21" translate="yes" xml:space="preserve">
          <source>Intn returns, as an int, a non-negative pseudo-random number in [0,n). It panics if n &amp;lt;= 0.</source>
          <target state="translated">Intn возвращает в виде int неотрицательное псевдослучайное число в [0, n). Паникает, если n &amp;lt;= 0.</target>
        </trans-unit>
        <trans-unit id="2473e96bc614a911821242119918a241a41836d6" translate="yes" xml:space="preserve">
          <source>Introduction</source>
          <target state="translated">Introduction</target>
        </trans-unit>
        <trans-unit id="b7f44e53c873fdc1db7cef7777af521f4a3b60c1" translate="yes" xml:space="preserve">
          <source>Ints</source>
          <target state="translated">Ints</target>
        </trans-unit>
        <trans-unit id="0d62fa520893beed143100d8873cdbc43cfe7428" translate="yes" xml:space="preserve">
          <source>Ints sorts a slice of ints in increasing order.</source>
          <target state="translated">Инты сортируют кусочек инта в порядке возрастания.</target>
        </trans-unit>
        <trans-unit id="00382ca46ab71a1b23e2790f3cf0a66b6faa90df" translate="yes" xml:space="preserve">
          <source>IntsAreSorted</source>
          <target state="translated">IntsAreSorted</target>
        </trans-unit>
        <trans-unit id="15003e1b93fee181a87b2536fb555a75f6e8fa12" translate="yes" xml:space="preserve">
          <source>IntsAreSorted reports whether the slice x is sorted in increasing order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d11bf023986ecfce333bd8a5477d90f31eb1db0a" translate="yes" xml:space="preserve">
          <source>IntsAreSorted tests whether a slice of ints is sorted in increasing order.</source>
          <target state="translated">IntsAreSorted проверяет,отсортирован ли кусок чернил в порядке возрастания.</target>
        </trans-unit>
        <trans-unit id="e6124bd83c6b099c79f4ac3379192d76121e3dfb" translate="yes" xml:space="preserve">
          <source>Inv sets z to 1/x and returns z.</source>
          <target state="translated">Inv устанавливает z в 1/x и возвращает z.</target>
        </trans-unit>
        <trans-unit id="496bc61a17df218d2461a9eddcde86416579b01a" translate="yes" xml:space="preserve">
          <source>Inv sets z to 1/x and returns z. If x == 0, Inv panics.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57f0200085fa1268ae261758bfb7dee5795a5704" translate="yes" xml:space="preserve">
          <source>InvalidByteError values describe errors resulting from an invalid byte in a hex string.</source>
          <target state="translated">Значения InvalidByteError описывают ошибки,возникающие из-за некорректного байта в шестнадцатеричной строке.</target>
        </trans-unit>
        <trans-unit id="fc945344ffab3c8e0685a8f6f0b347b0e1b5f04c" translate="yes" xml:space="preserve">
          <source>Invoke does a JavaScript call of the value v with the given arguments. It panics if v is not a JavaScript function. The arguments get mapped to JavaScript values according to the ValueOf function.</source>
          <target state="translated">Invoke выполняет вызов JavaScript значения v с заданными аргументами.Он паникует,если v не является JavaScript-функцией.Аргументы привязываются к значениям JavaScript в соответствии с функцией ValueOf.</target>
        </trans-unit>
        <trans-unit id="a8bc24ce97a4c19ceec821a6c13e305d4cc7093a" translate="yes" xml:space="preserve">
          <source>Invoking the JavaScript function will synchronously call the Go function fn with the value of JavaScript's &quot;this&quot; keyword and the arguments of the invocation. The return value of the invocation is the result of the Go function mapped back to JavaScript according to ValueOf.</source>
          <target state="translated">При вызове функции JavaScript будет синхронно вызываться функция Go fn со значением ключевого слова &quot;this&quot; JavaScript и аргументами вызова.Возвращаемое значение вызова является результатом отображения функции Go обратно в JavaScript в соответствии со значением ValueOf.</target>
        </trans-unit>
        <trans-unit id="cf66655914f273806173ce98e001321c956d8544" translate="yes" xml:space="preserve">
          <source>Invoking the wrapped Go function from JavaScript will pause the event loop and spawn a new goroutine. Other wrapped functions which are triggered during a call from Go to JavaScript get executed on the same goroutine.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="079bc3b6a59d995ce86a46665da2718451aea120" translate="yes" xml:space="preserve">
          <source>Is</source>
          <target state="translated">Is</target>
        </trans-unit>
        <trans-unit id="b80342e2833069978eb2ebabac8e59ca1a3fbfc5" translate="yes" xml:space="preserve">
          <source>Is reports whether any error in err's chain matches target.</source>
          <target state="translated">Сообщает о том,совпадает ли какая-либо ошибка в цепочке ошибок с целью.</target>
        </trans-unit>
        <trans-unit id="2dcad3f5fb898f44a28ca9cc90eb869f037180e6" translate="yes" xml:space="preserve">
          <source>Is reports whether the rune is in the specified table of ranges.</source>
          <target state="translated">Сообщает,находится ли руна в указанной таблице диапазонов.</target>
        </trans-unit>
        <trans-unit id="d895a1147fb9e99c093e2c8e3aa2a3a161a62599" translate="yes" xml:space="preserve">
          <source>Is unwraps its first argument sequentially looking for an error that matches the second. It reports whether it finds a match. It should be used in preference to simple equality checks:</source>
          <target state="translated">Разворачивает свой первый аргумент последовательно в поисках ошибки,совпадающей со вторым.Он сообщает,находит ли он совпадение.Его следует использовать вместо простой проверки равенства:</target>
        </trans-unit>
        <trans-unit id="4240feb2e7eac03ab7672bf3d52cbd0df60964bf" translate="yes" xml:space="preserve">
          <source>IsAbs</source>
          <target state="translated">IsAbs</target>
        </trans-unit>
        <trans-unit id="6ba3e5deb5d3ce3b158c2019d9e58f42637cf610" translate="yes" xml:space="preserve">
          <source>IsAbs reports whether the URL is absolute. Absolute means that it has a non-empty scheme.</source>
          <target state="translated">IsAbs сообщает,является ли URL абсолютным.Абсолютный означает,что он имеет непустую схему.</target>
        </trans-unit>
        <trans-unit id="36a0d5f9413d1e35ae6366ef607edd836694bee0" translate="yes" xml:space="preserve">
          <source>IsAbs reports whether the path is absolute.</source>
          <target state="translated">IsAbs сообщает,является ли путь абсолютным.</target>
        </trans-unit>
        <trans-unit id="e1eaf7841a07f287f076c00cb20e44f9651ff13f" translate="yes" xml:space="preserve">
          <source>IsAlias reports whether obj is an alias name for a type.</source>
          <target state="translated">IsAlias сообщает,является ли объект псевдонимом для типа.</target>
        </trans-unit>
        <trans-unit id="0e84022f347580b90f81c69d614f481de5c48849" translate="yes" xml:space="preserve">
          <source>IsBuiltin reports whether the corresponding expression denotes a (possibly parenthesized) built-in function.</source>
          <target state="translated">IsBuiltin сообщает,обозначает ли соответствующее выражение встроенную функцию (возможно в скобках).</target>
        </trans-unit>
        <trans-unit id="c915051f076524ecaa2f5d332eb2bb4d2765eefa" translate="yes" xml:space="preserve">
          <source>IsCommand reports whether the package is considered a command to be installed (not just a library). Packages named &quot;main&quot; are treated as commands.</source>
          <target state="translated">IsCommand сообщает,считается ли пакет командой для установки (а не только библиотекой).Пакеты с именем &quot;main&quot; рассматриваются как команды.</target>
        </trans-unit>
        <trans-unit id="2cd3abc2f41e5f98828e0ebaee47dfbcd10387ad" translate="yes" xml:space="preserve">
          <source>IsControl reports whether the rune is a control character. The C (Other) Unicode category includes more code points such as surrogates; use Is(C, r) to test for them.</source>
          <target state="translated">IsControl сообщает,является ли руна управляющим символом.Категория C (Другое)Юникода включает в себя больше пунктов кода,таких как суррогаты;используйте Is(C,r)для их проверки.</target>
        </trans-unit>
        <trans-unit id="c746a0807bba76d32760f9142c884716d0699c51" translate="yes" xml:space="preserve">
          <source>IsDigit reports whether the rune is a decimal digit.</source>
          <target state="translated">IsDigit сообщает,является ли руна десятичной цифрой.</target>
        </trans-unit>
        <trans-unit id="3dc4a185454e26efa4716393eed4775f2e55fe7c" translate="yes" xml:space="preserve">
          <source>IsDir reports whether m describes a directory. That is, it tests for the ModeDir bit being set in m.</source>
          <target state="translated">IsDir сообщает,описывает ли m каталог.То есть он проверяет,установлен ли бит ModeDir в m.</target>
        </trans-unit>
        <trans-unit id="e67a4b242fe3e4d35035e7774ab8072906fab973" translate="yes" xml:space="preserve">
          <source>IsEmptyTree reports whether this tree (node) is empty of everything but space or comments.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5fd80e2b1854e3452cd6bfd7234aa8fa8ddcdc63" translate="yes" xml:space="preserve">
          <source>IsEmptyTree reports whether this tree (node) is empty of everything but space.</source>
          <target state="translated">IsEmptyTree сообщает,пустое ли это дерево (узел),кроме пространства.</target>
        </trans-unit>
        <trans-unit id="cd43f5281afe605e10c23fa5e5c73089248f9feb" translate="yes" xml:space="preserve">
          <source>IsEnabled reports whether tracing is enabled. The information is advisory only. The tracing status may have changed by the time this function returns.</source>
          <target state="translated">IsEnabled сообщает,включена ли трассировка.Информация только рекомендательная.Состояние трассировки могло измениться к моменту возврата функции.</target>
        </trans-unit>
        <trans-unit id="39e18e7e1b9d6fbe4b3f09d74593704f059a0c0a" translate="yes" xml:space="preserve">
          <source>IsEncryptedPEMBlock returns if the PEM block is password encrypted.</source>
          <target state="translated">IsEncryptedPEMBlock возвращается,если блок PEM зашифрован паролем.</target>
        </trans-unit>
        <trans-unit id="60b1c669bbd4deb841f16ea07aaf99039943a55d" translate="yes" xml:space="preserve">
          <source>IsEncryptedPEMBlock returns whether the PEM block is password encrypted according to RFC 1423.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc66205543d841780222acbebc983e058e70415a" translate="yes" xml:space="preserve">
          <source>IsExist returns a boolean indicating whether the error is known to report that a file or directory already exists. It is satisfied by ErrExist as well as some syscall errors.</source>
          <target state="translated">IsExist возвращает логический ключ,указывающий,известна ли ошибка,чтобы сообщить,что файл или каталог уже существует.Он удовлетворен ErrExist,а также некоторыми ошибками syscall.</target>
        </trans-unit>
        <trans-unit id="fc56fa9983588228bd9fa3b0b5a7931ac3cb75f1" translate="yes" xml:space="preserve">
          <source>IsExported reports whether id starts with an upper-case letter.</source>
          <target state="translated">IsExported сообщает,начинается ли идентификатор с прописной буквы.</target>
        </trans-unit>
        <trans-unit id="3c6d4e31e0d52ed1d2823481dfa21ed80c9b776d" translate="yes" xml:space="preserve">
          <source>IsExported reports whether name starts with an upper-case letter.</source>
          <target state="translated">IsExported сообщает,начинается ли имя с прописной буквы.</target>
        </trans-unit>
        <trans-unit id="504274dd55fc2a273ebc2bd501f5695303ffe229" translate="yes" xml:space="preserve">
          <source>IsField reports whether the variable is a struct field.</source>
          <target state="translated">IsField сообщает,является ли переменная структурным полем.</target>
        </trans-unit>
        <trans-unit id="d9bdbeb50a8c37eb5d00e31069315d70d10359d6" translate="yes" xml:space="preserve">
          <source>IsGlobalUnicast reports whether ip is a global unicast address.</source>
          <target state="translated">IsGlobalUnicast сообщает,является ли ip глобальным одноадресным адресом.</target>
        </trans-unit>
        <trans-unit id="81438b4c8eca18603ccf70f1438b5199ee8dc35f" translate="yes" xml:space="preserve">
          <source>IsGoBuild reports whether the line of text is a &amp;ldquo;//go:build&amp;rdquo; constraint. It only checks the prefix of the text, not that the expression itself parses.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d72f8c1ccd0ac092185d981b6c61eacc3c121ef6" translate="yes" xml:space="preserve">
          <source>IsGraphic</source>
          <target state="translated">IsGraphic</target>
        </trans-unit>
        <trans-unit id="56022820abfd812a684373d7b12ff29c87996877" translate="yes" xml:space="preserve">
          <source>IsGraphic reports whether the rune is defined as a Graphic by Unicode. Such characters include letters, marks, numbers, punctuation, symbols, and spaces, from categories L, M, N, P, S, Zs.</source>
          <target state="translated">IsGraphic сообщает,определена ли руна как Graphic по Юникоду.К таким символам относятся буквы,знаки,цифры,знаки препинания,символы и пробелы из категорий L,M,N,P,S,Zs.</target>
        </trans-unit>
        <trans-unit id="3bed5baca126f10003a7fc44f4e55808b330feda" translate="yes" xml:space="preserve">
          <source>IsGraphic reports whether the rune is defined as a Graphic by Unicode. Such characters include letters, marks, numbers, punctuation, symbols, and spaces, from categories L, M, N, P, S, and Zs.</source>
          <target state="translated">IsGraphic сообщает,определена ли руна как Graphic по Юникоду.К таким символам относятся буквы,знаки,цифры,знаки препинания,символы и пробелы из категорий L,M,N,P,S и Zs.</target>
        </trans-unit>
        <trans-unit id="93d167ded0e381246ad35c4922eb8c26e2a4fc55" translate="yes" xml:space="preserve">
          <source>IsIdentifier reports whether name is a Go identifier, that is, a non-empty string made up of letters, digits, and underscores, where the first character is not a digit. Keywords are not identifiers.</source>
          <target state="translated">IsIdentifier сообщает,является ли имя идентификатором Go,то есть непустой строкой,состоящей из букв,цифр и символов подчеркивания,где первый символ не является цифрой.Ключевые слова не являются идентификаторами.</target>
        </trans-unit>
        <trans-unit id="679d30c5187a96f463dfbcdfb594ecc9983403ef" translate="yes" xml:space="preserve">
          <source>IsInf reports whether either real(x) or imag(x) is an infinity.</source>
          <target state="translated">IsInf сообщает,является ли real(x)или imag(x)бесконечностью.</target>
        </trans-unit>
        <trans-unit id="13dd75a92325ad267d0a2fa14c6cb50f24a9dd7b" translate="yes" xml:space="preserve">
          <source>IsInf reports whether f is an infinity, according to sign. If sign &amp;gt; 0, IsInf reports whether f is positive infinity. If sign &amp;lt; 0, IsInf reports whether f is negative infinity. If sign == 0, IsInf reports whether f is either infinity.</source>
          <target state="translated">IsInf сообщает, является ли f бесконечностью в соответствии со знаком. Если sign&amp;gt; 0, IsInf сообщает, является ли f положительной бесконечностью. Если sign &amp;lt;0, IsInf сообщает, является ли f отрицательной бесконечностью. Если sign == 0, IsInf сообщает, равно ли f бесконечности.</target>
        </trans-unit>
        <trans-unit id="8e1783a22a02fb29f43965c4b4c975183d78e4dd" translate="yes" xml:space="preserve">
          <source>IsInf reports whether x is +Inf or -Inf.</source>
          <target state="translated">IsInf сообщает,является ли x +Inf или -Inf.</target>
        </trans-unit>
        <trans-unit id="1b05edd34484393d17b771d708b4b2dd276cb90e" translate="yes" xml:space="preserve">
          <source>IsInt reports whether the denominator of x is 1.</source>
          <target state="translated">IsInt сообщает,равен ли знаменатель Х 1.</target>
        </trans-unit>
        <trans-unit id="63c80063be9af3740f75431caecb4e56ba22484c" translate="yes" xml:space="preserve">
          <source>IsInt reports whether x is an integer. &amp;plusmn;Inf values are not integers.</source>
          <target state="translated">IsInt сообщает, является ли x целым числом. &amp;plusmn; значения Inf не являются целыми числами.</target>
        </trans-unit>
        <trans-unit id="00a1b79e443959417f450c9b16cf5f48a8929d0f" translate="yes" xml:space="preserve">
          <source>IsInt64 reports whether x can be represented as an int64.</source>
          <target state="translated">IsInt64 сообщает,может ли x быть представлен как int64.</target>
        </trans-unit>
        <trans-unit id="ab97d0f94b18fe8f3b28313a45a877858cc4fa50" translate="yes" xml:space="preserve">
          <source>IsInterface reports whether typ is an interface type.</source>
          <target state="translated">IsInterface сообщает,является ли типом интерфейса.</target>
        </trans-unit>
        <trans-unit id="c6bdcbe107886851b028b532be31d52568400157" translate="yes" xml:space="preserve">
          <source>IsInterfaceLocalMulticast reports whether ip is an interface-local multicast address.</source>
          <target state="translated">IsInterfaceLocalMulticast сообщает,является ли ip интерфейсно-локальным адресом многоадресной передачи.</target>
        </trans-unit>
        <trans-unit id="203bcfa02f0ff2531137c0e97e09e91145ccf765" translate="yes" xml:space="preserve">
          <source>IsKeyword reports whether name is a Go keyword, such as &quot;func&quot; or &quot;return&quot;.</source>
          <target state="translated">IsKeyword сообщает,является ли имя ключевым словом Go,например &quot;func&quot; или &quot;return&quot;.</target>
        </trans-unit>
        <trans-unit id="b1af467f9e4844b489b1e4d07d7f23c5a24e49f8" translate="yes" xml:space="preserve">
          <source>IsKeyword returns true for tokens corresponding to keywords; it returns false otherwise.</source>
          <target state="translated">IsKeyword возвращает true для токенов,соответствующих ключевым словам;в противном случае возвращает false.</target>
        </trans-unit>
        <trans-unit id="9e659e799b643d193bc338fa878bc56e93c2043d" translate="yes" xml:space="preserve">
          <source>IsLetter reports whether the rune is a letter (category L).</source>
          <target state="translated">IsLetter сообщает,является ли руна буквой (категория L).</target>
        </trans-unit>
        <trans-unit id="796f0c2eac4ef075bdac49252f1a8a9437f7cb5a" translate="yes" xml:space="preserve">
          <source>IsLinkLocalMulticast reports whether ip is a link-local multicast address.</source>
          <target state="translated">IsLinkLocalMulticast сообщает,является ли ip канально-локальным адресом многоадресной передачи.</target>
        </trans-unit>
        <trans-unit id="bb398472e4891951632d23a856db9700a4f1260f" translate="yes" xml:space="preserve">
          <source>IsLinkLocalUnicast reports whether ip is a link-local unicast address.</source>
          <target state="translated">IsLinkLocalUnicast сообщает,является ли ip ссылочным одноадресным адресом.</target>
        </trans-unit>
        <trans-unit id="338823e775821fbbffd934b6dc8f8c7b06cf31f5" translate="yes" xml:space="preserve">
          <source>IsLiteral returns true for tokens corresponding to identifiers and basic type literals; it returns false otherwise.</source>
          <target state="translated">IsLiteral возвращает true для токенов,соответствующих идентификаторам и литералам базового типа;в противном случае возвращает false.</target>
        </trans-unit>
        <trans-unit id="a302aa5062a5a2939f950e77a3b1bd2cffbbb134" translate="yes" xml:space="preserve">
          <source>IsLocalImport reports whether the import path is a local import path, like &quot;.&quot;, &quot;..&quot;, &quot;./foo&quot;, or &quot;../foo&quot;.</source>
          <target state="translated">IsLocalImport сообщает,является ли путь импорта локальным путем импорта,например,&quot;...&quot;,&quot;...&quot;,&quot;.../foo&quot; или &quot;.../foo&quot;.</target>
        </trans-unit>
        <trans-unit id="a279a0dd486da312eb888a933fcd3c106d5ddf1b" translate="yes" xml:space="preserve">
          <source>IsLoopback reports whether ip is a loopback address.</source>
          <target state="translated">IsLoopback сообщает,является ли ip адресом обратного шлейфа.</target>
        </trans-unit>
        <trans-unit id="4c6115a445a46684f9b4821abab1454dcf00a510" translate="yes" xml:space="preserve">
          <source>IsLower reports whether the rune is a lower case letter.</source>
          <target state="translated">IsLower сообщает,является ли руна строчной буквой.</target>
        </trans-unit>
        <trans-unit id="e316f3e3a4a4a943e13f969fe03fe3e6888a42f0" translate="yes" xml:space="preserve">
          <source>IsMark reports whether the rune is a mark character (category M).</source>
          <target state="translated">IsMark сообщает,является ли руна символом метки (категория M).</target>
        </trans-unit>
        <trans-unit id="e919a8a1e5af711657ece2a09a282e053c84e876" translate="yes" xml:space="preserve">
          <source>IsMulticast reports whether ip is a multicast address.</source>
          <target state="translated">IsMulticast сообщает,является ли ip многоадресным.</target>
        </trans-unit>
        <trans-unit id="0d71475a6ac8cde45586a2e1ee4e9f1a73195c46" translate="yes" xml:space="preserve">
          <source>IsNaN reports whether either real(x) or imag(x) is NaN and neither is an infinity.</source>
          <target state="translated">IsNaN сообщает,является ли real(x)или imag(x)NaN и не является ли бесконечным.</target>
        </trans-unit>
        <trans-unit id="51cb1fb375010c76e1d272e937551b9aa294ed29" translate="yes" xml:space="preserve">
          <source>IsNaN reports whether f is an IEEE 754 &amp;ldquo;not-a-number&amp;rdquo; value.</source>
          <target state="translated">IsNaN сообщает, является ли f &amp;laquo;не числовым&amp;raquo; значением IEEE 754.</target>
        </trans-unit>
        <trans-unit id="e6682a80abf1bf240c434de0a86adc44d2b4fa9e" translate="yes" xml:space="preserve">
          <source>IsNaN reports whether v is the JavaScript value &quot;NaN&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a70a6c8c78f197d95d9931060aaaff0e1ad7ace" translate="yes" xml:space="preserve">
          <source>IsNil reports whether its argument v is nil. The argument must be a chan, func, interface, map, pointer, or slice value; if it is not, IsNil panics. Note that IsNil is not always equivalent to a regular comparison with nil in Go. For example, if v was created by calling ValueOf with an uninitialized interface variable i, i==nil will be true but v.IsNil will panic as v will be the zero Value.</source>
          <target state="translated">IsNil сообщает,равен ли его аргумент v нулю.Аргументом должен быть chan,func,interface,map,pointer или slice value;если это не так,то IsNil паникует.Обратите внимание,что IsNil не всегда эквивалентен обычному сравнению с nil в Go.Например,если v была создана вызовом ValueOf с неинициализированной переменной интерфейса i,то i==nil будет true,но v.IsNil запаникует,так как v будет нулевым Value.</target>
        </trans-unit>
        <trans-unit id="d1cbf137d274a495776ae13213f6abf32b87d01c" translate="yes" xml:space="preserve">
          <source>IsNil reports whether the corresponding expression denotes the predeclared value nil.</source>
          <target state="translated">IsNil сообщает,обозначает ли соответствующее выражение предзаявленное значение nil.</target>
        </trans-unit>
        <trans-unit id="299ff42ffbb3020ccb3e165c3f47990aa016cf3b" translate="yes" xml:space="preserve">
          <source>IsNotExist</source>
          <target state="translated">IsNotExist</target>
        </trans-unit>
        <trans-unit id="03c20e37da945e513d60a4c872afa073a5099855" translate="yes" xml:space="preserve">
          <source>IsNotExist returns a boolean indicating whether the error is known to report that a file or directory does not exist. It is satisfied by ErrNotExist as well as some syscall errors.</source>
          <target state="translated">IsNotExist возвращает логическое сообщение,указывающее,известна ли ошибка,сообщающая о том,что файл или каталог не существует.Он удовлетворен ErrNotExist,а также некоторыми ошибками syscall.</target>
        </trans-unit>
        <trans-unit id="05e6aafd3bbc506bf83192365d5b5ee27918dfa7" translate="yes" xml:space="preserve">
          <source>IsNull reports whether v is the JavaScript value &quot;null&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2c323038256b2a2953181c6a475ccd896ada404" translate="yes" xml:space="preserve">
          <source>IsNumber reports whether the rune is a number (category N).</source>
          <target state="translated">IsNumber сообщает,является ли руна номером (категория N).</target>
        </trans-unit>
        <trans-unit id="245475f668f23bbed41324e2de1b4948cc531ddc" translate="yes" xml:space="preserve">
          <source>IsOneOf reports whether the rune is a member of one of the ranges. The function &quot;In&quot; provides a nicer signature and should be used in preference to IsOneOf.</source>
          <target state="translated">IsOneOf сообщает,является ли руна членом одного из диапазонов.Функция &quot;In&quot; обеспечивает более приятную сигнатуру и должна использоваться в предпочтении перед IsOneOf.</target>
        </trans-unit>
        <trans-unit id="a20bd2f5568b340e7370b04b798bc3f83596bcce" translate="yes" xml:space="preserve">
          <source>IsOperator returns true for tokens corresponding to operators and delimiters; it returns false otherwise.</source>
          <target state="translated">IsOperator возвращает true для токенов,соответствующих операторам и разделителям;возвращает false иначе.</target>
        </trans-unit>
        <trans-unit id="73c5624da9ca6fbf3e420dbf86786a852cc89a14" translate="yes" xml:space="preserve">
          <source>IsPathSeparator reports whether c is a directory separator character.</source>
          <target state="translated">IsPathSeparator сообщает,является ли c символом разделителя каталогов.</target>
        </trans-unit>
        <trans-unit id="8bd40ac27999a79bc28cf90f839e43d8f9372279" translate="yes" xml:space="preserve">
          <source>IsPermission returns a boolean indicating whether the error is known to report that permission is denied. It is satisfied by ErrPermission as well as some syscall errors.</source>
          <target state="translated">IsPermission возвращает логический ключ,указывающий,известно ли об ошибке,что разрешение запрещено.Он удовлетворен ErrPermission,а также некоторыми ошибками syscall.</target>
        </trans-unit>
        <trans-unit id="ba016d3b011cf2a354ca328ddbed33673e5c990a" translate="yes" xml:space="preserve">
          <source>IsPlusBuild reports whether the line of text is a &amp;ldquo;// +build&amp;rdquo; constraint. It only checks the prefix of the text, not that the expression itself parses.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e48f3df15b49da83d51099ad5b3eb8bbfd8edc75" translate="yes" xml:space="preserve">
          <source>IsPredeclared reports whether s is a predeclared identifier.</source>
          <target state="translated">IsPredeclared сообщает,является ли s предзаявленным идентификатором.</target>
        </trans-unit>
        <trans-unit id="36ebaf4d189aca534d273d48d5ddeec782d7bed9" translate="yes" xml:space="preserve">
          <source>IsPrint</source>
          <target state="translated">IsPrint</target>
        </trans-unit>
        <trans-unit id="9798b863454466bfa901e359486dca8125aebd8e" translate="yes" xml:space="preserve">
          <source>IsPrint reports whether the rune is defined as printable by Go, with the same definition as unicode.IsPrint: letters, numbers, punctuation, symbols and ASCII space.</source>
          <target state="translated">IsPrint сообщает,определена ли руна как печатаемая Go,с тем же определением,что и unicode.IsPrint:буквы,цифры,пунктуация,символы и ASCII пространство.</target>
        </trans-unit>
        <trans-unit id="98481c27a5fae0a861fa7de3b6778c4d86a82e18" translate="yes" xml:space="preserve">
          <source>IsPrint reports whether the rune is defined as printable by Go. Such characters include letters, marks, numbers, punctuation, symbols, and the ASCII space character, from categories L, M, N, P, S and the ASCII space character. This categorization is the same as IsGraphic except that the only spacing character is ASCII space, U+0020.</source>
          <target state="translated">IsPrint сообщает,определена ли руна как печатаемая Go.К таким символам относятся буквы,знаки,цифры,пунктуация,символы и знак пробела ASCII из категорий L,M,N,P,S и знак пробела ASCII.Данная категоризация такая же,как и IsGraphic,за исключением того,что единственным пробельным символом является ASCII пробел,U+0020.</target>
        </trans-unit>
        <trans-unit id="8d669f2d873d45ac65ae33ba5fc527f66e56a570" translate="yes" xml:space="preserve">
          <source>IsPunct reports whether the rune is a Unicode punctuation character (category P).</source>
          <target state="translated">IsPunct сообщает,является ли руна символом препинания Юникода (категория P).</target>
        </trans-unit>
        <trans-unit id="09f51db22f739274d216b281ce628857122cde77" translate="yes" xml:space="preserve">
          <source>IsRegular reports whether m describes a regular file. That is, it tests that no mode type bits are set.</source>
          <target state="translated">IsRegular сообщает,описывает ли m обычный файл.То есть проверяется,что биты типа режима не заданы.</target>
        </trans-unit>
        <trans-unit id="7aa02fb0658d675b5c73f5d774f227af20e5eda3" translate="yes" xml:space="preserve">
          <source>IsScanValue is equivalent to IsValue. It exists for compatibility.</source>
          <target state="translated">IsScanValue эквивалентна IsValue.Он существует для совместимости.</target>
        </trans-unit>
        <trans-unit id="02fd007fd97349a8b2fafa3e48b3fe7f504ea24c" translate="yes" xml:space="preserve">
          <source>IsSorted reports whether data is sorted.</source>
          <target state="translated">IsSorted сообщает,сортируются ли данные.</target>
        </trans-unit>
        <trans-unit id="514d21d401add5f58b109e05d3a8a2615962f831" translate="yes" xml:space="preserve">
          <source>IsSpace reports whether the rune is a space character as defined by Unicode's White Space property; in the Latin-1 space this is</source>
          <target state="translated">IsSpace сообщает,является ли руна символом пробела,как определено свойством &quot;Белое пространство&quot; Юникода;в латинском пространстве-1 это</target>
        </trans-unit>
        <trans-unit id="b8364c32e39bc01deb2db29de008f790b53e0511" translate="yes" xml:space="preserve">
          <source>IsSurrogate reports whether the specified Unicode code point can appear in a surrogate pair.</source>
          <target state="translated">IsSurrogate сообщает,может ли указанная кодовая точка Юникода появляться в суррогатной паре.</target>
        </trans-unit>
        <trans-unit id="94ff69a73ee80e68160fc5d14463531f326feb1a" translate="yes" xml:space="preserve">
          <source>IsSymbol reports whether the rune is a symbolic character.</source>
          <target state="translated">IsSymbol сообщает,является ли руна символическим символом.</target>
        </trans-unit>
        <trans-unit id="80e8a9046c478caac6544a67a67898f6f56d102d" translate="yes" xml:space="preserve">
          <source>IsTimeout returns a boolean indicating whether the error is known to report that a timeout occurred.</source>
          <target state="translated">IsTimeout возвращает логическое сообщение,указывающее,известна ли ошибка,что произошел таймаут.</target>
        </trans-unit>
        <trans-unit id="5dae031aae8f79fce18391198feff6e45790996f" translate="yes" xml:space="preserve">
          <source>IsTitle reports whether the rune is a title case letter.</source>
          <target state="translated">IsTitle сообщает,является ли руна заглавной буквой.</target>
        </trans-unit>
        <trans-unit id="47cdd782e568065cbc896003cc3080e6fa343e64" translate="yes" xml:space="preserve">
          <source>IsTrue reports whether the value is 'true', in the sense of not the zero of its type, and whether the value has a meaningful truth value. This is the definition of truth used by if and other such actions.</source>
          <target state="translated">IsTrue сообщает,является ли значение &quot;истиной&quot;,в смысле не нуля своего типа,и имеет ли значение истины.Таково определение истины,используемое для определения &quot;если&quot; и других подобных действий.</target>
        </trans-unit>
        <trans-unit id="f386d0c906e9366cb699b0ae4451bc9d70023dc4" translate="yes" xml:space="preserve">
          <source>IsType reports whether the corresponding expression specifies a type.</source>
          <target state="translated">IsType сообщает,указывает ли соответствующее выражение на тип.</target>
        </trans-unit>
        <trans-unit id="bd72caa363338547d5699b96c1b4ac80c8cd24c1" translate="yes" xml:space="preserve">
          <source>IsUint64 reports whether x can be represented as a uint64.</source>
          <target state="translated">IsUint64 сообщает,может ли x быть представлен как uint64.</target>
        </trans-unit>
        <trans-unit id="85a3cd11f8d331b3763c1e34e0ce1cfca9c37e79" translate="yes" xml:space="preserve">
          <source>IsUndefined reports whether v is the JavaScript value &quot;undefined&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b3721da2086f5e9441475d80b1c204e06489512" translate="yes" xml:space="preserve">
          <source>IsUnspecified reports whether ip is an unspecified address, either the IPv4 address &quot;0.0.0.0&quot; or the IPv6 address &quot;::&quot;.</source>
          <target state="translated">IsUnspecified сообщает,является ли ip неуказанным адресом,либо адрес IPv4 &quot;0.0.0.0&quot;,либо адрес IPv6 &quot;::&quot;.</target>
        </trans-unit>
        <trans-unit id="b72d29b8198db403c8169f5f00434fb729acb678" translate="yes" xml:space="preserve">
          <source>IsUpper reports whether the rune is an upper case letter.</source>
          <target state="translated">IsUpper сообщает,является ли руна заглавной буквой.</target>
        </trans-unit>
        <trans-unit id="ecc382ac4eeae90631c4ff786a142c8cd4a2a1e3" translate="yes" xml:space="preserve">
          <source>IsValid reports whether the position is valid.</source>
          <target state="translated">IsValid сообщает,действительна ли позиция.</target>
        </trans-unit>
        <trans-unit id="fa9386e1dba484fd3efd4626c53284c1fe827e1b" translate="yes" xml:space="preserve">
          <source>IsValid reports whether v represents a value. It returns false if v is the zero Value. If IsValid returns false, all other methods except String panic. Most functions and methods never return an invalid Value. If one does, its documentation states the conditions explicitly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b4d65bab951e443a5b5a6cb70b5527aa329d397" translate="yes" xml:space="preserve">
          <source>IsValid reports whether v represents a value. It returns false if v is the zero Value. If IsValid returns false, all other methods except String panic. Most functions and methods never return an invalid value. If one does, its documentation states the conditions explicitly.</source>
          <target state="translated">IsValid сообщает,представляет ли v значение.Он возвращает false,если v является нулевым значением.Если IsValid возвращает false,все остальные методы,кроме String panic.Большинство функций и методов никогда не возвращают недопустимое значение.Если возвращает,то в его документации условия указываются явно.</target>
        </trans-unit>
        <trans-unit id="55d30ff7d3d863a32468776759178dbe0451ccce" translate="yes" xml:space="preserve">
          <source>IsValue reports whether the corresponding expression is a value. Builtins are not considered values. Constant values have a non- nil Value.</source>
          <target state="translated">IsValue сообщает,является ли соответствующее выражение значением.Сборки не считаются значениями.Постоянные значения имеют ненулевое значение.</target>
        </trans-unit>
        <trans-unit id="9d7a5d3a7652824e4f9b549a7d5a262a10ef59c5" translate="yes" xml:space="preserve">
          <source>IsValue reports whether v is a valid Value parameter type.</source>
          <target state="translated">IsValue сообщает,является ли v допустимым типом параметра Value.</target>
        </trans-unit>
        <trans-unit id="65e1a871482dad54f08e17dd72762a3fd2f75d74" translate="yes" xml:space="preserve">
          <source>IsVoid reports whether the corresponding expression is a function call without results.</source>
          <target state="translated">IsVoid сообщает,является ли соответствующее выражение вызовом функции без результатов.</target>
        </trans-unit>
        <trans-unit id="297c16f9ae029663b610c3b616363007a062b053" translate="yes" xml:space="preserve">
          <source>IsWordChar reports whether r is consider a &amp;ldquo;word character&amp;rdquo; during the evaluation of the \b and \B zero-width assertions. These assertions are ASCII-only: the word characters are [A-Za-z0-9_].</source>
          <target state="translated">IsWordChar сообщает, считается ли r &amp;laquo;символом слова&amp;raquo; во время оценки утверждений нулевой ширины \ b и \ B. Эти утверждения являются только ASCII: символы слова - [A-Za-z0-9_].</target>
        </trans-unit>
        <trans-unit id="5f0397c5af2b47c485a6cac89d344b49d39148e5" translate="yes" xml:space="preserve">
          <source>IsZero reports whether t represents the zero time instant, January 1, year 1, 00:00:00 UTC.</source>
          <target state="translated">IsZero сообщает,представляет ли t нулевой момент времени,1 января,год 1,00:00:00 UTC.</target>
        </trans-unit>
        <trans-unit id="14b29f8979f8b38e486b8c2fc265fcec75315a1b" translate="yes" xml:space="preserve">
          <source>IsZero reports whether v is the zero value for its type. It panics if the argument is invalid.</source>
          <target state="translated">IsZero сообщает,является ли v нулевым значением для своего типа.Он паникует,если аргумент недействителен.</target>
        </trans-unit>
        <trans-unit id="2e5ba7b50d53dc66de9ac76f94ae84e19ac42a4e" translate="yes" xml:space="preserve">
          <source>IsolationLevel is the transaction isolation level stored in TxOptions.</source>
          <target state="translated">IsolationLevel-это уровень изоляции транзакций,хранящийся в TxOptions.</target>
        </trans-unit>
        <trans-unit id="00b8885e61c34531225b38e32ae41a763eb82a05" translate="yes" xml:space="preserve">
          <source>IsolationLevel is the transaction isolation level used in TxOptions.</source>
          <target state="translated">IsolationLevel-уровень изоляции транзакций,используемый в TxOptions.</target>
        </trans-unit>
        <trans-unit id="d76fb5eb8c221bc52330dc2413a54b325f8af681" translate="yes" xml:space="preserve">
          <source>It does nothing if the URL's scheme is not HTTP or HTTPS.</source>
          <target state="translated">Он ничего не делает,если схема URL не HTTP или HTTPS.</target>
        </trans-unit>
        <trans-unit id="730fc66fc7c6f8658abbd279912d4debd6897a14" translate="yes" xml:space="preserve">
          <source>It is allowed but not required for the caller to hold c.L during the call.</source>
          <target state="translated">Во время разговора разрешается,но не требуется,чтобы вызывающий абонент удерживал c.L во время разговора.</target>
        </trans-unit>
        <trans-unit id="64b18effbf60d196d9c9972b0f4752ad49d90515" translate="yes" xml:space="preserve">
          <source>It is allowed to call Notify multiple times with different channels and the same signals: each channel receives copies of incoming signals independently.</source>
          <target state="translated">Допускается многократный вызов Notify с разными каналами и одними и теми же сигналами:каждый канал получает копии входящих сигналов независимо друг от друга.</target>
        </trans-unit>
        <trans-unit id="2b72f5a15cc86252895b6a5820ed7c36974cccb2" translate="yes" xml:space="preserve">
          <source>It is allowed to call Notify multiple times with the same channel: each call expands the set of signals sent to that channel. The only way to remove signals from the set is to call Stop.</source>
          <target state="translated">Допускается многократный вызов Notify по одному и тому же каналу:каждый вызов расширяет набор сигналов,посылаемых на этот канал.Единственный способ удалить сигналы из набора-это позвонить в Stop.</target>
        </trans-unit>
        <trans-unit id="64b9ab50226fefd57abe4e106fe4fbde6d348569" translate="yes" xml:space="preserve">
          <source>It is defined in RFC 1950:</source>
          <target state="translated">Определено в RFC 1950:</target>
        </trans-unit>
        <trans-unit id="3527f9b32341885623b87c38f5f98392bdedd8dc" translate="yes" xml:space="preserve">
          <source>It is equivalent to SplitAfterN with a count of -1.</source>
          <target state="translated">Он эквивалентен SplitAfterN с числом -1.</target>
        </trans-unit>
        <trans-unit id="dbac3455f5dcff27b15907e612c36dc6d6627118" translate="yes" xml:space="preserve">
          <source>It is equivalent to SplitN with a count of -1.</source>
          <target state="translated">Он эквивалентен SplitN с числом -1.</target>
        </trans-unit>
        <trans-unit id="9bc89c86db3c02e15ec65887cfcf0cc312b36a24" translate="yes" xml:space="preserve">
          <source>It is not associated with any particular color profile.</source>
          <target state="translated">Он не связан с каким-либо определенным цветовым профилем.</target>
        </trans-unit>
        <trans-unit id="8b9cf269b7a066efe335dc4941105afdd2791a76" translate="yes" xml:space="preserve">
          <source>It is not guaranteed that a finalizer will run for objects allocated in initializers for package-level variables. Such objects may be linker-allocated, not heap-allocated.</source>
          <target state="translated">Не гарантируется,что для объектов,выделенных в инициализаторах для переменных пакетного уровня,будет запущен финализатор.Такие объекты могут быть компоновщиками,а не кучами.</target>
        </trans-unit>
        <trans-unit id="185afc47d5312f1df75d7c2e1fd8c497c93c1bee" translate="yes" xml:space="preserve">
          <source>It is not guaranteed that a finalizer will run if the size of *obj is zero bytes.</source>
          <target state="translated">Не гарантируется,что финализатор будет запущен,если размер *obj равен нулю байт.</target>
        </trans-unit>
        <trans-unit id="e276973efe0e06473fcbf2184470a55ce905f9ea" translate="yes" xml:space="preserve">
          <source>It is rare to Close a DB, as the DB handle is meant to be long-lived and shared between many goroutines.</source>
          <target state="translated">Редко удается закрыть БД,так как рукоятка БД предназначена для долгого срока службы и разделения между многими горутинами.</target>
        </trans-unit>
        <trans-unit id="9a7d91a6cfdd5d25c7a9aebf66715a0621fd64e1" translate="yes" xml:space="preserve">
          <source>It is safe to call Dialer's methods concurrently.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13c70c7692f708ab80a79d217ba3b943c3b63874" translate="yes" xml:space="preserve">
          <source>It is safe to call Read and Write in parallel with each other or with Close. Parallel calls to Read and parallel calls to Write are also safe: the individual calls will be gated sequentially.</source>
          <target state="translated">Безопасно вызвать функцию Чтение и запись параллельно или с помощью функции Закрыть.Параллельные вызовы на Чтение и параллельные вызовы на Запись также безопасны:отдельные вызовы будут последовательно шлюзоваться.</target>
        </trans-unit>
        <trans-unit id="fdb69e790ac12df4afc740ea8ac0b288915135a0" translate="yes" xml:space="preserve">
          <source>It is safe to execute multiple Read calls concurrently, but their arguments must share no underlying memory. When in doubt, create a new []Sample from scratch, which is always safe, though may be inefficient.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e87bdde62b3a11cc618f6eef7d1ef7e95ea027e" translate="yes" xml:space="preserve">
          <source>It is sometimes necessary for a test program to do extra setup or teardown before or after testing. It is also sometimes necessary for a test to control which code runs on the main thread. To support these and other cases, if a test file contains a function:</source>
          <target state="translated">Иногда бывает необходимо,чтобы тестовая программа сделала дополнительную настройку или проиграла до или после тестирования.Также иногда необходимо,чтобы тест контролировал,какой код выполняется на основном потоке.Для поддержки этих и других случаев,если тестовый файл содержит функцию:</target>
        </trans-unit>
        <trans-unit id="c4c640b2d1c13408fc0addbe9ca9b3e33c914d4c" translate="yes" xml:space="preserve">
          <source>It is the caller's responsibility to call Close on the Reader when done.</source>
          <target state="translated">Звонящий обязан позвонить в Close on the Reader,когда все будет готово.</target>
        </trans-unit>
        <trans-unit id="986480998eaebed4b6a54647e1482613d046d84f" translate="yes" xml:space="preserve">
          <source>It is the caller's responsibility to call Close on the Writer when done. Writes may be buffered and not flushed until Close.</source>
          <target state="translated">Звонящий обязан позвонить в Close on the Writer,когда все будет готово.Письменные сообщения можно буферизировать и не смывать до тех пор,пока Close (Закрыть).</target>
        </trans-unit>
        <trans-unit id="5d5e9d1ff14ea8de0b89e8865f3f584d482a0afe" translate="yes" xml:space="preserve">
          <source>It is useful mainly in compressed network protocols, to ensure that a remote reader has enough data to reconstruct a packet. Flush does not return until the data has been written. If the underlying writer returns an error, Flush returns that error.</source>
          <target state="translated">Он полезен в основном в сжатых сетевых протоколах,чтобы гарантировать,что удаленное считывающее устройство имеет достаточно данных для восстановления пакета.Флеш не возвращается до тех пор,пока данные не будут записаны.Если основной пишущий CD-ROM возвращает ошибку,Flush возвращает эту ошибку.</target>
        </trans-unit>
        <trans-unit id="31cc99464ed62136a451655119e840afa7451b83" translate="yes" xml:space="preserve">
          <source>It is valid both to add and to subtract offsets from a pointer in this way. It is also valid to use &amp;amp;^ to round pointers, usually for alignment. In all cases, the result must continue to point into the original allocated object.</source>
          <target state="translated">Таким образом можно как добавлять, так и вычитать смещения из указателя. Также можно использовать &amp;amp; ^ для округления указателей, обычно для выравнивания. Во всех случаях результат должен продолжать указывать на исходный выделенный объект.</target>
        </trans-unit>
        <trans-unit id="dd1e16d418b70f8a4bcbc355b1da37369ffe8113" translate="yes" xml:space="preserve">
          <source>It makes one call to data.Len to determine n, O(n*log(n)) calls to data.Less and O(n*log(n)*log(n)) calls to data.Swap.</source>
          <target state="translated">Он делает один вызов data.Len для определения n,O(n*log(n))вызовов data.Less и O(n*log(n)*log(n))вызовов data.Swap.</target>
        </trans-unit>
        <trans-unit id="49a3b03dcb3864c71030445c5ba5bfe2611711d2" translate="yes" xml:space="preserve">
          <source>It may also be received into any of these:</source>
          <target state="translated">Он также может быть получен в любом из них:</target>
        </trans-unit>
        <trans-unit id="7b88fc3e61debf0d0f1a1581e71a0996edf539a5" translate="yes" xml:space="preserve">
          <source>It panics if count is negative or if the result of (len(b) * count) overflows.</source>
          <target state="translated">Он паникует,если счет отрицательный или если результат (len(b)*счет)переполняется.</target>
        </trans-unit>
        <trans-unit id="8b61a1a4bb411ee036d7d3cc509678ace33cef83" translate="yes" xml:space="preserve">
          <source>It panics if count is negative or if the result of (len(s) * count) overflows.</source>
          <target state="translated">Он паникует,если счет отрицательный или если результат (len(s)*счет)переполняется.</target>
        </trans-unit>
        <trans-unit id="652db58383317d0338f369bbd62022ed3ab07600" translate="yes" xml:space="preserve">
          <source>It panics if the Value was obtained by accessing unexported struct fields.</source>
          <target state="translated">Он паникует,если Значение было получено путем доступа к неэкспортированным полям структуры.</target>
        </trans-unit>
        <trans-unit id="564d342d70ea92defe3199a234b7ca21ece54f95" translate="yes" xml:space="preserve">
          <source>It returns a *rsa.PrivateKey, a *ecdsa.PrivateKey, or a ed25519.PrivateKey. More types might be supported in the future.</source>
          <target state="translated">Он возвращает *rsa.PrivateKey,*ecdsa.PrivateKey,или ed25519.PrivateKey.В будущем могут поддерживаться и другие типы.</target>
        </trans-unit>
        <trans-unit id="9f11d9cd546ed2abe8e697fa6f8bbdc2a3d2e5ef" translate="yes" xml:space="preserve">
          <source>It returns a *rsa.PublicKey, *dsa.PublicKey, *ecdsa.PublicKey, or ed25519.PublicKey. More types might be supported in the future.</source>
          <target state="translated">Он возвращает *rsa.PublicKey,*dsa.PublicKey,*ecdsa.PublicKey,или ed25519.PublicKey.В будущем могут поддерживаться и другие типы.</target>
        </trans-unit>
        <trans-unit id="e5010d434ca33dd92d7a44910817533939048059" translate="yes" xml:space="preserve">
          <source>It returns an empty slice if the URL's scheme is not HTTP or HTTPS.</source>
          <target state="translated">Возвращает пустой кусок,если схема URL не HTTP или HTTPS.</target>
        </trans-unit>
        <trans-unit id="2b565edf53edd5e13295b4a395aad926eda82327" translate="yes" xml:space="preserve">
          <source>It returns an error if t has already been executed.</source>
          <target state="translated">Он возвращает ошибку,если t уже была выполнена.</target>
        </trans-unit>
        <trans-unit id="a56353db7fb203c22e0bfd117b292abd05c5de94" translate="yes" xml:space="preserve">
          <source>It returns an error if t or any associated template has already been executed.</source>
          <target state="translated">Он возвращает ошибку,если t или любой связанный с ним шаблон уже был выполнен.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
