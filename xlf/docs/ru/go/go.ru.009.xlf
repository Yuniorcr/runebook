<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="go">
    <body>
      <group id="go">
        <trans-unit id="043f79dd25246a384c5fa68242e8b0950e54d69e" translate="yes" xml:space="preserve">
          <source>The comparison functions work on any values whose type Go defines as comparable. For basic types such as integers, the rules are relaxed: size and exact type are ignored, so any integer value, signed or unsigned, may be compared with any other integer value. (The arithmetic value is compared, not the bit pattern, so all negative integers are less than all unsigned integers.) However, as usual, one may not compare an int with a float32 and so on.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53528cbdfa92cb465406c07ac6068163f15d8aff" translate="yes" xml:space="preserve">
          <source>The comparison functions work on basic types only (or named basic types, such as &quot;type Celsius float32&quot;). They implement the Go rules for comparison of values, except that size and exact type are ignored, so any integer value, signed or unsigned, may be compared with any other integer value. (The arithmetic value is compared, not the bit pattern, so all negative integers are less than all unsigned integers.) However, as usual, one may not compare an int with a float32 and so on.</source>
          <target state="translated">Функции сравнения работают только с базовыми типами (или именованными базовыми типами,такими как &quot;тип Celsius float32&quot;).Они реализуют правила Go для сравнения значений,за исключением того,что размер и точный тип игнорируются,поэтому любое целое значение,знаковое или беззнаковое,может быть сравнено с любым другим целым значением.(Арифметическое значение сравнивается,а не битовый шаблон,поэтому все отрицательные целые числа меньше всех беззнаковых целых чисел).Однако,как обычно,нельзя сравнивать int с float32 и так далее.</target>
        </trans-unit>
        <trans-unit id="3947ad8b82d2733c9797fbc944569005335da23c" translate="yes" xml:space="preserve">
          <source>The compiler handles a Pointer converted to a uintptr in the argument list of a call to a function implemented in assembly by arranging that the referenced allocated object, if any, is retained and not moved until the call completes, even though from the types alone it would appear that the object is no longer needed during the call.</source>
          <target state="translated">Компилятор обрабатывает указатель,преобразованный в uintptr в списке аргументов вызова функции,реализованной при сборке,упорядочивая,что ссылающийся выделенный объект,если таковой имеется,сохраняется и не перемещается до завершения вызова,хотя из одних только типов может показаться,что этот объект больше не нужен во время вызова.</target>
        </trans-unit>
        <trans-unit id="fbe6ac33b06dc273e75926ad2490d8b3832a0214" translate="yes" xml:space="preserve">
          <source>The complex built-in function constructs a complex value from two floating-point values. The real and imaginary parts must be of the same size, either float32 or float64 (or assignable to them), and the return value will be the corresponding complex type (complex64 for float32, complex128 for float64).</source>
          <target state="translated">Встроенная комплексная функция строит комплексное значение из двух значений с плавающей точкой.Реальная и мнимая части должны быть одинакового размера,либо float32,либо float64 (или присваиваемые им),а возвращаемое значение будет соответствующего типа комплекса (complex64 для float32,complex128 для float64).</target>
        </trans-unit>
        <trans-unit id="ef38d7c2bab871a13bc3d0543cc12b1189486358" translate="yes" xml:space="preserve">
          <source>The compression level can be DefaultCompression, NoCompression, HuffmanOnly or any integer value between BestSpeed and BestCompression inclusive. The error returned will be nil if the level is valid.</source>
          <target state="translated">Степень сжатия может быть DefaultCompression,NoCompression,HuffmanOnly или любое целое значение между BestSpeed и BestCompression включительно.Возвращаемая ошибка будет равна нулю,если уровень является допустимым.</target>
        </trans-unit>
        <trans-unit id="0a1efe910d68e12343aa1a848eb28de270b6d379" translate="yes" xml:space="preserve">
          <source>The computed hash values depend only on the initial seed and the sequence of bytes provided to the Hash object, not on the way in which the bytes are provided. For example, the three sequences</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="351f67248e4d8a5518193363a02cfe1c83014012" translate="yes" xml:space="preserve">
          <source>The constant UpperLower has an otherwise impossible delta value.</source>
          <target state="translated">Константа Верхний Нижний имеет иначе невозможное значение дельты.</target>
        </trans-unit>
        <trans-unit id="8c8706295858fb442cc0b27075b7f68668230e3c" translate="yes" xml:space="preserve">
          <source>The content's Seek method must work: ServeContent uses a seek to the end of the content to determine its size.</source>
          <target state="translated">Метод поиска контента должен работать:ServeContent использует поиск до конца контента,чтобы определить его размер.</target>
        </trans-unit>
        <trans-unit id="7a49805d773fd718112af263e9a481b6533ee15e" translate="yes" xml:space="preserve">
          <source>The context function will be called with a single argument, a pointer to a struct:</source>
          <target state="translated">Контекстная функция будет вызвана с единственным аргументом,указателем на структуру:</target>
        </trans-unit>
        <trans-unit id="d756f1871d5d4f318cef847f3f882a9119bd1f8d" translate="yes" xml:space="preserve">
          <source>The conversion rules are:</source>
          <target state="translated">Правила преобразования таковы:</target>
        </trans-unit>
        <trans-unit id="8b9249f4b562855e188c8c6e04ee31f39d350295" translate="yes" xml:space="preserve">
          <source>The copy built-in function copies elements from a source slice into a destination slice. (As a special case, it also will copy bytes from a string to a slice of bytes.) The source and destination may overlap. Copy returns the number of elements copied, which will be the minimum of len(src) and len(dst).</source>
          <target state="translated">Встроенная функция копирования копирует элементы из исходного фрагмента в целевой фрагмент.(В особом случае она также будет копировать байты из строки в дольку байтов).Исходный и целевой фрагменты могут пересекаться.Копирование возвращает количество скопированных элементов,которое будет минимальным для len(src)и len(dst).</target>
        </trans-unit>
        <trans-unit id="7003f654a24cc0fe7e8417bb3241f59de9fe836b" translate="yes" xml:space="preserve">
          <source>The count determines the number of substrings to return:</source>
          <target state="translated">Счетчик определяет количество возвращаемых подстроек:</target>
        </trans-unit>
        <trans-unit id="5dbb8e654b6fb0895661f0c315a08864e55ec239" translate="yes" xml:space="preserve">
          <source>The crypto/tls package only implements some countermeasures against Lucky13 attacks on CBC-mode encryption, and only on SHA1 variants. See &lt;a href=&quot;http://www.isg.rhul.ac.uk/tls/TLStiming.pdf&quot;&gt;http://www.isg.rhul.ac.uk/tls/TLStiming.pdf&lt;/a&gt; and &lt;a href=&quot;https://www.imperialviolet.org/2013/02/04/luckythirteen.html&quot;&gt;https://www.imperialviolet.org/2013/02/04/luckythirteen.html&lt;/a&gt;.</source>
          <target state="translated">Пакет crypto / tls реализует только некоторые меры противодействия атакам Lucky13 на шифрование в режиме CBC и только на варианты SHA1. См. &lt;a href=&quot;http://www.isg.rhul.ac.uk/tls/TLStiming.pdf&quot;&gt;Http://www.isg.rhul.ac.uk/tls/TLStiming.pdf&lt;/a&gt; и &lt;a href=&quot;https://www.imperialviolet.org/2013/02/04/luckythirteen.html&quot;&gt;https://www.imperialviolet.org/2013/02/04/luckythirteen.html&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3df95d2be07bff158f354793704b39fa0b17441d" translate="yes" xml:space="preserve">
          <source>The cryptographic operations are implemented using constant-time algorithms.</source>
          <target state="translated">Криптографические операции реализованы с использованием алгоритмов постоянного времени.</target>
        </trans-unit>
        <trans-unit id="7eab6b01982b7d5d0967ad563265ae830b1ba245" translate="yes" xml:space="preserve">
          <source>The cryptographic operations do not use constant-time algorithms.</source>
          <target state="translated">В криптографических операциях не используются алгоритмы константного времени.</target>
        </trans-unit>
        <trans-unit id="27e1f3bd597aed109fd98be320131ab37e282b69" translate="yes" xml:space="preserve">
          <source>The currently supported key types are *rsa.PublicKey, *ecdsa.PublicKey and ed25519.PublicKey. pub must be a supported key type, and priv must be a crypto.Signer with a supported public key.</source>
          <target state="translated">В настоящее время поддерживаются следующие типы ключей:*rsa.PublicKey,*ecdsa.PublicKey и ed25519.PublicKey.pub должен быть поддерживаемым типом ключа,а priv должен быть крипто.Signer с поддерживаемым публичным ключом.</target>
        </trans-unit>
        <trans-unit id="5f866cd795794ee9a8943b941d8f0f21dd57c5d8" translate="yes" xml:space="preserve">
          <source>The d argument is the fs.DirEntry for the named path.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a6143ad908fa5d13101f2932405343a9fc3dd21" translate="yes" xml:space="preserve">
          <source>The debug parameter enables additional output. Passing debug=0 prints only the hexadecimal addresses that pprof needs. Passing debug=1 adds comments translating addresses to function names and line numbers, so that a programmer can read the profile without tools.</source>
          <target state="translated">Параметр отладки включает дополнительный вывод.Передача debug=0 печатает только те шестнадцатеричные адреса,которые нужны pprof.При передаче debug=1 добавляются комментарии,транслирующие адреса в имена функций и номера строк,чтобы программист мог читать профиль без инструментов.</target>
        </trans-unit>
        <trans-unit id="0fb33327b278ec03a78f307167cc6e36a7617010" translate="yes" xml:space="preserve">
          <source>The debug parameter enables additional output. Passing debug=0 writes the gzip-compressed protocol buffer described in &lt;a href=&quot;https://github.com/google/pprof/tree/master/proto#overview&quot;&gt;https://github.com/google/pprof/tree/master/proto#overview&lt;/a&gt;. Passing debug=1 writes the legacy text format with comments translating addresses to function names and line numbers, so that a programmer can read the profile without tools.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bcfadeab38a63378303009891c62ea08d3a9f648" translate="yes" xml:space="preserve">
          <source>The decision can also be forced while building the Go source tree by setting the netgo or netcgo build tag.</source>
          <target state="translated">Решение также может быть принудительно принято при построении дерева исходников Go,установив тег сборки netgo или netcgo.</target>
        </trans-unit>
        <trans-unit id="e55a5ed5aee48109c8f556983bc2b6ba47049c1e" translate="yes" xml:space="preserve">
          <source>The decoded form returned by the Reader's Read method rewrites the &quot;\r\n&quot; line endings into the simpler &quot;\n&quot;, removes leading dot escapes if present, and stops with error io.EOF after consuming (and discarding) the end-of-sequence line.</source>
          <target state="translated">Декодированная форма,возвращаемая методом Reader's Read,переписывает окончания строки &quot;\r\n&quot; в более простую &quot;\n&quot;,удаляет ведущие точечные эскалапы,если они присутствуют,и останавливается с ошибкой io.EOF после потребления (и отбрасывания)строки конца последовательности.</target>
        </trans-unit>
        <trans-unit id="ade9eaf300f62ddbbf2f36e130c2f06e8467d26d" translate="yes" xml:space="preserve">
          <source>The decoder introduces its own buffering and may read data from r beyond the JSON values requested.</source>
          <target state="translated">Декодер вводит собственную буферизацию и может считывать данные с r сверх запрошенных JSON-значений.</target>
        </trans-unit>
        <trans-unit id="500a9025cc154f7f8f86d7b577b23c5a4330caf0" translate="yes" xml:space="preserve">
          <source>The default HTTP/1.x and HTTP/2 ResponseWriter implementations support Flusher, but ResponseWriter wrappers may not. Handlers should always test for this ability at runtime.</source>
          <target state="translated">Реализации ResponseWriter по умолчанию HTTP/1.x и HTTP/2 поддерживают Flusher,но обёртки ResponseWriter могут и не поддерживаться.Обработчики всегда должны проверять эту возможность во время выполнения.</target>
        </trans-unit>
        <trans-unit id="dbfff1190b706ff9c82ad5d939db53ac5e19b8d5" translate="yes" xml:space="preserve">
          <source>The default ResponseWriter for HTTP/1.x connections supports Hijacker, but HTTP/2 connections intentionally do not. ResponseWriter wrappers may also not support Hijacker. Handlers should always test for this ability at runtime.</source>
          <target state="translated">По умолчанию ResponseWriter для соединений HTTP/1.x поддерживает Hijacker,но соединения HTTP/2 намеренно не поддерживают.Обертки ResponseWriter также могут не поддерживать Hijacker.Обработчики всегда должны проверять эту возможность во время выполнения.</target>
        </trans-unit>
        <trans-unit id="29a4bf6e98ccc92440a0810fcad76a8019aec7ff" translate="yes" xml:space="preserve">
          <source>The default behavior is to unlink the socket file only when package net created it. That is, when the listener and the underlying socket file were created by a call to Listen or ListenUnix, then by default closing the listener will remove the socket file. but if the listener was created by a call to FileListener to use an already existing socket file, then by default closing the listener will not remove the socket file.</source>
          <target state="translated">Поведение по умолчанию-развязывать файл сокета только тогда,когда пакетная сеть создала его.То есть,когда слушатель и лежащий в его основе файл сокета были созданы вызовом Listen или ListenUnix,то по умолчанию закрытие слушателя удалит файл сокета.но если слушатель был создан вызовом FileListener для использования уже существующего файла сокета,то по умолчанию закрытие слушателя не удалит файл сокета.</target>
        </trans-unit>
        <trans-unit id="f3bd4ca778e016b570e20fa99bcd057793129198" translate="yes" xml:space="preserve">
          <source>The default format for %v is:</source>
          <target state="translated">Формат по умолчанию для %v:</target>
        </trans-unit>
        <trans-unit id="e5fbfa4bdd17cdbfb6f18b5cea533902d960ee26" translate="yes" xml:space="preserve">
          <source>The default max idle connections is currently 2. This may change in a future release.</source>
          <target state="translated">По умолчанию максимальное количество незадействованных соединений в настоящее время равно 2.Это может измениться в будущем релизе.</target>
        </trans-unit>
        <trans-unit id="385f08ab994be40fdde70d56e38ccb63bb65d078" translate="yes" xml:space="preserve">
          <source>The default set of command-line flags is controlled by top-level functions. The FlagSet type allows one to define independent sets of flags, such as to implement subcommands in a command-line interface. The methods of FlagSet are analogous to the top-level functions for the command-line flag set.</source>
          <target state="translated">Набор флагов командной строки по умолчанию управляется функциями верхнего уровня.Тип FlagSet позволяет определять независимые наборы флагов,например,для реализации подкоманд в интерфейсе командной строки.Методы FlagSet аналогичны функциям верхнего уровня для набора флагов командной строки.</target>
        </trans-unit>
        <trans-unit id="a05d93e44d2bb1f3518c258e77ecac2e52df5b7c" translate="yes" xml:space="preserve">
          <source>The define action names the template being created by providing a string constant. Here is a simple example:</source>
          <target state="translated">Определите имена действий создаваемого шаблона,предоставив строковую константу.Вот простой пример:</target>
        </trans-unit>
        <trans-unit id="1752a2a854e41ac9841751567fab2d2b00d5fd9e" translate="yes" xml:space="preserve">
          <source>The defined file mode bits are the most significant bits of the FileMode. The nine least-significant bits are the standard Unix rwxrwxrwx permissions. The values of these bits should be considered part of the public API and may be used in wire protocols or disk representations: they must not be changed, although new bits might be added.</source>
          <target state="translated">Определенные биты файлового режима являются наиболее значимыми битами FileMode.Девять наименее значимых битов-это стандартные разрешения Unix rwxrwxrwx.Значения этих битов должны рассматриваться как часть публичного API и могут использоваться в протоколах проводов или представлениях диска:их нельзя изменять,хотя могут добавляться новые биты.</target>
        </trans-unit>
        <trans-unit id="5cff7ee8fa31e3f6a6739a2dee232b717a523c6f" translate="yes" xml:space="preserve">
          <source>The delete built-in function deletes the element with the specified key (m[key]) from the map. If m is nil or there is no such element, delete is a no-op.</source>
          <target state="translated">Встроенная функция delete удаляет элемент с указанным ключом (m[key])с карты.Если m равен нулю или такого элемента нет,то delete-нет.</target>
        </trans-unit>
        <trans-unit id="7be6f8c0500d37b62c7237cb3172e8612a1be7ae" translate="yes" xml:space="preserve">
          <source>The dictionary may be nil. If not, its contents should not be modified until the Writer is closed.</source>
          <target state="translated">Словарь может быть нулевым.В противном случае его содержимое не следует изменять до тех пор,пока не будет закрыт словарь.</target>
        </trans-unit>
        <trans-unit id="4b0f9980f9925bb5ac741f7cd28fdb88d41be31b" translate="yes" xml:space="preserve">
          <source>The difference is that &amp;lsquo;image/*&amp;rsquo; embeds &amp;lsquo;image/.tempfile&amp;rsquo; while &amp;lsquo;image&amp;rsquo; does not.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88f694bd36bf5619a0472bfb05ef008949d8b1c4" translate="yes" xml:space="preserve">
          <source>The differences between WalkDirFunc compared to filepath.WalkFunc are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc9a068b7cdbaff9efc9114bb2316dc6eaf9165d" translate="yes" xml:space="preserve">
          <source>The direction of a channel is indicated by one of these constants.</source>
          <target state="translated">Направление канала обозначается одной из этих констант.</target>
        </trans-unit>
        <trans-unit id="46b217ce09d8bd67e6158257fb40490e88a671dd" translate="yes" xml:space="preserve">
          <source>The direction of a channel type is indicated by a bit mask including one or both of the following constants.</source>
          <target state="translated">Направление типа канала обозначается битовой маской,включающей одну или обе следующие константы.</target>
        </trans-unit>
        <trans-unit id="b6be0a4961d7acbc941fa11a19835445036b49c8" translate="yes" xml:space="preserve">
          <source>The directive must immediately precede a line containing the declaration of a single variable. Only blank lines and &amp;lsquo;//&amp;rsquo; line comments are permitted between the directive and the declaration.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eee9b912ab49812886d0cf5f9ad11f8fdfc055f4" translate="yes" xml:space="preserve">
          <source>The directory and file are joined with Join, which may clean the directory name: if Walk is called with the root argument &quot;x/../dir&quot; and finds a file named &quot;a&quot; in that directory, the walk function will be called with argument &quot;dir/a&quot;, not &quot;x/../dir/a&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7dfb11306d6f3241074422bcaa067904172344cc" translate="yes" xml:space="preserve">
          <source>The directory is neither guaranteed to exist nor have accessible permissions.</source>
          <target state="translated">Не гарантируется ни существование,ни наличие прав доступа к каталогу.</target>
        </trans-unit>
        <trans-unit id="565d684eeda7e9edb8f7bb0c103897df1854d973" translate="yes" xml:space="preserve">
          <source>The documentation for http.Request.Write details which fields of req are included in the dump.</source>
          <target state="translated">Документация для http.Request.Write details,какие поля req включены в дамп.</target>
        </trans-unit>
        <trans-unit id="07211f6185f4e6de4337f341c2cdb69d4cc499c7" translate="yes" xml:space="preserve">
          <source>The documentation here focuses on the security features of the package. For information about how to program the templates themselves, see the documentation for text/template.</source>
          <target state="translated">Документация здесь сфокусирована на функциях безопасности пакета.Информацию о том,как запрограммировать сами шаблоны,смотрите в документации к тексту/шаблону.</target>
        </trans-unit>
        <trans-unit id="155a6f0a50ad424a0f77dec85fedb05aad3e6814" translate="yes" xml:space="preserve">
          <source>The driver interface has evolved over time. Drivers should implement Connector and DriverContext interfaces. The Connector.Connect and Driver.Open methods should never return ErrBadConn. ErrBadConn should only be returned from Validator, SessionResetter, or a query method if the connection is already in an invalid (e.g. closed) state.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d608ae58f506a273826ac24fbe8a6e832c7cfa18" translate="yes" xml:space="preserve">
          <source>The earlier index entries are the indices of the embedded fields implicitly traversed to get from (the type of) x to f, starting at embedding depth 0.</source>
          <target state="translated">Ранние записи индекса-это индексы вложенных полей,неявно пройденных для получения от (типа)x до f,начиная с глубины вложения 0.</target>
        </trans-unit>
        <trans-unit id="9969cd1fd12276c81b2d25b52e841cee1f38a6af" translate="yes" xml:space="preserve">
          <source>The earlier index entries are the indices of the embedded struct fields traversed to get to the found entry, starting at depth 0.</source>
          <target state="translated">Ранние записи индекса-это индексы вложенных полей структуры,пройденные для того,чтобы добраться до найденной записи,начиная с глубины 0.</target>
        </trans-unit>
        <trans-unit id="55f7215f8e7a1256ecd44a2e72424fdc36866f77" translate="yes" xml:space="preserve">
          <source>The encoded form is:</source>
          <target state="translated">Кодированная форма:</target>
        </trans-unit>
        <trans-unit id="58738aa6dbb46f39a2d83f07741091a7022a1024" translate="yes" xml:space="preserve">
          <source>The encoding handles 4-byte chunks, using a special encoding for the last fragment, so Encode is not appropriate for use on individual blocks of a large data stream. Use NewEncoder() instead.</source>
          <target state="translated">Кодировка обрабатывает 4-байтовые фрагменты,используя специальную кодировку для последнего фрагмента,поэтому кодировка не подходит для использования на отдельных блоках большого потока данных.Вместо этого используйте NewEncoder().</target>
        </trans-unit>
        <trans-unit id="352cf3ce7f63c6b9e4ef698575b243f2f7eab5f4" translate="yes" xml:space="preserve">
          <source>The encoding of each struct field can be customized by the format string stored under the &quot;json&quot; key in the struct field's tag. The format string gives the name of the field, possibly followed by a comma-separated list of options. The name may be empty in order to specify options without overriding the default field name.</source>
          <target state="translated">Кодировку каждого поля структуры можно настроить по строке формата,хранящейся под ключом &quot;json&quot; в теге поля структуры.Строка форматирования дает имя поля,за которым,возможно,следует разделенный запятыми список опций.Имя может быть пустым,чтобы указать опции без переопределения имени поля по умолчанию.</target>
        </trans-unit>
        <trans-unit id="17b6791f4c87db95fbf5fcc1580f710e0b98bcc7" translate="yes" xml:space="preserve">
          <source>The encoding pads the output to a multiple of 4 bytes, so Encode is not appropriate for use on individual blocks of a large data stream. Use NewEncoder() instead.</source>
          <target state="translated">Кодировочные колодки выводят в несколько 4 байт,поэтому кодировка не подходит для использования на отдельных блоках большого потока данных.Вместо этого используйте NewEncoder().</target>
        </trans-unit>
        <trans-unit id="f9b92d6b313993a8570c418851ae0a82ee1d08b2" translate="yes" xml:space="preserve">
          <source>The encoding pads the output to a multiple of 8 bytes, so Encode is not appropriate for use on individual blocks of a large data stream. Use NewEncoder() instead.</source>
          <target state="translated">Кодировочные колодки выводят в несколько 8 байт,поэтому кодировка не подходит для использования на отдельных блоках большого потока данных.Вместо этого используйте NewEncoder().</target>
        </trans-unit>
        <trans-unit id="f21e6b7ab20b84c2608ae859489552989b9c9ded" translate="yes" xml:space="preserve">
          <source>The entire test file is presented as the example when it contains a single example function, at least one other function, type, variable, or constant declaration, and no test or benchmark functions.</source>
          <target state="translated">Весь тестовый файл представляется в качестве примера,когда он содержит единственную функцию примера,по крайней мере,одну другую функцию,тип,переменную или константное объявление,и никаких тестовых или эталонных функций.</target>
        </trans-unit>
        <trans-unit id="8a5b41cf040dd894c5f5818385e864bb8f5f4256" translate="yes" xml:space="preserve">
          <source>The environment values may be either a complete URL or a &quot;host[:port]&quot;, in which case the &quot;http&quot; scheme is assumed. An error is returned if the value is a different form.</source>
          <target state="translated">Значения окружения могут быть как полным URL,так и &quot;host[:port]&quot;,в этом случае предполагается схема &quot;http&quot;.Возвращается ошибка,если значение имеет другую форму.</target>
        </trans-unit>
        <trans-unit id="118f5185e20d76d2e409557c089e1ce07b52abd5" translate="yes" xml:space="preserve">
          <source>The err argument reports an error related to path, signaling that Walk will not walk into that directory. The function can decide how to handle that error; as described earlier, returning the error will cause Walk to stop walking the entire tree.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="282f6346653700d9616b9fe704e3acbbfd78027c" translate="yes" xml:space="preserve">
          <source>The err argument reports an error related to path, signaling that WalkDir will not walk into that directory. The function can decide how to handle that error; as described earlier, returning the error will cause WalkDir to stop walking the entire tree.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63d88a909a5214b04c717d2600360e2bf8c34633" translate="yes" xml:space="preserve">
          <source>The error built-in interface type is the conventional interface for representing an error condition, with the nil value representing no error.</source>
          <target state="translated">Тип встроенного интерфейса &quot;Ошибка&quot; является обычным интерфейсом для представления состояния ошибки,при этом нулевое значение не означает отсутствие ошибки.</target>
        </trans-unit>
        <trans-unit id="057113f0f11fb7ab423f9c5529d153f0951fafc6" translate="yes" xml:space="preserve">
          <source>The error is EOF only if no bytes were read. If an EOF happens after reading some but not all the bytes, Read returns ErrUnexpectedEOF.</source>
          <target state="translated">Ошибка EOF только в том случае,если не было прочитано ни одного байта.Если EOF происходит после считывания нескольких,но не всех байтов,Read возвращает ErrUnexpectedEOF.</target>
        </trans-unit>
        <trans-unit id="eeed3acdc77455956d53c59d08490cc51e5c519c" translate="yes" xml:space="preserve">
          <source>The error result returned by the function controls how Walk continues. If the function returns the special value SkipDir, Walk skips the current directory (path if info.IsDir() is true, otherwise path's parent directory). Otherwise, if the function returns a non-nil error, Walk stops entirely and returns that error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0bdf1212e16d5b6273e524308d0d3b1c562326fa" translate="yes" xml:space="preserve">
          <source>The error result returned by the function controls how WalkDir continues. If the function returns the special value SkipDir, WalkDir skips the current directory (path if d.IsDir() is true, otherwise path's parent directory). Otherwise, if the function returns a non-nil error, WalkDir stops entirely and returns that error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53b8936240ed1387970343e072546b9e5c4ce38c" translate="yes" xml:space="preserve">
          <source>The errors that ParseComplex returns have concrete type *NumError and include err.Num = s.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e19a9195a1344f79f24fd7f396a97d73332aa946" translate="yes" xml:space="preserve">
          <source>The errors that ParseFloat returns have concrete type *NumError and include err.Num = s.</source>
          <target state="translated">Ошибки,которые возвращает ParseFloat,имеют конкретный тип *NumError и включают в себя err.Num=s.</target>
        </trans-unit>
        <trans-unit id="235cee0ee469905c73061c3ebbf12b0afd87e749" translate="yes" xml:space="preserve">
          <source>The errors that ParseInt returns have concrete type *NumError and include err.Num = s. If s is empty or contains invalid digits, err.Err = ErrSyntax and the returned value is 0; if the value corresponding to s cannot be represented by a signed integer of the given size, err.Err = ErrRange and the returned value is the maximum magnitude integer of the appropriate bitSize and sign.</source>
          <target state="translated">Ошибки,которые ParseInt возвращает,имеют конкретный тип *NumError и включают в себя err.Num=s.Если s пустая или содержит недопустимые цифры,err.Err=ErrSyntax и возвращаемое значение равно 0;если значение,соответствующее s,не может быть представлено знаковым целым числом заданного размера,err.Err=ErrRange и возвращаемое значение является максимальным амплитудным целым числом соответствующего bitSize и знака.</target>
        </trans-unit>
        <trans-unit id="1079b4c215daaeaddfd42a5c24ae40421a24ca31" translate="yes" xml:space="preserve">
          <source>The exact method of division of a binary into separate Objs is an internal detail of the symbol table format.</source>
          <target state="translated">Точным методом разделения двоичного файла на отдельные объекты является внутренняя детализация формата таблицы символов.</target>
        </trans-unit>
        <trans-unit id="704442846624164254cefb0621f909b9f8e7b255" translate="yes" xml:space="preserve">
          <source>The executable example for Time.Format demonstrates the working of the layout string in detail and is a good reference.</source>
          <target state="translated">Исполняемый пример для Time.Format подробно демонстрирует работу строки макета и является хорошей ссылкой.</target>
        </trans-unit>
        <trans-unit id="d1e6774ae13e892b5b495469c8177e657ea29b91" translate="yes" xml:space="preserve">
          <source>The execution trace captures a wide range of execution events such as goroutine creation/blocking/unblocking, syscall enter/exit/block, GC-related events, changes of heap size, processor start/stop, etc. A precise nanosecond-precision timestamp and a stack trace is captured for most events. The generated trace can be interpreted using `go tool trace`.</source>
          <target state="translated">Трасса выполнения фиксирует широкий диапазон событий выполнения,таких как создание/блокировка/разблокировка горутина,системный вход/выход/блок,события,связанные с ГХ,изменение размера кучи,запуск/остановка процессора и т.д.Для большинства событий фиксируются точные временные метки с наносекундной точностью и трасса стека.Сгенерированная трасса может быть интерпретирована с помощью `последней трассы инструмента`.</target>
        </trans-unit>
        <trans-unit id="0bb8da556b82de3d2273cd84d139d0610336a88a" translate="yes" xml:space="preserve">
          <source>The familiar base-setting prefixes 0b (binary), 0o and 0 (octal), and 0x (hexadecimal) are accepted when scanning integers without a format or with the %v verb, as are digit-separating underscores.</source>
          <target state="translated">При сканировании целых чисел без формата или с глаголом %v принимаются знакомые префиксы 0b (двоичный),0o и 0 (восьмеричный)и 0x (шестнадцатеричный),а также подчеркивания,разделенные цифрами.</target>
        </trans-unit>
        <trans-unit id="f9ffee1670410a5e7cd11d5f1bee248ae5a136bc" translate="yes" xml:space="preserve">
          <source>The field semantics differ slightly between client and server usage. In addition to the notes on the fields below, see the documentation for Request.Write and RoundTripper.</source>
          <target state="translated">Семантика поля немного отличается в зависимости от использования клиента и сервера.В дополнение к примечаниям по полям ниже,смотрите документацию к Request.Write и RoundTripper.</target>
        </trans-unit>
        <trans-unit id="055e51145f588ea85435a4c1863b09a1b1141496" translate="yes" xml:space="preserve">
          <source>The file name table of a compilation unit is not fixed. Files returns the file table as of the current position in the line table. This may contain more entries than the file table at an earlier position in the line table, though existing entries never change.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc18f2dd0c8c98e57212ed20f1a2ef2dc2747c6d" translate="yes" xml:space="preserve">
          <source>The file's data can then be read into a slice of bytes. Read and Write take their byte counts from the length of the argument slice.</source>
          <target state="translated">Данные файла затем могут быть прочитаны в кусок байта.При чтении и записи байты берутся из длины ломтика аргумента.</target>
        </trans-unit>
        <trans-unit id="bf3df07f08dd9391973ec022887d04b86f02f1b9" translate="yes" xml:space="preserve">
          <source>The filepath package uses either forward slashes or backslashes, depending on the operating system. To process paths such as URLs that always use forward slashes regardless of the operating system, see the path package.</source>
          <target state="translated">Пакет filepath использует либо прямые косая черта,либо обратные косые черты,в зависимости от операционной системы.Для обработки таких путей,как URL,которые всегда используют прямые косые черты независимо от операционной системы,см.пакет path.</target>
        </trans-unit>
        <trans-unit id="44d9396e877785e7c01e9d43d99cf0cdefb65dc4" translate="yes" xml:space="preserve">
          <source>The files are walked in lexical order, which makes the output deterministic but requires Walk to read an entire directory into memory before proceeding to walk that directory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d47cce3bdf876fa4c8fd7554f61be344c06ff401" translate="yes" xml:space="preserve">
          <source>The files are walked in lexical order, which makes the output deterministic but requires WalkDir to read an entire directory into memory before proceeding to walk that directory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2a5de21556a23ce2ab6268f51afe1d5e198e5ff" translate="yes" xml:space="preserve">
          <source>The finalizer is scheduled to run at some arbitrary time after the program can no longer reach the object to which obj points. There is no guarantee that finalizers will run before a program exits, so typically they are useful only for releasing non-memory resources associated with an object during a long-running program. For example, an os.File object could use a finalizer to close the associated operating system file descriptor when a program discards an os.File without calling Close, but it would be a mistake to depend on a finalizer to flush an in-memory I/O buffer such as a bufio.Writer, because the buffer would not be flushed at program exit.</source>
          <target state="translated">Финализатор планируется запустить в произвольное время после того,как программа уже не сможет добраться до объекта,на который указывает объект.Нет гарантии,что финализаторы будут запущены до выхода программы,поэтому обычно они полезны только для освобождения непамятных ресурсов,связанных с объектом,во время длительной работы программы.Например,объект os.File может использовать финализатор для закрытия файлового дескриптора,связанного с операционной системой,когда программа отбрасывает os.File без вызова Close,но было бы ошибкой полагаться на финализатор для промывки буфера ввода/вывода в памяти,такого как bufio.Writer,потому что буфер не будет смыт при выходе программы.</target>
        </trans-unit>
        <trans-unit id="b1e301ef4e8e6bbc26fb8b640366f5d912e010bd" translate="yes" xml:space="preserve">
          <source>The first call to ReadContinuedLine will return &quot;Line 1 continued...&quot; and the second will return &quot;Line 2&quot;.</source>
          <target state="translated">Первый звонок на ReadContinuedLine вернет &quot;Линия 1 продолжена...&quot;,а второй-&quot;Линия 2&quot;.</target>
        </trans-unit>
        <trans-unit id="aa248e4cf567dddf42fcb3d7320a5fbdd025b032" translate="yes" xml:space="preserve">
          <source>The first call will cache the current user information. Subsequent calls will return the cached value and will not reflect changes to the current user.</source>
          <target state="translated">Первый звонок будет кэшировать текущую информацию о пользователе.Последующие вызовы будут возвращать значение кэширования и не будут отражать изменения текущего пользователя.</target>
        </trans-unit>
        <trans-unit id="da786a1e6a510514415594e5971ba9d3b0ef0c66" translate="yes" xml:space="preserve">
          <source>The first key will be used when creating new tickets, while all keys can be used for decrypting tickets. It is safe to call this function while the server is running in order to rotate the session ticket keys. The function will panic if keys is empty.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9bea105d5515e425130c674b9a6d60024d04428" translate="yes" xml:space="preserve">
          <source>The first step to profiling a Go program is to enable profiling. Support for profiling benchmarks built with the standard testing package is built into go test. For example, the following command runs benchmarks in the current directory and writes the CPU and memory profiles to cpu.prof and mem.prof:</source>
          <target state="translated">Первым шагом к профилированию программы Go является включение профилирования.Поддержка профилирования бенчмарков,встроенная в стандартный пакет тестирования,встроена в go test.Например,следующая команда запускает бенчмарки в текущем каталоге и записывает профили процессора и памяти в cpu.prof и mem.prof:</target>
        </trans-unit>
        <trans-unit id="436dd80ca68673a729fce026c246571c6f61d421" translate="yes" xml:space="preserve">
          <source>The first time the function is called for a particular traceback, all the fields except PC will be 0. The function should fill in the other fields if possible, setting them to 0/nil if the information is not available. The Data field may be used to store any useful information across calls. The More field should be set to non-zero if there is more information for this PC, zero otherwise. If More is set non-zero, the function will be called again with the same PC, and may return different information (this is intended for use with inlined functions). If More is zero, the function will be called with the next PC value in the traceback. When the traceback is complete, the function will be called once more with PC set to zero; this may be used to free any information. Each call will leave the fields of the struct set to the same values they had upon return, except for the PC field when the More field is zero. The function must not keep a copy of the struct pointer between calls.</source>
          <target state="translated">При первом вызове функции для конкретной трассы все поля,кроме ПК,будут равны 0.Функция должна заполнить остальные поля,если это возможно,установив их в 0/ноль,если информация недоступна.Поле Данные может использоваться для хранения любой полезной информации во время вызова.Поле &quot;Больше&quot; должно быть установлено в ненулевое значение,если для данного ПК больше информации,в противном случае-в нулевое.Если поле &quot;Больше&quot; установлено ненулевым значением,то функция будет вызываться снова с того же самого ПК и может возвращать различную информацию (это поле предназначено для использования с инкрементными функциями).Если значение &quot;Больше&quot; равно нулю,функция будет вызвана со следующим значением ПК в трассировке.После завершения обратной связи,функция будет вызвана еще раз с установкой ПК на ноль;это может быть использовано для освобождения любой информации.При каждом вызове будут сохраняться те же значения,что и при возврате,за исключением поля ПК,когда поле More равно нулю.Функция не должна хранить копию указателя структуры между вызовами.</target>
        </trans-unit>
        <trans-unit id="1c12332b1a7f816e653faac5972323a1a86f4075" translate="yes" xml:space="preserve">
          <source>The fmt package's Errorf function lets us use the package's formatting features to create descriptive error messages.</source>
          <target state="translated">Функция Errorf пакета fmt позволяет нам использовать возможности форматирования пакета для создания описательных сообщений об ошибках.</target>
        </trans-unit>
        <trans-unit id="daed29ba07a438b86a35f4ffceadf0ee0b2962c4" translate="yes" xml:space="preserve">
          <source>The following environment variables ($name or %name%, depending on the host operating system) control the run-time behavior of Go programs. The meanings and use may change from release to release.</source>
          <target state="translated">Следующие переменные окружения ($name или %name%,в зависимости от операционной системы хоста)контролируют поведение программ Go во время выполнения.Значения и использование могут меняться от релиза к релизам.</target>
        </trans-unit>
        <trans-unit id="d76a76a5baf9188ebac1a65a2793d054e97d3403" translate="yes" xml:space="preserve">
          <source>The following example shows how to maintain a scalable frequently read, but infrequently updated data structure using copy-on-write idiom.</source>
          <target state="translated">Следующий пример показывает,как поддерживать масштабируемую,часто читаемую,но редко обновляемую структуру данных,используя идиому копирования на запись.</target>
        </trans-unit>
        <trans-unit id="3f0a6fe70878d3ed973c5f4c4f9e11a4b37e3d2a" translate="yes" xml:space="preserve">
          <source>The following example shows how to use Value for periodic program config updates and propagation of the changes to worker goroutines.</source>
          <target state="translated">Следующий пример показывает,как использовать Value для периодического обновления настроек программы и распространения изменений на рабочие горутины.</target>
        </trans-unit>
        <trans-unit id="2cccb14470014df050daea92c16a16fd189e8367" translate="yes" xml:space="preserve">
          <source>The following forms are permitted:</source>
          <target state="translated">Разрешены следующие формы:</target>
        </trans-unit>
        <trans-unit id="f535af253987553534ec7b604b13bea0bafaf89a" translate="yes" xml:space="preserve">
          <source>The following key types are currently supported: *rsa.PrivateKey, *ecdsa.PrivateKey and ed25519.PrivateKey. Unsupported key types result in an error.</source>
          <target state="translated">В настоящее время поддерживаются следующие типы ключей:*rsa.PrivateKey,*ecdsa.PrivateKey и ed25519.PrivateKey.Неподдерживаемые типы ключей приводят к ошибке.</target>
        </trans-unit>
        <trans-unit id="db7a430d5590cf9adf90b727249460131ab84e28" translate="yes" xml:space="preserve">
          <source>The following key types are currently supported: *rsa.PublicKey, *ecdsa.PublicKey and ed25519.PublicKey. Unsupported key types result in an error.</source>
          <target state="translated">В настоящее время поддерживаются следующие типы ключей:*rsa.PublicKey,*ecdsa.PublicKey и ed25519.PublicKey.Неподдерживаемые типы ключей приводят к ошибке.</target>
        </trans-unit>
        <trans-unit id="575dc13df3822635a20233f0d934b2828c4cbcc1" translate="yes" xml:space="preserve">
          <source>The following patterns involving Pointer are valid. Code not using these patterns is likely to be invalid today or to become invalid in the future. Even the valid patterns below come with important caveats.</source>
          <target state="translated">Следующие шаблоны с указателем действительны.Код,не использующий эти шаблоны,скорее всего,будет недействительным сегодня или станет недействительным в будущем.Даже нижеприведенные действительные шаблоны содержат важные предостережения.</target>
        </trans-unit>
        <trans-unit id="ea1b5d42ec809a44272262968add764fd0382aa5" translate="yes" xml:space="preserve">
          <source>The following table captures the capabilities of each format:</source>
          <target state="translated">В следующей таблице представлены возможности каждого формата:</target>
        </trans-unit>
        <trans-unit id="00ec28c9d7b575a36a11e5441e71a7350e3c8790" translate="yes" xml:space="preserve">
          <source>The following tags on struct fields have special meaning to Unmarshal:</source>
          <target state="translated">Следующие теги на полях структуры имеют особое значение для Unmarshal:</target>
        </trans-unit>
        <trans-unit id="b74a12e0ee03ebdd96a1e5698ef65e80645b4c11" translate="yes" xml:space="preserve">
          <source>The format fmt and precision prec have the same meaning as in FormatFloat. It rounds the result assuming that the original was obtained from a complex value of bitSize bits, which must be 64 for complex64 and 128 for complex128.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89924ba6250a79536c8a80bb6ca7f28f4193a60a" translate="yes" xml:space="preserve">
          <source>The format fmt is one of 'b' (-ddddp&amp;plusmn;ddd, a binary exponent), 'e' (-d.dddde&amp;plusmn;dd, a decimal exponent), 'E' (-d.ddddE&amp;plusmn;dd, a decimal exponent), 'f' (-ddd.dddd, no exponent), 'g' ('e' for large exponents, 'f' otherwise), 'G' ('E' for large exponents, 'f' otherwise), 'x' (-0xd.ddddp&amp;plusmn;ddd, a hexadecimal fraction and binary exponent), or 'X' (-0Xd.ddddP&amp;plusmn;ddd, a hexadecimal fraction and binary exponent).</source>
          <target state="translated">Формат fmt может быть одним из 'b' (-ddddp &amp;plusmn; ddd, двоичный показатель степени), 'e' (-d.dddde &amp;plusmn; dd, десятичный показатель степени), 'E' (-d.ddddE &amp;plusmn; dd, десятичный показатель степени ), 'f' (-ddd.dddd, без экспоненты), 'g' ('e' для больших показателей, 'f' в противном случае), 'G' ('E' для больших показателей, 'f' в противном случае), ' x '(-0xd.ddddp &amp;plusmn; ddd, шестнадцатеричная дробь и двоичная экспонента) или' X '(-0Xd.ddddP &amp;plusmn; ddd, шестнадцатеричная дробь и двоичная экспонента).</target>
        </trans-unit>
        <trans-unit id="f76288ef40c91d2e63963863e41869428543cdec" translate="yes" xml:space="preserve">
          <source>The formats 2, _2, and 02 are unpadded, space-padded, and zero-padded day of month. The formats __2 and 002 are space-padded and zero-padded three-character day of year; there is no unpadded day of year format.</source>
          <target state="translated">Форматы 2,_2 и 02 не имеют подложек,имеют подложки из космоса и не имеют подложек из нулевого числа дней месяца.Форматы __2 и 002-трехсимвольный день года с пробелами и без пробела;без пробела формат дня года отсутствует.</target>
        </trans-unit>
        <trans-unit id="1f639fab95b9f7e1b599aa2a265c8aee60d79d31" translate="yes" xml:space="preserve">
          <source>The formfeed character acts like a newline but it also terminates all columns in the current line (effectively calling Flush). Tab- terminated cells in the next line start new columns. Unless found inside an HTML tag or inside an escaped text segment, formfeed characters appear as newlines in the output.</source>
          <target state="translated">Символ подачи формы действует как новая строка,но он также завершает все столбцы в текущей строке (фактически,вызывая Flush).Ячейки в следующей строке,завершенные табуляцией,начинают работу с новыми столбцами.Если символы формальной подачи не найдены внутри HTML-тега или внутри экранированного сегмента текста,они появляются как новые строки в выводе.</target>
        </trans-unit>
        <trans-unit id="6c966e528430f5e8f847d49a893afb0bf98faff4" translate="yes" xml:space="preserve">
          <source>The function is never called with an empty data slice unless atEOF is true. If atEOF is true, however, data may be non-empty and, as always, holds unprocessed text.</source>
          <target state="translated">Функция никогда не вызывается с пустым срезом данных,если только atEOF не является истинным.Однако если atEOF равен true,данные могут быть непустыми и,как всегда,содержать необработанный текст.</target>
        </trans-unit>
        <trans-unit id="bb0e0b68d3018d9e09f97b972052414d315bce69" translate="yes" xml:space="preserve">
          <source>The function may return early (before the entire result is written) and return a formatting error, for instance due to an incorrect AST.</source>
          <target state="translated">Функция может вернуться раньше (до записи всего результата)и вернуть ошибку форматирования,например,из-за некорректного AST.</target>
        </trans-unit>
        <trans-unit id="f82da77fd5615642bd9b732fd9350b4315a5dea8" translate="yes" xml:space="preserve">
          <source>The function panics if the provided interface is not a slice.</source>
          <target state="translated">Функция паникует,если предоставленный интерфейс не является срезом.</target>
        </trans-unit>
        <trans-unit id="4a5f1ee976b1b1f94f517d27ee9603ea7e455c85" translate="yes" xml:space="preserve">
          <source>The function panics if z &amp;lt; 0. The value of z is undefined in that case.</source>
          <target state="translated">Функция вызывает панику, если z &amp;lt;0. В этом случае значение z не определено.</target>
        </trans-unit>
        <trans-unit id="d83c73a08df2f74bc57a61017e163cb8c0547bd2" translate="yes" xml:space="preserve">
          <source>The functions in this package allow a program to change the way Go programs handle signals.</source>
          <target state="translated">Функции в данном пакете позволяют программе изменять способ обработки сигналов Go-программами.</target>
        </trans-unit>
        <trans-unit id="c621ec21270aea7b19125c0f31ddb234d896d492" translate="yes" xml:space="preserve">
          <source>The fundamental interface is called Image. An Image contains colors, which are described in the image/color package.</source>
          <target state="translated">Фундаментальный интерфейс называется Image.Изображение содержит цвета,которые описаны в пакете &quot;изображение/цвет&quot;.</target>
        </trans-unit>
        <trans-unit id="3e95d4d070ede79d500e36cf5c238c24c3001c9d" translate="yes" xml:space="preserve">
          <source>The gc runtime imposes a limit of 64 kB on channel element types. If t's size is equal to or exceeds this limit, ChanOf panics.</source>
          <target state="translated">Время выполнения gc накладывает ограничение в 64 кБ на типы канальных элементов.Если размер t равен или превышает этот лимит,то ChanOf паникует.</target>
        </trans-unit>
        <trans-unit id="0b2d97be3dbe373d310641088f98b283534b1dcf" translate="yes" xml:space="preserve">
          <source>The general form represented is:</source>
          <target state="translated">Представлена общая форма:</target>
        </trans-unit>
        <trans-unit id="e818a1eefc582415dc190e3c644893b44536faa0" translate="yes" xml:space="preserve">
          <source>The gzip file stores a header giving metadata about the compressed file. That header is exposed as the fields of the Writer and Reader structs.</source>
          <target state="translated">В gzip-файле хранится заголовок,содержащий метаданные о сжатом файле.Этот заголовок выставляется в виде полей структур Writer и Reader.</target>
        </trans-unit>
        <trans-unit id="d55115d1e7ac93246c076c18ab9827900516047e" translate="yes" xml:space="preserve">
          <source>The handler is typically nil, in which case the DefaultServeMux is used.</source>
          <target state="translated">Обработчик,как правило,ноль,и в этом случае используется DefaultServeMux.</target>
        </trans-unit>
        <trans-unit id="19708f111db26407005495f3eafb1c4b25430791" translate="yes" xml:space="preserve">
          <source>The handling of spaces and newlines differs from that of C's scanf family: in C, newlines are treated as any other space, and it is never an error when a run of spaces in the format string finds no spaces to consume in the input.</source>
          <target state="translated">Работа с пробелами и новыми строками отличается от работы со строками семейства C scanf:в C новые строки рассматриваются как любые другие пробелы,и это никогда не является ошибкой,когда пробег пробелов в строке формата не находит пробелов,которые нужно использовать во входных данных.</target>
        </trans-unit>
        <trans-unit id="1093dd8291a3801884d5894ab223242420be1682" translate="yes" xml:space="preserve">
          <source>The hash functions are collision-resistant but not cryptographically secure. (See crypto/sha256 and crypto/sha512 for cryptographic use.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9eef6c0a2cccc47289259f60f06bd6983ba13a4d" translate="yes" xml:space="preserve">
          <source>The hash functions are not cryptographically secure. (See crypto/sha256 and crypto/sha512 for cryptographic use.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5be9b697fdd2e64517c87254bb1809a8bac3a286" translate="yes" xml:space="preserve">
          <source>The hash value of a given byte sequence is consistent within a single process, but will be different in different processes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e507edab6e88a1637c49a21b0db27e0ccae398e0" translate="yes" xml:space="preserve">
          <source>The heap dump format is defined at &lt;a href=&quot;https://golang.org/s/go15heapdump&quot;&gt;https://golang.org/s/go15heapdump&lt;/a&gt;.</source>
          <target state="translated">Формат дампа кучи определен на &lt;a href=&quot;https://golang.org/s/go15heapdump&quot;&gt;https://golang.org/s/go15heapdump&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8b009325b4464d415a87b0e6547346de038d0c47" translate="yes" xml:space="preserve">
          <source>The heap profile reports statistics as of the most recently completed garbage collection; it elides more recent allocation to avoid skewing the profile away from live data and toward garbage. If there has been no garbage collection at all, the heap profile reports all known allocations. This exception helps mainly in programs running without garbage collection enabled, usually for debugging purposes.</source>
          <target state="translated">Профиль кучи отражает статистику по последним завершенным сборам мусора;он элиминирует более недавнее распределение,чтобы избежать перекоса профиля в сторону от живых данных и в сторону мусора.Если сбор мусора вообще не проводился,профиль кучи сообщает обо всех известных распределениях.Это исключение помогает в основном в программах,работающих без включенной функции сбора мусора,обычно в целях отладки.</target>
        </trans-unit>
        <trans-unit id="421272feeab82226233835220df71bd5575dfeaf" translate="yes" xml:space="preserve">
          <source>The heap profile tracks both the allocation sites for all live objects in the application memory and for all objects allocated since the program start. Pprof's -inuse_space, -inuse_objects, -alloc_space, and -alloc_objects flags select which to display, defaulting to -inuse_space (live objects, scaled by size).</source>
          <target state="translated">Профиль кучи отслеживает как места выделения всех живых объектов в памяти приложения,так и всех объектов,выделенных с момента запуска программы.Флаги Pprof -inuse_space,-inuse_objects,-alloc_space и -alloc_objects выбирают,какой из них показывать,по умолчанию -inuse_space (живые объекты,масштабируемые по размеру).</target>
        </trans-unit>
        <trans-unit id="9054b52054ed118bba62807238e18c27e8900f1e" translate="yes" xml:space="preserve">
          <source>The http package's Transport and Server both automatically enable HTTP/2 support for simple configurations. To enable HTTP/2 for more complex configurations, to use lower-level HTTP/2 features, or to use a newer version of Go's http2 package, import &quot;golang.org/x/net/http2&quot; directly and use its ConfigureTransport and/or ConfigureServer functions. Manually configuring HTTP/2 via the golang.org/x/net/http2 package takes precedence over the net/http package's built-in HTTP/2 support.</source>
          <target state="translated">Транспорт и сервер пакета http автоматически включают поддержку HTTP/2 для простых конфигураций.Чтобы включить HTTP/2 для более сложных конфигураций,использовать функции HTTP/2 более низкого уровня или использовать более новую версию пакета Go http2,импортируйте &quot;golang.org/x/net/http2&quot; напрямую и используйте его функции ConfigureTransport и/или ConfigureServer.Ручная настройка HTTP/2 через пакет golang.org/x/net/http2 имеет приоритет над встроенной поддержкой HTTP/2 пакета net/http.</target>
        </trans-unit>
        <trans-unit id="7901eb39a7a77a33e17eff2e48d2aac1d7c0d97c" translate="yes" xml:space="preserve">
          <source>The identification of global unicast addresses uses address type identification as defined in RFC 1122, RFC 4632 and RFC 4291 with the exception of IPv4 directed broadcast addresses. It returns true even if ip is in IPv4 private address space or local IPv6 unicast address space.</source>
          <target state="translated">Идентификация глобальных одноадресных адресов использует идентификацию типа адреса,как определено в RFC 1122,RFC 4632 и RFC 4291,за исключением адресов направленного широковещания IPv4.Оно возвращает true,даже если ip находится в IPv4 приватном адресном пространстве или локальном IPv6 одноадресном адресном пространстве.</target>
        </trans-unit>
        <trans-unit id="b257c667cd0c9ffb7ee1c476e193cf63abc04956" translate="yes" xml:space="preserve">
          <source>The imag built-in function returns the imaginary part of the complex number c. The return value will be floating point type corresponding to the type of c.</source>
          <target state="translated">Встроенная функция imag возвращает воображаемую часть комплексного числа c.Возвращаемым значением будет тип с плавающей точкой,соответствующий типу c.</target>
        </trans-unit>
        <trans-unit id="bba6c5ec151d11520ba69091805c64672051a283" translate="yes" xml:space="preserve">
          <source>The implementation compiles a custom codec for each data type in the stream and is most efficient when a single Encoder is used to transmit a stream of values, amortizing the cost of compilation.</source>
          <target state="translated">Реализация компилирует пользовательский кодек для каждого типа данных в потоке и наиболее эффективна,когда для передачи потока значений используется один Кодер,амортизируя затраты на компиляцию.</target>
        </trans-unit>
        <trans-unit id="cc59eb7da6cf17b91e5a422524763e1124d23ad5" translate="yes" xml:space="preserve">
          <source>The implementation fn can assume that the argument Value slice has the number and type of arguments given by typ. If typ describes a variadic function, the final Value is itself a slice representing the variadic arguments, as in the body of a variadic function. The result Value slice returned by fn must have the number and type of results given by typ.</source>
          <target state="translated">Реализация fn может предполагать,что срез Value аргумента имеет количество и тип аргументов,заданных типом.Если тип описывает вариадическую функцию,то конечное значение само по себе является срезом,представляющим вариадические аргументы,как и в теле вариадической функции.Возвращаемый fn ломтик результата Value должен иметь количество и тип результатов,заданных типом.</target>
        </trans-unit>
        <trans-unit id="a41481e84f45a7e3719a2630303073b44edd9b5b" translate="yes" xml:space="preserve">
          <source>The implementation is sufficient for HTTP (RFC 2388) and the multipart bodies generated by popular browsers.</source>
          <target state="translated">Реализации достаточно для HTTP (RFC 2388)и многокомпонентных тел,генерируемых популярными браузерами.</target>
        </trans-unit>
        <trans-unit id="bd36b82add2ec8e45a6f77ef7cf720308cbe3f24" translate="yes" xml:space="preserve">
          <source>The implementation provides filters that uncompress during reading and compress during writing. For example, to write compressed data to a buffer:</source>
          <target state="translated">Реализация предоставляет фильтры,которые сжимаются во время чтения и сжимаются во время записи.Например,для записи сжатых данных в буфер:</target>
        </trans-unit>
        <trans-unit id="624abcf8f99d9c1ecd5f126ae0b1b1d2736d4655" translate="yes" xml:space="preserve">
          <source>The info argument is the fs.FileInfo for the named path.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c05b349b9c7f15622f23c1c3f50e289a6f9207b" translate="yes" xml:space="preserve">
          <source>The input stream consists of basic JSON values&amp;mdash;bool, string, number, and null&amp;mdash;along with delimiters [ ] { } of type Delim to mark the start and end of arrays and objects. Commas and colons are elided.</source>
          <target state="translated">Входной поток состоит из основных значений JSON - bool, string, number и null - вместе с разделителями [] {} типа Delim для обозначения начала и конца массивов и объектов. Запятые и двоеточия опускаются.</target>
        </trans-unit>
        <trans-unit id="12da2b29ce7b4618ed043885dc9bb14fc4b7647d" translate="yes" xml:space="preserve">
          <source>The input text for a template is UTF-8-encoded text in any format. &quot;Actions&quot;--data evaluations or control structures--are delimited by &quot;{{&quot; and &quot;}}&quot;; all text outside actions is copied to the output unchanged. Except for raw strings, actions may not span newlines, although comments can.</source>
          <target state="translated">Входной текст для шаблона-это текст в кодировке UTF-8 в любом формате.&quot;Действия&quot;-оценки данных или структуры управления-делится на &quot;{{&quot; и &quot;}}&quot;;весь текст вне действий копируется в выходной файл без изменений.За исключением необработанных строк,действия могут не перекрывать новые строки,хотя комментарии могут.</target>
        </trans-unit>
        <trans-unit id="4540c375047525b02ad242a07ddc447e593cb543" translate="yes" xml:space="preserve">
          <source>The issuer distinguished name CRL field and authority key identifier extension are populated using the issuer certificate. issuer must have SubjectKeyId set.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ba307a7ab47ab6e6c8f50d8bbcb53f28f406fab" translate="yes" xml:space="preserve">
          <source>The issuer may not be nil, and the crlSign bit must be set in KeyUsage in order to use it as a CRL issuer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0fe0f673e6c94e25d76ca7000237cacb398b340e" translate="yes" xml:space="preserve">
          <source>The key name will be used if it's a non-empty string consisting of only Unicode letters, digits, and ASCII punctuation except quotation marks, backslash, and comma.</source>
          <target state="translated">Имя ключа будет использоваться,если это непустая строка,состоящая только из букв Юникода,цифр и ASCII-знаков препинания,кроме кавычек,обратного слеша и запятой.</target>
        </trans-unit>
        <trans-unit id="56c8d36b799fc9e0b2026b0edca00b49c8b68568" translate="yes" xml:space="preserve">
          <source>The keys should be in canonical form, as returned by CanonicalHeaderKey.</source>
          <target state="translated">Ключи должны быть в канонической форме,как возвращает CanonicalHeaderKey.</target>
        </trans-unit>
        <trans-unit id="aafd41e452c62afe966c7e13f3df11b54dbc58d9" translate="yes" xml:space="preserve">
          <source>The label parameter may contain arbitrary data that will not be encrypted, but which gives important context to the message. For example, if a given public key is used to decrypt two types of messages then distinct label values could be used to ensure that a ciphertext for one purpose cannot be used for another by an attacker. If not required it can be empty.</source>
          <target state="translated">Параметр label может содержать произвольные данные,которые не будут зашифрованы,но которые дают важный контекст сообщения.Например,если заданный открытый ключ используется для расшифровки двух типов сообщений,то можно использовать разные значения меток,чтобы гарантировать,что шифрованный текст для одной цели не может быть использован злоумышленником для другой.Если это не требуется,то он может быть пустым.</target>
        </trans-unit>
        <trans-unit id="8cac55c132cd1a101696d231efd1dd2e57c66e06" translate="yes" xml:space="preserve">
          <source>The label parameter must match the value given when encrypting. See EncryptOAEP for details.</source>
          <target state="translated">Параметр метки должен совпадать со значением,заданным при шифровании.Подробности см.в разделе EncryptOAEP.</target>
        </trans-unit>
        <trans-unit id="1f23b14d8824650d5d93ee806d28aa66402f402a" translate="yes" xml:space="preserve">
          <source>The last index entry is the field or method index in the (possibly embedded) type where the entry was found, either:</source>
          <target state="translated">Последняя запись индекса является также полем или индексом метода в том типе (возможно,встроенном),в котором была найдена запись:</target>
        </trans-unit>
        <trans-unit id="4b9b3d3444da612bde04769b5c20561ed18e861d" translate="yes" xml:space="preserve">
          <source>The legacy Common Name field is ignored unless it's a valid hostname, the certificate doesn't have any Subject Alternative Names, and the GODEBUG environment variable is set to &quot;x509ignoreCN=0&quot;. Support for Common Name is deprecated will be entirely removed in the future.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="feec6e46b5f96d5f768a208b14b5f1c441e6736a" translate="yes" xml:space="preserve">
          <source>The len built-in function returns the length of v, according to its type:</source>
          <target state="translated">Встроенная в объектив функция возвращает длину v,в зависимости от типа:</target>
        </trans-unit>
        <trans-unit id="37c7e993d252a1780b2d17b25f28b15858ed3005" translate="yes" xml:space="preserve">
          <source>The less function must satisfy the same requirements as the Interface type's Less method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67e3ff53cc19034aa94ce5014984a3863b3ceaa2" translate="yes" xml:space="preserve">
          <source>The limit controls the number of operating system threads, not the number of goroutines. A Go program creates a new thread only when a goroutine is ready to run but all the existing threads are blocked in system calls, cgo calls, or are locked to other goroutines due to use of runtime.LockOSThread.</source>
          <target state="translated">Предел регулирует количество резьбовых соединений операционной системы,а не количество гортаней.Программа Go создает новый поток только тогда,когда горутин готов к запуску,но все существующие потоки заблокированы в системных вызовах,вызовах cgo,или заблокированы для других горутинов в связи с использованием runtime.LockOSThread.</target>
        </trans-unit>
        <trans-unit id="b7d62826dea7a7db650a9558cf682cb6d6d5b0e1" translate="yes" xml:space="preserve">
          <source>The list is sorted by ID. Note that the default cipher suites selected by this package might depend on logic that can't be captured by a static list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61b31a135931a0a96f45c468dd4c1356b142f056" translate="yes" xml:space="preserve">
          <source>The list of possible Object kinds.</source>
          <target state="translated">Список возможных видов Объектов.</target>
        </trans-unit>
        <trans-unit id="f82cdeb26140d2ac8d4f27048ef361e35bc34e51" translate="yes" xml:space="preserve">
          <source>The list of tokens.</source>
          <target state="translated">Список жетонов.</target>
        </trans-unit>
        <trans-unit id="744b107073d50b7c5d979152623baf7c98836ce1" translate="yes" xml:space="preserve">
          <source>The load and store operations, implemented by the LoadT and StoreT functions, are the atomic equivalents of &quot;return *addr&quot; and &quot;*addr = val&quot;.</source>
          <target state="translated">Операции загрузки и хранения,реализованные функциями LoadT и StoreT,являются атомными эквивалентами &quot;return *addr&quot; и &quot;*addr=val&quot;.</target>
        </trans-unit>
        <trans-unit id="d80346c4a6d83f0a2408ae318740b75196640a27" translate="yes" xml:space="preserve">
          <source>The lookup function is called each time the resulting importer needs to resolve an import path. In this mode the importer can only be invoked with canonical import paths (not relative or absolute ones); it is assumed that the translation to canonical import paths is being done by the client of the importer.</source>
          <target state="translated">Функция поиска вызывается каждый раз,когда результирующему импортеру необходимо разрешить путь импорта.В этом режиме импортер может быть вызван только с каноническими путями импорта (не относительными или абсолютными);предполагается,что преобразование в канонические пути импорта осуществляется клиентом импортера.</target>
        </trans-unit>
        <trans-unit id="d42ee39ba69d607990bf6285f526cdb4d05cd8c5" translate="yes" xml:space="preserve">
          <source>The low bit is therefore analogous to a sign bit, but making it the complement bit instead guarantees that the largest negative integer is not a special case. For example, -129=^128=(^256&amp;gt;&amp;gt;1) encodes as (FE 01 01).</source>
          <target state="translated">Поэтому младший бит аналогичен знаковому биту, но вместо этого превращение его в бит дополнения гарантирует, что наибольшее отрицательное целое число не является особым случаем. Например, -129 = ^ 128 = (^ 256 &amp;gt;&amp;gt; 1) кодируется как (FE 01 01).</target>
        </trans-unit>
        <trans-unit id="e23983031d30e849dd601f8a9a147a11b178b7e1" translate="yes" xml:space="preserve">
          <source>The main use case is finding resources located relative to an executable.</source>
          <target state="translated">Основным случаем использования является нахождение ресурсов,расположенных относительно исполняемого файла.</target>
        </trans-unit>
        <trans-unit id="ae651dd57d8aac89d2244b121832135b42a78e22" translate="yes" xml:space="preserve">
          <source>The make built-in function allocates and initializes an object of type slice, map, or chan (only). Like new, the first argument is a type, not a value. Unlike new, make's return type is the same as the type of its argument, not a pointer to it. The specification of the result depends on the type:</source>
          <target state="translated">Встроенная функция make выделяет и инициализирует объект типа срез,карту или чан (только).Как и новый,первый аргумент-тип,а не значение.В отличие от new,возвращаемый тип make тот же,что и тип его аргумента,а не указатель на него.Спецификация результата зависит от типа:</target>
        </trans-unit>
        <trans-unit id="38a5e445a42e339cecb3a2e57e70485eff805e93" translate="yes" xml:space="preserve">
          <source>The map need not include parent directories for files contained in the map; those will be synthesized if needed. But a directory can still be included by setting the MapFile.Mode's ModeDir bit; this may be necessary for detailed control over the directory's FileInfo or to create an empty directory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad15554627caa64494fe09878e570067f5641170" translate="yes" xml:space="preserve">
          <source>The meaning of the parameters fset, pkg, and pos is the same as in CheckExpr. An error is returned if expr cannot be parsed successfully, or the resulting expr AST cannot be type-checked.</source>
          <target state="translated">Значение параметров fset,pkg и pos такое же,как и в CheckExpr.Ошибка возвращается,если expr не может быть успешно обработан,или полученный expr AST не может быть проверен на тип.</target>
        </trans-unit>
        <trans-unit id="76f7a0e267f75e03932754601186fb88901bc244" translate="yes" xml:space="preserve">
          <source>The message must be no longer than the length of the public modulus minus twice the hash length, minus a further 2.</source>
          <target state="translated">Сообщение не должно быть больше длины публичного модуля минус в два раза больше длины хэша,минус еще 2.</target>
        </trans-unit>
        <trans-unit id="f50438ca0e284cc49442d4b96ed8422098542b37" translate="yes" xml:space="preserve">
          <source>The method for resolving domain names, whether indirectly with functions like Dial or directly with functions like LookupHost and LookupAddr, varies by operating system.</source>
          <target state="translated">Метод разрешения доменных имен,будь то косвенно с такими функциями,как Dial или непосредственно с такими функциями,как LookupHost и LookupAddr,варьируется в зависимости от операционной системы.</target>
        </trans-unit>
        <trans-unit id="fd8e3459dc1d93b8b2959d9f7ce9e888fe72a14d" translate="yes" xml:space="preserve">
          <source>The method's first argument represents the arguments provided by the caller; the second argument represents the result parameters to be returned to the caller. The method's return value, if non-nil, is passed back as a string that the client sees as if created by errors.New. If an error is returned, the reply parameter will not be sent back to the client.</source>
          <target state="translated">Первый аргумент метода представляет аргументы,предоставленные вызывающим абонентом;второй аргумент представляет параметры результата,которые должны быть возвращены вызывающему абоненту.Возвращаемое методом значение,если оно не равно нулю,передается обратно в виде строки,которую клиент видит как созданную по ошибке.New.Если возвращается ошибка,то ответный параметр не будет возвращен клиенту.</target>
        </trans-unit>
        <trans-unit id="eebd4cc8d1b396bccc721d19c4bd56800d60e192" translate="yes" xml:space="preserve">
          <source>The methods should behave the same as those on an *os.File.</source>
          <target state="translated">Методы должны вести себя так же,как и в *os.File.</target>
        </trans-unit>
        <trans-unit id="3351c33da5b9bc73dd81d983421271485dd91e09" translate="yes" xml:space="preserve">
          <source>The minimal source code for a binary-only package was therefore:</source>
          <target state="translated">Таким образом,минимальный исходный код для пакета только с двоичным кодом был:</target>
        </trans-unit>
        <trans-unit id="ba0d7c85cb07c29f22bceee0e488a79cf0a2c300" translate="yes" xml:space="preserve">
          <source>The minimum element in the tree is the root, at index 0.</source>
          <target state="translated">Минимальным элементом дерева является корень,с индексом 0.</target>
        </trans-unit>
        <trans-unit id="6cf2c8c68bd743b1d5a4e29ae7301dad5d49bcb2" translate="yes" xml:space="preserve">
          <source>The mode parameter controls the amount of source text parsed and other optional parser functionality. Position information is recorded in the file set fset, which must not be nil.</source>
          <target state="translated">Параметр mode (Режим)управляет количеством разобранного исходного текста и другими дополнительными функциями парсера.Информация о положении записывается в файл набора fset,который не должен быть нулевым.</target>
        </trans-unit>
        <trans-unit id="7d1773f39818c5825c59e48b1236b92119b0b32e" translate="yes" xml:space="preserve">
          <source>The month, day, hour, min, sec, and nsec values may be outside their usual ranges and will be normalized during the conversion. For example, October 32 converts to November 1.</source>
          <target state="translated">Значения месяца,дня,часа,минуты,секунды и nsec могут выходить за пределы их обычных диапазонов и будут нормализованы во время конвертации.Например,32 октября конвертируется на 1 ноября.</target>
        </trans-unit>
        <trans-unit id="a5541e290e27715c3d35b2115cad871f3ab99ccb" translate="yes" xml:space="preserve">
          <source>The most common numeric conversions are Atoi (string to int) and Itoa (int to string).</source>
          <target state="translated">Наиболее распространенными числовыми преобразованиями являются Atoi (строка в int)и Itoa (строка в int).</target>
        </trans-unit>
        <trans-unit id="4bbbacdbad6d2c99ac68260aad07ecb869838903" translate="yes" xml:space="preserve">
          <source>The most common use of this pattern is to access fields in a struct or elements of an array:</source>
          <target state="translated">Наиболее часто этот шаблон используется для доступа к полям в структуре или элементам массива:</target>
        </trans-unit>
        <trans-unit id="ac8cc81db3fc49af2479176c9231b929d55cdbd8" translate="yes" xml:space="preserve">
          <source>The msg parameter should be an RFC 822-style email with headers first, a blank line, and then the message body. The lines of msg should be CRLF terminated. The msg headers should usually include fields such as &quot;From&quot;, &quot;To&quot;, &quot;Subject&quot;, and &quot;Cc&quot;. Sending &quot;Bcc&quot; messages is accomplished by including an email address in the to parameter but not including it in the msg headers.</source>
          <target state="translated">Параметром msg должно быть письмо в стиле RFC 822 с заголовками,сначала пустая строка,а затем тело сообщения.Строки msg должны быть завершены CRLF.Заголовки msg обычно должны включать такие поля,как &quot;From&quot;,&quot;To&quot;,&quot;Subject&quot; и &quot;Cc&quot;.Отправка сообщений &quot;Bcc&quot; осуществляется путем включения адреса электронной почты в параметр &quot;to&quot;,но не включения его в заголовки msg.</target>
        </trans-unit>
        <trans-unit id="410aa7b0a0304575a8915750342dc577b832f74c" translate="yes" xml:space="preserve">
          <source>The name for the XML elements is taken from, in order of preference:</source>
          <target state="translated">Имя для элементов XML берется в порядке предпочтительности:</target>
        </trans-unit>
        <trans-unit id="57b088fc8d39478c2345773281e5eb271805f7ea" translate="yes" xml:space="preserve">
          <source>The naming convention to declare examples for the package, a function F, a type T and method M on type T are:</source>
          <target state="translated">Свод правил именования для объявления примеров для пакета,функции F,типа T и метода M для типа T:</target>
        </trans-unit>
        <trans-unit id="7b9b492a2e0fbf406f8b8d17e034f78a30b6eb8c" translate="yes" xml:space="preserve">
          <source>The net, net/http, and crypto/tls packages also refer to debugging variables in GODEBUG. See the documentation for those packages for details.</source>
          <target state="translated">Пакеты net,net/http и crypto/tls также относятся к отладочным переменным в GODEBUG.Подробности см.в документации к этим пакетам.</target>
        </trans-unit>
        <trans-unit id="69954652d3ee14598bd31e60017ff5be6ec75582" translate="yes" xml:space="preserve">
          <source>The net/http/cookiejar package provides a CookieJar implementation.</source>
          <target state="translated">Пакет net/http/cookiejar обеспечивает реализацию CookieJar.</target>
        </trans-unit>
        <trans-unit id="7815d9693c2e8fba3de7740f99dda917ebde80d7" translate="yes" xml:space="preserve">
          <source>The net/rpc package is frozen and is not accepting new features.</source>
          <target state="translated">Пакет net/rpc заморожен и не принимает новых функций.</target>
        </trans-unit>
        <trans-unit id="b67ec9dd23234843cefc446704be9276e0333344" translate="yes" xml:space="preserve">
          <source>The network must be &quot;tcp&quot;, &quot;tcp4&quot;, &quot;tcp6&quot;, &quot;unix&quot; or &quot;unixpacket&quot;.</source>
          <target state="translated">Сеть должна быть &quot;tcp&quot;,&quot;tcp4&quot;,&quot;tcp6&quot;,&quot;unix&quot; или &quot;unixpacket&quot;.</target>
        </trans-unit>
        <trans-unit id="f78c2675c0a1b78facf549c913ce29c8786aed4f" translate="yes" xml:space="preserve">
          <source>The network must be &quot;udp&quot;, &quot;udp4&quot;, &quot;udp6&quot;, &quot;unixgram&quot;, or an IP transport. The IP transports are &quot;ip&quot;, &quot;ip4&quot;, or &quot;ip6&quot; followed by a colon and a literal protocol number or a protocol name, as in &quot;ip:1&quot; or &quot;ip:icmp&quot;.</source>
          <target state="translated">Сеть должна быть &quot;udp&quot;,&quot;udp4&quot;,&quot;udp6&quot;,&quot;unixgram&quot; или IP-транспортом.IP-транспортами являются &quot;ip&quot;,&quot;ip4&quot; или &quot;ip6&quot;,за которыми следует двоеточие и буквальный номер протокола или имя протокола,как в &quot;ip:1&quot; или &quot;ip:icmp&quot;.</target>
        </trans-unit>
        <trans-unit id="f62f0c6bf3637b6bd91fbed73590e0c5ec059d67" translate="yes" xml:space="preserve">
          <source>The network must be &quot;unix&quot; or &quot;unixpacket&quot;.</source>
          <target state="translated">Сеть должна быть &quot;unix&quot; или &quot;unixpacket&quot;.</target>
        </trans-unit>
        <trans-unit id="961ea2a9664370be05fda243ace29bf62f0b8b14" translate="yes" xml:space="preserve">
          <source>The network must be &quot;unixgram&quot;.</source>
          <target state="translated">Сеть должна быть &quot;unixgram&quot;.</target>
        </trans-unit>
        <trans-unit id="143c1ec61594ea23a84fdfc668726a693ff1d059" translate="yes" xml:space="preserve">
          <source>The network must be a TCP network name.</source>
          <target state="translated">Сеть должна быть именем сети TCP.</target>
        </trans-unit>
        <trans-unit id="54bb9136f9b37f7468411dbae5b647c63059a3a1" translate="yes" xml:space="preserve">
          <source>The network must be a TCP network name; see func Dial for details.</source>
          <target state="translated">Сеть должна быть именем сети TCP;подробности смотрите в разделе Функция Dial.</target>
        </trans-unit>
        <trans-unit id="a35132d711d8945bdb8b272ee67848e4c94a5a16" translate="yes" xml:space="preserve">
          <source>The network must be a UDP network name.</source>
          <target state="translated">Сеть должна иметь имя UDP сети.</target>
        </trans-unit>
        <trans-unit id="89ed96066a0fbc9b6b82696daa8ba7effb94e0a8" translate="yes" xml:space="preserve">
          <source>The network must be a UDP network name; see func Dial for details.</source>
          <target state="translated">Сеть должна быть именем UDP сети;подробности смотрите в разделе Функция Dial.</target>
        </trans-unit>
        <trans-unit id="199d17e2fe63f354db9a6b916c396629d6b88dda" translate="yes" xml:space="preserve">
          <source>The network must be a Unix network name.</source>
          <target state="translated">Сеть должна быть именем сети Unix.</target>
        </trans-unit>
        <trans-unit id="b6cf9d29e750ed948316e5ba40edb44e452845b1" translate="yes" xml:space="preserve">
          <source>The network must be a Unix network name; see func Dial for details.</source>
          <target state="translated">Сеть должна быть сетевым именем Unix;подробности смотрите в функционале Dial.</target>
        </trans-unit>
        <trans-unit id="61f5a2270318ecc8414142178aaa1a53165f97e7" translate="yes" xml:space="preserve">
          <source>The network must be an IP network name.</source>
          <target state="translated">Сеть должна быть именем IP-сети.</target>
        </trans-unit>
        <trans-unit id="b881d6aafa14d5f635aad510160f9473031ecf6f" translate="yes" xml:space="preserve">
          <source>The network must be an IP network name; see func Dial for details.</source>
          <target state="translated">Сеть должна быть именем IP сети;подробности смотрите в разделе Функция Дозвон.</target>
        </trans-unit>
        <trans-unit id="882441c96cbf8f9716ac8a79d3a5eb4e3af0bcfd" translate="yes" xml:space="preserve">
          <source>The new Handler calls h.ServeHTTP to handle each request, but if a call runs for longer than its time limit, the handler responds with a 503 Service Unavailable error and the given message in its body. (If msg is empty, a suitable default message will be sent.) After such a timeout, writes by h to its ResponseWriter will return ErrHandlerTimeout.</source>
          <target state="translated">Новый обработчик вызывает h.ServeHTTP для обработки каждого запроса,но если вызов выполняется дольше установленного срока,обработчик отвечает ошибкой 503 Service Unavailable и выданным сообщением в его теле.(Если msg пустое,то будет отправлено соответствующее сообщение по умолчанию.)По истечении такого таймаута,запись by h в его ResponseWriter вернет ErrHandlerTimeout.</target>
        </trans-unit>
        <trans-unit id="3cf0c81686ac1acb508bf9e67780a55cee7159d9" translate="yes" xml:space="preserve">
          <source>The new built-in function allocates memory. The first argument is a type, not a value, and the value returned is a pointer to a newly allocated zero value of that type.</source>
          <target state="translated">Новая встроенная функция выделяет память.Первый аргумент-тип,а не значение,а возвращаемое значение-указатель на вновь выделенное нулевое значение этого типа.</target>
        </trans-unit>
        <trans-unit id="902360dabebdea5b3a521c7b72fed85e30d4437d" translate="yes" xml:space="preserve">
          <source>The node type must be *ast.File, *printer.CommentedNode, []ast.Decl, []ast.Stmt, or assignment-compatible to ast.Expr, ast.Decl, ast.Spec, or ast.Stmt. Node does not modify node. Imports are not sorted for nodes representing partial source files (for instance, if the node is not an *ast.File or a *printer.CommentedNode not wrapping an *ast.File).</source>
          <target state="translated">Тип узла должен быть *ast.File,*printer.CommentedNode,[]ast.Decl,[]ast.Stmt,или соответствовать назначениям ast.Expr,ast.Decl,ast.Spec,или ast.Stmt.Узел не изменяет узел.Импорт не сортируется для узлов,представляющих частичные исходные файлы (например,если узел не является *ast.File или *printer.CommentedNode не обертывает *ast.File).</target>
        </trans-unit>
        <trans-unit id="56cff2c7a026fcff6621abd1c298d8e39f80b3ef" translate="yes" xml:space="preserve">
          <source>The non-Go code should not change the signal mask on any threads created by the Go runtime. If the non-Go code starts new threads of its own, it may set the signal mask as it pleases.</source>
          <target state="translated">Код,отличный от Go,не должен изменять маску сигнала ни на одном потоке,создаваемом во время выполнения Go.Если не-Go код запускает новые потоки самостоятельно,он может установить сигнальную маску по своему усмотрению.</target>
        </trans-unit>
        <trans-unit id="67289d2a1e8eb416b3a82eb9f3e75a285c0158f6" translate="yes" xml:space="preserve">
          <source>The number represented by s must be of the form N, Ni, or N&amp;plusmn;Ni, where N stands for a floating-point number as recognized by ParseFloat, and i is the imaginary component. If the second N is unsigned, a + sign is required between the two components as indicated by the &amp;plusmn;. If the second N is NaN, only a + sign is accepted. The form may be parenthesized and cannot contain any spaces. The resulting complex number consists of the two components converted by ParseFloat.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ca31cdbe931eb86d33c507cac75f440d062f995" translate="yes" xml:space="preserve">
          <source>The ok result is false if the -timeout flag indicates &amp;ldquo;no timeout&amp;rdquo; (0).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b32a27700c08984e10653750973205a0166116d3" translate="yes" xml:space="preserve">
          <source>The only signal values guaranteed to be present in the os package on all systems are os.Interrupt (send the process an interrupt) and os.Kill (force the process to exit). On Windows, sending os.Interrupt to a process with os.Process.Signal is not implemented; it will return an error instead of sending a signal.</source>
          <target state="translated">Единственные значения сигналов,которые гарантированно присутствуют в пакете os на всех системах-os.Interrupt (отправить процесс на прерывание)и os.Kill (заставить процесс выйти).В Windows отправка os.Interrupt для процесса с os.Process.Signal не реализована;вместо отправки сигнала она возвращает ошибку.</target>
        </trans-unit>
        <trans-unit id="ff422009eedfd53fa7602cbdd94de8292f5f25ce" translate="yes" xml:space="preserve">
          <source>The original specification for encryption and signatures with RSA is PKCS #1 and the terms &quot;RSA encryption&quot; and &quot;RSA signatures&quot; by default refer to PKCS #1 version 1.5. However, that specification has flaws and new designs should use version 2, usually called by just OAEP and PSS, where possible.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c37b0a4e6fab650a215cbd5edb17eee82ff53db" translate="yes" xml:space="preserve">
          <source>The original specification for encryption and signatures with RSA is PKCS#1 and the terms &quot;RSA encryption&quot; and &quot;RSA signatures&quot; by default refer to PKCS#1 version 1.5. However, that specification has flaws and new designs should use version two, usually called by just OAEP and PSS, where possible.</source>
          <target state="translated">Оригинальной спецификацией шифрования и подписей с RSA является PKCS#1,а термины &quot;шифрование RSA&quot; и &quot;подписи RSA&quot; по умолчанию относятся к PKCS#1 версии 1.5.Однако эта спецификация имеет недостатки,и новые конструкции должны использовать версию 2,обычно называемую просто OAEP и PSS,где это возможно.</target>
        </trans-unit>
        <trans-unit id="540d9d25cf4179e22c8285de7096ab16e1c12b86" translate="yes" xml:space="preserve">
          <source>The original tar format was introduced in Unix V7. Since then, there have been multiple competing formats attempting to standardize or extend the V7 format to overcome its limitations. The most common formats are the USTAR, PAX, and GNU formats, each with their own advantages and limitations.</source>
          <target state="translated">Оригинальный формат tar был представлен в Unix V7.С тех пор существует множество конкурирующих форматов,пытающихся стандартизировать или расширить формат V7,чтобы преодолеть его ограничения.Наиболее распространенными форматами являются USTAR,PAX и GNU,каждый из которых имеет свои преимущества и ограничения.</target>
        </trans-unit>
        <trans-unit id="447ae61382377495d9bb3dcbc7167cc095d3d833" translate="yes" xml:space="preserve">
          <source>The os interface is intended to be uniform across all operating systems. Features not generally available appear in the system-specific package syscall.</source>
          <target state="translated">Интерфейс os предназначен для унификации всех операционных систем.Характеристики,недоступные в системном пакете syscall.</target>
        </trans-unit>
        <trans-unit id="826c8f633f039e53ad0aac6dce5e00961c47baef" translate="yes" xml:space="preserve">
          <source>The other reporting methods, such as the variations of Log and Error, may be called simultaneously from multiple goroutines.</source>
          <target state="translated">Другие методы отчетности,такие как вариации Log и Error,могут быть вызваны одновременно из нескольких goroutines.</target>
        </trans-unit>
        <trans-unit id="314818cec484a0a4f79c6a3bd12ea1e65d6a5497" translate="yes" xml:space="preserve">
          <source>The output of a command will be either one value or two values, the second of which has type error. If that second value is present and evaluates to non-nil, execution terminates and the error is returned to the caller of Execute.</source>
          <target state="translated">Выводом команды будет либо одно значение,либо два,второе из которых имеет ошибку типа.Если это второе значение присутствует и оценивается как ненулевое,выполнение команды прекращается и ошибка возвращается вызывающему абоненту Execute.</target>
        </trans-unit>
        <trans-unit id="8552b51b4b43726af9d21d2953952aab9f9eccb4" translate="yes" xml:space="preserve">
          <source>The package also exports a handler that serves execution trace data for the &quot;go tool trace&quot; command. To collect a 5-second execution trace:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01b79b49ed9f5aef9d64418cf5de61a045616033" translate="yes" xml:space="preserve">
          <source>The package also runs and verifies example code. Example functions may include a concluding line comment that begins with &quot;Output:&quot; and is compared with the standard output of the function when the tests are run. (The comparison ignores leading and trailing space.) These are examples of an example:</source>
          <target state="translated">Пакет также запускает и проверяет примерный код.Примеры функций могут содержать комментарий к заключительной строке,которая начинается с &quot;Output:&quot; и сравнивается со стандартным выводом функции при выполнении тестов.(При сравнении игнорируется ведущее и трейлинговое пространство.)Это примеры:</target>
        </trans-unit>
        <trans-unit id="a842fba56dd27e8e683543ed1da0bb8ec8237f57" translate="yes" xml:space="preserve">
          <source>The package is marked as complete if no errors occurred, otherwise it is incomplete. See Config.Error for controlling behavior in the presence of errors.</source>
          <target state="translated">Пакет помечается как полный,если не возникло ошибок,в противном случае он является неполным.См.раздел Config.Error для контроля поведения при наличии ошибок.</target>
        </trans-unit>
        <trans-unit id="084533be70387d373858b81e63ee3fdbb938556c" translate="yes" xml:space="preserve">
          <source>The package is sometimes only imported for the side effect of registering its HTTP handler and the above variables. To use it this way, link this package into your program:</source>
          <target state="translated">Иногда пакет импортируется только для побочного эффекта регистрации его HTTP обработчика и вышеперечисленных переменных.Чтобы использовать его таким образом,свяжите данный пакет с вашей программой:</target>
        </trans-unit>
        <trans-unit id="a76fef8dda549c1a3db0f0948e9255bd119d522e" translate="yes" xml:space="preserve">
          <source>The package is specified by a list of *ast.Files and corresponding file set, and the package path the package is identified with. The clean path must not be empty or dot (&quot;.&quot;).</source>
          <target state="translated">Пакет определяется списком *ast.Files и соответствующим набором файлов,а также путём к пакету,по которому он идентифицируется.Чистый путь не должен быть пустым или точечным (&quot;.&quot;).</target>
        </trans-unit>
        <trans-unit id="385716c34a6382063c2f2e6bebfaff89eee0a50e" translate="yes" xml:space="preserve">
          <source>The package is specified by a list of *ast.Files and corresponding file set, which must not be nil. NewFromFiles uses all provided files when computing documentation, so it is the caller's responsibility to provide only the files that match the desired build context. &quot;go/build&quot;.Context.MatchFile can be used for determining whether a file matches a build context with the desired GOOS and GOARCH values, and other build constraints. The import path of the package is specified by importPath.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="399fd3ad30378409e2dc4bdf013d129681dab5d4" translate="yes" xml:space="preserve">
          <source>The package is typically only imported for the side effect of registering its HTTP handlers. The handled paths all begin with /debug/pprof/.</source>
          <target state="translated">Обычно пакет импортируется только для побочного эффекта регистрации его HTTP обработчиков.Все обрабатываемые пути начинаются с /debug/pprof/.</target>
        </trans-unit>
        <trans-unit id="1435a203fd8b96db3ad7b17b180e6f206d92f47b" translate="yes" xml:space="preserve">
          <source>The package is using the Elastic Tabstops algorithm described at &lt;a href=&quot;http://nickgravgaard.com/elastictabstops/index.html&quot;&gt;http://nickgravgaard.com/elastictabstops/index.html&lt;/a&gt;.</source>
          <target state="translated">Пакет использует алгоритм Elastic Tabstops, описанный на &lt;a href=&quot;http://nickgravgaard.com/elastictabstops/index.html&quot;&gt;http://nickgravgaard.com/elastictabstops/index.html&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2d8c628767f33f2351dada491bfefd34f51b3140" translate="yes" xml:space="preserve">
          <source>The package provides:</source>
          <target state="translated">Пакет предоставляет:</target>
        </trans-unit>
        <trans-unit id="fdd304cc0ffa560e98ef7d6ccf98bb51070237a4" translate="yes" xml:space="preserve">
          <source>The packages golang.org/x/net/ipv4 and golang.org/x/net/ipv6 can be used to manipulate IP-level socket options in oob.</source>
          <target state="translated">Пакеты golang.org/x/net/ipv4 и golang.org/x/net/ipv6 могут использоваться для управления опциями сокетов IP-уровня в oob.</target>
        </trans-unit>
        <trans-unit id="e31e979e3edc39254b9a5c52d82e5a30deadc675" translate="yes" xml:space="preserve">
          <source>The panic built-in function stops normal execution of the current goroutine. When a function F calls panic, normal execution of F stops immediately. Any functions whose execution was deferred by F are run in the usual way, and then F returns to its caller. To the caller G, the invocation of F then behaves like a call to panic, terminating G's execution and running any deferred functions. This continues until all functions in the executing goroutine have stopped, in reverse order. At that point, the program is terminated with a non-zero exit code. This termination sequence is called panicking and can be controlled by the built-in function recover.</source>
          <target state="translated">Встроенная функция паники останавливает нормальное выполнение текущего гортани.Когда функция F вызывает панику,нормальное выполнение F останавливается немедленно.Любые функции,выполнение которых было отложено F,выполняются обычным образом,после чего F возвращается к своему вызывающему абоненту.Затем вызов F вызывает вызывающего абонента G,который ведет себя как вызов паники,прерывая выполнение G и выполняя любые отложенные функции.Это продолжается до тех пор,пока все функции исполняющего горутина не остановятся в обратном порядке.В этот момент программа завершается ненулевым кодом выхода.Эта последовательность завершения называется паникерской и может управляться встроенной функцией восстановления.</target>
        </trans-unit>
        <trans-unit id="af4f035528815b22e373ca233969d1eeb80da9ab" translate="yes" xml:space="preserve">
          <source>The parse functions return the widest type (float64, int64, and uint64), but if the size argument specifies a narrower width the result can be converted to that narrower type without data loss:</source>
          <target state="translated">Функции разбора возвращают самый широкий тип (float64,int64,uint64),но если аргумент size указывает более узкую ширину,то результат может быть приведен к этому более узкому типу без потери данных:</target>
        </trans-unit>
        <trans-unit id="a18efb4bf749b7c5acc3a4bfaddc4a2e6898762f" translate="yes" xml:space="preserve">
          <source>The parser accepts a larger language than is syntactically permitted by the Go spec, for simplicity, and for improved robustness in the presence of syntax errors. For instance, in method declarations, the receiver is treated like an ordinary parameter list and thus may contain multiple entries where the spec permits exactly one. Consequently, the corresponding field in the AST (ast.FuncDecl.Recv) field is not restricted to one entry.</source>
          <target state="translated">Парсер принимает более крупный язык,чем синтаксически разрешенный Go spec,за простоту и улучшенную робастность при наличии синтаксических ошибок.Например,в объявлениях методов приемник рассматривается как обычный список параметров и,таким образом,может содержать несколько записей,где спецификация разрешает именно одну.Следовательно,соответствующее поле в поле AST (ast.FuncDecl.Recv)не ограничивается одной записью.</target>
        </trans-unit>
        <trans-unit id="f1b15ae7c535ec21c3b3214f780b2381f7617014" translate="yes" xml:space="preserve">
          <source>The path and host are used unchanged for CONNECT requests.</source>
          <target state="translated">Путь и хост используются для запросов ПОДКЛЮЧЕНИЯ без изменений.</target>
        </trans-unit>
        <trans-unit id="623d365b943b6e8d95767b246041604e7f8848f2" translate="yes" xml:space="preserve">
          <source>The path argument contains the argument to Walk as a prefix. That is, if Walk is called with root argument &quot;dir&quot; and finds a file named &quot;a&quot; in that directory, the walk function will be called with argument &quot;dir/a&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="147552bd39d536fc2b6830c38de35cab2fd698e6" translate="yes" xml:space="preserve">
          <source>The path argument contains the argument to WalkDir as a prefix. That is, if WalkDir is called with root argument &quot;dir&quot; and finds a file named &quot;a&quot; in that directory, the walk function will be called with argument &quot;dir/a&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="185477acd3fd456d75fb7c4fc53e2fc58b8c4aaf" translate="yes" xml:space="preserve">
          <source>The path package should only be used for paths separated by forward slashes, such as the paths in URLs. This package does not deal with Windows paths with drive letters or backslashes; to manipulate operating system paths, use the path/filepath package.</source>
          <target state="translated">Пакет path должен использоваться только для путей,разделенных прямыми косыми чертами,например,пути в URL.Этот пакет не работает с путями Windows с буквами дисков или обратными слэшами;для манипулирования путями операционной системы используйте пакет path/filepath.</target>
        </trans-unit>
        <trans-unit id="26954c9ca56cc48a56a0453ce2488e2f260ed60b" translate="yes" xml:space="preserve">
          <source>The pkg/ directory holds installed package objects. As in the Go tree, each target operating system and architecture pair has its own subdirectory of pkg (pkg/GOOS_GOARCH).</source>
          <target state="translated">В каталоге pkg/хранятся объекты установленных пакетов.Как и в дереве Go,каждая целевая пара операционной системы и архитектуры имеет свой подкаталог pkg (pkg/GOOS_GOARCH).</target>
        </trans-unit>
        <trans-unit id="5a87eb4ca6fbc546df6339993053151079409112" translate="yes" xml:space="preserve">
          <source>The precision prec controls the number of digits (excluding the exponent) printed by the 'e', 'E', 'f', 'g', 'G', 'x', and 'X' formats. For 'e', 'E', 'f', 'x', and 'X', it is the number of digits after the decimal point. For 'g' and 'G' it is the maximum number of significant digits (trailing zeros are removed). The special precision -1 uses the smallest number of digits necessary such that ParseFloat will return f exactly.</source>
          <target state="translated">Прецизионный прецизионный контроль количества цифр (исключая экспоненту),печатаемых форматами 'e','E','f','g','G','x' и 'X'.Для форматов 'e','E','f','x' и 'X' это количество цифр после запятой.Для 'g' и 'G'-это максимальное количество значащих цифр (удаляются трейлинговые нули).Особая точность -1 использует наименьшее количество необходимых цифр,чтобы ParseFloat возвращал f точно.</target>
        </trans-unit>
        <trans-unit id="69078c80b7be9ecb1f89b1ab519c7b7264b1d687" translate="yes" xml:space="preserve">
          <source>The precision prec controls the number of digits (excluding the exponent) printed by the 'e', 'E', 'f', 'g', 'G', and 'x' formats. For 'e', 'E', 'f', and 'x', it is the number of digits after the decimal point. For 'g' and 'G' it is the total number of digits. A negative precision selects the smallest number of decimal digits necessary to identify the value x uniquely using x.Prec() mantissa bits. The prec value is ignored for the 'b' and 'p' formats.</source>
          <target state="translated">Для форматов 'e','E','f' и 'x' это количество цифр после запятой.Для форматов 'g' и 'G' это общее количество цифр.Отрицательная точность выбирает наименьшее количество десятичных цифр,необходимое для уникальной идентификации значения x с помощью мантиссовых битов x.Prec().Значение точности игнорируется для форматов 'b' и 'p'.</target>
        </trans-unit>
        <trans-unit id="456c4a02a800a4453e3d726e233dc51ff74f0fc9" translate="yes" xml:space="preserve">
          <source>The predefined profiles may assign meaning to other debug values; for example, when printing the &quot;goroutine&quot; profile, debug=2 means to print the goroutine stacks in the same form that a Go program uses when dying due to an unrecovered panic.</source>
          <target state="translated">Предопределённые профили могут присваивать значение другим отладочным значениям;например,при печати профиля &quot;goroutine&quot;,debug=2 означает вывод на печать стека &quot;goroutine&quot; в том же виде,в каком программа Go использует при умирании из-за невосстановившейся паники.</target>
        </trans-unit>
        <trans-unit id="58481973143a6de618e8538c648e764b31b42f2b" translate="yes" xml:space="preserve">
          <source>The print built-in function formats its arguments in an implementation-specific way and writes the result to standard error. Print is useful for bootstrapping and debugging; it is not guaranteed to stay in the language.</source>
          <target state="translated">Встроенная функция печати форматирует свои аргументы в зависимости от реализации и записывает результат в стандартную ошибку.Печать полезна при загрузке и отладке;она не гарантированно останется на языке.</target>
        </trans-unit>
        <trans-unit id="91f04de49b9af203098665c6f8b752b5392b78a0" translate="yes" xml:space="preserve">
          <source>The println built-in function formats its arguments in an implementation-specific way and writes the result to standard error. Spaces are always added between arguments and a newline is appended. Println is useful for bootstrapping and debugging; it is not guaranteed to stay in the language.</source>
          <target state="translated">Встроенная функция распечатки форматирует свои аргументы в зависимости от реализации и записывает результат в стандартную ошибку.Пробелы всегда добавляются между аргументами и добавляется новая строка.Println полезен при загрузке и отладке;он не гарантированно останется на языке.</target>
        </trans-unit>
        <trans-unit id="151eef92ef01a650c4a9036a013718d694ffc693" translate="yes" xml:space="preserve">
          <source>The provided Context must be non-nil. If the context expires before the connection is complete, an error is returned. Once successfully connected, any expiration of the context will not affect the connection.</source>
          <target state="translated">Предоставленный контекст не должен быть нулевым.Если срок действия контекста истекает до завершения соединения,возвращается ошибка.После успешного подключения любое истечение срока действия контекста не повлияет на соединение.</target>
        </trans-unit>
        <trans-unit id="0e411a42789a39be423654b810b14a1d819d3f7a" translate="yes" xml:space="preserve">
          <source>The provided TxOptions is optional and may be nil if defaults should be used. If a non-default isolation level is used that the driver doesn't support, an error will be returned.</source>
          <target state="translated">Предоставляемые опции TxOptions являются необязательными и могут быть нулевыми,если необходимо использовать настройки по умолчанию.Если используется уровень изоляции по умолчанию,который драйвер не поддерживает,будет возвращена ошибка.</target>
        </trans-unit>
        <trans-unit id="decd2b405e8241c6f8e12f33bd5a3bb2cc5dc04e" translate="yes" xml:space="preserve">
          <source>The provided body may be nil. If the body is of type *bytes.Reader, *strings.Reader, or *bytes.Buffer, the Request.ContentLength is set.</source>
          <target state="translated">Предоставленное тело может быть нулевым.Если тело имеет тип *bytes.Reader,*strings.Reader или *bytes.Buffer,то устанавливается длина запроса.ContentLength.</target>
        </trans-unit>
        <trans-unit id="58ddb87ccdb3a3bbf17dded9af2e6f690f9fa593" translate="yes" xml:space="preserve">
          <source>The provided code should be in the 3xx range and is usually StatusMovedPermanently, StatusFound or StatusSeeOther.</source>
          <target state="translated">Предоставляемый код должен быть в диапазоне 3xx и обычно является StatusMovedPermanently,StatusFound или StatusSeeOther.</target>
        </trans-unit>
        <trans-unit id="86be20106cb95d195cb582ade394435819f24514" translate="yes" xml:space="preserve">
          <source>The provided context is used for the preparation of the statement, not for the execution of the statement.</source>
          <target state="translated">Представленный контекст используется для подготовки заявления,а не для его исполнения.</target>
        </trans-unit>
        <trans-unit id="dd14eed153c5e1b07e7490871396f032fee4f925" translate="yes" xml:space="preserve">
          <source>The provided context is used to kill the process (by calling os.Process.Kill) if the context becomes done before the command completes on its own.</source>
          <target state="translated">Предоставленный контекст используется для того,чтобы убить процесс (вызовом os.Process.Kill),если контекст становится выполненным до того,как команда завершится самостоятельно.</target>
        </trans-unit>
        <trans-unit id="a4964ee167f777b88ff9017caa2a6e7f575494e2" translate="yes" xml:space="preserve">
          <source>The provided context is used until the transaction is committed or rolled back. If the context is canceled, the sql package will roll back the transaction. Tx.Commit will return an error if the context provided to BeginTx is canceled.</source>
          <target state="translated">Приведенный контекст используется до тех пор,пока сделка не будет совершена или откат не произойдет.Если контекст отменяется,пакет sql откатит транзакцию.Tx.Commit вернет ошибку,если контекст,предоставленный в BeginTx,будет отменен.</target>
        </trans-unit>
        <trans-unit id="08a11fcf0761deb535b1afddd2450e0cb1b073dd" translate="yes" xml:space="preserve">
          <source>The provided context will be used for the preparation of the context, not for the execution of the returned statement. The returned statement will run in the transaction context.</source>
          <target state="translated">Представленный контекст будет использоваться для подготовки контекста,а не для исполнения возвращенного заявления.Возвращаемое сообщение будет выполняться в контексте операции.</target>
        </trans-unit>
        <trans-unit id="36087efe71a5f2727d53bfdfa94ece516eb41424" translate="yes" xml:space="preserve">
          <source>The provided key must be comparable and should not be of type string or any other built-in type to avoid collisions between packages using context. Users of WithValue should define their own types for keys. To avoid allocating when assigning to an interface{}, context keys often have concrete type struct{}. Alternatively, exported context key variables' static type should be a pointer or interface.</source>
          <target state="translated">Предоставляемый ключ должен быть сопоставимым и не должен быть строкового типа или любого другого встроенного типа,чтобы избежать столкновений между пакетами,использующими контекст.Пользователи WithValue должны определить свои собственные типы для ключей.Чтобы избежать выделения при назначении интерфейсу{},контекстные ключи часто имеют конкретную типовую структуру{}.В качестве альтернативы,статический тип экспортируемых контекстных клавиш должен быть указателем или интерфейсом.</target>
        </trans-unit>
        <trans-unit id="85ad36caa7041b29ad99437d10d43da203313ed0" translate="yes" xml:space="preserve">
          <source>The race detector kills the program if it exceeds 8192 concurrent goroutines, so use care when running parallel tests with the -race flag set.</source>
          <target state="translated">Детектор гонки убивает программу,если она превышает 8192 одновременных гориллы,поэтому будьте внимательны при выполнении параллельных тестов с установленным флагом -race.</target>
        </trans-unit>
        <trans-unit id="8b5744dbc3f5965d88d3d9f6581899823cd536e1" translate="yes" xml:space="preserve">
          <source>The rand parameter is used as a source of entropy to ensure that encrypting the same message twice doesn't result in the same ciphertext.</source>
          <target state="translated">Параметр rand используется в качестве источника энтропии для того,чтобы шифрование одного и того же сообщения дважды не приводило к одному и тому же шифрованному тексту.</target>
        </trans-unit>
        <trans-unit id="9b3902f0d9da9da0e87784ba5652f4c8601d4919" translate="yes" xml:space="preserve">
          <source>The random parameter is used as a source of entropy to ensure that encrypting the same message twice doesn't result in the same ciphertext.</source>
          <target state="translated">Случайный параметр используется в качестве источника энтропии для обеспечения того,чтобы шифрование одного и того же сообщения дважды не приводило к получению одного и того же зашифрованного текста.</target>
        </trans-unit>
        <trans-unit id="cf169dddc14ea8341fcb30899e22a5fa61df4712" translate="yes" xml:space="preserve">
          <source>The random parameter, if not nil, is used to blind the private-key operation and avoid timing side-channel attacks. Blinding is purely internal to this function &amp;ndash; the random data need not match that used when encrypting.</source>
          <target state="translated">Параметр random, если не nil, используется, чтобы скрыть операцию с секретным ключом и избежать атак по побочному каналу по времени. Ослепление является чисто внутренним для этой функции - случайные данные не обязательно должны совпадать с данными, используемыми при шифровании.</target>
        </trans-unit>
        <trans-unit id="2314ea9b04c810fb371325317bf102a02d2d59d0" translate="yes" xml:space="preserve">
          <source>The rawurl may be relative (a path, without a host) or absolute (starting with a scheme). Trying to parse a hostname and path without a scheme is invalid but may not necessarily return an error, due to parsing ambiguities.</source>
          <target state="translated">Сырая нефть может быть относительной (путь,без хозяина)или абсолютной (начиная со схемы).Попытка разобрать имя хоста и путь без схемы является недействительной,но не обязательно может вернуть ошибку из-за неоднозначности разбора.</target>
        </trans-unit>
        <trans-unit id="239176c955d354cb84e342df1da6a160a09d1822" translate="yes" xml:space="preserve">
          <source>The read and write halves of the connection are serialized independently, so no interlocking is required. However each half may be accessed concurrently so the implementation of conn should protect against concurrent reads or concurrent writes.</source>
          <target state="translated">Половинки соединения для чтения и записи сериализуются независимо друг от друга,поэтому никакой блокировки не требуется.Однако каждая половина может быть доступна одновременно,поэтому реализация соединения должна защищать от одновременного чтения или одновременной записи.</target>
        </trans-unit>
        <trans-unit id="b43ec28ed349612adbaa799bb6c92934c3b075dc" translate="yes" xml:space="preserve">
          <source>The real built-in function returns the real part of the complex number c. The return value will be floating point type corresponding to the type of c.</source>
          <target state="translated">Вещественная встроенная функция возвращает вещественную часть комплексного числа c.Возвращаемым значением будет тип с плавающей точкой,соответствующий типу c.</target>
        </trans-unit>
        <trans-unit id="9bb09164885f351e6fb900da553f1e63b375bfa9" translate="yes" xml:space="preserve">
          <source>The recognized day of week formats are &quot;Mon&quot; and &quot;Monday&quot;. The recognized month formats are &quot;Jan&quot; and &quot;January&quot;.</source>
          <target state="translated">Распознаваемыми днями недели являются &quot;Пн&quot; и &quot;Понедельник&quot;.Признанные форматы месяца-&quot;Январь&quot; и &quot;Январь&quot;.</target>
        </trans-unit>
        <trans-unit id="2c571daa54e2fb7d0c128741daf715a11d1e44fe" translate="yes" xml:space="preserve">
          <source>The recover built-in function allows a program to manage behavior of a panicking goroutine. Executing a call to recover inside a deferred function (but not any function called by it) stops the panicking sequence by restoring normal execution and retrieves the error value passed to the call of panic. If recover is called outside the deferred function it will not stop a panicking sequence. In this case, or when the goroutine is not panicking, or if the argument supplied to panic was nil, recover returns nil. Thus the return value from recover reports whether the goroutine is panicking.</source>
          <target state="translated">Встроенная функция восстановления позволяет программе управлять поведением паникующего горутина.Выполнение вызова для восстановления внутри отложенной функции (но не любой вызываемой ею функции)останавливает последовательность паники,восстанавливая нормальное выполнение,и извлекает значение ошибки,переданное при вызове паники.Если восстановление вызывается вне отложенной функции,оно не останавливает последовательность паники.В этом случае,или когда горутин не паникует,или если аргумент,приведенный к панике,равен нулю,восстановление возвращает ноль.Таким образом,возвращаемое из recover значение сообщает,паникует ли горутин.</target>
        </trans-unit>
        <trans-unit id="ff14ed6c9720c452a0294998e96d92039ec86474" translate="yes" xml:space="preserve">
          <source>The regexp implementation provided by this package is guaranteed to run in time linear in the size of the input. (This is a property not guaranteed by most open source implementations of regular expressions.) For more information about this property, see</source>
          <target state="translated">Реализация регеxp,предоставляемая данным пакетом,гарантированно выполняется во времени линейно по размеру входа.(Это свойство не гарантируется большинством открытых реализаций регулярных выражений).Подробнее об этом свойстве см.</target>
        </trans-unit>
        <trans-unit id="e4c94cab05a4e2263ef4f912bc17e254d9de85c1" translate="yes" xml:space="preserve">
          <source>The regionType is used to classify regions, so there should be only a handful of unique region types.</source>
          <target state="translated">Для классификации регионов используется regionType,поэтому должно быть только несколько уникальных типов регионов.</target>
        </trans-unit>
        <trans-unit id="613161bf225c19a5f2c8859dc32ad7cbf64fe341" translate="yes" xml:space="preserve">
          <source>The regular expression syntax understood by this package when parsing with the Perl flag is as follows. Parts of the syntax can be disabled by passing alternate flags to Parse.</source>
          <target state="translated">Синтаксис регулярных выражений,понимаемый данным пакетом при разборе с флагом Perl,следующий.Часть синтаксиса может быть отключена передачей альтернативных флагов Parse.</target>
        </trans-unit>
        <trans-unit id="414d3f9a62c65f403de754cbbecda8b294ef6a05" translate="yes" xml:space="preserve">
          <source>The remaining patterns enumerate the only valid conversions from uintptr to Pointer.</source>
          <target state="translated">Остальные шаблоны перечисляют единственные верные преобразования из uintptr в Pointer.</target>
        </trans-unit>
        <trans-unit id="f01d454f6a8093b81d93ec48391c3d15861fea72" translate="yes" xml:space="preserve">
          <source>The remaining signals are asynchronous signals. They are not triggered by program errors, but are instead sent from the kernel or from some other program.</source>
          <target state="translated">Остальные сигналы являются асинхронными.Они не вызваны программными ошибками,а исходят от ядра или от какой-то другой программы.</target>
        </trans-unit>
        <trans-unit id="b6f243f72fd3fe537acd4a5fca41b95e81ce45b9" translate="yes" xml:space="preserve">
          <source>The representation of types is described below. When a type is defined on a given connection between an Encoder and Decoder, it is assigned a signed integer type id. When Encoder.Encode(v) is called, it makes sure there is an id assigned for the type of v and all its elements and then it sends the pair (typeid, encoded-v) where typeid is the type id of the encoded type of v and encoded-v is the gob encoding of the value v.</source>
          <target state="translated">Представление типов описано ниже.Когда тип определен на заданном соединении между Кодировщиком и Декодером,ему присваивается знаковый целочисленный идентификатор типа.При вызове Encoder.Encode(v),он убеждается,что для типа v и всех его элементов присвоен id,а затем посылает пару (typeid,encoded-v),где typeid-идентификатор типа кодируемого типа v,а encoded-v-кодировка gob значения v.</target>
        </trans-unit>
        <trans-unit id="cd667628565a5086d3e9895b56322424dc5621cd" translate="yes" xml:space="preserve">
          <source>The request Body, if non-nil, will be closed by the underlying Transport, even on errors.</source>
          <target state="translated">Запросивший Орган,если он не будет заполнен,будет закрыт соответствующим транспортом,даже по ошибке.</target>
        </trans-unit>
        <trans-unit id="d4e026c3f59ca2f49146d499574e033e155a3b79" translate="yes" xml:space="preserve">
          <source>The resolver decision can be overridden by setting the netdns value of the GODEBUG environment variable (see package runtime) to go or cgo, as in:</source>
          <target state="translated">Решение резольвера можно отменить,установив значение netdns переменной окружения GODEBUG (см.&quot;Время выполнения пакета&quot;)на &quot;go&quot; или &quot;cgo&quot;,как описано выше:</target>
        </trans-unit>
        <trans-unit id="85ba008f9a41b800d285074394b704f73cc09894" translate="yes" xml:space="preserve">
          <source>The rest of this package comment may be skipped on first reading; it includes details necessary to understand escaping contexts and error messages. Most users will not need to understand these details.</source>
          <target state="translated">Остальной комментарий пакета можно пропустить при первом чтении;он включает в себя подробности,необходимые для понимания контекста экранирования и сообщений об ошибках.Большинству пользователей не нужно будет понимать эти детали.</target>
        </trans-unit>
        <trans-unit id="5f29380aa9a229b911cfb4cbcef02c25951562ac" translate="yes" xml:space="preserve">
          <source>The rest of this section gives the precise details of how operations use monotonic clocks, but understanding those details is not required to use this package.</source>
          <target state="translated">В остальной части этого раздела приведены точные детали того,как операции используют монотонные часы,но понимание этих деталей не требуется для использования данного пакета.</target>
        </trans-unit>
        <trans-unit id="b7f11101676a7b7c4f383ade5d8d3f82131c1b53" translate="yes" xml:space="preserve">
          <source>The result of Scan is one of these tokens or a Unicode character.</source>
          <target state="translated">Результатом Сканирования является один из этих маркеров или символ Юникода.</target>
        </trans-unit>
        <trans-unit id="4646462be207e1c8f655d521c7883b8db5be5339" translate="yes" xml:space="preserve">
          <source>The results of a benchmark run.</source>
          <target state="translated">Результаты контрольного прогона.</target>
        </trans-unit>
        <trans-unit id="6be7e87ff9924a05b7bc2a7006d807f1fab39e3d" translate="yes" xml:space="preserve">
          <source>The returned *Float f is nil and the value of z is valid but not defined if an error is reported.</source>
          <target state="translated">Возвращаемое *Float f равно нулю,а значение z является действительным,но не определяется,если поступает сообщение об ошибке.</target>
        </trans-unit>
        <trans-unit id="bac86830681be1d31b72f9f7791b1c44ac2452e7" translate="yes" xml:space="preserve">
          <source>The returned Cmd's Args field is constructed from the command name followed by the elements of arg, so arg should not include the command name itself. For example, Command(&quot;echo&quot;, &quot;hello&quot;). Args[0] is always name, not the possibly resolved Path.</source>
          <target state="translated">Возвращаемое поле Args в Cmd строится из имени команды,за которым следуют элементы arg,поэтому arg не должен включать само имя команды.Например,Command(&quot;echo&quot;,&quot;hello&quot;).Args[0]-это всегда имя,а не возможно разрешенный путь.</target>
        </trans-unit>
        <trans-unit id="fe921f2e96cf2be56c2bf49f4740170d8dd45071" translate="yes" xml:space="preserve">
          <source>The returned Conn, if any, will always be of type *Conn.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3bc6a14f8ce0d88107543f9f02901b96c67b460c" translate="yes" xml:space="preserve">
          <source>The returned DB is safe for concurrent use by multiple goroutines and maintains its own pool of idle connections. Thus, the Open function should be called just once. It is rarely necessary to close a DB.</source>
          <target state="translated">Возвращаемая БД безопасна для одновременного использования несколькими горутинами и поддерживает собственный пул простаивающих соединений.Таким образом,функция Open должна быть вызвана всего один раз.Редко бывает необходимо закрыть БД.</target>
        </trans-unit>
        <trans-unit id="c94572c3b7d816968d78d57402944f7efb4246e7" translate="yes" xml:space="preserve">
          <source>The returned DB is safe for concurrent use by multiple goroutines and maintains its own pool of idle connections. Thus, the OpenDB function should be called just once. It is rarely necessary to close a DB.</source>
          <target state="translated">Возвращаемая БД безопасна для одновременного использования несколькими горутинами и поддерживает собственный пул простаивающих соединений.Таким образом,функция OpenDB должна вызываться всего один раз.Редко бывает необходимо закрыть БД.</target>
        </trans-unit>
        <trans-unit id="33f1666e076b57e7a3379acacb81a7ec24e7d31d" translate="yes" xml:space="preserve">
          <source>The returned RawConn only supports calling Control. Read and Write return an error.</source>
          <target state="translated">Возвращаемый RawConn поддерживает только вызов Control.Read and Write (Чтение и запись)возвращает ошибку.</target>
        </trans-unit>
        <trans-unit id="00382818b7b561dcf8c2e41afc3acbf78809ee7a" translate="yes" xml:space="preserve">
          <source>The returned Response will have at least its StatusCode, Header, Body, and optionally Trailer populated. More fields may be populated in the future, so callers should not DeepEqual the result in tests.</source>
          <target state="translated">Возвращаемый ответ будет содержать,по крайней мере,код статуса,заголовок,кузов и,опционально,прицеп.В будущем может быть заполнено большее количество полей,поэтому звонящие не должны DeepEqual получать результат в тестах.</target>
        </trans-unit>
        <trans-unit id="f4f37717fc57244b8b099472fa87f281f196d58d" translate="yes" xml:space="preserve">
          <source>The returned context is always non-nil; it defaults to the background context.</source>
          <target state="translated">Возвращаемый контекст всегда равен нулю;по умолчанию он соответствует фоновому контексту.</target>
        </trans-unit>
        <trans-unit id="9cbe06fbabaade2695a345469e46bbf5011eaae5" translate="yes" xml:space="preserve">
          <source>The returned end function is used to mark the task's end. The trace tool measures task latency as the time between task creation and when the end function is called, and provides the latency distribution per task type. If the end function is called multiple times, only the first call is used in the latency measurement.</source>
          <target state="translated">Функция возврата конца используется для маркировки конца задачи.Инструмент трассировки измеряет латентность задачи как время между созданием задачи и вызовом конечной функции и обеспечивает распределение латентности по типу задачи.Если конечная функция вызывается несколько раз,то при измерении задержки используется только первый вызов.</target>
        </trans-unit>
        <trans-unit id="f0a8feeaa4dbaf36e773a52f49c0b0ac6bb7e74a" translate="yes" xml:space="preserve">
          <source>The returned error is nil if the command runs, has no problems copying stdin, stdout, and stderr, and exits with a zero exit status.</source>
          <target state="translated">Возвращаемая ошибка равна нулю,если команда выполняется,не имеет проблем с копированием stdin,stdout и stderr,и выходит со статусом нулевого выхода.</target>
        </trans-unit>
        <trans-unit id="4d6b3f09dc97620be2a232fb3dc17468c15d1426" translate="yes" xml:space="preserve">
          <source>The returned list does not identify the associated interface; use Interfaces and Interface.Addrs for more detail.</source>
          <target state="translated">Возвращаемый список не идентифицирует соответствующий интерфейс;для более подробной информации используйте Interfaces и Interface.Addrs.</target>
        </trans-unit>
        <trans-unit id="c6a6b1723d6bc4ac24e64af0ce75d94122db9245" translate="yes" xml:space="preserve">
          <source>The returned memory allocator statistics are up to date as of the call to ReadMemStats. This is in contrast with a heap profile, which is a snapshot as of the most recently completed garbage collection cycle.</source>
          <target state="translated">Статистика возвращаемого аллокатора памяти актуальна на момент вызова ReadMemStats.Это контрастирует с профилем кучи,который является снимком последнего завершенного цикла сбора мусора.</target>
        </trans-unit>
        <trans-unit id="a6ee6f83dacc73003b6dade23a5eca55ab60b66f" translate="yes" xml:space="preserve">
          <source>The returned os.File's file descriptor is different from the connection's. Attempting to change properties of the original using this duplicate may or may not have the desired effect.</source>
          <target state="translated">Возвращаемый дескриптор файла os.File отличается от дескриптора соединения.Попытка изменить свойства оригинала с помощью этого дубликата может иметь или не иметь желаемого эффекта.</target>
        </trans-unit>
        <trans-unit id="5927f2050b65cd29032e207117c8b2d6ca472e54" translate="yes" xml:space="preserve">
          <source>The returned path ends in a slash only if it is the root &quot;/&quot;.</source>
          <target state="translated">Возвращаемый путь заканчивается косой чертой только в том случае,если это корень &quot;/&quot;.</target>
        </trans-unit>
        <trans-unit id="004ac519a1c16ea761d189382ea9cc0c1b68b7d1" translate="yes" xml:space="preserve">
          <source>The returned path ends in a slash only if it represents a root directory, such as &quot;/&quot; on Unix or `C:\` on Windows.</source>
          <target state="translated">Возвращаемый путь заканчивается косой чертой,только если он представляет корневую директорию,такую как &quot;/&quot; в Unix или `C:\` в Windows.</target>
        </trans-unit>
        <trans-unit id="709611ccac6cb61ed7ee0c2fc8499ed7e268fed4" translate="yes" xml:space="preserve">
          <source>The returned profile may be up to two garbage collection cycles old. This is to avoid skewing the profile toward allocations; because allocations happen in real time but frees are delayed until the garbage collector performs sweeping, the profile only accounts for allocations that have had a chance to be freed by the garbage collector.</source>
          <target state="translated">Возвращаемый профиль может быть до двух циклов сбора мусора старым.Это сделано во избежание перекоса профиля в сторону распределений;поскольку распределения происходят в реальном времени,а освобождение освобожденного мусора откладывается до тех пор,пока сборщик мусора не выполнит очистку,профиль учитывает только те распределения,которые имели шанс быть освобожденными сборщиком мусора.</target>
        </trans-unit>
        <trans-unit id="2fcbc7cecfbd88a968cff813905d726fdf40b131" translate="yes" xml:space="preserve">
          <source>The returned slice is the certificate in DER encoding.</source>
          <target state="translated">Возвращаемый кусок-это сертификат в кодировке DER.</target>
        </trans-unit>
        <trans-unit id="01c758564c188da314abf0218bd7cfbe2c752f80" translate="yes" xml:space="preserve">
          <source>The returned slice is the certificate request in DER encoding.</source>
          <target state="translated">Возвращаемый фрагмент-это запрос сертификата в DER-кодировке.</target>
        </trans-unit>
        <trans-unit id="56ef9da288a159e17f780d686422f0dfcfa221a7" translate="yes" xml:space="preserve">
          <source>The returned statement operates within the transaction and can no longer be used once the transaction has been committed or rolled back.</source>
          <target state="translated">Возвращаемый отчет действует в рамках операции и больше не может быть использован после совершения или отката операции.</target>
        </trans-unit>
        <trans-unit id="eaef2ac25b5ec95632c077f9297b6bf55f5dd3f6" translate="yes" xml:space="preserve">
          <source>The returned statement operates within the transaction and will be closed when the transaction has been committed or rolled back.</source>
          <target state="translated">Возвращаемый отчет действует в рамках сделки и будет закрыт,когда сделка будет совершена или откатится назад.</target>
        </trans-unit>
        <trans-unit id="10df7eea472cec1ead17a66cb1fdaefe2e6578cc" translate="yes" xml:space="preserve">
          <source>The returned string is meant for debugging; for a stable serialized representation, use t.MarshalText, t.MarshalBinary, or t.Format with an explicit format string.</source>
          <target state="translated">Возвращаемая строка предназначена для отладки;для стабильного сериализованного представления используйте t.MarshalText,t.MarshalBinary или t.Format со строкой явного форматирования.</target>
        </trans-unit>
        <trans-unit id="48866f9aa69c2bb04dcb85d20c5a3c1d2d405ca8" translate="yes" xml:space="preserve">
          <source>The rule Title uses for word boundaries does not handle Unicode punctuation properly.</source>
          <target state="translated">Правило Title,используемое для границ слов,не корректно обрабатывает знаки препинания Юникода.</target>
        </trans-unit>
        <trans-unit id="f80f01b0edf7103d5ecb8ca06eb4e22919710f70" translate="yes" xml:space="preserve">
          <source>The same Context may be passed to functions running in different goroutines; Contexts are safe for simultaneous use by multiple goroutines.</source>
          <target state="translated">Один и тот же Контекст может быть передан функциям,выполняющимся в разных горутинах;Контексты безопасны для одновременного использования несколькими горутинами.</target>
        </trans-unit>
        <trans-unit id="a401c4efb67cc0055f52caa84dcf2de0d8f63cd7" translate="yes" xml:space="preserve">
          <source>The second argument, quote, specifies the type of literal being parsed and therefore which escaped quote character is permitted. If set to a single quote, it permits the sequence \' and disallows unescaped '. If set to a double quote, it permits \&quot; and disallows unescaped &quot;. If set to zero, it does not permit either escape and allows both quote characters to appear unescaped.</source>
          <target state="translated">Второй аргумент,кавычки,определяет тип разбираемого литерала и,следовательно,допустимый символ экранированной кавычки.Если задать единственную кавычку,то разрешается последовательность \' и запрещается unescaped '.Если задать двойную кавычку,то разрешит \&quot; и запретит unescaped &quot;.Если установлено в ноль,то это не разрешает ни экранирование,ни кавычки,и разрешает оба символа в кавычках выглядеть неэкранированными.</target>
        </trans-unit>
        <trans-unit id="40a1d3ecbed0bf217ec97ece1c42e914315bd313" translate="yes" xml:space="preserve">
          <source>The security model used by this package assumes that template authors are trusted, while Execute's data parameter is not. More details are provided below.</source>
          <target state="translated">Модель безопасности,используемая этим пакетом,предполагает,что авторы шаблонов доверяют,а параметр данных Execute-нет.Более подробная информация представлена ниже.</target>
        </trans-unit>
        <trans-unit id="a70cb84ae80d93013971dc3c09e0dd11fbe3a660" translate="yes" xml:space="preserve">
          <source>The server calls (for HTTP service):</source>
          <target state="translated">Вызов сервера (для услуги HTTP):</target>
        </trans-unit>
        <trans-unit id="4694acea63f5ebf8b8be35e4e84982505cd7d21a" translate="yes" xml:space="preserve">
          <source>The server may handle requests on a single connection by calling ServeConn. More typically it will create a network listener and call Accept or, for an HTTP listener, HandleHTTP and http.Serve.</source>
          <target state="translated">Сервер может обрабатывать запросы по одному соединению,позвонив в ServeConn.Обычно он создает сетевой приемник и звонит в Accept или,для приемника HTTP,в HandleHTTP и http.Serve.</target>
        </trans-unit>
        <trans-unit id="901fd3527b931189389dc8b05aa80a401b308de0" translate="yes" xml:space="preserve">
          <source>The set of available CPUs is checked by querying the operating system at process startup. Changes to operating system CPU allocation after process startup are not reflected.</source>
          <target state="translated">Набор доступных ЦПУ проверяется путем запроса операционной системы при запуске процесса.Изменения в распределении ЦПУ операционной системы после ввода процесса в эксплуатацию не отражаются.</target>
        </trans-unit>
        <trans-unit id="a4ffb207191c8f11d25b769c7eab3f4bd62e8f7a" translate="yes" xml:space="preserve">
          <source>The set of metrics defined by this package may evolve as the runtime itself evolves, and also enables variation across Go implementations, whose relevant metric sets may not intersect.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10e3cd17c3685da24fcde871ef4da00a080771a9" translate="yes" xml:space="preserve">
          <source>The signals SIGKILL and SIGSTOP may not be caught by a program, and therefore cannot be affected by this package.</source>
          <target state="translated">Сигналы SIGKILL и SIGSTOP не могут быть пойманы программой,и поэтому не могут быть затронуты данным пакетом.</target>
        </trans-unit>
        <trans-unit id="7621705ac03f21ac222836c967959708135562eb" translate="yes" xml:space="preserve">
          <source>The simplest use of a Scanner, to read standard input as a set of lines.</source>
          <target state="translated">Самое простое использование сканера,для чтения стандартного входа в виде набора строк.</target>
        </trans-unit>
        <trans-unit id="9c0657904725889b0c9ba75534abc4f635bc0b2b" translate="yes" xml:space="preserve">
          <source>The size of a CRC-32 checksum in bytes.</source>
          <target state="translated">Размер контрольной суммы CRC-32 в байтах.</target>
        </trans-unit>
        <trans-unit id="3ff608e7233df0580119a8a262ba634622895d8a" translate="yes" xml:space="preserve">
          <source>The size of a CRC-64 checksum in bytes.</source>
          <target state="translated">Размер контрольной суммы CRC-64 в байтах.</target>
        </trans-unit>
        <trans-unit id="caae8e5aad6dbb0160181390b9818b080d122c80" translate="yes" xml:space="preserve">
          <source>The size of a SHA-1 checksum in bytes.</source>
          <target state="translated">Размер контрольной суммы SHA-1 в байтах.</target>
        </trans-unit>
        <trans-unit id="cea16f97cc88534275f0e03f305d57951a36e34b" translate="yes" xml:space="preserve">
          <source>The size of a SHA224 checksum in bytes.</source>
          <target state="translated">Размер контрольной суммы SHA224 в байтах.</target>
        </trans-unit>
        <trans-unit id="3a1556147bf25a0038243a962f16bc9d44b98e20" translate="yes" xml:space="preserve">
          <source>The size of a SHA256 checksum in bytes.</source>
          <target state="translated">Размер контрольной суммы SHA256 в байтах.</target>
        </trans-unit>
        <trans-unit id="fb49c909a50ec86545c33e34c0f3d64148914e03" translate="yes" xml:space="preserve">
          <source>The size of an Adler-32 checksum in bytes.</source>
          <target state="translated">Размер контрольной суммы Адлера-32 в байтах.</target>
        </trans-unit>
        <trans-unit id="edf1ef16cc66ffa121682ca1207ef5467651c4f4" translate="yes" xml:space="preserve">
          <source>The size of an MD5 checksum in bytes.</source>
          <target state="translated">Размер контрольной суммы MD5 в байтах.</target>
        </trans-unit>
        <trans-unit id="248e03e24b52c36053fea2b5fabdbb42fe255abb" translate="yes" xml:space="preserve">
          <source>The skip parameter has the same meaning as runtime.Caller's skip and controls where the stack trace begins. Passing skip=0 begins the trace in the function calling Add. For example, given this execution stack:</source>
          <target state="translated">Параметр skip имеет то же значение,что и runtime.Caller's skip и управляет тем,где начинается трасса стека.Пропуск=0 начинает трассу в функции,вызывающей Add.Например,учитывая этот стек выполнения:</target>
        </trans-unit>
        <trans-unit id="b675e8a3e2a529e23f6f667c1adf36c39ed93efb" translate="yes" xml:space="preserve">
          <source>The slice returned by this method consists of all the substrings of s not contained in the slice returned by FindAllString. When called on an expression that contains no metacharacters, it is equivalent to strings.SplitN.</source>
          <target state="translated">Возвращаемый этим методом ломтик состоит из всех подложек s,не содержащихся в ломтике,возвращаемом FindAllString.При вызове выражения,не содержащего мета-символов,оно эквивалентно строке.SplitN.</target>
        </trans-unit>
        <trans-unit id="37fc7946d5ac5fa1638ca298818fb97686f9142e" translate="yes" xml:space="preserve">
          <source>The smtp package is frozen and is not accepting new features. Some external packages provide more functionality. See:</source>
          <target state="translated">Пакет smtp заморожен и не принимает новых функций.Некоторые внешние пакеты предоставляют больше функциональности.Смотрите:</target>
        </trans-unit>
        <trans-unit id="37671db71f74ceff10a366ff8f17e7a0a28fae66" translate="yes" xml:space="preserve">
          <source>The sort is not guaranteed to be stable. For a stable sort, use SliceStable.</source>
          <target state="translated">Сорт не гарантированно будет стабильным.Для стабильного сорта используйте SliceStable.</target>
        </trans-unit>
        <trans-unit id="bda42a397fbbab417ff8adfb3aa5399f5d54b818" translate="yes" xml:space="preserve">
          <source>The sort is not guaranteed to be stable: equal elements may be reversed from their original order. For a stable sort, use SliceStable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17c5e77086e67a3f2c51a48bac9596dffc360456" translate="yes" xml:space="preserve">
          <source>The source and destination values/types need not correspond exactly. For structs, fields (identified by name) that are in the source but absent from the receiving variable will be ignored. Fields that are in the receiving variable but missing from the transmitted type or value will be ignored in the destination. If a field with the same name is present in both, their types must be compatible. Both the receiver and transmitter will do all necessary indirection and dereferencing to convert between gobs and actual Go values. For instance, a gob type that is schematically,</source>
          <target state="translated">Значения/типы источника и места назначения не обязательно должны точно совпадать.Для структур,поля (идентифицируемые по имени),которые находятся в источнике,но отсутствуют в принимающей переменной,будут игнорироваться.Поля,находящиеся в принимающей переменной,но отсутствующие в передаваемом типе или значении,будут игнорироваться в приемнике.Если поле с одинаковым именем присутствует в обоих,то их типы должны быть совместимы.И приемник,и передатчик будут делать все необходимые идирекции и разыменования,чтобы преобразовать между gobs и фактические значения Go.Например,тип варочных панелей,который является схематичным,</target>
        </trans-unit>
        <trans-unit id="0268779129500cf4856c5f56fd67106abaf097eb" translate="yes" xml:space="preserve">
          <source>The source code could include additional Go code. That code was never compiled but would be processed by tools like godoc and might be useful as end-user documentation.</source>
          <target state="translated">Исходный код может включать дополнительный код Go.Этот код никогда не компилировался,а обрабатывался бы такими инструментами,как godoc,и мог бы быть полезен в качестве документации для конечного пользователя.</target>
        </trans-unit>
        <trans-unit id="535d0edaef1db8d5c1dc136b1a303868255bb996" translate="yes" xml:space="preserve">
          <source>The source:</source>
          <target state="translated">Источник:</target>
        </trans-unit>
        <trans-unit id="e645e5bfb164f126d92a3414aa1a585176c8e465" translate="yes" xml:space="preserve">
          <source>The sql package checks for value checkers in the following order, stopping at the first found match: Stmt.NamedValueChecker, Conn.NamedValueChecker, Stmt.ColumnConverter, DefaultParameterConverter.</source>
          <target state="translated">Пакет sql проверяет на наличие шашек стоимости в следующем порядке,останавливаясь на первом найденном совпадении:Stmt.NamedValueChecker,Conn.NamedValueChecker,Stmt.ColumnConverter,DefaultParameterConverter.</target>
        </trans-unit>
        <trans-unit id="bf35db5d84a5c59679d57c2063978bf2973a302c" translate="yes" xml:space="preserve">
          <source>The sql package creates and frees connections automatically; it also maintains a free pool of idle connections. If the database has a concept of per-connection state, such state can be reliably observed within a transaction (Tx) or connection (Conn). Once DB.Begin is called, the returned Tx is bound to a single connection. Once Commit or Rollback is called on the transaction, that transaction's connection is returned to DB's idle connection pool. The pool size can be controlled with SetMaxIdleConns.</source>
          <target state="translated">Пакет sql автоматически создает и освобождает соединения;он также поддерживает свободный пул простаивающих соединений.Если БД имеет понятие состояния per-connection,то такое состояние может быть надежно отслежено в рамках транзакции (Tx)или соединения (Conn).После вызова DB.Begin возвращаемый Tx привязывается к одному соединению.После вызова Commit или Rollback по транзакции,соединение этой транзакции возвращается в пул простаивающих соединений БД.Размер пула можно контролировать с помощью SetMaxIdleConns.</target>
        </trans-unit>
        <trans-unit id="14c50009f306ef9ba308a3f9f45cb12ceab6e041" translate="yes" xml:space="preserve">
          <source>The sql package must be used in conjunction with a database driver. See &lt;a href=&quot;https://golang.org/s/sqldrivers&quot;&gt;https://golang.org/s/sqldrivers&lt;/a&gt; for a list of drivers.</source>
          <target state="translated">Пакет sql необходимо использовать вместе с драйвером базы данных. См. &lt;a href=&quot;https://golang.org/s/sqldrivers&quot;&gt;Https://golang.org/s/sqldrivers&lt;/a&gt; для получения списка драйверов.</target>
        </trans-unit>
        <trans-unit id="ff11c76849e5520b5d3c1908876a0a08249bbd90" translate="yes" xml:space="preserve">
          <source>The src/ directory holds source code. The path below 'src' determines the import path or executable name.</source>
          <target state="translated">В каталоге src/хранится исходный код.Путь под 'src' определяет путь импорта или имя исполняемого файла.</target>
        </trans-unit>
        <trans-unit id="51fce287253a04b9aa4e50fe0cda26970eb0eeca" translate="yes" xml:space="preserve">
          <source>The statements prepared for a transaction by calling the transaction's Prepare or Stmt methods are closed by the call to Commit or Rollback.</source>
          <target state="translated">Выписки,подготовленные для сделки путем вызова методов Prepare или Stmt сделки,закрываются путем вызова методов Commit или Rollback.</target>
        </trans-unit>
        <trans-unit id="7aaae34f98e3bd969409b9d4ab9b72c26d296745" translate="yes" xml:space="preserve">
          <source>The stop function releases resources associated with it, so code should call stop as soon as the operations running in this Context complete and signals no longer need to be diverted to the context.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e3f26a83995cf9b083b94337323c62f8d2e679a" translate="yes" xml:space="preserve">
          <source>The stop function unregisters the signal behavior, which, like signal.Reset, may restore the default behavior for a given signal. For example, the default behavior of a Go program receiving os.Interrupt is to exit. Calling NotifyContext(parent, os.Interrupt) will change the behavior to cancel the returned context. Future interrupts received will not trigger the default (exit) behavior until the returned stop function is called.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="266ee83c3a485624a9ce3be711986c42904d65df" translate="yes" xml:space="preserve">
          <source>The swap operation, implemented by the SwapT functions, is the atomic equivalent of:</source>
          <target state="translated">Операция подкачки,реализованная функциями SwapT,является атомным эквивалентом:</target>
        </trans-unit>
        <trans-unit id="78109ee602f829fc62630aa0958e0668bde1d9d0" translate="yes" xml:space="preserve">
          <source>The symbolizer function may be nil, in which case the results of the traceback function will be displayed as numbers. If the traceback function is nil, the symbolizer function will never be called. The context function may be nil, in which case the traceback function will only be called with the context field set to zero. If the context function is nil, then calls from Go to C to Go will not show a traceback for the C portion of the call stack.</source>
          <target state="translated">Функция символизатора может быть нулевой,в этом случае результаты работы функции трассировки будут отображаться в виде чисел.Если функция обратной связи равна нулю,то функция символизатора никогда не будет вызвана.Контекстная функция может быть равна нулю,в этом случае функция обратной связи будет вызываться только при установленном нулевом значении контекстного поля.Если значение контекстной функции равно нулю,то при вызове функции Обратная связь для C части стека вызовов не будет отображаться.</target>
        </trans-unit>
        <trans-unit id="7f3f65f4777096791e56d64b25eeec76abb44bfa" translate="yes" xml:space="preserve">
          <source>The symbolizer function will be called with a single argument, a pointer to a struct:</source>
          <target state="translated">Функция символизатора будет вызвана с единственным аргументом-указателем на структуру:</target>
        </trans-unit>
        <trans-unit id="826b161e82b6e953fc66964167887f9fb128e89d" translate="yes" xml:space="preserve">
          <source>The syntax of such definitions is to surround each template declaration with a &quot;define&quot; and &quot;end&quot; action.</source>
          <target state="translated">Синтаксис таких определений заключается в том,чтобы окружить каждую шаблонную декларацию действием &quot;определить&quot; и &quot;завершить&quot;.</target>
        </trans-unit>
        <trans-unit id="a896d242a72cd56df044b310d3d7e48636436044" translate="yes" xml:space="preserve">
          <source>The syntax of the regular expressions accepted is the same general syntax used by Perl, Python, and other languages. More precisely, it is the syntax accepted by RE2 and described at &lt;a href=&quot;https://golang.org/s/re2syntax&quot;&gt;https://golang.org/s/re2syntax&lt;/a&gt;, except for \C. For an overview of the syntax, run</source>
          <target state="translated">Синтаксис принятых регулярных выражений - тот же общий синтаксис, который используется Perl, Python и другими языками. Точнее, это синтаксис, принятый RE2 и описанный на &lt;a href=&quot;https://golang.org/s/re2syntax&quot;&gt;https://golang.org/s/re2syntax&lt;/a&gt; , за исключением \ C. Для обзора синтаксиса запустите</target>
        </trans-unit>
        <trans-unit id="ba2393e2ef8002ea106da87efa718a59742fc7ac" translate="yes" xml:space="preserve">
          <source>The syslog package is frozen and is not accepting new features. Some external packages provide more functionality. See:</source>
          <target state="translated">Пакет syslog заморожен и не принимает новых функций.Некоторые внешние пакеты предоставляют больше функциональности.Смотрите:</target>
        </trans-unit>
        <trans-unit id="99e701177eab165c110f7e05395c5e3f3462fc8b" translate="yes" xml:space="preserve">
          <source>The table's lower portion shows specialized features of each format, such as supported string encodings, support for sub-second timestamps, or support for sparse files.</source>
          <target state="translated">В нижней части таблицы показаны специализированные функции каждого формата,такие как поддерживаемые строковые кодировки,поддержка субсекундных меток времени или поддержка разреженных файлов.</target>
        </trans-unit>
        <trans-unit id="e6cfcc2895da4e068fb4279dd7ba0aaf57b5ca4f" translate="yes" xml:space="preserve">
          <source>The table's upper portion shows the Header fields, where each format reports the maximum number of bytes allowed for each string field and the integer type used to store each numeric field (where timestamps are stored as the number of seconds since the Unix epoch).</source>
          <target state="translated">В верхней части таблицы отображаются поля заголовка,где каждый формат сообщает максимальное количество байт,допустимое для каждого строкового поля,и целочисленный тип,используемый для хранения каждого числового поля (где метки времени хранятся в виде количества секунд с эпохи Unix).</target>
        </trans-unit>
        <trans-unit id="b0a984b621ec68366c5b1261f609a8ab7bb45ea3" translate="yes" xml:space="preserve">
          <source>The tag must be one that takes string values: DT_NEEDED, DT_SONAME, DT_RPATH, or DT_RUNPATH.</source>
          <target state="translated">Тэг должен быть таким,который принимает строковые значения:DT_NEEDED,DT_SONAME,DT_RPATH или DT_RUNPATH.</target>
        </trans-unit>
        <trans-unit id="cbe588a5ff1a44ccc9c3b05cfac0b378253441ae" translate="yes" xml:space="preserve">
          <source>The target is the RFC 7230 &quot;request-target&quot;: it may be either a path or an absolute URL. If target is an absolute URL, the host name from the URL is used. Otherwise, &quot;example.com&quot; is used.</source>
          <target state="translated">Целью является RFC 7230 &quot;запрос-цель&quot;:это может быть как путь,так и абсолютный URL.Если целевой является абсолютным URL,используется имя хоста из URL.В противном случае используется &quot;example.com&quot;.</target>
        </trans-unit>
        <trans-unit id="a6f845f916ddb97993362899697ada283b05c4e3" translate="yes" xml:space="preserve">
          <source>The taskType is used to classify task instances. Analysis tools like the Go execution tracer may assume there are only a bounded number of unique task types in the system.</source>
          <target state="translated">TaskType используется для классификации экземпляров задач.Инструменты анализа,такие как трассировщик выполнения Go,могут предполагать,что в системе существует только ограниченное количество уникальных типов задач.</target>
        </trans-unit>
        <trans-unit id="87c98cdec407269913a37379692f0119d00836f4" translate="yes" xml:space="preserve">
          <source>The template</source>
          <target state="translated">Шаблон</target>
        </trans-unit>
        <trans-unit id="8dbf1659d9b474dfc6de39448622e749ace9eba6" translate="yes" xml:space="preserve">
          <source>The testing/quick package is frozen and is not accepting new features.</source>
          <target state="translated">Пакет &quot;Тестирование/быстрота&quot; заморожен и не принимает новых функций.</target>
        </trans-unit>
        <trans-unit id="450bac070fc3c1d570ed998a1290dd681976d259" translate="yes" xml:space="preserve">
          <source>The text returned from ReadLine does not include the line end (&quot;\r\n&quot; or &quot;\n&quot;). No indication or error is given if the input ends without a final line end. Calling UnreadByte after ReadLine will always unread the last byte read (possibly a character belonging to the line end) even if that byte is not part of the line returned by ReadLine.</source>
          <target state="translated">Текст,возвращаемый из ReadLine,не включает конец строки (&quot;\r\n&quot; или &quot;\n&quot;).Никаких указаний или ошибок не дается,если входной текст заканчивается без конечного конца строки.Вызов UnreadByte после ReadLine всегда будет считать последний прочитанный байт (возможно,символ,принадлежащий концу строки),даже если этот байт не является частью строки,возвращенной ReadLine.</target>
        </trans-unit>
        <trans-unit id="e19ad8a62ebb2f930cd2d412533e63ab163f9e7f" translate="yes" xml:space="preserve">
          <source>The text/tabwriter package is frozen and is not accepting new features.</source>
          <target state="translated">Текстовый/табрайдерский пакет заморожен и не принимает новых функций.</target>
        </trans-unit>
        <trans-unit id="b8b4c6c4010154e59471f9dc5acececde45e4c79" translate="yes" xml:space="preserve">
          <source>The time zone database needed by LoadLocation may not be present on all systems, especially non-Unix systems. LoadLocation looks in the directory or uncompressed zip file named by the ZONEINFO environment variable, if any, then looks in known installation locations on Unix systems, and finally looks in $GOROOT/lib/time/zoneinfo.zip.</source>
          <target state="translated">База данных часовых поясов,необходимая для LoadLocation,может присутствовать не на всех системах,особенно не на Unix-системах.LoadLocation ищет в каталоге или несжатом zip-файле,названном переменной окружения ZONEINFO,если она есть,затем ищет в известных местах установки на Unix-системах,и,наконец,ищет в $GOROOT/lib/time/zoneinfo.zip.</target>
        </trans-unit>
        <trans-unit id="d9d95ea8fa35077316d58a8c096d78c878d9e8de" translate="yes" xml:space="preserve">
          <source>The timeout includes name resolution, if required. When using TCP, and the host in the address parameter resolves to multiple IP addresses, the timeout is spread over each consecutive dial, such that each is given an appropriate fraction of the time to connect.</source>
          <target state="translated">Тайм-аут включает в себя,при необходимости,разрешение имен.При использовании TCP,и хост в параметре адреса разрешается на несколько IP-адресов,таймаут распределяется по каждому последовательному набору,так что каждому из них дается соответствующая доля времени на соединение.</target>
        </trans-unit>
        <trans-unit id="1be65b230e905dbffd21fbadb56320938e08062d" translate="yes" xml:space="preserve">
          <source>The tools that process the memory profiles assume that the profile rate is constant across the lifetime of the program and equal to the current value. Programs that change the memory profiling rate should do so just once, as early as possible in the execution of the program (for example, at the beginning of main).</source>
          <target state="translated">Инструменты,обрабатывающие профили памяти,предполагают,что скорость профиля постоянна в течение всего времени жизни программы и равна текущему значению.Программы,изменяющие скорость профилирования памяти,должны делать это всего один раз,как можно раньше на этапе исполнения программы (например,в начале основного).</target>
        </trans-unit>
        <trans-unit id="1a177d1df849e44bddcb9ba4d4be3d9812f21f16" translate="yes" xml:space="preserve">
          <source>The trace tool computes the latency of a task by measuring the time between the task creation and the task end and provides latency distributions for each task type found in the trace.</source>
          <target state="translated">Инструмент трассировки вычисляет латентность задачи,измеряя время между созданием задачи и ее концом,и обеспечивает распределение латентности для каждого типа задачи,найденного в трассе.</target>
        </trans-unit>
        <trans-unit id="62d0bac03a171fb89c5dd19570b301f5442565f7" translate="yes" xml:space="preserve">
          <source>The traceback and context functions may be called from a signal handler, and must therefore use only async-signal safe functions. The symbolizer function may be called while the program is crashing, and so must be cautious about using memory. None of the functions may call back into Go.</source>
          <target state="translated">Обратная связь и контекстные функции могут вызываться обработчиком сигналов и поэтому должны использовать только функции безопасности асинхронных сигналов.Функция символизатора может быть вызвана во время аварийного завершения работы программы,поэтому следует с осторожностью относиться к использованию памяти.Ни одна из функций не может быть вызвана обратно в Go.</target>
        </trans-unit>
        <trans-unit id="64b5d618701b94606e91495371f70fb5b100120e" translate="yes" xml:space="preserve">
          <source>The traceback function will be called with a single argument, a pointer to a struct:</source>
          <target state="translated">Функция трассировки будет вызвана с единственным аргументом,указателем на структуру:</target>
        </trans-unit>
        <trans-unit id="fbcd1af40286bdefbe9605ee1269e5d70a141d29" translate="yes" xml:space="preserve">
          <source>The two methods Network and String conventionally return strings that can be passed as the arguments to Dial, but the exact form and meaning of the strings is up to the implementation.</source>
          <target state="translated">Два метода Network и String условно возвращают строки,которые могут быть переданы в качестве аргументов для Dial,но точная форма и значение строк зависит от реализации.</target>
        </trans-unit>
        <trans-unit id="ee1fff48d57b4264c60df5732fa6d287858ca513" translate="yes" xml:space="preserve">
          <source>The typ argument may be a defined (Named) type or an alias type. It may also be nil such that the returned TypeName can be used as argument for NewNamed, which will set the TypeName's type as a side- effect.</source>
          <target state="translated">Аргументом типа может быть определенный (именованный)тип или тип псевдонима.Он также может быть нулевым,чтобы возвращаемое имя типа могло быть использовано в качестве аргумента для NewNamed,который будет устанавливать тип TypeName в качестве побочного эффекта.</target>
        </trans-unit>
        <trans-unit id="626d44cfd72353f5912709705dc90b7455988913" translate="yes" xml:space="preserve">
          <source>The type of the variable must be a string type, or a slice of a byte type, or FS (or an alias of FS).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="761242af94989502320341408ab25169d28b2151" translate="yes" xml:space="preserve">
          <source>The typical use case for NewFileTransport is to register the &quot;file&quot; protocol with a Transport, as in:</source>
          <target state="translated">Типичным случаем использования NewFileTransport является регистрация &quot;файлового&quot; протокола на Transport,как в случае с NewFileTransport:</target>
        </trans-unit>
        <trans-unit id="c9dec8fd9ff2613dd03956d5301652519fcaec0c" translate="yes" xml:space="preserve">
          <source>The underlying filesystem may truncate or round the values to a less precise time unit. If there is an error, it will be of type *PathError.</source>
          <target state="translated">Базовая файловая система может усекать или округлять значения до менее точной единицы времени.В случае ошибки она будет иметь тип *PathError.</target>
        </trans-unit>
        <trans-unit id="bc08db1aae610f1545a452a1bb5a7582597ab3b7" translate="yes" xml:space="preserve">
          <source>The usage message will appear on a separate line for anything but a bool flag with a one-byte name. For bool flags, the type is omitted and if the flag name is one byte the usage message appears on the same line. The parenthetical default is omitted if the default is the zero value for the type. The listed type, here int, can be changed by placing a back-quoted name in the flag's usage string; the first such item in the message is taken to be a parameter name to show in the message and the back quotes are stripped from the message when displayed. For instance, given</source>
          <target state="translated">Сообщение об использовании появится в отдельной строке для чего угодно,кроме флага bool с однобайтовым именем.Для флагов bool тип опускается,а если имя флага однобайтовое,то сообщение об использовании появится в той же строке.Кодовое значение по умолчанию опускается,если по умолчанию это нулевое значение для типа.Перечисленный тип,здесь int,может быть изменён путём помещения в строку использования флага имени в обратной кавычке;первым таким элементом в сообщении считается имя параметра для отображения в сообщении,а обратные кавычки убираются из сообщения при отображении.Например,учитывая</target>
        </trans-unit>
        <trans-unit id="7175f6a7da0429173b6be919d1c9513e0498e3e7" translate="yes" xml:space="preserve">
          <source>The value 0xff was chosen because it cannot appear in a valid UTF-8 sequence.</source>
          <target state="translated">Значение 0xff было выбрано потому,что оно не может появиться в действительной последовательности UTF-8.</target>
        </trans-unit>
        <trans-unit id="e4328a7e24cd2970818970fe425c0b1b3c86f9d7" translate="yes" xml:space="preserve">
          <source>The variadic argument controls whether the function is variadic. FuncOf panics if the in[len(in)-1] does not represent a slice and variadic is true.</source>
          <target state="translated">Вариадический аргумент контролирует,является ли функция вариадической.FuncOf паникует,если in[len(in)-1]не представляет срез,а вариадический является верным.</target>
        </trans-unit>
        <trans-unit id="1e72c26ccaadcb98e76249dcd1c8f3cdb175e9de" translate="yes" xml:space="preserve">
          <source>The varint functions encode and decode single integer values using a variable-length encoding; smaller values require fewer bytes. For a specification, see &lt;a href=&quot;https://developers.google.com/protocol-buffers/docs/encoding&quot;&gt;https://developers.google.com/protocol-buffers/docs/encoding&lt;/a&gt;.</source>
          <target state="translated">Функции varint кодируют и декодируют одиночные целочисленные значения с использованием кодирования переменной длины; меньшие значения требуют меньше байтов. Спецификацию см. На &lt;a href=&quot;https://developers.google.com/protocol-buffers/docs/encoding&quot;&gt;странице https://developers.google.com/protocol-buffers/docs/encoding&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5cdb175715a8f3e26508e589b1b8622549f73fd8" translate="yes" xml:space="preserve">
          <source>The verbs behave analogously to those of Printf. For example, %x will scan an integer as a hexadecimal number, and %v will scan the default representation format for the value. The Printf verbs %p and %T and the flags # and + are not implemented. For floating-point and complex values, all valid formatting verbs (%b %e %E %f %F %g %G %x %X and %v) are equivalent and accept both decimal and hexadecimal notation (for example: &quot;2.3e+7&quot;, &quot;0x4.5p-8&quot;) and digit-separating underscores (for example: &quot;3.14159_26535_89793&quot;).</source>
          <target state="translated">Глаголы ведут себя аналогично глаголам Принтфа.Например,%x будет сканировать целое число как шестнадцатеричное число,а %v будет сканировать значение в формате представления по умолчанию.Глаголы %p и %T в Printf и флаги#и+не реализованы.Для значений с плавающей точкой и комплексных значений все правильные форматирующие глаголы (%b %e %E %f %F %g %G %x %X и %v)эквивалентны и принимают как десятичную,так и шестнадцатеричную нотацию (например:&quot;2.3e+7&quot;,&quot;0x4.5p-8&quot;)и символы подчеркивания,разделенные по разрядам (например:&quot;3.14159_26535_89793&quot;).</target>
        </trans-unit>
        <trans-unit id="a6ebe1343c13ca95e202e147b7f816ef1bc435a4" translate="yes" xml:space="preserve">
          <source>The verbs:</source>
          <target state="translated">Глаголы:</target>
        </trans-unit>
        <trans-unit id="3ce9ac6782ffe3c2b00e6a4b78b2ec7b810f1491" translate="yes" xml:space="preserve">
          <source>The writes of individual records are buffered. After all data has been written, the client should call the Flush method to guarantee all data has been forwarded to the underlying io.Writer. Any errors that occurred should be checked by calling the Error method.</source>
          <target state="translated">Записи отдельных записей буферизируются.После записи всех данных клиент должен обратиться к методу Flush,чтобы гарантировать,что все данные были перенаправлены в соответствующий io.Writer.Любые возникшие ошибки следует проверять путем вызова метода Error.</target>
        </trans-unit>
        <trans-unit id="c7efdce3a929526f7cd0a0a9c837645401afe311" translate="yes" xml:space="preserve">
          <source>The zero (uninitialized) value for a Float is ready to use and represents the number +0.0 exactly, with precision 0 and rounding mode ToNearestEven.</source>
          <target state="translated">Нулевое (неинициализированное)значение для Float готово к использованию и представляет собой число +0.0 точно,с точностью 0 и режимом округления ToNearestEven.</target>
        </trans-unit>
        <trans-unit id="0956e2f948a72c4e4d0d06cd6f921545906690fb" translate="yes" xml:space="preserve">
          <source>The zero Hash is a valid Hash ready to use. A zero Hash chooses a random seed for itself during the first call to a Reset, Write, Seed, Sum64, or Seed method. For control over the seed, use SetSeed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="232f8c7f5eea097cc9451d2d90b51db6b069254d" translate="yes" xml:space="preserve">
          <source>The zero Map is empty and ready for use. A Map must not be copied after first use.</source>
          <target state="translated">Карта нуля пуста и готова к использованию.Нельзя копировать карту после первого использования.</target>
        </trans-unit>
        <trans-unit id="ba5155e1e3916eee99a712d5244dcde8e9982094" translate="yes" xml:space="preserve">
          <source>The zero Value represents no value. Its IsValid method returns false, its Kind method returns Invalid, its String method returns &quot;&amp;lt;invalid Value&amp;gt;&quot;, and all other methods panic. Most functions and methods never return an invalid value. If one does, its documentation states the conditions explicitly.</source>
          <target state="translated">Нулевое значение представляет собой отсутствие значения. Его метод IsValid возвращает false, его метод Kind возвращает Invalid, его метод String возвращает &amp;laquo;&amp;lt;недопустимое значение&amp;gt;&amp;raquo;, а все другие методы вызывают панику. Большинство функций и методов никогда не возвращают недопустимое значение. Если это так, в документации явно указаны условия.</target>
        </trans-unit>
        <trans-unit id="384c750c13afaffcbd5ebf58e8afec2b8768e946" translate="yes" xml:space="preserve">
          <source>The zero value for Pos is NoPos; there is no file and line information associated with it, and NoPos.IsValid() is false. NoPos is always smaller than any other Pos value. The corresponding Position value for NoPos is the zero value for Position.</source>
          <target state="translated">Нулевым значением для Pos является NoPos;с ним не связана информация о файле и строке,а NoPos.IsValid()-false.NoPos всегда меньше любого другого Pos-значения.Соответствующее значение Position для NoPos является нулевым значением для Position.</target>
        </trans-unit>
        <trans-unit id="3f5973e68195ed6a7dd12c4c7dc485f8bde0523d" translate="yes" xml:space="preserve">
          <source>The zero value for an Int, Rat, or Float correspond to 0. Thus, new values can be declared in the usual ways and denote 0 without further initialization:</source>
          <target state="translated">Нулевое значение для Int,Rat или Float соответствует 0.Таким образом,новые значения могут быть объявлены обычным способом и обозначать 0 без дальнейшей инициализации:</target>
        </trans-unit>
        <trans-unit id="5d5aa4f538fd1571e15874ad0969ae7c0fda3040" translate="yes" xml:space="preserve">
          <source>The zero value for each field is equivalent to dialing without that option. Dialing with the zero value of Dialer is therefore equivalent to just calling the Dial function.</source>
          <target state="translated">Нулевое значение для каждого поля эквивалентно набору без этой опции.Поэтому набор с нулевым значением Dialer эквивалентен простому вызову функции Dial.</target>
        </trans-unit>
        <trans-unit id="beb5a289f20083f1018df67115c647d61b968230" translate="yes" xml:space="preserve">
          <source>The zero value of type Time is January 1, year 1, 00:00:00.000000000 UTC. As this time is unlikely to come up in practice, the IsZero method gives a simple way of detecting a time that has not been initialized explicitly.</source>
          <target state="translated">Нулевое значение типа Time-1 января,год 1,00:00:00.000000000 UTC.Поскольку на практике это время вряд ли появится,метод IsZero дает простой способ определения времени,которое не было явно инициализировано.</target>
        </trans-unit>
        <trans-unit id="4752552a303f0f1e8a6bd4b3555705dcb31c63a8" translate="yes" xml:space="preserve">
          <source>Then it can make a remote call:</source>
          <target state="translated">Тогда он может сделать удаленный звонок:</target>
        </trans-unit>
        <trans-unit id="c5d500f53dcbe43654b22f15924d609c47bcfc3c" translate="yes" xml:space="preserve">
          <source>Then use the pprof tool to look at the heap profile:</source>
          <target state="translated">Затем с помощью инструмента pprof посмотрите на профиль кучи:</target>
        </trans-unit>
        <trans-unit id="d249cadab1a19289ed9fd8f524a7048ff9efb13f" translate="yes" xml:space="preserve">
          <source>There are 16 methods of Regexp that match a regular expression and identify the matched text. Their names are matched by this regular expression:</source>
          <target state="translated">Существует 16 методов Regexp,которые соответствуют регулярному выражению и идентифицируют соответствующий текст.Их имена совпадают по этому регулярному выражению:</target>
        </trans-unit>
        <trans-unit id="089af1af9f031a6d4cb36f253f88e22a554b4d75" translate="yes" xml:space="preserve">
          <source>There are many commands available from the pprof command line. Commonly used commands include &quot;top&quot;, which prints a summary of the top program hot-spots, and &quot;web&quot;, which opens an interactive graph of hot-spots and their call graphs. Use &quot;help&quot; for information on all pprof commands.</source>
          <target state="translated">Существует множество команд,доступных из командной строки pprof.Часто используемые команды включают в себя &quot;top&quot;,который печатает сводку о верхних хот-спотах программы,и &quot;web&quot;,который открывает интерактивный график хот-спотов и графиков их вызова.Для получения информации по всем командам pprof используйте &quot;help&quot;.</target>
        </trans-unit>
        <trans-unit id="6fa5b171535b7941feffabcf1c5f915fe3f02940" translate="yes" xml:space="preserve">
          <source>There are no build tags for beta or minor releases.</source>
          <target state="translated">Для бета-и минорных релизов нет тегов сборки.</target>
        </trans-unit>
        <trans-unit id="f4ebe0322e94e23eec9f295ca340080dec64dffd" translate="yes" xml:space="preserve">
          <source>There are three types of user annotations: log messages, regions, and tasks.</source>
          <target state="translated">Существует три типа пользовательских аннотаций:сообщения журнала,регионы и задачи.</target>
        </trans-unit>
        <trans-unit id="311b843be371a8c7fc9f6f81df2189e5f92e44e5" translate="yes" xml:space="preserve">
          <source>There is also a set of binary comparison operators defined as functions:</source>
          <target state="translated">Существует также набор операторов двоичного сравнения,определенных как функции:</target>
        </trans-unit>
        <trans-unit id="5f5077a9bb275171893d0be52e74cbffe4b19888" translate="yes" xml:space="preserve">
          <source>There is also a standard HTTP interface to profiling data. Adding the following line will install handlers under the /debug/pprof/ URL to download live profiles:</source>
          <target state="translated">Существует также стандартный HTTP-интерфейс для профилирования данных.Добавление следующей строки установит обработчики под /debug/pprof/URL для загрузки профилей в реальном времени:</target>
        </trans-unit>
        <trans-unit id="f5962f465f0b5c003c4585058fcce10ec6a63c36" translate="yes" xml:space="preserve">
          <source>There is also a standard HTTP interface to trace data. Adding the following line will install a handler under the /debug/pprof/trace URL to download a live trace:</source>
          <target state="translated">Существует также стандартный HTTP-интерфейс для трассировки данных.Добавление следующей строки установит обработчик под URL /debug/pprof/trace для загрузки живой трассы:</target>
        </trans-unit>
        <trans-unit id="669c09ef6ba443f4e07a76e5e520b09339b0d7ba" translate="yes" xml:space="preserve">
          <source>There is also a subset of the methods that can be applied to text read from a RuneReader:</source>
          <target state="translated">Существует также подмножество методов,которые могут быть применены для чтения текста из RuneReader:</target>
        </trans-unit>
        <trans-unit id="e5e187581cfc7675624afa1252d945d3159b9872" translate="yes" xml:space="preserve">
          <source>There is no mechanism for full case folding, that is, for characters that involve multiple runes in the input or output.</source>
          <target state="translated">Механизм полного сгибания регистров,т.е.для символов,включающих несколько рун на входе или выходе,отсутствует.</target>
        </trans-unit>
        <trans-unit id="4e416754d4e74f38af1b48194c67cf3710f22527" translate="yes" xml:space="preserve">
          <source>These are predefined layouts for use in Time.Format and time.Parse. The reference time used in the layouts is the specific time:</source>
          <target state="translated">Это предопределенные макеты для использования в Time.Format и time.Parse.Справочное время,используемое в макетах-это конкретное время:</target>
        </trans-unit>
        <trans-unit id="622b937b45492ef40cc6c554bb302fd36d24a9dd" translate="yes" xml:space="preserve">
          <source>These are the errors that can be returned in ParseError.Err.</source>
          <target state="translated">Это ошибки,которые могут быть возвращены в ParseError.Err.</target>
        </trans-unit>
        <trans-unit id="df2271a2f22e4450d78c23577801038a703976de" translate="yes" xml:space="preserve">
          <source>These assume decimal and the Go int type.</source>
          <target state="translated">Они предполагают десятичное число и тип Go int.</target>
        </trans-unit>
        <trans-unit id="e44cf0ddaa746164e3256589314495380a8d22a3" translate="yes" xml:space="preserve">
          <source>These constants are copied from the flate package, so that code that imports &quot;compress/gzip&quot; does not also have to import &quot;compress/flate&quot;.</source>
          <target state="translated">Эти константы копируются из флат-пакета,так что код,который импортирует &quot;сжимать/сжимать&quot;,также не должен импортировать &quot;сжимать/сжимать&quot;.</target>
        </trans-unit>
        <trans-unit id="9b53ffb7fd51347180d120a25b5986ecdfdf8a40" translate="yes" xml:space="preserve">
          <source>These constants are copied from the flate package, so that code that imports &quot;compress/zlib&quot; does not also have to import &quot;compress/flate&quot;.</source>
          <target state="translated">Эти константы копируются из флат-пакета,так что код,который импортирует &quot;сжимать/сжимать&quot;,также не должен импортировать &quot;сжимать/сжимать&quot;.</target>
        </trans-unit>
        <trans-unit id="a6caaf07cd62c3bce0c1d44802c32e939959f7c6" translate="yes" xml:space="preserve">
          <source>These constants cause FlagSet.Parse to behave as described if the parse fails.</source>
          <target state="translated">Эти константы приводят к тому,что FlagSet.Parse ведет себя так,как описано в случае неудачи при разборе.</target>
        </trans-unit>
        <trans-unit id="c3e135e518f3071cd6e6de5ee8eb8509897ca8e4" translate="yes" xml:space="preserve">
          <source>These constants define supported rounding modes.</source>
          <target state="translated">Эти константы определяют поддерживаемые режимы округления.</target>
        </trans-unit>
        <trans-unit id="e9b81d06567b4f6ea4a134b77b7d8d68b11092d0" translate="yes" xml:space="preserve">
          <source>These examples demonstrate the basics of printing using a format string. Printf, Sprintf, and Fprintf all take a format string that specifies how to format the subsequent arguments. For example, %d (we call that a 'verb') says to print the corresponding argument, which must be an integer (or something containing an integer, such as a slice of ints) in decimal. The verb %v ('v' for 'value') always formats the argument in its default form, just how Print or Println would show it. The special verb %T ('T' for 'Type') prints the type of the argument rather than its value. The examples are not exhaustive; see the package comment for all the details.</source>
          <target state="translated">Эти примеры демонстрируют основы печати с использованием строки форматирования.Printf,Sprintf и Fprintf берут строку форматирования,которая определяет,как форматировать последующие аргументы.Например,%d (мы называем это 'глаголом')говорит,что нужно вывести соответствующий аргумент,который должен быть целым числом (или чем-то,содержащим целое число,например,кусок чернил)в десятичной дроби.Глагол %v ('v' для 'value')всегда форматирует аргумент в его стандартном виде,как его выводит Print или Println.Специальный глагол %T ('T' для 'Type')выводит тип аргумента,а не его значение.Примеры не являются исчерпывающими;подробности см.в комментарии к пакету.</target>
        </trans-unit>
        <trans-unit id="1b31c3c54ac0eb3ff04d00595a12fb566e8fcf7e" translate="yes" xml:space="preserve">
          <source>These flags define which text to prefix to each log entry generated by the Logger. Bits are or'ed together to control what's printed. There is no control over the order they appear (the order listed here) or the format they present (as described in the comments). The prefix is followed by a colon only when Llongfile or Lshortfile is specified. For example, flags Ldate | Ltime (or LstdFlags) produce,</source>
          <target state="translated">Эти флаги определяют,какой текст префиксовать к каждой записи журнала,сгенерированной Журналером.Биты редактируются или редактируются вместе,чтобы контролировать то,что распечатывается.Нет никакого контроля над порядком их появления (порядок,указанный здесь)или форматом,в котором они представлены (как описано в комментариях).За префиксом следует двоеточие только при указании Llongfile или Lshortfile.Например,флаги Ldate | Ltime (или LstdFlags)производят,</target>
        </trans-unit>
        <trans-unit id="eab8374633319fa49ea516b7b757172cc6a3ee35" translate="yes" xml:space="preserve">
          <source>These flags define which text to prefix to each log entry generated by the Logger. Bits are or'ed together to control what's printed. With the exception of the Lmsgprefix flag, there is no control over the order they appear (the order listed here) or the format they present (as described in the comments). The prefix is followed by a colon only when Llongfile or Lshortfile is specified. For example, flags Ldate | Ltime (or LstdFlags) produce,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc9914d5780e96c178ba8969a057705144577da8" translate="yes" xml:space="preserve">
          <source>These functions are also compatible with the &amp;ldquo;Ed25519&amp;rdquo; function defined in RFC 8032. However, unlike RFC 8032's formulation, this package's private key representation includes a public key suffix to make multiple signing operations with the same key more efficient. This package refers to the RFC 8032 private key as the &amp;ldquo;seed&amp;rdquo;.</source>
          <target state="translated">Эти функции также совместимы с функцией &amp;laquo;Ed25519&amp;raquo;, определенной в RFC 8032. Однако, в отличие от формулировки RFC 8032, представление закрытого ключа этого пакета включает суффикс открытого ключа, чтобы сделать несколько операций подписи одним и тем же ключом более эффективными. Этот пакет называет закрытый ключ RFC 8032 &amp;laquo;начальным числом&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="2034a99a91b57c3247261a1a8004621e6e0c4e1f" translate="yes" xml:space="preserve">
          <source>These functions require great care to be used correctly. Except for special, low-level applications, synchronization is better done with channels or the facilities of the sync package. Share memory by communicating; don't communicate by sharing memory.</source>
          <target state="translated">Эти функции требуют большой осторожности для их правильного использования.За исключением специальных низкоуровневых приложений,синхронизацию лучше осуществлять с каналами или средствами пакета синхронизации.Делитесь памятью,общаясь;не общайтесь,делясь памятью.</target>
        </trans-unit>
        <trans-unit id="54aa9a67852a83f3350017dd1b9500c555360772" translate="yes" xml:space="preserve">
          <source>These packages are part of the Go Project but outside the main Go tree. They are developed under looser &lt;a href=&quot;https://golang.org/doc/go1compat&quot;&gt;compatibility requirements&lt;/a&gt; than the Go core. Install them with &quot;&lt;a href=&quot;https://golang.org/cmd/go/#hdr-Download_and_install_packages_and_dependencies&quot;&gt;go get&lt;/a&gt;&quot;.</source>
          <target state="translated">Эти пакеты являются частью проекта Go, но не входят в основное дерево Go. Они разработаны с более &lt;a href=&quot;https://golang.org/doc/go1compat&quot;&gt;низкими требованиями к совместимости,&lt;/a&gt; чем ядро ​​Go. Установите их с помощью команды &amp;laquo; &lt;a href=&quot;https://golang.org/cmd/go/#hdr-Download_and_install_packages_and_dependencies&quot;&gt;иди и получи&lt;/a&gt; &amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="07168c583c59c9cae9d4bb3facc94a52fb2a21e9" translate="yes" xml:space="preserve">
          <source>These predefined profiles maintain themselves and panic on an explicit Add or Remove method call.</source>
          <target state="translated">Эти предопределенные профили поддерживают себя и паникуют при явном вызове метода Add or Remove.</target>
        </trans-unit>
        <trans-unit id="8dc4875980e26530686b9e8a46a4183aeaf7943d" translate="yes" xml:space="preserve">
          <source>These services can help you find Open Source packages provided by the community.</source>
          <target state="translated">Эти сервисы могут помочь вам найти пакеты с открытым исходным кодом,предоставляемые сообществом.</target>
        </trans-unit>
        <trans-unit id="6ba17173fd7e73d9151d0d7cdef890f5dd3a0a3f" translate="yes" xml:space="preserve">
          <source>These three formatting routines call the Qualifier for each package-level object O, and if the Qualifier returns a non-empty string p, the object is printed in the form p.O. If it returns an empty string, only the object name O is printed.</source>
          <target state="translated">Эти три процедуры форматирования вызывают Qualifier для каждого объекта на уровне пакетов O,и если Qualifier возвращает непустую строку p,то объект выводится в виде p.O.Если возвращает пустую строку,то выводится только имя объекта O.</target>
        </trans-unit>
        <trans-unit id="2207cae6c61d669eed106af825a6dce66aef87d1" translate="yes" xml:space="preserve">
          <source>These variables have type *RangeTable.</source>
          <target state="translated">Эти переменные имеют тип *RangeTable.</target>
        </trans-unit>
        <trans-unit id="610a8603a5a8aeac74a533f57b0c5eb7122b7d43" translate="yes" xml:space="preserve">
          <source>This cannot be done concurrent to other receives from the Timer's channel or other calls to the Timer's Stop method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1166cbd43d7ca0f544abde3cc256ae8afc9cd0b1" translate="yes" xml:space="preserve">
          <source>This cannot be done concurrent to other receives from the Timer's channel.</source>
          <target state="translated">Это не может быть сделано одновременно с другими приемами из канала Таймера.</target>
        </trans-unit>
        <trans-unit id="b00ff4b1fd4c120a5db60ce99d175dd291630987" translate="yes" xml:space="preserve">
          <source>This declares an integer flag, -flagname, stored in the pointer ip, with type *int.</source>
          <target state="translated">Объявляется целочисленный флаг -flagname,хранящийся в указателе ip,с типом *int.</target>
        </trans-unit>
        <trans-unit id="f1681bf43fc257c44b551cfb0077dc2be75b4283" translate="yes" xml:space="preserve">
          <source>This declares an integer flag, -n, stored in the pointer nFlag, with type *int:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="631f1841cf17bb7db8a22b0767e5099ebe5b8b09" translate="yes" xml:space="preserve">
          <source>This defines two templates, T1 and T2, and a third T3 that invokes the other two when it is executed. Finally it invokes T3. If executed this template will produce the text</source>
          <target state="translated">Это определяет два шаблона,T1 и T2,и третий T3,который вызывает два других при выполнении.Наконец,он вызывает T3.Если этот шаблон будет выполнен,то будет выдан текст</target>
        </trans-unit>
        <trans-unit id="07be652fe77b2bc1e633b76695cc662deba999dd" translate="yes" xml:space="preserve">
          <source>This example creates a PriorityQueue with some items, adds and manipulates an item, and then removes the items in priority order.</source>
          <target state="translated">В этом примере создается инструмент PriorityQueue с некоторыми элементами,добавляется и манипулируется элементом,а затем удаляется элемент в порядке приоритета.</target>
        </trans-unit>
        <trans-unit id="11e8e47e8373159f24438e9584e5f85d6b5441f2" translate="yes" xml:space="preserve">
          <source>This example demonstrates a custom function to process template text. It installs the strings.Title function and uses it to Make Title Text Look Good In Our Template's Output.</source>
          <target state="translated">В данном примере демонстрируется пользовательская функция для обработки текста шаблона.Она устанавливает функцию string.Title и использует ее для того,чтобы заголовок текста выглядел хорошо в выводе нашего шаблона.</target>
        </trans-unit>
        <trans-unit id="dfa54d108334a66ba7ab5757d71b4364db5ae271" translate="yes" xml:space="preserve">
          <source>This example demonstrates how a value can be passed to the context and also how to retrieve it if it exists.</source>
          <target state="translated">Этот пример демонстрирует,как значение может быть передано в контекст,а также как получить его,если оно существует.</target>
        </trans-unit>
        <trans-unit id="cbed8edb3aa3c802bdc2c523c3a0a851457324e3" translate="yes" xml:space="preserve">
          <source>This example demonstrates how to inspect the AST of a Go program.</source>
          <target state="translated">Этот пример демонстрирует,как осмотреть программу AST of a Go.</target>
        </trans-unit>
        <trans-unit id="165d3019bf668cef6d1995c8165503ac097763bd" translate="yes" xml:space="preserve">
          <source>This example demonstrates how to use big.Int to compute the smallest Fibonacci number with 100 decimal digits and to test whether it is prime.</source>
          <target state="translated">Этот пример демонстрирует,как использовать big.Int для вычисления наименьшего числа Фибоначчи со 100 знаками после запятой и для проверки,является ли оно простым.</target>
        </trans-unit>
        <trans-unit id="0059484fefd6cd0e894a9be3837a0c3c538eda17" translate="yes" xml:space="preserve">
          <source>This example demonstrates how to use big.Rat to compute the first 15 terms in the sequence of rational convergents for the constant e (base of natural logarithm).</source>
          <target state="translated">Этот пример демонстрирует,как использовать big.Rat для вычисления первых 15 членов в последовательности рациональных схождений для константы e (базы натурального логарифма).</target>
        </trans-unit>
        <trans-unit id="b29080504869eb07c938bd169b02dbf661e6a627" translate="yes" xml:space="preserve">
          <source>This example demonstrates how to use one group of driver templates with distinct sets of helper templates.</source>
          <target state="translated">Данный пример демонстрирует,как использовать одну группу шаблонов драйверов с различными наборами шаблонов хелперов.</target>
        </trans-unit>
        <trans-unit id="ba0650f40679135f634bca363681740adeafe34a" translate="yes" xml:space="preserve">
          <source>This example demonstrates one way to share some templates and use them in different contexts. In this variant we add multiple driver templates by hand to an existing bundle of templates.</source>
          <target state="translated">Этот пример демонстрирует один из способов обмена некоторыми шаблонами и их использования в различных контекстах.В этом варианте мы вручную добавляем несколько шаблонов драйверов к существующему набору шаблонов.</target>
        </trans-unit>
        <trans-unit id="0ba078883e861f3b147ecf053f6c06d8a3174cd3" translate="yes" xml:space="preserve">
          <source>This example demonstrates searching a list sorted in ascending order.</source>
          <target state="translated">Этот пример демонстрирует поиск списка,отсортированного по возрастанию.</target>
        </trans-unit>
        <trans-unit id="7888c65ff5bdcbe2c823d7d7283ee2975bf6366b" translate="yes" xml:space="preserve">
          <source>This example demonstrates searching a list sorted in descending order. The approach is the same as searching a list in ascending order, but with the condition inverted.</source>
          <target state="translated">Этот пример демонстрирует поиск списка,отсортированного в порядке убывания.Подход такой же,как и при поиске списка в порядке возрастания,но с перевернутым условием.</target>
        </trans-unit>
        <trans-unit id="2db6a343e7f8129baf91fac5d3ebedf3e8666279" translate="yes" xml:space="preserve">
          <source>This example demonstrates the use of a cancelable context to prevent a goroutine leak. By the end of the example function, the goroutine started by gen will return without leaking.</source>
          <target state="translated">Этот пример демонстрирует использование отменяемого контекста для предотвращения утечки горутина.К концу функции примера горутин,запущенный по гену,вернется без утечки.</target>
        </trans-unit>
        <trans-unit id="f5ede30ffc3c68340a6fb2445f68975fd1d677b3" translate="yes" xml:space="preserve">
          <source>This example demonstrates unmarshaling an XML excerpt into a value with some preset fields. Note that the Phone field isn't modified and that the XML &amp;lt;Company&amp;gt; element is ignored. Also, the Groups field is assigned considering the element path provided in its tag.</source>
          <target state="translated">В этом примере демонстрируется преобразование фрагмента XML в значение с некоторыми предустановленными полями. Обратите внимание, что поле &amp;laquo;Телефон&amp;raquo; не изменяется, а элемент XML &amp;lt;Company&amp;gt; игнорируется. Кроме того, поле Группы назначается с учетом пути элемента, указанного в его теге.</target>
        </trans-unit>
        <trans-unit id="363362d5c2e9f91c6b9857ffd69fe714bafa9ced" translate="yes" xml:space="preserve">
          <source>This example fetches several URLs concurrently, using a WaitGroup to block until all the fetches are complete.</source>
          <target state="translated">Этот пример извлекает несколько URL одновременно,используя WaitGroup для блокировки до тех пор,пока все извлечения не будут завершены.</target>
        </trans-unit>
        <trans-unit id="06701ebad78061b44ebf3ff359db4a889929ed4c" translate="yes" xml:space="preserve">
          <source>This example illustrates how to remove a variable declaration in a Go program while maintaining correct comment association using an ast.CommentMap.</source>
          <target state="translated">Этот пример иллюстрирует,как удалить объявление переменной в программе Go,сохраняя при этом корректную ассоциацию комментариев,с помощью программы ast.CommentMap.</target>
        </trans-unit>
        <trans-unit id="5b8dbce47ef4472e55b03e0ab77f57e1bbd03498" translate="yes" xml:space="preserve">
          <source>This example illustrates how to use NewFromFiles to compute package documentation with examples.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a88fa5b5d7ed0c65b753c3fe2d8b6cdc87e0d250" translate="yes" xml:space="preserve">
          <source>This example inserts several ints into an IntHeap, checks the minimum, and removes them in order of priority.</source>
          <target state="translated">В этом примере вставляется несколько дюймов в IntHeap,проверяется минимум,и удаляются в порядке приоритета.</target>
        </trans-unit>
        <trans-unit id="6720a93331216084a88085596ce48ea8bc49ea13" translate="yes" xml:space="preserve">
          <source>This example passes a context with a signal to tell a blocking function that it should abandon its work after a signal is received.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e36be68d73234a9e2fb853054688b98fefd0444d" translate="yes" xml:space="preserve">
          <source>This example passes a context with a timeout to tell a blocking function that it should abandon its work after the timeout elapses.</source>
          <target state="translated">В этом примере передается контекст с таймаутом,чтобы сообщить блокирующей функции,что она должна прекратить свою работу по истечении таймаута.</target>
        </trans-unit>
        <trans-unit id="eac2b4a123d3756695f2f19424362998d49962a1" translate="yes" xml:space="preserve">
          <source>This example passes a context with an arbitrary deadline to tell a blocking function that it should abandon its work as soon as it gets to it.</source>
          <target state="translated">В этом примере передается контекст с произвольным сроком,чтобы сообщить блокирующей функции,что она должна прекратить свою работу,как только доберется до нее.</target>
        </trans-unit>
        <trans-unit id="df7ace59807aa52b6b44602449d158b9635a420e" translate="yes" xml:space="preserve">
          <source>This example reads 10 cryptographically secure pseudorandom numbers from rand.Reader and writes them to a byte slice.</source>
          <target state="translated">Этот пример читает 10 криптографически безопасных псевдослучайных чисел из rand.Reader и записывает их в байтовый срез.</target>
        </trans-unit>
        <trans-unit id="d0f63cae6959df0e63ff45ed07152e8d354e9432" translate="yes" xml:space="preserve">
          <source>This example shows how csv.Reader can be configured to handle other types of CSV files.</source>
          <target state="translated">В этом примере показано,как csv.Reader можно настроить для работы с другими типами CSV-файлов.</target>
        </trans-unit>
        <trans-unit id="1cca172f7759e3ba0050255d1746af87f660b76a" translate="yes" xml:space="preserve">
          <source>This example shows how to encode an interface value. The key distinction from regular types is to register the concrete type that implements the interface.</source>
          <target state="translated">В этом примере показано,как кодировать значение интерфейса.Ключевым отличием от обычных типов является регистрация конкретного типа,реализующего интерфейс.</target>
        </trans-unit>
        <trans-unit id="a3357a230dfc48b693b3b94d9c6611698fcf1171" translate="yes" xml:space="preserve">
          <source>This example shows how to use big.Float to compute the square root of 2 with a precision of 200 bits, and how to print the result as a decimal number.</source>
          <target state="translated">Этот пример показывает,как использовать big.Float для вычисления квадратного корня из 2 с точностью до 200 бит,и как распечатать результат в виде десятичного числа.</target>
        </trans-unit>
        <trans-unit id="efe429413e771069e2a76db974f921ef42dbdd60" translate="yes" xml:space="preserve">
          <source>This example shows the basic usage of the package: Create an encoder, transmit some values, receive them with a decoder.</source>
          <target state="translated">В данном примере показано основное использование пакета:Создать кодировщик,передать некоторые значения,получить их с помощью декодера.</target>
        </trans-unit>
        <trans-unit id="4e20892924831ca17c2f745e5365e20b64d74b0e" translate="yes" xml:space="preserve">
          <source>This example shows the use of each of the methods on a *Rand. The use of the global functions is the same, without the receiver.</source>
          <target state="translated">Этот пример показывает использование каждого из методов в *Rand.Использование глобальных функций одинаково,без приемника.</target>
        </trans-unit>
        <trans-unit id="9dae51dea551843f94a869c5f0aec8bf68e765cc" translate="yes" xml:space="preserve">
          <source>This example shows what an AST looks like when printed for debugging.</source>
          <target state="translated">Этот пример показывает,как выглядит AST при печати для отладки.</target>
        </trans-unit>
        <trans-unit id="3d4d87b6b74c64cd8a077a3429d1b650786c492b" translate="yes" xml:space="preserve">
          <source>This example transmits a value that implements the custom encoding and decoding methods.</source>
          <target state="translated">Этот пример передает значение,реализующее пользовательские методы кодирования и декодирования.</target>
        </trans-unit>
        <trans-unit id="5ad4aea6278dc849132cadb70003c4716078bb1f" translate="yes" xml:space="preserve">
          <source>This example uses RawMessage to delay parsing part of a JSON message.</source>
          <target state="translated">Этот пример использует RawMessage для задержки разбора части JSON сообщения.</target>
        </trans-unit>
        <trans-unit id="f3c7cd2790bc702e1c4e8248c880538aa9480232" translate="yes" xml:space="preserve">
          <source>This example uses RawMessage to use a precomputed JSON during marshal.</source>
          <target state="translated">Этот пример использует RawMessage для использования предварительно вычисленного JSON во время маршала.</target>
        </trans-unit>
        <trans-unit id="0980067335654187fe3f7c133925d1affa51d747" translate="yes" xml:space="preserve">
          <source>This example uses a Decoder to decode a stream of distinct JSON values.</source>
          <target state="translated">Этот пример использует декодер для декодирования потока различных значений JSON.</target>
        </trans-unit>
        <trans-unit id="03fbac2b83cd3991555ff62920bdc91549cc27eb" translate="yes" xml:space="preserve">
          <source>This example uses a Decoder to decode a streaming array of JSON objects.</source>
          <target state="translated">Этот пример использует декодер для декодирования массива потоковых JSON-объектов.</target>
        </trans-unit>
        <trans-unit id="f5365f6fa06883e90b95f7b5b17bc92e07aa1a04" translate="yes" xml:space="preserve">
          <source>This function is deterministic. Thus, if the set of possible messages is small, an attacker may be able to build a map from messages to signatures and identify the signed messages. As ever, signatures provide authenticity, not confidentiality.</source>
          <target state="translated">Эта функция детерминирована.Таким образом,если набор возможных сообщений мал,атакующий может построить карту от сообщений до подписей и идентифицировать подписанные сообщения.Как всегда,подписи обеспечивают подлинность,а не конфиденциальность.</target>
        </trans-unit>
        <trans-unit id="fd018c9debfe4b296d2cfc4264240cd8fd943b8a" translate="yes" xml:space="preserve">
          <source>This function predates errors.Is, and the notion of whether an error indicates a timeout can be ambiguous. For example, the Unix error EWOULDBLOCK sometimes indicates a timeout and sometimes does not. New code should use errors.Is with a value appropriate to the call returning the error, such as os.ErrDeadlineExceeded.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b76ff62ea1ae6e83678ff4ff974ab310fb4c608" translate="yes" xml:space="preserve">
          <source>This function predates errors.Is. It only supports errors returned by the os package. New code should use errors.Is(err, os.ErrExist).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ac909599248ff292672881014f89872aa8e2750" translate="yes" xml:space="preserve">
          <source>This function predates errors.Is. It only supports errors returned by the os package. New code should use errors.Is(err, os.ErrNotExist).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4065f7f0b0bbe706f58a16388dc6fed510ded429" translate="yes" xml:space="preserve">
          <source>This function predates errors.Is. It only supports errors returned by the os package. New code should use errors.Is(err, os.ErrPermission).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d0f1a75b2c9ccfa817de559e09c94b8dbca3151" translate="yes" xml:space="preserve">
          <source>This function will call x509.ParseCertificate unless c.Leaf is set, which can incur a significant performance cost.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21dc4eae53c9012a7d2a049dd7f00db6a6938f5b" translate="yes" xml:space="preserve">
          <source>This function's execution time does not depend on the inputs.</source>
          <target state="translated">Время выполнения этой функции не зависит от входов.</target>
        </trans-unit>
        <trans-unit id="87202fef0c6c5ae187b02620dfd26b630d0392d4" translate="yes" xml:space="preserve">
          <source>This functionality should only be used with legacy web sites. RFC 2396 warns that interpreting Userinfo this way &amp;ldquo;is NOT RECOMMENDED, because the passing of authentication information in clear text (such as URI) has proven to be a security risk in almost every case where it has been used.&amp;rdquo;</source>
          <target state="translated">Эту функцию следует использовать только с устаревшими веб-сайтами. RFC 2396 предупреждает, что такая интерпретация Userinfo &amp;laquo;НЕ РЕКОМЕНДУЕТСЯ, потому что передача аутентификационной информации в виде открытого текста (например, URI) оказалась угрозой безопасности почти во всех случаях, когда она использовалась&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="898688304c78e7f2468d53e47407efc6f38af32f" translate="yes" xml:space="preserve">
          <source>This implementation derives the nonce from an AES-CTR CSPRNG keyed by ChopMD(256, SHA2-512(priv.D || entropy || hash)). The CSPRNG key is IRO by a result of Coron; the AES-CTR stream is IRO under standard assumptions.</source>
          <target state="translated">Эта реализация происходит от AES-CTR CSPRNG с ключом ChopMD(256,SHA2-512(priv.D || энтропия || хэш))).Ключ CSPRNG является IRO по результатам Coron;AES-CTR поток является IRO по стандартным допущениям.</target>
        </trans-unit>
        <trans-unit id="689c9dd99bb5162e68a9aedd41062dfeb2de0804" translate="yes" xml:space="preserve">
          <source>This implementation derives the nonce from an AES-CTR CSPRNG keyed by:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4c1ec8dd63ceb69c820647454432eed0e8ec308" translate="yes" xml:space="preserve">
          <source>This interface predates the fs.FS interface, which can be used instead: the FS adapter function converts an fs.FS to a FileSystem.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d67c9b0649198706841943ee7eba2049c49bcdb3" translate="yes" xml:space="preserve">
          <source>This is handled as if &quot;my:data-href&quot; was just &quot;data-href&quot; and not &quot;href&quot; as it would be if the &quot;data-&quot; prefix were to be ignored too. Thus at parse time this becomes just</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2d5c7329f986ca3d31bfdba2057014f5f44ad7d" translate="yes" xml:space="preserve">
          <source>This is only needed to install the handler in a non-standard location.</source>
          <target state="translated">Это необходимо только для установки обработчика в нестандартном месте.</target>
        </trans-unit>
        <trans-unit id="4726b7b6e93eb25607ca12b6c92e41d048948273" translate="yes" xml:space="preserve">
          <source>This is unnecessary as the next call to WriteHeader or Close will implicitly flush out the file's padding.</source>
          <target state="translated">В этом нет необходимости,так как при следующем вызове WriteHeader или Close неявно будет вымыта подкладка файла.</target>
        </trans-unit>
        <trans-unit id="8eba79d25cd0ac07c169a84af16002b1daff283c" translate="yes" xml:space="preserve">
          <source>This kind of key is commonly encoded in PEM blocks of type &quot;EC PRIVATE KEY&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb1b3ed68f800415903edd6e38e6c00b58c4b66a" translate="yes" xml:space="preserve">
          <source>This kind of key is commonly encoded in PEM blocks of type &quot;EC PRIVATE KEY&quot;. For a more flexible key format which is not EC specific, use MarshalPKCS8PrivateKey.</source>
          <target state="translated">Этот тип ключа обычно кодируется в блоках ПЕМ типа &quot;EC PRIVATE KEY&quot;.Для более гибкого формата ключа,который не является специфическим для ЕС,используйте MarshalPKCS8PrivateKey.</target>
        </trans-unit>
        <trans-unit id="56bef0ed59f36389d7550a0e4c48802187b81f7d" translate="yes" xml:space="preserve">
          <source>This kind of key is commonly encoded in PEM blocks of type &quot;EC PUBLIC KEY&quot;.</source>
          <target state="translated">Этот тип ключа обычно кодируется в блоках ПЕМ типа &quot;EC PUBLIC KEY&quot;.</target>
        </trans-unit>
        <trans-unit id="dfe352de6a0131091f458f18e937a358eab3152e" translate="yes" xml:space="preserve">
          <source>This kind of key is commonly encoded in PEM blocks of type &quot;PRIVATE KEY&quot;.</source>
          <target state="translated">Этот тип ключа обычно кодируется в блоках PEM типа &quot;PRIVATE KEY&quot;.</target>
        </trans-unit>
        <trans-unit id="42db7a056c64d4d64e474ea59fd1650377d9bc54" translate="yes" xml:space="preserve">
          <source>This kind of key is commonly encoded in PEM blocks of type &quot;PUBLIC KEY&quot;.</source>
          <target state="translated">Этот тип ключа обычно кодируется в блоках PEM типа &quot;PUBLIC KEY&quot;.</target>
        </trans-unit>
        <trans-unit id="64ab07dfb34f7d2feff364506aca7067a4453b39" translate="yes" xml:space="preserve">
          <source>This kind of key is commonly encoded in PEM blocks of type &quot;RSA PRIVATE KEY&quot;.</source>
          <target state="translated">Этот тип ключа обычно кодируется в блоках PEM типа &quot;RSA PRIVATE KEY&quot;.</target>
        </trans-unit>
        <trans-unit id="98a803d28f3224bf7891d32a0db324db326e4afd" translate="yes" xml:space="preserve">
          <source>This kind of key is commonly encoded in PEM blocks of type &quot;RSA PRIVATE KEY&quot;. For a more flexible key format which is not RSA specific, use MarshalPKCS8PrivateKey.</source>
          <target state="translated">Этот тип ключа обычно кодируется в блоках PEM типа &quot;RSA PRIVATE KEY&quot;.Для более гибкого формата ключа,который не является специфическим для RSA,используйте MarshalPKCS8PrivateKey.</target>
        </trans-unit>
        <trans-unit id="5d8222cc13301829f5dbdc649eec16abab7d33d6" translate="yes" xml:space="preserve">
          <source>This kind of key is commonly encoded in PEM blocks of type &quot;RSA PUBLIC KEY&quot;.</source>
          <target state="translated">Этот тип ключа обычно кодируется в блоках PEM типа &quot;RSA PUBLIC KEY&quot;.</target>
        </trans-unit>
        <trans-unit id="67c7b63689264a63777784c1588c7be8f2ebeb83" translate="yes" xml:space="preserve">
          <source>This means that, by default, command line programs will behave like typical Unix command line programs, while other programs will not crash with SIGPIPE when writing to a closed network connection.</source>
          <target state="translated">Это означает,что по умолчанию программы командной строки будут вести себя как обычные программы командной строки Unix,в то время как другие программы не будут аварийно завершать работу с SIGPIPE при записи в закрытое сетевое соединение.</target>
        </trans-unit>
        <trans-unit id="53c41745078961e0cbeedf1ad29b01ea99fe7434" translate="yes" xml:space="preserve">
          <source>This mechanism can be used to cancel long operations on the server if the client has disconnected before the response is ready.</source>
          <target state="translated">Этот механизм может быть использован для отмены длительных операций на сервере,если клиент отсоединился до того,как ответ был готов.</target>
        </trans-unit>
        <trans-unit id="d3191056acdbdc6fd1ca936f76914f75eb4f8098" translate="yes" xml:space="preserve">
          <source>This mechanism is intended only for trailers that are not known prior to the headers being written. If the set of trailers is fixed or known before the header is written, the normal Go trailers mechanism is preferred:</source>
          <target state="translated">Этот механизм предназначен только для прицепов,которые не известны до написания заголовков.Если комплект прицепов зафиксирован или известен до записи заголовка,предпочтительнее использовать обычный механизм Go прицепов:</target>
        </trans-unit>
        <trans-unit id="34dfd520d192c4e8193a79a528c0369751354149" translate="yes" xml:space="preserve">
          <source>This method consults the following fields of the response r:</source>
          <target state="translated">Этот метод учитывает следующие поля ответа r:</target>
        </trans-unit>
        <trans-unit id="6857cb2d00e6efa4c19dc849fe5f85bb657fb149" translate="yes" xml:space="preserve">
          <source>This method implements crypto.Signer, which is an interface to support keys where the private part is kept in, for example, a hardware module. Common uses should use the Sign function in this package directly.</source>
          <target state="translated">В этом методе реализован crypto.Signer-интерфейс для поддержки ключей,в котором приватная часть хранится,например,в аппаратном модуле.При обычном использовании функция Sign в данном пакете должна использоваться непосредственно.</target>
        </trans-unit>
        <trans-unit id="dca73678d958fc56a6644aad153e6b5ae346adb8" translate="yes" xml:space="preserve">
          <source>This method implements crypto.Signer, which is an interface to support keys where the private part is kept in, for example, a hardware module. Common uses should use the Sign* functions in this package directly.</source>
          <target state="translated">В этом методе реализован crypto.Signer-интерфейс для поддержки ключей,в котором приватная часть хранится,например,в аппаратном модуле.При обычном использовании функции Sign*в данном пакете должны использоваться непосредственно.</target>
        </trans-unit>
        <trans-unit id="6162e9fff452fe7b81839fc43d5a9b956682d1db" translate="yes" xml:space="preserve">
          <source>This package assumes that template authors are trusted, that Execute's data parameter is not, and seeks to preserve the properties below in the face of untrusted data:</source>
          <target state="translated">Этот пакет предполагает,что авторы шаблонов доверяют,а параметр данных Execute-нет,и стремится сохранить свойства,приведенные ниже,перед лицом недоверенных данных:</target>
        </trans-unit>
        <trans-unit id="646741784bedcfbc50f393efbc21b4c2b803f33a" translate="yes" xml:space="preserve">
          <source>This package does not guarantee bit-identical results across architectures.</source>
          <target state="translated">Этот пакет не гарантирует результат в битовом разрезе для разных архитектур.</target>
        </trans-unit>
        <trans-unit id="25b183f3fa47240bd162a6084ce81041d00db47f" translate="yes" xml:space="preserve">
          <source>This package does not support disk spanning.</source>
          <target state="translated">Этот пакет не поддерживает расширение диска.</target>
        </trans-unit>
        <trans-unit id="917226455af3a3e84812552f61aaf5f000d19a66" translate="yes" xml:space="preserve">
          <source>This package favors simplicity over efficiency. Clients that require high-performance serialization, especially for large data structures, should look at more advanced solutions such as the encoding/gob package or protocol buffers.</source>
          <target state="translated">В этом пакете предпочтение отдается простоте,а не эффективности.Клиентам,которым требуется высокопроизводительная сериализация,особенно для больших структур данных,следует обратить внимание на более продвинутые решения,такие как пакет кодировок/кодировок или буферы протоколов.</target>
        </trans-unit>
        <trans-unit id="91400ec0be490a039f54a2e8ea4991f07061b72f" translate="yes" xml:space="preserve">
          <source>This package is EXPERIMENTAL. Its current scope is only to allow tests to run, but not yet to provide a comprehensive API for users. It is exempt from the Go compatibility promise.</source>
          <target state="translated">Этот пакет является ЭКСПЕРИМЕНТАЛЬНЫМ.В настоящее время он предназначен только для того,чтобы позволить запустить тесты,но пока не предоставляет полного API для пользователей.Он освобожден от обещания совместимости с Go.</target>
        </trans-unit>
        <trans-unit id="f172ad46509f2996426e887fe6f7f5b737ccb0ba" translate="yes" xml:space="preserve">
          <source>This package is not implemented on NaCl (Native Client).</source>
          <target state="translated">Данный пакет не реализован на NaCl (Native Client).</target>
        </trans-unit>
        <trans-unit id="70b7c3d76332df2a567dd4571a1dd43d36bb3d95" translate="yes" xml:space="preserve">
          <source>This package is not implemented on Plan 9.</source>
          <target state="translated">Данный пакет не реализуется в рамках Плана 9.</target>
        </trans-unit>
        <trans-unit id="089323f3519ab53b437d7cbe9878efc86f18d94a" translate="yes" xml:space="preserve">
          <source>This package is not implemented on Windows. As the syslog package is frozen, Windows users are encouraged to use a package outside of the standard library. For background, see &lt;a href=&quot;https://golang.org/issue/1108&quot;&gt;https://golang.org/issue/1108&lt;/a&gt;.</source>
          <target state="translated">Этот пакет не реализован в Windows. Поскольку пакет syslog заморожен, пользователям Windows рекомендуется использовать пакет вне стандартной библиотеки. Для получения дополнительной информации см. &lt;a href=&quot;https://golang.org/issue/1108&quot;&gt;Https://golang.org/issue/1108&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="37ad2d1270c390f993e16f89ffda81efa69cc5ba" translate="yes" xml:space="preserve">
          <source>This package parses both the original &amp;ldquo;// +build&amp;rdquo; syntax and the &amp;ldquo;//go:build&amp;rdquo; syntax that will be added in Go 1.17. The parser is being included in Go 1.16 to allow tools that need to process Go 1.17 source code to still be built against the Go 1.16 release. See &lt;a href=&quot;https://golang.org/design/draft-gobuild&quot;&gt;https://golang.org/design/draft-gobuild&lt;/a&gt; for details about the &amp;ldquo;//go:build&amp;rdquo; syntax.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0a342a318c5bf238d0752ca434eaa7de9a66322" translate="yes" xml:space="preserve">
          <source>This package should normally be imported by a program's main package, not by a library. Libraries normally shouldn't decide whether to include the timezone database in a program.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d4fcbbffc8fc9a4336682d220cd948063216551" translate="yes" xml:space="preserve">
          <source>This package supports metrics whose values have a floating-point representation. In order to improve ease-of-use, this package promises to never produce the following classes of floating-point values: NaN, infinity.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c28db944fb8406ea70640148283b4f2b07cfe75" translate="yes" xml:space="preserve">
          <source>This package understands HTML, CSS, JavaScript, and URIs. It adds sanitizing functions to each simple action pipeline, so given the excerpt</source>
          <target state="translated">Этот пакет понимает HTML,CSS,JavaScript и URI.Он добавляет функции дезинфекции к каждому простому конвейеру действий,поэтому с учетом выдержки</target>
        </trans-unit>
        <trans-unit id="df567a8ebe9ff3e3072f56ef8a4b9eaa7e757875" translate="yes" xml:space="preserve">
          <source>This package will be automatically imported if you build with -tags timetzdata.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63f9c654258649e0fec61304d0149ff6b7e1fac2" translate="yes" xml:space="preserve">
          <source>This package wraps package text/template so you can share its template API to parse and execute HTML templates safely.</source>
          <target state="translated">Этот пакет обёртывает текст/шаблон пакета,так что вы можете поделиться его API шаблона для безопасного разбора и выполнения HTML шаблонов.</target>
        </trans-unit>
        <trans-unit id="12b81feb5020b97e164b3bd1ab6605720164a33f" translate="yes" xml:space="preserve">
          <source>This palette was used in the Plan 9 Operating System, described at &lt;a href=&quot;https://9p.io/magic/man2html/6/color&quot;&gt;https://9p.io/magic/man2html/6/color&lt;/a&gt;</source>
          <target state="translated">Эта палитра использовалась в операционной системе Plan 9, описанной на &lt;a href=&quot;https://9p.io/magic/man2html/6/color&quot;&gt;https://9p.io/magic/man2html/6/color.&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="53f264e60d97dda7c8e598fd892c840f64c77bcb" translate="yes" xml:space="preserve">
          <source>This returns a Writer to which the file contents should be written. The file's contents must be written to the io.Writer before the next call to Create, CreateHeader, or Close.</source>
          <target state="translated">При этом возвращается Writer,в который должно быть записано содержимое файла.Содержимое файла должно быть записано в io.Writer перед следующим вызовом Create,CreateHeader или Close.</target>
        </trans-unit>
        <trans-unit id="3636f2d8cb7dce3b52ad380d63ea631656bb70da" translate="yes" xml:space="preserve">
          <source>This runtime/trace package provides APIs to add equivalent tracing support to a standalone program. See the Example that demonstrates how to use this API to enable tracing.</source>
          <target state="translated">Пакет runtime/trace предоставляет API для добавления эквивалентной поддержки трассировки в отдельную программу.См.пример,демонстрирующий,как использовать этот API для включения трассировки.</target>
        </trans-unit>
        <trans-unit id="eb3d7236d288f19d5e07330ec9b641abb7a1c736" translate="yes" xml:space="preserve">
          <source>This section documents the encoding, details that are not important for most users. Details are presented bottom-up.</source>
          <target state="translated">Этот раздел документирует кодировку,детали,которые не важны для большинства пользователей.Детали представлены снизу вверх.</target>
        </trans-unit>
        <trans-unit id="8d97dde3cffa35e96f0901463ccd21bc2b7e33d2" translate="yes" xml:space="preserve">
          <source>This set may grow. Note that regular expression matches may need to examine text beyond the text returned by a match, so the methods that match text from a RuneReader may read arbitrarily far into the input before returning.</source>
          <target state="translated">Этот набор может расти.Обратите внимание,что в случае совпадения регулярных выражений может потребоваться изучение текста,выходящего за рамки текста,возвращенного в результате совпадения,поэтому методы,совпадающие с текстом из RuneReader,могут произвольно читаться далеко во входных данных,прежде чем возвращаться.</target>
        </trans-unit>
        <trans-unit id="13155ea54999e3f67a0c6d8a556ef2fb922860ce" translate="yes" xml:space="preserve">
          <source>This should not be done concurrent to other receives from the Timer's channel.</source>
          <target state="translated">Это не должно осуществляться одновременно с другими приемами из канала Таймера.</target>
        </trans-unit>
        <trans-unit id="0da770375be11542fa319ca413fcc3ece2b576a4" translate="yes" xml:space="preserve">
          <source>This type should be considered identical to sql.IsolationLevel along with any values defined on it.</source>
          <target state="translated">Этот тип следует считать идентичным sql.IsolationLevel вместе с любыми заданными на нем значениями.</target>
        </trans-unit>
        <trans-unit id="5cefc7416c362c1afcf6c674cc1720ba6d02139f" translate="yes" xml:space="preserve">
          <source>This type should be considered identical to sql.TxOptions.</source>
          <target state="translated">Этот тип следует считать идентичным sql.TxOptions.</target>
        </trans-unit>
        <trans-unit id="23bb56893bd9c167f4933bba0f06ea209969209a" translate="yes" xml:space="preserve">
          <source>ThreadCreateProfile returns n, the number of records in the thread creation profile. If len(p) &amp;gt;= n, ThreadCreateProfile copies the profile into p and returns n, true. If len(p) &amp;lt; n, ThreadCreateProfile does not change p and returns n, false.</source>
          <target state="translated">ThreadCreateProfile возвращает n - количество записей в профиле создания потока. Если len (p)&amp;gt; = n, ThreadCreateProfile копирует профиль в p и возвращает n, true. Если len (p) &amp;lt;n, ThreadCreateProfile не изменяет p и возвращает n, false.</target>
        </trans-unit>
        <trans-unit id="053a6e5ff5756153adf26636a41ad3c9d51f80be" translate="yes" xml:space="preserve">
          <source>Thus, users of this API are encouraged to sample supported metrics defined by the slice returned by All to remain compatible across Go versions. Of course, situations arise where reading specific metrics is critical. For these cases, users are encouraged to use build tags, and although metrics may be deprecated and removed, users should consider this to be an exceptional and rare event, coinciding with a very large change in a particular Go implementation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aeddfe22a01fc0ff5fb0fe691b08db0b2e2a26c7" translate="yes" xml:space="preserve">
          <source>Tick</source>
          <target state="translated">Tick</target>
        </trans-unit>
        <trans-unit id="26c9fc157a3f52de1aca92922ccb9a288e5fa386" translate="yes" xml:space="preserve">
          <source>Tick is a convenience wrapper for NewTicker providing access to the ticking channel only. While Tick is useful for clients that have no need to shut down the Ticker, be aware that without a way to shut it down the underlying Ticker cannot be recovered by the garbage collector; it &quot;leaks&quot;. Unlike NewTicker, Tick will return nil if d &amp;lt;= 0.</source>
          <target state="translated">Tick ​​- это удобная оболочка для NewTicker, предоставляющая доступ только к тикающему каналу. Хотя Tick полезен для клиентов, которым не нужно выключать тикер, имейте в виду, что без возможности его выключения базовый тикер не может быть восстановлен сборщиком мусора; он &amp;laquo;протекает&amp;raquo;. В отличие от NewTicker, Tick вернет nil, если d &amp;lt;= 0.</target>
        </trans-unit>
        <trans-unit id="464b9c4863cbad4e03c3166e6a41a020f20219b8" translate="yes" xml:space="preserve">
          <source>Time instants can be compared using the Before, After, and Equal methods. The Sub method subtracts two instants, producing a Duration. The Add method adds a Time and a Duration, producing a Time.</source>
          <target state="translated">Методы До,После и Равенство позволяют сравнивать мгновения времени.Метод Sub вычитает две мгновенности,производя Длительность.Метод Add добавляет Время и Продолжительность,производя Время.</target>
        </trans-unit>
        <trans-unit id="7e0d5fdb48c2796b9cc511f84f1969b59a9bd1cf" translate="yes" xml:space="preserve">
          <source>Time.Add</source>
          <target state="translated">Time.Add</target>
        </trans-unit>
        <trans-unit id="5c2e779ba4c8677013ab3eb4de9c1e6bf9c9924b" translate="yes" xml:space="preserve">
          <source>Time.AddDate</source>
          <target state="translated">Time.AddDate</target>
        </trans-unit>
        <trans-unit id="730b4aa03b8316a2a6c19e05b72ec5d4eb05e78c" translate="yes" xml:space="preserve">
          <source>Time.After</source>
          <target state="translated">Time.After</target>
        </trans-unit>
        <trans-unit id="d5e86b615c46a18260de62e172d7e06cc20f7083" translate="yes" xml:space="preserve">
          <source>Time.AppendFormat</source>
          <target state="translated">Time.AppendFormat</target>
        </trans-unit>
        <trans-unit id="88be4309d5e0539eff6218d7e8c02ecf0c7b2e65" translate="yes" xml:space="preserve">
          <source>Time.Before</source>
          <target state="translated">Time.Before</target>
        </trans-unit>
        <trans-unit id="480d1c53462d365532b2348e82a3f0dcb963c99e" translate="yes" xml:space="preserve">
          <source>Time.Date</source>
          <target state="translated">Time.Date</target>
        </trans-unit>
        <trans-unit id="ae2638b80e7bdac6e6725adc567cf7badedc6abe" translate="yes" xml:space="preserve">
          <source>Time.Day</source>
          <target state="translated">Time.Day</target>
        </trans-unit>
        <trans-unit id="d4766b7b3328342b5ba1a667334b95afb4c840fd" translate="yes" xml:space="preserve">
          <source>Time.Equal</source>
          <target state="translated">Time.Equal</target>
        </trans-unit>
        <trans-unit id="092fc9098aafde18e6cec288675831ee7d77f8a8" translate="yes" xml:space="preserve">
          <source>Time.Format</source>
          <target state="translated">Time.Format</target>
        </trans-unit>
        <trans-unit id="dd61b8e28117a6a8c31fd714a3696b1193538443" translate="yes" xml:space="preserve">
          <source>Time.Format (Pad)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3768befc26b5bc40a2c6b38ecc6f26a0656a5d40" translate="yes" xml:space="preserve">
          <source>Time.Round</source>
          <target state="translated">Time.Round</target>
        </trans-unit>
        <trans-unit id="5b138a17083c1c36c8bab2fd64e7493a32a70b68" translate="yes" xml:space="preserve">
          <source>Time.String</source>
          <target state="translated">Time.String</target>
        </trans-unit>
        <trans-unit id="e126e45961c85339227ad3c92517287507ec5152" translate="yes" xml:space="preserve">
          <source>Time.Sub</source>
          <target state="translated">Time.Sub</target>
        </trans-unit>
        <trans-unit id="d3f1777c34673ecabb71603383f8d1fd8d6be9c4" translate="yes" xml:space="preserve">
          <source>Time.Truncate</source>
          <target state="translated">Time.Truncate</target>
        </trans-unit>
        <trans-unit id="c4ee117595e7091017dcf807233ec5e3324552ac" translate="yes" xml:space="preserve">
          <source>Time.Unix</source>
          <target state="translated">Time.Unix</target>
        </trans-unit>
        <trans-unit id="f8fc7e6bb582b1829de5a848ff872dea68eff61d" translate="yes" xml:space="preserve">
          <source>TimeFormat is the time format to use when generating times in HTTP headers. It is like time.RFC1123 but hard-codes GMT as the time zone. The time being formatted must be in UTC for Format to generate the correct format.</source>
          <target state="translated">TimeFormat-это формат времени,используемый при генерации времени в заголовках HTTP.Он похож на time.RFC1123,но в качестве часового пояса используется жесткий код GMT.Чтобы формат времени был правильным,время должно быть отформатировано в UTC.</target>
        </trans-unit>
        <trans-unit id="9827d1afd02311b970b1c9ab5d2482ee7f917a5d" translate="yes" xml:space="preserve">
          <source>Timeout reports whether the DNS lookup is known to have timed out. This is not always known; a DNS lookup may fail due to a timeout and return a DNSError for which Timeout returns false.</source>
          <target state="translated">Таймаут сообщает о том,известен ли таймаут DNS поиска.Это не всегда известно;DNS поиск может не работать из-за таймаута и возвращает ошибку DNSError,для которой таймаут возвращается ложным.</target>
        </trans-unit>
        <trans-unit id="927810e8434679578bc9bf07a4312dbfd80340d4" translate="yes" xml:space="preserve">
          <source>Timeout reports whether this error represents a timeout.</source>
          <target state="translated">Таймаут сообщает,является ли эта ошибка таймаутом.</target>
        </trans-unit>
        <trans-unit id="e7860bff1be7d01a8121a71b30616b2279f825c3" translate="yes" xml:space="preserve">
          <source>TimeoutHandler returns a Handler that runs h with the given time limit.</source>
          <target state="translated">TimeoutHandler возвращает обработчик,который запускает h с заданным ограничением по времени.</target>
        </trans-unit>
        <trans-unit id="41f375b226e7f8e10a9acde2441f73751822f0d4" translate="yes" xml:space="preserve">
          <source>TimeoutHandler supports the Flusher and Pusher interfaces but does not support the Hijacker interface.</source>
          <target state="translated">TimeoutHandler поддерживает интерфейсы Flusher и Pusher,но не поддерживает интерфейс Hijacker.</target>
        </trans-unit>
        <trans-unit id="229f8a47d6424d21cc11a27228c5b3dd3021912d" translate="yes" xml:space="preserve">
          <source>TimeoutHandler supports the Pusher interface but does not support the Hijacker or Flusher interfaces.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b94b20b16ca4b5f916aaa1eb8d24553f8d4b92c2" translate="yes" xml:space="preserve">
          <source>TimeoutReader returns ErrTimeout on the second read with no data. Subsequent calls to read succeed.</source>
          <target state="translated">TimeoutReader возвращает ErrTimeout на втором чтении без данных.Последующие вызовы на чтение удаются.</target>
        </trans-unit>
        <trans-unit id="092b95acf2f2e3d735b1b9d6eb619d6f9b285116" translate="yes" xml:space="preserve">
          <source>TimespecToNSec returns the time stored in ts as nanoseconds.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8bdae2bbf616fbfd5c5eefd29c8a537bd886144c" translate="yes" xml:space="preserve">
          <source>TimespecToNsec converts a Timespec value into a number of nanoseconds since the Unix epoch.</source>
          <target state="translated">TimespecToNsec преобразует значение Timespec в несколько наносекунд со времен эпохи Unix.</target>
        </trans-unit>
        <trans-unit id="71641b558817e2a09b865dac9868550ced5db039" translate="yes" xml:space="preserve">
          <source>TimevalToNsec converts a Timeval value into a number of nanoseconds since the Unix epoch.</source>
          <target state="translated">TimevalToNsec преобразует значение Timeval в число наносекунд,начиная с эпохи Unix.</target>
        </trans-unit>
        <trans-unit id="88a226b5c5421dc95c12f9851cda7185d1ebf771" translate="yes" xml:space="preserve">
          <source>TimevalToNsec returns the time stored in tv as nanoseconds.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="768e0c1c69573fb588f61f1308a015c11468e05f" translate="yes" xml:space="preserve">
          <source>Title</source>
          <target state="translated">Title</target>
        </trans-unit>
        <trans-unit id="ee048df59e1fe3a78061c7c9271c635869379b9b" translate="yes" xml:space="preserve">
          <source>Title returns a copy of the string s with all Unicode letters that begin words mapped to their Unicode title case.</source>
          <target state="translated">Заголовок возвращает копию строки s со всеми буквами Юникода,которые начинают слова,привязанные к их заголовку в Юникоде.</target>
        </trans-unit>
        <trans-unit id="173f12648645a6edd8fcbab7c7ed0369c007806c" translate="yes" xml:space="preserve">
          <source>Title treats s as UTF-8-encoded bytes and returns a copy with all Unicode letters that begin words mapped to their title case.</source>
          <target state="translated">Заголовок рассматривает s как байты в кодировке UTF-8 и возвращает копию со всеми буквами Unicode,которые начинают слова,привязанные к их регистру заголовка.</target>
        </trans-unit>
        <trans-unit id="ae79ea1e9c6391a9ed83a2e18a031b835feec0c9" translate="yes" xml:space="preserve">
          <source>To</source>
          <target state="translated">To</target>
        </trans-unit>
        <trans-unit id="616d61f65a9f91c650c28db92d9cb8984a1f52bd" translate="yes" xml:space="preserve">
          <source>To add equivalent profiling support to a standalone program, add code like the following to your main function:</source>
          <target state="translated">Чтобы добавить эквивалентную поддержку профилирования в отдельную программу,добавьте код,подобный приведенному ниже,в свою основную функцию:</target>
        </trans-unit>
        <trans-unit id="f6f5822190a6e77b3f6e2423fce4abac430f1e8d" translate="yes" xml:space="preserve">
          <source>To avoid denial of service attacks, the provided bufio.Reader should be reading from an io.LimitReader or similar Reader to bound the size of responses.</source>
          <target state="translated">Чтобы избежать атак типа &quot;отказ в обслуживании&quot;,предоставляемый bufio.Reader должен считывать данные с io.LimitReader или аналогичного Reader,чтобы ограничить размер ответов.</target>
        </trans-unit>
        <trans-unit id="87386ad5a06e96430212748899697cda9d7a3724" translate="yes" xml:space="preserve">
          <source>To avoid recursion in cases such as</source>
          <target state="translated">Чтобы избежать рецидивов в таких случаях,как</target>
        </trans-unit>
        <trans-unit id="a87f0fb7c131221874ae3b0c17104f44ee1c34bc" translate="yes" xml:space="preserve">
          <source>To be backwards compatible the FileHeader has both 32 and 64 bit Size fields. The 64 bit fields will always contain the correct value and for normal archives both fields will be the same. For files requiring the ZIP64 format the 32 bit fields will be 0xffffffff and the 64 bit fields must be used instead.</source>
          <target state="translated">Для обратной совместимости FileHeader имеет поля размером 32 и 64 бита.64-битные поля всегда будут содержать правильное значение,а для обычных архивов оба поля будут одинаковыми.Для файлов,требующих формат ZIP64,32-битные поля будут 0xffffffff,вместо них должны использоваться 64-битные поля.</target>
        </trans-unit>
        <trans-unit id="f0c9c2ba0d3b42114f628f0336b7d63f8138a666" translate="yes" xml:space="preserve">
          <source>To build a file only when using cgo, and only on Linux and OS X:</source>
          <target state="translated">Собирать файл только при использовании cgo,и только под Linux и OS X:</target>
        </trans-unit>
        <trans-unit id="b59fa373960766ba2850aeb1bfd6ebb3acccc2d0" translate="yes" xml:space="preserve">
          <source>To build strings more efficiently, see the strings.Builder type.</source>
          <target state="translated">Для более эффективного построения строк смотрите тип stringings.builder.</target>
        </trans-unit>
        <trans-unit id="65822ab438826bd3303521dc362fbdb7385f9c68" translate="yes" xml:space="preserve">
          <source>To change the destination for flag messages, call CommandLine.SetOutput.</source>
          <target state="translated">Чтобы изменить пункт назначения для сообщений с флагами,позвоните в CommandLine.SetOutput.</target>
        </trans-unit>
        <trans-unit id="697c0150c9b1eec40f18c8aa7919a2878d3bf00a" translate="yes" xml:space="preserve">
          <source>To compare two Values, compare the results of the Interface method. Using == on two Values does not compare the underlying values they represent.</source>
          <target state="translated">Чтобы сравнить два значения,сравните результаты метода Интерфейс.Использование ==на двух Значениях не сравнивает базовые значения,которые они представляют.</target>
        </trans-unit>
        <trans-unit id="26bcf90200ee4c383ef61356b62c1cde915663a4" translate="yes" xml:space="preserve">
          <source>To complete the example above, the following code tries to find the value x in an integer slice data sorted in ascending order:</source>
          <target state="translated">Для завершения приведенного выше примера следующий код пытается найти значение x в целочисленном срезе данных,отсортированных в порядке возрастания:</target>
        </trans-unit>
        <trans-unit id="48862e3dd334f932c3f29aca76cb78295d40632d" translate="yes" xml:space="preserve">
          <source>To compute the number of allocations, the function will first be run once as a warm-up. The average number of allocations over the specified number of runs will then be measured and returned.</source>
          <target state="translated">Для вычисления количества распределений функция сначала будет запущена один раз в качестве разогрева.Затем будет измерено и возвращено среднее количество распределений,превышающее указанное количество запусков.</target>
        </trans-unit>
        <trans-unit id="a1b4d9690ab97f466c6d326d8c742f5be1f15108" translate="yes" xml:space="preserve">
          <source>To convert an integer number of units to a Duration, multiply:</source>
          <target state="translated">Чтобы преобразовать целое число единиц в Продолжительность,умножьте:</target>
        </trans-unit>
        <trans-unit id="c70ea98cf5f708e17c34d681b2e9583414cbfaae" translate="yes" xml:space="preserve">
          <source>To count the number of units in a Duration, divide:</source>
          <target state="translated">Чтобы посчитать количество единиц в Длительности,разделите:</target>
        </trans-unit>
        <trans-unit id="a8a481566ee5c9f4011b251f076b7cff25d2b336" translate="yes" xml:space="preserve">
          <source>To create a new request with a context, use NewRequestWithContext. To change the context of a request (such as an incoming) you then also want to modify to send back out, use Request.Clone. Between those two uses, it's rare to need WithContext.</source>
          <target state="translated">Для создания нового запроса с контекстом используйте NewRequestWithContext.Чтобы изменить контекст запроса (например,входящего),вы также хотите изменить,чтобы отправить обратно,используйте Request.Clone.Между этими двумя использованиями,редко нужно использовать WithContext.</target>
        </trans-unit>
        <trans-unit id="df17ef73a333723433e10a65752b7d97c8d742ec" translate="yes" xml:space="preserve">
          <source>To create a new request with a context, use NewRequestWithContext. To change the context of a request, such as an incoming request you want to modify before sending back out, use Request.Clone. Between those two uses, it's rare to need WithContext.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1ce4e028f3adf6fe5e3e3ea8b7a3ce1d7c4cce0" translate="yes" xml:space="preserve">
          <source>To create the Pos value for a specific source offset (measured in bytes), first add the respective file to the current file set using FileSet.AddFile and then call File.Pos(offset) for that file. Given a Pos value p for a specific file set fset, the corresponding Position value is obtained by calling fset.Position(p).</source>
          <target state="translated">Чтобы создать значение Pos для конкретного исходного смещения (измеряемого в байтах),сначала добавьте соответствующий файл к текущему набору файлов с помощью FileSet.AddFile,а затем вызовите File.Pos(offset)для этого файла.Получив значение позиции p для определенного набора файлов fset,соответствующее значение позиции можно получить с помощью вызова fset.Position(p).</target>
        </trans-unit>
        <trans-unit id="ffa6362a850b5571ec14ab520e75aaa3f0b772a0" translate="yes" xml:space="preserve">
          <source>To define a type, the encoder chooses an unused, positive type id and sends the pair (-type id, encoded-type) where encoded-type is the gob encoding of a wireType description, constructed from these types:</source>
          <target state="translated">Чтобы определить тип,кодировщик выбирает неиспользуемый,положительный идентификатор типа и посылает пару (-type id,encoded-type),где кодированный тип-это кодировка кубика описания wireType,построенного из этих типов:</target>
        </trans-unit>
        <trans-unit id="da43583df08c2ff7e4692ba80d3b2cf801b80a61" translate="yes" xml:space="preserve">
          <source>To define your own format, write down what the reference time would look like formatted your way; see the values of constants like ANSIC, StampMicro or Kitchen for examples. The model is to demonstrate what the reference time looks like so that the Format and Parse methods can apply the same transformation to a general time value.</source>
          <target state="translated">Чтобы определить свой собственный формат,запишите,как будет выглядеть время ссылки,отформатированное в вашем стиле;см.значения таких констант,как ANSIC,StampMicro или Kitchen для примеров.Модель должна продемонстрировать,как будет выглядеть опорное время,чтобы методы Format и Parse могли применить одно и то же преобразование к общему значению времени.</target>
        </trans-unit>
        <trans-unit id="79806cf1eaac70011a5e985d3751306c16fa37ee" translate="yes" xml:space="preserve">
          <source>To distinguish build constraints from package documentation, a series of build constraints must be followed by a blank line.</source>
          <target state="translated">Чтобы отличить ограничения на сборку от документации пакета,за рядом ограничений на сборку должна следовать пустая строка.</target>
        </trans-unit>
        <trans-unit id="a50607887789cbea54ccb0db0c455e312a84417e" translate="yes" xml:space="preserve">
          <source>To ensure the channel is empty after a call to Stop, check the return value and drain the channel. For example, assuming the program has not received from t.C already:</source>
          <target state="translated">Чтобы убедиться,что канал пуст после вызова Stop,проверьте возвращаемое значение и слейте воду из канала.Например,предположим,что программа еще не получила от t.C:</target>
        </trans-unit>
        <trans-unit id="dc7659d0594b1222a7c79baf65726fd2fc8fc92f" translate="yes" xml:space="preserve">
          <source>To escape a text segment, bracket it with Escape characters. For instance, the tab in this string &quot;Ignore this tab: \xff\t\xff&quot; does not terminate a cell and constitutes a single character of width one for formatting purposes.</source>
          <target state="translated">Чтобы избежать отрывка текста,заключите его в скобки с помощью символов Escape.Например,табуляция в этой строке &quot;Игнорировать эту табуляцию:\xff\t\xff&quot; не завершает ячейку и представляет собой один символ ширины один для форматирования.</target>
        </trans-unit>
        <trans-unit id="a3866d2c65d6d17db1dce0e7ab464336a1186960" translate="yes" xml:space="preserve">
          <source>To force integer division of Int operands, use op == token.QUO_ASSIGN instead of token.QUO; the result is guaranteed to be Int in this case. Division by zero leads to a run-time panic.</source>
          <target state="translated">Чтобы форсировать целочисленное деление операндов Int,используйте op ==token.QUO_ASSIGN вместо token.QUO;в этом случае результат гарантированно будет Int.Деление на ноль приводит к панике во время выполнения.</target>
        </trans-unit>
        <trans-unit id="93f96dd1110bc83e45c261305087ab59ccdab5c6" translate="yes" xml:space="preserve">
          <source>To generate HTML output, see package html/template, which has the same interface as this package but automatically secures HTML output against certain attacks.</source>
          <target state="translated">См.пакет html/template,который имеет тот же самый интерфейс,что и этот пакет,но автоматически защищает HTML-вывод от определенных атак.</target>
        </trans-unit>
        <trans-unit id="0f37e1016d8b746740d606c5f03bd61a370f62be" translate="yes" xml:space="preserve">
          <source>To generate a client HTTP request instead of a server request, see the NewRequest function in the net/http package.</source>
          <target state="translated">Чтобы сгенерировать HTTP-запрос клиента вместо запроса сервера,см.функцию NewRequest в пакете net/http.</target>
        </trans-unit>
        <trans-unit id="06a96f64d7d0f413489f0372ff0c9c5459591c5b" translate="yes" xml:space="preserve">
          <source>To include every allocated block in the profile, set MemProfileRate to 1. To turn off profiling entirely, set MemProfileRate to 0.</source>
          <target state="translated">Чтобы включить каждый выделенный блок в профиль,установите значение MemProfileRate равным 1.Чтобы полностью отключить профилирование,установите значение MemProfileRate равным 0.</target>
        </trans-unit>
        <trans-unit id="1cf82e7adf1a06dc5b4204dd8949c669c22a6ce1" translate="yes" xml:space="preserve">
          <source>To include every blocking event in the profile, pass rate = 1. To turn off profiling entirely, pass rate &amp;lt;= 0.</source>
          <target state="translated">Чтобы включить каждое событие блокировки в профиль, проходной рейтинг = 1. Чтобы полностью отключить профилирование, проходной балл &amp;lt;= 0.</target>
        </trans-unit>
        <trans-unit id="5634feb2ac7b66d9d403fa3ba44d3dd35de4aafa" translate="yes" xml:space="preserve">
          <source>To insert a literal $ in the output, use $$ in the template.</source>
          <target state="translated">Чтобы вставить в выходной файл буквальный $,используйте $$ в шаблоне.</target>
        </trans-unit>
        <trans-unit id="fc7c25c25b23cfac629203b1f680a734ada8bcd7" translate="yes" xml:space="preserve">
          <source>To iterate over a list (where l is a *List):</source>
          <target state="translated">Чтобы выполнить итерацию над списком (где l-*Список):</target>
        </trans-unit>
        <trans-unit id="04464b93c140cce60515e90ab741d559641a3b86" translate="yes" xml:space="preserve">
          <source>To keep a file from being considered for the build:</source>
          <target state="translated">Чтобы файл не был рассмотрен для сборки:</target>
        </trans-unit>
        <trans-unit id="b8dd565d2e14c4949f658d07fd948bd6982afd99" translate="yes" xml:space="preserve">
          <source>To make a request with custom headers, use NewRequest and Client.Do.</source>
          <target state="translated">Чтобы сделать запрос с пользовательскими заголовками,используйте NewRequest и Client.Do.</target>
        </trans-unit>
        <trans-unit id="5032a2d57ff9e66d730ea600879b156b0a5e02a1" translate="yes" xml:space="preserve">
          <source>To make a request with custom headers, use NewRequest and DefaultClient.Do.</source>
          <target state="translated">Чтобы сделать запрос с пользовательскими заголовками,используйте NewRequest и DefaultClient.Do.</target>
        </trans-unit>
        <trans-unit id="706ee8ff1d514d4082de19c46038d881341df0b9" translate="yes" xml:space="preserve">
          <source>To maps the rune to the specified case: UpperCase, LowerCase, or TitleCase.</source>
          <target state="translated">Для привязки руны к указанному случаю:UpperCase,LowerCase или TitleCase.</target>
        </trans-unit>
        <trans-unit id="13858e1fce15a0a8116d4d08d0813cfa32d04dd1" translate="yes" xml:space="preserve">
          <source>To prevent IP spoofing, be sure to delete any pre-existing X-Forwarded-For header coming from the client or an untrusted proxy.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16db8fa630b8ed6e5e098c9ecc986852e23449ff" translate="yes" xml:space="preserve">
          <source>To prevent duplicate operations, ErrBadConn should NOT be returned if there's a possibility that the database server might have performed the operation. Even if the server sends back an error, you shouldn't return ErrBadConn.</source>
          <target state="translated">Во избежание дублирования операций,ErrBadConn НЕ следует возвращать,если есть вероятность того,что сервер базы данных мог выполнить эту операцию.Даже если сервер отсылает ошибку,ErrBadConn не следует возвращать.</target>
        </trans-unit>
        <trans-unit id="367a95ef6b89677c6010e99bfe83911bb6aa0ff5" translate="yes" xml:space="preserve">
          <source>To remove a prefix, use TrimPrefix instead.</source>
          <target state="translated">Чтобы удалить префикс,используйте вместо него TrimPrefix.</target>
        </trans-unit>
        <trans-unit id="651b4bc851ab5004fd129e9e0ff7675d7d666cef" translate="yes" xml:space="preserve">
          <source>To remove a suffix, use TrimSuffix instead.</source>
          <target state="translated">Чтобы удалить суффикс,используйте вместо него TrimSuffix.</target>
        </trans-unit>
        <trans-unit id="c83bbc4183fb8f4e0540869ebe8099226ccd8816" translate="yes" xml:space="preserve">
          <source>To set custom headers, use NewRequest and Client.Do.</source>
          <target state="translated">Для установки пользовательских заголовков используйте NewRequest и Client.Do.</target>
        </trans-unit>
        <trans-unit id="71135b9f4481c76b2f670b0d39a1f656b3961a0f" translate="yes" xml:space="preserve">
          <source>To set custom headers, use NewRequest and DefaultClient.Do.</source>
          <target state="translated">Для установки пользовательских заголовков используйте NewRequest и DefaultClient.Do.</target>
        </trans-unit>
        <trans-unit id="db9b30900d9da4419f81d83d998e553e2dab25bb" translate="yes" xml:space="preserve">
          <source>To support custom data types, implement NamedValueChecker. NamedValueChecker also allows queries to accept per-query options as a parameter by returning ErrRemoveArgument from CheckNamedValue.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9522949e411b2165edb986c411282650712ef336" translate="yes" xml:space="preserve">
          <source>To support tools that analyze Go packages, the patterns found in //go:embed lines are available in &amp;ldquo;go list&amp;rdquo; output. See the EmbedPatterns, TestEmbedPatterns, and XTestEmbedPatterns fields in the &amp;ldquo;go help list&amp;rdquo; output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75e0a568234c8cc832fa169bfc3c25d385870808" translate="yes" xml:space="preserve">
          <source>To translate these PCs into symbolic information such as function names and line numbers, use CallersFrames. CallersFrames accounts for inlined functions and adjusts the return program counters into call program counters. Iterating over the returned slice of PCs directly is discouraged, as is using FuncForPC on any of the returned PCs, since these cannot account for inlining or return program counter adjustment.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83002d8cdc0fe4d874cff59ee6e149e3669f91df" translate="yes" xml:space="preserve">
          <source>To translate these PCs into symbolic information such as function names and line numbers, use CallersFrames. CallersFrames accounts for inlined functions and adjusts the return program counters into call program counters. Iterating over the returned slice of PCs directly is discouraged, as is using FuncForPC on any of the returned PCs, since these cannot account for inlining or return program counter adjustment. go:noinline</source>
          <target state="translated">Для перевода этих ПК в символическую информацию,такую как имена функций и номера линий,используйте CallersFrames.CallersFrames учитывает инкапсулированные функции и настраивает счетчики программы возврата в счетчики программы вызова.Итерация по возвращаемому фрагменту ПК напрямую не рекомендуется,так же как и использование FuncForPC на любом из возвращаемых ПК,поскольку они не могут учитывать настройку счетчиков программы возврата или вставки.go:noinline</target>
        </trans-unit>
        <trans-unit id="3b553336a2ed0371927e0210cc490999d6f454c6" translate="yes" xml:space="preserve">
          <source>To turn off profiling entirely, pass rate 0. To just read the current rate, pass rate &amp;lt; 0. (For n&amp;gt;1 the details of sampling may change.)</source>
          <target state="translated">Чтобы полностью отключить профилирование, введите значение 0. Чтобы просто прочитать текущую скорость, укажите значение &amp;lt;0. (Для n&amp;gt; 1 детали выборки могут измениться).</target>
        </trans-unit>
        <trans-unit id="ec0c40fcb609291204c17f8d3e9e4a0cf0fb716d" translate="yes" xml:space="preserve">
          <source>To unmarshal JSON into a pointer, Unmarshal first handles the case of the JSON being the JSON literal null. In that case, Unmarshal sets the pointer to nil. Otherwise, Unmarshal unmarshals the JSON into the value pointed at by the pointer. If the pointer is nil, Unmarshal allocates a new value for it to point to.</source>
          <target state="translated">Чтобы разобрать JSON на указатель,Unmarshal сначала рассматривает дело о том,что JSON является буквальным нулем JSON.В этом случае Unmarshal устанавливает указатель на ноль.В противном случае,Unmarshal размагничивает JSON в значение,на которое указывает указатель.Если указатель равен нулю,Unmarshal присваивает указателю новое значение.</target>
        </trans-unit>
        <trans-unit id="9ec7dbd6621b41728144a0cd3fc2c36f64948e68" translate="yes" xml:space="preserve">
          <source>To unmarshal JSON into a struct, Unmarshal matches incoming object keys to the keys used by Marshal (either the struct field name or its tag), preferring an exact match but also accepting a case-insensitive match. By default, object keys which don't have a corresponding struct field are ignored (see Decoder.DisallowUnknownFields for an alternative).</source>
          <target state="translated">Для разделения JSON на структуру,Unmarshal сопоставляет входящие ключи объектов с ключами,используемыми маршалом (либо имя поля структуры,либо его тег),предпочитая точное совпадение,но также принимая нечувствительное к регистру совпадение.По умолчанию ключи объектов,которые не имеют соответствующего поля struct,игнорируются (см.альтернативу в Decoder.DisallowUnknownFields).</target>
        </trans-unit>
        <trans-unit id="a6bdbb20d4135a3bc4596a68aa8c2c34912d504d" translate="yes" xml:space="preserve">
          <source>To unmarshal JSON into a value implementing the Unmarshaler interface, Unmarshal calls that value's UnmarshalJSON method, including when the input is a JSON null. Otherwise, if the value implements encoding.TextUnmarshaler and the input is a JSON quoted string, Unmarshal calls that value's UnmarshalText method with the unquoted form of the string.</source>
          <target state="translated">Для разделения JSON на значение,реализующее интерфейс Unmarshaler,Unmarshal вызывает метод UnmarshalJSON этого значения,в том числе и тогда,когда входной JSON нуль.В противном случае,если значение реализует кодировку.TextUnmarshaler и на входе находится JSON цитируемая строка,Unmarshal вызывает метод UnmarshalText этого значения с нецитируемой формой строки.</target>
        </trans-unit>
        <trans-unit id="c66b5ce0cf55557d8e9fd777ec15355bade4e117" translate="yes" xml:space="preserve">
          <source>To unmarshal JSON into an interface value, Unmarshal stores one of these in the interface value:</source>
          <target state="translated">Чтобы разобрать JSON на значение интерфейса,Unmarshal запоминает одно из них в значении интерфейса:</target>
        </trans-unit>
        <trans-unit id="94c1b420cdca6fe4940f209d9a41f19875bfb4e7" translate="yes" xml:space="preserve">
          <source>To unmarshal a JSON array into a Go array, Unmarshal decodes JSON array elements into corresponding Go array elements. If the Go array is smaller than the JSON array, the additional JSON array elements are discarded. If the JSON array is smaller than the Go array, the additional Go array elements are set to zero values.</source>
          <target state="translated">Для разделения массива JSON на массив Go,Unmarshal декодирует элементы массива JSON в соответствующие элементы массива Go.Если массив Go меньше массива JSON,то дополнительные JSON-элементы массива отбрасываются.Если JSON-массив меньше массива Go,то дополнительные элементы массива Go устанавливаются в нулевое значение.</target>
        </trans-unit>
        <trans-unit id="ed4bdd964a47161b70a00bdaa7dc00eb114dff57" translate="yes" xml:space="preserve">
          <source>To unmarshal a JSON array into a slice, Unmarshal resets the slice length to zero and then appends each element to the slice. As a special case, to unmarshal an empty JSON array into a slice, Unmarshal replaces the slice with a new empty slice.</source>
          <target state="translated">Для размартировки JSON-массива в срез Unmarshal сбрасывает длину среза до нуля и затем добавляет каждый элемент в срез.В особом случае,чтобы размартировать пустой JSON-массив в кусочек,Unmarshal заменяет кусочек на новый пустой кусочек.</target>
        </trans-unit>
        <trans-unit id="007b32960f68d5d51b318bb76ca9ea0286f4126d" translate="yes" xml:space="preserve">
          <source>To unmarshal a JSON object into a map, Unmarshal first establishes a map to use. If the map is nil, Unmarshal allocates a new map. Otherwise Unmarshal reuses the existing map, keeping existing entries. Unmarshal then stores key-value pairs from the JSON object into the map. The map's key type must either be a string, an integer, or implement encoding.TextUnmarshaler.</source>
          <target state="translated">Чтобы размагнитить JSON-объект на карте,Unmarshal сначала устанавливает карту для использования.Если карта нулевая,Unmarshal выделяет новую карту.В противном случае Unmarshal повторно использует существующую карту,сохраняя существующие записи.Unmarshal затем сохраняет пары значений клавиш из JSON-объекта на карте.Тип ключа карты должен быть либо строкой,либо целым числом,либо реализовывать кодировку.TextUnmarshaler.</target>
        </trans-unit>
        <trans-unit id="6d6fc53f4b0d33aa877b6d747d45b96f410c47fc" translate="yes" xml:space="preserve">
          <source>To unmarshal a JSON object into a map, Unmarshal first establishes a map to use. If the map is nil, Unmarshal allocates a new map. Otherwise Unmarshal reuses the existing map, keeping existing entries. Unmarshal then stores key-value pairs from the JSON object into the map. The map's key type must either be any string type, an integer, implement json.Unmarshaler, or implement encoding.TextUnmarshaler.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b87bf4d25ca4624c96c72d4062afc898f384fa73" translate="yes" xml:space="preserve">
          <source>To use a Pipeline p to manage multiple clients on a connection, each client should run:</source>
          <target state="translated">Чтобы использовать Pipeline p для управления несколькими клиентами в соединении,каждый клиент должен быть запущен:</target>
        </trans-unit>
        <trans-unit id="f6369ce890fdc06aa42e060bacdc465b9893f8d9" translate="yes" xml:space="preserve">
          <source>To use a fixed length slice, or a preallocated one, use FillBytes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="800eefdd201759f89cf9257524a524d86be67a56" translate="yes" xml:space="preserve">
          <source>To use an existing prepared statement on this transaction, see Tx.Stmt.</source>
          <target state="translated">О том,как использовать существующее подготовленное заявление по этой сделке,см.в Tx.Stmt.</target>
        </trans-unit>
        <trans-unit id="2a7b3f715f9964aa312835dc3f2ae71cd3041225" translate="yes" xml:space="preserve">
          <source>To use an fs.FS implementation, use http.FS to convert it:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c3bf1a32c9b769f727db4118e0b83ca4bb4efa4" translate="yes" xml:space="preserve">
          <source>To use gobs, create an Encoder and present it with a series of data items as values or addresses that can be dereferenced to values. The Encoder makes sure all type information is sent before it is needed. At the receive side, a Decoder retrieves values from the encoded stream and unpacks them into local variables.</source>
          <target state="translated">Чтобы использовать пульты,создайте кодировщик и предоставьте ему серию элементов данных в виде значений или адресов,которые могут быть разыменованы на значения.Кодировщик обеспечивает отправку всей информации о типе перед тем,как она понадобится.На стороне приема декодер извлекает значения из кодированного потока и распаковывает их в локальные переменные.</target>
        </trans-unit>
        <trans-unit id="8212c55a0bf9e12d2e296b39237ee5f72cae9d11" translate="yes" xml:space="preserve">
          <source>To use pprof, link this package into your program:</source>
          <target state="translated">Чтобы использовать pprof,свяжите этот пакет с вашей программой:</target>
        </trans-unit>
        <trans-unit id="5c29e8288fd1ed9e073fe203fb55fbea12d062de" translate="yes" xml:space="preserve">
          <source>To use the operating system's file system implementation, use http.Dir:</source>
          <target state="translated">Для использования реализации файловой системы операционной системы используйте http.Dir:</target>
        </trans-unit>
        <trans-unit id="467272919dc8f37262b26b52d65afd618589f7ff" translate="yes" xml:space="preserve">
          <source>To view all available profiles, open &lt;a href=&quot;http://localhost:6060/debug/pprof/&quot;&gt;http://localhost:6060/debug/pprof/&lt;/a&gt; in your browser.</source>
          <target state="translated">Чтобы просмотреть все доступные профили, откройте в браузере &lt;a href=&quot;http://localhost:6060/debug/pprof/&quot;&gt;http: // localhost: 6060 / debug / pprof /&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4193fe2d5f7ce0c7cb324cbe3968e7d5bd540d92" translate="yes" xml:space="preserve">
          <source>To write a new test suite, create a file whose name ends _test.go that contains the TestXxx functions as described here. Put the file in the same package as the one being tested. The file will be excluded from regular package builds but will be included when the &quot;go test&quot; command is run. For more detail, run &quot;go help test&quot; and &quot;go help testflag&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1229c7d06cb687b015bf9729398a1b9b76a455a" translate="yes" xml:space="preserve">
          <source>To write a new test suite, create a file whose name ends _test.go that contains the TestXxx functions as described here. Put the file in the same package as the one being tested. The file will be excluded from regular package builds but will be included when the &amp;ldquo;go test&amp;rdquo; command is run. For more detail, run &amp;ldquo;go help test&amp;rdquo; and &amp;ldquo;go help testflag&amp;rdquo;.</source>
          <target state="translated">Чтобы написать новый набор тестов, создайте файл с именем, оканчивающимся на _test.go, который содержит функции TestXxx, как описано здесь. Поместите файл в тот же пакет, что и тестируемый. Этот файл будет исключен из обычных сборок пакетов, но будет включен при запуске команды &amp;laquo;go test&amp;raquo;. Для получения дополнительных сведений запустите &amp;laquo;go help test&amp;raquo; и &amp;laquo;go help testflag&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="2392dbedc5657df0a5a8c5b158593f759c811858" translate="yes" xml:space="preserve">
          <source>To16 converts the IP address ip to a 16-byte representation. If ip is not an IP address (it is the wrong length), To16 returns nil.</source>
          <target state="translated">To16 преобразует IP-адрес ip в 16-байтовое представление.Если ip не является IP-адресом (это неправильная длина),то To16 возвращает ноль.</target>
        </trans-unit>
        <trans-unit id="4294dda7ebb07f9702b0ce5cc1cb8bbf6e004822" translate="yes" xml:space="preserve">
          <source>To4 converts the IPv4 address ip to a 4-byte representation. If ip is not an IPv4 address, To4 returns nil.</source>
          <target state="translated">To4 преобразует IPv4-адрес ip в 4-байтовое представление.Если ip не является IPv4-адресом,To4 возвращает ноль.</target>
        </trans-unit>
        <trans-unit id="7deadbf704990f79d3e4df9686f8846e15431131" translate="yes" xml:space="preserve">
          <source>ToComplex converts x to a Complex value if x is representable as a Complex. Otherwise it returns an Unknown.</source>
          <target state="translated">ToComplex преобразует x в значение Complex,если x представлен как Complex.В противном случае возвращается значение Неизвестно.</target>
        </trans-unit>
        <trans-unit id="95e3b1fabb27004c6322f401e410b77c8beecafb" translate="yes" xml:space="preserve">
          <source>ToFloat converts x to a Float value if x is representable as a Float. Otherwise it returns an Unknown.</source>
          <target state="translated">ToFloat преобразует x в значение Float,если x представлен как Float.В противном случае возвращается значение Неизвестно.</target>
        </trans-unit>
        <trans-unit id="f5e30e0ab3c38971ff0a23a0823ee7ab2da27587" translate="yes" xml:space="preserve">
          <source>ToHTML converts comment text to formatted HTML. The comment was prepared by DocReader, so it is known not to have leading, trailing blank lines nor to have trailing spaces at the end of lines. The comment markers have already been removed.</source>
          <target state="translated">ToHTML конвертирует текст комментария в форматированный HTML.Комментарий был подготовлен DocReader,поэтому известно,что в нем нет ни ведущих,ни следящих пустых строк,ни следящих пробелов в конце строк.Маркеры комментариев уже удалены.</target>
        </trans-unit>
        <trans-unit id="2f4af6e587a0b093dcea21d741f457946dac2539" translate="yes" xml:space="preserve">
          <source>ToInt converts x to an Int value if x is representable as an Int. Otherwise it returns an Unknown.</source>
          <target state="translated">ToInt преобразует x в значение Int,если x представлен как Int.В противном случае возвращается значение Неизвестно.</target>
        </trans-unit>
        <trans-unit id="2458b21542ecbc0f90f413b7ee46521686d711b0" translate="yes" xml:space="preserve">
          <source>ToLower</source>
          <target state="translated">ToLower</target>
        </trans-unit>
        <trans-unit id="6fec192e916332e15759b9ef1699226d11bdd209" translate="yes" xml:space="preserve">
          <source>ToLower maps the rune to lower case giving priority to the special mapping.</source>
          <target state="translated">ToLower maps руна в нижнем регистре,отдавая приоритет специальному отображению.</target>
        </trans-unit>
        <trans-unit id="0d0c9cd1331838718de8a67a4fe3f8edaf0bf598" translate="yes" xml:space="preserve">
          <source>ToLower maps the rune to lower case.</source>
          <target state="translated">ToLower отображает руну в нижнем регистре.</target>
        </trans-unit>
        <trans-unit id="0ad2eff81c68ba7feeec4169aa737e669765ecb3" translate="yes" xml:space="preserve">
          <source>ToLower returns a copy of the byte slice s with all Unicode letters mapped to their lower case.</source>
          <target state="translated">ToLower возвращает копию среза байта s с отображением всех букв Unicode в нижнем регистре.</target>
        </trans-unit>
        <trans-unit id="9ce8fb31583c9a3f9db4dda94a7dc14fcb01df77" translate="yes" xml:space="preserve">
          <source>ToLower returns s with all Unicode letters mapped to their lower case.</source>
          <target state="translated">ToLower возвращает s с отображением всех букв Unicode в нижнем регистре.</target>
        </trans-unit>
        <trans-unit id="7c6c5994143b17fa29690098b9cf21d8ab0c9626" translate="yes" xml:space="preserve">
          <source>ToLowerSpecial</source>
          <target state="translated">ToLowerSpecial</target>
        </trans-unit>
        <trans-unit id="a0c9710a46fb772958369a0897c7471714aeeeb8" translate="yes" xml:space="preserve">
          <source>ToLowerSpecial returns a copy of the string s with all Unicode letters mapped to their lower case using the case mapping specified by c.</source>
          <target state="translated">ToLowerSpecial возвращает копию строки s со всеми Unicode буквами,отображенными в нижний регистр с помощью отображения регистра,заданного c.</target>
        </trans-unit>
        <trans-unit id="cb046f134facad4d83f3df18153937dc0992ea81" translate="yes" xml:space="preserve">
          <source>ToLowerSpecial treats s as UTF-8-encoded bytes and returns a copy with all the Unicode letters mapped to their lower case, giving priority to the special casing rules.</source>
          <target state="translated">ToLowerSpecial рассматривает s как байты в кодировке UTF-8 и возвращает копию с отображением всех букв Unicode в нижнем регистре,отдавая приоритет специальным правилам оболочки.</target>
        </trans-unit>
        <trans-unit id="494e4ed4c22e6b9204664a8671089fb351d285ee" translate="yes" xml:space="preserve">
          <source>ToRDNSequence converts n into a single RDNSequence. The following attributes are encoded as multi-value RDNs:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2915308ca78a335773afea42473f5f868e85f100" translate="yes" xml:space="preserve">
          <source>ToSlash returns the result of replacing each separator character in path with a slash ('/') character. Multiple separators are replaced by multiple slashes.</source>
          <target state="translated">ToSlash возвращает результат замены каждого символа разделителя в пути на символ косой черты ('/').Несколько разделителей заменяются на несколько косых черт.</target>
        </trans-unit>
        <trans-unit id="ce9610dd835f1269c70383a5f4c28b5a0b063015" translate="yes" xml:space="preserve">
          <source>ToText prepares comment text for presentation in textual output. It wraps paragraphs of text to width or fewer Unicode code points and then prefixes each line with the indent. In preformatted sections (such as program text), it prefixes each non-blank line with preIndent.</source>
          <target state="translated">ToText подготавливает текст комментария для представления в текстовом виде.Он обертывает параграфы текста до ширины или меньшего количества точек кода Юникода,а затем префиксов каждой строки с отступом.В предварительно отформатированных разделах (например,в тексте программы)он префиксовывает каждую незаполненную строку с префиксом.</target>
        </trans-unit>
        <trans-unit id="687882b6dd58f630b4dc72d2b748bc2e5e517506" translate="yes" xml:space="preserve">
          <source>ToTitle</source>
          <target state="translated">ToTitle</target>
        </trans-unit>
        <trans-unit id="16626ca02836f3e96b71ac083f67d856672bee6a" translate="yes" xml:space="preserve">
          <source>ToTitle maps the rune to title case giving priority to the special mapping.</source>
          <target state="translated">ToTitle привязывает руну к заголовку,отдавая приоритет специальному отображению.</target>
        </trans-unit>
        <trans-unit id="82652cb33ebff96d0745bbb70b7b14b2b4f648b7" translate="yes" xml:space="preserve">
          <source>ToTitle maps the rune to title case.</source>
          <target state="translated">ToTitle привязывает руну к заголовку.</target>
        </trans-unit>
        <trans-unit id="b6339ce57388ab9579ed7dea7397386892cd79b3" translate="yes" xml:space="preserve">
          <source>ToTitle returns a copy of the string s with all Unicode letters mapped to their Unicode title case.</source>
          <target state="translated">ToTitle возвращает копию строки s со всеми буквами Юникода,привязанными к их Unicode заголовку.</target>
        </trans-unit>
        <trans-unit id="7c8bdbfdcd905744bd6bd92b5f2c2fe7b0b2a605" translate="yes" xml:space="preserve">
          <source>ToTitle treats s as UTF-8-encoded bytes and returns a copy with all the Unicode letters mapped to their title case.</source>
          <target state="translated">ToTitle рассматривает s как байты в кодировке UTF-8 и возвращает копию со всеми буквами Unicode,привязанными к их регистру заголовка.</target>
        </trans-unit>
        <trans-unit id="a7e031c3da9f939af57fa1eda658027190b07385" translate="yes" xml:space="preserve">
          <source>ToTitleSpecial</source>
          <target state="translated">ToTitleSpecial</target>
        </trans-unit>
        <trans-unit id="6c2252d5e081e10993ad66199a6ce0f9c88000da" translate="yes" xml:space="preserve">
          <source>ToTitleSpecial returns a copy of the string s with all Unicode letters mapped to their Unicode title case, giving priority to the special casing rules.</source>
          <target state="translated">ToTitleSpecial возвращает копию строки s со всеми буквами Unicode,привязанными к их Unicode заголовку,отдавая приоритет специальным правилам оболочки.</target>
        </trans-unit>
        <trans-unit id="03ad764cc2cf6e71773b140dd2607d85f903d19e" translate="yes" xml:space="preserve">
          <source>ToTitleSpecial treats s as UTF-8-encoded bytes and returns a copy with all the Unicode letters mapped to their title case, giving priority to the special casing rules.</source>
          <target state="translated">ToTitleSpecial рассматривает s как байты в кодировке UTF-8 и возвращает копию со всеми буквами Unicode,привязанными к их заглавному регистру,отдавая приоритет специальным правилам оболочки.</target>
        </trans-unit>
        <trans-unit id="0c72db5394ee29e5b12a191ab1a0f08579c43c0b" translate="yes" xml:space="preserve">
          <source>ToUpper</source>
          <target state="translated">ToUpper</target>
        </trans-unit>
        <trans-unit id="8830c3933f2751182fd45204e5ac41041c190ab0" translate="yes" xml:space="preserve">
          <source>ToUpper maps the rune to upper case giving priority to the special mapping.</source>
          <target state="translated">В верхнем регистре руна сопоставляется с верхним регистром,отдавая приоритет специальному отображению.</target>
        </trans-unit>
        <trans-unit id="9762b6a1a0f8f68d12efc0853373d81b1198caf9" translate="yes" xml:space="preserve">
          <source>ToUpper maps the rune to upper case.</source>
          <target state="translated">Верхний план отображает руну в верхний регистр.</target>
        </trans-unit>
        <trans-unit id="587e23bede12f256b7a2b187d202dc77575c043c" translate="yes" xml:space="preserve">
          <source>ToUpper returns a copy of the byte slice s with all Unicode letters mapped to their upper case.</source>
          <target state="translated">ToUpper возвращает копию среза байта s со всеми буквами Unicode,отображенными в верхнем регистре.</target>
        </trans-unit>
        <trans-unit id="1567cbaa93e2803c0387b5e052b94febf77b0dce" translate="yes" xml:space="preserve">
          <source>ToUpper returns s with all Unicode letters mapped to their upper case.</source>
          <target state="translated">ToUpper возвращает s с отображением всех букв Unicode в верхнем регистре.</target>
        </trans-unit>
        <trans-unit id="e8e18cf71c085c852139f777c3a777629eaba1d4" translate="yes" xml:space="preserve">
          <source>ToUpperSpecial</source>
          <target state="translated">ToUpperSpecial</target>
        </trans-unit>
        <trans-unit id="ca298ca7f1f797ffc04335283b821c4509371407" translate="yes" xml:space="preserve">
          <source>ToUpperSpecial returns a copy of the string s with all Unicode letters mapped to their upper case using the case mapping specified by c.</source>
          <target state="translated">ToUpperSpecial возвращает копию строки s со всеми Unicode буквами,отображенными в их заглавный регистр с помощью отображения регистра,заданного c.</target>
        </trans-unit>
        <trans-unit id="e092426a213e149b750e5c739fd48245f35d6f1d" translate="yes" xml:space="preserve">
          <source>ToUpperSpecial treats s as UTF-8-encoded bytes and returns a copy with all the Unicode letters mapped to their upper case, giving priority to the special casing rules.</source>
          <target state="translated">ToUpperSpecial рассматривает s как байты в кодировке UTF-8 и возвращает копию с отображением всех букв Unicode в верхнем регистре,отдавая приоритет специальным правилам оболочки.</target>
        </trans-unit>
        <trans-unit id="2918f3c11590ab69ac359dd26f3078e378d4433f" translate="yes" xml:space="preserve">
          <source>ToValidUTF8 returns a copy of the string s with each run of invalid UTF-8 byte sequences replaced by the replacement string, which may be empty.</source>
          <target state="translated">ToValidUTF8 возвращает копию строки s с каждым запуском недействительных последовательностей UTF-8 байт,заменённых строкой замены,которая может быть пустой.</target>
        </trans-unit>
        <trans-unit id="8ddb5599f330dcf8a14e657f65440d11567b1275" translate="yes" xml:space="preserve">
          <source>ToValidUTF8 treats s as UTF-8-encoded bytes and returns a copy with each run of bytes representing invalid UTF-8 replaced with the bytes in replacement, which may be empty.</source>
          <target state="translated">ToValidUTF8 рассматривает s как байты в кодировке UTF-8 и возвращает копию с каждым прогоном байтов,представляющих недействительный UTF-8,заменённую на байты в замене,которые могут быть пустыми.</target>
        </trans-unit>
        <trans-unit id="0e6e43d719b59d2f4b6d64b0d7506414e902ac66" translate="yes" xml:space="preserve">
          <source>Token expands self-closing elements such as &amp;lt;br/&amp;gt; into separate start and end elements returned by successive calls.</source>
          <target state="translated">Token расширяет самозакрывающиеся элементы, такие как &amp;lt;br/&amp;gt;, на отдельные начальные и конечные элементы, возвращаемые последовательными вызовами.</target>
        </trans-unit>
        <trans-unit id="76c580b187cf47d391aca0669ed50d6bdc842bd1" translate="yes" xml:space="preserve">
          <source>Token guarantees that the StartElement and EndElement tokens it returns are properly nested and matched: if Token encounters an unexpected end element or EOF before all expected end elements, it will return an error.</source>
          <target state="translated">Token гарантирует,что возвращаемые им маркеры StartElement и EndElement правильно вложены и сопоставлены:если Token столкнется с неожиданным конечным элементом или EOF перед всеми ожидаемыми конечными элементами,он вернет ошибку.</target>
        </trans-unit>
        <trans-unit id="20226a10555b22d829b042743665e60ca5ccfcef" translate="yes" xml:space="preserve">
          <source>Token guarantees that the delimiters [ ] { } it returns are properly nested and matched: if Token encounters an unexpected delimiter in the input, it will return an error.</source>
          <target state="translated">Token гарантирует,что возвращаемые разделители[]{}корректно вложены и сопоставлены:если Token столкнется с неожиданным разделителем во входных данных,он вернет ошибку.</target>
        </trans-unit>
        <trans-unit id="d280a9431f5d23758a555c6128dd19caf82e90f5" translate="yes" xml:space="preserve">
          <source>Token implements XML name spaces as described by &lt;a href=&quot;https://www.w3.org/TR/REC-xml-names/&quot;&gt;https://www.w3.org/TR/REC-xml-names/&lt;/a&gt;. Each of the Name structures contained in the Token has the Space set to the URL identifying its name space when known. If Token encounters an unrecognized name space prefix, it uses the prefix as the Space rather than report an error.</source>
          <target state="translated">Токен реализует пространства имен XML, как описано в &lt;a href=&quot;https://www.w3.org/TR/REC-xml-names/&quot;&gt;https://www.w3.org/TR/REC-xml-names/&lt;/a&gt; . Каждая из структур Name, содержащихся в токене, имеет пробел, установленный на URL-адрес, идентифицирующий его пространство имен, когда оно известно. Если токен встречает нераспознанный префикс пространства имен, он использует префикс в качестве пробела, а не сообщает об ошибке.</target>
        </trans-unit>
        <trans-unit id="3daac00da8a20a3986aa0fc3ba367725df5511ad" translate="yes" xml:space="preserve">
          <source>Token is the set of lexical tokens of the Go programming language.</source>
          <target state="translated">Токен-это набор лексических маркеров языка программирования Go.</target>
        </trans-unit>
        <trans-unit id="347b518b7ad14bbb5cbe2525a0e1cce83a18759e" translate="yes" xml:space="preserve">
          <source>Token returns the next JSON token in the input stream. At the end of the input stream, Token returns nil, io.EOF.</source>
          <target state="translated">Токен возвращает следующий JSON-токен во входном потоке.В конце входного потока Token возвращает ноль,io.EOF.</target>
        </trans-unit>
        <trans-unit id="fb460c5b7cbda3e107ef11644b412428d80a074a" translate="yes" xml:space="preserve">
          <source>Token returns the next XML token in the input stream. At the end of the input stream, Token returns nil, io.EOF.</source>
          <target state="translated">Токен возвращает следующий XML-токен во входном потоке.В конце входного потока Token возвращает ноль,io.EOF.</target>
        </trans-unit>
        <trans-unit id="1f5c5f661288844b6f2ecd574998016319ee9039" translate="yes" xml:space="preserve">
          <source>TokenString returns a printable string for a token or Unicode character.</source>
          <target state="translated">TokenString возвращает строку для печати маркера или символа Юникода.</target>
        </trans-unit>
        <trans-unit id="1a94c716310bd537564c947b302962f8f4ba3d71" translate="yes" xml:space="preserve">
          <source>TokenText returns the string corresponding to the most recently scanned token. Valid after calling Scan and in calls of Scanner.Error.</source>
          <target state="translated">TokenText возвращает строку,соответствующую последнему отсканированному токену.Проверяется после вызова Scanner.Error и в вызовах Scanner.Error.</target>
        </trans-unit>
        <trans-unit id="a7a728d87ab600f19a872de7d10dd426fc51a410" translate="yes" xml:space="preserve">
          <source>ToolDir is the directory containing build tools.</source>
          <target state="translated">ToolDir-это каталог,содержащий инструменты сборки.</target>
        </trans-unit>
        <trans-unit id="4fa8cc860c52b268dc6a3adcde7305e9415db5bb" translate="yes" xml:space="preserve">
          <source>Tools</source>
          <target state="translated">Tools</target>
        </trans-unit>
        <trans-unit id="84f632ebde53766b4762c1e662046a0bdb1f9bee" translate="yes" xml:space="preserve">
          <source>Trace responds with the execution trace in binary form. Tracing lasts for duration specified in seconds GET parameter, or for 1 second if not specified. The package initialization registers it as /debug/pprof/trace.</source>
          <target state="translated">Трассировка отвечает трассировкой исполнения в двоичном виде.Трассировка длится в течение указанного в секундах GET-параметра или в течение 1 секунды,если не указано.Инициализация пакета регистрирует его как /debug/pprof/trace.</target>
        </trans-unit>
        <trans-unit id="37fcf61c233a1ae946b84a69b2de57281c31900c" translate="yes" xml:space="preserve">
          <source>Tracing runtime activities</source>
          <target state="translated">Отслеживание работы в режиме реального времени</target>
        </trans-unit>
        <trans-unit id="bf930f74e883c038922957814259a08b1e5e21b8" translate="yes" xml:space="preserve">
          <source>TrailerPrefix is a magic prefix for ResponseWriter.Header map keys that, if present, signals that the map entry is actually for the response trailers, and not the response headers. The prefix is stripped after the ServeHTTP call finishes and the values are sent in the trailers.</source>
          <target state="translated">TrailerPrefix-это волшебный префикс для ключей карты ResponseWriter.Header,который,если присутствует,сигнализирует о том,что запись на карте на самом деле предназначена для трейлеров-ответчиков,а не для заголовков ответов.Префикс снимается после завершения вызова ServeHTTP,и значения передаются в трейлерах.</target>
        </trans-unit>
        <trans-unit id="d08af63de6fd07c70bf3724749899391ccd80f36" translate="yes" xml:space="preserve">
          <source>TrailingZeroBits returns the number of consecutive least significant zero bits of |x|.</source>
          <target state="translated">TrailingZeroBits возвращает количество последовательных минимально значимых нулевых битов |x|.</target>
        </trans-unit>
        <trans-unit id="173da913d8c53620762557efaa7f685234fe0888" translate="yes" xml:space="preserve">
          <source>TrailingZeros returns the number of trailing zero bits in x; the result is UintSize for x == 0.</source>
          <target state="translated">TrailingZeros возвращает количество нулевых битов трейлинга в x;результат UintSize для x ==0.</target>
        </trans-unit>
        <trans-unit id="3880be13b458ed7d8fd6226152f09a84df60affe" translate="yes" xml:space="preserve">
          <source>TrailingZeros16</source>
          <target state="translated">TrailingZeros16</target>
        </trans-unit>
        <trans-unit id="ac0e8b17c92ec54246a916c7c60a5898e47d2440" translate="yes" xml:space="preserve">
          <source>TrailingZeros16 returns the number of trailing zero bits in x; the result is 16 for x == 0.</source>
          <target state="translated">TrailingZeros16 возвращает количество нулевых битов трейлинга в x;результат 16 для x ==0.</target>
        </trans-unit>
        <trans-unit id="9ccb48d1009c49f2458e70054ffb06de2c2e52b1" translate="yes" xml:space="preserve">
          <source>TrailingZeros32</source>
          <target state="translated">TrailingZeros32</target>
        </trans-unit>
        <trans-unit id="ef12b2bd72258ab1ea24487faaf1b36b6624d53b" translate="yes" xml:space="preserve">
          <source>TrailingZeros32 returns the number of trailing zero bits in x; the result is 32 for x == 0.</source>
          <target state="translated">TrailingZeros32 возвращает количество нулевых битов трейлинга в x;результат 32 для x ==0.</target>
        </trans-unit>
        <trans-unit id="8645dda5fc4ccfbadfe816f019759dd903a6b384" translate="yes" xml:space="preserve">
          <source>TrailingZeros64</source>
          <target state="translated">TrailingZeros64</target>
        </trans-unit>
        <trans-unit id="9c1806ac56295eeda1305a5c016e361813241700" translate="yes" xml:space="preserve">
          <source>TrailingZeros64 returns the number of trailing zero bits in x; the result is 64 for x == 0.</source>
          <target state="translated">TrailingZeros64 возвращает количество нулевых бит трейлинга в x;результат 64 для x ==0.</target>
        </trans-unit>
        <trans-unit id="56b19e298a41e007826d31fb347a4fad087efb44" translate="yes" xml:space="preserve">
          <source>TrailingZeros8</source>
          <target state="translated">TrailingZeros8</target>
        </trans-unit>
        <trans-unit id="a51f3a70d56ba40f5381588670a32ee940f76014" translate="yes" xml:space="preserve">
          <source>TrailingZeros8 returns the number of trailing zero bits in x; the result is 8 for x == 0.</source>
          <target state="translated">TrailingZeros8 возвращает количество нулевых битов трейлинга в x;результат 8 для x ==0.</target>
        </trans-unit>
        <trans-unit id="c46e526f87b0902843d5c82001fbd44e74d2f2d7" translate="yes" xml:space="preserve">
          <source>Transport is an implementation of RoundTripper that supports HTTP, HTTPS, and HTTP proxies (for either HTTP or HTTPS with CONNECT).</source>
          <target state="translated">Transport-это реализация RoundTripper,которая поддерживает HTTP,HTTPS и HTTP прокси (для HTTP или HTTPS с ПОДТВЕРЖДЕНИЕМ).</target>
        </trans-unit>
        <trans-unit id="28030ddb48df392e29b838aa75a73353cb5390cf" translate="yes" xml:space="preserve">
          <source>Transport only retries a request upon encountering a network error if the request is idempotent and either has no body or has its Request.GetBody defined. HTTP requests are considered idempotent if they have HTTP methods GET, HEAD, OPTIONS, or TRACE; or if their Header map contains an &quot;Idempotency-Key&quot; or &quot;X-Idempotency-Key&quot; entry. If the idempotency key value is a zero-length slice, the request is treated as idempotent but the header is not sent on the wire.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a7dd5c9993ccdafc8353b9b9fef9d118c35957f" translate="yes" xml:space="preserve">
          <source>Transport only retries a request upon encountering a network error if the request is idempotent and either has no body or has its Request.GetBody defined. HTTP requests are considered idempotent if they have HTTP methods GET, HEAD, OPTIONS, or TRACE; or if their Header map contains an &quot;Idempotency-Key&quot; or &quot;X-Idempotency-Key&quot; entry. If the idempotency key value is an zero-length slice, the request is treated as idempotent but the header is not sent on the wire.</source>
          <target state="translated">Транспорт только повторяет запрос при обнаружении сетевой ошибки,если запрос является idempotent и либо не имеет тела,либо имеет свой запрос Request.GetBody.HTTP-запросы считаются idempotent,если у них есть HTTP-методы GET,HEAD,OPTIONS или TRACE;или если их карта заголовка содержит запись &quot;Idempotency-Key&quot; или &quot;X-Idempotency-Key&quot;.Если значение ключа idempotency является срезом нулевой длины,запрос рассматривается как idempotent,но заголовок не посылается на телеграф.</target>
        </trans-unit>
        <trans-unit id="a83654a5778fc158c90c291f8461263d34090fc9" translate="yes" xml:space="preserve">
          <source>Transport uses HTTP/1.1 for HTTP URLs and either HTTP/1.1 or HTTP/2 for HTTPS URLs, depending on whether the server supports HTTP/2, and how the Transport is configured. The DefaultTransport supports HTTP/2. To explicitly enable HTTP/2 on a transport, use golang.org/x/net/http2 and call ConfigureTransport. See the package docs for more about HTTP/2.</source>
          <target state="translated">Транспорт использует HTTP/1.1 для HTTP URL и либо HTTP/1.1,либо HTTP/2 для HTTPS URL,в зависимости от того,поддерживает ли сервер HTTP/2 и как сконфигурирован Транспорт.DefaultTransport поддерживает HTTP/2.Чтобы явно включить HTTP/2 на транспорте,используйте golang.org/x/net/http2 и позвоните ConfigureTransport.Подробнее о HTTP/2 смотрите в документации к пакету.</target>
        </trans-unit>
        <trans-unit id="5cba3ebebe9967d6b406fbd61cc05ffea9ddcf56" translate="yes" xml:space="preserve">
          <source>Transports should be reused instead of created as needed. Transports are safe for concurrent use by multiple goroutines.</source>
          <target state="translated">Транспорт следует использовать повторно,а не создавать по мере необходимости.Транспорты безопасны для одновременного использования несколькими горутинами.</target>
        </trans-unit>
        <trans-unit id="cf5547182a53dd7a581affea62258ee59e262b85" translate="yes" xml:space="preserve">
          <source>Tree is the representation of a single parsed template.</source>
          <target state="translated">Дерево-это представление одного разобранного шаблона.</target>
        </trans-unit>
        <trans-unit id="0266abd25371ad4670b041dda4dc487ed199d641" translate="yes" xml:space="preserve">
          <source>Trim</source>
          <target state="translated">Trim</target>
        </trans-unit>
        <trans-unit id="abb910d5bd0bd319cf1d5ef7ad6a5112dc6c0823" translate="yes" xml:space="preserve">
          <source>Trim returns a slice of the string s with all leading and trailing Unicode code points contained in cutset removed.</source>
          <target state="translated">Обрезка возвращает кусок строки s со всеми ведущими и ведущими точками кода Юникода,содержащимися в наборе сокращений.</target>
        </trans-unit>
        <trans-unit id="4f07669cc579ec14df811b3ca5fc72fde4f78f58" translate="yes" xml:space="preserve">
          <source>Trim returns a subslice of s by slicing off all leading and trailing UTF-8-encoded code points contained in cutset.</source>
          <target state="translated">Trim возвращает сублицензию s,отсекая все ведущие и конечные точки кода в кодировке UTF-8,содержащиеся в наборе сокращений.</target>
        </trans-unit>
        <trans-unit id="ba1962dfeb4e006658709dd72ff841213f7d1db0" translate="yes" xml:space="preserve">
          <source>TrimBytes returns b without leading and trailing ASCII space.</source>
          <target state="translated">TrimBytes возвращает b без ведущего и отстающего ASCII пространства.</target>
        </trans-unit>
        <trans-unit id="a48987784fdcef3e797c48099ede26a7260db2de" translate="yes" xml:space="preserve">
          <source>TrimFunc</source>
          <target state="translated">TrimFunc</target>
        </trans-unit>
        <trans-unit id="03343404f4f9dd2a23fda87bf2a4805f3806059d" translate="yes" xml:space="preserve">
          <source>TrimFunc returns a slice of the string s with all leading and trailing Unicode code points c satisfying f(c) removed.</source>
          <target state="translated">TrimFunc возвращает кусок строки s со всеми ведущими и ведущими точками кода Юникода c,удовлетворяющими f(c).</target>
        </trans-unit>
        <trans-unit id="625b4a484772db3f9992725f710f3d189c47d0db" translate="yes" xml:space="preserve">
          <source>TrimFunc returns a subslice of s by slicing off all leading and trailing UTF-8-encoded code points c that satisfy f(c).</source>
          <target state="translated">TrimFunc возвращает сублицензию s,отсекая все ведущие и последующие кодированные UTF-8 точки c,которые удовлетворяют f(c).</target>
        </trans-unit>
        <trans-unit id="b796ff265d1cc90c9b78c76a3f12dd8cbff027a6" translate="yes" xml:space="preserve">
          <source>TrimLeft</source>
          <target state="translated">TrimLeft</target>
        </trans-unit>
        <trans-unit id="3406f99b35b8781b2e30c5d4f1fb92b18ccfb0a0" translate="yes" xml:space="preserve">
          <source>TrimLeft returns a slice of the string s with all leading Unicode code points contained in cutset removed.</source>
          <target state="translated">TrimLeft возвращает кусок строки s со всеми ведущими точками кода Юникода,содержащимися в наборе сокращений.</target>
        </trans-unit>
        <trans-unit id="b52b880dc01fa22cd46ff385a39b5609f426247b" translate="yes" xml:space="preserve">
          <source>TrimLeft returns a subslice of s by slicing off all leading UTF-8-encoded code points contained in cutset.</source>
          <target state="translated">TrimLeft возвращает подстроку s,отсекая все ведущие точки кода в кодировке UTF-8,содержащиеся в наборе сокращений.</target>
        </trans-unit>
        <trans-unit id="0dda8e3188c1b3df6f3a5c77e5010dd280c96425" translate="yes" xml:space="preserve">
          <source>TrimLeftFunc</source>
          <target state="translated">TrimLeftFunc</target>
        </trans-unit>
        <trans-unit id="2a771ac81b0579d70a2a4390b741d5fed266d711" translate="yes" xml:space="preserve">
          <source>TrimLeftFunc returns a slice of the string s with all leading Unicode code points c satisfying f(c) removed.</source>
          <target state="translated">TrimLeftFunc возвращает кусок строки s со всеми ведущими точками кода Юникода c,удовлетворяющими f(c).</target>
        </trans-unit>
        <trans-unit id="49c15e330f226f8800b406f97802237df2f3f947" translate="yes" xml:space="preserve">
          <source>TrimLeftFunc treats s as UTF-8-encoded bytes and returns a subslice of s by slicing off all leading UTF-8-encoded code points c that satisfy f(c).</source>
          <target state="translated">TrimLeftFunc рассматривает s как байты в кодировке UTF-8 и возвращает подстроку s,отсекая все ведущие кодировочные точки в кодировке UTF-8,удовлетворяющие f(c).</target>
        </trans-unit>
        <trans-unit id="f6781400f56acf5b8bc035e02b3cdac08b09ae64" translate="yes" xml:space="preserve">
          <source>TrimPrefix</source>
          <target state="translated">TrimPrefix</target>
        </trans-unit>
        <trans-unit id="0cdb8742fe0e8f96e729ab0932195bcd75f8a8b2" translate="yes" xml:space="preserve">
          <source>TrimPrefix returns s without the provided leading prefix string. If s doesn't start with prefix, s is returned unchanged.</source>
          <target state="translated">TrimPrefix возвращает s без предоставленной ведущей префиксной строки.Если s не начинается с префикса,s возвращается без изменений.</target>
        </trans-unit>
        <trans-unit id="3a3dc250671844d052f305fc24e91daa5dfaf78b" translate="yes" xml:space="preserve">
          <source>TrimRight</source>
          <target state="translated">TrimRight</target>
        </trans-unit>
        <trans-unit id="f36ec5b5c4656d60b56116c5bdb688d629f84c86" translate="yes" xml:space="preserve">
          <source>TrimRight returns a slice of the string s, with all trailing Unicode code points contained in cutset removed.</source>
          <target state="translated">TrimRight возвращает кусок строки s,при этом все трейлинговые точки кода Юникода,содержащиеся в наборе сокращений,удаляются.</target>
        </trans-unit>
        <trans-unit id="3ca08db3862d11ac280fa859c98a5062cca7758f" translate="yes" xml:space="preserve">
          <source>TrimRight returns a subslice of s by slicing off all trailing UTF-8-encoded code points that are contained in cutset.</source>
          <target state="translated">TrimRight возвращает сублицензию s,отсекая все трейлинговые точки кода в кодировке UTF-8,которые содержатся в наборе сокращений.</target>
        </trans-unit>
        <trans-unit id="2face4904f1360f377438b017515ff3c2359f581" translate="yes" xml:space="preserve">
          <source>TrimRightFunc</source>
          <target state="translated">TrimRightFunc</target>
        </trans-unit>
        <trans-unit id="91f9e348fa7e18e840cf0ac3e8dc3a6295b78762" translate="yes" xml:space="preserve">
          <source>TrimRightFunc returns a slice of the string s with all trailing Unicode code points c satisfying f(c) removed.</source>
          <target state="translated">TrimRightFunc возвращает фрагмент строки s со всеми удаленными точками кода Юникода в трейлинге c,удовлетворяющими f(c).</target>
        </trans-unit>
        <trans-unit id="af58ad241c06498d7e5d96dabf6a334e19cb450d" translate="yes" xml:space="preserve">
          <source>TrimRightFunc returns a subslice of s by slicing off all trailing UTF-8-encoded code points c that satisfy f(c).</source>
          <target state="translated">TrimRightFunc возвращает сублицензию s,отсекая все трейлинговые кодированные UTF-8 точки c,удовлетворяющие f(c).</target>
        </trans-unit>
        <trans-unit id="3b9759ef917cd034e3fff66af6781ac1144ddf76" translate="yes" xml:space="preserve">
          <source>TrimSpace</source>
          <target state="translated">TrimSpace</target>
        </trans-unit>
        <trans-unit id="fb7131e90264c0cc3ce43bd31575b4282b5313c8" translate="yes" xml:space="preserve">
          <source>TrimSpace returns a slice of the string s, with all leading and trailing white space removed, as defined by Unicode.</source>
          <target state="translated">TrimSpace возвращает фрагмент строки s,с удалением всех лидирующих и скользящих белых пробелов,как определено в Юникоде.</target>
        </trans-unit>
        <trans-unit id="a187e5cf0dba2afc1b0487c662e640873854f7ec" translate="yes" xml:space="preserve">
          <source>TrimSpace returns a subslice of s by slicing off all leading and trailing white space, as defined by Unicode.</source>
          <target state="translated">TrimSpace возвращает сублицензию s,отрезая все ведущее и ведущее белое пространство,как определено в Юникоде.</target>
        </trans-unit>
        <trans-unit id="b11fe2b91f56619862961192ca92d40d14d67c9d" translate="yes" xml:space="preserve">
          <source>TrimString returns s without leading and trailing ASCII space.</source>
          <target state="translated">TrimString возвращает s без ведущего и отстающего ASCII пространства.</target>
        </trans-unit>
        <trans-unit id="31564f1b1fc10c6dcf98b0ba8f0d174cf833e697" translate="yes" xml:space="preserve">
          <source>TrimSuffix</source>
          <target state="translated">TrimSuffix</target>
        </trans-unit>
        <trans-unit id="92a8263afbc0fa4c5341e4098b039907219bbb45" translate="yes" xml:space="preserve">
          <source>TrimSuffix returns s without the provided trailing suffix string. If s doesn't end with suffix, s is returned unchanged.</source>
          <target state="translated">TrimSuffix возвращает s без прилагаемой суффиксной строки трейлинга.Если s не заканчивается суффиксом,s возвращается без изменений.</target>
        </trans-unit>
        <trans-unit id="0b8272d0bb8c9199c72411e406f2643a93b7ccca" translate="yes" xml:space="preserve">
          <source>Trunc</source>
          <target state="translated">Trunc</target>
        </trans-unit>
        <trans-unit id="4ac265259166695b742658a267b27c17c43d2d87" translate="yes" xml:space="preserve">
          <source>Trunc returns the integer value of x.</source>
          <target state="translated">Усечение возвращает целое значение x.</target>
        </trans-unit>
        <trans-unit id="a6f2f1d850d6a1bef2ab8b526d322b73779287f1" translate="yes" xml:space="preserve">
          <source>Truncate changes the size of the file. It does not change the I/O offset. If there is an error, it will be of type *PathError.</source>
          <target state="translated">Усечение изменяет размер файла.Не изменяет смещение ввода/вывода.Если есть ошибка,то она будет иметь тип *PathError.</target>
        </trans-unit>
        <trans-unit id="062334176014417d736c93d4f00898bc3b617151" translate="yes" xml:space="preserve">
          <source>Truncate changes the size of the named file. If the file is a symbolic link, it changes the size of the link's target. If there is an error, it will be of type *PathError.</source>
          <target state="translated">Усечение изменяет размер именованного файла.Если файл является символической ссылкой,то изменяется размер целевой ссылки.Если есть ошибка,то она будет иметь тип *PathError.</target>
        </trans-unit>
        <trans-unit id="e8c4ef35e7ba4d40ba29121e1bd589ff3e80bcb3" translate="yes" xml:space="preserve">
          <source>Truncate discards all but the first n unread bytes from the buffer but continues to use the same allocated storage. It panics if n is negative or greater than the length of the buffer.</source>
          <target state="translated">Усечение отбрасывает из буфера все,кроме первого n непрочитанных байт,но продолжает использовать то же самое выделенное хранилище.Она паникует,если n отрицательно или больше длины буфера.</target>
        </trans-unit>
        <trans-unit id="32beb0b08a1549453f279d1334d844a2afaea49a" translate="yes" xml:space="preserve">
          <source>Truncate operates on the time as an absolute duration since the zero time; it does not operate on the presentation form of the time. Thus, Truncate(Hour) may return a time with a non-zero minute, depending on the time's Location.</source>
          <target state="translated">Усеченный оперирует временем как абсолютной длительностью с нулевого времени;он не оперирует формой представления времени.Таким образом,усечение (час)может возвращать время с ненулевой минутой,в зависимости от местоположения времени.</target>
        </trans-unit>
        <trans-unit id="71998d5a06a6fc24a70aad616e3e9f7ea3e57939" translate="yes" xml:space="preserve">
          <source>Truncate returns the result of rounding d toward zero to a multiple of m. If m &amp;lt;= 0, Truncate returns d unchanged.</source>
          <target state="translated">Truncate возвращает результат округления d в сторону нуля до кратного m. Если m &amp;lt;= 0, Truncate возвращает d без изменений.</target>
        </trans-unit>
        <trans-unit id="498fecdf2960f4ea8c81a3634a3c6208f18d44bd" translate="yes" xml:space="preserve">
          <source>Truncate returns the result of rounding t down to a multiple of d (since the zero time). If d &amp;lt;= 0, Truncate returns t stripped of any monotonic clock reading but otherwise unchanged.</source>
          <target state="translated">Truncate возвращает результат округления t до кратного d (с нулевого времени). Если d &amp;lt;= 0, Truncate возвращает t без каких-либо монотонных показаний часов, но в остальном без изменений.</target>
        </trans-unit>
        <trans-unit id="7a922bb8e2913cab6dcad5ba9140345fb42fa502" translate="yes" xml:space="preserve">
          <source>TruncateWriter returns a Writer that writes to w but stops silently after n bytes.</source>
          <target state="translated">TruncateWriter возвращает Writer,который записывает в w,но беззвучно останавливается после n байт.</target>
        </trans-unit>
        <trans-unit id="66617c3163f43664fa6ddb9c95a7d88a932b782b" translate="yes" xml:space="preserve">
          <source>Truthy returns the JavaScript &quot;truthiness&quot; of the value v. In JavaScript, false, 0, &quot;&quot;, null, undefined, and NaN are &quot;falsy&quot;, and everything else is &quot;truthy&quot;. See &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Truthy&quot;&gt;https://developer.mozilla.org/en-US/docs/Glossary/Truthy&lt;/a&gt;.</source>
          <target state="translated">Truthy возвращает &amp;laquo;истинность&amp;raquo; значения v в JavaScript. В JavaScript false, 0, &amp;laquo;&amp;raquo;, null, undefined и NaN являются &amp;laquo;ложными&amp;raquo;, а все остальное - &amp;laquo;правдивыми&amp;raquo;. См. &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Truthy&quot;&gt;Https://developer.mozilla.org/en-US/docs/Glossary/Truthy&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c26728b3acc2b9a34150900b5536db30082f4043" translate="yes" xml:space="preserve">
          <source>TryRecv attempts to receive a value from the channel v but will not block. It panics if v's Kind is not Chan. If the receive delivers a value, x is the transferred value and ok is true. If the receive cannot finish without blocking, x is the zero Value and ok is false. If the channel is closed, x is the zero value for the channel's element type and ok is false.</source>
          <target state="translated">TryRecv пытается получить значение из канала v,но не блокирует.Будет паника,если v's Kind-это не Chan.Если приемник выдает значение,то x-это передаваемое значение,а ok-это правда.Если прием не может закончиться без блокировки,x-нулевое значение,а ok-ложное.Если канал закрыт,x-нулевое значение для типа элемента канала и ok-ложь.</target>
        </trans-unit>
        <trans-unit id="febc1b0170a31256a4ba31c38646abd1c14c7afb" translate="yes" xml:space="preserve">
          <source>TrySend attempts to send x on the channel v but will not block. It panics if v's Kind is not Chan. It reports whether the value was sent. As in Go, x's value must be assignable to the channel's element type.</source>
          <target state="translated">TrySend пытается отправить x на канал v,но не блокирует.Будет паника,если v's Kind-это не Chan.Он сообщает,было ли отправлено значение.Как и в Go,значение x должно быть присвоено типу элемента канала.</target>
        </trans-unit>
        <trans-unit id="7fd5a63a31a17c2aa8f2b5b0d5183f5173b04681" translate="yes" xml:space="preserve">
          <source>Two keys are only considered to have the same value if they have the same Curve value. Note that for example elliptic.P256() and elliptic.P256().Params() are different values, as the latter is a generic not constant time implementation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad904f452afce8318d85fd92e9c6e068ca4fed6e" translate="yes" xml:space="preserve">
          <source>Two sets of interfaces are included in this package. When a more abstract interface isn't necessary, there are functions for encrypting/decrypting with v1.5/OAEP and signing/verifying with v1.5/PSS. If one needs to abstract over the public key primitive, the PrivateKey type implements the Decrypter and Signer interfaces from the crypto package.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="042f2d498c44806f60201f1f05491910d5c73fe8" translate="yes" xml:space="preserve">
          <source>Two sets of interfaces are included in this package. When a more abstract interface isn't necessary, there are functions for encrypting/decrypting with v1.5/OAEP and signing/verifying with v1.5/PSS. If one needs to abstract over the public-key primitive, the PrivateKey struct implements the Decrypter and Signer interfaces from the crypto package.</source>
          <target state="translated">В комплект поставки входят два набора интерфейсов.Когда более абстрактный интерфейс не нужен,есть функции для шифрования/дешифрования с помощью v1.5/OAEP и подписания/проверки с помощью v1.5/PSS.Если необходимо абстрагироваться через примитив public-key,то структура PrivateKey реализует интерфейсы Decrypter и Signer из пакета crypto.</target>
        </trans-unit>
        <trans-unit id="021677bbd9ee4b61e5a1312cf21d452a27661c48" translate="yes" xml:space="preserve">
          <source>Tx is a transaction.</source>
          <target state="translated">Tx-это сделка.</target>
        </trans-unit>
        <trans-unit id="02cdcf0d841ea4d5e8abf2653c842d138120149a" translate="yes" xml:space="preserve">
          <source>Tx is an in-progress database transaction.</source>
          <target state="translated">Tx-это незавершенная транзакция с базой данных.</target>
        </trans-unit>
        <trans-unit id="41b6053676814b4fe97b2c9be9a306ee614bfa3d" translate="yes" xml:space="preserve">
          <source>Tx.ExecContext</source>
          <target state="translated">Tx.ExecContext</target>
        </trans-unit>
        <trans-unit id="2825856698e10e430365413d889b83a20654a02a" translate="yes" xml:space="preserve">
          <source>Tx.Prepare</source>
          <target state="translated">Tx.Prepare</target>
        </trans-unit>
        <trans-unit id="ef76ba4edb63dbd2cd7bf54f9037e276e1229e5a" translate="yes" xml:space="preserve">
          <source>Tx.Rollback</source>
          <target state="translated">Tx.Rollback</target>
        </trans-unit>
        <trans-unit id="a83fe983647bcf7e1590d7bef39b1b437680667a" translate="yes" xml:space="preserve">
          <source>TxOptions holds the transaction options to be used in DB.BeginTx.</source>
          <target state="translated">TxOptions удерживает опционы на транзакции,которые будут использоваться в DB.BeginTx.</target>
        </trans-unit>
        <trans-unit id="46eaf072cf758f74571ec8685b65883630652645" translate="yes" xml:space="preserve">
          <source>TxOptions holds the transaction options.</source>
          <target state="translated">TxOptions удерживает опционы на сделки.</target>
        </trans-unit>
        <trans-unit id="68e7b01d33d203d9281e2f2dd8f3398104376276" translate="yes" xml:space="preserve">
          <source>Typ contains the predeclared *Basic types indexed by their corresponding BasicKind.</source>
          <target state="translated">Typ содержит предзаявленные *Basic типы,индексируемые соответствующим им BasicKind.</target>
        </trans-unit>
        <trans-unit id="64f24b17ea9baa36a77dc3d1afdc32b1a420fb9e" translate="yes" xml:space="preserve">
          <source>Type flags for Header.Typeflag.</source>
          <target state="translated">Флаги типа Header.Typeflag.</target>
        </trans-unit>
        <trans-unit id="04ccb52737e3e40430c97b234b8f24e390173f8b" translate="yes" xml:space="preserve">
          <source>Type inference computes the type (Type) of every expression (ast.Expr) and checks for compliance with the language specification. Use Info.Types[expr].Type for the results of type inference.</source>
          <target state="translated">Вывод типа вычисляет тип (Type)каждого выражения (ast.Expr)и проверяет соответствие спецификации языка.Для получения результатов вывода типа используйте Info.Types[expr].Type.</target>
        </trans-unit>
        <trans-unit id="8035b14525c84dd4e5349419c0ff657e153c1c32" translate="yes" xml:space="preserve">
          <source>Type is found in Header.Type.</source>
          <target state="translated">Тип найден в заголовке.</target>
        </trans-unit>
        <trans-unit id="ec7bc4958b2c43e87f98f2ef7e1adb5d065d5c5e" translate="yes" xml:space="preserve">
          <source>Type is here for the purposes of documentation only. It is a stand-in for any Go type, but represents the same type for any given function invocation.</source>
          <target state="translated">Тип приведен здесь только для документации.Он является дублером для любого типа Go,но представляет собой тот же самый тип для любого заданного вызова функции.</target>
        </trans-unit>
        <trans-unit id="233ac19906546712346f536e7ee3880b82162310" translate="yes" xml:space="preserve">
          <source>Type is the documentation for a type declaration.</source>
          <target state="translated">Тип-это документация по типовым декларациям.</target>
        </trans-unit>
        <trans-unit id="d3c0b263d515209e36ac606a05719bce899addba" translate="yes" xml:space="preserve">
          <source>Type is the representation of a Go type.</source>
          <target state="translated">Тип-это представление типа &quot;Го&quot;.</target>
        </trans-unit>
        <trans-unit id="c3bca7d619ddc3b0ec61fb8f295216cb63f22eb4" translate="yes" xml:space="preserve">
          <source>Type reads the type at off in the DWARF &amp;ldquo;info&amp;rdquo; section.</source>
          <target state="translated">Тип читает тип в выключенном состоянии в разделе &amp;laquo;информация&amp;raquo; DWARF.</target>
        </trans-unit>
        <trans-unit id="1fce0b09390d2c3838db788c0cf76f63a5bf80a9" translate="yes" xml:space="preserve">
          <source>Type represents the JavaScript type of a Value.</source>
          <target state="translated">Тип представляет собой JavaScript тип значения.</target>
        </trans-unit>
        <trans-unit id="e06c5701673348f2eed499aa753a2ba395d1a12d" translate="yes" xml:space="preserve">
          <source>Type returns itself and provides an easy default implementation for embedding in a Node. Embedded in all non-trivial Nodes.</source>
          <target state="translated">Type возвращает себя и обеспечивает простую реализацию по умолчанию для встраивания в узел.Встраивается во все нетривиальные узлы.</target>
        </trans-unit>
        <trans-unit id="4726645469f41dd7bcb1d47132c78e582530c7e1" translate="yes" xml:space="preserve">
          <source>Type returns the JavaScript type of the value v. It is similar to JavaScript's typeof operator, except that it returns TypeNull instead of TypeObject for null.</source>
          <target state="translated">Type возвращает JavaScript-тип значения v.Он похож на JavaScript-оператор typeof,за исключением того,что возвращает TypeNull вместо TypeObject для null.</target>
        </trans-unit>
        <trans-unit id="2fa9db8cb436bbb192eec5d03d6240277e6eeffd" translate="yes" xml:space="preserve">
          <source>Type returns the object's type.</source>
          <target state="translated">Type возвращает тип объекта.</target>
        </trans-unit>
        <trans-unit id="d1407fc8c8322906d1372dd8a45dc51e6205559f" translate="yes" xml:space="preserve">
          <source>Type returns the type of x.f, which may be different from the type of f. See Selection for more information.</source>
          <target state="translated">Тип возвращает тип x.f,который может отличаться от типа f.Дополнительные сведения см.в разделе Выбор.</target>
        </trans-unit>
        <trans-unit id="55e720628bd8b49b52419d5886faf349fa86465b" translate="yes" xml:space="preserve">
          <source>Type returns type bits in m (m &amp;amp; ModeType).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="372fc3db84eb7f93272dcba175262aaab1565f30" translate="yes" xml:space="preserve">
          <source>Type returns v's type.</source>
          <target state="translated">Тип возвращает тип v.</target>
        </trans-unit>
        <trans-unit id="55dbc1b43ee6cb3b1548172b193bc2a7d3e5eca5" translate="yes" xml:space="preserve">
          <source>Type values are comparable, such as with the == operator, so they can be used as map keys. Two Type values are equal if they represent identical types.</source>
          <target state="translated">Значения типов сравнимы,например,с оператором ==,поэтому их можно использовать в качестве ключей карты.Два значения Type равны,если они представляют одинаковые типы.</target>
        </trans-unit>
        <trans-unit id="7bdac7349f75285c99f4a03ea2e2de6365f45c2a" translate="yes" xml:space="preserve">
          <source>Type-checking consists of several interdependent phases:</source>
          <target state="translated">Проверка типа состоит из нескольких взаимозависимых фаз:</target>
        </trans-unit>
        <trans-unit id="26984be5e6e3b06475f717ab4d76ce6f4ff88c54" translate="yes" xml:space="preserve">
          <source>Type1 is here for the purposes of documentation only. It is a stand-in for any Go type, but represents the same type for any given function invocation.</source>
          <target state="translated">Type1 приведен здесь только для документации.Он является дублером для любого типа Go,но представляет собой один и тот же тип для любого заданного вызова функции.</target>
        </trans-unit>
        <trans-unit id="7ace60c9c3dbd05ce39ba29e759c6ad4a52088eb" translate="yes" xml:space="preserve">
          <source>TypeAndValue reports the type and value (for constants) of the corresponding expression.</source>
          <target state="translated">TypeAndValue сообщает тип и значение (для констант)соответствующего выражения.</target>
        </trans-unit>
        <trans-unit id="2bc75a2b4beae4c84f906bb525769e97f38f0823" translate="yes" xml:space="preserve">
          <source>TypeByExtension returns the MIME type associated with the file extension ext. The extension ext should begin with a leading dot, as in &quot;.html&quot;. When ext has no associated type, TypeByExtension returns &quot;&quot;.</source>
          <target state="translated">TypeByExtension возвращает MIME тип,ассоциированный с расширением файлового расширения.Расширение должно начинаться с ведущей точки,как в &quot;.html&quot;.Если расширение не имеет ассоциированного типа,то TypeByExtension возвращает &quot;&quot;.</target>
        </trans-unit>
        <trans-unit id="263318bcaf840ab395175e373b1ab05080a86fda" translate="yes" xml:space="preserve">
          <source>TypeOf</source>
          <target state="translated">TypeOf</target>
        </trans-unit>
        <trans-unit id="94969a4aec167529cd20467de358b3733a4d1890" translate="yes" xml:space="preserve">
          <source>TypeOf returns the reflection Type that represents the dynamic type of i. If i is a nil interface value, TypeOf returns nil.</source>
          <target state="translated">TypeOf возвращает тип отражения,представляющий динамический тип i.Если i-это значение интерфейса nil,то TypeOf возвращает nil.</target>
        </trans-unit>
        <trans-unit id="610b14205855f95702d99da6e19e5297b1301163" translate="yes" xml:space="preserve">
          <source>TypeOf returns the type of expression e, or nil if not found. Precondition: the Types, Uses and Defs maps are populated.</source>
          <target state="translated">TypeOf возвращает тип выражения e,или nil,если не найдено.Предусловие:заполняются карты Types,Uses и Defs.</target>
        </trans-unit>
        <trans-unit id="af91dac9977c975dbcb45d1e0c495727ba389f89" translate="yes" xml:space="preserve">
          <source>TypeString returns the string representation of typ. The Qualifier controls the printing of package-level objects, and may be nil.</source>
          <target state="translated">TypeString возвращает строковое представление типа.Квалификатор управляет печатью объектов на уровне пакетов и может быть нулевым.</target>
        </trans-unit>
        <trans-unit id="70c0f61c1717bc58a510efe98bd7a3251bcbbcc7" translate="yes" xml:space="preserve">
          <source>Typed Strings</source>
          <target state="translated">Типизированные строки</target>
        </trans-unit>
        <trans-unit id="802976d08e8f16b7d83d8d12b5129fe9e25c37e3" translate="yes" xml:space="preserve">
          <source>Types HTML, JS, URL, and others from content.go can carry safe content that is exempted from escaping.</source>
          <target state="translated">Типы HTML,JS,URL и другие из content.go могут содержать безопасное содержимое,которое освобождается от экранирования.</target>
        </trans-unit>
        <trans-unit id="cea554202fc0c5ff6482d3e61417b6640fc17af4" translate="yes" xml:space="preserve">
          <source>Types and Values</source>
          <target state="translated">Типы и значения</target>
        </trans-unit>
        <trans-unit id="4a237767760223207248b2b72e8a0eb1c03dbe30" translate="yes" xml:space="preserve">
          <source>Types implementing Valuer interface are able to convert themselves to a driver Value.</source>
          <target state="translated">Типы,реализующие интерфейс Valuer,способны преобразовывать себя в Value драйвера.</target>
        </trans-unit>
        <trans-unit id="738f4e11bb80f11f67d45a4481cf366179186823" translate="yes" xml:space="preserve">
          <source>Types of signals</source>
          <target state="translated">Типы сигналов</target>
        </trans-unit>
        <trans-unit id="4a68e8d3eb65d7282f5ff466196272be854598ae" translate="yes" xml:space="preserve">
          <source>Typical usage inside a test is:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b842957498ea8405dcbf49648de63b65b478d2cb" translate="yes" xml:space="preserve">
          <source>UDPAddr represents the address of a UDP end point.</source>
          <target state="translated">UDPAddr представляет собой адрес конечной точки UDP.</target>
        </trans-unit>
        <trans-unit id="b3b4fc6834e1c9d716c787f9ac0d161736c5f604" translate="yes" xml:space="preserve">
          <source>UDPConn is the implementation of the Conn and PacketConn interfaces for UDP network connections.</source>
          <target state="translated">UDPConn-это реализация интерфейсов Conn и PacketConn для сетевых UDP-соединений.</target>
        </trans-unit>
        <trans-unit id="b499255e82796e4d28d962954395ad3d893bac9c" translate="yes" xml:space="preserve">
          <source>UDPConn.WriteTo</source>
          <target state="translated">UDPConn.WriteTo</target>
        </trans-unit>
        <trans-unit id="0e2d9b0777a485c1276de0803c12a7d76fbc5c39" translate="yes" xml:space="preserve">
          <source>URL</source>
          <target state="translated">URL</target>
        </trans-unit>
        <trans-unit id="2113a36dc330dedde4db70e90a71dcb67bd4a9a2" translate="yes" xml:space="preserve">
          <source>URL (Roundtrip)</source>
          <target state="translated">URL-адрес (Roundtrip)</target>
        </trans-unit>
        <trans-unit id="a727ea70072d81d7b63c816962c8a756b508329a" translate="yes" xml:space="preserve">
          <source>URL encapsulates a known safe URL or URL substring (see RFC 3986). A URL like `javascript:checkThatFormNotEditedBeforeLeavingPage()` from a trusted source should go in the page, but by default dynamic `javascript:` URLs are filtered out since they are a frequently exploited injection vector.</source>
          <target state="translated">URL-адрес инкапсулирует известную безопасную подстроку URL-адреса или URL-адреса (см.RFC 3986).URL типа `javascript:checkThatFormNotEditedBeforeLeavingPage()` из доверенного источника должен попасть на страницу,но по умолчанию динамические `javascript:` URL отфильтровываются,так как они являются часто используемым вектором инъекций.</target>
        </trans-unit>
        <trans-unit id="9f6702283d55dba63f2c15c6981885271e829853" translate="yes" xml:space="preserve">
          <source>URL's String method uses the EscapedPath method to obtain the path. See the EscapedPath method for more details.</source>
          <target state="translated">Метод URL String использует метод EscapedPath для получения пути.См.подробнее метод EscapedPath.</target>
        </trans-unit>
        <trans-unit id="a7ffebe53d073d64da891027cdca3ef31de6ee7a" translate="yes" xml:space="preserve">
          <source>URL.EscapedFragment</source>
          <target state="translated">URL.EscapedFragment</target>
        </trans-unit>
        <trans-unit id="fb15045a2812519f4e1083e5cb90b2d16bf5e0e2" translate="yes" xml:space="preserve">
          <source>URL.EscapedPath</source>
          <target state="translated">URL.EscapedPath</target>
        </trans-unit>
        <trans-unit id="4966fe66780da2ec3d10c8599e72fff7ab08a49a" translate="yes" xml:space="preserve">
          <source>URL.Hostname</source>
          <target state="translated">URL.Hostname</target>
        </trans-unit>
        <trans-unit id="93c3fa248c55505922464e5ed8d1899f54880821" translate="yes" xml:space="preserve">
          <source>URL.IsAbs</source>
          <target state="translated">URL.IsAbs</target>
        </trans-unit>
        <trans-unit id="c5ff099f399baf8e187d09b758e991f007d9fdbb" translate="yes" xml:space="preserve">
          <source>URL.MarshalBinary</source>
          <target state="translated">URL.MarshalBinary</target>
        </trans-unit>
        <trans-unit id="1f5b4a1bd876c3d2e848fa8ad0b5bcdecf59f3eb" translate="yes" xml:space="preserve">
          <source>URL.Parse</source>
          <target state="translated">URL.Parse</target>
        </trans-unit>
        <trans-unit id="df308e5c8e7a40f3e06e1c8f29546df6edd0815c" translate="yes" xml:space="preserve">
          <source>URL.Port</source>
          <target state="translated">URL.Port</target>
        </trans-unit>
        <trans-unit id="1f4af3bd8a928ef1166e58b54f440e84607bbe48" translate="yes" xml:space="preserve">
          <source>URL.Query</source>
          <target state="translated">URL.Query</target>
        </trans-unit>
        <trans-unit id="f2cbc812759bc0bcb35214d0c86a7a333cdc5ac4" translate="yes" xml:space="preserve">
          <source>URL.Redacted</source>
          <target state="translated">URL.Redacted</target>
        </trans-unit>
        <trans-unit id="2f6fe106a87daa55540bf1b3e2faa597e4637d72" translate="yes" xml:space="preserve">
          <source>URL.RequestURI</source>
          <target state="translated">URL.RequestURI</target>
        </trans-unit>
        <trans-unit id="5ef9cfae68b8e79167af493274ea7b99357dad6d" translate="yes" xml:space="preserve">
          <source>URL.ResolveReference</source>
          <target state="translated">URL.ResolveReference</target>
        </trans-unit>
        <trans-unit id="aae15178969446ff357ff699287cc769e108c1ee" translate="yes" xml:space="preserve">
          <source>URL.String</source>
          <target state="translated">URL.String</target>
        </trans-unit>
        <trans-unit id="ce84e8c5399c507871045bd05a22f805d2c4f2bd" translate="yes" xml:space="preserve">
          <source>URL.UnmarshalBinary</source>
          <target state="translated">URL.UnmarshalBinary</target>
        </trans-unit>
        <trans-unit id="ac64d1ff5ad8c8e979a983967383931627c1db93" translate="yes" xml:space="preserve">
          <source>URLEncoding is the alternate base64 encoding defined in RFC 4648. It is typically used in URLs and file names.</source>
          <target state="translated">URLEncoding-это альтернативная кодировка base64,определенная в RFC 4648.Обычно она используется в URL и именах файлов.</target>
        </trans-unit>
        <trans-unit id="c9df7bde57a8aa1d95e4f472d843c333da35563f" translate="yes" xml:space="preserve">
          <source>URLQueryEscaper returns the escaped value of the textual representation of its arguments in a form suitable for embedding in a URL query.</source>
          <target state="translated">URLQueryEscaper возвращает экранированное значение текстового представления его аргументов в форме,подходящей для встраивания в URL запрос.</target>
        </trans-unit>
        <trans-unit id="f75c8002cbe8f09b52b12100920f39a5c64e72ab" translate="yes" xml:space="preserve">
          <source>URLs in the comment text are converted into links; if the URL also appears in the words map, the link is taken from the map (if the corresponding map value is the empty string, the URL is not converted into a link).</source>
          <target state="translated">URL в тексте комментария преобразуются в ссылки;если URL также появляется в карте слов,то ссылка берется с карты (если соответствующее значение карты-пустая строка,то URL не преобразовывается в ссылку).</target>
        </trans-unit>
        <trans-unit id="66e91d3bfc1c62180f622950dd4b88caee7fb5f3" translate="yes" xml:space="preserve">
          <source>URLs that do not start with a slash after the scheme are interpreted as:</source>
          <target state="translated">URL,которые не начинаются со слеша после схемы,интерпретируются как:</target>
        </trans-unit>
        <trans-unit id="0809917b6f7b4556e78a9d2c239213f16de1592f" translate="yes" xml:space="preserve">
          <source>UTC represents Universal Coordinated Time (UTC).</source>
          <target state="translated">UTC представляет собой универсальное координированное время (UTC).</target>
        </trans-unit>
        <trans-unit id="2910e9336b266393bd7b3bb04c8ff09ab1ad423c" translate="yes" xml:space="preserve">
          <source>UTC returns t with the location set to UTC.</source>
          <target state="translated">UTC возвращает t с положением,установленным на UTC.</target>
        </trans-unit>
        <trans-unit id="bd4707cd474a6d0f83da094caeed9e471bb79e5c" translate="yes" xml:space="preserve">
          <source>Uint defines a uint flag with specified name, default value, and usage string. The return value is the address of a uint variable that stores the value of the flag.</source>
          <target state="translated">Uint определяет флаг uint с указанным именем,значением по умолчанию и строкой использования.Возвращаемое значение-адрес переменной uint,в которой хранится значение флага.</target>
        </trans-unit>
        <trans-unit id="c10a1c74871016b345bc36d5bdb30897f19968dc" translate="yes" xml:space="preserve">
          <source>Uint returns v's underlying value, as a uint64. It panics if v's Kind is not Uint, Uintptr, Uint8, Uint16, Uint32, or Uint64.</source>
          <target state="translated">Uint возвращает базовое значение v,как uint64.Возникает паника,если v's Kind не является Uint,Uintptr,Uint8,Uint16,Uint32 или Uint64.</target>
        </trans-unit>
        <trans-unit id="8c727e75a1c262fee3ed280d320bad7f8659ca56" translate="yes" xml:space="preserve">
          <source>Uint32 returns a pseudo-random 32-bit value as a uint32 from the default Source.</source>
          <target state="translated">Uint32 возвращает псевдослучайное 32-битное значение в виде uint32 из источника по умолчанию Source.</target>
        </trans-unit>
        <trans-unit id="e19c9ecfe9082dbf421a298c1c766023a8f7f823" translate="yes" xml:space="preserve">
          <source>Uint32 returns a pseudo-random 32-bit value as a uint32.</source>
          <target state="translated">Uint32 возвращает псевдослучайное 32-битное значение в виде uint32.</target>
        </trans-unit>
        <trans-unit id="030a2cb864d68ff2aba5fa883929c569cc36b65c" translate="yes" xml:space="preserve">
          <source>Uint64 defines a uint64 flag with specified name, default value, and usage string. The return value is the address of a uint64 variable that stores the value of the flag.</source>
          <target state="translated">Uint64 определяет флаг uint64 с указанным именем,значением по умолчанию и строкой использования.Возвращаемое значение-адрес переменной uint64,в которой хранится значение флага.</target>
        </trans-unit>
        <trans-unit id="6d3dffebe2bfc2c33c20643972b94062f6925708" translate="yes" xml:space="preserve">
          <source>Uint64 returns a pseudo-random 64-bit value as a uint64 from the default Source.</source>
          <target state="translated">Uint64 возвращает псевдослучайное 64-битное значение в виде uint64 из Source по умолчанию.</target>
        </trans-unit>
        <trans-unit id="4324e0d2d9e747146788fb1da362fb5053ac15fe" translate="yes" xml:space="preserve">
          <source>Uint64 returns a pseudo-random 64-bit value as a uint64.</source>
          <target state="translated">Uint64 возвращает псевдослучайное 64-битное значение в виде uint64.</target>
        </trans-unit>
        <trans-unit id="8f4f108ba23391540c5f57a2d283a1654c92a932" translate="yes" xml:space="preserve">
          <source>Uint64 returns a value drawn from the Zipf distribution described by the Zipf object.</source>
          <target state="translated">Uint64 возвращает значение,полученное из дистрибутива Zipf,описанного объектом Zipf.</target>
        </trans-unit>
        <trans-unit id="1ef36be6f6e6e03fddea6aa5e34904aadf0ca3e4" translate="yes" xml:space="preserve">
          <source>Uint64 returns the internal uint64 value for the metric.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e960db65d7bc2609ac63eaaddb18d0ce30fd34e" translate="yes" xml:space="preserve">
          <source>Uint64 returns the uint64 representation of x. If x cannot be represented in a uint64, the result is undefined.</source>
          <target state="translated">Uint64 возвращает uint64 представление x.Если x не может быть представлено в uint64,результат будет неопределен.</target>
        </trans-unit>
        <trans-unit id="4059a3fbb04daacbe98a3ac34acbb5b4f0511d79" translate="yes" xml:space="preserve">
          <source>Uint64 returns the unsigned integer resulting from truncating x towards zero. If 0 &amp;lt;= x &amp;lt;= math.MaxUint64, the result is Exact if x is an integer and Below otherwise. The result is (0, Above) for x &amp;lt; 0, and (math.MaxUint64, Below) for x &amp;gt; math.MaxUint64.</source>
          <target state="translated">Uint64 возвращает целое число без знака, полученное в результате усечения x до нуля. Если 0 &amp;lt;= x &amp;lt;= math.MaxUint64, результат будет Exact, если x является целым числом, и Lower в противном случае. Результатом будет (0, вверху) для x &amp;lt;0 и (math.MaxUint64, below) для x&amp;gt; math.MaxUint64.</target>
        </trans-unit>
        <trans-unit id="eee8610c675fa51e59aceef9ba15ad48fc3f7656" translate="yes" xml:space="preserve">
          <source>Uint64Val returns the Go uint64 value of x and whether the result is exact; x must be an Int or an Unknown. If the result is not exact, its value is undefined. If x is Unknown, the result is (0, false).</source>
          <target state="translated">Uint64Val возвращает Go uint64 значение x и точный ли результат;x должен быть Int или Unknown.Если результат не точный,то его значение не определено.Если x неизвестно,то результат будет (0,ложь).</target>
        </trans-unit>
        <trans-unit id="f8a9446572ec072b0dca42654febb328f4183bda" translate="yes" xml:space="preserve">
          <source>Uint64Var defines a uint64 flag with specified name, default value, and usage string. The argument p points to a uint64 variable in which to store the value of the flag.</source>
          <target state="translated">Uint64Var определяет флаг uint64 с указанным именем,значением по умолчанию и строкой использования.Аргумент p указывает на переменную uint64,в которой будет храниться значение флага.</target>
        </trans-unit>
        <trans-unit id="496dd0effb0126ef9e845598a59198590bcd043e" translate="yes" xml:space="preserve">
          <source>UintSize is the size of a uint in bits.</source>
          <target state="translated">UintSize-это размер мяты в битах.</target>
        </trans-unit>
        <trans-unit id="dbe3f8f6ae38a6c86be38b30cc7b136b0e0c8b33" translate="yes" xml:space="preserve">
          <source>UintVar defines a uint flag with specified name, default value, and usage string. The argument p points to a uint variable in which to store the value of the flag.</source>
          <target state="translated">UintVar определяет флаг uint с указанным именем,значением по умолчанию и строкой использования.Аргумент p указывает на переменную uint,в которой будет храниться значение флага.</target>
        </trans-unit>
        <trans-unit id="70e0b7ef4850aca01e0f7f10e5400e6c9147df8c" translate="yes" xml:space="preserve">
          <source>UnaryOp</source>
          <target state="translated">UnaryOp</target>
        </trans-unit>
        <trans-unit id="07e07a445fa30cc6121d05f031b487faccb7d573" translate="yes" xml:space="preserve">
          <source>UnaryOp returns the result of the unary expression op y. The operation must be defined for the operand. If prec &amp;gt; 0 it specifies the ^ (xor) result size in bits. If y is Unknown, the result is Unknown.</source>
          <target state="translated">UnaryOp возвращает результат унарного выражения op y. Операция должна быть определена для операнда. Если prec&amp;gt; 0, он указывает размер результата ^ (xor) в битах. Если y - Неизвестно, результат - Неизвестный.</target>
        </trans-unit>
        <trans-unit id="65ac12608f350c5da84519394457136c59d339ec" translate="yes" xml:space="preserve">
          <source>Undefined returns the JavaScript value &quot;undefined&quot;.</source>
          <target state="translated">Undefined возвращает JavaScript значение &quot;undefined&quot;.</target>
        </trans-unit>
        <trans-unit id="9933a40ae911d6dfb846e287c51e34fc4040de25" translate="yes" xml:space="preserve">
          <source>UnescapeString</source>
          <target state="translated">UnescapeString</target>
        </trans-unit>
        <trans-unit id="d8d400b63495a426dfadc8a4f1e5fdcfa4a8e536" translate="yes" xml:space="preserve">
          <source>UnescapeString unescapes entities like &quot;&amp;amp;lt;&quot; to become &quot;&amp;lt;&quot;. It unescapes a larger range of entities than EscapeString escapes. For example, &quot;&amp;amp;aacute;&quot; unescapes to &quot;&amp;aacute;&quot;, as does &quot;&amp;amp;#225;&quot; and &quot;&amp;amp;#xE1;&quot;. UnescapeString(EscapeString(s)) == s always holds, but the converse isn't always true.</source>
          <target state="translated">UnescapeString отменяет экранирование таких объектов, как &quot;&amp;amp; lt;&quot; стать &quot;&amp;lt;&quot;. Он отменяет экранирование большего диапазона сущностей, чем EscapeString. Например, &amp;laquo;&amp;amp; aacute;&amp;raquo; не экранируется на &quot;&amp;aacute;&quot;, как и &quot;&amp;amp; # 225;&quot; и &quot;&amp;amp; # xE1;&quot;. UnescapeString (EscapeString (s)) == s всегда выполняется, но обратное не всегда верно.</target>
        </trans-unit>
        <trans-unit id="32ea3c11e3a0c9441edc34338d9ee1468d7b9e70" translate="yes" xml:space="preserve">
          <source>Unicode character classes are those in unicode.Categories and unicode.Scripts.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c698e3c309a2ed8c52f6f41c34c41e2935c68bed" translate="yes" xml:space="preserve">
          <source>Uniform is an infinite-sized Image of uniform color. It implements the color.Color, color.Model, and Image interfaces.</source>
          <target state="translated">Униформа-это бесконечно большое изображение однородного цвета.Она реализует интерфейсы color.Color,color.Model и Image.</target>
        </trans-unit>
        <trans-unit id="c9b92cda61a2bd5ee7e67c31c67ae298972c3694" translate="yes" xml:space="preserve">
          <source>Union returns the smallest rectangle that contains both r and s.</source>
          <target state="translated">Союз возвращает наименьший прямоугольник,который содержит и r,и s.</target>
        </trans-unit>
        <trans-unit id="c30c209545f6cf55ee27d591debf698152bcbfd9" translate="yes" xml:space="preserve">
          <source>Unix returns t as a Unix time, the number of seconds elapsed since January 1, 1970 UTC. The result does not depend on the location associated with t.</source>
          <target state="translated">Unix возвращает t как Unix-время,количество секунд,прошедших с 1 января 1970 года по UTC.Результат не зависит от местоположения,связанного с t.</target>
        </trans-unit>
        <trans-unit id="0739141adf792995ead54a41a03b2314aaccc261" translate="yes" xml:space="preserve">
          <source>Unix returns t as a Unix time, the number of seconds elapsed since January 1, 1970 UTC. The result does not depend on the location associated with t. Unix-like operating systems often record time as a 32-bit count of seconds, but since the method here returns a 64-bit value it is valid for billions of years into the past or future.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c849502e5926e7f6de51dcd5dae32180a6c8fc5" translate="yes" xml:space="preserve">
          <source>Unix returns the local Time corresponding to the given Unix time, sec seconds and nsec nanoseconds since January 1, 1970 UTC. It is valid to pass nsec outside the range [0, 999999999]. Not all sec values have a corresponding time value. One such value is 1&amp;lt;&amp;lt;63-1 (the largest int64 value).</source>
          <target state="translated">Unix возвращает местное время, соответствующее заданному времени Unix, секундам секунды и наносекундам nsec с 1 января 1970 года по всемирному координированному времени. Допустимо пропускать нсек за пределы диапазона [0, 999999999]. Не все значения секунд имеют соответствующее значение времени. Одно из таких значений - 1 &amp;lt;&amp;lt; 63-1 (наибольшее значение int64).</target>
        </trans-unit>
        <trans-unit id="416b8be7737316cebb3c9cebf5753060cd3fcb1d" translate="yes" xml:space="preserve">
          <source>Unix returns the time stored in ts as seconds plus nanoseconds.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="164bbe899c45be28d564c4c79dd8c5d574ad3bc8" translate="yes" xml:space="preserve">
          <source>Unix returns the time stored in tv as seconds plus nanoseconds.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f49edfe928a8998235ec038d3202681fe6091b3" translate="yes" xml:space="preserve">
          <source>Unix returns ts as the number of seconds and nanoseconds elapsed since the Unix epoch.</source>
          <target state="translated">Unix возвращает ts как количество секунд и наносекунд,прошедших с эпохи Unix.</target>
        </trans-unit>
        <trans-unit id="36e051fac71bd9f38c8bee21a4fbf639eb952b84" translate="yes" xml:space="preserve">
          <source>Unix returns tv as the number of seconds and nanoseconds elapsed since the Unix epoch.</source>
          <target state="translated">Unix возвращает tv как количество секунд и наносекунд,прошедших с эпохи Unix.</target>
        </trans-unit>
        <trans-unit id="4d2a03437e4146025835f0a7a6ccd0e75af8c754" translate="yes" xml:space="preserve">
          <source>UnixAddr represents the address of a Unix domain socket end point.</source>
          <target state="translated">UnixAddr представляет собой адрес конечной точки доменного сокета Unix.</target>
        </trans-unit>
        <trans-unit id="04cdae900c7738c2f31e4e0db5e46a21f1971317" translate="yes" xml:space="preserve">
          <source>UnixConn is an implementation of the Conn interface for connections to Unix domain sockets.</source>
          <target state="translated">UnixConn-это реализация интерфейса Conn для подключения к доменным сокетам Unix.</target>
        </trans-unit>
        <trans-unit id="fd1ae11b5100fed8de8a53db38bf7aed0bddf628" translate="yes" xml:space="preserve">
          <source>UnixCredentials encodes credentials into a socket control message for sending to another process. This can be used for authentication.</source>
          <target state="translated">UnixCredentials кодирует учетные данные в управляющее сообщение сокета для отправки другому процессу.Это может быть использовано для аутентификации.</target>
        </trans-unit>
        <trans-unit id="aea7fd85f724d84dccda1e26d2c29b04dd2edf2d" translate="yes" xml:space="preserve">
          <source>UnixListener is a Unix domain socket listener. Clients should typically use variables of type Listener instead of assuming Unix domain sockets.</source>
          <target state="translated">UnixListener-прослушиватель сокетов домена Unix.Обычно клиенты должны использовать переменные типа Listener вместо того,чтобы предполагать наличие Unix-доменных сокетов.</target>
        </trans-unit>
        <trans-unit id="2a27b45fc326b4542c26186dc68da8cc5a7e5d10" translate="yes" xml:space="preserve">
          <source>UnixNano returns t as a Unix time, the number of nanoseconds elapsed since January 1, 1970 UTC. The result is undefined if the Unix time in nanoseconds cannot be represented by an int64 (a date before the year 1678 or after 2262). Note that this means the result of calling UnixNano on the zero Time is undefined. The result does not depend on the location associated with t.</source>
          <target state="translated">UnixNano возвращает t как Unix-время,количество наносекунд,прошедших с 1 января 1970 года по UTC.Результат неопределен,если Unix-время в наносекундах не может быть представлено int64 (дата до 1678 года или после 2262).Обратите внимание,что это означает,что результат вызова UnixNano в нулевое время неопределен.Результат не зависит от местоположения,связанного с t.</target>
        </trans-unit>
        <trans-unit id="b17a6e6eff6f04c581ee8cd1e56b3e493458a9f8" translate="yes" xml:space="preserve">
          <source>UnixRights encodes a set of open file descriptors into a socket control message for sending to another process.</source>
          <target state="translated">UnixRights кодирует набор открытых файловых дескрипторов в управляющее сообщение сокета для отправки другому процессу.</target>
        </trans-unit>
        <trans-unit id="dbe53cfcde936dfcaf7c8175938f51e315034103" translate="yes" xml:space="preserve">
          <source>UnknownAuthorityError results when the certificate issuer is unknown</source>
          <target state="translated">НеизвестноПолномочияОшибка при неизвестном эмитенте сертификата</target>
        </trans-unit>
        <trans-unit id="81414e166f7a74fc8a4df3127afc6add584dadf1" translate="yes" xml:space="preserve">
          <source>UnknownFileError represents a failure to find the specific file in the symbol table.</source>
          <target state="translated">UnknownFileError представляет собой невозможность найти конкретный файл в таблице символов.</target>
        </trans-unit>
        <trans-unit id="71d6e61364d65cc6b10f85900b022e3a712387e7" translate="yes" xml:space="preserve">
          <source>UnknownGroupError is returned by LookupGroup when a group cannot be found.</source>
          <target state="translated">UnknownGroupError возвращается LookupGroup,когда группа не может быть найдена.</target>
        </trans-unit>
        <trans-unit id="8395a289704405eac7a12dd0a91f81ec7b638b6b" translate="yes" xml:space="preserve">
          <source>UnknownGroupIdError is returned by LookupGroupId when a group cannot be found.</source>
          <target state="translated">UnknownGroupIdError возвращается LookupGroupId,когда группа не может быть найдена.</target>
        </trans-unit>
        <trans-unit id="ea06d94bc0ee6404fba69dbd6d9433ca16ab32bf" translate="yes" xml:space="preserve">
          <source>UnknownLineError represents a failure to map a line to a program counter, either because the line is beyond the bounds of the file or because there is no code on the given line.</source>
          <target state="translated">UnknownLineError представляет собой невозможность сопоставить строку с программным счетчиком,либо потому,что строка находится за пределами файла,либо потому,что на данной строке нет кода.</target>
        </trans-unit>
        <trans-unit id="161a93107711086546bec71b893d5cad7e7be15e" translate="yes" xml:space="preserve">
          <source>UnknownUserError is returned by Lookup when a user cannot be found.</source>
          <target state="translated">UnknownUserError возвращается Lookup,когда пользователь не может быть найден.</target>
        </trans-unit>
        <trans-unit id="6017e893f322aa54de196845bc71d4f23b1edfcb" translate="yes" xml:space="preserve">
          <source>UnknownUserIdError is returned by LookupId when a user cannot be found.</source>
          <target state="translated">UnknownUserIdError возвращается LookupId,когда пользователь не может быть найден.</target>
        </trans-unit>
        <trans-unit id="47025f2669ef0e585c9e4472fd182fc3f82a586e" translate="yes" xml:space="preserve">
          <source>Unless an explicit codec is set up, package encoding/gob is used to transport the data.</source>
          <target state="translated">Если явный кодек не настроен,для передачи данных используется пакетная кодировка/gob.</target>
        </trans-unit>
        <trans-unit id="e7e8c7e799f9b4c265f8eb16ca2467638931db85" translate="yes" xml:space="preserve">
          <source>Unless otherwise noted, these are defined in RFC 7231 section 4.3.</source>
          <target state="translated">Если не указано иное,они определены в разделе 4.3 RFC 7231.</target>
        </trans-unit>
        <trans-unit id="ad0d769d8f434903817312e6a1ab62dd81dfa28b" translate="yes" xml:space="preserve">
          <source>Unless specified otherwise, all operations (including setters) that specify a *Float variable for the result (usually via the receiver with the exception of MantExp), round the numeric result according to the precision and rounding mode of the result variable.</source>
          <target state="translated">Если не указано иное,все операции (включая сеттеры),в которых для результата указана переменная *Float (обычно через приемник,за исключением MantExp),округляют числовой результат в соответствии с точностью и режимом округления переменной результата.</target>
        </trans-unit>
        <trans-unit id="a99463bcf73aeb4ac48f9dbe6e1c4e0ad970639e" translate="yes" xml:space="preserve">
          <source>Unlike NextPart, it does not have special handling for &quot;Content-Transfer-Encoding: quoted-printable&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce1ab5c402bafab7c2f436e8311567b966b147df" translate="yes" xml:space="preserve">
          <source>Unlike in C, it is not valid to advance a pointer just beyond the end of its original allocation:</source>
          <target state="translated">В отличие от C,не допускается выдвигать указатель сразу после окончания его первоначального распределения:</target>
        </trans-unit>
        <trans-unit id="522a3a646a834223c2e98bb2c21ff8e76c01dd11" translate="yes" xml:space="preserve">
          <source>Unlike runtime.Callers, the PC values returned should, when passed to the symbolizer function, return the file/line of the call instruction. No additional subtraction is required or appropriate.</source>
          <target state="translated">В отличие от runtime.Callers,возвращаемые ПК значения должны при передаче в функцию символизатора возвращать файл/линию команды вызова.Никакого дополнительного вычитания не требуется и не требуется.</target>
        </trans-unit>
        <trans-unit id="406ad3e57d6ca887a28b68d7deb07d96e9cd7dc1" translate="yes" xml:space="preserve">
          <source>Unlike the &quot;system&quot; library call from C and other languages, the os/exec package intentionally does not invoke the system shell and does not expand any glob patterns or handle other expansions, pipelines, or redirections typically done by shells. The package behaves more like C's &quot;exec&quot; family of functions. To expand glob patterns, either call the shell directly, taking care to escape any dangerous input, or use the path/filepath package's Glob function. To expand environment variables, use package os's ExpandEnv.</source>
          <target state="translated">В отличие от вызова &quot;системной&quot; библиотеки из C и других языков,пакет os/exec намеренно не вызывает системную оболочку и не расширяет шаблоны глобусов и не обрабатывает другие расширения,трубопроводы или перенаправления,обычно выполняемые оболочками.Пакет ведет себя скорее как &quot;exec&quot; семейство функций на Си.Чтобы расширить шаблоны глобусов,либо вызовите оболочку напрямую,позаботившись о том,чтобы избежать любого опасного ввода,либо используйте Glob-функцию пакета path/filepath.Для расширения переменных окружения используйте пакет os ExpandEnv.</target>
        </trans-unit>
        <trans-unit id="abe91b52586dc5bbb2e6b3566c5e2c39387cbbd6" translate="yes" xml:space="preserve">
          <source>Unlink removes n % r.Len() elements from the ring r, starting at r.Next(). If n % r.Len() == 0, r remains unchanged. The result is the removed subring. r must not be empty.</source>
          <target state="translated">Анлинк удаляет n % элементов r.Len()из кольца r,начиная с r.Next().Если n % r.Len()==0,то r остается без изменений.В результате удаляется подкольцо.r не должна быть пустой.</target>
        </trans-unit>
        <trans-unit id="f1750196ed6e86ab6e565436971490e6b17346e5" translate="yes" xml:space="preserve">
          <source>Unlock unlocks m. It is a run-time error if m is not locked on entry to Unlock.</source>
          <target state="translated">Разблокировка разблокировки m.Ошибка во время выполнения,если m не заблокирована при входе в Разблокировку.</target>
        </trans-unit>
        <trans-unit id="1031b448939f378b7eec7282357fd0c8f02e0dd3" translate="yes" xml:space="preserve">
          <source>Unlock unlocks rw for writing. It is a run-time error if rw is not locked for writing on entry to Unlock.</source>
          <target state="translated">Разблокировать разблокировку rw для записи.Ошибка во время выполнения,если rw не заблокирован для записи при входе в Unlock.</target>
        </trans-unit>
        <trans-unit id="2769f111e84de5efeaaffb059d166476e34adffc" translate="yes" xml:space="preserve">
          <source>UnlockOSThread undoes an earlier call to LockOSThread. If this drops the number of active LockOSThread calls on the calling goroutine to zero, it unwires the calling goroutine from its fixed operating system thread. If there are no active LockOSThread calls, this is a no-op.</source>
          <target state="translated">Разблокировка LockOSThread отменяет предыдущий вызов LockOSThread.Если при этом количество активных вызовов LockOSThread на вызывающем горутине обнуляется,то он отсоединяет вызывающего горутина от своего фиксированного потока операционной системы.Если нет активных вызовов LockOSThread,то это не происходит.</target>
        </trans-unit>
        <trans-unit id="c0c55cc87781bbcbbe014b61cd39f339918efe82" translate="yes" xml:space="preserve">
          <source>Unmarshal</source>
          <target state="translated">Unmarshal</target>
        </trans-unit>
        <trans-unit id="b902b427877022323b14bf2942e7b4318af381ef" translate="yes" xml:space="preserve">
          <source>Unmarshal converts a point, serialized by Marshal, into an x, y pair. It is an error if the point is not in uncompressed form or is not on the curve. On error, x = nil.</source>
          <target state="translated">Unmarshal преобразует точку,сериализованную маршалом,в пару x,y.Это ошибка,если точка не находится в несжатом виде или на кривой.По ошибке x=ноль.</target>
        </trans-unit>
        <trans-unit id="05d9d3d65b2b20105c2330ab2953dfbf47f42b20" translate="yes" xml:space="preserve">
          <source>Unmarshal maps an XML element or attribute value to a bool by setting it to the boolean value represented by the string. Whitespace is trimmed and ignored.</source>
          <target state="translated">Unmarshal отображает XML элемент или значение атрибута в bool,устанавливая его в булевое значение,представленное строкой.Пробельные символы обрезаются и игнорируются.</target>
        </trans-unit>
        <trans-unit id="a20ffd00f170a26037fda94503e504e8f14a2140" translate="yes" xml:space="preserve">
          <source>Unmarshal maps an XML element or attribute value to a slice by extending the length of the slice and mapping the element or attribute to the newly created value.</source>
          <target state="translated">Unmarshal привязывает XML-элемент или значение атрибута к фрагменту,увеличивая длину фрагмента и привязывая элемент или атрибут к вновь созданному значению.</target>
        </trans-unit>
        <trans-unit id="f49e594c7cd50f427b1321468c3f00b6805b3bc7" translate="yes" xml:space="preserve">
          <source>Unmarshal maps an XML element or attribute value to an integer or floating-point field by setting the field to the result of interpreting the string value in decimal. There is no check for overflow. Whitespace is trimmed and ignored.</source>
          <target state="translated">Unmarshal привязывает XML элемент или значение атрибута к целому полю или полю с плавающей точкой,устанавливая в поле результат интерпретации строкового значения в десятичной форме.Проверка на переполнение отсутствует.Пробельные символы обрезаются и игнорируются.</target>
        </trans-unit>
        <trans-unit id="e3d47c5ca4b3a002e5a1a94281405e13a887e601" translate="yes" xml:space="preserve">
          <source>Unmarshal maps an XML element to a Name by recording the element name.</source>
          <target state="translated">Unmarshal сопоставляет XML-элемент с именем,записывая имя элемента.</target>
        </trans-unit>
        <trans-unit id="96b027c2d930b698a1ed10b0bb721de215ae272f" translate="yes" xml:space="preserve">
          <source>Unmarshal maps an XML element to a pointer by setting the pointer to a freshly allocated value and then mapping the element to that value.</source>
          <target state="translated">Unmarshal привязывает XML-элемент к указателю,устанавливая указатель на только что выделенное значение,а затем привязывая элемент к этому значению.</target>
        </trans-unit>
        <trans-unit id="6674f1401888e867e969567800411704118b6e15" translate="yes" xml:space="preserve">
          <source>Unmarshal maps an XML element to a string or []byte by saving the concatenation of that element's character data in the string or []byte. The saved []byte is never nil.</source>
          <target state="translated">Неразборчивое отображение XML-элемента в строку или []байт,сохраняя конкатенцию символьных данных этого элемента в строке или []байте.Сохраненный []байт никогда не равен нулю.</target>
        </trans-unit>
        <trans-unit id="a09403355ff68d791492810d3a6fdc52e5bc5f23" translate="yes" xml:space="preserve">
          <source>Unmarshal maps an XML element to a struct using the following rules. In the rules, the tag of a field refers to the value associated with the key 'xml' in the struct field's tag (see the example above).</source>
          <target state="translated">Неразборчивое отображение XML-элемента в структуру с помощью следующих правил.В правилах тег поля ссылается на значение,связанное с ключом 'xml' в теге поля структуры (см.пример выше).</target>
        </trans-unit>
        <trans-unit id="252b3357e8880736b5df5514f3757c07707118ae" translate="yes" xml:space="preserve">
          <source>Unmarshal maps an attribute value to a string or []byte by saving the value in the string or slice.</source>
          <target state="translated">Unmarshal привязывает значение атрибута к строке или []байту,сохраняя значение в строке или срезе.</target>
        </trans-unit>
        <trans-unit id="bb18922b79397b807a3d5909559848bfe9436488" translate="yes" xml:space="preserve">
          <source>Unmarshal maps an attribute value to an Attr by saving the attribute, including its name, in the Attr.</source>
          <target state="translated">Unmarshal отображает значение атрибута в Attr,сохраняя атрибут,включая его имя,в Attr.</target>
        </trans-unit>
        <trans-unit id="daa56a09ffbf4f0b35b7c340fa9c8ae81aa1dac5" translate="yes" xml:space="preserve">
          <source>Unmarshal parses the DER-encoded ASN.1 data structure b and uses the reflect package to fill in an arbitrary value pointed at by val. Because Unmarshal uses the reflect package, the structs being written to must use upper case field names.</source>
          <target state="translated">Unmarshal анализирует закодированную ЦОР структуру данных ASN.1 b и использует пакет отражения для заполнения произвольного значения,на которое указывает val.Поскольку Unmarshal использует пакет отражения,записываемые структуры должны использовать имена полей в верхнем регистре.</target>
        </trans-unit>
        <trans-unit id="896b9d75411fe008ac002fa69d65a02d32ae68e8" translate="yes" xml:space="preserve">
          <source>Unmarshal parses the DER-encoded ASN.1 data structure b and uses the reflect package to fill in an arbitrary value pointed at by val. Because Unmarshal uses the reflect package, the structs being written to must use upper case field names. If val is nil or not a pointer, Unmarshal returns an error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a9e198e98aaf9144ec031242893dd0ad5675a2b" translate="yes" xml:space="preserve">
          <source>Unmarshal parses the JSON-encoded data and stores the result in the value pointed to by v. If v is nil or not a pointer, Unmarshal returns an InvalidUnmarshalError.</source>
          <target state="translated">Unmarshal анализирует данные,закодированные в JSON,и сохраняет результат в значении,на которое указывает v.Если v равен нулю или нет указателя,Unmarshal возвращает InvalidUnmarshalError.</target>
        </trans-unit>
        <trans-unit id="ed1d87c314d03ac8a80eec05352fd3a2e828f6fd" translate="yes" xml:space="preserve">
          <source>Unmarshal parses the XML-encoded data and stores the result in the value pointed to by v, which must be an arbitrary struct, slice, or string. Well-formed data that does not fit into v is discarded.</source>
          <target state="translated">Unmarshal разбирает данные,закодированные в XML,и сохраняет результат в виде значения,на которое указывает v,которое должно быть произвольной структурой,срезом или строкой.Хорошо сформированные данные,не помещающиеся в v,отбрасываются.</target>
        </trans-unit>
        <trans-unit id="40f5f3bf6806f78bc75f412c5c5def4697b027f5" translate="yes" xml:space="preserve">
          <source>Unmarshal uses the inverse of the encodings that Marshal uses, allocating maps, slices, and pointers as necessary, with the following additional rules:</source>
          <target state="translated">Unmarshal использует обратную кодировку,которую использует Маршал,распределяя карты,срезы и указатели по мере необходимости,со следующими дополнительными правилами:</target>
        </trans-unit>
        <trans-unit id="8a48a17f3248cfe923e11a8bf58b4b7fb9c77d34" translate="yes" xml:space="preserve">
          <source>UnmarshalBinary implements the encoding.BinaryUnmarshaler interface.</source>
          <target state="translated">UnmarshalBinary реализует интерфейс encoding.BinaryUnmarshaler.</target>
        </trans-unit>
        <trans-unit id="3e8a767165b3da81fab334a0479c29a17b19b26e" translate="yes" xml:space="preserve">
          <source>UnmarshalBinary must be able to decode the form generated by MarshalBinary. UnmarshalBinary must copy the data if it wishes to retain the data after returning.</source>
          <target state="translated">UnmarshalBinary должен уметь декодировать форму,генерируемую MarshalBinary.UnmarshalBinary должен скопировать данные,если хочет сохранить их после возврата.</target>
        </trans-unit>
        <trans-unit id="c0f8f106115bed98d4438b712b344fc8e65ac7a2" translate="yes" xml:space="preserve">
          <source>UnmarshalCompressed converts a point, serialized by MarshalCompressed, into an x, y pair. It is an error if the point is not in compressed form or is not on the curve. On error, x = nil.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1f2034d1f5318f262d82d2c3d3d1a1f573ff376" translate="yes" xml:space="preserve">
          <source>UnmarshalJSON implements the json.Unmarshaler interface.</source>
          <target state="translated">UnmarshalJSON реализует интерфейс json.Unmarshaler.</target>
        </trans-unit>
        <trans-unit id="ac481b848955fbdb07ec4ed8b1f2094acec90508" translate="yes" xml:space="preserve">
          <source>UnmarshalJSON implements the json.Unmarshaler interface. The time is expected to be a quoted string in RFC 3339 format.</source>
          <target state="translated">UnmarshalJSON реализует интерфейс json.Unmarshaler.Время ожидается в виде кавычек в формате RFC 3339.</target>
        </trans-unit>
        <trans-unit id="501d2e87e0671202c95a53d1a0ea534ac74ed463" translate="yes" xml:space="preserve">
          <source>UnmarshalJSON sets *m to a copy of data.</source>
          <target state="translated">UnmarshalJSON устанавливает *m на копию данных.</target>
        </trans-unit>
        <trans-unit id="766c1d65184cba1147b7a3545fa3391dee2740d7" translate="yes" xml:space="preserve">
          <source>UnmarshalText implements the encoding.TextUnmarshaler interface.</source>
          <target state="translated">UnmarshalText реализует интерфейс encoding.TextUnmarshaler.</target>
        </trans-unit>
        <trans-unit id="85ec5d5725d7fc8b15d01b424436803971c310f0" translate="yes" xml:space="preserve">
          <source>UnmarshalText implements the encoding.TextUnmarshaler interface. The IP address is expected in a form accepted by ParseIP.</source>
          <target state="translated">UnmarshalText реализует интерфейс encoding.TextUnmarshaler.IP-адрес ожидается в форме,принятой ParseIP.</target>
        </trans-unit>
        <trans-unit id="131593f7a0c50a040c83c26b3def1697240de177" translate="yes" xml:space="preserve">
          <source>UnmarshalText implements the encoding.TextUnmarshaler interface. The result is rounded per the precision and rounding mode of z. If z's precision is 0, it is changed to 64 before rounding takes effect.</source>
          <target state="translated">UnmarshalText реализует интерфейс encoding.TextUnmarshaler.Результат округляется в режиме точности и округления z.Если точность z равна 0,то перед вступлением в силу округления она изменяется на 64.</target>
        </trans-unit>
        <trans-unit id="7b15f389f52fa3ed23e4bbf98f836b42c06e5eba" translate="yes" xml:space="preserve">
          <source>UnmarshalText implements the encoding.TextUnmarshaler interface. The time is expected to be in RFC 3339 format.</source>
          <target state="translated">UnmarshalText реализует интерфейс encoding.TextUnmarshaler.Время ожидается в формате RFC 3339.</target>
        </trans-unit>
        <trans-unit id="6b7f1ab4fc569112930c20562985da8185544c87" translate="yes" xml:space="preserve">
          <source>UnmarshalText must be able to decode the form generated by MarshalText. UnmarshalText must copy the text if it wishes to retain the text after returning.</source>
          <target state="translated">UnmarshalText должен уметь декодировать форму,генерируемую MarshalText.UnmarshalText должен скопировать текст,если хочет сохранить его после возврата.</target>
        </trans-unit>
        <trans-unit id="bd65d49d42bce927940aedf915c377e4dd09e40d" translate="yes" xml:space="preserve">
          <source>UnmarshalWithParams allows field parameters to be specified for the top-level element. The form of the params is the same as the field tags.</source>
          <target state="translated">UnmarshalWithParams позволяет задавать параметры поля для элемента верхнего уровня.Форма параметров такая же,как и у тегов полей.</target>
        </trans-unit>
        <trans-unit id="b3bf6c68384d3fb37cb6c7555cff99e7fce3bb41" translate="yes" xml:space="preserve">
          <source>UnmarshalXML decodes a single XML element beginning with the given start element. If it returns an error, the outer call to Unmarshal stops and returns that error. UnmarshalXML must consume exactly one XML element. One common implementation strategy is to unmarshal into a separate value with a layout matching the expected XML using d.DecodeElement, and then to copy the data from that value into the receiver. Another common strategy is to use d.Token to process the XML object one token at a time. UnmarshalXML may not use d.RawToken.</source>
          <target state="translated">UnmarshalXML декодирует один XML элемент,начинающийся с данного стартового элемента.Если он возвращает ошибку,внешний вызов Unmarshal останавливается и возвращает эту ошибку.UnmarshalXML должен потреблять ровно один XML элемент.Одной из распространенных стратегий реализации является размартирование в отдельное значение с версткой,соответствующей ожидаемому XML,с использованием d.DecodeElement,а затем копирование данных из этого значения в приемник.Другой общей стратегией является использование d.Token для обработки XML объекта по одному токену за раз.UnmarshalXML не может использовать d.RawToken.</target>
        </trans-unit>
        <trans-unit id="acecbda4c97cb520576b3b10bc8d83fa35017c1a" translate="yes" xml:space="preserve">
          <source>UnmarshalXMLAttr decodes a single XML attribute. If it returns an error, the outer call to Unmarshal stops and returns that error. UnmarshalXMLAttr is used only for struct fields with the &quot;attr&quot; option in the field tag.</source>
          <target state="translated">UnmarshalXMLAttr декодирует один XML атрибут.Если он возвращает ошибку,внешний вызов Unmarshal останавливается и возвращает эту ошибку.UnmarshalXMLAttr используется только для полей структуры с опцией &quot;attr&quot; в теге поля.</target>
        </trans-unit>
        <trans-unit id="74aa3bc85e3cd4c389b5c2ee32e0f9e728ff011a" translate="yes" xml:space="preserve">
          <source>Unmarshaler is the interface implemented by objects that can unmarshal an XML element description of themselves.</source>
          <target state="translated">Unmarshaler-это интерфейс,реализованный объектами,которые могут размагничивать описание XML-элементов.</target>
        </trans-unit>
        <trans-unit id="da8c67afda9119d4c5ae65e92c29582ea2cf5d56" translate="yes" xml:space="preserve">
          <source>Unmarshaler is the interface implemented by types that can unmarshal a JSON description of themselves. The input can be assumed to be a valid encoding of a JSON value. UnmarshalJSON must copy the JSON data if it wishes to retain the data after returning.</source>
          <target state="translated">Unmarshaler-это интерфейс,реализованный типами,которые могут снять с себя JSON-описание.Вход можно считать действительной кодировкой значения JSON.UnmarshalJSON должен скопировать JSON данные,если он хочет сохранить данные после возврата.</target>
        </trans-unit>
        <trans-unit id="53e6478e1491aec13688a3a1ab544532e2362899" translate="yes" xml:space="preserve">
          <source>UnmarshalerAttr is the interface implemented by objects that can unmarshal an XML attribute description of themselves.</source>
          <target state="translated">UnmarshalerAttr-это интерфейс,реализованный объектами,которые могут размагничивать XML атрибут описания себя.</target>
        </trans-unit>
        <trans-unit id="3db9a5e29909b34e2551d8477bb97dce0e5cc013" translate="yes" xml:space="preserve">
          <source>Unquote</source>
          <target state="translated">Unquote</target>
        </trans-unit>
        <trans-unit id="d3b6eaa5a8adda6c17843b82fa332f2940b5c172" translate="yes" xml:space="preserve">
          <source>Unquote and UnquoteChar unquote Go string and rune literals.</source>
          <target state="translated">Отменить кавычки и UnquoteChar отменить кавычки Go строк и рунических литералов.</target>
        </trans-unit>
        <trans-unit id="eb183728a78695573a325619f75443a862dbd0b9" translate="yes" xml:space="preserve">
          <source>Unquote interprets s as a single-quoted, double-quoted, or backquoted Go string literal, returning the string value that s quotes. (If s is single-quoted, it would be a Go character literal; Unquote returns the corresponding one-character string.)</source>
          <target state="translated">Unquote интерпретирует s как строковый литерал Go в одинарных кавычках,двойных кавычках или обратной кавычке,возвращая строковое значение,которое s заключено в кавычки.(Если s заключен в кавычки,то это будет символьный Go-литерал;Unquote возвращает соответствующую строку в одну кавычки).</target>
        </trans-unit>
        <trans-unit id="944cb633773df2e1ec790dd961a8146fba14fec2" translate="yes" xml:space="preserve">
          <source>UnquoteChar</source>
          <target state="translated">UnquoteChar</target>
        </trans-unit>
        <trans-unit id="29375f10dc5a5623870f8be238ab4c2e02bc8067" translate="yes" xml:space="preserve">
          <source>UnquoteChar decodes the first character or byte in the escaped string or character literal represented by the string s. It returns four values:</source>
          <target state="translated">UnquoteChar расшифровывает первый символ или байт в экранированной строке или символьный литерал,представленный строкой s.Возвращает четыре значения:</target>
        </trans-unit>
        <trans-unit id="b53dd6b78670edea47b93cdb0a942d08f61ad422" translate="yes" xml:space="preserve">
          <source>UnquoteUsage extracts a back-quoted name from the usage string for a flag and returns it and the un-quoted usage. Given &quot;a `name` to show&quot; it returns (&quot;name&quot;, &quot;a name to show&quot;). If there are no back quotes, the name is an educated guess of the type of the flag's value, or the empty string if the flag is boolean.</source>
          <target state="translated">UnquoteUsage извлекает имя в обратной кавычке из строки использования для флага и возвращает его и использование без кавычек.При указании &quot;a `name` to show&quot; возвращается (&quot;имя&quot;,&quot;a name to show&quot;).Если нет обратных кавычек,то имя-это обоснованная догадка о типе значения флага,или пустая строка,если флаг является булевым.</target>
        </trans-unit>
        <trans-unit id="31604e0bbb76d839a9e20bc3ad471c203d67835a" translate="yes" xml:space="preserve">
          <source>UnreadByte causes the next call to ReadByte to return the same byte as the previous call to ReadByte. It may be an error to call UnreadByte twice without an intervening call to ReadByte.</source>
          <target state="translated">UnreadByte приводит к тому,что при следующем вызове ReadByte возвращается тот же самый байт,что и при предыдущем вызове ReadByte.Возможно,будет ошибкой дважды вызвать UnreadByte без промежуточного вызова ReadByte.</target>
        </trans-unit>
        <trans-unit id="f50817f3bd6d2c35e72fde2b0a932fd55a8206aa" translate="yes" xml:space="preserve">
          <source>UnreadByte complements ReadByte in implementing the io.ByteScanner interface.</source>
          <target state="translated">UnreadByte дополняет ReadByte в реализации интерфейса io.ByteScanner.</target>
        </trans-unit>
        <trans-unit id="5f3d5858f8afa80b57a7c212de39d0a9aff8df3f" translate="yes" xml:space="preserve">
          <source>UnreadByte implements the io.ByteScanner interface.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77c7dde06491fe4b9339041eb3796382445874b6" translate="yes" xml:space="preserve">
          <source>UnreadByte returns an error if the most recent method called on the Reader was not a read operation. Notably, Peek is not considered a read operation.</source>
          <target state="translated">UnreadByte возвращает ошибку,если последний метод,вызванный на Читателе,не был операцией чтения.Примечательно,что Peek не считается операцией чтения.</target>
        </trans-unit>
        <trans-unit id="85bb36da753f37d1b461fc793f6153ef59c80214" translate="yes" xml:space="preserve">
          <source>UnreadByte unreads the last byte returned by the most recent successful read operation that read at least one byte. If a write has happened since the last read, if the last read returned an error, or if the read read zero bytes, UnreadByte returns an error.</source>
          <target state="translated">UnreadByte снимает последний байт,возвращенный последней успешной операцией чтения,прочитавшей хотя бы один байт.Если с момента последнего чтения произошла запись,если последний прочитанный возвратил ошибку,или если прочитанный нулевой байт,UnreadByte возвращает ошибку.</target>
        </trans-unit>
        <trans-unit id="965a6610c5d757c591de2c22877d96263eb8aa9d" translate="yes" xml:space="preserve">
          <source>UnreadByte unreads the last byte. Only the most recently read byte can be unread.</source>
          <target state="translated">UnreadByte не читает последний байт.Нечитаемым может быть только последний прочитанный байт.</target>
        </trans-unit>
        <trans-unit id="4b29ee18a300641e642a50770d2b768bae903a75" translate="yes" xml:space="preserve">
          <source>UnreadRune causes the next call to ReadRune to return the same rune as the previous call to ReadRune. It may be an error to call UnreadRune twice without an intervening call to ReadRune.</source>
          <target state="translated">UnreadRune приводит к тому,что при следующем вызове ReadRune возвращается та же руна,что и при предыдущем вызове ReadRune.Может быть ошибкой повторный вызов UnreadRune без промежуточного вызова ReadRune.</target>
        </trans-unit>
        <trans-unit id="53822d24e97f8bde421daa61dcb508cacfde9d9a" translate="yes" xml:space="preserve">
          <source>UnreadRune complements ReadRune in implementing the io.RuneScanner interface.</source>
          <target state="translated">UnreadRune дополняет ReadRune в реализации интерфейса io.RuneScanner.</target>
        </trans-unit>
        <trans-unit id="8842945f04ec11d52129a0fe96a5f0b4f9dd3388" translate="yes" xml:space="preserve">
          <source>UnreadRune implements the io.RuneScanner interface.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4e42f86f3f39d57a5422eae590b939a777bcf43" translate="yes" xml:space="preserve">
          <source>UnreadRune unreads the last rune returned by ReadRune. If the most recent read or write operation on the buffer was not a successful ReadRune, UnreadRune returns an error. (In this regard it is stricter than UnreadByte, which will unread the last byte from any read operation.)</source>
          <target state="translated">UnreadRune снимает с прочтения последнюю руну,возвращенную ReadRune.Если последняя операция чтения или записи в буфер не прошла успешно,UnreadRune возвращает ошибку.(В этом отношении она строже,чем UnreadByte,который будет считать последний байт от любой операции чтения).</target>
        </trans-unit>
        <trans-unit id="19847ace49c568ee229c8734fba08cf124cc864f" translate="yes" xml:space="preserve">
          <source>UnreadRune unreads the last rune. If the most recent method called on the Reader was not a ReadRune, UnreadRune returns an error. (In this regard it is stricter than UnreadByte, which will unread the last byte from any read operation.)</source>
          <target state="translated">UnreadRune считывает последнюю руну.Если последний метод,вызванный на Reader,не был ReadRune,то UnreadRune возвращает ошибку.(В этом отношении он строже,чем UnreadByte,который будет считывать последний байт от любой операции чтения).</target>
        </trans-unit>
        <trans-unit id="50c3f847c58ba55e1737c9ae778e9a6278576b57" translate="yes" xml:space="preserve">
          <source>UnsafeAddr returns a pointer to v's data. It is for advanced clients that also import the &quot;unsafe&quot; package. It panics if v is not addressable.</source>
          <target state="translated">UnsafeAddr возвращает указатель на данные v.Это для продвинутых клиентов,которые также импортируют &quot;небезопасный&quot; пакет.Он паникует,если v не адресуется.</target>
        </trans-unit>
        <trans-unit id="504ce26fbf37c2ede64fba6d4661638e260a1239" translate="yes" xml:space="preserve">
          <source>Unsetenv</source>
          <target state="translated">Unsetenv</target>
        </trans-unit>
        <trans-unit id="182ea105f6e57aa2c2130dff922916a82bfc3855" translate="yes" xml:space="preserve">
          <source>Unsetenv unsets a single environment variable.</source>
          <target state="translated">Снятие напряжения с установки единственной переменной окружения.</target>
        </trans-unit>
        <trans-unit id="5d092e34b5869cce62568374e8b69ed2285d4b5a" translate="yes" xml:space="preserve">
          <source>UnsupportedTypeError is returned when Marshal encounters a type that cannot be converted into XML.</source>
          <target state="translated">UnsupportedTypeError возвращается,когда Marshal встречает тип,который не может быть преобразован в XML.</target>
        </trans-unit>
        <trans-unit id="e92f4283009858bf9a4050cedd8fe684e6e6d055" translate="yes" xml:space="preserve">
          <source>Until returns the duration until t. It is shorthand for t.Sub(time.Now()).</source>
          <target state="translated">Пока не вернет продолжительность до t.Это сокращение для t.Sub(time.Now()).</target>
        </trans-unit>
        <trans-unit id="90df4c2aff351c99774ec32df813be4f64cfabcd" translate="yes" xml:space="preserve">
          <source>Unwrap returns the result of calling the Unwrap method on err, if err's type contains an Unwrap method returning error. Otherwise, Unwrap returns nil.</source>
          <target state="translated">Unwrap возвращает результат вызова метода Unwrap при ошибке,если тип ошибки содержит метод Unwrap,возвращающий ошибку.В противном случае Unwrap возвращает ноль.</target>
        </trans-unit>
        <trans-unit id="0674f5735125e15a98a0dd1cdad0bd08b0642deb" translate="yes" xml:space="preserve">
          <source>Unwrap returns the underlying error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2facf8e427018a05d97ad6fa738413f526dc52de" translate="yes" xml:space="preserve">
          <source>Unwrap unpacks wrapped errors. If its argument's type has an Unwrap method, it calls the method once. Otherwise, it returns nil.</source>
          <target state="translated">Распаковывайте упакованные ошибки.Если тип аргумента имеет метод Unwrap,то он вызывает этот метод один раз.В противном случае он возвращает ноль.</target>
        </trans-unit>
        <trans-unit id="2a313ddb07d29b1265d5875102d8b2f23477d34a" translate="yes" xml:space="preserve">
          <source>Update replaces an old node in the comment map with the new node and returns the new node. Comments that were associated with the old node are associated with the new node.</source>
          <target state="translated">Update заменяет старый узел на карте комментариев на новый узел и возвращает новый узел.Комментарии,которые были ассоциированы со старой вершиной,связываются с новой вершиной.</target>
        </trans-unit>
        <trans-unit id="edb9e0c28d17431f4e5d015de98ef6d3ddc2e66d" translate="yes" xml:space="preserve">
          <source>Update returns the result of adding the bytes in p to the crc.</source>
          <target state="translated">Update возвращает результат добавления байтов в p в crc.</target>
        </trans-unit>
        <trans-unit id="0bb18642b70b9f8a9c12ccf39487328f306b8e19" translate="yes" xml:space="preserve">
          <source>Usage</source>
          <target state="translated">Usage</target>
        </trans-unit>
        <trans-unit id="cec856deaea9fb4090c73c99e87c26b997d6e715" translate="yes" xml:space="preserve">
          <source>Usage prints a usage message documenting all defined command-line flags to CommandLine's output, which by default is os.Stderr. It is called when an error occurs while parsing flags. The function is a variable that may be changed to point to a custom function. By default it prints a simple header and calls PrintDefaults; for details about the format of the output and how to control it, see the documentation for PrintDefaults. Custom usage functions may choose to exit the program; by default exiting happens anyway as the command line's error handling strategy is set to ExitOnError.</source>
          <target state="translated">Usage распечатывает сообщение об использовании,документирующее все определенные флаги командной строки в выводе CommandLine,которым по умолчанию является os.Stderr.Оно вызывается при возникновении ошибки при разборе флагов.Функция является переменной,которая может быть изменена,чтобы указать на пользовательскую функцию.По умолчанию она печатает простой заголовок и вызывает PrintDefaults;подробнее о формате вывода и способах управления им см.в документации к PrintDefaults.Пользовательские функции использования могут выбрать выход из программы;по умолчанию выход из программы происходит в любом случае,так как стратегия обработки ошибок в командной строке установлена в ExitOnError.</target>
        </trans-unit>
        <trans-unit id="08b2986bb9311484289ed77e8cb011bc1a1a4415" translate="yes" xml:space="preserve">
          <source>Use GoTokens to configure the Scanner such that it accepts all Go literal tokens including Go identifiers. Comments will be skipped.</source>
          <target state="translated">Используйте GoTokens для настройки сканера таким образом,чтобы он принимал все буквальные маркеры Go,включая идентификаторы Go.Комментарии будут пропущены.</target>
        </trans-unit>
        <trans-unit id="e7059998d0ef4d38492eb586594b1a7f2fda5597" translate="yes" xml:space="preserve">
          <source>Use a Scanner to implement a simple word-count utility by scanning the input as a sequence of space-delimited tokens.</source>
          <target state="translated">Используйте сканер для реализации простой утилиты подсчета слов,сканируя вход как последовательность маркеров,разделенных пробелами.</target>
        </trans-unit>
        <trans-unit id="c7ed138fa83b46f7078f3eba45cc612903e73703" translate="yes" xml:space="preserve">
          <source>Use a Scanner with a custom split function (built by wrapping ScanWords) to validate 32-bit decimal input.</source>
          <target state="translated">Используйте сканер с собственной функцией разделения (построенный по обертке ScanWords)для проверки 32-битного десятичного ввода.</target>
        </trans-unit>
        <trans-unit id="a131c39c2cc3965eeb7903a72d441b0e6edc8b39" translate="yes" xml:space="preserve">
          <source>Use a Scanner with a custom split function to parse a comma-separated list with an empty final value.</source>
          <target state="translated">Используйте сканер с собственной функцией разделения для разбора разделенного запятыми списка с пустым конечным значением.</target>
        </trans-unit>
        <trans-unit id="3fe5cc9def42296a11d7d9a0af9fc8ea7342706f" translate="yes" xml:space="preserve">
          <source>Use context Values only for request-scoped data that transits processes and APIs, not for passing optional parameters to functions.</source>
          <target state="translated">Используйте контекстные значения только для запрашиваемых данных,которые передают процессы и API,а не для передачи дополнительных параметров функциям.</target>
        </trans-unit>
        <trans-unit id="b7726ad2d6a51eae4064f8abdd4f91a30451b9da" translate="yes" xml:space="preserve">
          <source>Use of this type presents a security risk: the encapsulated content should come from a trusted source, as it will be included verbatim in the template output.</source>
          <target state="translated">Использование этого типа представляет собой риск для безопасности:инкапсулированное содержимое должно поступать из доверенного источника,так как оно будет дословно включаться в вывод шаблона.</target>
        </trans-unit>
        <trans-unit id="34a9c66123dc40ac60f0472d60867161abcd1901" translate="yes" xml:space="preserve">
          <source>UseNumber causes the Decoder to unmarshal a number into an interface{} as a Number instead of as a float64.</source>
          <target state="translated">UseNumber приводит к тому,что декодер размартировывает число в интерфейс{}как число,а не как float64.</target>
        </trans-unit>
        <trans-unit id="b20930a62f52b49ee0781be625003d945b67da4b" translate="yes" xml:space="preserve">
          <source>User annotation</source>
          <target state="translated">Аннотация пользователя</target>
        </trans-unit>
        <trans-unit id="fc3da515c7dc35d47639ea550f79310b8bc9a78e" translate="yes" xml:space="preserve">
          <source>User represents a user account.</source>
          <target state="translated">Пользователь представляет учетную запись пользователя.</target>
        </trans-unit>
        <trans-unit id="d2b201b196f2c09ea10aa903c6f2d9d3642adbdc" translate="yes" xml:space="preserve">
          <source>User returns a Userinfo containing the provided username and no password set.</source>
          <target state="translated">Пользователь возвращает Пользовательскую информацию,содержащую предоставленное имя пользователя и не имеющую пароля.</target>
        </trans-unit>
        <trans-unit id="68b7ed6f3fe5a5fff91e1492620a3db521e39f64" translate="yes" xml:space="preserve">
          <source>UserAgent returns the client's User-Agent, if sent in the request.</source>
          <target state="translated">Пользователь-Агент возвращает Клиенту Пользователя-Агента,если он отправлен в запросе.</target>
        </trans-unit>
        <trans-unit id="4ea06ed977eda51c2aa11c6b438af4cabec784b4" translate="yes" xml:space="preserve">
          <source>UserCacheDir returns the default root directory to use for user-specific cached data. Users should create their own application-specific subdirectory within this one and use that.</source>
          <target state="translated">UserCacheDir возвращает корневую директорию по умолчанию для использования пользовательских кэшированных данных.Пользователи должны создать свой собственный подкаталог,специфичный для конкретного приложения,внутри этого подкаталога и использовать его.</target>
        </trans-unit>
        <trans-unit id="a2ed520c964d93e9ec6ba0898145eda2b4839b40" translate="yes" xml:space="preserve">
          <source>UserConfigDir returns the default root directory to use for user-specific configuration data. Users should create their own application-specific subdirectory within this one and use that.</source>
          <target state="translated">UserConfigDir возвращает корневую директорию по умолчанию для использования пользовательских конфигурационных данных.Пользователи должны создать свой собственный подкаталог,специфичный для конкретного приложения,в этом каталоге и использовать его.</target>
        </trans-unit>
        <trans-unit id="28c75db53e54c3bd7c5a9e9bf84aa07645cd4dd7" translate="yes" xml:space="preserve">
          <source>UserHomeDir returns the current user's home directory.</source>
          <target state="translated">UserHomeDir возвращает домашний каталог текущего пользователя.</target>
        </trans-unit>
        <trans-unit id="e4af3b1e17fb9be937bdb3790d770684874f4388" translate="yes" xml:space="preserve">
          <source>UserPassword returns a Userinfo containing the provided username and password.</source>
          <target state="translated">UserPassword возвращает Пользовательскую информацию,содержащую предоставленное имя пользователя и пароль.</target>
        </trans-unit>
        <trans-unit id="02f3110477b79296b9a835ccdda4c40254dba20b" translate="yes" xml:space="preserve">
          <source>UserTime returns the user CPU time of the exited process and its children.</source>
          <target state="translated">UserTime возвращает процессорное время пользователя и его дочерних процессов.</target>
        </trans-unit>
        <trans-unit id="596b2947d671a1bd54b3952e3987a478fe9edb86" translate="yes" xml:space="preserve">
          <source>Username returns the username.</source>
          <target state="translated">Имя пользователя возвращает имя пользователя.</target>
        </trans-unit>
        <trans-unit id="dc8f2880e32de7bce1932889e7d7d51c71d3c62a" translate="yes" xml:space="preserve">
          <source>Using GOOS=android matches build tags and files as for GOOS=linux in addition to android tags and files.</source>
          <target state="translated">Использование системы GOOS=android соответствует тегам и файлам сборки,как для GOOS=linux,в дополнение к тегам и файлам андроид.</target>
        </trans-unit>
        <trans-unit id="9ef58be31d291026b75b8271910eb178dd6cbe45" translate="yes" xml:space="preserve">
          <source>Using GOOS=illumos matches build tags and files as for GOOS=solaris in addition to illumos tags and files.</source>
          <target state="translated">Использование GOOS=illumos соответствует меткам и файлам сборки,как для GOOS=solaris в дополнение к меткам и файлам освещения.</target>
        </trans-unit>
        <trans-unit id="c3fe6f0d858556f91b252b308d506eedd3cb2ddd" translate="yes" xml:space="preserve">
          <source>Using JS to include valid but untrusted JSON is not safe. A safe alternative is to parse the JSON with json.Unmarshal and then pass the resultant object into the template, where it will be converted to sanitized JSON when presented in a JavaScript context.</source>
          <target state="translated">Использование JS для включения действительного,но недоверенного JSON не является безопасным.Безопасной альтернативой является разобрать JSON с помощью json.Unmarshal и затем передать результирующий объект в шаблон,где он будет преобразован в дезинфицированный JSON при представлении в JavaScript-контексте.</target>
        </trans-unit>
        <trans-unit id="9d9125a7eed89278993fd187aca47dc4a1d76ad9" translate="yes" xml:space="preserve">
          <source>Using a nil Qualifier is equivalent to using (*Package).Path: the object is qualified by the import path, e.g., &quot;encoding/json.Marshal&quot;.</source>
          <target state="translated">Использование нулевого Qualifier эквивалентно использованию (*Package).Path:объект квалифицируется по пути импорта,например,&quot;encoding/json.Marshal&quot;.</target>
        </trans-unit>
        <trans-unit id="2513c3904b3d8adc521d8c82ea1568602dc6d76b" translate="yes" xml:space="preserve">
          <source>Uvarint</source>
          <target state="translated">Uvarint</target>
        </trans-unit>
        <trans-unit id="cd0cf1cee138a1f47260e7774925bd884f2375a8" translate="yes" xml:space="preserve">
          <source>Uvarint decodes a uint64 from buf and returns that value and the number of bytes read (&amp;gt; 0). If an error occurred, the value is 0 and the number of bytes n is &amp;lt;= 0 meaning:</source>
          <target state="translated">Uvarint декодирует uint64 из buf и возвращает это значение и количество прочитанных байтов (&amp;gt; 0). Если произошла ошибка, значение равно 0, а количество байтов n &amp;lt;= 0, что означает:</target>
        </trans-unit>
        <trans-unit id="66771bf9a86898929e11d8280264a532271f941a" translate="yes" xml:space="preserve">
          <source>Val</source>
          <target state="translated">Val</target>
        </trans-unit>
        <trans-unit id="2bc81c70eb02eae4099191aef1e57849a8e8f03d" translate="yes" xml:space="preserve">
          <source>Val returns the constant's value.</source>
          <target state="translated">Вэл возвращает значение константы.</target>
        </trans-unit>
        <trans-unit id="b0f7ad9f186c50db1236f5511239fa9e5948970e" translate="yes" xml:space="preserve">
          <source>Val returns the underlying value for a given constant. Since it returns an interface, it is up to the caller to type assert the result to the expected type. The possible dynamic return types are:</source>
          <target state="translated">Val возвращает базовую величину для данной константы.Так как оно возвращает интерфейс,то именно вызывающий абонент должен ввести результат в ожидаемый тип.Возможны следующие типы динамического возврата:</target>
        </trans-unit>
        <trans-unit id="2559cc6528d308a907426a71ef2ddf45113dcc96" translate="yes" xml:space="preserve">
          <source>Val returns the value associated with attribute Attr in Entry, or nil if there is no such attribute.</source>
          <target state="translated">Val возвращает значение,связанное с атрибутом Attr в Entry,или nil,если такого атрибута нет.</target>
        </trans-unit>
        <trans-unit id="a4aefa35c3b5ad26cd56f18c500001b89f66a9ce" translate="yes" xml:space="preserve">
          <source>Valid</source>
          <target state="translated">Valid</target>
        </trans-unit>
        <trans-unit id="46c122fc5457cc399b8b858419e492a06b376755" translate="yes" xml:space="preserve">
          <source>Valid reports whether data is a valid JSON encoding.</source>
          <target state="translated">Действительно ли данные являются действительной кодировкой JSON.</target>
        </trans-unit>
        <trans-unit id="806cc965cf7a7b71a612856c03f868243e886f5c" translate="yes" xml:space="preserve">
          <source>Valid reports whether p consists entirely of valid UTF-8-encoded runes.</source>
          <target state="translated">Допустимо сообщать,состоит ли p целиком из действительных рун,закодированных в кодировке UTF-8.</target>
        </trans-unit>
        <trans-unit id="9519df7a8cc1237bbc29245d3ead17c2ceaba31e" translate="yes" xml:space="preserve">
          <source>ValidPath reports whether the given path name is valid for use in a call to Open.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c3cda690d8c1884d7b10ef8e13e38f05dfb3167" translate="yes" xml:space="preserve">
          <source>ValidRune</source>
          <target state="translated">ValidRune</target>
        </trans-unit>
        <trans-unit id="3e8899c82439ff69d29e69515b50bcac879155d8" translate="yes" xml:space="preserve">
          <source>ValidRune reports whether r can be legally encoded as UTF-8. Code points that are out of range or a surrogate half are illegal.</source>
          <target state="translated">ValidRune сообщает,может ли r быть легально закодировано как UTF-8.Коды,которые находятся вне диапазона или суррогатная половина являются незаконными.</target>
        </trans-unit>
        <trans-unit id="a9473e977cedeea3732bd1f0e634158b2fc8bc9c" translate="yes" xml:space="preserve">
          <source>ValidString</source>
          <target state="translated">ValidString</target>
        </trans-unit>
        <trans-unit id="1965e2764de3dba462118d2aa14e90df90d22255" translate="yes" xml:space="preserve">
          <source>ValidString reports whether s consists entirely of valid UTF-8-encoded runes.</source>
          <target state="translated">ValidString сообщает,состоит ли s целиком из действительных рун в кодировке UTF-8.</target>
        </trans-unit>
        <trans-unit id="c0a9babdac4db73aebddcf7c19ed25ebb45d7a5b" translate="yes" xml:space="preserve">
          <source>Validate performs basic sanity checks on the key. It returns nil if the key is valid, or else an error describing a problem.</source>
          <target state="translated">Валидат выполняет базовую проверку на вменяемость ключа.Он возвращает ноль,если ключ корректен,или ошибку,описывающую проблему.</target>
        </trans-unit>
        <trans-unit id="884a21f08ecc170ab0e83923a5cddfcafa2f19e8" translate="yes" xml:space="preserve">
          <source>Validator may be implemented by Conn to allow drivers to signal if a connection is valid or if it should be discarded.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8dce170de238b1feda2ecd9674ea3ca0d068fbcb" translate="yes" xml:space="preserve">
          <source>Value</source>
          <target state="translated">Value</target>
        </trans-unit>
        <trans-unit id="f3016ae4e1764c831e22db266c9f3792b104f577" translate="yes" xml:space="preserve">
          <source>Value (Config)</source>
          <target state="translated">Значение (Конфигурация)</target>
        </trans-unit>
        <trans-unit id="3b939f106840debe33fe7912aa5a94c4386c469d" translate="yes" xml:space="preserve">
          <source>Value (ReadMostly)</source>
          <target state="translated">Значение (ReadMostly)</target>
        </trans-unit>
        <trans-unit id="2a2d06d73feadc3e81a5b950d3c3a1578785b1f4" translate="yes" xml:space="preserve">
          <source>Value implements the driver Valuer interface.</source>
          <target state="translated">Value реализует интерфейс драйвера Valuer.</target>
        </trans-unit>
        <trans-unit id="dd218fab688fcead8af77b81093aadd12637b021" translate="yes" xml:space="preserve">
          <source>Value is a value that drivers must be able to handle. It is either nil, a type handled by a database driver's NamedValueChecker interface, or an instance of one of these types:</source>
          <target state="translated">Значение-это значение,которое водители должны уметь обрабатывать.Это либо нулевое значение,тип,обрабатываемый интерфейсом NamedValueChecker драйвера базы данных,либо экземпляр одного из этих типов:</target>
        </trans-unit>
        <trans-unit id="9752a7f3e66998d9403b579aaf11f5b93a26f7c0" translate="yes" xml:space="preserve">
          <source>Value is the documentation for a (possibly grouped) var or const declaration.</source>
          <target state="translated">Значение-это документация для (возможно,сгруппированная)var или const декларации.</target>
        </trans-unit>
        <trans-unit id="fc8bc38b52edf0162032e19caad204a132e1edc6" translate="yes" xml:space="preserve">
          <source>Value is the interface to the dynamic value stored in a flag. (The default value is represented as a string.)</source>
          <target state="translated">Значение-это интерфейс к динамическому значению,сохраненному во флаге.(Значение по умолчанию представлено в виде строки).</target>
        </trans-unit>
        <trans-unit id="2c289f13fb553c52397f1f031c283edf2f75ba5d" translate="yes" xml:space="preserve">
          <source>Value is the reflection interface to a Go value.</source>
          <target state="translated">Значение-это интерфейс отражения к значению Go.</target>
        </trans-unit>
        <trans-unit id="f874cfa2eae8a5288d6bb67626a8a5b202b1f1d3" translate="yes" xml:space="preserve">
          <source>Value represents a JavaScript value. The zero value is the JavaScript value &quot;undefined&quot;.</source>
          <target state="translated">Значение представляет собой JavaScript-значение.Нулевое значение-это значение JavaScript &quot;неопределенное&quot;.</target>
        </trans-unit>
        <trans-unit id="12bd1222cbe13b8343d523bcfbb727dc870d622e" translate="yes" xml:space="preserve">
          <source>Value represents a JavaScript value. The zero value is the JavaScript value &quot;undefined&quot;. Values can be checked for equality with the Equal method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="678d207a532dcdea8e626b9a2f73dbb88876a486" translate="yes" xml:space="preserve">
          <source>Value represents a metric value returned by the runtime.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bea9dc918e0d02a53c6ed34890033d051d6e5b45" translate="yes" xml:space="preserve">
          <source>Value returns an arbitrary value of the given type. If the type implements the Generator interface, that will be used. Note: To create arbitrary values for structs, all the fields must be exported.</source>
          <target state="translated">Значение возвращает произвольное значение данного типа.Если тип реализует интерфейс Генератора,то это значение будет использовано.Примечание:Для создания произвольных значений для структур,все поля должны быть экспортированы.</target>
        </trans-unit>
        <trans-unit id="010d442068b6dc0c175fb3be2478e451331b7772" translate="yes" xml:space="preserve">
          <source>Value returns the value of the iterator's current map entry.</source>
          <target state="translated">Значение возвращает значение текущей записи карты итератора.</target>
        </trans-unit>
        <trans-unit id="4814e1e8c0abd0c5b67abd9fa764cdfa19868250" translate="yes" xml:space="preserve">
          <source>ValueConverter is the interface providing the ConvertValue method.</source>
          <target state="translated">ValueConverter-это интерфейс,предоставляющий метод ConvertValue.</target>
        </trans-unit>
        <trans-unit id="bfff933f54248b785748322ae516a5abd89e358e" translate="yes" xml:space="preserve">
          <source>ValueKind is a tag for a metric Value which indicates its type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ee806fbc08f89d25017504477016f81d87178b9" translate="yes" xml:space="preserve">
          <source>ValueOf returns a new Value initialized to the concrete value stored in the interface i. ValueOf(nil) returns the zero Value.</source>
          <target state="translated">ValueOf возвращает новое значение,инициализированное к конкретному значению,сохраненному в интерфейсе i.ValueOf(nil)возвращает нулевое значение.</target>
        </trans-unit>
        <trans-unit id="73fa7582a50fd6ffa7153d229b6170f753731b5a" translate="yes" xml:space="preserve">
          <source>ValueOf returns x as a JavaScript value:</source>
          <target state="translated">ValueOf возвращает x в качестве значения JavaScript:</target>
        </trans-unit>
        <trans-unit id="f18975e8d6052ff98ae55792b39100c67475c7da" translate="yes" xml:space="preserve">
          <source>Valuer is the interface providing the Value method.</source>
          <target state="translated">Valuer-это интерфейс,предоставляющий метод Value.</target>
        </trans-unit>
        <trans-unit id="b1564f6b1512cbfa3cfcebc9a5badb6b239954f1" translate="yes" xml:space="preserve">
          <source>Values</source>
          <target state="translated">Values</target>
        </trans-unit>
        <trans-unit id="4c4b32df8b9b0ab6cff257dc64ed3eb643572b49" translate="yes" xml:space="preserve">
          <source>Values containing the types defined in this package should not be copied.</source>
          <target state="translated">Значения,содержащие типы,определенные в данном пакете,копировать не следует.</target>
        </trans-unit>
        <trans-unit id="db0f016ee293f8c7fb961ef81d6b041a8271fcde" translate="yes" xml:space="preserve">
          <source>Values maps a string key to a list of values. It is typically used for query parameters and form values. Unlike in the http.Header map, the keys in a Values map are case-sensitive.</source>
          <target state="translated">Значения отображают строковый ключ к списку значений.Обычно он используется для параметров запроса и значений форм.В отличие от http.header map,ключи на карте Values чувствительны к регистру.</target>
        </trans-unit>
        <trans-unit id="ed9ae6e1ddce7aa950c188cea7070152cbaaef3a" translate="yes" xml:space="preserve">
          <source>Values of IMAGE_FILE_HEADER.Characteristics. These can be combined together.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1b6d5f206af70bb39bd5fc526ef574743992a54" translate="yes" xml:space="preserve">
          <source>Values of the Image interface are created either by calling functions such as NewRGBA and NewPaletted, or by calling Decode on an io.Reader containing image data in a format such as GIF, JPEG or PNG. Decoding any particular image format requires the prior registration of a decoder function. Registration is typically automatic as a side effect of initializing that format's package so that, to decode a PNG image, it suffices to have</source>
          <target state="translated">Значения интерфейса Image создаются либо вызовом таких функций,как NewRGBA и NewPaletted,либо вызовом Decode на io.Reader,содержащем данные изображения в таком формате,как GIF,JPEG или PNG.Для декодирования любого конкретного формата изображения требуется предварительная регистрация функции декодера.Как правило,регистрация выполняется автоматически,что является побочным эффектом инициализации пакета этого формата,так что для декодирования изображения в PNG достаточно иметь</target>
        </trans-unit>
        <trans-unit id="b65743fb1655a6d5656fe5188b8219e485d45a6c" translate="yes" xml:space="preserve">
          <source>Values returns all values associated with the given key. It is case insensitive; CanonicalMIMEHeaderKey is used to canonicalize the provided key. To use non-canonical keys, access the map directly. The returned slice is not a copy.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0f032ed754eb781ca5f1ab9c0d5896202022c92" translate="yes" xml:space="preserve">
          <source>Values returns all values associated with the given key. It is case insensitive; textproto.CanonicalMIMEHeaderKey is used to canonicalize the provided key. To use non-canonical keys, access the map directly. The returned slice is not a copy.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="556542fae1b8220ad354f73db7960fdf03643304" translate="yes" xml:space="preserve">
          <source>Values that are shared by both R_PPC and R_PPC64 are prefixed with R_POWERPC_ in the ELF standard. For the R_PPC type, the relevant shared relocations have been renamed with the prefix R_PPC_. The original name follows the value in a comment.</source>
          <target state="translated">Значения,разделяемые как R_PPC,так и R_PPC64,в стандарте ELF имеют префикс R_POWERPC_.Для типа R_PPC соответствующие общие перемещения переименованы в префикс R_PPC_.Первоначальное имя следует за значением в комментарии.</target>
        </trans-unit>
        <trans-unit id="35513df4822daf6991ea9831d940cbcb44ab9510" translate="yes" xml:space="preserve">
          <source>Values that are shared by both R_PPC and R_PPC64 are prefixed with R_POWERPC_ in the ELF standard. For the R_PPC64 type, the relevant shared relocations have been renamed with the prefix R_PPC64_. The original name follows the value in a comment.</source>
          <target state="translated">Значения,разделяемые как R_PPC,так и R_PPC64,в стандарте ELF имеют префикс R_POWERPC_.Для типа R_PPC64 соответствующие общие перемещения переименованы в префикс R_PPC64_.Оригинальное имя следует за значением в комментарии.</target>
        </trans-unit>
        <trans-unit id="5491dd2526a7b6a12fe2eb7a45fdc97e08387c1a" translate="yes" xml:space="preserve">
          <source>Var defines a flag with the specified name and usage string. The type and value of the flag are represented by the first argument, of type Value, which typically holds a user-defined implementation of Value. For instance, the caller could create a flag that turns a comma-separated string into a slice of strings by giving the slice the methods of Value; in particular, Set would decompose the comma-separated string into the slice.</source>
          <target state="translated">Var определяет флаг с указанным именем и строкой использования.Тип и значение флага представлены первым аргументом,типом Value,который обычно содержит пользовательскую реализацию Value.Например,вызывающий абонент может создать флаг,который превращает строку,разделенную запятыми,в кусок строки,передавая куску методы Value;в частности,Set разложит строку,разделенную запятыми,на кусок.</target>
        </trans-unit>
        <trans-unit id="ce2b2698fd744904596b638fadb24e9ac560ff55" translate="yes" xml:space="preserve">
          <source>Var is an abstract type for all exported variables.</source>
          <target state="translated">Var является абстрактным типом для всех экспортируемых переменных.</target>
        </trans-unit>
        <trans-unit id="2fe39193f9c048f94aabb561a65b8ad4ebd4664a" translate="yes" xml:space="preserve">
          <source>VariableNode holds a list of variable names, possibly with chained field accesses. The dollar sign is part of the (first) name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac018db1f7b00972061adff843d37497d8ee153c" translate="yes" xml:space="preserve">
          <source>Variables</source>
          <target state="translated">Variables</target>
        </trans-unit>
        <trans-unit id="f9c863db27e83db40f4468fc4bc690e601042fdf" translate="yes" xml:space="preserve">
          <source>Variables previously declared can also be assigned, using the syntax</source>
          <target state="translated">Переменные,ранее объявленные,также могут быть назначены,используя синтаксис</target>
        </trans-unit>
        <trans-unit id="ca11a0cc5def9c210a74faf8ede1798e07fe2571" translate="yes" xml:space="preserve">
          <source>Variadic reports whether the signature s is variadic.</source>
          <target state="translated">Вариадический сообщает,является ли подпись s вариадической.</target>
        </trans-unit>
        <trans-unit id="41d79747265706c0afa494f13a1d7304f4478119" translate="yes" xml:space="preserve">
          <source>Varint</source>
          <target state="translated">Varint</target>
        </trans-unit>
        <trans-unit id="f5ebfb0ae8769b5ca2188331b009d7eba5a85341" translate="yes" xml:space="preserve">
          <source>Varint decodes an int64 from buf and returns that value and the number of bytes read (&amp;gt; 0). If an error occurred, the value is 0 and the number of bytes n is &amp;lt;= 0 with the following meaning:</source>
          <target state="translated">Varint декодирует int64 из buf и возвращает это значение и количество прочитанных байтов (&amp;gt; 0). Если произошла ошибка, значение равно 0, а количество байтов n &amp;lt;= 0 со следующим значением:</target>
        </trans-unit>
        <trans-unit id="d24fa62b1d834d7cd3cd0e8882051f85d094eda3" translate="yes" xml:space="preserve">
          <source>Various errors contained in OpError.</source>
          <target state="translated">Различные ошибки,содержащиеся в OpError.</target>
        </trans-unit>
        <trans-unit id="1a2978dcc531a211271eca6e53e9367381806a65" translate="yes" xml:space="preserve">
          <source>Various implementations of ValueConverter are provided by the driver package to provide consistent implementations of conversions between drivers. The ValueConverters have several uses:</source>
          <target state="translated">Различные реализации ValueConverter предоставляются пакетом драйверов для обеспечения согласованной реализации преобразований между драйверами.ValueConverters имеет несколько применений:</target>
        </trans-unit>
        <trans-unit id="677405d5dfca724a737bda64c6dc1ddb03f2bb84" translate="yes" xml:space="preserve">
          <source>Various isolation levels that drivers may support in BeginTx. If a driver does not support a given isolation level an error may be returned.</source>
          <target state="translated">Различные уровни изоляции,которые драйверы могут поддерживать в BeginTx.Если драйвер не поддерживает заданный уровень изоляции,может быть возвращена ошибка.</target>
        </trans-unit>
        <trans-unit id="cc21bbee9a9b0425c95545ecf2f53bc29369d55b" translate="yes" xml:space="preserve">
          <source>Various methods support conversions between strings and corresponding numeric values, and vice versa: *Int, *Rat, and *Float values implement the Stringer interface for a (default) string representation of the value, but also provide SetString methods to initialize a value from a string in a variety of supported formats (see the respective SetString documentation).</source>
          <target state="translated">Различные методы поддерживают преобразование строк в соответствующие числовые значения,и наоборот:*Int,*Rat и *Float значения реализуют интерфейс Stringer для (по умолчанию)строкового представления значения,а также предоставляют методы SetString для инициализации значения из строки в различных поддерживаемых форматах (см.соответствующую документацию SetString).</target>
        </trans-unit>
        <trans-unit id="fe5502979be4e45317e06e3f4bc8dea3c27b9d68" translate="yes" xml:space="preserve">
          <source>Verbose reports whether the -test.v flag is set.</source>
          <target state="translated">Verbose сообщает,установлен ли флаг -test.v.</target>
        </trans-unit>
        <trans-unit id="155a05e64e4d5e6d0dbf5afad455ef4b2c7d215e" translate="yes" xml:space="preserve">
          <source>Verify attempts to verify c by building one or more chains from c to a certificate in opts.Roots, using certificates in opts.Intermediates if needed. If successful, it returns one or more chains where the first element of the chain is c and the last element is from opts.Roots.</source>
          <target state="translated">Проверяйте попытки проверки c,построив одну или несколько цепочек от c до сертификата в opts.Roots,при необходимости используя сертификаты в opts.Intermediates.В случае успеха возвращает одну или несколько цепочек,где первым элементом цепочки является c,а последним-из opts.Roots.</target>
        </trans-unit>
        <trans-unit id="8f646662ac01cb1ef7a3f3dbe169c861f558bcfa" translate="yes" xml:space="preserve">
          <source>Verify checks the validity of an email address on the server. If Verify returns nil, the address is valid. A non-nil return does not necessarily indicate an invalid address. Many servers will not verify addresses for security reasons.</source>
          <target state="translated">Проверка достоверности адреса электронной почты на сервере.Если Verify возвращает ноль,то адрес является действительным.Нулевой возврат не обязательно означает недействительный адрес.Многие серверы не проверяют адреса из соображений безопасности.</target>
        </trans-unit>
        <trans-unit id="5f78fb77229812b310f6d30ba2f8eeb1a758e0db" translate="yes" xml:space="preserve">
          <source>Verify reports whether sig is a valid signature of message by publicKey. It will panic if len(publicKey) is not PublicKeySize.</source>
          <target state="translated">Проверяйте отчеты о том,является ли sig действительной подписью сообщения publicKey.Будет паниковать,если len(publicKey)не является PublicKeySize.</target>
        </trans-unit>
        <trans-unit id="afa19e9e5042f2e1366a51a651d0d42c62c9a9dc" translate="yes" xml:space="preserve">
          <source>Verify verifies the signature in r, s of hash using the public key, pub. It reports whether the signature is valid.</source>
          <target state="translated">Убедитесь,что подпись в r,s гашиша,используя публичный ключ,паб.Он сообщает,действительна ли подпись.</target>
        </trans-unit>
        <trans-unit id="29e311050b6e4da19e97375079ff2944ac6c7fb5" translate="yes" xml:space="preserve">
          <source>Verify verifies the signature in r, s of hash using the public key, pub. Its return value records whether the signature is valid.</source>
          <target state="translated">Убедитесь,что подпись в r,s гашиша,используя публичный ключ,паб.Его возвращаемое значение записывает,является ли подпись действительной.</target>
        </trans-unit>
        <trans-unit id="145232aacf42696b4e278956de6bab24512004cd" translate="yes" xml:space="preserve">
          <source>VerifyASN1 verifies the ASN.1 encoded signature, sig, of hash using the public key, pub. Its return value records whether the signature is valid.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c77ce67480dc146ec9f71541bb8eac40755f84ee" translate="yes" xml:space="preserve">
          <source>VerifyHostname checks that the peer certificate chain is valid for connecting to host. If so, it returns nil; if not, it returns an error describing the problem.</source>
          <target state="translated">CheckifyHostname проверяет,действительна ли цепочка сертификатов для подключения к узлу.Если да,то возвращает ноль;если нет,то возвращает ошибку,описывающую проблему.</target>
        </trans-unit>
        <trans-unit id="4d87443c0e8c5a2665736c35fe304b37073dc32e" translate="yes" xml:space="preserve">
          <source>VerifyHostname returns nil if c is a valid certificate for the named host. Otherwise it returns an error describing the mismatch.</source>
          <target state="translated">VerifyHostname возвращает nil,если c является действительным сертификатом для именованного узла.В противном случае возвращается ошибка,описывающая несоответствие.</target>
        </trans-unit>
        <trans-unit id="f86ef4530b45b573b44981bfecb27623cddb836c" translate="yes" xml:space="preserve">
          <source>VerifyOptions contains parameters for Certificate.Verify.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3cca137a6af7f592d32076ad3b96f2dd532d13e4" translate="yes" xml:space="preserve">
          <source>VerifyOptions contains parameters for Certificate.Verify. It's a structure because other PKIX verification APIs have ended up needing many options.</source>
          <target state="translated">VerifyOptions содержит параметры для Certificate.Verify.Это структура,потому что другие API верификации PKIX в конечном итоге требуют много опций.</target>
        </trans-unit>
        <trans-unit id="904631d00687a7288866da49169708056e59b147" translate="yes" xml:space="preserve">
          <source>VerifyPKCS1v15</source>
          <target state="translated">VerifyPKCS1v15</target>
        </trans-unit>
        <trans-unit id="03648c01c4f8ec482385a7d7d5a6f43278916d7d" translate="yes" xml:space="preserve">
          <source>VerifyPKCS1v15 verifies an RSA PKCS #1 v1.5 signature. hashed is the result of hashing the input message using the given hash function and sig is the signature. A valid signature is indicated by returning a nil error. If hash is zero then hashed is used directly. This isn't advisable except for interoperability.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7fac2ac8cef2b4f2fce0053008362560cd0a7f6f" translate="yes" xml:space="preserve">
          <source>VerifyPKCS1v15 verifies an RSA PKCS#1 v1.5 signature. hashed is the result of hashing the input message using the given hash function and sig is the signature. A valid signature is indicated by returning a nil error. If hash is zero then hashed is used directly. This isn't advisable except for interoperability.</source>
          <target state="translated">VerifyPKCS1v15 проверяет подпись RSA PKCS#1 v1.5.Хэширование является результатом хэширования входного сообщения с помощью данной хэш-функции,а sig-подписью.Действительная подпись обозначается возвратом нулевой ошибки.Если хэш равен нулю,то непосредственно используется хэширование.Это не рекомендуется,за исключением интероперабельности.</target>
        </trans-unit>
        <trans-unit id="22849df5c99a08214a361cc786e111d1f4ddafec" translate="yes" xml:space="preserve">
          <source>VerifyPSS verifies a PSS signature.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a12022e4f1f957db46b6ad31ae0c6d8b5b335f06" translate="yes" xml:space="preserve">
          <source>VerifyPSS verifies a PSS signature. hashed is the result of hashing the input message using the given hash function and sig is the signature. A valid signature is indicated by returning a nil error. The opts argument may be nil, in which case sensible defaults are used.</source>
          <target state="translated">VerifyPSS проверяет подпись PSS.хэш-результат хэширования входного сообщения с помощью заданной функции хэширования,а sig-подпись.Действительная подпись обозначается возвратом нулевой ошибки.Аргументом opts может быть nil,в этом случае используются разумные значения по умолчанию.</target>
        </trans-unit>
        <trans-unit id="fc50bdb16e95dd81d5ab93336a4873d743e71e10" translate="yes" xml:space="preserve">
          <source>Version is found in Header.Ident[EI_VERSION] and Header.Version.</source>
          <target state="translated">Версия находится в Header.Ident[EI_VERSION]и Header.Version.</target>
        </trans-unit>
        <trans-unit id="4d5c372788d86ffb1bb307fe18c33d0d35dfaf32" translate="yes" xml:space="preserve">
          <source>Version is the Unicode edition from which the tables are derived.</source>
          <target state="translated">Версия является редакцией Юникода,из которой производятся таблицы.</target>
        </trans-unit>
        <trans-unit id="50de89df378f68937423c4c0b0df29cc9d671898" translate="yes" xml:space="preserve">
          <source>Version returns the Go tree's version string. It is either the commit hash and date at the time of the build or, when possible, a release tag like &quot;go1.3&quot;.</source>
          <target state="translated">Версия возвращает строку версии дерева Go.Это либо хэш коммита и дата в момент сборки,либо,когда это возможно,тэг релиза типа &quot;go1.3&quot;.</target>
        </trans-unit>
        <trans-unit id="a9f8b9e002c84b093e85fe6340e9e2446c0f01f6" translate="yes" xml:space="preserve">
          <source>Very large values overflow to -1 or +Inf.</source>
          <target state="translated">Очень большие значения переполнения до -1 или +Inf.</target>
        </trans-unit>
        <trans-unit id="62ec9d14e878063c7140d04d700991af277e0332" translate="yes" xml:space="preserve">
          <source>Very large values overflow to 0 or +Inf. Very small values underflow to 1.</source>
          <target state="translated">Очень большие значения переполнения до 0 или +Инф.Очень маленькие значения переполнения до 1.</target>
        </trans-unit>
        <trans-unit id="548f7438120baf452d57249c7ed1e4259eddd666" translate="yes" xml:space="preserve">
          <source>Visit visits the command-line flags in lexicographical order, calling fn for each. It visits only those flags that have been set.</source>
          <target state="translated">Визит посещает флаги командной строки в лексикографическом порядке,вызывая fn для каждого.Он посещает только те флаги,которые были установлены.</target>
        </trans-unit>
        <trans-unit id="3d71d97888658f2741fa47ca0e6dafd3ee5bd8d5" translate="yes" xml:space="preserve">
          <source>Visit visits the flags in lexicographical order, calling fn for each. It visits only those flags that have been set.</source>
          <target state="translated">Визит посещает флаги в лексикографическом порядке,вызывая fn для каждого.Он посещает только те флаги,которые были установлены.</target>
        </trans-unit>
        <trans-unit id="fe139ba7798500e37c921c3f2eca473d92def875" translate="yes" xml:space="preserve">
          <source>VisitAll visits the command-line flags in lexicographical order, calling fn for each. It visits all flags, even those not set.</source>
          <target state="translated">VisitAll посещает флаги командной строки в лексикографическом порядке,вызывая fn для каждого.Он посещает все флаги,даже те,которые не установлены.</target>
        </trans-unit>
        <trans-unit id="91926cb218ad9a9f08c7f40210f9b3b594b76515" translate="yes" xml:space="preserve">
          <source>VisitAll visits the flags in lexicographical order, calling fn for each. It visits all flags, even those not set.</source>
          <target state="translated">VisitAll посещает флаги в лексикографическом порядке,вызывая fn для каждого.Он посещает все флаги,даже те,которые не установлены.</target>
        </trans-unit>
        <trans-unit id="82b27aedf84d8e8a368898854887f1a9db2938b6" translate="yes" xml:space="preserve">
          <source>VolumeName returns leading volume name. Given &quot;C:\foo\bar&quot; it returns &quot;C:&quot; on Windows. Given &quot;\\host\share\foo&quot; it returns &quot;\\host\share&quot;. On other platforms it returns &quot;&quot;.</source>
          <target state="translated">VolumeName возвращает имя ведущего тома.С учетом &quot;C:\foo\bar&quot; возвращает &quot;C:&quot; на Windows.Учитывая &quot;\\host\share\foo&quot; возвращает &quot;\\host\share&quot;.На других платформах возвращает &quot;&quot;.</target>
        </trans-unit>
        <trans-unit id="116af4a220931a113874c3a9a8fb8b67e737c229" translate="yes" xml:space="preserve">
          <source>WARNING: this function doesn't do any revocation checking.</source>
          <target state="translated">ВНИМАНИЕ:эта функция не проверяет отзыв.</target>
        </trans-unit>
        <trans-unit id="ac3ed0238ed01e1e125ce49b809e2689db256bfa" translate="yes" xml:space="preserve">
          <source>WARNING: use of this function to encrypt plaintexts other than session keys is dangerous. Use RSA OAEP in new protocols.</source>
          <target state="translated">ПРЕДУПРЕЖДЕНИЕ:использование этой функции для шифрования простых текстов,отличных от сеансовых ключей,опасно.Используйте RSA OAEP в новых протоколах.</target>
        </trans-unit>
        <trans-unit id="d791440e471e57ef06317ea366a55351a6722e8d" translate="yes" xml:space="preserve">
          <source>Wait atomically unlocks c.L and suspends execution of the calling goroutine. After later resuming execution, Wait locks c.L before returning. Unlike in other systems, Wait cannot return unless awoken by Broadcast or Signal.</source>
          <target state="translated">Подождите атоматически разблокирует К.Л.и приостанавливает исполнение вызывающего горутина.После того,как исполнение будет возобновлено,дождитесь блокировки c.L перед возвращением.В отличие от других систем,Wait не может вернуться до тех пор,пока не проснется по Трансляции или Сигналу.</target>
        </trans-unit>
        <trans-unit id="c1e4ec07809f552042a2744ebd76a1ff9cdfd927" translate="yes" xml:space="preserve">
          <source>Wait blocks until the WaitGroup counter is zero.</source>
          <target state="translated">Дождитесь блокировки до тех пор,пока счетчик WaitGroup не станет равен нулю.</target>
        </trans-unit>
        <trans-unit id="a2b93a450c159447eb449f1d44b9509d23d1eff8" translate="yes" xml:space="preserve">
          <source>Wait releases any resources associated with the Cmd.</source>
          <target state="translated">Подождите,освободите все ресурсы,связанные с Cmd.</target>
        </trans-unit>
        <trans-unit id="cecb6db143b18629c77edfdcfa6e40a828bd3ecd" translate="yes" xml:space="preserve">
          <source>Wait waits for the Process to exit, and then returns a ProcessState describing its status and an error, if any. Wait releases any resources associated with the Process. On most operating systems, the Process must be a child of the current process or an error will be returned.</source>
          <target state="translated">Дождитесь выхода Процесса,а затем вернитесь к Stateate,описывающему его статус и ошибку,если таковая имеется.Ожидание освобождает все ресурсы,связанные с Процессом.На большинстве операционных систем Процесс должен быть дочерним по отношению к текущему процессу,иначе будет возвращена ошибка.</target>
        </trans-unit>
        <trans-unit id="ef4d163f70a5558cd92581c6468ca54f951f10cb" translate="yes" xml:space="preserve">
          <source>Wait waits for the command to exit and waits for any copying to stdin or copying from stdout or stderr to complete.</source>
          <target state="translated">Дождитесь выхода команды и дождитесь завершения любого копирования в stdin или копирования из stdout или stderr.</target>
        </trans-unit>
        <trans-unit id="aea382006d640fdfa58d59c1e0ad39798008158f" translate="yes" xml:space="preserve">
          <source>Wait will close the pipe after seeing the command exit, so most callers need not close the pipe themselves. It is thus incorrect to call Wait before all reads from the pipe have completed. For the same reason, it is incorrect to call Run when using StdoutPipe. See the example for idiomatic usage.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d3243a3ead84d3a842320a1e7a6c5fbcf29075e" translate="yes" xml:space="preserve">
          <source>Wait will close the pipe after seeing the command exit, so most callers need not close the pipe themselves. It is thus incorrect to call Wait before all reads from the pipe have completed. For the same reason, it is incorrect to use Run when using StderrPipe. See the StdoutPipe example for idiomatic usage.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e61dcf7176445918332c5c75e515641021cd367b" translate="yes" xml:space="preserve">
          <source>Wait will close the pipe after seeing the command exit, so most callers need not close the pipe themselves; however, an implication is that it is incorrect to call Wait before all reads from the pipe have completed. For the same reason, it is incorrect to call Run when using StdoutPipe. See the example for idiomatic usage.</source>
          <target state="translated">Ожидание закроет трубу после того,как увидит выход команды,поэтому большинству звонящих не нужно закрывать трубу самостоятельно;однако,это означает,что неправильно вызывать функцию Ожидание до того,как все чтения с трубы завершатся.По той же причине неправильно вызывать Run при использовании StdoutPipe.См.пример для идиоматического использования.</target>
        </trans-unit>
        <trans-unit id="6e2d628a299984437542474f102b1e387913aa4f" translate="yes" xml:space="preserve">
          <source>Wait will close the pipe after seeing the command exit, so most callers need not close the pipe themselves; however, an implication is that it is incorrect to call Wait before all reads from the pipe have completed. For the same reason, it is incorrect to use Run when using StderrPipe. See the StdoutPipe example for idiomatic usage.</source>
          <target state="translated">Ожидание закроет трубу после того,как увидит выход команды,поэтому большинству звонящих не нужно закрывать трубу самостоятельно;однако,это означает,что неправильно вызывать функцию Ожидание до того,как все чтения с трубы завершатся.По той же причине неправильно использовать Run при использовании StderrPipe.Смотрите пример StdoutPipe для идиоматического использования.</target>
        </trans-unit>
        <trans-unit id="66edd56a29d8f65f00197517346652171bdf474e" translate="yes" xml:space="preserve">
          <source>WaitGroup</source>
          <target state="translated">WaitGroup</target>
        </trans-unit>
        <trans-unit id="e0c705d18e3fae4506d7273bda6435690cdbde08" translate="yes" xml:space="preserve">
          <source>Walk</source>
          <target state="translated">Walk</target>
        </trans-unit>
        <trans-unit id="52552b817eeffba362a3c98137f71c8293e62c3c" translate="yes" xml:space="preserve">
          <source>Walk calls the function with a non-nil err argument in two cases.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9374260d790571a0abca3c2ad0ee8f4b2fee093" translate="yes" xml:space="preserve">
          <source>Walk does not follow symbolic links.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29ff2f8a0272ea96bdd57633837c4d9205c5c003" translate="yes" xml:space="preserve">
          <source>Walk is less efficient than WalkDir, introduced in Go 1.16, which avoids calling os.Lstat on every visited file or directory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9272862a0570cd3c8a576242d0e65b3cfcf9dde3" translate="yes" xml:space="preserve">
          <source>Walk traverses an AST in depth-first order: It starts by calling v.Visit(node); node must not be nil. If the visitor w returned by v.Visit(node) is not nil, Walk is invoked recursively with visitor w for each of the non-nil children of node, followed by a call of w.Visit(nil).</source>
          <target state="translated">Прогулка преодолевает AST в первом порядке по глубине:Он начинается с вызова v.Visit(node);узел не должен быть нулевым.Если посетитель w,возвращаемый v.Visit(node),не равен нулю,Walk вызывается рекурсивно с помощью команды visitor w для каждого из дочерних узлов,не имеющих нуля,с последующим вызовом w.Visit(nil).</target>
        </trans-unit>
        <trans-unit id="448218872286b5074a9a3f4fa32510a7919bca39" translate="yes" xml:space="preserve">
          <source>Walk walks the file tree rooted at root, calling fn for each file or directory in the tree, including root.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="844997b7d380cfffe958c2b4b63e117129683358" translate="yes" xml:space="preserve">
          <source>Walk walks the file tree rooted at root, calling walkFn for each file or directory in the tree, including root. All errors that arise visiting files and directories are filtered by walkFn. The files are walked in lexical order, which makes the output deterministic but means that for very large directories Walk can be inefficient. Walk does not follow symbolic links.</source>
          <target state="translated">Walk ходит по дереву файлов,корневой,вызывая walkFn для каждого файла или директории в дереве,в том числе и корневой.Все ошибки,возникающие при посещении файлов и каталогов,отфильтровываются с помощью walkFn.Файлы проходят в лексическом порядке,что делает вывод детерминированным,но означает,что для очень больших каталогов Walk может быть неэффективным.Прогулка не сопровождается символическими ссылками.</target>
        </trans-unit>
        <trans-unit id="3474b62445a988d8dd7132a772a85658690ff2ba" translate="yes" xml:space="preserve">
          <source>WalkDir calls the function with a non-nil err argument in two cases.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2909c3003cad6334b97769f490356bda189f1f4c" translate="yes" xml:space="preserve">
          <source>WalkDir does not follow symbolic links found in directories, but if root itself is a symbolic link, its target will be walked.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2944078867d26e9f67caf63090c30efa8665e473" translate="yes" xml:space="preserve">
          <source>WalkDir does not follow symbolic links.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4671bbf058367649fe2ca3dc374a89674b38ba9a" translate="yes" xml:space="preserve">
          <source>WalkDir walks the file tree rooted at root, calling fn for each file or directory in the tree, including root.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71a3cdec2023da7868097ad68f8742c9c0a18055" translate="yes" xml:space="preserve">
          <source>WalkDirFunc is the type of the function called by WalkDir to visit each file or directory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a839647907d9b3be60eae8967669c7e1dc729b5" translate="yes" xml:space="preserve">
          <source>WalkFunc is the type of the function called by Walk to visit each each file or directory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea8fd18744a5b8a94a61df0e6be7f9d622440bee" translate="yes" xml:space="preserve">
          <source>WalkFunc is the type of the function called for each file or directory visited by Walk. The path argument contains the argument to Walk as a prefix; that is, if Walk is called with &quot;dir&quot;, which is a directory containing the file &quot;a&quot;, the walk function will be called with argument &quot;dir/a&quot;. The info argument is the os.FileInfo for the named path.</source>
          <target state="translated">WalkFunc-это тип функции,вызываемой для каждого файла или директории,посещаемой Walk.Аргумент path содержит аргумент Walk в качестве префикса;т.е.если Walk вызывается с &quot;dir&quot;,т.е.каталог,содержащий файл &quot;a&quot;,то функция walk будет вызываться с аргументом &quot;dir/a&quot;.Информационным аргументом является os.FileInfo для именованного пути.</target>
        </trans-unit>
        <trans-unit id="2918ed6d5c509e3ed1b93a9bceda4782bc8dd955" translate="yes" xml:space="preserve">
          <source>Warning logs a message with severity LOG_WARNING, ignoring the severity passed to New.</source>
          <target state="translated">Предупреждение регистрирует сообщение со значением степени тяжести LOG_WARNING,игнорируя степень тяжести,переданную New.</target>
        </trans-unit>
        <trans-unit id="6dda0897da5609f90207d91adc268a59c4a1ed0a" translate="yes" xml:space="preserve">
          <source>We define codes for each error that manifests while escaping templates, but escaped templates may also fail at runtime.</source>
          <target state="translated">Мы определяем коды для каждой ошибки,которая проявляется во время экранирования шаблонов,но экранированные шаблоны также могут не работать во время выполнения.</target>
        </trans-unit>
        <trans-unit id="4c1d860c4500491f651fd6c28babc0fc5252a9c1" translate="yes" xml:space="preserve">
          <source>WebSafe is a 216-color palette that was popularized by early versions of Netscape Navigator. It is also known as the Netscape Color Cube.</source>
          <target state="translated">WebSafe-это 216-цветная палитра,которая была популяризирована ранними версиями Netscape Navigator.Она также известна как Netscape Color Cube.</target>
        </trans-unit>
        <trans-unit id="9b612a9be3daa519fe810c831ee09c50cb694cd9" translate="yes" xml:space="preserve">
          <source>Weekday returns the day of the week specified by t.</source>
          <target state="translated">День недели возвращает день недели,указанный t.</target>
        </trans-unit>
        <trans-unit id="f665bbd01fb3804e446b49c63f8771aa2a58f0dc" translate="yes" xml:space="preserve">
          <source>Well-known IPv4 addresses</source>
          <target state="translated">Хорошо известные IPv4-адреса</target>
        </trans-unit>
        <trans-unit id="d1c37cf7857b91d487793e2b066aa7768c44b584" translate="yes" xml:space="preserve">
          <source>Well-known IPv6 addresses</source>
          <target state="translated">Известные IPv6 адреса</target>
        </trans-unit>
        <trans-unit id="423b2ce203c11b513c12b2cf5a302bece806d9e9" translate="yes" xml:space="preserve">
          <source>When Go code is built with options like -buildmode=c-shared, it will be run as part of an existing non-Go program. The non-Go code may have already installed signal handlers when the Go code starts (that may also happen in unusual cases when using cgo or SWIG; in that case, the discussion here applies). For -buildmode=c-archive the Go runtime will initialize signals at global constructor time. For -buildmode=c-shared the Go runtime will initialize signals when the shared library is loaded.</source>
          <target state="translated">Когда код Go собирается с опциями типа -buildmode=c-shared,он будет запущен как часть существующей не-Go программы.В не-Go-коде могут быть уже установлены обработчики сигналов,когда начинается Go-код (это также может произойти в необычных случаях при использовании cgo или SWIG;в этом случае,обсуждение здесь применимо).Для -buildmode=c-архивации время выполнения Go инициализирует сигналы во время глобального конструктора.Для -buildmode=c-shared время выполнения Go инициализирует сигналы при загрузке разделяемой библиотеки.</target>
        </trans-unit>
        <trans-unit id="157b3f39795f3c1bb26d85adf87f02f3367ef226" translate="yes" xml:space="preserve">
          <source>When Read encounters an error or end-of-file condition after successfully reading n &amp;gt; 0 bytes, it returns the number of bytes read. It may return the (non-nil) error from the same call or return the error (and n == 0) from a subsequent call. An instance of this general case is that a Reader returning a non-zero number of bytes at the end of the input stream may return either err == EOF or err == nil. The next Read should return 0, EOF.</source>
          <target state="translated">Когда Read обнаруживает ошибку или условие конца файла после успешного чтения n&amp;gt; 0 байтов, он возвращает количество прочитанных байтов. Он может вернуть ошибку (отличную от nil) из того же вызова или вернуть ошибку (и n == 0) из последующего вызова. Примером этого общего случая является то, что Reader, возвращающий ненулевое количество байтов в конце входного потока, может вернуть либо err == EOF, либо err == nil. Следующее чтение должно вернуть 0, EOF.</target>
        </trans-unit>
        <trans-unit id="d6278f9f812d1e00a798b88f0d43a4c07f1b736e" translate="yes" xml:space="preserve">
          <source>When ReadAt returns n &amp;lt; len(p), it returns a non-nil error explaining why more bytes were not returned. In this respect, ReadAt is stricter than Read.</source>
          <target state="translated">Когда ReadAt возвращает n &amp;lt;len (p), он возвращает ненулевую ошибку, объясняющую, почему не было возвращено больше байтов. В этом отношении ReadAt строже, чем Read.</target>
        </trans-unit>
        <trans-unit id="e42e8857e0f2dbf41e5d11d0b713339895c2d306" translate="yes" xml:space="preserve">
          <source>When Shutdown is called, Serve, ListenAndServe, and ListenAndServeTLS immediately return ErrServerClosed. Make sure the program doesn't exit and waits instead for Shutdown to return.</source>
          <target state="translated">При вызове Shutdown,Serve,ListenAndServe и ListenAndServeTLS немедленно вернуть ErrServerClosed.Убедитесь,что программа не выходит,а ждет выключения,чтобы вернуться.</target>
        </trans-unit>
        <trans-unit id="a1346033e8cd0c36ddc0423c4dcbbce227d0c225" translate="yes" xml:space="preserve">
          <source>When TestMain is called, flag.Parse has not been run. If TestMain depends on command-line flags, including those of the testing package, it should call flag.Parse explicitly. Command line flags are always parsed by the time test or benchmark functions run.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52cedf2625524a5c08d35a591f2ee66394bc79d6" translate="yes" xml:space="preserve">
          <source>When Token encounters an error or end-of-file condition after successfully reading a token, it returns the token. It may return the (non-nil) error from the same call or return the error (and a nil token) from a subsequent call. An instance of this general case is that a TokenReader returning a non-nil token at the end of the token stream may return either io.EOF or a nil error. The next Read should return nil, io.EOF.</source>
          <target state="translated">Когда Token встречает ошибку или состояние конца файла после успешного считывания маркера,он возвращает маркер.Он может вернуть ошибку (не нулевой)из того же вызова или вернуть ошибку (и нулевой маркер)из последующего вызова.В данном общем случае TokenReader,возвращающий нулевой маркер в конце потока маркеров,может вернуть ошибку io.EOF или нулевой маркер.Следующее Чтение должно вернуть ноль,io.EOF.</target>
        </trans-unit>
        <trans-unit id="3250a941e5738a81aa69e5097500ef947e64f456" translate="yes" xml:space="preserve">
          <source>When a Go program writes to a broken pipe, the kernel will raise a SIGPIPE signal.</source>
          <target state="translated">Когда программа Go пишет в сломанную трубу,ядро поднимает сигнал SIGPIPE.</target>
        </trans-unit>
        <trans-unit id="ed858d1cf0b08d8b30624984289eaf84deee9351" translate="yes" xml:space="preserve">
          <source>When a data value is not plain text, you can make sure it is not over-escaped by marking it with its type.</source>
          <target state="translated">Когда значение данных не является обычным текстом,вы можете убедиться,что оно не переполнено,пометив его типом.</target>
        </trans-unit>
        <trans-unit id="dcc36ea4f1110a5d9628600e555148a98813c271" translate="yes" xml:space="preserve">
          <source>When a plugin is first opened, the init functions of all packages not already part of the program are called. The main function is not run. A plugin is only initialized once, and cannot be closed.</source>
          <target state="translated">При первом открытии плагина вызываются init-функции всех пакетов,еще не входящих в состав программы.Основная функция не запускается.Плагин инициализируется только один раз и не может быть закрыт.</target>
        </trans-unit>
        <trans-unit id="34098c7334f20e516928585d3dd596a221004580" translate="yes" xml:space="preserve">
          <source>When adding a new file, a file base must be provided. That can be any integer value that is past the end of any interval of any file already in the file set. For convenience, FileSet.Base provides such a value, which is simply the end of the Pos interval of the most recently added file, plus one. Unless there is a need to extend an interval later, using the FileSet.Base should be used as argument for FileSet.AddFile.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82668902c85167e64c6f0f47b4424c5d8da33aca" translate="yes" xml:space="preserve">
          <source>When calling SetCgoTraceback, the version argument is the version number of the structs that the functions expect to receive. Currently this must be zero.</source>
          <target state="translated">При вызове SetCgoTraceback аргументом версии является номер версии структуры,которую ожидают получить функции.В настоящее время он должен быть равен нулю.</target>
        </trans-unit>
        <trans-unit id="bb4ae77735024f9be2c837577d3897cb72653910" translate="yes" xml:space="preserve">
          <source>When cgo is available, cgo-based (libc-backed) code is used by default. This can be overridden by using osusergo build tag, which enforces the pure Go implementation.</source>
          <target state="translated">При наличии cgo по умолчанию используется код,основанный на cgo (libc-backed).Это можно переопределить,используя тег сборки osusergo,который реализует чистую реализацию Go.</target>
        </trans-unit>
        <trans-unit id="3d68b88a257e3f62b9428ba8c7fdd32a8b354868" translate="yes" xml:space="preserve">
          <source>When decoding an ASN.1 value with an IMPLICIT tag into a string field, Unmarshal will default to a PrintableString, which doesn't support characters such as '@' and '&amp;amp;'. To force other encodings, use the following tags:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="752b47af0ec8b502ec7dd916b2f8679be6d9d28e" translate="yes" xml:space="preserve">
          <source>When err is nil, resp always contains a non-nil resp.Body. Caller should close resp.Body when done reading from it.</source>
          <target state="translated">Когда ошибка равна нулю,resp всегда содержит ноль или тело.Звонящий должен закрыть resp.body по окончании чтения из него.</target>
        </trans-unit>
        <trans-unit id="01d9fbd4a2ba2cf83a0b45d054350614384bbdc9" translate="yes" xml:space="preserve">
          <source>When execution begins, $ is set to the data argument passed to Execute, that is, to the starting value of dot.</source>
          <target state="translated">При начале выполнения $ устанавливается в аргумент данных,переданный в Execute,то есть в стартовое значение точки.</target>
        </trans-unit>
        <trans-unit id="8919d4f071112552ffa9917647b1e1053256e035" translate="yes" xml:space="preserve">
          <source>When following redirects, the Client will forward all headers set on the initial Request except:</source>
          <target state="translated">При последующих переадресациях Клиент будет переадресовывать все заголовки,установленные в первоначальном Запросе,за исключением:</target>
        </trans-unit>
        <trans-unit id="9524b6877cae25b318411b88de97b53bfbb0506c" translate="yes" xml:space="preserve">
          <source>When matching against text, the regexp returns a match that begins as early as possible in the input (leftmost), and among those it chooses the one that a backtracking search would have found first. This so-called leftmost-first matching is the same semantics that Perl, Python, and other implementations use, although this package implements it without the expense of backtracking. For POSIX leftmost-longest matching, see CompilePOSIX.</source>
          <target state="translated">При совпадении с текстом,регеxp возвращает совпадение,которое начинается как можно раньше на входе (крайний левый),и среди них выбирает то,которое обратный поиск нашел бы первым.Это так называемое &quot;крайнее левое-второе совпадение&quot;-та же семантика,что и в Perl,Python и других реализациях,хотя этот пакет реализует его без затрат на обратное отслеживание.Самое длинное левое совпадение для POSIX смотрите в CompilePOSIX.</target>
        </trans-unit>
        <trans-unit id="c6e22a9991087594c0b8cf7617afd5eef2db8623" translate="yes" xml:space="preserve">
          <source>When parsing a template, another template may be defined and associated with the template being parsed. Template definitions must appear at the top level of the template, much like global variables in a Go program.</source>
          <target state="translated">При разборе шаблона можно определить другой шаблон и связать его с обрабатываемым.Определения шаблонов должны появляться на верхнем уровне шаблона,так же как и глобальные переменные в программе Go.</target>
        </trans-unit>
        <trans-unit id="017afe59414197ba093e7c01bd629debe47b73b4" translate="yes" xml:space="preserve">
          <source>When parsing a time with a zone abbreviation like MST, if the zone abbreviation has a defined offset in the current location, then that offset is used. The zone abbreviation &quot;UTC&quot; is recognized as UTC regardless of location. If the zone abbreviation is unknown, Parse records the time as being in a fabricated location with the given zone abbreviation and a zero offset. This choice means that such a time can be parsed and reformatted with the same layout losslessly, but the exact instant used in the representation will differ by the actual zone offset. To avoid such problems, prefer time layouts that use a numeric zone offset, or use ParseInLocation.</source>
          <target state="translated">При разборе времени с аббревиатурой зоны,например MST,если аббревиатура зоны имеет определенное смещение в текущем местоположении,то используется это смещение.Сокращение зоны &quot;UTC&quot; распознается как UTC независимо от местоположения.Если аббревиатура зоны неизвестна,то Parse записывает время как находящееся в сконструированном месте с заданной аббревиатурой зоны и нулевым смещением.Этот выбор означает,что такое время может быть без потерь разобрано и переформатировано с тем же самым макетированием,но точное мгновение,используемое в представлении,будет отличаться на фактическое смещение зоны.Чтобы избежать таких проблем,отдавайте предпочтение временным макетам,использующим числовое смещение зоны,или используйте ParseInLocation.</target>
        </trans-unit>
        <trans-unit id="6cdce46cbdd242d854181ed07c3441caefe581b7" translate="yes" xml:space="preserve">
          <source>When parsing a time with a zone offset like -0700, if the offset corresponds to a time zone used by the current location (Local), then Parse uses that location and zone in the returned time. Otherwise it records the time as being in a fabricated location with time fixed at the given zone offset.</source>
          <target state="translated">При разборе времени со смещением зоны,например -0700,если смещение соответствует часовому поясу,используемому текущим местоположением (Local),то Parse использует это местоположение и зону в возвращаемом времени.В противном случае он записывает время как находящееся в сфабрикованном месте со временем,фиксированным при данном смещении зоны.</target>
        </trans-unit>
        <trans-unit id="67cd941accf04bdb338f577638abdd5419252ad9" translate="yes" xml:space="preserve">
          <source>When parsing multiple files with the same name in different directories, the last one mentioned will be the one that results.</source>
          <target state="translated">При разборе нескольких файлов с одним и тем же именем в разных каталогах,последним будет тот,который даст результат.</target>
        </trans-unit>
        <trans-unit id="ddcdf8b97f4b2868ce974b91b64fece54bf4c923" translate="yes" xml:space="preserve">
          <source>When parsing multiple files with the same name in different directories, the last one mentioned will be the one that results. For instance, ParseFiles(&quot;a/foo&quot;, &quot;b/foo&quot;) stores &quot;b/foo&quot; as the template named &quot;foo&quot;, while &quot;a/foo&quot; is unavailable.</source>
          <target state="translated">При разборе нескольких файлов с одним и тем же именем в разных каталогах,последним будет тот,который даст результат.Например,ParseFiles(&quot;a/foo&quot;,&quot;b/foo&quot;)сохраняет &quot;b/foo&quot; в качестве шаблона с именем &quot;foo&quot;,в то время как &quot;a/foo&quot; недоступен.</target>
        </trans-unit>
        <trans-unit id="34e29899665d5e8ad85e485fb7f40717928c9cd2" translate="yes" xml:space="preserve">
          <source>When printing a struct, fmt cannot and therefore does not invoke formatting methods such as Error or String on unexported fields.</source>
          <target state="translated">При печати структуры fmt не может и поэтому не использует методы форматирования,такие как Ошибка или Строка на неоткрытых полях.</target>
        </trans-unit>
        <trans-unit id="328b930d804aecf09f06d9e00e3215a83c9fe31a" translate="yes" xml:space="preserve">
          <source>When running a large set of sequential test cases, checking Coverage after each one can be useful for identifying which test cases exercise new code paths. It is not a replacement for the reports generated by 'go test -cover' and 'go tool cover'.</source>
          <target state="translated">При выполнении большого набора последовательных тестовых сценариев проверка Покрытия после каждой может быть полезна для определения того,какие тестовые сценария реализуют новые пути к коду.Она не является заменой отчетов,генерируемых с помощью 'go test -cover' и 'go tool cover'.</target>
        </trans-unit>
        <trans-unit id="909e63ef88f23df70a053ead84b3a43d68a17641" translate="yes" xml:space="preserve">
          <source>When template execution invokes a function with an argument list, that list must be assignable to the function's parameter types. Functions meant to apply to arguments of arbitrary type can use parameters of type interface{} or of type reflect.Value. Similarly, functions meant to return a result of arbitrary type can return interface{} or reflect.Value.</source>
          <target state="translated">Когда выполнение шаблона вызывает функцию со списком аргументов,этот список должен быть присвоен типам параметров функции.Функции,предназначенные для применения к аргументам произвольного типа,могут использовать параметры интерфейса типа{}или типа reflect.value.Аналогично функции,предназначенные для возврата результата произвольного типа,могут возвращать interface{}или reflect.Value.</target>
        </trans-unit>
        <trans-unit id="05dd6446129205c413b187abb37a98c5e685666d" translate="yes" xml:space="preserve">
          <source>When unmarshaling quoted strings, invalid UTF-8 or invalid UTF-16 surrogate pairs are not treated as an error. Instead, they are replaced by the Unicode replacement character U+FFFD.</source>
          <target state="translated">При размагничивании цитируемых строк,недействительные UTF-8 или недействительные суррогатные пары UTF-16 не считаются ошибкой.Вместо этого они заменяются символом замены Юникода U+FFFD.</target>
        </trans-unit>
        <trans-unit id="33fa3fdb7bbbbb81e834f8787f2ce9d1e3b0b605" translate="yes" xml:space="preserve">
          <source>When using TCP, and the host in the address parameter resolves to multiple network addresses, any dial timeout (from d.Timeout or ctx) is spread over each consecutive dial, such that each is given an appropriate fraction of the time to connect. For example, if a host has 4 IP addresses and the timeout is 1 minute, the connect to each single address will be given 15 seconds to complete before trying the next one.</source>
          <target state="translated">При использовании TCP,и хост в параметре адреса разрешается на несколько сетевых адресов,любой таймаут набора (от d.Timeout или ctx)распределяется по каждому последовательному набору,так что каждому дается соответствующая доля времени для соединения.Например,если хост имеет 4 IP-адреса,а таймаут составляет 1 минуту,то для соединения с каждым отдельным адресом будет дано 15 секунд,прежде чем пытаться подключиться к следующему.</target>
        </trans-unit>
        <trans-unit id="81ad3fb58a9738071410987f567b6f63ba760aad" translate="yes" xml:space="preserve">
          <source>When using the host C library resolver, at most one result will be returned. To bypass the host resolver, use a custom Resolver.</source>
          <target state="translated">При использовании резольвера библиотеки C хоста будет возвращен не более одного результата.Чтобы обойти главный резольвер,используйте пользовательский резольвер.</target>
        </trans-unit>
        <trans-unit id="b6af75ad725ff03ac3899006f586c6815dee0ab6" translate="yes" xml:space="preserve">
          <source>Whether and how a comment is associated with a node depends on the interpretation of the syntax tree by the manipulating program: Except for Doc and Comment comments directly associated with nodes, the remaining comments are &quot;free-floating&quot; (see also issues #18593, #20744).</source>
          <target state="translated">Связан ли комментарий с узлом и каким образом,зависит от интерпретации дерева синтаксиса управляющей программой:За исключением комментариев Doc и Comment,непосредственно связанных с узлами,остальные комментарии являются &quot;свободно плавающими&quot; (см.также выпуски #18593,#20744).</target>
        </trans-unit>
        <trans-unit id="1761aeba17f1966adf699cab82838ede9543b2ce" translate="yes" xml:space="preserve">
          <source>While it would be correct for the context function to record a complete a stack trace whenever it is called, and simply copy that out in the traceback function, in a typical program the context function will be called many times without ever recording a traceback for that context. Recording a complete stack trace in a call to the context function is likely to be inefficient.</source>
          <target state="translated">Хотя было бы правильным,чтобы контекстная функция записывала полную трассу стека всякий раз,когда она вызывается,и просто копировала ее из функции прослеживания,в типичной программе контекстная функция будет вызываться много раз,никогда не записывая трассировку для этого контекста.Запись полной трассы стека при вызове контекстной функции,скорее всего,будет неэффективной.</target>
        </trans-unit>
        <trans-unit id="97ac8575a01bb9731d0aacbb0c00a32106d3caac" translate="yes" xml:space="preserve">
          <source>While the FileSystem.Open method takes '/'-separated paths, a Dir's string value is a filename on the native file system, not a URL, so it is separated by filepath.Separator, which isn't necessarily '/'.</source>
          <target state="translated">В то время как метод FileSystem.Open принимает пути,разделенные '/',строковое значение Dir-это имя файла в родной файловой системе,а не URL,поэтому оно разделено файлом filepath.Separator,который не обязательно '/'.</target>
        </trans-unit>
        <trans-unit id="7d448d6e99b8642847a099da6f3145e12a69b2bf" translate="yes" xml:space="preserve">
          <source>White space is considered part of a field.</source>
          <target state="translated">Белое пространство считается частью поля.</target>
        </trans-unit>
        <trans-unit id="3462ed046f134fdadd9007f0e6ba397654359adc" translate="yes" xml:space="preserve">
          <source>Width and precision are measured in units of Unicode code points, that is, runes. (This differs from C's printf where the units are always measured in bytes.) Either or both of the flags may be replaced with the character '*', causing their values to be obtained from the next operand (preceding the one to format), which must be of type int.</source>
          <target state="translated">Ширина и точность измеряются в единицах единиц единиц измерения кодовых точек Юникода,т.е.рун.(Это отличается от printf языка C,где единицы измерения всегда измеряются в байтах.)Любой из флагов или оба они могут быть заменены символом '*',в результате чего их значения будут получены из следующего операнда (предшествующего форматированию),который должен быть типом int.</target>
        </trans-unit>
        <trans-unit id="285e52d2a4d90abe10ddf2c19e952396f894982a" translate="yes" xml:space="preserve">
          <source>Width is interpreted in the input text but there is no syntax for scanning with a precision (no %5.2f, just %5f). If width is provided, it applies after leading spaces are trimmed and specifies the maximum number of runes to read to satisfy the verb. For example,</source>
          <target state="translated">Ширина интерпретируется во входном тексте,но нет синтаксиса для сканирования с точностью (нет %5.2f,только %5f).Если задана ширина,то она применяется после обрезания лидирующих пробелов и указывает максимальное количество рун для чтения,чтобы удовлетворить глаголу.Например,</target>
        </trans-unit>
        <trans-unit id="798e2836ace5e24780c7dc5d76140278c0905170" translate="yes" xml:space="preserve">
          <source>Width is specified by an optional decimal number immediately preceding the verb. If absent, the width is whatever is necessary to represent the value. Precision is specified after the (optional) width by a period followed by a decimal number. If no period is present, a default precision is used. A period with no following number specifies a precision of zero. Examples:</source>
          <target state="translated">Ширина указывается необязательным десятичным числом,непосредственно предшествующим глаголу.Если оно отсутствует,то ширина-это то,что необходимо для представления значения.Точность указывается после (необязательной)ширины на период,за которым следует десятичное число.Если период отсутствует,используется точность по умолчанию.Период,за которым не следует ни одно последующее число,определяет точность нуля.Примеры:</target>
        </trans-unit>
        <trans-unit id="26d9c28d789c254f71ea99a3463b99a7ccc2f4fa" translate="yes" xml:space="preserve">
          <source>Windows</source>
          <target state="translated">Windows</target>
        </trans-unit>
        <trans-unit id="90527ca0c17e71be4b659b364a4632417bd48fd0" translate="yes" xml:space="preserve">
          <source>With HTTP Basic Authentication the provided username and password are not encrypted.</source>
          <target state="translated">При базовой аутентификации HTTP имя пользователя и пароль не шифруются.</target>
        </trans-unit>
        <trans-unit id="9c7242429a52b5edef337779ea090fbcc2bb6019" translate="yes" xml:space="preserve">
          <source>With the exceptions of comments, which are skipped if SkipComments is set, unrecognized tokens are not ignored. Instead, the scanner simply returns the respective individual characters (or possibly sub-tokens). For instance, if the mode is ScanIdents (not ScanStrings), the string &quot;foo&quot; is scanned as the token sequence '&quot;' Ident '&quot;'.</source>
          <target state="translated">За исключением комментариев,которые пропускаются,если установлен SkipComments,нераспознанные маркеры не игнорируются.Вместо этого сканер просто возвращает соответствующие отдельные символы (или,возможно,под-маркеры).Например,если установлен режим ScanIdents (не ScanStrings),строка &quot;foo&quot; сканируется как последовательность маркеров '&quot;.Идент '''.</target>
        </trans-unit>
        <trans-unit id="cfa2b7a12432ca7dde89800a43beb434b01e3ea5" translate="yes" xml:space="preserve">
          <source>WithCancel</source>
          <target state="translated">WithCancel</target>
        </trans-unit>
        <trans-unit id="10592d7ad2855a7180469ae213405203a2d50e89" translate="yes" xml:space="preserve">
          <source>WithCancel returns a copy of parent with a new Done channel. The returned context's Done channel is closed when the returned cancel function is called or when the parent context's Done channel is closed, whichever happens first.</source>
          <target state="translated">WithCancel возвращает копию родителя с новым Done каналом.Готовый канал возвращаемого контекста закрывается при вызове возвращаемой функции отмены или при закрытии родительского канала &quot;Готово&quot; контекста,в зависимости от того,что произойдет раньше.</target>
        </trans-unit>
        <trans-unit id="2261f632aeaf0a3059b969971069ca975c9ce32e" translate="yes" xml:space="preserve">
          <source>WithClientTrace returns a new context based on the provided parent ctx. HTTP client requests made with the returned context will use the provided trace hooks, in addition to any previous hooks registered with ctx. Any hooks defined in the provided trace will be called first.</source>
          <target state="translated">WithClientTrace возвращает новый контекст,основанный на предоставленном родительском ctx.Запросы HTTP клиентов,сделанные с возвращенным контекстом,будут использовать предоставленные крюки трассировки,в дополнение к любым предыдущим крюкам,зарегистрированным в ctx.Любые крюки,определенные в предоставленной трассе,будут вызываться первыми.</target>
        </trans-unit>
        <trans-unit id="f1cd36566b14c3bbf36e47b0c1cd6c5053972eb6" translate="yes" xml:space="preserve">
          <source>WithContext returns a shallow copy of r with its context changed to ctx. The provided ctx must be non-nil.</source>
          <target state="translated">WithContext возвращает мелкую копию r с измененным на ctx контекстом.Предоставленный ctx не должен быть нулевым.</target>
        </trans-unit>
        <trans-unit id="c81570667b5d5149acbef6b90b5b11ce74038f5e" translate="yes" xml:space="preserve">
          <source>WithDeadline</source>
          <target state="translated">WithDeadline</target>
        </trans-unit>
        <trans-unit id="4330da7d2b110737e8fe5953a232fb49e41e1165" translate="yes" xml:space="preserve">
          <source>WithDeadline returns a copy of the parent context with the deadline adjusted to be no later than d. If the parent's deadline is already earlier than d, WithDeadline(parent, d) is semantically equivalent to parent. The returned context's Done channel is closed when the deadline expires, when the returned cancel function is called, or when the parent context's Done channel is closed, whichever happens first.</source>
          <target state="translated">WithDeadline возвращает копию родительского контекста,при этом крайний срок устанавливается не позже d.Если крайний срок для родителя уже раньше d,то WithDeadline(parent,d)семантически эквивалентна родительскому контексту.Канал Done возвращаемого контекста закрывается по истечении срока,при вызове возвращаемой функции отмены или при закрытии канала Done родительского контекста,в зависимости от того,что произойдет раньше.</target>
        </trans-unit>
        <trans-unit id="7a280665a50cba23581e10e39947347ff060fae9" translate="yes" xml:space="preserve">
          <source>WithLabels returns a new context.Context with the given labels added. A label overwrites a prior label with the same key.</source>
          <target state="translated">WithLabels возвращает новый контекст с добавленными метками.Метка перезаписывает предыдущую метку тем же ключом.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
